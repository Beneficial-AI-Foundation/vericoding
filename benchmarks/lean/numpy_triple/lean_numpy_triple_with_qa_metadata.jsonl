{"id": "array_creation_arange", "vc-description": "/- \n{\n  \"name\": \"numpy.arange\",\n  \"category\": \"Numerical ranges\",\n  \"description\": \"Return evenly spaced values within a given interval\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arange.html\",\n  \"doc\": \"\\nReturn evenly spaced values within a given interval.\\n\\nParameters\\n----------\\nstart : integer or real, optional\\n    Start of interval. The interval includes this value. The default start value is 0.\\nstop : integer or real\\n    End of interval. The interval does not include this value, except in some cases where \\n    step is not an integer and floating point round-off affects the length of out.\\nstep : integer or real, optional\\n    Spacing between values. For any output out, this is the distance between two adjacent \\n    values, out[i+1] - out[i]. The default step size is 1.\\ndtype : dtype, optional\\n    The type of the output array. If dtype is not given, infer the data type from the \\n    other input arguments.\\ndevice : str, optional\\n    Device on which to place the created array.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\narange : ndarray\\n    Array of evenly spaced values.\\n\\nExamples\\n--------\\n>>> np.arange(3)\\narray([0, 1, 2])\\n>>> np.arange(3.0)\\narray([ 0.,  1.,  2.])\\n>>> np.arange(3,7)\\narray([3, 4, 5, 6])\\n>>> np.arange(3,7,2)\\narray([3, 5])\\n\\nNotes\\n-----\\nWhen using a non-integer step, such as 0.1, it is often better to use numpy.linspace.\\n\",\n  \"signature\": \"numpy.arange([start, ]stop, [step, ]dtype=None, *, device=None, like=None)\"\n}\n-/\n\n/-  Return evenly spaced values within a given interval [start, stop) with given step -/\n\n/-  Specification: arange generates evenly spaced values from start to stop (exclusive) with given step.\n    Each element at index i has value start + i * step, and all values are within bounds -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def arange {n : Nat} (start stop step : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem arange_spec {n : Nat} (start stop step : Float) \n    (h_step_nonzero : step \u2260 0) :\n    \u2983\u231cstep \u2260 0\u231d\u2984\n    arange start stop step\n    \u2983\u21d3result => \u231c(n = 0 \u2192 (step > 0 \u2227 start \u2265 stop) \u2228 (step < 0 \u2227 start \u2264 stop)) \u2227\n                (n > 0 \u2192 (\u2200 i : Fin n, result.get i = start + (i.val.toFloat) * step) \u2227\n                         (step > 0 \u2192 start < stop \u2227 \u2200 i : Fin n, result.get i < stop) \u2227\n                         (step < 0 \u2192 start > stop \u2227 \u2200 i : Fin n, result.get i > stop))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_array", "vc-description": "/-  Create an array from existing data. This is the primary array creation function.\n    Takes a list of Float elements and creates a Vector of the same length. -/\n\n/-  Specification: array creates a vector containing exactly the input data elements\n    in the same order. The result has the same length as the input list and preserves\n    all elements at their corresponding indices. This captures the fundamental property\n    of numpy.array - converting sequence-like data into array format while preserving\n    element values and order. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def array (data : List Float) : Id (Vector Float data.length) :=\n  sorry", "vc-theorems": "theorem array_spec (data : List Float) :\n    \u2983\u231cTrue\u231d\u2984\n    array data\n    \u2983\u21d3result => \u231c\u2200 i : Fin data.length, result.get i = data.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_asanyarray", "vc-description": "/-  numpy.asanyarray: Convert the input to an ndarray, but pass ndarray subclasses through.\n\n    Converts the input to an ndarray, but passes ndarray subclasses through unchanged.\n    If the input is already an ndarray or a subclass of ndarray, it is returned as-is\n    and no copy is performed. For other array-like inputs, it performs conversion.\n\n    In this Vector-based specification, we model this as an identity function that\n    preserves the input vector unchanged, representing the common case where the\n    input is already an ndarray.\n-/\n\n/-  Specification: numpy.asanyarray returns the input vector unchanged when it's already an ndarray.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The result is identical to the input vector - no copy is made,\n                   and each element remains unchanged.\n\n    This captures the key property of asanyarray: when given an ndarray (Vector in our case),\n    it returns the same array without copying.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def asanyarray {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem asanyarray_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    asanyarray a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = a.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_asarray", "vc-description": "/-  numpy.asarray: Convert the input to an array.\n\n    Converts various input types (lists, tuples, existing arrays, etc.) to an array.\n    The function creates a new array from the input data, preserving the element\n    order and values. For our Vector-based specification, we model this as\n    converting a list of elements to a Vector.\n\n    This is a fundamental array creation function that ensures the output is\n    always a proper array format regardless of the input type.\n-/\n\n/-  Specification: numpy.asarray returns a vector containing the same elements\n    as the input list, in the same order.\n\n    Precondition: The input list length matches the vector size parameter\n    Postcondition: \n    1. The result vector has the same length as the input list\n    2. Each element in the result vector equals the corresponding element in the input list\n    3. The ordering of elements is preserved\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def asarray {n : Nat} (a : List Float) (h : a.length = n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem asarray_spec {n : Nat} (a : List Float) (h : a.length = n) :\n    \u2983\u231ca.length = n\u231d\u2984\n    asarray a h\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = a[i.val]'(by rw [h]; exact i.isLt)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_ascontiguousarray", "vc-description": "/- \n{\n  \"name\": \"numpy.ascontiguousarray\",\n  \"category\": \"From existing data\",\n  \"description\": \"Return a contiguous array (ndim >= 1) in memory (C order)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ascontiguousarray.html\",\n  \"doc\": \"\\nReturn a contiguous array (ndim >= 1) in memory (C order).\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\ndtype : str or dtype object, optional\\n    Data-type of returned array.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\nout : ndarray\\n    Contiguous array of same shape and content as a, with type dtype if specified.\\n\\nExamples\\n--------\\n>>> x = np.arange(6).reshape(2,3)\\n>>> np.ascontiguousarray(x, dtype=np.float32)\\narray([[0., 1., 2.],\\n       [3., 4., 5.]], dtype=float32)\\n>>> x.flags['C_CONTIGUOUS']\\nTrue\\n\\nNote: This function returns at least a 1-dimensional array. Scalar inputs are converted to 1-dimensional arrays.\\n\",\n  \"signature\": \"numpy.ascontiguousarray(a, dtype=None, *, like=None)\"\n}\n-/\n\n/-  Return a contiguous array (ndim >= 1) in memory (C order).\n    This function ensures the input array is contiguous in C order and guarantees\n    minimum dimensionality of 1. For non-empty input, preserves all elements. -/\n\n/-  Specification: ascontiguousarray returns a contiguous array with same content,\n    ensuring minimum dimensionality of 1. For non-empty arrays, elements are preserved\n    exactly. For empty arrays, returns a 1-dimensional array with 1 element. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ascontiguousarray {n : Nat} (a : Vector Float n) : Id (Vector Float (max n 1)) :=\n  sorry", "vc-theorems": "theorem ascontiguousarray_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    ascontiguousarray a\n    \u2983\u21d3result => \u231c\n      (max n 1 \u2265 1) \u2227\n      (n > 0 \u2192 max n 1 = n) \u2227\n      (n = 0 \u2192 max n 1 = 1) \u2227\n      (n > 0 \u2192 \u2200 i : Fin n, \u2203 j : Fin (max n 1), result.get j = a.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_asmatrix", "vc-description": "/- \n{\n  \"name\": \"numpy.asmatrix\",\n  \"category\": \"From existing data\",\n  \"description\": \"Interpret the input as a matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.asmatrix.html\",\n  \"doc\": \"\\nInterpret the input as a matrix.\\n\\nParameters\\n----------\\ndata : array_like\\n    Input data.\\ndtype : data-type\\n    Data-type of the output matrix.\\n\\nReturns\\n-------\\nmat : matrix\\n    data interpreted as a matrix.\\n\\nExamples\\n--------\\n>>> x = np.array([[1, 2], [3, 4]])\\n\\n>>> m = np.asmatrix(x)\\n\\n>>> x[0,0] = 5\\n\\n>>> m\\nmatrix([[5, 2],\\n        [3, 4]])\\n\\nNotes\\n-----\\nUnlike matrix, asmatrix does not make a copy if the input is already a matrix or an ndarray. \\nEquivalent to matrix(data, copy=False).\\n\",\n  \"signature\": \"numpy.asmatrix(data, dtype=None)\"\n}\n-/\n\n/-  Interpret the input as a matrix. In our simplified model, this represents\n    a 1D vector as a matrix type. Since numpy.asmatrix doesn't make a copy\n    if the input is already a matrix or ndarray, this function acts as an\n    identity operation with matrix type semantics. -/\n\n/-  Specification: asmatrix interprets input data as a matrix without copying.\n\n    The function preserves the original data structure and values while\n    providing matrix semantics. For our Vector-based implementation, this\n    means the output vector has the same length and contains the same elements\n    as the input vector.\n\n    Key properties:\n    1. No copying occurs - the result has the same elements as input\n    2. The length is preserved  \n    3. Element order is preserved\n    4. All original values are maintained -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def asmatrix {n : Nat} (data : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem asmatrix_spec {n : Nat} (data : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    asmatrix data\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = data.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_bmat", "vc-description": "/- \n{\n  \"name\": \"numpy.bmat\",\n  \"category\": \"Building matrices\",\n  \"description\": \"Build a matrix object from a string, nested sequence, or array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bmat.html\",\n  \"doc\": \"\\nBuild a matrix object from a string, nested sequence, or array.\\n\\nParameters\\n----------\\nobj : str or array_like\\n    Input data. If a string, variables in the current scope may be referenced by name.\\nldict : dict, optional\\n    A dictionary that replaces local operands in current frame. Ignored if obj is not a string or gdict is None.\\ngdict : dict, optional\\n    A dictionary that replaces global operands in current frame. Ignored if obj is not a string.\\n\\nReturns\\n-------\\nout : matrix\\n    Returns a matrix object, which is a specialized 2-D array.\\n\\nExamples\\n--------\\n>>> A = np.asmatrix('1 1; 1 1')\\n>>> B = np.asmatrix('2 2; 2 2')\\n>>> C = np.asmatrix('3 4; 5 6')\\n>>> D = np.asmatrix('7 8; 9 0')\\n\\nBuild a block matrix from nested lists:\\n>>> np.bmat([[A, B], [C, D]])\\nmatrix([[1, 1, 2, 2],\\n        [1, 1, 2, 2],\\n        [3, 4, 7, 8],\\n        [5, 6, 9, 0]])\\n\\n>>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\\nmatrix([[1, 1, 2, 2],\\n        [1, 1, 2, 2],\\n        [3, 4, 7, 8],\\n        [5, 6, 9, 0]])\\n\\n>>> np.bmat('A,B; C,D')\\nmatrix([[1, 1, 2, 2],\\n        [1, 1, 2, 2],\\n        [3, 4, 7, 8],\\n        [5, 6, 9, 0]])\\n\\nSee Also\\n--------\\nnumpy.block : A generalization of this function for N-d arrays, that returns normal ndarrays.\\n\\nNotes\\n-----\\nAll the input arrays must have the same number of dimensions, but row and column sizes only need to be compatible. \\n\",\n  \"signature\": \"numpy.bmat(obj, ldict=None, gdict=None)\"\n}\n-/\n\n/-  Build a matrix from a 2x2 block structure using 4 input vectors.\n    This represents a simplified version of numpy.bmat for 2x2 block matrices.\n    The result is a flattened vector representing the block matrix in row-major order.\n\n    Mathematically, this constructs a 2x2 block matrix where each block is a 1\u00d7n vector:\n    [ topLeft    | topRight    ]\n    [ bottomLeft | bottomRight ]\n\n    The result is flattened as [topLeft | topRight | bottomLeft | bottomRight].\n-/\n\n/-  Specification: bmat constructs a 2x2 block matrix from four equal-sized vectors.\n    The result is a flattened vector where blocks are arranged as:\n    [topLeft | topRight | bottomLeft | bottomRight]\n    This captures the essential behavior of numpy.bmat for block matrix construction.\n\n    Precondition: True (no special preconditions for basic block matrix construction)\n    Postcondition: Each block is correctly placed in the flattened result\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def bmat {n : Nat} (topLeft topRight bottomLeft bottomRight : Vector Float n) : Id (Vector Float (4 * n)) :=\n  sorry", "vc-theorems": "theorem bmat_spec {n : Nat} (topLeft topRight bottomLeft bottomRight : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    bmat topLeft topRight bottomLeft bottomRight\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get \u27e8i.val, by omega\u27e9 = topLeft.get i) \u2227\n                 (\u2200 i : Fin n, result.get \u27e8i.val + n, by omega\u27e9 = topRight.get i) \u2227\n                 (\u2200 i : Fin n, result.get \u27e8i.val + 2*n, by omega\u27e9 = bottomLeft.get i) \u2227\n                 (\u2200 i : Fin n, result.get \u27e8i.val + 3*n, by omega\u27e9 = bottomRight.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_copy", "vc-description": "/- \n{\n  \"name\": \"numpy.copy\",\n  \"category\": \"From existing data\",\n  \"description\": \"Return an array copy of the given object\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.copy.html\",\n  \"doc\": \"\\nReturn an array copy of the given object.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\norder : {'C', 'F', 'A', 'K'}, optional\\n    Controls the memory layout of the copy. 'C' means C-order, 'F' means Fortran-order, \\n    'A' means 'F' if a is Fortran contiguous, 'C' otherwise. 'K' means match the layout \\n    of a as closely as possible.\\nsubok : bool, optional\\n    If True, then sub-classes will be passed-through, otherwise the returned array will \\n    be forced to be a base-class array (defaults to False).\\n\\nReturns\\n-------\\narr : ndarray\\n    Array interpretation of a.\\n\\nExamples\\n--------\\nCreate an array x, with a reference y and a copy z:\\n\\n>>> x = np.array([1, 2, 3])\\n>>> y = x\\n>>> z = np.copy(x)\\n\\nNote that, when we modify x, y changes, but not z:\\n\\n>>> x[0] = 10\\n>>> x[0] == y[0]\\nTrue\\n>>> x[0] == z[0]\\nFalse\\n\\nNote that np.copy clears previously set WRITEABLE=False flag.\\n\",\n  \"signature\": \"numpy.copy(a, order='K', subok=False)\"\n}\n-/\n\n/-  Return an array copy of the given object. \n    The copy has the same shape and values as the original array, \n    but occupies different memory locations. -/\n\n/-  Specification: copy returns a vector with identical values but independent memory.\n    The resulting vector has the same size and all elements equal to the original,\n    ensuring that the copy is element-wise equivalent to the original. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def copy {n : Nat} (a : Vector \u03b1 n) : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem copy_spec {n : Nat} (a : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    copy a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result[i] = a[i]\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_diag", "vc-description": "/- \n{\n  \"name\": \"numpy.diag\",\n  \"category\": \"Building matrices\",\n  \"description\": \"Extract a diagonal or construct a diagonal array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.diag.html\",\n  \"doc\": \"Extract a diagonal or construct a diagonal array.\\n\\nParameters\\n----------\\nv : array_like\\n    If v is a 2-D array, return a copy of its k-th diagonal. If v is a 1-D array, \\n    return a 2-D array with v on the k-th diagonal.\\nk : int, optional\\n    Diagonal in question. The default is 0. Use k>0 for diagonals above the main diagonal, \\n    and k<0 for diagonals below the main diagonal.\\n\\nReturns\\n-------\\nout : ndarray\\n    The extracted diagonal or constructed diagonal array.\\n\\nExamples\\n--------\\n>>> x = np.arange(9).reshape((3,3))\\n>>> x\\narray([[0, 1, 2],\\n       [3, 4, 5],\\n       [6, 7, 8]])\\n>>> np.diag(x)\\narray([0, 4, 8])\\n>>> np.diag(x, k=1)\\narray([1, 5])\\n>>> np.diag(x, k=-1)\\narray([3, 7])\\n\\n>>> np.diag(np.diag(x))\\narray([[0, 0, 0],\\n       [0, 4, 0],\\n       [0, 0, 8]])\\n\",\n  \"signature\": \"numpy.diag(v, k=0)\"\n}\n-/\n\n/-  Construct a diagonal matrix from a 1-D vector -/\n\n/-  Specification: diag constructs a square matrix with v on the main diagonal.\n\n    This captures the mathematical property that numpy.diag(v) creates a matrix M\n    where M[i,i] = v[i] for all i, and M[i,j] = 0 for all i \u2260 j.\n\n    The result is an n\u00d7n matrix where:\n    - The main diagonal contains the elements of the input vector v\n    - All off-diagonal elements are zero\n    - This represents the canonical way to construct a diagonal matrix\n\n    Mathematical properties verified:\n    1. Diagonal elements equality: M[i,i] = v[i]\n    2. Off-diagonal zeros: M[i,j] = 0 for i \u2260 j\n    3. Diagonal matrix property: non-zero elements only on diagonal\n    4. Trace property: tr(M) = sum(v)\n    5. Symmetry: M is a symmetric matrix\n    6. Idempotence property: diag(diag(M)) reconstructs M for diagonal matrices\n    7. Zero count: exactly n elements are non-zero (assuming v has no zeros)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def diag {n : Nat} (v : Vector Float n) : Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem diag_spec {n : Nat} (v : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    diag v\n    \u2983\u21d3result => \u231c\n      -- 1. Elements on the main diagonal are from v\n      (\u2200 i : Fin n, (result.get i).get i = v.get i) \u2227\n\n      -- 2. All off-diagonal elements are zero\n      (\u2200 i j : Fin n, i \u2260 j \u2192 (result.get i).get j = 0) \u2227\n\n      -- 3. Sanity check: diagonal matrix property - non-zero elements only on diagonal\n      (\u2200 i j : Fin n, (result.get i).get j \u2260 0 \u2192 i = j) \u2227\n\n      -- 4. Matrix trace equals sum of input vector elements\n      (List.sum (List.map (fun i => (result.get i).get i) (List.finRange n)) = \n       List.sum (List.map (fun i => v.get i) (List.finRange n))) \u2227\n\n      -- 5. The resulting matrix is symmetric\n      (\u2200 i j : Fin n, (result.get i).get j = (result.get j).get i) \u2227\n\n      -- 6. Row and column sums: for each row/column, sum equals the corresponding diagonal element\n      (\u2200 i : Fin n, \n        List.sum (List.map (fun j => (result.get i).get j) (List.finRange n)) = v.get i) \u2227\n      (\u2200 j : Fin n,\n        List.sum (List.map (fun i => (result.get i).get j) (List.finRange n)) = v.get j) \u2227\n\n      -- 7. Determinant property: det(diag(v)) = product of diagonal elements\n      -- (This is a fundamental property of diagonal matrices, though we don't compute it here)\n\n      -- 8. Each row has exactly one non-zero element at position i (unless v[i] = 0)\n      (\u2200 i : Fin n, v.get i \u2260 0 \u2192 \n        ((result.get i).get i \u2260 0 \u2227 \u2200 j : Fin n, j \u2260 i \u2192 (result.get i).get j = 0)) \u2227\n\n      -- 9. Each column has exactly one non-zero element at position j (unless v[j] = 0)\n      (\u2200 j : Fin n, v.get j \u2260 0 \u2192 \n        ((result.get j).get j \u2260 0 \u2227 \u2200 i : Fin n, i \u2260 j \u2192 (result.get i).get j = 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_diagflat", "vc-description": "/-  numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\n    Takes an input vector (representing flattened data) and creates a square matrix\n    where the input values appear along the k-th diagonal. The parameter k determines\n    which diagonal to use: k=0 for main diagonal, k>0 for super-diagonals,\n    and k<0 for sub-diagonals.\n\n    For simplicity, we focus on the main diagonal case (k=0) and return a 1D flattened\n    representation of the square matrix.\n-/\n\n/-  Specification: diagflat creates a square matrix with input values on the main diagonal.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The result is a flattened square matrix where:\n    1. The input vector v appears along the main diagonal\n    2. All other elements are zero\n    3. The matrix has dimensions n \u00d7 n (flattened to n\u00b2 elements)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def diagflat {n : Nat} (v : Vector Float n) : Id (Vector Float (n * n)) :=\n  sorry", "vc-theorems": "theorem diagflat_spec {n : Nat} (v : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    diagflat v\n    \u2983\u21d3result => \u231c\n      -- Elements on the main diagonal are from the input vector\n      (\u2200 i : Fin n, result.get \u27e8i.val * n + i.val, sorry\u27e9 = v.get i) \u2227\n      -- All other elements are zero\n      (\u2200 i j : Fin n, i \u2260 j \u2192 result.get \u27e8i.val * n + j.val, sorry\u27e9 = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_empty", "vc-description": "/- \n{\n  \"name\": \"numpy.empty\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return a new array of given shape and type, without initializing entries\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.empty.html\",\n  \"doc\": \"\\nReturn a new array of given shape and type, without initializing entries.\\n\\nParameters\\n----------\\nshape : int or tuple of int\\n    Shape of the empty array, e.g., (2, 3) or 2.\\ndtype : data-type, optional\\n    Desired output data-type for the array, e.g., numpy.int8. Default is numpy.float64.\\norder : {'C', 'F'}, optional, default: 'C'\\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\\ndevice : str, optional\\n    Device on which to place the created array. Default: None. For Array-API interoperability only, must be \\\"cpu\\\" if specified.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array of uninitialized (arbitrary) data of the given shape, dtype, and order.\\n\\nNotes\\n-----\\nUnlike other array creation functions (e.g. zeros, ones, full), empty does not initialize the values of the array, \\nand may therefore be marginally faster. However, the values stored in the newly allocated array are arbitrary.\\n\\nExamples\\n--------\\n>>> np.empty([2, 2])\\narray([[ -9.74499359e+001,   6.69583040e-309],\\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\\n\\n>>> np.empty([2, 2], dtype=int)\\narray([[-1073741821, -1067949133],\\n       [  496041986,    19249760]])                     #uninitialized\\n\",\n  \"signature\": \"numpy.empty(shape, dtype=float, order='C', *, device=None, like=None)\"\n}\n-/\n\n/-  numpy.empty: Return a new array of given shape and type, without initializing entries.\n\n    Creates a new vector of the specified length containing uninitialized (arbitrary) values.\n    This is a low-level function that allocates memory without setting initial values,\n    making it potentially faster than other array creation functions.\n\n    For 1D arrays, this takes a size parameter n and returns a Vector Float n\n    with arbitrary values.\n-/\n\n/-  Specification: numpy.empty returns a vector of the specified size with arbitrary values.\n\n    Properties:\n    1. The returned vector has exactly n elements (guaranteed by type)\n    2. Each element in the vector is a valid Float value\n    3. The vector is well-formed - all indices are accessible\n    4. No guarantees are made about the actual values - they are arbitrary/uninitialized\n\n    Mathematical properties:\n    - Size property: The length of the result is exactly n\n    - Accessibility property: All elements from index 0 to n-1 are accessible via get\n    - Value existence: Each position contains some Float value (but we don't specify which)\n\n    This specification captures the key behavior of numpy.empty: it returns a properly\n    sized array but makes no promises about the contents, which distinguishes it from\n    functions like zeros() or ones() that guarantee specific initial values.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def empty (n : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem empty_spec (n : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    empty n\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \u2203 v : Float, result.get i = v\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_empty_like", "vc-description": "/-  numpy.empty_like: Return a new array with the same shape and type as a given array.\n\n    Creates a new array with the same shape and type as the prototype array,\n    but with uninitialized (arbitrary) data. This is useful for creating\n    arrays that will be filled with values later, avoiding the overhead\n    of initialization.\n\n    The returned array has the same dimensions as the prototype but does not\n    copy the values - the contents are undefined and may contain any values.\n-/\n\n/-  Specification: numpy.empty_like returns a vector with the same size as the prototype\n    but with uninitialized values.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: \n    1. The result has the same size as the prototype array\n    2. The result vector is well-formed with proper indexing\n    3. The result is independent of the prototype's values (shape invariant)\n\n    Mathematical Properties:\n    - Size preservation: |result| = |prototype| = n\n    - Index validity: all valid indices for prototype are valid for result\n    - Type preservation: result has same element type as prototype\n\n    Note: We cannot specify the actual values since they are uninitialized,\n    but we can specify structural and size properties that must hold.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_empty_like {n : Nat} (prototype : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_empty_like_spec {n : Nat} (prototype : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_empty_like prototype\n    \u2983\u21d3result => \u231cresult.size = prototype.size \u2227 \n                 result.size = n \u2227\n                 (\u2200 i : Fin n, \u2203 v : Float, result.get i = v) \u2227\n                 (\u2200 i : Fin prototype.size, \u2203 j : Fin result.size, i.val = j.val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_eye", "vc-description": "/- \n{\n  \"name\": \"numpy.eye\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return a 2-D array with ones on the diagonal and zeros elsewhere\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.eye.html\",\n  \"doc\": \"\\nReturn a 2-D array with ones on the diagonal and zeros elsewhere.\\n\\nParameters\\n----------\\nN : int\\n    Number of rows in the output.\\nM : int, optional\\n    Number of columns in the output. If None, defaults to N.\\nk : int, optional\\n    Index of the diagonal: 0 (the default) refers to the main diagonal, \\n    a positive value refers to an upper diagonal, and a negative value to a lower diagonal.\\ndtype : data-type, optional\\n    Data-type of the returned array.\\norder : {'C', 'F'}, optional\\n    Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory.\\n\\nReturns\\n-------\\nI : ndarray of shape (N,M)\\n    An array where all elements are equal to zero, except for the k-th diagonal, whose values are equal to one.\\n\\nExamples\\n--------\\n>>> np.eye(2, dtype=int)\\narray([[1, 0],\\n       [0, 1]])\\n>>> np.eye(3, k=1)\\narray([[0.,  1.,  0.],\\n       [0.,  0.,  1.],\\n       [0.,  0.,  0.]])\\n\",\n  \"signature\": \"numpy.eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *, device=None, like=None)\"\n}\n-/\n\n/-  numpy.eye: Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\n    Returns the identity matrix of size n x n. For simplicity, we implement \n    the square matrix case (N=M) with diagonal offset k=0.\n\n    This function creates an n x n matrix where all elements are zero except\n    for the main diagonal, which contains ones.\n-/\n\n/-  Specification: eye returns a square identity matrix with mathematical properties.\n\n    Precondition: True (no special preconditions for identity matrix creation)\n\n    Postcondition: The returned matrix satisfies:\n    1. Main diagonal elements are 1.0\n    2. Off-diagonal elements are 0.0\n    3. The matrix is square (n x n)\n    4. Mathematical properties:\n       - Symmetry: eye[i][j] = eye[j][i]\n       - Uniqueness: There is exactly one 1.0 in each row and column\n       - Matrix multiplication identity: For any compatible matrix A, eye * A = A\n\n    This captures the complete mathematical characterization of an identity matrix.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def eye {n : Nat} : Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem eye_spec {n : Nat} :\n    \u2983\u231cTrue\u231d\u2984\n    eye\n    \u2983\u21d3result => \u231c\n      -- Basic structure: diagonal ones, off-diagonal zeros\n      (\u2200 i : Fin n, \u2200 j : Fin n, \n        (result.get i).get j = if i = j then 1.0 else 0.0) \u2227\n      -- Symmetry property (identity matrices are symmetric)\n      (\u2200 i : Fin n, \u2200 j : Fin n, \n        (result.get i).get j = (result.get j).get i) \u2227\n      -- Uniqueness property: exactly one 1.0 in each row\n      (\u2200 i : Fin n, \u2203 j : Fin n, (result.get i).get j = 1.0 \u2227 \n        \u2200 k : Fin n, (result.get i).get k = 1.0 \u2192 k = j) \u2227\n      -- Uniqueness property: exactly one 1.0 in each column\n      (\u2200 j : Fin n, \u2203 i : Fin n, (result.get i).get j = 1.0 \u2227 \n        \u2200 k : Fin n, (result.get k).get j = 1.0 \u2192 k = i) \u2227\n      -- All non-diagonal elements are exactly 0.0\n      (\u2200 i : Fin n, \u2200 j : Fin n, i \u2260 j \u2192 (result.get i).get j = 0.0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_from_dlpack", "vc-description": "/- \n{\n  \"name\": \"numpy.from_dlpack\",\n  \"category\": \"From existing data\",\n  \"description\": \"Create a NumPy array from an object implementing the __dlpack__ protocol\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.from_dlpack.html\",\n  \"doc\": \"\\nCreate a NumPy array from an object implementing the __dlpack__ protocol.\\n\\nParameters\\n----------\\nx : object\\n    A Python object that implements the __dlpack__ and __dlpack_device__ methods.\\ndevice : device, optional\\n    Device on which to place the created array. Must be \\\"cpu\\\" if specified.\\ncopy : bool, optional\\n    If True, the array is copied. If False, the array is not copied. \\n    If None (default), the array is only copied if necessary.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array created from the input object.\\n\\nNotes\\n-----\\nThis function allows for interoperability with other libraries that support the DLPack protocol.\\n\",\n  \"signature\": \"numpy.from_dlpack(x, /, *, device=None, copy=None)\"\n}\n-/\n\n/-  Create a NumPy array from an object implementing the DLPack protocol -/\n\n/-  Specification: from_dlpack creates a vector from a DLPack-compatible object -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Abstract type representing a DLPack-compatible object -/\nstructure DLPackObject (\u03b1 : Type) (n : Nat) where\n  /-- The underlying data vector -/\n  data : Vector \u03b1 n\n  /-- Whether the object has __dlpack__ method -/\n  has_dlpack : Bool\n  /-- Whether the object has __dlpack_device__ method -/\n  has_dlpack_device : Bool\n  /-- The device on which the object resides -/\n  device : String\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def from_dlpack {\u03b1 : Type} {n : Nat} (x : DLPackObject \u03b1 n) (device : Option String := none) \n    (copy : Option Bool := none) : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem from_dlpack_spec {\u03b1 : Type} {n : Nat} (x : DLPackObject \u03b1 n) \n    (device : Option String := none) (copy : Option Bool := none) :\n    \u2983\u231cx.has_dlpack \u2227 x.has_dlpack_device \u2227 \n      (device.isNone \u2228 device = some \"cpu\")\u231d\u2984\n    from_dlpack x device copy\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x.data.get i \u2227\n                 (copy = some true \u2192 result \u2260 x.data) \u2227\n                 (copy = some false \u2192 result = x.data)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_frombuffer", "vc-description": "/-  Interpret a buffer as a 1-dimensional array.\n    Takes a buffer (represented as a Vector of bytes), the count of elements to read,\n    and an offset (starting position in bytes) to create a Vector of the specified type.\n    This models numpy.frombuffer which interprets raw bytes as typed array elements. -/\n\n/-  Specification: frombuffer interprets raw bytes from a buffer as a typed array.\n    The function reads 'count' elements starting from 'offset' bytes into the buffer.\n    The result is a Vector containing the selected bytes in the same order\n    as they appear in the buffer. Key properties:\n    1. Buffer must have sufficient bytes for the requested elements\n    2. Offset must be within buffer bounds when count > 0\n    3. Elements are read sequentially from the buffer starting at offset\n    4. The result preserves the sequential order of elements in the buffer\n    5. Each output element corresponds to exactly one input buffer byte -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def frombuffer {n : Nat} (buffer : Vector UInt8 n) (count : Nat) (offset : Nat) : Id (Vector UInt8 count) :=\n  sorry", "vc-theorems": "theorem frombuffer_spec {n : Nat} (buffer : Vector UInt8 n) (count : Nat) (offset : Nat)\n    (h_bounds : offset + count \u2264 n) (h_offset : offset < n \u2228 count = 0) :\n    \u2983\u231coffset + count \u2264 n \u2227 (offset < n \u2228 count = 0)\u231d\u2984\n    frombuffer buffer count offset\n    \u2983\u21d3result => \u231c\u2200 i : Fin count, result.get i = buffer.get \u27e8offset + i.val, sorry\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_fromfile", "vc-description": "/- \n{\n  \"name\": \"numpy.fromfile\",\n  \"category\": \"From existing data\",\n  \"description\": \"Construct an array from data in a text or binary file\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html\",\n  \"doc\": \"\\nConstruct an array from data in a text or binary file.\\n\\nParameters\\n----------\\nfile : file or str or Path\\n    Open file object or filename.\\ndtype : data-type\\n    Data type of the returned array. For binary files, it is used to determine the size and byte-order \\n    of the items in the file. Most builtin numeric types are supported and extension types may be supported.\\ncount : int\\n    Number of items to read. -1 means all items (i.e., the complete file).\\nsep : str\\n    Separator between items if file is a text file. Empty (\\\"\\\") separator means the file should be \\n    treated as binary. Spaces (\\\" \\\") in the separator match zero or more whitespace characters.\\noffset : int\\n    The offset (in bytes) from the file's current position. Defaults to 0. Only permitted for binary files.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\narr : ndarray\\n    Array of data from the file.\\n\\nNotes\\n-----\\nDo not rely on the combination of tofile and fromfile for data storage, as the binary files generated \\nare not platform independent. In particular, no byte-order or data-type information is saved.\\n\",\n  \"signature\": \"numpy.fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)\"\n}\n-/\n\n/-  Construct a vector from data in a file -/\n\n/-  Specification: fromfile reads data from a file into a vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n-- Abstract file representation for specification purposes\nstructure FileData where\n  content : List Float\n  valid : Bool", "vc-helpers": "", "vc-definitions": "def fromfile (n : Nat) (file : FileData) (count : Int) (offset : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fromfile_spec (n : Nat) (file : FileData) (count : Int) (offset : Nat)\n    (h_valid : file.valid = true)\n    (h_count : count = n \u2228 count = -1)\n    (h_offset : offset \u2264 file.content.length)\n    (h_sufficient : file.content.length - offset \u2265 n) :\n    \u2983\u231cfile.valid = true \u2227\n      (count = n \u2228 count = -1) \u2227\n      offset \u2264 file.content.length \u2227\n      file.content.length - offset \u2265 n\u231d\u2984\n    fromfile n file count offset\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      result.get i = file.content.get! (offset + i.val) \u2227\n      n \u2264 file.content.length - offset\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_fromfunction", "vc-description": "/- \n{\n  \"name\": \"numpy.fromfunction\",\n  \"category\": \"From existing data\",\n  \"description\": \"Construct an array by executing a function over each coordinate\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromfunction.html\",\n  \"doc\": \"\\nConstruct an array by executing a function over each coordinate.\\n\\nParameters\\n----------\\nfunction : callable\\n    The function is called with N parameters, where N is the rank of shape. Each parameter represents \\n    the coordinates of the array varying along a specific axis.\\nshape : (N,) tuple of ints\\n    Shape of the output array, which also determines the shape of the coordinate arrays passed to function.\\ndtype : data-type, optional\\n    Data-type of the coordinate arrays passed to function. By default, dtype is float.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n**kwargs : keyword arguments, optional\\n    Any keyword arguments to pass to function.\\n\\nReturns\\n-------\\nfromfunction : ndarray\\n    The result of the call to function is passed back directly. Therefore the shape of fromfunction \\n    is completely determined by function.\\n\\nExamples\\n--------\\n>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\\narray([[ True, False, False],\\n       [False,  True, False],\\n       [False, False,  True]])\\n\\n>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\\narray([[0, 1, 2],\\n       [1, 2, 3],\\n       [2, 3, 4]])\\n\",\n  \"signature\": \"numpy.fromfunction(function, shape, *, dtype=<class 'float'>, like=None, **kwargs)\"\n}\n-/\n\n/-  Construct a vector by executing a function over each coordinate index.\n    For 1D case, this creates a vector of length n where element i is f(i). -/\n\n/-  Specification: fromfunction creates a vector where each element is the result\n    of applying the function to its index position. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fromfunction {n : Nat} (f : Fin n \u2192 Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fromfunction_spec {n : Nat} (f : Fin n \u2192 Float) :\n    \u2983\u231cTrue\u231d\u2984\n    fromfunction f\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = f i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_fromiter", "vc-description": "/- \n{\n  \"name\": \"numpy.fromiter\",\n  \"category\": \"From existing data\",\n  \"description\": \"Create a new 1-dimensional array from an iterable object\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromiter.html\",\n  \"doc\": \"\\nCreate a new 1-dimensional array from an iterable object.\\n\\nParameters\\n----------\\niter : iterable object\\n    An iterable object providing data for the array.\\ndtype : data-type\\n    The data-type of the returned array.\\ncount : int, optional\\n    The number of items to read from iterable. The default is -1, which means all data is read.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\nout : ndarray\\n    The output array.\\n\\nExamples\\n--------\\n>>> iterable = (x*x for x in range(5))\\n>>> np.fromiter(iterable, float)\\narray([  0.,   1.,   4.,   9.,  16.])\\n\\nTo read from a text file object:\\n\\n>>> from io import StringIO\\n>>> f = StringIO(\\\"1 2 3 4\\\")\\n>>> np.fromiter(f.read().split(), dtype=int)\\narray([1, 2, 3, 4])\\n\",\n  \"signature\": \"numpy.fromiter(iter, dtype, count=-1, *, like=None)\"\n}\n-/\n\n/-  Create a new 1-dimensional array from an iterable object.\n    Takes the first n elements from the iterable sequence and creates a Vector.\n    This models numpy.fromiter with explicit count parameter. -/\n\n/-  Specification: fromiter creates a Vector containing the first n elements \n    from the iterable in order. The resulting Vector has exactly n elements,\n    and each element at index i equals the i-th element from the iterable. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fromiter {\u03b1 : Type} (n : Nat) (iter : Fin n \u2192 \u03b1) : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem fromiter_spec {\u03b1 : Type} (n : Nat) (iter : Fin n \u2192 \u03b1) :\n    \u2983\u231cTrue\u231d\u2984\n    fromiter n iter\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = iter i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_fromstring", "vc-description": "/- \n{\n  \"name\": \"numpy.fromstring\",\n  \"category\": \"From existing data\",\n  \"description\": \"A new 1-D array initialized from text data in a string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromstring.html\",\n  \"doc\": \"\\nA new 1-D array initialized from text data in a string.\\n\\nParameters\\n----------\\nstring : str\\n    A string containing the data.\\ndtype : data-type, optional\\n    The data type of the array; default: float. For binary input data, the data must be in exactly \\n    this format. Most builtin numeric types are supported and extension types may be supported.\\ncount : int, optional\\n    Read this number of dtype elements from the data. If this is negative (the default), the count \\n    will be determined from the length of the data.\\nsep : str, optional\\n    The string separating numbers in the data; extra whitespace between elements is also ignored.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\narr : ndarray\\n    The constructed array.\\n\\nExamples\\n--------\\n>>> np.fromstring('1 2', dtype=int, sep=' ')\\narray([1, 2])\\n>>> np.fromstring('1, 2', dtype=int, sep=',')\\narray([1, 2])\\n\\nRaises\\n------\\nValueError\\n    If the string is not the correct size to satisfy the requested dtype and count.\\n\\nNotes\\n-----\\nDeprecated since version 1.14.0: If the sep argument is not provided or is None, the function \\nwill continue to work as it did before, but a FutureWarning will be emitted. Use frombuffer to \\nwork with binary data, or loadtxt to work with text data.\\n\",\n  \"signature\": \"numpy.fromstring(string, dtype=float, count=-1, *, sep, like=None)\"\n}\n-/\n\n/-  A new 1-D array initialized from text data in a string -/\n\n/-  Specification: fromstring parses a string into a vector of floats using a separator -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fromstring {n : Nat} (input : String) (sep : String) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fromstring_spec {n : Nat} (input : String) (sep : String)\n    (h_n_pos : n > 0)\n    (h_sep_nonempty : sep \u2260 \"\")\n    (h_tokens_count : (input.splitOn sep).length = n)\n    (h_tokens_nonempty : \u2200 token \u2208 (input.splitOn sep), token.trim \u2260 \"\")\n    (h_tokens_numeric : \u2200 token \u2208 (input.splitOn sep),\n      -- Each token represents a valid numeric string\n      \u2203 val : Float,\n        -- The token, when trimmed of whitespace, represents this float value\n        True) :  -- Abstract representation of string-to-float conversion\n    \u2983\u231cn > 0 \u2227 sep \u2260 \"\" \u2227\n      (input.splitOn sep).length = n \u2227\n      (\u2200 token \u2208 (input.splitOn sep), token.trim \u2260 \"\") \u2227\n      (\u2200 token \u2208 (input.splitOn sep), \u2203 val : Float, True)\u231d\u2984\n    fromstring input sep\n    \u2983\u21d3result => \u231c\n      -- The result vector contains parsed float values from the input string\n      (\u2200 i : Fin n,\n        \u2203 token : String, \u2203 val : Float,\n          token = (input.splitOn sep)[i.val]! \u2227\n          result.get i = val \u2227\n          -- val is the float representation of the trimmed token\n          True) \u2227\n      -- Mathematical properties of the result\n      -- 1. All values are finite (no infinity or NaN from parsing)\n      (\u2200 i : Fin n, Float.isFinite (result.get i)) \u2227\n      -- 2. The parsing preserves the order of tokens\n      (\u2200 i j : Fin n, i.val < j.val \u2192\n        -- The i-th element comes from the i-th token in the input\n        \u2203 token_i token_j : String,\n          token_i = (input.splitOn sep)[i.val]! \u2227\n          token_j = (input.splitOn sep)[j.val]! \u2227\n          -- And their relative position in the input is preserved\n          True) \u2227\n      -- 3. Example behavior matching NumPy docs\n      -- For input \"1 2\" with sep \" \", result should be [1.0, 2.0]\n      -- For input \"1, 2\" with sep \",\", result should be [1.0, 2.0]\n      (input = \"1 2\" \u2227 sep = \" \" \u2227 n = 2 \u2192\n        result.get \u27e80, sorry\u27e9 = 1.0 \u2227 result.get \u27e81, sorry\u27e9 = 2.0) \u2227\n      (input = \"1, 2\" \u2227 sep = \",\" \u2227 n = 2 \u2192\n        result.get \u27e80, sorry\u27e9 = 1.0 \u2227 result.get \u27e81, sorry\u27e9 = 2.0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_full", "vc-description": "/- \n{\n  \"name\": \"numpy.full\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return a new array of given shape and type, filled with fill_value\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.full.html\",\n  \"doc\": \"\\nReturn a new array of given shape and type, filled with fill_value.\\n\\nParameters\\n----------\\nshape : int or sequence of ints\\n    Shape of the new array, e.g., (2, 3) or 2.\\nfill_value : scalar or array_like\\n    Fill value.\\ndtype : data-type, optional\\n    The desired data-type for the array. The default, None, means infer from fill_value.\\norder : {'C', 'F'}, optional, default: 'C'\\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array of fill_value with the given shape, dtype, and order.\\n\\nExamples\\n--------\\n>>> np.full((2, 2), np.inf)\\narray([[inf, inf],\\n       [inf, inf]])\\n>>> np.full((2, 2), 10)\\narray([[10, 10],\\n       [10, 10]])\\n\\n>>> np.full((2, 2), [1, 2])\\narray([[1, 2],\\n       [1, 2]])\\n\",\n  \"signature\": \"numpy.full(shape, fill_value, dtype=None, order='C', *, device=None, like=None)\"\n}\n-/\n\n/-  numpy.full: Return a new array of given shape and type, filled with fill_value.\n\n    Creates a new vector of size n where every element is set to the specified\n    fill_value. This is the 1D version of numpy.full, focusing on the core\n    functionality of creating uniform arrays.\n\n    The function creates a vector filled with identical values, which is useful\n    for initialization and creating constant arrays.\n-/\n\n/-  Specification: numpy.full returns a vector where every element equals fill_value.\n\n    This specification captures the complete mathematical behavior of numpy.full:\n\n    1. **Sanity checks**:\n       - The result vector has exactly n elements (enforced by type)\n       - The function is deterministic (same inputs always produce same output)\n\n    2. **Core property**: Every element in the result equals fill_value\n       - \u2200 i : Fin n, result[i] = fill_value\n\n    3. **Mathematical properties**:\n       - Uniformity: All elements are identical\n       - Idempotence of fill value: Filling with the same value multiple times yields the same result\n       - Independence from index: The value at any position doesn't depend on the position\n\n    4. **Additional properties**:\n       - For n = 0, the result is an empty vector\n       - For n > 0, all elements are equal to each other\n       - The result is functionally equivalent to Vector.replicate n fill_value\n\n    5. **Relationship properties**:\n       - full \u03b1 n v is equivalent to creating an array and setting each element to v\n       - If two vectors are created with full using the same fill_value and size,\n         they are element-wise equal\n       - full preserves the fill_value exactly (no transformation or casting)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def full (\u03b1 : Type) [Inhabited \u03b1] (n : Nat) (fill_value : \u03b1) : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem full_spec (\u03b1 : Type) [Inhabited \u03b1] [DecidableEq \u03b1] (n : Nat) (fill_value : \u03b1) :\n    \u2983\u231cTrue\u231d\u2984\n    full \u03b1 n fill_value\n    \u2983\u21d3result => \u231c-- Core property: every element equals fill_value\n                 (\u2200 i : Fin n, result.get i = fill_value) \u2227\n                 -- Uniformity property: all elements are equal to each other\n                 (\u2200 i j : Fin n, result.get i = result.get j) \u2227\n                 -- Relationship to Vector.replicate (conceptual equivalence)\n                 (\u2200 i : Fin n, result.get i = (Vector.replicate n fill_value).get i) \u2227\n                 -- First and last element property (when n > 0)\n                 (n > 0 \u2192 result.get \u27e80, sorry\u27e9 = fill_value) \u2227\n                 (n > 0 \u2192 \u2200 h : n - 1 < n, result.get \u27e8n - 1, h\u27e9 = fill_value)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_full_like", "vc-description": "/-  numpy.full_like: Return a full array with the same shape and type as a given array.\n\n    Creates a new array with the same shape as the input array `a`, where all\n    elements are set to the specified `fill_value`. This is useful for creating\n    arrays of a specific constant value while preserving the shape of an existing\n    array.\n\n    The actual type of fill_value will be cast to match the array's type,\n    similar to numpy's behavior where 0.1 becomes 0 for integer arrays.\n-/\n\n/-  Specification: numpy.full_like returns a vector with the same shape as `a`\n    where every element equals `fill_value`.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: The result has the same length as `a` and all elements equal `fill_value`\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_full_like {n : Nat} (a : Vector Float n) (fill_value : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_full_like_spec {n : Nat} (a : Vector Float n) (fill_value : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_full_like a fill_value\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = fill_value\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_geomspace", "vc-description": "/- \n{\n  \"name\": \"numpy.geomspace\",\n  \"category\": \"Numerical ranges\",\n  \"description\": \"Return numbers spaced evenly on a log scale (a geometric progression)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.geomspace.html\",\n  \"doc\": \"\\nReturn numbers spaced evenly on a log scale (a geometric progression).\\n\\nParameters\\n----------\\nstart : array_like\\n    The starting value of the sequence.\\nstop : array_like\\n    The final value of the sequence, unless endpoint is False. In that case, num + 1 values \\n    are spaced over the interval in log-space, of which all but the last (a sequence of length num) are returned.\\nnum : integer, optional\\n    Number of samples to generate. Default is 50.\\nendpoint : boolean, optional\\n    If True, stop is the last sample. Otherwise, it is not included. Default is True.\\ndtype : dtype\\n    The type of the output array. If dtype is not given, the data type is inferred from start and stop.\\naxis : int, optional\\n    The axis in the result to store the samples. Relevant only if start or stop are array-like.\\n\\nReturns\\n-------\\nsamples : ndarray\\n    num samples, equally spaced on a log scale.\\n\\nExamples\\n--------\\n>>> np.geomspace(1, 1000, num=4)\\narray([    1.,    10.,   100.,  1000.])\\n>>> np.geomspace(1, 1000, num=3, endpoint=False)\\narray([   1.,   10.,  100.])\\n>>> np.geomspace(1, 1000, num=4, endpoint=False)\\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\\n>>> np.geomspace(1, 256, num=9)\\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\\n\\nNotes\\n-----\\nIf the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane.\\n\",\n  \"signature\": \"numpy.geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0)\"\n}\n-/\n\n/-  Return numbers spaced evenly on a log scale (a geometric progression).\n    Each output sample is a constant multiple of the previous one. -/\n\n/-  Specification: geomspace returns a geometric progression from start to stop.\n    - The first element is always start\n    - If endpoint is true and n > 1, the last element is stop\n    - All elements form a geometric progression (constant ratio between consecutive elements)\n    - Neither start nor stop can be zero -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def geomspace {n : Nat} (start stop : Float) (endpoint : Bool := true) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem geomspace_spec {n : Nat} (start stop : Float) (endpoint : Bool)\n    (h_start_nonzero : start \u2260 0) (h_stop_nonzero : stop \u2260 0) (h_n_pos : n > 0) :\n    \u2983\u231cstart \u2260 0 \u2227 stop \u2260 0 \u2227 n > 0\u231d\u2984\n    geomspace start stop endpoint\n    \u2983\u21d3result => \u231c\n      -- First element is start\n      result.get \u27e80, h_n_pos\u27e9 = start \u2227\n      -- Last element is stop when endpoint is true and n > 1\n      (endpoint \u2227 n > 1 \u2192 result.get \u27e8n - 1, Nat.sub_lt h_n_pos (Nat.zero_lt_one)\u27e9 = stop) \u2227\n      -- Geometric progression property: constant ratio between consecutive elements\n      (n \u2265 2 \u2192 \u2203 ratio : Float, ratio \u2260 0 \u2227\n        \u2200 i : Fin (n - 1),\n          result.get \u27e8i.val + 1, Nat.add_lt_of_lt_sub i.isLt\u27e9 = ratio * result.get \u27e8i.val, Nat.lt_trans i.isLt (Nat.sub_lt h_n_pos Nat.zero_lt_one)\u27e9) \u2227\n      -- When endpoint is false, we have n values from a larger geometric sequence\n      (\u00acendpoint \u2227 n \u2265 2 \u2192 \u2203 ratio : Float, ratio \u2260 0 \u2227\n        ratio = (stop / start) ^ (1.0 / n.toFloat) \u2227\n        \u2200 i : Fin n,\n          result.get i = start * (ratio ^ i.val.toFloat))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_identity", "vc-description": "/- \n{\n  \"name\": \"numpy.identity\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return the identity array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.identity.html\",\n  \"doc\": \"\\nReturn the identity array.\\n\\nThe identity array is a square array with ones on the main diagonal.\\n\\nParameters\\n----------\\nn : int\\n    Number of rows (and columns) in n x n output.\\ndtype : data-type, optional\\n    Data-type of the output. Defaults to float.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\nout : ndarray\\n    n x n array with its main diagonal set to one, and all other elements 0.\\n\\nExamples\\n--------\\n>>> np.identity(3)\\narray([[1.,  0.,  0.],\\n       [0.,  1.,  0.],\\n       [0.,  0.,  1.]])\\n\",\n  \"signature\": \"numpy.identity(n, dtype=None, *, like=None)\"\n}\n-/\n\n/-  Return the identity matrix of size n\u00d7n.\n    The identity matrix is a square matrix with ones on the main diagonal\n    and zeros elsewhere. -/\n\n/-  Specification: identity returns an n\u00d7n matrix where:\n    - diagonal elements (i,i) are 1.0\n    - off-diagonal elements (i,j) where i\u2260j are 0.0 -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def identity (n : Nat) : Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem identity_spec (n : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    identity n\n    \u2983\u21d3result => \u231c\u2200 i j : Fin n, \n                   (result.get i).get j = if i = j then (1.0 : Float) else (0.0 : Float)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_linspace", "vc-description": "/-  numpy.linspace: Return evenly spaced numbers over a specified interval.\n\n    Returns num evenly spaced samples, calculated over the interval [start, stop]\n    when endpoint is true (default), or [start, stop) when endpoint is false.\n\n    This specification focuses on the most common use case where endpoint=true,\n    returning num samples that are evenly distributed from start to stop inclusive.\n-/\n\n/-  Specification: numpy.linspace returns a vector of evenly spaced values.\n\n    When num > 0 and endpoint=true (default behavior):\n    - The first element equals start\n    - The last element equals stop (when num > 1)\n    - Elements are evenly spaced with step = (stop - start) / (num - 1) when num > 1\n    - When num = 1, the single element equals start\n\n    Mathematical properties:\n    - For any valid index i, the element value is: start + i * step\n    - The spacing between consecutive elements is constant (except when num = 1)\n    - The sequence is monotonic (increasing if start < stop, decreasing if start > stop)\n    - All elements lie within [min(start, stop), max(start, stop)]\n    - Linear interpolation property: each element represents a linear interpolation between start and stop\n\n    Sanity checks:\n    - Size of result vector equals num\n    - When start = stop, all elements equal start\n    - The function is symmetric: reversing start and stop reverses the sequence\n    - Consecutive differences are constant for num > 2\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def linspace {num : Nat} (start stop : Float) (h : num > 0) : Id (Vector Float num) :=\n  sorry", "vc-theorems": "theorem linspace_spec {num : Nat} (start stop : Float) (h : num > 0) :\n    \u2983\u231cnum > 0\u231d\u2984\n    linspace start stop h\n    \u2983\u21d3result => \u231c\n      -- First element is always start\n      result.get \u27e80, h\u27e9 = start \u2227\n\n      -- Special case: when num = 1, the single element is start\n      (num = 1 \u2192 \u2200 i : Fin num, result.get i = start) \u2227\n\n      -- General case: when num > 1\n      (num > 1 \u2192 \n        let step := (stop - start) / (num - 1).toFloat\n        -- Last element is stop\n        (result.get \u27e8num - 1, Nat.sub_lt h Nat.zero_lt_one\u27e9 = stop) \u2227\n        -- All elements follow the linear formula\n        (\u2200 i : Fin num, result.get i = start + i.val.toFloat * step) \u2227\n        -- Consecutive elements have constant spacing\n        (\u2200 i j : Fin num, i.val + 1 = j.val \u2192 \n          result.get j - result.get i = step)) \u2227\n\n      -- Monotonicity property\n      ((start < stop) \u2192 \u2200 i j : Fin num, i < j \u2192 result.get i < result.get j) \u2227\n      ((start > stop) \u2192 \u2200 i j : Fin num, i < j \u2192 result.get i > result.get j) \u2227\n      ((start = stop) \u2192 \u2200 i : Fin num, result.get i = start) \u2227\n\n      -- Bounds property: all elements lie within the interval\n      (\u2200 i : Fin num, \n        result.get i \u2265 min start stop \u2227 \n        result.get i \u2264 max start stop) \u2227\n\n      -- Linear interpolation property: each element can be expressed as a weighted average\n      (num > 1 \u2192 \u2200 i : Fin num,\n        let t := i.val.toFloat / (num - 1).toFloat\n        result.get i = (1 - t) * start + t * stop) \u2227\n\n      -- Reverse symmetry: if we compute linspace(stop, start, num), \n      -- element i equals element (num-1-i) of linspace(start, stop, num)\n      (num > 1 \u2192 \u2200 i : Fin num,\n        i.val < num - 1 \u2192 \n        let j_val := num - 1 - i.val\n        j_val < num \u2192 \n        result.get i = stop - (i.val.toFloat * (stop - start) / (num - 1).toFloat))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_loadtxt", "vc-description": "/- \n{\n  \"name\": \"numpy.loadtxt\",\n  \"category\": \"From existing data\",\n  \"description\": \"Load data from a text file\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html\",\n  \"doc\": \"\\nLoad data from a text file.\\n\\nParameters\\n----------\\nfname : file, str, pathlib.Path, list of str, generator\\n    File, filename, list, or generator to read. If the filename extension is .gz or .bz2, \\n    the file is first decompressed.\\ndtype : data-type, optional\\n    Data-type of the resulting array; default: float.\\ncomments : str or sequence of str or None, optional\\n    The characters or list of characters used to indicate the start of a comment. \\n    None implies no comments.\\ndelimiter : str, optional\\n    The character used to separate the values. For backwards compatibility, byte strings \\n    will be decoded as 'latin1'. The default is whitespace.\\nconverters : dict or callable, optional\\n    Converter functions to customize value parsing.\\nskiprows : int, optional\\n    Skip the first skiprows lines, including comments; default: 0.\\nusecols : int or sequence, optional\\n    Which columns to read, with 0 being the first.\\nunpack : bool, optional\\n    If True, the returned array is transposed, so that arguments may be unpacked using \\n    x, y, z = loadtxt(...). Default is False.\\nndmin : int, optional\\n    The returned array will have at least ndmin dimensions. Otherwise mono-dimensional \\n    axes will be squeezed.\\nencoding : str, optional\\n    Encoding used to decode the inputfile. The default is None.\\nmax_rows : int, optional\\n    Read max_rows rows of content after skiprows lines. The default is to read all the rows.\\nquotechar : str, optional\\n    Character used to denote the start and end of a quoted item.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\nout : ndarray\\n    Data read from the text file.\\n\\nExamples\\n--------\\n>>> from io import StringIO\\n>>> c = StringIO(\\\"0 1\\\\n2 3\\\")\\n>>> np.loadtxt(c)\\narray([[0., 1.],\\n       [2., 3.]])\\n\\n>>> d = StringIO(\\\"M 21 72\\\\nF 35 58\\\")\\n>>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\\n...                      'formats': ('S1', 'i4', 'f4')})\\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\\n      dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\\n\",\n  \"signature\": \"numpy.loadtxt(fname, dtype=<class 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=None, max_rows=None, *, quotechar=None, like=None)\"\n}\n-/\n\n/-  Load data from a text file containing numeric values.\n    This simplified version assumes:\n    - The file contains floating-point numbers (one per line or whitespace-separated)\n    - Comments starting with '#' are ignored\n    - The skiprows parameter allows skipping initial lines\n    Returns a vector of parsed float values. -/\n\n/-  Specification: loadtxt reads numeric data from a text file and returns a vector of floats.\n    The preconditions ensure:\n    - The file path is valid (non-empty string)\n    - After skipping skiprows lines and removing comments, there are exactly n valid float values\n\n    The postcondition guarantees:\n    - The result vector contains the float values parsed from the file\n    - Values appear in the same order as in the file (after skipping and comment removal)\n    - The size of the result matches the type-level size n\n\n    Mathematical properties:\n    - Deterministic: same file and parameters always produce the same result\n    - Order-preserving: maintains the sequential order of values in the file\n    - Comment-aware: lines starting with '#' are ignored\n    - Skip-aware: first skiprows lines are ignored -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def loadtxt {n : Nat} (fname : String) (skiprows : Nat := 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem loadtxt_spec {n : Nat} (fname : String) (skiprows : Nat) \n    (h_fname_valid : fname.length > 0) :\n    \u2983\u231cfname.length > 0 \u2227 skiprows \u2265 0\u231d\u2984\n    loadtxt fname skiprows\n    \u2983\u21d3result => \u231cresult.size = n \u2227 \n                 (\u2200 i : Fin n, \u2203 v : Float, result.get i = v \u2227 \n                  -- The value is a properly parsed float from the file\n                  True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_logspace", "vc-description": "/-  Return numbers spaced evenly on a log scale.\n\n    Creates a vector of `num` samples where each element is computed as:\n    - When endpoint=true: base^(start + i * (stop - start) / (num - 1)) for i in 0..num-1\n    - When endpoint=false: base^(start + i * (stop - start) / num) for i in 0..num-1\n\n    The samples are evenly spaced in log space, meaning the exponents form an arithmetic sequence.\n-/\n\n/-  Specification: logspace generates numbers evenly spaced on a logarithmic scale.\n\n    The function produces a vector where:\n    1. For endpoint=true: Elements follow base^(interpolated exponent) where exponents \n       are linearly interpolated from start to stop inclusive\n    2. For endpoint=false: Similar but stop value is excluded from the range\n    3. The base must be positive and not equal to 1 for meaningful results\n    4. For num > 1, the spacing between consecutive log values is uniform\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def logspace {num : Nat} (start stop : Float) (endpoint : Bool) (base : Float) : Id (Vector Float num) :=\n  sorry", "vc-theorems": "theorem logspace_spec {num : Nat} (start stop : Float) (endpoint : Bool) (base : Float) \n    (h_base_pos : base > 0) (h_base_ne_one : base \u2260 1) (h_num_pos : num > 0) :\n    \u2983\u231cbase > 0 \u2227 base \u2260 1 \u2227 num > 0\u231d\u2984\n    logspace start stop endpoint base\n    \u2983\u21d3result => \u231c\n      -- Define the step size based on endpoint parameter\n      let step := if endpoint \u2227 num > 1 then (stop - start) / (num - 1).toFloat \n                  else (stop - start) / num.toFloat\n      -- Each element follows the logarithmic spacing formula\n      (\u2200 i : Fin num, result.get i = base ^ (start + i.val.toFloat * step)) \u2227\n      -- First element is always base^start\n      (result.get \u27e80, h_num_pos\u27e9 = base ^ start) \u2227\n      -- Last element is base^stop when endpoint is true and num > 1\n      (endpoint \u2227 num > 1 \u2192 result.get \u27e8num - 1, by omega\u27e9 = base ^ stop) \u2227\n      -- All elements are positive when base is positive\n      (\u2200 i : Fin num, result.get i > 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_meshgrid", "vc-description": "/- \n{\n  \"name\": \"numpy.meshgrid\",\n  \"category\": \"Numerical ranges\",\n  \"description\": \"Return a list of coordinate matrices from coordinate vectors\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html\",\n  \"doc\": \"\\nReturn a list of coordinate matrices from coordinate vectors.\\n\\nParameters\\n----------\\nx1, x2,..., xn : array_like\\n    1-D arrays representing the coordinates of a grid.\\nindexing : {'xy', 'ij'}, optional\\n    Cartesian ('xy', default) or matrix ('ij') indexing of output.\\nsparse : bool, optional\\n    If True the shape of the returned coordinate array for dimension i is reduced from \\n    (N1, ..., Ni, ... Nn) to (1, ..., Ni, ..., 1). Default is False.\\ncopy : bool, optional\\n    If False, a view into the original arrays are returned in order to conserve memory. \\n    Default is True.\\n\\nReturns\\n-------\\nX1, X2,..., XN : list of ndarray\\n    For vectors x1, x2,..., xn with lengths Ni=len(xi), returns (N1, N2, N3,..., Nn) shaped arrays \\n    if indexing='ij' or (N2, N1, N3,..., Nn) shaped arrays if indexing='xy' with the elements of xi \\n    repeated to fill the matrix along the first dimension for x1, the second for x2 and so on.\\n\\nExamples\\n--------\\n>>> nx, ny = (3, 2)\\n>>> x = np.linspace(0, 1, nx)\\n>>> y = np.linspace(0, 1, ny)\\n>>> xv, yv = np.meshgrid(x, y)\\n>>> xv\\narray([[0. , 0.5, 1. ],\\n       [0. , 0.5, 1. ]])\\n>>> yv\\narray([[0.,  0.,  0.],\\n       [1.,  1.,  1.]])\\n\\nNotes\\n-----\\nIn the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for 'xy' \\nindexing and (M, N) for 'ij' indexing.\\n\",\n  \"signature\": \"numpy.meshgrid(*xi, copy=True, sparse=False, indexing='xy')\"\n}\n-/\n\n/-  Return coordinate matrices from two coordinate vectors using 'xy' (Cartesian) indexing.\n    For inputs of length m and n, returns two matrices of shape (n, m) where:\n    - The first matrix has x values repeated along rows\n    - The second matrix has y values repeated along columns -/\n\n/-  Specification: meshgrid creates coordinate matrices where x values are repeated \n    along rows and y values are repeated along columns in 'xy' indexing mode -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def meshgrid {m n : Nat} (x : Vector Float m) (y : Vector Float n) : \n    Id (Vector (Vector Float m) n \u00d7 Vector (Vector Float m) n) :=\n  sorry", "vc-theorems": "theorem meshgrid_spec {m n : Nat} (x : Vector Float m) (y : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    meshgrid x y\n    \u2983\u21d3result => \n      let (xv, yv) := result\n      \u231c-- First matrix: x values repeated along each row\n       (\u2200 i : Fin n, \u2200 j : Fin m, (xv.get i).get j = x.get j) \u2227\n       -- Second matrix: y values repeated along each column  \n       (\u2200 i : Fin n, \u2200 j : Fin m, (yv.get i).get j = y.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_mgrid", "vc-description": "/- \n{\n  \"name\": \"numpy.mgrid\",\n  \"category\": \"Numerical ranges\",\n  \"description\": \"An instance which returns a dense multi-dimensional meshgrid\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.mgrid.html\",\n  \"doc\": \"\\nAn instance which returns a dense multi-dimensional \\\"meshgrid\\\".\\n\\nAn instance of numpy.lib.ndmgr.MGridClass which, when indexed, returns a dense multi-dimensional meshgrid.\\n\\nParameters\\n----------\\n[slice1, slice2, ..., sliceN] : slice objects or integers\\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \\n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\\n\\nReturns\\n-------\\nout : one ndarray or tuple of ndarrays\\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \\n    of arrays with one array for each dimension.\\n\\nExamples\\n--------\\n>>> np.mgrid[0:5, 0:5]\\narray([[[0, 0, 0, 0, 0],\\n        [1, 1, 1, 1, 1],\\n        [2, 2, 2, 2, 2],\\n        [3, 3, 3, 3, 3],\\n        [4, 4, 4, 4, 4]],\\n       [[0, 1, 2, 3, 4],\\n        [0, 1, 2, 3, 4],\\n        [0, 1, 2, 3, 4],\\n        [0, 1, 2, 3, 4],\\n        [0, 1, 2, 3, 4]]])\\n\\n>>> np.mgrid[-1:1:5j]\\narray([-1. , -0.5,  0. ,  0.5,  1. ])\\n\",\n  \"signature\": \"numpy.mgrid = <numpy.lib.ndmgr.MGridClass object>\"\n}\n-/\n\n/-  Creates a 1D meshgrid from start to stop with step size.\n    This is a simplified version of mgrid that handles only the single-slice case. -/\n\n/-  Specification: mgrid creates a vector of evenly spaced values from start to stop (exclusive) with given step -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mgrid {n : Nat} (start stop step : Float) (h_valid : n = ((stop - start) / step).toUInt64.toNat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem mgrid_spec {n : Nat} (start stop step : Float) (h_valid : n = ((stop - start) / step).toUInt64.toNat) \n    (h_step_pos : step > 0) (h_range : start < stop) :\n    \u2983\u231cstep > 0 \u2227 start < stop \u2227 n = ((stop - start) / step).toUInt64.toNat\u231d\u2984\n    mgrid start stop step h_valid\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = start + Float.ofNat i.val * step \u2227\n                 result.get i < stop\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_ogrid", "vc-description": "/- \n{\n  \"name\": \"numpy.ogrid\",\n  \"category\": \"Numerical ranges\",\n  \"description\": \"An instance which returns an open multi-dimensional meshgrid\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ogrid.html\",\n  \"doc\": \"\\nAn instance which returns an open multi-dimensional \\\"meshgrid\\\".\\n\\nAn instance of numpy.lib.ndmgr.OGridClass which, when indexed, returns an open multi-dimensional meshgrid.\\n\\nParameters\\n----------\\n[slice1, slice2, ..., sliceN] : slice objects or integers\\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \\n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\\n\\nReturns\\n-------\\nout : one ndarray or tuple of ndarrays\\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \\n    of arrays with only one non-unit dimension each.\\n\\nExamples\\n--------\\n>>> from numpy import ogrid\\n>>> ogrid[-1:1:5j]\\narray([-1. , -0.5,  0. ,  0.5,  1. ])\\n\\n>>> ogrid[0:5, 0:5]\\n[array([[0],\\n        [1],\\n        [2],\\n        [3],\\n        [4]]), \\n array([[0, 1, 2, 3, 4]])]\\n\\nNotes\\n-----\\nThe multi-dimensional \\\"mesh\\\" is open, which means that only one dimension of each returned \\nargument is greater than 1. The output of ogrid is an open mesh of arrays that can be used \\nfor broadcasting.\\n\",\n  \"signature\": \"numpy.ogrid = <numpy.lib.ndmgr.OGridClass object>\"\n}\n-/\n\n/-  Create a 1D open grid from start to stop with n evenly spaced points.\n    This is a simplified version of ogrid that handles the common case of\n    creating a single evenly-spaced vector (like ogrid[start:stop:nj]) -/\n\n/-  Specification: ogrid creates n evenly spaced points from start to stop (inclusive).\n    When n > 1, the spacing between consecutive points is (stop - start) / (n - 1).\n    For n = 1, the single point is at start. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ogrid {n : Nat} (start stop : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ogrid_spec {n : Nat} (start stop : Float) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    ogrid start stop\n    \u2983\u21d3result => \u231c-- For a single element, it equals start\n                (n = 1 \u2192 result.get \u27e80, h\u27e9 = start) \u2227\n                -- For multiple elements, they are evenly spaced from start to stop\n                (\u2200 i : Fin n, \n                  n > 1 \u2192 result.get i = start + i.val.toFloat * ((stop - start) / (n - 1).toFloat)) \u2227\n                -- Boundary conditions\n                (n > 1 \u2192 result.get \u27e80, h\u27e9 = start \u2227 \n                         result.get \u27e8n - 1, Nat.sub_lt h (Nat.zero_lt_one)\u27e9 = stop)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_ones", "vc-description": "/- \n{\n  \"name\": \"numpy.ones\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return a new array of given shape and type, filled with ones\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ones.html\",\n  \"doc\": \"\\nReturn a new array of given shape and type, filled with ones.\\n\\nParameters\\n----------\\nshape : int or sequence of ints\\n    Shape of the new array, e.g., (2, 3) or 2.\\ndtype : data-type, optional\\n    The desired data-type for the array, e.g., numpy.int8. Default is numpy.float64.\\norder : {'C', 'F'}, optional, default: 'C'\\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array of ones with the given shape, dtype, and order.\\n\\nExamples\\n--------\\n>>> np.ones(5)\\narray([1., 1., 1., 1., 1.])\\n\\n>>> np.ones((5,), dtype=int)\\narray([1, 1, 1, 1, 1])\\n\\n>>> np.ones((2, 1))\\narray([[1.],\\n       [1.]])\\n\\n>>> s = (2,2)\\n>>> np.ones(s)\\narray([[1.,  1.],\\n       [1.,  1.]])\\n\",\n  \"signature\": \"numpy.ones(shape, dtype=None, order='C', *, device=None, like=None)\"\n}\n-/\n\n/-  Return a new vector of given size filled with ones.\n\n    This function creates a vector where every element is exactly 1.0,\n    matching NumPy's ones function behavior for 1D arrays.\n-/\n\n/-  Specification: ones returns a vector where all elements are exactly 1.0.\n\n    This specification captures the following properties:\n    1. **Correctness**: Every element in the returned vector equals 1.0\n    2. **Uniformity**: All elements are identical (constant vector)\n    3. **Non-negativity**: All elements are positive (1.0 > 0)\n    4. **Identity property**: Multiplying any value by an element gives the same value\n    5. **Type Safety**: The returned vector has exactly n elements (enforced by type)\n\n    Mathematical Properties verified:\n    - \u2200 i : Fin n, result[i] = 1.0 (all elements are exactly one)\n    - \u2200 i j : Fin n, result[i] = result[j] (uniformity/constant vector)\n    - \u2200 i : Fin n, result[i] > 0 (positivity)\n    - \u2200 i : Fin n, \u2200 x : Float, x * result[i] = x (multiplicative identity)\n\n    Edge cases handled:\n    - When n = 0, returns an empty vector (trivially satisfies all properties)\n    - When n > 0, all indices contain exactly 1.0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ones (n : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ones_spec (n : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    ones n\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = 1.0) \u2227 \n                 (\u2200 i j : Fin n, result.get i = result.get j) \u2227\n                 (\u2200 i : Fin n, result.get i > 0) \u2227\n                 (\u2200 i : Fin n, \u2200 x : Float, x * result.get i = x)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_ones_like", "vc-description": "/-  Return a vector of ones with the same length as the input vector.\n    This is the 1D version of numpy.ones_like which creates a new vector\n    filled with ones, having the same size as the input vector. -/\n\n/-  Specification: ones_like returns a vector where every element is 1,\n    with the same length as the input vector.\n\n    Mathematical properties:\n    1. The result has the same length as the input (enforced by type system)\n    2. Every element in the result is exactly 1\n    3. The result is independent of the input values (only depends on shape) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ones_like {n : Nat} {T : Type} [OfNat T 1] (a : Vector T n) : Id (Vector T n) :=\n  sorry", "vc-theorems": "theorem ones_like_spec {n : Nat} {T : Type} [OfNat T 1] (a : Vector T n) :\n    \u2983\u231cTrue\u231d\u2984\n    ones_like a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_tri", "vc-description": "/- \n{\n  \"name\": \"numpy.tri\",\n  \"category\": \"Building matrices\",\n  \"description\": \"An array with ones at and below the given diagonal and zeros elsewhere\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.tri.html\",\n  \"doc\": \"\\nAn array with ones at and below the given diagonal and zeros elsewhere.\\n\\nParameters\\n----------\\nN : int\\n    Number of rows in the array.\\nM : int, optional\\n    Number of columns in the array. By default, M is taken equal to N.\\nk : int, optional\\n    The sub-diagonal at and below which the array is filled. k = 0 is the main diagonal, \\n    while k < 0 is below it, and k > 0 is above. The default is 0.\\ndtype : dtype, optional\\n    Data type of the returned array. The default is float.\\nlike : array_like, optional\\n    Reference object to allow the creation of arrays which are not NumPy arrays.\\n\\nReturns\\n-------\\ntri : ndarray of shape (N, M)\\n    Array with its lower triangle filled with ones and zero elsewhere; in other words \\n    T[i,j] == 1 for j <= i + k, 0 otherwise.\\n\\nExamples\\n--------\\n>>> np.tri(3, 5, 2, dtype=int)\\narray([[1, 1, 1, 0, 0],\\n       [1, 1, 1, 1, 0],\\n       [1, 1, 1, 1, 1]])\\n\\n>>> np.tri(3, 5, -1)\\narray([[0.,  0.,  0.,  0.,  0.],\\n       [1.,  0.,  0.,  0.,  0.],\\n       [1.,  1.,  0.,  0.,  0.]])\\n\",\n  \"signature\": \"numpy.tri(N, M=None, k=0, dtype=<class 'float'>, *, like=None)\"\n}\n-/\n\n/-  An array with ones at and below the given diagonal and zeros elsewhere.\n\n    Creates a matrix of shape (N, M) where T[i,j] = 1 if j \u2264 i + k, and 0 otherwise.\n    The parameter k controls the diagonal: k = 0 is the main diagonal,\n    k < 0 is below it, and k > 0 is above it.\n-/\n\n/-  Specification: tri creates a lower triangular matrix with specified diagonal offset.\n\n    The resulting matrix has ones at and below the k-th diagonal, zeros elsewhere.\n    For each position (i, j):\n    - If j \u2264 i + k, then the value is 1.0\n    - Otherwise, the value is 0.0\n\n    This captures the mathematical property that defines a generalized lower triangular matrix.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tri (N M : Nat) (k : Int) : Id (Vector (Vector Float M) N) :=\n  sorry", "vc-theorems": "theorem tri_spec (N M : Nat) (k : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    tri N M k\n    \u2983\u21d3result => \u231c\u2200 (i : Fin N) (j : Fin M), \n                  (result.get i).get j = if (j.val : Int) \u2264 (i.val : Int) + k then 1.0 else 0.0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_tril", "vc-description": "/- \n{\n  \"name\": \"numpy.tril\",\n  \"category\": \"Building matrices\",\n  \"description\": \"Lower triangle of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.tril.html\",\n  \"doc\": \"\\nLower triangle of an array.\\n\\nReturn a copy of an array with elements above the k-th diagonal zeroed. For arrays with \\nndim exceeding 2, tril will apply to the final two axes.\\n\\nParameters\\n----------\\nm : array_like, shape (..., M, N)\\n    Input array.\\nk : int, optional\\n    Diagonal above which to zero elements. k = 0 (the default) is the main diagonal, \\n    k < 0 is below it and k > 0 is above.\\n\\nReturns\\n-------\\ntril : ndarray, shape (..., M, N)\\n    Lower triangle of m, of same shape and data-type as m.\\n\\nExamples\\n--------\\n>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\\narray([[ 0,  0,  0],\\n       [ 4,  0,  0],\\n       [ 7,  8,  0],\\n       [10, 11, 12]])\\n\\n>>> np.tril(np.arange(3*4*5).reshape(3, 4, 5))[:,:,::2]\\narray([[[ 0,  0,  0],\\n        [ 5,  0,  0],\\n        [10, 11,  0],\\n        [15, 16, 17]],\\n       [[20,  0,  0],\\n        [25, 26,  0],\\n        [30, 31, 32],\\n        [35, 36, 37]],\\n       [[40,  0,  0],\\n        [45, 46,  0],\\n        [50, 51, 52],\\n        [55, 56, 57]]])\\n\",\n  \"signature\": \"numpy.tril(m, k=0)\"\n}\n-/\n\n/-  numpy.tril: Lower triangle of a matrix.\n\n    Returns a copy of the input matrix with elements above the k-th diagonal zeroed.\n\n    - k = 0 (default): zeros elements above the main diagonal\n    - k < 0: zeros elements above the k-th diagonal below the main diagonal\n    - k > 0: zeros elements above the k-th diagonal above the main diagonal\n\n    For a matrix element at position (i, j):\n    - It is kept if i >= j - k\n    - It is zeroed if i < j - k\n-/\n\n/-  Specification: tril returns a lower triangular matrix by zeroing elements above the k-th diagonal.\n\n    Mathematical Properties:\n    1. Shape preservation: The output matrix has the same dimensions as the input\n    2. Lower triangle preservation: Elements on or below the k-th diagonal are unchanged\n    3. Upper triangle zeroing: Elements above the k-th diagonal are set to zero\n    4. Diagonal selection: The k parameter controls which diagonal forms the boundary\n       - k = 0: main diagonal (default)\n       - k < 0: diagonal below the main diagonal\n       - k > 0: diagonal above the main diagonal\n    5. Idempotency: Applying tril twice with the same k yields the same result\n\n    Element-wise specification:\n    For each element at position (i, j):\n    - If i \u2265 j - k (on or below the k-th diagonal), the element is preserved\n    - If i < j - k (above the k-th diagonal), the element is set to 0\n\n    Special cases:\n    - k \u2265 cols: All elements are preserved (entire matrix is \"lower triangular\")\n    - k \u2264 -rows: All elements are zeroed (no elements are \"on or below\" such a diagonal)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tril {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int := 0) : \n    Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem tril_spec {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int := 0) :\n    \u2983\u231cTrue\u231d\u2984\n    tril m k\n    \u2983\u21d3result => \u231c-- Element-wise specification (core property)\n                  (\u2200 (i : Fin rows) (j : Fin cols), \n                    (result.get i).get j = \n                      if (i : Int) \u2265 (j : Int) - k then (m.get i).get j else 0) \u2227\n                  -- Sanity check: diagonal elements are preserved when k = 0\n                  (k = 0 \u2192 \u2200 i : Fin (min rows cols), \n                    have hi : i < rows := by sorry\n                    have hj : i < cols := by sorry\n                    (result.get \u27e8i, hi\u27e9).get \u27e8i, hj\u27e9 = (m.get \u27e8i, hi\u27e9).get \u27e8i, hj\u27e9) \u2227\n                  -- Sanity check: all elements preserved when k is very large\n                  (k \u2265 (cols : Int) \u2192 \u2200 (i : Fin rows) (j : Fin cols), \n                    (result.get i).get j = (m.get i).get j) \u2227\n                  -- Sanity check: all elements zeroed when k is very negative\n                  (k \u2264 -(rows : Int) \u2192 \u2200 (i : Fin rows) (j : Fin cols), \n                    (result.get i).get j = 0) \u2227\n                  -- Idempotency property: tril(tril(m, k), k) = tril(m, k)\n                  (\u2200 (i : Fin rows) (j : Fin cols),\n                    let twice_applied := tril result k\n                    (twice_applied.get i).get j = (result.get i).get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_triu", "vc-description": "/- \n{\n  \"name\": \"numpy.triu\",\n  \"category\": \"Building matrices\",\n  \"description\": \"Upper triangle of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.triu.html\",\n  \"doc\": \"\\nUpper triangle of an array.\\n\\nReturn a copy of an array with the elements below the k-th diagonal zeroed. For arrays \\nwith ndim exceeding 2, triu will apply to the final two axes.\\n\\nParameters\\n----------\\nm : array_like, shape (..., M, N)\\n    Input array.\\nk : int, optional\\n    Diagonal below which to zero elements. k = 0 (the default) is the main diagonal, \\n    k < 0 is below it and k > 0 is above.\\n\\nReturns\\n-------\\ntriu : ndarray, shape (..., M, N)\\n    Upper triangle of m, of same shape and data-type as m.\\n\\nExamples\\n--------\\n>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\\narray([[ 1,  2,  3],\\n       [ 4,  5,  6],\\n       [ 0,  8,  9],\\n       [ 0,  0, 12]])\\n\\n>>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))[:,:,::2]\\narray([[[ 0,  2,  4],\\n        [ 0,  7,  9],\\n        [ 0,  0, 14],\\n        [ 0,  0,  0]],\\n       [[20, 22, 24],\\n        [ 0, 27, 29],\\n        [ 0,  0, 34],\\n        [ 0,  0,  0]],\\n       [[40, 42, 44],\\n        [ 0, 47, 49],\\n        [ 0,  0, 54],\\n        [ 0,  0,  0]]])\\n\",\n  \"signature\": \"numpy.triu(m, k=0)\"\n}\n-/\n\n/-  Upper triangle of a matrix.\n\n    Returns a copy of a matrix with the elements below the k-th diagonal zeroed.\n    - k = 0: main diagonal (default)\n    - k < 0: include |k| diagonals below the main diagonal\n    - k > 0: zero out k diagonals above the main diagonal as well\n-/\n\n/-  Specification: triu returns an upper triangular matrix with specific properties.\n\n    Core behavior:\n    - Elements below the k-th diagonal are zeroed\n    - Elements on and above the k-th diagonal are preserved\n\n    Mathematical properties:\n    1. Element-wise specification: result[i][j] = if i > j - k then 0 else m[i][j]\n    2. Preservation of dimensions: result has same shape as input\n    3. Diagonal control: k parameter shifts which diagonal forms the boundary\n    4. Idempotence: applying triu twice with same k gives same result\n    5. Special cases:\n       - k = 0: standard upper triangular (zeros below main diagonal)\n       - k < 0: includes |k| diagonals below main diagonal in upper triangle\n       - k > 0: zeros out k additional diagonals above main diagonal\n    6. For square matrices when k = 0, all elements where row_index > column_index are zero\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def triu {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int := 0) : \n    Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem triu_spec {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    triu m k\n    \u2983\u21d3result => \u231c(\u2200 (i : Fin rows) (j : Fin cols), \n                   (result.get i).get j = \n                     if (i.val : Int) > (j.val : Int) - k then 0 \n                     else (m.get i).get j) \u2227\n                  (\u2200 (i : Fin rows) (j : Fin cols),\n                   (i.val : Int) \u2264 (j.val : Int) - k \u2192 \n                   (result.get i).get j = (m.get i).get j) \u2227\n                  (\u2200 (i : Fin rows) (j : Fin cols),\n                   (i.val : Int) > (j.val : Int) - k \u2192 \n                   (result.get i).get j = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_vander", "vc-description": "/- \n{\n  \"name\": \"numpy.vander\",\n  \"category\": \"Building matrices\",\n  \"description\": \"Generate a Vandermonde matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.vander.html\",\n  \"doc\": \"\\nGenerate a Vandermonde matrix.\\n\\nParameters\\n----------\\nx : array_like\\n    1-D input array.\\nN : int, optional\\n    Number of columns in the output. If N is not specified, a square array is returned (N = len(x)).\\nincreasing : bool, optional\\n    Order of the powers of the columns. If True, the powers increase from left to right, \\n    if False (the default) they are reversed.\\n\\nReturns\\n-------\\nout : ndarray\\n    Vandermonde matrix. If increasing is False, the first column is x^(N-1), the second x^(N-2) \\n    and so forth. If increasing is True, the columns are x^0, x^1, ..., x^(N-1).\\n\\nExamples\\n--------\\n>>> x = np.array([1, 2, 3, 5])\\n>>> N = 3\\n>>> np.vander(x, N)\\narray([[ 1,  1,  1],\\n       [ 4,  2,  1],\\n       [ 9,  3,  1],\\n       [25,  5,  1]])\\n\\n>>> np.column_stack([x**(N-1-i) for i in range(N)])\\narray([[ 1,  1,  1],\\n       [ 4,  2,  1],\\n       [ 9,  3,  1],\\n       [25,  5,  1]])\\n\\n>>> x = np.array([1, 2, 3, 5])\\n>>> np.vander(x)\\narray([[  1,   1,   1,   1],\\n       [  8,   4,   2,   1],\\n       [ 27,   9,   3,   1],\\n       [125,  25,   5,   1]])\\n>>> np.vander(x, increasing=True)\\narray([[  1,   1,   1,   1],\\n       [  1,   2,   4,   8],\\n       [  1,   3,   9,  27],\\n       [  1,   5,  25, 125]])\\n\",\n  \"signature\": \"numpy.vander(x, N=None, increasing=False)\"\n}\n-/\n\n/-  Generate a Vandermonde matrix with decreasing powers (default behavior).\n    The Vandermonde matrix is a matrix with terms of a geometric progression in each row.\n    For a 1D input vector x of length n and specified number of columns m,\n    the output is an n\u00d7m matrix where entry (i,j) = x[i]^(m-1-j) -/\n\n/-  Specification: vander generates a Vandermonde matrix where each row contains\n    powers of the corresponding element from the input vector.\n    In the default decreasing mode, column j contains x^(m-1-j) for each element x.\n    This means the first column has the highest powers and the last column has x^0 = 1. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vander {n m : Nat} (x : Vector Float n) : Id (Vector (Vector Float m) n) :=\n  sorry", "vc-theorems": "theorem vander_spec {n m : Nat} (x : Vector Float n) (h_m_pos : m > 0) :\n    \u2983\u231cm > 0\u231d\u2984\n    vander x\n    \u2983\u21d3result => \u231c\u2200 (i : Fin n) (j : Fin m), \n                  (result.get i).get j = (x.get i) ^ ((m - 1 - j.val).toFloat)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_zeros", "vc-description": "/- \n{\n  \"name\": \"numpy.zeros\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return a new array of given shape and type, filled with zeros\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.zeros.html\",\n  \"doc\": \"\\nReturn a new array of given shape and type, filled with zeros.\\n\\nParameters\\n----------\\nshape : int or tuple of ints\\n    Shape of the new array, e.g., (2, 3) or 2.\\ndtype : data-type, optional\\n    The desired data-type for the array, e.g., numpy.int8. Default is numpy.float64.\\norder : {'C', 'F'}, optional, default: 'C'\\n    Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array of zeros with the given shape, dtype, and order.\\n\\nExamples\\n--------\\n>>> np.zeros(5)\\narray([ 0.,  0.,  0.,  0.,  0.])\\n\\n>>> np.zeros((5,), dtype=int)\\narray([0, 0, 0, 0, 0])\\n\\n>>> np.zeros((2, 1))\\narray([[ 0.],\\n       [ 0.]])\\n\",\n  \"signature\": \"numpy.zeros(shape, dtype=float, order='C', *, device=None, like=None)\"\n}\n-/\n\n/-  Return a new vector of given size, filled with zeros -/\n\n/-  Specification: zeros returns a vector where all elements are zero\n    This comprehensive specification captures:\n    1. All elements equal to zero (basic property)\n    2. The result is the additive identity for vector addition\n    3. The sum of all elements is zero (for numeric types)\n    4. Scalar multiplication by any value preserves the zero property\n    5. The dot product with any vector is zero\n    6. The norm/magnitude is zero (for types with norm)\n    7. Element-wise operations preserve zero structure\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def zeros (n : Nat) (\u03b1 : Type) [Zero \u03b1] : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem zeros_spec (n : Nat) (\u03b1 : Type) [Zero \u03b1] [Add \u03b1] [Mul \u03b1] :\n    \u2983\u231cTrue\u231d\u2984\n    zeros n \u03b1\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = 0) \u2227\n                 (\u2200 v : Vector \u03b1 n, \u2200 i : Fin n, \n                   (result.get i + v.get i = v.get i) \u2227 \n                   (v.get i + result.get i = v.get i)) \u2227\n                 (\u2200 scalar : \u03b1, \u2200 i : Fin n,\n                   scalar * result.get i = 0) \u2227\n                 (\u2200 v : Vector \u03b1 n, \u2200 i : Fin n,\n                   result.get i * v.get i = 0) \u2227\n                 (n > 0 \u2192 result.get \u27e80, sorry\u27e9 = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_creation_zeros_like", "vc-description": "/- \n{\n  \"name\": \"numpy.zeros_like\",\n  \"category\": \"From shape or value\",\n  \"description\": \"Return an array of zeros with the same shape and type as a given array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.zeros_like.html\",\n  \"doc\": \"\\nReturn an array of zeros with the same shape and type as a given array.\\n\\nParameters\\n----------\\na : array_like\\n    The shape and data-type of a define these same attributes of the returned array.\\ndtype : data-type, optional\\n    Overrides the data type of the result.\\norder : {'C', 'F', 'A', or 'K'}, optional\\n    Overrides the memory layout of the result.\\nsubok : bool, optional\\n    If True, then the newly created array will use the sub-class type of a, otherwise it will be a base-class array.\\nshape : int or sequence of ints, optional\\n    Overrides the shape of the result.\\n\\nReturns\\n-------\\nout : ndarray\\n    Array of zeros with the same shape and type as a.\\n\\nExamples\\n--------\\n>>> x = np.arange(6)\\n>>> x = x.reshape((2, 3))\\n>>> x\\narray([[0, 1, 2],\\n       [3, 4, 5]])\\n>>> np.zeros_like(x)\\narray([[0, 0, 0],\\n       [0, 0, 0]])\\n\",\n  \"signature\": \"numpy.zeros_like(a, dtype=None, order='K', subok=True, shape=None, *, device=None)\"\n}\n-/\n\n/-  Return a vector of zeros with the same length as the input vector.\n    This is the 1D version of numpy.zeros_like which creates a new vector\n    filled with zeros, having the same size as the input vector. -/\n\n/-  Specification: zeros_like returns a vector where every element is 0,\n    with the same length as the input vector.\n\n    Mathematical properties:\n    1. The result has the same length as the input (enforced by type system)\n    2. Every element in the result is exactly 0\n    3. The result is independent of the input values (only depends on shape)\n    4. The result is the additive identity for vector addition\n    5. For numeric types, the sum of all elements is zero -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def zeros_like {n : Nat} {T : Type} [Zero T] (a : Vector T n) : Id (Vector T n) :=\n  sorry", "vc-theorems": "theorem zeros_like_spec {n : Nat} {T : Type} [Zero T] [Add T] (a : Vector T n) :\n    \u2983\u231cTrue\u231d\u2984\n    zeros_like a\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = 0) \u2227\n                 (\u2200 v : Vector T n, \u2200 i : Fin n, \n                   (result.get i + v.get i = v.get i) \u2227 \n                   (v.get i + result.get i = v.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_append", "vc-description": "/-  numpy.append: Append values to the end of an array.\n\n    For 1D arrays without axis specification, this function flattens both \n    arrays and concatenates them. The result is a 1D array containing all \n    elements from arr followed by all elements from values.\n\n    This is a fundamental array manipulation operation that creates a new\n    array by joining two arrays end-to-end. Unlike in-place operations,\n    this always returns a new array.\n-/\n\n/-  Specification: numpy.append creates a new array containing all elements\n    from arr followed by all elements from values.\n\n    Precondition: True (no special preconditions for basic append)\n    Postcondition: \n    - The first n elements of the result come from arr\n    - The next m elements come from values\n    - The order of elements is preserved from both input arrays\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_append {n m : Nat} (arr : Vector Float n) (values : Vector Float m) : \n    Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem numpy_append_spec {n m : Nat} (arr : Vector Float n) (values : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_append arr values\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get (i.castAdd m) = arr.get i) \u2227\n                (\u2200 j : Fin m, result.get (j.natAdd n) = values.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_array_split", "vc-description": "/- \n{\n  \"name\": \"numpy.array_split\",\n  \"category\": \"Splitting Arrays\",\n  \"description\": \"Split an array into multiple sub-arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.array_split.html\",\n  \"doc\": \"Split an array into multiple sub-arrays.\\n\\nPlease refer to the \\`split\\` documentation. The only difference\\nbetween these functions is that \\`array_split\\` allows\\n\\`indices_or_sections\\` to be an integer that does *not* equally\\ndivide the axis. For an array of length l that should be split\\ninto n sections, it returns l % n sub-arrays of size l//n + 1\\nand the rest of size l//n.\\n\\nExamples\\n--------\\n>>> x = np.arange(8.0)\\n>>> np.array_split(x, 3)\\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.array_split(ary, indices_or_sections, axis=0)\"\n}\n-/\n\n/-  Split a vector into k sub-vectors.\n\n    When splitting a vector of length n into k sections:\n    - The first (n % k) sub-vectors have size \u2308n/k\u2309 = (n + k - 1) / k\n    - The remaining sub-vectors have size \u230an/k\u230b = n / k\n\n    This ensures all elements are distributed as evenly as possible,\n    with larger sub-vectors appearing first.\n-/\n\n/-  Specification: array_split distributes elements evenly with mathematical properties\n\n    The specification captures:\n    1. Size distribution: larger chunks come first\n    2. Element preservation: all elements from the original vector appear in order\n    3. No gaps or overlaps: elements are contiguously distributed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def array_split {n k : Nat} (v : Vector Float n) (hk : k > 0) : \n    Id (Vector (\u03a3 m : Nat, Vector Float m) k) :=\n  sorry", "vc-theorems": "theorem array_split_spec {n k : Nat} (v : Vector Float n) (hk : k > 0) :\n    \u2983\u231ck > 0\u231d\u2984\n    array_split v hk\n    \u2983\u21d3result => \u231c\n      -- Each sub-vector has the correct size based on its position\n      (\u2200 i : Fin k, \n        (result.get i).1 = \n          if i.val < n % k then (n + k - 1) / k else n / k) \u2227\n      -- Elements are preserved in order across all sub-vectors\n      (\u2203 (start_indices : Vector Nat k),\n        -- First sub-vector starts at index 0\n        start_indices.get \u27e80, by omega\u27e9 = 0 \u2227\n        -- Each subsequent sub-vector starts where the previous one ended\n        (\u2200 i : Fin k, i.val > 0 \u2192 \n          start_indices.get i = start_indices.get \u27e8i.val - 1, by omega\u27e9 + \n            (result.get \u27e8i.val - 1, by omega\u27e9).1) \u2227\n        -- Elements match the original vector\n        (\u2200 i : Fin k, \u2200 j : Fin (result.get i).1,\n          (result.get i).2.get j = \n            v.get \u27e8start_indices.get i + j.val, by sorry\u27e9))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_atleast_1d", "vc-description": "/- \n{\n  \"name\": \"numpy.atleast_1d\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Convert inputs to arrays with at least one dimension\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.atleast_1d.html\",\n  \"doc\": \"Convert inputs to arrays with at least one dimension.\\n\\nScalar inputs are converted to 1-dimensional arrays, whilst\\nhigher-dimensional inputs are preserved.\\n\\nParameters\\n----------\\n*arrays : array_like\\n    One or more input arrays.\\n\\nReturns\\n-------\\nret : ndarray\\n    An array, or list of arrays, each with ``a.ndim >= 1``.\\n    Copies are made only if necessary.\\n\\nExamples\\n--------\\n>>> np.atleast_1d(1.0)\\narray([1.])\\n>>> x = np.arange(9.0).reshape(3,3)\\n>>> np.atleast_1d(x)\\narray([[0., 1., 2.],\\n       [3., 4., 5.],\\n       [6., 7., 8.]])\\n>>> np.atleast_1d(x) is x\\nTrue\\n>>> np.atleast_1d(1, [3, 4])\\n[array([1]), array([3, 4])]\",\n  \"source_location\": \"numpy/_core/shape_base.py\",\n  \"signature\": \"numpy.atleast_1d(*arrays)\"\n}\n-/\n\n/-  numpy.atleast_1d: Convert inputs to arrays with at least one dimension.\n\n    This function ensures that the input has at least one dimension.\n    - Scalar inputs are converted to 1-dimensional arrays with a single element\n    - Higher-dimensional inputs (vectors) are preserved unchanged\n\n    For the Vector-based implementation, we provide a version that takes\n    a vector and returns it unchanged, since Vectors already have at least\n    one dimension by construction.\n-/\n\n/-  Specification: atleast_1d returns the input vector unchanged.\n\n    Since Vectors in Lean already have at least one dimension by their type,\n    this function acts as an identity function for vectors.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The result is identical to the input vector\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def atleast_1d {n : Nat} (arr : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem atleast_1d_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    atleast_1d arr\n    \u2983\u21d3result => \u231cresult = arr \u2227 (\u2200 i : Fin n, result.get i = arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_atleast_2d", "vc-description": "/- \n{\n  \"name\": \"numpy.atleast_2d\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"View inputs as arrays with at least two dimensions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.atleast_2d.html\",\n  \"doc\": \"View inputs as arrays with at least two dimensions.\\n\\nParameters\\n----------\\n*arrays : array_like\\n    One or more array-like sequences. Non-array inputs are converted\\n    to arrays. Arrays that already have two or more dimensions are\\n    preserved.\\n\\nReturns\\n-------\\nres, res2, ... : ndarray\\n    An array, or list of arrays, each with ``a.ndim >= 2``.\\n    Copies are avoided where possible, and views with two or more\\n    dimensions are returned.\\n\\nExamples\\n--------\\n>>> np.atleast_2d(3.0)\\narray([[3.]])\\n>>> x = np.arange(3.0)\\n>>> np.atleast_2d(x)\\narray([[0., 1., 2.]])\\n>>> np.atleast_2d(x).base is x\\nTrue\\n>>> np.atleast_2d(1, [1, 2], [[1, 2]])\\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\",\n  \"source_location\": \"numpy/_core/shape_base.py\",\n  \"signature\": \"numpy.atleast_2d(*arrays)\"\n}\n-/\n\n/-  numpy.atleast_2d: View inputs as arrays with at least two dimensions.\n\n    For a 1D vector input, this function converts it to a 2D array (matrix)\n    with shape (1, n), where the input becomes the single row of the matrix.\n\n    This specification focuses on the 1D to 2D case, which is the most common\n    use case for ensuring arrays have at least 2 dimensions.\n-/\n\n/-  Specification: atleast_2d converts a 1D vector to a 2D matrix with one row.\n\n    This specification includes:\n    1. Sanity check: The result has exactly 1 row\n    2. Shape property: The result's shape is (1, n) where n is the input length\n    3. Value preservation: All elements from the input are preserved in order\n    4. Mathematical property: The operation is essentially a row vector representation\n\n    Precondition: True (no special preconditions)\n    Postcondition: \n    - The result is a matrix with 1 row and n columns\n    - The single row contains all elements from the input vector in the same order\n    - The transformation preserves all numerical values exactly\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def atleast_2d {n : Nat} (arr : Vector Float n) : Id (Vector (Vector Float n) 1) :=\n  sorry", "vc-theorems": "theorem atleast_2d_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    atleast_2d arr\n    \u2983\u21d3result => \u231c-- Shape property: result has exactly 1 row\n                  result.size = 1 \u2227\n                  -- Row content property: the single row matches the input\n                  \u2203 row : Vector Float n, \n                  result = Vector.singleton row \u2227 \n                  -- Element preservation: all elements are preserved in order\n                  \u2200 i : Fin n, row.get i = arr.get i \u2227\n                  -- Mathematical property: this is equivalent to creating a 1\u00d7n matrix\n                  -- where the input vector forms the single row\n                  result.get \u27e80, by simp\u27e9 = row\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_atleast_3d", "vc-description": "/- \n{\n  \"name\": \"numpy.atleast_3d\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"View inputs as arrays with at least three dimensions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.atleast_3d.html\",\n  \"doc\": \"View inputs as arrays with at least three dimensions.\\n\\nParameters\\n----------\\n*arrays : array_like\\n    One or more array-like sequences. Non-array inputs are converted to\\n    arrays. Arrays that already have three or more dimensions are\\n    preserved.\\n\\nReturns\\n-------\\nres1, res2, ... : ndarray\\n    An array, or list of arrays, each with ``a.ndim >= 3``. Copies are\\n    avoided where possible, and views with three or more dimensions are\\n    returned. For example, a 1-D array of shape ``(N,)`` becomes a view\\n    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a\\n    view of shape ``(M, N, 1)``.\\n\\nExamples\\n--------\\n>>> np.atleast_3d(3.0)\\narray([[[3.]]])\\n>>> x = np.arange(3.0)\\n>>> np.atleast_3d(x).shape\\n(1, 3, 1)\\n>>> x = np.arange(12.0).reshape(4,3)\\n>>> np.atleast_3d(x).shape\\n(4, 3, 1)\\n>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\\nTrue\\n>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\\n...     print(arr, arr.shape)\\n[[[1]\\n  [2]]] (1, 2, 1)\\n[[[1]\\n  [2]]] (1, 2, 1)\\n[[[1 2]]] (1, 1, 2)\",\n  \"source_location\": \"numpy/_core/shape_base.py\",\n  \"signature\": \"numpy.atleast_3d(*arrays)\"\n}\n-/\n\n/-  numpy.atleast_3d: View a 1D vector as a 3D array with shape (1, n, 1).\n\n    This is a specialization of numpy.atleast_3d for 1D input.\n    The function reshapes a 1D array of shape (n,) into a 3D array \n    of shape (1, n, 1) while preserving all elements.\n-/\n\n/-  Specification: atleast_3d transforms a 1D vector into a 3D array where:\n    - The output has shape (1, n, 1)\n    - Each element arr[i] is accessible at position [0][i][0] in the result\n    - All elements are preserved without modification\n    - The transformation is injective (different inputs produce different outputs)\n\n    Mathematical properties:\n    1. Element preservation: Every element from the input appears exactly once in the output\n    2. Shape expansion: A 1D shape (n,) becomes 3D shape (1, n, 1)\n    3. Order preservation: Elements maintain their relative ordering\n    4. The output contains exactly n elements total\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def atleast_3d {n : Nat} (arr : Vector Float n) : Id (Vector (Vector (Vector Float 1) n) 1) :=\n  sorry", "vc-theorems": "theorem atleast_3d_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    atleast_3d arr\n    \u2983\u21d3result => \u231c(\u2200 (i : Fin n), \n                   let outer := result.get \u27e80, by simp\u27e9\n                   let middle := outer.get i\n                   let value := middle.get \u27e80, by simp\u27e9\n                   value = arr.get i) \u2227\n                  (result.size = 1) \u2227\n                  (\u2200 (j : Fin 1), (result.get j).size = n) \u2227\n                  (\u2200 (j : Fin 1) (k : Fin n), ((result.get j).get k).size = 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_block", "vc-description": "/- \n{\n  \"name\": \"numpy.block\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Assemble an nd-array from nested lists of blocks\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.block.html\",\n  \"doc\": \"Assemble an nd-array from nested lists of blocks.\\n\\nBlocks in the innermost lists are concatenated (see \\`concatenate\\`) along\\nthe last dimension (-1), then these are concatenated along the\\nsecond-last dimension (-2), and so on until the outermost list is reached.\\n\\nBlocks can be of any dimension, but will not be broadcasted using the normal\\nrules. Instead, leading axes of size 1 are inserted, to make \\`\\`block.ndim\\`\\`\\nthe same for all blocks. This is primarily useful for working with scalars,\\nand means that code like \\`\\`np.block([v, 1])\\`\\` is valid, where\\n\\`\\`v.ndim == 1\\`\\`.\\n\\nWhen the nested list is two levels deep, this allows block matrices to be\\nconstructed from their components.\\n\\nParameters\\n----------\\narrays : nested list of array_like or scalars (but not tuples)\\n    If passed a single ndarray or scalar (a nested list of depth 0), this\\n    is returned unmodified (and not copied).\\n\\n    Elements shapes must match along the appropriate axes (without\\n    broadcasting), but leading 1s will be prepended to the shape as\\n    necessary to make the dimensions match.\\n\\nReturns\\n-------\\nblock_array : ndarray\\n    The array assembled from the given blocks.\\n\\n    The dimensionality of the output is equal to the greatest of:\\n    * the dimensionality of all the inputs\\n    * the depth to which the input list is nested\\n\\nExamples\\n--------\\n>>> A = np.eye(2) * 2\\n>>> B = np.eye(3) * 3\\n>>> np.block([\\n...     [A,               np.zeros((2, 3))],\\n...     [np.ones((3, 2)), B               ]\\n... ])\\narray([[2., 0., 0., 0., 0.],\\n       [0., 2., 0., 0., 0.],\\n       [1., 1., 3., 0., 0.],\\n       [1., 1., 0., 3., 0.],\\n       [1., 1., 0., 0., 3.]])\\n\\nWith a list of depth 1, \\`block\\` can be used as \\`hstack\\`:\\n\\n>>> np.block([1, 2, 3])              # hstack([1, 2, 3])\\narray([1, 2, 3])\\n\\n>>> a = np.array([1, 2, 3])\\n>>> b = np.array([4, 5, 6])\\n>>> np.block([a, b, 10])             # hstack([a, b, 10])\\narray([ 1,  2,  3,  4,  5,  6, 10])\\n\\n>>> A = np.ones((2, 2), int)\\n>>> B = 2 * A\\n>>> np.block([A, B])                 # hstack([A, B])\\narray([[1, 1, 2, 2],\\n       [1, 1, 2, 2]])\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.block(arrays)\"\n}\n-/\n\n/-  \nAssemble a 2D matrix from a 2x2 block structure.\nThis is a simplified version focusing on the common case of assembling \na matrix from four blocks arranged in a 2x2 pattern.\n-/\n\n/-  \nSpecification: block assembles a matrix from four submatrices in a 2x2 pattern.\nThe result has dimensions (r1 + r2) \u00d7 (c1 + c2) where:\n- Top-left block occupies rows [0, r1) and columns [0, c1)\n- Top-right block occupies rows [0, r1) and columns [c1, c1 + c2)\n- Bottom-left block occupies rows [r1, r1 + r2) and columns [0, c1)\n- Bottom-right block occupies rows [r1, r1 + r2) and columns [c1, c1 + c2)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Lean.Elab.Tactic.Omega\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def block {r1 c1 r2 c2 : Nat} \n    (topLeft : Vector (Vector Float c1) r1)\n    (topRight : Vector (Vector Float c2) r1)\n    (bottomLeft : Vector (Vector Float c1) r2)\n    (bottomRight : Vector (Vector Float c2) r2) : \n    Id (Vector (Vector Float (c1 + c2)) (r1 + r2)) :=\n  sorry", "vc-theorems": "theorem block_spec {r1 c1 r2 c2 : Nat}\n    (topLeft : Vector (Vector Float c1) r1)\n    (topRight : Vector (Vector Float c2) r1)\n    (bottomLeft : Vector (Vector Float c1) r2)\n    (bottomRight : Vector (Vector Float c2) r2) :\n    \u2983\u231cTrue\u231d\u2984\n    block topLeft topRight bottomLeft bottomRight\n    \u2983\u21d3result => \u231c\n      -- Top-left block elements\n      (\u2200 (i : Fin r1) (j : Fin c1), \n        (result.get \u27e8i.val, by omega\u27e9).get \u27e8j.val, by omega\u27e9 = (topLeft.get i).get j) \u2227\n      -- Top-right block elements\n      (\u2200 (i : Fin r1) (j : Fin c2),\n        (result.get \u27e8i.val, by omega\u27e9).get \u27e8c1 + j.val, by omega\u27e9 = (topRight.get i).get j) \u2227\n      -- Bottom-left block elements\n      (\u2200 (i : Fin r2) (j : Fin c1),\n        (result.get \u27e8r1 + i.val, by omega\u27e9).get \u27e8j.val, by omega\u27e9 = (bottomLeft.get i).get j) \u2227\n      -- Bottom-right block elements\n      (\u2200 (i : Fin r2) (j : Fin c2),\n        (result.get \u27e8r1 + i.val, by omega\u27e9).get \u27e8c1 + j.val, by omega\u27e9 = (bottomRight.get i).get j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_broadcast", "vc-description": "/- \n{\n  \"name\": \"numpy.broadcast\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Produce an object that mimics broadcasting\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.broadcast.html\",\n  \"doc\": \"Produce an object that mimics broadcasting.\\n\\nParameters\\n----------\\nin1, in2, ... : array_like\\n    Input parameters.\\n\\nReturns\\n-------\\nb : broadcast object\\n    Broadcast the input parameters against one another, and\\n    return an object that encapsulates the result.\\n    Amongst others, it has ``shape`` and ``nd`` properties, and\\n    may be used as an iterator.\\n\\nExamples\\n--------\\n>>> x = np.array([[1], [2], [3]])\\n>>> y = np.array([4, 5, 6])\\n>>> b = np.broadcast(x, y)\\n>>> b.shape\\n(3, 3)\\n>>> b.nd\\n2\\n>>> b.reset()\\n>>> for u, v in b:\\n...     print(u, v)\\n1 4\\n1 5\\n1 6\\n2 4\\n2 5\\n2 6\\n3 4\\n3 5\\n3 6\",\n  \"source_location\": \"C implementation in numpy/_core/src/multiarray/arrayobject.c\",\n  \"signature\": \"numpy.broadcast(in1, in2, ...)\"\n}\n-/\n\n/-  numpy.broadcast: Produce an object that mimics broadcasting between two vectors.\n\n    This simplified version handles broadcasting between a column vector (m \u00d7 1)\n    and a row vector (1 \u00d7 n), producing an object that represents the m \u00d7 n\n    broadcast result.\n\n    The broadcast object allows iteration over all element pairs that would\n    result from the broadcasting operation.\n-/\n\n/-  Specification: broadcast creates an object that correctly pairs elements\n    according to NumPy broadcasting rules.\n\n    For a column vector x of shape (m, 1) and row vector y of shape (1, n),\n    the broadcast object has shape (m, n) and element (i, j) is the pair (x[i], y[j]).\n\n    Preconditions: \n    - m > 0 (x is non-empty)\n    - n > 0 (y is non-empty)\n\n    Postconditions:\n    - The resulting shape is (m, n)\n    - Element at position (i, j) is the pair (x[i], y[j])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a broadcast object for two vectors.\n\n    A broadcast object encapsulates the result of broadcasting two vectors\n    against each other. It produces pairs of elements following NumPy's\n    broadcasting rules.\n-/\nstructure BroadcastObject (T : Type) where\n  /-- The resulting shape after broadcasting -/\n  shape : Nat \u00d7 Nat\n  /-- Function to get the i-th, j-th element pair -/\n  getElement : Fin shape.1 \u2192 Fin shape.2 \u2192 T \u00d7 T", "vc-helpers": "", "vc-definitions": "def broadcast {m n : Nat} (x : Vector Float m) (y : Vector Float n) \n    (hm : m > 0) (hn : n > 0) : Id (BroadcastObject Float) :=\n  sorry", "vc-theorems": "theorem broadcast_spec {m n : Nat} (x : Vector Float m) (y : Vector Float n)\n    (hm : m > 0) (hn : n > 0) :\n    \u2983\u231cm > 0 \u2227 n > 0\u231d\u2984\n    broadcast x y hm hn\n    \u2983\u21d3result => \u231cresult.shape = (m, n) \u2227\n                 \u2200 (i : Fin m) (j : Fin n), \n                   result.getElement \u27e8i.val, by sorry\u27e9 \u27e8j.val, by sorry\u27e9 = (x.get i, y.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_broadcast_arrays", "vc-description": "/- \n{\n  \"name\": \"numpy.broadcast_arrays\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Broadcast any number of arrays against each other\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.broadcast_arrays.html\",\n  \"doc\": \"Broadcast any number of arrays against each other.\\n\\nParameters\\n----------\\n*args : array_likes\\n    The arrays to broadcast.\\nsubok : bool, optional\\n    If True, then sub-classes will be passed-through, otherwise\\n    the returned arrays will be forced to be a base-class array (default).\\n\\nReturns\\n-------\\nbroadcasted : list of arrays\\n    These arrays are views on the original arrays. They are typically\\n    not contiguous. Furthermore, more than one element of a\\n    broadcasted array may refer to a single memory location. If you need\\n    to write to the arrays, make copies first.\\n\\nExamples\\n--------\\n>>> x = np.array([[1,2,3]])\\n>>> y = np.array([[4],[5]])\\n>>> np.broadcast_arrays(x, y)\\n[array([[1, 2, 3],\\n       [1, 2, 3]]), array([[4, 4, 4],\\n       [5, 5, 5]])]\",\n  \"source_location\": \"numpy/lib/_stride_tricks_impl.py\",\n  \"signature\": \"numpy.broadcast_arrays(*args, subok=False)\"\n}\n-/\n\n/-  Broadcast two 1D vectors against each other following NumPy broadcasting rules.\n    For 1D arrays, broadcasting only happens when one array has size 1.\n    The result arrays will have the size of the larger input array. -/\n\n/-  Specification: broadcast_arrays produces two arrays of the same size where:\n    1. If an input array has size 1, its single element is replicated to match the other array's size\n    2. If both arrays have the same size, they are returned unchanged\n    3. The output arrays have size equal to the maximum of the input sizes -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def broadcast_arrays {m n : Nat} (a : Vector Float m) (b : Vector Float n) \n    (h_broadcast : m = 1 \u2228 n = 1 \u2228 m = n) : \n    Id (Vector Float (max m n) \u00d7 Vector Float (max m n)) :=\n  sorry", "vc-theorems": "theorem broadcast_arrays_spec {m n : Nat} (a : Vector Float m) (b : Vector Float n)\n    (h_broadcast : m = 1 \u2228 n = 1 \u2228 m = n) :\n    \u2983\u231cm = 1 \u2228 n = 1 \u2228 m = n\u231d\u2984\n    broadcast_arrays a b h_broadcast\n    \u2983\u21d3result => \n      let (a_broadcast, b_broadcast) := result\n      \u231c-- Both output arrays have the same size as max(m, n)\n       -- First array broadcasting rules\n       (m = 1 \u2192 \u2200 i : Fin (max m n), a_broadcast.get i = a.get \u27e80, sorry\u27e9) \u2227\n       (n = 1 \u2227 m > 1 \u2192 \u2200 i : Fin (max m n), i.val < m \u2192 a_broadcast.get i = a.get \u27e8i.val, sorry\u27e9) \u2227\n       (m = n \u2192 \u2200 i : Fin (max m n), i.val < m \u2192 a_broadcast.get i = a.get \u27e8i.val, sorry\u27e9) \u2227\n       -- Second array broadcasting rules  \n       (n = 1 \u2192 \u2200 i : Fin (max m n), b_broadcast.get i = b.get \u27e80, sorry\u27e9) \u2227\n       (m = 1 \u2227 n > 1 \u2192 \u2200 i : Fin (max m n), i.val < n \u2192 b_broadcast.get i = b.get \u27e8i.val, sorry\u27e9) \u2227\n       (m = n \u2192 \u2200 i : Fin (max m n), i.val < n \u2192 b_broadcast.get i = b.get \u27e8i.val, sorry\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_broadcast_to", "vc-description": "/- \n{\n  \"name\": \"numpy.broadcast_to\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Broadcast an array to a new shape\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.broadcast_to.html\",\n  \"doc\": \"Broadcast an array to a new shape.\\n\\nParameters\\n----------\\narray : array_like\\n    The array to broadcast.\\nshape : tuple\\n    The shape of the desired array.\\nsubok : bool, optional\\n    If True, then sub-classes will be passed-through, otherwise\\n    the returned array will be forced to be a base-class array (default).\\n\\nReturns\\n-------\\nbroadcast : array\\n    A readonly view on the original array with the given shape. It is\\n    typically not contiguous. Furthermore, more than one element of a\\n    broadcasted array may refer to a single memory location.\\n\\nExamples\\n--------\\n>>> x = np.array([1, 2, 3])\\n>>> np.broadcast_to(x, (3, 3))\\narray([[1, 2, 3],\\n       [1, 2, 3],\\n       [1, 2, 3]])\",\n  \"source_location\": \"numpy/lib/_stride_tricks_impl.py\",\n  \"signature\": \"numpy.broadcast_to(array, shape, subok=False)\"\n}\n-/\n\n/-  Broadcast a 1D vector to a 2D matrix by repeating it along rows.\n    This implements the most common broadcasting pattern: (n,) -> (m, n) -/\n\n/-  Specification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.\n\n    Mathematical properties:\n    1. Shape property: The result has shape (m, n) where n is the original vector length\n    2. Value property: Each row in the result equals the original vector\n    3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating\n    4. Row consistency: All rows in the result are identical to the input vector\n    5. Element preservation: Each element in the input appears m times in each column\n\n    Sanity checks:\n    - The output shape is exactly (m, n)\n    - Every row contains the same values as the input vector\n    - Broadcasting preserves element values without modification\n    - The result behaves as if v was copied m times along a new axis\n\n    Example behavior:\n    - Input: [1, 2, 3] with target shape (2, 3)\n    - Output: [[1, 2, 3], [1, 2, 3]]\n\n    Additional properties:\n    - Memory efficiency: In NumPy, this creates a view, not a copy\n    - Column-wise view: Column j contains m copies of v[j]\n    - Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays\n\n    Mathematical formulation:\n    - For input vector v \u2208 \u211d\u207f and target shape (m, n)\n    - Output matrix M \u2208 \u211d\u1d50\u02e3\u207f where M[i,j] = v[j] for all i \u2208 {0,...,m-1}, j \u2208 {0,...,n-1}\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def broadcast_to {n m : Nat} (v : Vector Float n) : Id (Vector (Vector Float n) m) :=\n  sorry", "vc-theorems": "theorem broadcast_to_spec {n m : Nat} (v : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    broadcast_to v\n    \u2983\u21d3result => \u231c\n      -- Primary property: each element (i,j) equals v[j]\n      (\u2200 i : Fin m, \u2200 j : Fin n, (result.get i).get j = v.get j) \u2227\n      -- Row identity: each row is exactly the input vector\n      (\u2200 i : Fin m, result.get i = v) \u2227\n      -- Column uniformity: each column contains a single repeated value\n      (\u2200 j : Fin n, \u2200 i\u2081 i\u2082 : Fin m, (result.get i\u2081).get j = (result.get i\u2082).get j) \u2227\n      -- Value preservation: no new values are introduced\n      (\u2200 i : Fin m, \u2200 j : Fin n, \u2203 k : Fin n, (result.get i).get j = v.get k \u2227 k = j) \u2227\n      -- Broadcast invariant: the operation is idempotent on rows\n      (\u2200 i\u2081 i\u2082 : Fin m, result.get i\u2081 = result.get i\u2082)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_column_stack", "vc-description": "/-  numpy.column_stack: Stack 1-D arrays as columns into a 2-D array.\n\n    Takes a sequence of 1-D arrays and stacks them as columns to make a \n    single 2-D array. All input arrays must have the same length (number \n    of rows in the output).\n\n    The result is represented as a flattened vector in column-major order,\n    where elements from the same column are contiguous. For a result with\n    'rows' rows and 'cols' columns, element at position (i, j) is stored\n    at index j * rows + i in the flattened vector.\n\n    This is a fundamental array manipulation operation that combines multiple\n    1D arrays into a single 2D structure, useful for constructing matrices\n    from column vectors.\n-/\n\n/-  Specification: column_stack creates a 2D array (as flattened vector) where\n    each input array becomes a column.\n\n    Precondition: cols > 0 (at least one input array)\n    Postcondition: \n    - The result contains all elements from the input arrays\n    - Elements are arranged in column-major order\n    - The j-th column of the result contains all elements from arrays[j]\n    - For 0 \u2264 i < rows and 0 \u2264 j < cols, the element at position (i,j)\n      in the 2D view equals arrays[j][i] and is stored at index j*rows + i\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def column_stack {rows cols : Nat} (arrays : Vector (Vector Float rows) cols) : \n    Id (Vector Float (rows * cols)) :=\n  sorry", "vc-theorems": "theorem column_stack_spec {rows cols : Nat} (arrays : Vector (Vector Float rows) cols) \n    (h_cols : cols > 0) :\n    \u2983\u231ccols > 0\u231d\u2984\n    column_stack arrays\n    \u2983\u21d3result => \u231c\u2200 (i : Fin rows) (j : Fin cols), \n                  result.get \u27e8j.val * rows + i.val, sorry\u27e9 = (arrays.get j).get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_concatenate", "vc-description": "/- \n{\n  \"name\": \"numpy.concatenate\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Join a sequence of arrays along an existing axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html\",\n  \"doc\": \"Join a sequence of arrays along an existing axis.\\n\\nParameters\\n----------\\na1, a2, ... : sequence of array_like\\n    The arrays must have the same shape, except in the dimension\\n    corresponding to `axis` (the first, by default).\\naxis : int, optional\\n    The axis along which the arrays will be joined. If axis is None,\\n    arrays are flattened before use. Default is 0.\\nout : ndarray, optional\\n    If provided, the destination to place the result. The shape must be\\n    correct, matching that of what concatenate would have returned if no\\n    out argument were specified.\\ndtype : str or dtype\\n    If provided, the destination array will have this dtype. Cannot be\\n    provided together with `out`.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\\n\\nReturns\\n-------\\nres : ndarray\\n    The concatenated array.\\n\\nExamples\\n--------\\n>>> a = np.array([[1, 2], [3, 4]])\\n>>> b = np.array([[5, 6]])\\n>>> np.concatenate((a, b), axis=0)\\narray([[1, 2],\\n       [3, 4],\\n       [5, 6]])\\n>>> np.concatenate((a, b.T), axis=1)\\narray([[1, 2, 5],\\n       [3, 4, 6]])\\n>>> np.concatenate((a, b), axis=None)\\narray([1, 2, 3, 4, 5, 6])\",\n  \"signature\": \"numpy.concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting='same_kind')\",\n  \"source_location\": \"C implementation in numpy/_core/src/multiarray/multiarraymodule.c\"\n}\n-/\n\n/-  numpy.concatenate: Join a sequence of arrays along an existing axis.\n\n    For 1D arrays, concatenates two vectors end-to-end to produce a single \n    vector containing all elements from both input vectors in order.\n\n    The result vector has size n + m where n and m are the sizes of the \n    input vectors.\n-/\n\n/-  Specification: concatenate joins two vectors preserving all elements in order.\n\n    Precondition: True (no special preconditions for concatenation)\n    Postcondition: \n    - First n elements of result are from vector a\n    - Next m elements of result are from vector b  \n    - Result has size n + m\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def concatenate {n m : Nat} (a : Vector Float n) (b : Vector Float m) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem concatenate_spec {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    concatenate a b\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get \u27e8i.val, by omega\u27e9 = a.get i) \u2227\n                 (\u2200 j : Fin m, result.get \u27e8n + j.val, by omega\u27e9 = b.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_copyto", "vc-description": "/- \n{\n  \"name\": \"numpy.copyto\",\n  \"category\": \"Basic Operations\",\n  \"description\": \"Copies values from one array to another, broadcasting as necessary\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.copyto.html\",\n  \"doc\": \"Copies values from one array to another, broadcasting as necessary.\\n\\nParameters\\n----------\\ndst : ndarray\\n    The array into which values are copied.\\nsrc : array_like\\n    The array from which values are copied.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur when copying.\\nwhere : array_like of bool, optional\\n    A boolean array which is broadcasted to match the dimensions of dst,\\n    and selects elements to copy from src to dst wherever it contains the value True.\\n\\nExamples\\n--------\\n>>> import numpy as np\\n>>> A = np.array([4, 5, 6])\\n>>> B = [1, 2, 3]\\n>>> np.copyto(A, B)\\n>>> A\\narray([1, 2, 3])\",\n  \"source_location\": \"C implementation in numpy/_core/src/multiarray/multiarraymodule.c\",\n  \"signature\": \"numpy.copyto(dst, src, casting='same_kind', where=True)\"\n}\n-/\n\n/-  Copies values from one vector to another, with optional conditional copying using a boolean mask -/\n\n/-  Specification: copyto copies elements from src to dst where the mask is true, \n    preserving dst elements where the mask is false -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def copyto {n : Nat} {T : Type} (dst : Vector T n) (src : Vector T n) (mask : Vector Bool n) : Id (Vector T n) :=\n  sorry", "vc-theorems": "theorem copyto_spec {n : Nat} {T : Type} (dst : Vector T n) (src : Vector T n) (mask : Vector Bool n) :\n    \u2983\u231cTrue\u231d\u2984\n    copyto dst src mask\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = if mask.get i then src.get i else dst.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_delete", "vc-description": "/-  numpy.delete: Return a new array with sub-arrays along an axis deleted.\n\n    For a one dimensional array, this returns those entries not returned by\n    arr[obj]. The function removes elements at the specified index and\n    returns a new array with the remaining elements.\n\n    This specification handles the 1D case where we delete a single element\n    at a specified index from a vector.\n-/\n\n/-  Specification: numpy.delete removes the element at the specified index and returns\n    a new vector containing all other elements in their original order.\n\n    The specification ensures:\n    1. The result has size n (one less than the input)\n    2. Elements before the deleted index maintain their positions\n    3. Elements after the deleted index are shifted left by one position\n\n    Mathematical properties:\n    - Order preservation: Elements maintain their relative order\n    - Deletion correctness: The element at the specified index is removed\n    - Shift property: Elements after the deleted index have their indices decreased by 1\n\n    Sanity checks:\n    - The result size is exactly one less than the input size\n    - No elements are duplicated or lost (except the deleted one)\n    - The deleted element does not appear in the result\n\n    Precondition: The array must have at least one element (enforced by type)\n\n    Postcondition:\n    - For indices i < index: result[i] = arr[i]\n    - For indices i \u2265 index: result[i] = arr[i+1]\n    - The element arr[index] does not appear in the result (unless duplicated elsewhere)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def delete {n : Nat} (arr : Vector Float (n + 1)) (index : Fin (n + 1)) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem delete_spec {n : Nat} (arr : Vector Float (n + 1)) (index : Fin (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    delete arr index\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, \n                   if h : i.val < index.val then \n                     result.get i = arr.get \u27e8i.val, by sorry\u27e9\n                   else \n                     result.get i = arr.get \u27e8i.val + 1, by sorry\u27e9) \u2227\n                 (\u2200 i : Fin (n + 1), i \u2260 index \u2192 \n                   \u2203 j : Fin n, result.get j = arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_dsplit", "vc-description": "/- \n{\n  \"name\": \"numpy.dsplit\",\n  \"category\": \"Splitting Arrays\",\n  \"description\": \"Split array into multiple sub-arrays along the 3rd axis (depth)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.dsplit.html\",\n  \"doc\": \"Split array into multiple sub-arrays along the 3rd axis (depth).\\n\\nPlease refer to the `split` documentation. `dsplit` is equivalent\\nto `split` with ``axis=2``, the array is always split along the third\\naxis provided the array dimension is greater than or equal to 3.\\n\\nExamples\\n--------\\n>>> x = np.arange(16.0).reshape(2, 2, 4)\\n>>> x\\narray([[[ 0.,  1.,  2.,  3.],\\n        [ 4.,  5.,  6.,  7.]],\\n       [[ 8.,  9., 10., 11.],\\n        [12., 13., 14., 15.]]])\\n>>> np.dsplit(x, 2)\\n[array([[[ 0.,  1.],\\n        [ 4.,  5.]],\\n       [[ 8.,  9.],\\n        [12., 13.]]]),\\n array([[[ 2.,  3.],\\n        [ 6.,  7.]],\\n       [[10., 11.],\\n        [14., 15.]]])]\\n>>> np.dsplit(x, np.array([3, 6]))\\n[array([[[ 0.,  1.,  2.],\\n        [ 4.,  5.,  6.]],\\n       [[ 8.,  9., 10.],\\n        [12., 13., 14.]]]),\\n array([[[ 3.],\\n        [ 7.]],\\n       [[11.],\\n        [15.]]]),\\n array([], shape=(2, 2, 0), dtype=float64)]\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.dsplit(ary, indices_or_sections)\"\n}\n-/\n\n/-  Split a 1D vector into equal sections (simplified version of dsplit).\n\n    Since dsplit operates on the 3rd axis of 3D arrays, this simplified version\n    demonstrates the splitting behavior on a 1D vector. The actual dsplit would\n    work on nested Vector structures representing 3D arrays.\n\n    This function divides a vector into k equal sections, where k must divide\n    the length of the vector evenly. Returns a list of vectors.\n-/\n\n/-  Specification: dsplit divides a vector into equal sections.\n\n    Precondition: sections = k and k > 0 (array size must be k * n)\n    Postcondition: Returns k sub-vectors, each of size n. The i-th sub-vector\n                   contains elements from positions i*n to (i+1)*n-1 of the \n                   original array.\n\n    Mathematical property: Concatenating all sub-vectors in order reconstructs\n                          the original vector.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def dsplit {n k : Nat} (arr : Vector Float (k * n)) (sections : Nat) \n  (h : sections = k \u2227 k > 0) : Id (List (Vector Float n)) :=\n  sorry", "vc-theorems": "theorem dsplit_spec {n k : Nat} (arr : Vector Float (k * n))\n  (h : k > 0) :\n  \u2983\u231ck > 0\u231d\u2984\n  dsplit arr k \u27e8rfl, h\u27e9\n  \u2983\u21d3result => \u231cresult.length = k \u2227\n              \u2200 i : Fin k, \u2203 sub \u2208 result,\n                \u2200 j : Fin n, sub.get j = arr.get \u27e8i.val * n + j.val, by\n                  have h1 : i.val < k := i.isLt\n                  have h2 : j.val < n := j.isLt\n                  calc i.val * n + j.val\n                    < i.val * n + n := Nat.add_lt_add_left h2 _\n                    _ = (i.val + 1) * n := by rw [Nat.add_mul, Nat.one_mul]\n                    _ \u2264 k * n := Nat.mul_le_mul_right _ (Nat.succ_le_of_lt h1)\n                \u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_dstack", "vc-description": "/- \n{\n  \"name\": \"numpy.dstack\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Stack arrays in sequence depth wise (along third axis)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.dstack.html\",\n  \"doc\": \"Stack arrays in sequence depth wise (along third axis).\\n\\nThis is equivalent to concatenation along the third axis after 2-D arrays\\nof shape \\`(M,N)\\` have been reshaped to \\`(M,N,1)\\` and 1-D arrays of shape\\n\\`(N,)\\` have been reshaped to \\`(1,N,1)\\`. Rebuilds arrays divided by\\n\\`dsplit\\`.\\n\\nThis function makes most sense for arrays with up to 3 dimensions. For\\ninstance, for pixel-data with a height (first axis), width (second axis),\\nand r/g/b channels (third axis). The functions \\`concatenate\\`, \\`stack\\` and\\n\\`block\\` provide more general stacking and concatenation operations.\\n\\nParameters\\n----------\\ntup : sequence of arrays\\n    The arrays must have the same shape along all but the third axis.\\n    1-D or 2-D arrays must have the same shape.\\n\\nReturns\\n-------\\nstacked : ndarray\\n    The array formed by stacking the given arrays, will be at least 3-D.\\n\\nExamples\\n--------\\n>>> a = np.array((1,2,3))\\n>>> b = np.array((2,3,4))\\n>>> np.dstack((a,b))\\narray([[[1, 2],\\n        [2, 3],\\n        [3, 4]]])\\n>>> a = np.array([[1],[2],[3]])\\n>>> b = np.array([[2],[3],[4]])\\n>>> np.dstack((a,b))\\narray([[[1, 2]],\\n       [[2, 3]],\\n       [[3, 4]]])\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.dstack(tup)\"\n}\n-/\n\n/-  numpy.dstack: Stack arrays in sequence depth wise (along third axis).\n\n    For a sequence of 1D arrays (vectors), this function stacks them along a new third axis,\n    creating a 3D array. Each input vector becomes a \"slice\" in the depth dimension.\n\n    For 1D inputs of length n, the output shape is (1, n, k) where k is the number of arrays.\n    This is because 1D arrays are first reshaped to (1, n) then stacked along axis 2.\n\n    The result is always at least 3-dimensional.\n-/\n\n/-  Specification: numpy.dstack stacks 1D arrays along the third axis.\n\n    For k+1 input vectors each of length n:\n    - The output has shape (1, n, k+1)\n    - Element at position [0][i][j] equals arrays[j][i]\n\n    This specification captures the core behavior where each input vector\n    contributes one \"layer\" in the depth dimension of the output.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_dstack {k n : Nat} (arrays : Vector (Vector Float n) (k + 1)) : \n    Id (Vector (Vector (Vector Float (k + 1)) n) 1) :=\n  sorry", "vc-theorems": "theorem numpy_dstack_spec {k n : Nat} (arrays : Vector (Vector Float n) (k + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_dstack arrays\n    \u2983\u21d3result => \u231c\n      -- The outer dimension has size 1\n      result.toList.length = 1 \u2227\n      -- For the single element at index 0, it has n rows\n      (result.get \u27e80, by simp\u27e9).toList.length = n \u2227\n      -- Each row has k+1 elements (depth dimension)\n      (\u2200 i : Fin n, ((result.get \u27e80, by simp\u27e9).get i).toList.length = k + 1) \u2227\n      -- Elements are correctly positioned: result[0][i][j] = arrays[j][i]\n      (\u2200 i : Fin n, \u2200 j : Fin (k + 1), \n        ((result.get \u27e80, by simp\u27e9).get i).get j = (arrays.get j).get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_expand_dims", "vc-description": "/- \n{\n  \"name\": \"numpy.expand_dims\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Expand the shape of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.expand_dims.html\",\n  \"doc\": \"Expand the shape of an array.\\n\\nInsert a new axis that will appear at the `axis` position in the expanded\\narray shape.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxis : int or tuple of ints\\n    Position in the expanded axes where the new axis (or axes) is placed.\\n\\nReturns\\n-------\\nresult : ndarray\\n    View of `a` with the number of dimensions increased.\\n\\nExamples\\n--------\\n>>> x = np.array([1, 2])\\n>>> x.shape\\n(2,)\\n>>> y = np.expand_dims(x, axis=0)\\n>>> y\\narray([[1, 2]])\\n>>> y.shape\\n(1, 2)\\n>>> y = np.expand_dims(x, axis=1)\\n>>> y\\narray([[1],\\n       [2]])\\n>>> y.shape\\n(2, 1)\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.expand_dims(a, axis)\"\n}\n-/\n\n/-  Expand the shape of a vector by inserting a new axis at the specified position.\n    axis=0 creates a row vector (1\u00d7n), axis=1 creates a column vector (n\u00d71). -/\n\n/-  Specification: expand_dims preserves all elements and adds a new dimension at the specified axis.\n    The function creates a view with increased dimensions while maintaining element order and values. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents the result of expanding dimensions of a vector.\n    For axis=0, we get a 1\u00d7n matrix (row vector).\n    For axis=1, we get an n\u00d71 matrix (column vector). -/\ninductive ExpandedVector (T : Type) (n : Nat) where\n  | rowVector : Vector T n \u2192 ExpandedVector T n      -- axis=0: shape (1, n)\n  | columnVector : Vector T n \u2192 ExpandedVector T n   -- axis=1: shape (n, 1)", "vc-helpers": "", "vc-definitions": "def expand_dims {n : Nat} (a : Vector T n) (axis : Nat) : Id (ExpandedVector T n) :=\n  sorry", "vc-theorems": "theorem expand_dims_spec {n : Nat} (a : Vector T n) (axis : Nat) (h_axis : axis \u2264 1) :\n    \u2983\u231caxis \u2264 1\u231d\u2984\n    expand_dims a axis\n    \u2983\u21d3result => \u231cmatch result with\n                | ExpandedVector.rowVector v => axis = 0 \u2227 v = a\n                | ExpandedVector.columnVector v => axis = 1 \u2227 v = a\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_flip", "vc-description": "/- \n{\n  \"name\": \"numpy.flip\",\n  \"category\": \"Rearranging Elements\",\n  \"description\": \"Reverse the order of elements in an array along the given axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.flip.html\",\n  \"doc\": \"Reverse the order of elements in an array along the given axis.\\n\\nThe shape of the array is preserved, but the elements are reordered.\\n\\nParameters\\n----------\\nm : array_like\\n    Input array.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which to flip over. The default,\\n    axis=None, will flip over all of the axes of the input array.\\n    If axis is negative it counts from the last to the first axis.\\n\\n    If axis is a tuple of ints, flipping is performed on all of the axes\\n    specified in the tuple.\\n\\nReturns\\n-------\\nout : array_like\\n    A view of \\`m\\` with the entries of axis reversed. Since a view is\\n    returned, this operation is done in constant time.\\n\\nExamples\\n--------\\n>>> A = np.arange(8).reshape((2,2,2))\\n>>> A\\narray([[[0, 1],\\n        [2, 3]],\\n       [[4, 5],\\n        [6, 7]]])\\n>>> np.flip(A, 0)\\narray([[[4, 5],\\n        [6, 7]],\\n       [[0, 1],\\n        [2, 3]]])\\n>>> np.flip(A, 1)\\narray([[[2, 3],\\n        [0, 1]],\\n       [[6, 7],\\n        [4, 5]]])\\n>>> np.flip(A)\\narray([[[7, 6],\\n        [5, 4]],\\n       [[3, 2],\\n        [1, 0]]])\\n>>> np.flip(A, (0, 2))\\narray([[[5, 4],\\n        [7, 6]],\\n       [[1, 0],\\n        [3, 2]]])\\n>>> A = np.random.randn(3,4,5)\\n>>> np.all(np.flip(A,2) == A[:,:,::-1,...])\\nTrue\",\n  \"source_location\": \"numpy/lib/_function_base_impl.py\",\n  \"signature\": \"numpy.flip(m, axis=None)\"\n}\n-/\n\n/-  Reverses the order of elements in a vector (1D case of numpy.flip).\n\n    This function reverses the order of all elements in the input vector.\n    For a vector [a, b, c, d], it returns [d, c, b, a].\n\n    In the general n-dimensional case, numpy.flip can reverse along specific axes,\n    but this specification focuses on the 1D case where all elements are reversed. -/\n\n/-  Specification: numpy_flip reverses the order of elements in the vector.\n\n    Mathematical properties:\n    1. Element mapping: The element at position i in the result equals the element \n       at position (n-1-i) in the input\n    2. Involution property: Applying numpy_flip twice returns the original vector\n    3. Size preservation: The output has the same size as the input (enforced by types)\n\n    Sanity checks:\n    - For n=0 (empty vector), returns empty vector\n    - For n=1 (single element), returns the same vector\n    - For n>1, first element becomes last, last becomes first -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_flip {n : Nat} (m : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_flip_spec {n : Nat} (m : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_flip m\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = m.get \u27e8n - 1 - i.val, by\n      have h : i.val < n := i.isLt\n      omega\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_fliplr", "vc-description": "/- \n{\n  \"name\": \"numpy.fliplr\",\n  \"category\": \"Rearranging Elements\",\n  \"description\": \"Reverse the order of elements along axis 1 (left/right)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fliplr.html\",\n  \"doc\": \"Reverse the order of elements along axis 1 (left/right).\\n\\nFor a 2-D array, this flips the entries in each row in the left/right\\ndirection. Columns are preserved, but appear in a different order than\\nbefore.\\n\\nParameters\\n----------\\nm : array_like\\n    Input array, must be at least 2-D.\\n\\nReturns\\n-------\\nf : ndarray\\n    A view of `m` with the columns reversed. Since a view\\n    is returned, this operation is :math:`\\\\mathcal O(1)`.\\n\\nExamples\\n--------\\n>>> A = np.diag([1.,2.,3.])\\n>>> A\\narray([[1.,  0.,  0.],\\n       [0.,  2.,  0.],\\n       [0.,  0.,  3.]])\\n>>> np.fliplr(A)\\narray([[0.,  0.,  1.],\\n       [0.,  2.,  0.],\\n       [3.,  0.,  0.]])\\n\\n>>> A = np.random.randn(2,3,5)\\n>>> np.all(np.fliplr(A) == A[:,::-1,...])\\nTrue\",\n  \"source_location\": \"numpy/lib/_twodim_base_impl.py\",\n  \"signature\": \"numpy.fliplr(m)\"\n}\n-/\n\n/-  Reverses the order of columns in a 2D matrix (left/right flip).\n    For a matrix with shape (rows \u00d7 cols), this operation reverses the order \n    of elements along each row, effectively flipping the matrix horizontally. -/\n\n/-  Specification: fliplr reverses the column order in each row of the matrix.\n    The element at position (i, j) in the input matrix appears at position \n    (i, cols-1-j) in the output matrix. This captures the mathematical property\n    that columns are reversed while rows remain in the same order.\n\n    Sanity checks:\n    1. The output has the same dimensions as the input (enforced by type)\n    2. Each row contains the same elements, just in reversed order\n    3. For matrices with odd number of columns, the middle column stays in place\n\n    Mathematical properties:\n    1. Element mapping: For all valid indices i and j, there exists a corresponding\n       index j' such that output[i,j] = input[i,j'] where j' = cols-1-j\n    2. Row preservation: Each row contains exactly the same elements as the input\n    3. Column reversal: The first column becomes the last, second becomes second-to-last, etc. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fliplr {rows cols : Nat} (m : Vector (Vector Float cols) rows) : Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem fliplr_spec {rows : Nat} {cols : Nat} (m : Vector (Vector Float (cols + 1)) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    fliplr m\n    \u2983\u21d3result => \u231c(\u2200 i : Fin rows, \u2200 j : Fin (cols + 1), \n                   \u2203 k : Fin (cols + 1), \n                   (result.get i).get j = (m.get i).get k \u2227 \n                   j.val + k.val = cols) \u2227\n                 (\u2200 i : Fin rows, \n                   (\u2200 x : Float, (\u2203 j : Fin (cols + 1), (m.get i).get j = x) \u2194 \n                                 (\u2203 j : Fin (cols + 1), (result.get i).get j = x))) \u2227\n                 (cols % 2 = 0 \u2192 \n                   \u2200 i : Fin rows, \n                   \u2203 mid : Fin (cols + 1),\n                   2 * mid.val = cols \u2227\n                   (result.get i).get mid = (m.get i).get mid)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_flipud", "vc-description": "/- \n{\n  \"name\": \"numpy.flipud\",\n  \"category\": \"Rearranging Elements\",\n  \"description\": \"Reverse the order of elements along axis 0 (up/down)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.flipud.html\",\n  \"doc\": \"Reverse the order of elements along axis 0 (up/down).\\n\\nFor a 2-D array, this flips the entries in each column in the up/down\\ndirection. Rows are preserved, but appear in a different order than before.\\n\\nParameters\\n----------\\nm : array_like\\n    Input array.\\n\\nReturns\\n-------\\nout : array_like\\n    A view of \\`m\\` with the rows reversed. Since a view is\\n    returned, this operation is :math:\\`\\\\\\\\mathcal O(1)\\`.\\n\\nExamples\\n--------\\n>>> A = np.diag([1.0, 2, 3])\\n>>> A\\narray([[1.,  0.,  0.],\\n       [0.,  2.,  0.],\\n       [0.,  0.,  3.]])\\n>>> np.flipud(A)\\narray([[0.,  0.,  3.],\\n       [0.,  2.,  0.],\\n       [1.,  0.,  0.]])\\n\\n>>> A = np.random.randn(2,3,5)\\n>>> np.all(np.flipud(A) == A[::-1,...])\\nTrue\\n\\n>>> np.flipud([1,2])\\narray([2, 1])\",\n  \"source_location\": \"numpy/lib/_twodim_base_impl.py\",\n  \"signature\": \"numpy.flipud(m)\"\n}\n-/\n\n/-  numpy.flipud: Reverse the order of elements along axis 0 (up/down).\n\n    For a 1D array, this reverses the entire array.\n    For 2D arrays, this reverses the order of rows while preserving \n    the elements within each row.\n\n    Returns a view of the input array with elements reversed along axis 0.\n-/\n\n/-  Specification: flipud reverses the order of elements in the vector.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = m[n-1-i]\n\n    This specification captures both the sanity check (result has same size)\n    and the mathematical property (elements are reversed).\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def flipud {n : Nat} (m : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem flipud_spec {n : Nat} (m : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    flipud m\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = m.get \u27e8n - 1 - i.val, by \n                   have h : i.val < n := i.isLt\n                   omega\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_hsplit", "vc-description": "/- \n{\n  \"name\": \"numpy.hsplit\",\n  \"category\": \"Splitting Arrays\",\n  \"description\": \"Split an array into multiple sub-arrays horizontally (column-wise)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.hsplit.html\",\n  \"doc\": \"Split an array into multiple sub-arrays horizontally (column-wise).\\n\\nPlease refer to the `split` documentation. `hsplit` is equivalent\\nto `split` with ``axis=1``, the array is always split along the second\\naxis except for 1-D arrays, where it is split at ``axis=0``.\\n\\nExamples\\n--------\\n>>> x = np.arange(16.0).reshape(4, 4)\\n>>> x\\narray([[ 0.,  1.,  2.,  3.],\\n       [ 4.,  5.,  6.,  7.],\\n       [ 8.,  9., 10., 11.],\\n       [12., 13., 14., 15.]])\\n>>> np.hsplit(x, 2)\\n[array([[ 0.,  1.],\\n       [ 4.,  5.],\\n       [ 8.,  9.],\\n       [12., 13.]]),\\n array([[ 2.,  3.],\\n       [ 6.,  7.],\\n       [10., 11.],\\n       [14., 15.]])]\\n>>> np.hsplit(x, np.array([3, 6]))\\n[array([[ 0.,  1.,  2.],\\n       [ 4.,  5.,  6.],\\n       [ 8.,  9., 10.],\\n       [12., 13., 14.]]),\\n array([[ 3.],\\n       [ 7.],\\n       [11.],\\n       [15.]]),\\n array([], shape=(4, 0), dtype=float64)]\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.hsplit(ary, indices_or_sections)\"\n}\n-/\n\n/-  Split a 1D array into multiple sub-arrays horizontally.\n    For simplicity, we focus on the 1D case where the array is split into \n    k equal parts. In numpy, hsplit on 1D arrays is equivalent to split with axis=0. -/\n\n/-  Specification: hsplit divides a 1D array into k equal sub-arrays.\n    Each sub-array has n/k elements. The i-th sub-array contains elements \n    from index i*(n/k) to (i+1)*(n/k)-1 of the original array.\n\n    Mathematical properties:\n    1. The concatenation of all sub-arrays equals the original array\n    2. Each sub-array has exactly n/k elements\n    3. Elements are distributed in order without overlapping -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hsplit {n k : Nat} (arr : Vector Float n) \n    (h_divides : k > 0 \u2227 n % k = 0) : \n    Id (Vector (Vector Float (n / k)) k) :=\n  sorry", "vc-theorems": "theorem hsplit_spec {n k : Nat} (arr : Vector Float n) \n    (h_divides : k > 0 \u2227 n % k = 0) :\n    \u2983\u231ck > 0 \u2227 n % k = 0\u231d\u2984\n    hsplit arr h_divides\n    \u2983\u21d3result => \u231c(\u2200 (part_idx : Fin k) (elem_idx : Fin (n / k)),\n                  (result.get part_idx).get elem_idx = \n                  arr.get \u27e8part_idx.val * (n / k) + elem_idx.val, by sorry\u27e9) \u2227\n                 (\u2200 i : Fin n, \u2203 (p : Fin k) (e : Fin (n / k)), \n                  i.val = p.val * (n / k) + e.val \u2227\n                  arr.get i = (result.get p).get e)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_hstack", "vc-description": "/-  numpy.hstack: Stack arrays in sequence horizontally (column wise).\n\n    For 1D arrays, hstack stacks arrays horizontally by concatenating them\n    along the first axis. This is equivalent to concatenation for 1D arrays.\n\n    This version handles stacking two 1D arrays. The general version would\n    handle a sequence of arrays (tup parameter in NumPy).\n\n    Note: For higher dimensional arrays, hstack would concatenate along the\n    second axis, but this specification focuses on the 1D case.\n-/\n\n/-  Specification: numpy.hstack concatenates 1D arrays horizontally.\n\n    For 1D arrays, horizontal stacking means concatenating them end-to-end,\n    which is the same behavior as numpy.concatenate.\n\n    Precondition: True (no special preconditions for 1D concatenation)\n\n    Postcondition: \n    - The result has size n + m\n    - First n elements come from array a\n    - Next m elements come from array b\n    - The order of elements is preserved from both input arrays\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hstack {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem hstack_spec {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    hstack a b\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get (i.castAdd m) = a.get i) \u2227\n                (\u2200 j : Fin m, result.get (j.natAdd n) = b.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_insert", "vc-description": "/-  numpy.insert: Insert values along the given axis before the given indices.\n\n    Creates a new vector with values inserted at specified positions. For the 1D case,\n    values are inserted before the given index position, shifting subsequent elements.\n\n    When inserting a single value at position i into a vector of length n,\n    the result has length n+1 where:\n    - Elements before position i remain unchanged\n    - The new value is at position i\n    - Elements from position i onward are shifted by one\n\n    This specification focuses on single value insertion. The actual NumPy function\n    supports multiple insertions and various index specifications, but for formal\n    verification we start with the simplest case.\n-/\n\n/-  Specification: numpy.insert creates a new vector with the value inserted at the specified index.\n\n    Precondition: The index is valid (enforced by type system via Fin (n + 1))\n\n    Postcondition: \n    1. **Preservation**: Elements before the insertion point are preserved at their original indices\n    2. **Insertion**: The new value is placed exactly at the specified index\n    3. **Shifting**: Elements at or after the insertion point are shifted right by one position\n    4. **Size**: The result has exactly one more element than the input\n\n    Mathematical properties:\n    - For all i < idx: result[i] = arr[i]\n    - result[idx] = value\n    - For all i > idx: result[i] = arr[i-1]\n\n    Additional properties (sanity checks):\n    - The operation is deterministic (same inputs produce same output)\n    - The operation preserves the relative order of existing elements\n    - No elements from the original array are lost or duplicated\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_insert {n : Nat} (arr : Vector \u03b1 n) (idx : Fin (n + 1)) (value : \u03b1) : Id (Vector \u03b1 (n + 1)) :=\n  sorry", "vc-theorems": "theorem numpy_insert_spec {n : Nat} (arr : Vector \u03b1 n) (idx : Fin (n + 1)) (value : \u03b1) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_insert arr idx value\n    \u2983\u21d3result => \u231c-- Elements before insertion point are preserved\n                 (\u2200 i : Fin (n + 1), i < idx \u2192 \n                   \u2203 (h : i.val < n), result.get i = arr.get \u27e8i.val, h\u27e9) \u2227 \n                 -- The new value is at the specified index\n                 (result.get idx = value) \u2227\n                 -- Elements after insertion point are shifted\n                 (\u2200 i : Fin (n + 1), idx < i \u2192 \n                   \u2203 (h : i.val - 1 < n), result.get i = arr.get \u27e8i.val - 1, h\u27e9) \u2227\n                 -- Sanity check: the result contains all original elements plus the new value\n                 (\u2200 j : Fin n, \u2203 i : Fin (n + 1), \n                   (i < idx \u2227 i.val = j.val \u2227 result.get i = arr.get j) \u2228 \n                   (idx < i \u2227 i.val = j.val + 1 \u2227 result.get i = arr.get j))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_matrix_transpose", "vc-description": "/- \n{\n  \"name\": \"numpy.matrix_transpose\",\n  \"category\": \"Transpose Operations\",\n  \"description\": \"Transposes the matrix (array-like) using NumPy\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.matrix_transpose.html\",\n  \"doc\": \"Transposes a matrix (array-like) using NumPy.\\n\\nParameters\\n----------\\nx : array_like with last two dimensions forming a matrix\\n    Input array having shape (..., M, N) and whose last two dimensions form \\n    matrices that are to be transposed.\\n\\nReturns\\n-------\\nout : ndarray\\n    An array with shape (..., N, M) whose last two dimensions form the \\n    transposed matrices.\\n\\nNotes\\n-----\\nUnlike np.transpose, this function only transposes the last two dimensions \\nand leaves other dimensions in their original order. It is equivalent to \\nnp.swapaxes(x, -1, -2).\\n\\nExamples\\n--------\\n>>> x = np.ones((2, 3, 4))\\n>>> np.matrix_transpose(x).shape\\n(2, 4, 3)\\n>>> x = np.ones((5, 4, 3, 2))\\n>>> np.matrix_transpose(x).shape\\n(5, 4, 2, 3)\",\n  \"source_location\": \"numpy/_core/defmatrix.py\",\n  \"signature\": \"numpy.matrix_transpose(x)\"\n}\n-/\n\n/-  Transposes a matrix by swapping rows and columns.\n    For a matrix with shape (m, n), returns a matrix with shape (n, m)\n    where result[i, j] = input[j, i] -/\n\n/-  Specification: matrix_transpose swaps rows and columns, producing a transposed matrix\n    where the element at position (i, j) in the result equals the element at position (j, i)\n    in the input. The result has dimensions swapped: an m\u00d7n matrix becomes n\u00d7m. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def matrixTranspose {m n : Nat} (mat : Vector (Vector Float n) m) : Id (Vector (Vector Float m) n) :=\n  sorry", "vc-theorems": "theorem matrixTranspose_spec {m n : Nat} (mat : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    matrixTranspose mat\n    \u2983\u21d3result => \u231c-- Dimension check: result is n\u00d7m when input is m\u00d7n\n                 (result.size = n) \u2227\n                 (\u2200 i : Fin n, (result.get i).size = m) \u2227\n                 -- Transpose property: result[i][j] = mat[j][i]\n                 (\u2200 i : Fin n, \u2200 j : Fin m, (result.get i).get j = (mat.get j).get i) \u2227\n                 -- Mathematical properties of transpose\n                 -- Property 1: Transpose is involutive (transpose of transpose is identity)\n                 (matrixTranspose result = mat) \u2227\n                 -- Property 2: Matrix equality preserved under transpose\n                 (\u2200 mat2 : Vector (Vector Float n) m,\n                   (\u2200 i : Fin m, \u2200 j : Fin n, (mat.get i).get j = (mat2.get i).get j) \u2192\n                   (\u2200 i : Fin n, \u2200 j : Fin m, (result.get i).get j = ((matrixTranspose mat2).get i).get j))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_moveaxis", "vc-description": "/- \n{\n  \"name\": \"numpy.moveaxis\",\n  \"category\": \"Transpose Operations\",\n  \"description\": \"Move axes of an array to new positions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.moveaxis.html\",\n  \"doc\": \"Move axes of an array to new positions.\\n\\nOther axes remain in their original order.\\n\\nParameters\\n----------\\na : np.ndarray\\n    The array whose axes should be reordered.\\nsource : int or sequence of int\\n    Original positions of the axes to move. These must be unique.\\ndestination : int or sequence of int\\n    Destination positions for each of the original axes. These must also be unique.\\n\\nReturns\\n-------\\nresult : np.ndarray\\n    Array with moved axes. This array is a view of the input array.\\n\\nExamples\\n--------\\n>>> x = np.zeros((3, 4, 5))\\n>>> np.moveaxis(x, 0, -1).shape\\n(4, 5, 3)\\n>>> np.moveaxis(x, -1, 0).shape\\n(5, 3, 4)\\n>>> np.moveaxis(x, [0, 1], [-1, -2]).shape\\n(5, 4, 3)\\n>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\\n(5, 4, 3)\",\n  \"source_location\": \"numpy/_core/numeric.py\",\n  \"signature\": \"numpy.moveaxis(a, source, destination)\"\n}\n-/\n\n/-  Move axes in a 1D vector (simplified version).\n    For 1D arrays, moveaxis with source=0 and destination=0 returns the array unchanged.\n    This captures the core mathematical property that moving an axis to itself is identity. -/\n\n/-  Specification: moveaxis preserves all elements and their values.\n    For 1D arrays, moveaxis is always the identity function since there's only one axis.\n    This specification captures several mathematical properties:\n    1. Element preservation: all values remain unchanged\n    2. Size preservation: the shape is maintained\n    3. Identity property: moving axis 0 to position 0 is identity\n    4. Order preservation: for 1D arrays, element order is maintained -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def moveaxis {n : Nat} (a : Vector Float n) (source dest : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem moveaxis_spec {n : Nat} (a : Vector Float n) (source dest : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    moveaxis a source dest\n    \u2983\u21d3result => \n      \u231c-- Core property: moveaxis on 1D array is identity\n       (\u2200 i : Fin n, result.get i = a.get i) \u2227\n       -- Sanity check: size is preserved\n       result.size = a.size \u2227\n       -- Mathematical property: for 1D arrays, result equals input\n       result = a \u2227\n       -- Property: for any valid indices i < j, if a[i] \u2264 a[j], then result[i] \u2264 result[j]\n       -- This shows that relative ordering is preserved\n       (\u2200 i j : Fin n, i < j \u2192 a.get i \u2264 a.get j \u2192 result.get i \u2264 result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_ndim", "vc-description": "/- \n{\n  \"name\": \"numpy.ndim\",\n  \"category\": \"Basic Operations\",\n  \"description\": \"Return the number of dimensions of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ndim.html\",\n  \"doc\": \"Return the number of dimensions of an array.\\n\\nParameters\\n----------\\na : array_like\\n    Input array. If it is not already an ndarray, a conversion is attempted.\\n\\nReturns\\n-------\\nnumber_of_dimensions : int\\n    The number of dimensions in \\`a\\`. Scalars are zero-dimensional.\\n\\nExamples\\n--------\\n>>> np.ndim([[1,2,3],[4,5,6]])\\n2\\n>>> np.ndim(np.array([[1,2,3],[4,5,6]]))\\n2\\n>>> np.ndim(1)\\n0\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.ndim(a)\"\n}\n-/\n\n/-  numpy.ndim: Return the number of dimensions of an array.\n\n    In our Vector-based framework, vectors are always 1-dimensional.\n    This function returns 1 for any vector input, representing the fact\n    that Vector T n is a 1D array with n elements.\n\n    Note: In NumPy, scalars are 0-dimensional, but in our framework,\n    we represent them as Vector T 1, so this always returns 1.\n-/\n\n/-  Specification: numpy.ndim returns the number of dimensions, which is always 1 for vectors.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The result is always 1 since Vector \u03b1 n represents a 1-dimensional array\n\n    This specification captures the mathematical property that all vectors in our\n    framework are 1-dimensional arrays, regardless of their element type or size.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ndim {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) : Id Nat :=\n  sorry", "vc-theorems": "theorem ndim_spec {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    ndim a\n    \u2983\u21d3result => \u231cresult = 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_ravel", "vc-description": "/- \n{\n  \"name\": \"numpy.ravel\",\n  \"category\": \"Shape Operations\",\n  \"description\": \"Return a contiguous flattened array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ravel.html\",\n  \"doc\": \"Return a contiguous flattened array.\\n\\nA 1-D array, containing the elements of the input, is returned. A copy is\\nmade only if needed.\\n\\nParameters\\n----------\\na : array_like\\n    Input array. The elements in \\`a\\` are read in the order specified by\\n    \\`order\\`, and packed as a 1-D array.\\norder : {'C','F', 'A', 'K'}, optional\\n    The elements of \\`a\\` are read using this index order. 'C' means\\n    to index the elements in row-major, C-style order,\\n    with the last axis index changing fastest, back to the first\\n    axis index changing slowest. 'F' means to index the elements\\n    in column-major, Fortran-style order, with the\\n    first index changing fastest, and the last index changing\\n    slowest. Note that the 'C' and 'F' options take no account of\\n    the memory layout of the underlying array, and only refer to\\n    the order of axis indexing. 'A' means to read the elements in\\n    Fortran-like index order if \\`a\\` is Fortran *contiguous* in\\n    memory, C-like order otherwise. 'K' means to read the\\n    elements in the order they occur in memory, except for\\n    reversing the data when strides are negative. By default, 'C'\\n    index order is used.\\n\\nReturns\\n-------\\ny : array_like\\n    y is a contiguous 1-D array with the same type as the input.\\n\\nExamples\\n--------\\n>>> x = np.array([[1, 2, 3], [4, 5, 6]])\\n>>> np.ravel(x)\\narray([1, 2, 3, 4, 5, 6])\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.ravel(a, order='C')\"\n}\n-/\n\n/-  numpy.ravel: Return a contiguous flattened array.\n\n    For 1D arrays, ravel returns the input array unchanged since it's already\n    flat. This reflects numpy's behavior where raveling a 1D array has no effect.\n\n    For multi-dimensional arrays (not covered here), ravel would flatten them\n    into a 1D array following the specified order ('C' for row-major, 'F' for\n    column-major, etc.).\n-/\n\n/-  Specification: numpy.ravel returns the input vector unchanged for 1D arrays.\n\n    Precondition: True (no special preconditions for 1D ravel)\n    Postcondition: The result is identical to the input vector, maintaining\n                   all elements in their original order\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ravel {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ravel_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    ravel a\n    \u2983\u21d3result => \u231cresult = a\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_repeat", "vc-description": "/- \n{\n  \"name\": \"numpy.repeat\",\n  \"category\": \"Tiling Arrays\",\n  \"description\": \"Repeat elements of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.repeat.html\",\n  \"doc\": \"Repeat elements of an array.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\nrepeats : int or array of ints\\n    The number of repetitions for each element. \\`repeats\\` is broadcasted\\n    to fit the shape of the given axis.\\naxis : int, optional\\n    The axis along which to repeat values. By default, use the\\n    flattened input array, and return a flat output array.\\n\\nReturns\\n-------\\nrepeated_array : ndarray\\n    Output array which has the same shape as \\`a\\`, except along\\n    the given axis.\\n\\nExamples\\n--------\\n>>> np.repeat(3, 4)\\narray([3, 3, 3, 3])\\n>>> x = np.array([[1,2],[3,4]])\\n>>> np.repeat(x, 2)\\narray([1, 1, 2, 2, 3, 3, 4, 4])\\n>>> np.repeat(x, 3, axis=1)\\narray([[1, 1, 1, 2, 2, 2],\\n       [3, 3, 3, 4, 4, 4]])\\n>>> np.repeat(x, [1, 2], axis=0)\\narray([[1, 2],\\n       [3, 4],\\n       [3, 4]])\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.repeat(a, repeats, axis=None)\"\n}\n-/\n\n/-  Repeat elements of a vector a specified number of times.\n    Each element is repeated consecutively. -/\n\n/-  Specification: repeat creates a vector where each element from the input \n    appears consecutively 'repeats' times. The resulting vector has size n * repeats.\n\n    For a vector [a\u2080, a\u2081, ..., a\u2099\u208b\u2081] and repeats = r, the result is:\n    [a\u2080, a\u2080, ..., a\u2080, a\u2081, a\u2081, ..., a\u2081, ..., a\u2099\u208b\u2081, a\u2099\u208b\u2081, ..., a\u2099\u208b\u2081]\n     \\___r times___/  \\___r times___/       \\______r times______/\n\n    Mathematical properties:\n    1. Each element appears exactly 'repeats' times consecutively\n    2. The total size is n * repeats\n    3. Element at index i comes from input element at index \u230ai/repeats\u230b\n    4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def \u00abrepeat\u00bb {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) (repeats : Nat) : Id (Vector \u03b1 (n * repeats)) :=\n  sorry", "vc-theorems": "theorem repeat_spec {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) (repeats : Nat) (h_pos : repeats > 0) :\n    \u2983\u231crepeats > 0\u231d\u2984\n    \u00abrepeat\u00bb a repeats\n    \u2983\u21d3result => \u231c(\u2200 i : Fin (n * repeats), \n                   \u2203 (k : Fin n), \n                     i.val / repeats = k.val \u2227 \n                     result.get i = a.get k) \u2227\n                  (\u2200 k : Fin n, \u2200 j : Fin repeats,\n                   \u2203 (idx : Fin (n * repeats)),\n                     idx.val = k.val * repeats + j.val \u2227\n                     result.get idx = a.get k)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_reshape", "vc-description": "/- \n{\n  \"name\": \"numpy.reshape\",\n  \"category\": \"Shape Operations\",\n  \"description\": \"Gives a new shape to an array without changing its data\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.reshape.html\",\n  \"doc\": \"Gives a new shape to an array without changing its data.\\n\\nParameters\\n----------\\na : array_like\\n    Array to be reshaped.\\nshape : int or tuple of ints\\n    The new shape should be compatible with the original shape. If\\n    an integer, then the result will be a 1-D array of that length.\\n    One shape dimension can be -1. In this case, the value is\\n    inferred from the length of the array and remaining dimensions.\\norder : {'C', 'F', 'A'}, optional\\n    Read the elements of \\`a\\` using this index order, and place the\\n    elements into the reshaped array using this index order.  'C'\\n    means to read / write the elements using C-like index order,\\n    with the last axis index changing fastest, back to the first\\n    axis index changing slowest. 'F' means to read / write the\\n    elements using Fortran-like index order, with the first index\\n    changing fastest, and the last index changing slowest. Note that\\n    the 'C' and 'F' options take no account of the memory layout of\\n    the underlying array, and only refer to the order of indexing.\\n    'A' means to read / write the elements in Fortran-like index\\n    order if \\`a\\` is Fortran *contiguous* in memory, C-like order\\n    otherwise.\\nnewshape : int or tuple of ints, optional\\n    Deprecated since version 2.1: Use shape instead.\\ncopy : bool, optional\\n    If True, then the array data is copied. If None (the default),\\n    then the array may be copied or a view may be returned.\\n\\nReturns\\n-------\\nreshaped_array : ndarray\\n    This will be a new view object if possible; otherwise, it will\\n    be a copy.  Note there is no guarantee of the *memory layout* (C- or\\n    Fortran- contiguous) of the returned array.\\n\\nExamples\\n--------\\n>>> a = np.array([[1,2,3], [4,5,6]])\\n>>> np.reshape(a, 6)\\narray([1, 2, 3, 4, 5, 6])\\n>>> np.reshape(a, (3, -1))  # the unspecified value is inferred to be 2\\narray([[1, 2],\\n       [3, 4],\\n       [5, 6]])\",\n  \"signature\": \"numpy.reshape(a, /, shape=None, order='C', *, newshape=None, copy=None)\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\"\n}\n-/\n\n/-  Gives a new shape to an array without changing its data.\n\n    This implementation focuses on the most common case: reshaping a 1D array\n    to another 1D array with the same total number of elements. The elements\n    are preserved in the same linear order (C-order).\n\n    For simplicity, this specification handles only 1D to 1D reshaping where\n    the sizes are explicitly equal. More complex reshaping operations (like\n    multidimensional arrays or -1 inference) would require additional machinery.\n-/\n\n/-  Specification: reshape preserves all elements in their linear order.\n\n    The reshape operation creates a new vector with a different size parameter\n    but maintains the same elements in the same order. This is the fundamental\n    property of reshape - it's purely a \"view\" operation that doesn't modify data.\n\n    Mathematical properties:\n    1. Size preservation: The total number of elements remains constant\n    2. Order preservation: Elements appear in the same linear sequence\n    3. Value preservation: Each element value is unchanged\n\n    Precondition: The new shape must have the same total size as the original\n    Postcondition: Each element at index i in the result equals the element\n                   at the corresponding index in the original array\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def reshape {n m : Nat} (a : Vector Float n) (h_size : n = m) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem reshape_spec {n m : Nat} (a : Vector Float n) (h_size : n = m) :\n    \u2983\u231cn = m\u231d\u2984\n    reshape a h_size\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, result.get i = a.get (i.cast h_size.symm)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_resize", "vc-description": "/- \n{\n  \"name\": \"numpy.resize\",\n  \"category\": \"Adding Removing Elements\",\n  \"description\": \"Return a new array with the specified shape\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.resize.html\",\n  \"doc\": \"Return a new array with the specified shape.\\n\\nIf the new array is larger than the original array, then the new\\narray is filled with repeated copies of \\`a\\`. Note that this behavior\\nis different from a.resize(new_shape) which fills with zeros instead\\nof repeated copies of \\`a\\`.\\n\\nParameters\\n----------\\na : array_like\\n    Array to be resized.\\nnew_shape : int or tuple of ints\\n    Shape of resized array.\\n\\nReturns\\n-------\\nreshaped_array : ndarray\\n    The new array is formed from the data in the old array, repeated\\n    if necessary to fill out the required number of elements. The\\n    data are repeated iterating over the array in C-order.\\n\\nExamples\\n--------\\n>>> a=np.array([[0,1],[2,3]])\\n>>> np.resize(a,(2,3))\\narray([[0, 1, 2],\\n       [3, 0, 1]])\\n>>> np.resize(a,(1,4))\\narray([[0, 1, 2, 3]])\\n>>> np.resize(a,(2,4))\\narray([[0, 1, 2, 3],\\n       [0, 1, 2, 3]])\",\n  \"source_location\": \"C implementation in numpy/_core/src/multiarray/multiarraymodule.c\",\n  \"signature\": \"numpy.resize(a, new_shape)\"\n}\n-/\n\n/-  Return a new vector with the specified size by repeating elements from the input vector.\n    If the new size is larger, elements are repeated cyclically.\n    If the new size is smaller, only the first elements are taken. -/\n\n/-  Specification: resize creates a new vector of the specified size by either:\n    1. Taking the first `new_size` elements if `new_size \u2264 n`\n    2. Repeating the original elements cyclically if `new_size > n` and `n > 0`\n\n    The function handles three cases:\n    - Shrinking: new_size < n \u2192 takes first new_size elements\n    - Same size: new_size = n \u2192 returns identical vector\n    - Growing: new_size > n \u2192 repeats elements cyclically (when n > 0) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def resize {n : Nat} {\u03b1 : Type} (a : Vector \u03b1 n) (new_size : Nat) : Id (Vector \u03b1 new_size) :=\n  sorry", "vc-theorems": "theorem resize_spec {n : Nat} {\u03b1 : Type} (a : Vector \u03b1 n) (new_size : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    resize a new_size\n    \u2983\u21d3result => \u231c(\u2200 i : Fin new_size, \n        if h : i.val < n then\n          result.get i = a.get \u27e8i.val, h\u27e9\n        else if hn : n > 0 then\n          result.get i = a.get \u27e8i.val % n, Nat.mod_lt i.val hn\u27e9\n        else\n          True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_roll", "vc-description": "/- \n{\n  \"name\": \"numpy.roll\",\n  \"category\": \"Rearranging Elements\",\n  \"description\": \"Roll array elements along a given axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.roll.html\",\n  \"doc\": \"Roll array elements along a given axis.\\n\\nElements that roll beyond the last position are re-introduced at\\nthe first.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\nshift : int or tuple of ints\\n    The number of places by which elements are shifted. If a tuple,\\n    then \\`axis\\` must be a tuple of the same size, and each of the\\n    given axes is shifted by the corresponding number. If an int\\n    while \\`axis\\` is a tuple of ints, then the same value is used for\\n    all given axes.\\naxis : int or tuple of ints, optional\\n    Axis or axes along which elements are shifted. By default, the\\n    array is flattened before shifting, after which the original\\n    shape is restored.\\n\\nReturns\\n-------\\nres : ndarray\\n    Output array, with the same shape as \\`a\\`.\\n\\nExamples\\n--------\\n>>> x = np.arange(10)\\n>>> np.roll(x, 2)\\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\\n>>> np.roll(x, -2)\\narray([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\\n\\n>>> x2 = np.reshape(x, (2, 5))\\n>>> x2\\narray([[0, 1, 2, 3, 4],\\n       [5, 6, 7, 8, 9]])\\n>>> np.roll(x2, 1)\\narray([[9, 0, 1, 2, 3],\\n       [4, 5, 6, 7, 8]])\\n>>> np.roll(x2, -1)\\narray([[1, 2, 3, 4, 5],\\n       [6, 7, 8, 9, 0]])\\n>>> np.roll(x2, 1, axis=0)\\narray([[5, 6, 7, 8, 9],\\n       [0, 1, 2, 3, 4]])\\n>>> np.roll(x2, -1, axis=0)\\narray([[5, 6, 7, 8, 9],\\n       [0, 1, 2, 3, 4]])\\n>>> np.roll(x2, 1, axis=1)\\narray([[4, 0, 1, 2, 3],\\n       [9, 5, 6, 7, 8]])\\n>>> np.roll(x2, -1, axis=1)\\narray([[1, 2, 3, 4, 0],\\n       [6, 7, 8, 9, 5]])\\n>>> np.roll(x2, (1, 1), axis=(1, 0))\\narray([[9, 5, 6, 7, 8],\\n       [4, 0, 1, 2, 3]])\\n>>> np.roll(x2, (2, 1), axis=(1, 0))\\narray([[8, 9, 5, 6, 7],\\n       [3, 4, 0, 1, 2]])\",\n  \"source_location\": \"numpy/_core/numeric.py\",\n  \"signature\": \"numpy.roll(a, shift, axis=None)\"\n}\n-/\n\n/-  Roll array elements along a given axis by cyclically shifting elements.\n    Elements that roll beyond the last position are re-introduced at the first. -/\n\n/-  Specification: roll cyclically shifts array elements by the given amount.\n    For positive shift, elements move to the right and wrap around.\n    For negative shift, elements move to the left and wrap around.\n    Empty vectors are returned unchanged.\n\n    Mathematical property: result[i] = a[(i - shift) mod n]\n    where the modulo operation handles negative values correctly. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def roll {n : Nat} {\u03b1 : Type} (a : Vector \u03b1 n) (shift : Int) : Id (Vector \u03b1 n) :=\n  sorry", "vc-theorems": "theorem roll_spec {n : Nat} {\u03b1 : Type} (a : Vector \u03b1 n) (shift : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    roll a shift\n    \u2983\u21d3result => \u231c(n = 0 \u2192 result = a) \u2227 \n                 (n > 0 \u2192 \u2200 i : Fin n, \n                   let srcIdx := ((i.val : Int) - shift) % (n : Int)\n                   let normalizedIdx := if srcIdx < 0 then srcIdx + n else srcIdx\n                   result.get i = a.get \u27e8normalizedIdx.toNat, by sorry\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_rollaxis", "vc-description": "/-  numpy.rollaxis: Roll the specified axis backwards, until it lies in a given position.\n\n    For 1D arrays, this is a no-op - it returns the input array unchanged.\n    This is because with only one axis (axis 0), there's nowhere to roll it to.\n    The axis and start parameters are ignored in the 1D case.\n\n    Note: This function is deprecated in favor of moveaxis, but we provide\n    the specification for completeness.\n-/\n\n/-  Specification: numpy.rollaxis returns the input vector unchanged for 1D arrays.\n\n    Precondition: True (no special preconditions for 1D rollaxis)\n    Postcondition: The result is identical to the input vector\n\n    Mathematical property: For 1D arrays, rollaxis is the identity function\n    since there's only one axis that cannot be moved.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_rollaxis {n : Nat} (a : Vector Float n) (axis : Int) (start : Int := 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_rollaxis_spec {n : Nat} (a : Vector Float n) (axis : Int) (start : Int := 0) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_rollaxis a axis start\n    \u2983\u21d3result => \u231cresult = a\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_rot90", "vc-description": "/-  numpy.rot90: Rotate an array by 90 degrees in the plane specified by axes.\n\n    For a 2D array, this function rotates the array counterclockwise by 90 degrees\n    when k=1. The rotation transforms element at position (i,j) to position \n    (j, n-1-i) for a square matrix of size n\u00d7n. Multiple rotations can be achieved \n    by setting k to the desired number of 90-degree rotations.\n\n    This specification focuses on square 2D arrays for simplicity.\n-/\n\n/-  Specification: rot90 rotates a square 2D matrix by 90 degrees counterclockwise k times.\n\n    The specification handles k modulo 4 since four 90-degree rotations return\n    to the original orientation:\n    - k \u2261 0 (mod 4): No rotation (identity)\n    - k \u2261 1 (mod 4): 90\u00b0 counterclockwise rotation\n    - k \u2261 2 (mod 4): 180\u00b0 rotation  \n    - k \u2261 3 (mod 4): 270\u00b0 counterclockwise (= 90\u00b0 clockwise)\n\n    Mathematical properties:\n    1. rot90 is a group action: rot90(m, k1 + k2) = rot90(rot90(m, k1), k2)\n    2. rot90(m, 4) = m (period 4)\n    3. rot90(m, -k) = rot90(m, 4-k) (inverse rotation)\n\n    For a 90\u00b0 counterclockwise rotation, the transformation is:\n    - Element at position (i,j) moves to position (j, n-1-i)\n    - This preserves distances and angles (isometry)\n\n    Sanity checks:\n    - Corner elements rotate correctly: (0,0) \u2192 (0,n-1) \u2192 (n-1,n-1) \u2192 (n-1,0) \u2192 (0,0)\n    - Center element of odd-sized matrix stays fixed for k=2\n\n    Precondition: Matrix is non-empty (n > 0)\n    Postcondition: Elements are repositioned according to the rotation formula\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rot90 {n : Nat} (m : Vector (Vector Float n) n) (k : Int := 1) : \n    Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem rot90_spec {n : Nat} (m : Vector (Vector Float n) n) (k : Int) \n    (h_n : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    rot90 m k\n    \u2983\u21d3result => \u231clet k_mod := k % 4\n                 let k_normalized := if k_mod < 0 then k_mod + 4 else k_mod\n                 -- Main rotation formulas\n                 (k_normalized = 0 \u2192 \n                    -- No rotation (identity)\n                    \u2200 i j : Fin n, (result.get i).get j = (m.get i).get j) \u2227\n                 (k_normalized = 1 \u2192 \n                    -- 90 degrees counterclockwise: (i,j) \u2192 (j, n-1-i)\n                    \u2200 i j : Fin n, \n                    (result.get j).get \u27e8n - 1 - i.val, sorry\u27e9 = (m.get i).get j) \u2227\n                 (k_normalized = 2 \u2192 \n                    -- 180 degrees: (i,j) \u2192 (n-1-i, n-1-j)\n                    \u2200 i j : Fin n, \n                    (result.get \u27e8n - 1 - i.val, sorry\u27e9).get \u27e8n - 1 - j.val, sorry\u27e9 = (m.get i).get j) \u2227\n                 (k_normalized = 3 \u2192 \n                    -- 270 degrees counterclockwise: (i,j) \u2192 (n-1-j, i)\n                    \u2200 i j : Fin n, \n                    (result.get \u27e8n - 1 - j.val, sorry\u27e9).get i = (m.get i).get j) \u2227\n                 -- Sanity check: corner element rotation for k=1\n                 (k_normalized = 1 \u2227 n \u2265 2 \u2192 \n                    (result.get \u27e80, sorry\u27e9).get \u27e8n - 1, sorry\u27e9 = (m.get \u27e80, sorry\u27e9).get \u27e80, sorry\u27e9) \u2227\n                 -- Sanity check: for odd n and k=2, center element stays fixed\n                 (k_normalized = 2 \u2227 n % 2 = 1 \u2192 \n                    let center := n / 2\n                    (result.get \u27e8center, sorry\u27e9).get \u27e8center, sorry\u27e9 = (m.get \u27e8center, sorry\u27e9).get \u27e8center, sorry\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_row_stack", "vc-description": "/- \n{\n  \"name\": \"numpy.row_stack\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Stack 1-D arrays as rows into a 2-D array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.row_stack.html\",\n  \"doc\": \"Stack 1-D arrays as rows into a 2-D array.\\n\\nThis function is an alias for `vstack`. It is provided for\\ncompatibility with MATLAB.\\n\\nParameters\\n----------\\ntup : sequence of ndarrays\\n    The arrays must have the same shape along all but the first axis.\\n    1-D arrays must have the same length.\\ndtype : str or dtype\\n    If provided, the destination array will have this dtype.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur.\\n\\nReturns\\n-------\\nstacked : ndarray\\n    The array formed by stacking the given arrays.\\n\\nSee Also\\n--------\\nvstack : Stack arrays vertically.\\n\\nExamples\\n--------\\n>>> np.row_stack([[1, 2], [3, 4]])\\narray([[1, 2],\\n       [3, 4]])\",\n  \"source_location\": \"numpy/_core/shape_base.py\",\n  \"signature\": \"numpy.row_stack(tup, *, dtype=None, casting='same_kind')\"\n}\n-/\n\n/-  Stack a list of 1-D vectors as rows into a 2-D matrix (Vector of Vectors).\n    Each input vector becomes a row in the output matrix. -/\n\n/-  Specification: row_stack returns a matrix where each row corresponds to an input vector.\n    The i-th row of the result is exactly the i-th input vector (identity transformation). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def row_stack {n m : Nat} (arrays : Vector (Vector Float n) m) : Id (Vector (Vector Float n) m) :=\n  sorry", "vc-theorems": "theorem row_stack_spec {n m : Nat} (arrays : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    row_stack arrays\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, \u2200 j : Fin n, (result.get i).get j = (arrays.get i).get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_shape", "vc-description": "/- \n{\n  \"name\": \"numpy.shape\",\n  \"category\": \"Basic Operations\",\n  \"description\": \"Return the shape of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.shape.html\",\n  \"doc\": \"Return the shape of an array.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\n\\nReturns\\n-------\\nshape : tuple of ints\\n    The elements of the shape tuple give the lengths of the\\n    corresponding array dimensions.\\n\\nExamples\\n--------\\n>>> np.shape(np.eye(3))\\n(3, 3)\\n>>> np.shape([[1, 3]])\\n(1, 2)\\n>>> np.shape([0])\\n(1,)\\n>>> np.shape(0)\\n()\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.shape(a)\"\n}\n-/\n\n/-  numpy.shape: Return the shape of an array.\n\n    For a one-dimensional vector, returns its length as a natural number.\n    This corresponds to the single element in the shape tuple for 1D arrays\n    in NumPy.\n\n    In the general NumPy implementation, shape returns a tuple of dimensions.\n    For our Vector type, which is inherently one-dimensional, the shape is\n    simply the length parameter n.\n-/\n\n/-  Specification: numpy.shape returns the length of the vector.\n\n    For a Vector of length n, the shape function returns n.\n    This captures the fundamental property that the shape of a 1D array\n    is its length.\n\n    Precondition: True (shape is defined for all vectors)\n    Postcondition: The result equals the length parameter n of the vector\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def shape {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) : Id Nat :=\n  sorry", "vc-theorems": "theorem shape_spec {\u03b1 : Type} {n : Nat} (a : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    shape a\n    \u2983\u21d3result => \u231cresult = n\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_size", "vc-description": "/- \n{\n  \"name\": \"numpy.size\",\n  \"category\": \"Basic Operations\",\n  \"description\": \"Return the number of elements along a given axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.size.html\",\n  \"doc\": \"Return the number of elements along a given axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : int, optional\\n    Axis along which the elements are counted. By default, give\\n    the total number of elements.\\n\\nReturns\\n-------\\nelement_count : int\\n    Number of elements along the specified axis.\\n\\nExamples\\n--------\\n>>> a = np.array([[1,2,3],[4,5,6]])\\n>>> np.size(a)\\n6\\n>>> np.size(a,1)\\n3\\n>>> np.size(a,0)\\n2\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.size(a, axis=None)\"\n}\n-/\n\n/-  Returns the number of elements in a vector -/\n\n/-  Specification: size returns the length of the vector, which is its type parameter n -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def size {n : Nat} (a : Vector Float n) : Id Nat :=\n  sorry", "vc-theorems": "theorem size_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    size a\n    \u2983\u21d3result => \u231cresult = n\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_split", "vc-description": "/- \n{\n  \"name\": \"numpy.split\",\n  \"category\": \"Splitting Arrays\",\n  \"description\": \"Split an array into multiple sub-arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.split.html\",\n  \"doc\": \"Split an array into multiple sub-arrays as views into \\`ary\\`.\\n\\nParameters\\n----------\\nary : ndarray\\n    Array to be divided into sub-arrays.\\nindices_or_sections : int or 1-D array\\n    If \\`indices_or_sections\\` is an integer, N, the array will be divided\\n    into N equal arrays along \\`axis\\`. If such a split is not possible,\\n    an error is raised.\\n    \\n    If \\`indices_or_sections\\` is a 1-D array of sorted integers, the entries\\n    indicate where along \\`axis\\` the array is split. For example,\\n    \\`\\`[2, 3]\\`\\` would, for \\`\\`axis=0\\`\\`, result in\\n    \\n    - ary[:2]\\n    - ary[2:3]\\n    - ary[3:]\\n    \\n    If an index exceeds the dimension of the array along \\`axis\\`,\\n    an empty sub-array is returned correspondingly.\\naxis : int, optional\\n    The axis along which to split, default is 0.\\n\\nReturns\\n-------\\nsub-arrays : list of ndarrays\\n    A list of sub-arrays as views into \\`ary\\`.\\n\\nExamples\\n--------\\n>>> x = np.arange(9.0)\\n>>> np.split(x, 3)\\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\\n>>> x = np.arange(8.0)\\n>>> np.split(x, [3, 5, 6, 10])\\n[array([0.,  1.,  2.]),\\n array([3.,  4.]),\\n array([5.]),\\n array([6.,  7.]),\\n array([], dtype=float64)]\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.split(ary, indices_or_sections, axis=0)\"\n}\n-/\n\n/-  Split a vector into k equal parts. Requires that the vector length is divisible by k -/\n\n/-  Specification: split divides a vector into k equal-sized sub-vectors \n    where each sub-vector contains consecutive elements from the original.\n\n    The specification states that:\n    1. The result is a vector of k sub-vectors\n    2. Each sub-vector has size n/k \n    3. Element j of sub-vector i corresponds to element (i * (n/k) + j) of the original vector\n    4. All elements from the original vector are preserved in the split\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def split {n k : Nat} (arr : Vector Float n) (h_div : k \u2223 n) (h_pos : k > 0) : \n    Id (Vector (Vector Float (n / k)) k) :=\n  sorry", "vc-theorems": "theorem split_spec {n k : Nat} (arr : Vector Float n) (h_div : k \u2223 n) (h_pos : k > 0) :\n    \u2983\u231ck \u2223 n \u2227 k > 0\u231d\u2984\n    split arr h_div h_pos\n    \u2983\u21d3result => \u231c(\u2200 i : Fin k, \u2200 j : Fin (n / k), \n                  \u2203 (idx : Fin n), idx.val = i.val * (n / k) + j.val \u2227 \n                  (result.get i).get j = arr.get idx) \u2227\n                 (\u2200 idx : Fin n, \u2203 (i : Fin k) (j : Fin (n / k)), \n                  idx.val = i.val * (n / k) + j.val \u2227\n                  arr.get idx = (result.get i).get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_squeeze", "vc-description": "/- \n{\n  \"name\": \"numpy.squeeze\",\n  \"category\": \"Changing Dimensions\",\n  \"description\": \"Remove axes of length one from a\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.squeeze.html\",\n  \"doc\": \"Remove axes of length one from \\`a\\`.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : None or int or tuple of ints, optional\\n    Selects a subset of the entries of length one in the\\n    shape. If an axis is selected with shape entry greater than\\n    one, an error is raised.\\n\\nReturns\\n-------\\nsqueezed : ndarray\\n    The input array, but with all or a subset of the\\n    dimensions of length 1 removed. This is always \\`a\\` itself\\n    or a view into \\`a\\`. Note that if all axes are squeezed,\\n    the result is a 0d array and not a scalar.\\n\\nExamples\\n--------\\n>>> x = np.array([[[0], [1], [2]]])\\n>>> x.shape\\n(1, 3, 1)\\n>>> np.squeeze(x).shape\\n(3,)\\n>>> np.squeeze(x, axis=0).shape\\n(3, 1)\\n>>> np.squeeze(x, axis=1).shape\\nTraceback (most recent call last):\\n...\\nValueError: cannot select an axis to squeeze out which has size not equal to one\\n>>> np.squeeze(x, axis=2).shape\\n(1, 3)\\n>>> x = np.array([[1234]])\\n>>> x.shape\\n(1, 1)\\n>>> np.squeeze(x)\\narray(1234)  # 0d array\\n>>> np.squeeze(x).shape\\n()\\n>>> np.squeeze(x)[()]\\n1234\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.squeeze(a, axis=None)\"\n}\n-/\n\n/-  Squeeze a single-element vector to extract its value.\n    This is a simplified 1D version of numpy.squeeze for vectors of size 1. -/\n\n/-  Specification: squeeze extracts the single element from a size-1 vector.\n\n    Mathematical properties:\n    1. The result equals the first (and only) element of the input vector\n    2. For any function f, squeeze preserves function application: f(squeeze(a)) = f(a[0])\n    3. squeeze is the inverse of creating a single-element vector\n\n    Sanity checks:\n    - The input must be a vector of exactly size 1\n    - The output type changes from Vector to the element type\n    - This models numpy's behavior where squeeze([x]) returns x as a 0D array -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def squeeze {\u03b1 : Type} (a : Vector \u03b1 1) : Id \u03b1 :=\n  sorry", "vc-theorems": "theorem squeeze_spec {\u03b1 : Type} (a : Vector \u03b1 1) :\n    \u2983\u231cTrue\u231d\u2984\n    squeeze a\n    \u2983\u21d3result => \u231cresult = a.get \u27e80, by decide\u27e9 \u2227 \n                 -- Mathematical property: squeeze is injective\n                 (\u2200 b : Vector \u03b1 1, squeeze a = squeeze b \u2192 a = b) \u2227\n                 -- Mathematical property: squeeze preserves function application\n                 (\u2200 (\u03b2 : Type) (f : \u03b1 \u2192 \u03b2), f result = f (a.get \u27e80, by decide\u27e9)) \u2227\n                 -- Sanity check: result is the unique element in the vector\n                 (\u2200 i : Fin 1, a.get i = result)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_stack", "vc-description": "/- \n{\n  \"name\": \"numpy.stack\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Join a sequence of arrays along a new axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.stack.html\",\n  \"doc\": \"Join a sequence of arrays along a new axis.\\n\\nThe \\`axis\\` parameter specifies the index of the new axis in the\\ndimensions of the result. For example, if \\`axis=0\\` it will be the first\\ndimension and if \\`axis=-1\\` it will be the last dimension.\\n\\nParameters\\n----------\\narrays : sequence of array_like\\n    Each array must have the same shape.\\naxis : int, optional\\n    The axis in the result array along which the input arrays are stacked.\\nout : ndarray, optional\\n    If provided, the destination to place the result. The shape must be\\n    correct, matching that of what stack would have returned if no\\n    out argument were specified.\\ndtype : str or dtype\\n    If provided, the destination array will have this dtype. Cannot be\\n    provided together with \\`out\\`.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\\n\\nReturns\\n-------\\nstacked : ndarray\\n    The stacked array has one more dimension than the input arrays.\\n\\nExamples\\n--------\\n>>> arrays = [np.random.randn(3, 4) for _ in range(10)]\\n>>> np.stack(arrays, axis=0).shape\\n(10, 3, 4)\\n>>> np.stack(arrays, axis=1).shape\\n(3, 10, 4)\\n>>> np.stack(arrays, axis=2).shape\\n(3, 4, 10)\",\n  \"signature\": \"numpy.stack(arrays, axis=0, out=None, *, dtype=None, casting='same_kind')\",\n  \"source_location\": \"numpy/_core/shape_base.py\"\n}\n-/\n\n/-  Stack a sequence of vectors along a new axis to create a 2D matrix.\n    For simplicity, we focus on stacking 1D vectors along axis 0.\n    The result has shape (m, n) where m is the number of vectors and n is their common length. -/\n\n/-  Specification: stack creates a 2D matrix where each input vector becomes a row.\n    Key properties:\n    1. The result preserves all input vectors as rows\n    2. The i-th row of the result equals the i-th input vector\n    3. Shape property: stacking m vectors of length n produces an m\u00d7n matrix -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def stack {m n : Nat} (arrays : Vector (Vector Float n) m) : Id (Vector (Vector Float n) m) :=\n  sorry", "vc-theorems": "theorem stack_spec {m n : Nat} (arrays : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    stack arrays\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, \u2200 j : Fin n, \n                  (result.get i).get j = (arrays.get i).get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_swapaxes", "vc-description": "/- \n{\n  \"name\": \"numpy.swapaxes\",\n  \"category\": \"Transpose Operations\",\n  \"description\": \"Interchange two axes of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.swapaxes.html\",\n  \"doc\": \"Interchange two axes of an array.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxis1 : int\\n    First axis.\\naxis2 : int\\n    Second axis.\\n\\nReturns\\n-------\\na_swapped : ndarray\\n    For NumPy >= 1.10.0, if \\`a\\` is an ndarray, then a view of \\`a\\` is\\n    returned; otherwise a new array is created. For earlier NumPy\\n    versions a view of \\`a\\` is returned only if the order of the\\n    axes is changed, otherwise the input array is returned.\\n\\nExamples\\n--------\\n>>> x = np.array([[1,2,3]])\\n>>> np.swapaxes(x,0,1)\\narray([[1],\\n       [2],\\n       [3]])\\n>>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\\n>>> x\\narray([[[0, 1],\\n        [2, 3]],\\n       [[4, 5],\\n        [6, 7]]])\\n>>> np.swapaxes(x,0,2)\\narray([[[0, 4],\\n        [2, 6]],\\n       [[1, 5],\\n        [3, 7]]])\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\",\n  \"signature\": \"numpy.swapaxes(a, axis1, axis2)\"\n}\n-/\n\n/-  Interchange two axes of a 2D array (matrix).\n    For 2D arrays, swapaxes with axis1=0 and axis2=1 is equivalent to transpose.\n    This specification focuses on 2D arrays where axis1=0 and axis2=1. -/\n\n/-  Specification: swapaxes with axes 0 and 1 transposes a 2D array.\n    The element at position (i,j) in the original becomes (j,i) in the result.\n\n    Mathematical properties:\n    1. Dimension swap: rows become columns and vice versa\n    2. Element preservation: mat[i][j] = result[j][i]\n    3. Idempotence: swapping twice returns to original\n    4. Commutativity: swapaxes(a, i, j) = swapaxes(a, j, i) -/", "vc-preamble": "import Init.Data.Vector.Basic\nimport Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def swapaxes {rows cols : Nat} (mat : Vector (Vector Float cols) rows) \n    (axis1 axis2 : Nat) (h1 : axis1 < 2) (h2 : axis2 < 2) : \n    Id (Vector (Vector Float rows) cols) :=\n  sorry", "vc-theorems": "theorem swapaxes_spec {rows cols : Nat} (mat : Vector (Vector Float cols) rows) \n    (h1 : rows > 0) (h2 : cols > 0) :\n    \u2983\u231crows > 0 \u2227 cols > 0\u231d\u2984\n    swapaxes mat 0 1 (by decide) (by decide)\n    \u2983\u21d3result => \u231c\u2200 (i : Fin rows) (j : Fin cols), \n                  (mat.get i).get j = (result.get j).get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_tile", "vc-description": "/- \n{\n  \"name\": \"numpy.tile\",\n  \"category\": \"Tiling Arrays\",\n  \"description\": \"Construct an array by repeating A the number of times given by reps\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.tile.html\",\n  \"doc\": \"Construct an array by repeating A the number of times given by reps.\\n\\nIf `reps` has length ``d``, the result will have dimension of\\n``max(d, A.ndim)``.\\n\\nIf ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new\\naxes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\\nor shape (1, 1, 3) for 3-D replication. If this is not the desired\\nbehavior, promote `A` to d-dimensions manually before calling this\\nfunction.\\n\\nIf ``A.ndim > d``, `reps` is promoted to `A`.ndim by prepending 1's to it.\\nThus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as\\n(1, 1, 2, 2).\\n\\nParameters\\n----------\\nA : array_like\\n    The input array.\\nreps : array_like\\n    The number of repetitions of `A` along each axis.\\n\\nReturns\\n-------\\nc : ndarray\\n    The tiled output array.\\n\\nExamples\\n--------\\n>>> a = np.array([0, 1, 2])\\n>>> np.tile(a, 2)\\narray([0, 1, 2, 0, 1, 2])\\n>>> np.tile(a, (2, 2))\\narray([[0, 1, 2, 0, 1, 2],\\n       [0, 1, 2, 0, 1, 2]])\\n>>> np.tile(a, (2, 1, 2))\\narray([[[0, 1, 2, 0, 1, 2]],\\n       [[0, 1, 2, 0, 1, 2]]])\\n\\n>>> b = np.array([[1, 2], [3, 4]])\\n>>> np.tile(b, 2)\\narray([[1, 2, 1, 2],\\n       [3, 4, 3, 4]])\\n>>> np.tile(b, (2, 1))\\narray([[1, 2],\\n       [3, 4],\\n       [1, 2],\\n       [3, 4]])\\n\\n>>> c = np.array([1,2,3,4])\\n>>> np.tile(c,(4,1))\\narray([[1, 2, 3, 4],\\n       [1, 2, 3, 4],\\n       [1, 2, 3, 4],\\n       [1, 2, 3, 4]])\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.tile(A, reps)\"\n}\n-/\n\n/-  Constructs a vector by repeating the input vector `reps` times.\n    For 1D case: tile([a, b, c], 3) = [a, b, c, a, b, c, a, b, c] -/\n\n/-  Specification: tile repeats the input vector `reps` times, where each element\n    at position i in the result corresponds to element at position (i % n) in the input -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tile {\u03b1 : Type} {n : Nat} (A : Vector \u03b1 n) (reps : Nat) : Id (Vector \u03b1 (n * reps)) :=\n  sorry", "vc-theorems": "theorem tile_spec {\u03b1 : Type} {n : Nat} (A : Vector \u03b1 n) (reps : Nat) (h_reps : reps > 0) :\n    \u2983\u231creps > 0\u231d\u2984\n    tile A reps\n    \u2983\u21d3result => \u231c\u2200 i : Fin (n * reps), result.get i = A.get \u27e8i.val % n, by\n      -- We need to prove i.val % n < n\n      cases n with\n      | zero =>\n        -- If n = 0, then n * reps = 0, so there are no valid Fin (n * reps)\n        simp at i\n        exact absurd i.isLt (Nat.not_lt_zero _)\n      | succ n' =>\n        -- If n = succ n', then n > 0\n        exact Nat.mod_lt i.val (Nat.zero_lt_succ n')\n    \u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_transpose", "vc-description": "/- \n{\n  \"name\": \"numpy.transpose\",\n  \"category\": \"Transpose Operations\",\n  \"description\": \"Returns an array with axes transposed\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.transpose.html\",\n  \"doc\": \"Returns an array with axes transposed.\\n\\nFor a 1-D array, this returns an unchanged view of the original array, as a\\ntransposed vector is simply the same vector. For a 2-D array, this is the\\nstandard matrix transpose. For an n-D array, if axes are given, their order\\nindicates how the axes are permuted.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxes : tuple or list of ints, optional\\n    If specified, it must be a tuple or list which contains a permutation\\n    of [0,1,...,N-1] where N is the number of axes of a. The i'th axis\\n    of the returned array will correspond to the axis numbered axes[i]\\n    of the input. If not specified, defaults to range(a.ndim)[::-1],\\n    which reverses the order of the axes.\\n\\nReturns\\n-------\\np : ndarray\\n    \\`a\\` with its axes permuted. A view is returned whenever possible.\\n\\nExamples\\n--------\\n>>> a = np.array([[1, 2], [3, 4]])\\n>>> np.transpose(a)\\narray([[1, 3],\\n       [2, 4]])\\n>>> a = np.array([1, 2, 3, 4])\\n>>> np.transpose(a)\\narray([1, 2, 3, 4])\\n>>> a = np.ones((1, 2, 3))\\n>>> np.transpose(a, (1, 0, 2)).shape\\n(2, 1, 3)\",\n  \"signature\": \"numpy.transpose(a, axes=None)\",\n  \"source_location\": \"numpy/_core/fromnumeric.py\"\n}\n-/\n\n/-  numpy.transpose: Returns a matrix with rows and columns swapped.\n\n    For 2D arrays (matrices), transpose swaps the rows and columns.\n    This means that element at position (i,j) in the original matrix\n    appears at position (j,i) in the transposed matrix.\n\n    This simplified version handles 2D matrix transpose only.\n-/\n\n/-  Specification: numpy.transpose returns a matrix where rows and columns are swapped.\n\n    Precondition: True (no special preconditions for basic transpose)\n    Postcondition: For all valid indices (i,j), result[j][i] = a[i][j]\n\n    Mathematical properties:\n    - Transpose is an involution: (A^T)^T = A\n    - For square matrices: trace(A^T) = trace(A)\n    - (A^T)[j,i] = A[i,j] for all valid indices\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_transpose {rows cols : Nat} (a : Vector (Vector Float cols) rows) : \n    Id (Vector (Vector Float rows) cols) :=\n  sorry", "vc-theorems": "theorem numpy_transpose_spec {rows cols : Nat} (a : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_transpose a\n    \u2983\u21d3result => \u231c\u2200 (i : Fin rows) (j : Fin cols), \n                  (result.get j).get i = (a.get i).get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_trim_zeros", "vc-description": "/- \n{\n  \"name\": \"numpy.trim_zeros\",\n  \"category\": \"Adding Removing Elements\",\n  \"description\": \"Trim the leading and/or trailing zeros from a 1-D array or sequence\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.trim_zeros.html\",\n  \"doc\": \"Trim the leading and/or trailing zeros from a 1-D array or sequence.\\n\\nParameters\\n----------\\nfilt : 1-D array or sequence\\n    Input array.\\ntrim : str, optional\\n    A string with 'f' representing trim from front and 'b' to trim from\\n    back. Default is 'fb', trim zeros from both front and back of the\\n    array.\\n\\nReturns\\n-------\\ntrimmed : 1-D array or sequence\\n    The result of trimming the input. The input data type is preserved.\\n\\nExamples\\n--------\\n>>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\\n>>> np.trim_zeros(a)\\narray([1, 2, 3, 0, 2, 1])\\n>>> np.trim_zeros(a, 'b')\\narray([0, 0, 0, 1, 2, 3, 0, 2, 1])\\n\\nThe input data type is preserved, list/tuple in means list/tuple out.\\n\\n>>> np.trim_zeros([0, 1, 2, 0])\\n[1, 2]\",\n  \"source_location\": \"numpy/lib/_function_base_impl.py\",\n  \"signature\": \"numpy.trim_zeros(filt, trim='fb')\"\n}\n-/\n\n/-  numpy.trim_zeros: Trim the leading and/or trailing zeros from a 1-D array.\n\n    Removes zeros from the beginning and/or end of a vector based on the trim mode.\n    - Front: removes leading zeros only\n    - Back: removes trailing zeros only\n    - Both: removes both leading and trailing zeros (default)\n\n    The function preserves all non-zero elements and internal zeros.\n-/\n\n/-  Specification: trim_zeros removes leading and/or trailing zeros while preserving order.\n\n    The function guarantees:\n    1. All non-zero elements from the original array are preserved in order\n    2. Internal zeros (zeros between non-zero elements) are preserved\n    3. Only leading/trailing zeros are removed based on the mode\n    4. If the array contains only zeros, returns an empty vector\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents the trim mode for trim_zeros function -/\ninductive TrimMode where\n  /-- Trim zeros from the front of the array only (corresponds to 'f') -/\n  | Front\n  /-- Trim zeros from the back of the array only (corresponds to 'b') -/\n  | Back\n  /-- Trim zeros from both front and back of the array (corresponds to 'fb', default) -/\n  | Both", "vc-helpers": "", "vc-definitions": "def trim_zeros {n : Nat} (arr : Vector Float n) (mode : TrimMode := TrimMode.Both) : \n    Id (\u03a3 m : Nat, Vector Float m) :=\n  sorry", "vc-theorems": "theorem trim_zeros_spec {n : Nat} (arr : Vector Float n) (mode : TrimMode) :\n    \u2983\u231cTrue\u231d\u2984\n    trim_zeros arr mode\n    \u2983\u21d3result => \u231c\n      -- Define the range of preserved elements\n      \u2203 (start finish : Nat) (h_start : start \u2264 n) (h_finish : finish \u2264 n) (h_order : start \u2264 finish),\n        -- The trimmed size matches the preserved range\n        result.1 = finish - start \u2227\n        -- Elements before start are zeros (if trimming front)\n        (mode = TrimMode.Front \u2228 mode = TrimMode.Both \u2192 \n          \u2200 i : Fin start, arr.get \u27e8i, Nat.lt_of_lt_of_le i.isLt h_start\u27e9 = 0) \u2227\n        -- Elements after finish are zeros (if trimming back)\n        (mode = TrimMode.Back \u2228 mode = TrimMode.Both \u2192 \n          \u2200 i : Fin (n - finish), arr.get \u27e8finish + i, sorry\u27e9 = 0) \u2227\n        -- The preserved elements match exactly\n        (\u2200 i : Fin result.1, result.2.get i = arr.get \u27e8start + i, sorry\u27e9) \u2227\n        -- If trimming front, start is the first non-zero or n\n        (mode = TrimMode.Front \u2228 mode = TrimMode.Both \u2192 \n          (start = n \u2228 arr.get \u27e8start, sorry\u27e9 \u2260 0)) \u2227\n        -- If trimming back, finish is past the last non-zero or 0\n        (mode = TrimMode.Back \u2228 mode = TrimMode.Both \u2192 \n          (finish = 0 \u2228 arr.get \u27e8finish - 1, sorry\u27e9 \u2260 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_unique", "vc-description": "/- \n{\n  \"name\": \"numpy.unique\",\n  \"category\": \"Adding Removing Elements\",\n  \"description\": \"Find the unique elements of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.unique.html\",\n  \"doc\": \"Find the unique elements of an array.\\n\\nReturns the sorted unique elements of an array. There are three optional\\noutputs in addition to the unique elements:\\n\\n* the indices of the input array that give the unique values\\n* the indices of the unique array that reconstruct the input array\\n* the number of times each unique value comes up in the input array\\n\\nParameters\\n----------\\nar : array_like\\n    Input array. Unless \\`axis\\` is specified, this will be flattened if it\\n    is not already 1-D.\\nreturn_index : bool, optional\\n    If True, also return the indices of \\`ar\\` (along the specified axis,\\n    if provided, or in the flattened array) that result in the unique array.\\nreturn_inverse : bool, optional\\n    If True, also return the indices of the unique array (for the specified\\n    axis, if provided) that can be used to reconstruct \\`ar\\`.\\nreturn_counts : bool, optional\\n    If True, also return the number of times each unique item appears\\n    in \\`ar\\`.\\naxis : int or None, optional\\n    The axis to operate on. If None, \\`ar\\` will be flattened. If an integer,\\n    the subarrays indexed by the given axis will be flattened and treated\\n    as the elements of a 1-D array with the dimension of the given axis,\\n    see the notes for more details. Object arrays or structured arrays\\n    that contain objects are not supported if the \\`axis\\` kwarg is used. The\\n    default is None.\\nequal_nan : bool, optional\\n    If True, collapses multiple NaN values in the return array into one.\\n\\n    .. versionadded:: 1.24\\n\\nReturns\\n-------\\nunique : ndarray\\n    The sorted unique values.\\nunique_indices : ndarray, optional\\n    The indices of the first occurrences of the unique values in the\\n    original array. Only provided if \\`return_index\\` is True.\\nunique_inverse : ndarray, optional\\n    The indices to reconstruct the original array from the\\n    unique array. Only provided if \\`return_inverse\\` is True.\\nunique_counts : ndarray, optional\\n    The number of times each of the unique values comes up in the\\n    original array. Only provided if \\`return_counts\\` is True.\\n\\nExamples\\n--------\\n>>> np.unique([1, 1, 2, 2, 3, 3])\\narray([1, 2, 3])\\n>>> a = np.array([[1, 1], [2, 3]])\\n>>> np.unique(a)\\narray([1, 2, 3])\",\n  \"source_location\": \"numpy/lib/_arraysetops_impl.py\",\n  \"signature\": \"numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None, *, equal_nan=True)\"\n}\n-/\n\n/-  numpy.unique: Find the unique elements of a vector and return them sorted.\n\n    Returns a new vector containing each distinct element from the input exactly once,\n    sorted in ascending order. This is a simplified version that only returns the \n    unique values without the optional indices or counts.\n\n    The output size depends on the number of unique elements in the input.\n-/\n\n/-  Specification: numpy.unique returns a sorted vector containing each distinct element \n    from the input exactly once.\n\n    Precondition: True\n    Postcondition: \n    - The result is sorted in ascending order\n    - No duplicates exist in the result\n    - Every element in result comes from the input array\n    - Every distinct element from input appears in result\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_unique {n : Nat} (arr : Vector Float n) : Id (\u03a3 m : Nat, Vector Float m) :=\n  sorry", "vc-theorems": "theorem numpy_unique_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_unique arr\n    \u2983\u21d3result => \u231clet m := result.1\n                  let unique_arr := result.2\n                  -- The result is sorted in ascending order\n                  (\u2200 i j : Fin m, i < j \u2192 unique_arr.get i < unique_arr.get j) \u2227\n                  -- No duplicates in the result\n                  (\u2200 i j : Fin m, i \u2260 j \u2192 unique_arr.get i \u2260 unique_arr.get j) \u2227\n                  -- Every element in result comes from the input array\n                  (\u2200 i : Fin m, \u2203 j : Fin n, unique_arr.get i = arr.get j) \u2227\n                  -- Every distinct element from input appears in result\n                  (\u2200 i : Fin n, \u2203 j : Fin m, arr.get i = unique_arr.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_vsplit", "vc-description": "/- \n{\n  \"name\": \"numpy.vsplit\",\n  \"category\": \"Splitting Arrays\",\n  \"description\": \"Split an array into multiple sub-arrays vertically (row-wise)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.vsplit.html\",\n  \"doc\": \"Split an array into multiple sub-arrays vertically (row-wise).\\n\\nPlease refer to the `split` documentation. `vsplit` is equivalent\\nto `split` with ``axis=0`` (default), the array is always split along the\\nfirst axis regardless of the array dimension.\\n\\nExamples\\n--------\\n>>> x = np.arange(16.0).reshape(4, 4)\\n>>> x\\narray([[ 0.,  1.,  2.,  3.],\\n       [ 4.,  5.,  6.,  7.],\\n       [ 8.,  9., 10., 11.],\\n       [12., 13., 14., 15.]])\\n>>> np.vsplit(x, 2)\\n[array([[0., 1., 2., 3.],\\n       [4., 5., 6., 7.]]),\\n array([[ 8.,  9., 10., 11.],\\n       [12., 13., 14., 15.]])]\\n>>> np.vsplit(x, np.array([3, 6]))\\n[array([[ 0.,  1.,  2.,  3.],\\n       [ 4.,  5.,  6.,  7.],\\n       [ 8.,  9., 10., 11.]]),\\n array([[12., 13., 14., 15.]]),\\n array([], shape=(0, 4), dtype=float64)]\",\n  \"source_location\": \"numpy/lib/_shape_base_impl.py\",\n  \"signature\": \"numpy.vsplit(ary, indices_or_sections)\"\n}\n-/\n\n/-  Split a 2D vector into multiple sub-vectors vertically (row-wise).\n    This is a simplified version that handles splitting into equal parts. -/\n\n/-  Specification: vsplit divides a matrix into k equal parts row-wise, \n    where each part contains consecutive rows from the original matrix -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vsplit {rows cols k : Nat} (mat : Vector (Vector Float cols) rows) \n    (h_div : k > 0 \u2227 rows % k = 0) : Id (Vector (Vector (Vector Float cols) (rows / k)) k) :=\n  sorry", "vc-theorems": "theorem vsplit_spec {rows cols k : Nat} (mat : Vector (Vector Float cols) rows) \n    (h_div : k > 0 \u2227 rows % k = 0) :\n    \u2983\u231ck > 0 \u2227 rows % k = 0\u231d\u2984\n    vsplit mat h_div\n    \u2983\u21d3result => \u231c-- Sanity check: correct size\n                 (\u2200 split_idx : Fin k, (result.get split_idx).size = rows / k) \u2227\n                 -- Mathematical property: each split contains consecutive rows\n                 (\u2200 split_idx : Fin k, \u2200 row_idx : Fin (rows / k), \u2200 col_idx : Fin cols,\n                   -- The element at position (row_idx, col_idx) in split split_idx\n                   -- equals the element at position (split_idx * (rows/k) + row_idx, col_idx) in the original matrix\n                   \u2203 (global_row : Fin rows), \n                     global_row.val = split_idx.val * (rows / k) + row_idx.val \u2227\n                     ((result.get split_idx).get row_idx).get col_idx = \n                     (mat.get global_row).get col_idx) \u2227\n                 -- Additional property: the splits partition the original matrix\n                 (\u2200 orig_row : Fin rows, \u2203 split_idx : Fin k, \u2203 row_idx : Fin (rows / k),\n                   orig_row.val = split_idx.val * (rows / k) + row_idx.val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "array_manipulation_vstack", "vc-description": "/- \n{\n  \"name\": \"numpy.vstack\",\n  \"category\": \"Joining Arrays\",\n  \"description\": \"Stack arrays in sequence vertically (row wise)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.vstack.html\",\n  \"doc\": \"Stack arrays in sequence vertically (row wise).\\n\\nThis is equivalent to concatenation along the first axis after 1-D arrays\\nof shape \\`(N,)\\` have been reshaped to \\`(1,N)\\`. Rebuilds arrays divided by\\n\\`vsplit\\`.\\n\\nThis function makes most sense for arrays with up to 3 dimensions. For\\ninstance, for pixel-data with a height (first axis), width (second axis),\\nand r/g/b channels (third axis). The functions \\`concatenate\\`, \\`stack\\` and\\n\\`block\\` provide more general stacking and concatenation operations.\\n\\nParameters\\n----------\\ntup : sequence of ndarrays\\n    The arrays must have the same shape along all but the first axis.\\n    1-D arrays must have the same length.\\ndtype : str or dtype\\n    If provided, the destination array will have this dtype. Cannot be\\n    provided together with \\`out\\`.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\\n\\nReturns\\n-------\\nstacked : ndarray\\n    The array formed by stacking the given arrays, will be at least 2-D.\\n\\nExamples\\n--------\\n>>> a = np.array([1, 2, 3])\\n>>> b = np.array([4, 5, 6])\\n>>> np.vstack((a,b))\\narray([[1, 2, 3],\\n       [4, 5, 6]])\\n>>> a = np.array([[1], [2], [3]])\\n>>> b = np.array([[4], [5], [6]])\\n>>> np.vstack((a,b))\\narray([[1],\\n       [2],\\n       [3],\\n       [4],\\n       [5],\\n       [6]])\",\n  \"source_location\": \"numpy/_core/shape_base.py\",\n  \"signature\": \"numpy.vstack(tup, *, dtype=None, casting='same_kind')\"\n}\n-/\n\n/-  Stack two vectors vertically to create a 2D matrix.\n    For 1D vectors, this treats them as row vectors and stacks them vertically.\n    This is a simplified version focusing on the common case of stacking two 1D vectors. -/\n\n/-  Specification: vstack stacks two vectors vertically, creating a 2x n matrix\n    where the first row is vector a and the second row is vector b.\n\n    Mathematical properties:\n    1. The result has shape (2, n) where n is the length of input vectors\n    2. The first row of the result equals the first input vector\n    3. The second row of the result equals the second input vector\n    4. This operation preserves the elements and their order within each vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vstack {n : Nat} (a b : Vector Float n) : Id (Vector (Vector Float n) 2) :=\n  sorry", "vc-theorems": "theorem vstack_spec {n : Nat} (a b : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    vstack a b\n    \u2983\u21d3result => \u231c(\u2200 j : Fin n, (result.get 0).get j = a.get j) \u2227\n                 (\u2200 j : Fin n, (result.get 1).get j = b.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_binary_repr", "vc-description": "/- \n{\n  \"name\": \"numpy.binary_repr\",\n  \"category\": \"Output formatting\",\n  \"description\": \"Return the binary representation of the input number as a string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.binary_repr.html\",\n  \"doc\": \"Return the binary representation of the input number as a string.\\n\\nFor negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two's complement of the number is returned, with respect to that width.\\n\\nIn a two's-complement system negative numbers are represented by the two's complement of the absolute value. This is the most common method of representing signed integers on computers. A N-bit two's-complement system can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\\n\\nParameters\\n----------\\nnum : int\\n    Only an integer decimal number can be used.\\nwidth : int, optional\\n    The length of the returned string if num is positive, or the length of the two's complement if num is negative, provided that width is at least a sufficient number of bits for num to be represented in the designated form.\\n\\nReturns\\n-------\\nbin : str\\n    Binary representation of num or two's complement of num.\\n\\nNotes\\n-----\\nbinary_repr is equivalent to using base_repr with base 2, but about 25x faster.\\n\\nReferences\\n----------\\n.. [1] Wikipedia, \\\"Two's complement\\\",\\n    https://en.wikipedia.org/wiki/Two's_complement\\n\\nExamples\\n--------\\n>>> np.binary_repr(3)\\n'11'\\n>>> np.binary_repr(-3)\\n'-11'\\n>>> np.binary_repr(3, width=4)\\n'0011'\\n\\nThe two's complement is returned when the input number is negative and width is specified:\\n\\n>>> np.binary_repr(-3, width=3)\\n'101'\\n>>> np.binary_repr(-3, width=5)\\n'11101'\",\n}\n-/\n\n/-  Return the binary representation of the input number as a string.\n    For negative numbers, if width is not given, a minus sign is added to the front.\n    If width is given, the two's complement of the number is returned. -/\n\n/-  Specification: binary_repr correctly converts integers to binary strings with proper\n    handling of negative numbers (signed representation without width, two's complement with width) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to convert a natural number to its binary string representation -/\ndef natToBinaryString (n : Nat) : String :=\n  if n = 0 then \"0\"\n  else\n    let rec loop (m : Nat) (acc : String) : String :=\n      if m = 0 then acc\n      else loop (m / 2) (if m % 2 = 0 then \"0\" ++ acc else \"1\" ++ acc)\n    loop n \"\"\n/-- Helper function to check if a string represents a valid binary number -/\ndef isValidBinary (s : String) : Bool :=\n  s.length > 0 && s.all (fun c => c = '0' || c = '1')\n/-- Helper function to check if a string represents a valid signed binary number -/\ndef isValidSignedBinary (s : String) : Bool :=\n  if s.startsWith \"-\" then\n    isValidBinary (s.drop 1)\n  else\n    isValidBinary s", "vc-helpers": "", "vc-definitions": "def binary_repr (num : Int) (width : Option Nat := none) : Id String :=\n  sorry", "vc-theorems": "theorem binary_repr_spec (num : Int) (width : Option Nat := none) :\n    \u2983\u231cwidth.map (\u00b7 \u2265 1) |>.getD true\u231d\u2984\n    binary_repr num width\n    \u2983\u21d3result => \u231c\n      -- Result is a valid binary string (possibly with sign)\n      (width.isNone \u2192 isValidSignedBinary result) \u2227\n      (width.isSome \u2192 isValidBinary result) \u2227\n\n      -- Length constraints\n      (width.isSome \u2192 result.length = width.get!) \u2227\n\n      -- Positive numbers: standard binary representation\n      (num \u2265 0 \u2227 width.isNone \u2192 \n        result = natToBinaryString num.natAbs) \u2227\n\n      -- Positive numbers with width: padded with zeros\n      (num \u2265 0 \u2227 width.isSome \u2192 \n        \u2203 (binary : String), binary = natToBinaryString num.natAbs \u2227\n        result = String.mk (List.replicate (width.get! - binary.length) '0') ++ binary) \u2227\n\n      -- Negative numbers without width: signed representation\n      (num < 0 \u2227 width.isNone \u2192 \n        result = \"-\" ++ natToBinaryString num.natAbs) \u2227\n\n      -- Negative numbers with width: two's complement\n      (num < 0 \u2227 width.isSome \u2192 \n        let w := width.get!\n        let twoComp := (2^w : Int) + num\n        -- Two's complement is in valid range\n        (0 \u2264 twoComp \u2227 twoComp < 2^w) \u2227\n        -- Result represents the two's complement\n        result = natToBinaryString twoComp.natAbs \u2227\n        -- Padded with 1s if needed\n        result.length = w)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_bitwise_and", "vc-description": "/-  numpy.bitwise_and: Compute the bit-wise AND of two arrays element-wise.\n\n    Computes the bit-wise AND of the underlying binary representation of \n    the integers in the input arrays. This ufunc implements the C/Python \n    operator &.\n\n    For each pair of corresponding elements in x1 and x2, the result contains\n    the bitwise AND of their binary representations. Each bit position in the\n    result is 1 only if both corresponding bits in x1 and x2 are 1.\n\n    Examples:\n    - 13 & 17 = 1 (binary: 01101 & 10001 = 00001)\n    - 14 & 13 = 12 (binary: 01110 & 01101 = 01100)\n\n    Note: This specification currently handles only non-negative integers.\n    For negative integers, NumPy uses two's complement representation,\n    which requires a more complex formalization in Lean.\n-/\n\n/-  Specification: bitwise_and returns a vector where each element is the \n    bitwise AND of the corresponding elements from x1 and x2.\n\n    Precondition: All elements are non-negative (to simplify the specification)\n\n    Postcondition: \n    1. For non-negative integers, each element of the result is the bitwise AND \n       of corresponding inputs\n    2. The result preserves the mathematical properties of bitwise AND:\n       - Commutativity: x & y = y & x\n       - Associativity: (x & y) & z = x & (y & z)\n       - Identity: x & (2^k - 1) = x for x < 2^k (all 1s acts as identity)\n       - Annihilator: x & 0 = 0\n       - Idempotence: x & x = x\n    3. The result is always less than or equal to both inputs (for non-negative integers)\n    4. Each bit in the result is 1 iff both corresponding bits in the inputs are 1\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def bitwise_and {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem bitwise_and_spec {n : Nat} (x1 x2 : Vector Int n) \n    (h_nonneg : \u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0) :\n    \u2983\u231c\u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0\u231d\u2984\n    bitwise_and x1 x2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = Int.ofNat (Int.toNat (x1.get i) &&& Int.toNat (x2.get i))) \u2227\n                (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                (\u2200 i : Fin n, result.get i \u2264 x1.get i) \u2227\n                (\u2200 i : Fin n, result.get i \u2264 x2.get i) \u2227\n                (\u2200 i : Fin n, result.get i = 0 \u2194 (x1.get i = 0 \u2228 x2.get i = 0)) \u2227\n                (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_bitwise_count", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_count\",\n  \"category\": \"Bit counting\",\n  \"description\": \"Computes the number of 1-bits in the absolute value of x\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_count.html\",\n  \"doc\": \"Computes the number of 1-bits in the absolute value of x.\\n\\nAnalogous to the builtin int.bit_count or popcount in C++.\\n\\nParameters\\n----------\\nx : array_like, unsigned int\\n    Input array.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the condition is True, the out array will be set to the ufunc result.\\n\\nReturns\\n-------\\ny : ndarray\\n    The corresponding number of 1-bits in the input.\\n    Returns uint8 for all integer types.\\n    This is a scalar if x is a scalar.\\n\\nReferences\\n----------\\n.. [1] Wikipedia, \\\"Hamming weight\\\",\\n       https://en.wikipedia.org/wiki/Hamming_weight\\n.. [2] http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\\n.. [3] https://aggregate.ee.engr.uky.edu/MAGIC/#Population%20Count%20(Ones%20Count)\\n\\nExamples\\n--------\\n>>> np.bitwise_count(1023)\\nnp.uint8(10)\\n>>> a = np.array([2**i - 1 for i in range(16)])\\n>>> np.bitwise_count(a)\\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],\\n      dtype=uint8)\",\n}\n-/\n\n/-  Computes the number of 1-bits in the absolute value of each element in a vector -/\n\n/-  Specification: bitwise_count returns the count of 1-bits in the binary representation\n    of the absolute value of each element. The result satisfies several properties:\n    1. Each output element is the popcount of the corresponding input's absolute value\n    2. The popcount is bounded by the number of bits in the representation\n    3. Zero inputs produce zero outputs\n    4. Powers of 2 have exactly one bit set\n    5. Powers of 2 minus 1 have consecutive 1-bits (e.g., 2^k - 1 has k bits set)\n    6. The popcount is always non-negative and bounded by bit width\n    7. For negative inputs, uses the absolute value\n    8. The popcount operation is invariant under sign changes -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to count the number of 1-bits in a natural number -/\ndef popcount (n : Nat) : Nat :=\n  if n = 0 then 0 else (n % 2) + popcount (n / 2)", "vc-helpers": "", "vc-definitions": "def bitwise_count {n : Nat} (x : Vector Int n) : Id (Vector Nat n) :=\n  sorry", "vc-theorems": "theorem bitwise_count_spec {n : Nat} (x : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    bitwise_count x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = popcount (Int.natAbs (x.get i))) \u2227\n                 (\u2200 i : Fin n, result.get i \u2264 (Int.natAbs (x.get i)).log2 + 1) \u2227\n                 (\u2200 i : Fin n, x.get i = 0 \u2192 result.get i = 0) \u2227\n                 (\u2200 i : Fin n, \u2200 k : Nat, k > 0 \u2192 x.get i = 2^k \u2192 result.get i = 1) \u2227\n                 (\u2200 i : Fin n, \u2200 k : Nat, k > 0 \u2192 x.get i = 2^k - 1 \u2192 result.get i = k) \u2227\n                 (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                 (\u2200 i : Fin n, x.get i < 0 \u2192 result.get i = popcount (Int.natAbs (x.get i))) \u2227\n                 (\u2200 i : Fin n, \u2200 m : Int, x.get i = m \u2192 result.get i = popcount (Int.natAbs m)) \u2227\n                 (\u2200 i : Fin n, \u2200 j : Fin n, x.get i = -(x.get j) \u2192 result.get i = result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_bitwise_or", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_or\",\n  \"category\": \"Elementwise bit operations\",\n  \"description\": \"Compute the bit-wise OR of two arrays element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_or.html\",\n  \"doc\": \"Compute the bit-wise OR of two arrays element-wise.\\n\\nComputes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator |.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Only integer and boolean types are handled.\\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n\\nExamples\\n--------\\n>>> np.bitwise_or(13, 16)\\n29\\n>>> np.array([2, 5, 255]) | np.array([4, 4, 4])\\narray([6, 5, 255])\\n>>> np.bitwise_or([33, 4], 1)\\narray([33, 5])\\n>>> np.bitwise_or([33, 4], [1, 2])\\narray([33, 6])\",\n}\n-/\n\n/-  Compute the bit-wise OR of two vectors element-wise -/\n\n/-  Specification: bitwise_or computes the element-wise bitwise OR of two integer vectors\n    with the following mathematical properties:\n    1. Element-wise application of Int.bitwise_or\n    2. Identity property with zero vectors\n    3. Saturation property with all-ones vectors\n    4. Commutativity at vector level\n    5. Idempotency at vector level -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Axiomatically define bitwise OR operation on integers.\n    In the actual implementation, this would compute the bitwise OR\n    of the binary representations of two integers. -/\naxiom Int.bitwise_or : Int \u2192 Int \u2192 Int\n\n/-- Helper axiom for bitwise AND used in absorption law -/\naxiom Int.bitwise_and : Int \u2192 Int \u2192 Int\n\n/-- Bitwise OR with 0 is identity -/\naxiom bitwise_or_zero_right (x : Int) : Int.bitwise_or x 0 = x\n\n/-- Bitwise OR with 0 is identity (left) -/\naxiom bitwise_or_zero_left (x : Int) : Int.bitwise_or 0 x = x\n\n/-- Bitwise OR with -1 (all bits set) returns -1 -/\naxiom bitwise_or_neg_one_right (x : Int) : Int.bitwise_or x (-1) = -1\n\n/-- Bitwise OR with -1 (all bits set) returns -1 (left) -/\naxiom bitwise_or_neg_one_left (x : Int) : Int.bitwise_or (-1) x = -1\n\n/-- Bitwise OR is commutative -/\naxiom bitwise_or_comm (x y : Int) : Int.bitwise_or x y = Int.bitwise_or y x\n\n/-- Bitwise OR is associative -/\naxiom bitwise_or_assoc (x y z : Int) : Int.bitwise_or (Int.bitwise_or x y) z = Int.bitwise_or x (Int.bitwise_or y z)\n\n/-- Bitwise OR is idempotent -/\naxiom bitwise_or_idempotent (x : Int) : Int.bitwise_or x x = x\n\n/-- Bitwise OR absorption law: x | (x & y) = x -/\naxiom bitwise_or_absorption (x y : Int) : Int.bitwise_or x (Int.bitwise_and x y) = x\n\n/-- Bitwise OR is monotonic: if a \u2264 b then a | c \u2264 b | c (for non-negative values) -/\naxiom bitwise_or_monotonic_nonneg (a b c : Int) (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hc : 0 \u2264 c) (hab : a \u2264 b) : \n  Int.bitwise_or a c \u2264 Int.bitwise_or b c", "vc-helpers": "", "vc-definitions": "def bitwise_or {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem bitwise_or_spec {n : Nat} (x1 x2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    bitwise_or x1 x2\n    \u2983\u21d3result => \u231c\n      -- Basic element-wise operation\n      (\u2200 i : Fin n, result.get i = Int.bitwise_or (x1.get i) (x2.get i)) \u2227\n      -- Identity with zero vector (right)\n      (\u2200 i : Fin n, x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n      -- Identity with zero vector (left)\n      (\u2200 i : Fin n, x1.get i = 0 \u2192 result.get i = x2.get i) \u2227\n      -- Saturation with -1 (all bits set)\n      (\u2200 i : Fin n, x1.get i = -1 \u2228 x2.get i = -1 \u2192 result.get i = -1) \u2227\n      -- Result preserves bits from both inputs\n      (\u2200 i : Fin n, \u2200 k : Nat, \n        -- If bit k is set in x1[i] or x2[i], it's set in result[i]\n        -- (This is the fundamental property of OR operation)\n        True) \u2227  -- Abstract bit-level property\n      -- Commutativity verification\n      (bitwise_or x1 x2 = bitwise_or x2 x1) \u2227\n      -- Idempotency verification\n      (x1 = x2 \u2192 result = x1)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_bitwise_xor", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_xor\",\n  \"category\": \"Elementwise bit operations\",\n  \"description\": \"Compute the bit-wise XOR of two arrays element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_xor.html\",\n  \"doc\": \"Compute the bit-wise XOR of two arrays element-wise.\\n\\nComputes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Only integer and boolean types are handled.\\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n\\nExamples\\n--------\\n>>> np.bitwise_xor(13, 17)\\n28\\n>>> np.bitwise_xor(31, 5)\\n26\\n>>> np.bitwise_xor([31,3], 5)\\narray([26, 6])\\n>>> np.bitwise_xor([31,3], [5,6])\\narray([26, 5])\\n>>> np.array([True, True]) ^ np.array([False, True])\\narray([True, False])\",\n}\n-/\n\n/-  numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.\n\n    Computes the bit-wise XOR (exclusive OR) of the underlying binary representation \n    of the integers in the input arrays. This ufunc implements the C/Python \n    operator ^.\n\n    For each pair of corresponding elements in x1 and x2, the result contains\n    the bitwise XOR of their binary representations. Each bit position in the\n    result is 1 if and only if exactly one of the corresponding bits in x1 and x2 is 1.\n\n    Examples:\n    - 13 ^ 17 = 28 (binary: 01101 ^ 10001 = 11100)\n    - 31 ^ 5 = 26 (binary: 11111 ^ 00101 = 11010)\n    - 31 ^ 3 = 28 (binary: 11111 ^ 00011 = 11100)\n\n    Note: This specification currently handles only non-negative integers.\n    For negative integers, NumPy uses two's complement representation,\n    which requires a more complex formalization in Lean.\n-/\n\n/-  Specification: bitwise_xor returns a vector where each element is the \n    bitwise XOR of the corresponding elements from x1 and x2.\n\n    Precondition: All elements are non-negative (to simplify the specification)\n\n    Postcondition: \n    1. For non-negative integers, each element of the result is the bitwise XOR \n       of corresponding inputs\n    2. The result preserves the mathematical properties of bitwise XOR:\n       - Commutativity: x ^ y = y ^ x\n       - Associativity: (x ^ y) ^ z = x ^ (y ^ z)\n       - Identity: x ^ 0 = x (0 acts as identity)\n       - Self-inverse: x ^ x = 0 (every element is its own inverse)\n       - Involution: (x ^ y) ^ y = x (applying XOR twice with same value gives original)\n    3. For Boolean values (0 or 1), XOR acts as logical exclusive OR\n    4. The result bit at position k is 1 iff exactly one of the input bits at position k is 1\n    5. XOR with all-1s mask acts as bitwise NOT: x ^ (2^k - 1) = (2^k - 1) - x for x < 2^k\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def bitwise_xor {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem bitwise_xor_spec {n : Nat} (x1 x2 : Vector Int n) \n    (h_nonneg : \u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0) :\n    \u2983\u231c\u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0\u231d\u2984\n    bitwise_xor x1 x2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = Int.ofNat (Int.toNat (x1.get i) ^^^ Int.toNat (x2.get i))) \u2227\n                (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                (\u2200 i : Fin n, x1.get i = 0 \u2192 result.get i = x2.get i) \u2227\n                (\u2200 i : Fin n, x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n                (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_invert", "vc-description": "/- \n{\n  \"name\": \"numpy.invert\",\n  \"category\": \"Elementwise bit operations\",\n  \"description\": \"Compute bit-wise inversion, or bit-wise NOT, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.invert.html\",\n  \"doc\": \"Compute bit-wise inversion, or bit-wise NOT, element-wise.\\n\\nComputes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ~.\\n\\nFor signed integer inputs, the two's complement is returned. In a two's-complement system negative numbers are represented by the two's complement of the absolute value. This is the most common method of representing signed integers on computers. A N-bit two's-complement system can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\\n\\nParameters\\n----------\\nx : array_like\\n    Only integer and boolean types are handled.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n\\nNotes\\n-----\\nbitwise_not is an alias for invert:\\n\\n>>> np.bitwise_not is np.invert\\nTrue\\n\\nExamples\\n--------\\n>>> np.invert(np.array([13], dtype=np.uint8))\\narray([242], dtype=uint8)\\n>>> np.invert(np.array([13], dtype=np.uint16))\\narray([65522], dtype=uint16)\\n>>> np.invert(np.array([13], dtype=np.int8))\\narray([-14], dtype=int8)\\n>>> np.invert(np.array([True, False]))\\narray([False, True])\",\n}\n-/\n\n/-  Compute bit-wise inversion (NOT) of each element in a vector of integers.\n    For signed integers, this returns the two's complement. -/\n\n/-  Specification: invert computes the bitwise NOT operation element-wise.\n\n    Mathematical properties:\n    1. Two's complement relationship: ~x = -(x + 1)\n    2. Involution property: applying invert twice returns the original value\n    3. The operation preserves vector size\n    4. Identity relationships:\n       - ~0 = -1\n       - ~(-1) = 0\n    5. Sign flipping: ~x has opposite sign to x when x \u2260 -1\n\n    The specification captures both the element-wise nature and the \n    mathematical relationship for two's complement representation. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def invert {n : Nat} (x : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem invert_spec {n : Nat} (x : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    invert x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = -(x.get i + 1)) \u2227\n                 (result.size = n) \u2227\n                 (\u2200 i : Fin n, x.get i = 0 \u2192 result.get i = -1) \u2227\n                 (\u2200 i : Fin n, x.get i = -1 \u2192 result.get i = 0) \u2227\n                 (\u2200 i : Fin n, x.get i \u2260 -1 \u2192 (x.get i > 0 \u2194 result.get i < 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_left_shift", "vc-description": "/- \n{\n  \"name\": \"numpy.left_shift\",\n  \"category\": \"Bit shifting\",\n  \"description\": \"Shift the bits of an integer to the left\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.left_shift.html\",\n  \"doc\": \"Shift the bits of an integer to the left.\\n\\nBits are shifted to the left by appending x2 0s at the right of x1. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying x1 by 2**x2.\\n\\nParameters\\n----------\\nx1 : array_like of integer type\\n    Input values.\\nx2 : array_like of integer type\\n    Number of zeros to append to x1. Has to be non-negative.\\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\n\\nReturns\\n-------\\nout : ndarray of integer type\\n    Return x1 with bits shifted x2 times to the left.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\nright_shift : Shift the bits of an integer to the right.\\nbinary_repr : Return the binary representation of the input number as a string.\\n\\nExamples\\n--------\\n>>> np.left_shift(5, 2)\\n20\\n>>> np.left_shift(5, [1,2,3])\\narray([10, 20, 40])\\n\\nNote that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases:\\n\\n>>> a = np.left_shift(np.uint8(255), 1) # Expect 254\\n>>> print(a, type(a)) # Unexpected result due to upcasting\\n510 <class 'numpy.int64'>\\n>>> b = np.left_shift(np.uint8(255), np.uint8(1))\\n>>> print(b, type(b))\\n254 <class 'numpy.uint8'>\",\n}\n-/\n\n/-  Shift the bits of integers to the left element-wise.\n    This operation is equivalent to multiplying each element by 2^shift_amount. -/\n\n/-  Specification: left_shift performs bitwise left shift operation on each element.\n    The result is equivalent to multiplying x1[i] by 2^x2[i] for non-negative shifts.\n\n    Mathematical properties:\n    1. Core behavior: Each element result[i] = x1[i] * 2^x2[i] for non-negative shifts\n    2. Identity property: Shifting by 0 returns the original value\n    3. Zero preservation: Shifting zero always yields zero\n    4. Monotonicity: For positive values, left shifting increases magnitude\n    5. Composition property: left_shift(x, a) then left_shift(result, b) = left_shift(x, a+b) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def left_shift {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem left_shift_spec {n : Nat} (x1 x2 : Vector Int n) \n    (h_nonneg : \u2200 i : Fin n, x2.get i \u2265 0) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2265 0\u231d\u2984\n    left_shift x1 x2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = x1.get i * (2 ^ (x2.get i).toNat)) \u2227\n                 (\u2200 i : Fin n, x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n                 (\u2200 i : Fin n, x1.get i = 0 \u2192 result.get i = 0) \u2227\n                 (\u2200 i : Fin n, x1.get i > 0 \u2227 x2.get i > 0 \u2192 result.get i > x1.get i) \u2227\n                 (\u2200 i : Fin n, x1.get i < 0 \u2227 x2.get i > 0 \u2192 result.get i < x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_packbits", "vc-description": "/- \n{\n  \"name\": \"numpy.packbits\",\n  \"category\": \"Bit packing\",\n  \"description\": \"Packs the elements of a binary-valued array into bits in a uint8 array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.packbits.html\",\n  \"doc\": \"Packs the elements of a binary-valued array into bits in a uint8 array.\\n\\nThe result is padded to full bytes by inserting zero bits at the end.\\n\\nParameters\\n----------\\na : array_like\\n    An array of integers or booleans whose elements should be packed to bits.\\naxis : int, optional\\n    The dimension over which bit-packing is done.\\n    None implies packing the flattened array.\\nbitorder : {'big', 'little'}, optional\\n    The order of the input bits. 'big' will mimic bin(val), 3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], 'little' will reverse the order to [1, 1, 0, 0, 0, 0, 0, 0].\\n    Defaults to 'big'.\\n\\nReturns\\n-------\\npacked : ndarray\\n    Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of packed has the same number of dimensions as the input (unless axis is None, in which case the output is 1-D).\\n\\nExamples\\n--------\\n>>> a = np.array([[[1,0,1],\\n...                [0,1,0]],\\n...               [[1,1,0],\\n...                [0,0,1]]])\\n>>> b = np.packbits(a, axis=-1)\\n>>> b\\narray([[[160],\\n        [ 64]],\\n       [[192],\\n        [ 32]]], dtype=uint8)\\n\\nNote that in binary 160 = 2^5 + 2^7, 64 = 2^6, 192 = 2^6 + 2^7, and 32 = 2^5.\",\n}\n-/\n\n/-  Packs binary-valued elements into bits in a UInt8 array.\n    Each group of 8 binary values is packed into one UInt8.\n    The result is padded with zeros if needed. -/\n\n/-  Specification: packbits correctly packs binary values into UInt8 bytes according to bitorder.\n    For big-endian: first element goes to MSB (bit 7)\n    For little-endian: first element goes to LSB (bit 0) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Enumeration for bit ordering in packbits -/\ninductive BitOrder\n  | big    -- MSB first (default): bit 7 is first element\n  | little -- LSB first: bit 0 is first element", "vc-helpers": "", "vc-definitions": "def packbits {n : Nat} (a : Vector Bool n) (bitorder : BitOrder := BitOrder.big) : \n    Id (Vector UInt8 ((n + 7) / 8)) :=\n  sorry", "vc-theorems": "theorem packbits_spec {n : Nat} (a : Vector Bool n) (bitorder : BitOrder := BitOrder.big) :\n    \u2983\u231cTrue\u231d\u2984\n    packbits a bitorder\n    \u2983\u21d3result => \u231c\u2200 byte_idx : Fin ((n + 7) / 8), \n                  result.get byte_idx = \n                    (match bitorder with\n                     | BitOrder.big => \n                       -- Big-endian: bit 7 is first, bit 0 is last\n                       let start_idx := byte_idx.val * 8\n                       let bits_in_byte := min 8 (n - start_idx)\n                       (List.range bits_in_byte).foldl (fun acc bit_pos =>\n                         if h : start_idx + bit_pos < n then\n                           let bit := if a.get \u27e8start_idx + bit_pos, h\u27e9 then 1 else 0\n                           acc ||| (bit <<< (7 - bit_pos)).toUInt8\n                         else acc\n                       ) 0\n                     | BitOrder.little => \n                       -- Little-endian: bit 0 is first, bit 7 is last  \n                       let start_idx := byte_idx.val * 8\n                       let bits_in_byte := min 8 (n - start_idx)\n                       (List.range bits_in_byte).foldl (fun acc bit_pos =>\n                         if h : start_idx + bit_pos < n then\n                           let bit := if a.get \u27e8start_idx + bit_pos, h\u27e9 then 1 else 0\n                           acc ||| (bit <<< bit_pos).toUInt8\n                         else acc\n                       ) 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_right_shift", "vc-description": "/- \n{\n  \"name\": \"numpy.right_shift\",\n  \"category\": \"Bit shifting\",\n  \"description\": \"Shift the bits of an integer to the right\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.right_shift.html\",\n  \"doc\": \"Shift the bits of an integer to the right.\\n\\nBits are shifted to the right x2. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing x1 by 2**x2.\\n\\nParameters\\n----------\\nx1 : array_like, int\\n    Input values.\\nx2 : array_like, int\\n    Number of bits to remove at the right of x1.\\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\n\\nReturns\\n-------\\nout : ndarray, int\\n    Return x1 with bits shifted x2 times to the right.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\nleft_shift : Shift the bits of an integer to the left.\\nbinary_repr : Return the binary representation of the input number as a string.\\n\\nExamples\\n--------\\n>>> np.right_shift(10, 1)\\n5\\n>>> np.right_shift(10, [1,2,3])\\narray([5, 2, 1])\\n\\nThe >> operator can be used as a shorthand for np.right_shift on ndarrays.\\n\\n>>> x1 = 10\\n>>> x2 = np.array([1,2,3])\\n>>> x1 >> x2\\narray([5, 2, 1])\",\n}\n-/\n\n/-  Shift the bits of integers to the right element-wise.\n    Bits are shifted to the right by the corresponding amount in the shift array.\n    This operation is equivalent to dividing each element by 2^shift_amount (using integer division). -/\n\n/-  Specification: right_shift performs bitwise right shift operation element-wise.\n    For each element, shifting right by k bits is equivalent to integer division by 2^k.\n    The function ensures:\n    1. Non-negative shift amounts (sanity check)\n    2. Each result equals x1[i] >> x2[i], which is x1[i] / 2^x2[i] for non-negative inputs\n    3. For negative inputs, the behavior follows arithmetic right shift (sign extension)\n    4. Shifting by 0 returns the original value (identity property)\n    5. Consecutive shifts can be combined: (x >> a) >> b = x >> (a + b)\n    6. Right shift preserves sign: sign(x >> k) = sign(x) for k \u2265 0 -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def right_shift {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem right_shift_spec {n : Nat} (x1 x2 : Vector Int n) \n    (h_shift_nonneg : \u2200 i : Fin n, x2.get i \u2265 0) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2265 0\u231d\u2984\n    right_shift x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- For non-negative values, right shift equals division by 2^shift\n        (x1.get i \u2265 0 \u2192 result.get i = x1.get i / (2 ^ (x2.get i).natAbs)) \u2227\n        -- For negative values, we use arithmetic right shift (sign extension)\n        -- This maintains the property that x >> k = floor(x / 2^k)\n        (x1.get i < 0 \u2192 result.get i = Int.ediv (x1.get i) (2 ^ (x2.get i).natAbs)) \u2227\n        -- Identity property: shifting by 0 returns the original value\n        (x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n        -- Sign preservation: the sign of the result matches the sign of the input\n        ((x1.get i > 0 \u2192 result.get i \u2265 0) \u2227 \n         (x1.get i < 0 \u2192 result.get i \u2264 0) \u2227\n         (x1.get i = 0 \u2192 result.get i = 0)) \u2227\n        -- Bounded result: |result| \u2264 |input| for any non-negative shift\n        (Int.natAbs (result.get i) \u2264 Int.natAbs (x1.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "bitwise_operations_unpackbits", "vc-description": "/- \n{\n  \"name\": \"numpy.unpackbits\",\n  \"category\": \"Bit packing\",\n  \"description\": \"Unpacks elements of a uint8 array into a binary-valued output array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.unpackbits.html\",\n  \"doc\": \"Unpacks elements of a uint8 array into a binary-valued output array.\\n\\nEach element of a represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if axis is None) or the same shape as the input array with unpacking done along the axis specified.\\n\\nParameters\\n----------\\na : ndarray, uint8 type\\n    Input array.\\naxis : int, optional\\n    The dimension over which bit-unpacking is done.\\n    None implies unpacking the flattened array.\\ncount : int or None, optional\\n    The number of elements to unpack along axis, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack count bits. A negative number means to trim off that many bits from the end. None means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.\\nbitorder : {'big', 'little'}, optional\\n    The order of the returned bits. 'big' will mimic bin(val), 3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1], 'little' will reverse the order to [1, 1, 0, 0, 0, 0, 0, 0].\\n    Defaults to 'big'.\\n\\nReturns\\n-------\\nunpacked : ndarray, uint8 type\\n    The elements are binary-valued (0 or 1).\\n\\nExamples\\n--------\\n>>> a = np.array([[2], [7], [23]], dtype=np.uint8)\\n>>> a\\narray([[ 2],\\n       [ 7],\\n       [23]], dtype=uint8)\\n>>> b = np.unpackbits(a, axis=1)\\n>>> b\\narray([[0, 0, 0, 0, 0, 0, 1, 0],\\n       [0, 0, 0, 0, 0, 1, 1, 1],\\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\",\n}\n-/\n\n/-  numpy.unpackbits: Unpacks elements of a uint8 array into a binary-valued output array.\n\n    Each element of the input array represents a bit-field that is unpacked into\n    a binary-valued output array. By default, each uint8 value is unpacked into\n    8 binary values (0 or 1) using big-endian bit order.\n\n    This specification covers the basic 1D case with default parameters.\n    For simplicity, we use Nat instead of UInt8, with the constraint that input values < 256.\n-/\n\n/-  Specification: numpy.unpackbits unpacks each uint8 element into 8 binary values.\n\n    Precondition: All input elements must be valid uint8 values (< 256)\n    Postcondition: Each input element a[i] is unpacked into 8 bits in big-endian order,\n                   where bit j of element i is stored at position i*8 + j in the result.\n                   The bit extraction follows: (a[i] >> (7-j)) & 1\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_unpackbits {n : Nat} (a : Vector Nat n) : Id (Vector Nat (n * 8)) :=\n  sorry", "vc-theorems": "theorem numpy_unpackbits_spec {n : Nat} (a : Vector Nat n) \n    (h_uint8 : \u2200 i : Fin n, a.get i < 256) :\n    \u2983\u231c\u2200 i : Fin n, a.get i < 256\u231d\u2984\n    numpy_unpackbits a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \u2200 j : Fin 8,\n                  result.get \u27e8i.val * 8 + j.val, sorry\u27e9 = \n                  (a.get i / (2 ^ (7 - j.val))) % 2\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_False_", "vc-description": "/- \n{\n  \"name\": \"numpy.False_\",\n  \"category\": \"Boolean constants\",\n  \"description\": \"NumPy boolean scalar representing False\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.scalars.html\",\n  \"doc\": \"NumPy's boolean type. Character code: '?'. Alias for numpy.bool_.\\n\\nComparison operations in NumPy return numpy.True_ or numpy.False_ instead of Python's built-in True or False.\",\n}\n-/\n\n/-  NumPy's boolean False value, used in comparison operations and boolean arrays -/\n\n/-  Specification: False_ represents the boolean false value with properties:\n    1. It equals false\n    2. It is the identity for logical OR\n    3. It is the absorbing element for logical AND\n    4. It is the negation of True_ -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def False_ : Id Bool :=\n  sorry", "vc-theorems": "theorem False__spec :\n    \u2983\u231cTrue\u231d\u2984\n    False_\n    \u2983\u21d3result => \u231cresult = false \u2227 \n                 (\u2200 b : Bool, result || b = b) \u2227\n                 (\u2200 b : Bool, result && b = false) \u2227\n                 result = !true\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NINF", "vc-description": "/- \n{\n  \"name\": \"numpy.NINF\",\n  \"category\": \"Special float values (deprecated)\",\n  \"description\": \"IEEE 754 floating point representation of negative infinity\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html\",\n  \"doc\": \"IEEE 754 floating point representation of negative infinity.\\n\\nDEPRECATED: Removed from main namespace in NumPy 2.0. Use -np.inf instead.\",\n}\n-/\n\n/-  IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0) -/\n\n/-  Specification: NINF represents negative infinity with the following properties:\n    1. NINF is less than any finite float value\n    2. NINF + any finite value = NINF\n    3. NINF * positive finite value = NINF\n    4. NINF * negative finite value = inf\n    5. NINF / any finite non-zero value = NINF (with appropriate sign)\n    6. NINF = -inf (negative of positive infinity) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NINF : Id Float :=\n  sorry", "vc-theorems": "theorem NINF_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NINF\n    \u2983\u21d3result => \u231c\n      -- Property 1: NINF is less than all finite values\n      (\u2200 x : Float, Float.isFinite x \u2192 result < x) \u2227\n      -- Property 2: NINF + finite = NINF\n      (\u2200 x : Float, Float.isFinite x \u2192 result + x = result) \u2227\n      -- Property 3: NINF * positive finite = NINF\n      (\u2200 x : Float, Float.isFinite x \u2227 x > 0 \u2192 result * x = result) \u2227\n      -- Property 4: NINF * negative finite = positive infinity\n      (\u2200 x : Float, Float.isFinite x \u2227 x < 0 \u2192 result * x = -result) \u2227\n      -- Property 5: NINF / finite non-zero = NINF (with sign)\n      (\u2200 x : Float, Float.isFinite x \u2227 x \u2260 0 \u2192 \n        (x > 0 \u2192 result / x = result) \u2227 \n        (x < 0 \u2192 result / x = -result)) \u2227\n      -- Property 6: NINF is not finite\n      \u00acFloat.isFinite result \u2227\n      -- Property 7: NINF is negative\n      result < 0 \u2227\n      -- Property 8: NINF squared is positive infinity\n      result * result = -result \u2227\n      -- Property 9: Absolute value of NINF is positive infinity\n      Float.abs result = -result\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_1_PI", "vc-description": "/- \n{\n  \"name\": \"NPY_1_PI\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"1 divided by pi\",\n  \"doc\": \"1/\u03c0 = 0.318309886183790671537767526745028724\",\n}\n-/\n\n/-  The mathematical constant 1/\u03c0 (one divided by pi), approximately 0.31831... -/\n\n/-  Specification: NPY_1_PI represents the reciprocal of pi (1/\u03c0),\n    and satisfies key mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_1_PI : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_1_PI_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_1_PI\n    \u2983\u21d3result => \u231c\n      -- 1/\u03c0 is approximately 0.31831...\n      0.31830 < result \u2227 result < 0.31832 \u2227\n      -- Basic sanity check: 1/\u03c0 is between 0 and 1\n      0 < result \u2227 result < 1 \u2227\n      -- More precise bounds for 1/\u03c0\n      0.318309 < result \u2227 result < 0.318310 \u2227\n      -- 2/\u03c0 is approximately 0.6366... (double of 1/\u03c0)\n      0.6366 < 2 * result \u2227 2 * result < 0.6367 \u2227\n      -- (1/\u03c0)\u00b2 is approximately 0.10132...\n      0.10131 < result * result \u2227 result * result < 0.10133 \u2227\n      -- 1/(2\u03c0) is approximately 0.15915... (half of 1/\u03c0)\n      0.15915 < result / 2 \u2227 result / 2 < 0.15916 \u2227\n      -- Mathematical relationship: result * \u03c0 \u2248 1 (within floating point precision)\n      -- This would require having pi defined, so we check an approximation\n      -- result * 3.14159... \u2248 1\n      0.99999 < result * 3.141592653589793 \u2227 result * 3.141592653589793 < 1.00001\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_2_PI", "vc-description": "/- \n{\n  \"name\": \"NPY_2_PI\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"2 divided by pi\",\n  \"doc\": \"2/\u03c0 = 0.636619772367581343075535053490057448\",\n}\n-/\n\n/-  The mathematical constant 2/\u03c0, approximately 0.6366... -/\n\n/-  Specification: NPY_2_PI represents the ratio 2/\u03c0 and satisfies key mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_2_PI : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_2_PI_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_2_PI\n    \u2983\u21d3result => \u231c\n      -- 2/\u03c0 is approximately 0.6366...\n      0.6366 < result \u2227 result < 0.6367 \u2227\n      -- Basic sanity check: 2/\u03c0 is between 0 and 1\n      0 < result \u2227 result < 1 \u2227\n      -- More precise bounds\n      0.636619 < result \u2227 result < 0.636620 \u2227\n      -- Relationship with \u03c0: result * \u03c0 \u2248 2\n      -- Since \u03c0 \u2248 3.14159, result * \u03c0 should be close to 2\n      1.999 < result * 3.14159 \u2227 result * 3.14159 < 2.001 \u2227\n      -- Square of 2/\u03c0 is approximately 0.4053...\n      0.405 < result * result \u2227 result * result < 0.406 \u2227\n      -- 2/\u03c0 divided by 2 gives 1/\u03c0 \u2248 0.3183...\n      0.318 < result / 2 \u2227 result / 2 < 0.319\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_LOG10E", "vc-description": "/- \n{\n  \"name\": \"NPY_LOG10E\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Base 10 logarithm of e\",\n  \"doc\": \"log10(e) = 0.434294481903251827651128918916605082\",\n}\n-/\n\n/-  Base 10 logarithm of Euler's number e -/\n\n/-  Specification: nPY_LOG10E returns the base 10 logarithm of e with correct mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nPY_LOG10E : Id Float :=\n  sorry", "vc-theorems": "theorem nPY_LOG10E_spec :\n    \u2983\u231cTrue\u231d\u2984\n    nPY_LOG10E\n    \u2983\u21d3result => \u231c\n      -- The value should be log\u2081\u2080(e)\n      result = 0.434294481903251827651128918916605082 \u2227\n      -- Mathematical property: 10^result = e (within floating-point precision)\n      Float.abs (10.0 ^ result - Float.exp 1.0) < 1e-15 \u2227\n      -- Another mathematical property: result * ln(10) = 1 (since log\u2081\u2080(e) * ln(10) = ln(e) = 1)\n      Float.abs (result * Float.log 10.0 - 1.0) < 1e-15 \u2227\n      -- The value is positive (since e > 1 and log\u2081\u2080 is increasing)\n      result > 0.0 \u2227\n      -- The value is less than 1 (since e < 10)\n      result < 1.0\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_LOG2E", "vc-description": "/- \n{\n  \"name\": \"NPY_LOG2E\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Base 2 logarithm of e\",\n  \"doc\": \"log2(e) = 1.442695040888963407359924681001892137\",\n}\n-/\n\n/-  Base 2 logarithm of e (log\u2082(e)) -/\n\n/-  Specification: NPY_LOG2E is the base 2 logarithm of e with mathematical properties:\n    1. It is approximately 1.442695040888963407359924681001892137\n    2. It satisfies the relationship: 2^(NPY_LOG2E) = e\n    3. It is the reciprocal of ln(2) (i.e., NPY_LOG2E = 1/ln(2))\n    4. It is used to convert natural logarithms to base 2 logarithms via: log\u2082(x) = ln(x) * NPY_LOG2E -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_LOG2E : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_LOG2E_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_LOG2E\n    \u2983\u21d3result => \u231c\n      -- Sanity check: NPY_LOG2E is within reasonable bounds\n      1.442 < result \u2227 result < 1.443 \u2227\n      -- Mathematical property: NPY_LOG2E is approximately 1.442695040888963407359924681001892137\n      Float.abs (result - 1.442695040888963407359924681001892137) < 1e-15 \u2227\n      -- Mathematical property: NPY_LOG2E is positive\n      result > 0 \u2227\n      -- Mathematical property: NPY_LOG2E is greater than 1 but less than 2\n      1 < result \u2227 result < 2 \u2227\n      -- Mathematical property: More precise bounds for the constant\n      result > 1.4426950408 \u2227 result < 1.4426950409 \u2227\n      -- Mathematical property: NPY_LOG2E * ln(2) = 1 (within floating point precision)\n      Float.abs (result * 0.693147180559945309417232121458176568 - 1.0) < 1e-14\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_LOGE10", "vc-description": "/- \n{\n  \"name\": \"NPY_LOGE10\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Natural logarithm of 10\",\n  \"doc\": \"ln(10) = 2.302585092994045684017991454684364208\",\n}\n-/\n\n/-  Natural logarithm of 10 (ln(10)) -/\n\n/-  Specification: npy_loge10 is the natural logarithm of 10 with mathematical properties:\n    1. It is approximately 2.302585092994045684017991454684364208\n    2. It satisfies the property that e^(npy_loge10) = 10\n    3. It is the inverse of log10(e), meaning npy_loge10 * log10(e) = 1\n    4. It is useful for converting between natural and base-10 logarithms -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def npy_loge10 : Id Float :=\n  sorry", "vc-theorems": "theorem npy_loge10_spec :\n    \u2983\u231cTrue\u231d\u2984\n    npy_loge10\n    \u2983\u21d3result => \u231c\n      -- Sanity check: ln(10) is within reasonable bounds\n      2.302 < result \u2227 result < 2.303 \u2227\n      -- Mathematical property: ln(10) is approximately 2.302585092994045684017991454684364208\n      Float.abs (result - 2.302585092994045684017991454684364208) < 1e-15 \u2227\n      -- Mathematical property: ln(10) is positive (since 10 > 1)\n      result > 0 \u2227\n      -- Mathematical property: ln(10) > ln(e) = 1 (since 10 > e)\n      result > 1 \u2227\n      -- Mathematical property: ln(10) < ln(100) = 2*ln(10), so ln(10) < 2*ln(10)\n      result < 2 * result \u2227\n      -- Mathematical property: ln(10) is between 2 and 3\n      2 < result \u2227 result < 3 \u2227\n      -- Mathematical property: ln(10) * ln(e) < ln(10) (since ln(e) = 1)\n      result * 1 = result \u2227\n      -- Mathematical property: More precise bounds\n      2.30258 < result \u2227 result < 2.30259\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_LOGE2", "vc-description": "/- \n{\n  \"name\": \"NPY_LOGE2\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Natural logarithm of 2\",\n  \"doc\": \"ln(2) = 0.693147180559945309417232121458176568\",\n}\n-/\n\n/-  Natural logarithm of 2 -/\n\n/-  Specification: nPY_LOGE2 returns the natural logarithm of 2 with correct mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nPY_LOGE2 : Id Float :=\n  sorry", "vc-theorems": "theorem nPY_LOGE2_spec :\n    \u2983\u231cTrue\u231d\u2984\n    nPY_LOGE2\n    \u2983\u21d3result => \u231c\n      -- The value should be ln(2)\n      result = 0.693147180559945309417232121458176568 \u2227\n      -- Mathematical property: e^result = 2 (within floating-point precision)\n      Float.abs (Float.exp result - 2.0) < 1e-15 \u2227\n      -- Mathematical property: 2 * result = ln(4) (logarithm property)\n      Float.abs (2.0 * result - Float.log 4.0) < 1e-15 \u2227\n      -- Mathematical property: result + ln(3) = ln(6) (logarithm addition property)\n      Float.abs (result + Float.log 3.0 - Float.log 6.0) < 1e-15 \u2227\n      -- The value is positive (since 2 > 1 and ln is increasing)\n      result > 0.0 \u2227\n      -- The value is less than 1 (since 2 < e and ln is increasing)\n      result < 1.0 \u2227\n      -- More precise bounds check\n      0.693147 < result \u2227 result < 0.693148\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_PI_2", "vc-description": "/- \n{\n  \"name\": \"NPY_PI_2\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Pi divided by 2\",\n  \"doc\": \"\u03c0/2 = 1.570796326794896619231321691639751442\",\n}\n-/\n\n/-  The mathematical constant \u03c0/2 (pi divided by 2), approximately 1.5708... -/\n\n/-  Specification: NPY_PI_2 represents \u03c0/2, which is half of pi and corresponds to 90 degrees\n    in radians. It satisfies key mathematical properties related to trigonometry and geometry -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_PI_2 : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_PI_2_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_PI_2\n    \u2983\u21d3result => \u231c\n      -- \u03c0/2 is approximately 1.5708...\n      1.5707 < result \u2227 result < 1.5708 \u2227\n      -- Basic sanity check: \u03c0/2 is between 1 and 2\n      1 < result \u2227 result < 2 \u2227\n      -- \u03c0/2 squared is approximately 2.4674...\n      2.467 < result * result \u2227 result * result < 2.468 \u2227\n      -- 2*(\u03c0/2) should be approximately \u03c0 (3.14159...)\n      3.141 < 2 * result \u2227 2 * result < 3.142 \u2227\n      -- (\u03c0/2)/2 = \u03c0/4 is approximately 0.7854...\n      0.785 < result / 2 \u2227 result / 2 < 0.786 \u2227\n      -- 3*(\u03c0/2) = 3\u03c0/2 is approximately 4.7124... (270 degrees)\n      4.712 < 3 * result \u2227 3 * result < 4.713 \u2227\n      -- 4*(\u03c0/2) = 2\u03c0 is approximately 6.2832... (full circle)\n      6.283 < 4 * result \u2227 4 * result < 6.284\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_PI_4", "vc-description": "/- \n{\n  \"name\": \"NPY_PI_4\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Pi divided by 4\",\n  \"doc\": \"\u03c0/4 = 0.785398163397448309615660845819875721\",\n}\n-/\n\n/-  NPY_PI_4: Mathematical constant representing \u03c0/4.\n\n    This constant provides the value of pi divided by 4, which is commonly used in\n    trigonometric calculations, particularly for 45-degree angle computations.\n\n    Value: \u03c0/4 \u2248 0.785398163397448309615660845819875721\n-/\n\n/-  Specification: NPY_PI_4 returns the mathematical constant \u03c0/4.\n\n    Precondition: True (no preconditions for accessing a constant)\n    Postcondition: The result equals \u03c0/4, which is approximately 0.7853981633974483\n\n    Mathematical properties:\n    - NPY_PI_4 = \u03c0/4\n    - NPY_PI_4 = arctan(1)  \n    - sin(NPY_PI_4) = cos(NPY_PI_4) = \u221a2/2\n    - tan(NPY_PI_4) = 1\n    - 4 * NPY_PI_4 = \u03c0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_PI_4 : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_PI_4_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_PI_4\n    \u2983\u21d3result => \u231cresult = 0.785398163397448309615660845819875721 \u2227\n                  result > 0.785 \u2227 result < 0.786 \u2227\n                  result * 4 > 3.141 \u2227 result * 4 < 3.142\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_SQRT1_2", "vc-description": "/- \n{\n  \"name\": \"NPY_SQRT1_2\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Square root of 1/2\",\n  \"doc\": \"\u221a(1/2) = 0.707106781186547524400844362104849039\",\n}\n-/\n\n/-  NPY_SQRT1_2: Square root of 1/2 as a Float constant -/\n\n/-  Specification: NPY_SQRT1_2 equals the square root of 1/2 with mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_SQRT1_2 : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_SQRT1_2_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_SQRT1_2\n    \u2983\u21d3result => \u231cresult * result = 0.5 \u2227 \n                 result > 0 \u2227\n                 result = Float.sqrt 0.5 \u2227\n                 result = 1.0 / Float.sqrt 2.0 \u2227\n                 Float.abs (result - 0.707106781186547524400844362104849039) < 1e-15\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NPY_SQRT2", "vc-description": "/- \n{\n  \"name\": \"NPY_SQRT2\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Square root of 2\",\n  \"doc\": \"\u221a2 = 1.414213562373095048801688724209698079\",\n}\n-/\n\n/-  The square root of 2 as a mathematical constant -/\n\n/-  Specification: NPY_SQRT2 represents the square root of 2 with appropriate mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NPY_SQRT2 : Id Float :=\n  sorry", "vc-theorems": "theorem NPY_SQRT2_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NPY_SQRT2\n    \u2983\u21d3result => \u231c\n      -- Sanity check: result is positive\n      result > 0 \u2227\n      -- Mathematical property: result squared equals 2 (within floating-point precision)\n      Float.abs (result * result - 2.0) < 1e-15 \u2227\n      -- Value check: result is approximately 1.414213562373095\n      Float.abs (result - 1.414213562373095048801688724209698079) < 1e-15\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_NZERO", "vc-description": "/- \n{\n  \"name\": \"numpy.NZERO\",\n  \"category\": \"Special float values (deprecated)\",\n  \"description\": \"IEEE 754 floating point representation of negative zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html\",\n  \"doc\": \"IEEE 754 floating point representation of negative zero.\\n\\nDEPRECATED: Removed from main namespace in NumPy 2.0. Use -0.0 instead.\",\n}\n-/\n\n/-  IEEE 754 floating point representation of negative zero -/\n\n/-  Specification: NZERO represents IEEE 754 negative zero, which equals zero \n    but has special properties in floating point arithmetic -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def NZERO : Id Float :=\n  sorry", "vc-theorems": "theorem NZERO_spec :\n    \u2983\u231cTrue\u231d\u2984\n    NZERO\n    \u2983\u21d3result => \u231c\n      -- Negative zero equals positive zero in value\n      result = 0.0 \u2227\n      -- Basic arithmetic properties\n      result + 0.0 = 0.0 \u2227\n      result - 0.0 = 0.0 \u2227\n      result * 1.0 = 0.0 \u2227\n      -- Multiplication by positive number preserves negative zero\n      result * 2.0 = 0.0 \u2227\n      -- Division properties (note: in IEEE 754, 1.0 / -0.0 = -\u221e)\n      result / 1.0 = 0.0 \u2227\n      -- Addition with positive numbers\n      result + 1.0 = 1.0 \u2227\n      result + (-1.0) = -1.0 \u2227\n      -- Subtraction properties\n      1.0 - result = 1.0 \u2227\n      (-1.0) - result = -1.0 \u2227\n      -- Absolute value of negative zero is positive zero\n      Float.abs result = 0.0\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_PZERO", "vc-description": "/- \n{\n  \"name\": \"numpy.PZERO\",\n  \"category\": \"Special float values (deprecated)\",\n  \"description\": \"IEEE 754 floating point representation of positive zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html\",\n  \"doc\": \"IEEE 754 floating point representation of positive zero.\\n\\nDEPRECATED: Removed from main namespace in NumPy 2.0. Use 0.0 instead.\",\n}\n-/\n\n/-  IEEE 754 floating point representation of positive zero -/\n\n/-  Specification: PZERO represents IEEE 754 positive zero with the following properties:\n    1. It equals the standard zero value\n    2. It behaves as the additive identity\n    3. It behaves as expected in multiplication and division\n    4. It has special IEEE 754 properties (e.g., 1.0 / PZERO = +\u221e) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def PZERO : Id Float :=\n  sorry", "vc-theorems": "theorem PZERO_spec :\n    \u2983\u231cTrue\u231d\u2984\n    PZERO\n    \u2983\u21d3result => \u231c\n      -- Positive zero equals zero in value\n      result = 0.0 \u2227\n      -- Additive identity properties\n      (\u2200 x : Float, x + result = x) \u2227\n      (\u2200 x : Float, result + x = x) \u2227\n      -- Multiplicative zero properties\n      (\u2200 x : Float, Float.isFinite x \u2192 result * x = 0.0) \u2227\n      (\u2200 x : Float, Float.isFinite x \u2192 x * result = 0.0) \u2227\n      -- Subtraction properties\n      (\u2200 x : Float, x - result = x) \u2227\n      (\u2200 x : Float, result - x = -x) \u2227\n      -- Division properties\n      result / 1.0 = 0.0 \u2227\n      result / (-1.0) = 0.0 \u2227\n      -- Note: 1.0 / result would be +\u221e in IEEE 754\n      -- Square and square root\n      result * result = 0.0 \u2227\n      Float.sqrt result = 0.0 \u2227\n      -- Absolute value\n      Float.abs result = 0.0 \u2227\n      -- Comparison properties\n      result \u2265 0.0 \u2227\n      result \u2264 0.0 \u2227\n      \u00ac(result > 0.0) \u2227\n      \u00ac(result < 0.0) \u2227\n      -- Is finite\n      Float.isFinite result\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_True_", "vc-description": "/- \n{\n  \"name\": \"numpy.True_\",\n  \"category\": \"Boolean constants\",\n  \"description\": \"NumPy boolean scalar representing True\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.scalars.html\",\n  \"doc\": \"NumPy's boolean type. Character code: '?'. Alias for numpy.bool_.\\n\\nComparison operations in NumPy return numpy.True_ or numpy.False_ instead of Python's built-in True or False.\",\n}\n-/\n\n/-  NumPy's boolean scalar type representing True.\n    This is NumPy's equivalent of Python's built-in True, but as a NumPy scalar type.\n    Comparison operations in NumPy return this type instead of Python's bool. -/\n\n/-  Specification: numpy.True_ represents the boolean value true and has the following properties:\n    1. It equals the Lean boolean true\n    2. It is the identity element for logical AND operations\n    3. It is the absorbing element for logical OR operations\n    4. Its negation gives false -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def True_ : Id Bool :=\n  sorry", "vc-theorems": "theorem True__spec :\n    \u2983\u231cTrue\u231d\u2984\n    True_\n    \u2983\u21d3result => \u231cresult = true \u2227 \n                 (\u2200 b : Bool, result && b = b) \u2227\n                 (\u2200 b : Bool, result || b = true) \u2227\n                 (!result = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_e", "vc-description": "/- \n{\n  \"name\": \"numpy.e\",\n  \"category\": \"Mathematical constants\",\n  \"description\": \"Euler's constant, base of natural logarithms, Napier's constant\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.e\",\n  \"doc\": \"e = 2.71828182845904523536028747135266249775724709369995...\\n\\nEuler's number is the base of the natural logarithm. It is the unique number whose natural logarithm is equal to one.\",\n}\n-/\n\n/-  Euler's constant (e), the base of natural logarithms -/\n\n/-  Specification: e is Euler's constant with mathematical properties:\n    1. It is approximately 2.718281828459045\n    2. It is the unique positive real number such that ln(e) = 1\n    3. It is the limit of (1 + 1/n)^n as n approaches infinity\n    4. It satisfies the property that the derivative of e^x equals e^x\n    5. It is the sum of the infinite series 1/0! + 1/1! + 1/2! + ... -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def e : Id Float :=\n  sorry", "vc-theorems": "theorem e_spec :\n    \u2983\u231cTrue\u231d\u2984\n    e\n    \u2983\u21d3result => \u231c\n      -- Sanity check: e is within reasonable bounds\n      2.718 < result \u2227 result < 2.719 \u2227\n      -- Mathematical property: e is approximately 2.718281828459045 (NumPy's precision)\n      Float.abs (result - 2.718281828459045) < 1e-15 \u2227\n      -- Mathematical property: e is positive\n      result > 0 \u2227\n      -- Mathematical property: e is greater than 2 but less than 3\n      2 < result \u2227 result < 3 \u2227\n      -- Mathematical property: More precise bounds based on known rational approximations\n      -- e is between 2.71828182 and 2.71828183\n      2.71828182 < result \u2227 result < 2.71828183 \u2227\n      -- Mathematical property: e > 5/2 and e < 11/4 (classical rational bounds)\n      result > 2.5 \u2227 result < 2.75 \u2227\n      -- Mathematical property: e is greater than (1 + 1/1000000)^1000000 (approximation of limit definition)\n      -- This approximates the limit definition of e = lim(n\u2192\u221e) (1 + 1/n)^n\n      result > 2.71828 \u2227\n      -- Mathematical property: Relation to natural logarithm base (if ln(x) = 1 then x = e)\n      -- This captures that e is the unique number whose natural logarithm equals 1\n      -- NumPy's value should satisfy this within floating-point precision\n      Float.abs (Float.log result - 1.0) < 1e-15\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_euler_gamma", "vc-description": "/- \n{\n  \"name\": \"numpy.euler_gamma\",\n  \"category\": \"Mathematical constants\",\n  \"description\": \"Euler-Mascheroni constant \u03b3\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.euler_gamma\",\n  \"doc\": \"\u03b3 = 0.5772156649015328606065120900824024310421...\\n\\nThe Euler-Mascheroni constant is a mathematical constant recurring in analysis and number theory, defined as the limiting difference between the harmonic series and the natural logarithm.\",\n}\n-/\n\n/-  The Euler-Mascheroni constant (\u03b3), approximately 0.577215... -/\n\n/-  Specification: euler_gamma represents the Euler-Mascheroni constant \u03b3,\n    which is the limiting difference between the harmonic series and the natural logarithm.\n    It satisfies key mathematical properties and bounds -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def euler_gamma : Id Float :=\n  sorry", "vc-theorems": "theorem euler_gamma_spec :\n    \u2983\u231cTrue\u231d\u2984\n    euler_gamma\n    \u2983\u21d3result => \u231c\n      -- Sanity check: euler_gamma is within reasonable bounds\n      0.577 < result \u2227 result < 0.578 \u2227\n      -- Mathematical property: euler_gamma is approximately 0.5772156649015329\n      Float.abs (result - 0.5772156649015329) < 1e-15 \u2227\n      -- Mathematical property: euler_gamma is positive\n      result > 0 \u2227\n      -- Mathematical property: euler_gamma is less than 1\n      result < 1 \u2227\n      -- Mathematical property: euler_gamma is between 0.5 and 0.6\n      0.5 < result \u2227 result < 0.6 \u2227\n      -- More precise bounds for numerical calculations\n      0.5772156649 < result \u2227 result < 0.5772156650 \u2227\n      -- Mathematical property: 1 - euler_gamma is positive (approximately 0.4228...)\n      0 < 1 - result \u2227 1 - result < 0.5\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_finfo", "vc-description": "/- \n{\n  \"name\": \"numpy.finfo\",\n  \"category\": \"Machine limits\",\n  \"description\": \"Machine limits for floating point types\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.finfo.html\",\n  \"doc\": \"Machine limits for floating point types.\\n\\nParameters:\\ndtype : float, dtype, or instance\\n    Kind of floating point or complex floating point data-type about which to get information.\\n\\nAttributes:\\n- eps : float - The difference between 1.0 and the next smallest representable float larger than 1.0\\n- epsneg : float - The difference between 1.0 and the next smallest representable float less than 1.0\\n- max : floating point number of the appropriate type - Largest representable number\\n- maxexp : int - The smallest positive power of the base (2) that causes overflow\\n- min : floating point number of the appropriate type - Smallest representable number, typically -max\\n- minexp : int - The most negative power of the base (2) consistent with there being no leading zeros in the mantissa\\n- negep : int - The exponent that yields epsneg\\n- nexp : int - The number of bits in the exponent including its sign and bias\\n- nmant : int - The number of bits in the mantissa\\n- precision : int - The approximate number of decimal digits to which this kind of float is precise\\n- resolution : floating point number of the appropriate type - The approximate decimal resolution of this type\\n- tiny : float - An alias for smallest_normal\\n- smallest_normal : float - The smallest positive normal number\\n- smallest_subnormal : float - The smallest positive number\",\n}\n-/\n\n/-  numpy.finfo: Returns machine limits for floating point types.\n\n    Given a floating-point data type, returns a structure containing\n    information about the numerical properties and limits of that type,\n    including epsilon, maximum/minimum values, and precision details.\n\n    For now, we model this as a function that takes Unit and returns\n    FloatInfo for the default Float type.\n-/\n\n/-  Specification: numpy.finfo returns consistent and mathematically valid\n    information about floating-point type limits.\n\n    The returned structure satisfies fundamental properties of floating-point\n    representations according to IEEE 754 standard.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing floating-point type information -/\nstructure FloatInfo where\n  eps : Float              -- Machine epsilon\n  epsneg : Float           -- Negative machine epsilon  \n  max : Float              -- Maximum representable value\n  min : Float              -- Minimum representable value (typically -max)\n  tiny : Float             -- Smallest positive normal number\n  smallest_subnormal : Float -- Smallest positive subnormal number\n  maxexp : Int             -- Maximum exponent\n  minexp : Int             -- Minimum exponent\n  negep : Int              -- Negative epsilon exponent\n  nexp : Nat               -- Number of bits in exponent\n  nmant : Nat              -- Number of bits in mantissa\n  precision : Nat          -- Approximate decimal precision", "vc-helpers": "", "vc-definitions": "def numpy_finfo : Id FloatInfo :=\n  sorry", "vc-theorems": "theorem numpy_finfo_spec :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_finfo\n    \u2983\u21d3info => \u231c\n      -- Machine epsilon is positive\n      info.eps > 0 \u2227\n      -- Negative epsilon is positive  \n      info.epsneg > 0 \u2227\n      -- eps represents the gap from 1.0 to next larger float\n      1.0 + info.eps > 1.0 \u2227\n      -- epsneg represents the gap from 1.0 to next smaller float\n      1.0 - info.epsneg < 1.0 \u2227\n      -- Max is positive and finite\n      info.max > 0 \u2227\n      -- Min is negative max (for symmetric representation)\n      info.min = -info.max \u2227\n      -- Tiny (smallest normal) is positive\n      info.tiny > 0 \u2227\n      -- Smallest subnormal is positive and less than tiny\n      info.smallest_subnormal > 0 \u2227\n      info.smallest_subnormal < info.tiny \u2227\n      -- Exponent relationships\n      info.maxexp > 0 \u2227\n      info.minexp < 0 \u2227\n      info.negep < 0 \u2227\n      -- Bit counts are positive\n      info.nexp > 0 \u2227\n      info.nmant > 0 \u2227\n      -- Precision is at least 1\n      info.precision \u2265 1 \u2227\n      -- Relationship between max value and maxexp (2^maxexp causes overflow)\n      Float.ofNat (2^info.maxexp.natAbs) > info.max \u2227\n      -- Relationship between mantissa bits and precision\n      -- Approximately: precision \u2248 mantissa_bits * log10(2)\n      info.precision \u2264 info.nmant\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_iinfo", "vc-description": "/- \n{\n  \"name\": \"numpy.iinfo\",\n  \"category\": \"Machine limits\",\n  \"description\": \"Machine limits for integer types\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.iinfo.html\",\n  \"doc\": \"Machine limits for integer types.\\n\\nParameters:\\nint_type : integer type, dtype, or instance\\n    The kind of integer data type to get information about.\\n\\nAttributes:\\n- bits : int - The number of bits occupied by the type\\n- dtype : dtype - The dtype for which iinfo returns information\\n- min : int - Minimum value of given dtype\\n- max : int - Maximum value of given dtype\",\n}\n-/\n\n/-  Machine limits for integer types - returns information about the given integer type including \n    the number of bits, minimum value, and maximum value -/\n\n/-  Specification: iinfo returns correct machine limits for integer types.\n    The returned IntegerInfo structure contains:\n    - bits: the number of bits used by the type\n    - min: the minimum representable value (-(2^(bits-1)) for signed, 0 for unsigned)\n    - max: the maximum representable value (2^(bits-1) - 1 for signed, 2^bits - 1 for unsigned) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing integer type information -/\nstructure IntegerInfo where\n  bits : Nat\n  min : Int\n  max : Int\n\n/-- Enumeration of supported integer types -/\ninductive IntegerType\n  | Int8\n  | Int16\n  | Int32\n  | Int64\n  | UInt8\n  | UInt16\n  | UInt32\n  | UInt64", "vc-helpers": "", "vc-definitions": "def iinfo (intType : IntegerType) : Id IntegerInfo :=\n  sorry", "vc-theorems": "theorem iinfo_spec (intType : IntegerType) :\n    \u2983\u231cTrue\u231d\u2984\n    iinfo intType\n    \u2983\u21d3info => \u231cmatch intType with\n      | IntegerType.Int8 => \n          info.bits = 8 \u2227 info.min = -128 \u2227 info.max = 127\n      | IntegerType.Int16 => \n          info.bits = 16 \u2227 info.min = -32768 \u2227 info.max = 32767\n      | IntegerType.Int32 => \n          info.bits = 32 \u2227 info.min = -2147483648 \u2227 info.max = 2147483647\n      | IntegerType.Int64 => \n          info.bits = 64 \u2227 info.min = -9223372036854775808 \u2227 info.max = 9223372036854775807\n      | IntegerType.UInt8 => \n          info.bits = 8 \u2227 info.min = 0 \u2227 info.max = 255\n      | IntegerType.UInt16 => \n          info.bits = 16 \u2227 info.min = 0 \u2227 info.max = 65535\n      | IntegerType.UInt32 => \n          info.bits = 32 \u2227 info.min = 0 \u2227 info.max = 4294967295\n      | IntegerType.UInt64 => \n          info.bits = 64 \u2227 info.min = 0 \u2227 info.max = 18446744073709551615\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_inf", "vc-description": "/- \n{\n  \"name\": \"numpy.inf\",\n  \"category\": \"Special float values\",\n  \"description\": \"IEEE 754 floating point representation of (positive) infinity\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.inf\",\n  \"doc\": \"IEEE 754 floating point representation of (positive) infinity.\\n\\nUse inf because Inf, Infinity, PINF and infty are aliases for inf. For more details, see inf.\\n\\nSee Also:\\ninf\",\n}\n-/\n\n/-  IEEE 754 floating point representation of (positive) infinity -/\n\n/-  Specification: inf represents positive infinity with the following properties:\n    1. inf is greater than any finite float value\n    2. inf + any finite value = inf\n    3. inf * positive finite value = inf\n    4. inf * negative finite value = -inf\n    5. inf / any finite non-zero value = inf (with appropriate sign) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def inf : Id Float :=\n  sorry", "vc-theorems": "theorem inf_spec :\n    \u2983\u231cTrue\u231d\u2984\n    inf\n    \u2983\u21d3result => \u231c\n      -- Property 1: inf is greater than all finite values\n      (\u2200 x : Float, Float.isFinite x \u2192 result > x) \u2227\n      -- Property 2: inf + finite = inf\n      (\u2200 x : Float, Float.isFinite x \u2192 result + x = result) \u2227\n      -- Property 3: inf * positive finite = inf\n      (\u2200 x : Float, Float.isFinite x \u2227 x > 0 \u2192 result * x = result) \u2227\n      -- Property 4: inf * negative finite = -inf\n      (\u2200 x : Float, Float.isFinite x \u2227 x < 0 \u2192 result * x = -result) \u2227\n      -- Property 5: inf / finite non-zero = inf (with sign)\n      (\u2200 x : Float, Float.isFinite x \u2227 x \u2260 0 \u2192 \n        (x > 0 \u2192 result / x = result) \u2227 \n        (x < 0 \u2192 result / x = -result)) \u2227\n      -- Property 6: inf is not finite\n      \u00acFloat.isFinite result \u2227\n      -- Property 7: inf is positive\n      result > 0\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_nan", "vc-description": "/- \n{\n  \"name\": \"numpy.nan\",\n  \"category\": \"Special float values\",\n  \"description\": \"IEEE 754 floating point representation of Not a Number (NaN)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.nan\",\n  \"doc\": \"IEEE 754 floating point representation of Not a Number (NaN).\\n\\nNaN and NAN are aliases for nan. Please use nan instead of NAN.\\n\\nSee Also:\\nnan\",\n}\n-/\n\n/-  IEEE 754 floating point representation of Not a Number (NaN) -/\n\n/-  Specification: nan represents Not a Number with the following IEEE 754 properties:\n    1. Float.isNaN returns true for NaN (primary property)\n    2. Any arithmetic operation with NaN results in NaN\n    3. NaN is not ordered (comparisons with any value are false except \u2260)\n    4. NaN is not finite\n    5. Standard operations preserve NaN propagation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nan : Id Float :=\n  sorry", "vc-theorems": "theorem nan_spec :\n    \u2983\u231cTrue\u231d\u2984\n    nan\n    \u2983\u21d3result => \u231c\n      -- Property 1: isNaN returns true (primary characterization)\n      Float.isNaN result \u2227\n      -- Property 2: Arithmetic operations with NaN produce NaN\n      (\u2200 x : Float, Float.isNaN (result + x)) \u2227\n      (\u2200 x : Float, Float.isNaN (result - x)) \u2227\n      (\u2200 x : Float, Float.isNaN (result * x)) \u2227\n      (\u2200 x : Float, x \u2260 0 \u2192 Float.isNaN (result / x)) \u2227\n      -- Property 3: NaN is unordered (all strict comparisons are false)\n      (\u2200 x : Float, \u00ac(result < x)) \u2227\n      (\u2200 x : Float, \u00ac(result > x)) \u2227\n      (\u2200 x : Float, \u00ac(x < result)) \u2227\n      (\u2200 x : Float, \u00ac(x > result)) \u2227\n      -- Property 4: NaN is not finite\n      \u00acFloat.isFinite result \u2227\n      -- Property 5: Additional NaN properties\n      Float.isNaN (result * 0) \u2227\n      Float.isNaN (0 / result) \u2227\n      Float.isNaN (result - result) \u2227\n      Float.isNaN (Float.sqrt result)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_newaxis", "vc-description": "/- \n{\n  \"name\": \"numpy.newaxis\",\n  \"category\": \"Indexing helpers\",\n  \"description\": \"A convenient alias for None, useful for indexing arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis\",\n  \"doc\": \"newaxis is an alias for None and is used to expand the dimensions of an array.\\n\\nExamples:\\n>>> a = np.array([1, 2, 3])\\n>>> a.shape\\n(3,)\\n>>> a[:, np.newaxis].shape\\n(3, 1)\\n>>> a[np.newaxis, :].shape\\n(1, 3)\",\n}\n-/\n\n/-  Expands a vector to a column matrix (n \u00d7 1) using newaxis.\n    This models the behavior of a[:, np.newaxis] which converts\n    a 1D array of shape (n,) to a 2D array of shape (n, 1). -/\n\n/-  Specification: expandToColumn creates a column matrix where each element\n    is a singleton vector containing the corresponding element from the input vector.\n\n    Mathematical property:\n    - The resulting matrix has shape (n, 1)\n    - Each row contains exactly one element from the original vector\n    - result[i][0] = v[i] for all valid indices -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents the newaxis constant used for dimension expansion.\n    In NumPy, newaxis is used in indexing to add new dimensions to arrays.\n    For our Vector-based implementation, we model this as a function that\n    converts a 1D vector into a 2D vector (matrix) with either shape (n, 1) or (1, n). -/\ninductive NewAxis where\n  | newaxis", "vc-helpers": "", "vc-definitions": "def expandToColumn {T : Type} {n : Nat} (v : Vector T n) (axis : NewAxis) : Id (Vector (Vector T 1) n) :=\n  sorry", "vc-theorems": "theorem expandToColumn_spec {T : Type} {n : Nat} (v : Vector T n) (axis : NewAxis) :\n    \u2983\u231cTrue\u231d\u2984\n    expandToColumn v axis\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                   (result.get i).size = 1 \u2227 \n                   (result.get i).get \u27e80, by simp\u27e9 = v.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "constants_pi", "vc-description": "/- \n{\n  \"name\": \"numpy.pi\",\n  \"category\": \"Mathematical constants\",\n  \"description\": \"Ratio of a circle's circumference to its diameter\",\n  \"url\": \"https://numpy.org/doc/stable/reference/constants.html#numpy.pi\",\n  \"doc\": \"pi = 3.1415926535897932384626433...\\n\\nPi is the ratio of a circle's circumference to its diameter. It is a mathematical constant that appears in many formulas in mathematics and physics.\",\n}\n-/\n\n/-  The mathematical constant pi (\u03c0), approximately 3.14159... -/\n\n/-  Specification: pi represents the ratio of a circle's circumference to its diameter,\n    and satisfies key mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def pi : Id Float :=\n  sorry", "vc-theorems": "theorem pi_spec :\n    \u2983\u231cTrue\u231d\u2984\n    pi\n    \u2983\u21d3result => \u231c\n      -- Pi is approximately 3.14159...\n      3.14159 < result \u2227 result < 3.14160 \u2227\n      -- Pi is between 3 and 4 (basic sanity check)\n      3 < result \u2227 result < 4 \u2227\n      -- Pi squared is approximately 9.8696... (useful for area calculations)\n      9.869 < result * result \u2227 result * result < 9.870 \u2227\n      -- 2*pi is approximately 6.28318... (useful for full circle calculations)\n      6.283 < 2 * result \u2227 2 * result < 6.284 \u2227\n      -- pi/2 is approximately 1.5708... (useful for quarter circle calculations)\n      1.570 < result / 2 \u2227 result / 2 < 1.571 \u2227\n      -- pi/4 is approximately 0.7854... (useful for eighth circle calculations)\n      0.785 < result / 4 \u2227 result / 4 < 0.786\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_as_strided", "vc-description": "/- \n{\n  \"name\": \"numpy.as_strided\",\n  \"category\": \"Memory and Striding\",\n  \"description\": \"Create a view into the array with the given shape and strides\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.lib.stride_tricks.as_strided.html\",\n  \"doc\": \"Create a view into the array with the given shape and strides.\\n\\nWarning: This function has to be used with extreme care, see notes.\\n\\nParameters\\n----------\\nx : ndarray\\n    Array to create a new view for.\\nshape : sequence of int, optional\\n    The shape of the new array. Defaults to x.shape.\\nstrides : sequence of int, optional\\n    The strides of the new array. Defaults to x.strides.\\nsubok : bool, optional\\n    If True, subclasses are preserved.\\nwriteable : bool, optional\\n    If set to False, the returned array will always be readonly.\\n\\nReturns\\n-------\\nview : ndarray\\n\\nNotes\\n-----\\nas_strided creates a view into the array given the exact strides and shape. This means it manipulates the internal data structure of ndarray and, if done incorrectly, the array elements can point to invalid memory and can corrupt results or crash your program.\\n\\nExamples\\n--------\\n>>> x = np.array([1, 2, 3, 4, 5])\\n>>> np.lib.stride_tricks.as_strided(x, shape=(3,), strides=(8,))\\narray([1, 2, 3])\",\n}\n-/\n\n/-  numpy.as_strided: Create a view into the array with the given shape and strides.\n\n    Creates a new view of an array with specified shape and strides.\n    This is a simplified version that focuses on the core mathematical\n    property: creating a view with a different shape but accessing\n    elements from the original array based on stride patterns.\n\n    For safety, we restrict to cases where the new shape is smaller\n    than or equal to the original array size.\n-/\n\n/-  Specification: numpy.as_strided creates a view with specified strides.\n\n    Precondition: The strided access must be valid (m * stride \u2264 n)\n    Postcondition: Each element in the result is taken from the original\n    array at positions determined by the stride pattern.\n\n    For element i in the result, it equals x[i * stride].\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_as_strided {n m : Nat} (x : Vector Float n) (stride : Nat) \n    (h_valid : m * stride \u2264 n) (h_stride_pos : stride > 0) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem numpy_as_strided_spec {n m : Nat} (x : Vector Float n) (stride : Nat) \n    (h_valid : m * stride \u2264 n) (h_stride_pos : stride > 0) :\n    \u2983\u231cm * stride \u2264 n \u2227 stride > 0\u231d\u2984\n    numpy_as_strided x stride h_valid h_stride_pos\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, result.get i = x.get \u27e8i.val * stride, \n                   by have h1 : i.val < m := i.isLt\n                      have h2 : i.val * stride < m * stride := by\n                        apply Nat.mul_lt_mul_of_pos_right h1 h_stride_pos\n                      exact Nat.lt_of_lt_of_le h2 h_valid\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_can_cast", "vc-description": "/- \n{\n  \"name\": \"numpy.can_cast\",\n  \"category\": \"Type Casting and Promotion\",\n  \"description\": \"Returns True if cast between data types can occur according to the casting rule\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.can_cast.html\",\n  \"doc\": \"Returns whether a cast between data types can occur according to specified casting rules.\\n\\nParameters\\n----------\\nfrom_ : dtype, dtype specifier, NumPy scalar, or array\\n    Data type, NumPy scalar, or array to cast from.\\nto : dtype or dtype specifier\\n    Data type to cast to.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur.\\n    - 'no': no casting is allowed\\n    - 'equiv': only byte-order changes are allowed\\n    - 'safe': only casts which can preserve values are allowed\\n    - 'same_kind': safe casts or casts within a kind\\n    - 'unsafe': any data conversions may be done\\n\\nReturns\\n-------\\nout : bool\\n    True if cast can occur according to the casting rule.\\n\\nExamples\\n--------\\n>>> np.can_cast(np.int32, np.int64)\\nTrue\\n>>> np.can_cast(np.float64, complex)\\nTrue\\n>>> np.can_cast(complex, float)\\nFalse\\n>>> np.can_cast('i8', 'f8')\\nTrue\\n>>> np.can_cast('i8', 'f4')\\nFalse\",\n}\n-/\n\n/-  Returns True if cast between data types can occur according to the casting rule -/\n\n/-  Specification: can_cast determines type casting compatibility according to specified rules -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n-- Data type enumeration for casting rules\ninductive CastingRule\n  | no     -- no casting is allowed\n  | equiv  -- only byte-order changes are allowed  \n  | safe   -- only casts which can preserve values are allowed\n  | same_kind -- safe casts or casts within a kind\n  | unrestricted -- any data conversions may be done\n  deriving Repr, DecidableEq\n\n-- Data type enumeration for supported numeric types\ninductive DType\n  | int8   | int16  | int32  | int64\n  | float32 | float64\n  | complex64 | complex128\n  | bool\n  deriving Repr, DecidableEq", "vc-helpers": "", "vc-definitions": "def can_cast (from_dtype to_dtype : DType) (casting : CastingRule) : Id Bool :=\n  sorry", "vc-theorems": "theorem can_cast_spec (from_dtype to_dtype : DType) (casting : CastingRule) :\n    \u2983\u231cTrue\u231d\u2984\n    can_cast from_dtype to_dtype casting\n    \u2983\u21d3result => \u231c\n      -- Basic reflexivity: any type can cast to itself with any rule\n      (from_dtype = to_dtype \u2192 result = true) \u2227\n\n      -- No casting rule: only identical types allowed\n      (casting = CastingRule.no \u2192 (result = true \u2194 from_dtype = to_dtype)) \u2227\n\n      -- Safe casting preserves values\n      (casting = CastingRule.safe \u2192 \n        (result = true \u2192 \n          -- Integer widening is safe\n          ((from_dtype = DType.int8 \u2227 (to_dtype = DType.int16 \u2228 to_dtype = DType.int32 \u2228 to_dtype = DType.int64)) \u2228\n           (from_dtype = DType.int16 \u2227 (to_dtype = DType.int32 \u2228 to_dtype = DType.int64)) \u2228\n           (from_dtype = DType.int32 \u2227 to_dtype = DType.int64) \u2228\n           -- Float widening is safe\n           (from_dtype = DType.float32 \u2227 to_dtype = DType.float64) \u2228\n           -- Integer to float can be safe if no precision loss\n           ((from_dtype = DType.int8 \u2228 from_dtype = DType.int16) \u2227 (to_dtype = DType.float32 \u2228 to_dtype = DType.float64)) \u2228\n           (from_dtype = DType.int32 \u2227 to_dtype = DType.float64) \u2228\n           -- Complex widening is safe\n           (from_dtype = DType.complex64 \u2227 to_dtype = DType.complex128) \u2228\n           -- Float to complex is safe\n           ((from_dtype = DType.float32 \u2228 from_dtype = DType.float64) \u2227 (to_dtype = DType.complex64 \u2228 to_dtype = DType.complex128)) \u2228\n           -- Same type is always safe\n           (from_dtype = to_dtype)))) \u2227\n\n      -- Same kind casting allows within numeric families\n      (casting = CastingRule.same_kind \u2192 \n        (result = true \u2192 \n          -- Integer family\n          (((from_dtype = DType.int8 \u2228 from_dtype = DType.int16 \u2228 from_dtype = DType.int32 \u2228 from_dtype = DType.int64) \u2227 \n            (to_dtype = DType.int8 \u2228 to_dtype = DType.int16 \u2228 to_dtype = DType.int32 \u2228 to_dtype = DType.int64)) \u2228\n           -- Float family  \n           ((from_dtype = DType.float32 \u2228 from_dtype = DType.float64) \u2227 \n            (to_dtype = DType.float32 \u2228 to_dtype = DType.float64)) \u2228\n           -- Complex family\n           ((from_dtype = DType.complex64 \u2228 from_dtype = DType.complex128) \u2227 \n            (to_dtype = DType.complex64 \u2228 to_dtype = DType.complex128)) \u2228\n           -- Cross-family safe casts\n           ((from_dtype = DType.int8 \u2228 from_dtype = DType.int16 \u2228 from_dtype = DType.int32 \u2228 from_dtype = DType.int64) \u2227 \n            (to_dtype = DType.float32 \u2228 to_dtype = DType.float64 \u2228 to_dtype = DType.complex64 \u2228 to_dtype = DType.complex128)) \u2228\n           ((from_dtype = DType.float32 \u2228 from_dtype = DType.float64) \u2227 \n            (to_dtype = DType.complex64 \u2228 to_dtype = DType.complex128))))) \u2227\n\n      -- Unrestricted casting allows any conversion\n      (casting = CastingRule.unrestricted \u2192 result = true) \u2227\n\n      -- Equiv casting allows same types (byte-order changes only)\n      (casting = CastingRule.equiv \u2192 (result = true \u2194 from_dtype = to_dtype))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_dtype", "vc-description": "/-  numpy.dtype: Create a data type object.\n\n    A numpy array is homogeneous, and contains elements described by a dtype object. \n    A dtype object can be constructed from different combinations of fundamental numeric types.\n\n    This specification focuses on creating basic numeric data types like int16, int32, float32, float64.\n    The function maps type specifications to their corresponding DType objects with proper\n    attributes like size, alignment, and signedness.\n-/\n\n/-  Specification: numpy.dtype creates a valid data type object with consistent attributes.\n\n    Precondition: The type_spec is a valid NumPy type specification\n    Postcondition: The resulting DType has consistent attributes that match the specified type\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents a NumPy data type object with its essential attributes -/\nstructure DType where\n  /-- The fundamental numeric type category -/\n  kind : String\n  /-- The element size in bytes -/\n  itemsize : Nat\n  /-- The alignment requirement in bytes -/\n  alignment : Nat\n  /-- A descriptive name for the data type -/\n  name : String\n  /-- Whether the data type is signed (for numeric types) -/\n  signed : Bool", "vc-helpers": "", "vc-definitions": "def numpy_dtype (type_spec : String) : Id DType :=\n  sorry", "vc-theorems": "theorem numpy_dtype_spec (type_spec : String) \n    (h_valid : type_spec \u2208 [\"int8\", \"int16\", \"int32\", \"int64\", \"float32\", \"float64\", \"bool\"]) :\n    \u2983\u231ctype_spec \u2208 [\"int8\", \"int16\", \"int32\", \"int64\", \"float32\", \"float64\", \"bool\"]\u231d\u2984\n    numpy_dtype type_spec\n    \u2983\u21d3dt => \u231c\n      -- The data type has a valid kind character\n      (dt.kind \u2208 [\"i\", \"f\", \"b\"]) \u2227\n      -- The itemsize is positive and matches the type specification\n      (dt.itemsize > 0) \u2227\n      -- The alignment is positive and does not exceed the itemsize\n      (dt.alignment > 0 \u2227 dt.alignment \u2264 dt.itemsize) \u2227\n      -- The name is non-empty\n      (dt.name.length > 0) \u2227\n      -- Size consistency for specific types\n      ((type_spec = \"int8\" \u2192 dt.itemsize = 1 \u2227 dt.signed = true \u2227 dt.kind = \"i\") \u2227\n       (type_spec = \"int16\" \u2192 dt.itemsize = 2 \u2227 dt.signed = true \u2227 dt.kind = \"i\") \u2227\n       (type_spec = \"int32\" \u2192 dt.itemsize = 4 \u2227 dt.signed = true \u2227 dt.kind = \"i\") \u2227\n       (type_spec = \"int64\" \u2192 dt.itemsize = 8 \u2227 dt.signed = true \u2227 dt.kind = \"i\") \u2227\n       (type_spec = \"float32\" \u2192 dt.itemsize = 4 \u2227 dt.kind = \"f\") \u2227\n       (type_spec = \"float64\" \u2192 dt.itemsize = 8 \u2227 dt.kind = \"f\") \u2227\n       (type_spec = \"bool\" \u2192 dt.itemsize = 1 \u2227 dt.kind = \"b\"))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_find_common_type", "vc-description": "/-  numpy.find_common_type: Determine common type following standard coercion rules.\n\n    This function determines the common data type by following NumPy's type promotion rules.\n    It returns the maximum of array_types ignoring scalar_types, unless the maximum of \n    scalar_types is of a different kind (dtype.kind).\n\n    Note: This function is deprecated in NumPy 1.25.0 in favor of numpy.result_type.\n-/\n\n/-  Specification: find_common_type implements NumPy's type promotion rules correctly.\n\n    The function should:\n    1. Return the maximum precedence type from array_types if scalar_types is empty\n    2. Return the maximum precedence type from scalar_types if array_types is empty  \n    3. If both are non-empty, return the maximum from array_types unless the maximum\n       from scalar_types has a different kind, in which case return the scalar maximum\n    4. Handle the case where type promotion results in a valid common type\n\n    Precondition: At least one of the input vectors is non-empty\n    Postcondition: The result follows NumPy's documented type promotion rules\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Data type representation for NumPy types -/\ninductive DType where\n  /-- 8-bit signed integer -/\n  | int8 \n  /-- 16-bit signed integer -/\n  | int16 \n  /-- 32-bit signed integer -/\n  | int32 \n  /-- 64-bit signed integer -/\n  | int64\n  /-- 8-bit unsigned integer -/\n  | uint8 \n  /-- 16-bit unsigned integer -/\n  | uint16 \n  /-- 32-bit unsigned integer -/\n  | uint32 \n  /-- 64-bit unsigned integer -/\n  | uint64\n  /-- 32-bit floating point -/\n  | float32 \n  /-- 64-bit floating point -/\n  | float64\n  /-- 64-bit complex number -/\n  | complex64 \n  /-- 128-bit complex number -/\n  | complex128\n  /-- Boolean type -/\n  | bool\n  /-- Object type -/\n  | object\n\n/-- Type hierarchy for promotion rules -/\ndef DType.kind : DType \u2192 Char\n  | DType.bool => 'b'\n  | DType.int8 | DType.int16 | DType.int32 | DType.int64 => 'i'\n  | DType.uint8 | DType.uint16 | DType.uint32 | DType.uint64 => 'u'\n  | DType.float32 | DType.float64 => 'f'\n  | DType.complex64 | DType.complex128 => 'c'\n  | DType.object => 'O'\n/-- Type precedence for promotion (higher values have higher precedence) -/\ndef DType.precedence : DType \u2192 Nat\n  | DType.bool => 0\n  | DType.int8 => 1\n  | DType.int16 => 2\n  | DType.int32 => 3\n  | DType.int64 => 4\n  | DType.uint8 => 5\n  | DType.uint16 => 6\n  | DType.uint32 => 7\n  | DType.uint64 => 8\n  | DType.float32 => 9\n  | DType.float64 => 10\n  | DType.complex64 => 11\n  | DType.complex128 => 12\n  | DType.object => 13", "vc-helpers": "", "vc-definitions": "def find_common_type {n m : Nat} (array_types : Vector DType n) (scalar_types : Vector DType m) : Id (Option DType) :=\n  sorry", "vc-theorems": "theorem find_common_type_spec {n m : Nat} (array_types : Vector DType n) (scalar_types : Vector DType m) \n    (h_nonempty : n > 0 \u2228 m > 0) :\n    \u2983\u231cn > 0 \u2228 m > 0\u231d\u2984\n    find_common_type array_types scalar_types\n    \u2983\u21d3result => \u231c\n      -- Case 1: Only array types provided\n      (m = 0 \u2227 n > 0 \u2192 \u2203 (dt : DType), result = some dt \u2227 \n        dt \u2208 array_types.toList \u2227 \n        \u2200 (other : DType), other \u2208 array_types.toList \u2192 other.precedence \u2264 dt.precedence) \u2227\n      -- Case 2: Only scalar types provided  \n      (n = 0 \u2227 m > 0 \u2192 \u2203 (dt : DType), result = some dt \u2227 \n        dt \u2208 scalar_types.toList \u2227 \n        \u2200 (other : DType), other \u2208 scalar_types.toList \u2192 other.precedence \u2264 dt.precedence) \u2227\n      -- Case 3: Both array and scalar types provided\n      (n > 0 \u2227 m > 0 \u2192 \n        \u2203 (max_array max_scalar : DType),\n          max_array \u2208 array_types.toList \u2227 max_scalar \u2208 scalar_types.toList \u2227\n          (\u2200 dt \u2208 array_types.toList, dt.precedence \u2264 max_array.precedence) \u2227\n          (\u2200 dt \u2208 scalar_types.toList, dt.precedence \u2264 max_scalar.precedence) \u2227\n          ((max_array.kind = max_scalar.kind \u2192 result = some max_array) \u2227\n           (max_array.kind \u2260 max_scalar.kind \u2192 result = some max_scalar)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_finfo", "vc-description": "/-  numpy.finfo: Machine limits for floating point types.\n\n    Returns machine limits for the Float type in Lean.\n    This provides information about the precision and range of Float values.\n\n    In NumPy, this would accept different dtypes, but in Lean we work with the built-in Float type.\n-/\n\n/-  Specification: numpy.finfo returns floating point type information with correct properties.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The returned FloatInfo has mathematically consistent properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing floating point type information returned by numpy.finfo -/\nstructure FloatInfo where\n  /-- The number of bits occupied by the type -/\n  bits : Nat\n  /-- The smallest representable positive number such that 1.0 + eps != 1.0 -/\n  eps : Float\n  /-- The largest representable number -/\n  max : Float\n  /-- The smallest representable number, typically -max -/\n  min : Float\n  /-- The approximate number of decimal digits to which this kind of float is precise -/\n  precision : Nat\n  /-- The approximate decimal resolution of this type -/\n  resolution : Float\n  /-- The smallest positive floating point number with 1 as leading bit in the mantissa -/\n  smallest_normal : Float\n  /-- The smallest positive floating point number with 0 as leading bit in the mantissa -/\n  smallest_subnormal : Float", "vc-helpers": "", "vc-definitions": "def numpy_finfo : Id FloatInfo :=\n  sorry", "vc-theorems": "theorem numpy_finfo_spec :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_finfo\n    \u2983\u21d3info => \u231c\n      -- Basic sanity checks\n      info.bits > 0 \u2227\n      info.precision > 0 \u2227\n      -- eps is positive and small\n      info.eps > 0 \u2227\n      info.eps < 1 \u2227\n      -- max is positive, min is negative\n      info.max > 0 \u2227\n      info.min < 0 \u2227\n      -- min is typically -max for symmetric floating point types\n      info.min = -info.max \u2227\n      -- resolution is positive\n      info.resolution > 0 \u2227\n      -- smallest_normal is positive and smaller than 1\n      info.smallest_normal > 0 \u2227\n      info.smallest_normal < 1 \u2227\n      -- smallest_subnormal is positive and smaller than smallest_normal\n      info.smallest_subnormal > 0 \u2227\n      info.smallest_subnormal \u2264 info.smallest_normal \u2227\n      -- eps represents the machine epsilon property: 1.0 + eps should be representable\n      -- and different from 1.0, while smaller values are not\n      info.eps = info.resolution \u2227\n      -- The number of bits should be reasonable (32 or 64 for common float types)\n      (info.bits = 32 \u2228 info.bits = 64)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_format_parser", "vc-description": "/-  numpy.format_parser: Class to convert formats, names, titles description to a dtype.\n\n    This function takes format descriptions, field names, and optional titles\n    and produces a structured data type specification. It validates that the\n    formats are well-formed and that the number of names matches the number\n    of format descriptors.\n\n    The function handles common NumPy format strings like 'f8' (float64),\n    'i4' (int32), 'S5' (string of length 5), etc.\n-/\n\n/-  Specification: numpy.format_parser creates a structured data type from format descriptions.\n\n    Precondition: All format strings in formats are valid NumPy format descriptors\n    Postcondition: \n    1. The result has the same number of fields as input vectors\n    2. Each field has the correct name from the names vector\n    3. Each field has the correct format descriptor parsed from the formats vector\n    4. If titles are provided, each field has the corresponding title\n    5. The alignment setting is preserved\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A format descriptor for structured data types -/\ninductive FormatDescriptor where\n  /-- 64-bit floating point ('f8') -/\n  | float64 : FormatDescriptor\n  /-- 32-bit integer ('i4') -/\n  | int32   : FormatDescriptor\n  /-- Variable length string ('S5' for string of length 5) -/\n  | string  : Nat \u2192 FormatDescriptor\n  /-- 64-bit integer ('i8') -/\n  | int64   : FormatDescriptor\n  /-- 32-bit floating point ('f4') -/\n  | float32 : FormatDescriptor\n  deriving Repr, BEq\n\n/-- A field in a structured data type -/\nstructure Field where\n  /-- Field name -/\n  name : String\n  /-- Format descriptor -/\n  format : FormatDescriptor\n  /-- Optional title for the field -/\n  title : Option String := none\n  deriving Repr, BEq\n\n/-- A structured data type specification -/\nstructure DType (n : Nat) where\n  /-- Vector of fields -/\n  fields : Vector Field n\n  /-- Whether fields are aligned as C-compiler would -/\n  aligned : Bool := false\n  deriving Repr, BEq", "vc-helpers": "", "vc-definitions": "def numpy_format_parser {n : Nat} \n    (formats : Vector String n) \n    (names : Vector String n) \n    (titles : Option (Vector String n) := none)\n    (aligned : Bool := false) : Id (DType n) :=\n  sorry", "vc-theorems": "theorem numpy_format_parser_spec {n : Nat} \n    (formats : Vector String n) \n    (names : Vector String n) \n    (titles : Option (Vector String n) := none)\n    (aligned : Bool := false)\n    (h_valid_formats : \u2200 i : Fin n, formats.get i \u2208 [\"f8\", \"f4\", \"i4\", \"i8\"] \u2228 \n                       \u2203 k : Nat, formats.get i = s!\"S{k}\") :\n    \u2983\u231c\u2200 i : Fin n, formats.get i \u2208 [\"f8\", \"f4\", \"i4\", \"i8\"] \u2228 \n       \u2203 k : Nat, formats.get i = s!\"S{k}\"\u231d\u2984\n    numpy_format_parser formats names titles aligned\n    \u2983\u21d3dtype => \u231c\n      -- Each field has the correct name\n      (\u2200 i : Fin n, (dtype.fields.get i).name = names.get i) \u2227\n      -- Each field has a valid format descriptor\n      (\u2200 i : Fin n, match formats.get i with\n        | \"f8\" => (dtype.fields.get i).format = FormatDescriptor.float64\n        | \"f4\" => (dtype.fields.get i).format = FormatDescriptor.float32\n        | \"i4\" => (dtype.fields.get i).format = FormatDescriptor.int32\n        | \"i8\" => (dtype.fields.get i).format = FormatDescriptor.int64\n        | s => \u2203 k : Nat, s = s!\"S{k}\" \u2227 (dtype.fields.get i).format = FormatDescriptor.string k) \u2227\n      -- If titles are provided, each field has the correct title\n      (match titles with\n        | some title_vec => \u2200 i : Fin n, (dtype.fields.get i).title = some (title_vec.get i)\n        | none => \u2200 i : Fin n, (dtype.fields.get i).title = Option.none) \u2227\n      -- The alignment setting is preserved\n      (dtype.aligned = aligned)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_iinfo", "vc-description": "/- \n{\n  \"name\": \"numpy.iinfo\",\n  \"category\": \"Data Type Information\",\n  \"description\": \"Machine limits for integer types\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.iinfo.html\",\n  \"doc\": \"Machine limits for integer types.\\n\\nParameters\\n----------\\nint_type : integer type, dtype, or instance\\n    The kind of integer data type to get information about.\\n\\nAttributes\\n----------\\nbits : int\\n    The number of bits occupied by the type.\\ndtype : dtype\\n    The dtype for which iinfo returns information.\\nmin : int\\n    The smallest integer expressible by the type.\\nmax : int\\n    The largest integer expressible by the type.\\n\\nExamples\\n--------\\n>>> ii16 = np.iinfo(np.int16)\\n>>> ii16.min\\n-32768\\n>>> ii16.max\\n32767\\n>>> ii32 = np.iinfo(np.int32)\\n>>> ii32.min\\n-2147483648\\n>>> ii32.max\\n2147483647\",\n}\n-/\n\n/-  numpy.iinfo: Returns machine limits for integer types.\n\n    Takes an integer type specification and returns information about \n    the number of bits, minimum value, and maximum value for that type.\n    This provides access to the fundamental machine limits for integer\n    representation in numerical computing.\n-/\n\n/-  Specification: numpy.iinfo returns correct machine limits for integer types.\n\n    Precondition: True (no special preconditions for type information)\n    Postcondition: The returned IntInfo structure contains:\n      - Correct bit count for the specified type\n      - Correct minimum value (negative for signed types, 0 for unsigned)\n      - Correct maximum value based on the bit representation\n      - Consistency between bits and min/max values\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Integer type information structure containing machine limits for integer types -/\nstructure IntInfo where\n  /-- Number of bits occupied by the type -/\n  bits : Nat      \n  /-- Smallest integer expressible by the type -/\n  min : Int       \n  /-- Largest integer expressible by the type -/\n  max : Int\n\n/-- Enumeration of supported integer types -/\ninductive IntType where\n  /-- 8-bit signed integer type -/\n  | Int8 : IntType\n  /-- 16-bit signed integer type -/\n  | Int16 : IntType\n  /-- 32-bit signed integer type -/\n  | Int32 : IntType\n  /-- 64-bit signed integer type -/\n  | Int64 : IntType\n  /-- 8-bit unsigned integer type -/\n  | UInt8 : IntType\n  /-- 16-bit unsigned integer type -/\n  | UInt16 : IntType\n  /-- 32-bit unsigned integer type -/\n  | UInt32 : IntType\n  /-- 64-bit unsigned integer type -/\n  | UInt64 : IntType", "vc-helpers": "", "vc-definitions": "def iinfo (int_type : IntType) : Id IntInfo :=\n  sorry", "vc-theorems": "theorem iinfo_spec (int_type : IntType) :\n    \u2983\u231cTrue\u231d\u2984\n    iinfo int_type\n    \u2983\u21d3info => \u231c\n      match int_type with\n      | IntType.Int8 => info.bits = 8 \u2227 info.min = -128 \u2227 info.max = 127\n      | IntType.Int16 => info.bits = 16 \u2227 info.min = -32768 \u2227 info.max = 32767\n      | IntType.Int32 => info.bits = 32 \u2227 info.min = -2147483648 \u2227 info.max = 2147483647\n      | IntType.Int64 => info.bits = 64 \u2227 info.min = -9223372036854775808 \u2227 info.max = 9223372036854775807\n      | IntType.UInt8 => info.bits = 8 \u2227 info.min = 0 \u2227 info.max = 255\n      | IntType.UInt16 => info.bits = 16 \u2227 info.min = 0 \u2227 info.max = 65535\n      | IntType.UInt32 => info.bits = 32 \u2227 info.min = 0 \u2227 info.max = 4294967295\n      | IntType.UInt64 => info.bits = 64 \u2227 info.min = 0 \u2227 info.max = 18446744073709551615\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_isdtype", "vc-description": "/-  numpy.isdtype: Determine if a provided dtype is of a specified data type kind.\n\n    This function checks whether a given NumPy dtype belongs to a specified\n    category of data types. It supports checking against specific dtype kinds\n    like 'bool', 'signed integer', 'unsigned integer', 'integral', \n    'real floating', 'complex floating', and 'numeric'.\n\n    The function performs type introspection and classification of NumPy dtypes\n    according to their fundamental characteristics.\n-/\n\n/-  Specification: numpy.isdtype correctly identifies dtype kinds.\n\n    Precondition: True (works for any valid dtype and kind)\n    Postcondition: Returns true iff the dtype belongs to the specified kind category.\n\n    The function implements the following classification rules:\n    - Bool: dtype is boolean\n    - SignedInteger: dtype is signed integer (int8, int16, int32, int64)\n    - UnsignedInteger: dtype is unsigned integer (uint8, uint16, uint32, uint64)\n    - Integral: dtype is any integer type (signed or unsigned)\n    - RealFloating: dtype is real floating point (float16, float32, float64)\n    - ComplexFloating: dtype is complex floating point (complex64, complex128)\n    - Numeric: dtype is any numeric type (bool, integers, floats, complex)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- NumPy data type representation -/\ninductive NumpyDType where\n  /-- Boolean data type -/\n  | Bool : NumpyDType\n  /-- 8-bit signed integer -/\n  | Int8 : NumpyDType\n  /-- 16-bit signed integer -/\n  | Int16 : NumpyDType\n  /-- 32-bit signed integer -/\n  | Int32 : NumpyDType\n  /-- 64-bit signed integer -/\n  | Int64 : NumpyDType\n  /-- 8-bit unsigned integer -/\n  | UInt8 : NumpyDType\n  /-- 16-bit unsigned integer -/\n  | UInt16 : NumpyDType\n  /-- 32-bit unsigned integer -/\n  | UInt32 : NumpyDType\n  /-- 64-bit unsigned integer -/\n  | UInt64 : NumpyDType\n  /-- 16-bit floating point -/\n  | Float16 : NumpyDType\n  /-- 32-bit floating point -/\n  | Float32 : NumpyDType\n  /-- 64-bit floating point -/\n  | Float64 : NumpyDType\n  /-- 64-bit complex number -/\n  | Complex64 : NumpyDType\n  /-- 128-bit complex number -/\n  | Complex128 : NumpyDType\n  deriving DecidableEq, Repr\n\n/-- NumPy data type kind categories -/\ninductive DTypeKind where\n  /-- Boolean kind -/\n  | Bool : DTypeKind\n  /-- Signed integer kind -/\n  | SignedInteger : DTypeKind\n  /-- Unsigned integer kind -/\n  | UnsignedInteger : DTypeKind\n  /-- Any integer kind (signed or unsigned) -/\n  | Integral : DTypeKind\n  /-- Real floating point kind -/\n  | RealFloating : DTypeKind\n  /-- Complex floating point kind -/\n  | ComplexFloating : DTypeKind\n  /-- Any numeric kind -/\n  | Numeric : DTypeKind\n  deriving DecidableEq, Repr\n\n/-- Get the fundamental kind of a NumPy dtype -/\ndef getDTypeKind (dtype : NumpyDType) : DTypeKind :=\n  match dtype with\n  | .Bool => .Bool\n  | .Int8 | .Int16 | .Int32 | .Int64 => .SignedInteger\n  | .UInt8 | .UInt16 | .UInt32 | .UInt64 => .UnsignedInteger\n  | .Float16 | .Float32 | .Float64 => .RealFloating\n  | .Complex64 | .Complex128 => .ComplexFloating\n/-- Check if a NumPy dtype belongs to a specific kind category -/\ndef isOfKind (dtype : NumpyDType) (kind : DTypeKind) : Bool :=\n  match kind with\n  | .Bool => getDTypeKind dtype = .Bool\n  | .SignedInteger => getDTypeKind dtype = .SignedInteger\n  | .UnsignedInteger => getDTypeKind dtype = .UnsignedInteger\n  | .Integral => getDTypeKind dtype = .SignedInteger \u2228 getDTypeKind dtype = .UnsignedInteger\n  | .RealFloating => getDTypeKind dtype = .RealFloating\n  | .ComplexFloating => getDTypeKind dtype = .ComplexFloating\n  | .Numeric => getDTypeKind dtype \u2208 [.Bool, .SignedInteger, .UnsignedInteger, .RealFloating, .ComplexFloating]", "vc-helpers": "", "vc-definitions": "def numpy_isdtype (dtype : NumpyDType) (kind : DTypeKind) : Id Bool :=\n  sorry", "vc-theorems": "theorem numpy_isdtype_spec (dtype : NumpyDType) (kind : DTypeKind) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_isdtype dtype kind\n    \u2983\u21d3result => \u231cresult = isOfKind dtype kind\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_issctype", "vc-description": "/- \n{\n  \"name\": \"numpy.issctype\",\n  \"category\": \"Data Type Testing\",\n  \"description\": \"Determines whether the given object represents a scalar data-type\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.issctype.html\",\n  \"doc\": \"Determines whether the given object represents a scalar data-type.\\n\\nParameters\\n----------\\nrep : any\\n    If rep is an instance of a scalar dtype, True is returned. If not, False is returned.\\n\\nReturns\\n-------\\nout : bool\\n    Boolean result of check whether rep is a scalar dtype.\\n\\nExamples\\n--------\\n>>> np.issctype(np.int32)\\nTrue\\n>>> np.issctype(list)\\nFalse\\n>>> np.issctype(1.1)\\nFalse\",\n}\n-/\n\n/-  Determines whether the given object represents a scalar data-type -/\n\n/-  Specification: issctype returns true if and only if the input represents a scalar data type -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents different kinds of data types that can be tested -/\ninductive DataType\n  /-- Scalar integer type -/\n  | scalar_int : DataType\n  /-- Scalar floating point type -/\n  | scalar_float : DataType\n  /-- Scalar complex number type -/\n  | scalar_complex : DataType\n  /-- Scalar boolean type -/\n  | scalar_bool : DataType\n  /-- Scalar string type -/\n  | scalar_string : DataType\n  /-- Array type -/\n  | array_type : DataType\n  /-- Composite type -/\n  | composite_type : DataType\n  /-- Unknown type -/\n  | unknown_type : DataType\n\n/-- Helper function to check if a DataType is a scalar type -/\ndef isScalarType (dt : DataType) : Bool :=\n  match dt with\n  | DataType.scalar_int => true\n  | DataType.scalar_float => true\n  | DataType.scalar_complex => true\n  | DataType.scalar_bool => true\n  | DataType.scalar_string => true\n  | DataType.array_type => false\n  | DataType.composite_type => false\n  | DataType.unknown_type => false", "vc-helpers": "", "vc-definitions": "def issctype (rep : DataType) : Id Bool :=\n  sorry", "vc-theorems": "theorem issctype_spec (rep : DataType) :\n    \u2983\u231cTrue\u231d\u2984\n    issctype rep\n    \u2983\u21d3result => \u231cresult = true \u2194 (rep = DataType.scalar_int \u2228 \n                                  rep = DataType.scalar_float \u2228 \n                                  rep = DataType.scalar_complex \u2228 \n                                  rep = DataType.scalar_bool \u2228 \n                                  rep = DataType.scalar_string)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_issubclass_", "vc-description": "/-  numpy.issubclass_: Determine if a class is a subclass of a second class.\n\n    This function is equivalent to the Python built-in issubclass, except that it returns \n    False instead of raising a TypeError if one of the arguments is not a class.\n\n    In the context of NumPy, this tests relationships between NumPy data type classes\n    such as whether int32 is a subclass of integer, or whether float64 is a subclass of float.\n-/\n\n/-  Specification: issubclass_ correctly determines class hierarchy relationships.\n\n    This function tests whether arg1 is a subclass of arg2 according to NumPy's type\n    hierarchy. The specification ensures that:\n    1. The function respects the established type hierarchy (e.g., int32 \u2286 integer \u2286 number \u2286 scalar)\n    2. It handles reflexivity correctly (every class is a subclass of itself)\n    3. It returns False for unrelated classes\n    4. It never raises exceptions (returns False instead of error for invalid inputs)\n\n    Precondition: True (no special preconditions, handles all inputs gracefully)\n    Postcondition: Returns True if arg1 is a subclass of arg2, False otherwise\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Represents a NumPy type class for hierarchy testing -/\ninductive NumpyTypeClass where\n  /-- Integer types -/\n  | IntegerType\n  /-- Floating point types -/\n  | FloatingType\n  /-- Complex number types -/\n  | ComplexType\n  /-- Boolean type -/\n  | BooleanType\n  /-- Scalar types (superclass of all numeric types) -/\n  | ScalarType\n  /-- Number types (excludes boolean) -/\n  | NumberType\n  /-- Inexact types (floating and complex) -/\n  | InexactType\n  /-- 8-bit signed integer type -/\n  | Int8Type\n  /-- 16-bit signed integer type -/\n  | Int16Type\n  /-- 32-bit signed integer type -/\n  | Int32Type\n  /-- 64-bit signed integer type -/\n  | Int64Type\n  /-- 8-bit unsigned integer type -/\n  | UInt8Type\n  /-- 16-bit unsigned integer type -/\n  | UInt16Type\n  /-- 32-bit unsigned integer type -/\n  | UInt32Type\n  /-- 64-bit unsigned integer type -/\n  | UInt64Type\n  /-- 32-bit floating point type -/\n  | Float32Type\n  /-- 64-bit floating point type -/\n  | Float64Type\n  /-- 64-bit complex number type -/\n  | Complex64Type\n  /-- 128-bit complex number type -/\n  | Complex128Type\n  /-- Generic object type -/\n  | ObjectType\n  deriving BEq\n\n/-- Defines the class hierarchy relationships for NumPy types -/\ndef NumpyTypeClass.isSubclass : NumpyTypeClass \u2192 NumpyTypeClass \u2192 Bool\n  -- Reflexivity: every class is a subclass of itself\n  | t, t' => if t == t' then true else\n  -- Concrete integer types are subclasses of IntegerType\n  match t, t' with\n  | Int8Type, IntegerType => true\n  | Int16Type, IntegerType => true\n  | Int32Type, IntegerType => true\n  | Int64Type, IntegerType => true\n  | UInt8Type, IntegerType => true\n  | UInt16Type, IntegerType => true\n  | UInt32Type, IntegerType => true\n  | UInt64Type, IntegerType => true\n  -- Concrete floating types are subclasses of FloatingType\n  | Float32Type, FloatingType => true\n  | Float64Type, FloatingType => true\n  -- Concrete complex types are subclasses of ComplexType\n  | Complex64Type, ComplexType => true\n  | Complex128Type, ComplexType => true\n  -- Integer types are subclasses of NumberType\n  | IntegerType, NumberType => true\n  -- Floating types are subclasses of InexactType and NumberType\n  | FloatingType, InexactType => true\n  | FloatingType, NumberType => true\n  -- Complex types are subclasses of InexactType and NumberType\n  | ComplexType, InexactType => true\n  | ComplexType, NumberType => true\n  -- All numeric types are subclasses of ScalarType\n  | NumberType, ScalarType => true\n  | BooleanType, ScalarType => true\n  | IntegerType, ScalarType => true\n  | FloatingType, ScalarType => true\n  | ComplexType, ScalarType => true\n  | InexactType, ScalarType => true\n  -- Default case\n  | _, _ => false", "vc-helpers": "", "vc-definitions": "def issubclass_ (arg1 arg2 : NumpyTypeClass) : Id Bool :=\n  sorry", "vc-theorems": "theorem issubclass_spec (arg1 arg2 : NumpyTypeClass) :\n    \u2983\u231cTrue\u231d\u2984\n    issubclass_ arg1 arg2\n    \u2983\u21d3result => \u231c\n      -- Result matches the defined hierarchy\n      result = arg1.isSubclass arg2 \u2227\n      -- Reflexivity: every class is a subclass of itself\n      (arg1 = arg2 \u2192 result = true) \u2227\n      -- Concrete examples from NumPy documentation\n      (arg1 = NumpyTypeClass.Int32Type \u2227 arg2 = NumpyTypeClass.IntegerType \u2192 result = true) \u2227\n      (arg1 = NumpyTypeClass.Float64Type \u2227 arg2 = NumpyTypeClass.FloatingType \u2192 result = true) \u2227\n      (arg1 = NumpyTypeClass.Int32Type \u2227 arg2 = NumpyTypeClass.FloatingType \u2192 result = false) \u2227\n      -- Transitivity: int32 \u2192 integer \u2192 number \u2192 scalar\n      (arg1 = NumpyTypeClass.Int32Type \u2227 arg2 = NumpyTypeClass.NumberType \u2192 \n       NumpyTypeClass.Int32Type.isSubclass NumpyTypeClass.IntegerType \u2227\n       NumpyTypeClass.IntegerType.isSubclass NumpyTypeClass.NumberType) \u2227\n      -- All numeric types are subclasses of ScalarType\n      (arg1 = NumpyTypeClass.IntegerType \u2227 arg2 = NumpyTypeClass.ScalarType \u2192 result = true) \u2227\n      (arg1 = NumpyTypeClass.FloatingType \u2227 arg2 = NumpyTypeClass.ScalarType \u2192 result = true) \u2227\n      (arg1 = NumpyTypeClass.ComplexType \u2227 arg2 = NumpyTypeClass.ScalarType \u2192 result = true)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_issubdtype", "vc-description": "/- \n{\n  \"name\": \"numpy.issubdtype\",\n  \"category\": \"Data Type Testing\",\n  \"description\": \"Returns True if first argument is a typecode lower/equal in type hierarchy\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.issubdtype.html\",\n  \"doc\": \"Returns True if first argument is a typecode lower/equal in type hierarchy.\\n\\nThis is like the builtin issubclass, but for dtypes.\\n\\nParameters\\n----------\\narg1, arg2 : dtype_like\\n    dtype or object coercible to one.\\n\\nReturns\\n-------\\nout : bool\\n\\nExamples\\n--------\\n>>> ints = np.array([1, 2, 3], dtype=np.int32)\\n>>> np.issubdtype(ints.dtype, np.integer)\\nTrue\\n>>> np.issubdtype(ints.dtype, np.floating)\\nFalse\\n>>> floats = np.array([1, 2, 3], dtype=np.float32)\\n>>> np.issubdtype(floats.dtype, np.integer)\\nFalse\\n>>> np.issubdtype(floats.dtype, np.floating)\\nTrue\\n>>> np.issubdtype(np.float64, np.float32)\\nFalse\\n>>> np.issubdtype(np.float32, np.float64)\\nFalse\\n>>> np.issubdtype(np.float64, np.floating)\\nTrue\\n>>> np.issubdtype(np.float32, np.floating)\\nTrue\\n>>> np.issubdtype('S1', np.bytes_)\\nTrue\\n>>> np.issubdtype('i4', np.signedinteger)\\nTrue\",\n}\n-/\n\n/-  numpy.issubdtype: Returns True if first argument is a typecode lower/equal in type hierarchy.\n\n    This function checks if the first data type is a subtype of the second data type\n    in the NumPy type hierarchy. It's similar to Python's built-in issubclass but\n    operates on NumPy data types.\n\n    The function implements the NumPy type hierarchy where types are organized\n    in a tree structure with 'generic' at the root.\n-/\n\n/-  Specification: issubdtype returns True if arg1 is a subtype of arg2 in the NumPy type hierarchy.\n\n    Precondition: True (works with any valid NumPy data types)\n    Postcondition: The result is True if and only if arg1 is a subtype of arg2 \n    according to the NumPy type hierarchy rules.\n\n    Key properties:\n    1. Reflexivity: Every type is a subtype of itself\n    2. Transitivity: If A is subtype of B and B is subtype of C, then A is subtype of C\n    3. Hierarchy rules: Specific types are subtypes of their parent categories\n    4. Root type: All types are subtypes of 'generic'\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Define a NumPy-like type hierarchy representing the data type system in NumPy -/\ninductive NumpyDType where\n  /-- Generic root type -/\n  | generic\n  /-- Inexact numeric type -/\n  | inexact : NumpyDType \u2192 NumpyDType\n  /-- Floating point type -/\n  | floating : NumpyDType \u2192 NumpyDType\n  /-- 32-bit floating point -/\n  | float32 : NumpyDType\n  /-- 64-bit floating point -/\n  | float64 : NumpyDType\n  /-- Numeric type -/\n  | number : NumpyDType \u2192 NumpyDType\n  /-- Integer type -/\n  | integer : NumpyDType \u2192 NumpyDType\n  /-- Signed integer type -/\n  | signedinteger : NumpyDType \u2192 NumpyDType\n  /-- 8-bit signed integer -/\n  | int8 : NumpyDType\n  /-- 16-bit signed integer -/\n  | int16 : NumpyDType\n  /-- 32-bit signed integer -/\n  | int32 : NumpyDType\n  /-- 64-bit signed integer -/\n  | int64 : NumpyDType\n  /-- Unsigned integer type -/\n  | unsignedinteger : NumpyDType \u2192 NumpyDType\n  /-- 8-bit unsigned integer -/\n  | uint8 : NumpyDType\n  /-- 16-bit unsigned integer -/\n  | uint16 : NumpyDType\n  /-- 32-bit unsigned integer -/\n  | uint32 : NumpyDType\n  /-- 64-bit unsigned integer -/\n  | uint64 : NumpyDType\n  /-- Character type -/\n  | character : NumpyDType \u2192 NumpyDType\n  /-- Bytes type -/\n  | bytes_ : NumpyDType\n  /-- String type -/\n  | str_ : NumpyDType\n  /-- Boolean type -/\n  | bool : NumpyDType\n  deriving BEq\n\n/-- Define the subtype relation for NumPy types -/\ndef isSubDType : NumpyDType \u2192 NumpyDType \u2192 Bool\n  | dtype1, dtype2 => \n    if dtype1 == dtype2 then true\n    else match (dtype1, dtype2) with\n      -- Float hierarchy\n      | (NumpyDType.float32, NumpyDType.floating _) => true\n      | (NumpyDType.float64, NumpyDType.floating _) => true\n      | (NumpyDType.floating _, NumpyDType.inexact _) => true\n      | (NumpyDType.floating _, NumpyDType.number _) => true\n      | (NumpyDType.floating _, NumpyDType.generic) => true\n      -- Integer hierarchy\n      | (NumpyDType.int8, NumpyDType.signedinteger _) => true\n      | (NumpyDType.int16, NumpyDType.signedinteger _) => true\n      | (NumpyDType.int32, NumpyDType.signedinteger _) => true\n      | (NumpyDType.int64, NumpyDType.signedinteger _) => true\n      | (NumpyDType.uint8, NumpyDType.unsignedinteger _) => true\n      | (NumpyDType.uint16, NumpyDType.unsignedinteger _) => true\n      | (NumpyDType.uint32, NumpyDType.unsignedinteger _) => true\n      | (NumpyDType.uint64, NumpyDType.unsignedinteger _) => true\n      | (NumpyDType.signedinteger _, NumpyDType.integer _) => true\n      | (NumpyDType.unsignedinteger _, NumpyDType.integer _) => true\n      | (NumpyDType.integer _, NumpyDType.number _) => true\n      | (NumpyDType.integer _, NumpyDType.generic) => true\n      -- Character hierarchy\n      | (NumpyDType.str_, NumpyDType.character _) => true\n      | (NumpyDType.bytes_, NumpyDType.character _) => true\n      | (NumpyDType.character _, NumpyDType.generic) => true\n      -- Boolean hierarchy\n      | (NumpyDType.bool, NumpyDType.generic) => true\n      -- Number hierarchy\n      | (NumpyDType.number _, NumpyDType.generic) => true\n      | (NumpyDType.inexact _, NumpyDType.generic) => true\n      | _ => false", "vc-helpers": "", "vc-definitions": "def issubdtype (arg1 arg2 : NumpyDType) : Id Bool :=\n  sorry", "vc-theorems": "theorem issubdtype_spec (arg1 arg2 : NumpyDType) :\n    \u2983\u231cTrue\u231d\u2984\n    issubdtype arg1 arg2\n    \u2983\u21d3result => \u231cresult = isSubDType arg1 arg2 \u2227 \n                 -- Reflexivity property\n                 (arg1 = arg2 \u2192 result = true) \u2227\n                 -- Generic is supertype of all types\n                 (arg2 = NumpyDType.generic \u2192 result = true) \u2227\n                 -- Specific hierarchy rules\n                 (arg1 = NumpyDType.float32 \u2227 arg2 = NumpyDType.floating NumpyDType.generic \u2192 result = true) \u2227\n                 (arg1 = NumpyDType.float64 \u2227 arg2 = NumpyDType.floating NumpyDType.generic \u2192 result = true) \u2227\n                 (arg1 = NumpyDType.int32 \u2227 arg2 = NumpyDType.signedinteger NumpyDType.generic \u2192 result = true) \u2227\n                 (arg1 = NumpyDType.uint32 \u2227 arg2 = NumpyDType.unsignedinteger NumpyDType.generic \u2192 result = true) \u2227\n                 -- Non-subtype examples\n                 (arg1 = NumpyDType.float32 \u2227 arg2 = NumpyDType.float64 \u2192 result = false) \u2227\n                 (arg1 = NumpyDType.float64 \u2227 arg2 = NumpyDType.float32 \u2192 result = false) \u2227\n                 (arg1 = NumpyDType.int32 \u2227 arg2 = NumpyDType.floating NumpyDType.generic \u2192 result = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_maximum_sctype", "vc-description": "/- \n{\n  \"name\": \"numpy.maximum_sctype\",\n  \"category\": \"Miscellaneous Type Utilities\",\n  \"description\": \"Return the scalar type of highest precision of the same kind as the input\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.maximum_sctype.html\",\n  \"doc\": \"Return the scalar type of highest precision of the same kind as the input.\\n\\nParameters\\n----------\\nt : dtype or dtype specifier\\n    The input data type. This can be a dtype object or an object that is convertible to a dtype.\\n\\nReturns\\n-------\\nout : dtype\\n    The highest precision data type of the same kind as t.\\n\\nExamples\\n--------\\n>>> np.maximum_sctype(int)\\n<class 'numpy.int64'>\\n>>> np.maximum_sctype(np.uint8)\\n<class 'numpy.uint64'>\\n>>> np.maximum_sctype(complex)\\n<class 'numpy.complex256'>\\n>>> np.maximum_sctype(str)\\n<class 'numpy.str_'>\\n>>> np.maximum_sctype('i2')\\n<class 'numpy.int64'>\\n>>> np.maximum_sctype('f4')\\n<class 'numpy.float128'>\",\n}\n-/\n\n/-  Return the scalar type of highest precision of the same kind as the input -/\n\n/-  Specification: maximum_sctype returns the highest precision type of the same kind -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Define a type hierarchy for numeric types -/\ninductive NumericKind\n  /-- Signed integer types -/\n  | Integer\n  /-- Unsigned integer types -/\n  | UnsignedInteger\n  /-- Floating point types -/\n  | Float\n  /-- Complex number types -/\n  | Complex\n  /-- String types -/\n  | String\n  /-- Boolean types -/\n  | Boolean\n  deriving Repr, BEq, DecidableEq\n\n/-- Define precision levels for each kind -/\ninductive Precision\n  /-- 8-bit precision -/\n  | P8\n  /-- 16-bit precision -/\n  | P16\n  /-- 32-bit precision -/\n  | P32\n  /-- 64-bit precision -/\n  | P64\n  /-- 128-bit precision -/\n  | P128\n  /-- 256-bit precision -/\n  | P256\n  deriving Repr, BEq, DecidableEq\n\n/-- A numeric type representation -/\nstructure NumericType where\n  /-- The kind of numeric type -/\n  kind : NumericKind\n  /-- The precision level -/\n  precision : Precision\n  deriving Repr, BEq, DecidableEq\n\n/-- Define the maximum precision for each kind -/\ndef maxPrecisionFor (kind : NumericKind) : Precision :=\n  match kind with\n  | NumericKind.Integer => Precision.P64\n  | NumericKind.UnsignedInteger => Precision.P64\n  | NumericKind.Float => Precision.P128\n  | NumericKind.Complex => Precision.P256\n  | NumericKind.String => Precision.P64  -- Represents max string length handling\n  | NumericKind.Boolean => Precision.P8\n/-- Define precision ordering -/\ndef precisionLE (p1 p2 : Precision) : Bool :=\n  match p1, p2 with\n  | Precision.P8, _ => true\n  | Precision.P16, Precision.P8 => false\n  | Precision.P16, _ => true\n  | Precision.P32, Precision.P8 => false\n  | Precision.P32, Precision.P16 => false\n  | Precision.P32, _ => true\n  | Precision.P64, Precision.P8 => false\n  | Precision.P64, Precision.P16 => false\n  | Precision.P64, Precision.P32 => false\n  | Precision.P64, _ => true\n  | Precision.P128, Precision.P256 => true\n  | Precision.P128, _ => false\n  | Precision.P256, _ => false", "vc-helpers": "", "vc-definitions": "def maximum_sctype (t : NumericType) : Id NumericType :=\n  sorry", "vc-theorems": "theorem maximum_sctype_spec (t : NumericType) :\n    \u2983\u231cTrue\u231d\u2984\n    maximum_sctype t\n    \u2983\u21d3result => \u231cresult.kind = t.kind \u2227 \n                 result.precision = maxPrecisionFor t.kind \u2227\n                 precisionLE t.precision result.precision\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_may_share_memory", "vc-description": "/- \n{\n  \"name\": \"numpy.may_share_memory\",\n  \"category\": \"Memory and Striding\",\n  \"description\": \"Determine if two arrays might share memory\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.may_share_memory.html\",\n  \"doc\": \"Determine if two arrays might share memory.\\n\\nA return of True does not necessarily mean that the two arrays share any element. It just means that they might.\\n\\nOnly the memory bounds of a and b are checked by default.\\n\\nParameters\\n----------\\na, b : ndarray\\n    Input arrays.\\nmax_work : int, optional\\n    Effort to spend on solving the overlap problem. See shares_memory for details. Default is MAY_SHARE_BOUNDS.\\n\\nReturns\\n-------\\nout : bool\\n    True if a and b might share memory.\\n\\nExamples\\n--------\\n>>> np.may_share_memory(np.array([1,2]), np.array([5,6]))\\nFalse\\n>>> x = np.zeros([3, 4])\\n>>> np.may_share_memory(x[:,0], x[:,1])\\nTrue\",\n}\n-/\n\n/-  numpy.may_share_memory: Determine if two arrays might share memory.\n\n    This function conservatively checks if two arrays might share memory.\n    A return of True does not necessarily mean that the two arrays share any element.\n    It just means that they might.\n\n    Only the memory bounds of a and b are checked by default.\n-/\n\n/-  Specification: may_share_memory returns a boolean indicating whether two arrays might share memory.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: The function returns a boolean value. If the arrays are identical references,\n    it must return True. For independent arrays, it may return False.\n    The function is conservative - it can return True even when arrays don't actually share memory.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def may_share_memory {n m : Nat} (a : Vector Float n) (b : Vector Float m) : Id Bool :=\n  sorry", "vc-theorems": "theorem may_share_memory_spec {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    may_share_memory a b\n    \u2983\u21d3result => \u231c\n      -- Basic sanity check: result is a boolean\n      (result = true \u2228 result = false) \u2227\n      -- Conservative property: function is sound - may return True even when arrays don't share memory\n      -- but will detect potential memory overlap based on bounds analysis\n      (result = true \u2192 True) \u2227\n      -- Deterministic property: same inputs always produce same output\n      (may_share_memory a b = result) \u2227\n      -- Reflexive property: an array compared with itself in the same-size case\n      (n = m \u2227 a.toList = b.toList \u2192 result = true \u2228 result = false)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_min_scalar_type", "vc-description": "/-  numpy.min_scalar_type: For scalar a, returns the data type with the smallest size \n    and smallest scalar kind which can hold its value.\n\n    This function determines the minimal NumPy data type that can represent a given scalar value.\n    The function prioritizes:\n    1. Smallest possible size (in bits)\n    2. Smallest scalar kind (unsigned int < signed int < float < complex)\n\n    For integer values, it finds the smallest integer type that can hold the value.\n    For floating point values, it finds the smallest float type that can represent it.\n-/\n\n/-  Specification: min_scalar_type returns the minimal data type that can hold the given value.\n\n    Precondition: True (works for any scalar value)\n    Postcondition: The returned type is the minimal type that can hold the value, meaning:\n    1. The type can represent the given value\n    2. No type with smaller size can represent the value\n    3. Among types of the same size, it has the smallest kind order\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Enumeration for NumPy data types -/\ninductive NumpyDType\n  | UInt8 | UInt16 | UInt32 | UInt64\n  | Int8 | Int16 | Int32 | Int64\n  | Float16 | Float32 | Float64\n  | Complex64 | Complex128\n  deriving Repr, DecidableEq\n\n/-- Define type sizes in bits -/\ndef dtype_size : NumpyDType \u2192 Nat\n  | .UInt8 => 8\n  | .UInt16 => 16\n  | .UInt32 => 32\n  | .UInt64 => 64\n  | .Int8 => 8\n  | .Int16 => 16\n  | .Int32 => 32\n  | .Int64 => 64\n  | .Float16 => 16\n  | .Float32 => 32\n  | .Float64 => 64\n  | .Complex64 => 64\n  | .Complex128 => 128\n/-- Define type hierarchy (order of preference) -/\ndef dtype_kind_order : NumpyDType \u2192 Nat\n  | .UInt8 | .UInt16 | .UInt32 | .UInt64 => 0  -- unsigned integers first\n  | .Int8 | .Int16 | .Int32 | .Int64 => 1      -- signed integers second\n  | .Float16 | .Float32 | .Float64 => 2       -- floats third\n  | .Complex64 | .Complex128 => 3             -- complex last\n/-- Check if a type can represent a given float value -/\ndef can_represent_value (dt : NumpyDType) (value : Float) : Prop :=\n  match dt with\n  | .UInt8 => 0 \u2264 value \u2227 value \u2264 255 \u2227 value = value.floor\n  | .UInt16 => 0 \u2264 value \u2227 value \u2264 65535 \u2227 value = value.floor\n  | .UInt32 => 0 \u2264 value \u2227 value \u2264 4294967295 \u2227 value = value.floor\n  | .UInt64 => 0 \u2264 value \u2227 value \u2264 18446744073709551615 \u2227 value = value.floor\n  | .Int8 => -128 \u2264 value \u2227 value \u2264 127 \u2227 value = value.floor\n  | .Int16 => -32768 \u2264 value \u2227 value \u2264 32767 \u2227 value = value.floor\n  | .Int32 => -2147483648 \u2264 value \u2227 value \u2264 2147483647 \u2227 value = value.floor\n  | .Int64 => -9223372036854775808 \u2264 value \u2227 value \u2264 9223372036854775807 \u2227 value = value.floor\n  | .Float16 | .Float32 | .Float64 | .Complex64 | .Complex128 => True", "vc-helpers": "", "vc-definitions": "def min_scalar_type (value : Float) : Id NumpyDType :=\n  sorry", "vc-theorems": "theorem min_scalar_type_spec (value : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    min_scalar_type value\n    \u2983\u21d3result => \u231c\n      -- The result type can represent the value\n      can_represent_value result value \u2227\n      -- No smaller type can represent the value\n      (\u2200 dt : NumpyDType, dtype_size dt < dtype_size result \u2192 \n        \u00accan_represent_value dt value) \u2227\n      -- Among types of same size, it has smallest kind order\n      (\u2200 dt : NumpyDType, dtype_size dt = dtype_size result \u2192 \n        can_represent_value dt value \u2192 \n        dtype_kind_order result \u2264 dtype_kind_order dt)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_mintypecode", "vc-description": "/- \n{\n  \"name\": \"numpy.mintypecode\",\n  \"category\": \"Miscellaneous Type Utilities\",\n  \"description\": \"Return the character for the minimum-size type to which given types can be safely cast\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.mintypecode.html\",\n  \"doc\": \"Return the character for the minimum-size type to which given types can be safely cast.\\n\\nParameters\\n----------\\ntypechars : list of str or array_like\\n    If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.\\ntypeset : str or list of str, optional\\n    The set of characters that the returned character is chosen from. The default set is 'GDFgdf'.\\ndefault : str, optional\\n    The default character if none in typeset matches.\\n\\nReturns\\n-------\\ntypechar : str\\n    The character representing the minimum-size type found.\\n\\nExamples\\n--------\\n>>> np.mintypecode(['d', 'f', 'S'])\\n'd'\\n>>> x = np.array([1.1, 2-3.j])\\n>>> np.mintypecode(x)\\n'D'\\n>>> np.mintypecode('abceh', default='G')\\n'G'\",\n}\n-/\n\n/-  Return the character for the minimum-size type to which given types can be safely cast -/\n\n/-  Specification: mintypecode returns the minimum-size type character that can handle all input types -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- NumPy type character to precedence mapping based on the default typeset 'GDFgdf'\n    Lower values indicate higher precedence (smaller/more restrictive types) -/\ndef typechar_precedence : Char \u2192 Nat\n  | 'g' => 0  -- longdouble (most restrictive in numerical sense)\n  | 'd' => 1  -- double\n  | 'f' => 2  -- float\n  | 'F' => 3  -- csingle (complex float)\n  | 'D' => 4  -- cdouble (complex double)\n  | 'G' => 5  -- clongdouble (complex long double)\n  | _   => 6  -- other types (lowest precedence)\n/-- Check if a type character is in the given typeset -/\ndef char_in_typeset {n : Nat} (c : Char) (typeset : Vector Char n) : Bool :=\n  typeset.toList.contains c", "vc-helpers": "", "vc-definitions": "def mintypecode {n m : Nat} (typechars : Vector Char n) (typeset : Vector Char m) (default : Char) : Id Char :=\n  sorry", "vc-theorems": "theorem mintypecode_spec {n m : Nat} (typechars : Vector Char n) (typeset : Vector Char m) (default : Char) \n    (h_typeset : typeset.toList = ['G', 'D', 'F', 'g', 'd', 'f']) :\n    \u2983\u231ctypeset.toList = ['G', 'D', 'F', 'g', 'd', 'f']\u231d\u2984\n    mintypecode typechars typeset default\n    \u2983\u21d3result => \u231c\n      -- Case 1: No input types in typeset - return default\n      (\u2200 c \u2208 typechars.toList, \u00ac(char_in_typeset c typeset) \u2192 result = default) \u2227\n\n      -- Case 2: Special rule - if both 'F' and 'd' are in intersection, return 'D'\n      (\u2203 (intersection : List Char), \n        intersection = (typechars.toList.filter (fun c => char_in_typeset c typeset)) \u2227\n        intersection.length > 0 \u2227\n        ('F' \u2208 intersection \u2227 'd' \u2208 intersection \u2192 result = 'D')) \u2227\n\n      -- Case 3: Normal case - return minimum precedence type from intersection\n      (\u2203 (intersection : List Char),\n        intersection = (typechars.toList.filter (fun c => char_in_typeset c typeset)) \u2227\n        intersection.length > 0 \u2227\n        \u00ac('F' \u2208 intersection \u2227 'd' \u2208 intersection) \u2192\n        (result \u2208 intersection \u2227 \n         \u2200 c \u2208 intersection, typechar_precedence result \u2264 typechar_precedence c)) \u2227\n\n      -- Validity: result is either from intersection or default\n      (result \u2208 (typechars.toList.filter (fun c => char_in_typeset c typeset)) \u2228 \n       result = default) \u2227\n\n      -- Safety property: result can handle all input types\n      (\u2200 c \u2208 typechars.toList, char_in_typeset c typeset \u2192 \n        typechar_precedence result \u2264 typechar_precedence c \u2228 \n        (result = 'D' \u2227 ('F' \u2208 typechars.toList \u2227 'd' \u2208 typechars.toList)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_obj2sctype", "vc-description": "/-  numpy.obj2sctype: Return the scalar dtype or NumPy equivalent of Python type of an object.\n\n    Takes any object and returns its corresponding NumPy scalar data type.\n    If the object's type cannot be determined, returns the default value if provided,\n    otherwise returns none.\n\n    This function performs type introspection to determine the appropriate NumPy\n    scalar type for any given object, including arrays, scalars, and generic objects.\n-/\n\n/-  Specification: obj2sctype returns the appropriate NumPy scalar type for the input object.\n\n    The function correctly identifies:\n    1. Scalar types from their corresponding objects\n    2. Array element types from array objects\n    3. Generic object types\n    4. Returns default for unrecognized types\n    5. Returns none when no default is provided for unrecognized types\n\n    Precondition: True (works with any object)\n    Postcondition: The result correctly represents the scalar type of the input object\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- NumPy scalar data types represented as an inductive type -/\ninductive NumpyScalarType\n  | int32 : NumpyScalarType\n  | int64 : NumpyScalarType\n  | float32 : NumpyScalarType\n  | float64 : NumpyScalarType\n  | complex64 : NumpyScalarType\n  | complex128 : NumpyScalarType\n  | object : NumpyScalarType\n  | string : NumpyScalarType\n  | bool : NumpyScalarType\n  deriving Repr, DecidableEq\n\n/-- Object representation for type introspection -/\ninductive NumpyObject\n  | int_val : Int \u2192 NumpyObject\n  | float_val : Float \u2192 NumpyObject\n  | array_int : \u2200 {n : Nat}, Vector Int n \u2192 NumpyObject\n  | array_float : \u2200 {n : Nat}, Vector Float n \u2192 NumpyObject\n  | array_complex : \u2200 {n : Nat}, Vector (Float \u00d7 Float) n \u2192 NumpyObject\n  | generic_obj : Unit \u2192 NumpyObject\n  | string_val : String \u2192 NumpyObject\n  | bool_val : Bool \u2192 NumpyObject\n  deriving Repr\n\n/-- Helper predicate: Check if object matches given scalar type -/\ndef NumpyObject.matches_scalar_type (obj : NumpyObject) (dtype : NumpyScalarType) : Prop :=\n  match obj, dtype with\n  | NumpyObject.int_val _, NumpyScalarType.int64 => True\n  | NumpyObject.float_val _, NumpyScalarType.float64 => True\n  | NumpyObject.string_val _, NumpyScalarType.string => True\n  | NumpyObject.bool_val _, NumpyScalarType.bool => True\n  | _, _ => False\n/-- Helper predicate: Check if object is an array with given element type -/\ndef NumpyObject.is_array_with_element_type (obj : NumpyObject) (dtype : NumpyScalarType) : Prop :=\n  match obj, dtype with\n  | NumpyObject.array_int _, NumpyScalarType.int64 => True\n  | NumpyObject.array_float _, NumpyScalarType.float64 => True\n  | NumpyObject.array_complex _, NumpyScalarType.complex128 => True\n  | _, _ => False\n/-- Helper predicate: Check if object is a generic object -/\ndef NumpyObject.is_generic_object (obj : NumpyObject) : Prop :=\n  match obj with\n  | NumpyObject.generic_obj _ => True\n  | _ => False", "vc-helpers": "", "vc-definitions": "def obj2sctype (rep : NumpyObject) (default : Option NumpyScalarType) : Id (Option NumpyScalarType) :=\n  sorry", "vc-theorems": "theorem obj2sctype_spec (rep : NumpyObject) (default : Option NumpyScalarType) :\n    \u2983\u231cTrue\u231d\u2984\n    obj2sctype rep default\n    \u2983\u21d3result => \u231c\n      (match rep with\n       | NumpyObject.int_val _ => result = some NumpyScalarType.int64\n       | NumpyObject.float_val _ => result = some NumpyScalarType.float64\n       | NumpyObject.array_int _ => result = some NumpyScalarType.int64\n       | NumpyObject.array_float _ => result = some NumpyScalarType.float64\n       | NumpyObject.array_complex _ => result = some NumpyScalarType.complex128\n       | NumpyObject.string_val _ => result = some NumpyScalarType.string\n       | NumpyObject.bool_val _ => result = some NumpyScalarType.bool\n       | NumpyObject.generic_obj _ => result = default) \u2227\n      (match result with\n       | some dtype => (\n           (rep.matches_scalar_type dtype) \u2228 \n           (rep.is_array_with_element_type dtype) \u2228\n           (rep.is_generic_object \u2227 result = default)\n         )\n       | none => rep.is_generic_object \u2227 default = none)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_promote_types", "vc-description": "/-  numpy.promote_types: Returns the data type with the smallest size and smallest scalar kind\n    to which both type1 and type2 may be safely cast.\n\n    This function is symmetric but rarely associative. It returns a \"canonical\" dtype.\n\n    Examples from NumPy documentation:\n    - promote_types('f4', 'f8') = 'f8' (float64)\n    - promote_types('i8', 'f4') = 'f8' (float64)\n    - promote_types('i4', 'S8') = 'S11' (string, but we focus on numeric types)\n-/\n\n/-  Specification: promote_types returns the smallest safe common type for two dtypes.\n\n    Key properties based on NumPy's type promotion rules:\n    1. Symmetry: promote_types(a, b) = promote_types(b, a)\n    2. Safety: Both input types can be safely cast to the result type\n    3. Minimality: The result is the smallest type that satisfies the safety requirement\n    4. Type promotion hierarchy: \n       - If either input is complex, result is complex\n       - If either input is float, result is float (unless both are complex)\n       - Signed integers promote to larger signed integers\n       - Unsigned integers promote to larger unsigned integers\n       - Mixed signed/unsigned promote to signed of sufficient size\n    5. Size consideration: Result has size >= max(size(type1), size(type2))\n    6. Specific examples:\n       - Float32 + Float64 \u2192 Float64 (larger precision)\n       - Int64 + Float32 \u2192 Float64 (float with sufficient precision)\n       - Complex64 + Float32 \u2192 Complex64 (complex dominates)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Define enumeration for NumPy data types -/\ninductive NumpyDType\n  /-- 8-bit unsigned integer -/  | UInt8\n  /-- 16-bit unsigned integer -/ | UInt16\n  /-- 32-bit unsigned integer -/ | UInt32\n  /-- 64-bit unsigned integer -/ | UInt64\n  /-- 8-bit signed integer -/    | Int8\n  /-- 16-bit signed integer -/   | Int16\n  /-- 32-bit signed integer -/   | Int32\n  /-- 64-bit signed integer -/   | Int64\n  /-- 16-bit floating point -/   | Float16\n  /-- 32-bit floating point -/   | Float32\n  /-- 64-bit floating point -/   | Float64\n  /-- 64-bit complex number -/   | Complex64\n  /-- 128-bit complex number -/  | Complex128\n  deriving Repr, DecidableEq\n\n/-- Define type sizes in bits -/\ndef dtype_size : NumpyDType \u2192 Nat\n  | .UInt8 => 8\n  | .UInt16 => 16\n  | .UInt32 => 32\n  | .UInt64 => 64\n  | .Int8 => 8\n  | .Int16 => 16\n  | .Int32 => 32\n  | .Int64 => 64\n  | .Float16 => 16\n  | .Float32 => 32\n  | .Float64 => 64\n  | .Complex64 => 64\n  | .Complex128 => 128\n/-- Define type promotion rules hierarchy -/\ndef promotion_hierarchy : NumpyDType \u2192 Nat\n  | .UInt8 => 0\n  | .UInt16 => 1\n  | .UInt32 => 2\n  | .UInt64 => 3\n  | .Int8 => 4\n  | .Int16 => 5\n  | .Int32 => 6\n  | .Int64 => 7\n  | .Float16 => 8\n  | .Float32 => 9\n  | .Float64 => 10\n  | .Complex64 => 11\n  | .Complex128 => 12\n/-- Check if a type is a signed integer -/\ndef is_signed_integer (dt : NumpyDType) : Bool :=\n  match dt with\n  | .Int8 | .Int16 | .Int32 | .Int64 => true\n  | _ => false\n/-- Check if a type is an unsigned integer -/\ndef is_unsigned_integer (dt : NumpyDType) : Bool :=\n  match dt with\n  | .UInt8 | .UInt16 | .UInt32 | .UInt64 => true\n  | _ => false\n/-- Check if a type is a floating point type -/\ndef is_float (dt : NumpyDType) : Bool :=\n  match dt with\n  | .Float16 | .Float32 | .Float64 => true\n  | _ => false\n/-- Check if a type is a complex type -/\ndef is_complex (dt : NumpyDType) : Bool :=\n  match dt with\n  | .Complex64 | .Complex128 => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def promote_types (type1 type2 : NumpyDType) : Id NumpyDType :=\n  sorry", "vc-theorems": "theorem promote_types_spec (type1 type2 : NumpyDType) :\n    \u2983\u231cTrue\u231d\u2984\n    promote_types type1 type2\n    \u2983\u21d3result => \u231c\n      -- Symmetry property - function is commutative\n      (promote_types type1 type2 = promote_types type2 type1) \u2227\n\n      -- Type promotion hierarchy rules\n      -- If either input is complex, result must be complex\n      (is_complex type1 \u2228 is_complex type2) \u2192 is_complex result \u2227\n\n      -- If either input is float (and not complex), result is float or complex\n      (is_float type1 \u2228 is_float type2) \u2192 (is_float result \u2228 is_complex result) \u2227\n\n      -- Size constraint: result size >= max of input sizes\n      (dtype_size result \u2265 max (dtype_size type1) (dtype_size type2)) \u2227\n\n      -- Promotion hierarchy: result rank >= max of input ranks\n      (promotion_hierarchy result \u2265 max (promotion_hierarchy type1) (promotion_hierarchy type2)) \u2227\n\n      -- Safety constraints: both input types can be safely cast to result\n      -- Complex types can hold any numeric value\n      (is_complex result \u2192\n        (is_complex type1 \u2228 is_float type1 \u2228 is_signed_integer type1 \u2228 is_unsigned_integer type1) \u2227\n        (is_complex type2 \u2228 is_float type2 \u2228 is_signed_integer type2 \u2228 is_unsigned_integer type2)) \u2227\n\n      -- Float types can hold integers and smaller floats\n      (is_float result \u2227 \u00acis_complex result \u2192\n        (\u00acis_complex type1 \u2227 \u00acis_complex type2) \u2227\n        (dtype_size result \u2265 dtype_size type1 \u2228 \u00acis_float type1) \u2227\n        (dtype_size result \u2265 dtype_size type2 \u2228 \u00acis_float type2)) \u2227\n\n      -- Specific promotion rules for common cases from NumPy documentation\n      -- Integer + Float \u2192 Float with sufficient precision (like 'i8' + 'f4' \u2192 'f8')\n      ((is_signed_integer type1 \u2228 is_unsigned_integer type1) \u2227 is_float type2 \u2192\n        is_float result \u2227 dtype_size result \u2265 dtype_size type2) \u2227\n\n      -- Float + Integer \u2192 Float with sufficient precision  \n      (is_float type1 \u2227 (is_signed_integer type2 \u2228 is_unsigned_integer type2) \u2192\n        is_float result \u2227 dtype_size result \u2265 dtype_size type1) \u2227\n\n      -- Complex + any non-complex \u2192 Complex with sufficient precision\n      (is_complex type1 \u2227 \u00acis_complex type2 \u2192\n        is_complex result \u2227 dtype_size result \u2265 dtype_size type1) \u2227\n      (is_complex type2 \u2227 \u00acis_complex type1 \u2192\n        is_complex result \u2227 dtype_size result \u2265 dtype_size type2) \u2227\n\n      -- Same types promote to themselves (reflexivity)\n      (type1 = type2 \u2192 result = type1) \u2227\n\n      -- Float precision promotion (like 'f4' + 'f8' \u2192 'f8')\n      (is_float type1 \u2227 is_float type2 \u2192\n        is_float result \u2227 dtype_size result \u2265 max (dtype_size type1) (dtype_size type2))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_result_type", "vc-description": "/- \n{\n  \"name\": \"numpy.result_type\",\n  \"category\": \"Type Casting and Promotion\",\n  \"description\": \"Returns the type that results from applying the NumPy type promotion rules to the arguments\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.result_type.html\",\n  \"doc\": \"Returns the type that results from applying NumPy type promotion rules to the arguments.\\n\\nType promotion in NumPy works similarly to the rules in languages like C++, with some differences. When both scalars and arrays are used, the array's type takes precedence and the scalar's actual value is considered.\\n\\nParameters\\n----------\\n*arrays_and_dtypes : list of arrays and dtypes\\n    The operands of some operation whose result type is needed.\\n\\nReturns\\n-------\\nout : dtype\\n    The result type.\\n\\nExamples\\n--------\\n>>> np.result_type(3, np.arange(7, dtype='i1'))\\ndtype('int8')\\n>>> np.result_type('i4', 'c8')\\ndtype('complex128')\\n>>> np.result_type(3.0, -2)\\ndtype('float64')\",\n}\n-/\n\n/-  Returns the data type that results from applying NumPy type promotion rules to the arguments -/\n\n/-  Specification: result_type returns the promoted type according to NumPy's hierarchy -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Define NumPy data types for type promotion -/\ninductive NumpyDType : Type where\n  /-- 8-bit signed integer -/\n  | int8 : NumpyDType\n  /-- 16-bit signed integer -/\n  | int16 : NumpyDType\n  /-- 32-bit signed integer -/\n  | int32 : NumpyDType\n  /-- 64-bit signed integer -/\n  | int64 : NumpyDType\n  /-- 32-bit floating point -/\n  | float32 : NumpyDType\n  /-- 64-bit floating point -/\n  | float64 : NumpyDType\n  /-- 64-bit complex number -/\n  | complex64 : NumpyDType\n  /-- 128-bit complex number -/\n  | complex128 : NumpyDType\n  /-- Boolean type -/\n  | bool : NumpyDType\nderiving Inhabited, DecidableEq\n\n/-- Define type promotion hierarchy (higher number = higher precedence) -/\ndef typeRank : NumpyDType \u2192 Nat\n  | NumpyDType.bool => 0\n  | NumpyDType.int8 => 1\n  | NumpyDType.int16 => 2\n  | NumpyDType.int32 => 3\n  | NumpyDType.int64 => 4\n  | NumpyDType.float32 => 5\n  | NumpyDType.float64 => 6\n  | NumpyDType.complex64 => 7\n  | NumpyDType.complex128 => 8\n/-- Define operand types (either scalar or array) -/\ninductive NumpyOperand : Type where\n  /-- Scalar value with data type -/\n  | scalar : NumpyDType \u2192 NumpyOperand\n  /-- Array with data type and vector of values -/\n  | array : \u2200 {n : Nat}, NumpyDType \u2192 Vector Int n \u2192 NumpyOperand\n\n/-- Extract the data type from an operand -/\ndef operandType : NumpyOperand \u2192 NumpyDType\n  | NumpyOperand.scalar dtype => dtype\n  | NumpyOperand.array dtype _ => dtype\n/-- Type promotion function for two types -/\ndef promoteTypes (t1 t2 : NumpyDType) : NumpyDType :=\n  if typeRank t1 \u2265 typeRank t2 then t1 else t2", "vc-helpers": "", "vc-definitions": "def result_type (operands : List NumpyOperand) : Id NumpyDType :=\n  sorry", "vc-theorems": "theorem result_type_spec (operands : List NumpyOperand) (h_nonempty : operands.length > 0) :\n    \u2983\u231coperands.length > 0\u231d\u2984\n    result_type operands\n    \u2983\u21d3result => \u231c\n      -- The result type is at least as high in the hierarchy as any input type\n      (\u2200 op, op \u2208 operands \u2192 typeRank result \u2265 typeRank (operandType op)) \u2227\n      -- The result type is the minimum type that can represent all inputs\n      (\u2203 op, op \u2208 operands \u2227 typeRank result = typeRank (operandType op)) \u2227\n      -- Array types take precedence over scalar types of the same rank\n      (\u2200 op1 op2, op1 \u2208 operands \u2192 op2 \u2208 operands \u2192\n        operandType op1 = operandType op2 \u2192 \n        (\u2203 n : Nat, \u2203 v : Vector Int n, op1 = NumpyOperand.array (operandType op1) v) \u2192\n        (op2 = NumpyOperand.scalar (operandType op2)) \u2192\n        typeRank result = typeRank (operandType op1)) \u2227\n      -- Type promotion follows the standard hierarchy\n      (\u2200 t1 t2 : NumpyDType, \n        (\u2203 op1, op1 \u2208 operands \u2227 operandType op1 = t1) \u2192\n        (\u2203 op2, op2 \u2208 operands \u2227 operandType op2 = t2) \u2192\n        typeRank result \u2265 max (typeRank t1) (typeRank t2))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_sctype2char", "vc-description": "/- \n{\n  \"name\": \"numpy.sctype2char\",\n  \"category\": \"Miscellaneous Type Utilities\",\n  \"description\": \"Return the string representation of a scalar dtype\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.sctype2char.html\",\n  \"doc\": \"Return the string representation of a scalar dtype.\\n\\nParameters\\n----------\\nsctype : scalar dtype or object\\n    If a scalar dtype, the corresponding string character is returned. If an object, sctype2char tries to infer its scalar type and then return the corresponding string character.\\n\\nReturns\\n-------\\ntypechar : str\\n    The string character corresponding to the scalar type.\\n\\nRaises\\n------\\nValueError\\n    If sctype is an object for which the type cannot be inferred.\\n\\nExamples\\n--------\\n>>> for sctype in [np.int32, np.double, np.complex_, np.bytes_, np.ndarray]:\\n...     print(np.sctype2char(sctype))\\n...\\nl\\nd\\nD\\nS\\nO\\n\\n>>> x = np.array([1., 2-1.j])\\n>>> np.sctype2char(x)\\n'D'\\n>>> np.sctype2char(list)\\n'O'\",\n}\n-/\n\n/-  numpy.sctype2char: Return the string representation of a scalar dtype\n\n    Converts a scalar data type to its corresponding single-character string representation.\n    This is used internally by numpy to represent data types in a compact form.\n\n    The mapping follows numpy's dtype.char convention:\n    - int32 \u2192 'l'\n    - float64 (double) \u2192 'd'  \n    - complex128 \u2192 'D'\n    - bytes \u2192 'S'\n    - object \u2192 'O'\n-/\n\n/-  Specification: sctype2char returns the correct character representation\n    for each scalar type.\n\n    Precondition: Valid scalar type (guaranteed by type system)\n    Postcondition: Returns the standard numpy character for the given type\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Scalar data type enumeration for numpy types -/\ninductive ScalarType\n  | /-- 32-bit signed integer -/ int32\n  | /-- 64-bit signed integer -/ int64\n  | /-- 32-bit floating point -/ float32\n  | /-- 64-bit floating point -/ float64\n  | /-- 64-bit complex number -/ complex64\n  | /-- 128-bit complex number -/ complex128\n  | /-- Byte string -/ bytes\n  | /-- Generic object -/ object", "vc-helpers": "", "vc-definitions": "def sctype2char (sctype : ScalarType) : Id String :=\n  sorry", "vc-theorems": "theorem sctype2char_spec (sctype : ScalarType) :\n    \u2983\u231cTrue\u231d\u2984\n    sctype2char sctype\n    \u2983\u21d3result => \u231c\n      (sctype = ScalarType.int32 \u2192 result = \"l\") \u2227\n      (sctype = ScalarType.int64 \u2192 result = \"q\") \u2227\n      (sctype = ScalarType.float32 \u2192 result = \"f\") \u2227\n      (sctype = ScalarType.float64 \u2192 result = \"d\") \u2227\n      (sctype = ScalarType.complex64 \u2192 result = \"F\") \u2227\n      (sctype = ScalarType.complex128 \u2192 result = \"D\") \u2227\n      (sctype = ScalarType.bytes \u2192 result = \"S\") \u2227\n      (sctype = ScalarType.object \u2192 result = \"O\")\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_shares_memory", "vc-description": "/- \n{\n  \"name\": \"numpy.shares_memory\",\n  \"category\": \"Memory and Striding\",\n  \"description\": \"Determine if two arrays share memory\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.shares_memory.html\",\n  \"doc\": \"Determine if two arrays share memory.\\n\\nWarning: This function can be exponentially slow for some inputs, see Notes.\\n\\nParameters\\n----------\\na, b : ndarray\\n    Input arrays.\\nmax_work : int, optional\\n    Effort to spend on solving the overlap problem.\\n\\nReturns\\n-------\\nout : bool\\n    True if a and b share memory.\\n\\nRaises\\n------\\nnumpy.exceptions.TooHardError\\n    Exceeded max_work.\\n\\nNotes\\n-----\\ncan_share_memory bounds the problem complexity.\\n\\nExamples\\n--------\\n>>> x = np.array([1, 2, 3, 4])\\n>>> np.shares_memory(x, x)\\nTrue\\n>>> np.shares_memory(x, x.copy())\\nFalse\",\n}\n-/\n\n/-  numpy.shares_memory: Determine if two arrays share memory.\n\n    This function determines if two arrays share memory by checking\n    if they reference the same underlying memory locations.\n\n    Unlike may_share_memory, this function provides a definitive answer\n    about memory sharing rather than a conservative estimate.\n\n    The function can be exponentially slow for some inputs due to the\n    complexity of the overlap detection algorithm.\n-/\n\n/-  Specification: shares_memory returns a boolean indicating whether two arrays actually share memory.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: The function returns a boolean value that accurately reflects memory sharing.\n    If the arrays are identical references, it must return True.\n    If the arrays are independent (non-overlapping memory), it must return False.\n    The function is precise - it returns True if and only if the arrays share memory.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def shares_memory {n m : Nat} (a : Vector Float n) (b : Vector Float m) : Id Bool :=\n  sorry", "vc-theorems": "theorem shares_memory_spec {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    shares_memory a b\n    \u2983\u21d3result => \u231c\n      -- Basic sanity check: result is a boolean\n      (result = true \u2228 result = false) \u2227\n      -- Deterministic property: same inputs always produce same output\n      (shares_memory a b = result) \u2227\n      -- Reflexive property: an array shares memory with itself when identical\n      (n = m \u2227 a.toList = b.toList \u2192 result = true) \u2227\n      -- Independence property: different arrays with different contents don't share memory\n      (n \u2260 m \u2228 a.toList \u2260 b.toList \u2192 result = false \u2228 result = true) \u2227\n      -- Precision property: the function provides definitive answers about memory sharing\n      -- (in contrast to may_share_memory which is conservative)\n      (result = true \u2192 True) \u2227 (result = false \u2192 True)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_typecodes", "vc-description": "/- \n{\n  \"name\": \"numpy.typecodes\",\n  \"category\": \"Miscellaneous Type Utilities\",\n  \"description\": \"Dictionary mapping strings to corresponding type character codes\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.typecodes.html\",\n  \"doc\": \"typecodes : dict\\n\\nA dictionary with string keys that represent NumPy dtype categories and string values that contain type codes for the NumPy data types in each category.\\n\\nKeys include:\\n- 'Character': 'S1'\\n- 'Integer': 'bhilqnp'\\n- 'UnsignedInteger': 'BHILQNP'\\n- 'Float': 'fdg'\\n- 'Complex': 'FDG'\\n- 'AllInteger': 'bBhHiIlLqQnNpP'\\n- 'AllFloat': 'fdgFDG'\\n- 'Datetime': 'Mm'\\n- 'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'\\n\\nThis is useful for iterating over all dtypes of a certain kind.\\n\\nExamples\\n--------\\n>>> np.typecodes['Character']\\n'S1'\\n>>> for typechar in np.typecodes['Integer']:\\n...     print(typechar)\\n...\\nb\\nh\\ni\\nl\\nq\\nn\\np\",\n}\n-/\n\n/-  Returns the type character codes for a given NumPy dtype category -/\n\n/-  Specification: typecodes returns the correct type character codes for each NumPy dtype category -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def typecodes (category : String) : Id (Option String) :=\n  sorry", "vc-theorems": "theorem typecodes_spec (category : String) :\n    \u2983\u231cTrue\u231d\u2984\n    typecodes category\n    \u2983\u21d3result => \u231c\n      (category = \"Character\" \u2192 result = some \"S1\") \u2227\n      (category = \"Integer\" \u2192 result = some \"bhilqnp\") \u2227\n      (category = \"UnsignedInteger\" \u2192 result = some \"BHILQNP\") \u2227\n      (category = \"Float\" \u2192 result = some \"fdg\") \u2227\n      (category = \"Complex\" \u2192 result = some \"FDG\") \u2227\n      (category = \"AllInteger\" \u2192 result = some \"bBhHiIlLqQnNpP\") \u2227\n      (category = \"AllFloat\" \u2192 result = some \"fdgFDG\") \u2227\n      (category = \"Datetime\" \u2192 result = some \"Mm\") \u2227\n      (category = \"All\" \u2192 result = some \"?bhilqnpBHILQNPfdgFDGSUVOMm\") \u2227\n      (category \u2209 [\"Character\", \"Integer\", \"UnsignedInteger\", \"Float\", \"Complex\", \"AllInteger\", \"AllFloat\", \"Datetime\", \"All\"] \u2192 result = none)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "data_type_routines_typename", "vc-description": "/- \n{\n  \"name\": \"numpy.typename\",\n  \"category\": \"Miscellaneous Type Utilities\",\n  \"description\": \"Return a description for the given data type code\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.typename.html\",\n  \"doc\": \"Return a description for the given data type code.\\n\\nParameters\\n----------\\nchar : str\\n    Data type code.\\n\\nReturns\\n-------\\nout : str\\n    Description of the input data type code.\\n\\nExamples\\n--------\\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\\n>>> for typechar in typechars:\\n...     print(typechar, ' : ', np.typename(typechar))\\n...\\nS1  :  character\\n?  :  bool\\nB  :  unsigned char\\nD  :  complex double precision\\nG  :  complex long double precision\\nF  :  complex single precision\\nI  :  unsigned integer\\nH  :  unsigned short\\nL  :  unsigned long integer\\nO  :  object\\nQ  :  unsigned long long integer\\nS  :  character\\nU  :  unicode\\nV  :  void\\nb  :  signed char\\nd  :  double precision\\ng  :  long precision\\nf  :  single precision\\ni  :  integer\\nh  :  short\\nl  :  long integer\\nq  :  long long integer\",\n}\n-/\n\n/-  Return a description for the given data type code -/\n\n/-  Specification: typename maps data type codes to their descriptions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def typename (char : String) : Id String :=\n  sorry", "vc-theorems": "theorem typename_spec (char : String) :\n    \u2983\u231cTrue\u231d\u2984\n    typename char\n    \u2983\u21d3result => \u231c\n      -- Known type code mappings from NumPy documentation\n      (char = \"S1\" \u2192 result = \"character\") \u2227\n      (char = \"?\" \u2192 result = \"bool\") \u2227\n      (char = \"B\" \u2192 result = \"unsigned char\") \u2227\n      (char = \"D\" \u2192 result = \"complex double precision\") \u2227\n      (char = \"G\" \u2192 result = \"complex long double precision\") \u2227\n      (char = \"F\" \u2192 result = \"complex single precision\") \u2227\n      (char = \"I\" \u2192 result = \"unsigned integer\") \u2227\n      (char = \"H\" \u2192 result = \"unsigned short\") \u2227\n      (char = \"L\" \u2192 result = \"unsigned long integer\") \u2227\n      (char = \"O\" \u2192 result = \"object\") \u2227\n      (char = \"Q\" \u2192 result = \"unsigned long long integer\") \u2227\n      (char = \"S\" \u2192 result = \"character\") \u2227\n      (char = \"U\" \u2192 result = \"unicode\") \u2227\n      (char = \"V\" \u2192 result = \"void\") \u2227\n      (char = \"b\" \u2192 result = \"signed char\") \u2227\n      (char = \"d\" \u2192 result = \"double precision\") \u2227\n      (char = \"g\" \u2192 result = \"long precision\") \u2227\n      (char = \"f\" \u2192 result = \"single precision\") \u2227\n      (char = \"i\" \u2192 result = \"integer\") \u2227\n      (char = \"h\" \u2192 result = \"short\") \u2227\n      (char = \"l\" \u2192 result = \"long integer\") \u2227\n      (char = \"q\" \u2192 result = \"long long integer\") \u2227\n      -- For unknown type codes, the function should return some default description\n      (char \u2209 [\"S1\", \"?\", \"B\", \"D\", \"G\", \"F\", \"I\", \"H\", \"L\", \"O\", \"Q\", \n               \"S\", \"U\", \"V\", \"b\", \"d\", \"g\", \"f\", \"i\", \"h\", \"l\", \"q\"] \u2192 \n       result = \"unknown type\" \u2228 result = char)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "datetime_support_datetime64", "vc-description": "/- \n{\n  \"name\": \"numpy.datetime64\",\n  \"category\": \"Datetime types\",\n  \"description\": \"Create a datetime64 object representing an offset from 1970-01-01T00:00:00\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64\",\n  \"doc\": \"If created from a 64-bit integer, it represents an offset from \\`\\`1970-01-01T00:00:00\\`\\`. If created from string, the string can be in ISO 8601 date or datetime format.\\n\\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\\n\\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\\n\\n>>> np.datetime64(10, 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64('1980', 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64(10, 'D')\\nnp.datetime64('1970-01-11')\\n\\nSee :ref:\\`arrays.datetime\\` for more information.\\n\\n:Character code: \\`\\`'M'\\`\\`\",\n}\n-/\n\n/-  Create a datetime64 object from an integer offset and time unit -/\n\n/-  Specification: datetime64 creates a UTC datetime object with the specified offset and unit.\n    The datetime64 object represents a specific moment in time as an offset from the Unix epoch\n    (1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input\n    parameters and ensures the result is always in UTC timezone. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Time unit for datetime64 -/\ninductive TimeUnit : Type where\n  /-- Years unit ('Y') -/\n  | years : TimeUnit   \n  /-- Days unit ('D') -/\n  | days : TimeUnit    \n  /-- Hours unit ('h') -/\n  | hours : TimeUnit   \n  /-- Minutes unit ('m') -/\n  | minutes : TimeUnit \n  /-- Seconds unit ('s') -/\n  | seconds : TimeUnit \n  /-- Milliseconds unit ('ms') -/\n  | milliseconds : TimeUnit \n  /-- Microseconds unit ('us') -/\n  | microseconds : TimeUnit \n  /-- Nanoseconds unit ('ns') -/\n  | nanoseconds : TimeUnit\n\n/-- DateTime64 structure representing offset from Unix epoch -/\nstructure DateTime64 where\n  /-- Offset value from 1970-01-01T00:00:00 -/\n  offset : Int          \n  /-- Time unit of the offset -/\n  unit : TimeUnit       \n  /-- Always UTC with +0000 offset -/\n  is_utc : Bool := true", "vc-helpers": "", "vc-definitions": "def datetime64 (offset : Int) (unit : TimeUnit) : Id DateTime64 :=\n  sorry", "vc-theorems": "theorem datetime64_spec (offset : Int) (unit : TimeUnit) :\n    \u2983\u231cTrue\u231d\u2984\n    datetime64 offset unit\n    \u2983\u21d3result => \u231cresult.offset = offset \u2227 \n                result.unit = unit \u2227 \n                result.is_utc = true \u2227\n                -- Unit-specific validity constraints based on NumPy datetime64 limits\n                (match unit with\n                 | TimeUnit.years => result.offset + 1970 \u2265 1 \u2227 result.offset + 1970 \u2264 9999  -- Valid year range\n                 | TimeUnit.days => result.offset \u2265 -2147483648 \u2227 result.offset \u2264 2147483647    -- Days since epoch\n                 | TimeUnit.hours => result.offset \u2265 -2147483648 \u2227 result.offset \u2264 2147483647   -- Hours since epoch\n                 | TimeUnit.minutes => result.offset \u2265 -2147483648 \u2227 result.offset \u2264 2147483647 -- Minutes since epoch\n                 | TimeUnit.seconds => result.offset \u2265 -2147483648 \u2227 result.offset \u2264 2147483647 -- Seconds since epoch\n                 | TimeUnit.milliseconds => True  -- Milliseconds can use full Int range\n                 | TimeUnit.microseconds => True  -- Microseconds can use full Int range\n                 | TimeUnit.nanoseconds => True)  -- Nanoseconds can use full Int range\n                \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "datetime_support_datetime_as_string", "vc-description": "/- \n{\n  \"name\": \"numpy.datetime_as_string\",\n  \"category\": \"Datetime conversion\",\n  \"description\": \"Convert an array of datetimes into an array of strings\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.datetime_as_string.html\",\n  \"doc\": \"datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\\n\\nConvert an array of datetimes into an array of strings.\\n\\nParameters\\n----------\\narr : array_like of datetime64\\n    The array of UTC timestamps to format.\\nunit : str\\n    One of None, 'auto', or a :ref:\\`datetime unit <arrays.dtypes.dateunits>\\`.\\ntimezone : {'naive', 'UTC', 'local'} or tzinfo\\n    Timezone information to use when displaying the datetime. If 'UTC', end with a Z to indicate UTC time. If 'local', convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with 'local', but use the specified timezone.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}\\n    Casting to allow when changing between datetime units.\\n\\nReturns\\n-------\\nstr_arr : ndarray\\n    An array of strings the same shape as \\`arr\\`.\\n\\nExamples\\n--------\\n>>> import numpy as np\\n>>> import pytz\\n>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\\n>>> d\\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\\n       '2002-10-27T07:30'], dtype='datetime64[m]')\\n\\nSetting the timezone to UTC shows the same information, but with a Z suffix\\n\\n>>> np.datetime_as_string(d, timezone='UTC')\\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\\n       '2002-10-27T07:30Z'], dtype='<U35')\",\n}\n-/\n\n/-  Convert an array of datetime64 values to an array of strings.\n\n    Converts each datetime64 value in the input vector to its string representation.\n    The format depends on the timezone option: 'naive' produces no suffix,\n    'UTC' adds 'Z' suffix, and 'local' would add timezone offset.\n\n    For simplicity, we focus on the core conversion from datetime64 to ISO format strings.\n-/\n\n/-  Specification: datetime_as_string converts each datetime64 to its string representation.\n\n    Precondition: True (no special preconditions)\n    Postcondition: Each datetime64 is converted to a properly formatted ISO 8601 string\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Time unit for datetime64 -/\ninductive TimeUnit : Type where\n  /-- Years unit ('Y') -/\n  | years : TimeUnit   \n  /-- Days unit ('D') -/\n  | days : TimeUnit    \n  /-- Hours unit ('h') -/\n  | hours : TimeUnit   \n  /-- Minutes unit ('m') -/\n  | minutes : TimeUnit \n  /-- Seconds unit ('s') -/\n  | seconds : TimeUnit \n  /-- Milliseconds unit ('ms') -/\n  | milliseconds : TimeUnit \n  /-- Microseconds unit ('us') -/\n  | microseconds : TimeUnit \n  /-- Nanoseconds unit ('ns') -/\n  | nanoseconds : TimeUnit\n\n/-- DateTime64 structure representing offset from Unix epoch -/\nstructure DateTime64 where\n  /-- Offset value from 1970-01-01T00:00:00 -/\n  offset : Int          \n  /-- Time unit of the offset -/\n  unit : TimeUnit       \n  /-- Always UTC with +0000 offset -/\n  is_utc : Bool := true\n\n/-- Timezone formatting options -/\ninductive TimezoneOption : Type where\n  /-- No timezone suffix -/\n  | naive : TimezoneOption  \n  /-- Add 'Z' suffix for UTC -/\n  | UTC : TimezoneOption    \n  /-- Add local timezone offset -/\n  | local : TimezoneOption", "vc-helpers": "", "vc-definitions": "def datetime_as_string {n : Nat} (arr : Vector DateTime64 n) (timezone : TimezoneOption := TimezoneOption.naive) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem datetime_as_string_spec {n : Nat} (arr : Vector DateTime64 n) (timezone : TimezoneOption := TimezoneOption.naive) :\n    \u2983\u231cTrue\u231d\u2984\n    datetime_as_string arr timezone\n    \u2983\u21d3result => \u231c\n      -- Each string is non-empty and represents a valid datetime\n      (\u2200 i : Fin n, result[i].length > 0) \u2227\n      -- Format consistency: string format depends on timezone option\n      (match timezone with\n       | TimezoneOption.naive => \u2200 i : Fin n, \u00acresult[i].endsWith \"Z\"\n       | TimezoneOption.UTC => \u2200 i : Fin n, result[i].endsWith \"Z\"\n       | TimezoneOption.local => True) \u2227  -- Simplified for local timezone\n      -- Each datetime is represented as a valid ISO 8601 string\n      (\u2200 i : Fin n, result[i].contains '-' \u2228 result[i].length \u2265 4) \u2227\n      -- String precision matches the datetime unit precision\n      (\u2200 i : Fin n, match arr[i].unit with\n       | TimeUnit.years => result[i].length \u2265 4    -- At least \"YYYY\"\n       | TimeUnit.days => result[i].length \u2265 10    -- At least \"YYYY-MM-DD\"\n       | TimeUnit.hours => result[i].length \u2265 13   -- At least \"YYYY-MM-DDTHH\"\n       | TimeUnit.minutes => result[i].length \u2265 16 -- At least \"YYYY-MM-DDTHH:MM\"\n       | TimeUnit.seconds => result[i].length \u2265 19 -- At least \"YYYY-MM-DDTHH:MM:SS\"\n       | TimeUnit.milliseconds => result[i].length \u2265 23 -- Include milliseconds\n       | TimeUnit.microseconds => result[i].length \u2265 26 -- Include microseconds\n       | TimeUnit.nanoseconds => result[i].length \u2265 29) -- Include nanoseconds\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "datetime_support_datetime_data", "vc-description": "/- \n{\n  \"name\": \"numpy.datetime_data\",\n  \"category\": \"Datetime metadata\",\n  \"description\": \"Get information about the step size of a date or time type\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.datetime_data.html\",\n  \"doc\": \"datetime_data(dtype, /)\\n\\nGet information about the step size of a date or time type.\\n\\nThe returned tuple can be passed as the second argument of \\`numpy.datetime64\\` and \\`numpy.timedelta64\\`.\\n\\nParameters\\n----------\\ndtype : dtype\\n    The dtype object, which must be a \\`datetime64\\` or \\`timedelta64\\` type.\\n\\nReturns\\n-------\\nunit : str\\n    The :ref:\\`datetime unit <arrays.dtypes.dateunits>\\` on which this dtype is based.\\ncount : int\\n    The number of base units in a step.\\n\\nExamples\\n--------\\n>>> import numpy as np\\n>>> dt_25s = np.dtype('timedelta64[25s]')\\n>>> np.datetime_data(dt_25s)\\n('s', 25)\\n>>> np.array(10, dt_25s).astype('timedelta64[s]')\\narray(250, dtype='timedelta64[s]')\\n\\nThe result can be used to construct a datetime that uses the same units as a timedelta\\n\\n>>> np.datetime64('2010', np.datetime_data(dt_25s))\\nnp.datetime64('2010-01-01T00:00:00','25s')\",\n}\n-/\n\n/-  Get information about the step size of a date or time type.\n\n    Returns a tuple containing the datetime unit and count for the given dtype.\n    This information can be used to construct datetime64 and timedelta64 objects.\n\n    For example, 'timedelta64[25s]' would return ('s', 25).\n-/\n\n/-  Specification: datetime_data extracts the unit and count from a datetime dtype.\n\n    Precondition: The dtype must be a valid datetime64 or timedelta64 type.\n    Postcondition: The returned tuple contains the unit and count that define the dtype.\n\n    For datetime64[N unit], returns (unit, N).\n    For timedelta64[N unit], returns (unit, N).\n\n    This ensures that the returned information can be used to reconstruct\n    the original dtype or create compatible datetime objects.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Datetime unit enumeration representing the time scales used in datetime operations -/\ninductive DatetimeUnit\n  /-- Years -/\n  | Y    \n  /-- Months -/\n  | M    \n  /-- Weeks -/\n  | W    \n  /-- Days -/\n  | D    \n  /-- Hours -/\n  | h    \n  /-- Minutes -/\n  | m    \n  /-- Seconds -/\n  | s    \n  /-- Milliseconds -/\n  | ms   \n  /-- Microseconds -/\n  | us   \n  /-- Nanoseconds -/\n  | ns\n\n/-- Structure containing datetime type information including unit and count -/\nstructure DatetimeTypeInfo where\n  /-- The time unit (seconds, minutes, hours, etc.) -/\n  unit : DatetimeUnit\n  /-- The count of base units in a step (e.g., 25 for \"25 seconds\") -/\n  count : Nat\n\n/-- Datetime dtype representing either datetime64 or timedelta64 types -/\ninductive DatetimeDtype\n  /-- A datetime64 type with specified unit and count -/\n  | datetime64 : DatetimeTypeInfo \u2192 DatetimeDtype\n  /-- A timedelta64 type with specified unit and count -/\n  | timedelta64 : DatetimeTypeInfo \u2192 DatetimeDtype", "vc-helpers": "", "vc-definitions": "def datetime_data (dtype : DatetimeDtype) : Id (DatetimeUnit \u00d7 Nat) :=\n  sorry", "vc-theorems": "theorem datetime_data_spec (dtype : DatetimeDtype) :\n    \u2983\u231cTrue\u231d\u2984\n    datetime_data dtype\n    \u2983\u21d3result => \u231cmatch dtype with\n       | DatetimeDtype.datetime64 info => result = (info.unit, info.count) \u2227 result.2 > 0\n       | DatetimeDtype.timedelta64 info => result = (info.unit, info.count) \u2227 result.2 > 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "datetime_support_timedelta64", "vc-description": "/- \n{\n  \"name\": \"numpy.timedelta64\",\n  \"category\": \"Datetime types\",\n  \"description\": \"A timedelta stored as a 64-bit integer\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.timedelta64\",\n  \"doc\": \"A timedelta stored as a 64-bit integer.\\n\\nSee :ref:\\`arrays.datetime\\` for more information.\\n\\n:Character code: \\`\\`'m'\\`\\`\",\n}\n-/\n\n/-  Create a timedelta64 object from a numeric value and time unit -/\n\n/-  Specification: timedelta64 creates a time duration object with given value and unit -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Time unit codes for timedelta64 -/\ninductive TimeUnit where\n  /-- Year unit ('Y') -/\n  | year       \n  /-- Month unit ('M') -/\n  | month      \n  /-- Week unit ('W') -/\n  | week       \n  /-- Day unit ('D') -/\n  | day        \n  /-- Hour unit ('h') -/\n  | hour       \n  /-- Minute unit ('m') -/\n  | minute     \n  /-- Second unit ('s') -/\n  | second     \n  /-- Millisecond unit ('ms') -/\n  | millisecond \n  /-- Microsecond unit ('us') -/\n  | microsecond \n  /-- Nanosecond unit ('ns') -/\n  | nanosecond \n  /-- Picosecond unit ('ps') -/\n  | picosecond \n  /-- Femtosecond unit ('fs') -/\n  | femtosecond \n  /-- Attosecond unit ('as') -/\n  | attosecond\n\n/-- Represents a time duration value -/\nstructure TimeDelta64 where\n  /-- The numeric value of the time duration -/\n  value : Int64\n  /-- The time unit for the duration -/\n  unit : TimeUnit", "vc-helpers": "", "vc-definitions": "def timedelta64 (value : Int64) (unit : TimeUnit) : Id TimeDelta64 :=\n  sorry", "vc-theorems": "theorem timedelta64_spec (value : Int64) (unit : TimeUnit) :\n    \u2983\u231cTrue\u231d\u2984\n    timedelta64 value unit\n    \u2983\u21d3result => \u231cresult.value = value \u2227 result.unit = unit \u2227 \n                result.value \u2265 -9223372036854775808 \u2227 \n                result.value \u2264 9223372036854775807\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_fft", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.fft\",\n  \"description\": \"Compute the one-dimensional discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.fft.html\",\n  \"doc\": \"numpy.fft.fft(a, n=None, axis=-1, norm=None, out=None)\\n\\nCompute the one-dimensional discrete Fourier Transform using the efficient Fast Fourier Transform (FFT) algorithm.\\n\\nParameters:\\n- a: Input array (can be complex)\\n- n: Optional length of transformed axis (default: input length)\\n- axis: Axis to compute FFT (default: last axis)\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray transformed along specified axis\\n\\nNotes:\\n- Most efficient when input size is a power of 2\\n- FFT calculates Discrete Fourier Transform efficiently\\n- Uses symmetries to optimize calculation\\n- Supports real and complex inputs\\n- Handles input cropping and zero-padding\\n- Provides flexible normalization options\\n\\nExample:\\nimport numpy as np\\nnp.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\",\n}\n-/\n\n/-  Compute the one-dimensional discrete Fourier Transform\n\n    The FFT computes the DFT defined as:\n    X[k] = \u03a3(n=0 to N-1) x[n] * exp(-2\u03c0i*k*n/N)\n\n    where:\n    - x is the input vector\n    - X is the output vector\n    - N is the length of the vector\n    - i is the imaginary unit\n-/\n\n/-  Specification: FFT computes the discrete Fourier transform\n\n    The FFT satisfies the DFT equation and has the following properties:\n    1. Each output element is the sum of input elements weighted by complex exponentials\n    2. The transform is linear\n    3. Parseval's theorem: energy is preserved (with proper normalization)\n    4. FFT(FFT^(-1)(x)) = x (inverse property when combined with IFFT)\n\n    The specification captures the fundamental DFT formula where each output\n    element k is computed as the sum over all input elements j, multiplied\n    by the complex exponential exp(-2\u03c0i*k*j/n).\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT -/\nstructure Complex where\n  /-- Real part of complex number -/\n  re : Float\n  /-- Imaginary part of complex number -/\n  im : Float\nderiving Repr\n\n/-- Complex exponential function -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }\n/-- Sum of complex numbers over finite indices -/\ndef complexSum {n : Nat} (f : Fin n \u2192 Complex) : Complex :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let rec go : Fin (n + 1) \u2192 Complex\n      | \u27e80, _\u27e9 => f \u27e80, by omega\u27e9\n      | \u27e8i + 1, h\u27e9 => f \u27e8i + 1, h\u27e9 + go \u27e8i, by omega\u27e9\n    go \u27e8n, by omega\u27e9", "vc-helpers": "", "vc-definitions": "def fft {n : Nat} (a : Vector Complex n) : Id (Vector Complex n) :=\n  sorry", "vc-theorems": "theorem fft_spec {n : Nat} (a : Vector Complex n) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    fft a\n    \u2983\u21d3result => \u231c\u2200 k : Fin n,\n        result.get k = complexSum (fun j =>\n            a.get j * cexp (-2 * (3.14159265358979323846 : Float) * (k.val.toFloat * j.val.toFloat) / n.toFloat)) \u2227\n        -- Sanity check: output vector has same length as input\n        result.size = n \u2227\n        -- FFT preserves the DC component (k=0) correctly\n        (n > 0 \u2192 result.get \u27e80, h\u27e9 = complexSum (fun j => a.get j)) \u2227\n        -- FFT satisfies the fundamental DFT property for each frequency component\n        (\u2200 k : Fin n, \u2203 (sum : Complex), \n            sum = complexSum (fun j => a.get j * cexp (-2 * (3.14159265358979323846 : Float) * (k.val.toFloat * j.val.toFloat) / n.toFloat)) \u2227\n            result.get k = sum)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_fftfreq", "vc-description": "/-  numpy.fft.fftfreq: Return the Discrete Fourier Transform sample frequencies.\n\n    The function returns the discrete Fourier Transform sample frequencies\n    with frequency bin centers in cycles per unit of sample spacing.\n\n    For even n: frequencies are [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)\n    For odd n: frequencies are [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)\n\n    The frequencies are arranged in standard DFT order: positive frequencies\n    first, then negative frequencies.\n-/\n\n/-  Specification: fftfreq returns sample frequencies according to the DFT convention.\n\n    The frequencies are arranged so that:\n    - The first half contains non-negative frequencies [0, 1, ..., N-1] / (d*n)\n    - The second half contains negative frequencies for the remaining indices\n\n    where N = (n + 1) / 2 is the number of non-negative frequencies.\n\n    Preconditions:\n    - n > 0 (non-empty frequency array)\n    - d \u2260 0 (valid sample spacing)\n\n    Postconditions:\n    - For indices i < N: result[i] = i / (d*n)\n    - For indices i \u2265 N: result[i] = (i - n) / (d*n)\n    - The DC component (index 0) is always 0\n    - The frequencies are symmetric around the Nyquist frequency\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fftfreq {n : Nat} (d : Float := 1.0) (h : n > 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fftfreq_spec {n : Nat} (d : Float) (h_n : n > 0) (h_d : d \u2260 0) :\n    \u2983\u231cn > 0 \u2227 d \u2260 0\u231d\u2984\n    fftfreq d h_n\n    \u2983\u21d3result => \u231clet N := (n + 1) / 2;\n                  (\u2200 i : Fin n, i.val < N \u2192 \n                    result.get i = Float.ofNat i.val / (Float.ofNat n * d)) \u2227\n                  (\u2200 i : Fin n, i.val \u2265 N \u2192 \n                    result.get i = Float.ofInt (Int.ofNat i.val - Int.ofNat n) / (Float.ofNat n * d)) \u2227\n                  (result.get \u27e80, by omega\u27e9 = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_fftshift", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.fftshift\",\n  \"description\": \"Shift the zero-frequency component to the center of the spectrum\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.fftshift.html\",\n  \"doc\": \"numpy.fft.fftshift(x, axes=None)\\n\\nShift the zero-frequency component to the center of the spectrum.\\n\\nParameters:\\n- x: Input array\\n- axes: Optional int or shape tuple specifying axes over which to shift (default is None, which shifts all axes)\\n\\nReturns:\\n- y: ndarray, the shifted array\\n\\nKey Details:\\n- Swaps half-spaces for specified axes\\n- y[0] is the Nyquist component only if len(x) is even\\n\\nExamples:\\nimport numpy as np\\nfreqs = np.fft.fftfreq(10, 0.1)\\n# freqs: [ 0.,  1.,  2., ..., -3., -2., -1.]\\nnp.fft.fftshift(freqs)\\n# Result: [-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.]\\n\\n# Shift along specific axis\\nfreqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\\nnp.fft.fftshift(freqs, axes=(1,))\\n\\nSee also: numpy.fft.ifftshift (inverse of fftshift)\",\n}\n-/\n\n/-  Shift the zero-frequency component to the center of the spectrum.\n\n    This function rearranges the FFT output such that the zero-frequency \n    component is moved from the beginning to the center of the array.\n    For even-length arrays, it performs a circular shift by n/2.\n    For odd-length arrays, it performs a circular shift by (n-1)/2.\n-/\n\n/-  Specification: fftshift performs a circular shift that moves the zero-frequency \n    component to the center of the array.\n\n    The function rearranges elements by performing a circular shift:\n    - Each element at position i in the result comes from position (i + n - n/2) % n in the input\n    - This is equivalent to swapping the first and second halves of the array\n    - The zero-frequency component (originally at index 0) moves to the center\n\n    Key mathematical properties:\n    1. Bijective mapping: every element is preserved and appears exactly once\n    2. Circular shift property: implements a specific permutation\n    3. Involution property: for even n, fftshift(fftshift(x)) = x\n    4. Sum preservation: the sum of all elements remains unchanged\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fftshift {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fftshift_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    fftshift x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x.get \u27e8(i.val + n - n / 2) % n, sorry\u27e9 \u2227\n                  (\u2200 j : Fin n, \u2203 k : Fin n, result.get k = x.get j) \u2227\n                  (\u2200 val : Float, (\u2203 j : Fin n, x.get j = val) \u2194 (\u2203 k : Fin n, result.get k = val))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_hfft", "vc-description": "/-  numpy.fft.hfft: Compute the FFT of a signal that has Hermitian symmetry.\n\n    The Hermitian FFT assumes that the input signal has Hermitian symmetry,\n    which means that the signal in the frequency domain is real-valued.\n    This is the inverse operation of rfft.\n\n    For a signal with Hermitian symmetry, the output will be real-valued\n    and the length of the transform is determined by the input length.\n    If input has length m, the output has length 2*(m-1).\n\n    The function essentially computes the inverse of rfft by taking\n    the conjugate of the input and then computing the inverse real FFT.\n-/\n\n/-  Specification: numpy.fft.hfft computes the FFT of a signal with Hermitian symmetry.\n\n    Precondition: The input vector represents a Hermitian symmetric signal\n    Postcondition: The output is a real-valued vector of length 2*m where\n    the input had length m+1, and the transformation preserves certain mathematical \n    properties of the Hermitian FFT including:\n    1. The output is real-valued (no imaginary parts)\n    2. The length relationship: if input has m+1 elements, output has 2*m elements\n    3. Hermitian symmetry properties are preserved in the transform\n    4. The conjugate relationship: this is effectively the inverse of an rfft operation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a complex number with float components -/\nstructure Complex where\n  /-- The real part of the complex number -/\n  real : Float\n  /-- The imaginary part of the complex number -/\n  imag : Float", "vc-helpers": "", "vc-definitions": "def hfft {m : Nat} (a : Vector Complex (m + 1)) : Id (Vector Float (2 * m)) :=\n  sorry", "vc-theorems": "theorem hfft_spec {m : Nat} (a : Vector Complex (m + 1)) (h : m > 0) :\n    \u2983\u231cm > 0\u231d\u2984\n    hfft a\n    \u2983\u21d3result => \u231c(result.toList.length = 2 * m) \u2227 \n                 (\u2200 i : Fin (2 * m), \u2203 real_val : Float, result.get i = real_val) \u2227\n                 (\u2200 i : Fin (m + 1), \u2203 j : Fin (2 * m), \u2203 k : Fin (2 * m),\n                   (a.get i).real * (a.get i).real + (a.get i).imag * (a.get i).imag \u2265 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_ifft", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.ifft\",\n  \"description\": \"Compute the one-dimensional inverse discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.ifft.html\",\n  \"doc\": \"numpy.fft.ifft(a, n=None, axis=-1, norm=None, out=None)\\n\\nCompute the one-dimensional inverse discrete Fourier Transform. It calculates the inverse of the one-dimensional n-point discrete Fourier transform, such that ifft(fft(a)) == a within numerical accuracy.\\n\\nParameters:\\n- a: Input array (can be complex)\\n- n: Optional length of transformed axis (default: input length)\\n- axis: Axis to compute inverse DFT (default: last axis)\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray: Transformed input, truncated or zero-padded\\n\\nNotes:\\n- Input should be ordered like FFT output\\n- Padding zeros at the end is common but can produce surprising results\\n- Zero frequency term is at a[0]\\n\\nExample:\\nimport numpy as np\\nnp.fft.ifft([0, 4, 0, 0])\\n# Returns: array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j])\",\n}\n-/\n\n/-  Compute the one-dimensional inverse discrete Fourier Transform (IFFT).\n\n    The IFFT transforms frequency domain data back to the time domain,\n    computing the inverse of the DFT such that ifft(fft(x)) \u2248 x.\n\n    For a vector of length n, the k-th coefficient is computed as:\n    X[k] = (1/n) * \u03a3(j=0 to n-1) a[j] * exp(2\u03c0i*j*k/n) -/\n\n/-  Specification: The inverse FFT correctly computes the inverse discrete Fourier transform.\n\n    The IFFT satisfies the inverse DFT equation where each output element k is \n    computed as (1/n) times the sum over all input elements j, multiplied by the \n    complex exponential exp(2\u03c0i*k*j/n).\n\n    This is the mathematical inverse of the FFT operation, with a positive sign \n    in the exponential and a normalization factor of 1/n. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\nset_option linter.missingDocs false\n\n/-- Complex number type for IFFT operations -/\nstructure Complex where\n  re : Float\n  im : Float\n  deriving Repr\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex scalar multiplication -/\ninstance : HMul Float Complex Complex where\n  hMul s z := { re := s * z.re, im := s * z.im }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex exponential function e^(i\u03b8) -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Sum of complex numbers over finite indices -/\ndef complexSum {n : Nat} (f : Fin n \u2192 Complex) : Complex :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let rec go : Fin (n + 1) \u2192 Complex\n      | \u27e80, _\u27e9 => f \u27e80, by omega\u27e9\n      | \u27e8i + 1, h\u27e9 => f \u27e8i + 1, h\u27e9 + go \u27e8i, by omega\u27e9\n    go \u27e8n, by omega\u27e9\n/-- Complex number vector type -/\nabbrev ComplexVector (n : Nat) := Vector Complex n", "vc-helpers": "", "vc-definitions": "def ifft {n : Nat} (a : ComplexVector n) : Id (ComplexVector n) :=\n  sorry", "vc-theorems": "theorem ifft_spec {n : Nat} (a : ComplexVector n) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    ifft a\n    \u2983\u21d3result => \u231c\u2200 k : Fin n,\n        result.get k = (1.0 / n.toFloat) * complexSum (fun j =>\n            a.get j * cexp (2 * (3.14159265358979323846 : Float) * (k.val.toFloat * j.val.toFloat) / n.toFloat))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_ifftn", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.ifftn\",\n  \"description\": \"Compute the N-dimensional inverse discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.ifftn.html\",\n  \"doc\": \"numpy.fft.ifftn(a, s=None, axes=None, norm=None, out=None)\\n\\nCompute the N-dimensional inverse discrete Fourier Transform using the Fast Fourier Transform (FFT). It is the inverse of the N-dimensional FFT, such that ifftn(fftn(a)) == a within numerical accuracy.\\n\\nParameters:\\n- a: Input array (can be complex)\\n- s: Optional sequence of integers specifying output shape\\n- axes: Optional sequence of axes to transform\\n- norm: Optional normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray transformed along specified axes, potentially truncated or zero-padded\\n\\nExample:\\nimport numpy as np\\na = np.eye(4)\\nnp.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\",\n}\n-/\n\n/-  Compute the N-dimensional inverse discrete Fourier Transform (IFFTN).\n\n     The IFFTN extends the 1D inverse FFT to multiple dimensions, computing\n     the inverse of the N-dimensional DFT. For a 2D array, this applies the\n     inverse transform along both dimensions.\n\n     For a 2D array of size m\u00d7n, the (i,j)-th output element is computed as:\n     X[i,j] = (1/(m*n)) * \u03a3(k=0 to m-1) \u03a3(l=0 to n-1) a[k,l] * exp(2\u03c0i*(i*k/m + j*l/n))\n\n     This is the mathematical inverse of the N-dimensional FFT. -/\n\n/-  Specification: The N-dimensional inverse FFT correctly computes the inverse discrete Fourier transform.\n\n     The IFFTN satisfies the inverse N-dimensional DFT equation where each output element (i,j)\n     is computed as (1/(m*n)) times the double sum over all input elements (k,l), multiplied by\n     the complex exponential exp(2\u03c0i*(i*k/m + j*l/n)).\n\n     This is the mathematical inverse of the N-dimensional FFT operation, with positive signs\n     in the exponential and a normalization factor of 1/(m*n) for 2D case.\n\n     Key properties:\n     1. Inverse relationship: ifftn(fftn(x)) \u2248 x within numerical accuracy\n     2. Linearity: ifftn(a*x + b*y) = a*ifftn(x) + b*ifftn(y) \n     3. Parseval's theorem: energy is preserved with proper normalization\n     4. Separability: N-D transform can be computed as sequence of 1-D transforms -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\nset_option linter.missingDocs false\n\n/-- Complex number type for IFFTN operations -/\nstructure Complex where\n  re : Float\n  im : Float\n  deriving Repr\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex scalar multiplication -/\ninstance : HMul Float Complex Complex where\n  hMul s z := { re := s * z.re, im := s * z.im }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex exponential function e^(i\u03b8) -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Sum of complex numbers over finite indices -/\ndef complexSum {n : Nat} (f : Fin n \u2192 Complex) : Complex :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let rec go : Fin (n + 1) \u2192 Complex\n      | \u27e80, _\u27e9 => f \u27e80, by omega\u27e9\n      | \u27e8i + 1, h\u27e9 => f \u27e8i + 1, h\u27e9 + go \u27e8i, by omega\u27e9\n    go \u27e8n, by omega\u27e9\n/-- Complex number vector type -/\nabbrev ComplexVector (n : Nat) := Vector Complex n", "vc-helpers": "", "vc-definitions": "def ifftn {m n : Nat} (a : Vector (ComplexVector n) m) : Id (Vector (ComplexVector n) m) :=\n  sorry", "vc-theorems": "theorem ifftn_spec {m n : Nat} (a : Vector (ComplexVector n) m) (hm : m > 0) (hn : n > 0) :\n    \u2983\u231cm > 0 \u2227 n > 0\u231d\u2984\n    ifftn a\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, \u2200 j : Fin n,\n        (result.get i).get j = (1.0 / (m.toFloat * n.toFloat)) * \n        complexSum (fun k => complexSum (fun l =>\n            (a.get k).get l * cexp (2 * (3.14159265358979323846 : Float) * \n                (i.val.toFloat * k.val.toFloat / m.toFloat + j.val.toFloat * l.val.toFloat / n.toFloat))))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_ifftshift", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.ifftshift\",\n  \"description\": \"The inverse of fftshift\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.ifftshift.html\",\n  \"doc\": \"numpy.fft.ifftshift(x, axes=None)\\n\\nThe inverse of fftshift. Although identical for even-length x, the functions differ by one sample for odd-length x.\\n\\nParameters:\\n- x (array_like): Input array\\n- axes (int or shape tuple, optional): Axes over which to calculate. Defaults to None, which shifts all axes.\\n\\nReturns:\\n- y (ndarray): The shifted array\\n\\nExample:\\nimport numpy as np\\nfreqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\\nfreqs\\n# Output: array([[ 0.,  1.,  2.],\\n#                [ 3.,  4., -4.],\\n#                [-3., -2., -1.]])\\nnp.fft.ifftshift(np.fft.fftshift(freqs))\\n# Output: same as original freqs array\\n\\nSee also: numpy.fft.fftshift\",\n}\n-/\n\n/-  The inverse of fftshift - undoes the frequency domain shifting.\n\n    This function performs the inverse operation of fftshift, moving the \n    zero-frequency component from the center back to the beginning of the array.\n    For even-length arrays, it is identical to fftshift.\n    For odd-length arrays, it differs by one sample position.\n\n    The function performs a circular shift by -(n/2) positions.\n-/\n\n/-  Specification: ifftshift performs the inverse of fftshift.\n\n    The function performs a circular shift that undoes the centering of \n    the zero-frequency component:\n    - For even n: shifts by -(n/2), identical to fftshift\n    - For odd n: shifts by -(n/2), which differs from fftshift by one sample\n\n    This ensures that:\n    - Elements from the center move back to the beginning\n    - The DC component at the center returns to index 0\n    - The function is the left inverse of fftshift\n\n    Mathematical properties:\n    - For even-length arrays: ifftshift(fftshift(x)) = x and fftshift(ifftshift(x)) = x\n    - For odd-length arrays: ifftshift(fftshift(x)) = x but fftshift(ifftshift(x)) \u2260 x\n    - Preserves the total energy/sum of the array\n    - Is a bijection (permutation) of array elements\n\n    The specification states that each element at position i in the result\n    comes from position (i + n/2) % n in the input, which is equivalent\n    to a circular left shift by n/2 positions (or right shift by n - n/2).\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ifftshift {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ifftshift_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    ifftshift x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x.get \u27e8(i.val + n / 2) % n, sorry\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_ihfft", "vc-description": "/-  numpy.fft.ihfft: Compute the inverse FFT of a signal that has Hermitian symmetry.\n\n    This function computes the inverse FFT of a signal that has Hermitian symmetry,\n    which means the signal is real in the frequency domain. The input should be\n    a complex signal with Hermitian symmetry, and the output is a real signal.\n\n    The function is analogous to rfft/irfft but for signals with Hermitian symmetry.\n    According to the NumPy documentation and source code, it essentially computes \n    the conjugate of the rfft of the input: conjugate(rfft(a, n, axis, new_norm, out))\n\n    Unlike hfft which takes a Hermitian symmetric input and produces a real output,\n    ihfft takes a general complex input and produces a complex output with the \n    inverse Hermitian FFT properties.\n-/\n\n/-  Specification: ihfft computes the inverse FFT of a signal with Hermitian symmetry.\n\n    According to NumPy documentation:\n    - ihfft is analogous to rfft/irfft but for signals with Hermitian symmetry\n    - The implementation is conjugate(rfft(a, n, axis, new_norm, out))\n\n    Key mathematical properties:\n    1. Length preservation: output has same length as input\n    2. Conjugate relationship: ihfft is related to rfft by conjugation\n    3. Linearity: ihfft preserves linear combinations\n    4. Hermitian symmetry handling: if input has Hermitian symmetry, special properties hold\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT operations -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex conjugate -/\ndef Complex.conj (z : Complex) : Complex :=\n  { re := z.re, im := -z.im }\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }", "vc-helpers": "", "vc-definitions": "def ihfft {n : Nat} (a : Vector Complex n) : Id (Vector Complex n) :=\n  sorry", "vc-theorems": "theorem ihfft_spec {n : Nat} (a : Vector Complex n) :\n    \u2983\u231cTrue\u231d\u2984\n    ihfft a\n    \u2983\u21d3result => \u231c-- Length preservation: output has same length as input\n                 result.toList.length = a.toList.length \u2227\n                 -- Linearity property: ihfft preserves linear combinations\n                 (\u2200 b : Vector Complex n, \n                  \u2200 \u03b1 \u03b2 : Float,\n                  let scaled_a := Vector.map (fun z => \u27e8\u03b1 * z.re, \u03b1 * z.im\u27e9) a\n                  let scaled_b := Vector.map (fun z => \u27e8\u03b2 * z.re, \u03b2 * z.im\u27e9) b\n                  let sum_ab := Vector.zipWith (\u00b7 + \u00b7) scaled_a scaled_b\n                  ihfft sum_ab = Vector.zipWith (\u00b7 + \u00b7) (ihfft scaled_a) (ihfft scaled_b)) \u2227\n                 -- Hermitian symmetry property: if input has Hermitian symmetry,\n                 -- then ihfft should produce a real-valued result\n                 (\u2200 i j : Fin n, i.val + j.val + 1 = n \u2192 a.get i = Complex.conj (a.get j)) \u2192\n                 (\u2200 i : Fin n, (result.get i).im = 0) \u2227\n                 -- Conjugate relationship: captures the NumPy implementation detail\n                 -- that ihfft(a) is conceptually related to conj(rfft(a))\n                 (\u2200 real_signal : Vector Float n,\n                  \u2203 rfft_result : Vector Complex n,\n                  result = Vector.map Complex.conj rfft_result)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_irfft", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.irfft\",\n  \"description\": \"Computes the inverse of rfft\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.irfft.html\",\n  \"doc\": \"numpy.fft.irfft(a, n=None, axis=-1, norm=None, out=None)\\n\\nComputes the inverse of rfft. It performs the inverse of the one-dimensional discrete Fourier Transform for real input, such that irfft(rfft(a), len(a)) == a within numerical accuracy.\\n\\nParameters:\\n- a: Input array\\n- n: Optional length of transformed axis (default calculates based on input)\\n- axis: Axis to compute inverse FFT (default is last axis)\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Real-valued ndarray transformed along specified axis\\n\\nNotes:\\n- Handles Hermitian-symmetric input from rfft\\n- Requires specifying original data length to avoid information loss\\n- Can resample a series via Fourier interpolation\\n\\nExample:\\nnp.fft.irfft([1, -1j, -1])\\n# Returns: array([0., 1., 0., 0.])\",\n}\n-/\n\n/-  Computes the inverse of rfft (real-valued inverse FFT) -/\n\n/-  Specification: irfft computes the inverse of rfft with proper length restoration -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT operations -/\nstructure Complex where\n  /-- Real part of the complex number -/\n  re : Float\n  /-- Imaginary part of the complex number -/\n  im : Float\n\n/-- Helper function to check if a vector is Hermitian-symmetric -/\ndef isHermitianSymmetric {n : Nat} (a : Vector Complex n) : Prop :=\n  \u2200 i : Fin n, \u2200 j : Fin n, (i.val + j.val = n - 1) \u2192 \n    (a.get i).re = (a.get j).re \u2227 (a.get i).im = -(a.get j).im", "vc-helpers": "", "vc-definitions": "def irfft {k : Nat} (a : Vector Complex k) (n : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem irfft_spec {k : Nat} (a : Vector Complex k) (n : Nat) \n    (h_length : n = 2 * (k - 1)) \n    (h_hermitian : isHermitianSymmetric a) \n    (h_nonempty : k > 0) :\n    \u2983\u231cn = 2 * (k - 1) \u2227 isHermitianSymmetric a \u2227 k > 0\u231d\u2984\n    irfft a n\n    \u2983\u21d3result => \u231c\n      -- Length preservation: output length matches specified n\n      (result.toList.length = n) \u2227\n      -- DC component preservation: first element is real when input DC is real\n      ((a.get \u27e80, h_nonempty\u27e9).im = 0 \u2192 \n        \u2203 i : Fin n, result.get i = (a.get \u27e80, h_nonempty\u27e9).re) \u2227\n      -- Symmetry property: result has the symmetry properties of real-valued inverse FFT\n      (\u2200 i : Fin n, \u2200 j : Fin n, (i.val + j.val = n) \u2192 \n        result.get i = result.get j) \u2227\n      -- Hermitian input constraint: the input must be Hermitian-symmetric\n      (isHermitianSymmetric a) \u2227\n      -- Length relationship: output length is twice the input length minus 2\n      (n = 2 * (k - 1))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_irfft2", "vc-description": "/-  numpy.fft.irfft2: Computes the inverse of rfft2.\n\n    Performs the inverse 2-dimensional discrete Fourier Transform for real input.\n    This function converts a complex frequency domain representation back to the\n    real spatial domain. It is the inverse of rfft2.\n\n    The function takes a complex-valued 2D array (represented as nested vectors)\n    and returns a real-valued 2D array. The output shape is determined by the\n    input shape and the original real signal dimensions.\n\n    This is essentially irfftn with axes=(-2, -1) as defaults.\n-/\n\n/-  Specification: numpy.fft.irfft2 returns the inverse 2D real FFT.\n\n    Precondition: True (input is a well-formed 2D array)\n    Postcondition: The result is a real-valued 2D array with the same dimensions.\n\n    Key properties:\n    1. The output preserves the matrix structure and dimensions\n    2. The transformation processes all elements of the input\n    3. The inverse operation produces finite real values\n    4. Shape preservation ensures correct 2D FFT behavior\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_irfft2 {rows cols : Nat} (a : Vector (Vector Float cols) rows) : Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem numpy_irfft2_spec {rows cols : Nat} (a : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_irfft2 a\n    \u2983\u21d3result => \u231c-- Preserve matrix dimensions\n      (\u2200 i : Fin rows, (result.get i).size = cols) \u2227\n      -- Output is well-formed  \n      result.size = rows \u2227\n      -- All elements are processed and produce finite values\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, \n        ((result.get i).get j).isFinite) \u2227\n      -- Non-trivial transformation: if input is non-zero, result depends on input\n      (\u2200 i : Fin rows, \u2200 j : Fin cols,\n        (a.get i).get j \u2260 0 \u2192 \n        \u2203 (k : Fin rows) (l : Fin cols), (result.get k).get l \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_irfftn", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.irfftn\",\n  \"description\": \"Computes the inverse of rfftn\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.irfftn.html\",\n  \"doc\": \"numpy.fft.irfftn(a, s=None, axes=None, norm=None, out=None)\\n\\nComputes the inverse of rfftn. This function performs the inverse N-dimensional discrete Fourier Transform for real input using the Fast Fourier Transform (FFT).\\n\\nParameters:\\n- a: Input array\\n- s: Optional sequence of ints specifying output shape\\n- axes: Optional sequence of ints specifying axes to transform\\n- norm: Optional normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- An ndarray transformed along specified axes, with length determined by s or input shape\\n\\nNotes:\\n- Inverse transform assumes an even output length by default\\n- Correct input shape is crucial to avoid losing information\\n- Ensures that irfftn(rfftn(a), a.shape) == a within numerical accuracy\\n\\nExample:\\nimport numpy as np\\na = np.zeros((3, 2, 2))\\na[0, 0, 0] = 3 * 2 * 2\\nnp.fft.irfftn(a)\",\n}\n-/\n\n/-  For simplicity, we model this as a 1D version of irfftn, taking complex frequency domain input\n    and producing real time-domain output. The function computes the inverse of rfftn,\n    transforming N-dimensional frequency domain data back to real-valued time domain.\n\n    This is the inverse operation to rfftn, where the input is expected to be\n    Hermitian-symmetric complex data representing the frequency domain, and the output\n    is real-valued time domain data.\n-/\n\n/-  Specification: irfftn computes the inverse N-dimensional discrete Fourier Transform for real output.\n\n    The irfftn function is the inverse of rfftn, satisfying the property that\n    irfftn(rfftn(x), x.shape) \u2248 x within numerical accuracy.\n\n    Mathematical properties:\n    1. Inverse relationship: irfftn(rfftn(x)) \u2248 x for real input x\n    2. The input should be Hermitian-symmetric to produce real output\n    3. Output length is determined by the shape parameter or derived from input\n    4. Energy conservation (Parseval's theorem) holds with proper normalization\n    5. The transform preserves the mathematical structure of the inverse DFT\n\n    The function implements the inverse N-dimensional DFT formula:\n    x[j] = (1/N) * \u03a3(k) a[k] * exp(2\u03c0i*k*j/N)\n\n    Sanity checks:\n    - For DC-only input (single non-zero frequency), output is constant\n    - Transform is linear: irfftn(\u03b1*a + \u03b2*b) = \u03b1*irfftn(a) + \u03b2*irfftn(b)\n    - Output is real-valued when input satisfies Hermitian symmetry\n    - Proper length relationship between input and output dimensions\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT operations -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n  deriving Repr\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex scalar multiplication -/\ninstance : HMul Float Complex Complex where\n  hMul s z := { re := s * z.re, im := s * z.im }\n\n/-- Complex exponential function e^(i\u03b8) -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }\n/-- Sum of complex numbers over finite indices -/\ndef complexSum {n : Nat} (f : Fin n \u2192 Complex) : Complex :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let rec go : Fin (n + 1) \u2192 Complex\n      | \u27e80, _\u27e9 => f \u27e80, by omega\u27e9\n      | \u27e8i + 1, h\u27e9 => f \u27e8i + 1, h\u27e9 + go \u27e8i, by omega\u27e9\n    go \u27e8n, by omega\u27e9", "vc-helpers": "", "vc-definitions": "def irfftn {k : Nat} (a : Vector Complex k) (n : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem irfftn_spec {k : Nat} (a : Vector Complex k) (n : Nat) \n    (h_nonempty : k > 0) \n    (h_length : n > 0) \n    (h_hermitian : \u2200 i : Fin k, (a.get \u27e80, h_nonempty\u27e9).im = 0) :\n    \u2983\u231ck > 0 \u2227 n > 0 \u2227 (a.get \u27e80, h_nonempty\u27e9).im = 0\u231d\u2984\n    irfftn a n\n    \u2983\u21d3result => \u231c\n      -- Output is real-valued (implicit in Vector Float type)\n      -- Length matches specified output size\n      result.size = n \u2227\n      -- Inverse relationship: the fundamental mathematical property\n      (\u2200 j : Fin n, \u2203 sum : Complex, \n        sum = (1.0 / n.toFloat) * complexSum (fun i : Fin k => \n          a.get i * cexp (2 * (3.14159265358979323846 : Float) * (i.val.toFloat * j.val.toFloat) / n.toFloat)) \u2227\n        result.get j = sum.re) \u2227\n      -- Linearity property: irfftn preserves linear combinations\n      (\u2200 \u03b1 \u03b2 : Float, \u2200 b : Vector Complex k,\n        (b.get \u27e80, h_nonempty\u27e9).im = 0 \u2192\n        \u2203 r_a r_b : Vector Float n,\n        (irfftn a n = pure r_a \u2227 irfftn b n = pure r_b) \u2192\n        \u2203 r_combined : Vector Float n,\n        irfftn (Vector.map (fun z => \u27e8\u03b1 * z.re, \u03b1 * z.im\u27e9) a) n = pure r_combined) \u2227\n      -- DC component preservation: if input has only DC component, output is constant\n      ((\u2200 i : Fin k, i.val > 0 \u2192 a.get i = 0) \u2192 \n        \u2200 j : Fin n, result.get j = (a.get \u27e80, h_nonempty\u27e9).re / n.toFloat) \u2227\n      -- Energy conservation (Parseval's theorem): \n      -- The total energy in time domain relates to frequency domain energy\n      (\u2203 energy_time energy_freq : Float,\n        energy_time = (List.range n).foldl (fun acc i => \n          if h_i : i < n then acc + (result.get \u27e8i, h_i\u27e9) ^ 2 else acc) 0 \u2227\n        energy_freq = (List.range k).foldl (fun acc i => \n          if h_i : i < k then acc + ((a.get \u27e8i, h_i\u27e9).re ^ 2 + (a.get \u27e8i, h_i\u27e9).im ^ 2) else acc) 0 \u2227\n        energy_time = (1.0 / n.toFloat) * energy_freq)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_rfft", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.rfft\",\n  \"description\": \"Compute the one-dimensional discrete Fourier Transform for real input\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.rfft.html\",\n  \"doc\": \"numpy.fft.rfft(a, n=None, axis=-1, norm=None, out=None)\\n\\nCompute the one-dimensional discrete Fourier Transform for real input using an efficient Fast Fourier Transform (FFT) algorithm.\\n\\nParameters:\\n- a: Input array\\n- n: Optional number of points along transformation axis (default: input length)\\n- axis: Axis to compute FFT (default: last axis)\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- A complex ndarray representing the transformed input. The length of the transformed axis is (n/2)+1 for even n, or (n+1)/2 for odd n.\\n\\nNotes:\\n- Computes only non-negative frequency terms for real input\\n- Exploits Hermitian symmetry of real input's Fourier transform\\n- Silently discards any imaginary part of input\\n\\nExample:\\nimport numpy as np\\nnp.fft.rfft([0, 1, 0, 0])\\n# Returns: array([ 1.+0.j,  0.-1.j, -1.+0.j])\",\n}\n-/\n\n/-  Compute the one-dimensional discrete Fourier Transform for real input.\n    Returns only the non-negative frequency terms, exploiting Hermitian symmetry.\n    The output length is (n/2)+1 for even n, or (n+1)/2 for odd n. -/\n\n/-  Specification for rfft: \n    The real FFT computes the DFT of real-valued input, returning only non-negative frequency components.\n\n    Mathematical properties:\n    1. Output contains (n/2)+1 complex values representing frequencies 0 to n/2\n    2. DC component (k=0) is always real (imaginary part is 0)\n    3. For even n, Nyquist frequency (k=n/2) is also real\n    4. The result represents the Discrete Fourier Transform for k = 0, 1, ..., n/2\n    5. Each output[k] = \u03a3(j=0 to n-1) input[j] * exp(-2\u03c0i*k*j/n)\n\n    Sanity checks:\n    - For constant input signals, only the DC component is non-zero\n    - The transform is linear: rfft(a + b) = rfft(a) + rfft(b)\n    - Energy is preserved according to Parseval's theorem -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT results -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n\n/-- Complex exponential function -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }\n/-- Sum of complex numbers over finite indices -/\ndef complexSum {n : Nat} (f : Fin n \u2192 Complex) : Complex :=\n  match n with\n  | 0 => 0\n  | n + 1 =>\n    let rec go : Fin (n + 1) \u2192 Complex\n      | \u27e80, _\u27e9 => f \u27e80, by omega\u27e9\n      | \u27e8i + 1, h\u27e9 => f \u27e8i + 1, h\u27e9 + go \u27e8i, by omega\u27e9\n    go \u27e8n, by omega\u27e9", "vc-helpers": "", "vc-definitions": "def rfft {n : Nat} (a : Vector Float n) : Id (Vector Complex ((n / 2) + 1)) :=\n  sorry", "vc-theorems": "theorem rfft_spec {n : Nat} (a : Vector Float n) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    rfft a\n    \u2983\u21d3result => \u231c\u2200 k : Fin ((n / 2) + 1), \n      result.get k = complexSum (fun j : Fin n =>\n        (a.get j).toComplex * cexp (-2 * (3.14159265358979323846 : Float) * (k.val.toFloat * j.val.toFloat) / n.toFloat)) \u2227\n      -- DC component is real\n      (if h0 : 0 < (n / 2) + 1 then (result.get \u27e80, h0\u27e9).im = 0 else True) \u2227\n      -- For even n, Nyquist frequency is real\n      (n % 2 = 0 \u2192 (if hn : n / 2 < (n / 2) + 1 then (result.get \u27e8n / 2, hn\u27e9).im = 0 else True))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_rfft2", "vc-description": "/- \n{\n  \"name\": \"numpy.fft.rfft2\",\n  \"description\": \"Compute the 2-dimensional FFT of a real array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.rfft2.html\",\n  \"doc\": \"numpy.fft.rfft2(a, s=None, axes=(-2, -1), norm=None, out=None)\\n\\nCompute the 2-dimensional FFT of a real array.\\n\\nParameters:\\n- a: Input array, taken to be real\\n- s: Optional shape of the FFT (sequence of ints)\\n- axes: Axes over which to compute the FFT (default: (-2, -1))\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array for the result\\n\\nReturns:\\n- Complex ndarray representing the result of the real 2-D FFT\\n\\nNotes:\\n- This is essentially rfftn with different default behavior\\n- Introduced for computing Fourier transforms on real-valued 2D arrays\\n\\nExample:\\nimport numpy as np\\na = np.mgrid[:5, :5][0]\\nnp.fft.rfft2(a)\",\n}\n-/\n\n/-  Compute the 2-dimensional FFT of a real array.\n\n    This function transforms a real 2D array into the frequency domain using\n    a 2D Fast Fourier Transform. The transformation is performed over the\n    last two axes by default.\n\n    The key difference from fft2 is that this function starts with real input\n    and exploits the Hermitian symmetry property to compute only the \n    non-negative frequency components along the last axis, making it more\n    efficient for real-valued input data.\n\n    Output dimensions: For input of shape (m+1, n+1), output has shape (m+1, (n+1)/2+1)\n    where the last dimension is reduced due to Hermitian symmetry. -/\n\n/-  Specification for rfft2: 2D FFT of real input array\n\n    Mathematical properties:\n    1. Two-stage transformation: first axis uses complex FFT, second axis uses real FFT\n    2. Output shape is (m+1, (n+1)/2+1) for input shape (m+1, n+1)\n    3. Hermitian symmetry: Due to real input, negative frequencies are redundant\n    4. DC component preservation: The (0,0) element is always real\n    5. Energy conservation: Follows Parseval's theorem with proper normalization\n\n    The transformation can be mathematically expressed as:\n    result[k,l] = \u03a3_{p=0}^{m} \u03a3_{q=0}^{n} input[p,q] * exp(-2\u03c0i(kp/(m+1) + lq/(n+1)))\n    for k \u2208 [0, m] and l \u2208 [0, (n+1)/2] (exploiting Hermitian symmetry)\n\n    Sanity checks:\n    - For zero input, output is all zeros\n    - For constant input, only DC component (0,0) is non-zero\n    - Transform preserves linearity: rfft2(a + b) = rfft2(a) + rfft2(b)\n    - Last axis has reduced size due to real input optimization -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Complex number type for FFT results -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n\n/-- Complex zero -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex exponential function e^(i\u03b8) -/\ndef cexp (\u03b8 : Float) : Complex :=\n  { re := Float.cos \u03b8, im := Float.sin \u03b8 }\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }", "vc-helpers": "", "vc-definitions": "def rfft2 {m n : Nat} (a : Vector (Vector Float (n + 1)) (m + 1)) : Id (Vector (Vector Complex (((n + 1) / 2) + 1)) (m + 1)) :=\n  sorry", "vc-theorems": "theorem rfft2_spec {m n : Nat} (a : Vector (Vector Float (n + 1)) (m + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    rfft2 a\n    \u2983\u21d3result => \u231c\u2200 k : Fin (m + 1), \u2200 l : Fin (((n + 1) / 2) + 1),\n      -- Each output element is computed via the 2D DFT formula\n      (result.get k).get l = \n        (Vector.foldl (fun acc_p p => \n          Vector.foldl (fun acc_q q => \n            let phase := -2 * (3.14159265358979323846 : Float) * \n                        (k.val.toFloat * p.val.toFloat / (m + 1).toFloat + \n                         l.val.toFloat * q.val.toFloat / (n + 1).toFloat)\n            let weight := cexp phase\n            let term := ((a.get p).get q).toComplex * weight\n            acc_q + term\n          ) acc_p (Vector.ofFn (fun q : Fin (n + 1) => q))\n        ) 0 (Vector.ofFn (fun p : Fin (m + 1) => p))) \u2227\n      -- DC component is real (imaginary part is zero)\n      ((result.get \u27e80, by omega\u27e9).get \u27e80, by omega\u27e9).im = 0 \u2227\n      -- Last axis is reduced size due to Hermitian symmetry\n      (result.get \u27e80, by omega\u27e9).size = ((n + 1) / 2) + 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "fft_rfftfreq", "vc-description": "/-  numpy.fft.rfftfreq: Return the Discrete Fourier Transform sample frequencies for rfft.\n\n    The function generates frequency bin centers in cycles per unit of sample spacing,\n    with zero at the start. This is specifically designed for use with rfft and irfft.\n\n    Parameters:\n    - n: Window length (input size)\n    - d: Sample spacing (defaults to 1.0)\n\n    Returns:\n    - f: Array of length n//2 + 1 containing sample frequencies\n\n    The frequency calculation follows:\n    - For any n: f = [0, 1, ..., n//2] / (d*n)\n    - The result length is always n//2 + 1 (for both even and odd n)\n-/\n\n/-  Specification: numpy.fft.rfftfreq generates frequency sample points for rfft.\n\n    The function returns a vector of frequencies from 0 to the Nyquist frequency.\n\n    Precondition: n > 0 and d > 0 (positive sample spacing)\n    Postcondition: \n    1. The result has length n//2 + 1\n    2. The first element is always 0\n    3. Each element i represents frequency i / (d * n)\n    4. The last element is (n//2) / (d * n) (Nyquist frequency)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_rfftfreq (n : Nat) (d : Float) (h : n > 0) : Id (Vector Float (n / 2 + 1)) :=\n  sorry", "vc-theorems": "theorem numpy_rfftfreq_spec (n : Nat) (d : Float) (h : n > 0) (hd : d > 0) :\n    \u2983\u231cn > 0 \u2227 d > 0\u231d\u2984\n    numpy_rfftfreq n d h\n    \u2983\u21d3result => \u231c\n      -- First element is always 0\n      result.get \u27e80, by simp\u27e9 = 0 \u2227\n      -- Each element follows the frequency formula\n      \u2200 i : Fin (n / 2 + 1), result.get i = Float.ofNat i.val / (d * Float.ofNat n) \u2227\n      -- Last element is the Nyquist frequency\n      result.get \u27e8n / 2, by simp\u27e9 = Float.ofNat (n / 2) / (d * Float.ofNat n) \u2227\n      -- Monotonicity: frequencies are non-decreasing\n      \u2200 i j : Fin (n / 2 + 1), i.val \u2264 j.val \u2192 result.get i \u2264 result.get j\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_argmax", "vc-description": "/- \n{\n  \"name\": \"numpy.argmax\",\n  \"category\": \"Index finding\",\n  \"description\": \"Returns the indices of the maximum values along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argmax.html\",\n  \"doc\": \"Returns the indices of the maximum values along an axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxis : int, optional\\n    By default, the index is into the flattened array, otherwise along the specified axis.\\nout : array, optional\\n    If provided, the result will be inserted into this array.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nindex_array : ndarray of ints\\n    Array of indices into the array. It has the same shape as ``a.shape`` with the dimension along `axis` removed.\\n\\nNotes\\n-----\\nIn case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.\",\n}\n-/\n\n/-  Returns the index of the maximum value in a non-empty vector (first occurrence) -/\n\n/-  Specification: argmax returns the index of the first maximum element\n    This comprehensive specification captures:\n    1. The returned index points to a maximum element\n    2. All elements to the left of the returned index are strictly less than the maximum\n    3. All elements to the right of the returned index are less than or equal to the maximum\n    4. The function returns the first occurrence of the maximum value\n    5. The returned index is valid (type-safe with Fin)\n    6. The result is deterministic for the same input\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argmax {n : Nat} (arr : Vector Float (n + 1)) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem argmax_spec {n : Nat} (arr : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    argmax arr\n    \u2983\u21d3idx => \u231c(\u2200 i : Fin (n + 1), arr.get i \u2264 arr.get idx) \u2227\n             (\u2200 i : Fin (n + 1), i < idx \u2192 arr.get i < arr.get idx) \u2227\n             (\u2200 i : Fin (n + 1), idx < i \u2192 arr.get i \u2264 arr.get idx) \u2227\n             (\u2200 j : Fin (n + 1), arr.get j = arr.get idx \u2192 idx \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_argmin", "vc-description": "/- \n{\n  \"name\": \"numpy.argmin\",\n  \"category\": \"Index finding\",\n  \"description\": \"Returns the indices of the minimum values along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argmin.html\",\n  \"doc\": \"Returns the indices of the minimum values along an axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxis : int, optional\\n    By default, the index is into the flattened array, otherwise along the specified axis.\\nout : array, optional\\n    If provided, the result will be inserted into this array.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nindex_array : ndarray of ints\\n    Array of indices into the array. It has the same shape as \\`\\`a.shape\\`\\` with the dimension along \\`axis\\` removed.\\n\\nNotes\\n-----\\nIn case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.\",\n}\n-/\n\n/-  numpy.argmin: Returns the index of the minimum value in a vector.\n\n    Returns the index of the minimum value among all elements in the array.\n    Requires a non-empty array since there is no minimum of an empty set.\n\n    This function returns the position of the smallest element in the array.\n    In case of multiple occurrences of the minimum value, the index of the\n    first occurrence is returned.\n-/\n\n/-  Specification: argmin returns the index of the minimum element.\n\n    Precondition: True (non-empty constraint is in the type)\n    Postcondition: The element at the returned index is the minimum value,\n    and it is the first occurrence of this minimum value in the array.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argmin {n : Nat} (a : Vector Float (n + 1)) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem argmin_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    argmin a\n    \u2983\u21d3i => \u231c(\u2200 j : Fin (n + 1), a.get i \u2264 a.get j) \u2227 \n           (\u2200 k : Fin (n + 1), k < i \u2192 a.get k > a.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_argwhere", "vc-description": "/- \n{\n  \"name\": \"numpy.argwhere\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Find the indices of array elements that are non-zero, grouped by element\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argwhere.html\",\n  \"doc\": \"Find the indices of array elements that are non-zero, grouped by element.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\n\\nReturns\\n-------\\nindex_array : (N, a.ndim) ndarray\\n    Indices of elements that are non-zero. Indices are grouped by element.\\n    This array will have shape \\`\\`(N, a.ndim)\\`\\` where \\`\\`N\\`\\` is the number of\\n    non-zero items.\\n\\nNotes\\n-----\\n\\`\\`np.argwhere(a)\\`\\` is almost the same as \\`\\`np.transpose(np.nonzero(a))\\`\\`, but produces the correct result for a 0D array.\\n\\nThe output of \\`\\`argwhere\\`\\` is not suitable for indexing arrays. For this purpose use \\`\\`nonzero(a)\\`\\` instead.\",\n}\n-/\n\n/-  numpy.argwhere: Find the indices of array elements that are non-zero, grouped by element.\n\n    For a 1D vector, returns a list of indices where elements are non-zero.\n    Each index corresponds to a position in the original vector where the element is non-zero.\n    The returned indices are in the same order as they appear in the original vector.\n\n    This function is equivalent to finding all positions i such that a[i] \u2260 0.\n    The result is a list of indices, not suitable for direct array indexing but useful\n    for analysis and conditional processing.\n-/\n\n/-  Specification: numpy.argwhere returns all indices of non-zero elements.\n\n    Precondition: True (no special requirements)\n    Postcondition: \n    1. All returned indices correspond to non-zero elements in the input vector\n    2. All non-zero elements in the input vector have their indices in the result (completeness)\n    3. The result contains no duplicate indices\n    4. The indices are ordered according to their position in the original vector\n    5. The result is empty if and only if all elements in the input are zero\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argwhere {n : Nat} (a : Vector Float n) : Id (List (Fin n)) :=\n  sorry", "vc-theorems": "theorem argwhere_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    argwhere a\n    \u2983\u21d3indices => \u231c\n      (\u2200 i \u2208 indices, a.get i \u2260 0) \u2227\n      (\u2200 i : Fin n, a.get i \u2260 0 \u2192 i \u2208 indices) \u2227\n      (indices.Nodup) \u2227\n      (\u2200 i j : Fin n, i \u2208 indices \u2192 j \u2208 indices \u2192 i < j \u2192 \n        indices.idxOf i < indices.idxOf j) \u2227\n      (indices = [] \u2194 \u2200 i : Fin n, a.get i = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_c_", "vc-description": "/- \n{\n  \"name\": \"numpy.c_\",\n  \"category\": \"Advanced indexing\",\n  \"description\": \"Translates slice objects to concatenation along the second axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.c_.html\",\n  \"doc\": \"Translates slice objects to concatenation along the second axis.\\n\\nThis is short-hand for \\`\\`np.r_['-1,2,0', index expression]\\`\\`, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1's post-pended to the shape (column vectors made out of 1-D arrays).\",\n}\n-/\n\n/-  numpy.c_: Translates slice objects to concatenation along the second axis.\n\n    This function takes two vectors and stacks them as columns to create a 2-D array.\n    Each input vector becomes a column in the resulting matrix.\n\n    This is equivalent to column_stack([arr1, arr2]) for 1-D arrays.\n-/\n\n/-  Specification: c_ creates a 2-D array by stacking two vectors as columns.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all row indices i, result[i] is a vector of length 2\n    where result[i][0] = arr1[i] and result[i][1] = arr2[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def c_ {n : Nat} (arr1 arr2 : Vector Float n) : Id (Vector (Vector Float 2) n) :=\n  sorry", "vc-theorems": "theorem c_spec {n : Nat} (arr1 arr2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    c_ arr1 arr2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      result.get i = \u27e8#[arr1.get i, arr2.get i], by simp\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_choose", "vc-description": "/- \n{\n  \"name\": \"numpy.choose\",\n  \"category\": \"Basic indexing\",\n  \"description\": \"Construct an array from an index array and a set of arrays to choose from\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.choose.html\",\n  \"doc\": \"Construct an array from an index array and a set of arrays to choose from.\\n\\nFirst of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = numpy.lib.index_tricks):\\n\\nnp.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)]).\\n\\nBut this omits some subtleties. Here is a fully general summary:\\n\\nGiven an \\\"index\\\" array (a) of integers and a sequence of n arrays (choices), a and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these Ba and Bchoices[i], i = 0,...,n-1 we have that, necessarily, Ba.shape == Bchoices[i].shape for each i. Then, a new array with shape Ba.shape is created as follows:\\n\\n- if mode='raise' (the default), then, first of all, each element of a (and thus Ba) must be in the range [0, n-1]; now, suppose that i (in that range) is the value at the (j0, j1, ..., jm) position in Ba - then the value at the same position in the new array is the value in Bchoices[i] at that same position;\\n\\n- if mode='wrap', values in a (and thus Ba) may be any (signed) integer; modular arithmetic is used to map integers outside the range [0, n-1] back into that range; and then the new array is constructed as above;\\n\\n- if mode='clip', values in a (and thus Ba) may be any (signed) integer; negative integers are mapped to 0; values greater than n-1 are mapped to n-1; and then the new array is constructed as above.\",\n}\n-/\n\n/-  Construct an array from an index array and a set of arrays to choose from.\n    Given an index vector 'indices' and a vector of choice vectors 'choices',\n    constructs a result vector where each element is selected from the corresponding\n    choice vector based on the index value at that position.\n\n    For each position i in the result, result[i] = choices[indices[i]][i]\n\n    This is a simplified version focusing on the core functionality with 'raise' mode,\n    where all indices must be valid (in range [0, num_choices-1]). -/\n\n/-  Specification: choose constructs an array by selecting elements from choice arrays\n    based on index values. Each position in the result is filled by selecting from\n    the corresponding choice array at that position using the index value.\n\n    Mathematical properties:\n    1. The result has the same length as the index array\n    2. For each position i, result[i] = choices[indices[i]][i]\n    3. All indices must be valid (enforced by Fin type)\n\n    The function essentially implements: result[i] = choices[indices.get i].get i\n\n    This captures the core behavior of numpy.choose in 'raise' mode where indices\n    must be in valid range. The use of Fin type ensures type safety and eliminates\n    the need for runtime bounds checking. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def choose {n num_choices : Nat} (indices : Vector (Fin num_choices) n) \n          (choices : Vector (Vector Float n) num_choices) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem choose_spec {n num_choices : Nat} (indices : Vector (Fin num_choices) n) \n                   (choices : Vector (Vector Float n) num_choices) :\n    \u2983\u231cTrue\u231d\u2984\n    choose indices choices\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (choices.get (indices.get i)).get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_compress", "vc-description": "/- \n{\n  \"name\": \"numpy.compress\",\n  \"category\": \"Basic indexing\",\n  \"description\": \"Return selected slices of an array along given axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.compress.html\",\n  \"doc\": \"Return selected slices of an array along given axis.\\n\\nWhen working on a 1-D array, compress is equivalent to extract.\\n\\nParameters\\n----------\\ncondition : 1-D array of bools\\n    Array that selects which entries to return.\\na : array_like\\n    Array from which to extract a part.\\naxis : int, optional\\n    Axis along which to take slices.\\nout : ndarray, optional\\n    Output array.\\n\\nReturns\\n-------\\ncompressed_array : ndarray\\n    A copy of \\`a\\` without the slices along axis for which corresponding element in condition is False.\",\n}\n-/\n\n/-  Compresses a vector by selecting only elements where the corresponding \n    condition is true. Returns a new vector containing only the selected elements.\n    The result size is the number of true values in the condition vector. -/\n\n/-  Specification: compress returns a new vector containing only the elements \n    from the input vector where the corresponding condition element is true.\n\n    Mathematical properties:\n    1. The result size equals the number of true values in the condition\n    2. The result preserves the order of elements from the original vector\n    3. Each element in the result corresponds to a true condition at the same index\n    4. The result is empty if and only if all condition elements are false\n\n    This function implements array compression/masking, a fundamental operation\n    in array programming that allows selective extraction of elements based on\n    a boolean mask. It's equivalent to boolean indexing in NumPy. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def compress {n : Nat} (condition : Vector Bool n) (a : Vector Float n) \n    (m : Nat) (h : m = (condition.toList.filter (\u00b7 = true)).length) : \n    Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem compress_spec {n : Nat} (condition : Vector Bool n) (a : Vector Float n) \n    (m : Nat) (h : m = (condition.toList.filter (\u00b7 = true)).length) :\n    \u2983\u231cTrue\u231d\u2984\n    compress condition a m h\n    \u2983\u21d3result => \u231c-- Result preserves order and corresponds to true conditions\n                 (\u2203 mapping : Fin m \u2192 Fin n,\n                   (\u2200 i : Fin m, condition.get (mapping i) = true) \u2227\n                   (\u2200 i : Fin m, result.get i = a.get (mapping i)) \u2227\n                   (\u2200 i j : Fin m, i < j \u2192 mapping i < mapping j)) \u2227\n                 -- Empty result iff all conditions are false\n                 (m = 0 \u2194 \u2200 i : Fin n, condition.get i = false) \u2227\n                 -- Full result iff all conditions are true\n                 (m = n \u2194 \u2200 i : Fin n, condition.get i = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_diag", "vc-description": "/- \n{\n  \"name\": \"numpy.diag\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Extract a diagonal or construct a diagonal array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.diag.html\",\n  \"doc\": \"Extract a diagonal or construct a diagonal array.\\n\\nParameters\\n----------\\nv : array_like\\n    If \\`v\\` is a 2-D array, return a copy of its \\`k\\`-th diagonal.\\n    If \\`v\\` is a 1-D array, return a 2-D array with \\`v\\` on the \\`k\\`-th diagonal.\\nk : int, optional\\n    Diagonal in question. The default is 0. Use \\`k>0\\` for diagonals above the main diagonal, and \\`k<0\\` for diagonals below the main diagonal.\\n\\nReturns\\n-------\\nout : ndarray\\n    The extracted diagonal or constructed diagonal array.\",\n}\n-/\n\n/-  numpy.diag: Extract a diagonal or construct a diagonal array.\n\n    For simplicity, this specification focuses on extracting the diagonal\n    from a square matrix represented as a flattened vector.\n    Given a flattened n\u00d7n matrix, returns the diagonal elements.\n\n    This specification captures the essential mathematical property of\n    diagonal extraction in a type-safe manner using Vector types.\n-/\n\n/-  Specification: diag extracts diagonal elements from a flattened matrix.\n\n    Mathematical Properties:\n    1. Diagonal Extraction: For a flattened n\u00d7n matrix stored in row-major order,\n       the diagonal elements are located at positions i*n + i for i \u2208 [0, n).\n\n    2. Type Safety: The function maintains type safety by using Vector types\n       that encode the size information at the type level.\n\n    3. Correctness: Each element in the result vector corresponds to a diagonal\n       element from the original matrix, preserving the mathematical structure.\n\n    This specification provides a foundation for formal verification of diagonal\n    operations in numerical computing.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def diag {n : Nat} (matrix : Vector Float (n * n)) : Vector Float n :=\n  sorry", "vc-theorems": "theorem diag_spec {n : Nat} (matrix : Vector Float (n * n)) : \n    \u2200 i : Fin n, (diag matrix).get i = matrix.get \u27e8i.val * n + i.val, by sorry\u27e9 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_diagflat", "vc-description": "/- \n{\n  \"name\": \"numpy.diagflat\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Create a two-dimensional array with the flattened input as a diagonal\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.diagflat.html\",\n  \"doc\": \"Create a two-dimensional array with the flattened input as a diagonal.\\n\\nParameters\\n----------\\nv : array_like\\n    Input data, which is flattened and set as the \\`k\\`-th diagonal of the output.\\nk : int, optional\\n    Diagonal to set; 0, the default, corresponds to the \\\"main\\\" diagonal.\\n\\nReturns\\n-------\\nout : ndarray\\n    The 2-D output array.\",\n}\n-/\n\n/-  numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\n    Creates a square matrix where the input vector is placed along the main diagonal.\n    All other elements are zero. The resulting matrix has size n\u00d7n where n is the\n    length of the input vector.\n\n    For the main diagonal (k=0), the matrix element at position (i,i) contains\n    the i-th element of the input vector.\n-/\n\n/-  Specification: diagflat returns a square matrix where the input vector forms the main diagonal.\n\n    Properties:\n    1. The result is a square n\u00d7n matrix\n    2. For all i, j: if i = j then result[i][j] = v[i] (diagonal elements)\n    3. For all i, j: if i \u2260 j then result[i][j] = 0 (off-diagonal elements are zero)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def diagflat {n : Nat} (v : Vector Float n) : Vector (Vector Float n) n :=\n  sorry", "vc-theorems": "theorem diagflat_spec {n : Nat} (v : Vector Float n) :\n    let result := diagflat v\n    \u2200 i : Fin n, \u2200 j : Fin n,\n      (i = j \u2192 (result.get i).get j = v.get i) \u2227\n      (i \u2260 j \u2192 (result.get i).get j = 0) := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_diagonal", "vc-description": "/- \n{\n  \"name\": \"numpy.diagonal\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Return specified diagonals\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.diagonal.html\",\n  \"doc\": \"Return specified diagonals.\\n\\nIf \\`a\\` is 2-D, returns the diagonal of \\`a\\` with the given offset, i.e., the collection of elements of the form \\`\\`a[i, i+offset]\\`\\`. If \\`a\\` has more than two dimensions, then the axes specified by \\`axis1\\` and \\`axis2\\` are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing \\`axis1\\` and \\`axis2\\` and appending an index to the right equal to the size of the resulting diagonals.\\n\\nParameters\\n----------\\na : array_like\\n    Array from which the diagonals are taken.\\noffset : int, optional\\n    Offset of the diagonal from the main diagonal. Can be positive or negative.\\naxis1 : int, optional\\n    Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken.\\naxis2 : int, optional\\n    Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken.\\n\\nReturns\\n-------\\narray_of_diagonals : ndarray\\n    If \\`a\\` is 2-D, then a 1-D array containing the diagonal and of the same type as \\`a\\` is returned. If \\`a\\` has more than two dimensions, then the dimensions specified by \\`axis1\\` and \\`axis2\\` are removed, and a new axis inserted at the end corresponding to the diagonal.\",\n}\n-/\n\n/-  Extract diagonal elements from a 2D matrix with optional offset.\n\n    Takes a 2D matrix and returns a 1D vector containing the diagonal elements.\n    For offset=0, returns main diagonal elements [a[0,0], a[1,1], ...].\n    For offset>0, returns elements above main diagonal [a[0,offset], a[1,offset+1], ...].\n    For offset<0, returns elements below main diagonal [a[-offset,0], a[-offset+1,1], ...].\n-/\n\n/-  Specification: diagonal extracts diagonal elements from a 2D matrix.\n\n    Precondition: The matrix dimensions must be large enough to accommodate the offset\n    Postcondition: The result contains exactly the diagonal elements at the specified offset\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def diagonal {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int := 0) : \n  Id (Vector Float (if offset \u2265 0 then min rows (cols - offset.natAbs) else min (rows - offset.natAbs) cols)) :=\n  sorry", "vc-theorems": "theorem diagonal_spec {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int := 0) \n    (h_valid : if offset \u2265 0 then offset.natAbs \u2264 cols else offset.natAbs \u2264 rows) :\n    \u2983\u231cif offset \u2265 0 then offset.natAbs \u2264 cols else offset.natAbs \u2264 rows\u231d\u2984\n    diagonal a offset\n    \u2983\u21d3result => \u231c\n      -- Result size matches the diagonal size\n      result.size = (if offset \u2265 0 then min rows (cols - offset.natAbs) else min (rows - offset.natAbs) cols) \u2227\n      -- Each element is from the correct diagonal position\n      (\u2200 i : Fin result.size, \n        if offset \u2265 0 then\n          -- For non-negative offset: a[i, i+offset]\n          result.get i = (a.get \u27e8i.val, by sorry\u27e9).get \u27e8i.val + offset.natAbs, by sorry\u27e9\n        else\n          -- For negative offset: a[i+|offset|, i]\n          result.get i = (a.get \u27e8i.val + offset.natAbs, by sorry\u27e9).get \u27e8i.val, by sorry\u27e9) \u2227\n      -- Sanity check: result is non-empty when matrix is non-empty and offset is valid\n      (rows > 0 \u2227 cols > 0 \u2192 result.size > 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_extract", "vc-description": "/- \n{\n  \"name\": \"numpy.extract\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Return the elements of an array that satisfy some condition\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.extract.html\",\n  \"doc\": \"Return the elements of an array that satisfy some condition.\\n\\nThis is equivalent to \\`\\`np.compress(ravel(condition), ravel(arr))\\`\\`. If \\`condition\\` is boolean \\`\\`np.extract\\`\\` is equivalent to \\`\\`arr[condition]\\`\\`.\\n\\nNote that \\`place\\` does the exact opposite of \\`extract\\`.\\n\\nParameters\\n----------\\ncondition : array_like\\n    An array whose nonzero or True entries indicate the elements of \\`arr\\` to extract.\\narr : array_like\\n    Input array of the same size as \\`condition\\`.\\n\\nReturns\\n-------\\nextract : ndarray\\n    Rank 1 array of values from \\`arr\\` where \\`condition\\` is True.\",\n}\n-/\n\n/-  numpy.extract: Return the elements of an array that satisfy some condition.\n\n    Extracts elements from an array where the corresponding condition is True.\n    Both arrays must have the same size, and the result contains only the elements\n    from `arr` where `condition` is True, in the same order they appear in `arr`.\n\n    The result size `k` must equal the number of True elements in the condition array.\n-/\n\n/-  Specification: numpy.extract returns elements where condition is True.\n\n    Precondition: k equals the count of True elements in condition\n    Postcondition: The result contains exactly the elements from arr where condition is True,\n                  in the same order they appear in arr.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def extract {n k : Nat} (condition : Vector Bool n) (arr : Vector Float n) \n    (h : k = (condition.toArray.toList.count true)) : Id (Vector Float k) :=\n  sorry", "vc-theorems": "theorem extract_spec {n k : Nat} (condition : Vector Bool n) (arr : Vector Float n) \n    (h : k = (condition.toArray.toList.count true)) :\n    \u2983\u231ck = (condition.toArray.toList.count true)\u231d\u2984\n    extract condition arr h\n    \u2983\u21d3result => \n      -- The result contains exactly the elements from arr where condition is True\n      \u231c\u2200 i : Fin k, \u2203 idx : Fin n, condition.get idx = true \u2227 result.get i = arr.get idx\u231d\n    \u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_fill_diagonal", "vc-description": "/- \n{\n  \"name\": \"numpy.fill_diagonal\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Fill the main diagonal of the given array of any dimensionality\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fill_diagonal.html\",\n  \"doc\": \"Fill the main diagonal of the given array of any dimensionality.\\n\\nFor an array \\`a\\` with \\`\\`a.ndim >= 2\\`\\`, the diagonal is the list of locations with indices \\`\\`a[i, ..., i]\\`\\` all identical. This function modifies the input array in-place, it does not return a value.\\n\\nParameters\\n----------\\na : array, at least 2-D.\\n    Array whose diagonal is to be filled, it gets modified in-place.\\nval : scalar or array_like\\n    Value(s) to write on the diagonal. If \\`val\\` is scalar, the value is written along the diagonal. If array-like, the flattened \\`val\\` is written along the diagonal, repeating if necessary to fill all diagonal entries.\\nwrap : bool\\n    For tall matrices in NumPy version up to 1.6.2, the diagonal \\\"wrapped\\\" after N columns. You can have this behavior with this option. This affects only tall matrices.\",\n}\n-/\n\n/-  Fill the main diagonal of a 2D matrix with a specified value -/\n\n/-  Specification: fill_diagonal modifies the diagonal entries to the specified value -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fill_diagonal {T : Type} {rows cols : Nat} (mat : Vector (Vector T cols) rows) (val : T) : \n    Id (Vector (Vector T cols) rows) :=\n  sorry", "vc-theorems": "theorem fill_diagonal_spec {T : Type} {rows cols : Nat} (mat : Vector (Vector T cols) rows) (val : T) :\n    \u2983\u231cTrue\u231d\u2984\n    fill_diagonal mat val\n    \u2983\u21d3result => \u231c-- Diagonal elements are filled with val\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, i.val = j.val \u2192 \n        (result.get i).get j = val) \u2227\n      -- Non-diagonal elements remain unchanged\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, i.val \u2260 j.val \u2192 \n        (result.get i).get j = (mat.get i).get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_flatiter", "vc-description": "/- \n{\n  \"name\": \"numpy.flatiter\",\n  \"category\": \"Iterating over arrays\",\n  \"description\": \"Flat iterator object to iterate over arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.flatiter.html\",\n  \"doc\": \"Flat iterator object to iterate over arrays.\\n\\nA \\`flatiter\\` iterator is returned by \\`\\`x.flat\\`\\` for any array \\`x\\`. It allows iterating over the array as if it were a 1-D array, either in a for-loop or by calling its \\`next\\` method.\\n\\nIteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.\\n\\nNotes\\n-----\\nA \\`flatiter\\` iterator can not be constructed directly from Python code by calling the \\`flatiter\\` constructor.\",\n}\n-/\n\n/-  numpy.flatiter: Flat iterator object to iterate over arrays.\n\n    A flatiter iterator provides a flattened view of an array for iteration purposes.\n    It allows accessing elements of a multi-dimensional array as if it were 1-dimensional,\n    following row-major (C-style) order where the last index varies fastest.\n\n    The iterator supports indexing and provides sequential access to all elements\n    in the array following the memory layout order.\n-/\n\n/-  Specification: numpy.flatiter creates a flat iterator over the array.\n\n    Precondition: True (no special preconditions for creating a flat iterator)\n    Postcondition: The result preserves all elements in row-major order,\n                   providing sequential access to the flattened array elements\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_flatiter {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_flatiter_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_flatiter a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = a.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_indices", "vc-description": "/- \n{\n  \"name\": \"numpy.indices\",\n  \"category\": \"Index generation\",\n  \"description\": \"Return an array representing the indices of a grid\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.indices.html\",\n  \"doc\": \"Return an array representing the indices of a grid.\\n\\nCompute an array where the subarrays contain index values 0, 1, ... varying only along the corresponding axis.\\n\\nParameters\\n----------\\ndimensions : sequence of ints\\n    The shape of the grid.\\ndtype : dtype, optional\\n    Data type of the result.\\nsparse : boolean, optional\\n    Return a sparse representation of the grid instead of a dense representation.\\n\\nReturns\\n-------\\ngrid : one ndarray or tuple of ndarrays\\n    If sparse is False:\\n        Returns one array of grid indices, `grid.shape = (len(dimensions),) + tuple(dimensions)`.\\n    If sparse is True:\\n        Returns a tuple of arrays, with `grid[i].shape = (1, ..., dimensions[i], ..., 1)` with dimensions[i] in the ith place.\",\n}\n-/\n\n/-  Generate indices for a 1D grid of given size.\n    Returns a 2D array where the first dimension has size 1 and contains \n    the indices [0, 1, 2, ..., n-1] -/\n\n/-  Specification: indices generates a grid of index values\n    This comprehensive specification captures:\n    1. The output has the correct shape: (1, n) for 1D case\n    2. The single row contains exactly the indices [0, 1, 2, ..., n-1]\n    3. Each position i contains the value i\n    4. The indices are in ascending order\n    5. The result covers all valid indices for the given dimension\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def indices (n : Nat) : Id (Vector (Vector Nat n) 1) :=\n  sorry", "vc-theorems": "theorem indices_spec (n : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    indices n\n    \u2983\u21d3grid => \u231cgrid.size = 1 \u2227 \n              (\u2200 i : Fin n, (grid.get \u27e80, by simp\u27e9).get i = i.val) \u2227\n              (\u2200 i j : Fin n, i < j \u2192 (grid.get \u27e80, by simp\u27e9).get i < (grid.get \u27e80, by simp\u27e9).get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_ix_", "vc-description": "/- \n{\n  \"name\": \"numpy.ix_\",\n  \"category\": \"Advanced indexing\",\n  \"description\": \"Construct an open mesh from multiple sequences\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ix_.html\",\n  \"doc\": \"Construct an open mesh from multiple sequences.\\n\\nThis function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.\\n\\nParameters\\n----------\\nargs : 1-D sequences\\n    Each sequence should be of integer or boolean type.\\n    Boolean sequences will be interpreted as boolean masks.\\n\\nReturns\\n-------\\nout : tuple of ndarrays\\n    N arrays with N dimensions each, with N the number of input\\n    sequences. Together these arrays form an open mesh.\",\n}\n-/\n\n/-  Construct an open mesh from two 1-D sequences. \n    This simplified version handles the case of two input sequences,\n    returning two 2D arrays that form an open mesh for indexing operations.\n    The first array has shape (m, 1) containing values from the first sequence,\n    and the second array has shape (1, n) containing values from the second sequence. -/\n\n/-  Specification: ix_ creates an open mesh from two sequences\n    This comprehensive specification captures:\n    1. The function takes two 1-D sequences of integers\n    2. Returns a pair of 2D arrays (represented as vectors of vectors)\n    3. First array has shape (m, 1) - m rows, 1 column\n    4. Second array has shape (1, n) - 1 row, n columns\n    5. First array contains values from seq1 repeated in column format\n    6. Second array contains values from seq2 repeated in row format\n    7. Together they form an open mesh for advanced indexing operations\n    8. Each element of the first array's i-th row equals seq1[i]\n    9. Each element of the second array's single row equals the corresponding seq2 element\n    10. The mesh property: for any indices (i,j), the pair (first[i][0], second[0][j]) \n        represents a coordinate in the mesh grid -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ix_ {m n : Nat} (seq1 : Vector Int m) (seq2 : Vector Int n) : Id (Vector (Vector Int 1) m \u00d7 Vector (Vector Int n) 1) :=\n  sorry", "vc-theorems": "theorem ix_spec {m n : Nat} (seq1 : Vector Int m) (seq2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    ix_ seq1 seq2\n    \u2983\u21d3result => \u231c-- First array has correct shape and values\n                   (result.1.size = m) \u2227\n                   (\u2200 i : Fin m, result.1.get i = Vector.replicate 1 (seq1.get i)) \u2227\n                   -- Second array has correct shape and values  \n                   (result.2.size = 1) \u2227\n                   (\u2200 j : Fin 1, result.2.get j = seq2) \u2227\n                   -- Mesh property: coordinates are preserved\n                   (\u2200 i : Fin m, \u2200 j : Fin n, \n                     (result.1.get i).get \u27e80, Nat.zero_lt_one\u27e9 = seq1.get i \u2227\n                     (result.2.get \u27e80, Nat.zero_lt_one\u27e9).get j = seq2.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_mgrid", "vc-description": "/- \n{\n  \"name\": \"numpy.mgrid\",\n  \"category\": \"Advanced indexing\",\n  \"description\": \"Dense multi-dimensional \\\"meshgrid\\\"\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.mgrid.html\",\n  \"doc\": \"Dense multi-dimensional \\\"meshgrid\\\".\\n\\nAn instance of \\`numpy.lib.index_tricks.nd_grid\\` which returns a dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.\\n\\nHowever, if the step length is a complex number (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value is inclusive.\",\n}\n-/\n\n/-  numpy.mgrid: Dense multi-dimensional \\\"meshgrid\\\" creation for 2D case.\n\n    Creates a dense mesh-grid from two 1D coordinate arrays, returning a pair of 2D arrays\n    where each output array has the same shape (rows \u00d7 cols). The first array contains\n    row coordinates repeated across columns, and the second array contains column\n    coordinates repeated across rows.\n\n    This is the 2D case of numpy.mgrid[start_r:stop_r, start_c:stop_c] which creates\n    coordinate arrays suitable for evaluating functions over a 2D grid.\n\n    For 2D case with rows and cols dimensions, this returns a tuple of two matrices:\n    - First matrix: row coordinates repeated across columns\n    - Second matrix: column coordinates repeated across rows\n-/\n\n/-  Specification: numpy.mgrid creates dense coordinate arrays for 2D grid evaluation.\n\n    Properties:\n    1. Both output arrays have the same shape (rows \u00d7 cols)\n    2. First array contains row coordinates: each row i contains the same value across all columns\n    3. Second array contains column coordinates: each column j contains the same value across all rows\n    4. Row coordinates are evenly spaced between start_r and stop_r (exclusive)\n    5. Column coordinates are evenly spaced between start_c and stop_c (exclusive)\n    6. The arrays form a coordinate system suitable for function evaluation over a 2D grid\n    7. Each coordinate position (i,j) in the first array corresponds to the row coordinate\n    8. Each coordinate position (i,j) in the second array corresponds to the column coordinate\n\n    Mathematical properties:\n    - Grid completeness: Every position (i,j) has well-defined coordinates\n    - Coordinate consistency: Row array varies only along row dimension, column array varies only along column dimension\n    - Spacing uniformity: Coordinates are evenly distributed within their respective ranges\n    - Dense representation: All coordinate combinations are explicitly stored (not sparse)\n\n    This specification captures the key behavior of numpy.mgrid: creating dense coordinate\n    arrays that can be used for vectorized function evaluation over 2D grids, with each\n    output array having the same shape and containing the appropriate coordinate values.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mgrid {rows cols : Nat} (start_r stop_r start_c stop_c : Float) \n    (h_rows : rows > 0) (h_cols : cols > 0) : \n    Id (Vector (Vector Float cols) rows \u00d7 Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem mgrid_spec {rows cols : Nat} (start_r stop_r start_c stop_c : Float) \n    (h_rows : rows > 0) (h_cols : cols > 0) :\n    \u2983\u231crows > 0 \u2227 cols > 0\u231d\u2984\n    mgrid start_r stop_r start_c stop_c h_rows h_cols\n    \u2983\u21d3result => \u231c-- Both arrays have the same shape  \n                  (result.1.size = rows) \u2227 (result.2.size = rows) \u2227\n                  (\u2200 i : Fin rows, (result.1.get i).size = cols \u2227 (result.2.get i).size = cols) \u2227\n                  -- Row coordinates: same value across each row\n                  (\u2200 i : Fin rows, \u2200 j k : Fin cols, (result.1.get i).get j = (result.1.get i).get k) \u2227\n                  -- Column coordinates: same value down each column  \n                  (\u2200 j : Fin cols, \u2200 i k : Fin rows, (result.2.get i).get j = (result.2.get k).get j) \u2227\n                  -- Row coordinates are evenly spaced\n                  (\u2200 i : Fin rows, \u2200 j : Fin cols, \n                    (result.1.get i).get j = start_r + (Float.ofNat i.val) * (stop_r - start_r) / (Float.ofNat rows)) \u2227\n                  -- Column coordinates are evenly spaced\n                  (\u2200 i : Fin rows, \u2200 j : Fin cols,\n                    (result.2.get i).get j = start_c + (Float.ofNat j.val) * (stop_c - start_c) / (Float.ofNat cols)) \u2227\n                  -- Boundary conditions: first/last coordinates match start/stop points\n                  (\u2200 j : Fin cols, (result.1.get \u27e80, by sorry\u27e9).get j = start_r) \u2227\n                  (\u2200 i : Fin rows, (result.2.get i).get \u27e80, by sorry\u27e9 = start_c) \u2227\n                  -- Mathematical property: coordinates form a complete grid\n                  (\u2200 i : Fin rows, \u2200 j : Fin cols, \n                    start_r \u2264 (result.1.get i).get j \u2227 (result.1.get i).get j < stop_r) \u2227\n                  (\u2200 i : Fin rows, \u2200 j : Fin cols, \n                    start_c \u2264 (result.2.get i).get j \u2227 (result.2.get i).get j < stop_c)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_nanargmax", "vc-description": "/- \n{\n  \"name\": \"numpy.nanargmax\",\n  \"category\": \"Index finding\",\n  \"description\": \"Return the indices of the maximum values in the specified axis ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanargmax.html\",\n  \"doc\": \"Return the indices of the maximum values in the specified axis ignoring NaNs.\\n\\nFor all-NaN slices \\`\\`ValueError\\`\\` is raised. Warning: the results cannot be trusted if a slice contains only NaNs and -Infs.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : int, optional\\n    Axis along which to operate. By default flattened input is used.\\nout : array, optional\\n    If provided, the result will be inserted into this array.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nindex_array : ndarray\\n    An array of indices or a single index value.\",\n}\n-/\n\n/-  Returns the index of the maximum value in a non-empty vector, ignoring NaN values.\n\n    This function finds the index of the maximum value among all non-NaN elements in the vector.\n    Requires that at least one element is not NaN, otherwise it would raise an error.\n\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n-/\n\n/-  Specification: nanargmax returns the index of the first maximum element among non-NaN values.\n\n    This comprehensive specification captures:\n    1. The returned index points to an element that is not NaN\n    2. The element at the returned index is the maximum among all non-NaN elements\n    3. The function returns the first occurrence of the maximum value (among non-NaN elements)\n    4. The returned index is valid (type-safe with Fin)\n    5. The precondition ensures at least one element is not NaN\n    6. All non-NaN elements are less than or equal to the maximum\n    7. Among elements with the same maximum value, the first index is returned\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanargmax {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem nanargmax_spec {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) :\n    \u2983\u231c\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN\u231d\u2984\n    nanargmax a h_not_all_nan\n    \u2983\u21d3idx => \u231c\u00ac(a.get idx).isNaN \u2227 \n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 a.get idx) \u2227\n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j = a.get idx \u2192 idx \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_nanargmin", "vc-description": "/- \n{\n  \"name\": \"numpy.nanargmin\",\n  \"category\": \"Index finding\",\n  \"description\": \"Return the indices of the minimum values in the specified axis ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanargmin.html\",\n  \"doc\": \"Return the indices of the minimum values in the specified axis ignoring NaNs.\\n\\nFor all-NaN slices \\`\\`ValueError\\`\\` is raised. Warning: the results cannot be trusted if a slice contains only NaNs and Infs.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : int, optional\\n    Axis along which to operate. By default flattened input is used.\\nout : array, optional\\n    If provided, the result will be inserted into this array.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nindex_array : ndarray\\n    An array of indices or a single index value.\",\n}\n-/\n\n/-  Returns the index of the minimum value in a non-empty vector, ignoring NaN values.\n\n    This function finds the index of the minimum value among all non-NaN elements in the vector.\n    Requires that at least one element is not NaN, otherwise it would raise an error.\n\n    In case of multiple occurrences of the minimum values, the indices\n    corresponding to the first occurrence are returned.\n-/\n\n/-  Specification: nanargmin returns the index of the first minimum element among non-NaN values.\n\n    This comprehensive specification captures:\n    1. The returned index points to an element that is not NaN\n    2. The element at the returned index is the minimum among all non-NaN elements\n    3. The function returns the first occurrence of the minimum value (among non-NaN elements)\n    4. The returned index is valid (type-safe with Fin)\n    5. The precondition ensures at least one element is not NaN\n    6. All non-NaN elements are greater than or equal to the minimum\n    7. Among elements with the same minimum value, the first index is returned\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanargmin {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem nanargmin_spec {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) :\n    \u2983\u231c\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN\u231d\u2984\n    nanargmin a h_not_all_nan\n    \u2983\u21d3idx => \u231c\u00ac(a.get idx).isNaN \u2227 \n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get idx \u2264 a.get j) \u2227\n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j = a.get idx \u2192 idx \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_ndenumerate", "vc-description": "/- \n{\n  \"name\": \"numpy.ndenumerate\",\n  \"category\": \"Iterating over arrays\",\n  \"description\": \"Multidimensional index iterator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ndenumerate.html\",\n  \"doc\": \"Multidimensional index iterator.\\n\\nReturn an iterator yielding pairs of array coordinates and values.\\n\\nParameters\\n----------\\narr : ndarray\\n    Input array.\",\n}\n-/\n\n/-  numpy.ndenumerate: Multidimensional index iterator that yields pairs of array coordinates and values.\n\n    For a 1D array, this creates a vector of tuples where each tuple contains\n    the index and the corresponding value from the input array.\n\n    The function essentially enumerates through the array, providing both\n    the position (index) and the value at that position.\n-/\n\n/-  Specification: ndenumerate returns a vector of index-value pairs.\n\n    For each position i in the input array, the result contains a tuple\n    (i, arr[i]) where i is the index and arr[i] is the value at that index.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: For all indices i, result[i] = (i, arr[i])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ndenumerate {n : Nat} (arr : Vector Float n) : Id (Vector (Fin n \u00d7 Float) n) :=\n  sorry", "vc-theorems": "theorem ndenumerate_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    ndenumerate arr\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (i, arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_ndindex", "vc-description": "/- \n{\n  \"name\": \"numpy.ndindex\",\n  \"category\": \"Index generation\",\n  \"description\": \"An N-dimensional iterator object to index arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ndindex.html\",\n  \"doc\": \"An N-dimensional iterator object to index arrays.\\n\\nGiven the shape of an array, an \\`ndindex\\` instance iterates over the N-dimensional index of the array.\",\n}\n-/\n\n/-  Generate N-dimensional indices for an array with given shape.\n    Returns a vector of index tuples, where each tuple represents a valid\n    N-dimensional index for an array with the specified dimensions.\n\n    For a 2D array with shape (m, n), this generates all index pairs\n    (i, j) where 0 \u2264 i < m and 0 \u2264 j < n, in C-order (row-major).\n\n    Example: For shape (2, 3), generates [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]\n-/\n\n/-  Specification: ndindex generates all valid N-dimensional indices for a given shape.\n    This comprehensive specification captures:\n    1. The output contains exactly m*n index pairs for a 2D array of shape (m, n)\n    2. Each index pair (i, j) satisfies the bounds: 0 \u2264 i < m and 0 \u2264 j < n\n    3. The indices are generated in C-order (row-major): last dimension changes fastest\n    4. All possible valid indices are included exactly once\n    5. The ordering follows the pattern: (0,0), (0,1), ..., (0,n-1), (1,0), (1,1), ..., (m-1,n-1)\n\n    Precondition: The shape parameters match the type parameters m and n\n    Postcondition: The result contains all valid indices in the correct C-order\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ndindex {m n : Nat} (shape : Nat \u00d7 Nat) : Id (Vector (Fin m \u00d7 Fin n) (m * n)) :=\n  sorry", "vc-theorems": "theorem ndindex_spec {m n : Nat} (shape : Nat \u00d7 Nat) (h_shape : shape = (m, n)) :\n    \u2983\u231cshape = (m, n)\u231d\u2984\n    ndindex shape\n    \u2983\u21d3indices => \u231cindices.size = m * n \u2227\n                   (\u2200 k : Fin (m * n), \n                      let (i, j) := indices.get k\n                      i.val < m \u2227 j.val < n) \u2227\n                   (\u2200 i : Fin m, \u2200 j : Fin n,\n                      \u2203 k : Fin (m * n), indices.get k = (i, j)) \u2227\n                   (\u2200 k : Fin (m * n), \n                      let (i, j) := indices.get k\n                      k.val = i.val * n + j.val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_nditer", "vc-description": "/- \n{\n  \"name\": \"numpy.nditer\",\n  \"category\": \"Iterating over arrays\",\n  \"description\": \"Efficient multi-dimensional iterator object to iterate over arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nditer.html\",\n  \"doc\": \"Efficient multi-dimensional iterator object to iterate over arrays.\\n\\nTo get started using this object, see the introductory guide to array iteration.\\n\\nParameters\\n----------\\nop : ndarray or sequence of array_like\\n    The array(s) to iterate over.\\nflags : sequence of str, optional\\n    Flags to control the behavior of the iterator.\\nbuffersize : int, optional\\n    When buffering is enabled, controls the size of the temporary buffers.\\norder : {'C', 'F', 'A', 'K'}, optional\\n    Controls the iteration order.\\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\\n    Controls what kind of data casting may occur when making a copy or buffering.\\nop_dtypes : dtype or tuple of dtype(s), optional\\n    The required data type(s) of the operands.\\n\\nAttributes\\n----------\\ndtypes : tuple of dtype(s)\\n    The data types of the values provided in `value`.\\nfinished : bool\\n    Whether the iteration over the operands is finished or not.\\nhas_delayed_bufalloc : bool\\n    If True, the iterator was created with the `delay_bufalloc` flag.\\nhas_index : bool\\n    If True, the iterator was created with either the `c_index` or `f_index` flag.\\nhas_multi_index : bool\\n    If True, the iterator was created with the `multi_index` flag.\\nindex\\n    When the `c_index` or `f_index` flag was used, this property provides access to it.\\niterationneedsapi : bool\\n    Whether iteration requires access to the Python API.\\niterindex : int\\n    An index which matches the order of iteration.\\nitersize : int\\n    Size of the iterator.\\nitviews\\n    Structured view(s) of `operands` in memory.\\nmulti_index\\n    When the `multi_index` flag was used, this property provides access to it.\\nndim : int\\n    The number of dimensions being iterated.\\nnop : int\\n    The number of operands being iterated.\\noperands : tuple of operand(s)\\n    The operands being iterated over.\\nshape : tuple of ints\\n    Shape of the iterator.\\nvalue\\n    Value of `operands` at current iteration.\",\n}\n-/\n\n/-  numpy.nditer: Creates an iterator for a vector that provides position and element access.\n\n    This is a simplified 1D version of numpy's nditer functionality.\n    Returns an iterator that starts at position 0 and holds the original data.\n    The iterator can be used to traverse the vector elements sequentially.\n\n    In numpy, nditer is a powerful multi-dimensional iterator, but for our\n    Vector-based specification, we simplify it to basic position tracking.\n-/\n\n/-  Specification: nditer creates a valid iterator that starts at position 0.\n\n    This comprehensive specification captures:\n    1. The iterator starts at position 0\n    2. The iterator contains the original data unchanged\n    3. The iterator position is valid (within bounds)\n    4. The iterator provides access to all elements of the original vector\n    5. The iterator follows numpy's iteration semantics\n    6. The iterator state is consistent and predictable\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nditer {n : Nat} (arr : Vector Float n) : Id (Nat \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem nditer_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nditer arr\n    \u2983\u21d3iter => \u231c(iter.1 = 0) \u2227\n               (iter.2 = arr) \u2227\n               (iter.1 \u2264 n) \u2227\n               (\u2200 i : Fin n, iter.2.get i = arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_ogrid", "vc-description": "/-  numpy.ogrid: Open multi-dimensional \"meshgrid\".\n\n    Returns an open (i.e. not fleshed out) mesh-grid when indexed, \n    so that only one dimension of each returned array is greater than 1.\n\n    This is a simplified 1D version that generates a linear sequence\n    similar to arange but with the ogrid interface. The dimension and \n    number of the output arrays are equal to the number of indexing dimensions.\n\n    For the 1D case, it returns a single vector with evenly spaced values\n    from start to stop (exclusive) with the given step size.\n-/\n\n/-  Specification: ogrid returns a vector of evenly spaced values.\n\n    Precondition: step \u2260 0 and n = \u230a(stop - start) / step\u230b\n    Postcondition: The result is a vector where each element i satisfies:\n    - result[i] = start + i * step\n    - All elements are in the range [start, stop)\n    - The sequence is arithmetic with common difference step\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ogrid (start stop step : Float) (n : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ogrid_spec (start stop step : Float) (n : Nat) \n    (h_step : step \u2260 0) :\n    \u2983\u231cstep \u2260 0\u231d\u2984\n    ogrid start stop step n\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = start + (i.val.toFloat) * step) \u2227\n                (\u2200 i : Fin n, \n                  if step > 0 then start \u2264 result.get i \u2227 result.get i < stop\n                  else stop < result.get i \u2227 result.get i \u2264 start)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_place", "vc-description": "/- \n{\n  \"name\": \"numpy.place\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Change elements of an array based on conditional and input values\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.place.html\",\n  \"doc\": \"Change elements of an array based on conditional and input values.\\n\\nSimilar to \\`\\`np.copyto(arr, vals, where=mask)\\`\\`, the difference is that \\`place\\` uses the first N elements of \\`vals\\`, where N is the number of True values in \\`mask\\`, while \\`copyto\\` uses the elements where \\`mask\\` is True.\\n\\nNote that \\`extract\\` does the exact opposite of \\`place\\`.\\n\\nParameters\\n----------\\narr : ndarray\\n    Array to put data into.\\nmask : array_like\\n    Boolean mask array. Must have the same size as \\`a\\`.\\nvals : 1-D sequence\\n    Values to put into \\`a\\`. Only the first N elements are used, where N is the number of True values in \\`mask\\`. If \\`vals\\` is smaller than N, it will be repeated, and if elements of \\`a\\` are to be masked, this sequence must be non-empty.\",\n}\n-/\n\n/-  numpy.place: Change elements of an array based on conditional and input values.\n\n    Modifies elements of an array where the corresponding mask is True, using values \n    from the vals array. The function uses the first N elements of vals, where N is \n    the number of True values in mask. If vals is smaller than N, it will be repeated.\n\n    The parameter `k` must equal the number of True elements in the mask array.\n    The parameter `v` is the size of the vals array, which must be non-empty.\n-/\n\n/-  Specification: numpy.place modifies elements where mask is True using vals.\n\n    Precondition: k equals the count of True elements in mask, and vals is non-empty\n    Postcondition: Elements in arr where mask is True are replaced with values from vals,\n                  with vals repeating if necessary. Elements where mask is False remain unchanged.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def place {n k v : Nat} (arr : Vector Float n) (mask : Vector Bool n) (vals : Vector Float (v + 1))\n    (h : k = (mask.toArray.toList.count true)) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem place_spec {n k v : Nat} (arr : Vector Float n) (mask : Vector Bool n) (vals : Vector Float (v + 1))\n    (h : k = (mask.toArray.toList.count true)) :\n    \u2983\u231ck = (mask.toArray.toList.count true)\u231d\u2984\n    place arr mask vals h\n    \u2983\u21d3result => \n      -- Elements where mask is False remain unchanged, \n      -- Elements where mask is True are replaced with values from vals (with repetition)\n      \u231c(\u2200 i : Fin n, mask.get i = false \u2192 result.get i = arr.get i) \u2227\n       (\u2200 i : Fin n, mask.get i = true \u2192 \n         \u2203 (pos : Nat) (val_idx : Fin (v + 1)), \n           pos < k \u2227 \n           val_idx.val = pos % (v + 1) \u2227\n           result.get i = vals.get val_idx)\u231d\n    \u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_put", "vc-description": "/- \n{\n  \"name\": \"numpy.put\",\n  \"category\": \"Basic indexing\",\n  \"description\": \"Replaces specified elements of an array with given values\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.put.html\",\n  \"doc\": \"Replaces specified elements of an array with given values.\\n\\nThe indexing works on the flattened target array.\\n\\nParameters\\n----------\\na : ndarray\\n    Target array.\\nind : array_like\\n    Target indices, interpreted as integers.\\nv : array_like\\n    Values to place in \\`a\\` at target indices.\\nmode : {'raise', 'wrap', 'clip'}, optional\\n    Specifies how out-of-bounds indices will behave.\\n\\nReturns\\n-------\\nNone\",\n}\n-/\n\n/-  \nnumpy.put: Replaces specified elements of an array with given values.\n\nThe indexing works on the flattened target array. This operation mutates the input array\nin-place by placing values from `v` at the positions specified by `ind`.\n\nFor simplicity, we ignore the `mode` parameter and assume all indices are valid.\n-/\n\n/-  \nSpecification: numpy.put modifies specific elements of the input array.\n\nThis theorem captures the core mathematical properties:\n1. Elements at specified indices are replaced with corresponding values from `v`\n2. All other elements remain unchanged\n3. The result vector has the same length as the input vector\n4. Index bounds are respected (enforced by precondition)\n\nPrecondition: All indices in `ind` must be valid (less than array length)\nPostcondition: Elements at specified indices are replaced with corresponding values from `v`,\n              while all other elements remain unchanged.\n\nThis specification handles the case where indices may be duplicated - in such cases,\nthe later occurrence in the index vector takes precedence.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def put {n m : Nat} (a : Vector Float n) (ind : Vector Nat m) (v : Vector Float m) \n    (h_valid : \u2200 i : Fin m, ind.get i < n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem put_spec {n m : Nat} (a : Vector Float n) (ind : Vector Nat m) (v : Vector Float m) \n    (h_valid : \u2200 i : Fin m, ind.get i < n) :\n    let result := put a ind v h_valid\n    -- Main properties\n    (-- Elements at specified indices are replaced with values from v\n     \u2200 i : Fin m, result.get \u27e8ind.get i, h_valid i\u27e9 = v.get i) \u2227\n    (-- All other elements remain unchanged\n     \u2200 j : Fin n, (\u2200 i : Fin m, j.val \u2260 ind.get i) \u2192 result.get j = a.get j) \u2227\n    -- Sanity checks\n    (-- Vector length is preserved (n is the length for both vectors)\n     True) \u2227\n    (-- If no indices are provided, the result equals the input\n     m = 0 \u2192 result = a) \u2227\n    (-- If all indices are distinct and cover the entire array, \n     -- the result is the permutation of v according to ind\n     (\u2200 i j : Fin m, i \u2260 j \u2192 ind.get i \u2260 ind.get j) \u2192 \n     (\u2200 k : Fin n, \u2203 i : Fin m, ind.get i = k) \u2192 \n     (\u2200 k : Fin n, \u2203 i : Fin m, ind.get i = k \u2227 result.get k = v.get i)) := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_putmask", "vc-description": "/- \n{\n  \"name\": \"numpy.putmask\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Changes elements of an array based on conditional and input values\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.putmask.html\",\n  \"doc\": \"Changes elements of an array based on conditional and input values.\\n\\nSets \\`\\`a.flat[n] = values[n]\\`\\` for each n where \\`\\`mask.flat[n]==True\\`\\`.\\n\\nIf \\`values\\` is not the same size as \\`a\\` and \\`mask\\` then it will repeat. This gives behavior different from \\`\\`a[mask] = values\\`\\`.\\n\\nParameters\\n----------\\na : array_like\\n    Target array.\\nmask : array_like\\n    Boolean mask array. It has to be the same shape as \\`a\\`.\\nvalues : array_like\\n    Values to put into \\`a\\` where \\`mask\\` is True. If \\`values\\` is smaller than \\`a\\` it will be repeated.\",\n}\n-/\n\n/-  Changes elements of an array based on conditional and input values.\n\n    This function modifies the target array in-place, setting elements to values\n    from the values array where the corresponding mask element is True.\n    If values is smaller than the target array, it will repeat cyclically.\n\n    Parameters:\n    - a: Target array to modify\n    - mask: Boolean mask array with same shape as a\n    - values: Values to put into a where mask is True\n    - m: Size of values array (must be positive for repetition)\n-/\n\n/-  Specification: putmask changes elements of an array based on conditional and input values.\n\n    This comprehensive specification captures:\n    1. Elements are changed only where mask is True\n    2. Elements are unchanged where mask is False  \n    3. Values are taken from the values array with cyclic repetition\n    4. The values array must be non-empty (m > 0)\n    5. The result has the same size as the input array\n    6. The mask and target array must have the same size\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def putmask {n m : Nat} (a : Vector Float n) (mask : Vector Bool n) (values : Vector Float m) \n    (h : m > 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem putmask_spec {n m : Nat} (a : Vector Float n) (mask : Vector Bool n) (values : Vector Float m) \n    (h : m > 0) :\n    \u2983\u231cm > 0\u231d\u2984\n    putmask a mask values h\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, mask.get i = true \u2192 result.get i = values.get \u27e8i.val % m, Nat.mod_lt i.val h\u27e9) \u2227\n                (\u2200 i : Fin n, mask.get i = false \u2192 result.get i = a.get i) \u2227\n                (\u2200 i : Fin n, mask.get i = true \u2192 \u2203 j : Fin m, result.get i = values.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_r_", "vc-description": "/-  numpy.r_: Translates slice objects to concatenation along the first axis.\n\n    This is a simple way to build up arrays quickly. There are two main use cases:\n    1. If the index expression contains comma separated arrays, then stack them along their first axis\n    2. If the index expression contains slice notation or scalars then create a 1-D array with a range\n\n    This implementation focuses on the first use case - concatenating two 1D arrays along the first axis.\n    The r_ object provides a convenient way to concatenate arrays by using index notation.\n\n    For example, numpy.r_[array1, array2] concatenates array1 and array2.\n-/\n\n/-  Specification: numpy.r_ concatenates arrays along the first axis.\n\n    Precondition: True (no special preconditions for basic concatenation)\n    Postcondition: The result contains all elements from the first array followed by all elements from the second array.\n    This comprehensive specification captures:\n    1. First n elements come from array a (preserving order and values)\n    2. Next m elements come from array b (preserving order and values)\n    3. Total length is n + m (enforced by type system)\n    4. No elements are duplicated or lost (bijective mapping)\n    5. The concatenation preserves all original values exactly\n    6. Order is preserved within each original array\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def r_ {n m : Nat} (a : Vector Float n) (b : Vector Float m) : \n    Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem r__spec {n m : Nat} (a : Vector Float n) (b : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    r_ a b\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get (i.castAdd m) = a.get i) \u2227\n                 (\u2200 j : Fin m, result.get (j.natAdd n) = b.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_ravel_multi_index", "vc-description": "/- \n{\n  \"name\": \"numpy.ravel_multi_index\",\n  \"category\": \"Index generation\",\n  \"description\": \"Converts a tuple of index arrays into an array of flat indices\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ravel_multi_index.html\",\n  \"doc\": \"Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.\\n\\nParameters\\n----------\\nmulti_index : tuple of array_like\\n    A tuple of integer arrays, one array for each dimension.\\ndims : tuple of ints\\n    The shape of array into which the indices from multi_index apply.\\nmode : {'raise', 'wrap', 'clip'}, optional\\n    Specifies how out-of-bounds indices are handled.\\norder : {'C', 'F'}, optional\\n    Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.\\n\\nReturns\\n-------\\nraveled_indices : ndarray\\n    An array of indices into the flattened version of an array of dimensions dims.\",\n}\n-/\n\n/-  Convert 2D multi-indices to flat indices using C-style (row-major) ordering.\n\n    Takes arrays of row and column indices and converts them to flat indices\n    for an array with given dimensions. The conversion uses row-major ordering\n    where flat_index = row_index * cols + col_index.\n\n    The function requires that all indices are within bounds of the specified dimensions.\n-/\n\n/-  Specification: ravel_multi_index converts 2D indices to flat indices using row-major ordering.\n\n    Precondition: All row and column indices must be within bounds\n    Postcondition: Each flat index is computed as row_index * cols + col_index\n\n    Mathematical properties:\n    1. The flat index correctly represents the 2D position in a flattened array\n    2. All resulting indices are within bounds of the flattened array\n    3. The conversion preserves the ordering relationship between multi-indices\n\n    This specification captures the essential behavior of NumPy's ravel_multi_index\n    for the 2D case with C-style ordering. The function maps 2D coordinates to\n    their corresponding positions in a flattened representation of the array.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ravel_multi_index {n : Nat} (row_indices col_indices : Vector Nat n) \n    (rows cols : Nat) \n    (h_rows_valid : \u2200 i : Fin n, row_indices.get i < rows)\n    (h_cols_valid : \u2200 i : Fin n, col_indices.get i < cols) : Id (Vector Nat n) :=\n  sorry", "vc-theorems": "theorem ravel_multi_index_spec {n : Nat} (row_indices col_indices : Vector Nat n) \n    (rows cols : Nat) \n    (h_rows_valid : \u2200 i : Fin n, row_indices.get i < rows)\n    (h_cols_valid : \u2200 i : Fin n, col_indices.get i < cols) :\n    \u2983\u231c\u2200 i : Fin n, row_indices.get i < rows \u2227 col_indices.get i < cols\u231d\u2984\n    ravel_multi_index row_indices col_indices rows cols h_rows_valid h_cols_valid\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = row_indices.get i * cols + col_indices.get i \u2227\n                              result.get i < rows * cols\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_s_", "vc-description": "/- \n{\n  \"name\": \"numpy.s_\",\n  \"category\": \"Advanced indexing\",\n  \"description\": \"A nicer way to build up index tuples for arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.s_.html\",\n  \"doc\": \"A nicer way to build up index tuples for arrays.\\n\\nUse one of the two predefined instances \\`index_exp\\` or \\`s_\\` rather than directly using IndexExpression.\\n\\nFor any index combination, including slicing and axis insertion, \\`\\`a[indices]\\`\\` is the same as \\`\\`a[np.index_exp[indices]]\\`\\` for any array \\`a\\`. However, \\`\\`np.index_exp[indices]\\`\\` can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.\",\n}\n-/\n\n/-  Index expression builder that creates slice objects for array indexing.\n    This is a simplified version of numpy.s_ that creates slice objects\n    for use in array indexing operations. -/\n\n/-  Specification: s_ creates a well-formed slice object\n    This comprehensive specification captures:\n    1. The slice object contains the provided start, stop, and step values\n    2. If step is provided, it must be positive (non-zero)\n    3. If start and stop are both provided, start should be less than or equal to stop\n    4. The resulting slice is valid for array indexing operations\n    5. The slice preserves the ordering constraints (start \u2264 stop when both present)\n    6. The step value, if present, is positive for forward slicing\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A slice object representing a range of indices for array slicing.\n    Contains start, stop, and step parameters for creating slices. -/\nstructure Slice where\n  /-- The starting index of the slice (inclusive). If None, starts from the beginning. -/\n  start : Option Nat\n  /-- The stopping index of the slice (exclusive). If None, goes to the end. -/\n  stop : Option Nat\n  /-- The step size for the slice. If None, defaults to 1. -/\n  step : Option Nat\n  deriving Repr, DecidableEq", "vc-helpers": "", "vc-definitions": "def s_ (start : Option Nat) (stop : Option Nat) (step : Option Nat := none) : Id Slice :=\n  sorry", "vc-theorems": "theorem s_spec (start : Option Nat) (stop : Option Nat) (step : Option Nat := none) :\n    \u2983\u231c(step.isSome \u2192 step.get! > 0) \u2227 \n     ((start.isSome \u2227 stop.isSome) \u2192 start.get! \u2264 stop.get!)\u231d\u2984\n    s_ start stop step\n    \u2983\u21d3slice => \u231cslice.start = start \u2227 \n               slice.stop = stop \u2227 \n               slice.step = step \u2227\n               (slice.step.isSome \u2192 slice.step.get! > 0) \u2227\n               ((slice.start.isSome \u2227 slice.stop.isSome) \u2192 slice.start.get! \u2264 slice.stop.get!)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_select", "vc-description": "/- \n{\n  \"name\": \"numpy.select\",\n  \"category\": \"Basic indexing\",\n  \"description\": \"Return an array drawn from elements in choicelist, depending on conditions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.select.html\",\n  \"doc\": \"Return an array drawn from elements in choicelist, depending on conditions.\\n\\nParameters\\n----------\\ncondlist : list of bool ndarrays\\n    The list of conditions which determine from which array in \\`choicelist\\`\\n    the output elements are taken. When multiple conditions are satisfied,\\n    the first one encountered in \\`condlist\\` is used.\\nchoicelist : list of ndarrays\\n    The list of arrays from which the output elements are taken. It has\\n    to be of the same length as \\`condlist\\`.\\ndefault : scalar, optional\\n    The element inserted in \\`output\\` when all conditions evaluate to False.\\n\\nReturns\\n-------\\noutput : ndarray\\n    The output at position m is the m-th element of the array in\\n    \\`choicelist\\` where the m-th element of the corresponding array in\\n    \\`condlist\\` is True.\",\n}\n-/\n\n/-  numpy.select: Return an array drawn from elements in choicelist, depending on conditions.\n\n    For each element position, returns the element from the first choice array\n    where the corresponding condition is True. If no conditions are True,\n    returns the default value.\n\n    This function enables multi-way conditional selection between arrays.\n-/\n\n/-  Specification: numpy.select performs element-wise multi-conditional selection.\n\n    Precondition: condlist and choicelist have the same length\n    Postcondition: Each element is selected from the first matching choice array,\n                   or default if no conditions match\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def select {n : Nat} {k : Nat} (condlist : Vector (Vector Bool n) k) (choicelist : Vector (Vector Float n) k) (default : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem select_spec {n : Nat} {k : Nat} (condlist : Vector (Vector Bool n) k) (choicelist : Vector (Vector Float n) k) (default : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    select condlist choicelist default\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (\u2203 j : Fin k, (condlist.get j).get i = true \u2227 \n        result.get i = (choicelist.get j).get i \u2227\n        (\u2200 j' : Fin k, j' < j \u2192 (condlist.get j').get i = false)) \u2228\n      (\u2200 j : Fin k, (condlist.get j).get i = false \u2227 result.get i = default)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_take", "vc-description": "/- \n{\n  \"name\": \"numpy.take\",\n  \"category\": \"Basic indexing\",\n  \"description\": \"Take elements from an array along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.take.html\",\n  \"doc\": \"Take elements from an array along an axis.\\n\\nWhen axis is not None, this function does the same thing as \\\"fancy\\\" indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis.\\n\\nParameters\\n----------\\na : array_like (Ni..., M, Nk...)\\n    The source array.\\nindices : array_like (Nj...)\\n    The indices of the values to extract.\\n    Also allow scalars for indices.\\naxis : int, optional\\n    The axis over which to select values. By default, the flattened\\n    input array is used.\\nout : ndarray, optional (Ni..., Nj..., Nk...)\\n    If provided, the result will be placed in this array.\\nmode : {'raise', 'wrap', 'clip'}, optional\\n    Specifies how out-of-bounds indices will behave.\\n\\nReturns\\n-------\\nout : ndarray (Ni..., Nj..., Nk...)\\n    The returned array has the same type as \\`a\\`.\\n\\nExamples\\n--------\\n>>> import numpy as np\\n>>> a = [4, 3, 5, 7, 6, 8]\\n>>> indices = [0, 1, 4]\\n>>> np.take(a, indices)\\narray([4, 3, 6])\",\n}\n-/\n\n/-  Take elements from a source array at specified indices.\n    Given a source array 'arr' and a vector of indices 'indices',\n    returns a new array containing the elements from 'arr' at the positions\n    specified by 'indices'. The indices must be valid positions in the source array.\n\n    This is a simplified 1D version of numpy.take with 'raise' mode,\n    where all indices must be valid (in range [0, n-1]). -/\n\n/-  Specification: take extracts elements from a source array at specified indices.\n\n    Mathematical properties:\n    1. The result has the same length as the indices array\n    2. For each position i in the result, result[i] = arr[indices[i]]\n    3. All indices must be valid (enforced by Fin type)\n    4. The order of elements in the result follows the order of indices\n    5. The same index can appear multiple times, resulting in duplicated elements\n\n    The function implements: result[i] = arr.get (indices.get i)\n\n    This captures the core behavior of numpy.take in 'raise' mode where indices\n    must be in valid range. The use of Fin type ensures type safety and eliminates\n    the need for runtime bounds checking. The result preserves the element type\n    of the source array. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def take {n m : Nat} (arr : Vector Float n) (indices : Vector (Fin n) m) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem take_spec {n m : Nat} (arr : Vector Float n) (indices : Vector (Fin n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    take arr indices\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, result.get i = arr.get (indices.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_trace", "vc-description": "/- \n{\n  \"name\": \"numpy.trace\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Return the sum along diagonals of the array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.trace.html\",\n  \"doc\": \"Return the sum along diagonals of the array.\\n\\nIf \\`a\\` is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements \\`\\`a[i,i+offset]\\`\\` for all i.\\n\\nIf \\`a\\` has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of \\`a\\` with \\`axis1\\` and \\`axis2\\` removed.\\n\\nParameters\\n----------\\na : array_like\\n    Input array, from which the diagonals are taken.\\noffset : int, optional\\n    Offset of the diagonal from the main diagonal. Can be both positive and negative.\\naxis1, axis2 : int, optional\\n    Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken.\\ndtype : dtype, optional\\n    Determines the data-type of the returned array and of the accumulator where the elements are summed.\\nout : ndarray, optional\\n    Array into which the output is placed.\\n\\nReturns\\n-------\\nsum_along_diagonals : ndarray\\n    If \\`a\\` is 2-D, the sum along the diagonal is returned. If \\`a\\` has larger dimensions, then an array of sums along diagonals is returned.\",\n}\n-/\n\n/-  numpy.trace: Return the sum along diagonals of the array.\n\n    For a 2D matrix, computes the sum of elements along the diagonal\n    with an optional offset. For offset=0, it computes the sum of \n    elements a[i,i] for all valid i. For positive offset, it sums\n    a[i,i+offset], and for negative offset, it sums a[i-offset,i].\n\n    This implementation focuses on the 2D case as the core functionality.\n-/\n\n/-  Specification: numpy.trace returns the sum along the diagonal.\n\n    For a 2D matrix with given offset, the trace is the sum of all\n    elements a[i,j] where j = i + offset and both i,j are valid indices.\n\n    Precondition: True\n    Postcondition: Result equals the sum of diagonal elements with given offset\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def trace {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int) : Id Float :=\n  sorry", "vc-theorems": "theorem trace_spec {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    trace a offset\n    \u2983\u21d3result => \u231c\n      -- The result is the sum of all valid diagonal elements with the given offset\n      -- For offset \u2265 0: sum a[i][i+offset] for valid i where i+offset < cols\n      -- For offset < 0: sum a[i-offset][i] for valid i where i-offset \u2265 0\n      (if offset \u2265 0 then\n        -- For non-negative offset: sum elements where row index i and column index i+offset are both valid\n        \u2203 (valid_indices : List (Fin rows \u00d7 Fin cols)),\n          (\u2200 ij \u2208 valid_indices, ij.2.val = ij.1.val + offset.natAbs) \u2227\n          result = valid_indices.foldl (fun acc ij => acc + (a.get ij.1).get ij.2) 0\n      else\n        -- For negative offset: sum elements where row index i+|offset| and column index i are both valid\n        \u2203 (valid_indices : List (Fin rows \u00d7 Fin cols)),\n          (\u2200 ij \u2208 valid_indices, ij.1.val = ij.2.val + offset.natAbs) \u2227\n          result = valid_indices.foldl (fun acc ij => acc + (a.get ij.1).get ij.2) 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_tril", "vc-description": "/- \n{\n  \"name\": \"numpy.tril\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Lower triangle of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.tril.html\",\n  \"doc\": \"Lower triangle of an array.\\n\\nReturn a copy of an array with elements above the \\`k\\`-th diagonal zeroed. For arrays with \\`\\`ndim\\`\\` exceeding 2, \\`tril\\` will apply to the final two axes.\\n\\nParameters\\n----------\\nm : array_like, shape (..., M, N)\\n    Input array.\\nk : int, optional\\n    Diagonal above which to zero elements. \\`k = 0\\` (the default) is the main diagonal, \\`k < 0\\` is below it and \\`k > 0\\` is above.\\n\\nReturns\\n-------\\ntril : ndarray, shape (..., M, N)\\n    Lower triangle of \\`m\\`, of same shape and data-type as \\`m\\`.\",\n}\n-/\n\n/-  numpy.tril: Lower triangle of an array.\n\n    Return a copy of an array with elements above the k-th diagonal zeroed.\n    For simplicity, this specification focuses on square matrices and k=0 (main diagonal).\n\n    Given a flattened square matrix (stored in row-major order), returns a copy\n    where elements above the main diagonal are set to zero.\n\n    This captures the essential mathematical property of extracting the lower\n    triangular part of a matrix.\n-/\n\n/-  Specification: tril returns the lower triangle of a matrix with elements above the main diagonal zeroed.\n\n    Mathematical Properties:\n    1. Shape Preservation: The output has the same shape as the input\n    2. Lower Triangle Preservation: Elements at or below the main diagonal are unchanged\n    3. Upper Triangle Zeroing: Elements above the main diagonal are set to zero\n    4. Diagonal Definition: For a square matrix stored in row-major order,\n       element at position (i,j) corresponds to index i*n + j in the flattened vector\n\n    The main diagonal consists of elements where i = j.\n    Lower triangle consists of elements where i \u2265 j.\n    Upper triangle consists of elements where i < j.\n\n    This specification provides a foundation for formal verification of\n    triangular matrix operations in numerical computing.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tril {n : Nat} (matrix : Vector Float (n * n)) : Id (Vector Float (n * n)) :=\n  sorry", "vc-theorems": "theorem tril_spec {n : Nat} (matrix : Vector Float (n * n)) :\n    \u2983\u231cTrue\u231d\u2984\n    tril matrix\n    \u2983\u21d3result => \u231c\n      -- The result has the same shape as the input\n      result.size = matrix.size \u2227\n      -- For the lower triangle (i \u2265 j), elements are preserved\n      (\u2200 i : Fin n, \u2200 j : Fin n, i.val \u2265 j.val \u2192 \n        \u2203 (hi : i.val * n + j.val < n * n) (hj : i.val * n + j.val < n * n),\n          result.get \u27e8i.val * n + j.val, hi\u27e9 = matrix.get \u27e8i.val * n + j.val, hj\u27e9) \u2227\n      -- For the upper triangle (i < j), elements are zero\n      (\u2200 i : Fin n, \u2200 j : Fin n, i.val < j.val \u2192 \n        \u2203 (hi : i.val * n + j.val < n * n),\n          result.get \u27e8i.val * n + j.val, hi\u27e9 = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_triu", "vc-description": "/- \n{\n  \"name\": \"numpy.triu\",\n  \"category\": \"Diagonal operations\",\n  \"description\": \"Upper triangle of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.triu.html\",\n  \"doc\": \"Upper triangle of an array.\\n\\nReturn a copy of an array with the elements below the \\`k\\`-th diagonal zeroed. For arrays with \\`\\`ndim\\`\\` exceeding 2, \\`triu\\` will apply to the final two axes.\\n\\nParameters\\n----------\\nm : array_like, shape (..., M, N)\\n    Input array.\\nk : int, optional\\n    Diagonal below which to zero elements. \\`k = 0\\` (the default) is the main diagonal, \\`k < 0\\` is below it and \\`k > 0\\` is above.\\n\\nReturns\\n-------\\ntriu : ndarray, shape (..., M, N)\\n    Upper triangle of \\`m\\`, of same shape and data-type as \\`m\\`.\",\n}\n-/\n\n/-  Upper triangle of a matrix. Returns a copy of the matrix with elements below the k-th diagonal zeroed.\n\n    Given a matrix m and an integer k, this function returns a new matrix where:\n    - Elements at position (i,j) where i+k <= j are preserved (upper triangle including k-th diagonal)\n    - Elements at position (i,j) where i+k > j are set to zero (below k-th diagonal)\n\n    The diagonal offset k works as follows:\n    - k = 0: main diagonal (default)\n    - k > 0: diagonal above the main diagonal\n    - k < 0: diagonal below the main diagonal -/\n\n/-  Specification: triu returns the upper triangle of a matrix with elements below the k-th diagonal set to zero.\n\n    Mathematical properties:\n    1. Elements on and above the k-th diagonal are preserved: if i+k <= j, then result[i][j] = m[i][j]\n    2. Elements below the k-th diagonal are zeroed: if i+k > j, then result[i][j] = 0\n    3. The result matrix has the same dimensions as the input matrix\n\n    The k-th diagonal is defined as positions (i,j) where i+k = j:\n    - When k=0: main diagonal (i=j)\n    - When k>0: diagonal above main diagonal \n    - When k<0: diagonal below main diagonal\n\n    This captures the essential behavior of numpy.triu which extracts the upper triangular part\n    of a matrix relative to the k-th diagonal. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def triu {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int) : Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem triu_spec {rows cols : Nat} (m : Vector (Vector Float cols) rows) (k : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    triu m k\n    \u2983\u21d3result => \u231c\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, (i.val : Int) + k \u2264 (j.val : Int) \u2192 \n        (result.get i).get j = (m.get i).get j) \u2227\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, (i.val : Int) + k > (j.val : Int) \u2192 \n        (result.get i).get j = (0 : Float))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_unravel_index", "vc-description": "/- \n{\n  \"name\": \"numpy.unravel_index\",\n  \"category\": \"Index generation\",\n  \"description\": \"Converts a flat index or array of flat indices into a tuple of coordinate arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.unravel_index.html\",\n  \"doc\": \"Converts a flat index or array of flat indices into a tuple of coordinate arrays.\\n\\nParameters\\n----------\\nindices : array_like\\n    An integer array whose elements are indices into the flattened version of an array of dimensions shape.\\nshape : tuple of ints\\n    The shape of the array to use for unraveling indices.\\norder : {'C', 'F'}, optional\\n    Determines whether the indices should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.\\n\\nReturns\\n-------\\nunraveled_coords : tuple of ndarray\\n    Each array in the tuple has the same shape as the indices array.\",\n}\n-/\n\n/-  Converts flat indices into multi-dimensional coordinates for a given shape.\n    This is the inverse operation of ravel_multi_index. -/\n\n/-  Specification: unravel_index converts flat indices to multi-dimensional coordinates\n    such that the coordinates are valid for the given shape and represent the correct\n    positions in the multi-dimensional array. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def unravel_index {n d : Nat} (indices : Vector Nat n) (shape : Vector Nat d) : Id (Vector (Vector Nat d) n) :=\n  sorry", "vc-theorems": "theorem unravel_index_spec {n d : Nat} (indices : Vector Nat n) (shape : Vector Nat d) \n    (h_shape_pos : \u2200 i : Fin d, shape.get i > 0)\n    (h_indices_valid : \u2200 i : Fin n, indices.get i < (shape.toList.foldl (\u00b7 * \u00b7) 1)) :\n    \u2983\u231c(\u2200 i : Fin d, shape.get i > 0) \u2227 (\u2200 i : Fin n, indices.get i < (shape.toList.foldl (\u00b7 * \u00b7) 1))\u231d\u2984\n    unravel_index indices shape\n    \u2983\u21d3coords => \u231c\n      -- Each result has the same size as the number of dimensions\n      (\u2200 i : Fin n, (coords.get i).size = d) \u2227\n      -- Each coordinate is within bounds for its dimension\n      (\u2200 i : Fin n, \u2200 j : Fin d, (coords.get i).get j < shape.get j) \u2227\n      -- Uniqueness: different flat indices produce different coordinates\n      (\u2200 i j : Fin n, i \u2260 j \u2192 indices.get i \u2260 indices.get j \u2192 coords.get i \u2260 coords.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "indexing_slicing_where", "vc-description": "/- \n{\n  \"name\": \"numpy.where\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Return elements chosen from x or y depending on condition\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.where.html\",\n  \"doc\": \"Return elements chosen from \\`x\\` or \\`y\\` depending on \\`condition\\`.\\n\\nParameters\\n----------\\ncondition : array_like, bool\\n    Where True, yield \\`x\\`, otherwise yield \\`y\\`.\\nx, y : array_like\\n    Values from which to choose. \\`x\\`, \\`y\\` and \\`condition\\` need to be broadcastable to some shape.\\n\\nReturns\\n-------\\nout : ndarray\\n    If both \\`x\\` and \\`y\\` are given, the output array contains elements of \\`x\\` where \\`condition\\` is True, and those from \\`y\\` elsewhere.\\n\\nNote\\n----\\nIf only \\`condition\\` is given, return \\`\\`condition.nonzero()\\`\\`.\",\n}\n-/\n\n/-  Return elements chosen from x or y depending on condition.\n    Given vectors of equal length for condition, x, and y, constructs a result vector\n    where each element is selected from x if the corresponding condition is true,\n    otherwise from y.\n\n    This implements the core ternary conditional operation:\n    result[i] = condition[i] ? x[i] : y[i]\n\n    The function requires all three input vectors to have the same length, which\n    is enforced by the type system using Vector types. -/\n\n/-  Specification: where returns elements chosen from x or y based on condition.\n    This captures the essential behavior of numpy.where function:\n\n    Mathematical properties:\n    1. The result has the same length as all input vectors\n    2. For each position i, if condition[i] is true, then result[i] = x[i]\n    3. For each position i, if condition[i] is false, then result[i] = y[i]\n    4. The function is deterministic - same inputs always produce same output\n    5. The result is well-defined for all inputs (no partial functions)\n\n    This specification captures the core ternary conditional semantics:\n    result[i] = if condition.get i then x.get i else y.get i\n\n    The use of Vector types ensures type safety and eliminates the need for\n    size compatibility checks at runtime. All vectors must have the same length\n    by construction. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def \u00abwhere\u00bb {n : Nat} (condition : Vector Bool n) (x y : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem where_spec {n : Nat} (condition : Vector Bool n) (x y : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    \u00abwhere\u00bb condition x y\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = if condition.get i then x.get i else y.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_array2string", "vc-description": "/- \n{\n  \"name\": \"numpy.array2string\",\n  \"category\": \"String formatting\",\n  \"description\": \"Return a string representation of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.array2string.html\",\n  \"doc\": \"Return a string representation of an array\",\n}\n-/\n\n/-  numpy.array2string: Return a string representation of an array\n\n    Converts an array to its string representation with customizable separator.\n    This function provides a way to format arrays for display purposes.\n\n    The separator parameter controls how elements are separated in the output.\n-/\n\n/-  Specification: array2string returns a string representation of the array\n\n    Precondition: True (no special preconditions)\n    Postcondition: result is non-empty string that starts with '[' and ends with ']'\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def array2string {n : Nat} (arr : Vector Float n) (separator : String := \" \") : Id String :=\n  sorry", "vc-theorems": "theorem array2string_spec {n : Nat} (arr : Vector Float n) (separator : String) :\n    \u2983\u231cTrue\u231d\u2984\n    array2string arr separator\n    \u2983\u21d3result => \u231cresult \u2260 \"\" \u2227 result.startsWith \"[\" \u2227 result.endsWith \"]\"\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_array_repr", "vc-description": "/- \n{\n  \"name\": \"numpy.array_repr\",\n  \"category\": \"String formatting\",\n  \"description\": \"Return the string representation of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.array_repr.html\",\n  \"doc\": \"Return the string representation of an array.\\n\\n    Parameters\\n    ----------\\n    arr : ndarray\\n        Input array.\\n    max_line_width : int, optional\\n        Inserts newlines if text is longer than \\`max_line_width\\`.\\n        Defaults to \\`\\`numpy.get_printoptions()['linewidth']\\`\\`.\\n    precision : int, optional\\n        Floating point precision.\\n        Defaults to \\`\\`numpy.get_printoptions()['precision']\\`\\`.\\n    suppress_small : bool, optional\\n        Represent numbers \\\"very close\\\" to zero as zero; d...\",\n}\n-/\n\n/-  Return the string representation of a vector, formatted as \"array([v1, v2, ..., vn])\".\n    This provides a structured string representation that includes the \"array()\" wrapper\n    and properly formatted element values. -/\n\n/-  Specification: array_repr returns a well-formatted string representation of the vector.\n\n    The specification captures:\n    1. Basic format: the string starts with \"array(\" and ends with \")\"\n    2. Element representation: each element is formatted as a string\n    3. Proper bracketing: elements are enclosed in square brackets\n    4. Separator consistency: elements are separated by commas and spaces\n    5. Precision handling: floating point numbers are formatted to specified precision\n    6. Small number suppression: very small numbers can be represented as zero\n    7. Non-emptiness: the result is always a non-empty string\n    8. Structural integrity: the string format is parseable and well-formed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def array_repr {n : Nat} (arr : Vector Float n) (max_line_width : Nat := 75) \n    (precision : Nat := 8) (suppress_small : Bool := false) : Id String :=\n  sorry", "vc-theorems": "theorem array_repr_spec {n : Nat} (arr : Vector Float n) (max_line_width : Nat := 75) \n    (precision : Nat := 8) (suppress_small : Bool := false) :\n    \u2983\u231cprecision > 0 \u2227 max_line_width > 0\u231d\u2984\n    array_repr arr max_line_width precision suppress_small\n    \u2983\u21d3result => \u231c-- Basic format structure: result starts with \"array([\" and ends with \"])\"\n                 result.startsWith \"array([\" \u2227 result.endsWith \"])\" \u2227\n                 -- Non-empty result: string representation is always non-empty\n                 result.length > 0 \u2227\n                 -- Empty array case: should be exactly \"array([])\"\n                 (n = 0 \u2192 result = \"array([])\") \u2227\n                 -- Non-empty array case: should contain comma-separated elements for n > 1\n                 (n > 1 \u2192 result.contains ',') \u2227\n                 -- Single element case: should not contain comma\n                 (n = 1 \u2192 \u00acresult.contains ',') \u2227\n                 -- Structural consistency: result contains expected characters\n                 (\u2200 c : Char, c \u2208 result.data \u2192 (c.isAlpha \u2228 c.isDigit \u2228 c \u2208 ['[', ']', '(', ')', ',', ' ', '.', '-', '+'])) \u2227\n                 -- Precision constraint: reasonable string length bounds\n                 result.length \u2264 max_line_width + 20 \u2227\n                 -- Format correctness: contains proper brackets\n                 (result.contains '(' \u2227 result.contains ')') \u2227\n                 (result.contains '[' \u2227 result.contains ']')\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_array_str", "vc-description": "/- \n{\n  \"name\": \"numpy.array_str\",\n  \"category\": \"String formatting\",\n  \"description\": \"Return a string representation of the data in an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.array_str.html\",\n  \"doc\": \"Return a string representation of the data in an array.\\n\\n    The data in the array is returned as a single string.  This function is\\n    similar to \\`array_repr\\`, the difference being that \\`array_repr\\` also\\n    returns information on the kind of array and its data type.\\n\\n    Parameters\\n    ----------\\n    a : ndarray\\n        Input array.\\n    max_line_width : int, optional\\n        Inserts newlines if text is longer than \\`max_line_width\\`.\\n        Defaults to \\`\\`numpy.get_printoptions()['linewidth']\\`\\`...\",\n}\n-/\n\n/-  Return a string representation of the data in a vector -/\n\n/-  Specification: array_str returns a formatted string representation of the vector data -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_str {n : Nat} (a : Vector Float n) : String :=\n  sorry", "vc-theorems": "theorem array_str_spec {n : Nat} (a : Vector Float n) :\n    -- The result is a non-empty string (always at least \"[]\")\n    (array_str a).length > 0 \u2227\n    -- For empty arrays, the result is exactly \"[]\"\n    (n = 0 \u2192 array_str a = \"[]\") \u2227\n    -- For non-empty arrays, the string starts with '[' and ends with ']'\n    (n > 0 \u2192 (array_str a).front = '[' \u2227 (array_str a).back = ']') \u2227\n    -- The string representation preserves the ordering of elements\n    (n > 0 \u2192 \u2200 i j : Fin n, i < j \u2192 \n      \u2203 pos_i pos_j : Nat, \n        pos_i < pos_j \u2227 \n        pos_i < (array_str a).length \u2227 \n        pos_j < (array_str a).length) := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_fromfile", "vc-description": "/- \n{\n  \"name\": \"numpy.fromfile\",\n  \"category\": \"Binary file I/O\",\n  \"description\": \"Construct an array from data in a text or binary file\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html\",\n  \"doc\": \"Construct an array from data in a text or binary file. A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the tofile method can be read using this function.\",\n}\n-/\n\n/-  Construct a vector from data in a text or binary file\n    Parameters:\n    - file: File handle for the input file\n    - dtype: Data type of the returned array\n    - count: Number of items to read (-1 means entire file)\n    - sep: Separator between items (empty string means binary file)\n    - offset: Byte offset from file's current position (binary files only)\n-/\n\n/-  Specification: fromfile reads data from a file and constructs a vector\n    Properties:\n    1. For binary files (sep = \"\"), reads exactly count items if count > 0\n    2. For text files (sep \u2260 \"\"), parses items separated by sep\n    3. If count = -1, reads all available data\n    4. Binary files respect the offset parameter\n    5. The resulting vector has the correct size and data type\n    6. Data is read sequentially from the file\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- File handle abstraction for I/O operations -/\nstructure FileHandle where\n  /-- Path to the file -/\n  path : String\n  /-- Whether the file is opened in binary mode -/\n  is_binary : Bool\n  /-- Current position in the file (in bytes) -/\n  position : Nat\n  deriving Repr\n\n/-- Represents different data types that can be read from files -/\ninductive DType where\n  /-- 32-bit floating point -/\n  | Float32 : DType\n  /-- 64-bit floating point -/\n  | Float64 : DType\n  /-- 32-bit signed integer -/\n  | Int32 : DType\n  /-- 64-bit signed integer -/\n  | Int64 : DType\n  /-- 8-bit unsigned integer -/\n  | UInt8 : DType\n  deriving Repr, DecidableEq\n\n/-- Get the size in bytes for each data type -/\ndef DType.size_bytes : DType \u2192 Nat\n  | DType.Float32 => 4\n  | DType.Float64 => 8\n  | DType.Int32 => 4\n  | DType.Int64 => 8\n  | DType.UInt8 => 1\n/-- Convert DType to Lean type -/\ndef DType.to_type : DType \u2192 Type\n  | DType.Float32 => Float\n  | DType.Float64 => Float\n  | DType.Int32 => Int\n  | DType.Int64 => Int\n  | DType.UInt8 => Nat  -- Using Nat instead of UInt8 for now", "vc-helpers": "", "vc-definitions": "def fromfile {n : Nat} (file : FileHandle) (dtype : DType) (count : Int) \n    (sep : String) (offset : Nat) : Id (Vector (dtype.to_type) n) :=\n  sorry", "vc-theorems": "theorem fromfile_spec {n : Nat} (file : FileHandle) (dtype : DType) (count : Int) \n    (sep : String) (offset : Nat) \n    (h_count_valid : count = -1 \u2228 count > 0)\n    (h_size_consistency : count = -1 \u2192 n \u2265 0)\n    (h_count_size : count > 0 \u2192 n = count.natAbs) :\n    \u2983\u231c(count = -1 \u2228 count > 0) \u2227 \n      (sep = \"\" \u2192 file.is_binary = true) \u2227\n      (file.is_binary = true \u2192 sep = \"\") \u2227\n      (count > 0 \u2192 n = count.natAbs)\u231d\u2984\n    fromfile (n := n) file dtype count sep offset\n    \u2983\u21d3result => \u231c-- Core property: result has correct size\n                 result.size = n \u2227\n                 -- For binary files, data is read sequentially from offset\n                 (file.is_binary = true \u2192 \n                   \u2203 file_size : Nat,\n                     file_size \u2265 offset + n * dtype.size_bytes \u2227\n                     (\u2200 i : Fin n, \n                       -- Each element is read from the correct byte position\n                       True)) \u2227\n                 -- For text files, data is parsed correctly using separator\n                 (file.is_binary = false \u2227 sep \u2260 \"\" \u2192 \n                   \u2200 i : Fin n, \n                     -- Each element is successfully parsed from text\n                     True) \u2227\n                 -- Sequential reading property: elements maintain file order\n                 (\u2200 i j : Fin n, i.val < j.val \u2192 \n                   -- Element at position i comes before element at position j\n                   True) \u2227\n                 -- Type consistency: all elements are well-typed\n                 (\u2200 i : Fin n, \n                   -- Each element has the correct type for the specified dtype\n                   True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_fromregex", "vc-description": "/- \n{\n  \"name\": \"numpy.fromregex\",\n  \"category\": \"Text file I/O\",\n  \"description\": \"Construct an array from a text file using regular expression parsing\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromregex.html\",\n  \"doc\": \"Construct an array from a text file, using regular expression parsing.\\n\\n    The returned array is always a structured array, and is constructed from\\n    all matches of the regular expression in the file. Groups in the regular\\n    expression are converted to fields of the structured array.\\n\\n    Parameters\\n    ----------\\n    file : file, str, or pathlib.Path\\n        Filename or file object to read.\\n\\n        .. versionchanged:: 1.22.0\\n            Now accepts \\`os.PathLike\\` implementations.\\n\\n    rege...\",\n}\n-/\n\n/-  Construct a structured array from a text file using regular expression parsing -/\n\n/-  Specification: fromregex constructs a structured array from regex matches in file content -/", "vc-preamble": "/-- A simple abstraction for regular expressions -/\nstructure RegExp where\n  /-- The regular expression pattern -/\n  pattern : String\n\n/-- A simple abstraction for structured data types -/\nstructure StructuredDataType where\n  /-- List of field names and their types -/\n  fields : List (String \u00d7 Type)\n\n/-- A simple abstraction for structured array elements -/\nstructure StructuredElement where\n  /-- List of field values as strings -/\n  values : List String", "vc-helpers": "", "vc-definitions": "def fromregex {n : Nat} (file_content : String) (regexp : RegExp) (dtype : StructuredDataType) : Id (Vector StructuredElement n) :=\n  sorry", "vc-theorems": "theorem fromregex_spec {n : Nat} (file_content : String) (regexp : RegExp) (dtype : StructuredDataType) \n    (h_valid_dtype : dtype.fields.length > 0) :\n    -- Precondition: structured data type must have at least one field\n    (dtype.fields.length > 0) \u2192\n    -- Postcondition: result properties after applying fromregex\n    let result := fromregex file_content regexp dtype\n    -- The result size n represents the number of regex matches found\n    (\u2200 i : Fin n, \u2203 se : StructuredElement, result.get i = se \u2227 \n      -- Each structured element has the same number of fields as the dtype\n      se.values.length = dtype.fields.length) \u2227\n    -- Each field value is extracted from the corresponding regex group\n    (\u2200 i : Fin n, \u2200 j : Fin (result.get i).values.length, \n      \u2203 match_group : String, (result.get i).values.get j = match_group) \u2227\n    -- Structured array property: all elements have consistent field structure\n    (\u2200 i j : Fin n, (result.get i).values.length = (result.get j).values.length) \u2227\n    -- Non-empty result requires non-empty input with valid matches\n    (n > 0 \u2192 file_content.length > 0) \u2227\n    -- Pattern matching property: each result corresponds to a successful regex match\n    (\u2200 i : Fin n, \u2203 substring : String, \n      substring.length > 0 \u2227 \n      -- This represents that the regex pattern matches some substring\n      True) := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_fromstring", "vc-description": "/- \n{\n  \"name\": \"numpy.fromstring\",\n  \"category\": \"String I/O\",\n  \"description\": \"A new 1-D array initialized from text data in a string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fromstring.html\",\n  \"doc\": \"A new 1-D array initialized from text data in a string. Deprecated since version 1.14: Passing sep='', the default, is deprecated since it will trigger the deprecated binary mode of this function. This mode interprets string as binary bytes, rather than ASCII text with decimal numbers.\",\n}\n-/\n\n/-  Create a 1-D array from text data in a string.\n    Parses a string containing numeric data separated by a specified separator\n    and returns a vector of the parsed values. -/\n\n/-  Specification: fromstring creates a vector by parsing numeric values from a string.\n    The function parses the input string using the given separator and converts\n    the resulting substrings to floating-point numbers. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fromstring {n : Nat} (input : String) (sep : String) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fromstring_spec {n : Nat} (input : String) (sep : String) \n    (h_valid : (input.splitOn sep).length = n) \n    (h_nonempty : sep \u2260 \"\") :\n    \u2983\u231c(input.splitOn sep).length = n \u2227 sep \u2260 \"\"\u231d\u2984\n    fromstring (n := n) input sep\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n       (input.splitOn sep)[i.val]!.trim \u2260 \"\"\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_genfromtxt", "vc-description": "/- \n{\n  \"name\": \"numpy.genfromtxt\",\n  \"category\": \"Text file I/O\",\n  \"description\": \"Load data from a text file, with missing values handled as specified\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html\",\n  \"doc\": \"Load data from a text file, with missing values handled as specified\",\n}\n-/\n\n/-  Load data from a text file with missing value handling. This is a simplified \n    version focusing on numeric data parsing from delimited text. -/\n\n/-  Specification: genfromtxt parses delimited text data into a matrix structure,\n    handling missing values by filling them with the specified default value.\n    The function skips the specified number of header lines and parses the\n    remaining lines into a structured matrix. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def genfromtxt {rows cols : Nat} (input : Vector String rows) \n    (delimiter : String) (fill_value : Float) (skip_header : Nat) :\n    Id (Vector (Vector Float cols) (rows - skip_header)) :=\n  sorry", "vc-theorems": "theorem genfromtxt_spec {rows cols : Nat} (input : Vector String rows) \n    (delimiter : String) (fill_value : Float) (skip_header : Nat)\n    (h_skip : skip_header < rows)\n    (h_well_formed : \u2200 i : Fin (rows - skip_header), \n      let line_idx : Fin rows := \u27e8i.val + skip_header, by omega\u27e9\n      (input.get line_idx).splitOn delimiter |>.length = cols) :\n    \u2983\u231cskip_header < rows \u2227 \n      \u2200 i : Fin (rows - skip_header), \n        let line_idx : Fin rows := \u27e8i.val + skip_header, by omega\u27e9\n        (input.get line_idx).splitOn delimiter |>.length = cols\u231d\u2984\n    genfromtxt input delimiter fill_value skip_header\n    \u2983\u21d3result => \u231c\n      (result.size = rows - skip_header) \u2227\n      (\u2200 i : Fin (rows - skip_header), \n        (result.get i).size = cols) \u2227\n      (\u2200 i : Fin (rows - skip_header), \u2200 j : Fin cols,\n          let line_idx : Fin rows := \u27e8i.val + skip_header, by omega\u27e9\n          let line := input.get line_idx\n          let fields := line.splitOn delimiter\n          let field_str := if h : j.val < fields.length then fields.get \u27e8j.val, h\u27e9 else \"\"\n          (result.get i).get j = if field_str.isEmpty \u2228 field_str.trim.isEmpty then \n                                   fill_value \n                                 else \n                                   field_str.toNat!.toFloat)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_get_printoptions", "vc-description": "/- \n{\n  \"name\": \"numpy.get_printoptions\",\n  \"category\": \"String formatting\",\n  \"description\": \"Return the current print options\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.get_printoptions.html\",\n  \"doc\": \"Return the current print options.\\n\\n    Returns\\n    -------\\n    print_opts : dict\\n        Dictionary of current print options with keys\\n\\n        - precision : int\\n        - threshold : int\\n        - edgeitems : int\\n        - linewidth : int\\n        - suppress : bool\\n        - nanstr : str\\n        - infstr : str\\n        - sign : str\\n        - formatter : dict of callables\\n        - floatmode : str\\n        - legacy : str or False\\n\\n        For a full description of these options, see \\`set_printoptio...\",\n}\n-/\n\n/-  numpy.get_printoptions: Return the current print options\n\n    Returns a structure containing the current print options that control\n    how arrays are formatted when displayed. These options include precision\n    for floating point numbers, threshold for array summarization, and\n    various string representations.\n\n    This function reads the current state of NumPy's print formatting system.\n-/\n\n/-  Specification: get_printoptions returns a valid PrintOptions structure\n    with sensible default values.\n\n    Precondition: True (no special preconditions)\n    Postcondition: Result contains valid print options with proper constraints\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing NumPy print options -/\nstructure PrintOptions where\n  /-- Number of digits of precision for floating point output -/\n  precision : Nat\n  /-- Total number of array elements which trigger summarization -/\n  threshold : Nat\n  /-- Number of array items in summary at beginning and end -/\n  edgeitems : Nat\n  /-- Number of characters per line for line breaks -/\n  linewidth : Nat\n  /-- Whether to suppress small floating point values -/\n  suppress : Bool\n  /-- String representation of floating point not-a-number -/\n  nanstr : String\n  /-- String representation of floating point infinity -/\n  infstr : String\n  /-- Controls printing of the sign of floating-point types -/\n  sign : String\n  /-- Controls interpretation of precision option -/\n  floatmode : String\n  /-- Legacy printing mode setting -/\n  legacy : Option String", "vc-helpers": "", "vc-definitions": "def get_printoptions : Id PrintOptions :=\n  sorry", "vc-theorems": "theorem get_printoptions_spec :\n    \u2983\u231cTrue\u231d\u2984\n    get_printoptions\n    \u2983\u21d3result => \u231cresult.precision > 0 \u2227 \n                 result.threshold > 0 \u2227 \n                 result.edgeitems > 0 \u2227 \n                 result.linewidth > 0 \u2227\n                 result.nanstr \u2260 \"\" \u2227\n                 result.infstr \u2260 \"\" \u2227\n                 (result.sign = \"-\" \u2228 result.sign = \"+\" \u2228 result.sign = \" \") \u2227\n                 (result.floatmode = \"fixed\" \u2228 result.floatmode = \"unique\" \u2228 \n                  result.floatmode = \"maxprec\" \u2228 result.floatmode = \"maxprec_equal\")\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_load", "vc-description": "/-  numpy.load: Load arrays or pickled objects from .npy, .npz or pickled files.\n\n    Loads array data from a binary file. This operation reads serialized array data\n    from disk storage and reconstructs it as a Vector. The function supports:\n    - .npy files: Single array format\n    - .npz files: Archive format with multiple arrays (simplified to single array here)\n    - Pickled files: Python pickle format (when allow_pickle is True)\n\n    The file parameter represents the path to the file to be loaded.\n    For security reasons, pickled files should be avoided unless explicitly allowed.\n\n    Memory mapping is not considered in this simplified specification.\n-/\n\n/-  Specification: numpy.load returns a vector containing the data from the file.\n\n    This specification captures the essential properties of the load operation:\n\n    1. Data Preservation: The loaded vector contains exactly the data that was stored\n    2. Size Consistency: The vector length matches the stored array dimensions\n    3. Type Compatibility: Data is correctly interpreted as Float values\n    4. Security Constraint: Object arrays are only loaded when explicitly allowed\n\n    Mathematical Properties:\n    - Idempotence: Loading the same file multiple times yields identical results\n    - Determinism: For a given file, load always returns the same vector\n    - Injectivity: Different valid files produce different vectors (when they differ)\n\n    Precondition: The file exists, is readable, and contains valid array data\n    Postcondition: The returned vector faithfully represents the stored data\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def load {n : Nat} (file : String) (allow_pickle : Bool := false) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem load_spec {n : Nat} (file : String) (allow_pickle : Bool := false) \n    (h_file_exists : True) (h_valid_format : True) (h_compatible_size : True) :\n    \u2983\u231cTrue\u231d\u2984\n    load file allow_pickle\n    \u2983\u21d3result => \u231cresult.toArray.size = n \u2227 \n                  (\u2200 i : Fin n, \u2203 (stored_val : Float), result.get i = stored_val) \u2227\n                  (\u2200 (second_load : Vector Float n), \n                    (load file allow_pickle = pure second_load) \u2192 \n                    (\u2200 i : Fin n, result.get i = second_load.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_loadtxt", "vc-description": "/- \n{\n  \"name\": \"numpy.loadtxt\",\n  \"category\": \"Text file I/O\",\n  \"description\": \"Load data from a text file\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html\",\n  \"doc\": \"Load data from a text file.\\n\\n    Parameters\\n    ----------\\n    fname : file, str, pathlib.Path, list of str, generator\\n        File, filename, list, or generator to read.  If the filename\\n        extension is \\`\\`.gz\\`\\` or \\`\\`.bz2\\`\\`, the file is first decompressed. Note\\n        that generators must return bytes or strings. The strings\\n        in a list or produced by a generator are treated as lines.\\n    dtype : data-type, optional\\n        Data-type of the resulting array; default: float.  If this i...\",\n}\n-/\n\n/-  Load data from a text file into a 2D array.\n    For simplicity, this specification focuses on loading a rectangular matrix of floats. -/\n\n/-  Specification: loadtxt reads numeric data from a text file into a well-formed 2D array.\n    The function preserves the structure of the input data and handles parsing correctly. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def loadtxt {rows cols : Nat} (filename : String) (delimiter : String := \" \") \n    (skiprows : Nat := 0) : Id (Vector (Vector Float cols) rows) :=\n  sorry", "vc-theorems": "theorem loadtxt_spec {rows cols : Nat} (filename : String) (delimiter : String := \" \") \n    (skiprows : Nat := 0) \n    (h_rectangular : rows > 0 \u2227 cols > 0) :\n    \u2983\u231crows > 0 \u2227 cols > 0 \u2227 filename.length > 0\u231d\u2984\n    loadtxt filename delimiter skiprows\n    \u2983\u21d3result => \u231c\n      -- Each element is finite (no NaN or infinite values for valid numeric input)\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, (result.get i).get j |>.isFinite) \u2227\n      -- Parsing preserves numeric relationships for well-formed input\n      (\u2200 i : Fin rows, \u2200 j : Fin cols, \n        let val := (result.get i).get j\n        val |>.isFinite \u2192 (val \u2265 -1e308 \u2227 val \u2264 1e308))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_memmap", "vc-description": "/- \n{\n  \"name\": \"numpy.memmap\",\n  \"category\": \"Memory mapping\",\n  \"description\": \"Create a memory-map to an array stored in a binary file on disk\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.memmap.html\",\n  \"doc\": \"Create a memory-map to an array stored in a *binary* file on disk.\\n\\n    Memory-mapped files are used for accessing small segments of large files\\n    on disk, without reading the entire file into memory.  NumPy's\\n    memmap's are array-like objects.  This differs from Python's \\`\\`mmap\\`\\`\\n    module, which uses file-like objects.\\n\\n    This subclass of ndarray has some unpleasant interactions with\\n    some operations, because it doesn't quite fit properly as a subclass.\\n    An alternative to using th...\",\n}\n-/\n\n/-  numpy.memmap: Create a memory-map to an array stored in a binary file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory. The memmap provides\n    an array-like interface to the file contents.\n\n    This function creates a Vector view into a binary file on disk with the\n    specified shape and access mode. The file is accessed starting at the\n    given offset.\n-/\n\n/-  Specification: numpy.memmap creates a memory-mapped view of a file.\n\n    This specification captures the essential properties of memory mapping:\n    1. The result is a valid vector of the specified size\n    2. The mapping respects the file access mode constraints\n    3. The offset is within valid bounds for the file\n    4. Read-only modes preserve data integrity\n    5. Write modes allow modification of the underlying file\n\n    Preconditions:\n    - The filename represents a valid file path\n    - The offset is non-negative and within the file bounds\n    - For WriteNew mode, the file will be created if it doesn't exist\n    - For ReadOnly mode, the file must exist and be readable\n\n    Postconditions:\n    - Returns a vector of the specified size n\n    - The vector provides a view into the file starting at the given offset\n    - Read operations reflect the file contents at the mapped region\n    - Write operations (when mode allows) modify the underlying file\n    - The mapping preserves the mathematical properties of array access\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A simplified representation of file access mode for memory mapping -/\ninductive FileMode\n  | /-- ReadOnly mode ('r') - read-only access to existing file -/\n    ReadOnly\n  | /-- ReadWrite mode ('r+') - read-write access to existing file -/\n    ReadWrite\n  | /-- WriteNew mode ('w+') - create new file with read-write access -/\n    WriteNew\n  | /-- CopyOnWrite mode ('c') - copy-on-write access, changes don't persist to disk -/\n    CopyOnWrite", "vc-helpers": "", "vc-definitions": "def memmap {n : Nat} (filename : String) (mode : FileMode) (offset : Nat) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem memmap_spec {n : Nat} (filename : String) (mode : FileMode) (offset : Nat)\n    (h_valid_file : filename.length > 0)\n    (h_valid_offset : offset \u2265 0) :\n    \u2983\u231cfilename.length > 0 \u2227 offset \u2265 0\u231d\u2984\n    memmap filename mode offset\n    \u2983\u21d3result => \u231c\n      -- Basic properties: result is a valid vector of size n\n      (result.toList.length = n) \u2227\n      -- Access mode constraints\n      (mode = FileMode.ReadOnly \u2192 \n        (\u2200 i : Fin n, \u2203 val : Float, result.get i = val)) \u2227\n      -- Consistency property: repeated access returns same values\n      (\u2200 i : Fin n, result.get i = result.get i) \u2227\n      -- Boundary safety: all indices are valid\n      (\u2200 i : Fin n, i.val < n)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_printoptions", "vc-description": "/-  numpy.printoptions: Context manager for setting print options.\n\n    Creates a context manager that temporarily sets print options and restores\n    the original options afterward. This allows for local formatting changes\n    without affecting global state.\n\n    The context manager returns the current print options that are active\n    within the context.\n-/\n\n/-  Specification: numpy.printoptions creates a context with temporary print options.\n\n    Precondition: Valid print options are provided\n    Postcondition: Returns a context that contains both old and new options,\n                   where the new options are the ones that would be active\n                   within the context\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Print options structure to represent configuration -/\nstructure PrintOptions where\n  /-- Number of digits of precision for floating point output -/\n  precision : Nat\n  /-- Total number of array elements which trigger summarization -/\n  threshold : Nat\n  /-- Number of array items in summary at beginning and end -/\n  edgeitems : Nat\n  /-- Number of characters per line for inserting line breaks -/\n  linewidth : Nat\n  /-- Whether to suppress small floating point values -/\n  suppress : Bool\n  /-- String representation of floating point NaN -/\n  nanstr : String\n  /-- String representation of floating point infinity -/\n  infstr : String\n\n/-- Context manager result representing the temporary state change -/\nstructure PrintOptionsContext where\n  /-- The original print options before the context change -/\n  old_options : PrintOptions\n  /-- The new print options active within the context -/\n  new_options : PrintOptions", "vc-helpers": "", "vc-definitions": "def numpy_printoptions (new_opts : PrintOptions) : Id PrintOptionsContext :=\n  sorry", "vc-theorems": "theorem numpy_printoptions_spec (new_opts : PrintOptions) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_printoptions new_opts\n    \u2983\u21d3context => \u231ccontext.new_options = new_opts \u2227 \n                   context.old_options \u2260 context.new_options\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_save", "vc-description": "/-  numpy.save: Save an array to a binary file in NumPy .npy format.\n\n    Saves Vector data to a binary file in NumPy .npy format. This operation serializes \n    the array data and writes it to disk storage. The function supports:\n    - Automatic .npy extension appending if not present\n    - Binary format writing for efficient storage and loading\n    - Security control via allow_pickle parameter\n\n    The file parameter represents the path where the data should be saved.\n    For security reasons, object arrays with pickled data should be avoided \n    unless explicitly allowed.\n\n    This is a file output operation that creates or overwrites the target file.\n-/\n\n/-  Specification: numpy.save persists vector data to disk in a recoverable format.\n\n    This specification captures the essential properties of the save operation:\n\n    1. Data Persistence: The vector data is written to the specified file\n    2. Format Consistency: Data is saved in .npy format for later loading\n    3. File Creation: The target file is created or overwritten\n    4. Extension Management: .npy extension is added if not present\n    5. Security Control: Object arrays are only saved when explicitly allowed\n\n    Mathematical Properties:\n    - Determinism: Saving the same vector to the same file produces identical results\n    - Completeness: All vector elements are preserved in the saved format\n    - Recoverability: The saved data can be loaded back to reconstruct the original vector\n    - Idempotence: Multiple saves of the same data to the same file yield identical files\n\n    Precondition: The file path is valid and writable\n    Postcondition: The file exists and contains the serialized vector data\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def save {n : Nat} (file : String) (arr : Vector Float n) (allow_pickle : Bool := false) : Id Unit :=\n  sorry", "vc-theorems": "theorem save_spec {n : Nat} (file : String) (arr : Vector Float n) (allow_pickle : Bool := false)\n    (h_valid_path : True) (h_writable : True) :\n    \u2983\u231cTrue\u231d\u2984\n    save file arr allow_pickle\n    \u2983\u21d3result => \u231cresult = () \u2227\n                  (\u2203 (file_content : String), \n                    -- File exists and contains serialized data\n                    True \u2227\n                    -- Data can be recovered (save-load roundtrip property)\n                    (\u2200 (loaded_vec : Vector Float n), \n                      (\u2203 (load_result : Id (Vector Float n)), \n                        load_result = pure loaded_vec) \u2192 \n                        (\u2200 i : Fin n, loaded_vec.get i = arr.get i)) \u2227\n                    -- Filename extension property\n                    (file.endsWith \".npy\" \u2228 (file ++ \".npy\").length > file.length) \u2227\n                    -- Determinism: same input produces same file\n                    (\u2200 (second_save : Unit), \n                      (save file arr allow_pickle = pure second_save) \u2192 \n                      result = second_save))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_savez", "vc-description": "/- \n{\n  \"name\": \"numpy.savez\",\n  \"category\": \"Binary file I/O\",\n  \"description\": \"Save several arrays into a single file in uncompressed .npz format\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.savez.html\",\n  \"doc\": \"Save several arrays into a single file in uncompressed \\`\\`.npz\\`\\` format.\\n\\n    Provide arrays as keyword arguments to store them under the\\n    corresponding name in the output file: \\`\\`savez(fn, x=x, y=y)\\`\\`.\\n\\n    If arrays are specified as positional arguments, i.e., \\`\\`savez(fn,\\n    x, y)\\`\\`, their names will be \\`arr_0\\`, \\`arr_1\\`, etc.\\n\\n    Parameters\\n    ----------\\n    file : file, str, or pathlib.Path\\n        Either the filename (string) or an open file (file-like object)\\n        where the data wil...\",\n}\n-/\n\n/-  numpy.savez: Save several arrays into a single file in uncompressed .npz format.\n\n    Saves multiple Vector arrays to a single .npz archive file. This operation\n    serializes multiple arrays into a single compressed archive, where each array\n    is stored as a separate .npy file within the archive.\n\n    Key functionality:\n    - Multiple arrays can be saved in a single operation\n    - Each array is stored with an associated name within the archive\n    - The resulting .npz file can be loaded later to recover the arrays\n    - Arrays are stored in uncompressed .npy format within the archive\n\n    The function takes a file path and multiple arrays to save. For simplicity,\n    this specification focuses on saving exactly two arrays (commonly used case).\n\n    Security considerations:\n    - Pickle support is controlled by allow_pickle parameter\n    - Invalid file paths or write permissions can cause failures\n    - The archive format ensures data integrity through checksums\n-/\n\n/-  Specification: numpy.savez creates a .npz archive containing multiple arrays.\n\n    This specification captures the essential properties of the savez operation:\n\n    1. Data Persistence: Arrays are written to disk in a retrievable format\n    2. Archive Structure: Multiple arrays are bundled into a single .npz file\n    3. Data Integrity: Saved arrays can be loaded with identical values\n    4. Name Association: Arrays are stored with identifiable names in the archive\n    5. Format Compliance: Output follows .npz format specification\n\n    Mathematical Properties:\n    - Bijection: There exists a one-to-one correspondence between saved and loaded arrays\n    - Preservation: All array values are preserved exactly in the archive\n    - Atomicity: Either all arrays are saved successfully or none are saved\n    - Idempotence: Saving the same arrays multiple times produces identical files\n\n    Security Properties:\n    - Pickle safety: Object arrays are only saved when explicitly allowed\n    - File system safety: Operation respects file system permissions\n\n    Precondition: File path is writable and arrays are valid\n    Postcondition: Archive file exists and contains both arrays with recoverable data\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def savez {n m : Nat} (file : String) (arr1 : Vector Float n) (arr2 : Vector Float m) \n    (allow_pickle : Bool := true) : Id Unit :=\n  sorry", "vc-theorems": "theorem savez_spec {n m : Nat} (file : String) (arr1 : Vector Float n) (arr2 : Vector Float m) \n    (allow_pickle : Bool := true) \n    (h_writable : True) (h_valid_path : True) :\n    \u2983\u231cTrue\u231d\u2984\n    savez file arr1 arr2 allow_pickle\n    \u2983\u21d3result => \u231cresult = () \u2227 \n                  (\u2203 (archive_exists : Bool), archive_exists = true) \u2227\n                  (\u2203 (recoverable_arr1 : Vector Float n), \n                    (\u2200 i : Fin n, recoverable_arr1.get i = arr1.get i)) \u2227\n                  (\u2203 (recoverable_arr2 : Vector Float m), \n                    (\u2200 i : Fin m, recoverable_arr2.get i = arr2.get i)) \u2227\n                  (\u2203 (file_size : Nat), file_size > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_savez_compressed", "vc-description": "/- \n{\n  \"name\": \"numpy.savez_compressed\",\n  \"category\": \"Binary file I/O\",\n  \"description\": \"Save several arrays into a single file in compressed .npz format\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.savez_compressed.html\",\n  \"doc\": \"Save several arrays into a single file in compressed \\`\\`.npz\\`\\` format.\\n\\n    Provide arrays as keyword arguments to store them under the\\n    corresponding name in the output file: \\`\\`savez_compressed(fn, x=x, y=y)\\`\\`.\\n\\n    If arrays are specified as positional arguments, i.e.,\\n    \\`\\`savez_compressed(fn, x, y)\\`\\`, their names will be \\`arr_0\\`, \\`arr_1\\`, etc.\\n\\n    Parameters\\n    ----------\\n    file : file, str, or pathlib.Path\\n        Either the filename (string) or an open file (file-like object)\\n      ...\",\n}\n-/\n\n/-  Save several arrays into a single file in compressed .npz format.\n\n    This function saves multiple arrays to a compressed archive file.\n    Arrays are stored with either provided names or automatic names (arr_0, arr_1, etc.).\n    The resulting file can be loaded back using numpy.load.\n-/\n\n/-  Specification: savez_compressed saves arrays to a compressed archive file.\n\n    The function should:\n    1. Create a compressed .npz file at the specified path\n    2. Store each array in the archive with proper naming\n    3. Ensure the file is readable by compatible loading functions\n    4. Handle filename extension automatically (.npz appended if not present)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def savez_compressed {n : Nat} (filename : String) (arrays : Vector (Vector Float n) n) : Id Unit :=\n  sorry", "vc-theorems": "theorem savez_compressed_spec {n : Nat} (filename : String) (arrays : Vector (Vector Float n) n) \n    (h_valid_path : filename \u2260 \"\") :\n    \u2983\u231cfilename \u2260 \"\"\u231d\u2984\n    savez_compressed filename arrays\n    \u2983\u21d3result => \u231cresult = () \u2227 \n                 -- File creation property: a compressed archive is created\n                 (\u2203 file_created : Bool, file_created = true) \u2227\n                 -- Data preservation: each array is stored with proper naming\n                 (\u2200 i : Fin n, \u2203 array_name : String, \n                   array_name = \"arr_\" ++ toString i.val \u2227\n                   (\u2203 array_stored : Bool, array_stored = true)) \u2227\n                 -- Filename handling: .npz extension is ensured\n                 (\u2203 final_filename : String, \n                   final_filename = filename ++ \".npz\" \u2228 \n                   (filename.endsWith \".npz\" \u2227 final_filename = filename))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "io_operations_set_printoptions", "vc-description": "/- \n{\n  \"name\": \"numpy.set_printoptions\",\n  \"category\": \"String formatting\",\n  \"description\": \"Set printing options\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.set_printoptions.html\",\n  \"doc\": \"Set printing options\",\n}\n-/\n\n/-  numpy.set_printoptions: Set printing options for NumPy arrays\n\n    Sets the global printing options that control how floating point numbers,\n    arrays and other NumPy objects are displayed. This function modifies the\n    global state of NumPy's print formatting system.\n\n    All parameters are optional and only modify the corresponding option if\n    provided. Options not specified retain their current values.\n-/\n\n/-  Specification: set_printoptions correctly updates the global print options\n    according to the provided parameters while validating input constraints.\n\n    Precondition: All optional parameters must satisfy their validation constraints\n    Postcondition: The global print state is updated with the provided options\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing NumPy print options -/\nstructure PrintOptions where\n  /-- Number of digits of precision for floating point output -/\n  precision : Nat\n  /-- Total number of array elements which trigger summarization -/\n  threshold : Nat\n  /-- Number of array items in summary at beginning and end -/\n  edgeitems : Nat\n  /-- Number of characters per line for line breaks -/\n  linewidth : Nat\n  /-- Whether to suppress small floating point values -/\n  suppress : Bool\n  /-- String representation of floating point not-a-number -/\n  nanstr : String\n  /-- String representation of floating point infinity -/\n  infstr : String\n  /-- Controls printing of the sign of floating-point types -/\n  sign : String\n  /-- Controls interpretation of precision option -/\n  floatmode : String\n  /-- Legacy printing mode setting -/\n  legacy : Option String", "vc-helpers": "", "vc-definitions": "def set_printoptions \n    (precision : Option Nat := none)\n    (threshold : Option Nat := none)\n    (edgeitems : Option Nat := none)\n    (linewidth : Option Nat := none)\n    (suppress : Option Bool := none)\n    (nanstr : Option String := none)\n    (infstr : Option String := none)\n    (sign : Option String := none)\n    (floatmode : Option String := none)\n    (legacy : Option String := none) : Id Unit :=\n  sorry", "vc-theorems": "theorem set_printoptions_spec \n    (precision : Option Nat := none)\n    (threshold : Option Nat := none)\n    (edgeitems : Option Nat := none)\n    (linewidth : Option Nat := none)\n    (suppress : Option Bool := none)\n    (nanstr : Option String := none)\n    (infstr : Option String := none)\n    (sign : Option String := none)\n    (floatmode : Option String := none)\n    (legacy : Option String := none)\n    (h_precision : \u2200 p : Nat, precision = some p \u2192 p > 0)\n    (h_threshold : \u2200 t : Nat, threshold = some t \u2192 t > 0)\n    (h_edgeitems : \u2200 e : Nat, edgeitems = some e \u2192 e > 0)\n    (h_linewidth : \u2200 l : Nat, linewidth = some l \u2192 l > 0)\n    (h_nanstr : \u2200 n : String, nanstr = some n \u2192 n \u2260 \"\")\n    (h_infstr : \u2200 i : String, infstr = some i \u2192 i \u2260 \"\")\n    (h_sign : \u2200 s : String, sign = some s \u2192 (s = \"-\" \u2228 s = \"+\" \u2228 s = \" \"))\n    (h_floatmode : \u2200 f : String, floatmode = some f \u2192 \n      (f = \"fixed\" \u2228 f = \"unique\" \u2228 f = \"maxprec\" \u2228 f = \"maxprec_equal\"))\n    (h_legacy : \u2200 l : String, legacy = some l \u2192 \n      (l = \"1.13\" \u2228 l = \"1.21\" \u2228 l = \"1.25\" \u2228 l = \"2.1\" \u2228 l = \"2.2\")) :\n    \u2983\u231c(\u2200 p : Nat, precision = some p \u2192 p > 0) \u2227\n      (\u2200 t : Nat, threshold = some t \u2192 t > 0) \u2227\n      (\u2200 e : Nat, edgeitems = some e \u2192 e > 0) \u2227\n      (\u2200 l : Nat, linewidth = some l \u2192 l > 0) \u2227\n      (\u2200 n : String, nanstr = some n \u2192 n \u2260 \"\") \u2227\n      (\u2200 i : String, infstr = some i \u2192 i \u2260 \"\") \u2227\n      (\u2200 s : String, sign = some s \u2192 (s = \"-\" \u2228 s = \"+\" \u2228 s = \" \")) \u2227\n      (\u2200 f : String, floatmode = some f \u2192 \n        (f = \"fixed\" \u2228 f = \"unique\" \u2228 f = \"maxprec\" \u2228 f = \"maxprec_equal\")) \u2227\n      (\u2200 l : String, legacy = some l \u2192 \n        (l = \"1.13\" \u2228 l = \"1.21\" \u2228 l = \"1.25\" \u2228 l = \"2.1\" \u2228 l = \"2.2\"))\u231d\u2984\n    set_printoptions precision threshold edgeitems linewidth suppress nanstr infstr sign floatmode legacy\n    \u2983\u21d3_ => \u231cTrue\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_LinAlgError", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.LinAlgError\",\n  \"category\": \"Exceptions\",\n  \"description\": \"Generic Python-exception-derived object raised by linalg functions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.LinAlgError.html\",\n  \"doc\": \"Generic Python-exception-derived object raised by linalg functions.\\n\\nGeneral purpose exception class, derived from Python's ValueError class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.\",\n}\n-/\n\n/-  Error checking predicate for linear algebra operations -/\n\n/-  Specification: Linear algebra error detection correctly identifies error conditions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Linear algebra error type representing conditions that prevent correct execution of linalg functions -/\ninductive LinAlgError where\n  /-- Error when numerical algorithm fails to converge -/\n  | NonConvergence : String \u2192 LinAlgError\n  /-- Error when matrix is singular (non-invertible) -/\n  | SingularMatrix : String \u2192 LinAlgError\n  /-- Error when operation requires square matrix but input is not square -/\n  | NonSquareMatrix : String \u2192 LinAlgError\n  /-- Error when matrix dimensions are incompatible for the operation -/\n  | IncompatibleDimensions : String \u2192 LinAlgError\n  /-- Error when input parameters are invalid -/\n  | InvalidInput : String \u2192 LinAlgError\n  /-- Error when numerical computation becomes unstable -/\n  | NumericalInstability : String \u2192 LinAlgError\n  /-- Generic error for other linear algebra failures -/\n  | Other : String \u2192 LinAlgError\n  deriving Repr, DecidableEq", "vc-helpers": "", "vc-definitions": "def checkLinAlgError (condition : Bool) (errorType : String \u2192 LinAlgError) (message : String) : Id (Option LinAlgError) :=\n  if condition then\n    return some (errorType message)\n  else\n    return none", "vc-theorems": "theorem checkLinAlgError_spec (condition : Bool) (errorType : String \u2192 LinAlgError) (message : String) :\n    \u2983\u231cTrue\u231d\u2984\n    checkLinAlgError condition errorType message\n    \u2983\u21d3result => \u231c(condition = true \u2192 result = some (errorType message)) \u2227 \n                  (condition = false \u2192 result = none)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_cond", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.cond\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Compute the condition number of a matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.cond.html\",\n  \"doc\": \"Compute the condition number of a matrix.\\n\\nThe condition number measures how sensitive the solution x is to errors in b for Ax=b.\\n\\nParameters:\\n- x: The matrix\\n- p: Order of the norm\\n\\nReturns:\\n- c: The condition number\",\n}\n-/\n\n/-  \nCompute the condition number of a square matrix using the 2-norm.\n\nThe condition number of a matrix A is defined as ||A|| * ||A^(-1)||,\nwhere ||.|| is the matrix norm. For the 2-norm, this equals the ratio\nof the largest singular value to the smallest singular value.\n\nThe condition number measures how sensitive the solution x is to errors \nin b for the linear system Ax = b. A condition number of 1 indicates\na perfectly conditioned matrix, while large condition numbers indicate\nill-conditioned matrices.\n-/\n\n/-  \nSpecification: The condition number is always non-negative and is at least 1 \nfor any invertible matrix. This captures the fundamental mathematical \nproperties of condition numbers in linear algebra.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def conditionNumber {n : Nat} (x : Vector (Vector Float n) n) : Id Float :=\n  sorry", "vc-theorems": "theorem conditionNumber_spec {n : Nat} (x : Vector (Vector Float n) n) \n    (h_nonempty : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    conditionNumber x\n    \u2983\u21d3result => \u231cresult \u2265 0 \u2227 result \u2265 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_cross", "vc-description": "/-  numpy.linalg.cross: Return the cross product of 3-element vectors.\n\n    Computes the cross product of two 3-element vectors. The cross product\n    of two vectors a and b is a vector perpendicular to both a and b.\n\n    For 3D vectors a = [a\u2080, a\u2081, a\u2082] and b = [b\u2080, b\u2081, b\u2082], the cross product\n    is defined as:\n    a \u00d7 b = [a\u2081b\u2082 - a\u2082b\u2081, a\u2082b\u2080 - a\u2080b\u2082, a\u2080b\u2081 - a\u2081b\u2080]\n\n    This follows the right-hand rule convention.\n-/\n\n/-  Specification: numpy.linalg.cross returns the cross product of two 3D vectors.\n\n    Precondition: True (both vectors must be 3-dimensional, enforced by type)\n\n    Postcondition: The result is a 3D vector where:\n    - result[0] = x1[1] * x2[2] - x1[2] * x2[1]\n    - result[1] = x1[2] * x2[0] - x1[0] * x2[2]  \n    - result[2] = x1[0] * x2[1] - x1[1] * x2[0]\n\n    The cross product has the mathematical property that it is perpendicular\n    to both input vectors (i.e., result \u00b7 x1 = 0 and result \u00b7 x2 = 0).\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_linalg_cross (x1 x2 : Vector Float 3) : Id (Vector Float 3) :=\n  sorry", "vc-theorems": "theorem numpy_linalg_cross_spec (x1 x2 : Vector Float 3) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_linalg_cross x1 x2\n    \u2983\u21d3result => \u231cresult.get 0 = x1.get 1 * x2.get 2 - x1.get 2 * x2.get 1 \u2227\n                result.get 1 = x1.get 2 * x2.get 0 - x1.get 0 * x2.get 2 \u2227\n                result.get 2 = x1.get 0 * x2.get 1 - x1.get 1 * x2.get 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_det", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.det\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Compute the determinant of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.det.html\",\n  \"doc\": \"Compute the determinant of an array.\\n\\nParameters:\\n- a: Input array, must be square\\n\\nReturns:\\n- det: Determinant of a\\n\\nThe determinant is computed via LU decomposition using LAPACK routine _getrf.\",\n}\n-/\n\n/-  Compute the determinant of a square matrix -/\n\n/-  Specification: det computes the determinant of a square matrix.\n    The determinant satisfies fundamental mathematical properties including:\n    - Explicit formulas for small matrices\n    - Multilinear properties\n    - Behavior under elementary row operations -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def det {n : Nat} (a : Vector (Vector Float n) n) : Id Float :=\n  sorry", "vc-theorems": "theorem det_spec {n : Nat} (a : Vector (Vector Float n) n) :\n    \u2983\u231cTrue\u231d\u2984\n    det a\n    \u2983\u21d3result => \u231c\n      -- The determinant of the identity matrix is 1\n      ((\u2200 i j : Fin n, (a.get i).get j = if i = j then 1 else 0) \u2192 result = 1) \u2227\n      -- If a row is all zeros, the determinant is 0\n      ((\u2203 i : Fin n, \u2200 j : Fin n, (a.get i).get j = 0) \u2192 result = 0) \u2227\n      -- If two rows are equal, the determinant is 0\n      ((\u2203 i j : Fin n, i \u2260 j \u2227 (\u2200 k : Fin n, (a.get i).get k = (a.get j).get k)) \u2192 result = 0) \u2227\n      -- For 1x1 matrices, the determinant is the single element\n      ((n = 1) \u2192 \u2203 h : 0 < n, result = (a.get \u27e80, h\u27e9).get \u27e80, h\u27e9) \u2227\n      -- For 2x2 matrices, the determinant is ad - bc\n      ((n = 2) \u2192 \u2203 h : 0 < n, \u2203 h1 : 1 < n, \n        result = (a.get \u27e80, h\u27e9).get \u27e80, h\u27e9 * (a.get \u27e81, h1\u27e9).get \u27e81, h1\u27e9 - \n                 (a.get \u27e80, h\u27e9).get \u27e81, h1\u27e9 * (a.get \u27e81, h1\u27e9).get \u27e80, h\u27e9) \u2227\n      -- For empty matrices (n = 0), the determinant is 1 by convention\n      ((n = 0) \u2192 result = 1) \u2227\n      -- If a column is all zeros, the determinant is 0\n      ((\u2203 j : Fin n, \u2200 i : Fin n, (a.get i).get j = 0) \u2192 result = 0) \u2227\n      -- If two columns are equal, the determinant is 0\n      ((\u2203 j k : Fin n, j \u2260 k \u2227 (\u2200 i : Fin n, (a.get i).get j = (a.get i).get k)) \u2192 result = 0) \u2227\n      -- The determinant is alternating: swapping rows changes sign\n      -- The determinant is linear in each row\n      (True) -- Placeholder for more advanced multilinear properties\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_diagonal", "vc-description": "/-  numpy.linalg.diagonal: Returns specified diagonals of a matrix.\n\n    Extracts the diagonal elements from a matrix. The offset parameter\n    controls which diagonal to extract:\n    - offset = 0: main diagonal (elements at position [i,i])\n    - offset > 0: diagonals above the main diagonal (elements at [i,i+offset])\n    - offset < 0: diagonals below the main diagonal (elements at [i-offset,i])\n\n    For simplicity, we return a vector of size min(m,n) which is valid for offset=0.\n    The actual diagonal length depends on the offset value and matrix dimensions.\n-/\n\n/-  Specification: numpy.linalg.diagonal returns the diagonal elements of a matrix.\n\n    Precondition: The matrix must be non-empty (both dimensions > 0)\n    Postcondition: The result contains the diagonal elements extracted from the matrix.\n                   - For offset = 0: result[i] = x[i][i] (main diagonal)\n                   - The result vector has the same type as the input matrix elements\n                   - The extraction respects the mathematical definition of matrix diagonals\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_diagonal {m n : Nat} (x : Vector (Vector Float n) m) (offset : Int) : Id (Vector Float (min m n)) :=\n  sorry", "vc-theorems": "theorem numpy_diagonal_spec {m n : Nat} (x : Vector (Vector Float n) m) (offset : Int) \n    (h_m : m > 0) (h_n : n > 0) :\n    \u2983\u231cm > 0 \u2227 n > 0\u231d\u2984\n    numpy_diagonal x offset\n    \u2983\u21d3result => \u231c\n      -- Main diagonal case: result[i] = x[i][i] for all valid i\n      (offset = 0 \u2192 \u2200 i : Fin (min m n), \n        result.get i = (x.get \u27e8i.val, Nat.lt_of_lt_of_le i.isLt (Nat.min_le_left m n)\u27e9).get \u27e8i.val, Nat.lt_of_lt_of_le i.isLt (Nat.min_le_right m n)\u27e9) \u2227\n      -- General case: diagonal elements are extracted according to offset\n      -- The function produces a valid diagonal extraction for any offset value\n      (\u2200 i : Fin (min m n), \u2203 r c : Nat, \n        r < m \u2227 c < n \u2227 \n        result.get i = (x.get \u27e8r, sorry\u27e9).get \u27e8c, sorry\u27e9)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_eig", "vc-description": "/-  Compute the eigenvalues and right eigenvectors of a square matrix.\n\n    For a square matrix A, this function computes vectors v and scalars \u03bb such that:\n    A * v = \u03bb * v\n\n    Returns a pair (eigenvalues, eigenvectors) where:\n    - eigenvalues: Vector of eigenvalues \u03bb_i\n    - eigenvectors: Matrix where column i is the eigenvector corresponding to eigenvalue \u03bb_i\n-/\n\n/-  Specification: eig computes the eigenvalues and right eigenvectors of a square matrix.\n\n    The fundamental eigenvalue equation is: A * v = \u03bb * v, where:\n    - A is the input matrix\n    - v is an eigenvector (non-zero vector)\n    - \u03bb is the corresponding eigenvalue\n\n    This specification captures the mathematical properties of eigenvalues and eigenvectors:\n    1. The eigenvalue equation holds for each eigenvalue-eigenvector pair\n    2. Eigenvectors are normalized (unit length) \n    3. For diagonal matrices, eigenvalues are the diagonal elements\n    4. Identity matrix has eigenvalue 1 with multiplicity n\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def eig {n : Nat} (a : Vector (Vector Float n) n) : Id (Vector Float n \u00d7 Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem eig_spec {n : Nat} (a : Vector (Vector Float n) n) :\n    \u2983\u231cTrue\u231d\u2984\n    eig a\n    \u2983\u21d3result => \u231c\n      let eigenvalues := result.1\n      let eigenvectors := result.2\n      -- Main eigenvalue equation: A * v_i = \u03bb_i * v_i for each i\n      (\u2200 i : Fin n, \n        let lambda_i := eigenvalues.get i\n        -- For each row j of the matrix equation A * v_i = \u03bb_i * v_i\n        (\u2200 j : Fin n, \n          -- Sum over columns k of A[j,k] * v_i[k] equals \u03bb_i * v_i[j]\n          (List.sum ((List.range n).map fun k_nat =>\n            (a.get j).get \u27e8k_nat, sorry\u27e9 * \n            (eigenvectors.get \u27e8k_nat, sorry\u27e9).get i)) = \n          lambda_i * (eigenvectors.get j).get i)) \u2227\n      -- For diagonal matrices, eigenvalues are diagonal elements\n      ((\u2200 i j : Fin n, i \u2260 j \u2192 (a.get i).get j = 0) \u2192 \n        (\u2200 i : Fin n, \u2203 j : Fin n, eigenvalues.get j = (a.get i).get i)) \u2227\n      -- Identity matrix has eigenvalue 1 with multiplicity n\n      ((\u2200 i j : Fin n, (a.get i).get j = if i = j then 1 else 0) \u2192 \n        (\u2200 i : Fin n, eigenvalues.get i = 1)) \u2227\n      -- Basic property: eigenvectors are non-zero\n      (\u2200 i : Fin n, \u2203 j : Fin n, (eigenvectors.get j).get i \u2260 0) \u2227\n      -- Eigenvectors are normalized (unit length)\n      (\u2200 i : Fin n, \n        List.sum ((List.range n).map fun k_nat =>\n          let v_k := (eigenvectors.get \u27e8k_nat, sorry\u27e9).get i\n          v_k * v_k) = 1)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_eigh", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.eigh\",\n  \"category\": \"Matrix eigenvalues\",\n  \"description\": \"Return the eigenvalues and eigenvectors of a complex Hermitian or symmetric matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.eigh.html\",\n  \"doc\": \"Return the eigenvalues and eigenvectors of a complex Hermitian (conjugate symmetric) or a real symmetric matrix.\\n\\nParameters:\\n- a: Hermitian or symmetric matrix\\n- UPLO: Whether to use upper or lower triangular part\\n\\nReturns namedtuple with:\\n- eigenvalues: The eigenvalues in ascending order\\n- eigenvectors: The normalized eigenvectors\\n\\nThe eigenvalues are always real.\",\n}\n-/\n\n/-  Compute eigenvalues and eigenvectors of a Hermitian or symmetric matrix -/\n\n/-  Specification: eigh returns eigenvalues and eigenvectors satisfying the eigenvalue equation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Result type for eigenvalue decomposition -/\nstructure EighResult (n : Nat) where\n  /-- The eigenvalues in ascending order -/\n  eigenvalues : Vector Float n\n  /-- The eigenvectors as column vectors -/\n  eigenvectors : Vector (Vector Float n) n", "vc-helpers": "", "vc-definitions": "def eigh {n : Nat} (a : Vector (Vector Float n) n) : Id (EighResult n) :=\n  sorry", "vc-theorems": "theorem eigh_spec {n : Nat} (a : Vector (Vector Float n) n) \n    (h_symmetric : \u2200 i j : Fin n, (a.get i).get j = (a.get j).get i) :\n    \u2983\u231c\u2200 i j : Fin n, (a.get i).get j = (a.get j).get i\u231d\u2984\n    eigh a\n    \u2983\u21d3result => \u231c\n      -- Eigenvalues are sorted in ascending order\n      (\u2200 i j : Fin n, i < j \u2192 result.eigenvalues.get i \u2264 result.eigenvalues.get j) \u2227\n      -- Eigenvectors are orthonormal (dot product properties)\n      (\u2200 i j : Fin n, \n        let v_i := result.eigenvectors.get i\n        let v_j := result.eigenvectors.get j\n        let dot_product := (List.range n).foldl (fun acc k => \n          acc + (v_i.get \u27e8k, by sorry\u27e9) * (v_j.get \u27e8k, by sorry\u27e9)) 0\n        if i = j then dot_product = 1 else dot_product = 0) \u2227\n      -- Fundamental eigenvalue equation: A * v_i = lambda_i * v_i\n      (\u2200 i : Fin n, \n        let lambda_i := result.eigenvalues.get i\n        let v_i := result.eigenvectors.get i\n        \u2200 j : Fin n, \n          let av_j := (List.range n).foldl (fun acc k => \n            acc + (a.get j).get \u27e8k, by sorry\u27e9 * (v_i.get \u27e8k, by sorry\u27e9)) 0\n          av_j = lambda_i * (v_i.get j))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_eigvals", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.eigvals\",\n  \"category\": \"Matrix eigenvalues\",\n  \"description\": \"Compute the eigenvalues of a general matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.eigvals.html\",\n  \"doc\": \"Compute the eigenvalues of a general matrix.\\n\\nMain difference from eig: Does not compute eigenvectors.\\n\\nParameters:\\n- a: Square array\\n\\nReturns:\\n- w: The eigenvalues, not necessarily ordered\",\n}\n-/\n\n/-  Compute the eigenvalues of a general square matrix -/\n\n/-  Specification: eigvals computes eigenvalues of a square matrix -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Matrix represented as a vector of vectors (rows) -/\ndef Matrix (n : Nat) (\u03b1 : Type) : Type := Vector (Vector \u03b1 n) n\n/-- Complex number type for eigenvalues -/\nstructure Complex where\n  re : Float\n  im : Float\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def eigvals {n : Nat} (a : Matrix (n + 1) Float) : Id (Vector Complex (n + 1)) :=\n  sorry", "vc-theorems": "theorem eigvals_spec {n : Nat} (a : Matrix (n + 1) Float) :\n    \u2983\u231cTrue\u231d\u2984\n    eigvals a\n    \u2983\u21d3w => \u231c-- The result contains exactly n+1 eigenvalues (guaranteed by type)\n            -- For diagonal matrices, eigenvalues are the diagonal elements\n            -- This captures the key mathematical property from the numpy documentation\n            (\u2200 i j : Fin (n + 1), i \u2260 j \u2192 (a.get i).get j = 0) \u2192\n            (\u2200 i : Fin (n + 1), \u2203 j : Fin (n + 1), (w.get j).re = (a.get i).get i \u2227 (w.get j).im = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_eigvalsh", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.eigvalsh\",\n  \"category\": \"Matrix eigenvalues\",\n  \"description\": \"Compute the eigenvalues of a complex Hermitian or real symmetric matrix\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.eigvalsh.html\",\n  \"doc\": \"Compute the eigenvalues of a complex Hermitian or real symmetric matrix.\\n\\nMain difference from eigh: Does not compute eigenvectors.\\n\\nParameters:\\n- a: Hermitian or symmetric matrix\\n- UPLO: Use upper or lower triangular part\\n\\nReturns:\\n- w: The eigenvalues in ascending order\",\n}\n-/\n\n/-  Compute the eigenvalues of a real symmetric matrix.\n    Returns eigenvalues in ascending order without computing eigenvectors.\n    This is the eigenvalues-only version of the symmetric eigenvalue problem. -/\n\n/-  Specification: eigvalsh computes eigenvalues of a real symmetric matrix.\n\n    The eigenvalues are real (since the matrix is symmetric) and returned in ascending order.\n    Key mathematical properties:\n    1. The eigenvalues are real for symmetric matrices\n    2. They are returned in ascending order\n    3. The trace equals the sum of eigenvalues\n    4. The determinant equals the product of eigenvalues\n    5. For the identity matrix, all eigenvalues are 1\n    6. For diagonal matrices, eigenvalues are the diagonal elements (sorted)\n    7. Matrix symmetry: a[i][j] = a[j][i] for all i,j -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def eigvalsh {n : Nat} (a : Vector (Vector Float n) n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem eigvalsh_spec {n : Nat} (a : Vector (Vector Float n) n) \n    (h_symm : \u2200 i j : Fin n, (a.get i).get j = (a.get j).get i) :\n    \u2983\u231c\u2200 i j : Fin n, (a.get i).get j = (a.get j).get i\u231d\u2984\n    eigvalsh a\n    \u2983\u21d3eigenvals => \u231c\n      -- Eigenvalues are in ascending order\n      (\u2200 i j : Fin n, i.val < j.val \u2192 eigenvals.get i \u2264 eigenvals.get j) \u2227\n      -- Trace property holds for eigenvalues (sum equals trace)\n      True \u2227\n      -- Identity matrix has all eigenvalues equal to 1\n      ((\u2200 i j : Fin n, (a.get i).get j = if i = j then 1 else 0) \u2192 \n       (\u2200 i : Fin n, eigenvals.get i = 1)) \u2227\n      -- Diagonal matrix eigenvalues are the diagonal elements (sorted)\n      ((\u2200 i j : Fin n, i \u2260 j \u2192 (a.get i).get j = 0) \u2192 \n       (\u2200 i : Fin n, \u2203 j : Fin n, eigenvals.get i = (a.get j).get j)) \u2227\n      -- Zero matrix has all eigenvalues equal to 0\n      ((\u2200 i j : Fin n, (a.get i).get j = 0) \u2192 \n       (\u2200 i : Fin n, eigenvals.get i = 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_lstsq", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.lstsq\",\n  \"category\": \"Solving equations and inverting matrices\",\n  \"description\": \"Return the least-squares solution to a linear matrix equation\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html\",\n  \"doc\": \"Return the least-squares solution to a linear matrix equation.\\n\\nSolves the equation a @ x = b by minimizing ||b - ax||^2.\\n\\nParameters:\\n- a: Coefficient matrix (M, N)\\n- b: Ordinate values (M,) or (M, K)\\n- rcond: Cut-off ratio for small singular values\\n\\nReturns tuple of:\\n- x: Least-squares solution\\n- residuals: Sums of squared residuals\\n- rank: Rank of matrix a\\n- s: Singular values of a\",\n}\n-/\n\n/-  Return the least-squares solution to a linear matrix equation -/\n\n/-  Specification: lstsq returns the solution that minimizes ||b - a*x||^2 -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to compute dot product of two vectors -/\ndef dotProduct {n : Nat} (u v : Vector Float n) : Float := by\n  induction n with\n  | zero => exact 0\n  | succ k ih => \n    exact (u.get \u27e80, Nat.zero_lt_succ k\u27e9) * (v.get \u27e80, Nat.zero_lt_succ k\u27e9) + \n          ih (u.tail) (v.tail)\n/-- Matrix-vector multiplication for Vector types -/\ndef matVecMul {M N : Nat} (A : Vector (Vector Float N) M) (x : Vector Float N) : Vector Float M :=\n  Vector.ofFn fun i => dotProduct (A.get i) x\n/-- Euclidean norm squared of a vector -/\ndef normSq {n : Nat} (v : Vector Float n) : Float :=\n  dotProduct v v\n/-- Vector subtraction -/\ndef vecSub {n : Nat} (a b : Vector Float n) : Vector Float n :=\n  Vector.ofFn fun i => a.get i - b.get i", "vc-helpers": "", "vc-definitions": "def lstsq {M N : Nat} (a : Vector (Vector Float N) M) (b : Vector Float M) : \n    Id (Vector Float N) :=\n  sorry", "vc-theorems": "theorem lstsq_spec {M N : Nat} (a : Vector (Vector Float N) M) (b : Vector Float M) \n    (h_dims : M > 0 \u2227 N > 0) :\n    \u2983\u231cM > 0 \u2227 N > 0\u231d\u2984\n    lstsq a b\n    \u2983\u21d3x => \u231c\u2200 y : Vector Float N, \n           normSq (vecSub b (matVecMul a x)) \u2264 normSq (vecSub b (matVecMul a y))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_matmul", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.matmul\",\n  \"category\": \"Matrix and vector products\",\n  \"description\": \"Matrix product of two arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.matmul.html\",\n  \"doc\": \"Matrix product of two arrays. The behavior depends on the arguments:\\n- If both arguments are 2-D they are multiplied like conventional matrices\\n- If either argument is N-D, N > 2, it is treated as a stack of matrices\\n- If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions\\n- If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions\\n\\nThis is the same as the @ operator.\",\n}\n-/\n\n/-  Matrix multiplication for 2D matrices. \n    Computes the matrix product of two 2D arrays following standard matrix multiplication rules.\n    The result matrix C has dimensions (m x p) where A is (m x n) and B is (n x p). -/\n\n/-  Specification: Matrix multiplication produces a result where each element is the dot product \n    of the corresponding row from the first matrix and column from the second matrix.\n\n    Mathematical properties:\n    1. Dimensions are compatible: A is m\u00d7n, B is n\u00d7p, result is m\u00d7p\n    2. Each element C[i][j] = sum of A[i][k] * B[k][j] for k from 0 to n-1\n    3. The operation preserves the fundamental matrix multiplication identity\n    4. Non-commutativity: A*B \u2260 B*A in general (handled by type system)\n    5. Associativity: (A*B)*C = A*(B*C) when dimensions are compatible -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def matmul {m n p : Nat} (A : Vector (Vector Float n) m) (B : Vector (Vector Float p) n) : \n    Id (Vector (Vector Float p) m) :=\n  sorry", "vc-theorems": "theorem matmul_spec {m n p : Nat} (A : Vector (Vector Float n) m) (B : Vector (Vector Float p) n) :\n    \u2983\u231cTrue\u231d\u2984\n    matmul A B\n    \u2983\u21d3C => \u231c\u2200 i : Fin m, \u2200 j : Fin p, \n              (C.get i).get j = List.sum (List.zipWith (\u00b7 * \u00b7) \n                (A.get i).toList \n                (List.map (fun row => row.get j) B.toList))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_matrix_norm", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.matrix_norm\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Compute matrix norm\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_norm.html\",\n  \"doc\": \"Computes the matrix norm of a matrix.\\n\\nThis function is able to return one of seven different matrix norms, depending on the value of the ord parameter.\",\n}\n-/\n\n/-  Compute matrix norm of a matrix (Frobenius norm by default) -/\n\n/-  Specification: matrix_norm computes the Frobenius norm of a matrix \n    The Frobenius norm is the square root of the sum of squares of all elements.\n\n    Properties:\n    1. Non-negativity: norm is always \u2265 0\n    2. Zero property: norm is 0 iff all elements are 0\n    3. Homogeneity: norm(c*A) = |c| * norm(A) for scalar c\n    4. Triangle inequality: norm(A + B) \u2264 norm(A) + norm(B)\n    5. Submultiplicativity: norm(A) dominates the absolute value of any element\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def matrix_norm {rows cols : Nat} (x : Vector (Vector Float cols) rows) : Id Float :=\n  sorry", "vc-theorems": "theorem matrix_norm_spec {rows cols : Nat} (x : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    matrix_norm x\n    \u2983\u21d3res => \u231cres \u2265 0 \u2227 \n             (res = 0 \u2194 \u2200 i : Fin rows, \u2200 j : Fin cols, (x.get i).get j = 0) \u2227\n             (\u2200 i : Fin rows, \u2200 j : Fin cols, Float.abs ((x.get i).get j) \u2264 res) \u2227\n             (rows > 0 \u2227 cols > 0 \u2192 \n               \u2203 i : Fin rows, \u2203 j : Fin cols, (x.get i).get j \u2260 0 \u2192 res > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_matrix_power", "vc-description": "/-  numpy.linalg.matrix_power: Raise a square matrix to the (integer) power n.\n\n    For positive integers n, the power is computed by repeated matrix squarings and \n    matrix multiplications. If n == 0, the identity matrix is returned. \n    If n < 0, the inverse is computed and raised to abs(n).\n\n    This implements the mathematical operation A^n for square matrices A.\n    The operation follows the standard mathematical definition:\n    - A^0 = I (identity matrix)\n    - A^1 = A\n    - A^n = A * A^(n-1) for n > 1\n    - A^(-n) = (A^(-1))^n for n < 0\n-/\n\n/-  Specification: matrix_power raises a square matrix to an integer power.\n\n    Precondition: The matrix A must be square (n\u00d7n). For negative powers,\n    the matrix must be invertible (non-singular).\n\n    Postcondition: The result satisfies the mathematical definition of matrix exponentiation:\n    1. For exp = 0: result is the identity matrix\n    2. For exp = 1: result equals the input matrix A\n    3. For exp > 1: result = A * A^(exp-1) (recursive definition)\n    4. For exp < 0: result = (A^(-1))^|exp| (inverse raised to absolute value)\n\n    Mathematical properties:\n    - A^0 = I (identity matrix) for any square matrix A\n    - A^1 = A for any square matrix A\n    - A^m * A^n = A^(m+n) for any integers m, n (when A is invertible for negative powers)\n    - (A^m)^n = A^(m*n) for any integers m, n (when A is invertible for negative powers)\n    - If A is invertible, then A^(-1) * A = A * A^(-1) = I\n    - Matrix power preserves the dimension: n\u00d7n input produces n\u00d7n output\n\n    This captures the complete mathematical characterization of matrix exponentiation.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def matrix_power {n : Nat} (A : Vector (Vector Float n) n) (exp : Int) : Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem matrix_power_spec {n : Nat} (A : Vector (Vector Float n) n) (exp : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    matrix_power A exp\n    \u2983\u21d3result => \u231c\n      -- Basic dimension preservation\n      (result.size = n) \u2227\n      (\u2200 i : Fin n, (result.get i).size = n) \u2227\n\n      -- Case 1: exp = 0 yields identity matrix\n      (exp = 0 \u2192 \n        \u2200 i : Fin n, \u2200 j : Fin n, \n        (result.get i).get j = if i = j then 1.0 else 0.0) \u2227\n\n      -- Case 2: exp = 1 yields the original matrix\n      (exp = 1 \u2192 \n        \u2200 i : Fin n, \u2200 j : Fin n, \n        (result.get i).get j = (A.get i).get j) \u2227\n\n      -- Case 3: exp = 2 yields A * A (matrix squared)\n      (exp = 2 \u2192 \n        \u2200 i : Fin n, \u2200 j : Fin n,\n        (result.get i).get j = List.sum (List.ofFn (fun k : Fin n => \n          (A.get i).get k * (A.get k).get j))) \u2227\n\n      -- Mathematical property: A^0 is always the identity matrix\n      (\u2200 i : Fin n, \u2200 j : Fin n, exp = 0 \u2192 \n        (result.get i).get j = if i = j then 1.0 else 0.0) \u2227\n\n      -- Consistency property: the result has the same structure as input\n      (\u2200 i : Fin n, \u2200 j : Fin n, \n        \u2203 val : Float, (result.get i).get j = val) \u2227\n\n      -- Preservation of matrix structure\n      (\u2200 i : Fin n, (result.get i).size = n)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_matrix_rank", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.matrix_rank\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Return matrix rank of array using SVD method\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.matrix_rank.html\",\n  \"doc\": \"Return matrix rank of array using SVD method.\\n\\nRank is the number of singular values greater than a threshold.\\n\\nParameters:\\n- A: Input vector or matrix\\n- tol: Threshold for 'small' singular values\\n- hermitian: If True, A is assumed to be Hermitian\\n\\nReturns:\\n- rank: Rank of matrix\",\n}\n-/\n\n/-  numpy.linalg.matrix_rank: Return matrix rank of array using SVD method.\n\n    The rank of a matrix is the number of linearly independent columns\n    (or rows). For numerical computation, this is determined by counting\n    the number of singular values greater than a threshold.\n\n    This implementation focuses on the core mathematical behavior for\n    square matrices, using default tolerance.\n-/\n\n/-  Specification: matrix_rank computes the rank of a matrix using SVD method.\n\n    The rank is the number of singular values greater than a numerical threshold.\n    This corresponds to the number of linearly independent columns (or rows).\n\n    Mathematical definition:\n    - For a matrix A, rank(A) = number of non-zero singular values\n    - In numerical computation, \"non-zero\" means above a threshold\n\n    Key properties verified:\n    1. Bounds: 0 \u2264 rank(A) \u2264 min(m, n) for m\u00d7n matrix\n    2. Zero matrix: rank(0) = 0 (all elements zero)\n    3. Identity matrix: rank(I) = n for n\u00d7n identity matrix\n    4. Rank deficiency: If a row/column is all zeros, rank < full rank\n    5. Linear dependence: If rows/columns are linearly dependent, rank < full rank\n\n    The threshold behavior ensures numerical stability but is not explicitly\n    specified here for simplicity.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def matrix_rank {m n : Nat} (A : Vector (Vector Float n) m) : Id Nat :=\n  sorry", "vc-theorems": "theorem matrix_rank_spec {m n : Nat} (A : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    matrix_rank A\n    \u2983\u21d3result => \u231c\n      -- Basic bounds: rank is bounded by matrix dimensions\n      result \u2264 min m n \u2227\n      -- Zero matrix has rank 0\n      ((\u2200 i : Fin m, \u2200 j : Fin n, (A.get i).get j = 0) \u2192 result = 0) \u2227\n      -- Identity matrix has full rank (for square matrices)\n      ((m = n) \u2192 \n        (\u2200 i : Fin m, \u2200 j : Fin n, (A.get i).get j = if i.val = j.val then 1 else 0) \u2192 \n        result = n) \u2227\n      -- If any row is all zeros, rank is less than m\n      ((\u2203 i : Fin m, \u2200 j : Fin n, (A.get i).get j = 0) \u2192 result < m) \u2227\n      -- If any column is all zeros, rank is less than n  \n      ((\u2203 j : Fin n, \u2200 i : Fin m, (A.get i).get j = 0) \u2192 result < n) \u2227\n      -- If two rows are identical, rank is less than m (when m > 1)\n      ((m > 1) \u2192 \n        (\u2203 i\u2081 i\u2082 : Fin m, i\u2081 \u2260 i\u2082 \u2227 (\u2200 j : Fin n, (A.get i\u2081).get j = (A.get i\u2082).get j)) \u2192 \n        result < m) \u2227\n      -- If two columns are identical, rank is less than n (when n > 1)\n      ((n > 1) \u2192 \n        (\u2203 j\u2081 j\u2082 : Fin n, j\u2081 \u2260 j\u2082 \u2227 (\u2200 i : Fin m, (A.get i).get j\u2081 = (A.get i).get j\u2082)) \u2192 \n        result < n) \u2227\n      -- For 1\u00d71 matrices, rank is 1 if non-zero, 0 if zero\n      ((m = 1 \u2227 n = 1) \u2192 \n        \u2203 h\u2081 : 0 < m, \u2203 h\u2082 : 0 < n,\n        (result = 1 \u2194 (A.get \u27e80, h\u2081\u27e9).get \u27e80, h\u2082\u27e9 \u2260 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_matrix_transpose", "vc-description": "/-  numpy.linalg.matrix_transpose: Transposes a matrix (or a stack of matrices).\n\n    For a 2D matrix, this operation swaps the rows and columns.\n    The element at position (i, j) in the input matrix becomes the element\n    at position (j, i) in the output matrix.\n\n    Input: A matrix with rows \u00d7 cols dimensions\n    Output: A matrix with cols \u00d7 rows dimensions (transposed)\n-/\n\n/-  Specification: numpy.linalg.matrix_transpose returns the transpose of the input matrix.\n\n    For a matrix x with dimensions rows \u00d7 cols, the transpose x_T has dimensions cols \u00d7 rows.\n    The element at position (i, j) in the original matrix x becomes the element at position (j, i) in x_T.\n\n    Precondition: True (no special preconditions for matrix transpose)\n    Postcondition: For all valid indices i and j, x_T[j][i] = x[i][j]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_matrix_transpose {rows cols : Nat} (x : Vector (Vector Float cols) rows) : Id (Vector (Vector Float rows) cols) :=\n  sorry", "vc-theorems": "theorem numpy_matrix_transpose_spec {rows cols : Nat} (x : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_matrix_transpose x\n    \u2983\u21d3result => \u231c\u2200 i : Fin rows, \u2200 j : Fin cols, (result.get j).get i = (x.get i).get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_multi_dot", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.multi_dot\",\n  \"category\": \"Matrix and vector products\",\n  \"description\": \"Compute the dot product of two or more arrays in a single function call\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.multi_dot.html\",\n  \"doc\": \"Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.\\n\\nmulti_dot chains numpy.dot and uses optimal parenthesization of the matrices. Depending on the shapes of the matrices, this can speed up the multiplication a lot.\\n\\nIf the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.\\n\\nThink of multi_dot as: def multi_dot(arrays): return functools.reduce(np.dot, arrays)\",\n}\n-/\n\n/-  Multi-dot product: compute the dot product of multiple matrices in a single function call\n    with optimal parenthesization. This function performs a chain of matrix multiplications\n    A\u2081 \u00d7 A\u2082 \u00d7 ... \u00d7 A\u2099 where the parenthesization is chosen to minimize computational cost.\n\n    For three matrices A, B, C, this computes A \u00d7 B \u00d7 C with the optimal evaluation order.\n    The result is independent of parenthesization due to associativity of matrix multiplication. -/\n\n/-  Specification: Multi-dot performs a chain of matrix multiplications with optimal parenthesization.\n\n    Mathematical properties:\n    1. Associativity: (A \u00d7 B) \u00d7 C = A \u00d7 (B \u00d7 C) - the result is independent of parenthesization\n    2. Dimension compatibility: A is n\u2081\u00d7n\u2082, B is n\u2082\u00d7n\u2083, C is n\u2083\u00d7n\u2084, result is n\u2081\u00d7n\u2084\n    3. Element-wise computation: result[i][j] equals the triple sum over intermediate indices\n    4. Optimal evaluation order: the implementation chooses the parenthesization that minimizes \n       the total number of scalar multiplications needed\n    5. Correctness: the result equals the sequential application of matrix multiplications\n    6. Non-empty constraint: at least two matrices are required (enforced by signature)\n\n    This specification captures the essential mathematical behavior while abstracting away \n    the optimization details. The key insight is that matrix multiplication is associative,\n    so different parenthesizations yield the same mathematical result. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def multi_dot {n\u2081 n\u2082 n\u2083 n\u2084 : Nat} \n    (A : Vector (Vector Float n\u2082) n\u2081) \n    (B : Vector (Vector Float n\u2083) n\u2082) \n    (C : Vector (Vector Float n\u2084) n\u2083) : \n    Id (Vector (Vector Float n\u2084) n\u2081) :=\n  sorry", "vc-theorems": "theorem multi_dot_spec {n\u2081 n\u2082 n\u2083 n\u2084 : Nat} \n    (A : Vector (Vector Float n\u2082) n\u2081) \n    (B : Vector (Vector Float n\u2083) n\u2082) \n    (C : Vector (Vector Float n\u2084) n\u2083) :\n    \u2983\u231cTrue\u231d\u2984\n    multi_dot A B C\n    \u2983\u21d3result => \u231cresult.toList.length = n\u2081 \u2227 \n                  \u2200 i : Fin n\u2081, (result.get i).toList.length = n\u2084 \u2227\n                  \u2200 i : Fin n\u2081, \u2200 j : Fin n\u2084, \n                    \u2203 matrix_product : Float,\n                    (result.get i).get j = matrix_product \u2227 \n                    matrix_product = List.sum (List.zipWith (\u00b7 * \u00b7) \n                      (A.get i).toList \n                      (List.map (fun row => \n                        List.sum (List.zipWith (\u00b7 * \u00b7) \n                          row.toList \n                          (List.map (fun col => col.get j) C.toList))) \n                        B.toList))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_norm", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.norm\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Matrix or vector norm\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html\",\n  \"doc\": \"Matrix or vector norm.\\n\\nParameters:\\n- x: Input array\\n- ord: Order of the norm (see Notes)\\n- axis: Axis along which to compute norms\\n- keepdims: Keep dimensions for broadcasting\\n\\nCommon ord values:\\n- None: 2-norm (default)\\n- 'fro': Frobenius norm\\n- 'nuc': Nuclear norm\\n- inf: max(abs(x))\\n- -inf: min(abs(x))\\n- 1: max column sum (matrix) or sum(abs(x)) (vector)\\n- 2: largest singular value (matrix) or 2-norm (vector)\",\n}\n-/\n\n/-  numpy.linalg.norm: Compute the 2-norm (Euclidean norm) of a vector.\n\n    This is the default vector norm when ord=None. For a vector x,\n    the 2-norm is defined as: ||x||_2 = sqrt(sum(x[i]^2))\n\n    This implementation focuses on the most common use case: computing\n    the Euclidean norm of a 1D vector.\n-/\n\n/-  Specification: norm computes the Euclidean norm (2-norm) of a vector.\n\n    The 2-norm is defined as the square root of the sum of squares of all elements.\n    This is the most common vector norm used in numerical computing and is the\n    default norm in NumPy when ord=None.\n\n    Mathematical definition:\n    - For a vector x = [x\u2081, x\u2082, ..., x\u2099], the 2-norm is: ||x||\u2082 = \u221a(\u03a3\u1d62 x\u1d62\u00b2)\n\n    Key properties verified:\n    1. Definition: result equals sqrt of sum of squared elements\n    2. Non-negativity: norm(x) \u2265 0 for all x\n    3. Definiteness: norm(x) = 0 if and only if x is the zero vector\n    4. Empty vector: norm of empty vector is 0\n\n    Note: Properties like triangle inequality and homogeneity follow from\n    the definition but are not explicitly stated in this specification.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def norm {n : Nat} (x : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem norm_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    norm x\n    \u2983\u21d3result => \u231cresult = Float.sqrt (List.sum (x.toList.map (fun xi => xi * xi))) \u2227\n                 result \u2265 0 \u2227\n                 (result = 0 \u2194 \u2200 i : Fin n, x.get i = 0) \u2227\n                 (n = 0 \u2192 result = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_outer", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.outer\",\n  \"category\": \"Matrix and vector products\",\n  \"description\": \"Compute the outer product of two vectors\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.outer.html\",\n  \"doc\": \"Computes the outer product of two vectors. Given two vectors a = [a0, a1, ..., aM] and b = [b0, b1, ..., bN], the outer product is: [[a0*b0  a0*b1 ... a0*bN ]\\n [a1*b0  a1*b1 ... a1*bN ]\\n [ ...              ...]\\n [aM*b0  aM*b1 ... aM*bN ]]\",\n}\n-/\n\n/-  Compute the outer product of two vectors.\n    Given vectors a of size m and b of size n, produces an m\u00d7n matrix\n    where element (i,j) equals a[i] * b[j]. -/\n\n/-  Specification: The outer product produces a matrix where each element (i,j)\n    is the product of the i-th element of the first vector and the j-th element\n    of the second vector. This captures the fundamental mathematical property\n    that outer(a,b)[i,j] = a[i] * b[j].\n\n    The specification includes:\n    1. Core property: Each matrix element equals the product of corresponding vector elements\n    2. Row structure: Each row i is the vector b scaled by a[i]\n    3. Column structure: Each column j is the vector a scaled by b[j]\n    4. Bilinearity: The outer product is linear in both arguments\n\n    This captures the essential mathematical behavior of the outer product operation,\n    which is fundamental in linear algebra and tensor analysis. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def outer {m n : Nat} [Mul \u03b1] (a : Vector \u03b1 m) (b : Vector \u03b1 n) : Id (Vector (Vector \u03b1 n) m) :=\n  sorry", "vc-theorems": "theorem outer_spec {m n : Nat} [Mul \u03b1] (a : Vector \u03b1 m) (b : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    outer a b\n    \u2983\u21d3result => \u231c\n      -- Core property: Each matrix element is the product of corresponding vector elements\n      -- This captures the fundamental definition of outer product: (a \u2297 b)[i,j] = a[i] * b[j]\n      \u2200 (i : Fin m) (j : Fin n), (result.get i).get j = a.get i * b.get j\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_pinv", "vc-description": "/-  numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.\n\n    Calculate the generalized inverse of a matrix using its\n    singular-value decomposition (SVD) and including all\n    large singular values.\n\n    For a matrix A, the pseudo-inverse A+ is defined as the matrix that\n    'solves' the least-squares problem Ax = b. If A is invertible,\n    then pinv(A) == inv(A).\n\n    The pseudo-inverse has the property that A * A+ * A = A and\n    A+ * A * A+ = A+ (Moore-Penrose conditions).\n-/\n\n/-  Specification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.\n\n    The pseudo-inverse satisfies the fundamental Moore-Penrose conditions:\n    1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)\n    2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)\n    3. (A * A+)\u2020 = A * A+  (A * A+ is Hermitian)\n    4. (A+ * A)\u2020 = A+ * A  (A+ * A is Hermitian)\n\n    For practical purposes, we focus on the first two conditions and\n    the dimensional correctness.\n\n    Precondition: True (pinv is defined for any matrix)\n    Postcondition: The result is the pseudo-inverse with correct dimensions\n    and satisfies the Moore-Penrose conditions.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def pinv {m n : Nat} (a : Vector (Vector Float n) m) : Id (Vector (Vector Float m) n) :=\n  sorry", "vc-theorems": "theorem pinv_spec {m n : Nat} (a : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    pinv a\n    \u2983\u21d3a_pinv => \u231c\n      -- Sanity check: All elements are finite (no NaN or infinity)\n      (\u2200 i : Fin n, \u2200 j : Fin m, Float.isFinite ((a_pinv.get i).get j)) \u2227\n      -- Boundedness property: pseudo-inverse elements should be bounded\n      (\u2200 i : Fin n, \u2200 j : Fin m, Float.abs ((a_pinv.get i).get j) \u2264 1000.0) \u2227\n      -- Zero matrix property: pinv(0) = 0\n      ((\u2200 i : Fin m, \u2200 j : Fin n, (a.get i).get j = 0.0) \u2192 \n       (\u2200 i : Fin n, \u2200 j : Fin m, (a_pinv.get i).get j = 0.0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_slogdet", "vc-description": "/-  Compute the sign and (natural) logarithm of the determinant of a square matrix.\n\n    This function is more numerically stable than computing log(det(a)) directly,\n    especially for very small or very large determinants.\n\n    For real matrices, the sign is -1, 0, or 1.\n    For complex matrices, the sign has absolute value 1 (on the unit circle) or 0.\n\n    The determinant can be recovered as: det = sign * exp(logabsdet)\n-/\n\n/-  Specification: slogdet computes the sign and natural logarithm of the determinant\n\n    The function returns a tuple (sign, logabsdet) where:\n    - sign is -1, 0, or 1 for real matrices\n    - logabsdet is the natural log of the absolute value of the determinant\n    - The original determinant can be recovered as: det = sign * exp(logabsdet)\n    - The function provides a numerically stable way to compute logarithms of determinants\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def slogdet {n : Nat} (a : Vector (Vector Float n) n) : Id (Float \u00d7 Float) :=\n  sorry", "vc-theorems": "theorem slogdet_spec {n : Nat} (a : Vector (Vector Float n) n) :\n    \u2983\u231cTrue\u231d\u2984\n    slogdet a\n    \u2983\u21d3result => \u231c\n      let (sign, logabsdet) := result\n      -- Sign is constrained to -1, 0, or 1 for real matrices\n      (sign = -1 \u2228 sign = 0 \u2228 sign = 1) \u2227\n      -- Sign magnitude is at most 1\n      Float.abs sign \u2264 1 \u2227\n      -- For identity matrix: sign = 1, logabsdet = 0 (since det(I) = 1, log(1) = 0)\n      ((\u2200 i j : Fin n, (a.get i).get j = if i = j then 1 else 0) \u2192 \n        sign = 1 \u2227 logabsdet = 0) \u2227\n      -- For matrix with zero row: sign = 0 (since det = 0)\n      ((\u2203 i : Fin n, \u2200 j : Fin n, (a.get i).get j = 0) \u2192 sign = 0) \u2227\n      -- For matrix with zero column: sign = 0 (since det = 0)  \n      ((\u2203 j : Fin n, \u2200 i : Fin n, (a.get i).get j = 0) \u2192 sign = 0) \u2227\n      -- For 1x1 matrices: sign corresponds to element sign, logabsdet = log(|element|)\n      ((n = 1) \u2192 \u2203 h : 0 < n, \n        let element := (a.get \u27e80, h\u27e9).get \u27e80, h\u27e9\n        (element > 0 \u2192 sign = 1 \u2227 logabsdet = Float.log element) \u2227\n        (element < 0 \u2192 sign = -1 \u2227 logabsdet = Float.log (-element)) \u2227\n        (element = 0 \u2192 sign = 0)) \u2227\n      -- For 2x2 matrices: explicit determinant formula\n      ((n = 2) \u2192 \u2203 h : 0 < n, \u2203 h1 : 1 < n,\n        let det_val := (a.get \u27e80, h\u27e9).get \u27e80, h\u27e9 * (a.get \u27e81, h1\u27e9).get \u27e81, h1\u27e9 - \n                       (a.get \u27e80, h\u27e9).get \u27e81, h1\u27e9 * (a.get \u27e81, h1\u27e9).get \u27e80, h\u27e9\n        (det_val > 0 \u2192 sign = 1 \u2227 logabsdet = Float.log det_val) \u2227\n        (det_val < 0 \u2192 sign = -1 \u2227 logabsdet = Float.log (-det_val)) \u2227\n        (det_val = 0 \u2192 sign = 0)) \u2227\n      -- General stability property: logabsdet is finite when determinant is non-zero\n      (sign \u2260 0 \u2192 Float.isFinite logabsdet)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_solve", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.solve\",\n  \"category\": \"Solving equations and inverting matrices\",\n  \"description\": \"Solve a linear matrix equation, or system of linear scalar equations\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html\",\n  \"doc\": \"Solve a linear matrix equation, or system of linear scalar equations.\\n\\nComputes the 'exact' solution, x, of the well-determined, full rank linear matrix equation ax = b.\\n\\nParameters:\\n- a: Coefficient matrix, shape (M, M)\\n- b: Ordinate values, shape (M,) or (M, K)\\n\\nReturns:\\n- x: Solution to the system ax = b. Shape matches b.\",\n}\n-/\n\n/-  \nSolve a linear matrix equation ax = b, where a is an n\u00d7n matrix and b is a vector.\nReturns the solution vector x such that ax = b.\nFor non-empty matrices (n > 0), the solution exists and is unique when a is invertible.\n-/\n\n/-  \nSpecification: solve returns a vector x such that ax = b when a is invertible.\nThis specification captures the mathematical properties of linear system solving:\n\n1. **Correctness**: The solution satisfies the matrix equation ax = b\n2. **Invertibility requirement**: Matrix a must be invertible (non-singular)\n3. **Uniqueness**: The solution is unique when it exists\n4. **Mathematical consistency**: The solution preserves linear algebra properties\n\nThe specification handles the general case where:\n- a is an n\u00d7n square matrix (represented as Vector of Vector Float)\n- b is an n-dimensional vector\n- The solution x is unique when a is invertible\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def solve {n : Nat} (a : Vector (Vector Float n) n) (b : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem solve_spec {n : Nat} (a : Vector (Vector Float n) n) (b : Vector Float n) \n    (h_invertible : \u2203 a_inv : Vector (Vector Float n) n, \n      -- Matrix multiplication: a * a_inv = I (identity matrix)\n      (\u2200 i j : Fin n, \n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a.get i).get k * (a_inv.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0) \u2227\n      -- Matrix multiplication: a_inv * a = I (identity matrix)  \n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a_inv.get i).get k * (a.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0)) :\n    \u2983\u231c\u2203 a_inv : Vector (Vector Float n) n, \n      (\u2200 i j : Fin n, \n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a.get i).get k * (a_inv.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0) \u2227\n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a_inv.get i).get k * (a.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0)\u231d\u2984\n    solve a b\n    \u2983\u21d3x => \u231c-- Primary property: The solution satisfies ax = b\n            (\u2200 i : Fin n, \n              List.sum (List.ofFn fun j : Fin n => \n                (a.get i).get j * x.get j) = b.get i) \u2227\n            -- Uniqueness: The solution is unique (if y also satisfies ay = b, then y = x)\n            (\u2200 y : Vector Float n, \n              (\u2200 i : Fin n,\n                List.sum (List.ofFn fun j : Fin n => \n                  (a.get i).get j * y.get j) = b.get i) \u2192 \n              y = x) \u2227\n            -- Mathematical consistency: The solution can be expressed as x = a^(-1)b\n            (\u2200 a_inv : Vector (Vector Float n) n,\n              (\u2200 i j : Fin n, \n                let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n                  (a.get i).get k * (a_inv.get k).get j)\n                matrix_mult_ij = if i = j then 1.0 else 0.0) \u2192\n              (\u2200 i : Fin n,\n                x.get i = List.sum (List.ofFn fun j : Fin n => \n                  (a_inv.get i).get j * b.get j)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_svd", "vc-description": "/-  numpy.linalg.svd: Singular Value Decomposition.\n\n    Computes the singular value decomposition of a matrix, factorizing it as\n    A = U @ diag(S) @ Vh, where U and Vh are unitary matrices and S is a \n    vector of singular values sorted in descending order.\n\n    This specification focuses on the 2D case with full_matrices=False\n    and compute_uv=True (the most common use case).\n\n    The decomposition satisfies: A = U @ diag(S) @ Vh\n    where U has orthonormal columns, Vh has orthonormal rows,\n    and S contains non-negative singular values in descending order.\n-/\n\n/-  Specification: numpy.linalg.svd returns matrices U, S, Vh such that:\n\n    1. Matrix reconstruction: A = U @ diag(S) @ Vh\n    2. U has orthonormal columns (U^T @ U = I)\n    3. Vh has orthonormal rows (Vh @ Vh^T = I)  \n    4. S contains non-negative singular values in descending order\n\n    This captures the essential mathematical properties of SVD as implemented in NumPy.\n\n    Precondition: True (SVD is defined for any real matrix)\n    Postcondition: The returned decomposition satisfies all SVD properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_svd {m n : Nat} (a : Vector (Vector Float n) m) : \n    Id (Vector (Vector Float (min m n)) m \u00d7 Vector Float (min m n) \u00d7 Vector (Vector Float n) (min m n)) :=\n  sorry", "vc-theorems": "theorem numpy_svd_spec {m n : Nat} (a : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_svd a\n    \u2983\u21d3result => \u231clet (u, s, vh) := result;\n                 -- Property 1: Matrix reconstruction A = U @ diag(S) @ Vh\n                 (\u2200 i : Fin m, \u2200 j : Fin n,\n                   (a.get i).get j = \n                   List.sum (List.map (fun k : Fin (min m n) =>\n                     (u.get i).get k * s.get k * (vh.get k).get j) \n                     (List.finRange (min m n)))) \u2227\n                 -- Property 2: U has orthonormal columns (U^T @ U = I)\n                 (\u2200 i j : Fin (min m n),\n                   List.sum (List.map (fun k : Fin m =>\n                     (u.get k).get i * (u.get k).get j) \n                     (List.finRange m)) = \n                   if i = j then 1.0 else 0.0) \u2227\n                 -- Property 3: Vh has orthonormal rows (Vh @ Vh^T = I)\n                 (\u2200 i j : Fin (min m n),\n                   List.sum (List.map (fun k : Fin n =>\n                     (vh.get i).get k * (vh.get j).get k) \n                     (List.finRange n)) = \n                   if i = j then 1.0 else 0.0) \u2227\n                 -- Property 4: Singular values are non-negative and sorted descending\n                 (\u2200 i : Fin (min m n), s.get i \u2265 0) \u2227\n                 (\u2200 i : Fin (min m n), \n                   \u2200 h : i.val + 1 < min m n,\n                   s.get i \u2265 s.get \u27e8i.val + 1, h\u27e9)\n                 \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_svdvals", "vc-description": "/-  numpy.linalg.svdvals: Compute singular values of a matrix.\n\n    Computes the singular values of a matrix without computing the U and V matrices.\n    The singular values are the square roots of the eigenvalues of A^T @ A (or A @ A^T),\n    returned in descending order.\n\n    This is equivalent to calling numpy.linalg.svd(x, compute_uv=False).\n    For an m\u00d7n matrix, this returns min(m,n) singular values.\n-/\n\n/-  Specification: svdvals returns the singular values of the input matrix.\n\n    The singular values are:\n    1. Non-negative real numbers\n    2. Sorted in descending order\n    3. Square roots of eigenvalues of x^T @ x\n    4. Measure the \"magnitude\" of the matrix in each singular direction\n\n    Precondition: True (singular values are defined for any matrix)\n    Postcondition: Returns singular values in descending order with mathematical properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def svdvals {m n : Nat} (x : Vector (Vector Float n) m) : Id (Vector Float (min m n)) :=\n  sorry", "vc-theorems": "theorem svdvals_spec {m n : Nat} (x : Vector (Vector Float n) m) :\n    \u2983\u231cTrue\u231d\u2984\n    svdvals x\n    \u2983\u21d3result => \u231c-- Property 1: All singular values are non-negative\n                 (\u2200 i : Fin (min m n), result.get i \u2265 0) \u2227\n                 -- Property 2: Singular values are sorted in descending order\n                 (\u2200 i j : Fin (min m n), i.val \u2264 j.val \u2192 result.get i \u2265 result.get j) \u2227\n                 -- Property 3: Singular values are bounded by the Frobenius norm\n                 (\u2200 i : Fin (min m n),\n                   result.get i \u2264 \n                   Float.sqrt (List.sum (List.map (fun row : Fin m =>\n                     List.sum (List.map (fun col : Fin n =>\n                       (x.get row).get col * (x.get row).get col) (List.finRange n)))\n                     (List.finRange m)))) \u2227\n                 -- Property 4: If the matrix is zero, all singular values are zero\n                 ((\u2200 i : Fin m, \u2200 j : Fin n, (x.get i).get j = 0) \u2192\n                   (\u2200 i : Fin (min m n), result.get i = 0)) \u2227\n                 -- Property 5: The sum of squares of singular values equals the Frobenius norm squared\n                 (List.sum (List.map (fun i : Fin (min m n) => \n                   result.get i * result.get i) (List.finRange (min m n))) \u2264\n                 List.sum (List.map (fun row : Fin m =>\n                   List.sum (List.map (fun col : Fin n =>\n                     (x.get row).get col * (x.get row).get col) (List.finRange n)))\n                   (List.finRange m)))\n                 \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_tensordot", "vc-description": "/-  numpy.tensordot: Compute tensor dot product along specified axes.\n\n    Given two tensors a and b, and axes, sums the products of a's and b's \n    elements over the axes specified. For 1-D arrays (vectors) with axes=1,\n    this computes the inner product of vectors.\n\n    This specification focuses on the 1-D case with axes=1, which is equivalent\n    to the dot product operation.\n-/\n\n/-  Specification: tensordot computes the tensor dot product along specified axes.\n\n    For 1-D vectors with axes=1, this is equivalent to the inner product:\n    result = sum(a[i] * b[i] for i in 0..n-1)\n\n    Mathematical properties:\n    - Commutative: tensordot(a, b, 1) = tensordot(b, a, 1)\n    - Bilinear: tensordot(\u03b1*a + \u03b2*c, b, 1) = \u03b1*tensordot(a, b, 1) + \u03b2*tensordot(c, b, 1)\n    - Zero vector: tensordot(zeros, b, 1) = 0\n    - Self-product: tensordot(a, a, 1) = ||a||\u00b2\n\n    Precondition: axes = 1 (for 1-D vector case)\n    Postcondition: result equals the sum of element-wise products\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tensordot {n : Nat} (a b : Vector Float n) (axes : Nat) : Id Float :=\n  sorry", "vc-theorems": "theorem tensordot_spec {n : Nat} (a b : Vector Float n) (axes : Nat) \n    (h_axes : axes = 1) :\n    \u2983\u231caxes = 1\u231d\u2984\n    tensordot a b axes\n    \u2983\u21d3result => \u231cresult = List.sum (List.zipWith (\u00b7 * \u00b7) a.toList b.toList)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_tensorinv", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.tensorinv\",\n  \"category\": \"Solving equations and inverting matrices\",\n  \"description\": \"Compute the 'inverse' of an N-dimensional array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.tensorinv.html\",\n  \"doc\": \"Compute the 'inverse' of an N-dimensional array.\\n\\nThe result is an inverse for a relative to the tensordot operation tensordot(a, b, ind), i.e., up to floating-point accuracy, tensordot(tensorinv(a), a, ind) is the identity tensor.\",\n}\n-/\n\n/-  Compute the 'inverse' of an N-dimensional array.\n    For simplicity, we implement the case where the tensor is represented as a 2D matrix\n    (viewed as a flattened N-dimensional array) and we compute its matrix inverse.\n    The result should be the inverse for the tensordot operation. -/\n\n/-  Specification: tensorinv computes the tensor inverse such that when composed\n    with the original tensor via tensordot operation, it yields the identity tensor.\n    The key properties are:\n    1. The result has the same square dimensions as the input\n    2. The tensor inverse, when applied via tensordot, acts as a left inverse\n    3. The tensor must be 'square' (equal first and last dimensions products)\n    4. The index parameter must be positive -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tensorinv {n : Nat} (a : Vector (Vector Float n) n) (ind : Nat) \n    (h_square : n > 0) (h_ind : ind > 0) : Id (Vector (Vector Float n) n) :=\n  sorry", "vc-theorems": "theorem tensorinv_spec {n : Nat} (a : Vector (Vector Float n) n) (ind : Nat) \n    (h_square : n > 0) (h_ind : ind > 0) \n    (h_invertible : \u2200 i j : Fin n, \u2203 det : Float, det \u2260 0) :\n    \u2983\u231cn > 0 \u2227 ind > 0\u231d\u2984\n    tensorinv a ind h_square h_ind\n    \u2983\u21d3result => \u231c\n      -- The result has the same dimensions as the input (simplified case)\n      result.size = n \u2227 \n      (\u2200 i : Fin n, (result.get i).size = n) \u2227\n      -- The tensor inverse property: when composed with original tensor,\n      -- it should yield an identity-like behavior\n      (\u2200 i j : Fin n, \u2203 identity_val : Float, \n        (if i = j then identity_val = 1.0 else identity_val = 0.0) \u2227\n        -- This represents the mathematical property that tensorinv(a) * a \u2248 I\n        Float.abs (((result.get i).get j) - identity_val) < 1e-10)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_tensorsolve", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.tensorsolve\",\n  \"category\": \"Solving equations and inverting matrices\",\n  \"description\": \"Solve the tensor equation a x = b for x\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.tensorsolve.html\",\n  \"doc\": \"Solve the tensor equation a x = b for x.\\n\\nIt is assumed that all indices of x are summed over in the product, and the dimensions of a are rearranged such that a is reshaped to a 2D matrix.\",\n}\n-/\n\n/-  \nSolve the tensor equation a x = b for x.\n\nThis function solves for x in the tensor equation a x = b, where:\n- a is a coefficient tensor that can be reshaped to a square matrix\n- b is the right-hand tensor  \n- x is the solution tensor\n\nFor simplicity, we model this as solving a square linear system where the \ncoefficient matrix a is reshaped from tensor form to a 2D matrix, and the \nsolution is reshaped back to tensor form.\n-/\n\n/-  \nSpecification: tensorsolve solves the tensor equation a x = b for x.\n\nThis specification captures the mathematical properties of tensor equation solving:\n\n1. **Correctness**: The solution x satisfies the matrix equation a x = b\n2. **Invertibility**: The coefficient matrix a must be invertible\n3. **Uniqueness**: The solution is unique when a is invertible\n\nThe specification handles the basic case where:\n- a is an n\u00d7n coefficient matrix (representing a reshaped tensor)\n- b is an n-dimensional right-hand vector\n- x is the n-dimensional solution vector\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tensorsolve {n : Nat} (a : Vector (Vector Float n) n) (b : Vector Float n) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem tensorsolve_spec {n : Nat} (a : Vector (Vector Float n) n) (b : Vector Float n)\n    (h_invertible : \u2203 a_inv : Vector (Vector Float n) n,\n      -- Matrix a is invertible (has an inverse)\n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a.get i).get k * (a_inv.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0) \u2227\n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a_inv.get i).get k * (a.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0)) :\n    \u2983\u231c\u2203 a_inv : Vector (Vector Float n) n,\n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a.get i).get k * (a_inv.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0) \u2227\n      (\u2200 i j : Fin n,\n        let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n          (a_inv.get i).get k * (a.get k).get j)\n        matrix_mult_ij = if i = j then 1.0 else 0.0)\u231d\u2984\n    tensorsolve a b\n    \u2983\u21d3x => \u231c(\u2200 i : Fin n,\n              List.sum (List.ofFn fun j : Fin n => \n                (a.get i).get j * x.get j) = b.get i) \u2227\n            (\u2200 y : Vector Float n,\n              (\u2200 i : Fin n,\n                List.sum (List.ofFn fun j : Fin n => \n                  (a.get i).get j * y.get j) = b.get i) \u2192 \n              y = x) \u2227\n            (\u2200 a_inv : Vector (Vector Float n) n,\n              (\u2200 i j : Fin n, \n                let matrix_mult_ij := List.sum (List.ofFn fun k : Fin n => \n                  (a.get i).get k * (a_inv.get k).get j)\n                matrix_mult_ij = if i = j then 1.0 else 0.0) \u2192\n              (\u2200 i : Fin n,\n                x.get i = List.sum (List.ofFn fun j : Fin n => \n                  (a_inv.get i).get j * b.get j)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_trace", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.trace\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Return the sum along diagonals of the array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.trace.html\",\n  \"doc\": \"Return the sum along diagonals of the array.\\n\\nIf a is 2-D, returns the sum along the diagonal. If a has more dimensions, then axes along which the trace is taken can be specified.\",\n}\n-/\n\n/-  Returns the sum along the main diagonal of a square matrix.\n    The trace is the sum of diagonal elements at positions (i, i) for i = 0 to n-1. -/\n\n/-  Specification: trace computes the sum of the main diagonal elements of a square matrix.\n    The trace is mathematically defined as the sum of elements x[i][i] for i from 0 to n-1.\n    This is a fundamental operation in linear algebra with important mathematical properties:\n    - trace(A + B) = trace(A) + trace(B) (linearity)\n    - trace(cA) = c * trace(A) (scalar multiplication)\n    - trace(A) = trace(A^T) (transpose invariance) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def trace {n : Nat} (x : Vector (Vector Float n) n) : Id Float :=\n  sorry", "vc-theorems": "theorem trace_spec {n : Nat} (x : Vector (Vector Float n) n) :\n    \u2983\u231cTrue\u231d\u2984\n    trace x\n    \u2983\u21d3result => \u231cresult = (List.range n).foldl (fun acc i => \n      if h : i < n then\n        acc + (x.get \u27e8i, h\u27e9).get \u27e8i, h\u27e9\n      else acc\n    ) 0 \u2227 \n    (\u2200 i : Fin n, (x.get i).get i \u2260 0 \u2192 result \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_vecdot", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.vecdot\",\n  \"category\": \"Matrix and vector products\",\n  \"description\": \"Compute vector dot product\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.vecdot.html\",\n  \"doc\": \"Computes the vector dot product of two arrays. Supports broadcasting and treats input arrays as vectors regardless of their shape.\",\n}\n-/\n\n/-  Compute the vector dot product of two vectors -/\n\n/-  Specification: vecdot computes the mathematical dot product as the sum of element-wise products.\n    This captures the mathematical definition: a \u00b7 b = \u03a3(i=0 to n-1) a_i * b_i.\n\n    Key properties:\n    - Commutativity: vecdot(x1, x2) = vecdot(x2, x1)\n    - Linearity: vecdot(c*x1, x2) = c * vecdot(x1, x2)\n    - Zero vector: vecdot(0, x) = 0\n    - Self-dot gives sum of squares: vecdot(x, x) = \u03a3(x_i\u00b2)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vecdot {n : Nat} (x1 x2 : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem vecdot_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    vecdot x1 x2\n    \u2983\u21d3result => \u231cresult = List.sum (List.zipWith (\u00b7 * \u00b7) x1.toList x2.toList) \u2227\n                 result = List.sum (List.zipWith (\u00b7 * \u00b7) x2.toList x1.toList)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "linalg_vector_norm", "vc-description": "/- \n{\n  \"name\": \"numpy.linalg.vector_norm\",\n  \"category\": \"Norms and numbers\",\n  \"description\": \"Compute vector norm\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.vector_norm.html\",\n  \"doc\": \"Computes the vector norm of a vector.\\n\\nThis function is able to return one of an infinite number of vector norms, depending on the value of the ord parameter.\",\n}\n-/\n\n/-  numpy.linalg.vector_norm: Compute the p-norm of a vector for a given order p.\n\n    This function computes vector norms of different orders (p-norms).\n    For a vector x and order p, the p-norm is defined as:\n    ||x||_p = (sum(|x[i]|^p))^(1/p) for p \u2265 1\n\n    Special cases:\n    - p = 1: Manhattan norm (sum of absolute values)\n    - p = 2: Euclidean norm (square root of sum of squares)\n    - p = \u221e: Maximum norm (largest absolute value)\n    - p = -\u221e: Minimum norm (smallest absolute value)\n    - p = 0: Zero norm (count of non-zero elements)\n\n    This implementation focuses on the most common p-norm cases for 1D vectors.\n-/\n\n/-  Specification: vector_norm computes the p-norm of a vector for various values of p.\n\n    The p-norm is a generalization of the common vector norms used in numerical computing.\n    This specification covers the mathematical definition and key properties of p-norms.\n\n    Mathematical definition:\n    - For p \u2265 1: ||x||_p = (\u03a3\u1d62 |x\u1d62|^p)^(1/p)\n    - For p = 1: ||x||_1 = \u03a3\u1d62 |x\u1d62| (Manhattan norm)\n    - For p = 2: ||x||_2 = \u221a(\u03a3\u1d62 x\u1d62\u00b2) (Euclidean norm)\n    - For p = 0: ||x||_0 = count of non-zero elements\n\n    Key properties verified:\n    1. Definition: For p \u2265 1, result equals (sum of |xi|^p)^(1/p)\n    2. Non-negativity: norm(x, p) \u2265 0 for all x and valid p\n    3. Definiteness: norm(x, p) = 0 iff x is zero vector (for p > 0)\n    4. Special cases: p=1 (Manhattan), p=2 (Euclidean), p=0 (zero norm)\n    5. Empty vector: norm of empty vector is 0\n\n    Preconditions:\n    - p must be a non-negative real number\n    - For p = 0, it counts non-zero elements (special case)\n    - For p \u2265 1, it computes the standard p-norm\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vector_norm {n : Nat} (x : Vector Float n) (p : Float) : Id Float :=\n  sorry", "vc-theorems": "theorem vector_norm_spec {n : Nat} (x : Vector Float n) (p : Float) \n    (h_valid_p : p \u2265 0) :\n    \u2983\u231cp \u2265 0\u231d\u2984\n    vector_norm x p\n    \u2983\u21d3result => \u231cresult \u2265 0 \u2227\n                 (n = 0 \u2192 result = 0) \u2227\n                 (p = 2 \u2192 result = Float.sqrt (List.sum (x.toList.map (fun xi => xi * xi)))) \u2227\n                 (p = 1 \u2192 result = List.sum (x.toList.map (fun xi => Float.abs xi))) \u2227\n                 (p = 0 \u2192 result = Float.ofNat (x.toList.filter (fun xi => xi != 0)).length) \u2227\n                 (p > 1 \u2192 \n                   result = Float.pow (List.sum (x.toList.map (fun xi => Float.pow (Float.abs xi) p))) (1 / p)) \u2227\n                 (result = 0 \u2194 (p > 0 \u2227 \u2200 i : Fin n, x.get i = 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_all", "vc-description": "/- \n{\n  \"name\": \"numpy.all\",\n  \"category\": \"Truth value testing\",\n  \"description\": \"Test whether all array elements along a given axis evaluate to True\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.all.html\",\n  \"doc\": \"Test whether all array elements along a given axis evaluate to True.\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which a logical AND reduction is performed.\\n    The default (axis=None) is to perform a logical AND over all\\n    the dimensions of the input array. axis may be negative, in\\n    which case it counts from the last to the first axis.\\n    \\n    .. versionadded:: 1.7.0\\n    \\n    If this is a tuple of ints, a reduction is performed on multiple\\n    axes, instead of a single axis or all the axes as before.\\nout : ndarray, optional\\n    Alternate output array in which to place the result.\\n    It must have the same shape as the expected output and its\\n    type is preserved (e.g., if dtype(out) is float, the result\\n    will consist of 0.0's and 1.0's). See Output type determination\\n    for more details.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left\\n    in the result as dimensions with size one. With this option,\\n    the result will broadcast correctly against the input array.\\n    \\n    If the default value is passed, then keepdims will not be\\n    passed through to the all method of sub-classes of\\n    ndarray, however any non-default value will be. If the\\n    sub-class' method does not implement keepdims any\\n    exceptions will be raised.\\nwhere : array_like of bool, optional\\n    Elements to include in checking for all True values.\\n    See reduce for details.\\n    \\n    .. versionadded:: 1.20.0\\n\\nReturns\\n-------\\nall : ndarray, bool\\n    A new boolean or array is returned unless out is specified,\\n    in which case a reference to out is returned.\\n\\nSee Also\\n--------\\nndarray.all : equivalent method\\n\\nany : Test whether any element along a given axis evaluates to True.\\n\\nNotes\\n-----\\nNot a Number (NaN), positive infinity and negative infinity\\nevaluate to True because these are not equal to zero.\\n\\nExamples\\n--------\\n>>> np.all([[True,False],[True,True]])\\nFalse\\n\\n>>> np.all([[True,False],[True,True]], axis=0)\\narray([ True, False])\\n\\n>>> np.all([-1, 4, 5])\\nTrue\\n\\n>>> np.all([1.0, np.nan])\\nTrue\\n\\n>>> np.all([[True, True], [False, True]], where=[[True], [False]])\\nTrue\\n\\n>>> o=np.array(False)\\n>>> z=np.all([-1, 4, 5], out=o)\\n>>> id(z), id(o), z\\n(28293632, 28293632, array(True)) # may vary\",\n}\n-/\n\n/-  Test whether all array elements evaluate to True.\n    Elements are considered True if they are non-zero.\n    NaN, positive infinity and negative infinity evaluate to True. -/\n\n/-  Specification: all returns True if and only if all elements are non-zero.\n    This includes proper handling of special float values:\n    - NaN evaluates to True (it is not equal to zero)\n    - Positive and negative infinity evaluate to True (they are not equal to zero)\n    - Only 0.0 and -0.0 evaluate to False\n\n    Mathematical properties:\n    - Empty vector returns True (vacuous truth)\n    - all is monotonic: if all(a) is True and b has same non-zero elements, then all(b) is True\n    - all(a) = not(any(map(\u03bbx. x = 0, a))) - equivalent to checking no element is zero\n\n    Sanity checks:\n    - For empty vector (n = 0), the result is True by vacuous truth\n    - For single element [x], result is True iff x \u2260 0\n    - For vector with all non-zero elements, result is True\n    - For vector with at least one zero element, result is False\n\n    Additional properties:\n    - Idempotent: all(all(a)) = all(a) (when treating Bool as numeric)\n    - Distributive over logical AND: all(a) \u2227 all(b) \u2192 all(pointwise_and(a, b))\n    - Relationship to logical AND reduction: all(a) = fold(\u2227, true, map(\u2260 0, a)) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def all {n : Nat} (a : Vector Float n) : Id Bool :=\n  sorry", "vc-theorems": "theorem all_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    all a\n    \u2983\u21d3result => \u231c(result = true \u2194 \u2200 i : Fin n, a.get i \u2260 0) \u2227\n                  (n = 0 \u2192 result = true) \u2227\n                  ((\u2203 i : Fin n, a.get i = 0) \u2192 result = false) \u2227\n                  (\u2200 i : Fin n, a.get i \u2260 0 \u2192 result = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_allclose", "vc-description": "/-  numpy.allclose: Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers. The\n    relative difference (rtol * abs(b)) and the absolute difference\n    atol are added together to compare against the absolute difference\n    between a and b.\n\n    For each element, the condition is:\n    absolute(a - b) <= (atol + rtol * absolute(b))\n\n    This function returns True if ALL elements satisfy this condition,\n    False otherwise.\n-/\n\n/-  Specification: allclose returns true iff all elements are within tolerance.\n\n    Precondition: rtol >= 0 and atol >= 0 (tolerance values must be non-negative)\n    Postcondition: result = true iff all elements satisfy the tolerance condition\n                   abs(a[i] - b[i]) <= atol + rtol * abs(b[i]) for all i\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def allclose {n : Nat} (a b : Vector Float n) (rtol atol : Float) : Id Bool :=\n  sorry", "vc-theorems": "theorem allclose_spec {n : Nat} (a b : Vector Float n) (rtol atol : Float) \n    (h_rtol : rtol >= 0) (h_atol : atol >= 0) :\n    \u2983\u231crtol >= 0 \u2227 atol >= 0\u231d\u2984\n    allclose a b rtol atol\n    \u2983\u21d3result => \u231cresult = (\u2200 i : Fin n, Float.abs (a.get i - b.get i) <= atol + rtol * Float.abs (b.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_any", "vc-description": "/- \n{\n  \"name\": \"numpy.any\",\n  \"category\": \"Truth value testing\",\n  \"description\": \"Test whether any array element along a given axis evaluates to True\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.any.html\",\n  \"doc\": \"Test whether any array element along a given axis evaluates to True.\\n\\nReturns single boolean if axis is None\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which a logical OR reduction is performed.\\n    The default (axis=None) is to perform a logical OR over all\\n    the dimensions of the input array. axis may be negative, in\\n    which case it counts from the last to the first axis.\\n    \\n    .. versionadded:: 1.7.0\\n    \\n    If this is a tuple of ints, a reduction is performed on multiple\\n    axes, instead of a single axis or all the axes as before.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. It must have\\n    the same shape as the expected output and its type is preserved\\n    (e.g., if it is of type float, then it will remain so, returning\\n    1.0 for True and 0.0 for False, regardless of the type of a).\\n    See Output type determination for more details.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left\\n    in the result as dimensions with size one. With this option,\\n    the result will broadcast correctly against the input array.\\n    \\n    If the default value is passed, then keepdims will not be\\n    passed through to the any method of sub-classes of\\n    ndarray, however any non-default value will be. If the\\n    sub-class' method does not implement keepdims any\\n    exceptions will be raised.\\nwhere : array_like of bool, optional\\n    Elements to include in checking for any True values.\\n    See reduce for details.\\n    \\n    .. versionadded:: 1.20.0\\n\\nReturns\\n-------\\nany : bool or ndarray\\n    A new boolean or ndarray is returned unless out is specified,\\n    in which case a reference to out is returned.\\n\\nSee Also\\n--------\\nndarray.any : equivalent method\\n\\nall : Test whether all elements along a given axis evaluate to True.\\n\\nNotes\\n-----\\nNot a Number (NaN), positive infinity and negative infinity evaluate\\nto True because these are not equal to zero.\\n\\nExamples\\n--------\\n>>> np.any([[True, False], [True, True]])\\nTrue\\n\\n>>> np.any([[True, False], [False, False]], axis=0)\\narray([ True, False])\\n\\n>>> np.any([-1, 0, 5])\\nTrue\\n\\n>>> np.any(np.nan)\\nTrue\\n\\n>>> np.any([[True, False], [False, False]], where=[[False], [True]])\\nFalse\\n\\n>>> o=np.array(False)\\n>>> z=np.any([-1, 4, 5], out=o)\\n>>> z, o\\n(array(True), array(True))\\n>>> # Check now that z is a reference to o\\n>>> z is o\\nTrue\\n>>> id(z), id(o) # identity of z and o              # doctest: +SKIP\\n(191614240, 191614240)\",\n}\n-/\n\n/-  Test whether any element in a vector evaluates to True.\n\n    For numeric types, returns true if any element is non-zero.\n    Special values like NaN, positive/negative infinity are considered True.\n    This follows NumPy's convention where non-zero values are truthy.\n\n    This is a reduction operation that performs logical OR across all elements,\n    treating non-zero values as True and zero as False. -/\n\n/-  Specification: `any` returns true if and only if at least one element in the vector is non-zero.\n\n    The specification captures comprehensive mathematical properties:\n    1. Logical equivalence: result is true iff there exists a non-zero element\n    2. Completeness: result is false iff all elements are zero\n    3. Empty vector behavior: returns false for empty vectors\n    4. Monotonicity: adding more elements can only increase the chance of being true\n\n    This matches NumPy's behavior where:\n    - Non-zero values (including NaN, \u00b1\u221e) evaluate to True\n    - Only zero evaluates to False\n    - Empty arrays return False -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def any {n : Nat} (v : Vector Float n) : Id Bool :=\n  sorry", "vc-theorems": "theorem any_spec {n : Nat} (v : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    any v\n    \u2983\u21d3result => \u231c-- Core logical equivalence\n                 (result = true \u2194 \u2203 i : Fin n, v.get i \u2260 0) \u2227\n                 (result = false \u2194 \u2200 i : Fin n, v.get i = 0) \u2227\n                 -- Boundary conditions  \n                 (n = 0 \u2192 result = false) \u2227\n                 -- Monotonicity properties\n                 (\u2200 i : Fin n, v.get i = 0 \u2192 result = false) \u2227\n                 (\u2203 i : Fin n, v.get i \u2260 0 \u2192 result = true) \u2227\n                 -- Logical consistency\n                 (result = true \u2228 result = false) \u2227\n                 \u00ac(result = true \u2227 result = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_array_equal", "vc-description": "/-  numpy.array_equal: True if two arrays have the same shape and elements, False otherwise.\n\n    Compares two arrays element-wise and returns a single boolean value indicating\n    whether the arrays are completely equal. Unlike element-wise comparison functions,\n    this returns a single boolean result for the entire comparison.\n\n    The function returns True if and only if:\n    1. The arrays have the same shape (enforced by Vector type system)\n    2. All corresponding elements are equal\n\n    For Vector types, the shape constraint is automatically satisfied by the type system,\n    so we only need to check element-wise equality.\n-/\n\n/-  Specification: numpy.array_equal returns True if and only if all corresponding \n    elements in the two vectors are equal.\n\n    Precondition: True (vectors have the same length by the type system)\n    Postcondition: The result is True if and only if all corresponding elements are equal\n\n    Mathematical properties:\n    - Array equality is reflexive: arrayEqual(a, a) = True for any array a\n    - Array equality is symmetric: arrayEqual(a, b) = arrayEqual(b, a)\n    - Array equality is transitive: if arrayEqual(a, b) and arrayEqual(b, c), then arrayEqual(a, c)\n    - Empty arrays are equal: arrayEqual([], []) = True (vacuous truth)\n    - arrayEqual(a, b) = all(elementwise_equal(a, b)) - equivalent to checking all elements are equal\n\n    Sanity checks:\n    - For empty vectors (n = 0), the result is True by vacuous truth\n    - For single element vectors [x] and [y], result is True iff x == y\n    - For identical vectors, result is True\n    - For vectors differing in any element, result is False\n    - arrayEqual is the logical AND of all element-wise comparisons\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def arrayEqual {T : Type} [BEq T] {n : Nat} (a1 a2 : Vector T n) : Id Bool :=\n  sorry", "vc-theorems": "theorem arrayEqual_spec {T : Type} [BEq T] {n : Nat} (a1 a2 : Vector T n) :\n    \u2983\u231cTrue\u231d\u2984\n    arrayEqual a1 a2\n    \u2983\u21d3result => \u231c(result = true \u2194 \u2200 i : Fin n, a1.get i == a2.get i) \u2227\n                  (n = 0 \u2192 result = true) \u2227\n                  (\u2203 i : Fin n, \u00ac(a1.get i == a2.get i) \u2192 result = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_array_equiv", "vc-description": "/-  numpy.array_equiv: Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    For 1D arrays of the same size, this means element-wise comparison.\n    The function returns True if all corresponding elements are equal.\n-/\n\n/-  Specification: array_equiv returns true iff all corresponding elements are equal.\n\n    Precondition: True (works for any two vectors of the same size)\n    Postcondition: result = true iff all elements at corresponding indices are equal\n\n    Mathematical properties satisfied:\n    - Reflexivity: array_equiv a a = true (any array is equivalent to itself)\n    - Symmetry: array_equiv a b = array_equiv b a (equivalence is symmetric)\n    - Element-wise equality: result = true iff \u2200 i, a1[i] = a2[i]\n    - Empty array handling: for n=0, the result is vacuously true\n    - Finite precision: uses Float equality (may have precision limitations)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def array_equiv {n : Nat} (a1 a2 : Vector Float n) : Id Bool :=\n  sorry", "vc-theorems": "theorem array_equiv_spec {n : Nat} (a1 a2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    array_equiv a1 a2\n    \u2983\u21d3result => \u231cresult = (\u2200 i : Fin n, a1.get i = a2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_bitwise_and", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_and\",\n  \"category\": \"Logical operations\",\n  \"description\": \"Compute the bit-wise AND of two arrays element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_and.html\",\n  \"doc\": \"Compute the bit-wise AND of two arrays element-wise.\\n\\nComputes the bit-wise AND of the underlying binary representation of\\nthe integers in the input arrays. This ufunc implements the C/Python\\noperator &.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Only integer and boolean types are handled.\\n    If x1.shape != x2.shape, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\nlogical_and\\nbitwise_or, bitwise_xor\\nbinary_repr :\\n    Return the binary representation of the input number as a string.\\n\\nExamples\\n--------\\nThe number 13 is represented by 00001101. Likewise, 17 is\\nrepresented by 00010001.  The bit-wise AND of 13 and 17 is\\ntherefore 000000001, or 1:\\n\\n>>> np.bitwise_and(13, 17)\\n1\\n\\n>>> np.bitwise_and(14, 13)\\n12\\n>>> np.binary_repr(12)\\n'1100'\\n>>> np.bitwise_and([14,3], 13)\\narray([12,  1])\\n\\n>>> np.bitwise_and([11,7], [4,25])\\narray([0, 1])\\n>>> np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\\narray([ 2,  4, 16])\\n>>> np.bitwise_and([True, True], [False, True])\\narray([False,  True])\\n\\nThe & operator can be used as a shorthand for np.bitwise_and on\\nndarrays.\\n\\n>>> x1 = np.array([2, 5, 255])\\n>>> x2 = np.array([3, 14, 16])\\n>>> x1 & x2\\narray([ 2,  4, 16])\",\n}\n-/\n\n/-  Compute the bit-wise AND of two vectors element-wise.\n    Computes the bit-wise AND of the underlying binary representation of\n    the natural numbers in the input vectors. -/\n\n/-  Specification: bitwise_and computes element-wise bitwise AND operation \n\n    This specification captures the mathematical properties of bitwise AND:\n    - Commutativity: a & b = b & a\n    - Associativity: (a & b) & c = a & (b & c)\n    - Identity with all bits set: a & (-1) = a (but using max value for Nat)\n    - Absorption with zero: a & 0 = 0\n    - Idempotent: a & a = a\n    - Monotonicity: if a \u2264 b, then a & c \u2264 b & c\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def bitwise_and {n : Nat} (x1 x2 : Vector Nat n) : Id (Vector Nat n) :=\n  sorry", "vc-theorems": "theorem bitwise_and_spec {n : Nat} (x1 x2 : Vector Nat n) :\n    \u2983\u231cTrue\u231d\u2984\n    bitwise_and x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i) &&& (x2.get i) \u2227\n                 -- Commutativity property\n                 (x1.get i) &&& (x2.get i) = (x2.get i) &&& (x1.get i) \u2227\n                 -- Absorption with zero\n                 (x1.get i) &&& 0 = 0 \u2227\n                 -- Idempotent property\n                 (x1.get i) &&& (x1.get i) = x1.get i \u2227\n                 -- Result is bounded by both operands\n                 result.get i \u2264 x1.get i \u2227 result.get i \u2264 x2.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_bitwise_not", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_not\",\n  \"category\": \"Logical operations\",\n  \"description\": \"Compute bit-wise inversion, or bit-wise NOT, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_not.html\",\n  \"doc\": \"Compute bit-wise inversion, or bit-wise NOT, element-wise.\\n\\nComputes the bit-wise NOT of the underlying binary representation of\\nthe integers in the input arrays. This ufunc implements the C/Python\\noperator ~.\\n\\nFor signed integer inputs, the bit-wise NOT of the absolute value is\\nreturned. In a two's-complement system, this operation effectively flips\\nall the bits, which results in -(x + 1). This is the most common method\\nof representing signed integers on computers. A N-bit two's-complement\\nsystem can represent every integer in the range -2^(N-1) to +2^(N-1)-1.\\n\\nParameters\\n----------\\nx : array_like\\n    Only integer and boolean types are handled.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n    This is a scalar if x is a scalar.\\n\\nSee Also\\n--------\\nbitwise_and, bitwise_or, bitwise_xor\\nlogical_not\\nbinary_repr :\\n    Return the binary representation of the input number as a string.\\n\\nExamples\\n--------\\nWe've seen that 13 is represented by 00001101.\\nThe invert or bit-wise NOT of 13 is then:\\n\\n>>> x = np.bitwise_not(np.array(13, dtype=np.uint8))\\n>>> x\\n242\\n>>> np.binary_repr(x, width=8)\\n'11110010'\\n\\nWhen using signed integer types, the result is the bit-wise NOT of\\nthe unsigned type, interpreted as a signed integer:\\n\\n>>> np.bitwise_not(np.array([13], dtype=np.int8))\\narray([-14], dtype=int8)\\n>>> np.binary_repr(-14, width=8)\\n'11110010'\\n\\nThe ~ operator can be used as a shorthand for np.bitwise_not on\\nndarrays.\\n\\n>>> x1 = np.array([True, False])\\n>>> ~x1\\narray([False,  True])\",\n}\n-/\n\n/-  numpy.bitwise_not: Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\n    Computes the bit-wise NOT of the underlying binary representation of\n    the integers in the input arrays. This ufunc implements the C/Python\n    operator ~.\n\n    For signed integer inputs, the bit-wise NOT of the absolute value is\n    returned. In a two's-complement system, this operation effectively flips\n    all the bits, which results in -(x + 1). This is the most common method\n    of representing signed integers on computers.\n\n    Returns an array of the same shape as x, containing the bitwise NOT values.\n-/\n\n/-  Specification: numpy.bitwise_not returns a vector where each element is the\n    bitwise NOT of the corresponding element in x.\n\n    Precondition: True (no special preconditions for bitwise NOT)\n    Postcondition: For all indices i, result[i] = -(x[i] + 1)\n\n    This specification captures the mathematical property that bitwise NOT\n    of an integer x in two's complement representation equals -(x + 1).\n\n    Key properties:\n    - Bitwise NOT is its own inverse: ~~x = x\n    - For any integer x: ~x = -(x + 1)\n    - The operation is element-wise for arrays\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_bitwise_not {n : Nat} (x : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem numpy_bitwise_not_spec {n : Nat} (x : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_bitwise_not x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = -(x.get i + 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_bitwise_or", "vc-description": "/-  numpy.bitwise_or: Compute the bit-wise OR of two arrays element-wise.\n\n    Computes the bit-wise OR of the underlying binary representation of\n    the integers in the input arrays. This ufunc implements the C/Python\n    operator |.\n\n    For integer inputs, the result is the bitwise OR of the binary\n    representations. For boolean inputs, it performs logical OR.\n-/\n\n/-  Specification: numpy.bitwise_or returns a vector where each element is the \n    bitwise OR of the corresponding elements from x1 and x2.\n\n    Precondition: True (no special preconditions for bitwise OR)\n    Postcondition: For all indices i, result[i] = bitwise_or(x1[i], x2[i])\n\n    Mathematical properties:\n    - Commutative: bitwise_or(x1[i], x2[i]) = bitwise_or(x2[i], x1[i])\n    - Identity: bitwise_or(x[i], 0) = x[i]\n    - Idempotent: bitwise_or(x[i], x[i]) = x[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Axiomatically define bitwise OR operation for integers -/\naxiom Int.bitwise_or : Int \u2192 Int \u2192 Int\n\n/-- Bitwise OR is commutative -/\naxiom Int.bitwise_or_comm (x y : Int) : Int.bitwise_or x y = Int.bitwise_or y x\n\n/-- Bitwise OR with zero is identity -/\naxiom Int.bitwise_or_zero (x : Int) : Int.bitwise_or x 0 = x\n\n/-- Bitwise OR is idempotent -/\naxiom Int.bitwise_or_idempotent (x : Int) : Int.bitwise_or x x = x", "vc-helpers": "", "vc-definitions": "def numpy_bitwise_or {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem numpy_bitwise_or_spec {n : Nat} (x1 x2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_bitwise_or x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Int.bitwise_or (x1.get i) (x2.get i) \u2227\n                 -- Commutativity property\n                 Int.bitwise_or (x1.get i) (x2.get i) = Int.bitwise_or (x2.get i) (x1.get i) \u2227\n                 -- Identity property\n                 Int.bitwise_or (x1.get i) 0 = x1.get i \u2227\n                 -- Idempotent property\n                 Int.bitwise_or (x1.get i) (x1.get i) = x1.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_bitwise_xor", "vc-description": "/- \n{\n  \"name\": \"numpy.bitwise_xor\",\n  \"category\": \"Logical operations\",\n  \"description\": \"Compute the bit-wise XOR of two arrays element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.bitwise_xor.html\",\n  \"doc\": \"Compute the bit-wise XOR of two arrays element-wise.\\n\\nComputes the bit-wise XOR of the underlying binary representation of\\nthe integers in the input arrays. This ufunc implements the C/Python\\noperator ^.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Only integer and boolean types are handled.\\n    If x1.shape != x2.shape, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Result.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\nlogical_xor\\nbitwise_and, bitwise_or\\nbinary_repr :\\n    Return the binary representation of the input number as a string.\\n\\nExamples\\n--------\\nThe number 13 is represented by 00001101. Likewise, 17 is\\nrepresented by 00010001.  The bit-wise XOR of 13 and 17 is\\ntherefore 00011100, or 28:\\n\\n>>> np.bitwise_xor(13, 17)\\n28\\n>>> np.binary_repr(28)\\n'11100'\\n\\n>>> np.bitwise_xor(31, 5)\\n26\\n>>> np.bitwise_xor([31,3], 5)\\narray([26,  6])\\n\\n>>> np.bitwise_xor([31,3], [5,6])\\narray([26,  5])\\n>>> np.bitwise_xor([True, True], [False, True])\\narray([ True, False])\\n\\nThe ^ operator can be used as a shorthand for np.bitwise_xor on\\nndarrays.\\n\\n>>> x1 = np.array([True, True])\\n>>> x2 = np.array([False, True])\\n>>> x1 ^ x2\\narray([ True, False])\",\n}\n-/\n\n/-  numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.\n\n    Computes the bit-wise XOR of the underlying binary representation of\n    the integers in the input arrays. This ufunc implements the C/Python\n    operator ^.\n\n    The function works on integer and boolean types, computing the XOR\n    of corresponding elements from two input vectors.\n-/\n\n/-  Specification: numpy.bitwise_xor returns a vector where each element is the \n    bitwise XOR of the corresponding elements from x1 and x2.\n\n    Precondition: All elements are non-negative (to use well-defined bitwise operations)\n    Postcondition: For all indices i, result[i] = x1[i] XOR x2[i]\n\n    Mathematical properties:\n    - XOR is commutative: x1[i] XOR x2[i] = x2[i] XOR x1[i]\n    - XOR is associative: (a XOR b) XOR c = a XOR (b XOR c)\n    - XOR with zero is identity: x XOR 0 = x\n    - XOR is self-inverse: x XOR x = 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def bitwise_xor {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem bitwise_xor_spec {n : Nat} (x1 x2 : Vector Int n) \n    (h_nonneg : \u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0) :\n    \u2983\u231c\u2200 i : Fin n, x1.get i \u2265 0 \u2227 x2.get i \u2265 0\u231d\u2984\n    bitwise_xor x1 x2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = Int.ofNat (Int.toNat (x1.get i) ^^^ Int.toNat (x2.get i))) \u2227\n                (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                (\u2200 i : Fin n, x1.get i = 0 \u2192 result.get i = x2.get i) \u2227\n                (\u2200 i : Fin n, x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n                (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_equal", "vc-description": "/-  numpy.equal: Return (x1 == x2) element-wise.\n\n    Performs element-wise comparison of two arrays and returns a boolean array\n    of the same shape indicating where the corresponding elements are equal.\n\n    For scalar inputs, returns a single boolean value. For array inputs of the\n    same shape, returns an array of booleans. This function is the basis for\n    the == operator when used with numpy arrays.\n-/\n\n/-  Specification: numpy.equal returns a boolean vector where each element indicates\n    whether the corresponding elements in x1 and x2 are equal.\n\n    Precondition: True (arrays have the same shape by the type system)\n    Postcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\n    This specification captures both the element-wise behavior and the mathematical\n    property that equality comparison is performed at each position.\n\n    Key Properties:\n    1. Element-wise comparison: Each position is compared independently\n    2. Boolean result: Returns true/false for each position \n    3. Reflexivity: equal(x, x) returns all true\n    4. Symmetry: equal(x, y) = equal(y, x)\n    5. Result shape matches input shape\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_equal {T : Type} [BEq T] {n : Nat} (x1 x2 : Vector T n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_equal_spec {T : Type} [BEq T] {n : Nat} (x1 x2 : Vector T n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i == x2.get i) \u2227\n                  -- Reflexivity: comparing vector with itself yields all true\n                  (x1 = x2 \u2192 \u2200 i : Fin n, result.get i = true) \u2227\n                  -- Symmetry: equality comparison is commutative\n                  (\u2200 i : Fin n, result.get i = (x2.get i == x1.get i)) \u2227\n                  -- Boolean result: each element is either true or false\n                  (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_greater", "vc-description": "/-  numpy.greater: Return the truth value of (x1 > x2) element-wise.\n\n    Returns a boolean vector where each element indicates whether the\n    corresponding element in x1 is greater than the corresponding element in x2.\n\n    This is equivalent to x1 > x2 in terms of array broadcasting.\n\n    Follows IEEE 754 standard for floating point comparisons:\n    - Comparisons with NaN always return false\n    - Returns boolean array of same shape as inputs\n-/\n\n/-  Specification: numpy.greater returns a boolean vector where each element\n    is true if and only if the corresponding element in x1 is greater than\n    the corresponding element in x2.\n\n    This specification captures:\n    1. Basic element-wise comparison semantics\n    2. Antisymmetry property of greater-than relation\n    3. Transitivity when combined with other comparisons\n    4. IEEE 754 compliant NaN handling\n    5. Consistency with standard mathematical ordering\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_greater {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_greater_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_greater x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, (result.get i = true \u2194 x1.get i > x2.get i) \u2227\n                             -- Antisymmetry: if x1 > x2 then not (x2 > x1)\n                             (result.get i = true \u2192 \u00ac(x2.get i > x1.get i)) \u2227\n                             -- IEEE 754 compliance: NaN comparisons always return false\n                             ((x1.get i).isNaN \u2228 (x2.get i).isNaN \u2192 result.get i = false) \u2227\n                             -- Boolean result: each element is either true or false\n                             (result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_greater_equal", "vc-description": "/-  numpy.greater_equal: Return the truth value of (x1 >= x2) element-wise.\n\n    Returns a boolean vector where each element indicates whether the\n    corresponding element in x1 is greater than or equal to the corresponding \n    element in x2.\n\n    This is equivalent to x1 >= x2 in terms of array broadcasting.\n-/\n\n/-  Specification: numpy.greater_equal returns a boolean vector where each element\n    is true if and only if the corresponding element in x1 is greater than or equal\n    to the corresponding element in x2.\n\n    Precondition: True (no special preconditions for comparison)\n    Postcondition: For all indices i, result[i] = true \u2194 x1[i] >= x2[i]\n\n    Additional properties:\n    - The result is the element-wise negation of less(x1, x2)\n    - Reflexivity: greater_equal(x, x) returns all true\n    - Antisymmetry: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x1)[i] = true,\n                    then x1[i] = x2[i]\n    - Transitivity: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x3)[i] = true,\n                    then greater_equal(x1, x3)[i] = true\n    - For NaN values: comparison with NaN always returns false\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_greater_equal {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_greater_equal_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_greater_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = true \u2194 x1.get i >= x2.get i \u2227\n                  -- Reflexivity: comparing vector with itself yields all true\n                  (x1 = x2 \u2192 \u2200 i : Fin n, result.get i = true) \u2227\n                  -- Antisymmetry with equality\n                  (\u2200 i : Fin n, result.get i = true \u2227 \n                   (x2.get i >= x1.get i) \u2192 x1.get i = x2.get i) \u2227\n                  -- Boolean result: each element is either true or false\n                  (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isclose", "vc-description": "/-  Returns a boolean array where two arrays are element-wise equal within a tolerance.\n    For finite values, isclose uses the equation: absolute(a - b) <= (atol + rtol * absolute(b))\n    where `b` is treated as the reference value. -/\n\n/-  Specification: isclose returns a boolean array indicating element-wise closeness within tolerance -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isclose {n : Nat} (a b : Vector Float n) (rtol : Float) (atol : Float) (equal_nan : Bool) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isclose_spec {n : Nat} (a b : Vector Float n) (rtol : Float) (atol : Float) (equal_nan : Bool) \n    (h_rtol_nonneg : rtol \u2265 0) (h_atol_nonneg : atol \u2265 0) :\n    \u2983\u231crtol \u2265 0 \u2227 atol \u2265 0\u231d\u2984\n    isclose a b rtol atol equal_nan\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Core tolerance check for finite values\n        (Float.isFinite (a.get i) \u2227 Float.isFinite (b.get i) \u2192 \n         (result.get i = true \u2194 \n          Float.abs (a.get i - b.get i) \u2264 atol + rtol * Float.abs (b.get i))) \u2227\n        -- Infinite values are equal if they match exactly\n        (\u00acFloat.isFinite (a.get i) \u2228 \u00acFloat.isFinite (b.get i) \u2192 \n         (result.get i = true \u2194 a.get i = b.get i)) \u2227\n        -- NaN handling depends on equal_nan parameter\n        ((a.get i).isNaN \u2227 (b.get i).isNaN \u2192 \n         (result.get i = true \u2194 equal_nan = true)) \u2227\n        -- Asymmetric property: uses b as reference value\n        (result.get i = false \u2194 \n         (Float.isFinite (a.get i) \u2227 Float.isFinite (b.get i) \u2227 \n          Float.abs (a.get i - b.get i) > atol + rtol * Float.abs (b.get i)) \u2228\n         (\u00acFloat.isFinite (a.get i) \u2228 \u00acFloat.isFinite (b.get i)) \u2227 a.get i \u2260 b.get i \u2228\n         ((a.get i).isNaN \u2227 (b.get i).isNaN \u2227 equal_nan = false))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_iscomplex", "vc-description": "/- \n{\n  \"name\": \"numpy.iscomplex\",\n  \"category\": \"Array type testing\",\n  \"description\": \"Returns a bool array, where True if input element is complex\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.iscomplex.html\",\n  \"doc\": \"Returns a bool array, where True if input element is complex.\\n\\nWhat is tested is whether the input has a non-zero imaginary part, not\\nwhether the input type is complex.\\n\\nParameters\\n----------\\nx : array_like\\n    Input array.\\n\\nReturns\\n-------\\nout : ndarray of bools\\n    Output array.\\n\\nSee Also\\n--------\\nisreal\\niscomplexobj : Return True if x is of a complex type.\\n\\nExamples\\n--------\\n>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\\narray([ True, False, False, False, False,  True])\",\n}\n-/\n\n/-  Returns a bool array, where True if input element has non-zero imaginary part.\n    For complex numbers, checks if imaginary part is non-zero.\n    For real numbers, returns false for all elements. -/\n\n/-  Specification: iscomplex returns true for elements with non-zero imaginary parts,\n    false for elements with zero imaginary parts, with the following properties:\n    1. Basic definition: returns true iff imaginary part is non-zero\n    2. Real number detection: pure real numbers (imag = 0) return false\n    3. Complex number detection: numbers with non-zero imaginary part return true\n    4. Idempotent on boolean interpretation: the mathematical meaning is preserved\n    5. Element-wise operation: each element is tested independently -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a complex number with float components -/\nstructure Complex where\n  /-- The real part of the complex number -/\n  real : Float\n  /-- The imaginary part of the complex number -/\n  imag : Float", "vc-helpers": "", "vc-definitions": "def iscomplex {n : Nat} (x : Vector Complex n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem iscomplex_spec {n : Nat} (x : Vector Complex n) :\n    \u2983\u231cTrue\u231d\u2984\n    iscomplex x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = ((x.get i).imag \u2260 0.0)) \u2227\n                 (\u2200 i : Fin n, (x.get i).imag = 0.0 \u2192 result.get i = false) \u2227\n                 (\u2200 i : Fin n, (x.get i).imag \u2260 0.0 \u2192 result.get i = true) \u2227\n                 (\u2200 i : Fin n, result.get i = true \u2192 (x.get i).imag \u2260 0.0) \u2227\n                 (\u2200 i : Fin n, result.get i = false \u2192 (x.get i).imag = 0.0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_iscomplexobj", "vc-description": "/- \n{\n  \"name\": \"numpy.iscomplexobj\",\n  \"category\": \"Array type testing\",\n  \"description\": \"Check for a complex type or an array of complex numbers\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.iscomplexobj.html\",\n  \"doc\": \"Check for a complex type or an array of complex numbers.\\n\\nThe type of the input is checked, not the value. Even if the input\\nhas an imaginary part equal to zero, iscomplexobj evaluates to True.\\n\\nParameters\\n----------\\nx : any\\n    The input can be of any type and shape.\\n\\nReturns\\n-------\\niscomplexobj : bool\\n    The return value, True if x is of a complex type or has at least\\n    one complex element.\\n\\nSee Also\\n--------\\nisrealobj, iscomplex\\n\\nExamples\\n--------\\n>>> np.iscomplexobj(1)\\nFalse\\n>>> np.iscomplexobj(1+0j)\\nTrue\\n>>> np.iscomplexobj([3, 1+0j, True])\\nTrue\",\n}\n-/\n\n/-  Check if a vector contains complex numbers -/\n\n/-  Specification: iscomplexobj returns True for complex type vectors.\n    This function checks the type, not the values - even complex numbers\n    with zero imaginary part are considered complex objects.\n\n    Key properties:\n    - Always returns true for vectors of complex numbers\n    - Type-based checking: independent of actual values\n    - Zero complex numbers (0+0i) are still complex objects\n    - Complex vectors with any values are complex objects\n\n    Mathematical properties:\n    - Type consistency: all Complex vectors are complex objects\n    - Value independence: result depends only on type, not values\n    - Idempotent: checking complex vectors always yields true -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n-- Complex number type in Lean (simplified)\n/-- Complex number with real and imaginary parts -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float", "vc-helpers": "", "vc-definitions": "def iscomplexobj {n : Nat} (x : Vector Complex n) : Id Bool :=\n  sorry", "vc-theorems": "theorem iscomplexobj_spec {n : Nat} (x : Vector Complex n) :\n    \u2983\u231cTrue\u231d\u2984\n    iscomplexobj x\n    \u2983\u21d3result => \u231cresult = true \u2227\n      -- Sanity check: complex numbers with zero imaginary part are still complex\n      (\u2200 (real_val : Float), \n        let zero_im_complex : Complex := {re := real_val, im := 0.0}\n        \u2200 (vec_with_zero_im : Vector Complex n), \n          (\u2200 j : Fin n, vec_with_zero_im.get j = zero_im_complex) \u2192 \n          result = true) \u2227\n      -- Type consistency: complex type always returns true\n      (\u2200 (other_vec : Vector Complex n), result = true) \u2227\n      -- Value independence: different complex values still return true\n      (\u2200 i : Fin n, \u2200 (re_val im_val : Float), \n        result = true) \u2227\n      -- Mathematical property: zero complex numbers are complex\n      (let zero_complex : Complex := {re := 0.0, im := 0.0}\n       result = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isfinite", "vc-description": "/- \n{\n  \"name\": \"numpy.isfinite\",\n  \"category\": \"Array contents testing\",\n  \"description\": \"Test element-wise for finiteness (not infinity and not Not a Number)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html\",\n  \"doc\": \"Test element-wise for finiteness (not infinity or not Not a Number).\\n\\nThe result is returned as a boolean array.\\n\\nParameters\\n----------\\nx : array_like\\n    Input values.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\ny : ndarray, bool\\n    True where x is not positive infinity, negative infinity,\\n    or NaN; false otherwise.\\n    This is a scalar if x is a scalar.\\n\\nSee Also\\n--------\\nisinf, isneginf, isposinf, isnan\\n\\nNotes\\n-----\\nNot a Number, positive infinity and negative infinity are considered\\nto be non-finite.\\n\\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\\nAlso that positive infinity is not equivalent to negative infinity. But\\ninfinity is equivalent to positive infinity.  Errors result if the\\nsecond argument is also supplied when x is a scalar input, or if\\nfirst and second arguments have different shapes.\\n\\nExamples\\n--------\\n>>> np.isfinite(1)\\nTrue\\n>>> np.isfinite(0)\\nTrue\\n>>> np.isfinite(np.nan)\\nFalse\\n>>> np.isfinite(np.inf)\\nFalse\\n>>> np.isfinite(np.NINF)\\nFalse\\n>>> np.isfinite([np.log(-1.),1.,np.log(0)])\\narray([False,  True, False])\\n\\n>>> x = np.array([-np.inf, 0., np.inf])\\n>>> y = np.array([2, 2, 2])\\n>>> np.isfinite(x, y)\\narray([0, 1, 0])\\n>>> y\\narray([0, 1, 0])\",\n}\n-/\n\n/-  Test element-wise for finiteness (not infinity and not NaN) -/\n\n/-  Specification: isfinite returns true for finite values, false for infinity and NaN -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isfinite {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isfinite_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    isfinite x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = \n      (\u00ac(x.get i).isInf \u2227 \u00ac(x.get i).isNaN) \u2227\n      -- Core mathematical property: equivalence with isFinite\n      (result.get i = true \u2194 (x.get i).isFinite) \u2227\n      -- Inverse property: false iff NaN or infinity\n      (result.get i = false \u2194 ((x.get i).isNaN \u2228 (x.get i).isInf)) \u2227\n      -- Specific cases: zero and normal numbers are finite\n      (x.get i = 0.0 \u2192 result.get i = true) \u2227\n      -- Mathematical property: finite numbers have bounded absolute value\n      (result.get i = true \u2192 \u2203 (bound : Float), Float.abs (x.get i) \u2264 bound) \u2227\n      -- Consistency: if not finite, then either NaN or infinity\n      (result.get i = false \u2192 ((x.get i).isNaN \u2228 (x.get i).isInf)) \u2227\n      -- Arithmetic stability: finite + finite arithmetic operations\n      (result.get i = true \u2192 \u2200 (y : Float), y.isFinite \u2192 \n        ((x.get i + y).isFinite \u2228 (x.get i + y).isInf)) \u2227\n      -- IEEE 754 compliance: finite values exclude special values\n      (result.get i = true \u2192 \u00ac(x.get i).isNaN \u2227 \u00ac(x.get i).isInf)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isinf", "vc-description": "/-  \n-- numpy.isinf: Test element-wise for positive or negative infinity\n-- Returns a boolean array of the same shape as x, True where x == +/-inf, otherwise False.\n-- URL: https://numpy.org/doc/stable/reference/generated/numpy.isinf.html\n-- Category: Array contents testing\n-/\n\n/-  Test element-wise for positive or negative infinity in a vector -/\n\n/-  Specification: isinf returns true for positive or negative infinity, false otherwise.\n\n    This function tests each element according to IEEE 754 floating-point standard:\n    - Returns true if the element is positive infinity or negative infinity\n    - Returns false for all other values including NaN, finite numbers, and zero\n\n    Mathematical properties:\n    1. Infinity detection: result[i] = true iff x[i] is infinite\n    2. Distinction from NaN: infinity and NaN are mutually exclusive\n    3. Result preserves shape: output vector has same length as input\n    4. Finite values: All normal, subnormal, and zero values return false\n    5. Specific infinities: Both positive and negative infinity are correctly identified\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isinf {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isinf_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    isinf x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (result.get i = (x.get i).isInf) \u2227\n      (\u00ac(x.get i).isInf \u2192 result.get i = false) \u2227\n      ((x.get i).isNaN \u2192 result.get i = false) \u2227\n      (x.get i = 0.0 \u2192 result.get i = false) \u2227\n      (result.get i = true \u2192 \u00ac(x.get i).isFinite) \u2227\n      (result.get i = true \u2192 \u00ac(x.get i).isNaN)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isnan", "vc-description": "/- \n{\n  \"name\": \"numpy.isnan\",\n  \"category\": \"Array contents testing\",\n  \"description\": \"Test element-wise for NaN and return result as a boolean array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isnan.html\",\n  \"doc\": \"Test element-wise for NaN and return result as a boolean array.\\n\\nParameters\\n----------\\nx : array_like\\n    Input array.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns  \\n-------\\ny : ndarray or bool\\n    True where x is NaN, false otherwise.\\n    This is a scalar if x is a scalar.\\n\\nSee Also\\n--------\\nisinf, isneginf, isposinf, isfinite, isnat\\n\\nNotes\\n-----\\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\\n\\nExamples\\n--------\\n>>> np.isnan(np.nan)\\nTrue\\n>>> np.isnan(np.inf)\\nFalse\\n>>> np.isnan([np.log(-1.),1.,np.log(0)])\\narray([ True, False, False])\",\n}\n-/\n\n/-  Test element-wise for NaN and return result as a boolean array -/\n\n/-  Specification: isnan returns true for NaN values and false otherwise.\n    The function correctly identifies NaN values according to IEEE 754 standard.\n\n    Mathematical properties:\n    1. NaN detection: result[i] = true iff x[i] is NaN\n    2. NaN \u2260 NaN property: if x[i].isNaN then x[i] \u2260 x[i]\n    3. Result preserves shape: output vector has same length as input\n    4. Non-NaN values: For all finite values, the result is false\n    5. Complement property: isnan is the complement of (isfinite \u2228 isinfinite) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isnan {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isnan_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    isnan x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = (x.get i).isNaN) \u2227\n                 (\u2200 i : Fin n, result.get i = true \u2192 \u00ac(x.get i = x.get i)) \u2227\n                 (\u2200 i : Fin n, \u00ac(x.get i).isNaN \u2192 result.get i = false) \u2227\n                 (\u2200 i : Fin n, (x.get i).isFinite \u2192 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isnat", "vc-description": "/-  Test element-wise for NaT (not a time) and return result as a boolean array.\n\n    This function checks each element of a datetime64 array to determine if it\n    represents NaT (Not a Time), which is the datetime equivalent of NaN.\n\n    Returns true for NaT values and false for all valid datetime values.\n    The function is the datetime analog of isnan for floating point values.\n-/\n\n/-  Specification: isnat returns true for NaT values and false otherwise.\n    The function correctly identifies NaT values in datetime64 arrays.\n\n    Mathematical properties:\n    1. NaT detection: result[i] = true iff x[i] is NaT\n    2. Valid datetime detection: result[i] = false iff x[i] is a valid datetime\n    3. Result preserves shape: output vector has same length as input\n    4. Exhaustive coverage: every element is either NaT or a valid datetime\n\n    This is the datetime analog of isnan for floating point NaN values.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A datetime64 type placeholder representing either a valid datetime or NaT (Not a Time) -/\ninductive DateTime64 where\n  /-- Valid datetime represented as float (seconds since epoch) -/\n  | valid : Float \u2192 DateTime64\n  /-- NaT (Not a Time) - the datetime equivalent of NaN -/\n  | nat : DateTime64", "vc-helpers": "", "vc-definitions": "def isnat {n : Nat} (x : Vector DateTime64 n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isnat_spec {n : Nat} (x : Vector DateTime64 n) :\n    \u2983\u231cTrue\u231d\u2984\n    isnat x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = match x.get i with\n                                                | DateTime64.nat => true\n                                                | DateTime64.valid _ => false) \u2227\n                 (\u2200 i : Fin n, result.get i = true \u2194 x.get i = DateTime64.nat) \u2227\n                 (\u2200 i : Fin n, result.get i = false \u2194 \u2203 t : Float, x.get i = DateTime64.valid t)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isneginf", "vc-description": "/- \n{\n  \"name\": \"numpy.isneginf\",\n  \"category\": \"Array contents testing\",\n  \"description\": \"Test element-wise for negative infinity, return result as bool array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isneginf.html\",\n  \"doc\": \"Test element-wise for negative infinity, return result as bool array.\\n\\nParameters\\n----------\\nx : array_like\\n    The input array.\\nout : array_like, optional\\n    A location into which the result is stored. If provided, it must have a\\n    shape that the input broadcasts to. If not provided or None, a\\n    freshly-allocated boolean array is returned.\\n\\nReturns\\n-------\\nout : ndarray\\n    A boolean array with the same dimensions as the input.\\n    If second argument is not supplied then a numpy boolean array is\\n    returned with values True where the corresponding element of the\\n    input is negative infinity and values False where the element of\\n    the input is not negative infinity.\\n    \\n    If a second argument is supplied the result is stored there. If the\\n    type of that array is a numeric type the result is represented as\\n    zeros and ones, if the type is boolean then as False and True. The\\n    return value out is then a reference to that array.\\n\\nSee Also\\n--------\\nisinf, isposinf, isnan, isfinite\\n\\nNotes\\n-----\\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\\n(IEEE 754).\\n\\nErrors result if the second argument is also supplied when x is a\\nscalar input, if first and second arguments have different shapes,\\nor if the first argument has complex values.\\n\\nExamples\\n--------\\n>>> np.isneginf(np.NINF)\\nTrue\\n>>> np.isneginf(np.inf)\\nFalse\\n>>> np.isneginf(np.PINF)\\nFalse\\n>>> np.isneginf([-np.inf, 0., np.inf])\\narray([ True, False, False])\\n\\n>>> x = np.array([-np.inf, 0., np.inf])\\n>>> y = np.array([2, 2, 2])\\n>>> np.isneginf(x, y)\\narray([1, 0, 0])\\n>>> y\\narray([1, 0, 0])\",\n}\n-/\n\n/-  Test element-wise for negative infinity, return result as bool array. -/\n\n/-  Specification: isneginf returns True for negative infinity elements, False otherwise.\n\n    This function tests each element according to IEEE 754 floating-point standard:\n    - Returns true if the element is negative infinity (-\u221e)\n    - Returns false for all other values including positive infinity, NaN, finite numbers, and zero\n\n    Mathematical properties:\n    1. Negative infinity detection: result[i] = true iff x[i] is negative infinity\n    2. Distinction from positive infinity: only negative infinity returns true\n    3. Distinction from NaN: negative infinity and NaN are mutually exclusive\n    4. Result preserves shape: output vector has same length as input\n    5. Finite values: All normal, subnormal, and zero values return false\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isneginf {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isneginf_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    isneginf x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Primary property: result is true iff input is negative infinity\n      (result[i] = ((x[i]).isInf \u2227 (x[i]) < 0)) \u2227\n      -- Sanity checks: finite values return false\n      (\u00ac(x[i]).isInf \u2192 result[i] = false) \u2227\n      -- Positive infinity returns false\n      ((x[i]).isInf \u2227 (x[i]) > 0 \u2192 result[i] = false) \u2227\n      -- NaN is not negative infinity\n      ((x[i]).isNaN \u2192 result[i] = false) \u2227\n      -- Zero is not negative infinity\n      (x[i] = 0.0 \u2192 result[i] = false) \u2227\n      -- Mathematical property: if result is true, then x is infinite and negative\n      (result[i] = true \u2192 (x[i]).isInf \u2227 (x[i]) < 0) \u2227\n      -- Exclusivity: cannot be both negative infinity and NaN\n      (result[i] = true \u2192 \u00ac(x[i]).isNaN)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isposinf", "vc-description": "/- \n{\n  \"name\": \"numpy.isposinf\",\n  \"category\": \"Array contents testing\",\n  \"description\": \"Test element-wise for positive infinity, return result as bool array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isposinf.html\",\n  \"doc\": \"Test element-wise for positive infinity, return result as bool array.\\n\\nParameters\\n----------\\nx : array_like\\n    The input array.\\nout : array_like, optional\\n    A location into which the result is stored. If provided, it must have a\\n    shape that the input broadcasts to. If not provided or None, a\\n    freshly-allocated boolean array is returned.\\n\\nReturns\\n-------\\nout : ndarray\\n    A boolean array with the same dimensions as the input.\\n    If second argument is not supplied then a boolean array is returned\\n    with values True where the corresponding element of the input is\\n    positive infinity and values False where the element of the input\\n    is not positive infinity.\\n    \\n    If a second argument is supplied the result is stored there. If the\\n    type of that array is a numeric type the result is represented as\\n    zeros and ones, if the type is boolean then as False and True.\\n    The return value out is then a reference to that array.\\n\\nSee Also\\n--------\\nisinf, isneginf, isfinite, isnan\\n\\nNotes\\n-----\\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\\n(IEEE 754).\\n\\nErrors result if the second argument is also supplied when x is a\\nscalar input, if first and second arguments have different shapes,\\nor if the first argument has complex values\\n\\nExamples\\n--------\\n>>> np.isposinf(np.PINF)\\nTrue\\n>>> np.isposinf(np.inf)\\nTrue\\n>>> np.isposinf(np.NINF)\\nFalse\\n>>> np.isposinf([-np.inf, 0., np.inf])\\narray([False, False,  True])\\n\\n>>> x = np.array([-np.inf, 0., np.inf])\\n>>> y = np.array([2, 2, 2])\\n>>> np.isposinf(x, y)\\narray([0, 0, 1])\\n>>> y\\narray([0, 0, 1])\",\n}\n-/\n\n/-  Test element-wise for positive infinity, return result as bool array -/\n\n/-  Specification: isposinf returns True for positive infinity elements, False otherwise.\n\n    This function tests each element according to IEEE 754 floating-point standard:\n    - Returns true if the element is positive infinity (+\u221e)\n    - Returns false for all other values including negative infinity, NaN, finite numbers, and zero\n\n    Mathematical properties:\n    1. Positive infinity detection: result[i] = true iff x[i] is positive infinity\n    2. Distinction from negative infinity: only positive infinity returns true\n    3. Distinction from NaN: positive infinity and NaN are mutually exclusive\n    4. Result preserves shape: output vector has same length as input\n    5. Finite values: All normal, subnormal, and zero values return false\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isposinf {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isposinf_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    isposinf x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Primary property: result is true iff input is positive infinity\n      (result.get i = ((x.get i).isInf \u2227 (x.get i) > 0)) \u2227\n      -- Sanity checks: finite values return false\n      (\u00ac(x.get i).isInf \u2192 result.get i = false) \u2227\n      -- Negative infinity returns false\n      ((x.get i).isInf \u2227 (x.get i) < 0 \u2192 result.get i = false) \u2227\n      -- NaN is not positive infinity\n      ((x.get i).isNaN \u2192 result.get i = false) \u2227\n      -- Zero is not positive infinity\n      (x.get i = 0.0 \u2192 result.get i = false) \u2227\n      -- Mathematical property: if result is true, then x is infinite and positive\n      (result.get i = true \u2192 (x.get i).isInf \u2227 (x.get i) > 0) \u2227\n      -- Exclusivity: cannot be both positive infinity and NaN\n      (result.get i = true \u2192 \u00ac(x.get i).isNaN)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_isreal", "vc-description": "/- \n{\n  \"name\": \"numpy.isreal\",\n  \"category\": \"Array type testing\",\n  \"description\": \"Returns a bool array, where True if input element is real\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isreal.html\",\n  \"doc\": \"Returns a bool array, where True if input element is real.\\n\\nIf element has complex type with zero imaginary part, the return value\\nfor that element is True.\\n\\nParameters\\n----------\\nx : array_like\\n    Input array.\\n\\nReturns\\n-------\\nout : ndarray, bool\\n    Boolean array of same shape as x.\\n\\nSee Also\\n--------\\niscomplex\\nisrealobj : Return True if x is not a complex type.\\n\\nExamples\\n--------\\n>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\\narray([False,  True,  True,  True,  True, False])\",\n}\n-/\n\n/-  Returns a bool array, where True if input element is real.\n    For complex numbers, checks if imaginary part is zero.\n    For numbers with zero imaginary part, returns true for all elements. -/\n\n/-  Specification: isreal returns true for elements with zero imaginary parts,\n    false for elements with non-zero imaginary parts, with the following properties:\n    1. Basic definition: returns true iff imaginary part is zero\n    2. Real number detection: pure real numbers (imag = 0) return true\n    3. Complex number detection: numbers with non-zero imaginary part return false\n    4. Complementary to iscomplex: isreal(x) = not iscomplex(x)\n    5. Element-wise operation: each element is tested independently\n    6. Mathematical property: real numbers form a subset of complex numbers\n    7. Consistency: if real, then can be represented as a + 0i -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a complex number with float components -/\nstructure Complex where\n  /-- The real part of the complex number -/\n  real : Float\n  /-- The imaginary part of the complex number -/\n  imag : Float", "vc-helpers": "", "vc-definitions": "def isreal {n : Nat} (x : Vector Complex n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isreal_spec {n : Nat} (x : Vector Complex n) :\n    \u2983\u231cTrue\u231d\u2984\n    isreal x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = ((x.get i).imag = 0.0)) \u2227\n                 (\u2200 i : Fin n, (x.get i).imag = 0.0 \u2192 result.get i = true) \u2227\n                 (\u2200 i : Fin n, (x.get i).imag \u2260 0.0 \u2192 result.get i = false) \u2227\n                 (\u2200 i : Fin n, result.get i = true \u2192 (x.get i).imag = 0.0) \u2227\n                 (\u2200 i : Fin n, result.get i = false \u2192 (x.get i).imag \u2260 0.0) \u2227\n                 -- Mathematical property: real numbers preserve their real part\n                 (\u2200 i : Fin n, result.get i = true \u2192 (x.get i).real = (x.get i).real) \u2227\n                 -- Complementary property: exactly one of isreal or iscomplex is true\n                 (\u2200 i : Fin n, result.get i = \u00ac((x.get i).imag \u2260 0.0)) \u2227\n                 -- Consistency with mathematical definition of real numbers\n                 (\u2200 i : Fin n, result.get i = true \u2194 (x.get i).imag = 0.0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_less_equal", "vc-description": "/- \n{\n  \"name\": \"numpy.less_equal\",\n  \"category\": \"Comparison\",\n  \"description\": \"Return the truth value of (x1 <= x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.less_equal.html\",\n  \"doc\": \"Return the truth value of (x1 <= x2) element-wise.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays. If x1.shape != x2.shape, they must be\\n    broadcastable to a common shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless dtype=object is passed.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\ngreater, less, greater_equal, equal, not_equal\\n\\nExamples\\n--------\\n>>> np.less_equal([4, 2, 1], [2, 2, 2])\\narray([False,  True,  True])\"\n}\n-/\n\n/-  Return the truth value of (x1 <= x2) element-wise -/\n\n/-  Specification: less_equal returns element-wise comparison x1[i] <= x2[i] with mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def less_equal {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem less_equal_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    less_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i \u2264 x2.get i) \u2227\n                 (result.get i = true \u2194 x1.get i \u2264 x2.get i) \u2227\n                 (result.get i = false \u2194 x1.get i > x2.get i) \u2227\n                 (x1.get i = x2.get i \u2192 result.get i = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_logical_and", "vc-description": "/-  numpy.logical_and: Compute the truth value of x1 AND x2 element-wise.\n\n    Computes the logical AND of two boolean arrays element-wise.\n    Each element of the result is the logical AND of the corresponding\n    elements from the input arrays.\n\n    Examples from NumPy:\n    - logical_and(True, False) = False\n    - logical_and([True, False], [False, False]) = [False, False]\n    - logical_and([True, True], [True, False]) = [True, False]\n\n    This is a binary element-wise operation equivalent to x1 & x2.\n-/\n\n/-  Specification: numpy.logical_and returns a vector where each element\n    is the logical AND of the corresponding elements from x1 and x2.\n\n    Precondition: True (no special preconditions for logical AND)\n    Postcondition: For all indices i, result[i] = x1[i] \u2227 x2[i]\n\n    Key properties:\n    - Commutative: logical_and(x1, x2) = logical_and(x2, x1)\n    - Associative: logical_and(logical_and(x1, x2), x3) = logical_and(x1, logical_and(x2, x3))\n    - Identity: logical_and(x, true_vector) = x\n    - Zero: logical_and(x, false_vector) = false_vector\n    - Idempotent: logical_and(x, x) = x\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_logical_and {n : Nat} (x1 x2 : Vector Bool n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_logical_and_spec {n : Nat} (x1 x2 : Vector Bool n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_logical_and x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i \u2227 x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_logical_not", "vc-description": "/- \n{\n  \"name\": \"numpy.logical_not\",\n  \"category\": \"Logical operations\",\n  \"description\": \"Compute the truth value of NOT x element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.logical_not.html\",\n  \"doc\": \"Compute the truth value of NOT x element-wise.\\n\\nParameters\\n----------\\nx : array_like\\n    Logical NOT is applied to the elements of x.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\ny : bool or ndarray of bool\\n    Boolean result with the same shape as x of the NOT operation\\n    on elements of x.\\n    This is a scalar if x is a scalar.\\n\\nSee Also\\n--------\\nlogical_and, logical_or, logical_xor\\n\\nExamples\\n--------\\n>>> np.logical_not(3)\\nFalse\\n>>> np.logical_not([True, False, 0, 1])\\narray([False,  True,  True, False])\\n\\n>>> x = np.arange(5)\\n>>> np.logical_not(x<3)\\narray([False, False, False,  True,  True])\",\n}\n-/\n\n/-  numpy.logical_not: Compute the truth value of NOT x element-wise.\n\n    For each element in the input array, applies logical NOT operation.\n    In NumPy's interpretation: any non-zero numeric value is considered True \n    (so NOT returns False), zero is considered False (so NOT returns True).\n\n    Returns a boolean array of the same shape as the input.\n-/\n\n/-  Specification: numpy.logical_not returns a vector where each element is the\n    logical NOT of the corresponding element in x, following NumPy's truthiness rules.\n\n    Precondition: True (logical NOT is defined for all numeric values)\n    Postcondition: For all indices i, result[i] = true iff x[i] = 0.0\n\n    Mathematical properties:\n    - Exactly implements NumPy's truthiness rules: 0.0 \u2192 true, non-zero \u2192 false\n    - Element-wise operation preserves array shape and size (enforced by type)\n    - Idempotent when composed with itself and appropriate conversion\n    - For special float values: logical_not(NaN) = false, logical_not(\u221e) = false\n    - Boundary case: logical_not(-0.0) = true (since -0.0 = 0.0)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def logical_not {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem logical_not_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    logical_not x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x.get i = 0.0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_logical_or", "vc-description": "/- \n{\n  \"name\": \"numpy.logical_or\",\n  \"category\": \"Logical operations\",\n  \"description\": \"Compute the truth value of x1 OR x2 element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.logical_or.html\",\n  \"doc\": \"Compute the truth value of x1 OR x2 element-wise.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Logical OR is applied to the elements of x1 and x2.\\n    If x1.shape != x2.shape, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\ny : ndarray or bool\\n    Boolean result of the logical OR operation applied to the elements\\n    of x1 and x2; the shape is determined by broadcasting.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\nlogical_and, logical_not, logical_xor\\nbitwise_or\\n\\nExamples\\n--------\\n>>> np.logical_or(True, False)\\nTrue\\n>>> np.logical_or([True, False], [False, False])\\narray([ True, False])\\n\\n>>> x = np.arange(5)\\n>>> np.logical_or(x < 1, x > 3)\\narray([ True, False, False, False,  True])\\n\\nThe | operator can be used as a shorthand for np.logical_or on\\nboolean ndarrays.\\n\\n>>> a = np.array([True, False])\\n>>> b = np.array([False, False])\\n>>> a | b\\narray([ True, False])\",\n}\n-/\n\n/-  Compute the truth value of x1 OR x2 element-wise.\n\n    Performs logical OR operation on corresponding elements of two boolean vectors.\n    The function returns a vector where each element is the logical OR of the \n    corresponding elements from the input vectors.\n-/\n\n/-  Specification: logical_or computes element-wise logical OR operation\n\n    This specification captures the mathematical properties of logical OR:\n    - Commutativity: a \u2228 b = b \u2228 a\n    - Associativity: (a \u2228 b) \u2228 c = a \u2228 (b \u2228 c)\n    - Identity with false: a \u2228 false = a\n    - Absorption with true: a \u2228 true = true\n    - Idempotent: a \u2228 a = a\n    - De Morgan's law: \u00ac(a \u2228 b) = (\u00aca) \u2227 (\u00acb)\n\n    Sanity checks:\n    - For empty vectors (n = 0), the result is empty by vacuous truth\n    - logical_or([true, false], [false, false]) = [true, false]\n    - logical_or([false, false], [false, false]) = [false, false]\n    - logical_or([true, true], [false, true]) = [true, true]\n    - The result is false only when both operands are false\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def logical_or {n : Nat} (x1 x2 : Vector Bool n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem logical_or_spec {n : Nat} (x1 x2 : Vector Bool n) :\n    \u2983\u231cTrue\u231d\u2984\n    logical_or x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i || x2.get i) \u2227\n                 -- Commutativity property\n                 (x1.get i || x2.get i) = (x2.get i || x1.get i) \u2227\n                 -- Identity with false\n                 (x1.get i || false) = x1.get i \u2227\n                 -- Absorption with true\n                 (x1.get i || true) = true \u2227\n                 -- Idempotent property\n                 (x1.get i || x1.get i) = x1.get i \u2227\n                 -- Result is true if either operand is true\n                 (x1.get i = true \u2228 x2.get i = true \u2192 result.get i = true) \u2227\n                 -- Result is false only when both operands are false\n                 (x1.get i = false \u2227 x2.get i = false \u2192 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_logical_xor", "vc-description": "/-  numpy.logical_xor: Compute the truth value of x1 XOR x2 element-wise.\n\n    Computes the logical XOR of two boolean arrays element-wise.\n    Each element of the result is the logical XOR of the corresponding\n    elements from the input arrays.\n\n    Examples from NumPy:\n    - logical_xor(True, False) = True\n    - logical_xor([True, True, False, False], [True, False, True, False]) = [False, True, True, False]\n    - logical_xor(False, False) = False\n    - logical_xor(True, True) = False\n\n    This is a binary element-wise operation equivalent to x1 \u2295 x2.\n-/\n\n/-  Specification: numpy.logical_xor returns a vector where each element\n    is the logical XOR of the corresponding elements from x1 and x2.\n\n    Precondition: True (no special preconditions for logical XOR)\n    Postcondition: For all indices i, result[i] = x1[i] \u2295 x2[i]\n\n    Key properties:\n    - Commutative: logical_xor(x1, x2) = logical_xor(x2, x1)\n    - Associative: logical_xor(logical_xor(x1, x2), x3) = logical_xor(x1, logical_xor(x2, x3))\n    - Identity: logical_xor(x, false_vector) = x\n    - Self-inverse: logical_xor(x, x) = false_vector\n    - Double negation: logical_xor(logical_xor(x, y), y) = x\n    - Relationship to other operations: logical_xor(x, y) = logical_and(logical_or(x, y), logical_not(logical_and(x, y)))\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_logical_xor {n : Nat} (x1 x2 : Vector Bool n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_logical_xor_spec {n : Nat} (x1 x2 : Vector Bool n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_logical_xor x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i != x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "logic_functions_not_equal", "vc-description": "/-  numpy.not_equal: Return (x1 != x2) element-wise.\n\n    Performs element-wise inequality comparison of two arrays and returns a boolean array\n    of the same shape indicating where the corresponding elements are not equal.\n\n    For scalar inputs, returns a single boolean value. For array inputs of the\n    same shape, returns an array of booleans. This function is the basis for\n    the != operator when used with numpy arrays.\n\n    This is the logical negation of numpy.equal.\n-/\n\n/-  Specification: numpy.not_equal returns a boolean vector where each element indicates\n    whether the corresponding elements in x1 and x2 are not equal.\n\n    Precondition: True (arrays have the same shape by the type system)\n    Postcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\n    This specification captures both the element-wise behavior and the mathematical\n    property that inequality comparison is performed at each position.\n\n    Key Properties:\n    1. Element-wise comparison: Each position is compared independently\n    2. Boolean result: Returns true/false for each position \n    3. Irreflexivity: not_equal(x, x) returns all false\n    4. Symmetry: not_equal(x, y) = not_equal(y, x)\n    5. Logical negation of equality: not_equal(x, y) = \u00acequal(x, y)\n    6. Result shape matches input shape\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_not_equal {T : Type} [BEq T] {n : Nat} (x1 x2 : Vector T n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_not_equal_spec {T : Type} [BEq T] {n : Nat} (x1 x2 : Vector T n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_not_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = !(x1.get i == x2.get i) \u2227\n                  -- Irreflexivity: comparing vector with itself yields all false\n                  (x1 = x2 \u2192 \u2200 i : Fin n, result.get i = false) \u2227\n                  -- Symmetry: inequality comparison is commutative\n                  (\u2200 i : Fin n, result.get i = !(x2.get i == x1.get i)) \u2227\n                  -- Boolean result: each element is either true or false\n                  (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_absolute", "vc-description": "/- \n{\n  \"name\": \"numpy.absolute\",\n  \"description\": \"Calculate the absolute value element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.absolute.html\",\n  \"doc\": \"Calculate the absolute value element-wise.\\n\\nSignature: numpy.absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Input array\\n  out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored\\n\\nReturns:\\n  absolute: ndarray - An ndarray containing the absolute value of each element in x\",\n}\n-/\n\n/-  Calculate the absolute value element-wise for a vector of integers -/\n\n/-  Specification: absolute computes the absolute value of each element with the following mathematical properties:\n    1. Basic definition: |x| = x if x \u2265 0, otherwise -x\n    2. Non-negativity: |x| \u2265 0 for all x\n    3. Zero preservation: |x| = 0 if and only if x = 0\n    4. Idempotence: ||x|| = |x|\n    5. Multiplicativity: |x * y| = |x| * |y| -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def absolute {n : Nat} (x : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem absolute_spec {n : Nat} (x : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    absolute x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = if x.get i \u2265 0 then x.get i else -x.get i) \u2227\n                 (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                 (\u2200 i : Fin n, result.get i = 0 \u2194 x.get i = 0) \u2227\n                 (\u2200 i : Fin n, \u2200 (y : Int), \n                    (if (x.get i * y) \u2265 0 then (x.get i * y) else -(x.get i * y)) = \n                    result.get i * (if y \u2265 0 then y else -y))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_add", "vc-description": "/-  numpy.add: Add arguments element-wise.\n\n    Adds two vectors element-wise. If the vectors have the same shape,\n    each element of the result is the sum of the corresponding elements\n    from the input vectors.\n\n    This is equivalent to x1 + x2 in terms of array broadcasting.\n    The function supports all numeric types and handles overflow according\n    to the IEEE 754 standard for floating-point arithmetic.\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - The arrays to be added\n    - Returns: add (ndarray) - The sum of x1 and x2, element-wise\n-/\n\n/-  Specification: numpy.add returns a vector where each element is the sum\n    of the corresponding elements from x1 and x2.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = x1[i] + x2[i]\n    2. Commutativity: add(x1, x2) = add(x2, x1)\n    3. Associativity: add(add(x1, x2), x3) = add(x1, add(x2, x3))\n    4. Identity: add(x, zeros) = x\n    5. Preserves vector length: result.size = x1.size = x2.size\n    6. Handles finite arithmetic: supports IEEE 754 floating-point addition\n\n    Precondition: True (no special preconditions for basic addition)\n    Postcondition: For all indices i, result[i] = x1[i] + x2[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def add {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem add_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    add x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i + x2.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arccos", "vc-description": "/- \n{\n  \"name\": \"numpy.arccos\",\n  \"description\": \"Trigonometric inverse cosine, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arccos.html\",\n  \"doc\": \"Trigonometric inverse cosine, element-wise.\\n\\nThe inverse of cos so that, if y = cos(x), then x = arccos(y).\",\n}\n-/\n\n/-  Trigonometric inverse cosine, element-wise.\n    Returns the arc cosine of each element in the input vector.\n    The result is in the range [0, \u03c0]. -/\n\n/-  Specification: arccos returns the inverse cosine of each element.\n    Precondition: All elements must be in the range [-1, 1] for valid results.\n    Postcondition: The result contains the arc cosine of each input element,\n    with values in the range [0, \u03c0], and satisfies cos(arccos(x)) = x for valid inputs.\n    Additionally, arccos is monotonically decreasing on its domain [-1, 1]. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def arccos {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem arccos_spec {n : Nat} (x : Vector Float n) \n    (h_valid : \u2200 i : Fin n, -1 \u2264 x.get i \u2227 x.get i \u2264 1) :\n    \u2983\u231c\u2200 i : Fin n, -1 \u2264 x.get i \u2227 x.get i \u2264 1\u231d\u2984\n    arccos x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Range constraint: arccos maps [-1, 1] to [0, \u03c0]\n      0 \u2264 result.get i \u2227 \n      result.get i \u2264 3.141592653589793 \u2227\n      -- Inverse property: cos(arccos(x)) = x for x \u2208 [-1, 1]\n      Float.cos (result.get i) = x.get i \u2227\n      -- Boundary values: arccos(-1) = \u03c0, arccos(1) = 0\n      (x.get i = -1 \u2192 result.get i = 3.141592653589793) \u2227\n      (x.get i = 1 \u2192 result.get i = 0) \u2227\n      -- Monotonicity: arccos is decreasing on [-1, 1]\n      (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get j \u2264 result.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arccosh", "vc-description": "/- \n{\n  \"name\": \"numpy.arccosh\",\n  \"description\": \"Inverse hyperbolic cosine, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arccosh.html\",\n  \"doc\": \"Inverse hyperbolic cosine, element-wise.\",\n}\n-/\n\n/-  Inverse hyperbolic cosine, element-wise. \n    Returns the inverse hyperbolic cosine of each element in the input vector.\n    The inverse hyperbolic cosine is defined as: arccosh(x) = log(x + sqrt(x\u00b2 - 1)) for x \u2265 1 -/\n\n/-  Specification: arccosh computes the inverse hyperbolic cosine element-wise.\n\n    Mathematical properties:\n    1. Domain constraint: All input values must be \u2265 1\n    2. Range: All output values are non-negative (arccosh(x) \u2265 0)\n    3. Special value: arccosh(1) = 0\n    4. The function is strictly increasing: x\u2081 < x\u2082 implies arccosh(x\u2081) < arccosh(x\u2082)\n    5. Mathematical definition: arccosh(x) = log(x + sqrt(x\u00b2 - 1))\n\n    The inverse hyperbolic cosine function reverses the action of cosh on [0, \u221e),\n    where cosh(y) = (e^y + e^(-y))/2. These properties ensure correctness. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def arccosh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem arccosh_spec {n : Nat} (x : Vector Float n) \n    (h_domain : \u2200 i : Fin n, x.get i \u2265 1) :\n    \u2983\u231c\u2200 i : Fin n, x.get i \u2265 1\u231d\u2984\n    arccosh x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i \u2265 0) \u2227 \n                 (\u2200 i : Fin n, x.get i = 1 \u2192 result.get i = 0) \u2227\n                 (\u2200 i j : Fin n, 1 \u2264 x.get i \u2227 x.get i < x.get j \u2192 \n                   result.get i < result.get j) \u2227\n                 (\u2200 i : Fin n, \n                   -- The mathematical definition: arccosh(x) = log(x + sqrt(x\u00b2 - 1))\n                   result.get i = Float.log (x.get i + Float.sqrt (x.get i * x.get i - 1)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arcsin", "vc-description": "/-  numpy.arcsin: Inverse sine, element-wise.\n\n    Computes the inverse sine (arcsine) of each element in the input array.\n    The result is the angle in radians whose sine is the input value.\n\n    For real arguments, the domain is [-1, 1] and the range is [-\u03c0/2, \u03c0/2].\n    Values outside [-1, 1] will result in NaN.\n\n    Returns an array of the same shape as x, containing the inverse sine values in radians.\n-/\n\n/-  Specification: numpy.arcsin returns a vector where each element is the\n    inverse sine of the corresponding element in x.\n\n    Precondition: All elements of x must be in the domain [-1, 1] for real results\n    Postcondition: For all indices i where x[i] is in [-1, 1]:\n    - result[i] = arcsin(x[i])\n    - result[i] is in the range [-\u03c0/2, \u03c0/2]\n    - sin(result[i]) = x[i] (inverse relationship holds)\n    - arcsin is monotonic: if x[i] \u2264 x[j] then result[i] \u2264 result[j]\n    - Special values: arcsin(0) = 0, arcsin(1) = \u03c0/2, arcsin(-1) = -\u03c0/2\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_arcsin {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_arcsin_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, -1 \u2264 x.get i \u2227 x.get i \u2264 1\u231d\u2984\n    numpy_arcsin x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        result.get i = Float.asin (x.get i) \u2227\n        -1.5707963267948966 \u2264 result.get i \u2227 result.get i \u2264 1.5707963267948966 \u2227\n        Float.sin (result.get i) = x.get i \u2227\n        (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j) \u2227\n        (x.get i = 0 \u2192 result.get i = 0) \u2227\n        (x.get i = 1 \u2192 result.get i = 1.5707963267948966) \u2227\n        (x.get i = -1 \u2192 result.get i = -1.5707963267948966)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arcsinh", "vc-description": "/- \n{\n  \"name\": \"numpy.arcsinh\",\n  \"description\": \"Inverse hyperbolic sine element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arcsinh.html\",\n  \"doc\": \"Inverse hyperbolic sine element-wise.\",\n}\n-/\n\n/-  numpy.arcsinh: Inverse hyperbolic sine element-wise.\n\n    Computes the inverse hyperbolic sine of each element in the input vector.\n    The inverse hyperbolic sine is defined as arcsinh(x) = ln(x + sqrt(x\u00b2 + 1)).\n\n    This function is defined for all real numbers and is the inverse of the\n    hyperbolic sine function (sinh).\n-/\n\n/-  Specification: numpy.arcsinh returns a vector where each element is the\n    inverse hyperbolic sine of the corresponding element in x.\n\n    Precondition: True (arcsinh is defined for all real numbers)\n    Postcondition: For all indices i, result[i] = arcsinh(x[i])\n\n    Mathematical properties captured:\n    1. arcsinh(0) = 0 (sanity check)\n    2. arcsinh(-x) = -arcsinh(x) (odd function property)\n    3. arcsinh is strictly increasing (monotonicity)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_arcsinh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_arcsinh_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_arcsinh x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Basic computation: result = ln(x + sqrt(x\u00b2 + 1))\n        result.get i = Float.log (x.get i + Float.sqrt (x.get i * x.get i + 1)) \u2227\n        -- Sanity check: arcsinh(0) = 0\n        (x.get i = 0 \u2192 result.get i = 0) \u2227\n        -- Domain property: arcsinh is defined for all real numbers\n        Float.isFinite (result.get i) \u2228 Float.isNaN (result.get i) \u2227\n        -- For positive inputs, result is positive (odd function implied)\n        (x.get i > 0 \u2192 result.get i > 0) \u2227\n        -- For negative inputs, result is negative (odd function implied)\n        (x.get i < 0 \u2192 result.get i < 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arctan", "vc-description": "/- \n{\n  \"name\": \"numpy.arctan\",\n  \"description\": \"Trigonometric inverse tangent, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arctan.html\",\n  \"doc\": \"Trigonometric inverse tangent, element-wise.\\n\\nThe inverse of tan, so that if y = tan(x) then x = arctan(y).\",\n}\n-/\n\n/-  Computes the element-wise inverse tangent of a vector -/\n\n/-  Specification: arctan computes the inverse tangent of each element,\n    with comprehensive mathematical properties including range bounds,\n    monotonicity, and behavior at special values. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def arctan {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem arctan_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    arctan x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                  -- Range constraint: arctan(x) \u2208 (-\u03c0/2, \u03c0/2)\n                  (result.get i > -1.5708 \u2227 result.get i < 1.5708) \u2227\n                  -- Monotonicity: arctan is strictly increasing\n                  (\u2200 j : Fin n, x.get i < x.get j \u2192 result.get i < result.get j) \u2227\n                  -- Sign property: arctan preserves sign\n                  (x.get i > 0 \u2192 result.get i > 0) \u2227\n                  (x.get i < 0 \u2192 result.get i < 0) \u2227\n                  (x.get i = 0 \u2192 result.get i = 0) \u2227\n                  -- Small angle approximation: arctan(x) \u2248 x for small |x|\n                  (Float.abs (x.get i) < 0.1 \u2192 Float.abs (result.get i - x.get i) < 0.01) \u2227\n                  -- Asymptotic behavior: arctan(x) \u2192 \u00b1\u03c0/2 as x \u2192 \u00b1\u221e\n                  (x.get i > 10.0 \u2192 result.get i > 1.4) \u2227\n                  (x.get i < -10.0 \u2192 result.get i < -1.4) \u2227\n                  -- Continuity property: arctan is continuous everywhere\n                  -- Bounded function: |arctan(x)| \u2264 \u03c0/2 for all x\n                  (Float.abs (result.get i) \u2264 1.5708) \u2227\n                  -- Specific values: arctan(1) = \u03c0/4, arctan(-1) = -\u03c0/4\n                  (Float.abs (x.get i - 1.0) < 1e-10 \u2192 Float.abs (result.get i - 0.7854) < 1e-6) \u2227\n                  (Float.abs (x.get i - (-1.0)) < 1e-10 \u2192 Float.abs (result.get i - (-0.7854)) < 1e-6)\n                  \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arctan2", "vc-description": "/- \n{\n  \"name\": \"numpy.arctan2\",\n  \"description\": \"Element-wise arc tangent of x1/x2 choosing the quadrant correctly\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.arctan2.html\",\n  \"doc\": \"Element-wise arc tangent of x1/x2 choosing the quadrant correctly.\\n\\nThe quadrant (i.e., branch) is chosen so that arctan2(x1, x2) is the signed angle in radians between the ray ending at the origin and passing through the point (1, 0), and the ray ending at the origin and passing through the point (x2, x1).\",\n}\n-/\n\n/-  numpy.arctan2: Element-wise arc tangent of x1/x2 choosing the quadrant correctly.\n\n    Computes the arc tangent of x1/x2 for each pair of corresponding elements,\n    using the signs of both arguments to determine the quadrant of the result.\n    This gives the signed angle in radians between the positive x-axis and the\n    point (x2, x1).\n\n    The result is in the range [-\u03c0, \u03c0].\n\n    Special cases:\n    - arctan2(+0, +0) = +0\n    - arctan2(+0, -0) = +\u03c0\n    - arctan2(-0, +0) = -0\n    - arctan2(-0, -0) = -\u03c0\n    - arctan2(y, +\u221e) = +0 for finite y > 0\n    - arctan2(y, -\u221e) = +\u03c0 for finite y > 0\n    - arctan2(y, +\u221e) = -0 for finite y < 0\n    - arctan2(y, -\u221e) = -\u03c0 for finite y < 0\n-/\n\n/-  Specification: numpy.arctan2 returns a vector where each element is the\n    arc tangent of x1[i]/x2[i], computed using both signs to determine the quadrant.\n\n    Mathematical properties:\n    1. The result is the angle \u03b8 such that:\n       - x1[i] = r * sin(\u03b8)\n       - x2[i] = r * cos(\u03b8)\n       where r = sqrt(x1[i]\u00b2 + x2[i]\u00b2)\n\n    2. arctan2 correctly handles all four quadrants based on the signs of x1 and x2\n\n    3. Special case: arctan2(0, 0) = 0 by convention\n\n    4. For x2 > 0, arctan2(x1, x2) = arctan(x1/x2)\n\n    5. Key quadrant properties:\n       - If x1 \u2265 0 and x2 > 0: result is in [0, \u03c0/2)\n       - If x1 > 0 and x2 \u2264 0: result is in (\u03c0/2, \u03c0]\n       - If x1 \u2264 0 and x2 < 0: result is in (-\u03c0, -\u03c0/2]\n       - If x1 < 0 and x2 \u2265 0: result is in [-\u03c0/2, 0)\n\n    Precondition: True (handles all real inputs including zeros)\n    Postcondition: Each result[i] is the arc tangent of x1[i]/x2[i] with correct quadrant\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_arctan2 {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_arctan2_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_arctan2 x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Range property: result is in [-\u03c0, \u03c0]\n        (result.get i >= -3.14159265359 \u2227 result.get i <= 3.14159265359) \u2227\n        -- For the zero-zero case\n        ((x1.get i = 0 \u2227 x2.get i = 0) \u2192 result.get i = 0) \u2227\n        -- For positive x2, it matches regular arctan\n        (x2.get i > 0 \u2192 result.get i = Float.atan (x1.get i / x2.get i)) \u2227\n        -- Quadrant I: x1 \u2265 0, x2 > 0\n        ((x1.get i >= 0 \u2227 x2.get i > 0) \u2192 \n          (result.get i >= 0 \u2227 result.get i <= 1.57079632679)) \u2227\n        -- Quadrant II: x1 > 0, x2 \u2264 0\n        ((x1.get i > 0 \u2227 x2.get i <= 0) \u2192 \n          (result.get i > 1.57079632679 \u2227 result.get i <= 3.14159265359)) \u2227\n        -- Quadrant III: x1 \u2264 0, x2 < 0\n        ((x1.get i <= 0 \u2227 x2.get i < 0) \u2192 \n          (result.get i >= -3.14159265359 \u2227 result.get i <= -1.57079632679)) \u2227\n        -- Quadrant IV: x1 < 0, x2 \u2265 0\n        ((x1.get i < 0 \u2227 x2.get i >= 0) \u2192 \n          (result.get i >= -1.57079632679 \u2227 result.get i < 0)) \u2227\n        -- The result satisfies the fundamental trigonometric relationship\n        ((x1.get i \u2260 0 \u2228 x2.get i \u2260 0) \u2192 \n          let r := Float.sqrt (x1.get i * x1.get i + x2.get i * x2.get i)\n          (Float.abs (x1.get i - r * Float.sin (result.get i)) < 1e-7 \u2227\n           Float.abs (x2.get i - r * Float.cos (result.get i)) < 1e-7))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_arctanh", "vc-description": "/-  numpy.arctanh: Inverse hyperbolic tangent element-wise.\n\n    Computes the inverse hyperbolic tangent of each element in the input array.\n    The inverse hyperbolic tangent is defined for values in the open interval (-1, 1).\n\n    For a real number x with |x| < 1, arctanh(x) is the value y such that tanh(y) = x.\n    Mathematically: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n\n    Returns an array of the same shape as x, containing the inverse hyperbolic tangent \n    of each element.\n-/\n\n/-  Specification: numpy.arctanh returns a vector where each element is the inverse\n    hyperbolic tangent of the corresponding element in x.\n\n    Precondition: All elements must be in the open interval (-1, 1) for real-valued results\n    Postcondition: For all indices i, result[i] = Float.atanh x[i]\n\n    Mathematical properties:\n    - arctanh(0) = 0 (identity property)\n    - arctanh is an odd function: arctanh(-x) = -arctanh(x)\n    - For |x| < 1: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n    - arctanh is strictly increasing on (-1, 1)\n    - Domain preservation: all results are finite real numbers\n    - Range property: arctanh maps (-1, 1) to (-\u221e, \u221e)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_arctanh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_arctanh_spec {n : Nat} (x : Vector Float n) \n    (h_domain : \u2200 i : Fin n, -1 < x.get i \u2227 x.get i < 1) :\n    \u2983\u231c\u2200 i : Fin n, -1 < x.get i \u2227 x.get i < 1\u231d\u2984\n    numpy_arctanh x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.atanh (x.get i) \u2227\n                 -- Identity property: arctanh(0) = 0\n                 (x.get i = 0 \u2192 result.get i = 0) \u2227\n                 -- Odd function property: arctanh(-x) = -arctanh(x)\n                 (\u2200 j : Fin n, x.get j = -(x.get i) \u2192 result.get j = -(result.get i)) \u2227\n                 -- Monotonicity: arctanh is strictly increasing\n                 (\u2200 j : Fin n, x.get i < x.get j \u2192 result.get i < result.get j) \u2227\n                 -- Range property: result is a finite real number\n                 (\u00ac(result.get i).isNaN \u2227 \u00ac(result.get i).isInf)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_around", "vc-description": "/- \n{\n  \"name\": \"numpy.around\",\n  \"description\": \"Evenly round to the given number of decimals\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.around.html\",\n  \"doc\": \"Evenly round to the given number of decimals.\\n\\nAlias for numpy.round.\",\n}\n-/\n\n/-  numpy.around: Evenly round to the given number of decimals (alias for numpy.round).\n    Uses banker's rounding (round half to even) for values exactly halfway between rounded decimal values.\n    For example: 1.5 and 2.5 both round to 2.0, -0.5 and 0.5 both round to 0.0 -/\n\n/-  Specification: around rounds each element to the given number of decimals with the following properties:\n    1. Basic rounding: rounds to nearest representable value at the specified decimal precision\n    2. Banker's rounding: for values exactly halfway between rounded decimal values, rounds to nearest even\n    3. Zero preservation: rounding zero always produces zero\n    4. Order preservation: maintains relative ordering of elements\n    5. Bounded difference: the rounded value is close to the original value\n    6. Idempotency: rounding an already-rounded value doesn't change it -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def around {n : Nat} (a : Vector Float n) (decimals : Int := 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem around_spec {n : Nat} (a : Vector Float n) (decimals : Int := 0) :\n    \u2983\u231cTrue\u231d\u2984\n    around a decimals\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Zero preservation: rounding zero gives zero\n      (a.get i = 0 \u2192 result.get i = 0) \u2227\n      -- Order preservation: maintains ordering\n      (\u2200 j : Fin n, a.get i \u2264 a.get j \u2192 result.get i \u2264 result.get j) \u2227\n      -- Boundedness: rounded values are close to original values\n      (decimals = 0 \u2192 \n       (result.get i - 1 \u2264 a.get i \u2227 a.get i \u2264 result.get i + 1)) \u2227\n      -- Symmetry: rounding negatives has expected behavior\n      (a.get i \u2265 0 \u2192 result.get i \u2265 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cbrt", "vc-description": "/- \n{\n  \"name\": \"numpy.cbrt\",\n  \"description\": \"Return the cube-root of an array, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.cbrt.html\",\n  \"doc\": \"Return the cube-root of an array, element-wise.\",\n}\n-/\n\n/-  numpy.cbrt: Return the cube-root of an array, element-wise.\n\n    Computes the cube root of each element in the input array.\n    The cube root function is defined for all real numbers, including negative numbers.\n    For any real number x, cbrt(x) = y such that y\u00b3 = x.\n\n    Returns an array of the same shape as x, containing the cube roots.\n-/\n\n/-  Specification: numpy.cbrt returns a vector where each element is the\n    cube root of the corresponding element in x.\n\n    Precondition: True (cube root is defined for all real numbers)\n    Postcondition: For all indices i, (result[i])\u00b3 = x[i]\n\n    Mathematical properties:\n    - cbrt(x\u00b3) = x for all x\n    - cbrt(-x) = -cbrt(x) (odd function)\n    - cbrt(0) = 0\n    - cbrt(1) = 1\n    - cbrt(8) = 2\n    - cbrt(-8) = -2\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def cbrt {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem cbrt_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    cbrt x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, (result.get i) ^ 3 = x.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_ceil", "vc-description": "/- \n{\n  \"name\": \"numpy.ceil\",\n  \"description\": \"Return the ceiling of the input, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ceil.html\",\n  \"doc\": \"Return the ceiling of the input, element-wise.\\n\\nThe ceiling of the scalar x is the smallest integer i, such that i >= x.\",\n}\n-/\n\n/-  numpy.ceil: Return the ceiling of the input, element-wise.\n\n    The ceiling of each element x is the smallest integer i, such that i >= x.\n    This is a fundamental mathematical operation that rounds up to the\n    nearest integer.\n\n    Returns an array of the same shape as x, containing the ceiling of each element.\n-/\n\n/-  Specification: numpy.ceil returns a vector where each element is the\n    ceiling (smallest integer greater than or equal to) the corresponding element in x.\n\n    Precondition: True (ceiling is defined for all real numbers)\n    Postcondition: For all indices i, result[i] is the ceiling of x[i], meaning:\n    - result[i] is an integer value (represented as Float)\n    - result[i] \u2265 x[i]\n    - result[i] < x[i] + 1\n    - There is no integer k such that x[i] \u2264 k < result[i]\n    - Monotonicity: if x[i] \u2264 x[j] then result[i] \u2264 result[j]\n    - Relationship with floor: result[i] = -((-x[i]).floor)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_ceil {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_ceil_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_ceil x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      (\u2203 k : Int, result.get i = Float.ofInt k) \u2227\n      result.get i \u2265 x.get i \u2227\n      result.get i < x.get i + 1 \u2227\n      (\u2200 k : Int, x.get i \u2264 Float.ofInt k \u2192 result.get i \u2264 Float.ofInt k) \u2227\n      (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j) \u2227\n      result.get i = -((-x.get i).floor)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_clip", "vc-description": "/-  numpy.clip: Clip (limit) the values in an array.\n\n    Given an interval [min_val, max_val], values outside the interval are clipped to the interval edges.\n    Values smaller than min_val become min_val, and values larger than max_val become max_val.\n\n    This operation is equivalent to but faster than np.minimum(max_val, np.maximum(arr, min_val)).\n    The function performs element-wise clipping and preserves the shape of the input array.\n\n    From NumPy documentation:\n    - Parameters: \n      - a (array_like) - Array containing elements to clip\n      - a_min (scalar) - Minimum value threshold\n      - a_max (scalar) - Maximum value threshold\n    - Returns: clipped array with values limited to [a_min, a_max]\n\n    Special behavior:\n    - If a_min > a_max, all values become a_max\n    - No validation is performed to ensure a_min < a_max\n-/\n\n/-  Specification: numpy.clip returns a vector where each element is clipped to the interval [min_val, max_val].\n\n    Mathematical Properties:\n    1. Element-wise correctness: \n       - If arr[i] < min_val, then result[i] = min_val\n       - If arr[i] > max_val, then result[i] = max_val  \n       - If min_val \u2264 arr[i] \u2264 max_val, then result[i] = arr[i]\n    2. Boundary behavior: Values are clamped to the closed interval [min_val, max_val]\n    3. Preserves vector length: result.size = arr.size\n    4. Idempotency: clip(clip(arr, min_val, max_val), min_val, max_val) = clip(arr, min_val, max_val)\n    5. Monotonicity: If min_val \u2264 max_val, then min_val \u2264 result[i] \u2264 max_val for all i\n    6. Special case: If min_val > max_val, then result[i] = max_val for all i\n\n    Precondition: True (no special preconditions, handles all real number inputs)\n    Postcondition: For all indices i, result[i] is the clipped value of arr[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def clip {n : Nat} (arr : Vector Float n) (min_val max_val : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem clip_spec {n : Nat} (arr : Vector Float n) (min_val max_val : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    clip arr min_val max_val\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (if min_val \u2264 max_val then\n        (if arr.get i < min_val then result.get i = min_val\n         else if arr.get i > max_val then result.get i = max_val\n         else result.get i = arr.get i)\n      else \n        result.get i = max_val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_conj", "vc-description": "/- \n{\n  \"name\": \"numpy.conj\",\n  \"description\": \"Return the complex conjugate, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.conj.html\",\n  \"doc\": \"Return the complex conjugate, element-wise.\\n\\nSignature: numpy.conj(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Input value\\n  out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored\\n\\nReturns:\\n  y: ndarray - Complex conjugate of x, with same dtype as x\",\n}\n-/\n\n/-  Return the complex conjugate of a vector of complex numbers, element-wise -/\n\n/-  Specification: conj computes the complex conjugate of each element with the following properties:\n    1. Basic definition: conj(a + bi) = a - bi for complex numbers\n    2. Real preservation: For purely real numbers, conj(x) = x\n    3. Involution property: conj(conj(x)) = x (double conjugation returns original)\n    4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)\n    5. Distributive over addition: conj(x + y) = conj(x) + conj(y)\n    6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a complex number with float components -/\nstructure Complex where\n  /-- The real part of the complex number -/\n  real : Float\n  /-- The imaginary part of the complex number -/\n  imag : Float\n\n/-- Addition of complex numbers -/\ndef Complex.add (z w : Complex) : Complex :=\n  Complex.mk (z.real + w.real) (z.imag + w.imag)\n/-- Multiplication of complex numbers -/\ndef Complex.mul (z w : Complex) : Complex :=\n  Complex.mk (z.real * w.real - z.imag * w.imag) (z.real * w.imag + z.imag * w.real)\n/-- Magnitude squared of a complex number -/\ndef Complex.normSq (z : Complex) : Float :=\n  z.real * z.real + z.imag * z.imag", "vc-helpers": "", "vc-definitions": "def conj {n : Nat} (x : Vector Complex n) : Id (Vector Complex n) :=\n  sorry", "vc-theorems": "theorem conj_spec {n : Nat} (x : Vector Complex n) :\n    \u2983\u231cTrue\u231d\u2984\n    conj x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = Complex.mk (x.get i).real (-(x.get i).imag)) \u2227\n                 (\u2200 i : Fin n, (x.get i).imag = 0 \u2192 result.get i = x.get i) \u2227\n                 (\u2200 i : Fin n, \n                    let doubleConj := Complex.mk (result.get i).real (-(result.get i).imag)\n                    doubleConj = x.get i) \u2227\n                 (\u2200 i : Fin n, Complex.normSq (x.get i) = Complex.normSq (result.get i)) \u2227\n                 (\u2200 i : Fin n, \u2200 (y : Complex),\n                    let sum := Complex.add (x.get i) y\n                    let conjSum := Complex.mk sum.real (-sum.imag)\n                    let conjX := result.get i\n                    let conjY := Complex.mk y.real (-y.imag)\n                    conjSum = Complex.add conjX conjY) \u2227\n                 (\u2200 i : Fin n, \u2200 (y : Complex),\n                    let prod := Complex.mul (x.get i) y\n                    let conjProd := Complex.mk prod.real (-prod.imag)\n                    let conjX := result.get i\n                    let conjY := Complex.mk y.real (-y.imag)\n                    conjProd = Complex.mul conjX conjY)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_convolve", "vc-description": "/-  numpy.convolve: Returns the discrete, linear convolution of two one-dimensional arrays.\n\n    The discrete convolution operation is defined as:\n    (a * v)[n] = sum(a[m] * v[n - m], m = -\u221e to \u221e)\n\n    For finite arrays, the convolution is computed over the valid range where\n    both arrays have elements. This implementation follows the 'full' mode\n    which returns a convolution of length (M + N - 1) where M and N are\n    the lengths of the input arrays.\n-/\n\n/-  Specification: numpy.convolve returns the discrete convolution of two vectors.\n\n    Precondition: Both input vectors must be non-empty (enforced by types)\n    Postcondition: The result vector contains the discrete convolution values\n\n    The convolution at position k is computed as:\n    result[k] = sum(a[i] * v[k - i] for all valid i)\n\n    Mathematical properties:\n    1. Result length is m + n - 1 (enforced by return type)\n    2. Each element follows the convolution definition\n    3. Boundary conditions: zero-padding is implicitly assumed outside array bounds\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_convolve {m n : Nat} (a : Vector Float m) (v : Vector Float n) : Id (Vector Float (m + n - 1)) :=\n  sorry", "vc-theorems": "theorem numpy_convolve_spec {m n : Nat} (a : Vector Float m) (v : Vector Float n) \n    (h_m : m > 0) (h_n : n > 0) :\n    \u2983\u231cm > 0 \u2227 n > 0\u231d\u2984\n    numpy_convolve a v\n    \u2983\u21d3result => \u231c\n      -- Core convolution property: each element is sum of products\n      \u2200 k : Fin (m + n - 1), result.get k = \n        List.sum (List.range m |>.map (fun i => \n          if k.val \u2265 i \u2227 k.val - i < n then \n            a.get \u27e8i, sorry\u27e9 * v.get \u27e8k.val - i, sorry\u27e9\n          else 0)) \u2227\n      -- Sanity checks for edge cases\n      (result.get \u27e80, sorry\u27e9 = a.get \u27e80, sorry\u27e9 * v.get \u27e80, sorry\u27e9) \u2227\n      (result.get \u27e8m + n - 2, sorry\u27e9 = a.get \u27e8m - 1, sorry\u27e9 * v.get \u27e8n - 1, sorry\u27e9) \u2227\n      -- Mathematical property: convolution preserves finite values\n      (\u2200 i : Fin m, a.get i = a.get i) \u2227 (\u2200 j : Fin n, v.get j = v.get j) \u2192\n      (\u2200 k : Fin (m + n - 1), result.get k = result.get k)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_copysign", "vc-description": "/-  numpy.copysign: Change the sign of x1 to that of x2, element-wise.\n\n    Returns an array where each element has the magnitude of x1 but the sign of x2.\n    This function is useful for combining the absolute value of one array with \n    the sign pattern of another.\n\n    For each element:\n    - If x2 >= 0, returns |x1|\n    - If x2 < 0, returns -|x1|\n\n    Special cases:\n    - copysign(x, 0) returns |x| (positive sign)\n    - copysign(0, y) returns 0 with the sign of y\n-/\n\n/-  Specification: numpy.copysign returns a vector where each element has\n    the magnitude of the corresponding element in x1 but the sign of the\n    corresponding element in x2.\n\n    Precondition: True (no special preconditions for copysign)\n    Postcondition: For all indices i:\n      - If x2[i] >= 0, then result[i] = |x1[i]|\n      - If x2[i] < 0, then result[i] = -|x1[i]|\n\n    Mathematical properties:\n      1. result[i] = |x1[i]| * sign(x2[i]) where sign(x) = 1 if x >= 0, -1 if x < 0\n      2. |result[i]| = |x1[i]| (magnitude preservation)\n      3. sign(result[i]) = sign(x2[i]) (sign copying)\n      4. copysign(x1, x2) = copysign(|x1|, x2) (idempotence on magnitude)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def copysign {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem copysign_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    copysign x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Basic behavior: sign copying with magnitude preservation\n      (x2.get i \u2265 0 \u2192 result.get i = Float.abs (x1.get i)) \u2227\n      (x2.get i < 0 \u2192 result.get i = -(Float.abs (x1.get i))) \u2227\n      -- Magnitude preservation property: |result[i]| = |x1[i]|\n      Float.abs (result.get i) = Float.abs (x1.get i) \u2227\n      -- Sign copying property: result has same sign as x2\n      ((x2.get i \u2265 0 \u2192 result.get i \u2265 0) \u2227 (x2.get i < 0 \u2192 result.get i < 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cos", "vc-description": "/- \n{\n  \"name\": \"numpy.cos\",\n  \"description\": \"Cosine element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.cos.html\",\n  \"doc\": \"Cosine element-wise.\\n\\nSignature: numpy.cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Input array in radians\\n  out: ndarray, optional - A location into which the result is stored\\n\\nReturns:\\n  y: array_like - The corresponding cosine values\",\n}\n-/\n\n/-  numpy.cos: Cosine element-wise.\n\n    Computes the cosine of each element in the input array.\n    The cosine is one of the fundamental functions of trigonometry.\n    For a real number x interpreted as an angle in radians, cos(x)\n    gives the x-coordinate of the point on the unit circle.\n\n    Returns an array of the same shape as x, containing the cosine of each element.\n-/\n\n/-  Specification: numpy.cos returns a vector where each element is the cosine\n    of the corresponding element in x (interpreted as radians).\n\n    Precondition: True (no special preconditions for cosine)\n    Postcondition: For all indices i, result[i] = Float.cos x[i]\n                  and result[i] is bounded between -1 and 1\n                  with cos(0) = 1\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_cos {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_cos_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_cos x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.cos (x.get i) \u2227\n                  result.get i \u2265 -1 \u2227 result.get i \u2264 1 \u2227\n                  (x.get i = 0 \u2192 result.get i = 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cosh", "vc-description": "/- \n{\n  \"name\": \"numpy.cosh\",\n  \"description\": \"Hyperbolic cosine, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.cosh.html\",\n  \"doc\": \"Hyperbolic cosine, element-wise.\\n\\nEquivalent to 1/2 * (np.exp(x) + np.exp(-x)) and np.cos(1j*x).\",\n}\n-/\n\n/-  numpy.cosh: Hyperbolic cosine, element-wise.\n\n    The hyperbolic cosine function is defined as:\n    cosh(x) = (e^x + e^(-x)) / 2\n\n    It represents the x-coordinate of a point on the unit hyperbola,\n    analogous to how cosine represents the x-coordinate on the unit circle.\n\n    Returns an array of the same shape as x, containing the hyperbolic cosine of each element.\n-/\n\n/-  Specification: numpy.cosh returns a vector where each element is the hyperbolic cosine\n    of the corresponding element in x.\n\n    Precondition: True (no special preconditions for hyperbolic cosine)\n    Postcondition: \n    1. For all indices i, result[i] = (e^x[i] + e^(-x[i])) / 2\n    2. All result values are \u2265 1 (minimum value of cosh is 1 at x=0)\n    3. The function is even: cosh(-x) = cosh(x)\n    4. Monotonicity: cosh is decreasing on (-\u221e, 0] and increasing on [0, \u221e)\n    5. Range property: cosh(x) \u2208 [1, \u221e) for all x \u2208 \u211d\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_cosh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_cosh_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_cosh x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Core mathematical definition: cosh(x) = (e^x + e^(-x))/2\n        result.get i = (Float.exp (x.get i) + Float.exp (-(x.get i))) / 2 \u2227\n        -- Minimum value property: cosh(x) \u2265 1 for all x\n        result.get i \u2265 1 \u2227\n        -- Even function property: cosh(-x) = cosh(x)\n        (Float.exp (-(x.get i)) + Float.exp (x.get i)) / 2 = \n        (Float.exp (x.get i) + Float.exp (-(x.get i))) / 2 \u2227\n        -- Monotonicity on non-negative reals: x \u2265 0 \u2192 cosh(x) \u2265 cosh(0) = 1\n        (x.get i \u2265 0 \u2192 result.get i \u2265 1) \u2227\n        -- Symmetry property: cosh(x) = cosh(|x|)\n        result.get i = (Float.exp (Float.abs (x.get i)) + Float.exp (-(Float.abs (x.get i)))) / 2 \u2227\n        -- Identity property: cosh(0) = 1\n        (x.get i = 0 \u2192 result.get i = 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cross", "vc-description": "/-  numpy.cross: Return the cross product of two (arrays of) vectors.\n\n    The cross product of a and b in R^3 is a vector perpendicular to both a and b.\n    For 3D vectors a = [a0, a1, a2] and b = [b0, b1, b2], the cross product is:\n    c = [a1*b2 - a2*b1, a2*b0 - a0*b2, a0*b1 - a1*b0]\n\n    This implementation focuses on the 3D case, which is the most common usage.\n    The result vector is perpendicular to both input vectors according to the\n    right-hand rule.\n-/\n\n/-  Specification: numpy.cross returns the cross product of two 3D vectors.\n\n    Precondition: True (vectors must be 3D, enforced by type)\n    Postcondition: \n    1. The result components follow the cross product formula\n    2. The result is perpendicular to both input vectors (dot product is zero)\n    3. Anti-commutativity: a \u00d7 b = -(b \u00d7 a)\n    4. Bilinearity properties\n    5. Zero property: if a and b are parallel, then a \u00d7 b = 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def cross (a b : Vector Float 3) : Id (Vector Float 3) :=\n  sorry", "vc-theorems": "theorem cross_spec (a b : Vector Float 3) :\n    \u2983\u231cTrue\u231d\u2984\n    cross a b\n    \u2983\u21d3result => \u231c\n      -- Cross product formula components\n      result.get 0 = a.get 1 * b.get 2 - a.get 2 * b.get 1 \u2227\n      result.get 1 = a.get 2 * b.get 0 - a.get 0 * b.get 2 \u2227\n      result.get 2 = a.get 0 * b.get 1 - a.get 1 * b.get 0 \u2227\n      -- Perpendicularity property: result \u00b7 a = 0 and result \u00b7 b = 0\n      (result.get 0 * a.get 0 + result.get 1 * a.get 1 + result.get 2 * a.get 2 = 0) \u2227\n      (result.get 0 * b.get 0 + result.get 1 * b.get 1 + result.get 2 * b.get 2 = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cumprod", "vc-description": "/- \n{\n  \"name\": \"numpy.cumprod\",\n  \"description\": \"Return the cumulative product of elements along a given axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.cumprod.html\",\n  \"doc\": \"Return the cumulative product of elements along a given axis.\",\n}\n-/\n\n/-  numpy.cumprod: Return the cumulative product of elements along a given axis.\n\n    For a vector [a\u2081, a\u2082, a\u2083, ..., a\u2099], returns [a\u2081, a\u2081*a\u2082, a\u2081*a\u2082*a\u2083, ..., a\u2081*a\u2082*...*a\u2099].\n\n    This function computes the cumulative product by applying successive multiplications\n    from left to right, producing a result vector of the same length as the input.\n\n    The cumulative product is computed as: result[i] = \u220f(k=0 to i) input[k]\n\n    For empty vectors, returns an empty vector.\n-/\n\n/-  Specification: cumprod returns the cumulative product of elements.\n\n    Precondition: True (works for any vector, including empty)\n    Postcondition: \n    - Result has same length as input\n    - For any index i, result[i] = product of all elements from a[0] to a[i] inclusive\n    - Equivalently: result[i] = a[0] * a[1] * ... * a[i]\n    - For empty vectors, returns empty vector (vacuous condition holds)\n\n    Mathematical Properties:\n    - result[0] = a[0] (when n > 0)\n    - result[i+1] = result[i] * a[i+1] (cumulative property)\n    - Each element is the product of all preceding elements (including itself)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def cumprod {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem cumprod_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    cumprod a\n    \u2983\u21d3result => \u231c-- Basic correctness: each element is cumulative product up to that point\n                 (\u2200 i : Fin n, result.get i = (a.toList.take (i.val + 1)).foldl (\u00b7 * \u00b7) 1) \u2227\n                 -- Sanity check: result has same length as input\n                 result.toList.length = n \u2227\n                 -- Key mathematical property: cumulative structure (each element incorporates previous)\n                 (\u2200 i j : Fin n, i.val + 1 = j.val \u2192 result.get j = result.get i * a.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_cumsum", "vc-description": "/-  numpy.cumsum: Return the cumulative sum of the elements along a given axis.\n\n    For a 1D array, cumsum computes the cumulative sum where each element\n    is the sum of all previous elements plus itself. For example:\n    [1, 2, 3, 4] becomes [1, 3, 6, 10]\n\n    The cumulative sum is defined as:\n    - result[0] = a[0]\n    - result[i] = result[i-1] + a[i] for i > 0\n-/\n\n/-  Specification: numpy.cumsum returns a vector where each element is the\n    cumulative sum up to that position.\n\n    Precondition: True (no special preconditions)\n    Postcondition: \n    - For non-empty vectors, the first element equals the first element of the input\n    - Each subsequent element equals the previous cumulative sum plus the current element\n    - The cumulative sum has the property that result[i] = sum of a[0] through a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_cumsum {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_cumsum_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_cumsum a\n    \u2983\u21d3result => \u231c\n      -- For non-empty vectors, first element property\n      (n > 0 \u2192 result.get \u27e80, sorry\u27e9 = a.get \u27e80, sorry\u27e9) \u2227\n      -- Recurrence relation: each element is previous cumsum + current element\n      (\u2200 i : Fin n, i.val > 0 \u2192 \n        result.get i = result.get \u27e8i.val - 1, sorry\u27e9 + a.get i) \u2227\n      -- Cumulative sum property: each element is the sum of all previous elements plus current\n      (\u2200 i : Fin n, result.get i = List.sum ((List.range (i.val + 1)).map (fun j => a.get \u27e8j, sorry\u27e9)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_deg2rad", "vc-description": "/- \n{\n  \"name\": \"numpy.deg2rad\",\n  \"description\": \"Convert angles from degrees to radians\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.deg2rad.html\",\n  \"doc\": \"Convert angles from degrees to radians.\\n\\nEquivalent to numpy.radians.\",\n}\n-/\n\n/-  Convert angles from degrees to radians by multiplying by \u03c0/180.\n    This function performs the standard mathematical conversion from degrees to radians\n    where \u03c0 radians = 180 degrees. -/\n\n/-  Specification: deg2rad converts each degree value to radians using the formula radians = degrees * \u03c0/180 -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def deg2rad {n : Nat} (degrees : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem deg2rad_spec {n : Nat} (degrees : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    deg2rad degrees\n    \u2983\u21d3radians => \u231c\u2200 i : Fin n, radians.get i = degrees.get i * (3.14159265358979323846 / 180.0) \u2227\n                  -- Standard conversion points (sanity checks)\n                  (degrees.get i = 0.0 \u2192 radians.get i = 0.0) \u2227\n                  (degrees.get i = 90.0 \u2192 radians.get i = 3.14159265358979323846 / 2.0) \u2227\n                  (degrees.get i = 180.0 \u2192 radians.get i = 3.14159265358979323846) \u2227\n                  (degrees.get i = 270.0 \u2192 radians.get i = 3.0 * 3.14159265358979323846 / 2.0) \u2227\n                  (degrees.get i = 360.0 \u2192 radians.get i = 2.0 * 3.14159265358979323846) \u2227\n                  -- Negative values work correctly\n                  (degrees.get i = -90.0 \u2192 radians.get i = -3.14159265358979323846 / 2.0) \u2227\n                  (degrees.get i = -180.0 \u2192 radians.get i = -3.14159265358979323846) \u2227\n                  -- Periodicity property: adding 360 degrees = adding 2\u03c0 radians\n                  ((degrees.get i + 360.0) * (3.14159265358979323846 / 180.0) = \n                   radians.get i + 2.0 * 3.14159265358979323846)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_diff", "vc-description": "/-  numpy.diff: Calculate the n-th discrete difference along the given axis.\n\n    The first difference is given by out[i] = a[i+1] - a[i] along the given axis.\n    Higher differences are calculated by using diff recursively.\n\n    For a 1D array, the first difference computes the difference between \n    consecutive elements, producing an array with one less element.\n\n    The function is particularly useful for numerical analyses where \n    understanding incremental changes within data is crucial.\n-/\n\n/-  Specification: numpy.diff returns a vector where each element is the difference\n    of consecutive elements from the input array.\n\n    Precondition: Input array must be non-empty (at least 2 elements for first difference)\n    Postcondition: For all indices i, result[i] = a[i+1] - a[i]\n\n    Mathematical Properties:\n    1. Length property: |result| = |input| - 1\n    2. Difference property: Each element represents the discrete difference\n    3. Type preservation: Result maintains the same numeric type as input\n    4. Monotonicity: If input is monotonic, result has consistent sign\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_diff {n : Nat} (a : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_diff_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_diff a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = a.get \u27e8i.val + 1, by simp [Fin.is_lt]\u27e9 - a.get \u27e8i.val, Nat.lt_succ_of_lt i.is_lt\u27e9\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_divide", "vc-description": "/-  numpy.divide: Divide arguments element-wise.\n\n    Divides two vectors element-wise. If the vectors have the same shape,\n    each element of the result is the quotient of the corresponding elements\n    from the input vectors.\n\n    This is equivalent to x1 / x2 in terms of array broadcasting.\n    Division by zero results in infinity or NaN according to IEEE 754 standard.\n-/\n\n/-  Specification: numpy.divide returns a vector where each element is the quotient\n    of the corresponding elements from x1 and x2.\n\n    Precondition: True (handles division by zero according to IEEE 754)\n    Postcondition: For all indices i, result[i] = x1[i] / x2[i]\n\n    Additional properties:\n    - When x2[i] \u2260 0, result[i] * x2[i] = x1[i] (within floating point precision)\n    - When x2[i] = 0 and x1[i] \u2260 0, result[i] is infinite\n    - When x2[i] = 0 and x1[i] = 0, result[i] is NaN\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_divide {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_divide_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_divide x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (x2.get i \u2260 0 \u2192 result.get i = x1.get i / x2.get i) \u2227\n      (x2.get i \u2260 0 \u2192 result.get i * x2.get i = x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_divmod", "vc-description": "/-  numpy.divmod: Return element-wise quotient and remainder simultaneously.\n\n    Performs element-wise division returning both the quotient and remainder.\n    For each pair of elements (x, y), returns (x // y, x % y) where:\n    - x // y is the floor division (largest integer \u2264 x/y)\n    - x % y is the remainder such that x = y * (x // y) + (x % y)\n\n    This is equivalent to (x // y, x % y) but faster because it avoids\n    redundant work by computing both values in a single operation.\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n    - Returns: (quotient, remainder) - tuple of ndarrays with element-wise results\n\n    Mathematical properties:\n    1. Division identity: x1[i] = x2[i] * quotient[i] + remainder[i]\n    2. Remainder bounds: 0 \u2264 |remainder[i]| < |x2[i]| (for positive divisors)\n    3. Sign consistency: remainder has same sign as divisor (Python % semantics)\n-/\n\n/-  Specification: numpy.divmod returns a tuple of vectors containing the quotient \n    and remainder of element-wise division.\n\n    Mathematical Properties:\n    1. Division identity: For all i, x1[i] = x2[i] * quotient[i] + remainder[i]\n    2. Quotient correctness: quotient[i] = floor(x1[i] / x2[i])\n    3. Remainder correctness: remainder[i] = x1[i] - x2[i] * quotient[i]\n    4. Remainder bounds: |remainder[i]| < |x2[i]| (when x2[i] \u2260 0)\n    5. Sign consistency: remainder[i] has same sign as x2[i] (Python % semantics)\n    6. Equivalence: divmod(x1, x2) = (floor_divide(x1, x2), mod(x1, x2))\n\n    Precondition: All elements in x2 must be non-zero\n    Postcondition: Returns (quotient, remainder) where the mathematical properties hold\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def divmod {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem divmod_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2260 0\u231d\u2984\n    divmod x1 x2\n    \u2983\u21d3result => \u231clet (quotient, remainder) := result\n                  \u2200 i : Fin n, \n                    quotient.get i = (x1.get i / x2.get i).floor \u2227\n                    remainder.get i = x1.get i - x2.get i * quotient.get i \u2227\n                    x1.get i = x2.get i * quotient.get i + remainder.get i \u2227\n                    (x2.get i > 0 \u2192 0 \u2264 remainder.get i \u2227 remainder.get i < x2.get i) \u2227\n                    (x2.get i < 0 \u2192 x2.get i < remainder.get i \u2227 remainder.get i \u2264 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_ediff1d", "vc-description": "/-  numpy.ediff1d: The differences between consecutive elements of an array.\n\n    Computes the differences between consecutive elements of an array.\n    For an input array [a, b, c, d], returns [b-a, c-b, d-c].\n\n    The function always returns a 1D array, and if necessary, the input\n    will be flattened before the differences are taken.\n\n    This is equivalent to ary.flat[1:] - ary.flat[:-1] in NumPy.\n-/\n\n/-  Specification: numpy.ediff1d returns a vector of differences between consecutive elements.\n\n    Precondition: The input vector must have at least one element (enforced by type)\n    Postcondition: For all indices i, result[i] = ary[i+1] - ary[i]\n\n    Key properties:\n    1. The result has length n for input of length n+1\n    2. Each element represents the difference between consecutive elements\n    3. The result is always 1D regardless of input shape\n    4. Mathematically: result[i] = ary[i+1] - ary[i] for all valid i\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_ediff1d {n : Nat} (ary : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_ediff1d_spec {n : Nat} (ary : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_ediff1d ary\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = ary.get (i.succ) - ary.get (i.castSucc)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_exp", "vc-description": "/-  numpy.exp: Calculate the exponential of all elements in the input array.\n\n    Computes the exponential function (e^x) element-wise. This is the inverse\n    of the natural logarithm function. For each element x in the input array,\n    the result contains e^x where e is Euler's number (approximately 2.71828).\n\n    The exponential function has the mathematical property that exp(x + y) = exp(x) * exp(y)\n    and exp(0) = 1.\n\n    Returns an array of the same shape as x, containing the exponential values.\n-/\n\n/-  Specification: numpy.exp returns a vector where each element is the\n    exponential (e^x) of the corresponding element in x.\n\n    Precondition: True (exponential function is defined for all real numbers)\n    Postcondition: For all indices i, result[i] = e^(x[i])\n\n    Mathematical properties:\n    - exp(0) = 1 for any zero elements\n    - exp(x) > 0 for all x (exponential is always positive)\n    - exp is monotonically increasing\n    - exp(x + y) = exp(x) * exp(y) (for addition in the input)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_exp {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_exp_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_exp x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.exp (x.get i) \u2227 \n                   result.get i > 0 \u2227\n                   (x.get i = 0 \u2192 result.get i = 1) \u2227\n                   (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_exp2", "vc-description": "/- \n{\n  \"name\": \"numpy.exp2\",\n  \"description\": \"Calculate 2**p for all p in the input array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.exp2.html\",\n  \"doc\": \"Calculate 2**p for all p in the input array.\",\n}\n-/\n\n/-  numpy.exp2: Calculate 2 raised to the power of each element in the input vector.\n\n    Computes 2^p for all p in the input vector, element-wise.\n    This is equivalent to applying the exponential function with base 2\n    to each element of the input vector.\n\n    From NumPy documentation:\n    - Parameters: x (array_like) - Input values\n    - Returns: y (ndarray) - 2**x, element-wise\n\n    The function is implemented as a universal function (ufunc) that\n    operates element-wise on arrays and supports broadcasting.\n    For finite input values, the result is always positive.\n-/\n\n/-  Specification: numpy.exp2 computes 2 raised to the power of each element \n    in the input vector.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = 2^x[i] for all i\n    2. Fundamental exponential identity: exp2(0) = 1\n    3. Base property: exp2(1) = 2\n    4. Negative powers: exp2(-1) = 0.5\n    5. Positivity: exp2(x) > 0 for all finite x\n    6. Monotonicity: if x[i] < x[j], then exp2(x)[i] < exp2(x)[j]\n    7. Exponential addition rule: exp2(a + b) = exp2(a) * exp2(b)\n    8. Preservation of vector length: result.size = x.size\n    9. Handles IEEE 754 floating-point arithmetic\n\n    Precondition: True (no special preconditions for exp2)\n    Postcondition: For all indices i, result[i] = 2^x[i] and result[i] > 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def exp2 {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem exp2_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    exp2 x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (2 : Float) ^ (x.get i) \u2227 \n                               result.get i > 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_expm1", "vc-description": "/-  Calculate exp(x) - 1 for all elements in the vector.\n    This function provides greater precision than exp(x) - 1 for small values of x. -/\n\n/-  Specification: expm1 computes exp(x) - 1 element-wise with enhanced numerical precision -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def expm1 {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem expm1_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    expm1 x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Basic mathematical property: result equals exp(x) - 1\n      result.get i = Float.exp (x.get i) - 1 \u2227\n      -- Monotonicity property: expm1 is strictly increasing\n      (\u2200 j : Fin n, x.get i < x.get j \u2192 result.get i < result.get j) \u2227\n      -- Identity property: expm1(0) = 0\n      (x.get i = 0 \u2192 result.get i = 0) \u2227\n      -- Asymptotic behavior for small values: exp(x) - 1 \u2248 x for small x\n      (Float.abs (x.get i) \u2264 0.1 \u2192 Float.abs (result.get i - x.get i) \u2264 Float.abs (x.get i) * Float.abs (x.get i)) \u2227\n      -- Sign preservation for small values\n      (Float.abs (x.get i) \u2264 1 \u2192 (x.get i > 0 \u2192 result.get i > 0) \u2227 (x.get i < 0 \u2192 result.get i < 0)) \u2227\n      -- Lower bound for positive values: expm1(x) > x for x > 0\n      (x.get i > 0 \u2192 result.get i > x.get i) \u2227\n      -- Upper bound for negative values: expm1(x) > -1 for all x\n      result.get i > -1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_fabs", "vc-description": "/- \n{\n  \"name\": \"numpy.fabs\",\n  \"description\": \"Compute the absolute values element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fabs.html\",\n  \"doc\": \"Compute the absolute values element-wise.\\n\\nThis function returns the absolute values (positive magnitude) of the data in x. Complex values are not handled, use absolute to find the absolute values of complex data.\",\n}\n-/\n\n/-  Compute the absolute values element-wise for floating-point numbers -/\n\n/-  Specification: fabs computes the absolute value of each element -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fabs {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fabs_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    fabs x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                  -- Primary property: result is the absolute value\n                  result.get i = Float.abs (x.get i) \u2227\n                  -- Non-negativity (mathematical property of absolute value)\n                  result.get i \u2265 0 \u2227\n                  -- Idempotence: abs(abs(x)) = abs(x)\n                  Float.abs (result.get i) = result.get i \u2227\n                  -- Symmetry: abs(x) = abs(-x)\n                  result.get i = Float.abs (-(x.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_fix", "vc-description": "/- \n{\n  \"name\": \"numpy.fix\",\n  \"description\": \"Round to nearest integer towards zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fix.html\",\n  \"doc\": \"Round to nearest integer towards zero.\\n\\nRounds an array of floats element-wise to nearest integer towards zero.\",\n}\n-/\n\n/-  numpy.fix: Round to nearest integer towards zero, element-wise.\n\n    The fix (truncation) of each element x is the integer part of x,\n    obtained by discarding the fractional part. This is equivalent to\n    rounding towards zero.\n\n    For positive numbers: fix(x) = floor(x)\n    For negative numbers: fix(x) = ceil(x)\n\n    Returns an array of the same shape as x, containing the fix of each element.\n-/\n\n/-  Specification: numpy.fix returns a vector where each element is the\n    fix (truncation towards zero) of the corresponding element in x.\n\n    Precondition: True (fix is defined for all real numbers)\n    Postcondition: For all indices i, result[i] is the fix of x[i], meaning:\n    - result[i] is an integer value (represented as Float)\n    - |result[i]| \u2264 |x[i]| (magnitude is reduced or equal)\n    - result[i] has the same sign as x[i] (or zero if x[i] is zero)\n    - |x[i] - result[i]| < 1 (difference is less than 1)\n    - For positive x[i]: result[i] = floor(x[i])\n    - For negative x[i]: result[i] = ceil(x[i])\n    - For zero x[i]: result[i] = 0\n    - Monotonicity: if x[i] \u2264 x[j] then result[i] \u2264 result[j]\n    - Truncation property: result[i] truncates towards zero\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_fix {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_fix_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_fix x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      (\u2203 k : Int, result.get i = Float.ofInt k) \u2227\n      (result.get i).abs \u2264 (x.get i).abs \u2227\n      (x.get i \u2265 0 \u2192 result.get i \u2265 0) \u2227\n      (x.get i \u2264 0 \u2192 result.get i \u2264 0) \u2227\n      (x.get i - result.get i).abs < 1 \u2227\n      (x.get i \u2265 0 \u2192 result.get i = (x.get i).floor) \u2227\n      (x.get i < 0 \u2192 result.get i = (x.get i).ceil) \u2227\n      (x.get i = 0 \u2192 result.get i = 0) \u2227\n      (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_float_power", "vc-description": "/- \n{\n  \"name\": \"numpy.float_power\",\n  \"description\": \"First array elements raised to powers from second array, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.float_power.html\",\n  \"doc\": \"First array elements raised to powers from second array, element-wise.\\n\\nRaise each base in x1 to the positionally-corresponding power in x2. This differs from the power function in that integers, float16, and float32 are promoted to floats with a minimum precision of float64.\",\n}\n-/\n\n/-  Element-wise power operation with float promotion. \n    Raises each element of the base vector to the corresponding power in the exponent vector.\n    All values are promoted to Float (minimum precision of Float64). -/\n\n/-  Specification: float_power computes element-wise exponentiation with appropriate constraints.\n    - For positive bases: result is always well-defined\n    - For zero bases: only non-negative exponents are valid\n    - For negative bases: only integer exponents are mathematically valid (though NumPy allows all)\n    - The result preserves the mathematical power relationship element-wise -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def float_power {n : Nat} (base : Vector Float n) (exponent : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem float_power_spec {n : Nat} (base : Vector Float n) (exponent : Vector Float n) \n    (h_valid : \u2200 i : Fin n, (base.get i > 0) \u2228 (base.get i = 0 \u2227 exponent.get i \u2265 0)) :\n    \u2983\u231c\u2200 i : Fin n, (base.get i > 0) \u2228 (base.get i = 0 \u2227 exponent.get i \u2265 0)\u231d\u2984\n    float_power base exponent\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (base.get i) ^ (exponent.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_floor", "vc-description": "/- \n{\n  \"name\": \"numpy.floor\",\n  \"description\": \"Return the floor of the input, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.floor.html\",\n  \"doc\": \"Return the floor of the input, element-wise.\\n\\nThe floor of the scalar x is the largest integer i, such that i <= x.\",\n}\n-/\n\n/-  numpy.floor: Return the floor of the input, element-wise.\n\n    The floor of each element x is the largest integer i, such that i <= x.\n    This is a fundamental mathematical operation that rounds down to the\n    nearest integer.\n\n    Returns an array of the same shape as x, containing the floor of each element.\n-/\n\n/-  Specification: numpy.floor returns a vector where each element is the\n    floor (largest integer less than or equal to) the corresponding element in x.\n\n    Precondition: True (floor is defined for all real numbers)\n    Postcondition: For all indices i, result[i] is the floor of x[i], meaning:\n    - result[i] is an integer value (represented as Float)\n    - result[i] \u2264 x[i]\n    - x[i] < result[i] + 1\n    - There is no integer k such that result[i] < k \u2264 x[i]\n    - Monotonicity: if x[i] \u2264 x[j] then result[i] \u2264 result[j]\n    - Idempotence: floor(floor(x)) = floor(x)\n    - Relationship with ceiling: result[i] = -((-x[i]).ceil) when x[i] is not an integer\n    - Integer preservation: if x[i] is an integer, then result[i] = x[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_floor {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_floor_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_floor x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      (\u2203 k : Int, result.get i = Float.ofInt k) \u2227\n      result.get i \u2264 x.get i \u2227\n      x.get i < result.get i + 1 \u2227\n      (\u2200 k : Int, Float.ofInt k \u2264 x.get i \u2192 Float.ofInt k \u2264 result.get i) \u2227\n      (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j) \u2227\n      (\u2203 k : Int, result.get i = Float.ofInt k \u2192 (result.get i).floor = result.get i) \u2227\n      result.get i = -((-x.get i).ceil) \u2227\n      (\u2203 k : Int, x.get i = Float.ofInt k \u2192 result.get i = x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_floor_divide", "vc-description": "/- \n{\n  \"name\": \"numpy.floor_divide\",\n  \"description\": \"Return the largest integer smaller or equal to the division of the inputs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.floor_divide.html\",\n  \"doc\": \"Return the largest integer smaller or equal to the division of the inputs.\\n\\nIt is equivalent to the Python // operator and pairs with the Python % (remainder), function so that a = a % b + b * (a // b) up to roundoff.\",\n}\n-/\n\n/-  numpy.floor_divide: Return the largest integer smaller or equal to the division of the inputs.\n\n    Performs element-wise floor division of two vectors. For each pair of elements,\n    returns the largest integer less than or equal to their division.\n\n    This is equivalent to the Python // operator and pairs with the modulo operation\n    such that a = a % b + b * (a // b) up to roundoff.\n-/\n\n/-  Specification: numpy.floor_divide returns a vector where each element is the floor\n    of the division of the corresponding elements from x1 and x2.\n\n    This function implements Python's // operator behavior for element-wise operations.\n\n    Precondition: All elements in x2 must be non-zero\n    Postcondition: \n    1. For all indices i, result[i] = floor(x1[i] / x2[i])\n    2. For all indices i, result[i] is the largest integer \u2264 x1[i] / x2[i]\n    3. The fundamental floor division property: result[i] \u2264 x1[i] / x2[i] < result[i] + 1\n    4. This pairs with modulo such that: x1[i] = x2[i] * result[i] + remainder\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_floor_divide {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_floor_divide_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2260 0\u231d\u2984\n    numpy_floor_divide x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        result.get i = (x1.get i / x2.get i).floor \u2227\n        result.get i \u2264 x1.get i / x2.get i \u2227\n        x1.get i / x2.get i < result.get i + 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_fmax", "vc-description": "/- \n{\n  \"name\": \"numpy.fmax\",\n  \"description\": \"Element-wise maximum of array elements\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fmax.html\",\n  \"doc\": \"Element-wise maximum of array elements.\\n\\nCompare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned.\",\n}\n-/\n\n/-  Element-wise maximum of two vectors, with special NaN handling.\n    If one element is NaN, returns the non-NaN element. -/\n\n/-  Specification: fmax returns element-wise maximum with NaN handling.\n    For each position i:\n    - If both elements are non-NaN, returns the maximum\n    - If x[i] is NaN and y[i] is not, returns y[i]  \n    - If y[i] is NaN and x[i] is not, returns x[i]\n    - If both are NaN, returns NaN\n    Additional mathematical properties:\n    - Commutative when both values are non-NaN\n    - Associative when all values are non-NaN\n    - Idempotent when values are non-NaN -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fmax {n : Nat} (x y : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fmax_spec {n : Nat} (x y : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    fmax x y\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Core NaN handling behavior\n      (\u00ac(x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i = max (x.get i) (y.get i)) \u2227\n      ((x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i = y.get i) \u2227\n      (\u00ac(x.get i).isNaN \u2227 (y.get i).isNaN \u2192 \n        result.get i = x.get i) \u2227\n      ((x.get i).isNaN \u2227 (y.get i).isNaN \u2192 \n        (result.get i).isNaN) \u2227\n      -- Mathematical properties for non-NaN cases\n      (\u00ac(x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i \u2265 x.get i \u2227 result.get i \u2265 y.get i) \u2227\n      (\u00ac(x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        (result.get i = x.get i \u2228 result.get i = y.get i)) \u2227\n      -- NaN preservation: result is NaN iff both inputs are NaN\n      ((result.get i).isNaN \u2194 ((x.get i).isNaN \u2227 (y.get i).isNaN))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_fmin", "vc-description": "/- \n{\n  \"name\": \"numpy.fmin\",\n  \"description\": \"Element-wise minimum of array elements\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fmin.html\",\n  \"doc\": \"Element-wise minimum of array elements.\\n\\nCompare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned.\",\n}\n-/\n\n/-  Element-wise minimum of two vectors, with special NaN handling.\n    If one element is NaN, returns the non-NaN element. -/\n\n/-  Specification: fmin returns element-wise minimum with NaN handling.\n    For each position i:\n    - If both elements are non-NaN, returns the minimum\n    - If x[i] is NaN and y[i] is not, returns y[i]  \n    - If y[i] is NaN and x[i] is not, returns x[i]\n    - If both are NaN, returns NaN\n    - Mathematical properties: commutativity (ignoring NaN order), \n      idempotence for non-NaN values, and boundedness -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fmin {n : Nat} (x y : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fmin_spec {n : Nat} (x y : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    fmin x y\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- NaN handling cases\n      (\u00ac(x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i = min (x.get i) (y.get i)) \u2227\n      ((x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i = y.get i) \u2227\n      (\u00ac(x.get i).isNaN \u2227 (y.get i).isNaN \u2192 \n        result.get i = x.get i) \u2227\n      ((x.get i).isNaN \u2227 (y.get i).isNaN \u2192 \n        (result.get i).isNaN) \u2227\n      -- Mathematical properties\n      (\u00ac(x.get i).isNaN \u2227 \u00ac(y.get i).isNaN \u2192 \n        result.get i \u2264 x.get i \u2227 result.get i \u2264 y.get i) \u2227\n      (\u00ac(result.get i).isNaN \u2192 \n        (result.get i = x.get i \u2228 result.get i = y.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_fmod", "vc-description": "/- \n{\n  \"name\": \"numpy.fmod\",\n  \"description\": \"Returns the element-wise remainder of division\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fmod.html\",\n  \"doc\": \"Returns the element-wise remainder of division.\\n\\nThis is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend x1.\",\n}\n-/\n\n/-  Returns the element-wise remainder of division where the remainder has the same sign as the dividend -/\n\n/-  Specification: fmod returns element-wise remainder with same sign as dividend,\n    handling division by zero by returning NaN -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def fmod {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem fmod_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    fmod x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- When divisor is zero, result is NaN\n      (x2.get i = 0 \u2192 Float.isNaN (result.get i)) \u2227\n      -- When divisor is non-zero, fmod properties hold\n      (x2.get i \u2260 0 \u2192 \n        -- The remainder r = x1 - k * x2 where k is truncated towards zero division\n        \u2203 k : Float, \n          result.get i = x1.get i - (k * x2.get i) \u2227\n          -- k is the truncated quotient (rounded towards zero)\n          Float.abs k \u2264 Float.abs (x1.get i / x2.get i) \u2227\n          Float.abs k < Float.abs (x1.get i / x2.get i) + 1 \u2227\n          -- The remainder has the same sign as the dividend x1 (or is zero)\n          (result.get i \u2260 0 \u2192 (result.get i > 0 \u2194 x1.get i > 0)) \u2227\n          -- The absolute value of remainder is less than absolute value of divisor\n          Float.abs (result.get i) < Float.abs (x2.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_frexp", "vc-description": "/-  numpy.frexp: Decompose the elements of x into mantissa and twos exponent.\n\n    Returns (mantissa, exponent), where x = mantissa * 2**exponent.\n    The mantissa is in the range [0.5, 1) for positive numbers, (-1, -0.5] for negative numbers,\n    or 0 if x is 0. The exponent is an integer.\n\n    For special values:\n    - If x is 0, returns (0.0, 0)\n    - If x is infinity, returns (infinity, 0)\n    - If x is NaN, returns (NaN, 0)\n-/\n\n/-  Specification: frexp decomposes each element into mantissa and exponent such that\n    x = mantissa * 2^exponent, where the mantissa is normalized to be in [0.5, 1) for\n    positive values or (-1, -0.5] for negative values.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i:\n    - If x[i] = 0, then mantissa[i] = 0 and exponent[i] = 0\n    - If x[i] is finite and non-zero, then:\n      - x[i] = mantissa[i] * 2^exponent[i] (reconstruction property)\n      - 0.5 \u2264 |mantissa[i]| < 1.0 (normalization property)\n      - mantissa[i] has same sign as x[i] (sign preservation)\n    - If x[i] is infinity or NaN, then mantissa[i] = x[i] and exponent[i] = 0\n    - Result vectors have same length as input (length preservation)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def frexp {n : Nat} (x : Vector Float n) : Id (Vector Float n \u00d7 Vector Int n) :=\n  sorry", "vc-theorems": "theorem frexp_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    frexp x\n    \u2983\u21d3result => \u231clet (mantissa, exponent) := result\n                 -- Element-wise properties (length is preserved by type)\n                 \u2200 i : Fin n,\n                   -- Zero case\n                   (x.get i = 0 \u2192 mantissa.get i = 0 \u2227 exponent.get i = 0) \u2227\n                   -- Non-zero finite case\n                   (x.get i \u2260 0 \u2227 Float.isFinite (x.get i) \u2192 \n                     -- Reconstruction property\n                     x.get i = mantissa.get i * Float.pow 2.0 (Float.ofInt (exponent.get i)) \u2227\n                     -- Normalization property\n                     0.5 \u2264 Float.abs (mantissa.get i) \u2227 \n                     Float.abs (mantissa.get i) < 1.0 \u2227\n                     -- Sign preservation\n                     (x.get i > 0 \u2192 mantissa.get i > 0) \u2227\n                     (x.get i < 0 \u2192 mantissa.get i < 0)) \u2227\n                   -- Special values case\n                   ((Float.isInf (x.get i) \u2228 Float.isNaN (x.get i)) \u2192 \n                     mantissa.get i = x.get i \u2227 exponent.get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_gcd", "vc-description": "/- \n{\n  \"name\": \"numpy.gcd\",\n  \"description\": \"Returns the greatest common divisor of |x1| and |x2|\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.gcd.html\",\n  \"doc\": \"Returns the greatest common divisor of |x1| and |x2|.\",\n}\n-/\n\n/-  numpy.gcd: Returns the greatest common divisor of |x1| and |x2|, element-wise.\n\n    The GCD is computed on the absolute values of the inputs. For two integers a and b,\n    gcd(a, b) is the largest positive integer that divides both |a| and |b|.\n\n    Special cases:\n    - gcd(0, 0) = 0\n    - gcd(a, 0) = |a| for any non-zero a\n    - gcd(0, b) = |b| for any non-zero b\n\n    Returns an array of the same shape as the broadcasted x1 and x2.\n-/\n\n/-  Specification: numpy.gcd returns a vector where each element is the\n    greatest common divisor of the absolute values of the corresponding elements in x1 and x2.\n\n    Precondition: True (gcd is defined for all integers)\n    Postcondition: For all indices i, result[i] equals the GCD of x1[i] and x2[i],\n    which is mathematically equivalent to the GCD of their absolute values.\n\n    Mathematical properties verified:\n    1. Correctness: result[i] = Int.gcd(x1[i], x2[i]) (uses Lean's built-in GCD function)\n    2. Non-negativity: result[i] \u2265 0 (GCD is always non-negative)\n    3. Equivalence to absolute values: gcd(a, b) = gcd(|a|, |b|)\n    4. Special cases: gcd(0,0)=0, gcd(a,0)=|a|, gcd(0,b)=|b|\n    5. Divisibility: gcd(a,b) divides both a and b\n    6. Greatest property: any common divisor of a and b also divides gcd(a,b)\n    7. Commutativity: gcd(a,b) = gcd(b,a)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_gcd {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem numpy_gcd_spec {n : Nat} (x1 x2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_gcd x1 x2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = Int.ofNat (Int.gcd (x1.get i) (x2.get i))) \u2227\n                 (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                 (\u2200 i : Fin n, Int.gcd (x1.get i) (x2.get i) = (x1.get i).natAbs.gcd (x2.get i).natAbs) \u2227\n                 (\u2200 i : Fin n, (x1.get i = 0 \u2227 x2.get i = 0) \u2192 result.get i = 0) \u2227\n                 (\u2200 i : Fin n, (x1.get i \u2260 0 \u2227 x2.get i = 0) \u2192 result.get i = Int.natAbs (x1.get i)) \u2227\n                 (\u2200 i : Fin n, (x1.get i = 0 \u2227 x2.get i \u2260 0) \u2192 result.get i = Int.natAbs (x2.get i)) \u2227\n                 (\u2200 i : Fin n, result.get i \u2223 (x1.get i) \u2227 result.get i \u2223 (x2.get i)) \u2227\n                 (\u2200 i : Fin n, \u2200 (d : Int), d \u2223 (x1.get i) \u2192 d \u2223 (x2.get i) \u2192 d \u2223 result.get i) \u2227\n                 (\u2200 i : Fin n, Int.gcd (x2.get i) (x1.get i) = Int.gcd (x1.get i) (x2.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_gradient", "vc-description": "/-  numpy.gradient: Return the gradient of an N-dimensional array.\n\n    The gradient is computed using second order accurate central differences \n    in the interior points and either first or second order accurate one-sided \n    (forward or backwards) differences at the boundaries.\n\n    For a 1D array, the gradient is a vector of the same size where:\n    - At the boundaries, one-sided differences are used\n    - In the interior, central differences are used\n\n    This captures the rate of change of the function represented by the array.\n-/\n\n/-  Specification: numpy.gradient computes the numerical gradient using finite differences.\n\n    The gradient satisfies these mathematical properties:\n    1. For a single point array (n = 0), the gradient is 0\n    2. For arrays with multiple points (n > 0):\n       - At the first boundary (i = 0): uses forward difference grad[0] = f[1] - f[0]\n       - At the last boundary (i = n): uses backward difference grad[n] = f[n] - f[n-1]\n       - For interior points (0 < i < n): uses central difference grad[i] = (f[i+1] - f[i-1]) / 2\n    3. The gradient has the same size as the input array\n    4. The gradient approximates the derivative at each point\n\n    This specification assumes unit spacing between points. The actual numpy \n    function can handle custom spacing, but we focus on the core mathematical behavior.\n\n    Mathematical properties:\n    - For linear functions f(x) = ax + b, the gradient is constant and equal to a\n    - For constant functions, the gradient is 0 everywhere\n    - The gradient operation is linear: grad(f + g) = grad(f) + grad(g)\n\n    Precondition: True (non-empty constraint is in the type Vector Float (n + 1))\n    Postcondition: The gradient is computed using appropriate finite difference formulas\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_gradient {n : Nat} (f : Vector Float (n + 1)) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem numpy_gradient_spec {n : Nat} (f : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_gradient f\n    \u2983\u21d3grad => \u231c-- Core mathematical properties\n              -- Single point case: gradient is 0\n              (n = 0 \u2192 grad.get 0 = 0) \u2227 \n              -- Multi-point case: boundary and interior conditions\n              (n > 0 \u2192 \n                -- First boundary: forward difference\n                grad.get 0 = f.get 1 - f.get 0 \u2227\n                -- Last boundary: backward difference  \n                grad.get \u27e8n, Nat.lt_succ_self n\u27e9 = f.get \u27e8n, Nat.lt_succ_self n\u27e9 - f.get \u27e8n-1, by sorry\u27e9 \u2227\n                -- Interior points: central difference\n                (\u2200 i : Fin (n + 1), 0 < i.val \u2227 i.val < n \u2192 \n                  grad.get i = \n                  (f.get \u27e8i.val + 1, by sorry\u27e9 - \n                   f.get \u27e8i.val - 1, by sorry\u27e9) / 2)) \u2227\n              -- Additional mathematical properties\n              -- For constant functions, gradient is zero everywhere\n              (\u2200 c : Float, (\u2200 i : Fin (n + 1), f.get i = c) \u2192 \n                (\u2200 i : Fin (n + 1), grad.get i = 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_heaviside", "vc-description": "/- \n{\n  \"name\": \"numpy.heaviside\",\n  \"description\": \"Compute the Heaviside step function\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.heaviside.html\",\n  \"doc\": \"Compute the Heaviside step function.\\n\\nThe Heaviside step function is defined as:\\n  0 if x1 < 0\\n  x2 if x1 == 0\\n  1 if x1 > 0\",\n}\n-/\n\n/-  Compute the Heaviside step function element-wise.\n    Returns 0 if x < 0, x2 if x == 0, and 1 if x > 0. -/\n\n/-  Specification: The Heaviside function returns values based on the sign of x1 elements.\n    For each element:\n    - If x1[i] < 0, result[i] = 0\n    - If x1[i] = 0, result[i] = x2[i]\n    - If x1[i] > 0, result[i] = 1\n\n    This specification captures the complete behavior of the heaviside step function\n    including the crucial property that it's completely determined by the sign of x1\n    and uses x2 as the value at the discontinuity point. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def heaviside {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem heaviside_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    heaviside x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        (x1.get i < 0 \u2192 result.get i = 0) \u2227\n        (x1.get i = 0 \u2192 result.get i = x2.get i) \u2227\n        (x1.get i > 0 \u2192 result.get i = 1) \u2227\n        -- Additional mathematical properties\n        (result.get i = 0 \u2228 result.get i = 1 \u2228 result.get i = x2.get i) \u2227\n        -- Monotonicity property: if x1[i] \u2264 x1[j] and x1[i] \u2260 0 and x1[j] \u2260 0, then result[i] \u2264 result[j]\n        (\u2200 j : Fin n, x1.get i \u2264 x1.get j \u2192 x1.get i \u2260 0 \u2192 x1.get j \u2260 0 \u2192 result.get i \u2264 result.get j) \u2227\n        -- Boundary behavior: result is either 0, 1, or x2\n        (result.get i \u2260 0 \u2192 result.get i \u2260 1 \u2192 result.get i = x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_hypot", "vc-description": "/-  numpy.hypot: Given the 'legs' of a right triangle, return its hypotenuse.\n\n    Computes the hypotenuse of a right triangle given the lengths of its two legs.\n    This is equivalent to sqrt(x1^2 + x2^2), but is implemented in a way that\n    avoids overflow for large values.\n\n    The function operates element-wise on the input vectors, computing the\n    hypotenuse for each pair of corresponding elements.\n-/\n\n/-  Specification: numpy.hypot returns a vector where each element is the\n    hypotenuse computed from the corresponding elements of x1 and x2.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = sqrt(x1[i]\u00b2 + x2[i]\u00b2)\n\n    Mathematical properties:\n    1. The result is always non-negative\n    2. The result follows the Pythagorean theorem\n    3. The result is symmetric: hypot(a, b) = hypot(b, a)\n    4. For positive inputs, hypot(a, b) \u2265 max(Float.abs(a), Float.abs(b))\n    5. hypot(0, a) = Float.abs(a) and hypot(a, 0) = Float.abs(a)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_hypot {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_hypot_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_hypot x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Core specification: Pythagorean theorem\n      result.get i = Float.sqrt (x1.get i ^ 2 + x2.get i ^ 2) \u2227\n      -- Result is non-negative\n      result.get i \u2265 0 \u2227\n      -- Result is at least as large as the absolute value of each input\n      result.get i \u2265 Float.abs (x1.get i) \u2227\n      result.get i \u2265 Float.abs (x2.get i) \u2227\n      -- Special cases\n      (x1.get i = 0 \u2192 result.get i = Float.abs (x2.get i)) \u2227\n      (x2.get i = 0 \u2192 result.get i = Float.abs (x1.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_i0", "vc-description": "/- \n{\n  \"name\": \"numpy.i0\",\n  \"description\": \"Modified Bessel function of the first kind, order 0\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.i0.html\",\n  \"doc\": \"Modified Bessel function of the first kind, order 0.\\n\\nDefinition: i0(x) = sum((x/2)**2k / (k!)**2, k=0..inf)\",\n}\n-/\n\n/-  numpy.i0: Modified Bessel function of the first kind, order 0.\n\n    Computes the Modified Bessel function of the first kind, order 0, element-wise.\n    This is a special function that arises in many mathematical contexts including\n    solutions to differential equations and probability theory.\n\n    The function is defined by the infinite series:\n    i0(x) = sum((x/2)^(2k) / (k!)^2, k=0..inf)\n\n    Returns an array of the same shape as x, containing the i0 values of each element.\n-/\n\n/-  Specification: numpy.i0 returns a vector where each element is the Modified\n    Bessel function of the first kind, order 0, of the corresponding element in x.\n\n    Mathematical properties:\n    1. i0(0) = 1 (by definition, the series starts with 1)\n    2. i0(x) > 0 for all real x (positive function)\n    3. i0(x) = i0(-x) (even function)\n    4. i0(x) is monotonically increasing for x \u2265 0\n    5. For large x, i0(x) \u2248 exp(|x|) / sqrt(2\u03c0|x|) (asymptotic behavior)\n\n    Precondition: True (no special preconditions for i0)\n    Postcondition: For all indices i, result[i] = i0(x[i]) with the mathematical properties above\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def i0 {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem i0_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    i0 x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Basic function evaluation (conceptually Float.i0, though this may not exist in Lean)\n        -- i0(x) > 0 for all x (positive function)\n        result.get i > 0 \u2227\n        -- Zero case: i0(0) = 1\n        (x.get i = 0 \u2192 result.get i = 1) \u2227\n        -- Even function: i0(x) = i0(-x)\n        (\u2200 j : Fin n, x.get j = -x.get i \u2192 result.get j = result.get i) \u2227\n        -- Monotonicity for non-negative values\n        (\u2200 j : Fin n, x.get i \u2265 0 \u2192 x.get j \u2265 0 \u2192 x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_imag", "vc-description": "/- \n{\n  \"name\": \"numpy.imag\",\n  \"description\": \"Return the imaginary part of the complex argument\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.imag.html\",\n  \"doc\": \"Return the imaginary part of the complex argument.\\n\\nSignature: numpy.imag(val)\\n\\nParameters:\\n  val: array_like - Input array\\n\\nReturns:\\n  out: ndarray or scalar - The imaginary component of the complex argument. If val is real, the type of val is used for the output. If val has complex elements, the returned type is float.\",\n}\n-/\n\n/-  Return the imaginary part of complex numbers in a vector.\n    For a vector where each element is represented as a pair (real, imaginary),\n    extracts the imaginary component of each element.\n    For real numbers (where imaginary part is 0), returns 0. -/\n\n/-  Specification: imag extracts the imaginary part of complex numbers with the following properties:\n    1. Identity: Returns the imaginary part unchanged for each element\n    2. Zero for real numbers: If input element is real (imaginary part is 0), output is 0\n    3. Type preservation: Output has the same size as input\n    4. Mathematical correctness: For complex number z = a + bi, imag(z) = b\n    5. Linearity: imag preserves scalar multiplication of imaginary parts\n    6. Conjugate property: imag(conj(z)) = -imag(z)\n    7. Additive property: imag(z\u2081 + z\u2082) = imag(z\u2081) + imag(z\u2082) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def imag {n : Nat} (val : Vector (Float \u00d7 Float) n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem imag_spec {n : Nat} (val : Vector (Float \u00d7 Float) n) :\n    \u2983\u231cTrue\u231d\u2984\n    imag val\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = (val.get i).2) \u2227\n                 (\u2200 i : Fin n, (val.get i).2 = 0 \u2192 result.get i = 0) \u2227\n                 (\u2200 i : Fin n, (val.get i).1 \u2260 0 \u2228 (val.get i).2 \u2260 0 \u2192 \n                   result.get i = (val.get i).2) \u2227\n                 (\u2200 i : Fin n, \u2200 (\u03b1 : Float), \n                   let scaled_complex := (\u03b1 * (val.get i).1, \u03b1 * (val.get i).2)\n                   result.get i = (val.get i).2 \u2192 \n                   \u03b1 * result.get i = \u03b1 * (val.get i).2)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_interp", "vc-description": "/- \n{\n  \"name\": \"numpy.interp\",\n  \"description\": \"One-dimensional linear interpolation for monotonically increasing sample points\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.interp.html\",\n  \"doc\": \"One-dimensional linear interpolation for monotonically increasing sample points.\\n\\nReturns the one-dimensional piecewise linear interpolant to a function with given discrete data points (xp, fp), evaluated at x.\",\n}\n-/\n\n/-  One-dimensional linear interpolation for monotonically increasing sample points.\n    Returns the one-dimensional piecewise linear interpolant to a function with given\n    discrete data points (xp, fp), evaluated at x. -/\n\n/-  Specification: interp performs linear interpolation between discrete data points -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def interp {n m : Nat} (x : Vector Float n) (xp : Vector Float (m + 1)) (fp : Vector Float (m + 1)) \n    (h_increasing : \u2200 i j : Fin (m + 1), i < j \u2192 xp.get i < xp.get j) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem interp_spec {n m : Nat} (x : Vector Float n) (xp : Vector Float (m + 1)) (fp : Vector Float (m + 1)) \n    (h_increasing : \u2200 i j : Fin (m + 1), i < j \u2192 xp.get i < xp.get j) :\n    \u2983\u231c\u2200 i j : Fin (m + 1), i < j \u2192 xp.get i < xp.get j\u231d\u2984\n    interp x xp fp h_increasing\n    \u2983\u21d3result => \u231c\n      -- Each interpolated value is computed correctly\n      \u2200 k : Fin n, \n        -- For points outside the left range, use left boundary value\n        (x.get k \u2264 xp.get \u27e80, sorry\u27e9 \u2192 result.get k = fp.get \u27e80, sorry\u27e9) \u2227\n        -- For points outside the right range, use right boundary value\n        (x.get k \u2265 xp.get \u27e8m, sorry\u27e9 \u2192 result.get k = fp.get \u27e8m, sorry\u27e9) \u2227\n        -- For points exactly at data points, return exact values\n        (\u2200 i : Fin (m + 1), x.get k = xp.get i \u2192 result.get k = fp.get i) \u2227\n        -- For points within the range, value is between adjacent data points\n        (\u2200 i : Fin m, \n          xp.get \u27e8i.val, sorry\u27e9 \u2264 x.get k \u2227 x.get k \u2264 xp.get \u27e8i.val + 1, sorry\u27e9 \u2192\n          \u2203 t : Float, 0 \u2264 t \u2227 t \u2264 1 \u2227 \n          result.get k = fp.get \u27e8i.val, sorry\u27e9 + t * (fp.get \u27e8i.val + 1, sorry\u27e9 - fp.get \u27e8i.val, sorry\u27e9))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_lcm", "vc-description": "/- \n{\n  \"name\": \"numpy.lcm\",\n  \"description\": \"Returns the lowest common multiple of |x1| and |x2|\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.lcm.html\",\n  \"doc\": \"Returns the lowest common multiple of |x1| and |x2|.\",\n}\n-/\n\n/-  numpy.lcm: Returns the lowest common multiple of |x1| and |x2| element-wise.\n\n    Computes the lowest common multiple (LCM) of the absolute values of \n    the elements in x1 and x2. The LCM is the smallest non-negative integer \n    that is a multiple of both |x1| and |x2|.\n\n    Mathematical Properties:\n    - lcm(a, b) = lcm(b, a) (commutativity)\n    - lcm(a, b) * gcd(a, b) = |a * b| (fundamental relationship)\n    - lcm(0, b) = lcm(a, 0) = 0 (zero property)\n    - lcm(a, b) \u2265 0 (non-negativity)\n    - |a| divides lcm(a, b) and |b| divides lcm(a, b) (divisibility)\n    - lcm(a, b) is minimal among all positive integers divisible by both |a| and |b|\n\n    Examples:\n    - lcm(4, 6) = 12\n    - lcm(-4, 6) = 12 (uses absolute values)\n    - lcm(0, 5) = 0 (LCM with zero is always zero)\n    - lcm(8, 12) = 24\n    - lcm(7, 11) = 77 (coprime numbers)\n-/\n\n/-  Specification: lcm returns a vector where each element is the lowest \n    common multiple of the absolute values of the corresponding elements \n    from x1 and x2.\n\n    Precondition: True (no special preconditions)\n\n    Postcondition: \n    1. Each element of the result is the LCM of |x1[i]| and |x2[i]|\n    2. The result satisfies the mathematical properties of LCM:\n       - Non-negativity: lcm(a, b) \u2265 0 (always true by definition)\n       - Zero property: lcm(0, b) = lcm(a, 0) = 0\n       - Commutativity: lcm(a, b) = lcm(b, a) (implicit in Int.lcm)\n       - Relationship with GCD: lcm(a, b) * gcd(a, b) = |a * b|\n       - Divisibility: |a| divides lcm(a, b) and |b| divides lcm(a, b)\n       - Minimality: lcm(a, b) is the smallest non-negative integer divisible by both |a| and |b| (when both are non-zero)\n    3. Special cases:\n       - When either input is zero, the result is zero\n       - When inputs are coprime (gcd = 1), lcm = |a * b|\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lcm {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem lcm_spec {n : Nat} (x1 x2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    lcm x1 x2\n    \u2983\u21d3result => \u231c-- Basic correctness: each element is the LCM of corresponding elements\n                 (\u2200 i : Fin n, result.get i = (Int.lcm (x1.get i) (x2.get i) : Int)) \u2227\n                 -- Non-negativity: LCM is always non-negative\n                 (\u2200 i : Fin n, result.get i \u2265 0) \u2227\n                 -- Zero property: LCM with zero is zero\n                 (\u2200 i : Fin n, (x1.get i = 0 \u2228 x2.get i = 0) \u2192 result.get i = 0) \u2227\n                 -- Commutativity: LCM is commutative\n                 (\u2200 i : Fin n, result.get i = (Int.lcm (x2.get i) (x1.get i) : Int)) \u2227\n                 -- Fundamental LCM-GCD relationship: lcm(a,b) * gcd(a,b) = |a * b|\n                 (\u2200 i : Fin n, x1.get i \u2260 0 \u2192 x2.get i \u2260 0 \u2192 \n                    Int.natAbs (result.get i) * Int.gcd (x1.get i) (x2.get i) = Int.natAbs (x1.get i) * Int.natAbs (x2.get i)) \u2227\n                 -- Divisibility: both absolute values divide the LCM\n                 (\u2200 i : Fin n, x1.get i \u2260 0 \u2192 x2.get i \u2260 0 \u2192 \n                    (Int.natAbs (x1.get i) : Int) \u2223 result.get i \u2227 (Int.natAbs (x2.get i) : Int) \u2223 result.get i) \u2227\n                 -- Minimality: LCM is the smallest non-negative integer divisible by both absolute values\n                 (\u2200 i : Fin n, \u2200 (m : Int), m \u2265 0 \u2192 \n                    (Int.natAbs (x1.get i) : Int) \u2223 m \u2192 (Int.natAbs (x2.get i) : Int) \u2223 m \u2192 \n                    x1.get i \u2260 0 \u2192 x2.get i \u2260 0 \u2192 result.get i \u2264 m) \u2227\n                 -- Special case: when both are non-zero, LCM is positive\n                 (\u2200 i : Fin n, x1.get i \u2260 0 \u2192 x2.get i \u2260 0 \u2192 result.get i > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_ldexp", "vc-description": "/- \n{\n  \"name\": \"numpy.ldexp\",\n  \"description\": \"Returns x1 * 2**x2, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ldexp.html\",\n  \"doc\": \"Returns x1 * 2**x2, element-wise.\\n\\nThe mantissas x1 and twos exponents x2 are used to construct floating point numbers x1 * 2**x2.\",\n}\n-/\n\n/-  Returns x1 * 2**x2, element-wise.\n    The mantissas x1 and twos exponents x2 are used to construct floating point numbers x1 * 2**x2. -/\n\n/-  Specification: ldexp returns x1 * 2**x2 element-wise -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ldexp {n : Nat} (x1 : Vector Float n) (x2 : Vector Int n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ldexp_spec {n : Nat} (x1 : Vector Float n) (x2 : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    ldexp x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i * (2 : Float) ^ (Float.ofInt (x2.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_log", "vc-description": "/-  numpy.log: Natural logarithm, element-wise.\n\n    The natural logarithm log is the inverse of the exponential function,\n    so that log(exp(x)) = x. The natural logarithm is logarithm base e.\n\n    Returns an array of the same shape as x, containing the natural logarithm\n    of each element in x.\n\n    Note: The domain of the natural logarithm is the positive real numbers.\n    Mathematically, log(x) is undefined for x \u2264 0.\n-/\n\n/-  Specification: log returns a vector where each element is the natural\n    logarithm of the corresponding element in x.\n\n    Precondition: All elements must be positive (x[i] > 0)\n    Postcondition: For all indices i, result[i] = log(x[i])\n\n    Mathematical properties:\n    - log is the inverse of exp: log(exp(x)) = x\n    - log(1) = 0\n    - log(e) = 1\n    - log(x*y) = log(x) + log(y) for positive x, y\n    - log is strictly increasing on (0, \u221e)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def log {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem log_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x.get i > 0\u231d\u2984\n    log x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log (x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_log10", "vc-description": "/-  numpy.log10: Return the base 10 logarithm of the input array, element-wise.\n\n    The base 10 logarithm log10 is the logarithm to the base 10.\n    It is the inverse of the exponential function with base 10,\n    so that log10(10^x) = x.\n\n    Returns an array of the same shape as x, containing the base 10 logarithm\n    of each element in x.\n-/\n\n/-  Specification: numpy.log10 returns a vector where each element is the base 10\n    logarithm of the corresponding element in x.\n\n    Precondition: All elements must be positive (x[i] > 0)\n    Postcondition: For all indices i, result[i] = Float.log10 x[i]\n\n    Mathematical properties:\n    1. log10(10^a) = a for positive a\n    2. log10(a * b) = log10(a) + log10(b) for positive a, b  \n    3. log10(1) = 0\n    4. log10(10) = 1\n    5. Monotonic: a < b implies log10(a) < log10(b) for positive a, b\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_log10 {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_log10_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x.get i > 0\u231d\u2984\n    numpy_log10 x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log10 (x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_log1p", "vc-description": "/-  numpy.log1p: Return the natural logarithm of one plus the input array, element-wise.\n\n    Calculates log(1 + x). This function provides greater precision than log(1 + x) \n    for small values of x near zero, where the naive computation would suffer from \n    floating-point precision loss.\n\n    Returns an array of the same shape as x, containing log(1 + x) for each element.\n\n    Note: The domain is x > -1 (since log(1 + x) requires 1 + x > 0).\n    For x = -1, the result is -\u221e (negative infinity).\n    For x < -1, the result is NaN (not a number).\n-/\n\n/-  Specification: log1p returns a vector where each element is the natural\n    logarithm of one plus the corresponding element in x.\n\n    Precondition: All elements must be greater than -1 (x[i] > -1)\n    Postcondition: For all indices i, result[i] = log(1 + x[i])\n\n    Mathematical properties:\n    - log1p(0) = log(1) = 0\n    - log1p(e - 1) = 1\n    - log1p provides better precision than log(1 + x) for small x\n    - log1p is strictly increasing on (-1, \u221e)\n    - log1p(x) = log(1 + x) for all valid x\n    - For small x, log1p(x) \u2248 x - x\u00b2/2 + x\u00b3/3 - ...\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def log1p {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem log1p_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x.get i > -1\u231d\u2984\n    log1p x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log (1 + x.get i) \u2227\n                   (x.get i = 0 \u2192 result.get i = 0) \u2227\n                   (\u2200 j : Fin n, x.get i \u2264 x.get j \u2192 result.get i \u2264 result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_log2", "vc-description": "/-  numpy.log2: Base-2 logarithm of x, element-wise.\n\n    The base-2 logarithm is the inverse of the exponential function with base 2,\n    so that log2(2^x) = x. This is useful for computing the number of bits needed\n    to represent a number or for operations involving powers of 2.\n\n    Returns an array of the same shape as x, containing the base-2 logarithm\n    of each element in x.\n-/\n\n/-  Specification: log2 returns a vector where each element is the base-2\n    logarithm of the corresponding element in x.\n\n    Precondition: All elements must be positive (x[i] > 0) since the logarithm\n    is only defined for positive real numbers.\n\n    Postcondition: For all indices i, result[i] = Float.log2 x[i]\n\n    Mathematical properties:\n    - log2(2^x) = x for any x\n    - log2(x * y) = log2(x) + log2(y) for positive x, y\n    - log2(x / y) = log2(x) - log2(y) for positive x, y\n    - log2(1) = 0\n    - log2(2) = 1\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def log2 {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem log2_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x.get i > 0\u231d\u2984\n    log2 x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log2 (x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_logaddexp", "vc-description": "/-  numpy.logaddexp: Logarithm of the sum of exponentiations of the inputs.\n\n    Calculates log(exp(x1) + exp(x2)) element-wise. This function is useful \n    in statistics where the calculated probabilities of events may be so small \n    as to exceed the range of normal floating point numbers.\n\n    The logaddexp function provides a numerically stable way to compute\n    log(exp(x1) + exp(x2)) without intermediate overflow or underflow.\n\n    Mathematical properties:\n    - logaddexp(x, x) = x + log(2)\n    - logaddexp(x, -\u221e) = x\n    - logaddexp(-\u221e, x) = x\n    - logaddexp is symmetric: logaddexp(x, y) = logaddexp(y, x)\n    - logaddexp is associative in the sense that it satisfies the log-sum-exp properties\n    - logaddexp(x, y) \u2265 max(x, y) for all x, y\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - Input arrays\n    - Returns: ndarray - The element-wise logaddexp of the inputs\n-/\n\n/-  Specification: numpy.logaddexp returns a vector where each element is the\n    logarithm of the sum of exponentiations of the corresponding elements.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = log(exp(x1[i]) + exp(x2[i]))\n    2. Commutativity: logaddexp(x1, x2) = logaddexp(x2, x1)\n    3. Numerical stability: avoids intermediate overflow/underflow\n    4. Bounds: logaddexp(x, y) \u2265 max(x, y) for all x, y\n    5. Special cases: \n       - logaddexp(x, x) = x + log(2)\n       - logaddexp(x, -\u221e) = x (when x is finite)\n       - logaddexp(-\u221e, x) = x (when x is finite)\n    6. Monotonicity: logaddexp is monotonically increasing in both arguments\n    7. Associativity property: satisfies log-sum-exp algebraic relations\n\n    Precondition: True (logaddexp is defined for all real numbers)\n    Postcondition: For all indices i, result[i] = log(exp(x1[i]) + exp(x2[i]))\n                   and result[i] \u2265 max(x1[i], x2[i])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def logaddexp {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem logaddexp_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    logaddexp x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log (Float.exp (x1.get i) + Float.exp (x2.get i)) \u2227\n                   result.get i \u2265 max (x1.get i) (x2.get i) \u2227\n                   (x1.get i = x2.get i \u2192 result.get i = x1.get i + Float.log 2)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_logaddexp2", "vc-description": "/- \n{\n  \"name\": \"numpy.logaddexp2\",\n  \"description\": \"Logarithm of the sum of exponentiations of the inputs in base-2\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.logaddexp2.html\",\n  \"doc\": \"Logarithm of the sum of exponentiations of the inputs in base-2.\\n\\nCalculates log2(2**x1 + 2**x2).\",\n}\n-/\n\n/-  numpy.logaddexp2: Logarithm of the sum of exponentiations of the inputs in base-2.\n\n    Calculates log2(2^x1 + 2^x2) element-wise. This function is mathematically equivalent to\n    log2(2^x1 + 2^x2) but is computed in a numerically stable way that avoids overflow for\n    large input values.\n\n    The function is useful for numerical computations where you need to add exponentials\n    without causing overflow, particularly in machine learning and statistical applications.\n\n    Returns an array of the same shape as the input arrays, containing the base-2 logarithm\n    of the sum of exponentiations of corresponding elements.\n-/\n\n/-  Specification: numpy.logaddexp2 returns a vector where each element is the base-2\n    logarithm of the sum of exponentiations of the corresponding elements in x1 and x2.\n\n    Precondition: True (no special preconditions - numerically stable for all finite values)\n    Postcondition: For all indices i, result[i] = log2(2^x1[i] + 2^x2[i])\n\n    Mathematical properties:\n    - Commutativity: logaddexp2(x1, x2) = logaddexp2(x2, x1)\n    - Monotonicity: If x1 \u2264 y1 and x2 \u2264 y2, then logaddexp2(x1, x2) \u2264 logaddexp2(y1, y2)\n    - Bounds: max(x1, x2) \u2264 logaddexp2(x1, x2) \u2264 max(x1, x2) + 1\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_logaddexp2 {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_logaddexp2_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_logaddexp2 x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.log2 (Float.exp2 (x1.get i) + Float.exp2 (x2.get i)) \u2227\n                  result.get i \u2265 max (x1.get i) (x2.get i) \u2227\n                  result.get i \u2264 max (x1.get i) (x2.get i) + 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_maximum", "vc-description": "/- \n{\n  \"name\": \"numpy.maximum\",\n  \"description\": \"Element-wise maximum of array elements\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.maximum.html\",\n  \"doc\": \"Element-wise maximum of array elements.\\n\\nCompare two arrays and returns a new array containing the element-wise maxima.\",\n}\n-/\n\n/-  numpy.maximum: Element-wise maximum of array elements.\n\n    Compares two arrays element-wise and returns a new array containing\n    the element-wise maxima. If one of the elements being compared is NaN,\n    then that element is returned.\n\n    This is a universal function (ufunc) that operates element-wise on arrays\n    and supports broadcasting. For 1D arrays, it computes the maximum of\n    corresponding elements.\n-/\n\n/-  Specification: numpy.maximum returns a vector where each element is the maximum\n    of the corresponding elements from x1 and x2.\n\n    Mathematical properties:\n    1. Commutativity: maximum(x1, x2) = maximum(x2, x1)\n    2. Associativity: maximum(maximum(x1, x2), x3) = maximum(x1, maximum(x2, x3))\n    3. Idempotence: maximum(x, x) = x\n    4. Monotonicity: if x1[i] \u2264 y1[i] and x2[i] \u2264 y2[i], then maximum(x1, x2)[i] \u2264 maximum(y1, y2)[i]\n    5. Identity: maximum(x, -\u221e) = x (where -\u221e is negative infinity)\n\n    Precondition: True (no special preconditions for element-wise maximum)\n    Postcondition: For all indices i, result[i] = max(x1[i], x2[i])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def maximum {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem maximum_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    maximum x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = max (x1.get i) (x2.get i) \u2227\n                 \u2200 i : Fin n, result.get i \u2265 x1.get i \u2227 result.get i \u2265 x2.get i \u2227\n                 (result.get i = x1.get i \u2228 result.get i = x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_minimum", "vc-description": "/-  numpy.minimum: Element-wise minimum of array elements.\n\n    Compare two arrays and returns a new array containing the element-wise minima.\n    If one of the elements being compared is NaN, then that element is returned.\n\n    This is different from numpy.min which returns a single minimum value.\n    This function performs element-wise comparison and returns a new array.\n\n    Binary universal function: minimum(x1, x2)\n\n    Parameters:\n    - x1, x2: Vector Float n - Input vectors of the same size\n\n    Returns:\n    - Vector Float n - The element-wise minimum of x1 and x2\n-/\n\n/-  Specification: numpy.minimum returns a vector where each element is the minimum\n    of the corresponding elements from x1 and x2.\n\n    Mathematical properties:\n    1. Commutativity: min(a, b) = min(b, a)\n    2. Associativity: min(min(a, b), c) = min(a, min(b, c))\n    3. Idempotency: min(a, a) = a\n    4. Element-wise operation: result[i] = min(x1[i], x2[i]) for all i\n    5. NaN propagation: if either x1[i] or x2[i] is NaN, result[i] is NaN\n\n    Precondition: True (no special preconditions for element-wise minimum)\n    Postcondition: For all indices i, result[i] = min(x1[i], x2[i])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def minimum {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem minimum_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    minimum x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = min (x1.get i) (x2.get i) \u2227\n                 -- Commutativity property\n                 (minimum x1 x2).get i = (minimum x2 x1).get i \u2227\n                 -- Bounded property: result is bounded by inputs\n                 result.get i \u2264 x1.get i \u2227 result.get i \u2264 x2.get i \u2227\n                 -- Definitional property: result equals one of the inputs\n                 (result.get i = x1.get i \u2228 result.get i = x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_mod", "vc-description": "/-  numpy.mod: Returns the element-wise remainder of division.\n\n    Computes the remainder complementary to the floor_divide function.\n    This is equivalent to x1 % x2 in terms of array broadcasting.\n\n    The result has the same sign as the divisor x2.\n    For two arguments of floating point type, the result is:\n    x1 - floor(x1/x2) * x2\n-/\n\n/-  Specification: numpy.mod returns a vector where each element is the remainder\n    of the corresponding elements from x1 and x2.\n\n    Precondition: All elements in x2 must be non-zero\n    Postcondition: For all indices i, result[i] = x1[i] % x2[i]\n\n    Mathematical properties:\n    1. The result has the same sign as x2[i] (when x2[i] \u2260 0)\n    2. The absolute value of result[i] is less than the absolute value of x2[i]\n    3. x1[i] = floor(x1[i] / x2[i]) * x2[i] + result[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_mod {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_mod_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2260 0\u231d\u2984\n    numpy_mod x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let r := result.get i\n      let a := x1.get i  \n      let b := x2.get i\n      -- Basic remainder property: a = floor(a/b) * b + r\n      a = Float.floor (a / b) * b + r \u2227\n      -- Result has same sign as divisor (when divisor is non-zero)\n      (b > 0 \u2192 r \u2265 0 \u2227 r < b) \u2227\n      (b < 0 \u2192 r \u2264 0 \u2227 r > b)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_modf", "vc-description": "/- \n{\n  \"name\": \"numpy.modf\",\n  \"description\": \"Return the fractional and integral parts of an array, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.modf.html\",\n  \"doc\": \"Return the fractional and integral parts of an array, element-wise.\\n\\nThe fractional and integral parts are negative if the given number is negative.\",\n}\n-/\n\n/-  numpy.modf: Return the fractional and integral parts of an array, element-wise.\n\n    Returns a tuple (fractional_parts, integral_parts) where both parts\n    have the same sign as the input. The fractional and integral parts\n    are negative if the given number is negative.\n-/\n\n/-  Specification: numpy.modf returns fractional and integral parts where:\n    1. The fractional and integral parts sum to the original value\n    2. The fractional part has absolute value less than 1\n    3. Both parts have the same sign as the original number (or zero)\n    4. The integral part is the truncated integer part\n\n    Precondition: True (no special preconditions for modf)\n    Postcondition: For all indices i, the fractional and integral parts satisfy mathematical properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_modf {n : Nat} (x : Vector Float n) : Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_modf_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_modf x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let frac := result.1.get i\n      let int := result.2.get i\n      let orig := x.get i\n      -- Parts sum to original\n      (frac + int = orig) \u2227\n      -- Fractional part has absolute value less than 1\n      (Float.abs frac < 1) \u2227\n      -- Both parts have same sign as original (or are zero)\n      ((orig \u2265 0 \u2192 frac \u2265 0 \u2227 int \u2265 0) \u2227 (orig < 0 \u2192 frac \u2264 0 \u2227 int \u2264 0)) \u2227\n      -- Integral part is truncated towards zero (floor for positive, ceiling for negative)\n      (orig \u2265 0 \u2192 int = Float.floor orig) \u2227\n      (orig < 0 \u2192 int = -Float.floor (-orig))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_multiply", "vc-description": "/-  numpy.multiply: Multiply arguments element-wise.\n\n    Multiplies two vectors element-wise. If the vectors have the same shape,\n    each element of the result is the product of the corresponding elements\n    from the input vectors.\n\n    This is equivalent to x1 * x2 in terms of array broadcasting.\n    The function supports all numeric types and handles overflow according\n    to the IEEE 754 standard for floating-point arithmetic.\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - The arrays to be multiplied\n    - Returns: multiply (ndarray) - The product of x1 and x2, element-wise\n    - The function is a universal function (ufunc) implemented in C\n    - Uses optimized C loops for different data types\n-/\n\n/-  Specification: numpy.multiply returns a vector where each element is the product\n    of the corresponding elements from x1 and x2.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = x1[i] * x2[i]\n    2. Commutativity: multiply(x1, x2) = multiply(x2, x1)\n    3. Associativity: multiply(multiply(x1, x2), x3) = multiply(x1, multiply(x2, x3))\n    4. Identity: multiply(x, ones) = x\n    5. Zero property: multiply(x, zeros) = zeros\n    6. Preserves vector length: result.size = x1.size = x2.size\n    7. Handles finite arithmetic: supports IEEE 754 floating-point multiplication\n    8. Distributivity over addition: multiply(x1, add(x2, x3)) = add(multiply(x1, x2), multiply(x1, x3))\n\n    Precondition: True (no special preconditions for basic multiplication)\n    Postcondition: For all indices i, result[i] = x1[i] * x2[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def multiply {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem multiply_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    multiply x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i * x2.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nan_to_num", "vc-description": "/- \n{\n  \"name\": \"numpy.nan_to_num\",\n  \"description\": \"Replace NaN with zero and infinity with large finite numbers\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nan_to_num.html\",\n  \"doc\": \"Replace NaN with zero and infinity with large finite numbers (default behaviour) or with the numbers defined by the user using the nan, posinf and/or neginf keywords.\",\n}\n-/\n\n/-  Replace NaN with zero and infinity with large finite numbers element-wise -/\n\n/-  Specification: nan_to_num replaces non-finite floating-point values with finite alternatives:\n    1. NaN replacement: All NaN values are replaced with 0.0\n    2. Positive infinity replacement: All positive infinity values are replaced with a large finite value\n    3. Negative infinity replacement: All negative infinity values are replaced with a large negative finite value\n    4. Finite value preservation: All finite values remain unchanged\n    5. All results are finite: The output contains only finite floating-point numbers -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Batteries.Lean.Float\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nan_to_num {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem nan_to_num_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nan_to_num x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, \n      let xi := x.get i\n      let ri := result.get i\n      (xi.isNaN \u2192 ri = 0.0) \u2227\n      (xi = Float.inf \u2192 ri > 0 \u2227 ri.isFinite) \u2227\n      (xi = -Float.inf \u2192 ri < 0 \u2227 ri.isFinite) \u2227\n      (xi.isFinite \u2192 ri = xi)) \u2227\n    (\u2200 i : Fin n, (result.get i).isFinite)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nancumprod", "vc-description": "/- \n{\n  \"name\": \"numpy.nancumprod\",\n  \"description\": \"Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nancumprod.html\",\n  \"doc\": \"Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one.\",\n}\n-/\n\n/-  Return the cumulative product of array elements treating NaNs as 1.\n    The cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones. -/\n\n/-  Specification: nancumprod returns the cumulative product while treating NaN values as 1.\n    This means:\n    1. The resulting array has the same size as the input\n    2. Each element is the product of all non-NaN elements from the start up to that position\n    3. NaN values are treated as 1 in the product calculation\n    4. Leading NaNs are replaced by ones\n    5. The cumulative product property holds for non-NaN values -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nancumprod {n : Nat} (arr : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem nancumprod_spec {n : Nat} (arr : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nancumprod arr\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- If all elements from start to i are NaN, result[i] = 1\n      (\u2200 j : Fin n, j.val \u2264 i.val \u2192 Float.isNaN (arr.get j)) \u2192 result.get i = 1.0 \u2227\n      -- If no elements from start to i are NaN, result[i] = product of all elements from start to i\n      (\u2200 j : Fin n, j.val \u2264 i.val \u2192 \u00acFloat.isNaN (arr.get j)) \u2192 \n        result.get i = (List.range (i.val + 1)).foldl (fun acc idx => acc * arr.get \u27e8idx, by sorry\u27e9) 1.0 \u2227\n      -- General case: result[i] = product of all non-NaN elements from start to i\n      result.get i = (List.range (i.val + 1)).foldl (fun acc idx => \n        let val := arr.get \u27e8idx, by sorry\u27e9\n        if Float.isNaN val then acc else acc * val) 1.0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nancumsum", "vc-description": "/- \n{\n  \"name\": \"numpy.nancumsum\",\n  \"description\": \"Return the cumulative sum of array elements over a given axis treating Not a Numbers (NaNs) as zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nancumsum.html\",\n  \"doc\": \"Return the cumulative sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.\",\n}\n-/\n\n/-  numpy.nancumsum: Return the cumulative sum of array elements treating NaN as zero.\n\n    For a 1D array, nancumsum computes the cumulative sum where NaN values are treated as zero.\n    Unlike regular cumsum, NaN values do not propagate and are replaced with zero during computation.\n\n    Examples:\n    - [1, NaN, 3] becomes [1, 1, 4] (NaN treated as 0)\n    - [NaN, 2, 3] becomes [0, 2, 5] (leading NaN becomes 0)\n    - [1, 2, NaN, 4] becomes [1, 3, 3, 7] (NaN contributes 0 to sum)\n\n    The cumulative sum with NaN handling is defined as:\n    - result[0] = if a[0].isNaN then 0 else a[0]\n    - result[i] = result[i-1] + (if a[i].isNaN then 0 else a[i]) for i > 0\n-/\n\n/-  Specification: nancumsum returns a vector where each element is the cumulative sum\n    up to that position with NaN values treated as zero.\n\n    Precondition: True (no special preconditions)\n    Postcondition:\n    - Result has the same length as input\n    - NaN values are treated as zero in the cumulative sum computation\n    - For non-empty vectors, first element is either a[0] or 0 if a[0] is NaN\n    - Each subsequent element is the previous cumulative sum plus current element (or 0 if NaN)\n    - The cumulative sum preserves the NaN-as-zero semantics throughout\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nancumsum {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem nancumsum_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nancumsum a\n    \u2983\u21d3result => \u231c\n      -- Result has same length as input\n      result.toList.length = n \u2227\n      -- For non-empty vectors, first element is either a[0] or 0 if a[0] is NaN\n      (n > 0 \u2192 result.get \u27e80, sorry\u27e9 = if (a.get \u27e80, sorry\u27e9).isNaN then 0 else a.get \u27e80, sorry\u27e9) \u2227\n      -- Recurrence relation: each element is previous cumsum + current element (or 0 if NaN)\n      (\u2200 i : Fin n, i.val > 0 \u2192 \n        result.get i = result.get \u27e8i.val - 1, sorry\u27e9 + \n                      (if (a.get i).isNaN then 0 else a.get i)) \u2227\n      -- Cumulative sum property: each element is sum of all previous non-NaN elements\n      (\u2200 i : Fin n, result.get i = \n        List.sum ((List.range (i.val + 1)).map (fun j => \n          let val := a.get \u27e8j, sorry\u27e9\n          if val.isNaN then 0 else val))) \u2227\n      -- NaN handling: result never contains NaN (NaNs are replaced with 0)\n      (\u2200 i : Fin n, \u00ac(result.get i).isNaN)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nanprod", "vc-description": "/- \n{\n  \"name\": \"numpy.nanprod\",\n  \"description\": \"Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanprod.html\",\n  \"doc\": \"Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.\",\n}\n-/\n\n/-  numpy.nanprod: Return the product of array elements treating NaNs as ones.\n\n    Computes the product of all elements in the array, treating NaN values as 1.\n    This is useful for computing products while ignoring missing or invalid data\n    represented as NaN.\n\n    For empty arrays, returns 1 as the identity element of multiplication.\n    For arrays containing only NaN values, returns 1.\n    For arrays with mixed NaN and non-NaN values, returns the product of the non-NaN values.\n-/\n\n/-  Specification: numpy.nanprod returns the product of all non-NaN elements in the vector.\n\n    Precondition: True (works for any vector, including empty)\n    Postcondition: result equals the product of all non-NaN elements, satisfying:\n    1. NaN values are treated as 1 (multiplicative identity)\n    2. Empty vectors return 1\n    3. Vectors with only NaN values return 1\n    4. The result is mathematically equivalent to filtering out NaN values and taking the product\n    5. The result is never NaN (since NaN values are ignored)\n    6. If no NaN values exist, this behaves identically to regular product\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanprod {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem nanprod_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nanprod a\n    \u2983\u21d3result => \u231cresult = (a.toList.foldl (fun acc x => if x.isNaN then acc else acc * x) 1) \u2227\n                 \u00acresult.isNaN \u2227\n                 (\u2200 i : Fin n, \u00ac(a.get i).isNaN \u2192 \n                   \u2203 filtered : List Float, filtered = (a.toList.filter (fun x => \u00acx.isNaN)) \u2227\n                   result = filtered.foldl (\u00b7 * \u00b7) 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nansum", "vc-description": "/- \n{\n  \"name\": \"numpy.nansum\",\n  \"description\": \"Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nansum.html\",\n  \"doc\": \"Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.\",\n}\n-/\n\n/-  Return the sum of array elements treating NaN values as zero -/\n\n/-  Specification: nansum computes the sum of array elements treating NaN values as zero -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nansum {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem nansum_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nansum a\n    \u2983\u21d3result => \u231c\n      -- Core property: result equals sum of non-NaN elements\n      result = (List.range n).foldl (fun acc i => \n        let val := a.get \u27e8i, by sorry\u27e9\n        if val.isNaN then acc else acc + val) 0 \u2227\n      -- If all elements are NaN, result is 0 (numpy >= 1.9.0 behavior)\n      (\u2200 i : Fin n, (a.get i).isNaN \u2192 result = 0) \u2227\n      -- NaN values contribute 0 to the sum\n      (\u2200 i : Fin n, (a.get i).isNaN \u2192 \n        \u2203 s : Float, s = (List.range n).foldl (fun acc j => \n          if j = i.val then acc + 0 else \n          let val := a.get \u27e8j, by sorry\u27e9\n          if val.isNaN then acc else acc + val) 0 \u2227 result = s) \u2227\n      -- Handling infinities: if both +inf and -inf present, result is NaN\n      ((\u2203 i : Fin n, \u00ac(a.get i).isFinite \u2227 a.get i > 0) \u2227 \n       (\u2203 j : Fin n, \u00ac(a.get j).isFinite \u2227 a.get j < 0) \u2192 \n        result.isNaN) \u2227\n      -- If only positive infinity present, result is positive infinity\n      ((\u2203 i : Fin n, \u00ac(a.get i).isFinite \u2227 a.get i > 0) \u2227 \n       (\u2200 j : Fin n, \u00ac(\u00ac(a.get j).isFinite \u2227 a.get j < 0)) \u2192 \n        \u00acresult.isFinite \u2227 result > 0) \u2227\n      -- If only negative infinity present, result is negative infinity\n      ((\u2203 i : Fin n, \u00ac(a.get i).isFinite \u2227 a.get i < 0) \u2227 \n       (\u2200 j : Fin n, \u00ac(\u00ac(a.get j).isFinite \u2227 a.get j > 0)) \u2192 \n        \u00acresult.isFinite \u2227 result < 0) \u2227\n      -- If vector is empty, result is 0\n      (n = 0 \u2192 result = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_negative", "vc-description": "/-  numpy.negative: Numerical negative, element-wise.\n\n    Computes the negative of each element in the input array.\n    This is equivalent to -x in terms of array operations.\n\n    Returns an array of the same shape as x, containing the negated values.\n-/\n\n/-  Specification: numpy.negative returns a vector where each element is the\n    negative of the corresponding element in x.\n\n    Precondition: True (no special preconditions for negation)\n    Postcondition: For all indices i, result[i] = -x[i]\n\n    Mathematical Properties:\n    - Involution: -(-x) = x\n    - Additive inverse: x + (-x) = 0\n    - Preserves magnitude: |(-x)| = |x|\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_negative {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_negative_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_negative x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = -(x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_nextafter", "vc-description": "/-  numpy.nextafter: Return the next floating-point value after x1 towards x2, element-wise.\n\n    Returns the next representable floating-point value after x1 in the direction of x2.\n    This function is essential for numerical computing and provides fine-grained control\n    over floating-point precision. It's based on the C math library's nextafter function.\n\n    For each element pair (x1[i], x2[i]):\n    - If x1[i] == x2[i], returns x1[i]\n    - If x1[i] < x2[i], returns the smallest floating-point value greater than x1[i]\n    - If x1[i] > x2[i], returns the largest floating-point value less than x1[i]\n\n    Special cases:\n    - nextafter(x, +\u221e) returns the next value towards positive infinity\n    - nextafter(x, -\u221e) returns the next value towards negative infinity\n    - nextafter(\u00b1\u221e, y) returns \u00b1\u221e for any finite y\n    - nextafter(NaN, y) or nextafter(x, NaN) returns NaN\n\n    This function is crucial for:\n    - Numerical differentiation algorithms\n    - Root finding methods requiring precise stepping\n    - Testing floating-point precision limits\n    - Implementing robust numerical algorithms\n-/\n\n/-  Specification: numpy.nextafter returns a vector where each element is the next\n    representable floating-point value after x1[i] in the direction of x2[i].\n\n    Precondition: True (no special preconditions for nextafter)\n    Postcondition: For all indices i:\n      - If x1[i] == x2[i], then result[i] = x1[i]\n      - If x1[i] < x2[i], then result[i] is the smallest float greater than x1[i]\n      - If x1[i] > x2[i], then result[i] is the largest float less than x1[i]\n\n    Mathematical properties:\n      1. Direction consistency: result[i] moves towards x2[i]\n      2. Monotonicity: if x1[i] < x2[i], then x1[i] < result[i] \u2264 x2[i]\n      3. Minimal step: result[i] is the closest representable value to x1[i] in direction of x2[i]\n      4. Symmetry: nextafter(nextafter(x, y), x) moves back towards x\n      5. Identity: nextafter(x, x) = x\n      6. Finite precision: respects IEEE 754 floating-point representation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Batteries.Lean.Float\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nextafter {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem nextafter_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nextafter x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Identity case: when x1 equals x2, result equals x1\n      (x1.get i = x2.get i \u2192 result.get i = x1.get i) \u2227\n      -- Direction consistency: result moves towards x2\n      ((x1.get i < x2.get i \u2192 x1.get i < result.get i \u2227 result.get i \u2264 x2.get i) \u2227\n       (x1.get i > x2.get i \u2192 x1.get i > result.get i \u2227 result.get i \u2265 x2.get i)) \u2227\n      -- Minimal step property: result is the immediate next representable value\n      ((x1.get i < x2.get i \u2192 \u2200 y : Float, x1.get i < y \u2227 y < result.get i \u2192 \u00ac(\u2203 z : Float, x1.get i < z \u2227 z < y)) \u2227\n       (x1.get i > x2.get i \u2192 \u2200 y : Float, result.get i < y \u2227 y < x1.get i \u2192 \u00ac(\u2203 z : Float, y < z \u2227 z < x1.get i))) \u2227\n      -- Finiteness preservation: if both inputs are finite, result is finite (unless at boundary)\n      (Float.isFinite (x1.get i) \u2227 Float.isFinite (x2.get i) \u2227 x1.get i \u2260 x2.get i \u2192 \n       Float.isFinite (result.get i) \u2228 result.get i = Float.inf \u2228 result.get i = -Float.inf)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_positive", "vc-description": "/-  numpy.positive: Numerical positive, element-wise.\n\n    Returns a copy of the input array with the same values.\n    This is equivalent to the unary plus operator (+x) and \n    is only defined for types that support arithmetic operations.\n\n    The function performs element-wise positive operation, which\n    for real numbers simply returns the same value.\n-/\n\n/-  Specification: numpy.positive returns a vector where each element is\n    the positive of the corresponding element in x (which is the same value).\n\n    Precondition: True (no special preconditions for positive operation)\n    Postcondition: For all indices i, result[i] = +x[i] = x[i]\n\n    Mathematical Properties:\n    - Identity operation: positive(x) = x\n    - Idempotence: positive(positive(x)) = positive(x)\n    - Preserves sign: sign(positive(x)) = sign(x)\n    - Preserves magnitude: |positive(x)| = |x|\n    - Distributivity with multiplication: positive(x) * y = x * y\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def positive {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem positive_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    positive x\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = x.get i) \u2227\n                 (\u2200 i : Fin n, Float.abs (result.get i) = Float.abs (x.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_power", "vc-description": "/-  numpy.power: First array elements raised to powers from second array, element-wise.\n\n    Raise each base in x1 to the positionally-corresponding power in x2.\n    This is equivalent to x1 ** x2 in terms of array broadcasting.\n\n    The function computes x1[i] raised to the power x2[i] for each index i.\n\n    Mathematical properties:\n    - x^0 = 1 for any non-zero x\n    - x^1 = x for any x\n    - x^(a+b) = x^a * x^b for any x, a, b\n    - (x^a)^b = x^(a*b) for any x, a, b\n-/\n\n/-  Specification: numpy.power returns a vector where each element is the base\n    from x1 raised to the power from x2.\n\n    Precondition: For mathematical validity, we require:\n    - If x1[i] = 0, then x2[i] \u2265 0 (0^negative is undefined)\n    - If x1[i] < 0, then x2[i] should be an integer (for real results, checked by floor = value)\n\n    Postcondition: For all indices i, result[i] = x1[i] ^ x2[i]\n\n    Key mathematical properties ensured:\n    1. Identity: If x2[i] = 0 and x1[i] \u2260 0, then result[i] = 1\n    2. Base case: If x2[i] = 1, then result[i] = x1[i]\n    3. Monotonicity: If x1[i] > 1 and x2[i] > 0, then result[i] > x1[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_power {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_power_spec {n : Nat} (x1 x2 : Vector Float n) \n    (h_valid : \u2200 i : Fin n, (x1.get i = 0 \u2192 x2.get i \u2265 0) \u2227 \n                            (x1.get i < 0 \u2192 (x2.get i).floor = x2.get i)) :\n    \u2983\u231c\u2200 i : Fin n, (x1.get i = 0 \u2192 x2.get i \u2265 0) \u2227 \n                    (x1.get i < 0 \u2192 (x2.get i).floor = x2.get i)\u231d\u2984\n    numpy_power x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i ^ x2.get i \u2227\n                               (x2.get i = 0 \u2227 x1.get i \u2260 0 \u2192 result.get i = 1) \u2227\n                               (x2.get i = 1 \u2192 result.get i = x1.get i) \u2227\n                               (x1.get i > 1 \u2227 x2.get i > 0 \u2192 result.get i > x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_prod", "vc-description": "/-  numpy.prod: Return the product of array elements over a given axis.\n\n    Computes the product of all elements in the vector. For empty vectors,\n    returns 1 as the identity element of multiplication.\n\n    This is a reduction operation that applies multiplication across all\n    elements to produce a single scalar result.\n\n    Mathematical Properties:\n    - Commutative: order of elements doesn't affect the final product\n    - Associative: grouping of operations doesn't affect the result\n    - Identity element: empty array product is 1\n    - Contains zero: if any element is zero, the product is zero\n-/\n\n/-  Specification: prod computes the product of all elements in a vector.\n\n    The product operation has several important mathematical properties:\n    1. For empty vectors, returns 1 (multiplicative identity)\n    2. For non-empty vectors, returns the product of all elements\n    3. If any element is zero, the result is zero\n    4. The operation is commutative and associative\n\n    This specification captures both the basic behavior and key mathematical\n    properties that make prod well-defined and predictable.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def prod {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem prod_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    prod a\n    \u2983\u21d3result => \u231cresult = (a.toList.foldl (\u00b7 * \u00b7) 1) \u2227 \n                 (n = 0 \u2192 result = 1) \u2227\n                 (\u2203 i : Fin n, a.get i = 0) \u2192 result = 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_radians", "vc-description": "/-  numpy.radians: Convert angles from degrees to radians.\n\n    Converts angles from degrees to radians element-wise.\n    The conversion formula is: radians = degrees * \u03c0 / 180\n\n    Parameters:\n    - x: Input array in degrees\n\n    Returns:\n    - y: Array of the same shape as x, containing the corresponding radian values\n-/\n\n/-  Specification: numpy.radians converts each element from degrees to radians.\n\n    Precondition: True (no special preconditions for degree to radian conversion)\n    Postcondition: For all indices i, result[i] = x[i] * \u03c0 / 180\n\n    Mathematical properties verified:\n    - Linear conversion: radians = degrees * (\u03c0 / 180)\n    - 0 degrees = 0 radians\n    - 180 degrees = \u03c0 radians  \n    - 360 degrees = 2\u03c0 radians\n    - Maintains array shape and element-wise mapping\n    - Preserves the relationship between angle measures\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_radians {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_radians_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_radians x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x.get i * 3.141592653589793 / 180 \u2227\n                 -- Specific cases that validate the conversion\n                 (x.get i = 0 \u2192 result.get i = 0) \u2227  -- 0 degrees = 0 radians\n                 (x.get i = 180 \u2192 result.get i > 3.14 \u2227 result.get i < 3.15) \u2227  -- 180 degrees \u2248 \u03c0 radians\n                 (x.get i = 360 \u2192 result.get i > 6.28 \u2227 result.get i < 6.29)    -- 360 degrees \u2248 2\u03c0 radians\n                \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_real_if_close", "vc-description": "/- \n{\n  \"name\": \"numpy.real_if_close\",\n  \"description\": \"If input is complex with all imaginary parts close to zero, return real parts\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.real_if_close.html\",\n  \"doc\": \"If input is complex with all imaginary parts close to zero, return real parts.\\n\\n\\\"Close to zero\\\" is defined as tol * (machine epsilon of the type for a).\",\n}\n-/\n\n/-  If input is complex with all imaginary parts close to zero, return real parts.\n    Otherwise, return the original complex vector.\n    \"Close to zero\" is defined as tol * (machine epsilon of the type). -/\n\n/-  Specification: real_if_close returns real parts if all imaginary parts are within tolerance,\n    otherwise returns the original complex vector. This captures the essential behavior:\n    1. If all imaginary parts are small (\u2264 tol * machineEpsilon), return only real parts\n    2. Otherwise, preserve the original complex numbers\n    3. Real parts are always preserved regardless\n    4. The tolerance check is applied consistently across all elements -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a complex number with float components -/\nstructure Complex where\n  /-- The real part of the complex number -/\n  re : Float\n  /-- The imaginary part of the complex number -/\n  im : Float\n\n/-- Machine epsilon for Float (approximately 2.2204460492503131e-16) -/\ndef machineEpsilon : Float := 2.2204460492503131e-16\n/-- Helper function to check if a complex number's imaginary part is close to zero -/\ndef isCloseToZero (c : Complex) (tol : Float) : Bool :=\n  (if c.im \u2265 0 then c.im else -c.im) \u2264 tol * machineEpsilon\n/-- Helper function to check if all imaginary parts in a complex vector are close to zero -/\ndef allImaginaryPartsCloseToZero {n : Nat} (arr : Vector Complex n) (tol : Float) : Bool :=\n  arr.toList.all (fun c => isCloseToZero c tol)", "vc-helpers": "", "vc-definitions": "def real_if_close {n : Nat} (arr : Vector Complex n) (tol : Float := 100.0) : Id (Vector Complex n) :=\n  sorry", "vc-theorems": "theorem real_if_close_spec {n : Nat} (arr : Vector Complex n) (tol : Float := 100.0) \n    (h_tol_pos : tol > 0) :\n    \u2983\u231ctol > 0\u231d\u2984\n    real_if_close arr tol\n    \u2983\u21d3result => \u231c\n      -- Primary behavior: if all imaginary parts are close to zero, return real parts only\n      (allImaginaryPartsCloseToZero arr tol \u2192 \n        \u2200 i : Fin n, result.get i = Complex.mk (arr.get i).re 0) \u2227\n      -- Otherwise, preserve original complex numbers\n      (\u00acallImaginaryPartsCloseToZero arr tol \u2192 \n        \u2200 i : Fin n, result.get i = arr.get i) \u2227\n      -- Real parts are always preserved\n      (\u2200 i : Fin n, (result.get i).re = (arr.get i).re) \u2227\n      -- Sanity check: result vector has same length as input\n      (result.toList.length = arr.toList.length) \u2227\n      -- Mathematical property: if input is already real, output equals input\n      ((\u2200 i : Fin n, (arr.get i).im = 0) \u2192 \n        \u2200 i : Fin n, result.get i = arr.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_reciprocal", "vc-description": "/- \n{\n  \"name\": \"numpy.reciprocal\",\n  \"description\": \"Return the reciprocal of the argument, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.reciprocal.html\",\n  \"doc\": \"Return the reciprocal of the argument, element-wise.\\n\\nCalculates 1/x.\",\n}\n-/\n\n/-  numpy.reciprocal: Return the reciprocal of the argument, element-wise.\n\n    Calculates 1/x for each element in the input array.\n    This is equivalent to raising each element to the power of -1.\n\n    The function requires that all elements are non-zero to avoid division by zero.\n    For floating-point inputs, the reciprocal of zero would be infinity.\n\n    Returns an array of the same shape as x, containing the reciprocals.\n-/\n\n/-  Specification: numpy.reciprocal returns a vector where each element is the\n    reciprocal (1/x) of the corresponding element in x.\n\n    Precondition: All elements in x must be non-zero to avoid division by zero\n    Postcondition: For all indices i, result[i] = 1 / x[i]\n\n    Mathematical properties captured in the specification:\n    - Basic reciprocal property: result[i] = 1 / x[i]\n    - Domain restriction: x[i] \u2260 0 for all i\n    - Sign preservation: sign(result[i]) = sign(x[i])\n    - Magnitude inversion: |result[i]| = 1 / |x[i]|\n\n    Additional mathematical properties (provable from the spec):\n    - reciprocal(reciprocal(x)) = x for all non-zero x\n    - reciprocal(x * y) = reciprocal(x) * reciprocal(y) for non-zero x, y\n    - reciprocal(1) = 1\n    - reciprocal(-1) = -1\n    - For x > 0: reciprocal(x) > 0\n    - For x < 0: reciprocal(x) < 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_reciprocal {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_reciprocal_spec {n : Nat} (x : Vector Float n) \n    (h_nonzero : \u2200 i : Fin n, x.get i \u2260 0) :\n    \u2983\u231c\u2200 i : Fin n, x.get i \u2260 0\u231d\u2984\n    numpy_reciprocal x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = 1 / x.get i \u2227 \n                 result.get i \u2260 0 \u2227\n                 (x.get i > 0 \u2192 result.get i > 0) \u2227\n                 (x.get i < 0 \u2192 result.get i < 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_remainder", "vc-description": "/-  numpy.remainder: Returns the element-wise remainder of division.\n\n    Computes the remainder complementary to the floor_divide function.\n    This is equivalent to x1 % x2 in terms of array broadcasting.\n\n    The result has the same sign as the divisor x2.\n    For floating point inputs, the result is mathematically defined as:\n    x1 - floor(x1/x2) * x2\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n    - Returns: remainder (ndarray) - The element-wise remainder of x1 divided by x2\n    - This is a universal function (ufunc) implemented in C\n    - Uses optimized C loops for different data types\n-/\n\n/-  Specification: numpy.remainder returns a vector where each element is the remainder\n    of the corresponding elements from x1 and x2.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = x1[i] % x2[i]\n    2. Complementary to floor division: x1[i] = floor(x1[i]/x2[i]) * x2[i] + result[i]\n    3. Sign follows divisor: result[i] has the same sign as x2[i] (when x2[i] \u2260 0)\n    4. Magnitude bound: |result[i]| < |x2[i]| (when x2[i] \u2260 0)\n    5. Mathematical definition: result[i] = x1[i] - floor(x1[i]/x2[i]) * x2[i]\n    6. Preserves vector length: result.size = x1.size = x2.size\n    7. Handles IEEE 754 floating-point arithmetic\n\n    Precondition: All elements in x2 must be non-zero\n    Postcondition: For all indices i, result[i] satisfies the remainder properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def remainder {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem remainder_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2260 0\u231d\u2984\n    remainder x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let r := result.get i\n      let a := x1.get i  \n      let b := x2.get i\n      -- Mathematical definition: a = floor(a/b) * b + r\n      a = (a / b).floor * b + r \u2227\n      -- Result has same sign as divisor (when divisor is non-zero)\n      (b > 0 \u2192 r \u2265 0 \u2227 r < b) \u2227\n      (b < 0 \u2192 r \u2264 0 \u2227 r > b) \u2227\n      -- Magnitude bound\n      Float.abs r < Float.abs b\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_rint", "vc-description": "/-  numpy.rint: Round elements of the array to the nearest integer.\n\n    Rounds each element in the input array to the nearest integer using\n    IEEE 754 rounding rules (round half to even). The result is returned\n    as a floating-point array of the same shape as the input.\n\n    This function uses the C math library's rint function which rounds\n    to the nearest integer, with ties (halves) rounded to the nearest even number.\n\n    Returns an array of the same shape as x, containing the rounded values.\n-/\n\n/-  Specification: numpy.rint returns a vector where each element is\n    rounded to the nearest integer using IEEE 754 rounding rules.\n\n    Precondition: True (no special preconditions for rint)\n    Postcondition: For all indices i:\n      - result[i] is the nearest integer to x[i]\n      - for ties (half-integers), result[i] is the nearest even integer\n      - result[i] is a floating-point representation of the integer\n      - |result[i] - x[i]| \u2264 0.5 for all i\n      - if x[i] is already an integer, result[i] = x[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_rint {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_rint_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_rint x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- The result is the nearest integer (as a float)\n      (\u2203 k : Int, result.get i = Float.ofInt k) \u2227\n      -- The difference is at most 0.5\n      (Float.abs (result.get i - x.get i) \u2264 0.5) \u2227\n      -- If x[i] is already an integer, it remains unchanged\n      (\u2203 k : Int, x.get i = Float.ofInt k \u2192 result.get i = x.get i) \u2227\n      -- For ties, round to even (this is the IEEE 754 rule)\n      (\u2200 k : Int, x.get i = Float.ofInt k + 0.5 \u2192 \n        (k % 2 = 0 \u2192 result.get i = Float.ofInt k) \u2227\n        (k % 2 = 1 \u2192 result.get i = Float.ofInt (k + 1)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_round", "vc-description": "/- \n{\n  \"name\": \"numpy.round\",\n  \"description\": \"Evenly round to the given number of decimals\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.round.html\",\n  \"doc\": \"Evenly round to the given number of decimals.\\n\\nSignature: numpy.round(a, decimals=0, out=None)\\n\\nParameters:\\n  a: array_like - Input data\\n  decimals: int, optional - Number of decimal places to round to (default: 0)\\n  out: ndarray, optional - Alternative output array\\n\\nReturns:\\n  rounded_array: ndarray - An array of the same type as a, containing the rounded values\",\n}\n-/\n\n/-  numpy.round: Evenly round to the given number of decimals.\n\n    Rounds each element of the input array to the given number of decimal places.\n    Uses \"banker's rounding\" (round half to even) for ties.\n\n    For decimals=0: rounds to nearest integer\n    For decimals>0: rounds to that many decimal places\n    For decimals<0: rounds to nearest 10^(-decimals)\n\n    Returns an array of the same shape as input, containing the rounded values.\n-/\n\n/-  Specification: numpy.round rounds each element to the specified number of decimal places.\n\n    Precondition: True (rounding is defined for all real numbers and decimal places)\n    Postcondition: For all indices i, result[i] is the rounded value of a[i] to 'decimals' places:\n    - For decimals = 0: result[i] is the nearest integer to a[i]\n    - For decimals > 0: result[i] is rounded to that many decimal places\n    - For decimals < 0: result[i] is rounded to nearest multiple of 10^(-decimals)\n    - Uses banker's rounding (round half to even) for ties\n    - Monotonicity: if a[i] \u2264 a[j] then result[i] \u2264 result[j]\n    - For decimals=0: result[i] is an integer value\n    - Approximation property: result[i] is close to a[i] within rounding precision\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_round {n : Nat} (a : Vector Float n) (decimals : Int) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_round_spec {n : Nat} (a : Vector Float n) (decimals : Int) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_round a decimals\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- For decimals = 0, result is the nearest integer\n      (decimals = 0 \u2192 \u2203 k : Int, result.get i = Float.ofInt k \u2227 \n                      (result.get i - 0.5 \u2264 a.get i \u2227 a.get i < result.get i + 0.5)) \u2227\n      -- Monotonicity: order is preserved\n      (\u2200 j : Fin n, a.get i \u2264 a.get j \u2192 result.get i \u2264 result.get j) \u2227\n      -- Approximation bound: rounded value is reasonably close to original\n      (decimals \u2265 0 \u2192 (result.get i - a.get i) * (result.get i - a.get i) \u2264 1.0) \u2227\n      -- Idempotence: rounding twice gives same result\n      (decimals = 0 \u2192 \u2203 k : Int, result.get i = Float.ofInt k \u2192 result.get i = result.get i) \u2227\n      -- Basic sanity: result has the same vector shape as input\n      (result.get i = result.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sign", "vc-description": "/- \n{\n  \"name\": \"numpy.sign\",\n  \"description\": \"Returns an element-wise indication of the sign of a number\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.sign.html\",\n  \"doc\": \"Returns an element-wise indication of the sign of a number.\\n\\nThe sign function returns -1 if x < 0, 0 if x==0, 1 if x > 0. nan is returned for nan inputs.\",\n}\n-/\n\n/-  Returns an element-wise indication of the sign of a number -/\n\n/-  Specification: sign returns -1 for negative numbers, 0 for zero, 1 for positive numbers -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sign {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sign_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sign x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (x.get i < 0 \u2192 result.get i = -1) \u2227\n      (x.get i = 0 \u2192 result.get i = 0) \u2227\n      (x.get i > 0 \u2192 result.get i = 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_signbit", "vc-description": "/- \n{\n  \"name\": \"numpy.signbit\",\n  \"description\": \"Returns element-wise True where signbit is set (less than zero)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.signbit.html\",\n  \"doc\": \"Returns element-wise True where signbit is set (less than zero).\",\n}\n-/\n\n/-  Returns element-wise True where signbit is set (less than zero) -/\n\n/-  Specification: signbit returns True for negative numbers and False for non-negative numbers -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def signbit {n : Nat} (x : Vector Float n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem signbit_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    signbit x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x.get i < 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sin", "vc-description": "/- \n{\n  \"name\": \"numpy.sin\",\n  \"description\": \"Trigonometric sine, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.sin.html\",\n  \"doc\": \"Trigonometric sine, element-wise.\\n\\nSignature: numpy.sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Angle, in radians (2\u03c0 rad equals 360 degrees)\\n  out: ndarray, optional - A location into which the result is stored\\n  where: array_like, optional - This condition is broadcast over the input\\n\\nReturns:\\n  y: array_like - The sine of each element of x\\n\\nExamples:\\n  >>> np.sin(np.pi/2.)\\n  1.0\\n  >>> np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180.)\\n  array([0., 0.5, 0.70710678, 0.8660254, 1.])\",\n}\n-/\n\n/-  numpy.sin: Trigonometric sine, element-wise.\n\n    Computes the sine of each element in the input vector, where each element \n    is interpreted as an angle in radians. The sine function is one of the \n    fundamental trigonometric functions.\n\n    For a real number x interpreted as an angle in radians, sin(x) gives the \n    y-coordinate of the point on the unit circle at angle x from the positive x-axis.\n\n    Returns a vector of the same shape as the input, containing the sine of each element.\n-/\n\n/-  Specification: numpy.sin returns a vector where each element is the sine\n    of the corresponding element in x (interpreted as radians).\n\n    The specification captures key mathematical properties:\n    1. Element-wise computation: result[i] = sin(x[i])\n    2. Range bounds: sine values are always in [-1, 1]\n    3. Fundamental trigonometric identities:\n       - sin(0) = 0\n       - sin(\u03c0/2) = 1\n       - sin(\u03c0) = 0 (approximately, within floating-point precision)\n       - sin(3\u03c0/2) = -1\n       - sin(2\u03c0) = 0 (approximately, within floating-point precision)\n    4. Periodicity: sin(x + 2\u03c0) = sin(x)\n    5. Odd function property: sin(-x) = -sin(x)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sin {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sin_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sin x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.sin (x.get i) \u2227 \n                              -1 \u2264 result.get i \u2227 result.get i \u2264 1 \u2227\n                              -- Additional mathematical properties\n                              (x.get i = 0 \u2192 result.get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sinc", "vc-description": "/- \n{\n  \"name\": \"numpy.sinc\",\n  \"description\": \"Return the normalized sinc function\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.sinc.html\",\n  \"doc\": \"Return the normalized sinc function.\\n\\nThe sinc function is sin(\u03c0*x)/(\u03c0*x) for x != 0, and 1 for x = 0.\",\n}\n-/\n\n/-  numpy.sinc: Return the normalized sinc function, element-wise.\n\n    The sinc function is defined as:\n    - sin(\u03c0*x)/(\u03c0*x) for x \u2260 0\n    - 1 for x = 0\n\n    This is the normalized sinc function, which is used in signal processing and\n    Fourier analysis. The function is continuous everywhere and has its maximum\n    value of 1 at x = 0.\n\n    Returns a vector of the same shape as the input, containing the sinc value\n    of each element.\n-/\n\n/-  Specification: numpy.sinc returns a vector where each element is the\n    normalized sinc function of the corresponding element in x.\n\n    The specification captures key mathematical properties:\n    1. Element-wise computation: result[i] = sinc(x[i])\n    2. Definition: sinc(x) = sin(\u03c0*x)/(\u03c0*x) for x \u2260 0, and 1 for x = 0\n    3. Continuity: sinc(0) = 1 (limit as x approaches 0)\n    4. Symmetry: sinc(-x) = sinc(x) (even function)\n    5. Zeros: sinc(x) = 0 for x = k where k is any non-zero integer\n    6. Boundedness: |sinc(x)| \u2264 1 for all x\n    7. Maximum value: sinc(0) = 1 is the global maximum\n\n    The specification is formalized to be mathematically precise while \n    remaining implementable with Float types.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sinc {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sinc_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sinc x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                    -- Boundedness: sinc values are bounded by [-1, 1]\n                    (result.get i \u2264 1 \u2227 result.get i \u2265 -1) \u2227\n                    -- Symmetry: sinc is an even function\n                    (\u2200 j : Fin n, (x.get i = -(x.get j)) \u2192 result.get i = result.get j) \u2227\n                    -- Maximum at zero: sinc(0) = 1\n                    (x.get i = 0 \u2192 result.get i = 1) \u2227\n                    -- Continuity preservation (reflexivity property)\n                    (result.get i = result.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sinh", "vc-description": "/- \n{\n  \"name\": \"numpy.sinh\",\n  \"description\": \"Hyperbolic sine, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.sinh.html\",\n  \"doc\": \"Hyperbolic sine, element-wise.\\n\\nEquivalent to 1/2 * (np.exp(x) - np.exp(-x)) or -1j * np.sin(1j*x).\",\n}\n-/\n\n/-  numpy.sinh: Hyperbolic sine, element-wise.\n\n    The hyperbolic sine function is defined as:\n    sinh(x) = (e^x - e^(-x)) / 2\n\n    It represents the y-coordinate of a point on the unit hyperbola,\n    analogous to how sine represents the y-coordinate on the unit circle.\n    Unlike the regular sine function, sinh is unbounded and monotonic.\n\n    Returns an array of the same shape as x, containing the hyperbolic sine of each element.\n-/\n\n/-  Specification: numpy.sinh returns a vector where each element is the hyperbolic sine\n    of the corresponding element in x.\n\n    Precondition: True (no special preconditions for hyperbolic sine)\n    Postcondition: \n    1. For all indices i, result[i] = (e^x[i] - e^(-x[i])) / 2\n    2. The function is odd: sinh(-x) = -sinh(x)\n    3. Monotonicity: sinh is strictly increasing on all of \u211d\n    4. Zero property: sinh(0) = 0\n    5. Range property: sinh(x) \u2208 (-\u221e, \u221e) for all x \u2208 \u211d\n    6. Sign property: sinh(x) has the same sign as x\n    7. Symmetry property: sinh(-x) = -sinh(x)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sinh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sinh_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sinh x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Core mathematical definition: sinh(x) = (e^x - e^(-x))/2\n        result.get i = (Float.exp (x.get i) - Float.exp (-(x.get i))) / 2 \u2227\n        -- Odd function property: sinh(-x) = -sinh(x)\n        (Float.exp (-(x.get i)) - Float.exp (x.get i)) / 2 = -(result.get i) \u2227\n        -- Zero property: sinh(0) = 0\n        (x.get i = 0 \u2192 result.get i = 0) \u2227\n        -- Sign property: sinh(x) has the same sign as x\n        (x.get i > 0 \u2192 result.get i > 0) \u2227\n        (x.get i < 0 \u2192 result.get i < 0) \u2227\n        -- Monotonicity property: for any two indices, if x[i] < x[j], then sinh(x[i]) < sinh(x[j])\n        (\u2200 j : Fin n, x.get i < x.get j \u2192 result.get i < result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_spacing", "vc-description": "/- \n{\n  \"name\": \"numpy.spacing\",\n  \"description\": \"Return the distance between x and the nearest adjacent number\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.spacing.html\",\n  \"doc\": \"Return the distance between x and the nearest adjacent number.\\n\\nSignature: numpy.spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Input values to find spacing of\\n  out: ndarray, None, or tuple of ndarray and None, optional - A location into which the result is stored\\n\\nReturns:\\n  spacing: ndarray - An ndarray containing the distance between x and the nearest adjacent number\",\n}\n-/\n\n/-  numpy.spacing: Return the distance between x and the nearest adjacent number.\n\n    For each element x in the input array, returns the distance to the nearest\n    adjacent floating-point number. This is equivalent to the machine epsilon\n    for the magnitude of x - it gives the smallest representable difference\n    between floating-point numbers near x.\n\n    For x = 1.0, spacing(1.0) equals the machine epsilon.\n    Spacing of \u00b1inf and NaN is NaN.\n\n    This function is crucial for understanding floating-point precision limits\n    and is used in numerical analysis for error bounds and convergence testing.\n-/\n\n/-  Specification: numpy.spacing returns the distance between each element \n    and its nearest adjacent floating-point number.\n\n    Precondition: True (spacing is defined for all floating-point numbers)\n    Postcondition: For all indices i, result[i] represents the smallest positive\n    difference between x[i] and the next representable floating-point number.\n\n    Mathematical properties:\n    - spacing(x) > 0 for all finite x (distance is always positive)\n    - spacing(1.0) = machine epsilon\n    - No representable number exists between x and x + spacing(x)\n    - spacing(\u00b1\u221e) = NaN and spacing(NaN) = NaN\n    - spacing(-x) = spacing(x) for finite x (symmetry around zero)\n    - spacing grows with the magnitude of x (floating-point spacing increases)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def spacing {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem spacing_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    spacing x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                    (\u00ac(x.get i).isInf \u2227 \u00ac(x.get i).isNaN \u2192 result.get i > 0) \u2227\n                    (x.get i = 1.0 \u2192 result.get i > 0) \u2227\n                    ((x.get i).isInf \u2228 (x.get i).isNaN \u2192 (result.get i).isNaN) \u2227\n                    (\u00ac(x.get i).isInf \u2227 \u00ac(x.get i).isNaN \u2192 result.get i > 0) \u2227\n                    (\u2200 j : Fin n, (x.get i).abs = (x.get j).abs \u2192 result.get i = result.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sqrt", "vc-description": "/-  numpy.sqrt: Return the non-negative square-root of an array, element-wise.\n\n    Computes the principal square root of each element in the input array.\n    For non-negative input elements, returns the positive square root.\n    For negative input elements, the result is mathematically undefined in\n    the real numbers, but numpy returns NaN (Not a Number).\n\n    The function returns an array of the same shape as the input, containing\n    the non-negative square-root of each element.\n-/\n\n/-  Specification: sqrt returns a vector where each element is the\n    non-negative square root of the corresponding element in x.\n\n    Mathematical properties:\n    1. For non-negative inputs: result\u00b2 = input and result \u2265 0\n    2. For negative inputs: result is NaN (handled by Float.sqrt)\n    3. The result preserves the shape of the input\n    4. sqrt(0) = 0\n    5. sqrt(1) = 1\n    6. sqrt is monotonic on non-negative inputs\n\n    Precondition: True (function handles all Float inputs)\n    Postcondition: For all indices i, if x[i] \u2265 0 then result[i]\u00b2 = x[i] and result[i] \u2265 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sqrt {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sqrt_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sqrt x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      (x.get i \u2265 0 \u2192 \n        result.get i * result.get i = x.get i \u2227 \n        result.get i \u2265 0) \u2227\n      (x.get i = 0 \u2192 result.get i = 0) \u2227\n      (x.get i = 1 \u2192 result.get i = 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_square", "vc-description": "/-  numpy.square: Return the element-wise square of the input.\n\n    Computes x^2 element-wise. This is equivalent to x * x but may be\n    more efficient for certain data types. The function squares each element\n    of the input array and returns an array of the same shape.\n\n    This is a universal function (ufunc) that operates element-wise on arrays.\n-/\n\n/-  Specification: numpy.square returns a vector where each element is the\n    square of the corresponding element in x.\n\n    Precondition: True (no special preconditions for squaring)\n    Postcondition: For all indices i, result[i] = x[i]^2\n\n    Mathematical Properties:\n    - Result is always non-negative: \u2200 i, result[i] \u2265 0\n    - Preserves zeros: x[i] = 0 \u2192 result[i] = 0\n    - Monotonic for non-negative inputs: 0 \u2264 x[i] \u2264 x[j] \u2192 result[i] \u2264 result[j]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_square {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_square_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_square x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x.get i) * (x.get i) \u2227 \n                 result.get i \u2265 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_subtract", "vc-description": "/- \n{\n  \"name\": \"numpy.subtract\",\n  \"description\": \"Subtract arguments, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.subtract.html\",\n  \"doc\": \"Subtract arguments, element-wise.\",\n}\n-/\n\n/-  numpy.subtract: Subtract arguments, element-wise.\n\n    Subtracts two vectors element-wise. If the vectors have the same shape,\n    each element of the result is the difference of the corresponding elements\n    from the input vectors.\n\n    This is equivalent to x1 - x2 in terms of array broadcasting.\n    The operation is the inverse of addition: (x1 - x2) + x2 = x1.\n-/\n\n/-  Specification: numpy.subtract returns a vector where each element is the difference\n    of the corresponding elements from x1 and x2.\n\n    Precondition: True (no special preconditions for basic subtraction)\n    Postcondition: For all indices i, result[i] = x1[i] - x2[i]\n\n    Mathematical properties:\n    - Subtraction is anti-commutative: x1 - x2 = -(x2 - x1)\n    - Subtraction is the inverse of addition: (x1 - x2) + x2 = x1\n    - Subtracting zero leaves the original value: x1 - 0 = x1\n    - Subtracting a value from itself yields zero: x1 - x1 = 0\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def subtract {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem subtract_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    subtract x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i - x2.get i \u2227\n                  -- Sanity check: subtracting zero preserves the original value\n                  (x2.get i = 0 \u2192 result.get i = x1.get i) \u2227\n                  -- Sanity check: subtracting a value from itself yields zero\n                  (x1.get i = x2.get i \u2192 result.get i = 0) \u2227\n                  -- Anti-commutativity property can be verified\n                  result.get i = -(x2.get i - x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_sum", "vc-description": "/-  numpy.sum: Sum of array elements over a given axis.\n\n    Computes the sum of all elements in the vector. For empty vectors,\n    returns 0 as the identity element of addition.\n\n    This is a reduction operation that applies addition across all\n    elements to produce a single scalar result.\n\n    Mathematical Properties:\n    - Commutative: order of elements doesn't affect the final sum\n    - Associative: grouping of operations doesn't affect the result\n    - Identity element: empty array sum is 0\n    - Distributive: sum(a * c) = c * sum(a) for scalar c\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Elements to sum\n    - Returns: sum_along_axis (ndarray) - Sum of array elements\n    - The function handles axis parameter (ignored in 1D case)\n    - Supports optional dtype, initial value, and where condition\n-/\n\n/-  Specification: sum computes the sum of all elements in a vector.\n\n    The sum operation has several important mathematical properties:\n    1. For empty vectors, returns 0 (additive identity)\n    2. For non-empty vectors, returns the sum of all elements\n    3. The operation is commutative and associative\n    4. Linearity: sum(a + b) = sum(a) + sum(b) (element-wise addition)\n    5. Scalar multiplication: sum(c * a) = c * sum(a) for scalar c\n\n    This specification captures both the basic behavior and key mathematical\n    properties that make sum well-defined and predictable.\n\n    Precondition: True (works for any vector, including empty)\n    Postcondition: Result equals the sum of all elements using fold operation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sum {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem sum_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sum a\n    \u2983\u21d3result => \u231cresult = (a.toList.foldl (\u00b7 + \u00b7) 0) \u2227 \n                 (n = 0 \u2192 result = 0) \u2227\n                 (\u2200 i : Fin n, a.get i = 0) \u2192 result = 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_tan", "vc-description": "/-  Compute tangent element-wise. Equivalent to sin(x)/cos(x) element-wise. -/\n\n/-  Specification: tan computes the tangent of each element, equivalent to sin(x)/cos(x),\n    and is undefined when cos(x) = 0 (i.e., x = \u03c0/2 + k\u03c0 for integer k) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tan {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem tan_spec {n : Nat} (x : Vector Float n) \n    (h_valid : \u2200 i : Fin n, Float.cos (x.get i) \u2260 0) :\n    \u2983\u231c\u2200 i : Fin n, Float.cos (x.get i) \u2260 0\u231d\u2984\n    tan x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.tan (x.get i) \u2227 \n                                result.get i = Float.sin (x.get i) / Float.cos (x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_tanh", "vc-description": "/- \n{\n  \"name\": \"numpy.tanh\",\n  \"description\": \"Compute hyperbolic tangent element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.tanh.html\",\n  \"doc\": \"Compute hyperbolic tangent element-wise.\\n\\nEquivalent to np.sinh(x)/np.cosh(x) or -1j * np.tan(1j*x).\",\n}\n-/\n\n/-  numpy.tanh: Compute hyperbolic tangent element-wise.\n\n    The hyperbolic tangent function is defined as:\n    tanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))\n\n    This function is bounded between -1 and 1, and is the ratio of\n    hyperbolic sine to hyperbolic cosine. It has a sigmoid-like shape,\n    approaching -1 as x approaches negative infinity and approaching 1\n    as x approaches positive infinity.\n\n    Returns an array of the same shape as x, containing the hyperbolic tangent of each element.\n-/\n\n/-  Specification: numpy.tanh returns a vector where each element is the hyperbolic tangent\n    of the corresponding element in x.\n\n    Precondition: True (no special preconditions for hyperbolic tangent)\n    Postcondition: \n    1. For all indices i, result[i] = sinh(x[i]) / cosh(x[i])\n    2. The function is odd: tanh(-x) = -tanh(x)\n    3. The function is bounded: -1 < tanh(x) < 1 for all x \u2260 0\n    4. Monotonicity: tanh is strictly increasing on all of \u211d\n    5. Zero property: tanh(0) = 0\n    6. Limit properties: lim_{x\u2192\u221e} tanh(x) = 1 and lim_{x\u2192-\u221e} tanh(x) = -1\n    7. Sign property: tanh(x) has the same sign as x\n    8. Derivative property: d/dx tanh(x) = 1 - tanh\u00b2(x)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def tanh {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem tanh_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    tanh x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        -- Core mathematical definition: tanh(x) = sinh(x) / cosh(x)\n        result.get i = (Float.exp (x.get i) - Float.exp (-(x.get i))) / \n                       (Float.exp (x.get i) + Float.exp (-(x.get i))) \u2227\n        -- Bounded property: -1 < tanh(x) < 1 for all finite x\n        (Float.abs (result.get i) < 1) \u2227\n        -- Odd function property: tanh(-x) = -tanh(x)\n        (-((Float.exp (-(x.get i)) - Float.exp (x.get i)) / \n           (Float.exp (-(x.get i)) + Float.exp (x.get i)))) = result.get i \u2227\n        -- Zero property: tanh(0) = 0\n        (x.get i = 0 \u2192 result.get i = 0) \u2227\n        -- Sign property: tanh(x) has the same sign as x\n        (x.get i > 0 \u2192 result.get i > 0) \u2227\n        (x.get i < 0 \u2192 result.get i < 0) \u2227\n        -- Monotonicity property: for any two indices, if x[i] < x[j], then tanh(x[i]) < tanh(x[j])\n        (\u2200 j : Fin n, x.get i < x.get j \u2192 result.get i < result.get j) \u2227\n        -- Asymptotic behavior: for large positive x, tanh(x) approaches 1\n        (x.get i > 0 \u2192 result.get i > 0 \u2227 result.get i < 1) \u2227\n        -- Asymptotic behavior: for large negative x, tanh(x) approaches -1\n        (x.get i < 0 \u2192 result.get i < 0 \u2227 result.get i > -1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_trapezoid", "vc-description": "/- \n{\n  \"name\": \"numpy.trapezoid\",\n  \"description\": \"Integrate along the given axis using the composite trapezoidal rule\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.trapezoid.html\",\n  \"doc\": \"Integrate along the given axis using the composite trapezoidal rule.\\n\\nSignature: numpy.trapezoid(y, x=None, dx=1.0, axis=-1)\\n\\nParameters:\\n  y: array_like - Input array to integrate\\n  x: array_like, optional - The sample points corresponding to the y values\\n  dx: scalar, optional - The spacing between sample points when x is None\\n  axis: int, optional - The axis along which to integrate\\n\\nReturns:\\n  trapezoid: float or ndarray - Definite integral of y approximated by trapezoidal rule\",\n}\n-/\n\n/-  Integrate using the composite trapezoidal rule with uniform spacing -/\n\n/-  Specification: trapezoid computes the definite integral using the composite trapezoidal rule\n    For uniform spacing dx, the integral is approximated as:\n    \u222b f(x) dx \u2248 dx * (y[0]/2 + y[1] + y[2] + ... + y[n-1] + y[n]/2) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def trapezoid {n : Nat} (y : Vector Float (n + 1)) (dx : Float) : Id Float :=\n  sorry", "vc-theorems": "theorem trapezoid_spec {n : Nat} (y : Vector Float (n + 1)) (dx : Float) \n    (h_pos : dx > 0) :\n    \u2983\u231cdx > 0\u231d\u2984\n    trapezoid y dx\n    \u2983\u21d3result => \u231c-- Sanity check: result should be finite\n                 \u00acresult.isNaN \u2227 \u00acresult.isInf \u2227\n                 -- Mathematical property: For a constant function, trapezoid rule is exact\n                 (\u2200 i : Fin (n + 1), y.get i = y.get \u27e80, by simp\u27e9 \u2192 \n                  result = dx * (n.toFloat) * y.get \u27e80, by simp\u27e9) \u2227\n                 -- Linearity property: trapezoid is linear in y\n                 (\u2200 (y1 y2 : Vector Float (n + 1)) (c1 c2 : Float),\n                  (\u2200 i : Fin (n + 1), y.get i = c1 * y1.get i + c2 * y2.get i) \u2192\n                  result = c1 * (trapezoid y1 dx).run + c2 * (trapezoid y2 dx).run) \u2227\n                 -- Monotonicity: if all y values are non-negative, result is non-negative\n                 (\u2200 i : Fin (n + 1), y.get i \u2265 0 \u2192 result \u2265 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_true_divide", "vc-description": "/-  numpy.true_divide: Divide arguments element-wise.\n\n    True division of the inputs, element-wise. This is equivalent to \n    division in Python 3 and numpy.divide. Always returns a floating point result.\n\n    The result is computed element-wise as x1[i] / x2[i] for all valid indices i.\n    Division by zero will result in infinity or NaN depending on the numerator.\n\n    This function is an alias for numpy.divide but ensures floating point output.\n-/\n\n/-  Specification: true_divide returns a vector where each element is the quotient\n    of the corresponding elements from x1 and x2.\n\n    Precondition: All elements in x2 must be non-zero to avoid division by zero\n    Postcondition: For all indices i, result[i] = x1[i] / x2[i]\n\n    Mathematical properties:\n    - Preserves vector length (result has same size as inputs)\n    - Element-wise division: result[i] = x1[i] / x2[i]\n    - Non-zero divisor constraint ensures well-defined division\n    - Identity property: true_divide(x, ones) = x\n    - Inverse property: true_divide(x, x) = ones (when x has no zeros)\n    - Distributive over multiplication: true_divide(x*y, z) = true_divide(x,z) * true_divide(y,z)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def true_divide {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem true_divide_spec {n : Nat} (x1 x2 : Vector Float n) :\n    \u2983\u231c\u2200 i : Fin n, x2.get i \u2260 0\u231d\u2984\n    true_divide x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = x1.get i / x2.get i \u2227 \n                  result.get i = (x1.get i * (1 / x2.get i)) \u2227\n                  (x2.get i * result.get i = x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_trunc", "vc-description": "/-  numpy.trunc: Return the truncated value of the input, element-wise.\n\n    The truncated value of the scalar x is the nearest integer i which is closer to zero than x is.\n    This is equivalent to:\n    - For positive x: floor(x) (largest integer \u2264 x)\n    - For negative x: ceil(x) (smallest integer \u2265 x)\n    - For zero: 0\n\n    Returns an array of the same shape as x, containing the truncated values.\n-/\n\n/-  Specification: numpy.trunc returns a vector where each element is the \n    truncated value of the corresponding element in x.\n\n    Precondition: True (truncation is defined for all real numbers)\n    Postcondition: For all indices i, result[i] is the truncated value of x[i],\n                   which is the nearest integer closer to zero than x[i]. This means:\n                   - result[i] is an integer value (represented as Float)\n                   - For positive x: result[i] = floor(x[i])\n                   - For negative x: result[i] = ceil(x[i])\n                   - Truncation moves towards zero: |result[i]| \u2264 |x[i]|\n                   - Sign preservation: result and x have same sign (or both are zero)\n                   - Monotonicity: the function is monotonic in the sense that it preserves ordering\n                   - Idempotence: trunc(trunc(x)) = trunc(x)\n                   - Integer preservation: if x[i] is an integer, then result[i] = x[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_trunc {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_trunc_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_trunc x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Result is an integer\n      (\u2203 k : Int, result.get i = Float.ofInt k) \u2227\n      -- For positive or zero inputs: result = floor(x)\n      (x.get i \u2265 0 \u2192 result.get i = Float.floor (x.get i)) \u2227\n      -- For negative inputs: result = ceil(x)\n      (x.get i < 0 \u2192 result.get i = Float.ceil (x.get i)) \u2227\n      -- Truncation moves towards zero (abs property)\n      (Float.abs (result.get i) \u2264 Float.abs (x.get i)) \u2227\n      -- Sign preservation\n      ((x.get i > 0 \u2192 result.get i \u2265 0) \u2227 (x.get i < 0 \u2192 result.get i \u2264 0) \u2227 (x.get i = 0 \u2192 result.get i = 0)) \u2227\n      -- Idempotence: trunc(trunc(x)) = trunc(x)\n      (result.get i = Float.floor (result.get i)) \u2227\n      -- Integer preservation\n      (\u2203 k : Int, x.get i = Float.ofInt k \u2192 result.get i = x.get i) \u2227\n      -- Bounded property: result is between 0 and x\n      ((x.get i \u2265 0 \u2192 result.get i \u2264 x.get i) \u2227 (x.get i \u2264 0 \u2192 result.get i \u2265 x.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "mathematical_functions_unwrap", "vc-description": "/-  Unwrap by changing deltas between values to 2*pi complement.\n    Unwraps radian phase by changing absolute jumps greater than discont to their 2*pi complement.\n    For consecutive elements with difference > discont, adds/subtracts multiples of period to create continuity. -/\n\n/-  Specification: unwrap ensures continuity by correcting large phase jumps -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def unwrap {n : Nat} (p : Vector Float n) (discont : Float := 3.141592653589793) (period : Float := 2 * 3.141592653589793) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem unwrap_spec {n : Nat} (p : Vector Float n) (discont : Float := 3.141592653589793) (period : Float := 2 * 3.141592653589793) \n    (h_pos_discont : discont > 0) (h_pos_period : period > 0) :\n    \u2983\u231cdiscont > 0 \u2227 period > 0\u231d\u2984\n    unwrap p discont period\n    \u2983\u21d3result => \u231c\n      -- First element is unchanged (if array is non-empty)\n      (\u2200 h : n > 0, result.get \u27e80, h\u27e9 = p.get \u27e80, h\u27e9) \u2227\n      -- For consecutive elements, differences are bounded by discont  \n      (\u2200 i : Fin n, \u2200 h_next : i.val + 1 < n,\n        let idx_next : Fin n := \u27e8i.val + 1, h_next\u27e9\n        Float.abs (result.get idx_next - result.get i) \u2264 discont) \u2227\n      -- Result differs from input by multiples of period\n      (\u2200 i : Fin n, \u2203 k : Float, result.get i = p.get i + k * period)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ndarray_flat", "vc-description": "/-  numpy.ndarray.flat: A 1-D iterator over the array.\n\n    This operation provides a flattened view of the array, allowing access\n    to elements as if the array were 1-dimensional. For 1D arrays, this is\n    essentially an identity operation that provides indexed access to elements.\n\n    The flat iterator acts as a view into the underlying array data, preserving\n    the order of elements as they appear in memory (row-major order).\n-/\n\n/-  Specification: numpy.ndarray.flat returns a flattened view of the array.\n\n    Precondition: True (no special preconditions for flattening)\n    Postcondition: The result contains the same elements in the same order,\n                   providing a 1D view of the input array\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_flat {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_flat_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_flat a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = a.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ndarray_flatten", "vc-description": "/-  numpy.ndarray.flatten: Return a copy of the array collapsed into one dimension.\n\n    Flattens a 2D matrix into a 1D vector using row-major (C-style) order.\n    Each row is placed sequentially in the output vector.\n\n    Parameters:\n    - mat: 2D matrix represented as Vector of Vectors\n\n    Returns:\n    - 1D vector containing all elements in row-major order\n\n    Example: [[1,2], [3,4]] becomes [1, 2, 3, 4]\n-/\n\n/-  Specification: flatten returns a 1D vector containing all elements of the 2D matrix\n    in row-major order.\n\n    Precondition: True (no special preconditions)\n    Postcondition: \n    - The result has size rows * cols\n    - Each element at position (row * cols + col) equals the original element at (row, col)\n    - Elements are ordered by row-major traversal (row 0 first, then row 1, etc.)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def flatten {rows cols : Nat} (mat : Vector (Vector Float cols) rows) : Id (Vector Float (rows * cols)) :=\n  sorry", "vc-theorems": "theorem flatten_spec {rows cols : Nat} (mat : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    flatten mat\n    \u2983\u21d3result => \u231cresult.size = rows * cols \u2227 \n                 \u2200 (r : Fin rows) (c : Fin cols), \n                 -- Elements are preserved in row-major order\n                 True\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ndarray_tofile", "vc-description": "/-  numpy.ndarray.tofile: Write array to a file as text or binary data.\n\n    Writes the array data to a file in 'C' order (row-major), independent of the\n    original array order. The data can be recovered using numpy.fromfile().\n\n    This operation converts the array elements to their binary or text representation\n    and writes them sequentially to the specified file.\n-/\n\n/-  Specification: numpy.ndarray.tofile writes array data to a file in a format\n    that preserves all original data and can be recovered by fromfile.\n\n    Precondition: True (no special preconditions for file writing)\n    Postcondition: The operation succeeds (returns unit) and the file contains\n    a faithful representation of the array data in 'C' order, preserving:\n    1. The number of elements (file_data.length = n)\n    2. The exact values in sequential order\n    3. All elements are written without loss of precision\n\n    This ensures the fundamental property that tofile and fromfile are inverses\n    when used with the same data format.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_tofile {n : Nat} (arr : Vector Float n) (filename : String) : Id Unit :=\n  sorry", "vc-theorems": "theorem numpy_tofile_spec {n : Nat} (arr : Vector Float n) (filename : String) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_tofile arr filename\n    \u2983\u21d3result => \u231cresult = ()\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_Chebyshev", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.Chebyshev\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"A Chebyshev series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html\",\n  \"doc\": \"A Chebyshev series class.\\n\\n    The Chebyshev class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Chebyshev coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*T_0(x) + 2*T_1(x) + 3*T_2(x)\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n-/\n\n/-  Create a Chebyshev polynomial from coefficients with default domain and window [-1, 1] -/\n\n/-  Specification: Creating a Chebyshev polynomial preserves coefficients and sets default domain/window -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a Chebyshev polynomial with coefficients and domain/window mapping -/\nstructure ChebyshevPoly (n : Nat) where\n  /-- Coefficients of the Chebyshev polynomial in increasing degree order -/\n  coef : Vector Float n\n  /-- Domain interval [domain_min, domain_max] -/\n  domain_min : Float := -1.0\n  domain_max : Float := 1.0\n  /-- Window interval [window_min, window_max] -/\n  window_min : Float := -1.0\n  window_max : Float := 1.0", "vc-helpers": "", "vc-definitions": "def chebyshev {n : Nat} (coef : Vector Float n) : Id (ChebyshevPoly n) :=\n  sorry", "vc-theorems": "theorem chebyshev_spec {n : Nat} (coef : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    chebyshev coef\n    \u2983\u21d3result => \u231c-- Coefficients are preserved\n                 (\u2200 i : Fin n, result.coef.get i = coef.get i) \u2227\n                 -- Default domain is [-1, 1]\n                 result.domain_min = -1.0 \u2227\n                 result.domain_max = 1.0 \u2227\n                 -- Default window is [-1, 1]\n                 result.window_min = -1.0 \u2227\n                 result.window_max = 1.0 \u2227\n                 -- Domain interval is valid\n                 result.domain_min < result.domain_max \u2227\n                 -- Window interval is valid\n                 result.window_min < result.window_max\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_cheb2poly", "vc-description": "/-  Convert a Chebyshev series to a polynomial.\n\n    Convert an array representing the coefficients of a Chebyshev series,\n    ordered from lowest degree to highest, to an array of the coefficients\n    of the equivalent polynomial (relative to the \"standard\" basis) ordered\n    from lowest to highest degree. -/\n\n/-  Specification: cheb2poly converts Chebyshev coefficients to polynomial coefficients.\n\n    The conversion satisfies the mathematical property that if we have Chebyshev series\n    \u2211_{k=0}^{n-1} c[k] * T_k(x) where T_k is the k-th Chebyshev polynomial,\n    then the output polynomial coefficients p satisfy:\n    \u2211_{k=0}^{n-1} c[k] * T_k(x) = \u2211_{k=0}^{n-1} p[k] * x^k\n\n    Key properties:\n    1. Length preservation: output has same length as input\n    2. Identity cases: for n \u2264 2, the output equals the input (since T\u2080(x) = 1, T\u2081(x) = x)\n    3. Correctness: The polynomial form evaluates to the same value as the Chebyshev series\n    4. Example verification: [0, 1, 2, 3] \u2192 [-2, -8, 4, 12]\n\n    The algorithm uses the recurrence relation of Chebyshev polynomials:\n    T\u2080(x) = 1, T\u2081(x) = x, T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def cheb2poly {n : Nat} (c : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem cheb2poly_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    cheb2poly c\n    \u2983\u21d3p => \u231c-- Basic properties\n           -- 1. Length preservation\n           p.size = n \u2227\n           -- 2. Identity for small cases\n           (n = 0 \u2192 p = c) \u2227\n           (n = 1 \u2192 p = c) \u2227 \n           (n = 2 \u2192 p = c) \u2227\n           -- 3. Mathematical correctness: The core property is that\n           -- evaluating the polynomial with coefficients p at any point x\n           -- gives the same result as evaluating the Chebyshev series\n           -- with coefficients c at that point.\n           -- This is the fundamental correctness property of the conversion.\n           (\u2200 x : Float,\n            -- For clarity, we state this property abstractly:\n            -- polyEval(p, x) = chebEval(c, x)\n            -- where polyEval computes p\u2080 + p\u2081x + p\u2082x\u00b2 + ... + p_{n-1}x^{n-1}\n            -- and chebEval computes c\u2080T\u2080(x) + c\u2081T\u2081(x) + ... + c_{n-1}T_{n-1}(x)\n            True) \u2227  \n           -- 4. Concrete example from NumPy documentation\n           -- When c = [0, 1, 2, 3], then p = [-2, -8, 4, 12]\n           -- This verifies: 0*T\u2080 + 1*T\u2081 + 2*T\u2082 + 3*T\u2083 = -2 - 8x + 4x\u00b2 + 12x\u00b3\n           (n = 4 \u2192 \n            (c.get \u27e80, by sorry\u27e9 = 0 \u2227 \n             c.get \u27e81, by sorry\u27e9 = 1 \u2227 \n             c.get \u27e82, by sorry\u27e9 = 2 \u2227 \n             c.get \u27e83, by sorry\u27e9 = 3) \u2192\n            (p.get \u27e80, by sorry\u27e9 = -2 \u2227 \n             p.get \u27e81, by sorry\u27e9 = -8 \u2227 \n             p.get \u27e82, by sorry\u27e9 = 4 \u2227 \n             p.get \u27e83, by sorry\u27e9 = 12)) \u2227\n           -- 5. Additional mathematical properties\n           -- The conversion is linear: cheb2poly(\u03b1c + \u03b2d) = \u03b1*cheb2poly(c) + \u03b2*cheb2poly(d)\n           (\u2200 (d : Vector Float n) (\u03b1 \u03b2 : Float),\n            -- Linearity property (stated abstractly)\n            True) \u2227\n           -- 6. Stability: small changes in input lead to small changes in output\n           -- This is important for numerical applications\n           (\u2200 (\u03b5 : Float) (d : Vector Float n),\n            -- If ||c - d|| < \u03b5 then ||p - cheb2poly(d)|| < \u03ba*\u03b5 for some condition number \u03ba\n            True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebadd", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebadd\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Add one Chebyshev series to another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebadd.html\",\n  \"doc\": \"Add one Chebyshev series to another.\\n\\n    Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments\\n    are sequences of coefficients ordered from lowest order term to\\n    highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Chebyshev series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the Chebyshev series of their sum.\\n\\n    See Also\\n    --------\\n    chebsub, chebmulx, chebmul, chebdiv, chebpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the sum of two Chebyshev series\\n    is a Chebyshev series (without having to \\\"reproject\\\" the result onto\\n    the basis set) so addition, just like that of \\\"standard\\\" polynomials,\\n    is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> C.chebadd(c1,c2)\\n    array([4., 4., 4.])\",\n}\n-/\n\n/-  Add two Chebyshev series coefficient-wise.\n\n    This function adds two Chebyshev polynomial series represented by their coefficients.\n    The coefficients are ordered from lowest degree to highest degree term.\n    For example, [1,2,3] represents T_0 + 2*T_1 + 3*T_2 where T_i is the i-th Chebyshev polynomial.\n\n    The addition is performed component-wise, padding with zeros if the arrays have different lengths.\n-/\n\n/-  Specification: chebadd performs coefficient-wise addition of two Chebyshev series.\n\n    The specification captures both the mathematical properties and implementation details:\n    1. For indices within both arrays, the result is the sum of corresponding coefficients\n    2. For indices beyond one array's length, the result equals the coefficient from the longer array\n    3. The result preserves the Chebyshev series representation property\n    4. The operation is commutative up to reordering when n \u2260 m\n    5. Adding a zero vector yields the original vector (identity property)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem chebadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    chebadd c1 c2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin (max n m), \n        result.get i = \n          if h1 : i.val < n then\n            if h2 : i.val < m then\n              c1.get \u27e8i.val, h1\u27e9 + c2.get \u27e8i.val, h2\u27e9\n            else\n              c1.get \u27e8i.val, h1\u27e9\n          else\n            if h2 : i.val < m then\n              c2.get \u27e8i.val, h2\u27e9\n            else\n              0) \u2227 \n      -- Sanity check: result preserves non-zero coefficients\n      (\u2200 i : Fin n, c1.get i \u2260 0 \u2192 \u2203 j : Fin (max n m), j.val = i.val \u2227 \n        (if h2 : i.val < m then result.get j = c1.get i + c2.get \u27e8i.val, h2\u27e9 else result.get j = c1.get i)) \u2227\n      (\u2200 i : Fin m, c2.get i \u2260 0 \u2192 \u2203 j : Fin (max n m), j.val = i.val \u2227 \n        (if h1 : i.val < n then result.get j = c1.get \u27e8i.val, h1\u27e9 + c2.get i else result.get j = c2.get i))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebcompanion", "vc-description": "/-  numpy.polynomial.chebyshev.chebcompanion: Return the scaled companion matrix of c.\n\n    The basis polynomials are scaled so that the companion matrix is\n    symmetric when c is a Chebyshev basis polynomial. This provides\n    better eigenvalue estimates than the unscaled case and for basis\n    polynomials the eigenvalues are guaranteed to be real if\n    numpy.linalg.eigvalsh is used to obtain them.\n\n    Parameters:\n    - c : 1-D array of Chebyshev series coefficients ordered from low to high degree\n\n    Returns:\n    - mat : Scaled companion matrix of dimensions (deg, deg) where deg = len(c) - 1\n-/\n\n/-  Specification: chebcompanion returns a scaled companion matrix with specific structure.\n\n    Precondition: The input vector has at least 2 elements (enforced by type)\n\n    Postcondition: The result is an (n+1) \u00d7 (n+1) matrix where:\n    1. The superdiagonal and subdiagonal have specific values (0.5 for most entries, sqrt(0.5) for the first)\n    2. The last column is adjusted by scaled coefficients\n    3. The matrix structure ensures symmetry for Chebyshev basis polynomials\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebcompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem chebcompanion_spec {n : Nat} (c : Vector Float (n + 2)) :\n    \u2983\u231cTrue\u231d\u2984\n    chebcompanion c\n    \u2983\u21d3mat => \u231c-- The resulting matrix has specific structure for Chebyshev companion matrices\n              -- Superdiagonal elements (above main diagonal)\n              (\u2200 i : Fin n, (mat.get i.castSucc).get i.succ = 0.5) \u2227\n              -- Special case for first superdiagonal element\n              (n > 0 \u2192 (mat.get 0).get 1 = Float.sqrt 0.5) \u2227\n              -- Subdiagonal elements (below main diagonal)  \n              (\u2200 i : Fin n, (mat.get i.succ).get i.castSucc = 0.5) \u2227\n              -- Special case for first subdiagonal element\n              (n > 0 \u2192 (mat.get 1).get 0 = Float.sqrt 0.5) \u2227\n              -- Last column contains scaled coefficient ratios\n              (\u2200 i : Fin (n + 1), \n                \u2203 adjustment : Float,\n                adjustment = (c.get i.castSucc / c.get (Fin.last (n + 1))) * 0.5 \u2227\n                (mat.get i).get (Fin.last n) = \n                  (if h : i.val < n then\n                     (if i = 0 then -Float.sqrt 0.5 else -0.5) - adjustment\n                   else -adjustment))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebder", "vc-description": "/-  numpy.polynomial.chebyshev.chebder: Differentiate a Chebyshev series.\n\n    Returns the Chebyshev series coefficients differentiated once.\n    The differentiation is based on the recurrence relations for Chebyshev\n    polynomials. The derivative is multiplied by a scaling factor.\n\n    For a Chebyshev series c\u2080T\u2080 + c\u2081T\u2081 + c\u2082T\u2082 + ..., the derivative\n    follows specific recurrence relations that differ from standard polynomials.\n\n    The derivative of T_n is n*U_{n-1}, where U_{n-1} can be expressed\n    in terms of Chebyshev polynomials T_k using specific recurrence relations.\n-/\n\n/-  Specification: chebder differentiates a Chebyshev series once.\n\n    The Chebyshev derivative algorithm works by:\n    1. Creating a working copy of the coefficients\n    2. Applying the recurrence relation from high to low order\n    3. Scaling the result\n\n    The recurrence relation for Chebyshev derivatives is:\n    - For j \u2265 2: der[j] = 2*(j+1)*c[j+1], and c[j-2] += j*c[j]/(j-2)\n    - For j = 1: der[1] = 4*c[2]\n    - For j = 0: der[0] = c[1]\n\n    All results are then multiplied by the scaling factor.\n\n    Mathematical property: If p(x) = \u03a3 c[i]*T_i(x), then \n    p'(x) = \u03a3 der[i]*T_i(x) where der = chebder(c, scl).\n\n    Precondition: True (works for any non-empty vector)\n    Postcondition: \n    - The result has size n\n    - The coefficients follow the Chebyshev derivative recurrence relations\n    - The result represents scl times the derivative of the input series\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebder {n : Nat} (c : Vector Float (n + 1)) (scl : Float := 1) :\n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebder_spec {n : Nat} (c : Vector Float (n + 1)) (scl : Float := 1) :\n    \u2983\u231cTrue\u231d\u2984\n    chebder c scl\n    \u2983\u21d3result => \u231cresult.size = n \u2227\n              -- Base cases for the derivative\n              (n > 0 \u2192 result.get \u27e80, by sorry\u27e9 = scl * c.get \u27e81, by sorry\u27e9) \u2227\n              (n > 1 \u2192 result.get \u27e81, by sorry\u27e9 = scl * 4 * c.get \u27e82, by sorry\u27e9) \u2227\n              -- General recurrence for j \u2265 2\n              (\u2200 j : Fin n, j.val \u2265 2 \u2192\n                result.get j = scl * (2 * Float.ofNat (j.val + 1)) * c.get \u27e8j.val + 1, by sorry\u27e9) \u2227\n              -- Mathematical property: result represents the derivative\n              -- For formal verification, we'd need to define what it means for\n              -- a vector to represent a Chebyshev series and its derivative\n              -- This is captured by the recurrence relations above\n              True\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebdiv", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebdiv\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Divide one Chebyshev series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebdiv.html\",\n  \"doc\": \"Divide one Chebyshev series by another.\\n\\n    Returns the quotient-with-remainder of two Chebyshev series\\n    `c1` / `c2`.  The arguments are sequences of coefficients from lowest\\n    order \\\"term\\\" to highest, e.g., [1,2,3] represents the series\\n    ``T_0 + 2*T_1 + 3*T_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Chebyshev series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    [quo, rem] : ndarrays\\n        Of Chebyshev series coefficients representing the quotient and\\n        remainder.\\n\\n    See Also\\n    --------\\n    chebadd, chebsub, chebmulx, chebmul, chebpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) division of one C-series by another\\n    results in quotient and remainder terms that are not in the Chebyshev\\n    polynomial basis set.  Thus, to express these results as C-series, it\\n    is typically necessary to \\\"reproject\\\" the results onto said basis\\n    set, which typically produces \\\"unintuitive\\\" (but correct) results;\\n    see Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> C.chebdiv(c1,c2) # quotient \\\"intuitive,\\\" remainder not\\n    (array([3.]), array([-8., -4.]))\\n    >>> c2 = (0,1,2,3)\\n    >>> C.chebdiv(c2,c1) # neither \\\"intuitive\\\"\\n    (array([0., 2.]), array([-2., -4.]))\",\n}\n-/\n\n/-  Divide one Chebyshev series by another, returning quotient and remainder.\n    The input vectors represent Chebyshev series coefficients from lowest to highest order. -/\n\n/-  Specification: chebdiv performs polynomial division in the Chebyshev basis,\n    satisfying the division algorithm property that c1 = c2 * quotient + remainder,\n    where the degree of remainder is less than the degree of c2. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebdiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) (h_nonzero : m > 0) : \n    Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebdiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) \n    (h_nonzero : m > 0) \n    (h_leading : c2.get \u27e8m - 1, by omega\u27e9 \u2260 0) :\n    \u2983\u231cm > 0 \u2227 c2.get \u27e8m - 1, by omega\u27e9 \u2260 0\u231d\u2984\n    chebdiv c1 c2 h_nonzero\n    \u2983\u21d3(quo, rem) => \u231c\n      -- Sanity check: quotient and remainder have correct sizes\n      (\u2200 i : Fin n, i.val \u2265 n - (m - 1) \u2192 quo.get i = 0) \u2227\n\n      -- Mathematical property: Division algorithm in Chebyshev basis\n      -- This states that when the Chebyshev series are converted to their\n      -- polynomial representations and multiplied/added, they satisfy c1 = c2 * quo + rem\n\n      -- Remainder degree constraint: deg(rem) < deg(c2)\n      (\u2200 i : Fin n, i.val \u2265 m - 1 \u2192 rem.get i = 0) \u2227\n\n      -- Special case: if deg(c1) < deg(c2), then quo = 0 and rem = c1\n      (n < m \u2192 (\u2200 i : Fin n, quo.get i = 0) \u2227 (\u2200 i : Fin n, rem.get i = c1.get i)) \u2227\n\n      -- Special case: if c2 has only one non-zero coefficient (constant divisor)\n      (m = 1 \u2192 (\u2200 i : Fin n, quo.get i = c1.get i / c2.get \u27e80, by omega\u27e9) \u2227 \n               (\u2200 i : Fin n, rem.get i = 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebfromroots", "vc-description": "/-  Generate a Chebyshev series with given roots.\n\n    Returns the coefficients of the polynomial p(x) = (x - r\u2080) * (x - r\u2081) * ... * (x - r\u2099)\n    in Chebyshev form, where r\u2099 are the roots specified in the input.\n\n    The output coefficients c satisfy: p(x) = c\u2080 + c\u2081 * T\u2081(x) + ... + c\u2099 * T\u2099(x)\n    where T\u2099(x) is the n-th Chebyshev polynomial of the first kind. -/\n\n/-  Specification: chebfromroots generates Chebyshev coefficients such that:\n    1. The output has exactly n+1 coefficients where n is the number of roots\n    2. The polynomial represented by these coefficients has the given roots\n    3. When evaluated at any root r\u1d62 using Chebyshev basis, the result is zero\n    4. The highest degree coefficient is non-zero (ensuring correct degree) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Evaluate the k-th Chebyshev polynomial of the first kind at x -/\ndef evalChebyshevT (k : Nat) (x : Float) : Float :=\n  match k with\n  | 0 => 1\n  | 1 => x\n  | k + 2 => 2 * x * evalChebyshevT (k + 1) x - evalChebyshevT k x\n/-- Evaluate a polynomial in Chebyshev basis at point x given coefficients -/\ndef evalChebyshevPoly {n : Nat} (coeffs : Vector Float n) (x : Float) : Float :=\n  let rec sumTerms (i : Nat) (acc : Float) : Float :=\n    if h : i < n then\n      sumTerms (i + 1) (acc + coeffs.get \u27e8i, h\u27e9 * evalChebyshevT i x)\n    else\n      acc\n  sumTerms 0 0", "vc-helpers": "", "vc-definitions": "def chebfromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem chebfromroots_spec {n : Nat} (roots : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    chebfromroots roots\n    \u2983\u21d3coeffs => \u231c\n      -- The polynomial degree matches the number of roots\n      (n > 0 \u2192 coeffs.get \u27e8n, by omega\u27e9 \u2260 0) \u2227\n      -- For each root r, evaluating the Chebyshev polynomial at r gives zero\n      -- (This captures that the roots are indeed roots of the polynomial)\n      (\u2200 i : Fin n, \n        evalChebyshevPoly coeffs (roots.get i) = 0) \u2227\n      -- Additional property: coefficient vector has the correct mathematical relationship\n      -- The leading coefficient relates to the product form of the polynomial\n      (n > 0 \u2192 \n        -- For a monic polynomial in standard basis, the leading coefficient would be 1,\n        -- but in Chebyshev basis it's 2^(1-n) for n > 0\n        coeffs.get \u27e8n, by omega\u27e9 = Float.pow 2 (Float.ofNat (1 - n)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebgauss", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebgauss\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Gauss-Chebyshev quadrature.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebgauss.html\",\n  \"doc\": \"Gauss-Chebyshev quadrature.\\n\\n    Computes the sample points and weights for Gauss-Chebyshev quadrature.\\n    These sample points and weights will correctly integrate polynomials of\\n    degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with\\n    the weight function :math:`f(x) = 1/\\\\sqrt{1 - x^2}`.\\n\\n    Parameters\\n    ----------\\n    deg : int\\n        Number of sample points and weights. It must be >= 1.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        1-D ndarray containing the sample points.\\n    y : ndarray\\n        1-D ndarray containing the weights.\\n\\n    Notes\\n    -----\\n    The results have only been tested up to degree 100, higher degrees may\\n    be problematic. For Gauss-Chebyshev there are closed form solutions for\\n    the sample points and weights. If n = `deg`, then\\n\\n    .. math:: x_i = \\\\cos(\\\\pi (2 i - 1) / (2 n))\\n\\n    .. math:: w_i = \\\\pi / n\",\n}\n-/\n\n/-  Computes the sample points and weights for Gauss-Chebyshev quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*n - 1 or less over the interval [-1, 1] with the weight \n    function f(x) = 1/\u221a(1 - x\u00b2). -/\n\n/-  Specification: chebgauss returns Gauss-Chebyshev quadrature nodes and weights\n    where nodes are the zeros of the n-th Chebyshev polynomial and weights are \n    uniform \u03c0/n. The nodes are given by cos(\u03c0(2i-1)/(2n)) for i = 1 to n. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebgauss (n : Nat) (h : n > 0) : Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebgauss_spec (n : Nat) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    chebgauss n h\n    \u2983\u21d3(nodes, weights) => \u231c\n      -- Nodes are the Chebyshev-Gauss quadrature points\n      -- x_i = cos(\u03c0(2i-1)/(2n)) where i ranges from 1 to n\n      -- In Lean's 0-indexed system: x_i = cos(\u03c0(2*i.val+1)/(2n))\n      (\u2200 i : Fin n, \u2203 (theta : Float), \n        theta = (2 * i.val.toFloat + 1) / (2 * n.toFloat) \u2227\n        nodes.get i = theta.cos) \u2227\n      -- All weights are equal (uniform weights)\n      (\u2200 i j : Fin n, weights.get i = weights.get j) \u2227\n      -- Each weight equals \u03c0/n\n      (\u2203 (w : Float), \u2200 i : Fin n, weights.get i = w \u2227 w > 0) \u2227\n      -- Nodes are in descending order (cosine is decreasing)\n      (\u2200 i j : Fin n, i < j \u2192 nodes.get i > nodes.get j) \u2227\n      -- All nodes are in the open interval (-1, 1)\n      (\u2200 i : Fin n, -1 < nodes.get i \u2227 nodes.get i < 1) \u2227\n      -- Nodes are distinct\n      (\u2200 i j : Fin n, i \u2260 j \u2192 nodes.get i \u2260 nodes.get j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebgrid3d", "vc-description": "/-  Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.\n\n    This function returns the values:\n    p(a,b,c) = \u2211_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)\n\n    where the points (a, b, c) consist of all triples formed by taking\n    a from x, b from y, and c from z. The resulting points form\n    a grid with x in the first dimension, y in the second, and z in\n    the third. -/\n\n/-  Specification: chebgrid3d evaluates a 3D Chebyshev series on the Cartesian product.\n    The result at position (ix, iy, iz) is the sum over all coefficient indices (i, j, k)\n    of c[i][j][k] * T_i(x[ix]) * T_j(y[iy]) * T_k(z[iz]) where T_n is the n-th\n    Chebyshev polynomial.\n\n    Mathematical properties:\n    1. The output has the correct shape: nx \u00d7 ny \u00d7 nz\n    2. Each element is computed as a triple sum over the coefficient indices\n    3. The function evaluates the 3D Chebyshev series at each grid point\n    4. For a zero coefficient array, the result is zero everywhere\n    5. The result is linear in the coefficients\n    6. The Chebyshev polynomials T_i satisfy the recurrence relation:\n       T_0(x) = 1, T_1(x) = x, T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x)\n    7. The evaluation respects the orthogonality of Chebyshev polynomials on [-1, 1]\n    8. When all x, y, z values are in [-1, 1], the series converges uniformly\n    9. The result is the tensor product of 1D Chebyshev evaluations -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebgrid3d {nx ny nz : Nat} {ni nj nk : Nat}\n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float nk) nj) ni) :\n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry", "vc-theorems": "theorem chebgrid3d_spec {nx ny nz : Nat} {ni nj nk : Nat}\n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float nk) nj) ni)\n    (chebyshev_T : Nat \u2192 Float \u2192 Float)\n    (h_T0 : \u2200 x, chebyshev_T 0 x = 1)\n    (h_T1 : \u2200 x, chebyshev_T 1 x = x)\n    (h_Tn : \u2200 n x, n \u2265 1 \u2192 chebyshev_T (n + 1) x = 2 * x * chebyshev_T n x - chebyshev_T (n - 1) x) :\n    \u2983\u231cTrue\u231d\u2984\n    chebgrid3d x y z c\n    \u2983\u21d3result => \u231c\u2200 (ix : Fin nx) (iy : Fin ny) (iz : Fin nz),\n        \u2203 (value : Float), \n        ((result.get ix).get iy).get iz = value \u2227\n        (\u2200 (compute_sum : (Fin ni \u2192 Fin nj \u2192 Fin nk \u2192 Float) \u2192 Float),\n          (\u2200 f g, (\u2200 i j k, f i j k = g i j k) \u2192 compute_sum f = compute_sum g) \u2192\n          value = compute_sum (fun i j k => \n            ((c.get i).get j).get k * \n            chebyshev_T i.val (x.get ix) *\n            chebyshev_T j.val (y.get iy) *\n            chebyshev_T k.val (z.get iz)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebint", "vc-description": "/-  numpy.polynomial.chebyshev.chebint: Integrate a Chebyshev series.\n\n    Returns the Chebyshev series coefficients integrated m times from\n    lbnd along axis. At each iteration the resulting series is\n    multiplied by scl and an integration constant k is added.\n\n    The integration transforms Chebyshev polynomials according to the\n    recurrence relations for Chebyshev polynomial integrals. For a \n    single integration (m=1) of coefficients [c\u2080, c\u2081, ..., c\u2099], the \n    result follows the Chebyshev integration formula.\n\n    Parameters:\n    - c: Vector of Chebyshev series coefficients (low to high degree)\n    - m: Order of integration (must be positive)\n    - k: Integration constants (defaults to zeros)\n    - lbnd: Lower bound of the integral (default: 0)\n    - scl: Scaling factor applied after each integration (default: 1)\n-/\n\n/-  Specification: chebint integrates Chebyshev series coefficients m times.\n\n    The function performs m successive integrations of the Chebyshev series,\n    where each integration:\n    1. Multiplies the current coefficients by scl\n    2. Applies the Chebyshev integration recurrence relations\n    3. Adjusts the constant term to satisfy the boundary condition at lbnd\n    4. Adds the corresponding integration constant from k\n\n    Mathematical properties:\n    - The result has m more coefficients than the input (integration increases degree)\n    - For m=0, returns the original coefficients unchanged\n    - The integration follows Chebyshev polynomial recurrence relations:\n      \u222b T\u2099(x) dx = [T\u2099\u208a\u2081(x)/(2(n+1)) - T\u2099\u208b\u2081(x)/(2(n-1))] for n \u2265 2\n      \u222b T\u2081(x) dx = T\u2082(x)/4\n      \u222b T\u2080(x) dx = T\u2081(x)\n    - The constant term is adjusted so the integral equals k[i] at x=lbnd\n\n    Sanity checks:\n    - The output vector has exactly n + m coefficients\n    - When m = 0, the function should return the input unchanged\n    - Integration constants k affect only the constant term of each integration\n    - The scaling factor scl is applied before adding integration constants\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebint {n : Nat} (c : Vector Float n) (m : Nat) (k : Vector Float m) \n    (lbnd : Float) (scl : Float) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem chebint_spec {n : Nat} (c : Vector Float n) (m : Nat) (k : Vector Float m) \n    (lbnd : Float) (scl : Float) (h_m_pos : m > 0) :\n    \u2983\u231cm > 0 \u2227 scl \u2260 0\u231d\u2984\n    chebint c m k lbnd scl\n    \u2983\u21d3result => \u231c\n      -- For m=1 case, specify the integration formula\n      (m = 1 \u2192 \n        -- First coefficient (constant term) is adjusted for boundary condition\n        \u2203 adj : Float, result.get \u27e80, sorry\u27e9 = adj \u2227\n        -- T\u2080 integrates to T\u2081\n        (n \u2265 1 \u2192 result.get \u27e81, sorry\u27e9 = scl * c.get \u27e80, sorry\u27e9) \u2227\n        -- T\u2081 integrates to T\u2082/4  \n        (n \u2265 2 \u2192 result.get \u27e82, sorry\u27e9 = scl * c.get \u27e81, sorry\u27e9 / 4.0) \u2227\n        -- General recurrence: T\u2099 integrates to [T\u2099\u208a\u2081/(2(n+1)) - T\u2099\u208b\u2081/(2(n-1))]\n        (\u2200 j : Fin n, j.val \u2265 2 \u2192 \n          (j.val + 1 < n + m \u2192 \n            result.get \u27e8j.val + 1, sorry\u27e9 = scl * c.get j / (2.0 * (j.val.toFloat + 1.0))) \u2227\n          (j.val \u2265 1 \u2192 \u2203 prev_val : Float, \n            result.get \u27e8j.val - 1, sorry\u27e9 = prev_val - scl * c.get j / (2.0 * (j.val.toFloat - 1.0))))) \u2227\n      -- For general m > 1, the operation is repeated m times\n      (m > 1 \u2192 \u2203 intermediate : Vector Float (n + m - 1),\n        -- The result is obtained by integrating the intermediate result once more\n        True) \u2227  -- Simplified for now, full recurrence would be complex\n      -- Additional sanity checks\n      -- When all input coefficients are zero, output depends only on integration constants\n      ((\u2200 i : Fin n, c.get i = 0) \u2192 \n        \u2203 const_terms : Vector Float m, \n          result.get \u27e80, sorry\u27e9 = const_terms.get \u27e80, sorry\u27e9) \u2227\n      -- Scaling by zero should produce zero coefficients (except possibly constant terms)\n      (scl = 0 \u2192 \u2200 i : Fin (n + m), i.val > 0 \u2192 result.get i = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebinterpolate", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebinterpolate\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Interpolate a function at the Chebyshev points of the first kind.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebinterpolate.html\",\n  \"doc\": \"Interpolate a function at the Chebyshev points of the first kind.\\n\\n    Returns the Chebyshev series that interpolates `func` at the Chebyshev\\n    points of the first kind in the interval [-1, 1]. The interpolating\\n    series tends to a minmax approximation to `func` with increasing `deg`\\n    if the function is continuous in the interval.\\n\\n    Parameters\\n    ----------\\n    func : function\\n        The function to be approximated. It must be a function of a single\\n        variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are\\n        extra arguments passed in the `args` parameter.\\n    deg : int\\n        Degree of the interpolating polynomial\\n    args : tuple, optional\\n        Extra arguments to be used in the function call. Default is no extra\\n        arguments.\\n\\n    Returns\\n    -------\\n    coef : ndarray, shape (deg + 1,)\\n        Chebyshev coefficients of the interpolating series ordered from low to\\n        high.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.chebyshev as C\\n    >>> C.chebinterpolate(lambda x: np.tanh(x) + 0.5, 8)\\n    array([  5.00000000e-01,   8.11675684e-01,  -9.86864911e-17,\\n            -5.42457905e-02,  -2.71387850e-16,   4.51658839e-03,\\n             2.46716228e-17,  -3.79694221e-04,  -3.26899002e-16])\\n\\n    Notes\\n    -----\\n    The Chebyshev polynomials used in the interpolation are orthogonal when\\n    sampled at the Chebyshev points of the first kind. If it is desired to\\n    constrain some of the coefficients they can simply be set to the desired\\n    value after the interpolation, no new interpolation or fit is needed. This\\n    is especially useful if it is known apriori that some of coefficients are\\n    zero. For instance, if the function is even then the coefficients of the\\n    terms of odd degree in the result can be set to zero.\",\n}\n-/\n\n/-  numpy.polynomial.chebyshev.chebinterpolate: Interpolate a function at the Chebyshev points of the first kind.\n\n    Returns the Chebyshev series coefficients that interpolate the given function\n    at the Chebyshev points of the first kind in the interval [-1, 1]. The resulting\n    coefficients represent a polynomial of degree deg that interpolates the function\n    at deg+1 Chebyshev points.\n\n    The Chebyshev interpolation provides near-optimal polynomial approximation\n    for continuous functions on [-1, 1], minimizing the Runge phenomenon and\n    providing good convergence properties.\n-/\n\n/-  Specification: chebinterpolate returns Chebyshev coefficients c such that:\n    1. The coefficients form a vector of length deg + 1\n    2. When evaluated as a Chebyshev polynomial at the Chebyshev points of the\n       first kind, it exactly reproduces the function values at those points\n    3. The interpolation is exact at the Chebyshev points: for each Chebyshev\n       point x_k = cos(\u03c0 * k / deg) where k \u2208 {0, ..., deg}, the Chebyshev\n       polynomial with coefficients c evaluates to func(x_k)\n\n    Mathematical properties:\n    - The Chebyshev points of the first kind are x_k = cos(\u03c0 * k / deg) for k = 0, ..., deg\n    - The interpolation minimizes the maximum error among all polynomial interpolations\n    - For continuous functions, the interpolation converges uniformly as deg increases\n    - The coefficients are computed using the discrete cosine transform of the\n      function values at the Chebyshev points\n\n    Precondition: True (the function can be any Float \u2192 Float function)\n    Postcondition: The returned coefficients satisfy the interpolation property\n                   at all Chebyshev points of the first kind\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebinterpolate (deg : Nat) (func : Float \u2192 Float) : Id (Vector Float (deg + 1)) :=\n  sorry", "vc-theorems": "theorem chebinterpolate_spec (deg : Nat) (func : Float \u2192 Float) :\n    \u2983\u231cTrue\u231d\u2984\n    chebinterpolate deg func\n    \u2983\u21d3coef => \u231c-- The coefficients satisfy the key properties of Chebyshev interpolation:\n              -- 1. The coefficient vector has the correct length (guaranteed by type)\n              -- 2. When the function is constant, all coefficients except the first are zero\n              (\u2200 x y, func x = func y) \u2192 \n                (coef.get \u27e80, by simp\u27e9 = func 0 \u2227\n                 \u2200 i : Fin deg, coef.get \u27e8i.val + 1, by simp [Fin.is_lt]\u27e9 = 0) \u2227\n              -- 3. The interpolation is exact at the Chebyshev points\n              -- (This property is stated abstractly without computing the exact points)\n              \u2203 cheb_points : Vector Float (deg + 1),\n                -- The Chebyshev points are in [-1, 1] and ordered\n                (\u2200 i : Fin (deg + 1), -1 \u2264 cheb_points.get i \u2227 cheb_points.get i \u2264 1) \u2227\n                (\u2200 i j : Fin (deg + 1), i < j \u2192 cheb_points.get j < cheb_points.get i) \u2227\n                -- The interpolation property holds at these points\n                \u2200 k : Fin (deg + 1), \n                  \u2203 interpolated_value : Float,\n                    Float.abs (interpolated_value - func (cheb_points.get k)) < 1e-10\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebline", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebline\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Chebyshev series whose graph is a straight line.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebline.html\",\n  \"doc\": \"Chebyshev series whose graph is a straight line.\\n\\n    Parameters\\n    ----------\\n    off, scl : scalars\\n        The specified line is given by ``off + scl*x``.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        This module's representation of the Chebyshev series for\\n        ``off + scl*x``.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyline\\n    numpy.polynomial.legendre.legline\\n    numpy.polynomial.laguerre.lagline\\n    numpy.polynomial.hermite.hermline\\n    numpy.polynomial.hermite_e.hermeline\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.chebyshev as C\\n    >>> C.chebline(3,2)\\n    array([3, 2])\\n    >>> C.chebval(-3, C.chebline(3,2)) # should be -3\\n    -3.0\",\n}\n-/\n\n/-  Chebyshev series whose graph is a straight line.\n    Returns coefficients for the Chebyshev series representing off + scl*x.\n    For simplicity, we always return a 2-element vector where the second element\n    might be zero when scl = 0. -/\n\n/-  Specification: chebline returns correct Chebyshev coefficients for a linear function.\n    The key mathematical property is that the Chebyshev series T\u2080(x) = 1 and T\u2081(x) = x,\n    so the coefficients [off, scl] directly represent off*T\u2080(x) + scl*T\u2081(x) = off + scl*x.\n\n    The result is always a 2-element vector [off, scl], even when scl = 0.\n    This represents the Chebyshev series: off * T\u2080(x) + scl * T\u2081(x) = off + scl*x\n\n    Mathematical Properties:\n    1. The first coefficient equals the offset parameter\n    2. The second coefficient equals the scale parameter\n    3. When evaluated as a Chebyshev series, this produces the line off + scl*x\n    4. This is the minimal degree Chebyshev representation of a linear function -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem chebline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    chebline off scl\n    \u2983\u21d3result => \u231cresult.get \u27e80, by decide\u27e9 = off \u2227 \n                 result.get \u27e81, by decide\u27e9 = scl\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebmul", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebmul\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Multiply one Chebyshev series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebmul.html\",\n  \"doc\": \"Multiply one Chebyshev series by another.\\n\\n    Returns the product of two Chebyshev series `c1` * `c2`.  The arguments\\n    are sequences of coefficients, from lowest order \\\"term\\\" to highest,\\n    e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Chebyshev series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Chebyshev series coefficients representing their product.\\n\\n    See Also\\n    --------\\n    chebadd, chebsub, chebmulx, chebdiv, chebpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) product of two C-series results in terms\\n    that are not in the Chebyshev polynomial basis set.  Thus, to express\\n    the product as a C-series, it is typically necessary to \\\"reproject\\\"\\n    the product onto said basis set, which typically produces\\n    \\\"unintuitive live\\\" (but correct) results; see Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> C.chebmul(c1,c2) # multiplication requires \\\"reprojection\\\"\\n    array([  6.5,  12. ,  12. ,   4. ,   1.5])\",\n}\n-/\n\n/-  Multiply one Chebyshev series by another.\n\n    Returns the product of two Chebyshev series c1 * c2. The arguments\n    are sequences of coefficients, from lowest order term to highest,\n    e.g., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\n    The result length is m + n - 1 where m and n are the lengths of c1 and c2. -/\n\n/-  Specification: chebmul computes the product of two Chebyshev series.\n\n    The multiplication of Chebyshev polynomials follows the recurrence relation:\n    T_m * T_n = (T_{m+n} + T_{|m-n|}) / 2\n\n    This specification captures:\n    1. The result has the correct length (m + n - 1)\n    2. Mathematical properties of the resulting coefficients\n    3. Example verification: multiplying T_0 with any polynomial preserves coefficients\n    4. Symmetry: chebmul c1 c2 = chebmul c2 c1\n    5. Example from documentation: [1,2,3] * [3,2,1] = [6.5, 12, 12, 4, 1.5] -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebmul {m n : Nat} (c1 : Vector Float m) (c2 : Vector Float n) \n    (hm : m > 0) (hn : n > 0) : Id (Vector Float (m + n - 1)) :=\n  sorry", "vc-theorems": "theorem chebmul_spec {m n : Nat} (c1 : Vector Float m) (c2 : Vector Float n) \n    (hm : m > 0) (hn : n > 0) :\n    \u2983\u231cm > 0 \u2227 n > 0\u231d\u2984\n    chebmul c1 c2 hm hn\n    \u2983\u21d3result => \u231c-- The result vector has the correct length\n                result.toList.length = m + n - 1 \u2227\n                -- Example property: multiplying by the constant polynomial [a] scales all coefficients\n                (\u2200 a : Float, n = 1 \u2192 c2.get \u27e80, sorry\u27e9 = a \u2192 \n                  \u2200 i : Fin m, result.get \u27e8i.val, sorry\u27e9 = a * c1.get i) \u2227\n                -- Another example: multiplying [1,0,...] (T_0) by any polynomial preserves it\n                (m = 1 \u2192 c1.get \u27e80, sorry\u27e9 = 1 \u2192 \n                  \u2200 j : Fin n, result.get \u27e8j.val, sorry\u27e9 = c2.get j) \u2227\n                -- Special case: multiplying two linear polynomials [a,b] * [c,d]\n                -- Result should be [ac + bd/2, ad + bc, bd/2]\n                (m = 2 \u2227 n = 2 \u2192 \n                  let a := c1.get \u27e80, sorry\u27e9\n                  let b := c1.get \u27e81, sorry\u27e9\n                  let c := c2.get \u27e80, sorry\u27e9\n                  let d := c2.get \u27e81, sorry\u27e9\n                  result.get \u27e80, sorry\u27e9 = a * c + b * d / 2 \u2227\n                  result.get \u27e81, sorry\u27e9 = a * d + b * c \u2227\n                  result.get \u27e82, sorry\u27e9 = b * d / 2) \u2227\n                -- Verify the example from documentation: [1,2,3] * [3,2,1]\n                (m = 3 \u2227 n = 3 \u2192 \n                  c1.get \u27e80, sorry\u27e9 = 1 \u2227 c1.get \u27e81, sorry\u27e9 = 2 \u2227 c1.get \u27e82, sorry\u27e9 = 3 \u2192\n                  c2.get \u27e80, sorry\u27e9 = 3 \u2227 c2.get \u27e81, sorry\u27e9 = 2 \u2227 c2.get \u27e82, sorry\u27e9 = 1 \u2192\n                  result.get \u27e80, sorry\u27e9 = 6.5 \u2227\n                  result.get \u27e81, sorry\u27e9 = 12 \u2227\n                  result.get \u27e82, sorry\u27e9 = 12 \u2227\n                  result.get \u27e83, sorry\u27e9 = 4 \u2227\n                  result.get \u27e84, sorry\u27e9 = 1.5)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebmulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebmulx\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Multiply a Chebyshev series by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebmulx.html\",\n  \"doc\": \"Multiply a Chebyshev series by x.\\n\\n    Multiply the polynomial \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Chebyshev series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    chebadd, chebsub, chebmul, chebdiv, chebpow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> C.chebmulx([1,2,3])\\n    array([1. , 2.5, 1. , 1.5])\",\n}\n-/\n\n/-  Multiply a Chebyshev series by x.\n    This function multiplies a Chebyshev polynomial represented by its coefficients by x.\n    The operation is based on the recurrence relation:\n    - xT\u2080(x) = T\u2081(x)\n    - xT\u2099(x) = (T\u2099\u208a\u2081(x) + T\u2099\u208b\u2081(x))/2 for n \u2265 1 -/\n\n/-  Specification: chebmulx correctly multiplies a Chebyshev polynomial by x.\n\n    Given coefficients c = [c\u2080, c\u2081, ..., c\u2099\u208b\u2081] representing the polynomial\n    P(x) = c\u2080T\u2080(x) + c\u2081T\u2081(x) + ... + c\u2099\u208b\u2081T\u2099\u208b\u2081(x),\n    this function computes coefficients for xP(x).\n\n    The implementation follows from the Chebyshev recurrence relations:\n    - xT\u2080(x) = T\u2081(x)\n    - xT\u2099(x) = (T\u2099\u208a\u2081(x) + T\u2099\u208b\u2081(x))/2 for n \u2265 1\n\n    The algorithm redistributes coefficients according to these relations,\n    resulting in a polynomial with degree increased by 1. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebmulx {n : Nat} (c : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem chebmulx_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    chebmulx c\n    \u2983\u21d3result => \u231c\n      -- Sanity check: output size is input size + 1\n      result.size = n + 1 \u2227\n      -- Mathematical property: The operation follows Chebyshev recurrence\n      -- For each T\u1d62 in the input, multiplication by x produces contributions\n      -- to neighboring terms according to the recurrence relations\n      (\u2200 i : Fin n,\n        -- Each input coefficient c[i] contributes to the output as follows:\n        -- c[0] contributes c[0] to result[1] (since xT\u2080 = T\u2081)\n        -- c[i] for i>0 contributes c[i]/2 to both result[i-1] and result[i+1]\n        -- This captures the essence of xT\u2099 = (T\u2099\u208a\u2081 + T\u2099\u208b\u2081)/2\n        True) \u2227\n      -- Linearity property: chebmulx is a linear operation\n      (\u2200 \u03b1 \u03b2 : Float, \u2200 c1 c2 : Vector Float n,\n        let linear_comb := Vector.ofFn (fun i : Fin n => \u03b1 * c1.get i + \u03b2 * c2.get i)\n        let result1 := chebmulx c1\n        let result2 := chebmulx c2\n        let result_comb := chebmulx linear_comb\n        \u2200 j : Fin (n + 1), \n          result_comb.get j = \u03b1 * result1.get j + \u03b2 * result2.get j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebpow", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebpow\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Raise a Chebyshev series to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebpow.html\",\n  \"doc\": \"Raise a Chebyshev series to a power.\\n\\n    Returns the Chebyshev series `c` raised to the power `pow`. The\\n    argument `c` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Chebyshev series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Chebyshev series of power.\\n\\n    See Also\\n    --------\\n    chebadd, chebsub, chebmulx, chebmul, chebdiv\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> C.chebpow([1, 2, 3, 4], 2)\\n    array([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])\",\n}\n-/\n\n/-  Raise a Chebyshev series to a power.\n\n    Returns the Chebyshev series c raised to the power pow. The\n    argument c is a sequence of coefficients ordered from low to high,\n    i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\n    The power must be a non-negative integer. Special cases:\n    - pow = 0 returns [1] (the constant polynomial 1)\n    - pow = 1 returns the input series unchanged\n    - pow > 1 returns the series multiplied by itself pow times\n\n    The result length grows as: 1 + (n - 1) * pow, where n is the input length. -/\n\n/-  Specification: chebpow computes the power of a Chebyshev series.\n\n    This specification captures:\n    1. Special cases for pow = 0 and pow = 1\n    2. The mathematical property that (T(x))^pow represents the polynomial T(x) raised to power pow\n    3. The result is a valid Chebyshev series representation\n\n    Key properties:\n    - pow = 0: Returns [1], representing the constant polynomial 1\n    - pow = 1: Returns the input unchanged\n    - pow > 1: Returns coefficients such that if c represents T(x), result represents (T(x))^pow\n\n    The specification ensures:\n    - Correct handling of the constant term (T_0 coefficient)\n    - Proper coefficient computation through repeated Chebyshev multiplication\n    - Result represents the mathematical power of the input polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebpow {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat := 16) \n    (h_nonzero : n > 0) (h_maxpower : pow \u2264 maxpower) : \n    Id (Vector Float (if pow = 0 then 1 else 1 + (n - 1) * pow)) :=\n  sorry", "vc-theorems": "theorem chebpow_spec {n : Nat} (c : Vector Float n) (pow : Nat) \n    (maxpower : Nat := 16) (h_nonzero : n > 0) (h_maxpower : pow \u2264 maxpower) :\n    \u2983\u231cn > 0 \u2227 pow \u2264 maxpower\u231d\u2984\n    chebpow c pow maxpower h_nonzero h_maxpower\n    \u2983\u21d3result => \u231c-- Special case: pow = 0\n                -- Returns a vector containing only 1.0\n                (pow = 0 \u2192 result.toList = [1.0]) \u2227\n                -- Special case: pow = 1 \n                -- Returns the input unchanged (but with correct type)\n                (pow = 1 \u2192 n = 1 + (n - 1) * 1 \u2227 \n                  \u2200 i : Fin n, result.get \u27e8i.val, sorry\u27e9 = c.get i) \u2227\n                -- Sanity check: result length is correct\n                (result.toList.length = if pow = 0 then 1 else 1 + (n - 1) * pow) \u2227\n                -- General mathematical property for pow > 1\n                (pow > 1 \u2192 \n                  -- The result coefficients are bounded\n                  -- First coefficient (constant term) check\n                  (n \u2265 1 \u2192 \u2203 (v : Float), result.get \u27e80, sorry\u27e9 = v \u2227 v \u2260 0) \u2227\n                  -- All coefficients are finite\n                  (\u2200 i : Nat, i < result.toList.length \u2192 \n                    \u2203 (coeff : Float), result.get \u27e8i, sorry\u27e9 = coeff \u2227 \n                      Float.isFinite coeff)) \u2227\n                -- Additional property: non-triviality for pow \u2265 2\n                (pow \u2265 2 \u2227 n \u2265 2 \u2192 \n                  -- At least one coefficient beyond the first two is non-zero\n                  \u2203 k : Nat, k \u2265 2 \u2227 k < result.toList.length \u2227 \n                    result.get \u27e8k, sorry\u27e9 \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebpts1", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebpts1\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Chebyshev points of the first kind.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebpts1.html\",\n  \"doc\": \"Chebyshev points of the first kind.\\n\\n    The Chebyshev points of the first kind are the points ``cos(x)``,\\n    where ``x = [pi*(k + .5)/npts for k in range(npts)]``.\\n\\n    Parameters\\n    ----------\\n    npts : int\\n        Number of sample points desired.\\n\\n    Returns\\n    -------\\n    pts : ndarray\\n        The Chebyshev points of the first kind.\\n\\n    See Also\\n    --------\\n    chebpts2\",\n}\n-/\n\n/-  numpy.polynomial.chebyshev.chebpts1: Chebyshev points of the first kind.\n\n    The Chebyshev points of the first kind are the points cos(\u03c0*(k + 0.5)/n)\n    for k in range(n), which are the roots of the Chebyshev polynomial T_n(x).\n    These points are particularly useful for polynomial interpolation as they\n    minimize the Runge phenomenon.\n\n    The implementation uses the identity sin(x) = cos(\u03c0/2 - x) to compute\n    the values using sine instead of cosine.\n-/\n\n/-  Specification: chebpts1 returns a vector of n Chebyshev points of the first kind.\n\n    The k-th point (0-indexed) is cos(\u03c0*(k + 0.5)/n), which equals\n    sin(\u03c0*(n - k - 0.5)/n) by the complementary angle identity.\n\n    Precondition: n > 0 (at least one point must be generated)\n    Postcondition: \n    1. For all indices k, result[k] = cos(\u03c0*(k + 0.5)/n)\n    2. The points are in descending order: for all i < j, result[i] > result[j]\n    3. All points lie in the interval [-1, 1]\n    4. The points are symmetric about 0: result[k] = -result[n-1-k] for all k\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebpts1 (n : Nat) (h : n > 0) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebpts1_spec (n : Nat) (h : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    chebpts1 n h\n    \u2983\u21d3result => \u231c(\u2200 k : Fin n, \n                  result.get k = Float.cos (3.141592653589793 * (k.val.toFloat + 0.5) / n.toFloat)) \u2227\n                 (\u2200 i j : Fin n, i < j \u2192 result.get i > result.get j) \u2227\n                 (\u2200 k : Fin n, -1 \u2264 result.get k \u2227 result.get k \u2264 1) \u2227\n                 (\u2200 k : Fin n, k.val + 1 \u2264 n \u2192 \n                  result.get k = -result.get \u27e8n - 1 - k.val, sorry\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebpts2", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebpts2\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Chebyshev points of the second kind.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebpts2.html\",\n  \"doc\": \"Chebyshev points of the second kind.\\n\\n    The Chebyshev points of the second kind are the points ``cos(x)``,\\n    where ``x = [pi*k/(npts - 1) for k in range(npts)]`` sorted in ascending\\n    order.\\n\\n    Parameters\\n    ----------\\n    npts : int\\n        Number of sample points desired.\\n\\n    Returns\\n    -------\\n    pts : ndarray\\n        The Chebyshev points of the second kind.\",\n}\n-/\n\n/-  Chebyshev points of the second kind.\n\n    Generates n Chebyshev points of the second kind, which are the values\n    cos(\u03c0*k/(n-1)) for k from 0 to n-1, sorted in ascending order.\n    These points are the extrema and endpoints of the Chebyshev polynomial T_{n-1}. -/\n\n/-  Specification: chebpts2 generates Chebyshev points of the second kind\n\n    The function returns n points where:\n    1. Each point is cos(\u03c0*k/(n-1)) for k from n-1 down to 0\n    2. The points are sorted in ascending order\n    3. The first point is -1 and the last point is 1\n    4. The points are symmetric around 0 for the transformation x \u21a6 -x -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebpts2 (n : Nat) (h : n \u2265 2) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebpts2_spec (n : Nat) (h : n \u2265 2) :\n    \u2983\u231cn \u2265 2\u231d\u2984\n    chebpts2 n h\n    \u2983\u21d3pts => \u231c-- Points are sorted in ascending order\n              (\u2200 i j : Fin n, i < j \u2192 pts.get i \u2264 pts.get j) \u2227\n              -- First point is -1 (cos(\u03c0))\n              pts.get \u27e80, Nat.zero_lt_of_lt h\u27e9 = -1 \u2227\n              -- Last point is 1 (cos(0))\n              pts.get \u27e8n - 1, Nat.sub_lt (Nat.zero_lt_of_lt h) Nat.zero_lt_one\u27e9 = 1 \u2227\n              -- All points are in the range [-1, 1]\n              (\u2200 i : Fin n, -1 \u2264 pts.get i \u2227 pts.get i \u2264 1) \u2227\n              -- Points are distinct (strict monotonicity)\n              (\u2200 i j : Fin n, i < j \u2192 pts.get i < pts.get j) \u2227\n              -- For n = 2, we have exactly {-1, 1}\n              (n = 2 \u2192 pts.get \u27e80, sorry\u27e9 = -1 \u2227 pts.get \u27e81, sorry\u27e9 = 1) \u2227\n              -- For n = 3, the middle point is 0\n              (n = 3 \u2192 pts.get \u27e81, sorry\u27e9 = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebsub", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebsub\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Subtract one Chebyshev series from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebsub.html\",\n  \"doc\": \"Subtract one Chebyshev series from another.\\n\\n    Returns the difference of two Chebyshev series `c1` - `c2`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Chebyshev series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Chebyshev series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    chebadd, chebmulx, chebmul, chebdiv, chebpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Chebyshev\\n    series is a Chebyshev series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import chebyshev as C\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> C.chebsub(c1,c2)\\n    array([-2.,  0.,  2.])\\n    >>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)\\n    array([ 2.,  0., -2.])\",\n}\n-/\n\n/-  Subtract one Chebyshev series from another component-wise.\n    The input vectors c1 and c2 represent Chebyshev series coefficients\n    ordered from lowest to highest degree term. -/\n\n/-  Specification: chebsub performs component-wise subtraction of two Chebyshev series.\n\n    The specification includes:\n    1. The basic property that each coefficient in the result is the difference\n       of the corresponding coefficients in c1 and c2\n    2. Anti-commutativity: chebsub(c1, c2) = -chebsub(c2, c1)\n    3. Identity property: subtracting a series from itself yields zero\n    4. Associativity with addition: (c1 - c2) + c2 = c1 -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebsub {n : Nat} (c1 c2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebsub_spec {n : Nat} (c1 c2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    chebsub c1 c2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, result.get i = c1.get i - c2.get i) \u2227\n                 (\u2200 i : Fin n, (chebsub c2 c1).get i = -(result.get i)) \u2227\n                 (\u2200 i : Fin n, (chebsub c1 c1).get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebvander", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebvander\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Pseudo-Vandermonde matrix of given degree.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebvander.html\",\n  \"doc\": \"Pseudo-Vandermonde matrix of given degree.\\n\\n    Returns the pseudo-Vandermonde matrix of degree \\`deg\\` and sample points\\n    \\`x\\`. The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., i] = T_i(x),\\n\\n    where \\`\\`0 <= i <= deg\\`\\`. The leading indices of \\`V\\` index the elements of\\n    \\`x\\` and the last index is the degree of the Chebyshev polynomial.\\n\\n    If \\`c\\` is a 1-D array of coefficients of length \\`\\`n + 1\\`\\` and \\`V\\` is the\\n    matrix \\`\\`V = chebvander(x, n)\\`\\`, then \\`\\`np.dot(V, c)\\`\\` and\\n    \\`\\`chebval(x, c)\\`\\` are the same up to roundoff.  This equivalence is\\n    useful both for least squares fitting and for the evaluation of a large\\n    number of Chebyshev series of the same degree and sample points.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        Array of points. The dtype is converted to float64 or complex128\\n        depending on whether any of the elements are complex. If \\`x\\` is\\n        scalar it is converted to a 1-D array.\\n    deg : int\\n        Degree of the resulting matrix.\\n\\n    Returns\\n    -------\\n    vander : ndarray\\n        The pseudo Vandermonde matrix. The shape of the returned matrix is\\n        \\`\\`x.shape + (deg + 1,)\\`\\`, where The last index is the degree of the\\n        corresponding Chebyshev polynomial.  The dtype will be the same as\\n        the converted \\`x\\`.\",\n}\n-/\n\n/-  Pseudo-Vandermonde matrix of Chebyshev polynomials of given degree.\n\n    Given a vector of sample points `x` and a degree `deg`, returns a matrix\n    where each row corresponds to a sample point and each column contains\n    the values of Chebyshev polynomials T_0, T_1, ..., T_deg evaluated at\n    that point. -/\n\n/-  Specification: chebvander produces a matrix where entry (i,j) is the j-th Chebyshev \n    polynomial T_j evaluated at x[i], following the recurrence relation:\n    T_0(x) = 1, T_1(x) = x, T_{k+1}(x) = 2x*T_k(x) - T_{k-1}(x) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebvander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry", "vc-theorems": "theorem chebvander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    chebvander x deg\n    \u2983\u21d3V => \u231c-- T_0(x) = 1 for all x\n            (\u2200 i : Fin n, (V.get i).get \u27e80, sorry\u27e9 = 1) \u2227\n            -- T_1(x) = x when deg \u2265 1\n            (deg \u2265 1 \u2192 \u2200 i : Fin n, (V.get i).get \u27e81, sorry\u27e9 = x.get i) \u2227\n            -- Recurrence relation: T_{k+1}(x) = 2x*T_k(x) - T_{k-1}(x) for k \u2265 1\n            (\u2200 k : Nat, 1 \u2264 k \u2227 k < deg \u2192 \n              \u2200 i : Fin n, \n                (V.get i).get \u27e8k + 1, sorry\u27e9 = \n                  2 * (x.get i) * (V.get i).get \u27e8k, sorry\u27e9 - \n                  (V.get i).get \u27e8k - 1, sorry\u27e9) \u2227\n            -- Mathematical property: Chebyshev polynomials are bounded by 1 on [-1,1]\n            (\u2200 i : Fin n, -1 \u2264 x.get i \u2227 x.get i \u2264 1 \u2192 \n              \u2200 j : Fin (deg + 1), -1 \u2264 (V.get i).get j \u2227 (V.get i).get j \u2264 1) \u2227\n            -- Symmetry property: T_n(-x) = (-1)^n * T_n(x)\n            (\u2200 i j : Fin n, x.get i = -(x.get j) \u2192 \n              \u2200 k : Fin (deg + 1), \n                (V.get i).get k = (if k.val % 2 = 0 then 1 else -1) * (V.get j).get k)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_chebweight", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.chebweight\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"The weight function of the Chebyshev polynomials.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebweight.html\",\n  \"doc\": \"The weight function of the Chebyshev polynomials.\\n\\n    The weight function is :math:`1/\\\\sqrt{1 - x^2}` and the interval of\\n    integration is :math:`[-1, 1]`. The Chebyshev polynomials are\\n    orthogonal, but not normalized, with respect to this weight function.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n       Values at which the weight function will be computed.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n       The weight function at `x`.\",\n}\n-/\n\n/-  The weight function of the Chebyshev polynomials.\n    Computes 1/sqrt(1 - x\u00b2) for each element. -/\n\n/-  Specification: chebweight computes the Chebyshev weight function 1/sqrt(1 - x\u00b2).\n    The function is well-defined when all elements are in the open interval (-1, 1).\n\n    Mathematical properties:\n    1. The weight function equals 1/sqrt(1 - x\u00b2) for each element\n    2. The result is always positive for valid inputs\n    3. The function is symmetric: w(-x) = w(x)\n    4. The function approaches infinity as x approaches \u00b11\n    5. The implementation uses the factored form 1/(sqrt(1+x) * sqrt(1-x)) for numerical stability -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def chebweight {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem chebweight_spec {n : Nat} (x : Vector Float n)\n    (h_valid : \u2200 i : Fin n, -1 < x.get i \u2227 x.get i < 1) :\n    \u2983\u231c\u2200 i : Fin n, -1 < x.get i \u2227 x.get i < 1\u231d\u2984\n    chebweight x\n    \u2983\u21d3w => \u231c-- Primary mathematical formula\n            (\u2200 i : Fin n, w.get i = 1 / Float.sqrt (1 - (x.get i)^2)) \u2227\n            -- Sanity check: result is always positive\n            (\u2200 i : Fin n, w.get i > 0) \u2227\n            -- Symmetry property: w(-x) = w(x)\n            (\u2200 i j : Fin n, x.get i = -(x.get j) \u2192 w.get i = w.get j) \u2227\n            -- Numerical stability: the implementation should use factored form\n            (\u2200 i : Fin n, w.get i = 1 / (Float.sqrt (1 + x.get i) * Float.sqrt (1 - x.get i)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_chebyshev_poly2cheb", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.chebyshev.poly2cheb\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Convert a polynomial to a Chebyshev series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.poly2cheb.html\",\n  \"doc\": \"Convert a polynomial to a Chebyshev series.\\n\\n    Convert an array representing the coefficients of a polynomial (relative\\n    to the \\\"standard\\\" basis) ordered from lowest degree to highest, to an\\n    array of the coefficients of the equivalent Chebyshev series, ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    pol : array_like\\n        1-D array containing the polynomial coefficients\\n\\n    Returns\\n    -------\\n    c : ndarray\\n        1-D array containing the coefficients of the equivalent Chebyshev\\n        series.\\n\\n    See Also\\n    --------\\n    cheb2poly\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy import polynomial as P\\n    >>> p = P.Polynomial(range(4))\\n    >>> p\\n    Polynomial([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')\\n    >>> c = p.convert(kind=P.Chebyshev)\\n    >>> c\\n    Chebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1., ...\\n    >>> P.chebyshev.poly2cheb(range(4))\\n    array([1.  , 3.25, 1.  , 0.75])\",\n}\n-/\n\n/-  Convert a polynomial to a Chebyshev series.\n\n    This function converts coefficients of a polynomial in the standard monomial basis\n    (1, x, x\u00b2, x\u00b3, ...) to coefficients in the Chebyshev polynomial basis\n    (T\u2080(x), T\u2081(x), T\u2082(x), T\u2083(x), ...).\n\n    The input polynomial coefficients are ordered from lowest degree to highest:\n    pol = [a\u2080, a\u2081, a\u2082, ..., a\u2099] represents the polynomial a\u2080 + a\u2081x + a\u2082x\u00b2 + ... + a\u2099x\u207f\n\n    The output Chebyshev coefficients are also ordered from lowest to highest degree:\n    result = [c\u2080, c\u2081, c\u2082, ..., c\u2099] represents c\u2080T\u2080(x) + c\u2081T\u2081(x) + c\u2082T\u2082(x) + ... + c\u2099T\u2099(x) -/\n\n/-  Specification: poly2cheb correctly converts polynomial coefficients to Chebyshev series coefficients.\n\n    The conversion preserves the polynomial function - that is, the polynomial represented\n    in the standard basis and the polynomial represented in the Chebyshev basis evaluate\n    to the same value for all x in the domain [-1, 1].\n\n    Mathematical Properties:\n    1. The conversion is linear: poly2cheb(\u03b1p + \u03b2q) = \u03b1\u00b7poly2cheb(p) + \u03b2\u00b7poly2cheb(q)\n    2. The conversion preserves polynomial degree\n    3. For the monomial x\u207f, the conversion yields specific Chebyshev coefficients\n       based on the expansion of x\u207f in terms of Chebyshev polynomials\n\n    Implementation follows Horner's method in reverse:\n    - Start with the highest degree coefficient\n    - Multiply the accumulator by x (using chebmulx)\n    - Add the next coefficient (using chebadd)\n    - Repeat until all coefficients are processed\n\n    Example conversions:\n    - [1, 0, 0, 0] (constant 1) \u2192 [1, 0, 0, 0] (T\u2080(x) = 1)\n    - [0, 1, 0, 0] (x) \u2192 [0, 1, 0, 0] (T\u2081(x) = x)\n    - [0, 0, 1, 0] (x\u00b2) \u2192 [0.5, 0, 0.5, 0] (x\u00b2 = 0.5T\u2080(x) + 0.5T\u2082(x))\n    - [0, 1, 2, 3] \u2192 [1, 3.25, 1, 0.75] (from the documentation example) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def poly2cheb {n : Nat} (pol : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem poly2cheb_spec {n : Nat} (pol : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    poly2cheb pol\n    \u2983\u21d3result => \u231c\n      -- Sanity check: output has same size as input\n      result.size = n \u2227\n      -- Correctness property: Specific test cases match expected outputs\n      -- Example from documentation: [0, 1, 2, 3] \u2192 [1, 3.25, 1, 0.75]\n      (n = 4 \u2192 pol.get \u27e80, sorry\u27e9 = 0 \u2227 pol.get \u27e81, sorry\u27e9 = 1 \u2227 \n               pol.get \u27e82, sorry\u27e9 = 2 \u2227 pol.get \u27e83, sorry\u27e9 = 3 \u2192 \n        result.get \u27e80, sorry\u27e9 = 1 \u2227 result.get \u27e81, sorry\u27e9 = 3.25 \u2227 \n        result.get \u27e82, sorry\u27e9 = 1 \u2227 result.get \u27e83, sorry\u27e9 = 0.75) \u2227\n      -- Identity property: Converting constant polynomial [c, 0, ..., 0] yields [c, 0, ..., 0]\n      (\u2200 c : Float, n > 0 \u2192 (\u2200 i : Fin n, i.val > 0 \u2192 pol.get i = 0) \u2227 pol.get \u27e80, sorry\u27e9 = c \u2192\n        (\u2200 i : Fin n, i.val > 0 \u2192 result.get i = 0) \u2227 result.get \u27e80, sorry\u27e9 = c) \u2227\n      -- Linear polynomial property: [a, b, 0, ..., 0] preserves first two coefficients\n      (n > 1 \u2192 (\u2200 i : Fin n, i.val > 1 \u2192 pol.get i = 0) \u2192\n        result.get \u27e80, sorry\u27e9 = pol.get \u27e80, sorry\u27e9 \u2227 \n        result.get \u27e81, sorry\u27e9 = pol.get \u27e81, sorry\u27e9) \u2227\n      -- Mathematical property: Conversion is valid for polynomials up to degree n-1\n      -- The algorithm uses Horner's method starting from highest degree coefficient\n      -- Using recursive application of chebmulx and chebadd operations\n      (n > 0 \u2192 \n        -- For quadratic polynomial x\u00b2: [0, 0, 1] \u2192 [0.5, 0, 0.5]\n        (n = 3 \u2227 pol.get \u27e80, sorry\u27e9 = 0 \u2227 pol.get \u27e81, sorry\u27e9 = 0 \u2227 pol.get \u27e82, sorry\u27e9 = 1 \u2192\n          result.get \u27e80, sorry\u27e9 = 0.5 \u2227 result.get \u27e81, sorry\u27e9 = 0 \u2227 result.get \u27e82, sorry\u27e9 = 0.5) \u2227\n        -- For cubic polynomial x\u00b3: [0, 0, 0, 1] \u2192 [0, 0.75, 0, 0.25]  \n        (n = 4 \u2227 pol.get \u27e80, sorry\u27e9 = 0 \u2227 pol.get \u27e81, sorry\u27e9 = 0 \u2227 \n         pol.get \u27e82, sorry\u27e9 = 0 \u2227 pol.get \u27e83, sorry\u27e9 = 1 \u2192\n          result.get \u27e80, sorry\u27e9 = 0 \u2227 result.get \u27e81, sorry\u27e9 = 0.75 \u2227 \n          result.get \u27e82, sorry\u27e9 = 0 \u2227 result.get \u27e83, sorry\u27e9 = 0.25))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_Hermite", "vc-description": "/-  Evaluates a Hermite polynomial at a given point.\n    Given coefficients (c\u2080, c\u2081, ..., c\u2099), evaluates \u2211\u1d62 c\u1d62 * H\u1d62(x)\n    where H\u1d62 is the i-th Hermite polynomial.\n\n    The Hermite polynomials satisfy the recurrence:\n    H\u2080(x) = 1\n    H\u2081(x) = 2x\n    H\u2099\u208a\u2081(x) = 2x * H\u2099(x) - 2n * H\u2099\u208b\u2081(x)\n-/\n\n/-  Specification: hermiteEval correctly evaluates the Hermite polynomial series.\n\n    Mathematical properties:\n    1. Empty coefficient vector evaluates to 0\n    2. Single coefficient [c] evaluates to c * H\u2080(x) = c * 1 = c\n    3. Two coefficients [a, b] evaluates to a + b * 2x\n    4. The evaluation follows the Hermite polynomial recurrence relation\n    5. Hermite polynomials form an orthogonal basis\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermiteEval {n : Nat} (coef : Vector Float n) (x : Float) : Id Float :=\n  sorry", "vc-theorems": "theorem hermiteEval_spec {n : Nat} (coef : Vector Float n) (x : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    hermiteEval coef x\n    \u2983\u21d3result => \u231c-- Base cases for small n\n                 (n = 0 \u2192 result = 0) \u2227\n                 (n = 1 \u2192 result = coef.get \u27e80, sorry\u27e9) \u2227\n                 (n = 2 \u2192 result = coef.get \u27e80, sorry\u27e9 + coef.get \u27e81, sorry\u27e9 * 2 * x) \u2227\n                 -- General case: result is the sum of coefficients times Hermite polynomials\n                 (\u2203 H : Nat \u2192 Float,\n                   -- Hermite polynomial recurrence relation\n                   H 0 = 1 \u2227\n                   H 1 = 2 * x \u2227\n                   (\u2200 k : Nat, k + 2 < n \u2192 H (k + 2) = 2 * x * H (k + 1) - 2 * Float.ofNat (k + 1) * H k) \u2227\n                   -- Result is the weighted sum\n                   result = List.sum (List.map (fun i : Fin n => coef.get i * H i.val) (List.finRange n))) \u2227\n                 -- Additional mathematical properties\n                 -- Symmetry property: H_n(-x) = (-1)^n * H_n(x)\n                 (\u2200 H : Nat \u2192 Float,\n                   (H 0 = 1 \u2227 H 1 = 2 * x \u2227\n                    (\u2200 k : Nat, H (k + 2) = 2 * x * H (k + 1) - 2 * Float.ofNat (k + 1) * H k)) \u2192\n                   (\u2200 k : Nat, k < n \u2192 \n                     \u2203 H_neg : Nat \u2192 Float,\n                       (H_neg 0 = 1 \u2227 H_neg 1 = 2 * (-x) \u2227\n                        (\u2200 j : Nat, H_neg (j + 2) = 2 * (-x) * H_neg (j + 1) - 2 * Float.ofNat (j + 1) * H_neg j)) \u2227\n                       H_neg k = (if k % 2 = 0 then 1 else -1) * H k))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_HermiteE", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.HermiteE\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"An HermiteE series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.HermiteE.html\",\n  \"doc\": \"An HermiteE series class.\\n\\n    The HermiteE class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        HermiteE coefficients in order of increasing degree, i.e,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*He_0(x) + 2*He_1(X) + 3*He_2(x)\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n-/\n\n/-  Create a HermiteE polynomial from coefficients with default domain and window [-1, 1] -/\n\n/-  Specification: Creating a HermiteE polynomial preserves coefficients and establishes mathematical properties.\n\n    HermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\n    Key mathematical properties:\n    1. He\u2080(x) = 1, He\u2081(x) = x\n    2. Recurrence: He\u2099\u208a\u2081(x) = x * He\u2099(x) - n * He\u2099\u208b\u2081(x)\n    3. Parity: He_n(-x) = (-1)^n He_n(x)\n    4. Orthogonality with respect to Gaussian weight e^(-x\u00b2/2)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a HermiteE polynomial with coefficients and domain/window mapping.\n    HermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\n    They satisfy the recurrence relation:\n    He\u2080(x) = 1\n    He\u2081(x) = x  \n    He\u2099\u208a\u2081(x) = x * He\u2099(x) - n * He\u2099\u208b\u2081(x)\n\n    The coefficients represent the expansion: \u2211\u1d62 c\u1d62 * He\u1d62(x)\n-/\nstructure HermiteEPoly (n : Nat) where\n  /-- Coefficients of the HermiteE polynomial in increasing degree order -/\n  coef : Vector Float n\n  /-- Domain interval [domain_min, domain_max] -/\n  domain_min : Float := -1.0\n  /-- Domain interval upper bound -/\n  domain_max : Float := 1.0\n  /-- Window interval [window_min, window_max] -/\n  window_min : Float := -1.0\n  /-- Window interval upper bound -/\n  window_max : Float := 1.0", "vc-helpers": "", "vc-definitions": "def hermiteE {n : Nat} (coef : Vector Float n) : Id (HermiteEPoly n) :=\n  sorry", "vc-theorems": "theorem hermiteE_spec {n : Nat} (coef : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermiteE coef\n    \u2983\u21d3result => \u231c-- Coefficients are preserved exactly\n                 (\u2200 i : Fin n, result.coef.get i = coef.get i) \u2227\n                 -- Default domain is [-1, 1]\n                 result.domain_min = -1.0 \u2227\n                 result.domain_max = 1.0 \u2227\n                 -- Default window is [-1, 1]\n                 result.window_min = -1.0 \u2227\n                 result.window_max = 1.0 \u2227\n                 -- Domain and window intervals are valid\n                 result.domain_min < result.domain_max \u2227\n                 result.window_min < result.window_max \u2227\n                 -- Mathematical soundness: polynomial can be evaluated\n                 (\u2203 hermite_basis : Nat \u2192 Float \u2192 Float,\n                   -- Base cases for HermiteE polynomials\n                   (\u2200 x : Float, hermite_basis 0 x = 1) \u2227\n                   (n > 0 \u2192 \u2200 x : Float, hermite_basis 1 x = x) \u2227\n                   -- Recurrence relation for higher order polynomials\n                   (\u2200 k : Nat, k + 1 < n \u2192 \u2200 x : Float, \n                     hermite_basis (k + 2) x = x * hermite_basis (k + 1) x - Float.ofNat (k + 1) * hermite_basis k x) \u2227\n                   -- Parity property: He_n(-x) = (-1)^n He_n(x)\n                   (\u2200 k : Nat, k < n \u2192 \u2200 x : Float,\n                     hermite_basis k (-x) = (if k % 2 = 0 then 1 else -1) * hermite_basis k x))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeadd", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeadd\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Add one Hermite series to another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeadd.html\",\n  \"doc\": \"Add one Hermite series to another.\\n\\n    Returns the sum of two Hermite series \\`c1\\` + \\`c2\\`.  The arguments\\n    are sequences of coefficients ordered from lowest order term to\\n    highest, i.e., [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the Hermite series of their sum.\\n\\n    See Also\\n    --------\\n    hermesub, hermemulx, hermemul, hermediv, hermepow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the sum of two Hermite series\\n    is a Hermite series (without having to \\\"reproject\\\" the result onto\\n    the basis set) so addition, just like that of \\\"standard\\\" polynomials,\\n    is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeadd\\n    >>> hermeadd([1, 2, 3], [1, 2, 3, 4])\\n    array([2.,  4.,  6.,  4.])\",\n}\n-/\n\n/-  Add one Hermite series to another. Component-wise addition of polynomial coefficients. -/\n\n/-  Specification: hermeadd performs component-wise addition of Hermite polynomial coefficients.\n    The result has the length of the longer input vector. Elements are added where both vectors\n    have coefficients, and remaining coefficients from the longer vector are preserved.\n\n    This models the mathematical property that polynomial addition is component-wise:\n    (a\u2080 + a\u2081x + a\u2082x\u00b2 + ...) + (b\u2080 + b\u2081x + b\u2082x\u00b2 + ...) = (a\u2080+b\u2080) + (a\u2081+b\u2081)x + (a\u2082+b\u2082)x\u00b2 + ...\n\n    Additional mathematical properties:\n    - Commutativity: hermeadd c1 c2 = hermeadd c2 c1\n    - Associativity: hermeadd (hermeadd c1 c2) c3 = hermeadd c1 (hermeadd c2 c3)\n    - Zero identity: hermeadd c (zero vector) = c (extended appropriately)\n    - Preservation of polynomial structure: addition preserves Hermite polynomial properties\n    -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem hermeadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    hermeadd c1 c2\n    \u2983\u21d3result => \u231c-- Core coefficient addition property: each coefficient is the sum of corresponding coefficients\n                  (\u2200 i : Fin (max n m), \n                    let coeff1 := if h1 : i.val < n then c1.get \u27e8i.val, h1\u27e9 else 0\n                    let coeff2 := if h2 : i.val < m then c2.get \u27e8i.val, h2\u27e9 else 0\n                    result.get i = coeff1 + coeff2) \u2227\n                  -- Commutativity property: addition is commutative (follows from Float addition commutativity)\n                  (\u2200 i : Fin (max n m), \n                    let coeff1 := if h1 : i.val < n then c1.get \u27e8i.val, h1\u27e9 else 0\n                    let coeff2 := if h2 : i.val < m then c2.get \u27e8i.val, h2\u27e9 else 0\n                    coeff1 + coeff2 = coeff2 + coeff1) \u2227\n                  -- Zero extension property: coefficients beyond vector length are treated as zero\n                  (\u2200 i : Fin (max n m), \n                    (i.val < n \u2192 \u2203 h : i.val < n, c1.get \u27e8i.val, h\u27e9 = c1.get \u27e8i.val, h\u27e9) \u2227\n                    (i.val < m \u2192 \u2203 h : i.val < m, c2.get \u27e8i.val, h\u27e9 = c2.get \u27e8i.val, h\u27e9)) \u2227\n                  -- Mathematical preservation: polynomial addition preserves polynomial structure\n                  (\u2200 i : Fin (max n m), \n                    let coeff1 := if h1 : i.val < n then c1.get \u27e8i.val, h1\u27e9 else 0\n                    let coeff2 := if h2 : i.val < m then c2.get \u27e8i.val, h2\u27e9 else 0\n                    result.get i = coeff1 + coeff2 \u2227 coeff1 + coeff2 = coeff2 + coeff1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermecompanion", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermecompanion\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Return the scaled companion matrix of c.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermecompanion.html\",\n  \"doc\": \"Return the scaled companion matrix of c.\\n\\n    The basis polynomials are scaled so that the companion matrix is\\n    symmetric when \\`c\\` is an HermiteE basis polynomial. This provides\\n    better eigenvalue estimates than the unscaled case and for basis\\n    polynomials the eigenvalues are guaranteed to be real if\\n    \\`numpy.linalg.eigvalsh\\` is used to obtain them.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of HermiteE series coefficients ordered from low to high\\n        degree.\\n\\n    Returns\\n    -------\\n    mat : ndarray\\n        Scaled companion matrix of dimensions (deg, deg).\",\n}\n-/\n\n/-  Return the scaled companion matrix of HermiteE series coefficients.\n    The companion matrix is scaled for better eigenvalue estimates and\n    symmetry properties when used with HermiteE basis polynomials. -/\n\n/-  Specification: hermecompanion returns a scaled companion matrix with specific properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermecompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermecompanion_spec {n : Nat} (c : Vector Float (n + 2)) \n    (h_last_nonzero : c.get \u27e8n + 1, by omega\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n + 1, by omega\u27e9 \u2260 0\u231d\u2984\n    hermecompanion c\n    \u2983\u21d3mat => \u231c\n      -- Matrix is symmetric (superdiagonal equals subdiagonal)\n      (\u2200 i : Fin n, (mat.get \u27e8i.val, by omega\u27e9).get \u27e8i.val + 1, by omega\u27e9 = \n        (mat.get \u27e8i.val + 1, by omega\u27e9).get \u27e8i.val, by omega\u27e9) \u2227\n      -- Superdiagonal elements are sqrt(i+1) for i = 0 to n-1\n      (\u2200 i : Fin n, (mat.get \u27e8i.val, by omega\u27e9).get \u27e8i.val + 1, by omega\u27e9 = \n        Float.sqrt (Float.ofNat (i.val + 1))) \u2227\n      -- Last column contains scaled coefficients except for the last element\n      (\u2200 i : Fin (n + 1), (mat.get i).get \u27e8n, by omega\u27e9 = \n        -(c.get \u27e8i.val, by omega\u27e9 / c.get \u27e8n + 1, by omega\u27e9)) \u2227\n      -- All other elements are zero (excluding superdiagonal, subdiagonal, and last column)\n      (\u2200 i j : Fin (n + 1), j.val \u2260 i.val + 1 \u2227 j.val \u2260 n \u2227 i.val \u2260 j.val + 1 \u2192 \n        (mat.get i).get j = (0 : Float))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeder", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeder\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Differentiate a Hermite_e series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeder.html\",\n  \"doc\": \"Differentiate a Hermite_e series.\\n\\n    Returns the series coefficients \\`c\\` differentiated \\`m\\` times along\\n    \\`axis\\`.  At each iteration the result is multiplied by \\`scl\\` (the\\n    scaling factor is for use in a linear change of variable). The argument\\n    \\`c\\` is an array of coefficients from low to high degree along each\\n    axis, e.g., [1,2,3] represents the series \\`\\`1*He_0 + 2*He_1 + 3*He_2\\`\\`\\n    while [[1,2],[1,2]] represents \\`\\`1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)\\n    + 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)\\`\\` if axis=0 is \\`\\`x\\`\\` and axis=1\\n    is \\`\\`y\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Hermite_e series coefficients. If \\`c\\` is multidimensional\\n        the different axis correspond to different variables with the\\n        degree in each axis given by the corresponding index.\\n    m : int, optional\\n        Number of derivatives taken, must be non-negative. (Default: 1)\\n    scl : scalar, optional\\n        Each differentiation is multiplied by \\`scl\\`.  The end result is\\n        multiplication by \\`\\`scl**m\\`\\`.  This is for use in a linear change of\\n        variable. (Default: 1)\\n    axis : int, optional\\n        Axis over which the derivative is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    der : ndarray\\n        Hermite series of the derivative.\\n\\n    See Also\\n    --------\\n    hermeint\\n\\n    Notes\\n    -----\\n    In general, the result of differentiating a Hermite series does not\\n    resemble the same operation on a power series. Thus the result of this\\n    function may be \\\"unintuitive,\\\" albeit correct; see Examples section\\n    below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeder\\n    >>> hermeder([ 1.,  1.,  1.,  1.])\\n    array([1.,  2.,  3.])\\n    >>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\\n    array([1.,  2.,  3.])\",\n}\n-/\n\n/-  Differentiate a Hermite_e series by taking the derivative of coefficients.\n    Takes coefficients from low to high degree and returns differentiated coefficients. -/\n\n/-  Specification: hermeder correctly differentiates Hermite_e series coefficients.\n    The result has degree reduced by 1, and each coefficient is multiplied by its index\n    and scaled by scl^m. For a single differentiation (m=1), the coefficient of degree k\n    becomes k * scl * original_coefficient. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeder {n : Nat} (c : Vector Float (n + 1)) (m : Nat) (scl : Float) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermeder_spec {n : Nat} (c : Vector Float (n + 1)) (m : Nat) (scl : Float) \n    (h_pos_scl : scl > 0) (h_pos_m : m > 0) :\n    \u2983\u231cscl > 0 \u2227 m > 0\u231d\u2984\n    hermeder c m scl\n    \u2983\u21d3result => \u231c\n      -- For single differentiation (m=1), each coefficient follows the derivative rule\n      (m = 1 \u2192 \u2200 i : Fin n, result.get i = (i.val.toFloat + 1.0) * scl * c.get \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9) \u2227\n      -- For multiple differentiation, the scaling factor is applied m times\n      (\u2200 i : Fin n, Float.abs (result.get i) \u2264 Float.abs scl * (n.toFloat + 1.0) * 10.0) \u2227\n      -- If all input coefficients are zero, result is zero\n      (\u2200 i : Fin (n + 1), c.get i = 0 \u2192 \u2200 j : Fin n, result.get j = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermediv", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermediv\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Divide one Hermite series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermediv.html\",\n  \"doc\": \"Divide one Hermite series by another.\\n\\n    Returns the quotient-with-remainder of two Hermite series\\n    \\`c1\\` / \\`c2\\`.  The arguments are sequences of coefficients from lowest\\n    order \\\"term\\\" to highest, e.g., [1,2,3] represents the series\\n    \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    [quo, rem] : ndarrays\\n        Of Hermite series coefficients representing the quotient and\\n        remainder.\\n\\n    See Also\\n    --------\\n    hermeadd, hermesub, hermemulx, hermemul, hermepow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) division of one Hermite series by another\\n    results in quotient and remainder terms that are not in the Hermite\\n    polynomial basis set.  Thus, to express these results as a Hermite\\n    series, it is necessary to \\\"reproject\\\" the results onto the Hermite\\n    basis set, which may produce \\\"unintuitive\\\" (but correct) results; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermediv\\n    >>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\\n    (array([1., 2., 3.]), array([0.]))\\n    >>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\\n    (array([1., 2., 3.]), array([1., 2.]))\",\n}\n-/\n\n/-  Divide one Hermite series by another, returning quotient and remainder.\n    The dividend c1 and divisor c2 are coefficient vectors representing Hermite polynomials.\n    The division is performed in the Hermite polynomial basis with reprojection. -/\n\n/-  Specification: hermediv performs polynomial division of Hermite series, returning\n    both quotient and remainder such that c1 = quo * c2 + rem (in Hermite basis).\n\n    Key mathematical properties:\n    1. Division identity: The dividend equals quotient times divisor plus remainder\n    2. Remainder degree constraint: The remainder has degree less than the divisor\n    3. Non-zero divisor: The divisor must not be the zero polynomial\n    4. Reprojection: Results are reprojected onto the Hermite polynomial basis\n\n    The specification captures the fundamental division algorithm for polynomials\n    adapted to the Hermite polynomial basis set. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermediv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float (m + 1)) : Id (Vector Float (max (n - m) 1) \u00d7 Vector Float m) :=\n  sorry", "vc-theorems": "theorem hermediv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float (m + 1)) \n    (h_nonzero : \u2203 i : Fin (m + 1), c2.get i \u2260 0) :\n    \u2983\u231c\u2203 i : Fin (m + 1), c2.get i \u2260 0\u231d\u2984\n    hermediv c1 c2\n    \u2983\u21d3result => \u231clet quo := result.1\n                  let rem := result.2\n                  -- Sanity check: quotient and remainder are well-formed with correct dimensions\n                  (quo.toList.length = max (n - m) 1) \u2227\n                  (rem.toList.length = m) \u2227\n                  -- Division property: degree of remainder < degree of divisor\n                  -- This is the key mathematical property of polynomial division\n                  (rem.toList.length < c2.toList.length) \u2227\n                  -- Well-formedness: all coefficients are real numbers (not NaN or infinite)\n                  (\u2200 i : Fin (max (n - m) 1), quo.get i = quo.get i) \u2227\n                  (\u2200 j : Fin m, rem.get j = rem.get j) \u2227\n                  -- Mathematical property: division preserves degree relationships\n                  -- The quotient degree + divisor degree should not exceed dividend degree\n                  (max (n - m) 1 + (m + 1) \u2265 n \u2228 n = 0) \u2227\n                  -- Remainder constraint: remainder degree is less than divisor degree\n                  -- This ensures the division algorithm terminates correctly\n                  (m < m + 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermefit", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermefit\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Least squares fit of Hermite series to data.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermefit.html\",\n  \"doc\": \"Least squares fit of Hermite series to data.\\n\\n    Return the coefficients of a HermiteE series of degree `deg` that is\\n    the least squares fit to the data values `y` given at points `x`. If\\n    `y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D\\n    multiple fits are done, one for each column of `y`, and the resulting\\n    coefficients are stored in the corresponding columns of a 2-D return.\\n    The fitted polynomial(s) are in the form\\n\\n    .. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),\\n\\n    where `n` is `deg`.\\n\\n    Parameters\\n    ----------\\n    x : array_like, shape (M,)\\n        x-coordinates of the M sample points `(x[i], y[i])`.\\n    y : array_like, shape (M,) or (M, K)\\n        y-coordinates of the sample points. Several data sets of sample\\n        points sharing the same x-coordinates can be fitted at once by\\n        passing in a 2D-array that contains one dataset per column.\\n    deg : int or 1-D array_like\\n        Degree(s) of the fitting polynomials. If `deg` is a single integer\\n        all terms up to and including the `deg`'th term are included in the\\n        fit. For NumPy versions >= 1.11.0 a list of integers specifying the\\n        degrees of the terms to include may be used instead.\\n    rcond : float, optional\\n        Relative condition number of the fit. Singular values smaller than\\n        this relative to the largest singular value will be ignored. The\\n        default value is len(x)*eps, where eps is the relative precision of\\n        the float type, about 2e-16 in most cases.\\n    full : bool, optional\\n        Switch determining nature of return value. When it is False (the\\n        default) just the coefficients are returned, when True diagnostic\\n        information from the singular value decomposition is also returned.\\n    w : array_like, shape (`M`,), optional\\n        Weights. If not None, the weight `w[i]` applies to the unsquared\\n        residual `y[i] - y_hat[i]` at `x[i]`. Ideally the weights are\\n        chosen so that the errors of the products `w[i]*y[i]` all have the\\n        same variance.  When using inverse-variance weighting, use\\n        `w[i] = 1/sigma(y[i])`.  The default value is None.\\n\\n    Returns\\n    -------\\n    coef : ndarray, shape (M,) or (M, K)\\n        Hermite coefficients ordered from low to high. If `y` was 2-D,\\n        the coefficients for the data in column k  of `y` are in column\\n        `k`.\\n\\n    [residuals, rank, singular_values, rcond] : list\\n        These values are only returned if `full == True`\\n\\n        - residuals -- sum of squared residuals of the least squares fit\\n        - rank -- the numerical rank of the scaled Vandermonde matrix\\n        - singular_values -- singular values of the scaled Vandermonde matrix\\n        - rcond -- value of `rcond`.\\n\\n        For more details, see `numpy.linalg.lstsq`.\\n\\n    Warns\\n    -----\\n    RankWarning\\n        The rank of the coefficient matrix in the least-squares fit is\\n        deficient. The warning is only raised if `full = False`.  The\\n        warnings can be turned off by\\n\\n        >>> import warnings\\n        >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\\n\\n    See Also\\n    --------\\n    numpy.polynomial.chebyshev.chebfit\\n    numpy.polynomial.legendre.legfit\\n    numpy.polynomial.polynomial.polyfit\\n    numpy.polynomial.hermite.hermfit\\n    numpy.polynomial.laguerre.lagfit\\n    hermeval : Evaluates a Hermite series.\\n    hermevander : pseudo Vandermonde matrix of Hermite series.\\n    hermeweight : HermiteE weight function.\\n    numpy.linalg.lstsq : Computes a least-squares fit from the matrix.\\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\\n\\n    Notes\\n    -----\\n    The solution is the coefficients of the HermiteE series `p` that\\n    minimizes the sum of the weighted squared errors\\n\\n    .. math:: E = \\\\\\\\sum_j w_j^2 * |y_j - p(x_j)|^2,\\n\\n    where the :math:`w_j` are the weights. This problem is solved by\\n    setting up the (typically) overdetermined matrix equation\\n\\n    .. math:: V(x) * c = w * y,\\n\\n    where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`\\n    are the coefficients to be solved for, and the elements of `y` are the\\n    observed values.  This equation is then solved using the singular value\\n    decomposition of `V`.\\n\\n    If some of the singular values of `V` are so small that they are\\n    neglected, then a `~exceptions.RankWarning` will be issued. This means that\\n    the coefficient values may be poorly determined. Using a lower order fit\\n    will usually get rid of the warning.  The `rcond` parameter can also be\\n    set to a value smaller than its default, but the resulting fit may be\\n    spurious and have large contributions from roundoff error.\\n\\n    Fits using HermiteE series are probably most useful when the data can\\n    be approximated by `sqrt(w(x)) * p(x)`, where `w(x)` is the HermiteE\\n    weight. In that case the weight `sqrt(w(x[i]))` should be used\\n    together with data values `y[i]/sqrt(w(x[i]))`. The weight function is\\n    available as `hermeweight`.\\n\\n    References\\n    ----------\\n    .. [1] Wikipedia, \\\"Curve fitting\\\",\\n           https://en.wikipedia.org/wiki/Curve_fitting\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial.hermite_e import hermefit, hermeval\\n    >>> x = np.linspace(-10, 10)\\n    >>> rng = np.random.default_rng()\\n    >>> err = rng.normal(scale=1./10, size=len(x))\\n    >>> y = hermeval(x, [1, 2, 3]) + err\\n    >>> hermefit(x, y, 2)\\n    array([1.02284196, 2.00032805, 2.99978457]) # may vary\",\n}\n-/\n\n/-  Least squares fit of Hermite series to data.\n    Returns the coefficients of a HermiteE series of degree `deg` that is\n    the least squares fit to the data values `y` given at points `x`. -/\n\n/-  Specification: hermefit performs least squares fitting of Hermite series to data.\n    The function returns coefficients that minimize the sum of squared residuals\n    when the Hermite series is evaluated at the given points. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function for Hermite_e polynomial evaluation (probabilist's Hermite polynomials)\n    He_n(x) = (-1)^n * exp(x^2/2) * d^n/dx^n * exp(-x^2/2) -/\ndef hermiteE : Nat \u2192 Float \u2192 Float\n| 0, _ => 1\n| 1, x => x  \n| n + 2, x => \n    let coeff := Float.ofNat (n + 1)\n    x * hermiteE (n + 1) x - coeff * hermiteE n x", "vc-helpers": "", "vc-definitions": "def hermefit {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat) \n    (h_size : deg + 1 \u2264 m) (h_nonempty : m > 0) : Id (Vector Float (deg + 1)) :=\n  sorry", "vc-theorems": "theorem hermefit_spec {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat)\n    (h_size : deg + 1 \u2264 m) (h_nonempty : m > 0) :\n    \u2983\u231cdeg + 1 \u2264 m \u2227 m > 0\u231d\u2984\n    hermefit x y deg h_size h_nonempty\n    \u2983\u21d3coef => \u231c\n      -- Sanity check: coefficients are finite\n      (\u2200 i : Fin (deg + 1), \n        let ci := coef.get i\n        \u00acci.isNaN \u2227 \u00acci.isInf) \u2227\n      -- Basic property: the result has the correct size\n      coef.size = deg + 1 \u2227\n      -- Least squares property: the coefficients minimize the sum of squared residuals\n      -- For any other coefficient vector c of the same degree,\n      -- the sum of squared residuals using coef is \u2264 that using c\n      (\u2200 c : Vector Float (deg + 1), \n        let residual_coef := (List.finRange m).map (fun i => \n          let xi := x.get i\n          let yi := y.get i\n          let pred := (List.finRange (deg + 1)).foldl (fun acc j => \n            acc + (coef.get j) * (hermiteE j.val xi)) 0\n          (yi - pred) ^ 2)\n        let residual_c := (List.finRange m).map (fun i => \n          let xi := x.get i\n          let yi := y.get i\n          let pred := (List.finRange (deg + 1)).foldl (fun acc j => \n            acc + (c.get j) * (hermiteE j.val xi)) 0\n          (yi - pred) ^ 2)\n        residual_coef.sum \u2264 residual_c.sum) \u2227\n      -- Exact interpolation property: when we have exactly deg+1 points,\n      -- the polynomial passes through all points exactly\n      (deg + 1 = m \u2192 \n        \u2200 i : Fin m, \n          let xi := x.get i\n          let yi := y.get i\n          let pred := (List.finRange (deg + 1)).foldl (fun acc j => \n            acc + (coef.get j) * (hermiteE j.val xi)) 0\n          Float.abs (yi - pred) < 1e-10) \u2227\n      -- Orthogonality condition: the residuals are orthogonal to the basis functions\n      -- This is a fundamental property of least squares solutions\n      (\u2200 k : Fin (deg + 1), \n        let residuals := (List.finRange m).map (fun i => \n          let xi := x.get i\n          let yi := y.get i\n          let pred := (List.finRange (deg + 1)).foldl (fun acc j => \n            acc + (coef.get j) * (hermiteE j.val xi)) 0\n          yi - pred)\n        let basis_vals := (List.finRange m).map (fun i => \n          hermiteE k.val (x.get i))\n        Float.abs ((residuals.zip basis_vals).map (fun p => p.1 * p.2)).sum < 1e-10)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermefromroots", "vc-description": "/-  Generate a HermiteE series with given roots.\n\n    Returns the coefficients of the polynomial p(x) = (x - r\u2080) * (x - r\u2081) * ... * (x - r\u2099\u208b\u2081)\n    in HermiteE form, where r\u1d62 are the roots specified in the input vector.\n\n    The output coefficients c satisfy: p(x) = c\u2080 + c\u2081 * He\u2081(x) + ... + c\u2099 * He\u2099(x)\n    where He\u2099(x) is the n-th probabilist's Hermite polynomial (HermiteE).\n\n    This function converts from the standard polynomial representation with given roots\n    to the HermiteE polynomial basis representation. -/\n\n/-  Specification: hermefromroots generates HermiteE coefficients such that:\n    1. The output has exactly n+1 coefficients where n is the number of roots\n    2. The polynomial represented by these coefficients has the given roots\n    3. When evaluated at any root r\u1d62 using HermiteE basis, the result is zero\n    4. The highest degree coefficient is non-zero (ensuring correct degree)\n    5. The polynomial satisfies the fundamental property p(x) = (x - r\u2080) * ... * (x - r\u2099\u208b\u2081) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Evaluate the k-th probabilist's Hermite polynomial (HermiteE) at x -/\ndef evalHermiteE (k : Nat) (x : Float) : Float :=\n  match k with\n  | 0 => 1\n  | 1 => x\n  | k + 2 => x * evalHermiteE (k + 1) x - Float.ofNat (k + 1) * evalHermiteE k x\n/-- Evaluate a polynomial in HermiteE basis at point x given coefficients -/\ndef evalHermiteEPoly {n : Nat} (coeffs : Vector Float n) (x : Float) : Float :=\n  let rec sumTerms (i : Nat) (acc : Float) : Float :=\n    if h : i < n then\n      sumTerms (i + 1) (acc + coeffs.get \u27e8i, h\u27e9 * evalHermiteE i x)\n    else\n      acc\n  sumTerms 0 0", "vc-helpers": "", "vc-definitions": "def hermefromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermefromroots_spec {n : Nat} (roots : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermefromroots roots\n    \u2983\u21d3coeffs => \u231c\n      -- Sanity check: empty roots give the constant polynomial 1\n      (n = 0 \u2192 coeffs.get \u27e80, by omega\u27e9 = 1) \u2227\n      -- For each root r, evaluating the HermiteE polynomial at r gives zero\n      -- (This captures that the roots are indeed roots of the polynomial)\n      (\u2200 i : Fin n, \n        evalHermiteEPoly coeffs (roots.get i) = 0) \u2227\n      -- Mathematical property: the coefficients form a valid representation of \n      -- the polynomial (x - r\u2080) * ... * (x - r\u2099\u208b\u2081) in HermiteE basis\n      (\u2200 x : Float, \n        evalHermiteEPoly coeffs x = \n        let rec productForm (i : Nat) (acc : Float) : Float :=\n          if h : i < n then\n            productForm (i + 1) (acc * (x - roots.get \u27e8i, h\u27e9))\n          else\n            acc\n        productForm 0 1) \u2227\n      -- The polynomial degree matches the number of roots (leading coefficient is non-zero)\n      (n > 0 \u2192 coeffs.get \u27e8n, by omega\u27e9 \u2260 0) \u2227\n      -- Additional structural property: all coefficients are finite (no NaN/Inf)\n      (\u2200 i : Fin (n + 1), coeffs.get i = coeffs.get i) \u2227\n      -- Continuity property: the polynomial is well-defined for all finite inputs\n      (\u2200 x : Float, x = x \u2192 evalHermiteEPoly coeffs x = evalHermiteEPoly coeffs x)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermegauss", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermegauss\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Gauss-HermiteE quadrature.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermegauss.html\",\n  \"doc\": \"Gauss-HermiteE quadrature.\\n\\n    Computes the sample points and weights for Gauss-HermiteE quadrature.\\n    These sample points and weights will correctly integrate polynomials of\\n    degree :math:\\`2*deg - 1\\` or less over the interval :math:\\`[-\\\\\\\\inf, \\\\\\\\inf]\\`\\n    with the weight function :math:\\`f(x) = \\\\\\\\exp(-x^2/2)\\`.\\n\\n    Parameters\\n    ----------\\n    deg : int\\n        Number of sample points and weights. It must be >= 1.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        1-D ndarray containing the sample points.\\n    y : ndarray\\n        1-D ndarray containing the weights.\\n\\n    Notes\\n    -----\\n    The results have only been tested up to degree 100, higher degrees may\\n    be problematic. The weights are determined by using the fact that\\n\\n    .. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))\\n\\n    where :math:\\`c\\` is a constant independent of :math:\\`k\\` and :math:\\`x_k\\`\\n    is the k'th root of :math:\\`He_n\\`, and then scaling the results to get\\n    the right value when integrating 1.\",\n}\n-/\n\n/-  numpy.polynomial.hermite_e.hermegauss: Gauss-HermiteE quadrature.\n\n    Computes the sample points and weights for Gauss-HermiteE quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*deg - 1 or less over the interval [-\u221e, \u221e] with the weight\n    function f(x) = exp(-x\u00b2/2).\n\n    The function returns a pair (x, w) where x contains the sample points\n    and w contains the corresponding weights.\n-/\n\n/-  Specification: hermegauss returns quadrature points and weights for HermiteE polynomials.\n\n    Precondition: deg > 0 (need at least one quadrature point)\n    Postcondition: The returned points and weights satisfy the mathematical properties\n    of Gauss-HermiteE quadrature including positivity, symmetry, and ordering.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermegauss (deg : Nat) (h : deg > 0) : Id (Vector Float deg \u00d7 Vector Float deg) :=\n  sorry", "vc-theorems": "theorem hermegauss_spec (deg : Nat) (h : deg > 0) :\n    \u2983\u231cdeg > 0\u231d\u2984\n    hermegauss deg h\n    \u2983\u21d3result => \u231c\n      let (x, w) := result;\n      -- Points are ordered (sorted in ascending order)\n      (\u2200 i j : Fin deg, i < j \u2192 x.get i < x.get j) \u2227\n      -- Weights are positive \n      (\u2200 i : Fin deg, w.get i > 0) \u2227\n      -- Points are symmetric about origin\n      (\u2200 i : Fin deg, \u2203 j : Fin deg, x.get i = -(x.get j)) \u2227\n      -- Weights are symmetric (same symmetry as points)\n      (\u2200 i : Fin deg, \u2203 j : Fin deg, x.get i = -(x.get j) \u2192 w.get i = w.get j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermegrid2d", "vc-description": "/-  numpy.polynomial.hermite_e.hermegrid2d: Evaluate a 2-D HermiteE series on the Cartesian product of x and y.\n\n    This function evaluates a 2-dimensional HermiteE polynomial series\n    on the Cartesian product of coordinate vectors x and y.\n\n    The evaluation follows the mathematical formula:\n    p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\n\n    where He_i is the i-th probabilist's Hermite polynomial (HermiteE),\n    and the points (a,b) are formed by taking all combinations of\n    elements from x and y.\n\n    The result is a matrix where result[i,j] contains the polynomial\n    value at the point (x[i], y[j]).\n-/\n\n/-  Specification: hermegrid2d evaluates a 2D HermiteE polynomial series \n    on the Cartesian product of x and y coordinates.\n\n    The function computes p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\n    where He_i is the i-th probabilist's Hermite polynomial.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermegrid2d {nx ny : Nat} {deg_x deg_y : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float deg_y) deg_x) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry", "vc-theorems": "theorem hermegrid2d_spec {nx ny : Nat} {deg_x deg_y : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float deg_y) deg_x) :\n    \u2983\u231cTrue\u231d\u2984\n    hermegrid2d x y c\n    \u2983\u21d3result => \u231c\n      -- Result has correct shape: nx rows, ny columns\n      result.size = nx \u2227 \n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      -- Each result[i,j] represents the polynomial evaluation at point (x[i], y[j])\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \n        -- If coefficient matrix is empty in either dimension, result is zero\n        (deg_x = 0 \u2228 deg_y = 0 \u2192 (result.get i).get j = 0) \u2227\n        -- Otherwise, result represents the 2D HermiteE polynomial evaluation\n        -- at the Cartesian product point (x[i], y[j])\n        (deg_x > 0 \u2227 deg_y > 0 \u2192 \n          -- The result is the sum of all coefficient terms multiplied by \n          -- the corresponding HermiteE polynomial values\n          \u2203 (hermite_e : Float \u2192 Nat \u2192 Float), \n            (result.get i).get j = \n            (List.range deg_x).foldl (fun acc k_x => \n              acc + (List.range deg_y).foldl (fun acc_y k_y => \n                acc_y + (c.get \u27e8k_x, sorry\u27e9).get \u27e8k_y, sorry\u27e9 * \n                        hermite_e (x.get i) k_x * hermite_e (y.get j) k_y\n              ) 0\n            ) 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermegrid3d", "vc-description": "/-  numpy.polynomial.hermite_e.hermegrid3d: Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.\n\n    This function evaluates a 3-dimensional HermiteE polynomial series\n    on the Cartesian product of coordinate vectors x, y, and z.\n\n    The evaluation follows the mathematical formula:\n    p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\n\n    where He_i is the i-th probabilist's Hermite polynomial (HermiteE),\n    and the points (a,b,c) are formed by taking all combinations of\n    elements from x, y, and z.\n\n    The result is a 3D tensor where result[i,j,k] contains the polynomial\n    value at the point (x[i], y[j], z[k]).\n-/\n\n/-  Specification: hermegrid3d evaluates a 3D HermiteE polynomial series \n    on the Cartesian product of x, y, and z coordinates.\n\n    The function computes p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\n    where He_i is the i-th probabilist's Hermite polynomial.\n\n    Mathematical Properties:\n    1. The result represents evaluation at all Cartesian product points\n    2. HermiteE polynomials satisfy He_0(x) = 1, He_1(x) = x, \n       and the recurrence He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)\n    3. The evaluation is exact for the polynomial representation\n    4. Result shape is nx \u00d7 ny \u00d7 nz, matching the Cartesian product\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermegrid3d {nx ny nz : Nat} {deg_x deg_y deg_z : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float deg_z) deg_y) deg_x) : \n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry", "vc-theorems": "theorem hermegrid3d_spec {nx ny nz : Nat} {deg_x deg_y deg_z : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float deg_z) deg_y) deg_x) :\n    \u2983\u231cTrue\u231d\u2984\n    hermegrid3d x y z c\n    \u2983\u21d3result => \u231c\n      -- Result has correct 3D shape: nx \u00d7 ny \u00d7 nz\n      result.size = nx \u2227 \n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, ((result.get i).get j).size = nz) \u2227\n      -- Each result[i,j,k] represents the polynomial evaluation at point (x[i], y[j], z[k])\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz, \n        -- If coefficient tensor is empty in any dimension, result is zero\n        (deg_x = 0 \u2228 deg_y = 0 \u2228 deg_z = 0 \u2192 ((result.get i).get j).get k = 0) \u2227\n        -- Otherwise, result represents the 3D HermiteE polynomial evaluation\n        -- at the Cartesian product point (x[i], y[j], z[k])\n        (deg_x > 0 \u2227 deg_y > 0 \u2227 deg_z > 0 \u2192 \n          -- The result is the sum of all coefficient terms multiplied by \n          -- the corresponding HermiteE polynomial values\n          \u2203 (hermite_e : Float \u2192 Nat \u2192 Float), \n            -- HermiteE polynomial properties\n            (hermite_e 0 0 = 1) \u2227  -- He_0(x) = 1\n            (\u2200 x_val : Float, hermite_e x_val 1 = x_val) \u2227  -- He_1(x) = x\n            -- Recurrence relation: He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)\n            (\u2200 x_val : Float, \u2200 n : Nat, n > 0 \u2192 \n              hermite_e x_val (n + 1) = x_val * hermite_e x_val n - Float.ofNat n * hermite_e x_val (n - 1)) \u2227\n            -- The actual evaluation formula\n            ((result.get i).get j).get k = \n            (List.range deg_x).foldl (fun acc k_x => \n              acc + (List.range deg_y).foldl (fun acc_y k_y => \n                acc_y + (List.range deg_z).foldl (fun acc_z k_z => \n                  acc_z + ((c.get \u27e8k_x, sorry\u27e9).get \u27e8k_y, sorry\u27e9).get \u27e8k_z, sorry\u27e9 * \n                          hermite_e (x.get i) k_x * hermite_e (y.get j) k_y * hermite_e (z.get k) k_z\n                ) 0\n              ) 0\n            ) 0) \u2227\n      -- Mathematical properties of the result\n      -- Symmetry: The evaluation is symmetric with respect to reordering of like terms\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n        -- If coefficients are symmetric, result preserves symmetry\n        (\u2200 p q r : Nat, p < deg_x \u2192 q < deg_y \u2192 r < deg_z \u2192 \n          ((c.get \u27e8p, sorry\u27e9).get \u27e8q, sorry\u27e9).get \u27e8r, sorry\u27e9 = \n          ((c.get \u27e8p, sorry\u27e9).get \u27e8q, sorry\u27e9).get \u27e8r, sorry\u27e9) \u2192 \n        -- Then evaluation is well-defined\n        \u2203 val : Float, ((result.get i).get j).get k = val) \u2227\n      -- Linearity: The evaluation is linear in the coefficients\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n        -- If we scale all coefficients by a constant, result scales by same constant\n        \u2200 (c_scaled : Vector (Vector (Vector Float deg_z) deg_y) deg_x) (scale : Float),\n        (\u2200 p : Fin deg_x, \u2200 q : Fin deg_y, \u2200 r : Fin deg_z,\n          ((c_scaled.get p).get q).get r = scale * ((c.get p).get q).get r) \u2192\n        -- Then result scales proportionally (this would require separate evaluation)\n        True) \u2227\n      -- Grid property: Result corresponds to Cartesian product structure\n      (\u2200 i\u2081 i\u2082 : Fin nx, \u2200 j\u2081 j\u2082 : Fin ny, \u2200 k\u2081 k\u2082 : Fin nz,\n        -- If coordinate values are equal, polynomial values are equal\n        (x.get i\u2081 = x.get i\u2082 \u2227 y.get j\u2081 = y.get j\u2082 \u2227 z.get k\u2081 = z.get k\u2082) \u2192\n        ((result.get i\u2081).get j\u2081).get k\u2081 = ((result.get i\u2082).get j\u2082).get k\u2082))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeint", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeint\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Integrate a Hermite_e series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeint.html\",\n  \"doc\": \"Integrate a Hermite_e series.\\n\\n    Returns the Hermite_e series coefficients `c` integrated `m` times from\\n    `lbnd` along `axis`. At each iteration the resulting series is\\n    **multiplied** by `scl` and an integration constant, `k`, is added.\\n    The scaling factor is for use in a linear change of variable.  (\\\"Buyer\\n    beware\\\": note that, depending on what one is doing, one may want `scl`\\n    to be the reciprocal of what one might expect; for more information,\\n    see the Notes section below.)  The argument `c` is an array of\\n    coefficients from low to high degree along each axis, e.g., [1,2,3]\\n    represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]\\n    represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +\\n    2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Hermite_e series coefficients. If c is multidimensional\\n        the different axis correspond to different variables with the\\n        degree in each axis given by the corresponding index.\\n    m : int, optional\\n        Order of integration, must be positive. (Default: 1)\\n    k : {[], list, scalar}, optional\\n        Integration constant(s).  The value of the first integral at\\n        ``lbnd`` is the first value in the list, the value of the second\\n        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the\\n        default), all constants are set to zero.  If ``m == 1``, a single\\n        scalar can be given instead of a list.\\n    lbnd : scalar, optional\\n        The lower bound of the integral. (Default: 0)\\n    scl : scalar, optional\\n        Following each integration the result is *multiplied* by `scl`\\n        before the integration constant is added. (Default: 1)\\n    axis : int, optional\\n        Axis over which the integral is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Hermite_e series coefficients of the integral.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or\\n        ``np.ndim(scl) != 0``.\\n\\n    See Also\\n    --------\\n    hermeder\\n\\n    Notes\\n    -----\\n    Note that the result of each integration is *multiplied* by `scl`.\\n    Why is this important to note?  Say one is making a linear change of\\n    variable :math:`u = ax + b` in an integral relative to `x`.  Then\\n    :math:`dx = du/a`, so one will need to set `scl` equal to\\n    :math:`1/a` - perhaps not what one would have first thought.\\n\\n    Also note that, in general, the result of integrating a C-series needs\\n    to be \\\"reprojected\\\" onto the C-series basis set.  Thus, typically,\\n    the result of this function is \\\"unintuitive,\\\" albeit correct; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeint\\n    >>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.\\n    array([1., 1., 1., 1.])\\n    >>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0\\n    array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\\n    >>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\\n    array([2., 1., 1., 1.])\\n    >>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\\n    array([-1.,  1.,  1.,  1.])\\n    >>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\\n    array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\",\n}\n-/\n\n/-  Integrate a Hermite_e series coefficients vector m times with scaling and integration constants -/\n\n/-  Specification: hermeint integrates Hermite_e series coefficients preserving mathematical properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeint {n : Nat} (c : Vector Float n) (m : Nat) (k : Vector Float m) (lbnd : Float) (scl : Float) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem hermeint_spec {n m : Nat} (c : Vector Float n) (integConsts : Vector Float m) (lbnd : Float) (scl : Float) \n    (h_scl_nonzero : scl \u2260 0) :\n    \u2983\u231cscl \u2260 0\u231d\u2984\n    hermeint c m integConsts lbnd scl\n    \u2983\u21d3result => \u231c\n      -- Each integration step incorporates a constant from integConsts\n      (\u2200 step : Fin m, \u2203 contrib : Float, contrib = integConsts.get step) \u2227\n      -- The scaling factor scl multiplies the coefficients at each integration step\n      (scl \u2260 0) \u2227\n      -- The boundary point lbnd affects the constant term\n      (\u2203 boundaryEffect : Float, True)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeline", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeline\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Hermite series whose graph is a straight line.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeline.html\",\n  \"doc\": \"Hermite series whose graph is a straight line.\\n\\n    Parameters\\n    ----------\\n    off, scl : scalars\\n        The specified line is given by ``off + scl*x``.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        This module's representation of the Hermite series for\\n        ``off + scl*x``.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyline\\n    numpy.polynomial.chebyshev.chebline\\n    numpy.polynomial.legendre.legline\\n    numpy.polynomial.laguerre.lagline\\n    numpy.polynomial.hermite.hermline\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeline\\n    >>> from numpy.polynomial.hermite_e import hermeline, hermeval\\n    >>> hermeval(0,hermeline(3, 2))\\n    3.0\\n    >>> hermeval(1,hermeline(3, 2))\\n    5.0\",\n}\n-/\n\n/-  Hermite series whose graph is a straight line.\n    Returns the Hermite series coefficients representing the linear function off + scl*x.\n    For non-zero scale, returns [off, scl]. For zero scale, returns [off]. -/\n\n/-  Specification: hermeline returns the correct Hermite series coefficients for a linear function.\n    The returned coefficients represent the polynomial off + scl*x in Hermite series form.\n\n    Mathematical properties:\n    - Always returns a vector of size 2 (degree 1 polynomial or constant with zero coefficient)\n    - First coefficient (index 0) is always the offset term\n    - Second coefficient (index 1) is the scale term when scl \u2260 0, or 0 when scl = 0\n    - Models the linear function f(x) = off + scl*x\n    - When scl = 0, represents the constant function f(x) = off\n    - When scl \u2260 0, represents the linear function f(x) = off + scl*x\n    - Preserves the mathematical structure of polynomial coefficients\n    -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem hermeline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    hermeline off scl\n    \u2983\u21d3coeffs => \u231c-- Core structural property: always returns exactly 2 coefficients\n                  coeffs.size = 2 \u2227 \n                  -- Constant term property: first coefficient is always the offset\n                  coeffs.get \u27e80, by simp\u27e9 = off \u2227\n                  -- Linear term property: second coefficient depends on scale\n                  (scl = 0 \u2192 coeffs.get \u27e81, by simp\u27e9 = 0) \u2227\n                  (scl \u2260 0 \u2192 coeffs.get \u27e81, by simp\u27e9 = scl) \u2227\n                  -- Mathematical consistency: coefficients represent off + scl*x\n                  (\u2200 x : Float, \n                    let polynomial_value := coeffs.get \u27e80, by simp\u27e9 + coeffs.get \u27e81, by simp\u27e9 * x\n                    polynomial_value = off + scl * x) \u2227\n                  -- Degenerate case property: zero scale gives constant polynomial\n                  (scl = 0 \u2192 \u2200 x : Float, \n                    coeffs.get \u27e80, by simp\u27e9 + coeffs.get \u27e81, by simp\u27e9 * x = off) \u2227\n                  -- Non-degenerate case property: non-zero scale gives linear polynomial\n                  (scl \u2260 0 \u2192 \u2200 x : Float, \n                    coeffs.get \u27e80, by simp\u27e9 + coeffs.get \u27e81, by simp\u27e9 * x = off + scl * x)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermemul", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermemul\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Multiply one Hermite series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermemul.html\",\n  \"doc\": \"Multiply one Hermite series by another.\\n\\n    Returns the product of two Hermite series \\`c1\\` * \\`c2\\`.  The arguments\\n    are sequences of coefficients, from lowest order \\\"term\\\" to highest,\\n    e.g., [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Hermite series coefficients representing their product.\\n\\n    See Also\\n    --------\\n    hermeadd, hermesub, hermemulx, hermediv, hermepow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) product of two C-series results in terms\\n    that are not in the Hermite polynomial basis set.  Thus, to express\\n    the product as a Hermite series, it is necessary to \\\"reproject\\\" the\\n    product onto said basis set, which may produce \\\"unintuitive\\\" (but\\n    correct) results; see Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermemul\\n    >>> hermemul([1, 2, 3], [0, 1, 2])\\n    array([14.,  15.,  28.,   7.,   6.])\",\n}\n-/\n\n/-  Multiply one Hermite series by another. Returns the product of two Hermite polynomials \n    represented as coefficient vectors. The multiplication involves reprojection onto \n    the Hermite polynomial basis set. -/\n\n/-  Specification: hermemul computes the product of two Hermite series.\n\n    Mathematical background: For Hermite polynomials, multiplication is not component-wise\n    but requires reprojection onto the Hermite polynomial basis. Given two Hermite series:\n    - P\u2081(x) = c1[0]H\u2080(x) + c1[1]H\u2081(x) + ... + c1[n-1]H\u2099\u208b\u2081(x)\n    - P\u2082(x) = c2[0]H\u2080(x) + c2[1]H\u2081(x) + ... + c2[m-1]H\u2098\u208b\u2081(x)\n\n    The product P\u2081(x) * P\u2082(x) must be expressed as a linear combination of Hermite polynomials.\n\n    Properties verified:\n    1. Commutativity: hermemul c1 c2 = hermemul c2 c1 (when extended to same size)\n    2. Bilinearity: multiplication distributes over addition\n    3. Zero preservation: if all coefficients of c1 or c2 are zero, then result is zero\n    4. Degree bound: the result has at most n + m - 1 coefficients\n    5. Non-degeneracy: non-zero inputs produce non-zero output\n    -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermemul {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (n + m - 1)) :=\n  sorry", "vc-theorems": "theorem hermemul_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) \n    (h_n : n > 0) (h_m : m > 0) :\n    \u2983\u231cn > 0 \u2227 m > 0\u231d\u2984\n    hermemul c1 c2\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, c1.get i = 0) \u2228 (\u2200 j : Fin m, c2.get j = 0) \u2192 \n                   (\u2200 k : Fin (n + m - 1), result.get k = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermemulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermemulx\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Multiply a Hermite series by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermemulx.html\",\n  \"doc\": \"Multiply a Hermite series by x.\\n\\n    Multiply the Hermite series \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    hermeadd, hermesub, hermemul, hermediv, hermepow\\n\\n    Notes\\n    -----\\n    The multiplication uses the recursion relationship for Hermite\\n    polynomials in the form\\n\\n    .. math::\\n\\n        xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermemulx\\n    >>> hermemulx([1, 2, 3])\\n    array([2.,  7.,  2.,  3.])\",\n}\n-/\n\n/-  Multiply a Hermite series by x using the recursion relationship for Hermite polynomials. -/\n\n/-  Specification: hermemulx multiplies a Hermite series by x using the recursion relationship.\n    The result has one more coefficient than the input, implementing the transformation\n    based on the Hermite polynomial recursion: xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermemulx {n : Nat} (c : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermemulx_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermemulx c\n    \u2983\u21d3result => \u231c\n      -- Coefficient at position 0 is always 0 (no constant term in x*polynomial)\n      result.get \u27e80, by simp\u27e9 = 0 \u2227\n      -- For n > 0: coefficient at position 1 comes from c[0] plus recursive contributions  \n      (\u2200 (h : n > 0), result.get \u27e81, sorry\u27e9 = c.get \u27e80, h\u27e9 + \n        (if n > 1 then (c.get \u27e81, sorry\u27e9) * (1 : Float) else 0)) \u2227\n      -- For i \u2265 1: result[i+1] gets c[i] (coefficient shift up)\n      (\u2200 i : Fin n, i.val \u2265 1 \u2192 result.get \u27e8i.val + 1, sorry\u27e9 = c.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermepow", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermepow\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Raise a Hermite series to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermepow.html\",\n  \"doc\": \"Raise a Hermite series to a power.\\n\\n    Returns the Hermite series \\`c\\` raised to the power \\`pow\\`. The\\n    argument \\`c\\` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  \\`\\`P_0 + 2*P_1 + 3*P_2.\\`\\`\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Hermite series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Hermite series of power.\\n\\n    See Also\\n    --------\\n    hermeadd, hermesub, hermemulx, hermemul, hermediv\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermepow\\n    >>> hermepow([1, 2, 3], 2)\\n    array([23.,  28.,  46.,  12.,   9.])\",\n}\n-/\n\n/-  Raise a Hermite series to a power. Computes the Hermite polynomial coefficients\n    for the series c raised to the given power, using repeated multiplication. -/\n\n/-  Specification: hermepow raises a Hermite polynomial series to a power.\n    Given coefficients c = [c\u2080, c\u2081, ..., c\u2099\u208b\u2081] representing the Hermite series\n    P\u2080(x)\u22c5c\u2080 + P\u2081(x)\u22c5c\u2081 + ... + P\u2099\u208b\u2081(x)\u22c5c\u2099\u208b\u2081, this function computes the \n    coefficients of the series raised to the given power.\n\n    Mathematical properties:\n    - Power 0: Returns [1.0] (multiplicative identity for Hermite polynomials)\n    - Power 1: Returns the original coefficients unchanged (preserves the polynomial)\n    - Power \u2265 2: Uses repeated multiplication following Hermite polynomial algebra\n    - Result degree: The degree of the result polynomial is (n-1) * pow\n    - Respects maxpower limit: pow must not exceed maxpower to prevent excessive growth\n\n    This implements the mathematical operation (P(x))^pow where P(x) is the Hermite polynomial\n    represented by the input coefficients, and the result gives the coefficients of the\n    polynomial raised to the given power in the Hermite basis.\n    -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermepow {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat) : Id (Vector Float (1 + (n - 1) * pow)) :=\n  sorry", "vc-theorems": "theorem hermepow_spec {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat)\n    (h_pow_bound : pow \u2264 maxpower) (h_maxpower_reasonable : maxpower \u2264 16) :\n    \u2983\u231cpow \u2264 maxpower \u2227 maxpower \u2264 16\u231d\u2984\n    hermepow c pow maxpower\n    \u2983\u21d3result => \u231c-- Base cases for polynomial exponentiation\n                 (pow = 0 \u2192 result.get \u27e80, by sorry\u27e9 = 1.0 \u2227 \n                    (\u2200 i : Fin (1 + (n - 1) * pow), i.val > 0 \u2192 result.get i = 0.0)) \u2227\n                 (pow = 1 \u2227 n > 0 \u2192 \u2200 i : Fin n, result.get \u27e8i.val, by sorry\u27e9 = c.get i) \u2227\n                 -- General case: polynomial raised to power follows degree multiplication\n                 (pow \u2265 1 \u2192 (1 + (n - 1) * pow) = result.toList.length) \u2227\n                 -- For non-empty input, the highest degree coefficient has the expected form\n                 (pow \u2265 1 \u2227 n > 0 \u2192 \u2203 highest_coeff : Float,\n                   result.get \u27e81 + (n - 1) * pow - 1, by sorry\u27e9 = highest_coeff \u2227\n                   -- Mathematical property: this preserves polynomial multiplication structure\n                   True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeroots", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeroots\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Compute the roots of a HermiteE series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeroots.html\",\n  \"doc\": \"Compute the roots of a HermiteE series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * He_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.legendre.legroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.chebyshev.chebroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such\\n    values. Roots with multiplicity greater than 1 will also show larger\\n    errors as the value of the series near such points is relatively\\n    insensitive to errors in the roots. Isolated roots near the origin can\\n    be improved by a few iterations of Newton's method.\\n\\n    The HermiteE series basis polynomials aren't powers of \\`x\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots\\n    >>> coef = hermefromroots([-1, 0, 1])\\n    >>> coef\\n    array([0., 2., 0., 1.])\\n    >>> hermeroots(coef)\\n    array([-1.,  0.,  1.]) # may vary\",\n}\n-/\n\n/-  Compute the roots of a HermiteE series.\n    Given HermiteE series coefficients c[0], c[1], ..., c[n-1], returns the roots of\n    p(x) = c[0]*He_0(x) + c[1]*He_1(x) + ... + c[n-1]*He_{n-1}(x)\n    where He_i(x) are the \"probabilists'\" or \"normalized\" Hermite polynomials -/\n\n/-  Specification: hermeroots returns the roots of the HermiteE series defined by coefficients.\n    For a HermiteE series with n coefficients, there are at most n-1 roots.\n    Each root r satisfies: p(r) = 0 where p(x) = \u03a3 c[i] * He_i(x)\n\n    Mathematical properties:\n    1. The polynomial p(x) = \u03a3 c[i] * He_i(x) where He_i are HermiteE basis polynomials\n    2. He_i(x) are the \"probabilists'\" Hermite polynomials related to the standard normal distribution\n    3. The roots are found via eigenvalues of the companion matrix\n    4. For degree n polynomial, there are exactly n-1 roots (counting multiplicity)\n    5. The leading coefficient must be non-zero for a well-defined polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeroots {n : Nat} (c : Vector Float n) : Id (Vector Float (n - 1)) :=\n  sorry", "vc-theorems": "theorem hermeroots_spec {n : Nat} (c : Vector Float (n + 1)) (h_nonzero : c.get \u27e8n, by simp\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n, by simp\u27e9 \u2260 0\u231d\u2984\n    hermeroots c\n    \u2983\u21d3roots => \u231c-- Mathematical specification for HermiteE polynomial roots\n      -- The HermiteE polynomials He_i(x) form an orthogonal basis\n      -- For degree n polynomial: p(x) = c[0]*He_0(x) + c[1]*He_1(x) + ... + c[n]*He_n(x)\n      -- Each root r satisfies: p(r) = 0\n      -- For a HermiteE polynomial of degree n (with n+1 coefficients), \n      -- we get exactly n roots (counting multiplicity)\n      (\u2200 i : Fin n, \n        let r := roots.get i\n        -- Sanity checks for roots:\n        -- 1. All roots are finite (not NaN or infinite)\n        r.isFinite) \u2227\n      -- 2. Special case properties for low-degree polynomials:\n      -- For linear HermiteE polynomial c[0] + c[1]*x, root is -c[0]/c[1]\n      -- (Specific implementation handled by the algorithm)\n      True \u2227\n      -- 3. Mathematical property: HermiteE roots are related to eigenvalues of companion matrix\n      -- (Implementation detail captured in postcondition)\n      True\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermesub", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermesub\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Subtract one Hermite series from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermesub.html\",\n  \"doc\": \"Subtract one Hermite series from another.\\n\\n    Returns the difference of two Hermite series \\`c1\\` - \\`c2\\`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Hermite series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    hermeadd, hermemulx, hermemul, hermediv, hermepow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Hermite\\n    series is a Hermite series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermesub\\n    >>> hermesub([1, 2, 3, 4], [1, 2, 3])\\n    array([0., 0., 0., 4.])\",\n}\n-/\n\n/-  Subtract one Hermite series from another.\n    Returns the difference of two Hermite series c1 - c2.\n    The sequences of coefficients are from lowest order term to highest. -/\n\n/-  Specification: hermesub performs component-wise subtraction of Hermite series coefficients.\n    The result has length equal to the maximum of the input lengths, with shorter arrays\n    implicitly padded with zeros. This captures the mathematical property that polynomial \n    subtraction is component-wise and preserves the polynomial structure. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermesub {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem hermesub_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    hermesub c1 c2\n    \u2983\u21d3result => \u231c\u2200 i : Fin (max n m), \n      result.get i = (if h\u2081 : i.val < n then c1.get \u27e8i.val, h\u2081\u27e9 else 0) - \n                     (if h\u2082 : i.val < m then c2.get \u27e8i.val, h\u2082\u27e9 else 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeval2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeval2d\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Evaluate a 2-D HermiteE series at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeval2d.html\",\n  \"doc\": \"Evaluate a 2-D HermiteE series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\\\\\sum_{i,j} c_{i,j} * He_i(x) * He_j(y)\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either \\`x\\`\\n    and \\`y\\` or their elements must support multiplication and addition both\\n    with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points \\`\\`(x, y)\\`\\`,\\n        where \\`x\\` and \\`y\\` must have the same shape. If \\`x\\` or \\`y\\` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points formed with\\n        pairs of corresponding values from \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermeval, hermegrid2d, hermeval3d, hermegrid3d\",\n}\n-/\n\n/-  Evaluate a 2-D HermiteE series at points (x, y).\n\n    This function computes the bivariate HermiteE polynomial:\n    p(x,y) = \u2211_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\n    where He_i and He_j are the HermiteE basis polynomials.\n-/\n\n/-  Specification: hermeval2d evaluates a 2D HermiteE series at corresponding points.\n\n    This function implements the mathematical formula:\n    p(x,y) = \u2211_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\n    Key properties:\n    1. Bivariate polynomial evaluation using HermiteE basis\n    2. Mathematical correctness and linearity properties\n    3. Point-wise evaluation for corresponding (x,y) pairs\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeval2d {n m : Nat} (x y : Vector Float n) (c : Vector (Vector Float m) n) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermeval2d_spec {n m : Nat} (x y : Vector Float n) (c : Vector (Vector Float m) n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermeval2d x y c\n    \u2983\u21d3result => \u231c-- Mathematical correctness: Each result point follows bivariate HermiteE evaluation\n                 (\u2200 k : Fin n, \n                   \u2203 hermite_basis : Nat \u2192 Float \u2192 Float,\n                   -- Base cases for HermiteE polynomials\n                   (\u2200 t : Float, hermite_basis 0 t = 1) \u2227\n                   (m > 0 \u2192 \u2200 t : Float, hermite_basis 1 t = t) \u2227\n                   -- Recurrence relation: He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)\n                   (\u2200 i : Nat, i + 1 < m \u2192 \u2200 t : Float, \n                     hermite_basis (i + 2) t = t * hermite_basis (i + 1) t - Float.ofNat (i + 1) * hermite_basis i t) \u2227\n                   -- The result is the bivariate polynomial evaluation  \n                   result.get k = \n                     (List.range n).foldl (fun acc i =>\n                       acc + (List.range m).foldl (fun acc_inner j =>\n                         acc_inner + (c.get \u27e8i, sorry\u27e9).get \u27e8j, sorry\u27e9 * \n                         hermite_basis i (x.get k) * hermite_basis j (y.get k)\n                       ) 0\n                     ) 0) \u2227\n                 -- Linearity in coefficients: Evaluating \u03b1c\u2081 + \u03b2c\u2082 = \u03b1\u00b7eval(c\u2081) + \u03b2\u00b7eval(c\u2082)\n                 (\u2200 \u03b1 \u03b2 : Float, \u2200 c1 c2 : Vector (Vector Float m) n,\n                   \u2203 result1 result2 result_combined : Vector Float n,\n                   -- Individual evaluations\n                   hermeval2d x y c1 = pure result1 \u2227\n                   hermeval2d x y c2 = pure result2 \u2227\n                   -- Combined coefficient matrix\n                   (\u2203 c_combined : Vector (Vector Float m) n,\n                     (\u2200 i : Fin n, \u2200 j : Fin m, (c_combined.get i).get j = \u03b1 * (c1.get i).get j + \u03b2 * (c2.get i).get j) \u2227\n                     hermeval2d x y c_combined = pure result_combined \u2227\n                     \u2200 k : Fin n, result_combined.get k = \u03b1 * result1.get k + \u03b2 * result2.get k)) \u2227\n                 -- Bilinearity: Polynomial evaluation is linear in both x and y coordinates\n                 (\u2200 \u03b1 \u03b2 : Float, \u2200 x1 x2 y1 y2 : Vector Float n,\n                   \u2203 result_x1y1 result_x2y1 result_x1y2 result_combined_x result_combined_y : Vector Float n,\n                   -- Base evaluations\n                   hermeval2d x1 y1 c = pure result_x1y1 \u2227\n                   hermeval2d x2 y1 c = pure result_x2y1 \u2227\n                   hermeval2d x1 y2 c = pure result_x1y2 \u2227\n                   -- Linear combination in x direction\n                   (\u2203 x_combined : Vector Float n,\n                     (\u2200 i : Fin n, x_combined.get i = \u03b1 * x1.get i + \u03b2 * x2.get i) \u2227\n                     hermeval2d x_combined y1 c = pure result_combined_x \u2227\n                     \u2200 k : Fin n, result_combined_x.get k = \u03b1 * result_x1y1.get k + \u03b2 * result_x2y1.get k) \u2227\n                   -- Linear combination in y direction\n                   (\u2203 y_combined : Vector Float n,\n                     (\u2200 i : Fin n, y_combined.get i = \u03b1 * y1.get i + \u03b2 * y2.get i) \u2227\n                     hermeval2d x1 y_combined c = pure result_combined_y \u2227\n                     \u2200 k : Fin n, result_combined_y.get k = \u03b1 * result_x1y1.get k + \u03b2 * result_x1y2.get k)) \u2227\n                 -- Special case properties for verification\n                 (m > 0 \u2227 n > 0 \u2192 \n                   -- Zero coefficient matrix gives zero polynomial\n                   (\u2203 zero_coeff : Vector (Vector Float m) n,\n                     (\u2200 i : Fin n, \u2200 j : Fin m, (zero_coeff.get i).get j = 0) \u2227\n                     \u2203 zero_result : Vector Float n,\n                     hermeval2d x y zero_coeff = pure zero_result \u2227\n                     \u2200 k : Fin n, zero_result.get k = 0) \u2227\n                   -- Constant polynomial (c\u2080\u2080 = 1, all others = 0)\n                   (\u2203 const_coeff : Vector (Vector Float m) n,\n                     (const_coeff.get \u27e80, sorry\u27e9).get \u27e80, sorry\u27e9 = 1 \u2227\n                     (\u2200 i : Fin n, \u2200 j : Fin m, (i.val \u2260 0 \u2228 j.val \u2260 0) \u2192 (const_coeff.get i).get j = 0) \u2227\n                     \u2203 const_result : Vector Float n,\n                     hermeval2d x y const_coeff = pure const_result \u2227\n                     \u2200 k : Fin n, const_result.get k = 1))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermevander", "vc-description": "/-  numpy.polynomial.hermite_e.hermevander: Pseudo-Vandermonde matrix of given degree.\n\n    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points\n    `x`. The pseudo-Vandermonde matrix is defined by\n\n    .. math:: V[..., i] = He_i(x),\n\n    where ``0 <= i <= deg``. The leading indices of `V` index the elements of\n    `x` and the last index is the degree of the HermiteE polynomial.\n\n    If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the\n    array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and\n    ``hermeval(x, c)`` are the same up to roundoff. This equivalence is\n    useful both for least squares fitting and for the evaluation of a large\n    number of HermiteE series of the same degree and sample points.\n\n    Parameters\n    ----------\n    x : array_like\n        Array of points. The dtype is converted to float64 or complex128\n        depending on whether any of the elements are complex. If `x` is\n        scalar it is converted to a 1-D array.\n    deg : int\n        Degree of the resulting matrix.\n\n    Returns\n    -------\n    vander : ndarray\n        The pseudo-Vandermonde matrix. The shape of the returned matrix is\n        ``x.shape + (deg + 1,)``, where The last index is the degree of the\n        corresponding HermiteE polynomial.  The dtype will be the same as\n        the converted `x`.\n-/\n\n/-  Specification: hermevander returns a pseudo-Vandermonde matrix where each row\n    corresponds to a point in x, and each column corresponds to a HermiteE polynomial\n    of degree 0 through deg evaluated at that point.\n\n    The HermiteE polynomials (also called probabilist's Hermite polynomials) are\n    defined by the recurrence relation:\n    - He_0(x) = 1\n    - He_1(x) = x  \n    - He_n(x) = x * He_{n-1}(x) - (n-1) * He_{n-2}(x)\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: \n    1. The matrix has shape (n, deg + 1)\n    2. For each row i and column j, V[i][j] = He_j(x[i])\n    3. First column is all ones (He_0(x) = 1)\n    4. Second column equals x (He_1(x) = x) when deg > 0\n    5. Subsequent columns follow the HermiteE recurrence relation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermevander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry", "vc-theorems": "theorem hermevander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    hermevander x deg\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- First column is all ones (He_0(x) = 1)\n      (result.get i).get \u27e80, Nat.zero_lt_succ deg\u27e9 = 1 \u2227\n\n      -- Second column equals x when deg > 0 (He_1(x) = x)\n      (deg > 0 \u2192 \u2203 h : 1 < deg + 1, (result.get i).get \u27e81, h\u27e9 = x.get i) \u2227\n\n      -- For j \u2265 2: He_j(x) = x * He_{j-1}(x) - (j-1) * He_{j-2}(x)\n      (\u2200 j : Fin (deg + 1), j.val \u2265 2 \u2192 \n        \u2203 (h1 : j.val - 1 < deg + 1) (h2 : j.val - 2 < deg + 1),\n        (result.get i).get j = \n          x.get i * (result.get i).get \u27e8j.val - 1, h1\u27e9 - \n          (Float.ofNat (j.val - 1)) * (result.get i).get \u27e8j.val - 2, h2\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermevander2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.hermevander2d\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Pseudo-Vandermonde matrix of given degrees.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermevander2d.html\",\n  \"doc\": \"Pseudo-Vandermonde matrix of given degrees.\\n\\n    Returns the pseudo-Vandermonde matrix of degrees \\`deg\\` and sample\\n    points \\`\\`(x, y)\\`\\`. The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),\\n\\n    where \\`\\`0 <= i <= deg[0]\\`\\` and \\`\\`0 <= j <= deg[1]\\`\\`. The leading indices of\\n    \\`V\\` index the points \\`\\`(x, y)\\`\\` and the last index encodes the degrees of\\n    the HermiteE polynomials.\\n\\n    If \\`\\`V = hermevander2d(x, y, [xdeg, ydeg])\\`\\`, then the columns of \\`V\\`\\n    correspond to the elements of a 2-D coefficient array \\`c\\` of shape\\n    (xdeg + 1, ydeg + 1) in the order\\n\\n    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...\\n\\n    and \\`\\`np.dot(V, c.flat)\\`\\` and \\`\\`hermeval2d(x, y, c)\\`\\` will be the same\\n    up to roundoff. This equivalence is useful both for least squares\\n    fitting and for the evaluation of a large number of 2-D HermiteE\\n    series of the same degrees and sample points.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like\\n        Arrays of point coordinates, all of the same shape. The dtypes\\n        will be converted to either float64 or complex128 depending on\\n        whether any of the elements are complex. Scalars are converted to\\n        1-D arrays.\\n    deg : list of ints\\n        List of maximum degrees of the form [x_deg, y_deg].\\n\\n    Returns\\n    -------\\n    vander2d : ndarray\\n        The shape of the returned matrix is \\`\\`x.shape + (order,)\\`\\`, where\\n        :math:\\`order = (deg[0]+1)*(deg[1]+1)\\`.  The dtype will be the same\\n        as the converted \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermevander, hermevander3d, hermeval2d, hermeval3d\",\n}\n-/\n\n/-  Pseudo-Vandermonde matrix of given degrees for 2D HermiteE polynomials.\n\n    Returns the pseudo-Vandermonde matrix of degrees (x_deg, y_deg) and sample\n    points (x, y). The matrix is defined by:\n    V[..., (y_deg + 1)*i + j] = He_i(x) * He_j(y)\n    where 0 <= i <= x_deg and 0 <= j <= y_deg.\n-/\n\n/-  Specification: hermevander2d constructs a 2D pseudo-Vandermonde matrix for HermiteE polynomials.\n\n    This function creates a matrix where each row corresponds to a point (x[k], y[k]) and\n    each column corresponds to a basis function He_i(x) * He_j(y).\n\n    Mathematical properties:\n    1. Matrix structure: V[point_idx, basis_idx] = He_i(x[point_idx]) * He_j(y[point_idx])\n    2. Basis ordering: basis_idx = (y_deg + 1) * i + j for degrees (i, j)\n    3. Equivalence with hermeval2d: V \u00b7 c.flat \u2248 hermeval2d(x, y, c)\n    4. Orthogonality properties from HermiteE basis functions\n    5. Polynomial fitting capability: least squares via V^T V c = V^T y\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermevander2d {n : Nat} (x y : Vector Float n) (x_deg y_deg : Nat) : \n    Id (Vector (Vector Float ((x_deg + 1) * (y_deg + 1))) n) :=\n  sorry", "vc-theorems": "theorem hermevander2d_spec {n : Nat} (x y : Vector Float n) (x_deg y_deg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    hermevander2d x y x_deg y_deg\n    \u2983\u21d3result => \u231c-- Matrix dimensions are correct\n                 (\u2200 point_idx : Fin n, \n                   -- Each row has the correct number of basis functions\n                   (result.get point_idx).size = (x_deg + 1) * (y_deg + 1)) \u2227\n                 -- Matrix entries follow the HermiteE basis structure\n                 (\u2203 hermite_basis : Nat \u2192 Float \u2192 Float,\n                   -- Base cases for HermiteE polynomials\n                   (\u2200 t : Float, hermite_basis 0 t = 1) \u2227\n                   (\u2200 t : Float, hermite_basis 1 t = t) \u2227\n                   -- Recurrence relation: He_{k+1}(x) = x * He_k(x) - k * He_{k-1}(x)\n                   (\u2200 k : Nat, k \u2265 1 \u2192 k < max x_deg y_deg \u2192 \u2200 t : Float, \n                     hermite_basis (k + 1) t = t * hermite_basis k t - Float.ofNat k * hermite_basis (k - 1) t) \u2227\n                   -- Matrix entries computed correctly using basis functions\n                   (\u2200 point_idx : Fin n, \u2200 basis_idx : Fin ((x_deg + 1) * (y_deg + 1)),\n                     -- Extract degree indices from basis index\n                     \u2203 i j : Nat, i \u2264 x_deg \u2227 j \u2264 y_deg \u2227 \n                     basis_idx.val = (y_deg + 1) * i + j \u2227\n                     -- Matrix entry is the product of HermiteE basis functions\n                     (result.get point_idx).get basis_idx = \n                       hermite_basis i (x.get point_idx) * hermite_basis j (y.get point_idx))) \u2227\n                 -- Polynomial evaluation equivalence property exists\n                 (\u2200 coeff_matrix : Vector (Vector Float (y_deg + 1)) (x_deg + 1),\n                   \u2203 flattened_coeff : Vector Float ((x_deg + 1) * (y_deg + 1)),\n                   -- Coefficient flattening follows row-major order\n                   (\u2200 i : Fin (x_deg + 1), \u2200 j : Fin (y_deg + 1),\n                     flattened_coeff.get \u27e8(y_deg + 1) * i.val + j.val, sorry\u27e9 = \n                     (coeff_matrix.get i).get j) \u2227\n                   -- Matrix-vector multiplication gives polynomial evaluation\n                   \u2200 point_idx : Fin n,\n                   (List.range ((x_deg + 1) * (y_deg + 1))).foldl (fun acc k =>\n                     acc + (result.get point_idx).get \u27e8k, sorry\u27e9 * flattened_coeff.get \u27e8k, sorry\u27e9\n                   ) 0 = \n                   -- Equivalent to direct 2D polynomial evaluation  \n                   (List.range (x_deg + 1)).foldl (fun acc_i i =>\n                     acc_i + (List.range (y_deg + 1)).foldl (fun acc_j j =>\n                       acc_j + (coeff_matrix.get \u27e8i, sorry\u27e9).get \u27e8j, sorry\u27e9 * \n                       -- Note: hermite_basis exists from above, this is evaluation at point\n                       1.0  -- Placeholder for correct hermite evaluation\n                     ) 0\n                   ) 0) \u2227\n                 -- Vandermonde matrix properties for polynomial fitting\n                 (n \u2265 (x_deg + 1) * (y_deg + 1) \u2192 \n                   -- Full rank condition for overdetermined systems\n                   \u2203 rank_val : Nat, rank_val = (x_deg + 1) * (y_deg + 1) \u2227\n                   -- Matrix has full column rank for unique least squares solution\n                   True) \u2227\n                 -- Basic symmetry when degrees are equal\n                 (x_deg = y_deg \u2192 \n                   \u2200 point_idx : Fin n, \u2200 i j : Nat, i \u2264 x_deg \u2192 j \u2264 y_deg \u2192\n                   \u2203 basis_idx1 basis_idx2 : Fin ((x_deg + 1) * (y_deg + 1)),\n                   basis_idx1.val = (y_deg + 1) * i + j \u2227\n                   basis_idx2.val = (y_deg + 1) * j + i \u2227\n                   -- Swapping x and y coordinates gives related matrix structure\n                   True) \u2227\n                 -- Orthogonality properties conceptually exist\n                 (\u2200 i1 j1 i2 j2 : Nat, i1 \u2264 x_deg \u2192 j1 \u2264 y_deg \u2192 i2 \u2264 x_deg \u2192 j2 \u2264 y_deg \u2192\n                   -- HermiteE polynomials are orthogonal with Gaussian weight\n                   (i1 \u2260 i2 \u2228 j1 \u2260 j2) \u2192 True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermevander3d", "vc-description": "/-  numpy.polynomial.hermite_e.hermevander3d: Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\n    points `(x, y, z)`. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\n    then the pseudo-Vandermonde matrix is defined by\n\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),\n\n    where `0 <= i <= l`, `0 <= j <= m`, and `0 <= k <= n`. The leading\n    indices of `V` index the points `(x, y, z)` and the last index encodes\n    the degrees of the HermiteE polynomials.\n\n    The HermiteE polynomials (also called probabilist's Hermite polynomials) are\n    defined by the recurrence relation:\n    - He_0(t) = 1\n    - He_1(t) = t  \n    - He_n(t) = t * He_{n-1}(t) - (n-1) * He_{n-2}(t)\n\n    Parameters\n    ----------\n    x, y, z : Vector Float n\n        Arrays of point coordinates, all of the same shape.\n    deg : Vector Nat 3\n        Vector of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n    Returns\n    -------\n    vander3d : Vector (Vector Float order) n\n        The pseudo-Vandermonde matrix where order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1).\n-/\n\n/-  Specification: hermevander3d returns a 3D pseudo-Vandermonde matrix where each row\n    corresponds to a point (x[i], y[i], z[i]), and each column corresponds to a product\n    of HermiteE polynomials He_i(x)*He_j(y)*He_k(z) for various degrees.\n\n    The HermiteE polynomials (also called probabilist's Hermite polynomials) are\n    defined by the recurrence relation:\n    - He_0(t) = 1\n    - He_1(t) = t  \n    - He_n(t) = t * He_{n-1}(t) - (n-1) * He_{n-2}(t)\n\n    The indexing follows the formula:\n    V[p, (m+1)(n+1)i + (n+1)j + k] = He_i(x[p]) * He_j(y[p]) * He_k(z[p])\n    where m = deg[1], n = deg[2], and:\n    - 0 <= i <= deg[0] (x-degree)\n    - 0 <= j <= deg[1] (y-degree)  \n    - 0 <= k <= deg[2] (z-degree)\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: \n    1. The matrix has shape (n, order) where order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)\n    2. Each element V[p][idx] = He_i(x[p]) * He_j(y[p]) * He_k(z[p])\n    3. The column ordering follows the flattened 3D coefficient array pattern\n    4. Base case: V[p][0] = He_0(x[p]) * He_0(y[p]) * He_0(z[p]) = 1 * 1 * 1 = 1\n    5. Mathematical consistency with tensor product structure\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermevander3d {n : Nat} (x y z : Vector Float n) (deg : Vector Nat 3) : \n    Id (Vector (Vector Float ((deg.get \u27e80, by simp\u27e9 + 1) * (deg.get \u27e81, by simp\u27e9 + 1) * (deg.get \u27e82, by simp\u27e9 + 1))) n) :=\n  sorry", "vc-theorems": "theorem hermevander3d_spec {n : Nat} (x y z : Vector Float n) (deg : Vector Nat 3) :\n    \u2983\u231cTrue\u231d\u2984\n    hermevander3d x y z deg\n    \u2983\u21d3result => \u231c\n      let x_deg := deg.get \u27e80, by simp\u27e9\n      let y_deg := deg.get \u27e81, by simp\u27e9\n      let z_deg := deg.get \u27e82, by simp\u27e9\n      let order := (x_deg + 1) * (y_deg + 1) * (z_deg + 1)\n\n      -- Shape property: result has n rows, each with order elements (enforced by types)\n      True \u2227\n\n      -- Base case: first column is all ones (He_0(x)*He_0(y)*He_0(z) = 1*1*1 = 1)\n      (\u2200 p : Fin n, order > 0 \u2192 (result.get p).get \u27e80, by sorry\u27e9 = 1) \u2227\n\n      -- Mathematical consistency: tensor product structure\n      (\u2203 hermite_poly : Nat \u2192 Float \u2192 Float,\n        -- HermiteE polynomial base cases\n        (\u2200 t : Float, hermite_poly 0 t = 1) \u2227\n        (\u2200 t : Float, hermite_poly 1 t = t) \u2227\n        -- HermiteE polynomial recurrence relation\n        (\u2200 k : Nat, k \u2265 2 \u2192 \u2200 t : Float, \n          hermite_poly k t = t * hermite_poly (k-1) t - Float.ofNat (k-1) * hermite_poly (k-2) t) \u2227\n        -- Each matrix element follows the 3D product formula\n        (\u2200 p : Fin n, \u2200 i : Nat, \u2200 j : Nat, \u2200 k : Nat,\n          i \u2264 x_deg \u2192 j \u2264 y_deg \u2192 k \u2264 z_deg \u2192\n          let col_idx := (y_deg + 1) * (z_deg + 1) * i + (z_deg + 1) * j + k\n          col_idx < order \u2192\n          (result.get p).get \u27e8col_idx, by sorry\u27e9 = \n            hermite_poly i (x.get p) * hermite_poly j (y.get p) * hermite_poly k (z.get p))) \u2227\n\n      -- Orthogonality property: HermiteE polynomials are orthogonal with respect to Gaussian weight\n      (\u2200 p : Fin n, \u2200 i\u2081 j\u2081 k\u2081 i\u2082 j\u2082 k\u2082 : Nat,\n        i\u2081 \u2264 x_deg \u2192 j\u2081 \u2264 y_deg \u2192 k\u2081 \u2264 z_deg \u2192\n        i\u2082 \u2264 x_deg \u2192 j\u2082 \u2264 y_deg \u2192 k\u2082 \u2264 z_deg \u2192\n        (i\u2081 \u2260 i\u2082 \u2228 j\u2081 \u2260 j\u2082 \u2228 k\u2081 \u2260 k\u2082) \u2192\n        let col_idx\u2081 := (y_deg + 1) * (z_deg + 1) * i\u2081 + (z_deg + 1) * j\u2081 + k\u2081\n        let col_idx\u2082 := (y_deg + 1) * (z_deg + 1) * i\u2082 + (z_deg + 1) * j\u2082 + k\u2082\n        col_idx\u2081 < order \u2192 col_idx\u2082 < order \u2192\n        -- Different polynomial products are linearly independent\n        (result.get p).get \u27e8col_idx\u2081, by sorry\u27e9 \u2260 (result.get p).get \u27e8col_idx\u2082, by sorry\u27e9 \u2228 \n        x.get p = 0 \u2227 y.get p = 0 \u2227 z.get p = 0) \u2227\n\n      -- Consistency with evaluation: dot product with coefficients equals 3D polynomial evaluation\n      (\u2200 p : Fin n, \u2200 coeff : Vector Float order,\n        \u2203 polynomial_value : Float,\n          -- The dot product of the Vandermonde row with coefficients\n          -- equals the evaluation of the 3D HermiteE polynomial expansion\n          polynomial_value = (List.sum (List.ofFn (fun i : Fin order => (result.get p).get i * coeff.get i)))) \u2227\n\n      -- Parity property: HermiteE polynomials satisfy He_n(-x) = (-1)^n * He_n(x)\n      (\u2203 hermite_poly : Nat \u2192 Float \u2192 Float,\n        (\u2200 k : Nat, k \u2264 max (max x_deg y_deg) z_deg \u2192 \u2200 t : Float,\n          hermite_poly k (-t) = (if k % 2 = 0 then 1 else -1) * hermite_poly k t) \u2227\n        -- This parity property is reflected in the matrix structure\n        (\u2200 p : Fin n, \u2200 i j k : Nat,\n          i \u2264 x_deg \u2192 j \u2264 y_deg \u2192 k \u2264 z_deg \u2192\n          let col_idx := (y_deg + 1) * (z_deg + 1) * i + (z_deg + 1) * j + k\n          col_idx < order \u2192\n          (result.get p).get \u27e8col_idx, by sorry\u27e9 = \n            hermite_poly i (x.get p) * hermite_poly j (y.get p) * hermite_poly k (z.get p)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_hermeweight", "vc-description": "/-  numpy.polynomial.hermite_e.hermeweight: Weight function of the Hermite_e polynomials.\n\n    The weight function is exp(-x\u00b2/2) and the interval of integration is [-\u221e, \u221e].\n    The HermiteE polynomials are orthogonal, but not normalized, with respect to this weight function.\n\n    For each input value x, computes the weight function w(x) = exp(-x\u00b2/2).\n    This is a fundamental weight function used in probabilistic HermiteE polynomial theory.\n\n    Returns an array of the same shape as x, containing the weight function values.\n-/\n\n/-  Specification: hermeweight returns a vector where each element is the HermiteE weight function\n    applied to the corresponding element in x.\n\n    The weight function is mathematically defined as w(x) = exp(-x\u00b2/2).\n\n    Precondition: True (no special preconditions - weight function is defined for all real numbers)\n    Postcondition: For all indices i, result[i] = exp(-x[i]\u00b2/2)\n\n    Mathematical properties:\n    - Weight function is always positive: w(x) > 0 for all x\n    - Weight function is symmetric: w(x) = w(-x)\n    - Weight function achieves maximum at x = 0: w(0) = 1\n    - Weight function approaches 0 as |x| \u2192 \u221e\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermeweight {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermeweight_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermeweight x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.exp (-(x.get i)^2 / 2) \u2227\n                  result.get i > 0 \u2227\n                  (\u2200 j : Fin n, result.get i = result.get j \u2194 Float.abs (x.get i) = Float.abs (x.get j))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_e_poly2herme", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite_e.poly2herme\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"poly2herme(pol)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.poly2herme.html\",\n  \"doc\": \"poly2herme(pol)\\n\\n    Convert a polynomial to a Hermite series.\\n\\n    Convert an array representing the coefficients of a polynomial (relative\\n    to the \\\"standard\\\" basis) ordered from lowest degree to highest, to an\\n    array of the coefficients of the equivalent Hermite series, ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    pol : array_like\\n        1-D array containing the polynomial coefficients\\n\\n    Returns\\n    -------\\n    c : ndarray\\n        1-D array containing the coefficients of the equivalent Hermite\\n        series.\\n\\n    See Also\\n    --------\\n    herme2poly\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial.hermite_e import poly2herme\\n    >>> poly2herme(np.arange(4))\\n    array([  2.,  10.,   2.,   3.])\",\n}\n-/\n\n/-  Convert a polynomial to a Hermite series. \n    Converts coefficients from standard polynomial basis to Hermite series basis.\n    Uses Horner's method with Hermite operations: for polynomial p(x) = a\u2099x\u207f + ... + a\u2081x + a\u2080,\n    builds the equivalent Hermite series by iteratively applying hermeadd(hermemulx(result), coefficient).\n-/\n\n/-  Specification: poly2herme converts polynomial coefficients to equivalent Hermite series coefficients.\n\n    The conversion preserves the polynomial's mathematical value but represents it in the Hermite basis.\n    This is a fundamental basis transformation in polynomial algebra.\n\n    Key mathematical properties:\n    1. Basis transformation: standard polynomial basis {1, x, x\u00b2, x\u00b3, ...} \u2192 Hermite basis {He\u2080, He\u2081, He\u2082, He\u2083, ...}\n    2. Value preservation: \u2211\u1d62 pol\u1d62\u00b7x\u2071 = \u2211\u1d62 result\u1d62\u00b7He\u1d62(x) for all x\n    3. Degree preservation: polynomial of degree n maps to Hermite series of degree n\n    4. Invertibility: conversion can be reversed with herme2poly\n    5. Horner's method: algorithm uses iterative structure for numerical stability\n\n    The algorithm implements: result = hermeadd(hermemulx(previous_result), current_coefficient)\n    applied from highest to lowest degree coefficients.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def poly2herme {n : Nat} (pol : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem poly2herme_spec {n : Nat} (pol : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    poly2herme pol\n    \u2983\u21d3result => \u231c-- Basis transformation property: result has same length as input\n                  result.toList.length = pol.toList.length \u2227\n                  -- Degree preservation: the effective degree is preserved\n                  (\u2200 i : Fin n, pol.get i \u2260 0 \u2192 \u2203 j : Fin n, result.get j \u2260 0) \u2227\n                  -- Non-trivial transformation: for non-zero polynomials, transformation is meaningful\n                  (\u2203 i : Fin n, pol.get i \u2260 0) \u2192 (\u2203 j : Fin n, result.get j \u2260 0) \u2227\n                  -- Linearity property: transformation is linear in coefficients\n                  (\u2200 \u03b1 : Float, \u2200 i : Fin n, \n                    -- This represents that scaling input scales output proportionally\n                    (\u2200 pol' : Vector Float n, (\u2200 k : Fin n, pol'.get k = \u03b1 * pol.get k) \u2192 \n                      \u2203 result' : Vector Float n, (\u2200 k : Fin n, result'.get k = \u03b1 * result.get k))) \u2227\n                  -- Mathematical soundness: conversion preserves polynomial evaluation structure\n                  -- This property ensures the Hermite series represents the same mathematical function\n                  (\u2200 hermite_basis : Nat \u2192 Float \u2192 Float,\n                    -- Given the standard Hermite basis functions\n                    (\u2200 x : Float, hermite_basis 0 x = 1) \u2227\n                    (n > 0 \u2192 \u2200 x : Float, hermite_basis 1 x = x) \u2227\n                    (\u2200 k : Nat, k + 1 < n \u2192 \u2200 x : Float, \n                      hermite_basis (k + 2) x = x * hermite_basis (k + 1) x - Float.ofNat (k + 1) * hermite_basis k x) \u2192\n                    -- The transformed coefficients define the same polynomial function\n                    \u2203 evaluation_equivalence : Float \u2192 Float,\n                      (\u2200 x : Float, evaluation_equivalence x = \n                        (List.range n).foldl (fun acc i => acc + pol.get \u27e8i, sorry\u27e9 * (Float.pow x (Float.ofNat i))) 0) \u2227\n                      (\u2200 x : Float, evaluation_equivalence x = \n                        (List.range n).foldl (fun acc i => acc + result.get \u27e8i, sorry\u27e9 * hermite_basis i x) 0)) \u2227\n                  -- Horner's method structural property: algorithm applies operations in correct order\n                  (\u2200 intermediate_results : List (Vector Float n), \n                    -- The algorithm builds result iteratively through hermeadd and hermemulx operations\n                    intermediate_results.length = n \u2192\n                    \u2203 construction_valid : Bool, construction_valid = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_herm2poly", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.herm2poly\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Convert a Hermite series to a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.herm2poly.html\",\n  \"doc\": \"Convert a Hermite series to a polynomial.\\n\\n    Convert an array representing the coefficients of a Hermite series,\\n    ordered from lowest degree to highest, to an array of the coefficients\\n    of the equivalent polynomial (relative to the \\\"standard\\\" basis) ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array containing the Hermite series coefficients, ordered\\n        from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    pol : ndarray\\n        1-D array containing the coefficients of the equivalent polynomial\\n        (relative to the \\\"standard\\\" basis) ordered from lowest order term\\n        to highest.\\n\\n    See Also\\n    --------\\n    poly2herm\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import herm2poly\\n    >>> herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\\n    array([0., 1., 2., 3.])\",\n}\n-/\n\n/-  Convert a Hermite series to a polynomial.\n    Converts coefficients of a Hermite series (ordered from lowest to highest degree)\n    to coefficients of the equivalent standard polynomial (ordered from lowest to highest degree).\n\n    The Hermite polynomials H_n(x) satisfy the recurrence relation:\n    H_{n+1}(x) = 2x * H_n(x) - 2n * H_{n-1}(x)\n    with H_0(x) = 1 and H_1(x) = 2x\n\n    This function performs the inverse transformation, converting from Hermite basis to standard basis. -/\n\n/-  Specification: herm2poly converts Hermite series coefficients to standard polynomial coefficients.\n\n    The conversion satisfies:\n    1. The output has the same length as the input\n    2. For n=1 (constant), the output equals the input\n    3. For n=2, the second coefficient is doubled (since H_1(x) = 2x)\n    4. The conversion algorithm follows the recurrence relation for Hermite polynomials\n    5. Special example: herm2poly([1, 2.75, 0.5, 0.375]) = [0, 1, 2, 3]\n    6. The conversion preserves basis transformation properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def herm2poly {n : Nat} (c : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem herm2poly_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    herm2poly c\n    \u2983\u21d3result => \u231c\n      -- Sanity checks\n      (n = 1 \u2192 result = c) \u2227\n      (n = 2 \u2192 result.get \u27e80, sorry\u27e9 = c.get \u27e80, sorry\u27e9 \u2227 \n               result.get \u27e81, sorry\u27e9 = 2 * c.get \u27e81, sorry\u27e9) \u2227\n      -- Example from documentation\n      (n = 4 \u2227 c.get \u27e80, sorry\u27e9 = 1 \u2227 c.get \u27e81, sorry\u27e9 = 2.75 \u2227 \n       c.get \u27e82, sorry\u27e9 = 0.5 \u2227 c.get \u27e83, sorry\u27e9 = 0.375 \u2192\n       result.get \u27e80, sorry\u27e9 = 0 \u2227 result.get \u27e81, sorry\u27e9 = 1 \u2227\n       result.get \u27e82, sorry\u27e9 = 2 \u2227 result.get \u27e83, sorry\u27e9 = 3) \u2227\n      -- Mathematical property: The transformation is invertible\n      -- There exists poly2herm such that poly2herm(herm2poly(c)) = c\n      (\u2203 poly2herm : Vector Float n \u2192 Vector Float n, \n        poly2herm result = c)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermadd", "vc-description": "/-  numpy.polynomial.hermite.hermadd: Add one Hermite series to another.\n\n    Returns the sum of two Hermite series c1 + c2. The arguments are\n    sequences of coefficients ordered from lowest order term to highest,\n    i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\n    Unlike multiplication, division, etc., the sum of two Hermite series\n    is a Hermite series (without having to \"reproject\" the result onto\n    the basis set) so addition, just like that of \"standard\" polynomials,\n    is simply \"component-wise.\"\n\n    This version handles adding two Hermite coefficient vectors where the\n    result length is the maximum of the input lengths. Shorter vectors are\n    implicitly padded with zeros.\n-/\n\n/-  Specification: hermadd performs component-wise addition of Hermite series coefficients.\n\n    Precondition: True (no special preconditions for basic addition)\n    Postcondition: \n    - If i < min(n,m), result[i] = c1[i] + c2[i]\n    - If min(n,m) \u2264 i < n, result[i] = c1[i] (c2 is treated as 0)\n    - If min(n,m) \u2264 i < m, result[i] = c2[i] (c1 is treated as 0)\n\n    The mathematical property: The i-th coefficient of the sum is the sum of\n    the i-th coefficients of the input series, treating missing coefficients as 0.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : \n    Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem hermadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    hermadd c1 c2\n    \u2983\u21d3result => \u231c\u2200 i : Fin (max n m), \n                  result.get i = \n                    if h1 : i.val < n then\n                      if h2 : i.val < m then\n                        c1.get \u27e8i.val, h1\u27e9 + c2.get \u27e8i.val, h2\u27e9\n                      else\n                        c1.get \u27e8i.val, h1\u27e9\n                    else\n                      if h2 : i.val < m then\n                        c2.get \u27e8i.val, h2\u27e9\n                      else\n                        0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermcompanion", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermcompanion\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Return the scaled companion matrix of c.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermcompanion.html\",\n  \"doc\": \"Return the scaled companion matrix of c.\\n\\n    The basis polynomials are scaled so that the companion matrix is\\n    symmetric when \\`c\\` is an Hermite basis polynomial. This provides\\n    better eigenvalue estimates than the unscaled case and for basis\\n    polynomials the eigenvalues are guaranteed to be real if\\n    \\`numpy.linalg.eigvalsh\\` is used to obtain them.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Hermite series coefficients ordered from low to high\\n        degree.\\n\\n    Returns\\n    -------\\n    mat : ndarray\\n        Scaled companion matrix of dimensions (deg, deg).\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermcompanion\\n    >>> hermcompanion([1, 0, 1])\\n    array([[0.        , 0.35355339],\\n           [0.70710678, 0.        ]])\",\n}\n-/\n\n/-  Return the scaled companion matrix of Hermite polynomial coefficients.\n    The companion matrix is symmetric when c represents a Hermite basis polynomial. -/\n\n/-  Specification: hermcompanion produces a scaled companion matrix with specific properties.\n    For a coefficient vector of length n+2, the result is an (n+1)\u00d7(n+1) matrix where:\n    1. The super-diagonal and sub-diagonal contain sqrt(k/2) for k = 1 to n\n    2. The last column is adjusted by scaled coefficients\n    3. The matrix is symmetric when c represents a Hermite basis polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermcompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermcompanion_spec {n : Nat} (c : Vector Float (n + 2)) \n    (h_nonzero : c.get \u27e8n + 1, by omega\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n + 1, by omega\u27e9 \u2260 0\u231d\u2984\n    hermcompanion c\n    \u2983\u21d3mat => \u231c\n      -- The matrix has the correct diagonal structure\n      (\u2200 k : Fin n, (mat.get \u27e8k.val, by omega\u27e9).get \u27e8k.val + 1, by omega\u27e9 = \n        Float.sqrt (0.5 * Float.ofNat (k.val + 1))) \u2227\n      (\u2200 k : Fin n, (mat.get \u27e8k.val + 1, by omega\u27e9).get \u27e8k.val, by omega\u27e9 = \n        Float.sqrt (0.5 * Float.ofNat (k.val + 1))) \u2227\n      -- All other entries except last column are zero\n      (\u2200 i j : Fin (n + 1), \n        (i.val + 1 \u2260 j.val \u2227 j.val + 1 \u2260 i.val \u2227 j.val \u2260 n) \u2192 \n        (mat.get i).get j = 0) \u2227\n      -- Last column has special scaling based on coefficients\n      (\u2200 i : Fin (n + 1), \n        \u2203 scale : Float, (mat.get i).get \u27e8n, by omega\u27e9 = \n          if i.val + 1 = n \u2228 i.val = n + 1 then\n            Float.sqrt (0.5 * Float.ofNat n) - scale * c.get \u27e8i.val, by omega\u27e9 / (2.0 * c.get \u27e8n + 1, by omega\u27e9)\n          else\n            - scale * c.get \u27e8i.val, by omega\u27e9 / (2.0 * c.get \u27e8n + 1, by omega\u27e9))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermder", "vc-description": "/-  Differentiate a Hermite series.\n    Returns the Hermite series coefficients differentiated `m` times.\n    At each iteration the result is multiplied by `scl` (scaling factor).\n    The coefficients are from low to high degree. -/\n\n/-  Specification: hermder differentiates Hermite series coefficients according to\n    the Hermite polynomial derivative rule: d/dx H_n(x) = 2n * H_{n-1}(x).\n    The result has degree reduced by m (or becomes zero if m >= n).\n    Each differentiation multiplies by the scaling factor scl. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermder {n : Nat} (c : Vector Float n) (m : Nat := 1) (scl : Float := 1.0) : \n    Id (Vector Float (n - min m n)) :=\n  sorry", "vc-theorems": "theorem hermder_spec {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    hermder c m scl\n    \u2983\u21d3result => \u231c\n      -- Basic size property: output size is n - min(m, n)\n      result.size = n - min m n \u2227\n      -- Case 1: Single differentiation (m = 1)\n      (m = 1 \u2227 n > 0 \u2192 \n        \u2200 i : Fin (n - 1), \n          -- For Hermite polynomials: d/dx H_j(x) = 2j * H_{j-1}(x)\n          -- So the i-th coefficient (degree i) comes from the (i+1)-th coefficient\n          -- multiplied by 2*(i+1) and the scaling factor\n          result.get \u27e8i.val, sorry\u27e9 = scl * (2.0 * (i.val + 1 : Nat).toFloat) * c.get \u27e8i.val + 1, sorry\u27e9) \u2227\n      -- Case 2: Over-differentiation (m \u2265 n) gives empty vector\n      (m \u2265 n \u2192 result.size = 0) \u2227\n      -- Mathematical property: The operation reduces the degree by exactly m\n      (m < n \u2192 result.size = n - m) \u2227\n      -- Mathematical property: Each differentiation applies the Hermite derivative rule\n      -- For multiple differentiations, the pattern compounds\n      (m = 2 \u2227 n > 1 \u2192 \n        \u2200 i : Fin (n - 2),\n          -- Second derivative: apply the rule twice\n          -- d\u00b2/dx\u00b2 H_j(x) = d/dx (2j * H_{j-1}(x)) = 2j * 2(j-1) * H_{j-2}(x)\n          result.get \u27e8i.val, sorry\u27e9 = \n            scl * scl * (2.0 * (i.val + 2 : Nat).toFloat) * (2.0 * (i.val + 1 : Nat).toFloat) * \n            c.get \u27e8i.val + 2, sorry\u27e9)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermdiv", "vc-description": "/-  Divide one Hermite series by another.\n\n    Returns the quotient-with-remainder of two Hermite series\n    c1 / c2. The arguments are sequences of coefficients from lowest\n    order term to highest, e.g., [1,2,3] represents the series\n    P_0 + 2*P_1 + 3*P_2.\n\n    Parameters:\n    - c1: 1-D array of Hermite series coefficients (dividend)\n    - c2: 1-D array of Hermite series coefficients (divisor)\n\n    Returns:\n    - (quo, rem): Pair of arrays representing quotient and remainder\n-/\n\n/-  Specification: hermdiv divides Hermite series c1 by c2, producing quotient and remainder\n    such that c1 = c2 * quo + rem in the Hermite polynomial basis, where the degree of rem\n    is less than the degree of c2. The divisor must have at least one non-zero coefficient. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermdiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) (h : m > 0) : \n    Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermdiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) (h : m > 0)\n    (h_nonzero : \u2203 i : Fin m, c2.get i \u2260 0) :\n    \u2983\u231cm > 0 \u2227 \u2203 i : Fin m, c2.get i \u2260 0\u231d\u2984\n    hermdiv c1 c2 h\n    \u2983\u21d3result => \u231clet (quo, rem) := result\n                -- The remainder has all coefficients zero or its effective degree is less than c2's\n                (\u2200 i : Fin n, rem.get i = 0) \u2228 \n                (\u2203 k : Fin n, (\u2200 j : Fin n, j \u2265 k \u2192 rem.get j = 0) \u2227\n                              (k < m \u2228 m > n))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermfit", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermfit\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Least squares fit of Hermite series to data.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermfit.html\",\n  \"doc\": \"Least squares fit of Hermite series to data.\\n\\n    Return the coefficients of a Hermite series of degree \\`deg\\` that is the\\n    least squares fit to the data values \\`y\\` given at points \\`x\\`. If \\`y\\` is\\n    1-D the returned coefficients will also be 1-D. If \\`y\\` is 2-D multiple\\n    fits are done, one for each column of \\`y\\`, and the resulting\\n    coefficients are stored in the corresponding columns of a 2-D return.\\n    The fitted polynomial(s) are in the form\\n\\n    .. math::  p(x) = c_0 + c_1 * H_1(x) + ... + c_n * H_n(x),\\n\\n    where \\`n\\` is \\`deg\\`.\\n\\n    Parameters\\n    ----------\\n    x : array_like, shape (M,)\\n        x-coordinates of the M sample points \\`\\`(x[i], y[i])\\`\\`.\\n    y : array_like, shape (M,) or (M, K)\\n        y-coordinates of the sample points. Several data sets of sample\\n        points sharing the same x-coordinates can be fitted at once by\\n        passing in a 2D-array that contains one dataset per column.\\n    deg : int or 1-D array_like\\n        Degree(s) of the fitting polynomials. If \\`deg\\` is a single integer\\n        all terms up to and including the \\`deg\\`'th term are included in the\\n        fit. For NumPy versions >= 1.11.0 a list of integers specifying the\\n        degrees of the terms to include may be used instead.\\n    rcond : float, optional\\n        Relative condition number of the fit. Singular values smaller than\\n        this relative to the largest singular value will be ignored. The\\n        default value is len(x)*eps, where eps is the relative precision of\\n        the float type, about 2e-16 in most cases.\\n    full : bool, optional\\n        Switch determining nature of return value. When it is False (the\\n        default) just the coefficients are returned, when True diagnostic\\n        information from the singular value decomposition is also returned.\\n    w : array_like, shape (\\`M\\`,), optional\\n        Weights. If not None, the weight \\`\\`w[i]\\`\\` applies to the unsquared\\n        residual \\`\\`y[i] - y_hat[i]\\`\\` at \\`\\`x[i]\\`\\`. Ideally the weights are\\n        chosen so that the errors of the products \\`\\`w[i]*y[i]\\`\\` all have the\\n        same variance.  When using inverse-variance weighting, use\\n        \\`\\`w[i] = 1/sigma(y[i])\\`\\`.  The default value is None.\\n\\n    Returns\\n    -------\\n    coef : ndarray, shape (M,) or (M, K)\\n        Hermite coefficients ordered from low to high. If \\`y\\` was 2-D,\\n        the coefficients for the data in column k  of \\`y\\` are in column\\n        \\`k\\`.\\n\\n    [residuals, rank, singular_values, rcond] : list\\n        These values are only returned if \\`\\`full == True\\`\\`\\n\\n        - residuals -- sum of squared residuals of the least squares fit\\n        - rank -- the numerical rank of the scaled Vandermonde matrix\\n        - singular_values -- singular values of the scaled Vandermonde matrix\\n        - rcond -- value of \\`rcond\\`.\\n\\n        For more details, see \\`numpy.linalg.lstsq\\`.\\n\\n    Warns\\n    -----\\n    RankWarning\\n        The rank of the coefficient matrix in the least-squares fit is\\n        deficient. The warning is only raised if \\`\\`full == False\\`\\`.  The\\n        warnings can be turned off by\\n\\n        >>> import warnings\\n        >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\\n\\n    See Also\\n    --------\\n    numpy.polynomial.chebyshev.chebfit\\n    numpy.polynomial.legendre.legfit\\n    numpy.polynomial.laguerre.lagfit\\n    numpy.polynomial.polynomial.polyfit\\n    numpy.polynomial.hermite_e.hermefit\\n    hermval : Evaluates a Hermite series.\\n    hermvander : Vandermonde matrix of Hermite series.\\n    hermweight : Hermite weight function\\n    numpy.linalg.lstsq : Computes a least-squares fit from the matrix.\\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\\n\\n    Notes\\n    -----\\n    The solution is the coefficients of the Hermite series \\`p\\` that\\n    minimizes the sum of the weighted squared errors\\n\\n    .. math:: E = \\\\\\\\sum_j w_j^2 * |y_j - p(x_j)|^2,\\n\\n    where the :math:\\`w_j\\` are the weights. This problem is solved by\\n    setting up the (typically) overdetermined matrix equation\\n\\n    .. math:: V(x) * c = w * y,\\n\\n    where \\`V\\` is the weighted pseudo Vandermonde matrix of \\`x\\`, \\`c\\` are the\\n    coefficients to be solved for, \\`w\\` are the weights, \\`y\\` are the\\n    observed values.  This equation is then solved using the singular value\\n    decomposition of \\`V\\`.\\n\\n    If some of the singular values of \\`V\\` are so small that they are\\n    neglected, then a \\`~exceptions.RankWarning\\` will be issued. This means that\\n    the coefficient values may be poorly determined. Using a lower order fit\\n    will usually get rid of the warning.  The \\`rcond\\` parameter can also be\\n    set to a value smaller than its default, but the resulting fit may be\\n    spurious and have large contributions from roundoff error.\\n\\n    Fits using Hermite series are probably most useful when the data can be\\n    approximated by \\`\\`sqrt(w(x)) * p(x)\\`\\`, where \\`\\`w(x)\\`\\` is the Hermite\\n    weight. In that case the weight \\`\\`sqrt(w(x[i]))\\`\\` should be used\\n    together with data values \\`\\`y[i]/sqrt(w(x[i]))\\`\\`. The weight function is\\n    available as \\`hermweight\\`.\\n\\n    References\\n    ----------\\n    .. [1] Wikipedia, \\\"Curve fitting\\\",\\n           https://en.wikipedia.org/wiki/Curve_fitting\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial.hermite import hermfit, hermval\\n    >>> x = np.linspace(-10, 10)\\n    >>> rng = np.random.default_rng()\\n    >>> err = rng.normal(scale=1./10, size=len(x))\\n    >>> y = hermval(x, [1, 2, 3]) + err\\n    >>> hermfit(x, y, 2)\\n    array([1.02294967, 2.00016403, 2.99994614]) # may vary\",\n}\n-/\n\n/-  Least squares fit of Hermite series to data. Returns coefficients of a Hermite polynomial\n    that best fits the given data points (x, y) with degree deg. -/\n\n/-  Specification: hermfit returns coefficients that minimize the least squares error\n    for a Hermite polynomial fit of the given degree to the data points -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermfit {m : Nat} (x y : Vector Float m) (deg : Nat) : Id (Vector Float (deg + 1)) :=\n  sorry", "vc-theorems": "theorem hermfit_spec {m : Nat} (x y : Vector Float m) (deg : Nat) (h_m : m > 0) :\n    \u2983\u231cm > 0\u231d\u2984\n    hermfit x y deg\n    \u2983\u21d3coef => \u231c\n      -- The result has the correct size (deg + 1 coefficients)\n      coef.size = deg + 1 \u2227\n      -- Sanity check: coefficients vector is not empty\n      deg + 1 > 0 \u2227\n      -- The coefficients minimize the squared error\n      -- Let H_k(x) be the k-th Hermite polynomial evaluated at x\n      -- The fitted polynomial is p(x) = sum_{k=0}^{deg} coef[k] * H_k(x)\n      -- For a hypothetical hermval function that evaluates Hermite polynomials:\n      -- hermval : Float \u2192 Vector Float n \u2192 Float\n      -- that computes sum_{k=0}^{n-1} coeffs[k] * H_k(x)\n\n      -- The least squares property: for any other coefficient vector c' of the same size,\n      -- the sum of squared errors with coef is less than or equal to that with c'\n      \u2200 c' : Vector Float (deg + 1),\n        -- Assuming we have a hermval function to evaluate Hermite polynomials\n        -- let error_coef := sum_{i=0}^{m-1} (y[i] - hermval(x[i], coef))^2\n        -- let error_c' := sum_{i=0}^{m-1} (y[i] - hermval(x[i], c'))^2\n        -- then error_coef \u2264 error_c'\n\n        -- Mathematical property: The solution satisfies the normal equations\n        -- V^T * V * coef = V^T * y\n        -- where V is the Vandermonde matrix of Hermite polynomials evaluated at x\n\n        -- Additional properties:\n        -- 1. If m \u2265 deg + 1, the fit is unique (assuming full rank)\n        -- 2. If m = deg + 1 and points are distinct, the polynomial interpolates exactly\n        (m = deg + 1 \u2192 \n          -- For interpolation case: the polynomial passes through all points\n          -- \u2200 i : Fin m, hermval(x.get i, coef) = y.get i\n          True) \u2227\n\n        -- 3. The coefficients are real-valued (no complex numbers in this spec)\n        (\u2200 k : Fin (deg + 1), \u00ac(coef.get k).isNaN)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermfromroots", "vc-description": "/-  Generate a Hermite series with given roots.\n\n    Returns the coefficients of the polynomial p(x) = (x - r\u2080) * (x - r\u2081) * ... * (x - r\u2099)\n    in Hermite form. If a zero has multiplicity n, it must appear n times in the roots vector.\n\n    The resulting polynomial is expressed as: p(x) = c\u2080 + c\u2081 * H\u2081(x) + ... + c\u2099 * H\u2099(x)\n    where H\u1d62(x) are Hermite polynomials. -/\n\n/-  Specification: hermfromroots generates Hermite coefficients such that:\n    1. The result has length n+1 where n is the number of roots\n    2. The polynomial has exactly the given roots (when evaluated using Hermite polynomials)\n    3. The leading coefficient is non-zero (for non-empty roots)\n    4. For repeated roots, the multiplicity is preserved -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermfromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermfromroots_spec {n : Nat} (roots : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermfromroots roots\n    \u2983\u21d3coef => \u231c\n      -- The coefficient vector has the correct size (n+1 coefficients for n roots)\n      (coef.size = n + 1) \u2227\n      -- For n > 0, the highest degree coefficient is non-zero\n      (n > 0 \u2192 coef.get \u27e8n, by omega\u27e9 \u2260 0) \u2227\n      -- The polynomial formed by these coefficients has the given roots\n      -- Note: This property requires Hermite polynomial evaluation which we abstract here\n      -- In actual implementation, this would verify that hermval(roots[i], coef) = 0 for all i\n      (\u2200 i : Fin n, \n        -- Abstract property: the Hermite polynomial with these coefficients\n        -- evaluates to zero at each root\n        True  -- Placeholder for: hermval(roots.get i, coef) = 0\n      )\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermgauss", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermgauss\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Gauss-Hermite quadrature.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermgauss.html\",\n  \"doc\": \"Gauss-Hermite quadrature.\\n\\n    Computes the sample points and weights for Gauss-Hermite quadrature.\\n    These sample points and weights will correctly integrate polynomials of\\n    degree :math:\\`2*deg - 1\\` or less over the interval :math:\\`[-\\\\\\\\inf, \\\\\\\\inf]\\`\\n    with the weight function :math:\\`f(x) = \\\\\\\\exp(-x^2)\\`.\\n\\n    Parameters\\n    ----------\\n    deg : int\\n        Number of sample points and weights. It must be >= 1.\\n\\n    Returns\\n    -------\\n    x : ndarray\\n        1-D ndarray containing the sample points.\\n    y : ndarray\\n        1-D ndarray containing the weights.\\n\\n    Notes\\n    -----\\n    The results have only been tested up to degree 100, higher degrees may\\n    be problematic. The weights are determined by using the fact that\\n\\n    .. math:: w_k = c / (H'_n(x_k) * H_{n-1}(x_k))\\n\\n    where :math:\\`c\\` is a constant independent of :math:\\`k\\` and :math:\\`x_k\\`\\n    is the k'th root of :math:\\`H_n\\`, and then scaling the results to get\\n    the right value when integrating 1.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermgauss\\n    >>> hermgauss(2)\\n    (array([-0.70710678,  0.70710678]), array([0.88622693, 0.88622693]))\",\n}\n-/\n\n/-  Computes the sample points and weights for Gauss-Hermite quadrature -/\n\n/-  Specification: hermgauss returns quadrature points and weights that satisfy key properties:\n    1. The points are roots of the deg-th Hermite polynomial\n    2. The weights are positive\n    3. The weights sum to a positive value (specifically sqrt(\u03c0))\n    4. The quadrature exactly integrates polynomials up to degree 2*deg - 1 with weight exp(-x\u00b2)\n    5. Points are symmetric around 0 and are distinct -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermgauss (deg : Nat) (h : deg > 0) : Id (Vector Float deg \u00d7 Vector Float deg) :=\n  sorry", "vc-theorems": "theorem hermgauss_spec (deg : Nat) (h : deg > 0) :\n    \u2983\u231cdeg > 0\u231d\u2984\n    hermgauss deg h\n    \u2983\u21d3result => \u231clet (points, weights) := result\n                 -- All weights are positive\n                 (\u2200 i : Fin deg, weights.get i > 0) \u2227\n                 -- Weights sum to a positive value\n                 (weights.toList.sum > 0) \u2227\n                 -- Points are symmetric around 0 (for each point there's a negative counterpart)\n                 (\u2200 i : Fin deg, \u2203 j : Fin deg, \n                   points.get i = -points.get j) \u2227\n                 -- Points are distinct\n                 (\u2200 i j : Fin deg, i \u2260 j \u2192 points.get i \u2260 points.get j) \u2227\n                 -- For Gauss-Hermite quadrature, the points are sorted\n                 (\u2200 i j : Fin deg, i < j \u2192 points.get i < points.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermint", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermint\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Integrate a Hermite series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermint.html\",\n  \"doc\": \"Integrate a Hermite series.\\n\\n    Returns the Hermite series coefficients \\`c\\` integrated \\`m\\` times from\\n    \\`lbnd\\` along \\`axis\\`. At each iteration the resulting series is\\n    **multiplied** by \\`scl\\` and an integration constant, \\`k\\`, is added.\\n    The scaling factor is for use in a linear change of variable.  (\\\"Buyer\\n    beware\\\": note that, depending on what one is doing, one may want \\`scl\\`\\n    to be the reciprocal of what one might expect; for more information,\\n    see the Notes section below.)  The argument \\`c\\` is an array of\\n    coefficients from low to high degree along each axis, e.g., [1,2,3]\\n    represents the series \\`\\`H_0 + 2*H_1 + 3*H_2\\`\\` while [[1,2],[1,2]]\\n    represents \\`\\`1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +\\n    2*H_1(x)*H_1(y)\\`\\` if axis=0 is \\`\\`x\\`\\` and axis=1 is \\`\\`y\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Hermite series coefficients. If c is multidimensional the\\n        different axis correspond to different variables with the degree in\\n        each axis given by the corresponding index.\\n    m : int, optional\\n        Order of integration, must be positive. (Default: 1)\\n    k : {[], list, scalar}, optional\\n        Integration constant(s).  The value of the first integral at\\n        \\`\\`lbnd\\`\\` is the first value in the list, the value of the second\\n        integral at \\`\\`lbnd\\`\\` is the second value, etc.  If \\`\\`k == []\\`\\` (the\\n        default), all constants are set to zero.  If \\`\\`m == 1\\`\\`, a single\\n        scalar can be given instead of a list.\\n    lbnd : scalar, optional\\n        The lower bound of the integral. (Default: 0)\\n    scl : scalar, optional\\n        Following each integration the result is *multiplied* by \\`scl\\`\\n        before the integration constant is added. (Default: 1)\\n    axis : int, optional\\n        Axis over which the integral is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Hermite series coefficients of the integral.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If \\`\\`m < 0\\`\\`, \\`\\`len(k) > m\\`\\`, \\`\\`np.ndim(lbnd) != 0\\`\\`, or\\n        \\`\\`np.ndim(scl) != 0\\`\\`.\\n\\n    See Also\\n    --------\\n    hermder\\n\\n    Notes\\n    -----\\n    Note that the result of each integration is *multiplied* by \\`scl\\`.\\n    Why is this important to note?  Say one is making a linear change of\\n    variable :math:\\`u = ax + b\\` in an integral relative to \\`x\\`.  Then\\n    :math:\\`dx = du/a\\`, so one will need to set \\`scl\\` equal to\\n    :math:\\`1/a\\` - perhaps not what one would have first thought.\\n\\n    Also note that, in general, the result of integrating a C-series needs\\n    to be \\\"reprojected\\\" onto the C-series basis set.  Thus, typically,\\n    the result of this function is \\\"unintuitive,\\\" albeit correct; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermint\\n    >>> hermint([1,2,3]) # integrate once, value 0 at 0.\\n    array([1. , 0.5, 0.5, 0.5])\\n    >>> hermint([1,2,3], m=2) # integrate twice, value & deriv 0 at 0\\n    array([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\\n    >>> hermint([1,2,3], k=1) # integrate once, value 1 at 0.\\n    array([2. , 0.5, 0.5, 0.5])\\n    >>> hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\\n    array([-2. ,  0.5,  0.5,  0.5])\\n    >>> hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\\n    array([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\",\n}\n-/\n\n/-  Integrate a Hermite series.\n\nReturns the Hermite series coefficients integrated `m` times from `lbnd`.\nAt each iteration the resulting series is multiplied by `scl` and an\nintegration constant from `k` is added. -/\n\n/-  Specification: hermint integrates Hermite series coefficients.\n\nThe specification captures:\n1. The output vector has size n + m (m additional coefficients from integration)\n2. Each integration adds one coefficient to the series\n3. The integration follows Hermite polynomial integration rules\n4. Integration constants from k are applied at each integration step\n5. Results are scaled by scl at each step\n\nFor Hermite polynomials, the integration rule is:\n- \u222b H_n(x) dx = H_{n+1}(x)/(2(n+1)) + constant\n\nMathematical properties:\n- The first coefficient of the result incorporates the integration constant to ensure\n  the integral evaluates to the appropriate value at lbnd\n- For coefficient c[i] representing H_i, integration contributes c[i]/(2*(i+1)) to H_{i+1}\n- The scaling factor scl is applied after each integration step -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermint {n : Nat} (c : Vector Float n) (m : Nat) \n    (k : Vector Float m) (lbnd : Float) (scl : Float) \n    (h_m_pos : m > 0) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem hermint_spec {n : Nat} (c : Vector Float n) (m : Nat) \n    (k : Vector Float m) (lbnd : Float) (scl : Float) \n    (h_m_pos : m > 0) :\n    \u2983\u231cm > 0\u231d\u2984\n    hermint c m k lbnd scl h_m_pos\n    \u2983\u21d3result => \u231c\n      -- For single integration (m = 1), specify the integration rule\n      (m = 1 \u2192 \n        -- The integral of H_i contributes to H_{i+1} with coefficient c[i]/(2*(i+1))\n        -- scaled by scl\n        (\u2200 i : Fin n, i.val > 0 \u2192 \n          \u2203 contribution : Float,\n          contribution = scl * (c.get \u27e8i.val - 1, by omega\u27e9) / (2 * i.val.toFloat) \u2227\n          -- This contribution appears in the result at position i\n          (\u2203 other_terms : Float, result.get \u27e8i.val, by omega\u27e9 = contribution + other_terms)) \u2227\n        -- The first coefficient is adjusted to satisfy the boundary condition at lbnd\n        (\u2203 adjustment : Float, result.get \u27e80, by omega\u27e9 = adjustment))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermline", "vc-description": "/-  Hermite series whose graph is a straight line.\n\n    Creates a Hermite series representation for the line off + scl*x.\n    Returns a 2-element vector where:\n    - First element is the constant term (off)\n    - Second element is the linear coefficient (scl/2)\n\n    Note: When scl = 0, the second element is 0, representing a constant function.\n-/\n\n/-  Specification: hermline returns Hermite coefficients for a linear function.\n\n    The Hermite series representation of off + scl*x has coefficients:\n    - c\u2080 = off (constant term)\n    - c\u2081 = scl/2 (linear term coefficient)\n\n    These coefficients, when evaluated as a Hermite series, produce the \n    original linear function. The relationship comes from the fact that\n    H\u2081(x) = 2x in the physicist's Hermite polynomials.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem hermline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    hermline off scl\n    \u2983\u21d3result => \u231c\n      result.get \u27e80, by decide\u27e9 = off \u2227\n      result.get \u27e81, by decide\u27e9 = scl / 2\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermmul", "vc-description": "/-  numpy.polynomial.hermite.hermmul: Multiply one Hermite series by another.\n\n    Returns the product of two Hermite series c1 * c2. The arguments\n    are sequences of coefficients, from lowest order term to highest,\n    e.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2 where P_i\n    is the i-th Hermite polynomial.\n\n    The product of two Hermite series requires reprojection onto the\n    Hermite basis, which uses the recurrence relation for Hermite\n    polynomials.\n\n    For non-empty inputs of length m and n, the result has length m + n - 1.\n    For empty inputs, returns a single zero coefficient.\n-/\n\n/-  Specification: hermmul returns the coefficients of the product of two\n    Hermite series.\n\n    The key mathematical properties:\n    1. Empty input handling: If either input is empty, returns [0]\n    2. Degree property: For non-empty inputs of degree m-1 and n-1,\n       the product has degree (m-1) + (n-1) = m + n - 2, requiring m + n - 1 coefficients\n    3. Multiplication by constant: When one series has only one coefficient (constant polynomial),\n       the result is element-wise scaling\n    4. Commutativity: hermmul c1 c2 = hermmul c2 c1 (up to floating point precision)\n    5. The general multiplication follows Hermite polynomial recurrence relations\n\n    Precondition: True (works for all valid inputs)\n    Postcondition: Captures empty input behavior, constant multiplication, and size properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermmul (m n : Nat) (c1 : Vector Float m) (c2 : Vector Float n) : \n    Id (Vector Float (if m = 0 \u2228 n = 0 then 1 else m + n - 1)) :=\n  sorry", "vc-theorems": "theorem hermmul_spec (m n : Nat) (c1 : Vector Float m) (c2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermmul m n c1 c2\n    \u2983\u21d3result => \u231c\n      -- Empty input handling\n      ((m = 0 \u2228 n = 0) \u2192 result.size = 1 \u2227 result.get \u27e80, sorry\u27e9 = 0) \u2227\n      -- Non-empty inputs have correct output size\n      (m > 0 \u2227 n > 0 \u2192 result.size = m + n - 1) \u2227\n      -- Multiplication by constant polynomial (degree 0)\n      (n = 1 \u2227 m > 0 \u2192 \u2200 i : Fin m, \n        result.get \u27e8i.val, sorry\u27e9 = c1.get i * c2.get \u27e80, sorry\u27e9) \u2227\n      (m = 1 \u2227 n > 0 \u2192 \u2200 i : Fin n, \n        result.get \u27e8i.val, sorry\u27e9 = c2.get i * c1.get \u27e80, sorry\u27e9) \u2227\n      -- Zero polynomial property\n      ((\u2200 i : Fin m, c1.get i = 0) \u2228 (\u2200 j : Fin n, c2.get j = 0) \u2192 \n        \u2200 k : Fin result.size, result.get k = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermmulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermmulx\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Multiply a Hermite series by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermmulx.html\",\n  \"doc\": \"Multiply a Hermite series by x.\\n\\n    Multiply the Hermite series \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    hermadd, hermsub, hermmul, hermdiv, hermpow\\n\\n    Notes\\n    -----\\n    The multiplication uses the recursion relationship for Hermite\\n    polynomials in the form\\n\\n    .. math::\\n\\n        xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermmulx\\n    >>> hermmulx([1, 2, 3])\\n    array([2. , 6.5, 1. , 1.5])\",\n}\n-/\n\n/-  Multiply a Hermite series by x using the recursion relationship xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x)) -/\n\n/-  Specification: hermmulx multiplies a Hermite series by x using the recursion relationship for Hermite polynomials.\n\n    The algorithm implements the recursion: $$xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x))$$\n\n    Given input coefficients c[0], c[1], ..., c[n-1], the output has n+1 coefficients where:\n    - The first coefficient is always 0\n    - Each c[i] contributes c[i]/2 to position i+1 and c[i]*i to position i-1\n\n    For example, with input [1, 2, 3]:\n    - result[0] = 0 + 2*1 = 2\n    - result[1] = 1/2 + 3*2 = 0.5 + 6 = 6.5\n    - result[2] = 2/2 = 1\n    - result[3] = 3/2 = 1.5\n    Giving [2, 6.5, 1, 1.5] -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermmulx {n : Nat} (c : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem hermmulx_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermmulx c\n    \u2983\u21d3result =>\n      -- The output has exactly n+1 coefficients\n      \u231cresult.size = n + 1\u231d \u2227\n      -- Mathematical property: each position in result is the sum of contributions\n      -- from the recursion formula $xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x))$\n      \u231c\u2200 k : Fin (n + 1),\n        result.get k =\n          -- Base case: position 0 starts at 0\n          (if k.val = 0 then 0 else 0) +\n          -- Contribution from c[k-1]/2 when k > 0 and k-1 < n\n          (if h1 : k.val > 0 \u2227 k.val - 1 < n then c.get \u27e8k.val - 1, sorry\u27e9 / 2 else 0) +\n          -- Contribution from c[k+1]*(k+1) when k+1 < n\n          (if h2 : k.val + 1 < n then c.get \u27e8k.val + 1, sorry\u27e9 * Float.ofNat (k.val + 1) else 0)\u231d\n    \u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermpow", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermpow\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Raise a Hermite series to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermpow.html\",\n  \"doc\": \"Raise a Hermite series to a power.\\n\\n    Returns the Hermite series `c` raised to the power `pow`. The\\n    argument `c` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Hermite series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Hermite series of power.\\n\\n    See Also\\n    --------\\n    hermadd, hermsub, hermmulx, hermmul, hermdiv\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermpow\\n    >>> hermpow([1, 2, 3], 2)\\n    array([81.,  52.,  82.,  12.,   9.])\",\n}\n-/\n\n/-  Raise a Hermite polynomial series to a power.\n    Given coefficients `c` representing a Hermite series (ordered from low to high degree),\n    returns the coefficients of the series raised to the power `pow`.\n    The `maxpower` parameter limits the maximum degree of the result. -/\n\n/-  Specification: hermpow raises a Hermite series to a power by repeated multiplication.\n    Key properties:\n    1. For pow = 0, the result is the constant polynomial [1]\n    2. For pow = 1, the result equals the input polynomial\n    3. For pow > 1, the result is obtained by repeated Hermite multiplication\n    4. The result degree is bounded by min(n + (n-1)*pow - 1, maxpower)\n    5. The operation respects the algebraic properties of polynomial exponentiation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermpow {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat := 16) : \n    Id (Vector Float (min (n + (n - 1) * pow) (maxpower + 1))) :=\n  sorry", "vc-theorems": "theorem hermpow_spec {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat := 16) :\n    \u2983\u231cn > 0 \u2227 maxpower \u2265 0\u231d\u2984\n    hermpow c pow maxpower\n    \u2983\u21d3result => \u231c\n      -- Sanity check: result has bounded size\n      result.size \u2264 maxpower + 1 \u2227\n      result.size = min (n + (n - 1) * pow) (maxpower + 1) \u2227\n\n      -- Property 1: Power of 0 gives constant polynomial [1]\n      (pow = 0 \u2192 result.size = 1 \u2227 result.get \u27e80, sorry\u27e9 = 1) \u2227\n\n      -- Property 2: Power of 1 preserves the polynomial (up to size constraints)\n      (pow = 1 \u2227 n \u2264 maxpower + 1 \u2192 \n        result.size = n \u2227 \u2200 i : Fin n, result.get \u27e8i.val, sorry\u27e9 = c.get i) \u2227\n\n      -- Property 3: The result represents c^pow in the Hermite polynomial basis\n      -- This is the core mathematical property but requires Hermite multiplication definition\n      -- For now, we express that the result is non-trivial for non-zero inputs\n      ((\u2203 i : Fin n, c.get i \u2260 0) \u2227 pow > 0 \u2192 \u2203 j : Fin result.size, result.get j \u2260 0) \u2227\n\n      -- Property 4: Degree bound property\n      -- The degree of c^pow is at most (deg(c) * pow) where deg(c) \u2264 n-1\n      -- This ensures the result size calculation is reasonable\n      (\u2200 i : Fin result.size, i.val \u2265 min (n + (n - 1) * pow) (maxpower + 1) \u2192 \n        result.get i = 0) \u2227\n\n      -- Property 5: Consistency with repeated multiplication\n      -- For small powers, we can express this concretely\n      (pow = 2 \u2227 n \u2264 maxpower / 2 \u2192 \n        -- The result should be equivalent to hermmul(c, c)\n        -- This captures the essence of polynomial multiplication in Hermite basis\n        True) -- Placeholder for hermmul consistency\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermroots", "vc-description": "/-  Compute the roots of a Hermite series.\n\n    Returns the roots (zeros) of the polynomial p(x) = \u03a3\u1d62 c[i] * H\u1d62(x),\n    where H\u1d62(x) are Hermite polynomials.\n\n    The roots are obtained as eigenvalues of the companion matrix. -/\n\n/-  Specification: hermroots computes the roots of a Hermite polynomial.\n\n    Key properties:\n    1. Returns n-1 roots for n coefficients (degree n-1 polynomial)\n    2. The roots are sorted in ascending order\n    3. Each root is a zero of the Hermite polynomial\n    4. For the linear case (n=2), provides exact formula\n\n    Precondition: n > 0 to ensure valid polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermroots {n : Nat} (c : Vector Float n) : Id (Vector Float (n - 1)) :=\n  sorry", "vc-theorems": "theorem hermroots_spec {n : Nat} (c : Vector Float n) (h_pos : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    hermroots c\n    \u2983\u21d3roots => \u231c\n      -- Basic size property\n      roots.size = n - 1 \u2227\n      -- For n = 1 (constant polynomial), no roots\n      (n = 1 \u2192 roots.size = 0) \u2227\n      -- For n = 2 (linear polynomial c\u2080 + c\u2081\u00b7H\u2081(x) where H\u2081(x) = 2x)\n      -- The root is x = -c\u2080/(2c\u2081)\n      (n = 2 \u2192 \n        \u2203 (hn : n = 2),\n        roots.size = 1 \u2227\n        -- Abstract the computation to avoid index issues\n        -- In practice: roots[0] = -0.5 * c[0] / c[1] when c[1] \u2260 0\n        True) \u2227\n      -- Roots are sorted\n      (n > 2 \u2192 \n        \u2200 i j : Fin roots.size, i.val < j.val \u2192 roots.get i \u2264 roots.get j) \u2227\n      -- Mathematical property: roots are zeros of the Hermite polynomial\n      -- Each r in roots satisfies: \u03a3\u1d62 c[i] * H\u1d62(r) \u2248 0\n      (\u2200 i : Fin roots.size,\n        -- Abstract property: the polynomial evaluates to approximately 0 at this root\n        True\n      ) \u2227\n      -- Numerical accuracy: the companion matrix method is stable for\n      -- well-conditioned polynomials\n      True\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermsub", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermsub\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Subtract one Hermite series from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermsub.html\",\n  \"doc\": \"Subtract one Hermite series from another.\\n\\n    Returns the difference of two Hermite series `c1` - `c2`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Hermite series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Hermite series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    hermadd, hermmulx, hermmul, hermdiv, hermpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Hermite\\n    series is a Hermite series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermsub\\n    >>> hermsub([1, 2, 3, 4], [1, 2, 3])\\n    array([0.,  0.,  0.,  4.])\",\n}\n-/\n\n/-  Subtract one Hermite series from another.\n\n    Returns the difference of two Hermite series c1 - c2. The sequences of coefficients \n    are from lowest order term to highest. The subtraction is component-wise, with \n    missing coefficients treated as zero. -/\n\n/-  Specification: hermsub performs component-wise subtraction of Hermite series coefficients,\n    treating missing coefficients as zero. The result has the length of the longer input. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermsub {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : \n    Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem hermsub_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    hermsub c1 c2\n    \u2983\u21d3result => \u231c\n      -- For indices within both arrays, result is the difference\n      (\u2200 i : Nat, i < min n m \u2192 \n        result.get \u27e8i, sorry\u27e9 = c1.get \u27e8i, sorry\u27e9 - c2.get \u27e8i, sorry\u27e9) \u2227\n      -- For indices beyond c2's length (when n > m), result equals c1\n      (n > m \u2192 \u2200 i : Nat, m \u2264 i \u2227 i < n \u2192 \n        result.get \u27e8i, sorry\u27e9 = c1.get \u27e8i, sorry\u27e9) \u2227\n      -- For indices beyond c1's length (when m > n), result equals negation of c2\n      (m > n \u2192 \u2200 i : Nat, n \u2264 i \u2227 i < m \u2192 \n        result.get \u27e8i, sorry\u27e9 = -c2.get \u27e8i, sorry\u27e9)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermval2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermval2d\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Evaluate a 2-D Hermite series at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermval2d.html\",\n  \"doc\": \"Evaluate a 2-D Hermite series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\sum_{i,j} c_{i,j} * H_i(x) * H_j(y)\\n\\n    The parameters `x` and `y` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either `x`\\n    and `y` or their elements must support multiplication and addition both\\n    with themselves and with the elements of `c`.\\n\\n    If `c` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points ``(x, y)``,\\n        where `x` and `y` must have the same shape. If `x` or `y` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in ``c[i,j]``. If `c` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points formed with\\n        pairs of corresponding values from `x` and `y`.\\n\\n    See Also\\n    --------\\n    hermval, hermgrid2d, hermval3d, hermgrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermval2d\\n    >>> x = [1, 2]\\n    >>> y = [4, 5]\\n    >>> c = [[1, 2, 3], [4, 5, 6]]\\n    >>> hermval2d(x, y, c)\\n    array([1035., 2883.])\",\n}\n-/\n\n/-  Evaluate a 2-D Hermite series at points (x, y).\n\n    Given a 2D coefficient matrix c where c[i,j] is the coefficient for H_i(x) * H_j(y),\n    evaluates the sum: \u2211_{i,j} c_{i,j} * H_i(x) * H_j(y)\n    where H_i and H_j are Hermite polynomials.\n\n    The x and y vectors must have the same length, and the function evaluates\n    the 2D polynomial at each pair of corresponding points (x[k], y[k]).\n-/\n\n/-  Specification: hermval2d correctly evaluates a 2D Hermite polynomial series.\n\n    Mathematical properties:\n    1. The result at each point (x[k], y[k]) is the sum \u2211_{i,j} c_{i,j} * H_i(x[k]) * H_j(y[k])\n    2. Empty coefficient matrix (rows = 0 or cols = 0) evaluates to zero vector\n    3. The evaluation is separable: H_i(x) * H_j(y) where H_i, H_j are 1D Hermite polynomials\n    4. Hermite polynomials satisfy the recurrence relation in each dimension\n    5. The result respects the bilinearity of the 2D Hermite basis\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermval2d {n rows cols : Nat} (x y : Vector Float n) (c : Vector (Vector Float cols) rows) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermval2d_spec {n rows cols : Nat} (x y : Vector Float n) (c : Vector (Vector Float cols) rows) :\n    \u2983\u231cTrue\u231d\u2984\n    hermval2d x y c\n    \u2983\u21d3result => \u231c-- Empty coefficient cases\n                 ((rows = 0 \u2228 cols = 0) \u2192 \u2200 k : Fin n, result.get k = 0) \u2227\n                 -- General case: each result element is the 2D Hermite series evaluation\n                 (rows > 0 \u2227 cols > 0 \u2192 \n                   \u2200 k : Fin n,\n                     \u2203 (H_x H_y : Nat \u2192 Float),\n                       -- H_x satisfies Hermite recurrence at x[k]\n                       H_x 0 = 1 \u2227\n                       H_x 1 = 2 * (x.get k) \u2227\n                       (\u2200 i : Nat, i + 2 < rows \u2192 \n                         H_x (i + 2) = 2 * (x.get k) * H_x (i + 1) - 2 * Float.ofNat (i + 1) * H_x i) \u2227\n                       -- H_y satisfies Hermite recurrence at y[k]\n                       H_y 0 = 1 \u2227\n                       H_y 1 = 2 * (y.get k) \u2227\n                       (\u2200 j : Nat, j + 2 < cols \u2192 \n                         H_y (j + 2) = 2 * (y.get k) * H_y (j + 1) - 2 * Float.ofNat (j + 1) * H_y j) \u2227\n                       -- Result is the double sum\n                       result.get k = List.sum (List.map \n                         (fun i : Fin rows => List.sum (List.map \n                           (fun j : Fin cols => (c.get i).get j * H_x i.val * H_y j.val) \n                           (List.finRange cols)))\n                         (List.finRange rows))) \u2227\n                 -- Bilinearity property: the evaluation is linear in coefficients\n                 (\u2200 (c1 c2 : Vector (Vector Float cols) rows) (a b : Float),\n                   \u2200 k : Fin n,\n                     -- Linear combination of coefficient matrices\n                     let c_combined := Vector.ofFn (fun i : Fin rows => \n                       Vector.ofFn (fun j : Fin cols => \n                         a * (c1.get i).get j + b * (c2.get i).get j))\n                     -- Evaluates to linear combination of results\n                     \u2203 (res1 res2 res_combined : Vector Float n),\n                       (\u2983\u231cTrue\u231d\u2984 hermval2d x y c1 \u2983\u21d3r => \u231cr = res1\u231d\u2984) \u2227\n                       (\u2983\u231cTrue\u231d\u2984 hermval2d x y c2 \u2983\u21d3r => \u231cr = res2\u231d\u2984) \u2227\n                       (\u2983\u231cTrue\u231d\u2984 hermval2d x y c_combined \u2983\u21d3r => \u231cr = res_combined\u231d\u2984) \u2227\n                       res_combined.get k = a * res1.get k + b * res2.get k) \u2227\n                 -- Separability property: 2D evaluation is product of 1D evaluations\n                 (rows = 1 \u2227 cols > 0 \u2192 \n                   \u2200 k : Fin n,\n                     \u2203 H_y : Nat \u2192 Float,\n                       -- H_y satisfies Hermite recurrence\n                       H_y 0 = 1 \u2227\n                       H_y 1 = 2 * (y.get k) \u2227\n                       (\u2200 j : Nat, j + 2 < cols \u2192 \n                         H_y (j + 2) = 2 * (y.get k) * H_y (j + 1) - 2 * Float.ofNat (j + 1) * H_y j) \u2227\n                       -- Result is c[0,j] * H_0(x) * H_j(y) = c[0,j] * 1 * H_j(y)\n                       result.get k = List.sum (List.map \n                         (fun j : Fin cols => (c.get \u27e80, sorry\u27e9).get j * H_y j.val) \n                         (List.finRange cols))) \u2227\n                 (cols = 1 \u2227 rows > 0 \u2192 \n                   \u2200 k : Fin n,\n                     \u2203 H_x : Nat \u2192 Float,\n                       -- H_x satisfies Hermite recurrence\n                       H_x 0 = 1 \u2227\n                       H_x 1 = 2 * (x.get k) \u2227\n                       (\u2200 i : Nat, i + 2 < rows \u2192 \n                         H_x (i + 2) = 2 * (x.get k) * H_x (i + 1) - 2 * Float.ofNat (i + 1) * H_x i) \u2227\n                       -- Result is c[i,0] * H_i(x) * H_0(y) = c[i,0] * H_i(x) * 1\n                       result.get k = List.sum (List.map \n                         (fun i : Fin rows => (c.get i).get \u27e80, sorry\u27e9 * H_x i.val) \n                         (List.finRange rows)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermvander2d", "vc-description": "/-  Pseudo-Vandermonde matrix of given degrees for 2D Hermite polynomials.\n\n    Returns a matrix where each row corresponds to a sample point (x[i], y[i]),\n    and columns represent products of Hermite polynomials H_i(x) * H_j(y).\n    The column at index (ydeg + 1)*i + j contains H_i(x) * H_j(y).\n\n    This creates the design matrix for fitting 2D Hermite polynomial surfaces,\n    where coefficients are arranged in row-major order: c_00, c_01, ..., c_10, c_11, ...\n-/\n\n/-  Specification: hermvander2d creates a 2D Vandermonde matrix where each element\n    V[k][(ydeg + 1)*i + j] equals H_i(x[k]) * H_j(y[k]), where H_i denotes the \n    i-th Hermite polynomial. The Hermite polynomials follow the recurrence:\n    H_0(t) = 1, H_1(t) = 2t, H_n(t) = 2t * H_{n-1}(t) - 2(n-1) * H_{n-2}(t) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermvander2d {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) : \n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1))) n) :=\n  sorry", "vc-theorems": "theorem hermvander2d_spec {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    hermvander2d x y xdeg ydeg\n    \u2983\u21d3V => \u231c-- Each row has the correct size\n           (\u2200 k : Fin n, (V.get k).size = (xdeg + 1) * (ydeg + 1)) \u2227\n           -- The first column (i=0, j=0) is all ones\n           (\u2200 k : Fin n, (V.get k).get \u27e80, Nat.zero_lt_of_ne_zero (Nat.mul_ne_zero (Nat.succ_ne_zero xdeg) (Nat.succ_ne_zero ydeg))\u27e9 = 1) \u2227\n           -- Column indexing follows row-major order: (ydeg + 1)*i + j\n           (\u2200 k : Fin n, \u2200 i : Fin (xdeg + 1), \u2200 j : Fin (ydeg + 1),\n             -- We need a proof that the column index is valid\n             \u2200 (h_idx : (ydeg + 1) * i.val + j.val < (xdeg + 1) * (ydeg + 1)),\n             let col_idx : Fin ((xdeg + 1) * (ydeg + 1)) := \u27e8(ydeg + 1) * i.val + j.val, h_idx\u27e9\n             \u2203 (H_i_x H_j_y : Float),\n               -- H_i_x is the i-th Hermite polynomial evaluated at x[k]\n               (i.val = 0 \u2192 H_i_x = 1) \u2227\n               (i.val = 1 \u2192 H_i_x = 2 * x.get k) \u2227\n               (i.val \u2265 2 \u2192 \u2203 (H_prev H_prev2 : Float),\n                 H_i_x = 2 * x.get k * H_prev - 2 * Float.ofNat (i.val - 1) * H_prev2) \u2227\n               -- H_j_y is the j-th Hermite polynomial evaluated at y[k]\n               (j.val = 0 \u2192 H_j_y = 1) \u2227\n               (j.val = 1 \u2192 H_j_y = 2 * y.get k) \u2227\n               (j.val \u2265 2 \u2192 \u2203 (H_prev H_prev2 : Float),\n                 H_j_y = 2 * y.get k * H_prev - 2 * Float.ofNat (j.val - 1) * H_prev2) \u2227\n               -- The matrix element is the product\n               (V.get k).get col_idx = H_i_x * H_j_y) \u2227\n           -- Additional property: The matrix columns correspond to coefficient ordering\n           -- c_00, c_01, c_02, ..., c_10, c_11, ...\n           (\u2200 k : Fin n, \u2200 idx : Fin ((xdeg + 1) * (ydeg + 1)),\n             let i := idx.val / (ydeg + 1)\n             let j := idx.val % (ydeg + 1)\n             \u2200 (h_i : i < xdeg + 1) (h_j : j < ydeg + 1),\n             idx.val = (ydeg + 1) * i + j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_hermweight", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.hermite.hermweight\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Weight function of the Hermite polynomials.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermweight.html\",\n  \"doc\": \"Weight function of the Hermite polynomials.\\n\\n    The weight function is :math:\\`\\\\\\\\exp(-x^2)\\` and the interval of\\n    integration is :math:\\`[-\\\\\\\\inf, \\\\\\\\inf]\\`. the Hermite polynomials are\\n    orthogonal, but not normalized, with respect to this weight function.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n       Values at which the weight function will be computed.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n       The weight function at \\`x\\`.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial.hermite import hermweight\\n    >>> x = np.arange(-2, 2)\\n    >>> hermweight(x)\\n    array([0.01831564, 0.36787944, 1.        , 0.36787944])\",\n}\n-/\n\n/-  Weight function of the Hermite polynomials.\n    Computes exp(-x\u00b2) for each element in the input vector. -/\n\n/-  Specification: hermweight computes the Hermite weight function exp(-x\u00b2) for each element.\n\n    The specification includes:\n    1. Basic property: Each output element equals exp(-x\u00b2) of the corresponding input\n    2. Non-negativity: All output values are positive (since exp is always positive)\n    3. Symmetry: The weight function is symmetric around zero\n    4. Maximum at zero: The weight function achieves its maximum value of 1 at x=0\n    5. Monotonicity: The function decreases as |x| increases -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def hermweight {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem hermweight_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    hermweight x\n    \u2983\u21d3w => \u231c(\u2200 i : Fin n, w.get i = Float.exp (-(x.get i * x.get i))) \u2227\n            (\u2200 i : Fin n, w.get i > 0) \u2227\n            (\u2200 i : Fin n, x.get i = 0 \u2192 w.get i = 1) \u2227\n            (\u2200 i j : Fin n, Float.abs (x.get i) < Float.abs (x.get j) \u2192 \n                            w.get i > w.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_hermite_poly2herm", "vc-description": "/-  numpy.polynomial.hermite.poly2herm: Convert a polynomial to a Hermite series.\n\n    Convert an array representing the coefficients of a polynomial (relative\n    to the \"standard\" basis) ordered from lowest degree to highest, to an\n    array of the coefficients of the equivalent Hermite series, ordered\n    from lowest to highest degree.\n\n    The conversion transforms between different polynomial bases. The standard\n    polynomial basis consists of monomials {1, x, x\u00b2, x\u00b3, ...} while the\n    Hermite polynomial basis consists of Hermite polynomials {H\u2080(x), H\u2081(x), H\u2082(x), ...}.\n\n    The algorithm uses Hermite polynomial operations (multiplication by x and addition)\n    to build up the result iteratively from the highest degree coefficient down.\n-/\n\n/-  Specification: poly2herm converts polynomial coefficients to Hermite series coefficients\n\n    The specification ensures:\n    1. The output has the same dimension as the input\n    2. The conversion preserves the polynomial function when evaluated using respective bases\n    3. For the zero polynomial (all coefficients zero), the result is also zero\n    4. The conversion is linear: poly2herm(a*p + b*q) = a*poly2herm(p) + b*poly2herm(q)\n\n    Additionally, for specific test cases:\n    - Converting [0, 1, 2, 3] should yield [1, 2.75, 0.5, 0.375]\n    - Converting a constant polynomial [c] should yield [c]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def poly2herm {n : Nat} (pol : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem poly2herm_spec {n : Nat} (pol : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    poly2herm pol\n    \u2983\u21d3result => \u231c-- Same dimension constraint\n                 result.size = pol.size \u2227\n                 -- Zero polynomial maps to zero\n                 (\u2200 i : Fin n, pol.get i = 0) \u2192 (\u2200 i : Fin n, result.get i = 0) \u2227\n                 -- Constant polynomial preservation (when n \u2265 1)\n                 (n > 0 \u2192 (\u2200 i : Fin n, i.val > 0 \u2192 pol.get i = 0) \u2192 \n                  result.get \u27e80, sorry\u27e9 = pol.get \u27e80, sorry\u27e9) \u2227\n                 -- Specific example from documentation (when applicable)\n                 (n = 4 \u2227 pol.get \u27e80, sorry\u27e9 = 0 \u2227 pol.get \u27e81, sorry\u27e9 = 1 \u2227 \n                  pol.get \u27e82, sorry\u27e9 = 2 \u2227 pol.get \u27e83, sorry\u27e9 = 3) \u2192\n                 (result.get \u27e80, sorry\u27e9 = 1 \u2227 result.get \u27e81, sorry\u27e9 = 2.75 \u2227 \n                  result.get \u27e82, sorry\u27e9 = 0.5 \u2227 result.get \u27e83, sorry\u27e9 = 0.375)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_Laguerre", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.Laguerre\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"A Laguerre series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.Laguerre.html\",\n  \"doc\": \"A Laguerre series class.\\n\\n    The Laguerre class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Laguerre coefficients in order of increasing degree, i.e,\\n        ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\\n        to the interval ``[window[0], window[1]]`` by shifting and scaling.\\n        The default value is [0., 1.].\\n    window : (2,) array_like, optional\\n        Window, see `domain` for its use. The default value is [0., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n-/\n\n/-  Constructor for Laguerre series with default domain and window -/\n\n/-  Specification for Laguerre series construction and properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to evaluate a Laguerre polynomial at a given point -/\naxiom evaluateLaguerrePolynomial {k : Nat} : Vector Float k \u2192 Float \u2192 Float\n\n/-- Domain mapping function for polynomial transformations -/\naxiom mapDomain : Vector Float 2 \u2192 Vector Float 2 \u2192 Float \u2192 Float\n\n/-- Helper function for individual Laguerre polynomial basis functions -/\naxiom laguerrePolynomialBasis : Nat \u2192 Float \u2192 Float\n\n/-- A Laguerre series class representing a polynomial in the Laguerre basis.\n    This structure encapsulates Laguerre coefficients with domain and window information. -/\nstructure Laguerre (n : Nat) where\n  /-- Laguerre coefficients in order of increasing degree -/\n  coef : Vector Float n\n  /-- Domain interval [domain[0], domain[1]] for mapping -/\n  domain : Vector Float 2\n  /-- Window interval [window[0], window[1]] for mapping -/\n  window : Vector Float 2", "vc-helpers": "", "vc-definitions": "def makeLaguerre {n : Nat} (coefficients : Vector Float n) : Id (Laguerre n) :=\n  sorry", "vc-theorems": "theorem makeLaguerre_spec {n : Nat} (coefficients : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    makeLaguerre coefficients\n    \u2983\u21d3result => \u231c\n      -- The coefficients are preserved exactly\n      (result.coef = coefficients) \u2227\n      -- Default domain is [0, 1]\n      (result.domain.get 0 = 0.0 \u2227 result.domain.get 1 = 1.0) \u2227\n      -- Default window is [0, 1]\n      (result.window.get 0 = 0.0 \u2227 result.window.get 1 = 1.0) \u2227\n      -- The Laguerre polynomial can be evaluated at any point\n      (\u2200 x : Float, \n        let transformedX := mapDomain result.domain result.window x\n        \u2203 value : Float, \n        value = evaluateLaguerrePolynomial result.coef transformedX) \u2227\n      -- The polynomial representation is mathematically consistent\n      -- The evaluation function produces valid results\n      (\u2200 x : Float,\n        let transformedX := mapDomain result.domain result.window x\n        \u2203 value : Float, value = evaluateLaguerrePolynomial result.coef transformedX) \u2227\n      -- Basic sanity check for coefficient preservation\n      (\u2200 i : Fin n, result.coef.get i = coefficients.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lag2poly", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lag2poly\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Convert a Laguerre series to a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lag2poly.html\",\n  \"doc\": \"Convert a Laguerre series to a polynomial.\\n\\n    Convert an array representing the coefficients of a Laguerre series,\\n    ordered from lowest degree to highest, to an array of the coefficients\\n    of the equivalent polynomial (relative to the \\\"standard\\\" basis) ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array containing the Laguerre series coefficients, ordered\\n        from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    pol : ndarray\\n        1-D array containing the coefficients of the equivalent polynomial\\n        (relative to the \\\"standard\\\" basis) ordered from lowest order term\\n        to highest.\\n\\n    See Also\\n    --------\\n    poly2lag\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lag2poly\\n    >>> lag2poly([ 23., -63.,  58., -18.])\\n    array([0., 1., 2., 3.])\",\n}\n-/\n\n/-  Convert a Laguerre series to a polynomial.\n    Convert an array representing the coefficients of a Laguerre series,\n    ordered from lowest degree to highest, to an array of the coefficients\n    of the equivalent polynomial (relative to the \"standard\" basis). -/\n\n/-  Specification: lag2poly converts Laguerre series coefficients to standard polynomial coefficients.\n    The converted polynomial evaluates to the same values as the original Laguerre series. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to evaluate a Laguerre polynomial at a given point -/\naxiom evaluateLaguerrePolynomial {k : Nat} : Vector Float k \u2192 Float \u2192 Float\n\n/-- Helper function to evaluate a standard polynomial at a given point -/\naxiom evaluatePolynomial {k : Nat} : Vector Float k \u2192 Float \u2192 Float", "vc-helpers": "", "vc-definitions": "def lag2poly {n : Nat} (c : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lag2poly_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    lag2poly c\n    \u2983\u21d3result => \u231c\n      -- The converted polynomial evaluates to the same values as the Laguerre series\n      (\u2200 x : Float, \n        evaluatePolynomial result x = evaluateLaguerrePolynomial c x) \u2227\n      -- Single coefficient case: lag2poly([a]) = [a]\n      (n = 1 \u2192 result = c) \u2227\n      -- The conversion preserves the polynomial degree\n      (n > 0 \u2192 \u2200 h : n - 1 < n, result.get \u27e8n - 1, h\u27e9 \u2260 0 \u2192 \n        evaluatePolynomial result 0 = evaluateLaguerrePolynomial c 0) \u2227\n      -- The conversion is mathematically consistent\n      -- Basic identity check at evaluation point x = 0\n      (evaluatePolynomial result 0 = evaluateLaguerrePolynomial c 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagadd", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagadd\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Add one Laguerre series to another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagadd.html\",\n  \"doc\": \"Add one Laguerre series to another.\\n\\n    Returns the sum of two Laguerre series `c1` + `c2`.  The arguments\\n    are sequences of coefficients ordered from lowest order term to\\n    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Laguerre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the Laguerre series of their sum.\\n\\n    See Also\\n    --------\\n    lagsub, lagmulx, lagmul, lagdiv, lagpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the sum of two Laguerre series\\n    is a Laguerre series (without having to \\\"reproject\\\" the result onto\\n    the basis set) so addition, just like that of \\\"standard\\\" polynomials,\\n    is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagadd\\n    >>> lagadd([1, 2, 3], [1, 2, 3, 4])\\n    array([2.,  4.,  6.,  4.])\",\n}\n-/\n\n/-  Add one Laguerre series to another.\n    Returns the sum of two Laguerre series c1 + c2. The arguments\n    are sequences of coefficients ordered from lowest order term to highest. -/\n\n/-  Specification: lagadd performs component-wise addition of two Laguerre series coefficients.\n    The result length is the maximum of the input lengths, with shorter arrays padded with zeros. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to evaluate a Laguerre polynomial at a given point -/\naxiom evaluateLaguerrePolynomial {k : Nat} : Vector Float k \u2192 Float \u2192 Float", "vc-helpers": "", "vc-definitions": "def lagadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : \n    Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem lagadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    lagadd c1 c2\n    \u2983\u21d3result => \u231c\n      -- Component-wise addition with zero padding\n      (\u2200 i : Fin (max n m), \n        let val1 := if h : i.val < n then c1.get \u27e8i.val, h\u27e9 else 0\n        let val2 := if h : i.val < m then c2.get \u27e8i.val, h\u27e9 else 0\n        result.get i = val1 + val2) \u2227\n      -- Basic sanity: non-empty inputs produce non-empty output  \n      (n > 0 \u2228 m > 0 \u2192 max n m > 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagcompanion", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagcompanion\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Return the companion matrix of c.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagcompanion.html\",\n  \"doc\": \"Return the companion matrix of c.\\n\\n    The usual companion matrix of the Laguerre polynomials is already\\n    symmetric when \\`c\\` is a basis Laguerre polynomial, so no scaling is\\n    applied.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Laguerre series coefficients ordered from low to high\\n        degree.\\n\\n    Returns\\n    -------\\n    mat : ndarray\\n        Companion matrix of dimensions (deg, deg).\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagcompanion\\n    >>> lagcompanion([1, 2, 3])\\n    array([[ 1.        , -0.33333333],\\n           [-1.        ,  4.33333333]])\",\n}\n-/\n\n/-  Returns the companion matrix of Laguerre polynomial coefficients.\n    The companion matrix is a square matrix of size (deg, deg) where deg = c.size - 1.\n    For coefficients [c\u2080, c\u2081, ..., c\u2099], the companion matrix has specific structure\n    for Laguerre polynomials with diagonal elements 2*i + 1 and off-diagonal elements. -/\n\n/-  Specification: lagcompanion returns the companion matrix of Laguerre polynomial coefficients.\n    The companion matrix is symmetric for Laguerre polynomials and has dimension (deg, deg)\n    where deg = c.size - 1. The matrix structure follows the Laguerre polynomial recurrence relation. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagcompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem lagcompanion_spec {n : Nat} (c : Vector Float (n + 2)) \n    (h_nonzero : c.get (Fin.last (n + 1)) \u2260 0) :\n    \u2983\u231cc.get (Fin.last (n + 1)) \u2260 0\u231d\u2984\n    lagcompanion c\n    \u2983\u21d3mat => \u231c-- Matrix has correct dimensions\n             mat.size = n + 1 \u2227 \n             (\u2200 i : Fin (n + 1), (mat.get i).size = n + 1) \u2227\n             -- Diagonal elements follow pattern: 2*i + 1  \n             (\u2200 i : Fin (n + 1), (mat.get i).get i = 2 * Float.ofNat i.val + 1) \u2227\n             -- Off-diagonal elements for tridiagonal structure\n             (\u2200 i : Fin n, (mat.get (i.castSucc)).get (i.succ) = -(Float.ofNat i.val + 1)) \u2227\n             (\u2200 i : Fin n, (mat.get (i.succ)).get (i.castSucc) = -(Float.ofNat i.val + 1))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagder", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagder\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Differentiate a Laguerre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagder.html\",\n  \"doc\": \"Differentiate a Laguerre series.\\n\\n    Returns the Laguerre series coefficients \\`c\\` differentiated \\`m\\` times\\n    along \\`axis\\`.  At each iteration the result is multiplied by \\`scl\\` (the\\n    scaling factor is for use in a linear change of variable). The argument\\n    \\`c\\` is an array of coefficients from low to high degree along each\\n    axis, e.g., [1,2,3] represents the series \\`\\`1*L_0 + 2*L_1 + 3*L_2\\`\\`\\n    while [[1,2],[1,2]] represents \\`\\`1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +\\n    2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)\\`\\` if axis=0 is \\`\\`x\\`\\` and axis=1 is\\n    \\`\\`y\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Laguerre series coefficients. If \\`c\\` is multidimensional\\n        the different axis correspond to different variables with the\\n        degree in each axis given by the corresponding index.\\n    m : int, optional\\n        Number of derivatives taken, must be non-negative. (Default: 1)\\n    scl : scalar, optional\\n        Each differentiation is multiplied by \\`scl\\`.  The end result is\\n        multiplication by \\`\\`scl**m\\`\\`.  This is for use in a linear change of\\n        variable. (Default: 1)\\n    axis : int, optional\\n        Axis over which the derivative is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    der : ndarray\\n        Laguerre series of the derivative.\\n\\n    See Also\\n    --------\\n    lagint\\n\\n    Notes\\n    -----\\n    In general, the result of differentiating a Laguerre series does not\\n    resemble the same operation on a power series. Thus the result of this\\n    function may be \\\"unintuitive,\\\" albeit correct; see Examples section\\n    below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagder\\n    >>> lagder([ 1.,  1.,  1., -3.])\\n    array([1.,  2.,  3.])\\n    >>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)\\n    array([1.,  2.,  3.])\",\n}\n-/\n\n/-  Differentiates a Laguerre series m times with optional scaling.\n    Returns the coefficients of the differentiated Laguerre series. -/\n\n/-  Specification: lagder differentiates a Laguerre series m times.\n    Each differentiation is scaled by scl and follows Laguerre polynomial recurrence relations. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagder {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float := 1.0) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lagder_spec {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    lagder c m scl\n    \u2983\u21d3result => \u231c-- Basic properties\n                 result.size = n \u2227\n                 -- If m = 0, result equals input\n                 (m = 0 \u2192 \u2200 i : Fin n, result.get i = c.get i) \u2227\n                 -- For large m, result becomes zero or minimal\n                 (m \u2265 n \u2227 n > 0 \u2192 \u2200 i : Fin n, result.get i = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagdiv", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagdiv\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Divide one Laguerre series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagdiv.html\",\n  \"doc\": \"Divide one Laguerre series by another.\\n\\n    Returns the quotient-with-remainder of two Laguerre series\\n    \\`c1\\` / \\`c2\\`.  The arguments are sequences of coefficients from lowest\\n    order \\\"term\\\" to highest, e.g., [1,2,3] represents the series\\n    \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Laguerre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    [quo, rem] : ndarrays\\n        Of Laguerre series coefficients representing the quotient and\\n        remainder.\\n\\n    See Also\\n    --------\\n    lagadd, lagsub, lagmulx, lagmul, lagpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) division of one Laguerre series by another\\n    results in quotient and remainder terms that are not in the Laguerre\\n    polynomial basis set.  Thus, to express these results as a Laguerre\\n    series, it is necessary to \\\"reproject\\\" the results onto the Laguerre\\n    basis set, which may produce \\\"unintuitive\\\" (but correct) results; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagdiv\\n    >>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\\n    (array([1., 2., 3.]), array([0.]))\\n    >>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\\n    (array([1., 2., 3.]), array([1., 1.]))\",\n}\n-/\n\n/-  Divides one Laguerre series by another, returning quotient and remainder.\n    The division is performed in the Laguerre polynomial basis. -/\n\n/-  Specification: lagdiv divides one Laguerre series by another.\n    Returns a pair (quotient, remainder) where c1 = quotient * c2 + remainder\n    in the Laguerre polynomial basis. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagdiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : \n    Id (Vector Float n \u00d7 Vector Float m) :=\n  sorry", "vc-theorems": "theorem lagdiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) \n    (h_nonzero : \u2203 i : Fin m, c2.get i \u2260 0) :\n    \u2983\u231c\u2203 i : Fin m, c2.get i \u2260 0\u231d\u2984\n    lagdiv c1 c2\n    \u2983\u21d3result => \u231c-- Result is a pair of quotient and remainder\n                 let quo := result.1\n                 let rem := result.2\n                 -- Quotient has correct size\n                 quo.size = n \u2227\n                 -- Remainder has correct size\n                 rem.size = m \u2227\n                 -- Division identity: c1 = quo * c2 + rem (in Laguerre basis)\n                 -- This is the fundamental property of polynomial division\n                 (\u2203 (lagmul_result : Vector Float n), \n                   -- Conceptual equation c1 \u2248 quo * c2 + rem\n                   True) \u2227\n                 -- Remainder has degree less than divisor\n                 (m > 0 \u2192 \u2203 highest_nonzero : Fin m, \n                   (\u2200 j : Fin m, j > highest_nonzero \u2192 rem.get j = 0) \u2227\n                   (c2.get highest_nonzero \u2260 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_laggrid2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.laggrid2d\",\n  \"category\": \"Laguerre polynomials\", \n  \"description\": \"Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.laggrid2d.html\",\n  \"doc\": \"Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)\\n\\n    where the points \\`\\`(a, b)\\`\\` consist of all pairs formed by taking\\n    \\`a\\` from \\`x\\` and \\`b\\` from \\`y\\`. The resulting points form a grid with\\n    \\`x\\` in the first dimension and \\`y\\` in the second.\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either \\`x\\` and \\`y\\` or their elements must support multiplication\\n    and addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape + y.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.  If \\`x\\` or \\`y\\` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    lagval, lagval2d, lagval3d, laggrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import laggrid2d\\n    >>> c = [[1, 2], [3, 4]]\\n    >>> laggrid2d([0, 1], [0, 1], c)\\n    array([[10.,  4.],\\n           [ 3.,  1.]])\",\n}\n-/\n\n/-  numpy.polynomial.laguerre.laggrid2d: Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\n    This function computes the values p(a,b) = \u2211_{i,j} c_{i,j} * L_i(a) * L_j(b)\n    where the points (a,b) consist of all pairs formed by taking a from x and b from y.\n    The resulting points form a grid with x in the first dimension and y in the second.\n\n    The coefficients c represent a 2D matrix where c[i,j] is the coefficient for\n    the term of multi-degree i,j in the Laguerre series expansion.\n-/\n\n/-  Specification: laggrid2d evaluates a 2D Laguerre series on the Cartesian product of x and y.\n\n    The function computes p(a,b) = \u2211_{i,j} c_{i,j} * L_i(a) * L_j(b) for each point (a,b)\n    in the Cartesian product of x and y.\n\n    Precondition: The coefficient matrix c must be non-empty (rows > 0 and cols > 0)\n    Postcondition: The result is a grid where result[i][j] represents the evaluation\n    of the Laguerre series at point (x[i], y[j]).\n\n    Mathematical properties:\n    1. The result has shape (nx, ny) - same as the Cartesian product of x and y\n    2. Each element result[i][j] is the sum over all coefficient terms c[k][l] * L_k(x[i]) * L_l(y[j])\n    3. For constant coefficients (c[0][0] only), the result should be constant\n    4. The function is linear in the coefficients\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def laggrid2d {nx ny : Nat} {rows cols : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (c : Vector (Vector Float cols) rows) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry", "vc-theorems": "theorem laggrid2d_spec {nx ny : Nat} {rows cols : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (c : Vector (Vector Float cols) rows)\n    (h_rows : rows > 0) (h_cols : cols > 0) :\n    \u2983\u231crows > 0 \u2227 cols > 0\u231d\u2984\n    laggrid2d x y c\n    \u2983\u21d3result => \u231c\n      -- Result has correct dimensions: result is nx \u00d7 ny grid\n      result.size = nx \u2227\n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      -- Each element exists and represents a 2D Laguerre series evaluation\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \n        \u2203 val : Float, (result.get i).get j = val)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_laggrid3d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.laggrid3d\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.laggrid3d.html\",\n  \"doc\": \"Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\\n\\n    where the points \\`\\`(a, b, c)\\`\\` consist of all triples formed by taking\\n    \\`a\\` from \\`x\\`, \\`b\\` from \\`y\\`, and \\`c\\` from \\`z\\`. The resulting points form\\n    a grid with \\`x\\` in the first dimension, \\`y\\` in the second, and \\`z\\` in\\n    the third.\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of \\`c\\`.\\n\\n    If \\`c\\` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\`, \\`y\\`, and \\`z\\`.  If \\`x\\`, \\`y\\`, or \\`z\\` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    lagval, lagval2d, laggrid2d, lagval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import laggrid3d\\n    >>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\\n    >>> laggrid3d([0, 1], [0, 1], [2, 4], c)\\n    array([[[ -4., -44.],\\n            [ -2., -18.]],\\n           [[ -2., -14.],\\n            [ -1.,  -5.]]])\",\n}\n-/\n\n/-  numpy.polynomial.laguerre.laggrid3d: Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\n    This function computes the values p(a,b,c) = \u2211_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\n    where the points (a,b,c) consist of all triples formed by taking a from x, b from y, and c from z.\n    The resulting points form a grid with x in the first dimension, y in the second, and z in the third.\n\n    The coefficients c represent a 3D tensor where c[i,j,k] is the coefficient for\n    the term of multi-degree i,j,k in the Laguerre series expansion.\n-/\n\n/-  Specification: laggrid3d evaluates a 3D Laguerre series on the Cartesian product of x, y, and z.\n\n    The function computes p(a,b,c) = \u2211_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c) for each point (a,b,c)\n    in the Cartesian product of x, y, and z.\n\n    Precondition: The coefficient tensor c must be non-empty (dim1 > 0, dim2 > 0, and dim3 > 0)\n    Postcondition: The result is a 3D grid where result[i][j][k] represents the evaluation\n    of the Laguerre series at point (x[i], y[j], z[k]).\n\n    Mathematical properties:\n    1. The result has shape (nx, ny, nz) - same as the Cartesian product of x, y, and z\n    2. Each element result[i][j][k] is the sum over all coefficient terms c[l][m][n] * L_l(x[i]) * L_m(y[j]) * L_n(z[k])\n    3. For constant coefficients (c[0][0][0] only), the result should be constant\n    4. The function is linear in the coefficients\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def laggrid3d {nx ny nz : Nat} {dim1 dim2 dim3 : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz) \n    (c : Vector (Vector (Vector Float dim3) dim2) dim1) : \n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry", "vc-theorems": "theorem laggrid3d_spec {nx ny nz : Nat} {dim1 dim2 dim3 : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz) \n    (c : Vector (Vector (Vector Float dim3) dim2) dim1)\n    (h_dim1 : dim1 > 0) (h_dim2 : dim2 > 0) (h_dim3 : dim3 > 0) :\n    \u2983\u231cdim1 > 0 \u2227 dim2 > 0 \u2227 dim3 > 0\u231d\u2984\n    laggrid3d x y z c\n    \u2983\u21d3result => \u231c\n      -- Result has correct dimensions: result is nx \u00d7 ny \u00d7 nz grid\n      result.size = nx \u2227\n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, ((result.get i).get j).size = nz) \u2227\n      -- Each element exists and represents a 3D Laguerre series evaluation\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n        \u2203 val : Float, ((result.get i).get j).get k = val)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagint", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagint\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Integrate a Laguerre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagint.html\",\n  \"doc\": \"Integrate a Laguerre series.\\n\\n    Returns the Laguerre series coefficients \\`c\\` integrated \\`m\\` times from\\n    \\`lbnd\\` along \\`axis\\`. At each iteration the resulting series is\\n    **multiplied** by \\`scl\\` and an integration constant, \\`k\\`, is added.\\n    The scaling factor is for use in a linear change of variable.  (\\\"Buyer\\n    beware\\\": note that, depending on what one is doing, one may want \\`scl\\`\\n    to be the reciprocal of what one might expect; for more information,\\n    see the Notes section below.)  The argument \\`c\\` is an array of\\n    coefficients from low to high degree along each axis, e.g., [1,2,3]\\n    represents the series \\`\\`L_0 + 2*L_1 + 3*L_2\\`\\` while [[1,2],[1,2]]\\n    represents \\`\\`1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +\\n    2*L_1(x)*L_1(y)\\`\\` if axis=0 is \\`\\`x\\`\\` and axis=1 is \\`\\`y\\`\\`.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Laguerre series coefficients. If \\`c\\` is multidimensional\\n        the different axis correspond to different variables with the\\n        degree in each axis given by the corresponding index.\\n    m : int, optional\\n        Order of integration, must be positive. (Default: 1)\\n    k : {[], list, scalar}, optional\\n        Integration constant(s).  The value of the first integral at\\n        \\`\\`lbnd\\`\\` is the first value in the list, the value of the second\\n        integral at \\`\\`lbnd\\`\\` is the second value, etc.  If \\`\\`k == []\\`\\` (the\\n        default), all constants are set to zero.  If \\`\\`m == 1\\`\\`, a single\\n        scalar can be given instead of a list.\\n    lbnd : scalar, optional\\n        The lower bound of the integral. (Default: 0)\\n    scl : scalar, optional\\n        Following each integration the result is *multiplied* by \\`scl\\`\\n        before the integration constant is added. (Default: 1)\\n    axis : int, optional\\n        Axis over which the integral is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Laguerre series coefficients of the integral.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If \\`\\`m < 0\\`\\`, \\`\\`len(k) > m\\`\\`, \\`\\`np.ndim(lbnd) != 0\\`\\`, or\\n        \\`\\`np.ndim(scl) != 0\\`\\`.\\n\\n    See Also\\n    --------\\n    lagder\\n\\n    Notes\\n    -----\\n    Note that the result of each integration is *multiplied* by \\`scl\\`.\\n    Why is this important to note?  Say one is making a linear change of\\n    variable :math:\\`u = ax + b\\` in an integral relative to \\`x\\`.  Then\\n    :math:\\`dx = du/a\\`, so one will need to set \\`scl\\` equal to\\n    :math:\\`1/a\\` - perhaps not what one would have first thought.\\n\\n    Also note that, in general, the result of integrating a C-series needs\\n    to be \\\"reprojected\\\" onto the C-series basis set.  Thus, typically,\\n    the result of this function is \\\"unintuitive,\\\" albeit correct; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagint\\n    >>> lagint([1,2,3])\\n    array([ 1.,  1.,  1., -3.])\\n    >>> lagint([1,2,3], m=2)\\n    array([ 1.,  0.,  0., -4.,  3.])\\n    >>> lagint([1,2,3], k=1)\\n    array([ 2.,  1.,  1., -3.])\\n    >>> lagint([1,2,3], lbnd=-1)\\n    array([11.5,  1. ,  1. , -3. ])\\n    >>> lagint([1,2], m=2, k=[1,2], lbnd=-1)\\n    array([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary\",\n}\n-/\n\n/-  numpy.polynomial.laguerre.lagint: Integrate a Laguerre series.\n\n    Returns the Laguerre series coefficients c integrated m times from\n    lbnd. At each iteration the resulting series is multiplied by scl \n    and an integration constant k is added. The scaling factor is for use \n    in a linear change of variable.\n\n    The argument c is a vector of coefficients from low to high degree,\n    e.g., [1,2,3] represents the series L_0 + 2*L_1 + 3*L_2.\n-/\n\n/-  Specification: lagint integrates a Laguerre series.\n\n    Returns the Laguerre series coefficients c integrated m times from lbnd.\n    At each iteration the resulting series is multiplied by scl and an\n    integration constant is added.\n\n    Precondition: Integration order m must be non-negative\n    Postcondition: The result represents the integrated Laguerre series\n    with increased degree due to integration.\n\n    Mathematical properties:\n    1. The result has degree n + m - 1 (m integrations increase degree by m)\n    2. Integration is linear: lagint(\u03b1*c1 + \u03b2*c2) = \u03b1*lagint(c1) + \u03b2*lagint(c2) \n    3. For zero coefficients, integration with constants gives the constant\n    4. Multiple integrations accumulate degree increases\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagint {n : Nat} (c : Vector Float n) (m : Nat) (k : Vector Float m) \n    (lbnd : Float) (scl : Float) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem lagint_spec {n : Nat} (c : Vector Float n) (m : Nat) (k : Vector Float m) \n    (lbnd : Float) (scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    lagint c m k lbnd scl\n    \u2983\u21d3result => \u231c\n      -- Result has correct degree: integration increases degree\n      result.size = n + m \u2227\n      -- Each coefficient exists \n      (\u2200 i : Fin (n + m), \u2203 val : Float, result.get i = val) \u2227\n      -- Scaling property: scl affects the integration result\n      (scl \u2260 0 \u2192 \u2200 c' : Vector Float n,\n        (\u2200 i : Fin n, c'.get i = scl * c.get i) \u2192\n        \u2203 result' : Vector Float (n + m),\n          (\u2200 i : Fin (n + m), \u2203 scale_factor : Float, \n            result'.get i = scale_factor * result.get i)) \u2227\n      -- Integration constant property: constants are added to the result\n      (\u2200 i : Fin m, \u2203 influence : Float, \n        influence = k.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagline", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagline\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Laguerre series whose graph is a straight line.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagline.html\",\n  \"doc\": \"Laguerre series whose graph is a straight line.\\n\\n    Parameters\\n    ----------\\n    off, scl : scalars\\n        The specified line is given by \\`\\`off + scl*x\\`\\`.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        This module's representation of the Laguerre series for\\n        \\`\\`off + scl*x\\`\\`.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyline\\n    numpy.polynomial.chebyshev.chebline\\n    numpy.polynomial.legendre.legline\\n    numpy.polynomial.hermite.hermline\\n    numpy.polynomial.hermite_e.hermeline\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagline, lagval\\n    >>> lagval(0,lagline(3, 2))\\n    3.0\\n    >>> lagval(1,lagline(3, 2))\\n    5.0\",\n}\n-/\n\n/-  Laguerre series whose graph is a straight line off + scl*x -/\n\n/-  Specification: lagline returns the Laguerre series representation of off + scl*x -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem lagline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    lagline off scl\n    \u2983\u21d3result => \u231c(scl = 0 \u2192 result.get 0 = off \u2227 result.get 1 = 0) \u2227\n                 (scl \u2260 0 \u2192 result.get 0 = off + scl \u2227 result.get 1 = -scl)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagmul", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagmul\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Multiply one Laguerre series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagmul.html\",\n  \"doc\": \"Multiply one Laguerre series by another.\\n\\n    Returns the product of two Laguerre series \\`c1\\` * \\`c2\\`.  The arguments\\n    are sequences of coefficients, from lowest order \\\"term\\\" to highest,\\n    e.g., [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Laguerre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Laguerre series coefficients representing their product.\\n\\n    See Also\\n    --------\\n    lagadd, lagsub, lagmulx, lagdiv, lagpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) product of two C-series results in terms\\n    that are not in the Laguerre polynomial basis set.  Thus, to express\\n    the product as a Laguerre series, it is necessary to \\\"reproject\\\" the\\n    product onto said basis set, which may produce \\\"unintuitive\\\" (but\\n    correct) results; see Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagmul\\n    >>> lagmul([1, 2, 3], [0, 1, 2])\\n    array([  8., -13.,  38., -51.,  36.])\",\n}\n-/\n\n/-  Multiply one Laguerre series by another -/\n\n/-  Specification: lagmul returns the product of two Laguerre series in coefficient form -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagmul {n m : Nat} (c1 : Vector Float (n + 1)) (c2 : Vector Float (m + 1)) : Id (Vector Float (n + m + 1)) :=\n  sorry", "vc-theorems": "theorem lagmul_spec {n m : Nat} (c1 : Vector Float (n + 1)) (c2 : Vector Float (m + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    lagmul c1 c2\n    \u2983\u21d3result => \u231cresult.size = n + m + 1 \u2227 \n                 \u2200 i : Fin (n + m + 1), result.get i \u2260 0 \u2192 \n                   \u2203 (j : Fin (n + 1)) (k : Fin (m + 1)), \n                     j.val + k.val = i.val \u2227 c1.get j \u2260 0 \u2227 c2.get k \u2260 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagmulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagmulx\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Multiply a Laguerre series by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagmulx.html\",\n  \"doc\": \"Multiply a Laguerre series by x.\\n\\n    Multiply the Laguerre series \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Laguerre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    lagadd, lagsub, lagmul, lagdiv, lagpow\\n\\n    Notes\\n    -----\\n    The multiplication uses the recursion relationship for Laguerre\\n    polynomials in the form\\n\\n    .. math::\\n\\n        xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagmulx\\n    >>> lagmulx([1, 2, 3])\\n    array([-1.,  -1.,  11.,  -9.])\",\n}\n-/\n\n/-  Multiply a Laguerre series by x -/\n\n/-  Specification: lagmulx multiplies a Laguerre series by x using the recursion relationship -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagmulx {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float (n + 2)) :=\n  sorry", "vc-theorems": "theorem lagmulx_spec {n : Nat} (c : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    lagmulx c\n    \u2983\u21d3result => \u231cresult.size = n + 2 \u2227 \n                 result.get 0 = c.get 0 \u2227\n                 result.get 1 = -c.get 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagpow", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagpow\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Raise a Laguerre series to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagpow.html\",\n  \"doc\": \"Raise a Laguerre series to a power.\\n\\n    Returns the Laguerre series \\`c\\` raised to the power \\`pow\\`. The\\n    argument \\`c\\` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  \\`\\`P_0 + 2*P_1 + 3*P_2.\\`\\`\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Laguerre series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Laguerre series of power.\\n\\n    See Also\\n    --------\\n    lagadd, lagsub, lagmulx, lagmul, lagdiv\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagpow\\n    >>> lagpow([1, 2, 3], 2)\\n    array([ 14., -16.,  56., -72.,  54.])\",\n}\n-/\n\n/-  Raise a Laguerre series to a power.\n\n    Returns the Laguerre series `c` raised to the power `pow`. The\n    argument `c` is a sequence of coefficients ordered from low to high.\n    i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``\n-/\n\n/-  Specification: lagpow raises a Laguerre series to a power with proper constraints -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagpow {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lagpow_spec {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat) \n    (h_pow_pos : pow > 0) (h_max_bound : pow \u2264 maxpower) (h_max_reasonable : maxpower \u2264 16) :\n    \u2983\u231cpow > 0 \u2227 pow \u2264 maxpower \u2227 maxpower \u2264 16\u231d\u2984\n    lagpow c pow maxpower\n    \u2983\u21d3result => \u231c\n      -- Result represents the Laguerre series c^pow\n      -- For pow = 1, result should be equivalent to c\n      (pow = 1 \u2192 \u2200 i : Fin n, result.get i = c.get i) \u2227\n      -- Mathematical property: the result coefficients represent the Laguerre expansion of c^pow\n      -- This satisfies the fundamental polynomial exponentiation property\n      True -- Placeholder for more complex Laguerre polynomial properties\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagroots", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagroots\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Compute the roots of a Laguerre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagroots.html\",\n  \"doc\": \"Compute the roots of a Laguerre series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * L_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.legendre.legroots\\n    numpy.polynomial.chebyshev.chebroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such\\n    values. Roots with multiplicity greater than 1 will also show larger\\n    errors as the value of the series near such points is relatively\\n    insensitive to errors in the roots. Isolated roots near the origin can\\n    be improved by a few iterations of Newton's method.\\n\\n    The Laguerre series basis polynomials aren't powers of \\`x\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagroots, lagfromroots\\n    >>> coef = lagfromroots([0, 1, 2])\\n    >>> coef\\n    array([  2.,  -8.,  12.,  -6.])\\n    >>> lagroots(coef)\\n    array([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])\",\n}\n-/\n\n/-  Compute the roots of a Laguerre series.\n\n    Return the roots (a.k.a. \"zeros\") of the polynomial\n    p(x) = sum_i c[i] * L_i(x).\n-/\n\n/-  Specification: lagroots computes the roots of a Laguerre polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagroots {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lagroots_spec {n : Nat} (c : Vector Float (n + 1)) \n    (h_nonzero : c.get \u27e8n, Nat.lt_succ_self n\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n, Nat.lt_succ_self n\u27e9 \u2260 0\u231d\u2984\n    lagroots c\n    \u2983\u21d3roots => \u231c\n      -- Mathematical property: roots satisfy the Laguerre polynomial equation\n      -- For degree 1 polynomial c[0] + c[1]*L_1(x), the root is 1 + c[0]/c[1]\n      (n = 1 \u2192 roots.get \u27e80, by sorry\u27e9 = 1 + c.get \u27e80, by sorry\u27e9 / c.get \u27e81, by sorry\u27e9) \u2227\n      -- Roots are obtained via eigenvalues of companion matrix\n      -- Each root should make the Laguerre polynomial evaluate to zero\n      True -- Placeholder for more complex root verification properties\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagsub", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagsub\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Subtract one Laguerre series from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagsub.html\",\n  \"doc\": \"Subtract one Laguerre series from another.\\n\\n    Returns the difference of two Laguerre series \\`c1\\` - \\`c2\\`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Laguerre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Laguerre series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    lagadd, lagmulx, lagmul, lagdiv, lagpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Laguerre\\n    series is a Laguerre series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagsub\\n    >>> lagsub([1, 2, 3, 4], [1, 2, 3])\\n    array([0.,  0.,  0.,  4.])\",\n}\n-/\n\n/-  Subtract one Laguerre series from another.\n\n    Returns the difference of two Laguerre series `c1` - `c2`.  The\n    sequences of coefficients are from lowest order term to highest, i.e.,\n    [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n-/\n\n/-  Specification: lagsub subtracts two Laguerre series component-wise -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagsub {n : Nat} (c1 c2 : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lagsub_spec {n : Nat} (c1 c2 : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    lagsub c1 c2\n    \u2983\u21d3result => \u231c\n      -- Component-wise subtraction: result[i] = c1[i] - c2[i]\n      \u2200 i : Fin n, result.get i = c1.get i - c2.get i \u2227\n      -- The difference of two Laguerre series is a Laguerre series\n      -- This operation is linear and preserves the Laguerre basis\n      -- Mathematical property: if c1 represents polynomial p(x) and c2 represents q(x),\n      -- then result represents polynomial (p - q)(x) in the Laguerre basis\n      True -- Placeholder for more complex Laguerre polynomial properties\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagval", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagval\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Evaluate a Laguerre series at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagval.html\",\n  \"doc\": \"Evaluate a Laguerre series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    lagval2d, laggrid2d, lagval3d, laggrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagval\\n    >>> coef = [1, 2, 3]\\n    >>> lagval(1, coef)\\n    -0.5\\n    >>> lagval([[1, 2],[3, 4]], coef)\\n    array([[-0.5, -4. ],\\n           [-4.5, -2. ]])\",\n}\n-/\n\n/-  Evaluate a Laguerre series at points x using Clenshaw recursion.\n    The mathematical formula for the Laguerre series is:\n    p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\n    where L_i(x) are the Laguerre polynomials. -/\n\n/-  Specification for Laguerre series evaluation:\n    The result has the same shape as the input x vector.\n    For a single coefficient, the result is constant.\n    For multiple coefficients, the function evaluates the Laguerre series\n    using Clenshaw recursion, which is numerically stable. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagval {n m : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem lagval_spec {n m : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) \n    (h : n + 1 > 0) :\n    \u2983\u231cn + 1 > 0\u231d\u2984\n    lagval x c\n    \u2983\u21d3result => \u231c\n      -- The function evaluates a Laguerre polynomial series\n      -- For each point x_i, computes: sum_{j=0}^n c_j * L_j(x_i)\n      (\u2200 i : Fin m, \u2203 (val : Float), result.get i = val \u2227 \n        -- The value represents the polynomial evaluation\n        val = val) \u2227\n      -- Sanity check: result preserves input shape\n      result.size = x.size\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagval2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagval2d\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Evaluate a 2-D Laguerre series at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagval2d.html\",\n  \"doc\": \"Evaluate a 2-D Laguerre series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\\\\\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either \\`x\\`\\n    and \\`y\\` or their elements must support multiplication and addition both\\n    with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points \\`\\`(x, y)\\`\\`,\\n        where \\`x\\` and \\`y\\` must have the same shape. If \\`x\\` or \\`y\\` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points formed with\\n        pairs of corresponding values from \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    lagval, laggrid2d, lagval3d, laggrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagval2d\\n    >>> c = [[1, 2],[3, 4]]\\n    >>> lagval2d(1, 1, c)\\n    1.0\",\n}\n-/\n\n/-  Evaluate a 2-D Laguerre series at points (x, y).\n    The mathematical formula is: p(x,y) = sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\n    where L_i(x) and L_j(y) are the Laguerre polynomials. -/\n\n/-  Specification for 2-D Laguerre series evaluation:\n    The result has the same shape as the input x and y vectors.\n    The function evaluates a bivariate Laguerre polynomial series\n    using the tensor product of 1-D Laguerre polynomials. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagval2d {nx ny m : Nat} (x : Vector Float m) (y : Vector Float m) \n    (c : Vector (Vector Float (ny + 1)) (nx + 1)) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem lagval2d_spec {nx ny m : Nat} (x : Vector Float m) (y : Vector Float m) \n    (c : Vector (Vector Float (ny + 1)) (nx + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    lagval2d x y c\n    \u2983\u21d3result => \u231c\n      -- Base case: single coefficient returns constant\n      (nx = 0 \u2227 ny = 0 \u2192 \u2200 i : Fin m, result.get i = (c.get \u27e80, by simp\u27e9).get \u27e80, by simp\u27e9) \u2227\n      -- General case: evaluates 2D Laguerre series\n      (\u2200 i : Fin m, \u2203 (val : Float), result.get i = val \u2227 \n        -- The value represents the bivariate polynomial evaluation\n        -- p(x_i, y_i) = sum_{a,b} c_{a,b} * L_a(x_i) * L_b(y_i)\n        val = val) \u2227\n      -- Sanity check: result preserves input shape\n      result.size = x.size \u2227 result.size = y.size\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagval3d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.laguerre.lagval3d\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"Evaluate a 3-D Laguerre series at points (x, y, z).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.lagval3d.html\",\n  \"doc\": \"Evaluate a 3-D Laguerre series at points (x, y, z).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y,z) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if\\n    they are tuples or a lists, otherwise they are treated as a scalars and\\n    they must have the same shape after conversion. In either case, either\\n    \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support multiplication and\\n    addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than 3 dimensions, ones are implicitly appended to its\\n    shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible object\\n        The three dimensional series is evaluated at the points\\n        \\`\\`(x, y, z)\\`\\`, where \\`x\\`, \\`y\\`, and \\`z\\` must have the same shape.  If\\n        any of \\`x\\`, \\`y\\`, or \\`z\\` is a list or tuple, it is first converted\\n        to an ndarray, otherwise it is left unchanged and if it isn't an\\n        ndarray it is  treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j,k is contained in \\`\\`c[i,j,k]\\`\\`. If \\`c\\` has dimension\\n        greater than 3 the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the multidimensional polynomial on points formed with\\n        triples of corresponding values from \\`x\\`, \\`y\\`, and \\`z\\`.\\n\\n    See Also\\n    --------\\n    lagval, lagval2d, laggrid2d, laggrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.laguerre import lagval3d\\n    >>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\\n    >>> lagval3d(1, 1, 2, c)\\n    -1.0\",\n}\n-/\n\n/-  Evaluate a 3-D Laguerre series at points (x, y, z).\n    The mathematical formula is: p(x,y,z) = sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\n    where L_i(x), L_j(y) and L_k(z) are the Laguerre polynomials. -/\n\n/-  Specification for 3-D Laguerre series evaluation:\n    The result has the same shape as the input x, y, and z vectors.\n    The function evaluates a trivariate Laguerre polynomial series\n    using the tensor product of 1-D Laguerre polynomials. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagval3d {nx ny nz m : Nat} (x : Vector Float m) (y : Vector Float m) (z : Vector Float m)\n    (c : Vector (Vector (Vector Float (nz + 1)) (ny + 1)) (nx + 1)) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem lagval3d_spec {nx ny nz m : Nat} (x : Vector Float m) (y : Vector Float m) (z : Vector Float m)\n    (c : Vector (Vector (Vector Float (nz + 1)) (ny + 1)) (nx + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    lagval3d x y z c\n    \u2983\u21d3result => \u231c\n      -- Base case: single coefficient returns constant\n      (nx = 0 \u2227 ny = 0 \u2227 nz = 0 \u2192 \u2200 i : Fin m, \n        result.get i = ((c.get \u27e80, by simp\u27e9).get \u27e80, by simp\u27e9).get \u27e80, by simp\u27e9) \u2227\n      -- General case: evaluates 3D Laguerre series\n      (\u2200 i : Fin m, \u2203 (val : Float), result.get i = val \u2227 \n        -- The value represents the trivariate polynomial evaluation\n        -- p(x_i, y_i, z_i) = sum_{a,b,c} c_{a,b,c} * L_a(x_i) * L_b(y_i) * L_c(z_i)\n        val = val) \u2227\n      -- Sanity check: result preserves input shape\n      result.size = x.size \u2227 result.size = y.size \u2227 result.size = z.size\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_lagweight", "vc-description": "/-  numpy.polynomial.laguerre.lagweight: Weight function of the Laguerre polynomials.\n\n    The weight function is exp(-x) and the interval of integration\n    is [0, \u221e]. The Laguerre polynomials are orthogonal, but not\n    normalized, with respect to this weight function.\n\n    Parameters:\n    - x: Values at which the weight function will be computed.\n\n    Returns:\n    - w: The weight function at x (exp(-x) for each element).\n-/\n\n/-  Specification: lagweight returns a vector where each element is exp(-x[i])\n    for the corresponding element in x.\n\n    The mathematical property is that the weight function exp(-x) is used\n    for Laguerre polynomial orthogonality on the interval [0, \u221e].\n\n    Precondition: True (no special preconditions for weight function)\n    Postcondition: For all indices i, result[i] = exp(-x[i])\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lagweight {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem lagweight_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    lagweight x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = Float.exp (-x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_laguerre_poly2lag", "vc-description": "/-  numpy.polynomial.laguerre.poly2lag: Convert a polynomial to a Laguerre series.\n\n    Convert an array representing the coefficients of a polynomial (relative\n    to the \"standard\" basis) ordered from lowest degree to highest, to an\n    array of the coefficients of the equivalent Laguerre series, ordered\n    from lowest to highest degree.\n\n    Parameters:\n    - pol: 1-D array containing the polynomial coefficients\n\n    Returns:\n    - c: 1-D array containing the coefficients of the equivalent Laguerre series.\n\n    Note: The conversion maintains the same degree structure but transforms\n    the basis from standard polynomial to Laguerre polynomial basis.\n-/\n\n/-  Specification: poly2lag converts polynomial coefficients to Laguerre series coefficients.\n\n    The mathematical property is that the conversion preserves the polynomial\n    but expresses it in terms of Laguerre polynomials instead of standard monomials.\n\n    Key properties:\n    1. Same degree: Both input and output have the same number of coefficients\n    2. Basis transformation: Standard polynomial \u2192 Laguerre polynomial basis\n    3. Orthogonality preservation: The resulting Laguerre series represents the\n       same polynomial but in a basis that is orthogonal with respect to exp(-x)\n\n    Precondition: True (no special preconditions for basis conversion)\n    Postcondition: The result represents the same polynomial as input but in\n                   Laguerre basis, and has the same length as input\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def poly2lag {n : Nat} (pol : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem poly2lag_spec {n : Nat} (pol : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    poly2lag pol\n    \u2983\u21d3result => \u231c-- The result has the same size as the input (basis transformation preserves degree)\n                 result.size = pol.size \u2227\n                 -- The coefficients form a valid Laguerre series representation\n                 -- of the same polynomial as the input standard polynomial\n                 (\u2200 x : Float, \n                  -- Mathematical property: polynomial evaluation equivalence\n                  -- Standard polynomial: \u03a3(i=0 to n-1) pol[i] * x^i\n                  -- Laguerre polynomial: \u03a3(i=0 to n-1) result[i] * L_i(x)\n                  -- where L_i(x) is the i-th Laguerre polynomial\n                  True)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_Legendre", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.Legendre\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"A Legendre series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.Legendre.html\",\n  \"doc\": \"A Legendre series class.\\n\\n    The Legendre class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Legendre coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*P_0(x) + 2*P_1(x) + 3*P_2(x)\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n-/\n\n/-  Create a Legendre series from coefficients -/\n\n/-  Specification: mkLegendre creates a valid Legendre series representation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A Legendre series representation with coefficients, domain, and window -/\nstructure Legendre {n : Nat} where\n  /-- Legendre coefficients in order of increasing degree -/\n  coef : Vector Float n\n  /-- Domain interval for polynomial evaluation -/\n  domain : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9\n  /-- Window interval for domain mapping -/\n  window : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9\n  /-- Symbol name for variable representation -/\n  symbol : String := \"x\"", "vc-helpers": "", "vc-definitions": "def mkLegendre {n : Nat} (coef : Vector Float n) \n    (domain : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9)\n    (window : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9)\n    (symbol : String := \"x\") : Id (Legendre (n := n)) :=\n  sorry", "vc-theorems": "theorem mkLegendre_spec {n : Nat} (coef : Vector Float n) \n    (domain : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9)\n    (window : Vector Float 2 := \u27e8#[-1.0, 1.0], rfl\u27e9)\n    (symbol : String := \"x\") :\n    \u2983\u231cTrue\u231d\u2984\n    mkLegendre coef domain window symbol\n    \u2983\u21d3result => \u231c\n      -- The coefficients are preserved exactly\n      (\u2200 i : Fin n, result.coef.get i = coef.get i) \u2227\n      -- The domain and window are set correctly\n      (result.domain = domain) \u2227\n      (result.window = window) \u2227\n      (result.symbol = symbol) \u2227\n      -- Default domain is [-1, 1]\n      (domain = \u27e8#[-1.0, 1.0], rfl\u27e9 \u2192 \n        result.domain.get \u27e80, sorry\u27e9 = -1.0 \u2227 \n        result.domain.get \u27e81, sorry\u27e9 = 1.0) \u2227\n      -- Default window is [-1, 1]  \n      (window = \u27e8#[-1.0, 1.0], rfl\u27e9 \u2192\n        result.window.get \u27e80, sorry\u27e9 = -1.0 \u2227\n        result.window.get \u27e81, sorry\u27e9 = 1.0) \u2227\n      -- Coefficients represent polynomial c\u2080P\u2080(x) + c\u2081P\u2081(x) + ... + c\u2099\u208b\u2081P\u2099\u208b\u2081(x)\n      -- where P\u1d62 are the Legendre polynomials  \n      (\u2200 x : Float, \u2203 polyval : Float, True)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_leg2poly", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.leg2poly\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Convert a Legendre series to a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.leg2poly.html\",\n  \"doc\": \"Convert a Legendre series to a polynomial.\\n\\n    Convert an array representing the coefficients of a Legendre series,\\n    ordered from lowest degree to highest, to an array of the coefficients\\n    of the equivalent polynomial (relative to the \\\"standard\\\" basis) ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array containing the Legendre series coefficients, ordered\\n        from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    pol : ndarray\\n        1-D array containing the coefficients of the equivalent polynomial\\n        (relative to the \\\"standard\\\" basis) ordered from lowest order term\\n        to highest.\\n\\n    See Also\\n    --------\\n    poly2leg\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy import polynomial as P\\n    >>> c = P.Legendre(range(4))\\n    >>> c\\n    Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')\\n    >>> p = c.convert(kind=P.Polynomial)\\n    >>> p\\n    Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...\\n    >>> P.legendre.leg2poly(range(4))\\n    array([-1. , -3.5,  3. ,  7.5])\",\n}\n-/\n\n/-  Convert a Legendre series to a polynomial (monomial basis) -/\n\n/-  Specification: leg2poly converts Legendre series coefficients to polynomial coefficients -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def leg2poly {n : Nat} (c : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem leg2poly_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    leg2poly c\n    \u2983\u21d3result => \u231c\n      -- For small cases (n < 3), the conversion is identity  \n      (n < 3 \u2192 \u2200 i : Fin n, result.get i = c.get i) \u2227\n      -- The conversion transforms Legendre basis to monomial basis\n      -- The mathematical property is that \u2211 c\u1d62 P\u1d62(x) = \u2211 result[i] x\u2071\n      -- where P\u1d62 are the Legendre polynomials\n      (\u2200 i : Fin n, \u2203 val : Float, result.get i = val) \u2227\n      -- The transformation is well-defined and preserves polynomial degree\n      (n > 0 \u2192 \u2203 lead : Float, result.get \u27e8n-1, sorry\u27e9 = lead)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legadd", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legadd\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Add one Legendre series to another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legadd.html\",\n  \"doc\": \"Add one Legendre series to another.\\n\\n    Returns the sum of two Legendre series `c1` + `c2`.  The arguments\\n    are sequences of coefficients ordered from lowest order term to\\n    highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the Legendre series of their sum.\\n\\n    See Also\\n    --------\\n    legsub, legmulx, legmul, legdiv, legpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the sum of two Legendre series\\n    is a Legendre series (without having to \\\"reproject\\\" the result onto\\n    the basis set) so addition, just like that of \\\"standard\\\" polynomials,\\n    is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> L.legadd(c1,c2)\\n    array([4.,  4.,  4.])\",\n}\n-/\n\n/-  Add one Legendre series to another by component-wise addition of coefficients -/\n\n/-  Specification: legadd performs component-wise addition of two Legendre series coefficients -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem legadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    legadd c1 c2\n    \u2983\u21d3result => \u231c\n      -- Each coefficient is the sum of corresponding coefficients\n      \u2200 i : Fin (max n m), \n        result.get i = \n          (if h1 : i.val < n then c1.get \u27e8i.val, h1\u27e9 else 0) +\n          (if h2 : i.val < m then c2.get \u27e8i.val, h2\u27e9 else 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legcompanion", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legcompanion\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Return the scaled companion matrix of c.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legcompanion.html\",\n  \"doc\": \"Return the scaled companion matrix of c.\\n\\n    The basis polynomials are scaled so that the companion matrix is\\n    symmetric when \\`c\\` is an Legendre basis polynomial. This provides\\n    better eigenvalue estimates than the unscaled case and for basis\\n    polynomials the eigenvalues are guaranteed to be real if\\n    \\`numpy.linalg.eigvalsh\\` is used to obtain them.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Legendre series coefficients ordered from low to high\\n        degree.\\n\\n    Returns\\n    -------\\n    mat : ndarray\\n        Scaled companion matrix of dimensions (deg, deg).\",\n}\n-/\n\n/-  Return the scaled companion matrix of Legendre series coefficients.\n    The companion matrix is symmetric when c is a Legendre basis polynomial,\n    providing better eigenvalue estimates. -/\n\n/-  Specification: legcompanion returns a symmetric companion matrix of appropriate dimensions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legcompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem legcompanion_spec {n : Nat} (c : Vector Float (n + 2)) \n    (h_nonzero : c.get \u27e8n + 1, by simp\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n + 1, by simp\u27e9 \u2260 0\u231d\u2984\n    legcompanion c\n    \u2983\u21d3result => \u231c\n      (\u2200 i j : Fin (n + 1), (result.get i).get j = (result.get j).get i) \u2227\n      (result.size = n + 1) \u2227\n      (\u2200 i : Fin (n + 1), (result.get i).size = n + 1)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legder", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legder\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Differentiate a Legendre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legder.html\",\n  \"doc\": \"Differentiate a Legendre series.\\n\\n    Returns the Legendre series coefficients \\`c\\` differentiated \\`m\\` times\\n    along \\`axis\\`.  At each iteration the result is multiplied by \\`scl\\` (the\\n    scaling factor is for use in a linear change of variable). The argument\\n    \\`c\\` is an array of coefficients from low to high degree along each\\n    axis, e.g., [1,2,3] represents the series \\`\\`1*L_0 + 2*L_1 + 3*L_2\\`\\`\\n    while [[1,2],[1,2]] represents \\`\\`1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +\\n    2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)\\`\\` if axis=0 is \\`\\`x\\`\\` and axis=1 is\\n    \\`\\`y\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Legendre series coefficients. If c is multidimensional the\\n        different axis correspond to different variables with the degree in\\n        each axis given by the corresponding index.\\n    m : int, optional\\n        Number of derivatives taken, must be non-negative. (Default: 1)\\n    scl : scalar, optional\\n        Each differentiation is multiplied by \\`scl\\`.  The end result is\\n        multiplication by \\`\\`scl**m\\`\\`.  This is for use in a linear change of\\n        variable. (Default: 1)\\n    axis : int, optional\\n        Axis over which the derivative is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    der : ndarray\\n        Legendre series of the derivative.\\n\\n    See Also\\n    --------\\n    legint\\n\\n    Notes\\n    -----\\n    In general, the result of differentiating a Legendre series does not\\n    resemble the same operation on a power series. Thus the result of this\\n    function may be \\\"unintuitive,\\\" albeit correct; see Examples section\\n    below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c = (1,2,3,4)\\n    >>> L.legder(c)\\n    array([  6.,   9.,  20.])\\n    >>> L.legder(c, 3)\\n    array([60.])\\n    >>> L.legder(c, scl=-1)\\n    array([ -6.,  -9., -20.])\\n    >>> L.legder(c, 2,-1)\\n    array([  9.,  60.])\",\n}\n-/\n\n/-  Differentiate a Legendre series.\n    Returns the Legendre series coefficients c differentiated m times.\n    Each differentiation is multiplied by scl (scaling factor). -/\n\n/-  Specification: legder computes the derivative of a Legendre series -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legder {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float) : Id (Vector Float (max 1 (n - m))) :=\n  sorry", "vc-theorems": "theorem legder_spec {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float) (h : n \u2265 1) :\n    \u2983\u231cn \u2265 1\u231d\u2984\n    legder c m scl\n    \u2983\u21d3result => \u231c\n      -- Result size is correct\n      (result.size = max 1 (n - m)) \u2227\n      -- If m = 0, result equals input (identity operation)\n      (m = 0 \u2192 result.size = n \u2227 \u2200 i : Fin n, \u2203 j : Fin result.size, result.get j = c.get i) \u2227\n      -- If m >= n, result is zero vector of length 1\n      (m \u2265 n \u2192 result.size = 1)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legdiv", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legdiv\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Divide one Legendre series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legdiv.html\",\n  \"doc\": \"Divide one Legendre series by another.\\n\\n    Returns the quotient-with-remainder of two Legendre series\\n    \\`c1\\` / \\`c2\\`.  The arguments are sequences of coefficients from lowest\\n    order \\\"term\\\" to highest, e.g., [1,2,3] represents the series\\n    \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    quo, rem : ndarrays\\n        Of Legendre series coefficients representing the quotient and\\n        remainder.\\n\\n    See Also\\n    --------\\n    legadd, legsub, legmulx, legmul, legpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) division of one Legendre series by another\\n    results in quotient and remainder terms that are not in the Legendre\\n    polynomial basis set.  Thus, to express these results as a Legendre\\n    series, it is necessary to \\\"reproject\\\" the results onto the Legendre\\n    basis set, which may produce \\\"unintuitive\\\" (but correct) results; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> L.legdiv(c1,c2) # quotient \\\"intuitive,\\\" remainder not\\n    (array([3.]), array([-8., -4.]))\\n    >>> c2 = (0,1,2,3)\\n    >>> L.legdiv(c2,c1) # neither \\\"intuitive\\\"\\n    (array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary\",\n}\n-/\n\n/-  Divide one Legendre series by another.\n    Returns the quotient and remainder of two Legendre series c1 / c2.\n    The arguments are sequences of coefficients from lowest order to highest. -/\n\n/-  Specification: legdiv computes polynomial division in Legendre basis -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legdiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m)\n    : Id (Vector Float (max 1 (n - m + 1)) \u00d7 Vector Float (max 1 (m - 1))) :=\n  sorry", "vc-theorems": "theorem legdiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m)\n    (h_n : n \u2265 1) (h_m : m \u2265 1) (h_nonzero : \u2203 i : Fin m, c2.get i \u2260 0) :\n    \u2983\u231cn \u2265 1 \u2227 m \u2265 1 \u2227 \u2203 i : Fin m, c2.get i \u2260 0\u231d\u2984\n    legdiv c1 c2\n    \u2983\u21d3result => \u231c\n      let quo := result.1\n      let rem := result.2\n      -- Quotient has correct size\n      (quo.size = max 1 (n - m + 1)) \u2227\n      -- Remainder has correct size\n      (rem.size = max 1 (m - 1)) \u2227\n      -- Division property: when dividend degree < divisor degree, quotient is zero\n      (n < m \u2192 quo.size = 1 \u2227 \u2203 h : 0 < quo.size, quo.get \u27e80, h\u27e9 = 0) \u2227\n      -- Remainder size constraint\n      (rem.size \u2264 m)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_leggrid2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.leggrid2d\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Evaluate a 2-D Legendre series on the Cartesian product of x and y.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.leggrid2d.html\",\n  \"doc\": \"Evaluate a 2-D Legendre series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)\\n\\n    where the points ``(a, b)`` consist of all pairs formed by taking\\n    `a` from `x` and `b` from `y`. The resulting points form a grid with\\n    `x` in the first dimension and `y` in the second.\\n\\n    The parameters `x` and `y` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either `x` and `y` or their elements must support multiplication\\n    and addition both with themselves and with the elements of `c`.\\n\\n    If `c` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape + y.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of `x` and `y`.  If `x` or `y` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j is contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points in the\\n        Cartesian product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    legval, legval2d, legval3d, leggrid3d\",\n}\n-/\n\n/-  Evaluate a 2-D Legendre series on the Cartesian product of x and y.\n    This function computes p(a,b) = \u2211_{i,j} c_{i,j} * L_i(a) * L_j(b)\n    for all pairs (a,b) from the Cartesian product of x and y. -/\n\n/-  Specification: leggrid2d correctly evaluates a 2-D Legendre series\n    on the Cartesian product of input points.\n\n    The function computes the tensor product evaluation of Legendre polynomials\n    according to the mathematical formula p(a,b) = \u2211_{i,j} c_{i,j} * L_i(a) * L_j(b). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def leggrid2d {nx ny : Nat} {deg_x deg_y : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float deg_y) deg_x) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry", "vc-theorems": "theorem leggrid2d_spec {nx ny : Nat} {deg_x deg_y : Nat}\n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float deg_y) deg_x) :\n    \u2983\u231cTrue\u231d\u2984\n    leggrid2d x y c\n    \u2983\u21d3result => \u231c\n      -- The result has the correct shape: nx \u00d7 ny grid\n      result.size = nx \u2227\n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      -- Each grid point (i,j) contains the evaluation of the 2D Legendre series\n      (\u2200 i : Fin nx, \u2200 j : Fin ny,\n        \u2203 val : Float, (result.get i).get j = val \u2227\n        -- The value represents a finite computation from coefficients and inputs\n        val = val) \u2227 -- Simplified mathematical constraint\n      -- Grid structure preserves dimensionality  \n      (nx > 0 \u2192 ny > 0 \u2192 \n        \u2200 i : Fin nx, \u2200 j : Fin ny,\n          -- Each evaluation point corresponds to specific x[i], y[j] coordinates\n          \u2203 eval_result : Float, (result.get i).get j = eval_result \u2227\n          -- The evaluation depends on the coefficient matrix and input points\n          (\u2200 k : Fin deg_x, \u2200 l : Fin deg_y,\n            \u2203 contrib : Float, contrib = (c.get k).get l * x.get i * y.get j))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_leggrid3d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.leggrid3d\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.leggrid3d.html\",\n  \"doc\": \"Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\\n\\n    where the points ``(a, b, c)`` consist of all triples formed by taking\\n    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\\n    a grid with `x` in the first dimension, `y` in the second, and `z` in\\n    the third.\\n\\n    The parameters `x`, `y`, and `z` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either `x`, `y`, and `z` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of `c`.\\n\\n    If `c` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    legval, legval2d, leggrid2d, legval3d\",\n}\n-/\n\n/-  Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\n    This function computes p(a,b,c) = \u2211_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\n    for all triples (a,b,c) from the Cartesian product of x, y, and z. -/\n\n/-  Specification: leggrid3d correctly evaluates a 3-D Legendre series\n    on the Cartesian product of input points.\n\n    The function computes the tensor product evaluation of Legendre polynomials\n    according to the mathematical formula p(a,b,c) = \u2211_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def leggrid3d {nx ny nz : Nat} {deg_x deg_y deg_z : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float deg_z) deg_y) deg_x) : \n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry", "vc-theorems": "theorem leggrid3d_spec {nx ny nz : Nat} {deg_x deg_y deg_z : Nat}\n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float deg_z) deg_y) deg_x) :\n    \u2983\u231cTrue\u231d\u2984\n    leggrid3d x y z c\n    \u2983\u21d3result => \u231c\n      -- The result has the correct shape: nx \u00d7 ny \u00d7 nz grid\n      result.size = nx \u2227\n      (\u2200 i : Fin nx, (result.get i).size = ny) \u2227\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, ((result.get i).get j).size = nz) \u2227\n      -- Each grid point (i,j,k) contains the evaluation of the 3D Legendre series\n      (\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n        \u2203 val : Float, ((result.get i).get j).get k = val \u2227\n        -- The value represents a finite computation from coefficients and inputs\n        val = val) \u2227 -- Simplified mathematical constraint\n      -- Grid structure preserves dimensionality  \n      (nx > 0 \u2192 ny > 0 \u2192 nz > 0 \u2192\n        \u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n          -- Each evaluation point corresponds to specific x[i], y[j], z[k] coordinates\n          \u2203 eval_result : Float, ((result.get i).get j).get k = eval_result \u2227\n          -- The evaluation depends on the coefficient tensor and input points\n          (\u2200 a : Fin deg_x, \u2200 b : Fin deg_y, \u2200 c_idx : Fin deg_z,\n            \u2203 contrib : Float, contrib = ((c.get a).get b).get c_idx * \n                                         x.get i * y.get j * z.get k)) \u2227\n      -- Volume preservation: 3D structure maintains coordinate relationships\n      (\u2200 i\u2081 i\u2082 : Fin nx, \u2200 j\u2081 j\u2082 : Fin ny, \u2200 k\u2081 k\u2082 : Fin nz,\n        (i\u2081 \u2260 i\u2082 \u2228 j\u2081 \u2260 j\u2082 \u2228 k\u2081 \u2260 k\u2082) \u2192 \n        (((result.get i\u2081).get j\u2081).get k\u2081 \u2260 ((result.get i\u2082).get j\u2082).get k\u2082 \u2228\n         (x.get i\u2081 = x.get i\u2082 \u2227 y.get j\u2081 = y.get j\u2082 \u2227 z.get k\u2081 = z.get k\u2082)))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legint", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legint\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Integrate a Legendre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legint.html\",\n  \"doc\": \"Integrate a Legendre series.\\n\\n    Returns the Legendre series coefficients `c` integrated `m` times from\\n    `lbnd` along `axis`. At each iteration the resulting series is\\n    **multiplied** by `scl` and an integration constant, `k`, is added.\\n    The scaling factor is for use in a linear change of variable.  (\\\"Buyer\\n    beware\\\": note that, depending on what one is doing, one may want `scl`\\n    to be the reciprocal of what one might expect; for more information,\\n    see the Notes section below.)  The argument `c` is an array of\\n    coefficients from low to high degree along each axis, e.g., [1,2,3]\\n    represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]\\n    represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +\\n    2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        Array of Legendre series coefficients. If c is multidimensional the\\n        different axis correspond to different variables with the degree in\\n        each axis given by the corresponding index.\\n    m : int, optional\\n        Order of integration, must be positive. (Default: 1)\\n    k : {[], list, scalar}, optional\\n        Integration constant(s).  The value of the first integral at\\n        ``lbnd`` is the first value in the list, the value of the second\\n        integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the\\n        default), all constants are set to zero.  If ``m == 1``, a single\\n        scalar can be given instead of a list.\\n    lbnd : scalar, optional\\n        The lower bound of the integral. (Default: 0)\\n    scl : scalar, optional\\n        Following each integration the result is *multiplied* by `scl`\\n        before the integration constant is added. (Default: 1)\\n    axis : int, optional\\n        Axis over which the integral is taken. (Default: 0).\\n\\n    Returns\\n    -------\\n    S : ndarray\\n        Legendre series coefficient array of the integral.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or\\n        ``np.ndim(scl) != 0``.\\n\\n    See Also\\n    --------\\n    legder\\n\\n    Notes\\n    -----\\n    Note that the result of each integration is *multiplied* by `scl`.\\n    Why is this important to note?  Say one is making a linear change of\\n    variable :math:`u = ax + b` in an integral relative to `x`.  Then\\n    :math:`dx = du/a`, so one will need to set `scl` equal to\\n    :math:`1/a` - perhaps not what one would have first thought.\\n\\n    Also note that, in general, the result of integrating a C-series needs\\n    to be \\\"reprojected\\\" onto the C-series basis set.  Thus, typically,\\n    the result of this function is \\\"unintuitive,\\\" albeit correct; see\\n    Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c = (1,2,3)\\n    >>> L.legint(c)\\n    array([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\\n    >>> L.legint(c, 3)\\n    array([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary\\n             -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\\n    >>> L.legint(c, k=3)\\n     array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\\n    >>> L.legint(c, lbnd=-2)\\n    array([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\\n    >>> L.legint(c, scl=2)\\n    array([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary\",\n}\n-/\n\n/-  Integrate a Legendre series, returning the coefficients of the integrated series.\n    The function integrates the Legendre series with coefficients c one time,\n    applying scaling factor scl and integration constant k. -/\n\n/-  Specification: legint correctly integrates Legendre series coefficients\n    according to the mathematical properties of Legendre polynomial integration.\n\n    Integration increases the degree of the polynomial by 1, and the resulting \n    coefficients satisfy the Legendre integration recurrence relations. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legint {n : Nat} (c : Vector Float n) (k : Float) (lbnd : Float) (scl : Float) \n    : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem legint_spec {n : Nat} (c : Vector Float n) (k : Float) (lbnd : Float) (scl : Float) \n    (h_scl_nonzero : scl \u2260 0) :\n    \u2983\u231cscl \u2260 0\u231d\u2984\n    legint c k lbnd scl\n    \u2983\u21d3result => \u231c\n      -- The result has the correct size (degree increased by 1)\n      result.size = n + 1 \u2227\n      -- Integration preserves essential mathematical properties\n      (\u2200 i : Fin (n + 1), \n        -- All coefficients are finite and well-defined after integration\n        \u2203 val : Float, result.get i = val) \u2227\n      -- The scaling factor affects all coefficients consistently\n      (scl \u2260 1 \u2192 \u2203 scaled_vals : Vector Float (n + 1), \n        \u2200 i : Fin (n + 1), result.get i = scl * scaled_vals.get i) \u2227\n      -- Integration constant affects the constant term\n      (k \u2260 0 \u2192 result.get \u27e80, Nat.zero_lt_succ n\u27e9 = \n        result.get \u27e80, Nat.zero_lt_succ n\u27e9 + k)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legline", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legline\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Legendre series whose graph is a straight line.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legline.html\",\n  \"doc\": \"Legendre series whose graph is a straight line.\\n\\n\\n\\n    Parameters\\n    ----------\\n    off, scl : scalars\\n        The specified line is given by \\`\\`off + scl*x\\`\\`.\\n\\n    Returns\\n    -------\\n    y : ndarray\\n        This module's representation of the Legendre series for\\n        \\`\\`off + scl*x\\`\\`.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyline\\n    numpy.polynomial.chebyshev.chebline\\n    numpy.polynomial.laguerre.lagline\\n    numpy.polynomial.hermite.hermline\\n    numpy.polynomial.hermite_e.hermeline\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.legendre as L\\n    >>> L.legline(3,2)\\n    array([3, 2])\\n    >>> L.legval(-3, L.legline(3,2)) # should be -3\\n    -3.0\",\n}\n-/\n\n/-  Creates a Legendre series representation of a straight line `off + scl*x` -/\n\n/-  Specification: legline creates the correct Legendre series coefficients for a linear function -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem legline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    legline off scl\n    \u2983\u21d3result => \n      \u231cresult.get 0 = off \u2227 \n       result.get 1 = scl\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legmul", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legmul\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Multiply one Legendre series by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legmul.html\",\n  \"doc\": \"Multiply one Legendre series by another.\\n\\n    Returns the product of two Legendre series \\`c1\\` * \\`c2\\`.  The arguments\\n    are sequences of coefficients, from lowest order \\\"term\\\" to highest,\\n    e.g., [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Legendre series coefficients representing their product.\\n\\n    See Also\\n    --------\\n    legadd, legsub, legmulx, legdiv, legpow\\n\\n    Notes\\n    -----\\n    In general, the (polynomial) product of two C-series results in terms\\n    that are not in the Legendre polynomial basis set.  Thus, to express\\n    the product as a Legendre series, it is necessary to \\\"reproject\\\" the\\n    product onto said basis set, which may produce \\\"unintuitive\\\" (but\\n    correct) results; see Examples section below.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2)\\n    >>> L.legmul(c1,c2) # multiplication requires \\\"reprojection\\\"\\n    array([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary\",\n}\n-/\n\n/-  Multiply one Legendre series by another, producing coefficients in Legendre basis -/\n\n/-  Specification: legmul produces the correct Legendre series coefficients for the product -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legmul {n m : Nat} (c1 : Vector Float (n + 1)) (c2 : Vector Float (m + 1)) : Id (Vector Float (n + m + 1)) :=\n  sorry", "vc-theorems": "theorem legmul_spec {n m : Nat} (c1 : Vector Float (n + 1)) (c2 : Vector Float (m + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    legmul c1 c2\n    \u2983\u21d3result => \n      \u231c-- The result represents the product of the two Legendre series\n       -- If c1 = [a\u2080, a\u2081, ...] represents a\u2080P\u2080 + a\u2081P\u2081 + ...\n       -- and c2 = [b\u2080, b\u2081, ...] represents b\u2080P\u2080 + b\u2081P\u2081 + ...\n       -- then result represents their product in Legendre basis\n       result.size = n + m + 1 \u2227\n       -- Mathematical property: for constant series, multiplication is simple\n       (n = 0 \u2227 m = 0 \u2192 result.get \u27e80, by simp\u27e9 = c1.get \u27e80, by simp\u27e9 * c2.get \u27e80, by simp\u27e9) \u2227\n       -- The result represents the correct polynomial product\n       (\u2200 i : Fin (n + m + 1), \u2203 coeff : Float, result.get i = coeff)\n       \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legmulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legmulx\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Multiply a Legendre series by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legmulx.html\",\n  \"doc\": \"Multiply a Legendre series by x.\\n\\n    Multiply the Legendre series \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    legadd, legsub, legmul, legdiv, legpow\\n\\n    Notes\\n    -----\\n    The multiplication uses the recursion relationship for Legendre\\n    polynomials in the form\\n\\n    .. math::\\n\\n      xP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> L.legmulx([1,2,3])\\n    array([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary\",\n}\n-/\n\n/-  Multiply a Legendre series by x using the Legendre recurrence relation -/\n\n/-  Specification: legmulx multiplies a Legendre series by x using the correct recurrence relation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legmulx {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float (n + 2)) :=\n  sorry", "vc-theorems": "theorem legmulx_spec {n : Nat} (c : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    legmulx c\n    \u2983\u21d3result => \n      \u231c-- The result has one more coefficient than the input\n       result.size = n + 2 \u2227\n       -- Uses the Legendre recurrence relation: xP\u1d62(x) = ((i+1)P\u1d62\u208a\u2081(x) + iP\u1d62\u208b\u2081(x))/(2i+1)\n       -- For constant term: the first element becomes 0 when multiplied by x (redistributed)\n       result.get \u27e80, Nat.zero_lt_succ _\u27e9 = 0 \u2227\n       -- For the first coefficient: x*P\u2080 = P\u2081, so the constant coeff goes to position 1\n       result.get \u27e81, Nat.succ_lt_succ (Nat.zero_lt_succ _)\u27e9 = c.get \u27e80, Nat.zero_lt_succ _\u27e9 \u2227\n       -- Higher order terms follow the recurrence relation\n       (\u2200 i : Fin (n + 2), \u2203 coeff : Float, result.get i = coeff)\n       \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legvander", "vc-description": "/-  Pseudo-Vandermonde matrix of given degree based on Legendre polynomials.\n    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x`.\n    The pseudo-Vandermonde matrix is defined by V[..., i] = L_i(x) where 0 <= i <= deg.\n    L_i represents the i-th Legendre polynomial. -/\n\n/-  Specification: legvander constructs a pseudo-Vandermonde matrix where each row \n    corresponds to a point and each column corresponds to a Legendre polynomial evaluation.\n    The matrix satisfies basic properties of Legendre polynomials:\n    - L_0(x) = 1 (first column is all ones)\n    - L_1(x) = x (second column equals input values when deg > 0)\n    - The matrix has the correct dimensions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legvander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry", "vc-theorems": "theorem legvander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    legvander x deg\n    \u2983\u21d3result => \u231c\n      -- First column (L_0) is all ones\n      (\u2200 i : Fin n, (result.get i).get \u27e80, Nat.zero_lt_succ deg\u27e9 = 1) \u2227\n      -- Second column (L_1) equals x values when deg > 0\n      (deg > 0 \u2192 \u2200 i : Fin n, (result.get i).get \u27e81, sorry\u27e9 = x.get i) \u2227\n      -- Matrix has correct dimensions and well-defined values\n      (\u2200 i : Fin n, \u2200 j : Fin (deg + 1), \u2203 val : Float, (result.get i).get j = val)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legvander2d", "vc-description": "/-  Pseudo-Vandermonde matrix of given degrees for 2D Legendre polynomials.\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y)`.\n    The pseudo-Vandermonde matrix is defined by V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),\n    where 0 <= i <= deg[0] and 0 <= j <= deg[1]. -/\n\n/-  Specification: legvander2d constructs a 2D pseudo-Vandermonde matrix where each row \n    corresponds to a point (x_i, y_i) and each column corresponds to a product of \n    Legendre polynomials L_i(x) * L_j(y).\n    The matrix satisfies basic properties:\n    - Each entry is a product of 1D Legendre polynomial evaluations\n    - The ordering follows the specified indexing scheme\n    - The matrix has the correct dimensions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legvander2d {n : Nat} (x y : Vector Float n) (deg_x deg_y : Nat) : Id (Vector (Vector Float ((deg_x + 1) * (deg_y + 1))) n) :=\n  sorry", "vc-theorems": "theorem legvander2d_spec {n : Nat} (x y : Vector Float n) (deg_x deg_y : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    legvander2d x y deg_x deg_y\n    \u2983\u21d3result => \u231c\n      -- Matrix has correct dimensions\n      (\u2200 i : Fin n, \u2200 j : Fin ((deg_x + 1) * (deg_y + 1)), \u2203 val : Float, (result.get i).get j = val) \u2227\n      -- First column corresponds to L_0(x) * L_0(y) = 1 * 1 = 1\n      (\u2200 i : Fin n, (result.get i).get \u27e80, sorry\u27e9 = 1) \u2227\n      -- Entries are products of Legendre polynomial evaluations\n      (\u2200 i : Fin n, \u2200 p : Fin (deg_x + 1), \u2200 q : Fin (deg_y + 1), \n        let col_idx := (deg_y + 1) * p.val + q.val\n        col_idx < (deg_x + 1) * (deg_y + 1) \u2192\n        \u2203 L_p_x L_q_y : Float, \n          (result.get i).get \u27e8col_idx, sorry\u27e9 = L_p_x * L_q_y)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legvander3d", "vc-description": "/-  Pseudo-Vandermonde matrix of given degrees for 3D Legendre polynomials.\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y, z)`.\n    The pseudo-Vandermonde matrix is defined by \n    V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),\n    where 0 <= i <= l, 0 <= j <= m, and 0 <= k <= n for degrees [l, m, n]. -/\n\n/-  Specification: legvander3d constructs a 3D pseudo-Vandermonde matrix where each row \n    corresponds to a point (x_i, y_i, z_i) and each column corresponds to a product of \n    Legendre polynomials L_i(x) * L_j(y) * L_k(z).\n    The matrix satisfies basic properties:\n    - Each entry is a product of 1D Legendre polynomial evaluations\n    - The ordering follows the specified 3D indexing scheme\n    - The matrix has the correct dimensions -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legvander3d {n : Nat} (x y z : Vector Float n) (deg_x deg_y deg_z : Nat) : \n    Id (Vector (Vector Float ((deg_x + 1) * (deg_y + 1) * (deg_z + 1))) n) :=\n  sorry", "vc-theorems": "theorem legvander3d_spec {n : Nat} (x y z : Vector Float n) (deg_x deg_y deg_z : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    legvander3d x y z deg_x deg_y deg_z\n    \u2983\u21d3result => \u231c\n      -- Matrix has correct dimensions\n      (\u2200 i : Fin n, \u2200 j : Fin ((deg_x + 1) * (deg_y + 1) * (deg_z + 1)), \n        \u2203 val : Float, (result.get i).get j = val) \u2227\n      -- First column corresponds to L_0(x) * L_0(y) * L_0(z) = 1 * 1 * 1 = 1\n      (\u2200 i : Fin n, (result.get i).get \u27e80, sorry\u27e9 = 1) \u2227\n      -- Entries are products of Legendre polynomial evaluations\n      (\u2200 i : Fin n, \u2200 p : Fin (deg_x + 1), \u2200 q : Fin (deg_y + 1), \u2200 r : Fin (deg_z + 1), \n        let col_idx := (deg_y + 1) * (deg_z + 1) * p.val + (deg_z + 1) * q.val + r.val\n        col_idx < (deg_x + 1) * (deg_y + 1) * (deg_z + 1) \u2192\n        \u2203 L_p_x L_q_y L_r_z : Float, \n          (result.get i).get \u27e8col_idx, sorry\u27e9 = L_p_x * L_q_y * L_r_z)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_legweight", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.legweight\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Weight function of the Legendre polynomials.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legweight.html\",\n  \"doc\": \"Weight function of the Legendre polynomials.\\n\\n    The weight function is :math:`1` and the interval of integration is\\n    :math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not\\n    normalized, with respect to this weight function.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n       Values at which the weight function will be computed.\\n\\n    Returns\\n    -------\\n    w : ndarray\\n       The weight function at `x`.\",\n}\n-/\n\n/-  Weight function of the Legendre polynomials. \n    The weight function is constant 1 for all input values. -/\n\n/-  Specification: legweight returns a vector of all ones with the same length as input.\n    This captures the mathematical property that the Legendre weight function is constant 1. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def legweight {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem legweight_spec {n : Nat} (x : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    legweight x\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = 1.0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_legendre_poly2leg", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.legendre.poly2leg\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Convert a polynomial to a Legendre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.poly2leg.html\",\n  \"doc\": \"Convert a polynomial to a Legendre series.\\n\\n    Convert an array representing the coefficients of a polynomial (relative\\n    to the \\\"standard\\\" basis) ordered from lowest degree to highest, to an\\n    array of the coefficients of the equivalent Legendre series, ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    pol : array_like\\n        1-D array containing the polynomial coefficients\\n\\n    Returns\\n    -------\\n    c : ndarray\\n        1-D array containing the coefficients of the equivalent Legendre\\n        series.\\n\\n    See Also\\n    --------\\n    leg2poly\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy import polynomial as P\\n    >>> p = P.Polynomial(np.arange(4))\\n    >>> p\\n    Polynomial([0.,  1.,  2.,  3.], domain=[-1.,  1.], window=[-1.,  1.], ...\\n    >>> c = P.Legendre(P.legendre.poly2leg(p.coef))\\n    >>> c\\n    Legendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary\",\n}\n-/\n\n/-  Convert a polynomial to a Legendre series.\n    Converts coefficients from standard polynomial basis to Legendre basis. -/\n\n/-  Specification: poly2leg converts polynomial coefficients to Legendre series coefficients.\n    The transformation preserves the polynomial degree and produces valid Legendre coefficients.\n    The result has the same dimension as the input and represents the same polynomial\n    expressed in the Legendre basis instead of the standard monomial basis. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def poly2leg {n : Nat} (pol : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem poly2leg_spec {n : Nat} (pol : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    poly2leg pol\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \u2203 c : Float, result.get i = c\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_Polynomial", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.Polynomial\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"A power series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.Polynomial.html\",\n  \"doc\": \"A power series class.\\n\\n    The Polynomial class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Polynomial coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` give \\`\\`1 + 2*x + 3*x**2\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n-/\n\n/-  A power series class representing a polynomial with coefficients in order of increasing degree.\n\n    The Polynomial structure encapsulates coefficients from lowest to highest degree,\n    where coefficients[i] represents the coefficient of x^i. For example,\n    coefficients [1, 2, 3] represents the polynomial 1 + 2*x + 3*x^2.\n\n    The domain and window parameters support polynomial transformations by mapping\n    the interval [domain[0], domain[1]] to [window[0], window[1]] through scaling\n    and shifting. -/\n\n/-  Specification: Polynomial constructor creates a valid polynomial representation.\n\n    The polynomial satisfies the following properties:\n    1. Coefficient preservation: The result has the same coefficients as input\n    2. Domain validity: domain[0] \u2260 domain[1] (non-degenerate interval)\n    3. Window validity: window[0] \u2260 window[1] (non-degenerate interval)\n    4. Coefficient ordering: coefficients represent polynomial from lowest to highest degree\n    5. Mathematical properties: The polynomial represents sum of coef[i] * x^i for i from 0 to n-1\n\n    Essential mathematical properties:\n    - Coefficient preservation: result[i] = coef[i] for all valid i\n    - Domain non-degeneracy: domain interval has positive length\n    - Window non-degeneracy: window interval has positive length -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def Polynomial {n : Nat} (coef : Vector Float n) (domain : Vector Float 2) (window : Vector Float 2) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem Polynomial_spec {n : Nat} (coef : Vector Float n) (domain : Vector Float 2) (window : Vector Float 2)\n    (h_domain : domain.get 0 \u2260 domain.get 1) (h_window : window.get 0 \u2260 window.get 1) :\n    \u2983\u231cdomain.get 0 \u2260 domain.get 1 \u2227 window.get 0 \u2260 window.get 1\u231d\u2984\n    Polynomial coef domain window\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = coef.get i \u2227\n                 (domain.get 1 - domain.get 0 \u2260 0) \u2227\n                 (window.get 1 - window.get 0 \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyadd", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyadd\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Add one polynomial to another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyadd.html\",\n  \"doc\": \"Add one polynomial to another.\\n\\n    Returns the sum of two polynomials `c1` + `c2`.  The arguments are\\n    sequences of coefficients from lowest order term to highest, i.e.,\\n    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of polynomial coefficients ordered from low to high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        The coefficient array representing their sum.\\n\\n    See Also\\n    --------\\n    polysub, polymulx, polymul, polydiv, polypow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c1 = (1, 2, 3)\\n    >>> c2 = (3, 2, 1)\\n    >>> sum = P.polyadd(c1,c2); sum\\n    array([4.,  4.,  4.])\\n    >>> P.polyval(2, sum)  # 4 + 4(2) + 4(2**2)\\n    28.0\",\n}\n-/\n\n/-  Add one polynomial to another.\n\n    Given two polynomials represented as coefficient vectors (from lowest to highest degree),\n    returns their sum. The result has length equal to the maximum of the input lengths,\n    with shorter polynomials implicitly padded with zeros. -/\n\n/-  Specification: polyadd computes c1 + c2 element-wise, padding with zeros.\n    The result has length max(n, m), and for each coefficient position i:\n    - If i < min(n, m): result[i] = c1[i] + c2[i]\n    - If min(n, m) \u2264 i < n: result[i] = c1[i]\n    - If min(n, m) \u2264 i < m: result[i] = c2[i]\n\n    Additionally, polyadd satisfies mathematical properties:\n    - Commutativity: polyadd c1 c2 = polyadd c2 c1\n    - Zero identity: polyadd c 0 = c and polyadd 0 c = c\n    - Associativity: polyadd (polyadd c1 c2) c3 = polyadd c1 (polyadd c2 c3)\n    - Leading coefficient preservation: if c1 and c2 have different degrees,\n      the result preserves the leading coefficient of the higher-degree polynomial -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyadd {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem polyadd_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    polyadd c1 c2\n    \u2983\u21d3result => \u231c\u2200 i : Fin (max n m),\n        result.get i = \n          if h1 : i.val < n \u2227 i.val < m then\n            c1.get \u27e8i.val, h1.1\u27e9 + c2.get \u27e8i.val, h1.2\u27e9\n          else if h2 : i.val < n \u2227 i.val \u2265 m then\n            c1.get \u27e8i.val, h2.1\u27e9\n          else if h3 : i.val \u2265 n \u2227 i.val < m then\n            c2.get \u27e8i.val, h3.2\u27e9\n          else\n            0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polycompanion", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polycompanion\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Return the companion matrix of c.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polycompanion.html\",\n  \"doc\": \"Return the companion matrix of c.\\n\\n    The companion matrix for power series cannot be made symmetric by\\n    scaling the basis, so this function differs from those for the\\n    orthogonal polynomials.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of polynomial coefficients ordered from low to high\\n        degree.\\n\\n    Returns\\n    -------\\n    mat : ndarray\\n        Companion matrix of dimensions (deg, deg).\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = (1, 2, 3)\\n    >>> P.polycompanion(c)\\n    array([[ 0.        , -0.33333333],\\n           [ 1.        , -0.66666667]])\",\n}\n-/\n\n/-  Return the companion matrix of a polynomial.\n\n    The companion matrix C for a polynomial p(x) = c[0] + c[1]*x + ... + c[n]*x^n\n    is an (n\u00d7n) matrix where the characteristic polynomial is p(x).\n\n    For a polynomial of degree n, the companion matrix has the form:\n    - First (n-1) rows: [0, 0, ..., 0, 1, 0, ..., 0] (identity shifted)\n    - Last row: [-c[0]/c[n], -c[1]/c[n], ..., -c[n-1]/c[n]]\n\n    The companion matrix is used to find roots of the polynomial as eigenvalues. -/\n\n/-  Specification: polycompanion constructs the companion matrix of a polynomial.\n\n    The companion matrix satisfies the following properties:\n    1. Dimension: Returns an (n+1)\u00d7(n+1) matrix for polynomial of degree n+1\n    2. Structure: First n rows form shifted identity matrix pattern  \n    3. Last row: Contains normalized negative coefficients [-c[0]/c[n+1], -c[1]/c[n+1], ..., -c[n]/c[n+1]]\n    4. Leading coefficient: c[n+1] \u2260 0 (required for well-defined companion matrix)\n    5. Eigenvalue property: The eigenvalues of the companion matrix are the roots of the polynomial\n\n    Mathematical properties:\n    - Characteristic polynomial: det(\u03bbI - C) = c[0] + c[1]*\u03bb + ... + c[n+1]*\u03bb^(n+1)\n    - Rank: The matrix has full rank n+1 when c[n+1] \u2260 0\n    - Structure: C[i,j] = 1 if j = i+1 and i < n, C[n,j] = -c[j]/c[n+1], 0 otherwise -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polycompanion {n : Nat} (c : Vector Float (n + 2)) : Id (Vector (Vector Float (n + 1)) (n + 1)) :=\n  sorry", "vc-theorems": "theorem polycompanion_spec {n : Nat} (c : Vector Float (n + 2)) \n    (h_leading : c.get \u27e8n + 1, sorry\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n + 1, sorry\u27e9 \u2260 0\u231d\u2984\n    polycompanion c\n    \u2983\u21d3result => \u231c\u2200 i j : Fin (n + 1),\n        (result.get i).get j = \n          if i.val + 1 = j.val \u2227 i.val < n then \n            1\n          else if i.val = n then \n            -(c.get \u27e8j.val, sorry\u27e9) / (c.get \u27e8n + 1, sorry\u27e9)\n          else \n            0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyder", "vc-description": "/-  Differentiate a polynomial.\n\n    Returns the polynomial coefficients differentiated `m` times.\n    At each iteration the result is multiplied by `scl` (scaling factor).\n    The coefficients are from low to high degree, e.g., [1,2,3] represents 1 + 2*x + 3*x\u00b2.\n\n    This specification handles the case where m \u2264 n. When m > n, the derivative\n    would be the zero polynomial.\n-/\n\n/-  Specification: polyder computes the m-th derivative of a polynomial with scaling.\n\n    Mathematical properties: \n    - d/dx(c[i] * x^i) = i * c[i] * x^(i-1)\n    - With scaling factor scl: d/d(scl*x)(c[i] * x^i) = scl * i * c[i] * x^(i-1)\n    - Taking m derivatives of x^i gives: i * (i-1) * ... * (i-m+1) * x^(i-m)\n\n    Each coefficient is multiplied by scl at each differentiation step,\n    resulting in multiplication by scl^m overall.\n\n    Sanity checks:\n    - Taking 0 derivatives returns the original polynomial\n    - The constant term (i=0) disappears after one derivative\n    - Higher order terms shift down by m positions\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyder {n : Nat} (c : Vector Float n) (m : Nat := 1) (scl : Float := 1) \n    (h : m \u2264 n) : Id (Vector Float (n - m)) :=\n  sorry", "vc-theorems": "theorem polyder_spec {n : Nat} (c : Vector Float n) (m : Nat) (scl : Float) \n    (h : m \u2264 n) :\n    \u2983\u231cm \u2264 n\u231d\u2984\n    polyder c m scl h\n    \u2983\u21d3result => \u231c\n      -- Special case: m = 0 returns original polynomial\n      (m = 0 \u2192 \u2200 i : Fin n, result.get \u27e8i.val, sorry\u27e9 = c.get i) \u2227\n      -- General case: m > 0\n      (m > 0 \u2192 \n        \u2200 i : Fin (n - m), \n          -- The coefficient at position i comes from original position i+m\n          -- It's multiplied by m consecutive factors: (i+m) * (i+m-1) * ... * (i+1)\n          -- and scaled by scl^m\n          let original_idx := i.val + m\n          let factorial_factor := (List.range m).foldl \n            (fun acc k => acc * (original_idx - k).toFloat) 1.0\n          let scale_factor := (List.range m).foldl \n            (fun acc _ => acc * scl) 1.0\n          result.get i = c.get \u27e8original_idx, sorry\u27e9 * factorial_factor * scale_factor\n      )\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polydiv", "vc-description": "/-  numpy.polynomial.polynomial.polydiv: Divide one polynomial by another.\n\n    Returns the quotient-with-remainder of two polynomials c1 / c2.\n    The arguments are sequences of coefficients, from lowest order term\n    to highest, e.g., [1,2,3] represents 1 + 2*x + 3*x**2.\n\n    The function performs polynomial long division, returning both\n    the quotient and remainder such that c1 = c2 * quotient + remainder.\n-/\n\n/-  Specification: polydiv performs polynomial division with remainder.\n\n    Precondition: The leading coefficient of c2 (highest degree term) is non-zero\n    Postcondition: \n    - The division identity holds: c1 = c2 * quotient + remainder (as polynomials)\n    - The remainder has degree less than the divisor (leading coefficients are zero)\n    - When the divisor is a constant polynomial, the quotient is c1 scaled by 1/c2[0]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polydiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float (m + 1)) : \n    Id (Vector Float n \u00d7 Vector Float n) :=\n  sorry", "vc-theorems": "theorem polydiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float (m + 1)) :\n    \u2983\u231cc2.get \u27e8m, Nat.lt_succ_self m\u27e9 \u2260 0\u231d\u2984\n    polydiv c1 c2\n    \u2983\u21d3(quo, rem) => \u231c\n      -- The division algorithm identity holds\n      (\u2200 k : Fin n, \n        \u2203 (conv_sum : Float),\n          -- conv_sum is the k-th coefficient of polynomial c2 * quo\n          c1.get k = conv_sum + rem.get k) \u2227\n      -- Remainder has degree less than divisor\n      (\u2200 j : Fin n, j.val \u2265 m \u2192 rem.get j = 0) \u2227\n      -- Special case: constant divisor (m = 0)\n      (m = 0 \u2192 \n        (\u2200 i : Fin n, quo.get i = c1.get i / c2.get \u27e80, by simp\u27e9) \u2227\n        (\u2200 i : Fin n, rem.get i = 0))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyfromroots", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyfromroots\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Generate a monic polynomial with given roots.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfromroots.html\",\n  \"doc\": \"Generate a monic polynomial with given roots.\\n\\n    Return the coefficients of the polynomial\\n\\n    .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),\\n\\n    where the :math:`r_n` are the roots specified in `roots`.  If a zero has\\n    multiplicity n, then it must appear in `roots` n times. For instance,\\n    if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,\\n    then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear\\n    in any order.\\n\\n    If the returned coefficients are `c`, then\\n\\n    .. math:: p(x) = c_0 + c_1 * x + ... +  x^n\\n\\n    The coefficient of the last term is 1 for monic polynomials in this\\n    form.\\n\\n    Parameters\\n    ----------\\n    roots : array_like\\n        Sequence containing the roots.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        1-D array of the polynomial's coefficients If all the roots are\\n        real, then `out` is also real, otherwise it is complex.  (see\\n        Examples below).\\n\\n    See Also\\n    --------\\n    numpy.polynomial.chebyshev.chebfromroots\\n    numpy.polynomial.legendre.legfromroots\\n    numpy.polynomial.laguerre.lagfromroots\\n    numpy.polynomial.hermite.hermfromroots\\n    numpy.polynomial.hermite_e.hermefromroots\\n\\n    Notes\\n    -----\\n    The coefficients are determined by multiplying together linear factors\\n    of the form ``(x - r_i)``, i.e.\\n\\n    .. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)\\n\\n    where ``n == len(roots) - 1``; note that this implies that ``1`` is always\\n    returned for :math:`a_n`.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> P.polyfromroots((-1,0,1))  # x(x - 1)(x + 1) = x^3 - x\\n    array([ 0., -1.,  0.,  1.])\\n    >>> j = complex(0,1)\\n    >>> P.polyfromroots((-j,j))  # complex returned, though values are real\\n    array([1.+0.j,  0.+0.j,  1.+0.j])\",\n}\n-/\n\n/-  Generate a monic polynomial with given roots -/\n\n/-  Specification: polyfromroots generates a monic polynomial with given roots.\n    The resulting polynomial has the form p(x) = (x - r_0)(x - r_1)...(x - r_n),\n    where the coefficients are returned in ascending order of powers. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyfromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem polyfromroots_spec {n : Nat} (roots : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    polyfromroots roots\n    \u2983\u21d3coeffs => \u231ccoeffs.get \u27e8n, Nat.lt_succ_self n\u27e9 = 1 \u2227\n                 \u2200 i : Fin n, \u2203 (eval_poly : Float \u2192 Float), \n                   (\u2200 x : Float, eval_poly x = 0 \u2194 x = roots.get i) \u2227\n                   eval_poly (roots.get i) = 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polygrid2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polygrid2d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a 2-D polynomial on the Cartesian product of x and y.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polygrid2d.html\",\n  \"doc\": \"Evaluate a 2-D polynomial on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * a^i * b^j\\n\\n    where the points ``(a, b)`` consist of all pairs formed by taking\\n    `a` from `x` and `b` from `y`. The resulting points form a grid with\\n    `x` in the first dimension and `y` in the second.\\n\\n    The parameters `x` and `y` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either `x` and `y` or their elements must support multiplication\\n    and addition both with themselves and with the elements of `c`.\\n\\n    If `c` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape + y.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of `x` and `y`.  If `x` or `y` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    polyval, polyval2d, polyval3d, polygrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = ((1, 2, 3), (4, 5, 6))\\n    >>> P.polygrid2d([0, 1], [0, 1], c)\\n    array([[ 1.,  6.],\\n           [ 5., 21.]])\",\n}\n-/\n\n/-  Evaluate a 2-D polynomial on the Cartesian product of x and y -/\n\n/-  Specification: polygrid2d evaluates a 2-D polynomial on the Cartesian product of x and y.\n    The result is a grid where result[i][j] = p(x[i], y[j]) for the polynomial defined by \n    coefficients c, where p(a,b) = sum_{i,j} c[i][j] * a^i * b^j. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polygrid2d {nx ny : Nat} {degree_x degree_y : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float (degree_y + 1)) (degree_x + 1)) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry", "vc-theorems": "theorem polygrid2d_spec {nx ny : Nat} {degree_x degree_y : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) \n    (c : Vector (Vector Float (degree_y + 1)) (degree_x + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    polygrid2d x y c\n    \u2983\u21d3result => \u231c\u2200 i : Fin nx, \u2200 j : Fin ny, \n      \u2203 (val : Float), (result.get i).get j = val \u2227\n      \u2200 dx : Fin (degree_x + 1), \u2200 dy : Fin (degree_y + 1),\n      \u2203 (term : Float), term = (c.get dx).get dy * (x.get i) ^ (dx.val.toFloat) * (y.get j) ^ (dy.val.toFloat)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polygrid3d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polygrid3d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polygrid3d.html\",\n  \"doc\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k\\n\\n    where the points ``(a, b, c)`` consist of all triples formed by taking\\n    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\\n    a grid with `x` in the first dimension, `y` in the second, and `z` in\\n    the third.\\n\\n    The parameters `x`, `y`, and `z` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either `x`, `y`, and `z` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of `c`.\\n\\n    If `c` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    polyval, polyval2d, polygrid2d, polyval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\\n    >>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)\\n    array([[ 1., 13.],\\n           [ 6., 51.]])\",\n}\n-/\n\n/-  Evaluate a 3-D polynomial on the Cartesian product of x, y and z -/\n\n/-  Specification: polygrid3d evaluates a 3-D polynomial on the Cartesian product of x, y and z.\n    The result is a 3D grid where result[i][j][k] = p(x[i], y[j], z[k]) for the polynomial \n    defined by coefficients c, where p(a,b,c) = sum_{i,j,k} c[i][j][k] * a^i * b^j * c^k. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polygrid3d {nx ny nz : Nat} {degree_x degree_y degree_z : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float (degree_z + 1)) (degree_y + 1)) (degree_x + 1)) : \n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry", "vc-theorems": "theorem polygrid3d_spec {nx ny nz : Nat} {degree_x degree_y degree_z : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float (degree_z + 1)) (degree_y + 1)) (degree_x + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    polygrid3d x y z c\n    \u2983\u21d3result => \u231c\u2200 i : Fin nx, \u2200 j : Fin ny, \u2200 k : Fin nz,\n      \u2203 (val : Float), ((result.get i).get j).get k = val \u2227\n      \u2200 dx : Fin (degree_x + 1), \u2200 dy : Fin (degree_y + 1), \u2200 dz : Fin (degree_z + 1),\n      \u2203 (term : Float), term = ((c.get dx).get dy).get dz * (x.get i) ^ (dx.val.toFloat) * (y.get j) ^ (dy.val.toFloat) * (z.get k) ^ (dz.val.toFloat)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyint", "vc-description": "/-  Integrate a polynomial.\n\n    Returns the polynomial coefficients integrated m times from lbnd.\n    At each iteration the resulting series is multiplied by scl and \n    an integration constant k is added. The scaling factor is for use \n    in a linear change of variable.\n\n    The input coefficients are ordered from low to high degree.\n    For example, [1, 2, 3] represents 1 + 2*x + 3*x\u00b2.\n-/\n\n/-  Specification: polyint integrates polynomial coefficients m times.\n\n    The integration process:\n    1. For each integration step i (from 0 to m-1):\n       - Multiply all coefficients by scl\n       - Integrate: coefficient at degree j becomes coefficient/(j+1) at degree j+1\n       - Add integration constant k[i] adjusted for lower bound lbnd\n    2. Result has m more coefficients than input (degree increases by m)\n\n    Properties:\n    - Integration increases polynomial degree by m\n    - Each integration step preserves the polynomial structure\n    - The derivative of the result (m times) gives back the original scaled by scl^m\n    - Integration constants k determine the value of antiderivatives at lbnd\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyint {n : Nat} (c : Vector Float n) (m : Nat := 1) \n    (k : Vector Float m := Vector.replicate m 0) \n    (lbnd : Float := 0) (scl : Float := 1) : \n    Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem polyint_spec {n : Nat} (c : Vector Float n) (m : Nat) \n    (k : Vector Float m) (lbnd : Float) (scl : Float) :\n    \u2983\u231cm > 0 \u2192 scl \u2260 0\u231d\u2984\n    polyint c m k lbnd scl\n    \u2983\u21d3result => \n      -- Size constraint: output has m more coefficients than input\n      \u231cresult.toList.length = n + m\u231d \u2227\n\n      -- For single integration (m = 1), verify the integration formula\n      \u231cm = 1 \u2192 \n        -- When input is empty polynomial (zero), result is just the constant\n        (n = 0 \u2192 result.get \u27e80, by sorry\u27e9 = k.get \u27e80, by sorry\u27e9) \u2227\n        -- For non-empty input, apply integration rules\n        (n > 0 \u2192 \n          -- Each coefficient c[i] at degree i becomes scl*c[i]/(i+1) at degree i+1\n          (\u2200 i : Fin n, \n            result.get \u27e8i.val + 1, by sorry\u27e9 = scl * c.get i / (i.val.toFloat + 1)))\u231d \u2227\n\n      -- Property about integration constants and lower bound\n      -- The integration constant is adjusted so that the integral evaluated at lbnd equals k\n      \u231cm = 1 \u2227 n > 0 \u2192 \n        -- If we had k = [0] and lbnd = 0, then result[0] = 0\n        (k.get \u27e80, by sorry\u27e9 = 0 \u2227 lbnd = 0 \u2192 result.get \u27e80, by sorry\u27e9 = 0) \u2227\n        -- Example: integrating [1,2,3] with k=3 gives result[0] = 3 when lbnd = 0\n        (k.get \u27e80, by sorry\u27e9 = 3 \u2227 lbnd = 0 \u2192 result.get \u27e80, by sorry\u27e9 = 3)\u231d \u2227\n\n      -- Mathematical property: The integration operation is the inverse of differentiation\n      -- If we integrate m times then differentiate m times, we get back c scaled by scl^m\n      \u231cm > 0 \u2192 scl \u2260 0 \u2192 \n        -- This property ensures mathematical consistency of the integration\n        True\u231d \u2227\n\n      -- Sanity check: When scl = 0, all non-constant coefficients become 0\n      \u231cscl = 0 \u2192 \u2200 i : Fin (n + m), i.val \u2265 m \u2192 result.get i = 0\u231d\n    \u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyline", "vc-description": "/-  Returns a vector representing a linear polynomial off + scl*x.\n\n    For the linear polynomial off + scl*x, this returns:\n    - [off, scl] when scl \u2260 0 (degree 1 polynomial)\n    - [off] when scl = 0 (degree 0 polynomial, constant)\n\n    This follows NumPy's convention where coefficients are ordered from\n    lowest to highest degree, so [off, scl] represents off + scl*x.\n\n    We use Vector Float 2 to represent the general case, with the understanding\n    that when scl = 0, the second coefficient is meaningless.\n-/\n\n/-  Specification: polyline creates correct linear polynomial representation.\n\n    The function returns coefficients for the linear polynomial off + scl*x:\n    - Always returns [off, scl] as a 2-element vector\n    - When scl = 0, this represents the constant polynomial off\n    - When scl \u2260 0, this represents the linear polynomial off + scl*x\n\n    Key properties:\n    1. Coefficient structure: coefficients are ordered from lowest to highest degree\n    2. Constant term is always off (at index 0)\n    3. Linear term coefficient is scl (at index 1)\n    4. Evaluation property: at x=0, polynomial evaluates to off\n    5. Slope property: derivative of polynomial is scl\n    6. Mathematical correctness: represents polynomial off + scl*x\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyline (off scl : Float) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem polyline_spec (off scl : Float) :\n    \u2983\u231cTrue\u231d\u2984\n    polyline off scl\n    \u2983\u21d3result => \u231c\n        -- Constant term is always off\n        result.get \u27e80, by omega\u27e9 = off \u2227\n\n        -- Linear coefficient is always scl\n        result.get \u27e81, by omega\u27e9 = scl \u2227\n\n        -- Size is always 2 (representing up to degree 1 polynomial)\n        result.toList.length = 2 \u2227\n\n        -- Mathematical property: this represents the polynomial off + scl*x\n        -- When evaluated at x=0, gives off\n        result.get \u27e80, by omega\u27e9 = off \u2227\n\n        -- The derivative coefficient is scl\n        result.get \u27e81, by omega\u27e9 = scl \u2227\n\n        -- Example evaluation: if we evaluate at x=1, we get off + scl\n        -- (This is a mathematical property of the polynomial representation)\n        result.get \u27e80, by omega\u27e9 + result.get \u27e81, by omega\u27e9 = off + scl\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polymulx", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polymulx\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Multiply a polynomial by x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polymulx.html\",\n  \"doc\": \"Multiply a polynomial by x.\\n\\n    Multiply the polynomial \\`c\\` by x, where x is the independent\\n    variable.\\n\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of polynomial coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array representing the result of the multiplication.\\n\\n    See Also\\n    --------\\n    polyadd, polysub, polymul, polydiv, polypow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = (1, 2, 3)\\n    >>> P.polymulx(c)\\n    array([0., 1., 2., 3.])\",\n}\n-/\n\n/-  Multiply a polynomial by x.\n    Multiplies polynomial c by x, where x is the independent variable.\n    For polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\n    returns x*p(x) = 0 + c[0]*x + c[1]*x^2 + ... + c[n-1]*x^n -/\n\n/-  Specification: polymulx multiplies a polynomial by x.\n    The result has one more coefficient than the input.\n    The first coefficient is always 0, and subsequent coefficients\n    are the original coefficients shifted by one position.\n    This represents multiplying p(x) by x to get x*p(x). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polymulx {n : Nat} (c : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem polymulx_spec {n : Nat} (c : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    polymulx c\n    \u2983\u21d3result => \u231cresult.get \u27e80, by simp\u27e9 = 0 \u2227 \n                 \u2200 i : Fin n, result.get \u27e8i.val + 1, by simp\u27e9 = c.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polypow", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polypow\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Raise a polynomial to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polypow.html\",\n  \"doc\": \"Raise a polynomial to a power.\\n\\n    Returns the polynomial \\`c\\` raised to the power \\`pow\\`. The argument\\n    \\`c\\` is a sequence of coefficients ordered from low to high. i.e.,\\n    [1,2,3] is the series  \\`\\`1 + 2*x + 3*x**2.\\`\\`\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of array of series coefficients ordered from low to\\n        high degree.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Power series of power.\\n\\n    See Also\\n    --------\\n    polyadd, polysub, polymulx, polymul, polydiv\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> P.polypow([1, 2, 3], 2)\\n    array([ 1., 4., 10., 12., 9.])\",\n}\n-/\n\n/-  Raise a polynomial to a power.\n    Returns the polynomial c raised to the power pow.\n    For polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\n    returns p(x)^pow with appropriate coefficient expansion. -/\n\n/-  Specification: polypow raises a polynomial to a non-negative integer power.\n    The result represents the polynomial p(x)^pow where p(x) is defined by coefficients c.\n    For power 0, returns [1] (the constant polynomial 1).\n    For power 1, returns the original polynomial.\n    The degree grows as expected for polynomial multiplication. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polypow {n : Nat} (c : Vector Float n) (pow : Nat) : Id (Vector Float (n * pow + 1)) :=\n  sorry", "vc-theorems": "theorem polypow_spec {n : Nat} (c : Vector Float (n + 1)) (pow : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    polypow c pow\n    \u2983\u21d3result => \u231c(pow = 0 \u2192 result.get \u27e80, by omega\u27e9 = 1) \u2227\n                 (pow = 1 \u2192 \u2200 i : Fin (n + 1), result.get \u27e8i.val, by sorry\u27e9 = c.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyroots", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyroots\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Compute the roots of a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyroots.html\",\n  \"doc\": \"Compute the roots of a polynomial.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\sum_i c[i] * x^i.\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of polynomial coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the polynomial. If all the roots are real,\\n        then `out` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.chebyshev.chebroots\\n    numpy.polynomial.legendre.legroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the power series for such\\n    values. Roots with multiplicity greater than 1 will also show larger\\n    errors as the value of the series near such points is relatively\\n    insensitive to errors in the roots. Isolated roots near the origin can\\n    be improved by a few iterations of Newton's method.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.polynomial as poly\\n    >>> poly.polyroots(poly.polyfromroots((-1,0,1)))\\n    array([-1.,  0.,  1.])\\n    >>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\\n    dtype('float64')\\n    >>> j = complex(0,1)\\n    >>> poly.polyroots(poly.polyfromroots((-j,0,j)))\\n    array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])  # may vary\",\n}\n-/\n\n/-  Compute the roots of a polynomial.\n    Given polynomial coefficients c[0], c[1], ..., c[n-1], returns the roots of\n    p(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n-1]*x^(n-1).\n    For a polynomial of degree n, there are exactly n roots (counting multiplicity). -/\n\n/-  Specification: polyroots returns the roots of the polynomial defined by coefficients.\n    For a polynomial p(x) = \u03a3 c[i] * x^i with degree n (where c[n] \u2260 0), \n    there are exactly n roots (counting multiplicity).\n    The polynomial must be non-constant (degree \u2265 1). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyroots {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem polyroots_spec {n : Nat} (c : Vector Float (n + 1)) \n    (h_nonzero : c.get \u27e8n, by omega\u27e9 \u2260 0) :\n    \u2983\u231cc.get \u27e8n, by omega\u27e9 \u2260 0\u231d\u2984\n    polyroots c\n    \u2983\u21d3roots => \u231c\u2200 i : Fin n, \u2203 j : Fin (n + 1), c.get j \u2260 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polysub", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polysub\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Subtract one polynomial from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polysub.html\",\n  \"doc\": \"Subtract one polynomial from another.\\n\\n    Returns the difference of two polynomials `c1` - `c2`.  The arguments\\n    are sequences of coefficients from lowest order term to highest, i.e.,\\n    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of polynomial coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    polyadd, polymulx, polymul, polydiv, polypow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c1 = (1, 2, 3)\\n    >>> c2 = (3, 2, 1)\\n    >>> P.polysub(c1,c2)\\n    array([-2.,  0.,  2.])\\n    >>> P.polysub(c2, c1)  # -P.polysub(c1,c2)\\n    array([ 2.,  0., -2.])\",\n}\n-/\n\n/-  Subtract one polynomial from another.\n    Returns the difference of two polynomials c1 - c2, where polynomials are\n    represented as coefficient vectors from lowest order term to highest. -/\n\n/-  Specification: polysub computes c1 - c2 element-wise, padding with zeros.\n    The result has length max(n, m), and for each coefficient position i:\n    - If i < min(n, m): result[i] = c1[i] - c2[i]\n    - If min(n, m) \u2264 i < n: result[i] = c1[i]\n    - If min(n, m) \u2264 i < m: result[i] = -c2[i]\n\n    Additionally, polysub satisfies mathematical properties:\n    - Anti-commutativity: polysub c1 c2 = -(polysub c2 c1)\n    - Zero identity: polysub c 0 = c and polysub 0 c = -c -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polysub {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) : Id (Vector Float (max n m)) :=\n  sorry", "vc-theorems": "theorem polysub_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    polysub c1 c2\n    \u2983\u21d3result => \u231c\u2200 i : Fin (max n m),\n        result.get i = \n          if h1 : i.val < n \u2227 i.val < m then\n            c1.get \u27e8i.val, h1.1\u27e9 - c2.get \u27e8i.val, h1.2\u27e9\n          else if h2 : i.val < n \u2227 i.val \u2265 m then\n            c1.get \u27e8i.val, h2.1\u27e9\n          else if h3 : i.val \u2265 n \u2227 i.val < m then\n            -c2.get \u27e8i.val, h3.2\u27e9\n          else\n            0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyval", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyval\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a polynomial at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyval.html\",\n  \"doc\": \"Evaluate a polynomial at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value\\n\\n    .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        with themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The shape of the returned array is described above.\\n\\n    See Also\\n    --------\\n    polyval2d, polygrid2d, polyval3d, polygrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Horner's method.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial.polynomial import polyval\\n    >>> polyval(1, [1,2,3])\\n    6.0\\n    >>> a = np.arange(4).reshape(2,2)\\n    >>> a\\n    array([[0, 1],\\n           [2, 3]])\\n    >>> polyval(a, [1, 2, 3])\\n    array([[ 1.,   6.],\\n           [17.,  34.]])\\n    >>> coef = np.arange(4).reshape(2, 2)  # multidimensional coefficients\\n    >>> coef\\n    array([[0, 1],\\n           [2, 3]])\\n    >>> polyval([1, 2], coef, tensor=True)\\n    array([[2.,  4.],\\n           [4.,  7.]])\\n    >>> polyval([1, 2], coef, tensor=False)\\n    array([2.,  7.])\",\n}\n-/\n\n/-  Evaluate a polynomial at points x using Horner's method.\n    Given coefficients c = [c\u2080, c\u2081, ..., c\u2099] and evaluation points x,\n    computes p(x) = c\u2080 + c\u2081\u00b7x + c\u2082\u00b7x\u00b2 + ... + c\u2099\u00b7x\u207f for each x -/\n\n/-  Specification: polyval evaluates a polynomial with coefficients c at points x.\n    The result at each point x\u1d62 is the polynomial value p(x\u1d62) = c\u2080 + c\u2081\u00b7x\u1d62 + c\u2082\u00b7x\u1d62\u00b2 + ... + c\u2099\u00b7x\u1d62\u207f\n\n    Mathematical properties:\n    - For coefficient vector c = [c\u2080, c\u2081, ..., c\u2099], evaluates polynomial p(x) = \u03a3\u2c7c c\u2c7c\u00b7x\u02b2\n    - Uses Horner's method for numerical stability: p(x) = c\u2080 + x\u00b7(c\u2081 + x\u00b7(c\u2082 + x\u00b7(...)))\n    - Linear in coefficients: p(x, \u03b1c\u2081 + \u03b2c\u2082) = \u03b1\u00b7p(x, c\u2081) + \u03b2\u00b7p(x, c\u2082)\n    - Polynomial evaluation at zero gives constant term: p(0) = c\u2080\n    - For degree-0 polynomial [c\u2080], result is constant c\u2080 for all x -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyval {m n : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem polyval_spec {m n : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    polyval x c\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, \u2203 (poly_val : Float), result.get i = poly_val \u2227\n                  (n = 0 \u2192 poly_val = c.get \u27e80, Nat.zero_lt_succ _\u27e9) \u2227\n                  (\u2200 j : Fin (n + 1), c.get j = 0 \u2192 poly_val = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyval2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyval2d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a 2-D polynomial at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyval2d.html\",\n  \"doc\": \"Evaluate a 2-D polynomial at points (x, y).\\n\\n    This function returns the value\\n\\n    .. math:: p(x,y) = \\\\\\\\sum_{i,j} c_{i,j} * x^i * y^j\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either \\`x\\`\\n    and \\`y\\` or their elements must support multiplication and addition both\\n    with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points \\`\\`(x, y)\\`\\`,\\n        where \\`x\\` and \\`y\\` must have the same shape. If \\`x\\` or \\`y\\` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points formed with\\n        pairs of corresponding values from \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    polyval, polygrid2d, polyval3d, polygrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = ((1, 2, 3), (4, 5, 6))\\n    >>> P.polyval2d(1, 1, c)\\n    21.0\",\n}\n-/\n\n/-  Evaluate a 2D polynomial at points (x, y).\n    Given a coefficient matrix c and evaluation points (x, y),\n    computes p(x,y) = \u03a3\u1d62\u2c7c c\u1d62\u2c7c\u00b7x\u2071\u00b7y\u02b2 for each point pair -/\n\n/-  Specification: polyval2d evaluates a 2D polynomial with coefficient matrix c at point pairs (x, y).\n    The result at each point (x\u1d62, y\u1d62) is the polynomial value p(x\u1d62, y\u1d62) = \u03a3\u1d62\u2c7c c\u1d62\u2c7c\u00b7x\u1d62\u2071\u00b7y\u1d62\u02b2\n\n    Mathematical properties:\n    - For coefficient matrix c[i][j], evaluates p(x,y) = \u03a3\u1d62\u2c7c c[i][j]\u00b7x\u2071\u00b7y\u02b2\n    - Reduces to 1D polyval when one variable is zero: p(x,0) uses first column c[*][0]\n    - Bilinear in coefficients: p(x,y, \u03b1c\u2081 + \u03b2c\u2082) = \u03b1\u00b7p(x,y,c\u2081) + \u03b2\u00b7p(x,y,c\u2082)  \n    - Constant term: p(0,0) = c[0][0]\n    - Degree-0 in both variables gives constant: c = [[c\u2080\u2080]] \u2192 p(x,y) = c\u2080\u2080 for all (x,y) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyval2d {m nx ny : Nat} (x y : Vector Float m) \n    (c : Vector (Vector Float (ny + 1)) (nx + 1)) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem polyval2d_spec {m nx ny : Nat} (x y : Vector Float m) \n    (c : Vector (Vector Float (ny + 1)) (nx + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    polyval2d x y c\n    \u2983\u21d3result => \u231c\u2200 k : Fin m, \u2203 (poly_val : Float), result.get k = poly_val \u2227\n                  -- Constant term property: when both degrees are 0\n                  (nx = 0 \u2227 ny = 0 \u2192 poly_val = (c.get \u27e80, Nat.zero_lt_succ _\u27e9).get \u27e80, Nat.zero_lt_succ _\u27e9) \u2227\n                  -- Zero coefficient property: if all coefficients are zero, result is zero\n                  (\u2200 i : Fin (nx + 1), \u2200 j : Fin (ny + 1), (c.get i).get j = 0 \u2192 poly_val = 0) \u2227\n                  -- Evaluation at origin gives constant term\n                  (x.get k = 0 \u2227 y.get k = 0 \u2192 poly_val = (c.get \u27e80, Nat.zero_lt_succ _\u27e9).get \u27e80, Nat.zero_lt_succ _\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyval3d", "vc-description": "/-  Evaluate a 3-D polynomial at points (x, y, z).\n    This function evaluates the polynomial p(x,y,z) = \u03a3_{i,j,k} c[i,j,k] * x^i * y^j * z^k\n    where the sum is over all valid indices of the coefficient tensor c. -/\n\n/-  Specification: polyval3d evaluates a 3-dimensional polynomial at each point (x[i], y[i], z[i]).\n    The polynomial is defined as the sum of c[i,j,k] * x^i * y^j * z^k over all coefficient indices. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyval3d {n : Nat} {deg_x deg_y deg_z : Nat} \n    (x y z : Vector Float n) \n    (c : Vector (Vector (Vector Float (deg_z + 1)) (deg_y + 1)) (deg_x + 1)) : \n    Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem polyval3d_spec {n : Nat} {deg_x deg_y deg_z : Nat} \n    (x y z : Vector Float n) \n    (c : Vector (Vector (Vector Float (deg_z + 1)) (deg_y + 1)) (deg_x + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    polyval3d x y z c\n    \u2983\u21d3result => \u231c\u2200 p : Fin n, \n                  \u2203 val : Float, result.get p = val \u2227 \n                  (deg_x = 0 \u2227 deg_y = 0 \u2227 deg_z = 0 \u2192 \n                   val = ((c.get \u27e80, sorry\u27e9).get \u27e80, sorry\u27e9).get \u27e80, sorry\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyvalfromroots", "vc-description": "/-  Evaluate a polynomial specified by its roots at points x.\n    If `r` is of length `N`, this function returns the value p(x) = \u220f(x - r_i)\n    where the product is over all roots r_i in the roots vector. -/\n\n/-  Specification: polyvalfromroots evaluates the polynomial with the given roots\n    at each point in x. The polynomial is defined as the product of (x - r_i) for all roots r_i. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyvalfromroots {n m : Nat} (x : Vector Float n) (r : Vector Float m) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem polyvalfromroots_spec {n m : Nat} (x : Vector Float n) (r : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    polyvalfromroots x r\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                  result.get i = (List.range m).foldl (fun acc j => acc * (x.get i - r.get \u27e8j, sorry\u27e9)) 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyvander", "vc-description": "/-  Vandermonde matrix of given degree.\n    Returns the Vandermonde matrix of degree `deg` and sample points `x`.\n    The Vandermonde matrix is defined by V[i,j] = x[i]^j for 0 <= j <= deg. -/\n\n/-  Specification: polyvander generates a Vandermonde matrix where each row corresponds to\n    powers of the corresponding element in x, from degree 0 to deg. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyvander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry", "vc-theorems": "theorem polyvander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    polyvander x deg\n    \u2983\u21d3V => \u231c\u2200 i : Fin n, \n             (V.get i).get \u27e80, Nat.zero_lt_succ deg\u27e9 = 1.0 \u2227 \n             (deg > 0 \u2192 (V.get i).get \u27e81, sorry\u27e9 = x.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyvander2d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyvander2d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Pseudo-Vandermonde matrix of given degrees.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyvander2d.html\",\n  \"doc\": \"Pseudo-Vandermonde matrix of given degrees.\\n\\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\\n    points ``(x, y)``. The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,\\n\\n    where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of\\n    `V` index the points ``(x, y)`` and the last index encodes the powers of\\n    `x` and `y`.\\n\\n    If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`\\n    correspond to the elements of a 2-D coefficient array `c` of shape\\n    (xdeg + 1, ydeg + 1) in the order\\n\\n    .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...\\n\\n    and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same\\n    up to roundoff. This equivalence is useful both for least squares\\n    fitting and for the evaluation of a large number of 2-D polynomials\\n    of the same degrees and sample points.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like\\n        Arrays of point coordinates, all of the same shape. The dtypes\\n        will be converted to either float64 or complex128 depending on\\n        whether any of the elements are complex. Scalars are converted to\\n        1-D arrays.\\n    deg : list of ints\\n        List of maximum degrees of the form [x_deg, y_deg].\\n\\n    Returns\\n    -------\\n    vander2d : ndarray\\n        The shape of the returned matrix is ``x.shape + (order,)``, where\\n        :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same\\n        as the converted `x` and `y`.\\n\\n    See Also\\n    --------\\n    polyvander, polyvander3d, polyval2d, polyval3d\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n\\n    The 2-D pseudo-Vandermonde matrix of degree ``[1, 2]`` and sample\\n    points ``x = [-1, 2]`` and ``y = [1, 3]`` is as follows:\\n\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> x = np.array([-1, 2])\\n    >>> y = np.array([1, 3])\\n    >>> m, n = 1, 2\\n    >>> deg = np.array([m, n])\\n    >>> V = P.polyvander2d(x=x, y=y, deg=deg)\\n    >>> V\\n    array([[ 1.,  1.,  1., -1., -1., -1.],\\n           [ 1.,  3.,  9.,  2.,  6., 18.]])\\n\\n    We can verify the columns for any ``0 <= i <= m`` and ``0 <= j <= n``:\\n\\n    >>> i, j = 0, 1\\n    >>> V[:, (deg[1]+1)*i + j] == x**i * y**j\\n    array([ True,  True])\\n\\n    The (1D) Vandermonde matrix of sample points ``x`` and degree ``m`` is a\\n    special case of the (2D) pseudo-Vandermonde matrix with ``y`` points all\\n    zero and degree ``[m, 0]``.\\n\\n    >>> P.polyvander2d(x=x, y=0*x, deg=(m, 0)) == P.polyvander(x=x, deg=m)\\n    array([[ True,  True],\\n           [ True,  True]])\",\n}\n-/\n\n/-  Pseudo-Vandermonde matrix of given degrees for 2D polynomials.\n    Returns a matrix where V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j\n    for 0 <= i <= xDeg and 0 <= j <= yDeg. -/\n\n/-  Specification: polyvander2d creates a pseudo-Vandermonde matrix where each entry\n    satisfies the polynomial power relationship V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j.\n    The matrix has dimensions n \u00d7 ((xDeg + 1) * (yDeg + 1)) and represents all polynomial\n    terms x^i * y^j for 0 \u2264 i \u2264 xDeg and 0 \u2264 j \u2264 yDeg. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyvander2d {n : Nat} (x y : Vector Float n) (xDeg yDeg : Nat) : \n    Id (Vector (Vector Float ((xDeg + 1) * (yDeg + 1))) n) :=\n  sorry", "vc-theorems": "theorem polyvander2d_spec {n : Nat} (x y : Vector Float n) (xDeg yDeg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    polyvander2d x y xDeg yDeg\n    \u2983\u21d3V => \u231c\u2200 k : Fin n, \u2200 i : Fin (xDeg + 1), \u2200 j : Fin (yDeg + 1),\n            let colIdx := (yDeg + 1) * i.val + j.val\n            let colIdxFin : Fin ((xDeg + 1) * (yDeg + 1)) := \n              \u27e8colIdx, by sorry\u27e9\n            (V.get k).get colIdxFin = (x.get k) ^ (Float.ofNat i.val) * (y.get k) ^ (Float.ofNat j.val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polynomial_polyvander3d", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polynomial.polyvander3d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Pseudo-Vandermonde matrix of given degrees.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyvander3d.html\",\n  \"doc\": \"Pseudo-Vandermonde matrix of given degrees.\\n\\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\\n    then The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,\\n\\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\\n    the powers of `x`, `y`, and `z`.\\n\\n    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\\n\\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\\n\\n    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the\\n    same up to roundoff. This equivalence is useful both for least squares\\n    fitting and for the evaluation of a large number of 3-D polynomials\\n    of the same degrees and sample points.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like\\n        Arrays of point coordinates, all of the same shape. The dtypes will\\n        be converted to either float64 or complex128 depending on whether\\n        any of the elements are complex. Scalars are converted to 1-D\\n        arrays.\\n    deg : list of ints\\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\\n\\n    Returns\\n    -------\\n    vander3d : ndarray\\n        The shape of the returned matrix is ``x.shape + (order,)``, where\\n        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will\\n        be the same as the converted `x`, `y`, and `z`.\\n\\n    See Also\\n    --------\\n    polyvander, polyvander3d, polyval2d, polyval3d\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> x = np.asarray([-1, 2, 1])\\n    >>> y = np.asarray([1, -2, -3])\\n    >>> z = np.asarray([2, 2, 5])\\n    >>> l, m, n = [2, 2, 1]\\n    >>> deg = [l, m, n]\\n    >>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)\\n    >>> V\\n    array([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,\\n             -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],\\n           [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,\\n             -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],\\n           [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,\\n            -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])\\n\\n    We can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,\\n    and ``0 <= k <= n``\\n\\n    >>> i, j, k = 2, 1, 0\\n    >>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k\\n    array([ True,  True,  True])\",\n}\n-/\n\n/-  Pseudo-Vandermonde matrix of given degrees for 3D polynomials.\n    Returns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k\n    for 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg. -/\n\n/-  Specification: polyvander3d creates a pseudo-Vandermonde matrix where each entry\n    satisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.\n    The matrix has dimensions n \u00d7 ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial\n    terms x^i * y^j * z^k for 0 \u2264 i \u2264 xDeg, 0 \u2264 j \u2264 yDeg, and 0 \u2264 k \u2264 zDeg. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def polyvander3d {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) : \n    Id (Vector (Vector Float ((xDeg + 1) * (yDeg + 1) * (zDeg + 1))) n) :=\n  sorry", "vc-theorems": "theorem polyvander3d_spec {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    polyvander3d x y z xDeg yDeg zDeg\n    \u2983\u21d3V => \u231c\u2200 p : Fin n, \u2200 i : Fin (xDeg + 1), \u2200 j : Fin (yDeg + 1), \u2200 k : Fin (zDeg + 1),\n            let colIdx := (yDeg + 1) * (zDeg + 1) * i.val + (zDeg + 1) * j.val + k.val\n            let colIdxFin : Fin ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) := \n              \u27e8colIdx, by sorry\u27e9\n            (V.get p).get colIdxFin = (x.get p) ^ (Float.ofNat i.val) * (y.get p) ^ (Float.ofNat j.val) * (z.get p) ^ (Float.ofNat k.val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_as_series", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polyutils.as_series\",\n  \"category\": \"Polynomial utilities\",\n  \"description\": \"Return argument as a list of 1-d arrays.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polyutils.as_series.html\",\n  \"doc\": \"Return argument as a list of 1-d arrays.\\n\\n    The returned list contains array(s) of dtype double, complex double, or\\n    object.  A 1-d argument of shape \\`\\`(N,)\\`\\` is parsed into \\`\\`N\\`\\` arrays of\\n    size one; a 2-d argument of shape \\`\\`(M,N)\\`\\` is parsed into \\`\\`M\\`\\` arrays\\n    of size \\`\\`N\\`\\` (i.e., is \\\"parsed by row\\\"); and a higher dimensional array\\n    raises a Value Error if it is not first reshaped into either a 1-d or 2-d\\n    array.\\n\\n    Parameters\\n    ----------\\n    alist : array_like\\n        A 1- or 2-d array_like\\n    trim : boolean, optional\\n        When True, trailing zeros are removed from the inputs.\\n        When False, the inputs are passed through intact.\\n\\n    Returns\\n    -------\\n    [a1, a2,...] : list of 1-D arrays\\n        A copy of the input data as a list of 1-d arrays.\\n\\n    Raises\\n    ------\\n    ValueError\\n        Raised when \\`as_series\\` cannot convert its input to 1-d arrays, or at\\n        least one of the resulting arrays is empty.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial import polyutils as pu\\n    >>> a = np.arange(4)\\n    >>> pu.as_series(a)\\n    [array([0.]), array([1.]), array([2.]), array([3.])]\\n    >>> b = np.arange(6).reshape((2,3))\\n    >>> pu.as_series(b)\\n    [array([0., 1., 2.]), array([3., 4., 5.])]\\n\\n    >>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))\\n    [array([1.]), array([0., 1., 2.]), array([0., 1.])]\\n\\n    >>> pu.as_series([2, [1.1, 0.]])\\n    [array([2.]), array([1.1])]\\n\\n    >>> pu.as_series([2, [1.1, 0.]], trim=False)\\n    [array([2.]), array([1.1, 0. ])]\\n\\n    >>> pu.as_series([2, [1.1, 0.]], trim=False)\\n    [array([2.]), array([1.1, 0. ])]\",\n}\n-/\n\n/-  Return argument as a list of 1-d arrays. Takes a 2-d array of shape (M,N)\n    and returns M arrays of size N (parsed by row). Optionally trims trailing \n    zeros from each array. -/\n\n/-  Specification: as_series returns a list of 1-d arrays where each row of the\n    input becomes a separate 1-d array. When trim is false, arrays are unchanged.\n    When trim is true, trailing zeros are removed from each array. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def as_series {m n : Nat} (arr : Vector (Vector Float n) m) (trim : Bool) : \n    Id (Vector (Vector Float n) m) :=\n  sorry", "vc-theorems": "theorem as_series_spec {m n : Nat} (arr : Vector (Vector Float n) m) (trim : Bool) :\n    \u2983\u231cTrue\u231d\u2984\n    as_series arr trim\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, \n                  (\u00actrim \u2192 \u2200 j : Fin n, (result.get i).get j = (arr.get i).get j) \u2227\n                  (trim \u2192 (\u2200 j : Fin n, (result.get i).get j = (arr.get i).get j \u2228 \n                           (result.get i).get j = 0) \u2227\n                          (\u2203 k : Fin n, \u2200 l : Fin n, l > k \u2192 (arr.get i).get l = 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_format_float", "vc-description": "/-  Format a floating-point number into a string representation.\n    This function takes a floating-point value and converts it to a human-readable \n    string format, handling special cases like NaN and infinity, and choosing \n    between scientific and positional notation based on the magnitude of the number. -/\n\n/-  Specification: format_float produces a valid string representation of a float.\n    The function handles special cases (NaN, infinity) and chooses appropriate \n    notation based on the magnitude of the input. The output string should be \n    parseable back to a float representation and preserve the essential value \n    characteristics. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def format_float (x : Float) (parens : Bool := false) : Id String :=\n  sorry", "vc-theorems": "theorem format_float_spec (x : Float) (parens : Bool := false) :\n    \u2983\u231cTrue\u231d\u2984\n    format_float x parens\n    \u2983\u21d3result => \u231c\n      -- The result is a non-empty string\n      result.length > 0 \u2227\n      -- If x is NaN, result represents NaN (case insensitive)\n      (x.isNaN \u2192 (result = \"nan\" \u2228 result = \"NaN\")) \u2227\n      -- If x is positive infinity, result represents positive infinity\n      (x.isInf \u2227 x > 0 \u2192 (result = \"inf\" \u2228 result = \"Inf\")) \u2227\n      -- If x is negative infinity, result represents negative infinity\n      (x.isInf \u2227 x < 0 \u2192 (result = \"-inf\" \u2228 result = \"-Inf\")) \u2227\n      -- If x is zero, result represents zero appropriately\n      (x = 0.0 \u2192 (result = \"0.\" \u2228 result = \"0.0\" \u2228 result = \"0\")) \u2227\n      -- For finite non-zero numbers, result contains digits\n      (x.isFinite \u2227 x \u2260 0.0 \u2192 \n        (result.any (fun c => c.isDigit) = true)) \u2227\n      -- For negative finite numbers, result starts with minus sign\n      (x.isFinite \u2227 x < 0 \u2192 result.startsWith \"-\") \u2227\n      -- If parens is true and the result looks like scientific notation, wrap in parentheses\n      (parens \u2227 (result.any (fun c => c = 'e' \u2228 c = 'E')) \u2192 \n        (result.startsWith \"(\" \u2227 result.endsWith \")\")) \u2227\n      -- Result contains only valid float representation characters\n      (result.all (fun c => c.isDigit \u2228 c = '.' \u2228 c = '-' \u2228 c = '+' \u2228 c = 'e' \u2228 c = 'E' \u2228 \n                            c = '(' \u2228 c = ')' \u2228 c = 'n' \u2228 c = 'a' \u2228 c = 'i' \u2228 c = 'f' \u2228 c = 'I' \u2228 c = 'N'))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_getdomain", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polyutils.getdomain\",\n  \"category\": \"Polynomial utilities\",\n  \"description\": \"Return a domain suitable for given abscissae.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polyutils.getdomain.html\",\n  \"doc\": \"Return a domain suitable for given abscissae.\\n\\n    Find a domain suitable for a polynomial or Chebyshev series\\n    defined at the values supplied.\\n\\n    Parameters\\n    ----------\\n    x : array_like\\n        1-d array of abscissae whose domain will be determined.\\n\\n    Returns\\n    -------\\n    domain : ndarray\\n        1-d array containing two values.  If the inputs are complex, then\\n        the two returned points are the lower left and upper right corners\\n        of the smallest rectangle (aligned with the axes) in the complex\\n        plane containing the points \\`x\\`. If the inputs are real, then the\\n        two points are the ends of the smallest interval containing the\\n        points \\`x\\`.\\n\\n    See Also\\n    --------\\n    mapparms, mapdomain\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> from numpy.polynomial import polyutils as pu\\n    >>> points = np.arange(4)**2 - 5; points\\n    array([-5, -4, -1,  4])\\n    >>> pu.getdomain(points)\\n    array([-5.,  4.])\\n    >>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle\\n    >>> pu.getdomain(c)\\n    array([-1.-1.j,  1.+1.j])\",\n}\n-/\n\n/-  Return a domain suitable for given abscissae (real numbers).\n    For real inputs, returns the minimum and maximum values as a 2-element vector.\n    This represents the smallest interval containing all points in the input vector. -/\n\n/-  Specification: getdomain returns the smallest interval containing all input points -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def getdomain {n : Nat} (x : Vector Float (n + 1)) : Id (Vector Float 2) :=\n  sorry", "vc-theorems": "theorem getdomain_spec {n : Nat} (x : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    getdomain x\n    \u2983\u21d3result => \u231c\n      -- The minimum is less than or equal to the maximum\n      result[0] \u2264 result[1] \u2227\n      -- Every element in x is within the domain\n      (\u2200 i : Fin (n + 1), result[0] \u2264 x[i] \u2227 x[i] \u2264 result[1]) \u2227\n      -- The domain bounds are achieved by some elements in x\n      (\u2203 i : Fin (n + 1), x[i] = result[0]) \u2227\n      (\u2203 j : Fin (n + 1), x[j] = result[1])\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_mapdomain", "vc-description": "/-  numpy.polynomial.polyutils.mapdomain: Apply linear map to input points.\n\n    The linear map `offset + scale*x` that maps the domain `old` to\n    the domain `new` is applied to the points `x`.\n\n    This function implements the mathematical transformation:\n    x_out = new[0] + m(x - old[0])\n    where m = (new[1] - new[0]) / (old[1] - old[0])\n\n    Parameters:\n    - x: Points to be mapped (Vector of Float values)\n    - old: Two-element vector defining the old domain [old[0], old[1]]\n    - new: Two-element vector defining the new domain [new[0], new[1]]\n\n    Returns:\n    - x_out: Array of points of the same shape as x, after linear transformation\n-/\n\n/-  Specification: mapdomain applies linear transformation to map points from old domain to new domain.\n\n    The function computes a linear transformation that maps the interval [old[0], old[1]] \n    to the interval [new[0], new[1]], then applies this transformation to each point in x.\n\n    Mathematical properties:\n    1. The transformation is linear: f(x) = offset + scale * x\n    2. The scale factor is: (new[1] - new[0]) / (old[1] - old[0])\n    3. The offset is: new[0] - scale * old[0]\n    4. Points at old[0] map to new[0], points at old[1] map to new[1]\n\n    Precondition: The old domain must be non-degenerate (old[1] \u2260 old[0])\n    Postcondition: Each result point follows the linear transformation formula\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mapdomain {n : Nat} (x : Vector Float n) (old new : Vector Float 2) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem mapdomain_spec {n : Nat} (x : Vector Float n) (old new : Vector Float 2)\n    (h_nondegenerate : old.get 1 \u2260 old.get 0) :\n    \u2983\u231cold.get 1 \u2260 old.get 0\u231d\u2984\n    mapdomain x old new\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let scale := (new.get 1 - new.get 0) / (old.get 1 - old.get 0)\n      let offset := new.get 0 - scale * old.get 0\n      result.get i = offset + scale * x.get i\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_mapparms", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polyutils.mapparms\",\n  \"category\": \"Polynomial utilities\",\n  \"description\": \"Linear map parameters between domains.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polyutils.mapparms.html\",\n  \"doc\": \"Linear map parameters between domains.\\n\\n    Return the parameters of the linear map \\`\\`offset + scale*x\\`\\` that maps\\n    \\`old\\` to \\`new\\` such that \\`\\`old[i] -> new[i]\\`\\`, \\`\\`i = 0, 1\\`\\`.\\n\\n    Parameters\\n    ----------\\n    old, new : array_like\\n        Domains. Each domain must (successfully) convert to a 1-d array\\n        containing precisely two values.\\n\\n    Returns\\n    -------\\n    offset, scale : scalars\\n        The map \\`\\`L(x) = offset + scale*x\\`\\` maps the first domain to the\\n        second.\\n\\n    See Also\\n    --------\\n    getdomain, mapdomain\\n\\n    Notes\\n    -----\\n    Also works for complex numbers, and thus can be used to calculate the\\n    parameters required to map any line in the complex plane to any other\\n    line therein.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polyutils as pu\\n    >>> pu.mapparms((-1,1),(-1,1))\\n    (0.0, 1.0)\\n    >>> pu.mapparms((1,-1),(-1,1))\\n    (-0.0, -1.0)\\n    >>> i = complex(0,1)\\n    >>> pu.mapparms((-i,-1),(1,i))\\n    ((1+1j), (1-0j))\",\n}\n-/\n\n/-  Linear map parameters between domains. \n    Returns the parameters of the linear map `offset + scale*x` that maps\n    `old` to `new` such that `old[i] -> new[i]`, `i = 0, 1`. -/\n\n/-  Specification: mapparms computes linear mapping parameters between domains.\n    The returned offset and scale define a linear map L(x) = offset + scale*x\n    that maps the old domain to the new domain. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mapparms (old new : Vector Float 2) : Id (Float \u00d7 Float) :=\n  sorry", "vc-theorems": "theorem mapparms_spec (old new : Vector Float 2) \n    (h_old_distinct : old.get \u27e80, by simp\u27e9 \u2260 old.get \u27e81, by simp\u27e9) :\n    \u2983\u231cold.get \u27e80, by simp\u27e9 \u2260 old.get \u27e81, by simp\u27e9\u231d\u2984\n    mapparms old new\n    \u2983\u21d3result => \u231clet (offset, scale) := result\n                  let oldlen := old.get \u27e81, by simp\u27e9 - old.get \u27e80, by simp\u27e9\n                  let newlen := new.get \u27e81, by simp\u27e9 - new.get \u27e80, by simp\u27e9\n                  -- The linear map L(x) = offset + scale*x maps old domain to new domain\n                  offset + scale * old.get \u27e80, by simp\u27e9 = new.get \u27e80, by simp\u27e9 \u2227\n                  offset + scale * old.get \u27e81, by simp\u27e9 = new.get \u27e81, by simp\u27e9 \u2227\n                  -- Mathematical relationships from numpy implementation\n                  scale = newlen / oldlen \u2227\n                  offset = (old.get \u27e81, by simp\u27e9 * new.get \u27e80, by simp\u27e9 - old.get \u27e80, by simp\u27e9 * new.get \u27e81, by simp\u27e9) / oldlen\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_trimcoef", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polyutils.trimcoef\",\n  \"category\": \"Polynomial utilities\",\n  \"description\": \"Remove \\\"small\\\" \\\"trailing\\\" coefficients from a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polyutils.trimcoef.html\",\n  \"doc\": \"Remove \\\"small\\\" \\\"trailing\\\" coefficients from a polynomial.\\n\\n    \\\"Small\\\" means \\\"small in absolute value\\\" and is controlled by the\\n    parameter \\`tol\\`; \\\"trailing\\\" means highest order coefficient(s), e.g., in\\n    \\`\\`[0, 1, 1, 0, 0]\\`\\` (which represents \\`\\`0 + x + x**2 + 0*x**3 + 0*x**4\\`\\`)\\n    both the 3-rd and 4-th order coefficients would be \\\"trimmed.\\\"\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-d array of coefficients, ordered from lowest order to highest.\\n    tol : number, optional\\n        Trailing (i.e., highest order) elements with absolute value less\\n        than or equal to \\`tol\\` (default value is zero) are removed.\\n\\n    Returns\\n    -------\\n    trimmed : ndarray\\n        1-d array with trailing zeros removed.  If the resulting series\\n        would be empty, a series containing a single zero is returned.\\n\\n    Raises\\n    ------\\n    ValueError\\n        If \\`tol\\` < 0\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polyutils as pu\\n    >>> pu.trimcoef((0,0,3,0,5,0,0))\\n    array([0.,  0.,  3.,  0.,  5.])\\n    >>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\\n    array([0.])\\n    >>> i = complex(0,1) # works for complex\\n    >>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\\n    array([0.0003+0.j   , 0.001 -0.001j])\",\n}\n-/\n\n/-  Remove \"small\" \"trailing\" coefficients from a polynomial.\n    Small means small in absolute value controlled by tolerance parameter.\n    Trailing means highest order coefficients. -/\n\n/-  Specification: trimcoef removes trailing coefficients with absolute value \u2264 tol.\n    If all coefficients are small, returns a single zero.\n    The tolerance must be non-negative. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def trimcoef {n : Nat} (c : Vector Float n) (tol : Float) : Id (Vector Float (n + 1)) :=\n  sorry", "vc-theorems": "theorem trimcoef_spec {n : Nat} (c : Vector Float n) (tol : Float) \n    (h_tol_nonneg : tol \u2265 0) :\n    \u2983\u231ctol \u2265 0\u231d\u2984\n    trimcoef c tol\n    \u2983\u21d3result => \u231c\n      -- Basic sanity: result is non-empty\n      (\u2203 m : Nat, m \u2265 1) \u2227\n      -- Special case: if all input coefficients are small, return single zero\n      ((\u2200 i : Fin n, Float.abs (c.get i) \u2264 tol) \u2192 \n        (\u2203 h : 0 < n + 1, result.get \u27e80, h\u27e9 = 0)) \u2227\n      -- General case: preserve coefficients up to the last significant one\n      ((\u2203 i : Fin n, Float.abs (c.get i) > tol) \u2192 \n        (\u2203 last_significant : Fin n, \n          -- last_significant is the rightmost index with coefficient > tol\n          (Float.abs (c.get last_significant) > tol) \u2227\n          (\u2200 j : Fin n, j > last_significant \u2192 Float.abs (c.get j) \u2264 tol) \u2227\n          -- All coefficients up to last_significant are preserved in order\n          (\u2200 i : Fin n, i.val \u2264 last_significant.val \u2192 \n            (\u2203 h : i.val < n + 1, result.get \u27e8i.val, h\u27e9 = c.get i)))) \u2227\n      -- Mathematical correctness: no large coefficients are lost\n      (\u2200 i : Fin n, Float.abs (c.get i) > tol \u2192 \n        (\u2203 j : Fin (n + 1), result.get j = c.get i)) \u2227\n      -- Trimming guarantee: result has no trailing large coefficients\n      (\u2200 i : Fin (n + 1), (\u2200 j : Fin (n + 1), j > i \u2192 Float.abs (result.get j) \u2264 tol) \u2192\n        (\u2200 k : Fin (n + 1), k \u2265 i \u2192 Float.abs (result.get k) \u2264 tol))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "polynomial_polyutils_trimseq", "vc-description": "/- \n{\n  \"name\": \"numpy.polynomial.polyutils.trimseq\",\n  \"category\": \"Polynomial utilities\",\n  \"description\": \"Remove small Poly series coefficients.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polyutils.trimseq.html\",\n  \"doc\": \"Remove small Poly series coefficients.\\n\\n    Parameters\\n    ----------\\n    seq : sequence\\n        Sequence of Poly series coefficients.\\n\\n    Returns\\n    -------\\n    series : sequence\\n        Subsequence with trailing zeros removed. If the resulting sequence\\n        would be empty, return the first element. The returned sequence may\\n        or may not be a view.\\n\\n    Notes\\n    -----\\n    Do not lose the type info if the sequence contains unknown objects.\",\n}\n-/\n\n/-  Remove trailing zeros from a sequence of polynomial coefficients.\n    Returns the sequence with trailing zeros removed. If the sequence would be empty \n    after trimming, returns the first element. Empty sequences are handled. -/\n\n/-  Specification: trimseq removes trailing zeros while preserving at least one element.\n    For non-empty sequences, if the last element is non-zero, return the sequence unchanged.\n    If the last element is zero, trim trailing zeros but always keep at least one element. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def trimseq {n : Nat} (seq : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem trimseq_spec {n : Nat} (seq : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    trimseq seq\n    \u2983\u21d3result => \u231c-- Result has same length as input\n                 result.toList.length = n \u2227\n                 -- If empty or last element is non-zero, return unchanged\n                 (n = 0 \u2228 (n > 0 \u2227 seq.get \u27e8n - 1, sorry\u27e9 \u2260 0) \u2192 result = seq) \u2227\n                 -- If last element is zero, trim properly\n                 (n > 0 \u2227 seq.get \u27e8n - 1, sorry\u27e9 = 0 \u2192 \n                   -- There exists a position k where trimming occurs\n                   (\u2203 k : Fin n, \n                    -- All elements after k in original sequence are zero\n                    (\u2200 j : Fin n, j.val > k.val \u2192 seq.get j = 0) \u2227\n                    -- Result preserves elements up to k, zeros after\n                    (\u2200 i : Fin n, i.val \u2264 k.val \u2192 result.get i = seq.get i) \u2227\n                    (\u2200 i : Fin n, i.val > k.val \u2192 result.get i = 0) \u2227\n                    -- Element at k is non-zero unless k = 0 (all zeros case)\n                    (k.val > 0 \u2192 seq.get k \u2260 0)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_BitGenerator", "vc-description": "/- \n{\n  \"name\": \"numpy.random.BitGenerator\",\n  \"description\": \"Base class for bit generators\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/bit_generators/index.html\",\n  \"doc\": \"BitGenerator(seed=None)\\n\\nBase class for bit generators.\\n\\nThe BitGenerator has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.\\n\\nThis class should not be instantiated directly.\",\n}\n-/\n\n/-  numpy.random.BitGenerator: Base class for bit generators.\n\n    The BitGenerator manages state and provides functions to produce random doubles \n    and random unsigned 32- and 64-bit values. This function initializes a BitGenerator\n    with an optional seed value.\n\n    Parameters:\n    - seed: Optional seed value to initialize the generator (None uses system entropy)\n\n    Returns:\n    - A BitGeneratorState that can be used to generate random values\n-/\n\n/-  Specification: numpy.random.BitGenerator creates a properly initialized BitGenerator state.\n\n    Precondition: True (any seed value is valid, including None)\n    Postcondition: The returned state has the provided seed (or maintains None if no seed given)\n                  and has a valid internal state representation.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- BitGenerator state representing the internal state of a pseudo-random number generator.\n    This is an abstract representation that can be seeded and used to generate random values.\n-/\nstructure BitGeneratorState where\n  /-- The seed value used to initialize the generator, or None if no seed was provided -/\n  seed : Option UInt64\n  /-- The internal state of the generator used for random number generation -/\n  internal_state : UInt64", "vc-helpers": "", "vc-definitions": "def numpy_random_BitGenerator (seed : Option UInt64) : Id BitGeneratorState :=\n  sorry", "vc-theorems": "theorem numpy_random_BitGenerator_spec (seed : Option UInt64) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_random_BitGenerator seed\n    \u2983\u21d3result => \u231cresult.seed = seed \u2227 \n                 (seed.isSome \u2192 result.internal_state \u2260 0) \u2227\n                 (seed.isNone \u2192 result.internal_state = 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_MT19937", "vc-description": "/-  MT19937 BitGenerator for the Mersenne Twister pseudo-random number generator\n\n    MT19937 provides a capsule containing function pointers that produce doubles, \n    and unsigned 32 and 64-bit integers. This implementation focuses on the core\n    state initialization and next value generation.\n\n    The Mersenne Twister is a pseudorandom number generator that maintains an\n    internal state and produces a sequence of 32-bit integers with a period of 2^19937 - 1.\n\n    Parameters:\n    - seed : UInt32 optional seed value to initialize the generator\n\n    The generator produces uniformly distributed values in [0, 2^32 - 1]\n-/\n\n/-  Specification: MT19937 initializes the generator state with proper seeding\n\n    The MT19937 generator maintains a state vector of 624 32-bit integers.\n    When initialized with a seed, it produces a deterministic sequence.\n\n    Precondition: None (any seed value is valid)\n    Postcondition: \n    1. The state vector has exactly 624 elements\n    2. The state is deterministically initialized based on the seed\n    3. The first element of the state equals the seed\n    4. The generator produces deterministic values based on the seed\n    5. All state values are 32-bit unsigned integers\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mt19937 (seed : UInt32) : Id (Vector UInt32 624) :=\n  sorry", "vc-theorems": "theorem mt19937_spec (seed : UInt32) :\n    \u2983\u231cTrue\u231d\u2984\n    mt19937 seed\n    \u2983\u21d3state => \u231c\n      -- The state vector has the correct size (624 elements)\n      (state.size = 624) \u2227\n      -- The first element equals the seed\n      (state.get \u27e80, by simp\u27e9 = seed) \u2227\n      -- All elements are valid 32-bit values (this is guaranteed by type)\n      (\u2200 i : Fin 624, True) \u2227\n      -- State initialization follows MT19937 recurrence relation\n      (\u2200 i : Fin 623, \n        let k := i.val + 1\n        let prev_state := state.get \u27e8i.val, by exact Nat.lt_trans i.2 (by simp)\u27e9\n        let shifted := prev_state.shiftRight 30\n        let xor_result := prev_state ^^^ shifted\n        let mult_result := 1812433253 * xor_result\n        let next_val := mult_result + UInt32.ofNat k\n        \u2203 h : k < 624, state.get \u27e8k, h\u27e9 = next_val) \u2227\n      -- Deterministic: same seed produces same initial state\n      (\u2200 seed' : UInt32, seed = seed' \u2192 \n        \u2200 state' : Vector UInt32 624, \n          state'.get \u27e80, by simp\u27e9 = seed' \u2192 \n          (\u2200 j : Fin 624, state.get j = state'.get j))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_PCG64DXSM", "vc-description": "/- \n{\n  \"name\": \"numpy.random.PCG64DXSM\",\n  \"description\": \"BitGenerator for the PCG-64 DXSM pseudo-random number generator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/bit_generators/pcg64dxsm.html\",\n  \"doc\": \"PCG64DXSM(seed=None)\\n\\nBitGenerator for the PCG-64 DXSM pseudo-random number generator.\\n\\nPCG-64 DXSM is an implementation of O'Neill's permutation congruential generator with the DXSM output mixer. It has better statistical properties in parallel contexts than the standard PCG-64.\\n\\nParameters:\\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\\n    A seed to initialize the BitGenerator\",\n}\n-/\n\n/-  PCG64DXSM: BitGenerator for the PCG-64 DXSM pseudo-random number generator.\n\n    PCG-64 DXSM is a 128-bit implementation of O'Neill's permutation congruential generator\n    with the DXSM output mixer. It has better statistical properties in parallel contexts\n    than the standard PCG-64.\n\n    The generator uses a linear congruential generator (LCG) to advance the state,\n    with a fixed odd increment. It uses a 64-bit \"cheap multiplier\" in the LCG.\n    The generator has a period of 2^128 and supports advancing an arbitrary number\n    of steps as well as 2^127 streams.\n\n    This function generates a sequence of random 64-bit unsigned integers given\n    a seed value.\n-/\n\n/-  Specification: PCG64DXSM generates a sequence of pseudo-random numbers with specific mathematical properties.\n\n    The PCG64DXSM generator satisfies the following properties:\n    1. Deterministic: Same seed produces same sequence\n    2. Uniform distribution: All 64-bit values are equally likely over the full period\n    3. Full period: The generator has period 2^128\n    4. Statistical independence: Generated values appear statistically independent\n    5. Non-predictability: Knowledge of some outputs doesn't easily predict others\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def PCG64DXSM {n : Nat} (seed : UInt64) : Id (Vector UInt64 n) :=\n  sorry", "vc-theorems": "theorem PCG64DXSM_spec {n : Nat} (seed : UInt64) :\n    \u2983\u231cTrue\u231d\u2984\n    PCG64DXSM seed\n    \u2983\u21d3result => \u231c\n      -- Deterministic property: same seed produces same sequence\n      (\u2200 (seed' : UInt64), seed = seed' \u2192 result = (PCG64DXSM seed' : Id (Vector UInt64 n))) \u2227\n      -- Non-trivial output: if n > 0, we get at least one non-zero value  \n      (n > 0 \u2192 \u2203 (i : Fin n), result.get i \u2260 0) \u2227\n      -- Distinctness property: for sufficient length, not all values are identical\n      (n > 1 \u2192 \u2203 (i j : Fin n), i \u2260 j \u2227 (result.get i \u2260 result.get j \u2228 result.get i = result.get j)) \u2227\n      -- Seed dependency: different seeds should generally produce different sequences\n      (\u2200 (seed' : UInt64), seed \u2260 seed' \u2192 \n        let other := (PCG64DXSM seed' : Id (Vector UInt64 n))\n        n > 0 \u2192 \u2203 (i : Fin n), result.get i \u2260 other.get i)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_Philox", "vc-description": "/-  Philox (4x64) pseudo-random number generator.\n\n    Philox is a counter-based RNG that generates pseudo-random numbers\n    using a counter and key. It provides high-quality random numbers\n    with a large period (2^256 - 1) and supports parallel generation.\n\n    The core operation takes a seed and generates a vector of random\n    numbers in the range [0, 1).\n-/\n\n/-  Specification: Philox generates pseudo-random numbers with deterministic behavior.\n\n    The Philox algorithm has several key mathematical properties:\n    1. Deterministic: same seed produces same sequence\n    2. Uniform distribution: values are uniformly distributed in [0, 1)\n    3. Range constraint: all values are in the half-open interval [0, 1)\n    4. Reproducibility: identical seeds produce identical sequences\n\n    Precondition: True (no special preconditions)\n    Postcondition: All values are in [0, 1) and sequence is deterministic based on seed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def philox {n : Nat} (seed : Nat) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem philox_spec {n : Nat} (seed : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    philox seed\n    \u2983\u21d3result => \u231c(\u2200 i : Fin n, 0 \u2264 result.get i \u2227 result.get i < 1) \u2227\n                  (\u2200 seed\u2081 seed\u2082 : Nat, seed\u2081 = seed\u2082 \u2192 (philox seed\u2081 : Id (Vector Float n)) = (philox seed\u2082 : Id (Vector Float n)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_RandomState", "vc-description": "/- \n{\n  \"name\": \"numpy.random.RandomState\",\n  \"description\": \"Container for the slow Mersenne Twister pseudo-random number generator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState\",\n  \"doc\": \"RandomState(seed=None)\\n\\nContainer for the slow Mersenne Twister pseudo-random number generator.\\n\\nConsider using the more modern np.random.Generator instead.\\n\\nRandomState is effectively frozen and will only receive updates required for compatibility.\\n\\nParameters:\\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\\n    Random seed initializing the pseudo-random number generator\",\n}\n-/\n\n/-  Generate a random float in the range [0, 1) using the RandomState\n    This models the RandomState.random() method which is the most fundamental\n    operation for generating uniformly distributed random numbers.\n-/\n\n/-  Specification: random generates a float in the range [0, 1)\n\n    The random function should satisfy:\n    1. The result is always in the range [0, 1)\n    2. The result is deterministic given the same seed\n    3. The result follows uniform distribution properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A simple random state container that can generate random numbers\n    This models the core functionality of numpy.random.RandomState.\n    We focus on the random() method which generates random floats in [0, 1).\n-/\nstructure RandomState where\n  /-- The seed value used to initialize the random number generator -/\n  seed : Nat", "vc-helpers": "", "vc-definitions": "def random (state : RandomState) : Id Float :=\n  sorry", "vc-theorems": "theorem random_spec (state : RandomState) :\n    \u2983\u231cTrue\u231d\u2984\n    random state\n    \u2983\u21d3result => \u231c0 \u2264 result \u2227 result < 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_SFC64", "vc-description": "/- \n{\n  \"name\": \"numpy.random.SFC64\",\n  \"description\": \"BitGenerator for the SFC64 pseudo-random number generator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/bit_generators/sfc64.html\",\n  \"doc\": \"SFC64(seed=None)\\n\\nBitGenerator for the SFC64 pseudo-random number generator.\\n\\nSFC64 is a chaotic RNG that uses a 256-bit state. It is very fast and appears to be very robust to statistical tests.\\n\\nParameters:\\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\\n    A seed to initialize the BitGenerator\",\n}\n-/\n\n/-  SFC64 pseudo-random number generator with 256-bit state -/\n\n/-  Specification: SFC64 initializes a 256-bit state from seed -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- SFC64 state containing 256 bits split into four 64-bit words -/\nstructure SFC64State where\n  a : UInt64\n  b : UInt64  \n  c : UInt64\n  counter : UInt64", "vc-helpers": "", "vc-definitions": "def sfc64 (seed : Option UInt64) : Id SFC64State :=\n  sorry", "vc-theorems": "theorem sfc64_spec (seed : Option UInt64) :\n    \u2983\u231cTrue\u231d\u2984\n    sfc64 seed\n    \u2983\u21d3state => \u231c(seed.isNone \u2192 state.a = 0 \u2227 state.b = 0 \u2227 state.c = 0 \u2227 state.counter = 0) \u2227\n                 (seed.isSome \u2192 \u2203 s : UInt64, seed = some s \u2227 \n                   (state.a \u2260 0 \u2228 state.b \u2260 0 \u2228 state.c \u2260 0 \u2228 state.counter \u2260 0)) \u2227\n                 (\u2200 s1 s2 : UInt64, s1 \u2260 s2 \u2192 \n                   \u2203 state1 state2 : SFC64State, \n                     (sfc64 (some s1)).run = state1 \u2227 (sfc64 (some s2)).run = state2 \u2227\n                     (state1.a \u2260 state2.a \u2228 state1.b \u2260 state2.b \u2228 state1.c \u2260 state2.c \u2228 state1.counter \u2260 state2.counter))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_SeedSequence", "vc-description": "/-  numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way\n    to set the initial state for independent and very probably non-overlapping\n    BitGenerators.\n\n    SeedSequence takes entropy sources (integers) and mixes them using\n    cryptographic hash functions to produce high-quality seed states.\n    The mixing algorithm ensures that even low-quality entropy sources\n    produce high-quality, uniformly distributed output.\n\n    Key properties:\n    - Reproducible: Same entropy input always produces same output\n    - Avalanche effect: Single bit changes affect all output bits\n    - Independence: Spawned sequences are non-overlapping\n    - Uniform distribution: Output is uniformly distributed over the state space\n-/\n\n/-  Specification: SeedSequence produces a seed state from entropy sources\n    with reproducibility and non-degeneracy properties.\n\n    Precondition: True (accepts any entropy input, including empty)\n    Postcondition: \n    1. Reproducibility: Same entropy always produces same output\n    2. Non-degeneracy: Output depends on input entropy\n    3. Deterministic: Function is deterministic for fixed inputs\n    4. Well-defined: Always produces valid output within expected bounds\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def seedSequence {n : Nat} (entropy : Vector UInt32 n) (spawn_key : Vector UInt32 0) \n    (pool_size : Nat := 4) : Id (Vector UInt32 pool_size) :=\n  sorry", "vc-theorems": "theorem seedSequence_spec {n : Nat} (entropy : Vector UInt32 n) (spawn_key : Vector UInt32 0)\n    (pool_size : Nat := 4) :\n    \u2983\u231cTrue\u231d\u2984\n    seedSequence entropy spawn_key pool_size\n    \u2983\u21d3result => \u231c\n      -- Reproducibility property: same inputs produce same outputs\n      (\u2200 entropy2 spawn_key2, entropy = entropy2 \u2227 spawn_key = spawn_key2 \u2192 \n        seedSequence entropy2 spawn_key2 pool_size = result) \u2227\n      -- Non-degeneracy: output depends on input when entropy is present\n      (n > 0 \u2192 \u2203 i : Fin n, \u2203 modified_entropy : Vector UInt32 n,\n        modified_entropy \u2260 entropy \u2192\n        seedSequence modified_entropy spawn_key pool_size \u2260 result) \u2227\n      -- Deterministic: function is well-defined and deterministic\n      (\u2200 call1 call2, call1 = seedSequence entropy spawn_key pool_size \u2227\n                      call2 = seedSequence entropy spawn_key pool_size \u2192 \n                      call1 = call2) \u2227\n      -- Well-defined output: result has the correct size\n      (result.size = pool_size)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "random_default_rng", "vc-description": "/- \n{\n  \"name\": \"numpy.random.default_rng\",\n  \"description\": \"Construct a new Generator with the default BitGenerator (PCG64)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/generator.html\",\n  \"doc\": \"default_rng(seed=None)\\n\\nConstruct a new Generator with the default BitGenerator (PCG64).\\n\\nParameters:\\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\\n    A seed to initialize the BitGenerator. If None, fresh, unpredictable entropy will be pulled from the OS.\\n\\nReturns:\\n- Generator\\n    The initialized generator object\",\n}\n-/\n\n/-  numpy.random.default_rng: Construct a new Generator with the default BitGenerator (PCG64).\n\n    Creates a new Generator instance using PCG64 as the underlying BitGenerator.\n    This is the recommended way to create random number generators in NumPy.\n\n    If seed is None, the generator will be initialized with fresh entropy from the OS.\n    If seed is provided, the generator will be deterministically initialized with that seed.\n-/\n\n/-  Specification: default_rng returns a properly initialized Generator object.\n\n    Precondition: True (no restrictions on the seed parameter)\n    Postcondition: The returned Generator is properly initialized with the given seed\n    and uses PCG64 as the underlying BitGenerator.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- BitGenerator represents the underlying random number generator engine -/\nstructure BitGenerator where\n  /-- Internal state of the generator -/\n  state : Nat\n  /-- Seed used to initialize the generator -/\n  seed : Option Nat\n\n/-- Generator provides high-level random number generation methods -/\nstructure Generator where\n  /-- The underlying BitGenerator (PCG64 by default) -/\n  bitGenerator : BitGenerator\n  /-- Whether the generator has been properly initialized -/\n  initialized : Bool", "vc-helpers": "", "vc-definitions": "def default_rng (seed : Option Nat := none) : Id Generator :=\n  sorry", "vc-theorems": "theorem default_rng_spec (seed : Option Nat := none) :\n    \u2983\u231cTrue\u231d\u2984\n    default_rng seed\n    \u2983\u21d3result => \u231cresult.initialized = true \u2227 \n                 result.bitGenerator.seed = seed \u2227\n                 (seed.isSome \u2192 result.bitGenerator.state \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_in1d", "vc-description": "/- \n{\n  \"name\": \"numpy.in1d\",\n  \"category\": \"Testing membership\",\n  \"description\": \"Test whether each element of a 1-D array is also present in a second array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.in1d.html\",\n  \"doc\": \"Test whether each element of a 1-D array is also present in a second array.\\n\\n.. deprecated:: 2.0\\n    Use :func:`isin` instead of `in1d` for new code.\\n\\nReturns a boolean array the same length as `ar1` that is True\\nwhere an element of `ar1` is in `ar2` and False otherwise.\\n\\nParameters\\n----------\\nar1 : (M,) array_like\\n    Input array.\\nar2 : array_like\\n    The values against which to test each value of `ar1`.\\n\\nReturns\\n-------\\nin1d : (M,) ndarray, bool\\n    The values `ar1[in1d]` are in `ar2`.\",\n}\n-/\n\n/-  Test whether each element of a 1-D array is also present in a second array.\n    Returns a boolean array the same length as `ar1` that is True where an element \n    of `ar1` is in `ar2` and False otherwise. -/\n\n/-  Specification: in1d tests membership of each element of ar1 in ar2.\n    The result is a boolean vector of the same length as ar1, where each element\n    indicates whether the corresponding element of ar1 is present in ar2. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def in1d {\u03b1 : Type} {m n : Nat} [DecidableEq \u03b1] (ar1 : Vector \u03b1 m) (ar2 : Vector \u03b1 n) : Id (Vector Bool m) :=\n  sorry", "vc-theorems": "theorem in1d_spec {\u03b1 : Type} {m n : Nat} [DecidableEq \u03b1] (ar1 : Vector \u03b1 m) (ar2 : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    in1d ar1 ar2\n    \u2983\u21d3result => \u231c\u2200 i : Fin m, result.get i = true \u2194 \u2203 j : Fin n, ar1.get i = ar2.get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_intersect1d", "vc-description": "/- \n{\n  \"name\": \"numpy.intersect1d\",\n  \"category\": \"Set operations\",\n  \"description\": \"Find the intersection of two arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.intersect1d.html\",\n  \"doc\": \"Find the intersection of two arrays.\\n\\nReturn the sorted, unique values that are in both of the input arrays.\\n\\nParameters\\n----------\\nar1, ar2 : array_like\\n    Input arrays. Will be flattened if not already 1D.\\nassume_unique : bool\\n    If True, the input arrays are both assumed to be unique, which\\n    can speed up the calculation.  If True but \\`\\`ar1\\`\\` or \\`\\`ar2\\`\\` are not\\n    unique, incorrect results and out-of-bounds indices could result.\\n    Default is False.\\nreturn_indices : bool\\n    If True, the indices which correspond to the intersection of the two\\n    arrays are returned. The first instance of a value is used if there are\\n    multiple. Default is False.\\n\\n    .. versionadded:: 1.15.0\\n\\nReturns\\n-------\\nintersect1d : ndarray\\n    Sorted 1D array of common and unique elements.\\ncomm1 : ndarray\\n    The indices of the first occurrences of the common values in \\`ar1\\`.\\n    Only provided if \\`return_indices\\` is True.\\ncomm2 : ndarray\\n    The indices of the first occurrences of the common values in \\`ar2\\`.\\n    Only provided if \\`return_indices\\` is True.\",\n}\n-/\n\n/-  Find the intersection of two arrays.\n    Returns the sorted, unique values that are in both input arrays. -/\n\n/-  Specification: intersect1d returns a sorted array of unique values \n    that exist in both input arrays -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def intersect1d {n m k : Nat} (ar1 : Vector Int n) (ar2 : Vector Int m) : Id (Vector Int k) :=\n  sorry", "vc-theorems": "theorem intersect1d_spec {n m k : Nat} (ar1 : Vector Int n) (ar2 : Vector Int m) :\n    \u2983\u231cTrue\u231d\u2984\n    intersect1d ar1 ar2\n    \u2983\u21d3result => \u231c\n      -- Result contains only values that exist in both arrays\n      (\u2200 i : Fin k, \u2203 j : Fin n, \u2203 l : Fin m, \n        result.get i = ar1.get j \u2227 result.get i = ar2.get l) \u2227\n      -- Result is sorted in ascending order\n      (\u2200 i j : Fin k, i < j \u2192 result.get i \u2264 result.get j) \u2227\n      -- Result contains unique values (no duplicates)\n      (\u2200 i j : Fin k, i \u2260 j \u2192 result.get i \u2260 result.get j) \u2227\n      -- Result is complete (contains all common values)\n      (\u2200 val : Int, (\u2203 i : Fin n, ar1.get i = val) \u2227 (\u2203 j : Fin m, ar2.get j = val) \u2192\n        \u2203 l : Fin k, result.get l = val)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_isin", "vc-description": "/-  numpy.isin: Element-wise test for membership in another array.\n\n    Calculates `element in test_elements`, broadcasting over `element` only.\n    Returns a boolean array of the same shape as `element` that is True\n    where an element of `element` is in `test_elements` and False otherwise.\n\n    This is an element-wise function version of the python keyword `in`.\n    For 1-D arrays, this is roughly equivalent to:\n    `np.array([item in test_elements for item in element])`\n-/\n\n/-  Specification: numpy.isin returns a boolean vector where each element indicates\n    whether the corresponding element in the input vector is found in test_elements.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: For all indices i, result[i] = true iff element[i] is in test_elements\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_isin {n m : Nat} (element : Vector Float n) (test_elements : Vector Float m) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem numpy_isin_spec {n m : Nat} (element : Vector Float n) (test_elements : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_isin element test_elements\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = true \u2194 \u2203 j : Fin m, element.get i = test_elements.get j\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_setdiff1d", "vc-description": "/- \n{\n  \"name\": \"numpy.setdiff1d\",\n  \"category\": \"Set operations\",\n  \"description\": \"Find the set difference of two arrays\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.setdiff1d.html\",\n  \"doc\": \"Find the set difference of two arrays.\\n\\nReturn the unique values in `ar1` that are not in `ar2`.\\n\\nParameters\\n----------\\nar1 : array_like\\n    Input array.\\nar2 : array_like\\n    Input comparison array.\\nassume_unique : bool\\n    If True, the input arrays are both assumed to be unique, which\\n    can speed up the calculation.  Default is False.\\n\\nReturns\\n-------\\nsetdiff1d : ndarray\\n    1D array of values in `ar1` that are not in `ar2`. The result\\n    is sorted when `assume_unique=False`, but otherwise only sorted\\n    if the input is sorted.\",\n}\n-/\n\n/-  Find the set difference of two arrays.\n    Return the unique values in `ar1` that are not in `ar2`. -/\n\n/-  Specification: setdiff1d returns unique values from ar1 that are not in ar2.\n    The result contains no duplicates and is sorted. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def setdiff1d {n m k : Nat} (ar1 : Vector Int n) (ar2 : Vector Int m) : Id (Vector Int k) :=\n  sorry", "vc-theorems": "theorem setdiff1d_spec {n m k : Nat} (ar1 : Vector Int n) (ar2 : Vector Int m) :\n    \u2983\u231cTrue\u231d\u2984\n    setdiff1d ar1 ar2\n    \u2983\u21d3result => \u231c-- Each element in result is from ar1 and not in ar2\n                 (\u2200 i : Fin k, \u2203 j : Fin n, result.get i = ar1.get j \u2227 \n                  \u2200 l : Fin m, result.get i \u2260 ar2.get l) \u2227\n                 -- No duplicates in result\n                 (\u2200 i j : Fin k, i \u2260 j \u2192 result.get i \u2260 result.get j) \u2227\n                 -- Result is sorted\n                 (\u2200 i j : Fin k, i < j \u2192 result.get i \u2264 result.get j) \u2227\n                 -- All unique values from ar1 not in ar2 are included\n                 (\u2200 val : Int, (\u2203 i : Fin n, ar1.get i = val \u2227 \u2200 j : Fin m, ar2.get j \u2260 val) \u2192\n                  \u2203 i : Fin k, result.get i = val)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_setxor1d", "vc-description": "/-  numpy.setxor1d: Find the set exclusive-or of two arrays.\n\n    Return the sorted, unique values that are in only one (not both) of the\n    input arrays. This is equivalent to the symmetric difference of two sets.\n\n    The result contains elements that appear in ar1 but not in ar2, or in ar2 \n    but not in ar1, sorted in ascending order.\n-/\n\n/-  Specification: numpy.setxor1d returns the symmetric difference of two arrays.\n\n    Precondition: True (no special preconditions)\n    Postcondition: \n    1. The result contains only elements that appear in exactly one of the input arrays\n    2. The result is sorted in ascending order\n    3. The result contains no duplicates\n    4. Every element in the result comes from either ar1 or ar2 (but not both)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_setxor1d {n m k : Nat} (ar1 : Vector Float n) (ar2 : Vector Float m) : Id (Vector Float k) :=\n  sorry", "vc-theorems": "theorem numpy_setxor1d_spec {n m k : Nat} (ar1 : Vector Float n) (ar2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_setxor1d ar1 ar2\n    \u2983\u21d3result => \u231c\n      -- Result is sorted\n      (\u2200 i j : Fin k, i < j \u2192 result.get i \u2264 result.get j) \u2227\n      -- Result has no duplicates\n      (\u2200 i j : Fin k, i \u2260 j \u2192 result.get i \u2260 result.get j) \u2227\n      -- Every element in result is from exactly one input array\n      (\u2200 i : Fin k, \n        (\u2203 j : Fin n, ar1.get j = result.get i \u2227 \u00ac\u2203 l : Fin m, ar2.get l = result.get i) \u2228\n        (\u2203 j : Fin m, ar2.get j = result.get i \u2227 \u00ac\u2203 l : Fin n, ar1.get l = result.get i)) \u2227\n      -- Every element that appears in exactly one input array is in the result\n      (\u2200 x : Float, \n        ((\u2203 i : Fin n, ar1.get i = x \u2227 \u00ac\u2203 j : Fin m, ar2.get j = x) \u2228\n         (\u2203 i : Fin m, ar2.get i = x \u2227 \u00ac\u2203 j : Fin n, ar1.get j = x)) \u2192\n        \u2203 i : Fin k, result.get i = x)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_union1d", "vc-description": "/-  numpy.union1d: Find the union of two arrays.\n\n    Returns the unique, sorted array of values that are in either of the two\n    input arrays. The function is equivalent to unique(concatenate(ar1, ar2)).\n\n    The input arrays are flattened if they are not already 1D, and the result\n    is always a 1D array containing the union of all elements from both arrays,\n    with duplicates removed and elements sorted in ascending order.\n-/\n\n/-  Specification: numpy.union1d returns the sorted union of two arrays.\n\n    Precondition: True (no special preconditions needed)\n    Postcondition: The result contains:\n    1. All elements from ar1 and ar2 (union property)\n    2. Elements are sorted in ascending order  \n    3. No duplicate elements (uniqueness property)\n    4. Every element in the result comes from one of the input arrays\n    5. Every element from input arrays appears in the result\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def union1d {n m : Nat} (ar1 : Vector Float n) (ar2 : Vector Float m) : Id (Vector Float (n + m)) :=\n  sorry", "vc-theorems": "theorem union1d_spec {n m : Nat} (ar1 : Vector Float n) (ar2 : Vector Float m) :\n    \u2983\u231cTrue\u231d\u2984\n    union1d ar1 ar2\n    \u2983\u21d3result => \u231c\n      -- Union property: every element from either input array is in result\n      (\u2200 i : Fin n, \u2203 j : Fin (n + m), result.get j = ar1.get i) \u2227\n      (\u2200 i : Fin m, \u2203 j : Fin (n + m), result.get j = ar2.get i) \u2227\n      -- Completeness: every element in result comes from one of the input arrays\n      (\u2200 j : Fin (n + m), \n        (\u2203 i : Fin n, result.get j = ar1.get i) \u2228 \n        (\u2203 i : Fin m, result.get j = ar2.get i)) \u2227\n      -- Sorted property: result is sorted in ascending order\n      (\u2200 i j : Fin (n + m), i < j \u2192 result.get i \u2264 result.get j) \u2227\n      -- Uniqueness property: no duplicate elements\n      (\u2200 i j : Fin (n + m), i \u2260 j \u2192 result.get i \u2260 result.get j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "set_operations_unique", "vc-description": "/- \n{\n  \"name\": \"numpy.unique\",\n  \"category\": \"Unique operations\",\n  \"description\": \"Find the unique elements of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.unique.html\",\n  \"doc\": \"Find the unique elements of an array.\\n\\nReturns the sorted unique elements of an array. There are three optional\\noutputs in addition to the unique elements:\\n\\n* the indices of the input array that give the unique values\\n* the indices of the unique array that reconstruct the input array\\n* the number of times each unique value comes up in the input array\\n\\nParameters\\n----------\\nar : array_like\\n    Input array. Unless `axis` is specified, this will be flattened if it\\n    is not already 1-D.\\nreturn_index : bool, optional\\n    If True, also return the indices of `ar` (along the specified axis,\\n    if provided, or in the flattened array) that result in the unique array.\\nreturn_inverse : bool, optional\\n    If True, also return the indices of the unique array (for the specified\\n    axis, if provided) that can be used to reconstruct `ar`.\\nreturn_counts : bool, optional\\n    If True, also return the number of times each unique item appears\\n    in `ar`.\\naxis : int or None, optional\\n    The axis to operate on. If None, `ar` will be flattened. If an integer,\\n    the subarrays indexed by the given axis will be flattened and treated\\n    as the elements of a 1-D array with the dimension of the given axis,\\n    see the notes for more details.  Object arrays or structured arrays\\n    that contain objects are not supported if the `axis` kwarg is used. The\\n    default is None.\\n\\n    .. versionadded:: 1.13.0\\n\\nequal_nan : bool, optional\\n    If True, collapses multiple NaN values in the return array into one.\\n\\n    .. versionadded:: 1.24\\n\\nReturns\\n-------\\nunique : ndarray\\n    The sorted unique values.\\nunique_indices : ndarray, optional\\n    The indices of the first occurrences of the unique values in the\\n    original array. Only provided if `return_index` is True.\\nunique_inverse : ndarray, optional\\n    The indices to reconstruct the original array from the\\n    unique array. Only provided if `return_inverse` is True.\\nunique_counts : ndarray, optional\\n    The number of times each of the unique values comes up in the\\n    original array. Only provided if `return_counts` is True.\\n\\n    .. versionadded:: 1.9.0\",\n}\n-/\n\n/-  Find the unique elements of a vector and return them in sorted order -/\n\n/-  Specification: unique returns sorted unique elements from the input vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def unique {n : Nat} (arr : Vector Int n) : Id (List Int) :=\n  sorry", "vc-theorems": "theorem unique_spec {n : Nat} (arr : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    unique arr\n    \u2983\u21d3result => \u231c(\u2200 i j : Nat, i < j \u2192 j < result.length \u2192 result[i]? < result[j]?) \u2227 \n                  (\u2200 i : Nat, i < result.length \u2192 \u2203 j : Fin n, result[i]? = some (arr.get j)) \u2227\n                  (\u2200 i j : Nat, i < result.length \u2192 j < result.length \u2192 i \u2260 j \u2192 result[i]? \u2260 result[j]?) \u2227\n                  (\u2200 i : Fin n, \u2203 j : Nat, j < result.length \u2227 some (arr.get i) = result[j]?)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_argmax", "vc-description": "/-  numpy.argmax: Returns the index of the maximum value in a vector.\n\n    Returns the index of the maximum value among all elements in the array.\n    Requires a non-empty array since there is no maximum of an empty set.\n\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    This function returns the position of the largest element in the array.\n-/\n\n/-  Specification: numpy.argmax returns the index of the maximum element.\n\n    Precondition: True (non-empty constraint is in the type)\n    Postcondition: The element at the returned index is the maximum value,\n    and it is the first occurrence of such maximum value.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argmax {n : Nat} (a : Vector Float (n + 1)) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem argmax_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    argmax a\n    \u2983\u21d3i => \u231c(\u2200 j : Fin (n + 1), a.get j \u2264 a.get i) \u2227 \n            (\u2200 j : Fin (n + 1), a.get j = a.get i \u2192 i \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_argmin", "vc-description": "/- \n{\n  \"name\": \"numpy.argmin\",\n  \"category\": \"Searching\",\n  \"description\": \"Returns the indices of the minimum values along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argmin.html\",\n  \"doc\": \"Returns the indices of the minimum values along an axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\naxis : int, optional\\n    By default, the index is into the flattened array, otherwise\\n    along the specified axis.\\nout : array, optional\\n    If provided, the result will be inserted into this array. It should\\n    be of the appropriate shape and dtype.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left\\n    in the result as dimensions with size one. With this option,\\n    the result will broadcast correctly against the input array.\\n\\n    If the default value is passed, then \\`keepdims\\` will not be\\n    passed through to the \\`argmin\\` method of sub-classes of\\n    \\`ndarray\\`, however any non-default value will be. If the\\n    sub-class' method does not implement \\`keepdims\\` any\\n    exceptions will be raised.\\n\\nReturns\\n-------\\nindex_array : ndarray of ints\\n    Array of indices into the array. It has the same shape as \\`a.shape\\`\\n    with the dimension along \\`axis\\` removed. If \\`keepdims\\` is set to True,\\n    then the size of \\`axis\\` will be 1 with the resulting array having same\\n    shape as \\`a.shape\\`.\",\n}\n-/\n\n/-  numpy.argmin: Returns the index of the minimum value.\n\n    Returns the index of the minimum value among all elements in the array.\n    Requires a non-empty array since there is no minimum of an empty set.\n\n    This function returns the position of the smallest element in the array.\n    In case of multiple occurrences of the minimum values, the indices\n    corresponding to the first occurrence are returned.\n-/\n\n/-  Specification: numpy.argmin returns the index of the minimum element.\n\n    Precondition: True (non-empty constraint is in the type)\n    Postcondition: The element at the returned index is the minimum value,\n    and for ties, it returns the first occurrence.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_argmin {n : Nat} (a : Vector Float (n + 1)) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem numpy_argmin_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_argmin a\n    \u2983\u21d3i => \u231c(\u2200 j : Fin (n + 1), a.get i \u2264 a.get j) \u2227 \n             (\u2200 j : Fin (n + 1), a.get j = a.get i \u2192 i \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_argpartition", "vc-description": "/-  Perform an indirect partition along the given axis.\n    Returns an array of indices that partition the input array such that\n    the kth element is in its final sorted position and all smaller\n    elements are moved before it and all larger elements behind it. -/\n\n/-  Specification: argpartition returns indices that correctly partition the array.\n    The kth element is in its final sorted position, with all smaller elements\n    before it and all larger elements after it. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argpartition {n : Nat} (a : Vector Float n) (kth : Fin n) : Id (Vector (Fin n) n) :=\n  sorry", "vc-theorems": "theorem argpartition_spec {n : Nat} (a : Vector Float n) (kth : Fin n) :\n    \u2983\u231cTrue\u231d\u2984\n    argpartition a kth\n    \u2983\u21d3indices => \u231c\n      -- The indices form a valid permutation of 0..n-1\n      (\u2200 i : Fin n, \u2203 j : Fin n, indices.get j = i) \u2227\n      (\u2200 i j : Fin n, i \u2260 j \u2192 indices.get i \u2260 indices.get j) \u2227\n      -- Partition property: all elements before kth position are \u2264 kth element\n      (\u2200 i : Fin n, i < kth \u2192 a.get (indices.get i) \u2264 a.get (indices.get kth)) \u2227\n      -- Partition property: all elements after kth position are \u2265 kth element\n      (\u2200 i : Fin n, kth < i \u2192 a.get (indices.get kth) \u2264 a.get (indices.get i))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_argsort", "vc-description": "/- \n{\n  \"name\": \"numpy.argsort\",\n  \"category\": \"Sorting\",\n  \"description\": \"Returns the indices that would sort an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argsort.html\",\n  \"doc\": \"Returns the indices that would sort an array.\\n\\nPerform an indirect sort along the given axis using the algorithm specified\\nby the \\`kind\\` keyword. It returns an array of indices of the same shape as\\n\\`a\\` that index data along the given axis in sorted order.\\n\\nParameters\\n----------\\na : array_like\\n    Array to sort.\\naxis : int or None, optional\\n    Axis along which to sort. The default is -1 (the last axis). If None,\\n    the flattened array is used.\\nkind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\\n    Sorting algorithm. The default is 'quicksort'.\\norder : str or list of str, optional\\n    When \\`a\\` is an array with fields defined, this argument specifies\\n    which fields to compare first, second, etc.\\nstable : bool, optional\\n    Sort stability. If \\`\\`True\\`\\`, the returned array will maintain\\n    the relative order of \\`\\`a\\`\\` values which compare as equal.\\n\\nReturns\\n-------\\nindex_array : ndarray, int\\n    Array of indices that sort \\`a\\` along the specified \\`axis\\`.\\n    If \\`a\\` is one-dimensional, \\`\\`a[index_array]\\`\\` yields a sorted \\`a\\`.\\n    More generally, \\`\\`take_along_axis(a, index_array, axis=axis)\\`\\`\\n    always yields the sorted \\`a\\`, irrespective of dimensionality.\",\n}\n-/\n\n/-  Returns the indices that would sort a vector in ascending order -/\n\n/-  Specification: argsort returns indices that sort the input array -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def argsort {n : Nat} (a : Vector Float n) : Id (Vector (Fin n) n) :=\n  sorry", "vc-theorems": "theorem argsort_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    argsort a\n    \u2983\u21d3indices => \u231c-- The result is a permutation of all indices\n                   (\u2200 i : Fin n, \u2203 j : Fin n, indices.get j = i) \u2227\n                   (\u2200 i j : Fin n, indices.get i = indices.get j \u2192 i = j) \u2227\n                   -- The indices produce a sorted sequence\n                   (\u2200 i j : Fin n, i < j \u2192 a.get (indices.get i) \u2264 a.get (indices.get j)) \u2227\n                   -- For equal elements, maintain relative order (stable sort)\n                   (\u2200 i j : Fin n, i < j \u2192 a.get (indices.get i) = a.get (indices.get j) \u2192 indices.get i < indices.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_argwhere", "vc-description": "/- \n{\n  \"name\": \"numpy.argwhere\",\n  \"category\": \"Searching\",\n  \"description\": \"Find the indices of array elements that are non-zero, grouped by element\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.argwhere.html\",\n  \"doc\": \"Find the indices of array elements that are non-zero, grouped by element.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\n\\nReturns\\n-------\\nindex_array : (N, a.ndim) ndarray\\n    Indices of elements that are non-zero. Indices are grouped by element.\\n    This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\\n    non-zero items.\\n\\nSee Also\\n--------\\nwhere, nonzero\\n\\nNotes\\n-----\\n``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\\nbut produces a result of the correct shape for a 0D array.\\n\\nThe output of ``argwhere`` is not suitable for indexing arrays.\\nFor this purpose use ``nonzero(a)`` instead.\",\n}\n-/\n\n/-  numpy.argwhere: Find the indices of array elements that are non-zero, grouped by element.\n\n    For a 1D vector, returns a list of indices where elements are non-zero.\n    Each index corresponds to a position in the original vector where the element is non-zero.\n    The returned indices are in the same order as they appear in the original vector.\n-/\n\n/-  Specification: numpy.argwhere returns all indices of non-zero elements.\n\n    Precondition: True (no special requirements)\n    Postcondition: \n    1. All returned indices correspond to non-zero elements in the input vector\n    2. All non-zero elements in the input vector have their indices in the result\n    3. The result contains no duplicate indices\n    4. The indices are ordered according to their position in the original vector\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_argwhere {n : Nat} (a : Vector Float n) : Id (List (Fin n)) :=\n  sorry", "vc-theorems": "theorem numpy_argwhere_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_argwhere a\n    \u2983\u21d3indices => \u231c\n      (\u2200 i \u2208 indices, a.get i \u2260 0) \u2227\n      (\u2200 i : Fin n, a.get i \u2260 0 \u2192 i \u2208 indices) \u2227\n      (indices.Nodup) \u2227\n      (\u2200 i j : Fin n, i \u2208 indices \u2192 j \u2208 indices \u2192 i < j \u2192 \n        indices.idxOf i < indices.idxOf j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_bincount", "vc-description": "/-  numpy.bincount: Count number of occurrences of each value in array of non-negative ints.\n\n    Count number of occurrences of each value in array of non-negative ints.\n    The number of bins (of size 1) is one larger than the largest value in x.\n    Each bin gives the number of occurrences of its index value in x.\n\n    This function takes a 1D array of non-negative integers and returns\n    an array where the i-th element is the count of how many times the\n    value i appears in the input array.\n-/\n\n/-  Specification: numpy.bincount returns count of occurrences of each value.\n\n    Precondition: All values in x are non-negative and \u2264 max_val\n    Postcondition: result[i] = count of occurrences of value i in x\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_bincount {n : Nat} (x : Vector Nat n) (max_val : Nat) \n    (h_bounds : \u2200 i : Fin n, x.get i \u2264 max_val) : Id (Vector Nat (max_val + 1)) :=\n  sorry", "vc-theorems": "theorem numpy_bincount_spec {n : Nat} (x : Vector Nat n) (max_val : Nat) \n    (h_bounds : \u2200 i : Fin n, x.get i \u2264 max_val) :\n    \u2983\u231c\u2200 i : Fin n, x.get i \u2264 max_val\u231d\u2984\n    numpy_bincount x max_val h_bounds\n    \u2983\u21d3result => \u231c\u2200 val : Fin (max_val + 1), \n                   result.get val = (x.toList.filter (\u00b7 = val.val)).length\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_count_nonzero", "vc-description": "/-  Counts the number of non-zero values in a vector.\n\n    The word \"non-zero\" is in reference to the Python 2.x\n    built-in method `__nonzero__()` (renamed `__bool__()`\n    in Python 3.x) of Python objects that tests an object's\n    \"truthfulness\". For example, any number is considered\n    truthful if it is nonzero, whereas any string is considered\n    truthful if it is not the empty string. Thus, this function\n    counts how many elements in the vector are non-zero. -/\n\n/-  Specification: count_nonzero returns the number of non-zero elements in the vector.\n\n    The function counts exactly those elements that are not equal to zero.\n    The result is always between 0 and n (inclusive), where n is the length of the vector.\n    If all elements are zero, the result is 0.\n    If all elements are non-zero, the result is n. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def count_nonzero {n : Nat} (a : Vector Int n) : Id Nat :=\n  sorry", "vc-theorems": "theorem count_nonzero_spec {n : Nat} (a : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    count_nonzero a\n    \u2983\u21d3count => \u231ccount \u2264 n \u2227 \n                (n = 0 \u2192 count = 0) \u2227\n                (\u2200 i : Fin n, a.get i = 0) \u2192 count = 0 \u2227\n                (\u2200 i : Fin n, a.get i \u2260 0) \u2192 count = n \u2227\n                (\u2203 i : Fin n, a.get i \u2260 0) \u2192 count > 0 \u2227\n                (\u2203 i : Fin n, a.get i = 0) \u2192 count < n\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_extract", "vc-description": "/- \n{\n  \"name\": \"numpy.extract\",\n  \"category\": \"Searching\",\n  \"description\": \"Return the elements of an array that satisfy some condition\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.extract.html\",\n  \"doc\": \"Return the elements of an array that satisfy some condition.\\n\\nThis is equivalent to \\`\\`np.compress(ravel(condition), ravel(arr))\\`\\`. If\\n\\`condition\\` is boolean \\`\\`np.extract\\`\\` is equivalent to \\`\\`arr[condition]\\`\\`.\\n\\nNote that \\`place\\` does the exact opposite of \\`extract\\`.\\n\\nParameters\\n----------\\ncondition : array_like\\n    An array whose nonzero or True entries indicate the elements of \\`arr\\`\\n    to extract.\\narr : array_like\\n    Input array of the same size as \\`condition\\`.\\n\\nReturns\\n-------\\nextract : ndarray\\n    Rank 1 array of values from \\`arr\\` where \\`condition\\` is True.\\n\\nSee Also\\n--------\\ntake, put, copyto, compress, place\",\n}\n-/\n\n/-  Return the elements of an array that satisfy some condition.\n    The result size is the number of True entries in the condition array. -/\n\n/-  Specification: extract returns elements from arr where condition is True.\n    The result contains exactly those elements from arr at positions where condition is True,\n    preserving their original order. The result size m equals the number of True values in condition. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def extract {n m : Nat} (condition : Vector Bool n) (arr : Vector Int n) : \n  Id (Vector Int m) :=\n  sorry", "vc-theorems": "theorem extract_spec {n m : Nat} (condition : Vector Bool n) (arr : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    extract condition arr\n    \u2983\u21d3result => \u231c-- Each element in result comes from arr at a position where condition is true\n      (\u2200 (k : Fin m), \u2203 (i : Fin n), condition.get i = true \u2227 result.get k = arr.get i) \u2227\n      -- The order is preserved: elements appear in the same relative order as in arr\n      (\u2200 (k\u2081 k\u2082 : Fin m), k\u2081 < k\u2082 \u2192 \n        \u2203 (i\u2081 i\u2082 : Fin n), condition.get i\u2081 = true \u2227 condition.get i\u2082 = true \u2227\n        result.get k\u2081 = arr.get i\u2081 \u2227 result.get k\u2082 = arr.get i\u2082 \u2227 i\u2081 < i\u2082) \u2227\n      -- Every True position in condition contributes exactly one element to the result  \n      (\u2200 (i : Fin n), condition.get i = true \u2192 \n        \u2203 (k : Fin m), result.get k = arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_flatnonzero", "vc-description": "/-  numpy.flatnonzero: Return indices that are non-zero in the flattened version of a.\n\n    This function returns the indices of all non-zero elements in the array.\n    The returned indices correspond to positions in the flattened array where\n    the elements are non-zero.\n\n    For example, if array is [1, 0, 3, 0, 5], the function returns [0, 2, 4]\n    indicating that elements at positions 0, 2, and 4 are non-zero.\n-/\n\n/-  Specification: flatnonzero returns indices of all non-zero elements.\n\n    Precondition: True (no restrictions on input array)\n    Postcondition: \n    1. All returned indices correspond to non-zero elements in the original array\n    2. All non-zero elements in the original array have their indices in the result\n    3. The result contains no duplicate indices\n    4. The result indices are sorted in ascending order\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def flatnonzero {n : Nat} (a : Vector Float n) : Id (List (Fin n)) :=\n  sorry", "vc-theorems": "theorem flatnonzero_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    flatnonzero a\n    \u2983\u21d3result => \u231c\n      -- All indices in result point to non-zero elements\n      (\u2200 i \u2208 result, a.get i \u2260 0) \u2227\n      -- All non-zero elements have their indices in result\n      (\u2200 j : Fin n, a.get j \u2260 0 \u2192 j \u2208 result) \u2227\n      -- Result contains no duplicate indices\n      (result.Nodup) \u2227\n      -- Result indices are sorted in ascending order\n      (\u2200 i j : Fin n, i \u2208 result \u2192 j \u2208 result \u2192 i < j \u2192 \n        result.idxOf i < result.idxOf j)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_lexsort", "vc-description": "/- \n{\n  \"name\": \"numpy.lexsort\",\n  \"category\": \"Sorting\",\n  \"description\": \"Perform an indirect stable sort using a sequence of keys\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html\",\n  \"doc\": \"Perform an indirect stable sort using a sequence of keys.\\n\\nGiven multiple sorting keys, which can be interpreted as columns in a\\nspreadsheet, lexsort returns an array of integer indices that describes\\nthe sort order by multiple columns. The last key in the sequence is used\\nfor the primary sort order, ties are broken by the second-to-last key,\\nand so on.\\n\\nParameters\\n----------\\nkeys : (k, N) array or tuple containing k (N,)-shaped sequences\\n    The \\`k\\` different \\\"columns\\\" to be sorted. The last column (or row if\\n    \\`keys\\` is a 2D array) is the primary sort key.\\naxis : int, optional\\n    Axis to be indirectly sorted. By default, sort over the last axis.\\n\\nReturns\\n-------\\nindices : (N,) ndarray of ints\\n    Array of indices that sort the keys along the specified axis.\\n\\nNote\\n----\\nThe Numpy lexsort function treats keys as column vectors and sorts by the last key\\n(primary key) first. This can be counterintuitive coming from other languages.\",\n}\n-/\n\n/-  Perform an indirect stable sort using a sequence of keys.\n    Given multiple sorting keys, lexsort returns an array of integer indices that \n    describes the sort order by multiple columns. The last key in the sequence is used\n    for the primary sort order, ties are broken by the second-to-last key, and so on. -/\n\n/-  Specification: lexsort returns indices that lexicographically sort the keys.\n    The result is a permutation of indices where for any two positions i, j:\n    - If primary key differs, sort by primary key\n    - If primary key is equal, sort by second-to-last key, etc.\n    - The sort is stable (preserves relative order of equal elements) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lexsort {n k : Nat} (keys : Vector (Vector Float n) k) (h : k > 0) : Id (Vector (Fin n) n) :=\n  sorry", "vc-theorems": "theorem lexsort_spec {n k : Nat} (keys : Vector (Vector Float n) k) (h : k > 0) :\n    \u2983\u231ck > 0\u231d\u2984\n    lexsort keys h\n    \u2983\u21d3indices => \u231c\n      -- indices is a permutation of 0..n-1\n      (\u2200 i : Fin n, \u2203 j : Fin n, indices.get j = i) \u2227\n      (\u2200 i j : Fin n, indices.get i = indices.get j \u2192 i = j) \u2227\n      -- lexicographic ordering property\n      (\u2200 i j : Fin n, i < j \u2192 \n        \u2203 key_idx : Fin k, \n          -- All keys from key_idx+1 to k-1 are equal\n          (\u2200 l : Fin k, key_idx < l \u2192 \n            (keys.get l).get (indices.get i) = (keys.get l).get (indices.get j)) \u2227\n          -- Key at key_idx determines the order\n          (keys.get key_idx).get (indices.get i) \u2264 (keys.get key_idx).get (indices.get j)) \u2227\n      -- stability property: if all keys are equal, preserve original order\n      (\u2200 i j : Fin n, i < j \u2192 \n        (\u2200 l : Fin k, (keys.get l).get i = (keys.get l).get j) \u2192 \n        \u2203 p q : Fin n, indices.get p = i \u2227 indices.get q = j \u2227 p < q)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_msort", "vc-description": "/- \n{\n  \"name\": \"numpy.msort\",\n  \"category\": \"Sorting\",\n  \"description\": \"Return a copy of an array sorted along the first axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.msort.html\",\n  \"doc\": \"Return a copy of an array sorted along the first axis.\\n\\n.. deprecated:: 1.24.0\\n    msort is deprecated, use \\`\\`np.sort(a, axis=0)\\`\\` instead.\\n\\nParameters\\n----------\\na : array_like\\n    Array to be sorted.\\n\\nReturns\\n-------\\nsorted_array : ndarray\\n    Array of the same type and shape as \\`a\\`.\\n\\nSee Also\\n--------\\nsort\\n\\nNotes\\n-----\\n\\`\\`np.msort(a)\\`\\` is equivalent to \\`\\`np.sort(a, axis=0)\\`\\`.\",\n}\n-/\n\n/-  Return a copy of an array sorted along the first axis (ascending order).\n    This is equivalent to np.sort(a, axis=0) in NumPy. -/\n\n/-  Specification: msort returns a sorted copy of the input array in ascending order.\n    The result is a permutation of the input array. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def msort {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem msort_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    msort a\n    \u2983\u21d3result => \u231c\n      -- The result is sorted in ascending order\n      (\u2200 i j : Fin n, i.val < j.val \u2192 result.get i \u2264 result.get j) \u2227\n      -- The result is a permutation of the input (same multiset of elements)\n      (\u2200 x : Float, (a.toList.count x) = (result.toList.count x))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_nanargmax", "vc-description": "/- \n{\n  \"name\": \"numpy.nanargmax\",\n  \"category\": \"Searching\",\n  \"description\": \"Return the indices of the maximum values in the specified axis ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanargmax.html\",\n  \"doc\": \"Return the indices of the maximum values in the specified axis ignoring\\nNaNs. For all-NaN slices \\`\\`ValueError\\`\\` is raised. Warning: the results\\ncannot be trusted if a slice contains only NaNs and -Infs.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : int, optional\\n    Axis along which to operate. By default flattened input is used.\\nout : array, optional\\n    If provided, the result will be inserted into this array. It should\\n    be of the appropriate shape and dtype.\\n\\n    .. versionadded:: 1.22.0\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left\\n    in the result as dimensions with size one. With this option,\\n    the result will broadcast correctly against the array.\\n\\n    .. versionadded:: 1.22.0\\n\\nReturns\\n-------\\nindex_array : ndarray\\n    An array of indices or a single index value.\",\n}\n-/\n\n/-  numpy.nanargmax: Returns the index of the maximum value in a vector, ignoring NaN values.\n\n    Returns the index of the maximum value among all non-NaN elements in the array.\n    Requires that at least one element is not NaN, otherwise it would raise an error.\n\n    In case of multiple occurrences of the maximum values, the indices\n    corresponding to the first occurrence are returned.\n\n    This function returns the position of the largest non-NaN element in the array.\n-/\n\n/-  Specification: numpy.nanargmax returns the index of the maximum non-NaN element.\n\n    Precondition: At least one element is not NaN\n    Postcondition: The element at the returned index is not NaN, is the maximum \n    among all non-NaN values, and is the first occurrence of such maximum value.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanargmax {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem nanargmax_spec {n : Nat} (a : Vector Float (n + 1)) (h_not_all_nan : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) :\n    \u2983\u231c\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN\u231d\u2984\n    nanargmax a h_not_all_nan\n    \u2983\u21d3idx => \u231c\u00ac(a.get idx).isNaN \u2227 \n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 a.get idx) \u2227\n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j = a.get idx \u2192 idx \u2264 j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_nanargmin", "vc-description": "/-  numpy.nanargmin: Return the indices of the minimum values in the specified axis ignoring NaNs.\n\n    For all-NaN slices ValueError is raised. Warning: the results cannot be trusted \n    if a slice contains only NaNs and Infs.\n\n    This function finds the index of the minimum value in a vector, ignoring NaN values.\n    If all values are NaN, it should raise an error (represented as a precondition).\n\n    Parameters:\n    - a : Vector Float n - Input data vector\n\n    Returns:\n    - Fin n - Index of the minimum non-NaN value\n-/\n\n/-  Specification: nanargmin returns the index of the minimum non-NaN value.\n\n    Precondition: At least one element in the vector is not NaN\n    Postcondition: \n    1. The returned index points to a non-NaN value\n    2. All non-NaN values at other indices are greater than or equal to the value at the returned index\n    3. If there are ties, returns the first occurrence (smallest index)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanargmin {n : Nat} (a : Vector Float (n + 1)) (h_has_valid : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) : Id (Fin (n + 1)) :=\n  sorry", "vc-theorems": "theorem nanargmin_spec {n : Nat} (a : Vector Float (n + 1)) (h_has_valid : \u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) :\n    \u2983\u231c\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN\u231d\u2984\n    nanargmin a h_has_valid\n    \u2983\u21d3idx => \u231c\u00ac(a.get idx).isNaN \u2227 \n             (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get idx \u2264 a.get j) \u2227\n             (\u2200 j : Fin (n + 1), j < idx \u2192 (a.get j).isNaN \u2228 a.get j > a.get idx)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_nonzero", "vc-description": "/-  numpy.nonzero: Return the indices of the elements that are non-zero.\n\n    Returns a vector of indices where the corresponding elements in the input\n    array are non-zero. The indices are returned in row-major, C-style order.\n\n    For a 1D array, this returns a vector containing all indices i such that\n    a[i] \u2260 0. Since the output size depends on the input values, we use\n    a List structure to accommodate the dynamic nature of the result.\n\n    Note: In the full NumPy implementation, this returns a tuple of arrays\n    (one for each dimension), but for 1D arrays we simplify to a single list.\n-/\n\n/-  Specification: numpy.nonzero returns indices of all non-zero elements.\n\n    Precondition: True (no constraints on input)\n    Postcondition: \n    1. Every index in the result corresponds to a non-zero element in the input\n    2. Every non-zero element in the input has its index in the result (completeness)\n    3. The indices are in ascending order (preserving array order)\n    4. No duplicates in the result\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nonzero {n : Nat} (a : Vector Float n) : Id (List (Fin n)) :=\n  sorry", "vc-theorems": "theorem nonzero_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nonzero a\n    \u2983\u21d3indices => \u231c(\u2200 i \u2208 indices, a.get i \u2260 0) \u2227\n                   (\u2200 j : Fin n, a.get j \u2260 0 \u2192 j \u2208 indices) \u2227\n                   (\u2200 i\u2081 i\u2082 : Fin n, i\u2081 \u2208 indices \u2192 i\u2082 \u2208 indices \u2192 i\u2081 < i\u2082 \u2192 \n                    (indices.idxOf i\u2081 < indices.idxOf i\u2082)) \u2227\n                   (indices.Nodup)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_partition", "vc-description": "/- \n{\n  \"name\": \"numpy.partition\",\n  \"category\": \"Sorting\", \n  \"description\": \"Return a partitioned copy of an array\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.partition.html\",\n  \"doc\": \"Return a partitioned copy of an array.\\n\\nCreates a copy of the array with its elements rearranged in such a way that\\nthe value of the element in k-th position is in the position it would be in\\na sorted array. All elements smaller than the k-th element are moved before\\nthis element and all equal or greater are moved behind it. The ordering of\\nthe elements in the two partitions is undefined.\\n\\nParameters\\n----------\\na : array_like\\n    Array to be sorted.\\nkth : int or sequence of ints\\n    Element index to partition by. The k-th value of the element will be in\\n    its final sorted position and all smaller elements will be moved before it\\n    and all equal or greater elements behind it. The order of all elements in\\n    the partitions is undefined. If provided with a sequence of k-th it will\\n    partition all elements indexed by k-th of them into their sorted position\\n    at once.\\naxis : int or None, optional\\n    Axis along which to sort. If None, the array is flattened before sorting.\\n    The default is -1, which sorts along the last axis.\\nkind : {'introselect'}, optional\\n    Selection algorithm. Default is 'introselect'.\\norder : str or list of str, optional\\n    When \\`a\\` is an array with fields defined, this argument specifies which\\n    fields to compare first, second, etc.\\n\\nReturns\\n-------\\npartitioned_array : ndarray\\n    Array of the same type and shape as \\`a\\`.\",\n}\n-/\n\n/-  Return a partitioned copy of an array around the k-th element -/\n\n/-  Specification: partition rearranges elements so that the k-th element is in its sorted position,\n    with smaller elements before it and equal/greater elements after it -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def partition {n : Nat} (arr : Vector Float n) (kth : Fin n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem partition_spec {n : Nat} (arr : Vector Float n) (kth : Fin n) :\n    \u2983\u231cTrue\u231d\u2984\n    partition arr kth\n    \u2983\u21d3result => \u231c\n      -- All elements before kth are \u2264 the kth element\n      (\u2200 i : Fin n, i < kth \u2192 result.get i \u2264 result.get kth) \u2227\n      -- All elements after kth are \u2265 the kth element  \n      (\u2200 i : Fin n, kth < i \u2192 result.get i \u2265 result.get kth) \u2227\n      -- The k-th element is in its correct sorted position relative to the original array\n      (\u2203 (sorted : Vector Float n), \n        (\u2200 i j : Fin n, i < j \u2192 sorted.get i \u2264 sorted.get j) \u2227\n        (\u2200 i : Fin n, \u2203 j : Fin n, sorted.get i = arr.get j) \u2227\n        (\u2200 i : Fin n, \u2203 j : Fin n, arr.get i = sorted.get j) \u2227\n        result.get kth = sorted.get kth) \u2227\n      -- The result contains the same elements as the original (multiset equality)\n      (\u2200 x : Float, (List.ofFn (fun i => result.get i)).count x = (List.ofFn (fun i => arr.get i)).count x)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_searchsorted", "vc-description": "/-  numpy.searchsorted: Find indices where elements should be inserted to maintain order.\n\n    Given a sorted array `a` and values `v`, returns indices such that inserting \n    each element of `v` at the corresponding index would preserve the sorted order of `a`.\n\n    This implementation focuses on the 'left' side behavior where for each value v[i],\n    it returns the leftmost suitable insertion position. The returned indices are\n    in the range [0, n] where n is the length of the sorted array.\n-/\n\n/-  Specification: numpy.searchsorted returns indices for sorted insertion.\n\n    Precondition: The input array `a` must be sorted in ascending order\n    Postcondition: For each element v[i], the returned index idx satisfies:\n    - All elements before idx are strictly less than v[i] (left insertion property)\n    - All elements at or after idx are greater than or equal to v[i] (sorted property)\n    - The index is valid for insertion (between 0 and n inclusive)\n    - Inserting v[i] at idx preserves the sorted order of the array\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_searchsorted {n m : Nat} (a : Vector Float n) (v : Vector Float m) : Id (Vector (Fin (n + 1)) m) :=\n  sorry", "vc-theorems": "theorem numpy_searchsorted_spec {n m : Nat} (a : Vector Float n) (v : Vector Float m) \n    (h_sorted : \u2200 i j : Fin n, i < j \u2192 a.get i \u2264 a.get j) :\n    \u2983\u231c\u2200 i j : Fin n, i < j \u2192 a.get i \u2264 a.get j\u231d\u2984\n    numpy_searchsorted a v\n    \u2983\u21d3indices => \u231c\u2200 k : Fin m, \n        let idx := indices.get k\n        -- Left insertion property: all elements before idx are strictly less than v[k]\n        (\u2200 i : Fin n, i.val < idx.val \u2192 a.get i < v.get k) \u2227\n        -- Sorted property: all elements at or after idx are greater than or equal to v[k]\n        (\u2200 j : Fin n, idx.val \u2264 j.val \u2192 v.get k \u2264 a.get j) \u2227\n        -- Leftmost property: idx is the leftmost valid insertion point\n        (\u2200 pos : Fin (n + 1), pos.val < idx.val \u2192 \n            \u2203 i : Fin n, i.val < pos.val \u2227 a.get i \u2265 v.get k)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_sort", "vc-description": "/-  numpy.sort: Return a sorted copy of an array.\n\n    Returns a new array with the same elements sorted in ascending order.\n    The original array is not modified. This function performs a stable sort \n    on the array elements, meaning that when multiple records have the same key,\n    their original order is preserved.\n\n    Parameters:\n    - a : array_like - Array to be sorted\n\n    Returns:\n    - sorted_array : ndarray - Array of the same type and shape as a, with elements sorted\n-/\n\n/-  Specification: numpy.sort returns a sorted permutation of the input array.\n\n    The specification captures three key properties:\n    1. Sorting property: Elements are in non-decreasing order\n    2. Permutation property: The result contains exactly the same elements as the input\n    3. Stability property: Relative order of equal elements is preserved (implicit in permutation)\n\n    Precondition: True (works for any vector)\n    Postcondition: Result is sorted and is a permutation of the input\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def sort {n : Nat} (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem sort_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    sort a\n    \u2983\u21d3result => \u231c(\u2200 i j : Fin n, i.val < j.val \u2192 result.get i \u2264 result.get j) \u2227\n                (\u2200 x : Float, (result.toList.count x) = (a.toList.count x))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_unique", "vc-description": "/-  numpy.unique: Find the unique elements of an array.\n\n    Returns the sorted unique elements of an array. This operation removes\n    duplicate values and returns them in sorted order. The result contains\n    each unique value exactly once.\n\n    For a 1D array, this function eliminates duplicate elements and sorts\n    the remaining unique elements in ascending order.\n\n    The returned array will have size less than or equal to the input array,\n    with equality only when all elements are already unique.\n-/\n\n/-  Specification: numpy.unique returns sorted unique elements without duplicates.\n\n    Precondition: True (no special preconditions)\n    Postcondition: The result contains all unique elements from the input array,\n    sorted in ascending order, with no duplicates, and every element in the \n    result appears in the original array.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def unique {n : Nat} (ar : Vector Float n) : Id (\u03a3 m : Nat, Vector Float m) :=\n  sorry", "vc-theorems": "theorem unique_spec {n : Nat} (ar : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    unique ar\n    \u2983\u21d3result => \u231clet m := result.1\n                  let unique_arr := result.2\n                  -- The result is sorted in ascending order\n                  (\u2200 i j : Fin m, i < j \u2192 unique_arr.get i < unique_arr.get j) \u2227\n                  -- No duplicates in the result\n                  (\u2200 i j : Fin m, i \u2260 j \u2192 unique_arr.get i \u2260 unique_arr.get j) \u2227\n                  -- Every element in result comes from the input array\n                  (\u2200 i : Fin m, \u2203 j : Fin n, unique_arr.get i = ar.get j) \u2227\n                  -- Every distinct element from input appears in result\n                  (\u2200 i : Fin n, \u2203 j : Fin m, ar.get i = unique_arr.get j)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "sorting_searching_where", "vc-description": "/- \n{\n  \"name\": \"numpy.where\",\n  \"category\": \"Searching\",\n  \"description\": \"Return elements chosen from x or y depending on condition\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.where.html\",\n  \"doc\": \"Return elements chosen from \\`x\\` or \\`y\\` depending on \\`condition\\`.\\n\\nNote\\n----\\nWhen only \\`condition\\` is provided, this function is a shorthand for\\n\\`\\`np.asarray(condition).nonzero()\\`\\`. Using \\`nonzero\\` directly should be\\npreferred, as it behaves correctly for subclasses. The rest of this\\ndocumentation covers only the case where all three arguments are\\nprovided.\\n\\nParameters\\n----------\\ncondition : array_like, bool\\n    Where True, yield \\`x\\`, otherwise yield \\`y\\`.\\nx, y : array_like\\n    Values from which to choose. \\`x\\`, \\`y\\` and \\`condition\\` need to be\\n    broadcastable to some shape.\\n\\nReturns\\n-------\\nout : ndarray\\n    An array with elements from \\`x\\` where \\`condition\\` is True, and elements\\n    from \\`y\\` elsewhere.\\n\\nSee Also\\n--------\\nchoose\\nnonzero : The function that is called when x and y are omitted\",\n}\n-/\n\n/-  Return elements chosen from x or y depending on condition.\n    For each position i, if condition[i] is True, take x[i], otherwise take y[i]. -/\n\n/-  Specification: numpy_where returns an array where elements are chosen from x when condition is True,\n    and from y when condition is False. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_where {n : Nat} (condition : Vector Bool n) (x y : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem numpy_where_spec {n : Nat} (condition : Vector Bool n) (x y : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_where condition x y\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      (condition.get i = true \u2192 result.get i = x.get i) \u2227\n      (condition.get i = false \u2192 result.get i = y.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_amax", "vc-description": "/- \n{\n  \"name\": \"numpy.amax\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Return the maximum of an array or maximum along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.amax.html\",\n  \"doc\": \"numpy.amax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)\\n\\nReturn the maximum of an array or maximum along an axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which to operate. By default, flattened input is used.\\n    If this is a tuple of ints, the maximum is selected over multiple axes,\\n    instead of a single axis or all the axes as before.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. Must be of the same\\n    shape and buffer length as the expected output.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result\\n    as dimensions with size one. With this option, the result will broadcast\\n    correctly against the input array.\\ninitial : scalar, optional\\n    The minimum value of an output element. Must be present to allow computation\\n    on empty slice.\\nwhere : array_like of bool, optional\\n    Elements to compare for the maximum.\\n\\nReturns\\n-------\\namax : ndarray or scalar\\n    Maximum of a. If axis is None, the result is a scalar value. If axis is given,\\n    the result is an array of dimension a.ndim - 1.\\n\\nNotes\\n-----\\nNaN values are propagated, that is if at least one item is NaN, the corresponding\\nmax value will be NaN as well. To ignore NaN values (MATLAB behavior), please use\\nnanmax.\\n\\nDon't use amax for element-wise comparison of 2 arrays; when a.shape[0] is 2,\\nmaximum(a[0], a[1]) is faster than amax(a, axis=0).\",\n}\n-/\n\n/-  Returns the maximum value of all elements in a non-empty vector -/\n\n/-  Specification: amax returns the maximum value in the vector.\n    Mathematical properties:\n    1. The result is an element that exists in the vector\n    2. No element in the vector is greater than the result\n    3. The result is unique (first occurrence if there are duplicates)\n    4. For constant vectors, amax equals the constant value -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def amax {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem amax_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    amax a\n    \u2983\u21d3result => \u231c-- Core property: result is the maximum element in the vector\n                 (\u2203 max_idx : Fin (n + 1),\n                   result = a.get max_idx \u2227\n                   (\u2200 i : Fin (n + 1), a.get i \u2264 result)) \u2227\n                 -- Uniqueness: result is the first occurrence of the maximum\n                 (\u2203 first_max_idx : Fin (n + 1),\n                   result = a.get first_max_idx \u2227\n                   (\u2200 i : Fin (n + 1), a.get i = result \u2192 first_max_idx \u2264 i) \u2227\n                   (\u2200 i : Fin (n + 1), a.get i \u2264 result)) \u2227\n                 -- For constant vectors, amax equals the constant\n                 ((\u2200 i j : Fin (n + 1), a.get i = a.get j) \u2192 \n                   result = a.get \u27e80, Nat.zero_lt_succ n\u27e9) \u2227\n                 -- Sanity check: the maximum exists in the vector\n                 (\u2203 witness : Fin (n + 1), result = a.get witness)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_amin", "vc-description": "/- \n{\n  \"name\": \"numpy.amin\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Return the minimum of an array or minimum along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.amin.html\",\n  \"doc\": \"numpy.amin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)\\n\\nReturn the minimum of an array or minimum along an axis.\\n\\nParameters\\n----------\\na : array_like\\n    Input data.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which to operate. By default, flattened input is used.\\n    If this is a tuple of ints, the minimum is selected over multiple axes,\\n    instead of a single axis or all the axes as before.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. Must be of the same\\n    shape and buffer length as the expected output.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result\\n    as dimensions with size one. With this option, the result will broadcast\\n    correctly against the input array.\\ninitial : scalar, optional\\n    The maximum value of an output element. Must be present to allow computation\\n    on empty slice.\\nwhere : array_like of bool, optional\\n    Elements to compare for the minimum.\\n\\nReturns\\n-------\\namin : ndarray or scalar\\n    Minimum of a. If axis is None, the result is a scalar value. If axis is given,\\n    the result is an array of dimension a.ndim - 1.\\n\\nNotes\\n-----\\nNaN values are propagated, that is if at least one item is NaN, the corresponding\\nmin value will be NaN as well. To ignore NaN values (MATLAB behavior), please use\\nnanmin.\\n\\nDon't use amin for element-wise comparison of 2 arrays; when a.shape[0] is 2,\\nminimum(a[0], a[1]) is faster than amin(a, axis=0).\",\n}\n-/\n\n/-  numpy.amin: Return the minimum of an array or minimum along an axis.\n\n    This is an alias for numpy.min that returns the minimum value among all elements in the array.\n    Requires a non-empty array since there is no minimum of an empty set.\n\n    This is a reduction operation that finds the smallest value in the array.\n    NaN values are propagated - if any element is NaN, the result will be NaN.\n-/\n\n/-  Specification: amin returns the minimum element in the vector.\n\n    Precondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\n    Postcondition: result is the minimum value and is an element of the vector\n\n    Properties:\n    1. The result is actually an element of the input vector\n    2. The result is less than or equal to all elements in the vector\n    3. This captures the mathematical definition of minimum\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def amin {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem amin_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    amin a\n    \u2983\u21d3result => \u231c(\u2203 i : Fin (n + 1), a.get i = result) \u2227\n                (\u2200 i : Fin (n + 1), result \u2264 a.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_average", "vc-description": "/- \n{\n  \"name\": \"numpy.average\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the weighted average along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.average.html\",\n  \"doc\": \"numpy.average(a, axis=None, weights=None, returned=False, *, keepdims=<no value>)\\n\\nCompute the weighted average along the specified axis.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing data to be averaged. If a is not an array, a conversion is attempted.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which to average a. The default, axis=None, will average over all of the elements of the input array.\\nweights : array_like, optional\\n    An array of weights associated with the values in a. Each value in a contributes to the average according to its associated weight.\\nreturned : bool, optional\\n    Default is False. If True, the tuple (average, sum_of_weights) is returned, otherwise only the average is returned.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nretval, [sum_of_weights] : array_type or double\\n    Return the average along the specified axis. When returned is True, return a tuple with the average as the first element and the sum of the weights as the second element.\\n\\nRaises\\n------\\nZeroDivisionError\\n    When all weights along axis are zero.\\nTypeError\\n    When the length of 1D weights is not the same as the shape of a along axis.\",\n}\n-/\n\n/-  numpy.average: Compute the weighted average along the specified axis.\n\n    Computes the weighted average of the elements in the input vector.\n    If weights are not provided, it computes the arithmetic mean.\n    If weights are provided, it computes the weighted average where each\n    element contributes according to its associated weight.\n\n    The weighted average is computed as:\n    sum(a * weights) / sum(weights)\n\n    When weights are not provided, this reduces to:\n    sum(a) / len(a)\n-/\n\n/-  Specification: numpy.average computes the weighted average when weights are provided,\n    and arithmetic mean when weights are None.\n\n    Precondition: Array is non-empty and if weights are provided, their sum is non-zero\n    Postcondition: Returns the weighted average or arithmetic mean as appropriate\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def average {n : Nat} (a : Vector Float (n + 1)) (weights : Option (Vector Float (n + 1))) : Id Float :=\n  sorry", "vc-theorems": "theorem average_spec {n : Nat} (a : Vector Float (n + 1)) (weights : Option (Vector Float (n + 1))) :\n    \u2983\u231cTrue\u231d\u2984\n    average a weights\n    \u2983\u21d3result => \u231c(weights.isNone \u2192 \n        \u2203 sum_a : Float, result = sum_a / Float.ofNat (n + 1)) \u2227\n      (\u2200 w, weights = some w \u2192 \n        \u2203 sum_aw sum_w : Float, result = sum_aw / sum_w \u2227 sum_w \u2260 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_corrcoef", "vc-description": "/-  numpy.corrcoef: Return Pearson product-moment correlation coefficients.\n\n    The correlation coefficient measures the linear relationship between two variables.\n    For two vectors x and y, the correlation coefficient is computed as:\n\n    corr(x, y) = cov(x, y) / (std(x) * std(y))\n\n    Where:\n    - cov(x, y) is the covariance between x and y\n    - std(x) and std(y) are the standard deviations of x and y\n\n    This function computes the correlation coefficient between two vectors of observations.\n    The result is bounded between -1 and 1, where:\n    - 1 indicates perfect positive correlation\n    - -1 indicates perfect negative correlation  \n    - 0 indicates no linear correlation\n\n    Requires non-empty vectors and non-zero variance in both variables.\n-/\n\n/-  Specification: corrcoef computes the Pearson correlation coefficient between two vectors.\n\n    The correlation coefficient satisfies several mathematical properties:\n    1. Symmetry: corr(x, y) = corr(y, x)\n    2. Bounded: -1 \u2264 corr(x, y) \u2264 1\n    3. Self-correlation: corr(x, x) = 1 (if x has non-zero variance)\n    4. Scale invariance: correlation is preserved under linear transformations\n\n    Precondition: Both vectors have non-zero variance (not all elements equal)\n    Postcondition: Result is bounded between -1 and 1, and captures linear relationship\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def corrcoef {n : Nat} (x y : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem corrcoef_spec {n : Nat} (x y : Vector Float (n + 1)) \n    (hx_var : \u2203 i j : Fin (n + 1), x.get i \u2260 x.get j) \n    (hy_var : \u2203 i j : Fin (n + 1), y.get i \u2260 y.get j) :\n    \u2983\u231c\u2203 i j : Fin (n + 1), x.get i \u2260 x.get j \u2227 \n       \u2203 i j : Fin (n + 1), y.get i \u2260 y.get j\u231d\u2984\n    corrcoef x y\n    \u2983\u21d3result => \u231c-- Bounded property: correlation coefficient is always between -1 and 1\n                  -1.0 \u2264 result \u2227 result \u2264 1.0 \u2227\n                  -- Relationship to covariance: correlation normalizes covariance\n                  (\u2200 (mean_x mean_y : Float),\n                   mean_x = (List.sum (x.toList)) / Float.ofNat (n + 1) \u2192\n                   mean_y = (List.sum (y.toList)) / Float.ofNat (n + 1) \u2192\n                   \u2203 (cov_xy var_x var_y : Float),\n                   cov_xy = (List.sum (List.zipWith (fun xi yi => (xi - mean_x) * (yi - mean_y)) x.toList y.toList)) / Float.ofNat (n + 1) \u2227\n                   var_x > 0 \u2227 var_y > 0 \u2227\n                   result = cov_xy / Float.sqrt (var_x * var_y))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_correlate", "vc-description": "/- \n{\n  \"name\": \"numpy.correlate\",\n  \"category\": \"Correlating\",\n  \"description\": \"Cross-correlation of two 1-dimensional sequences\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.correlate.html\",\n  \"doc\": \"numpy.correlate(a, v, mode='valid')\\n\\nCross-correlation of two 1-dimensional sequences.\\n\\nThis function computes the correlation as generally defined in signal processing texts:\\n\\nc_k = sum_n a_{n+k} * conj(v_n)\\n\\nwith a and v sequences being zero-padded where necessary and conj being the complex conjugate.\\n\\nParameters\\n----------\\na, v : array_like\\n    Input sequences.\\nmode : {'valid', 'same', 'full'}, optional\\n    Refer to the convolve docstring. Note that the default is 'valid', unlike convolve, which uses 'full'.\\n\\nReturns\\n-------\\nout : ndarray\\n    Discrete cross-correlation of a and v.\\n\\nNotes\\n-----\\nThe definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:\\n\\nc'_k = sum_n a_n * conj(v_{n+k})\\n\\nwhich is related to c_k by c'_k = conj(c_{-k}).\",\n}\n-/\n\n/-  Cross-correlation of two 1-dimensional sequences in 'valid' mode.\n    Computes c_k = sum_i a_{k+i} * v_i for positions where both sequences fully overlap. -/\n\n/-  Specification: correlate computes cross-correlation with valid mode overlap.\n    Each output element is the sum of products of overlapping elements from the input sequences.\n\n    Mathematical properties:\n    1. The result has size (m + 1 - n) for valid mode\n    2. Each output element k is computed as: sum_i a[k+i] * v[i] for i in [0, n-1]\n    3. Only positions where both sequences fully overlap are computed\n    4. The correlation preserves the mathematical definition of cross-correlation -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def correlate {m n : Nat} (a : Vector Float m) (v : Vector Float n) (h : n \u2264 m) (h_pos : 0 < n) : Id (Vector Float (m + 1 - n)) :=\n  sorry", "vc-theorems": "theorem correlate_spec {m n : Nat} (a : Vector Float m) (v : Vector Float n) (h : n \u2264 m) (h_pos : 0 < n) :\n    \u2983\u231cn \u2264 m \u2227 0 < n\u231d\u2984\n    correlate a v h h_pos\n    \u2983\u21d3result => \u231c-- Cross-correlation computation property: each output element is the sum of products\n                 (\u2200 k : Fin (m + 1 - n), \n                   \u2203 products : Fin n \u2192 Float,\n                   (\u2200 i : Fin n, products i = a.get \u27e8k.val + i.val, by sorry\u27e9 * v.get i) \u2227\n                   result.get k = (Vector.ofFn products).toList.sum) \u2227\n                 -- Boundary condition: all indices are valid for the computation\n                 (\u2200 k : Fin (m + 1 - n), \u2200 i : Fin n, k.val + i.val < m) \u2227\n                 -- Mathematical property: correlation is bilinear in its arguments\n                 (\u2200 k : Fin (m + 1 - n), \n                   result.get k = (Vector.ofFn (fun i : Fin n => a.get \u27e8k.val + i.val, by sorry\u27e9 * v.get i)).toList.sum) \u2227\n                 -- Non-negativity when both sequences are non-negative\n                 ((\u2200 i : Fin m, 0 \u2264 a.get i) \u2227 (\u2200 i : Fin n, 0 \u2264 v.get i) \u2192\n                   \u2200 k : Fin (m + 1 - n), 0 \u2264 result.get k)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_cov", "vc-description": "/-  numpy.cov: Estimate a covariance matrix, given data and weights.\n\n    Covariance indicates the level to which two variables vary together. \n    If we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, \n    then the covariance matrix element C_{ij} is the covariance of x_i and x_j. \n    The element C_{ii} is the variance of x_i.\n\n    For a matrix with `vars` variables and `obs` observations:\n    - Each row represents a variable\n    - Each column represents an observation\n    - Returns a vars \u00d7 vars covariance matrix\n\n    This implementation focuses on the basic unweighted case without bias correction.\n-/\n\n/-  Specification: numpy.cov computes the covariance matrix from data matrix m.\n\n    Given a data matrix m where each row is a variable and each column is an observation,\n    the covariance matrix C has the following mathematical properties:\n\n    1. Symmetry: C[i,j] = C[j,i] for all i,j\n    2. Diagonal elements are variances: C[i,i] = Var(X_i)\n    3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)\n    4. Positive semi-definite: all eigenvalues \u2265 0\n\n    The covariance between variables i and j is computed as:\n    Cov(X_i, X_j) = E[(X_i - \u03bc_i)(X_j - \u03bc_j)]\n    where \u03bc_i is the mean of variable i.\n\n    Precondition: At least one observation (obs > 0)\n    Postcondition: Returns a symmetric positive semi-definite covariance matrix\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_cov {vars obs : Nat} (m : Vector (Vector Float obs) vars) (h : obs > 0) : Id (Vector (Vector Float vars) vars) :=\n  sorry", "vc-theorems": "theorem numpy_cov_spec {vars obs : Nat} (m : Vector (Vector Float obs) vars) (h : obs > 0) :\n    \u2983\u231cobs > 0\u231d\u2984\n    numpy_cov m h\n    \u2983\u21d3cov_matrix => \u231c\n      -- Symmetry property: C[i,j] = C[j,i]\n      (\u2200 i j : Fin vars, (cov_matrix.get i).get j = (cov_matrix.get j).get i) \u2227\n      -- Diagonal elements are variances (non-negative)\n      (\u2200 i : Fin vars, (cov_matrix.get i).get i \u2265 0) \u2227\n      -- Covariance relationship: for any two variables i and j,\n      -- the covariance matrix element C[i,j] represents their covariance\n      (\u2200 i j : Fin vars, \n        let var_i := m.get i\n        let var_j := m.get j\n        let mean_i := (List.sum (List.map (fun k : Fin obs => var_i.get k) (List.finRange obs))) / (obs.toFloat)\n        let mean_j := (List.sum (List.map (fun k : Fin obs => var_j.get k) (List.finRange obs))) / (obs.toFloat)\n        (cov_matrix.get i).get j = \n          (List.sum (List.map (fun k : Fin obs => \n            (var_i.get k - mean_i) * (var_j.get k - mean_j)\n          ) (List.finRange obs))) / (obs.toFloat - 1))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_histogram", "vc-description": "/- \n{\n  \"name\": \"numpy.histogram\",\n  \"category\": \"Histograms\",\n  \"description\": \"Compute the histogram of a dataset\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.histogram.html\",\n  \"doc\": \"numpy.histogram(a, bins=10, range=None, density=None, weights=None)\\n\\nCompute the histogram of a dataset.\\n\\nParameters\\n----------\\na : array_like\\n    Input data. The histogram is computed over the flattened array.\\nbins : int or sequence of scalars or str, optional\\n    If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.\\nrange : (float, float), optional\\n    The lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()). Values outside the range are ignored.\\ndensity : bool, optional\\n    If False, the result will contain the number of samples in each bin. If True, the result is the value of the probability density function at the bin, normalized such that the integral over the range is 1.\\nweights : array_like, optional\\n    An array of weights, of the same shape as a. Each value in a only contributes its associated weight towards the bin count (instead of 1).\\n\\nReturns\\n-------\\nhist : array\\n    The values of the histogram.\\nbin_edges : array of dtype float\\n    Return the bin edges (length(hist)+1).\",\n}\n-/\n\n/-  numpy.histogram: Compute the histogram of a dataset.\n\n    Computes the histogram of a dataset by dividing the range into equal-width bins\n    and counting the number of values that fall into each bin.\n\n    The function returns both the histogram counts and the bin edges.\n    For n_bins bins, there are n_bins+1 bin edges.\n\n    This implementation focuses on the core mathematical properties:\n    - Monotonically increasing bin edges\n    - Equal bin widths (uniform binning)\n    - Correct counting of values in each bin\n    - Conservation of total count\n-/\n\n/-  Specification: histogram correctly partitions data into bins and counts occurrences.\n\n    The histogram satisfies fundamental mathematical properties:\n    1. Bin edges are monotonically increasing\n    2. The first edge equals min_val and the last edge equals max_val\n    3. Bin widths are equal for uniform binning\n    4. Each bin count equals the number of data points in that bin\n    5. The sum of all bin counts equals the number of data points in range\n\n    Precondition: Number of bins > 0 and min_val < max_val\n    Postcondition: The result satisfies the histogram mathematical properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def histogram {n_data n_bins : Nat} (data : Vector Float n_data) (min_val max_val : Float)\n    (h_bins_pos : n_bins > 0) (h_range : min_val < max_val) : \n    Id (Vector Nat n_bins \u00d7 Vector Float (n_bins + 1)) :=\n  sorry", "vc-theorems": "theorem histogram_spec {n_data n_bins : Nat} (data : Vector Float n_data) (min_val max_val : Float)\n    (h_bins_pos : n_bins > 0) (h_range : min_val < max_val) :\n    \u2983\u231cn_bins > 0 \u2227 min_val < max_val\u231d\u2984\n    histogram data min_val max_val h_bins_pos h_range\n    \u2983\u21d3result => \u231c-- Bin edges are monotonically increasing\n      (\u2200 i j : Fin (n_bins + 1), i.val < j.val \u2192 result.2.get i < result.2.get j) \u2227\n      -- Boundary conditions: first edge is min_val, last edge is max_val\n      (result.2.get \u27e80, Nat.succ_pos n_bins\u27e9 = min_val) \u2227\n      (result.2.get \u27e8n_bins, Nat.le_refl (n_bins + 1)\u27e9 = max_val) \u2227\n      -- Uniform binning: all bin widths are equal\n      (\u2200 i : Fin n_bins, \n        result.2.get \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9 - \n        result.2.get \u27e8i.val, Nat.lt_trans i.isLt (Nat.lt_succ_self n_bins)\u27e9 = \n        (max_val - min_val) / n_bins.toFloat) \u2227\n      -- Each bin count is non-negative (trivially true for Nat)\n      (\u2200 i : Fin n_bins, result.1.get i \u2265 0) \u2227\n      -- Conservation: total count equals number of data points in range\n      (List.sum (List.map result.1.get (List.finRange n_bins)) = \n        (data.toList.filter (fun x => min_val \u2264 x \u2227 x \u2264 max_val)).length)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_histogram2d", "vc-description": "/- \n{\n  \"name\": \"numpy.histogram2d\",\n  \"category\": \"Histograms\",\n  \"description\": \"Compute the bi-dimensional histogram of two data samples\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.histogram2d.html\",\n  \"doc\": \"numpy.histogram2d(x, y, bins=10, range=None, density=None, weights=None)\\n\\nCompute the bi-dimensional histogram of two data samples.\\n\\nParameters\\n----------\\nx : array_like, shape (N,)\\n    An array containing the x coordinates of the points to be histogrammed.\\ny : array_like, shape (N,)\\n    An array containing the y coordinates of the points to be histogrammed.\\nbins : int or array_like or [int, int] or [array, array], optional\\n    The bin specification:\\n    * If int, the number of bins for the two dimensions (nx=ny=bins).\\n    * If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).\\n    * If [int, int], the number of bins in each dimension (nx, ny = bins).\\n    * If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).\\nrange : array_like, shape(2,2), optional\\n    The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the bins parameters): [[xmin, xmax], [ymin, ymax]].\\ndensity : bool, optional\\n    If False, the default, returns the number of samples in each bin. If True, returns the probability density function at the bin.\\nweights : array_like, shape(N,), optional\\n    An array of values w_i weighing each sample (x_i, y_i).\\n\\nReturns\\n-------\\nH : ndarray, shape(nx, ny)\\n    The bi-dimensional histogram of samples x and y.\\nxedges : ndarray, shape(nx+1,)\\n    The bin edges along the first dimension.\\nyedges : ndarray, shape(ny+1,)\\n    The bin edges along the second dimension.\",\n}\n-/\n\n/-  Computes the bi-dimensional histogram of two data samples with equal number of bins -/\n\n/-  Specification: histogram2d computes a 2D histogram from two equal-length vectors.\n    Mathematical properties:\n    1. Input vectors must have the same length (enforced by type system)\n    2. The histogram matrix has dimensions (nbins, nbins) where nbins = bins\n    3. Each histogram bin counts the number of points falling within its boundaries\n    4. The bin edges define the boundaries for both x and y dimensions\n    5. The total count equals the input vector length\n    6. All histogram values are non-negative\n    7. Bin edges are monotonically increasing -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def histogram2d {n : Nat} {nbins : Nat} (x y : Vector Float n) (bins : Nat) \n    (h_bins_pos : bins > 0) (h_nbins_eq : nbins = bins) : Id (Vector (Vector Nat nbins) nbins \u00d7 Vector Float (nbins + 1) \u00d7 Vector Float (nbins + 1)) :=\n  sorry", "vc-theorems": "theorem histogram2d_spec {n : Nat} {nbins : Nat} (x y : Vector Float n) (bins : Nat) \n    (h_bins_pos : bins > 0) (h_nbins_eq : nbins = bins) :\n    \u2983\u231cbins > 0\u231d\u2984\n    histogram2d x y bins h_bins_pos h_nbins_eq\n    \u2983\u21d3result => \u231c-- Destructure the result tuple\n                 let (hist, x_edges, y_edges) := result\n                 -- 1. All histogram values are non-negative\n                 (\u2200 i : Fin nbins, \u2200 j : Fin nbins, (hist.get i).get j \u2265 0) \u2227\n                 -- 2. Total count conservation: sum of all bins equals input length\n                 (\u2203 total : Nat, \n                   (\u2200 i : Fin nbins, \u2200 j : Fin nbins, (hist.get i).get j \u2264 n) \u2227\n                   total = n) \u2227\n                 -- 3. Bin edges are monotonically increasing\n                 (\u2200 i : Fin nbins, x_edges.get \u27e8i, sorry\u27e9 < x_edges.get \u27e8i + 1, sorry\u27e9) \u2227\n                 (\u2200 i : Fin nbins, y_edges.get \u27e8i, sorry\u27e9 < y_edges.get \u27e8i + 1, sorry\u27e9) \u2227\n                 -- 4. Bin edges span the data range appropriately\n                 (\u2203 x_min x_max y_min y_max : Float,\n                   (\u2200 i : Fin n, x_min \u2264 x.get i \u2227 x.get i \u2264 x_max) \u2227\n                   (\u2200 i : Fin n, y_min \u2264 y.get i \u2227 y.get i \u2264 y_max) \u2227\n                   x_edges.get \u27e80, sorry\u27e9 \u2264 x_min \u2227 x_max \u2264 x_edges.get \u27e8nbins, sorry\u27e9 \u2227\n                   y_edges.get \u27e80, sorry\u27e9 \u2264 y_min \u2227 y_max \u2264 y_edges.get \u27e8nbins, sorry\u27e9) \u2227\n                 -- 5. Histogram correctly partitions the data space\n                 (\u2200 i : Fin nbins, \u2200 j : Fin nbins,\n                   \u2200 k : Fin n,\n                   let x_val := x.get k\n                   let y_val := y.get k\n                   let x_left := x_edges.get \u27e8i, sorry\u27e9\n                   let x_right := x_edges.get \u27e8i + 1, sorry\u27e9  \n                   let y_left := y_edges.get \u27e8j, sorry\u27e9\n                   let y_right := y_edges.get \u27e8j + 1, sorry\u27e9\n                   (x_left \u2264 x_val \u2227 x_val < x_right \u2227 y_left \u2264 y_val \u2227 y_val < y_right) \u2228\n                   (i = nbins - 1 \u2227 j = nbins - 1 \u2227 x_val = x_right \u2227 y_val = y_right) \u2192\n                   (hist.get i).get j \u2265 1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_histogram_bin_edges", "vc-description": "/- \n{\n  \"name\": \"numpy.histogram_bin_edges\",\n  \"category\": \"Histograms\",\n  \"description\": \"Function to calculate only the edges of the bins used by the histogram function\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html\",\n  \"doc\": \"numpy.histogram_bin_edges(a, bins=10, range=None, weights=None)\\n\\nFunction to calculate only the edges of the bins used by the histogram function.\\n\\nParameters\\n----------\\na : array_like\\n    Input data. The histogram is computed over the flattened array.\\nbins : int or sequence of scalars or str, optional\\n    If bins is an int, it defines the number of equal-width bins in the given range (10, by default). If bins is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.\\n    If bins is a string from the list below, histogram_bin_edges will use the method chosen to calculate the optimal bin width and consequently the number of bins.\\nrange : (float, float), optional\\n    The lower and upper range of the bins. If not provided, range is simply (a.min(), a.max()). Values outside the range are ignored.\\nweights : array_like, optional\\n    An array of weights, of the same shape as a. Each value in a only contributes its associated weight towards the bin count (instead of 1).\\n\\nReturns\\n-------\\nbin_edges : array of dtype float\\n    The edges to pass into histogram\",\n}\n-/\n\n/-  Calculate the bin edges for histogram computation with equal-width bins.\n    Takes non-empty data and number of bins, returns bin edges. -/\n\n/-  Specification: histogram_bin_edges computes equal-width bin edges from data range.\n    This comprehensive specification captures:\n    1. The number of returned edges equals num_bins + 1\n    2. The edges are monotonically increasing (strictly ordered)\n    3. The first edge is at or below the minimum data value\n    4. The last edge is at or above the maximum data value\n    5. The edges are evenly spaced (equal width bins)\n    6. All data values fall within the range [first_edge, last_edge]\n    7. The bin width is consistent across all bins\n    8. The function handles non-empty data correctly\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def histogram_bin_edges {n : Nat} (data : Vector Float (n + 1)) (num_bins : Nat) \n    (h_bins : num_bins > 0) : Id (Vector Float (num_bins + 1)) :=\n  sorry", "vc-theorems": "theorem histogram_bin_edges_spec {n : Nat} (data : Vector Float (n + 1)) (num_bins : Nat)\n    (h_bins : num_bins > 0) :\n    \u2983\u231cnum_bins > 0\u231d\u2984\n    histogram_bin_edges data num_bins h_bins\n    \u2983\u21d3edges => \u231c-- The returned edges have the correct length\n                (edges.size = num_bins + 1) \u2227\n                -- The edges are monotonically increasing\n                (\u2200 i : Fin num_bins, \n                  let curr_edge := edges.get \u27e8i.val, Nat.lt_trans i.isLt (Nat.lt_succ_self _)\u27e9\n                  let next_edge := edges.get \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9\n                  curr_edge < next_edge) \u2227\n                -- The first edge is at or below the minimum data value\n                (let min_val := (data.toArray.foldl min (data.get \u27e80, Nat.succ_pos _\u27e9) : Float)\n                 let first_edge := edges.get \u27e80, Nat.succ_pos _\u27e9\n                 first_edge \u2264 min_val) \u2227\n                -- The last edge is at or above the maximum data value\n                (let max_val := (data.toArray.foldl max (data.get \u27e80, Nat.succ_pos _\u27e9) : Float)\n                 let last_edge := edges.get \u27e8num_bins, Nat.lt_succ_self _\u27e9\n                 last_edge \u2265 max_val) \u2227\n                -- The bins have equal width (equal spacing between consecutive edges)\n                (\u2200 i j : Fin num_bins, \n                  let bin_width_i := edges.get \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9 - \n                                    edges.get \u27e8i.val, Nat.lt_trans i.isLt (Nat.lt_succ_self _)\u27e9\n                  let bin_width_j := edges.get \u27e8j.val + 1, Nat.succ_lt_succ j.isLt\u27e9 - \n                                    edges.get \u27e8j.val, Nat.lt_trans j.isLt (Nat.lt_succ_self _)\u27e9\n                  bin_width_i = bin_width_j) \u2227\n                -- All data values fall within the range of the edges\n                (let first_edge := edges.get \u27e80, Nat.succ_pos _\u27e9\n                 let last_edge := edges.get \u27e8num_bins, Nat.lt_succ_self _\u27e9\n                 \u2200 i : Fin (n + 1), \n                   first_edge \u2264 data.get i \u2227 data.get i \u2264 last_edge)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_histogramdd", "vc-description": "/- \n{\n  \"name\": \"numpy.histogramdd\",\n  \"category\": \"Histograms\",\n  \"description\": \"Compute the multidimensional histogram of some data\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.histogramdd.html\",\n  \"doc\": \"numpy.histogramdd(sample, bins=10, range=None, density=None, weights=None)\\n\\nCompute the multidimensional histogram of some data.\\n\\nParameters\\n----------\\nsample : (N, D) array, or (N, D) list of arrays\\n    The data to be histogrammed.\\n    Note the unusual interpretation of sample when an array_like:\\n    * When an array, each row is a coordinate in a D-dimensional space - such as histogramdd(np.array([p1, p2, p3])).\\n    * When a list of arrays, each array is the list of values for single coordinate - such as histogramdd([X, Y, Z]).\\nbins : sequence or int, optional\\n    The bin specification:\\n    * A sequence of arrays describing the monotonically increasing bin edges along each dimension.\\n    * The number of bins for each dimension (nx, ny, ... =bins)\\n    * The number of bins for all dimensions (nx=ny=...=bins).\\nrange : sequence, optional\\n    A sequence of length D, each an optional (lower, upper) tuple giving the outer bin edges to be used if the edges are not given explicitly in bins.\\ndensity : bool, optional\\n    If False, the default, returns the number of samples in each bin. If True, returns the probability density function at the bin.\\nweights : (N,) array_like, optional\\n    An array of values w_i weighing each sample (x_i, y_i, z_i, ...).\\n\\nReturns\\n-------\\nH : ndarray\\n    The multidimensional histogram of sample x.\\nedges : list\\n    A list of D arrays describing the bin edges for each dimension.\",\n}\n-/\n\n/-  Compute the multidimensional histogram of some data.\n    For simplicity, we focus on 2D histograms with fixed dimensions. -/\n\n/-  Specification: histogramdd computes a 2D histogram with correct bin counts and edges -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def histogramdd {n : Nat} (sample : Vector (Float \u00d7 Float) n) (bins_x bins_y : Nat) : \n    Id (Vector (Vector Float bins_x) bins_y \u00d7 Vector Float (bins_x + 1) \u00d7 Vector Float (bins_y + 1)) :=\n  sorry", "vc-theorems": "theorem histogramdd_spec {n : Nat} (sample : Vector (Float \u00d7 Float) n) (bins_x bins_y : Nat) \n    (h_bins_x_pos : bins_x > 0) (h_bins_y_pos : bins_y > 0) :\n    \u2983\u231cbins_x > 0 \u2227 bins_y > 0\u231d\u2984\n    histogramdd sample bins_x bins_y\n    \u2983\u21d3result => \n      let (hist, edges_x, edges_y) := result\n      \u231c-- The histogram has the correct dimensions\n      (hist.toArray.size = bins_y) \u2227\n      (\u2200 i : Fin bins_y, (hist.get i).toArray.size = bins_x) \u2227\n      -- The edges have the correct sizes\n      (edges_x.toArray.size = bins_x + 1) \u2227\n      (edges_y.toArray.size = bins_y + 1) \u2227\n      -- The edges are monotonically increasing\n      (\u2200 i : Fin bins_x, edges_x.get \u27e8i.val, by omega\u27e9 < edges_x.get \u27e8i.val + 1, by omega\u27e9) \u2227\n      (\u2200 i : Fin bins_y, edges_y.get \u27e8i.val, by omega\u27e9 < edges_y.get \u27e8i.val + 1, by omega\u27e9) \u2227\n      -- The histogram counts are non-negative\n      (\u2200 i : Fin bins_y, \u2200 j : Fin bins_x, (hist.get i).get j \u2265 0) \u2227\n      -- Each sample point falls into exactly one bin\n      (\u2200 p : Float \u00d7 Float, p \u2208 sample.toArray \u2192\n        \u2203 i : Fin bins_y, \u2203 j : Fin bins_x,\n          edges_y.get \u27e8i.val, by omega\u27e9 \u2264 p.snd \u2227 p.snd < edges_y.get \u27e8i.val + 1, by omega\u27e9 \u2227\n          edges_x.get \u27e8j.val, by omega\u27e9 \u2264 p.fst \u2227 p.fst < edges_x.get \u27e8j.val + 1, by omega\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_max", "vc-description": "/- \n{\n  \"name\": \"numpy.max\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Alias for numpy.amax - Return the maximum of an array or maximum along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.max.html\",\n  \"doc\": \"numpy.max is an alias for numpy.amax. See numpy.amax for full documentation.\",\n}\n-/\n\n/-  Returns the maximum value of all elements in a non-empty vector.\n    This is an alias for numpy.amax that returns the maximum value among all elements in the array.\n\n    Mathematical Properties:\n    - Returns an element that exists in the vector\n    - No element in the vector is greater than the returned value\n    - For constant vectors, returns the constant value\n    - Handles non-empty vectors only (n + 1 elements) -/\n\n/-  Specification: max returns the maximum value in the vector.\n    This specification delegates to amax_spec since max is an alias for amax.\n\n    Mathematical properties:\n    1. The result is an element that exists in the vector\n    2. No element in the vector is greater than the result\n    3. The result is unique (first occurrence if there are duplicates)\n    4. For constant vectors, max equals the constant value\n    5. Sanity check: the maximum exists in the vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def max {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem max_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    max a\n    \u2983\u21d3result => \u231c-- Core property: result is the maximum element in the vector\n                 (\u2203 max_idx : Fin (n + 1),\n                   result = a.get max_idx \u2227\n                   (\u2200 i : Fin (n + 1), a.get i \u2264 result)) \u2227\n                 -- Uniqueness: result is the first occurrence of the maximum\n                 (\u2203 first_max_idx : Fin (n + 1),\n                   result = a.get first_max_idx \u2227\n                   (\u2200 i : Fin (n + 1), a.get i = result \u2192 first_max_idx \u2264 i) \u2227\n                   (\u2200 i : Fin (n + 1), a.get i \u2264 result)) \u2227\n                 -- For constant vectors, max equals the constant\n                 ((\u2200 i j : Fin (n + 1), a.get i = a.get j) \u2192 \n                   result = a.get \u27e80, Nat.zero_lt_succ n\u27e9) \u2227\n                 -- Sanity check: the maximum exists in the vector\n                 (\u2203 witness : Fin (n + 1), result = a.get witness)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_mean", "vc-description": "/- \n{\n  \"name\": \"numpy.mean\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the arithmetic mean along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.mean.html\",\n  \"doc\": \"numpy.mean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)\\n\\nCompute the arithmetic mean along the specified axis.\\n\\nReturns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. float64 intermediate and return values are used for integer inputs.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.\\ndtype : data-type, optional\\n    Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. The default is None.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nwhere : array_like of bool, optional\\n    Elements to include in the mean.\\n\\nReturns\\n-------\\nm : ndarray, see dtype parameter above\\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned.\\n\\nNotes\\n-----\\nThe arithmetic mean is the sum of the elements along the axis divided by the number of elements.\\n\\nNote that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32. Specifying a higher-precision accumulator using the dtype keyword can alleviate this issue.\",\n}\n-/\n\n/-  Computes the arithmetic mean of all elements in a non-empty vector -/\n\n/-  Specification: mean computes the arithmetic average of all elements.\n    Mathematical properties:\n    1. The result is the sum of all elements divided by the count\n    2. The mean lies between the minimum and maximum values\n    3. For constant vectors, mean equals the constant value -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mean {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem mean_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    mean a\n    \u2983\u21d3result => \u231c-- Core property: mean is sum divided by count\n                 (\u2203 sum : Float, \n                   (sum = (List.range (n + 1)).foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0 \u2227\n                    result = sum / Float.ofNat (n + 1))) \u2227\n                 -- Mean is bounded by min and max\n                 (\u2203 min_idx max_idx : Fin (n + 1),\n                   (\u2200 i : Fin (n + 1), a.get min_idx \u2264 a.get i) \u2227\n                   (\u2200 i : Fin (n + 1), a.get i \u2264 a.get max_idx) \u2227\n                   a.get min_idx \u2264 result \u2227 result \u2264 a.get max_idx) \u2227\n                 -- For constant vectors, mean equals the constant\n                 ((\u2200 i j : Fin (n + 1), a.get i = a.get j) \u2192 \n                   result = a.get \u27e80, Nat.zero_lt_succ n\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_median", "vc-description": "/- \n{\n  \"name\": \"numpy.median\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the median along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.median.html\",\n  \"doc\": \"numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)\\n\\nCompute the median along the specified axis.\\n\\nReturns the median of the array elements.\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array.\\naxis : {int, sequence of int, None}, optional\\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output.\\noverwrite_input : bool, optional\\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nmedian : ndarray\\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64. Otherwise, the data-type of the output is the same as that of the input.\\n\\nNotes\\n-----\\nGiven a vector V of length N, the median of V is the middle value of a sorted copy of V, V_sorted - i.e., V_sorted[(N-1)/2], when N is odd, and the average of the two middle values of V_sorted when N is even.\",\n}\n-/\n\n/-  Compute the median of a vector.\n    For odd-length vectors, returns the middle value of the sorted array.\n    For even-length vectors, returns the average of the two middle values. -/\n\n/-  Specification: median returns the middle value(s) of a sorted vector.\n    - For odd length (n+1), the median is the middle element when sorted\n    - For even length (n+1), the median is the average of the two middle elements when sorted\n    - The median divides the data such that approximately half the values are \u2264 it,\n      and approximately half are \u2265 it -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def median {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem median_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    median a\n    \u2983\u21d3m => \u231c\u2203 sorted : Vector Float (n + 1),\n            -- sorted is a permutation of a\n            (\u2200 i : Fin (n + 1), \u2203 j : Fin (n + 1), sorted.get i = a.get j) \u2227\n            (\u2200 j : Fin (n + 1), \u2203 i : Fin (n + 1), sorted.get i = a.get j) \u2227\n            -- sorted is in non-decreasing order\n            (\u2200 i j : Fin (n + 1), i < j \u2192 sorted.get i \u2264 sorted.get j) \u2227\n            -- m is the median of sorted based on odd/even length\n            (if h : (n + 1) % 2 = 1 then\n              -- odd case: middle element at index n/2\n              m = sorted.get \u27e8n / 2, by\n                have : n / 2 < n + 1 :=\n  sorry\n                exact this\u27e9\n            else\n              -- even case: average of two middle elements  \n              m = (sorted.get \u27e8n / 2, by\n                have : n / 2 < n + 1 :=\n  sorry\n                exact this\u27e9 + \n                   sorted.get \u27e8(n + 1) / 2, by\n                have : (n + 1) / 2 < n + 1 :=\n  sorry\n                exact this\u27e9) / 2) \u2227\n            -- median property: it's a value that appears in the original vector\n            -- or can be computed from values in the vector\n            (\u2203 i : Fin (n + 1), m = sorted.get i \u2228 \n             \u2203 i j : Fin (n + 1), m = (sorted.get i + sorted.get j) / 2)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_min", "vc-description": "/- \n{\n  \"name\": \"numpy.min\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Alias for numpy.amin - Return the minimum of an array or minimum along an axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.min.html\",\n  \"doc\": \"numpy.min is an alias for numpy.amin. See numpy.amin for full documentation.\",\n}\n-/\n\n/-  numpy.min: Return the minimum of an array or minimum along an axis.\n\n    This function is an alias for numpy.amin that returns the minimum value \n    among all elements in the array. Requires a non-empty array since there \n    is no minimum of an empty set.\n\n    This is a reduction operation that finds the smallest value in the array.\n    NaN values are propagated - if any element is NaN, the result will be NaN.\n\n    Being an alias, it has identical behavior to amin but provides a more\n    intuitive name for the operation.\n-/\n\n/-  Specification: min returns the minimum element in the vector.\n\n    Precondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\n    Postcondition: result is the minimum value and is an element of the vector\n\n    Properties:\n    1. The result is actually an element of the input vector\n    2. The result is less than or equal to all elements in the vector\n    3. This captures the mathematical definition of minimum\n    4. As an alias for amin, it has identical mathematical properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def min {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem min_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    min a\n    \u2983\u21d3result => \u231c(\u2203 i : Fin (n + 1), a.get i = result) \u2227\n                (\u2200 i : Fin (n + 1), result \u2264 a.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanmax", "vc-description": "/- \n{\n  \"name\": \"numpy.nanmax\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Return the maximum of an array or maximum along an axis, ignoring any NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanmax.html\",\n  \"doc\": \"numpy.nanmax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)\\n\\nReturn the maximum of an array or maximum along an axis, ignoring any NaNs.\\nWhen all-NaN slices are encountered a RuntimeWarning is raised and NaN is returned for that slice.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose maximum is desired. If a is not an array, a conversion is attempted.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. The default is None; if provided, it must have the same shape as the expected output.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\ninitial : scalar, optional\\n    The minimum value of an output element. Must be present to allow computation on empty slice.\\nwhere : array_like of bool, optional\\n    Elements to compare for the maximum.\\n\\nReturns\\n-------\\nnanmax : ndarray\\n    An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, an ndarray scalar is returned.\",\n}\n-/\n\n/-  Returns the maximum value of all elements in a non-empty vector, ignoring NaN values.\n    When all elements are NaN, returns NaN.\n\n    Mathematical Properties:\n    - Ignores NaN values in the computation\n    - Returns the maximum of all non-NaN elements\n    - If all elements are NaN, returns NaN\n    - If at least one element is not NaN, returns the maximum non-NaN value\n    - For vectors with no NaN values, behaves identically to regular max -/\n\n/-  Specification: nanmax returns the maximum value in the vector, ignoring NaN values.\n\n    Mathematical properties:\n    1. If there exists at least one non-NaN element, the result is the maximum among non-NaN elements\n    2. If all elements are NaN, the result is NaN\n    3. The result is either a non-NaN element from the vector or NaN\n    4. For vectors without NaN values, nanmax behaves identically to regular max\n    5. NaN values are completely ignored during the maximum computation\n    6. Sanity check: result is either NaN or exists in the vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanmax {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem nanmax_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    nanmax a\n    \u2983\u21d3result => \u231c-- Case 1: If there exists at least one non-NaN element\n                 ((\u2203 i : Fin (n + 1), \u00acresult.isNaN \u2227 \u00ac(a.get i).isNaN) \u2192\n                   (\u2203 max_idx : Fin (n + 1), \n                     result = a.get max_idx \u2227 \n                     \u00ac(a.get max_idx).isNaN \u2227\n                     (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 result))) \u2227\n                 -- Case 2: If all elements are NaN, result is NaN\n                 ((\u2200 i : Fin (n + 1), (a.get i).isNaN) \u2192 result.isNaN) \u2227\n                 -- Case 3: NaN values are ignored (result is max of non-NaN elements)\n                 (\u00acresult.isNaN \u2192 \n                   (\u2203 witness : Fin (n + 1), \n                     result = a.get witness \u2227 \n                     \u00ac(a.get witness).isNaN \u2227\n                     (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 result))) \u2227\n                 -- Case 4: For vectors without NaN, behaves like regular max\n                 ((\u2200 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192 \n                   (\u2203 max_idx : Fin (n + 1),\n                     result = a.get max_idx \u2227\n                     (\u2200 j : Fin (n + 1), a.get j \u2264 result))) \u2227\n                 -- Sanity check: result is either NaN or exists in the vector\n                 (result.isNaN \u2228 (\u2203 witness : Fin (n + 1), result = a.get witness))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanmean", "vc-description": "/- \n{\n  \"name\": \"numpy.nanmean\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the arithmetic mean along the specified axis, ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanmean.html\",\n  \"doc\": \"numpy.nanmean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)\\n\\nCompute the arithmetic mean along the specified axis, ignoring NaNs.\\n\\nReturns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. float64 intermediate and return values are used for integer inputs.\\n\\nFor all-NaN slices, NaN is returned and a RuntimeWarning is raised.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.\\ndtype : data-type, optional\\n    Type to use in computing the mean. For integer inputs, the default is float64; for inexact inputs, it is the same as the input dtype.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. The default is None.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nwhere : array_like of bool, optional\\n    Elements to include in the mean.\\n\\nReturns\\n-------\\nm : ndarray, see dtype parameter above\\n    If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.\",\n}\n-/\n\n/-  Compute the arithmetic mean along the specified axis, ignoring NaNs.\n    Returns the average of the array elements, ignoring NaN values.\n    If all values are NaN, returns NaN. -/\n\n/-  Specification: nanmean computes the arithmetic mean while ignoring NaN values.\n\n    Mathematical properties:\n    1. If vector contains valid (non-NaN) values, result is their arithmetic mean\n    2. If all values are NaN, result is NaN\n    3. Result is never NaN when valid values exist\n    4. NaN values are completely ignored in the computation\n    5. For vectors without NaN values, behaves identically to regular mean\n    6. The result is bounded by the minimum and maximum of non-NaN elements -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanmean {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem nanmean_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nanmean a\n    \u2983\u21d3result => \u231c-- Case 1: If there exists at least one non-NaN element\n                 ((\u2203 i : Fin n, \u00ac(a.get i).isNaN) \u2192\n                   (let valid_indices := (List.range n).filter (fun i => \u00ac(a.get \u27e8i, by sorry\u27e9).isNaN)\n                    let valid_sum := valid_indices.foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0\n                    let valid_count := Float.ofNat valid_indices.length\n                    result = valid_sum / valid_count \u2227 \u00acresult.isNaN)) \u2227\n                 -- Case 2: If all elements are NaN, result is NaN\n                 ((\u2200 i : Fin n, (a.get i).isNaN) \u2192 result.isNaN) \u2227\n                 -- Case 3: NaN values are ignored (result is mean of non-NaN elements)\n                 (\u00acresult.isNaN \u2192 \n                   (\u2203 valid_count : Nat, valid_count > 0 \u2227\n                    let valid_sum := (List.range n).filter (fun i => \u00ac(a.get \u27e8i, by sorry\u27e9).isNaN)\n                                   |>.foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0\n                    result = valid_sum / Float.ofNat valid_count)) \u2227\n                 -- Case 4: For vectors without NaN, behaves like regular mean\n                 ((\u2200 i : Fin n, \u00ac(a.get i).isNaN) \u2227 n > 0 \u2192 \n                   (let total_sum := (List.range n).foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0\n                    result = total_sum / Float.ofNat n)) \u2227\n                 -- Case 5: Result is bounded by min and max of non-NaN elements (when valid elements exist)\n                 ((\u2203 i : Fin n, \u00ac(a.get i).isNaN) \u2227 \u00acresult.isNaN \u2192\n                   (\u2203 min_idx max_idx : Fin n,\n                     \u00ac(a.get min_idx).isNaN \u2227 \u00ac(a.get max_idx).isNaN \u2227\n                     (\u2200 j : Fin n, \u00ac(a.get j).isNaN \u2192 a.get min_idx \u2264 a.get j) \u2227\n                     (\u2200 j : Fin n, \u00ac(a.get j).isNaN \u2192 a.get j \u2264 a.get max_idx) \u2227\n                     a.get min_idx \u2264 result \u2227 result \u2264 a.get max_idx))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanmedian", "vc-description": "/- \n{\n  \"name\": \"numpy.nanmedian\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the median along the specified axis, ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanmedian.html\",\n  \"doc\": \"numpy.nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=False)\\n\\nCompute the median along the specified axis, while ignoring NaNs.\\n\\nReturns the median of the array elements.\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array.\\naxis : {int, sequence of int, None}, optional\\n    Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output.\\noverwrite_input : bool, optional\\n    If True, then allow use of memory of input array a for calculations. The input array will be modified by the call to median.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\n\\nReturns\\n-------\\nmedian : ndarray\\n    A new array holding the result. If the input contains integers or floats smaller than float64, then the output data-type is np.float64. Otherwise, the data-type of the output is the same as that of the input.\\n\\nNotes\\n-----\\nGiven a vector V of length N, the median of V is the middle value of a sorted copy of V, V_sorted - i.e., V_sorted[(N-1)/2], when N is odd, and the average of the two middle values of V_sorted when N is even.\",\n}\n-/\n\n/-  Compute the median along the specified axis, ignoring NaNs.\n    Returns the median of the array elements.\n    For a vector V of length N, the median is the middle value of a sorted copy of V\n    (ignoring NaN values), when N is odd, and the average of the two middle values when N is even.\n    If all values are NaN, returns NaN. -/\n\n/-  Specification: nanmedian computes the median of non-NaN values in the array.\n    The result is NaN if all values are NaN, otherwise it's the median of the finite values.\n    The median is defined as the middle value (for odd number of elements) or the average\n    of two middle values (for even number of elements) when the non-NaN values are sorted. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanmedian {n : Nat} (a : Vector Float n) : Id Float :=\n  sorry", "vc-theorems": "theorem nanmedian_spec {n : Nat} (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    nanmedian a\n    \u2983\u21d3result => \u231c\n      -- Case 1: All values are NaN\n      (\u2200 i : Fin n, (a.get i).isNaN) \u2192 result.isNaN \u2227\n      -- Case 2: At least one finite value exists\n      (\u2203 i : Fin n, \u00ac(a.get i).isNaN) \u2192 \n        \u2203 finite_indices : List (Fin n),\n          -- finite_indices contains all indices with finite values\n          (\u2200 i : Fin n, i \u2208 finite_indices \u2194 \u00ac(a.get i).isNaN) \u2227\n          finite_indices.length > 0 \u2227\n          -- There exists a sorted permutation of finite values\n          \u2203 sorted_vals : List Float,\n            -- sorted_vals is the sorted list of finite values\n            sorted_vals.length = finite_indices.length \u2227\n            (\u2200 i : Fin finite_indices.length, \n              sorted_vals.get \u27e8i, sorry\u27e9 = a.get (finite_indices.get \u27e8i, sorry\u27e9)) \u2227\n            -- sorted_vals is in non-decreasing order\n            (\u2200 i j : Fin sorted_vals.length, i < j \u2192 \n              sorted_vals.get \u27e8i, sorry\u27e9 \u2264 sorted_vals.get \u27e8j, sorry\u27e9) \u2227\n            -- result is the median of sorted finite values\n            (if sorted_vals.length % 2 = 1 then\n              result = sorted_vals.get \u27e8sorted_vals.length / 2, sorry\u27e9\n            else\n              result = (sorted_vals.get \u27e8sorted_vals.length / 2 - 1, sorry\u27e9 + \n                       sorted_vals.get \u27e8sorted_vals.length / 2, sorry\u27e9) / 2)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanmin", "vc-description": "/- \n{\n  \"name\": \"numpy.nanmin\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Return minimum of an array or minimum along an axis, ignoring any NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanmin.html\",\n  \"doc\": \"numpy.nanmin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)\\n\\nReturn minimum of an array or minimum along an axis, ignoring any NaNs.\\nWhen all-NaN slices are encountered a RuntimeWarning is raised and NaN is returned for that slice.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose minimum is desired. If a is not an array, a conversion is attempted.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. The default is None; if provided, it must have the same shape as the expected output.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\ninitial : scalar, optional\\n    The maximum value of an output element. Must be present to allow computation on empty slice.\\nwhere : array_like of bool, optional\\n    Elements to compare for the minimum.\\n\\nReturns\\n-------\\nnanmin : ndarray\\n    An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, an ndarray scalar is returned.\",\n}\n-/\n\n/-  Returns the minimum value of all elements in a non-empty vector, ignoring NaN values.\n    When all elements are NaN, returns NaN.\n\n    Mathematical Properties:\n    - Ignores NaN values in the computation\n    - Returns the minimum of all non-NaN elements\n    - If all elements are NaN, returns NaN\n    - If at least one element is not NaN, returns the minimum non-NaN value\n    - For vectors with no NaN values, behaves identically to regular min -/\n\n/-  Specification: nanmin returns the minimum value in the vector, ignoring NaN values.\n\n    Mathematical properties:\n    1. If there exists at least one non-NaN element, the result is the minimum among non-NaN elements\n    2. If all elements are NaN, the result is NaN\n    3. The result is either a non-NaN element from the vector or NaN\n    4. For vectors without NaN values, nanmin behaves identically to regular min\n    5. NaN values are completely ignored during the minimum computation\n    6. Sanity check: result is either NaN or exists in the vector -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanmin {n : Nat} (a : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem nanmin_spec {n : Nat} (a : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    nanmin a\n    \u2983\u21d3result => \u231c-- Case 1: If there exists at least one non-NaN element\n                 ((\u2203 i : Fin (n + 1), \u00acresult.isNaN \u2227 \u00ac(a.get i).isNaN) \u2192\n                   (\u2203 min_idx : Fin (n + 1), \n                     result = a.get min_idx \u2227 \n                     \u00ac(a.get min_idx).isNaN \u2227\n                     (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 result \u2264 a.get j))) \u2227\n                 -- Case 2: If all elements are NaN, result is NaN\n                 ((\u2200 i : Fin (n + 1), (a.get i).isNaN) \u2192 result.isNaN) \u2227\n                 -- Case 3: NaN values are ignored (result is min of non-NaN elements)\n                 (\u00acresult.isNaN \u2192 \n                   (\u2203 witness : Fin (n + 1), \n                     result = a.get witness \u2227 \n                     \u00ac(a.get witness).isNaN \u2227\n                     (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 result \u2264 a.get j))) \u2227\n                 -- Case 4: For vectors without NaN, behaves like regular min\n                 ((\u2200 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192 \n                   (\u2203 min_idx : Fin (n + 1),\n                     result = a.get min_idx \u2227\n                     (\u2200 j : Fin (n + 1), result \u2264 a.get j))) \u2227\n                 -- Sanity check: result is either NaN or exists in the vector\n                 (result.isNaN \u2228 (\u2203 witness : Fin (n + 1), result = a.get witness))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanpercentile", "vc-description": "/- \n{\n  \"name\": \"numpy.nanpercentile\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Compute the q-th percentile of the data along the specified axis, ignoring nan values\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanpercentile.html\",\n  \"doc\": \"numpy.nanpercentile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, weights=None, interpolation=None)\\n\\nCompute the q-th percentile of the data along the specified axis, ignoring nan values.\\n\\nReturns the q-th percentile(s) of the array elements.\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array, containing nan values to be ignored.\\nq : array_like of float\\n    Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the percentiles are computed.\\nout : ndarray, optional\\n    Alternative output array in which to place the result.\\noverwrite_input : bool, optional\\n    If True, then allow the input array a to be modified by intermediate calculations.\\nmethod : str, optional\\n    Method to use for estimating the percentile.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nweights : array_like, optional\\n    An array of weights associated with the values in a.\\ninterpolation : str, optional\\n    Deprecated name for the method keyword argument.\\n\\nReturns\\n-------\\npercentile : scalar or ndarray\\n    If q is a single percentile and axis=None, then the result is a scalar. Otherwise, an array is returned.\",\n}\n-/\n\n/-  Compute the q-th percentile of the data along the specified axis, ignoring NaN values.\n    Returns the q-th percentile of the array elements.\n    If all values are NaN, returns NaN.\n    The percentile q must be between 0 and 100 inclusive. -/\n\n/-  Specification: nanpercentile computes the q-th percentile of non-NaN values in the array.\n    The result is NaN if all values are NaN, otherwise it's the q-th percentile of the finite values.\n    The percentile is computed by sorting the non-NaN values and finding the value at the position\n    corresponding to the percentile q (between 0 and 100). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanpercentile {n : Nat} (a : Vector Float n) (q : Float) (h : 0 \u2264 q \u2227 q \u2264 100) : Id Float :=\n  sorry", "vc-theorems": "theorem nanpercentile_spec {n : Nat} (a : Vector Float n) (q : Float) (h : 0 \u2264 q \u2227 q \u2264 100) :\n    \u2983\u231c0 \u2264 q \u2227 q \u2264 100\u231d\u2984\n    nanpercentile a q h\n    \u2983\u21d3result => \u231c\n      -- Case 1: All values are NaN\n      (\u2200 i : Fin n, (a.get i).isNaN) \u2192 result.isNaN \u2227\n      -- Case 2: At least one finite value exists\n      (\u2203 i : Fin n, \u00ac(a.get i).isNaN) \u2192 \n        \u2203 finite_indices : List (Fin n),\n          -- finite_indices contains all indices with finite values\n          (\u2200 i : Fin n, i \u2208 finite_indices \u2194 \u00ac(a.get i).isNaN) \u2227\n          finite_indices.length > 0 \u2227\n          -- There exists a sorted permutation of finite values\n          \u2203 sorted_vals : List Float,\n            -- sorted_vals is the sorted list of finite values\n            sorted_vals.length = finite_indices.length \u2227\n            (\u2200 i : Fin finite_indices.length, \n              sorted_vals.get \u27e8i, sorry\u27e9 = a.get (finite_indices.get \u27e8i, sorry\u27e9)) \u2227\n            -- sorted_vals is in non-decreasing order\n            (\u2200 i j : Fin sorted_vals.length, i < j \u2192 \n              sorted_vals.get \u27e8i, sorry\u27e9 \u2264 sorted_vals.get \u27e8j, sorry\u27e9) \u2227\n            -- Percentile computation: q% of sorted values\n            (if sorted_vals.length = 1 then\n               -- Single value case\n               result = sorted_vals.get \u27e80, sorry\u27e9\n             else\n               -- For any percentile q, the result should be within the range\n               -- of the sorted values and satisfy the percentile property\n               \u2203 idx : Nat, \n                 idx < sorted_vals.length \u2227\n                 result = sorted_vals.get \u27e8idx, sorry\u27e9 \u2228\n                 -- OR result is an interpolated value between two consecutive elements\n                 (\u2203 i j : Nat, \n                   i < sorted_vals.length \u2227 j < sorted_vals.length \u2227\n                   i + 1 = j \u2227\n                   sorted_vals.get \u27e8i, sorry\u27e9 \u2264 result \u2227\n                   result \u2264 sorted_vals.get \u27e8j, sorry\u27e9)) \u2227\n            -- Sanity checks: result should be within bounds of finite values\n            (\u00acresult.isNaN \u2192 \n              sorted_vals.get \u27e80, sorry\u27e9 \u2264 result \u2227 \n              result \u2264 sorted_vals.get \u27e8sorted_vals.length - 1, sorry\u27e9)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanquantile", "vc-description": "/- \n{\n  \"name\": \"numpy.nanquantile\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Compute the q-th quantile of the data along the specified axis, ignoring nan values\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanquantile.html\",\n  \"doc\": \"numpy.nanquantile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, weights=None, interpolation=None)\\n\\nCompute the q-th quantile of the data along the specified axis, ignoring nan values.\\n\\nReturns the q-th quantile(s) of the array elements.\\n\\nParameters\\n----------\\na : array_like\\n    Input array or object that can be converted to an array, containing nan values to be ignored.\\nq : array_like of float\\n    Quantile or sequence of quantiles to compute, which must be between 0 and 1 inclusive.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the quantiles are computed.\\nout : ndarray, optional\\n    Alternative output array in which to place the result.\\noverwrite_input : bool, optional\\n    If True, then allow the input array a to be modified by intermediate calculations.\\nmethod : str, optional\\n    Method to use for estimating the quantile.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nweights : array_like, optional\\n    An array of weights associated with the values in a.\\ninterpolation : str, optional\\n    Deprecated name for the method keyword argument.\\n\\nReturns\\n-------\\nquantile : scalar or ndarray\\n    If q is a single quantile and axis=None, then the result is a scalar.\",\n}\n-/\n\n/-  Compute the q-th quantile of the data in a vector, ignoring NaN values.\n    When all elements are NaN, returns NaN.\n\n    Mathematical Properties:\n    - Ignores NaN values in the computation\n    - Returns the q-th quantile of all non-NaN elements \n    - If all elements are NaN, returns NaN\n    - If at least one element is not NaN, returns the quantile of non-NaN values\n    - For q=0, returns the minimum of non-NaN elements\n    - For q=1, returns the maximum of non-NaN elements\n    - For vectors with no NaN values, behaves identically to regular quantile -/\n\n/-  Specification: nanquantile returns the q-th quantile of non-NaN values in the vector.\n\n    Mathematical properties:\n    1. The quantile parameter q must be between 0 and 1 inclusive\n    2. If there exists at least one non-NaN element, the result is the q-th quantile among non-NaN elements\n    3. If all elements are NaN, the result is NaN\n    4. For q=0, result is the minimum of non-NaN elements\n    5. For q=1, result is the maximum of non-NaN elements\n    6. The result is bounded by the range of non-NaN elements\n    7. NaN values are completely ignored during the quantile computation\n    8. For vectors without NaN values, nanquantile behaves identically to regular quantile -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanquantile {n : Nat} (a : Vector Float (n + 1)) (q : Float) : Id Float :=\n  sorry", "vc-theorems": "theorem nanquantile_spec {n : Nat} (a : Vector Float (n + 1)) (q : Float) \n    (h_q_valid : 0 \u2264 q \u2227 q \u2264 1) :\n    \u2983\u231c0 \u2264 q \u2227 q \u2264 1\u231d\u2984\n    nanquantile a q\n    \u2983\u21d3result => \n      \u231c-- Case 1: If there exists at least one non-NaN element\n       ((\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192\n         (\u00acresult.isNaN \u2227\n          -- Result is bounded by the non-NaN elements\n          (\u2203 min_idx : Fin (n + 1), \u00ac(a.get min_idx).isNaN \u2227 \n            (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get min_idx \u2264 a.get j) \u2227\n            a.get min_idx \u2264 result) \u2227\n          (\u2203 max_idx : Fin (n + 1), \u00ac(a.get max_idx).isNaN \u2227 \n            (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 a.get max_idx) \u2227\n            result \u2264 a.get max_idx))) \u2227\n       -- Case 2: If all elements are NaN, result is NaN\n       ((\u2200 i : Fin (n + 1), (a.get i).isNaN) \u2192 result.isNaN) \u2227\n       -- Case 3: For q=0, result is the minimum of non-NaN elements\n       (q = 0 \u2192 (\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192 \n         (\u2203 min_idx : Fin (n + 1), \n           result = a.get min_idx \u2227 \n           \u00ac(a.get min_idx).isNaN \u2227\n           (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 result \u2264 a.get j))) \u2227\n       -- Case 4: For q=1, result is the maximum of non-NaN elements\n       (q = 1 \u2192 (\u2203 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192 \n         (\u2203 max_idx : Fin (n + 1), \n           result = a.get max_idx \u2227 \n           \u00ac(a.get max_idx).isNaN \u2227\n           (\u2200 j : Fin (n + 1), \u00ac(a.get j).isNaN \u2192 a.get j \u2264 result))) \u2227\n       -- Case 5: For vectors without NaN, behaves like regular quantile\n       ((\u2200 i : Fin (n + 1), \u00ac(a.get i).isNaN) \u2192 \n         (\u00acresult.isNaN \u2227\n          (\u2203 lower_idx upper_idx : Fin (n + 1),\n            a.get lower_idx \u2264 result \u2227 result \u2264 a.get upper_idx)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanstd", "vc-description": "/- \n{\n  \"name\": \"numpy.nanstd\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the standard deviation along the specified axis, ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanstd.html\",\n  \"doc\": \"numpy.nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, *, where=<no value>)\\n\\nCompute the standard deviation along the specified axis, while ignoring NaNs.\\n\\nReturns the standard deviation, a measure of the spread of a distribution, of the non-NaN array elements. The standard deviation is computed for the flattened array by default, otherwise over the specified axis.\\n\\nFor all-NaN slices, NaN is returned and a RuntimeWarning is raised.\\n\\nParameters\\n----------\\na : array_like\\n    Calculate the standard deviation of the non-NaN values.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.\\ndtype : dtype, optional\\n    Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. It must have the same shape as the expected output.\\nddof : int, optional\\n    Means Delta Degrees of Freedom. The divisor used in calculations is N - ddof, where N represents the number of non-NaN elements. By default ddof is zero.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nwhere : array_like of bool, optional\\n    Elements to include in the standard deviation.\\n\\nReturns\\n-------\\nstandard_deviation : ndarray, see dtype parameter above.\\n    If out is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.\",\n}\n-/\n\n/-  Compute the standard deviation along the specified axis, ignoring NaNs.\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the non-NaN array elements. The standard deviation is the square root\n    of the variance computed from non-NaN values.\n\n    For all-NaN slices, NaN is returned. -/\n\n/-  Specification: nanstd computes the standard deviation while ignoring NaN values.\n    Mathematical properties:\n    1. If vector contains valid (non-NaN) values and ddof < valid_count, \n       result is the square root of the variance of valid values\n    2. If all values are NaN, result is NaN\n    3. If ddof >= valid_count, result is NaN\n    4. Result is always non-negative when valid\n\n    The standard deviation is computed as:\n    1. Filter out NaN values to get valid values\n    2. Calculate the mean of valid values\n    3. Calculate squared deviations from the mean for valid values\n    4. Sum the squared deviations\n    5. Divide by (valid_count - ddof)\n    6. Take the square root of the result -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanstd {n : Nat} (a : Vector Float n) (ddof : Nat := 0) : Id Float :=\n  sorry", "vc-theorems": "theorem nanstd_spec {n : Nat} (a : Vector Float n) (ddof : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    nanstd a ddof\n    \u2983\u21d3result => \u231clet valid_indices := (List.range n).filter (fun i => \u00ac(a.get \u27e8i, by sorry\u27e9).isNaN)\n                 let valid_count := valid_indices.length\n                 -- Case 1: Valid values exist and ddof < valid_count\n                 if valid_count > 0 \u2227 ddof < valid_count then\n                   let valid_sum := valid_indices.foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0\n                   let valid_mean := valid_sum / Float.ofNat valid_count\n                   let squared_deviations := valid_indices.map (fun i => \n                     let val := a.get \u27e8i, by sorry\u27e9\n                     (val - valid_mean) * (val - valid_mean))\n                   let variance := (squared_deviations.foldl (\u00b7 + \u00b7) 0) / Float.ofNat (valid_count - ddof)\n                   result = Float.sqrt variance \u2227 \n                   result \u2265 0 \u2227\n                   \u00acresult.isNaN\n                 -- Case 2: All values are NaN or ddof >= valid_count\n                 else\n                   result.isNaN\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_nanvar", "vc-description": "/- \n{\n  \"name\": \"numpy.nanvar\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the variance along the specified axis, ignoring NaNs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nanvar.html\",\n  \"doc\": \"numpy.nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, *, where=<no value>)\\n\\nCompute the variance along the specified axis, while ignoring NaNs.\\n\\nReturns the variance of the array elements, a measure of the spread of a distribution. The variance is computed for the flattened array by default, otherwise over the specified axis.\\n\\nFor all-NaN slices, NaN is returned and a RuntimeWarning is raised.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose variance is desired. If a is not an array, a conversion is attempted.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.\\ndtype : data-type, optional\\n    Type to use in computing the variance. For arrays of integer type the default is float64; for arrays of float types it is the same as the array type.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. It must have the same shape as the expected output.\\nddof : int, optional\\n    \\\"Delta Degrees of Freedom\\\": the divisor used in the calculation is N - ddof, where N represents the number of non-NaN elements. By default ddof is zero.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nwhere : array_like of bool, optional\\n    Elements to include in the variance.\\n\\nReturns\\n-------\\nvariance : ndarray, see dtype parameter above\\n    If out is None, returns a new array containing the variance; otherwise, a reference to the output array is returned. If ddof is >= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.\",\n}\n-/\n\n/-  Compute the variance along the specified axis, while ignoring NaNs.\n    Uses the formula: sum((x - mean)\u00b2) / (n - ddof) for non-NaN elements.\n    Returns NaN if all elements are NaN or if degrees of freedom <= 0. -/\n\n/-  Specification for nanvar: Computes variance while ignoring NaN values.\n    Mathematical properties:\n    1. If vector contains valid (non-NaN) values and ddof < valid_count, \n       result is the variance of valid values\n    2. If all values are NaN, result is NaN\n    3. If ddof >= valid_count, result is NaN\n    4. Result is always non-negative when valid\n\n    The variance is computed as:\n    1. Filter out NaN values to get valid values\n    2. Calculate the mean of valid values\n    3. Calculate squared deviations from the mean for valid values\n    4. Sum the squared deviations\n    5. Divide by (valid_count - ddof) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def nanvar {n : Nat} (a : Vector Float n) (ddof : Nat := 0) : Id Float :=\n  sorry", "vc-theorems": "theorem nanvar_spec {n : Nat} (a : Vector Float n) (ddof : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    nanvar a ddof\n    \u2983\u21d3result => \u231clet valid_indices := (List.range n).filter (fun i => \u00ac(a.get \u27e8i, by sorry\u27e9).isNaN)\n                 let valid_count := valid_indices.length\n                 -- Case 1: Valid values exist and ddof < valid_count\n                 if valid_count > 0 \u2227 ddof < valid_count then\n                   let valid_sum := valid_indices.foldl (fun acc i => acc + a.get \u27e8i, by sorry\u27e9) 0\n                   let valid_mean := valid_sum / Float.ofNat valid_count\n                   let squared_deviations := valid_indices.map (fun i => \n                     let val := a.get \u27e8i, by sorry\u27e9\n                     (val - valid_mean) * (val - valid_mean))\n                   let variance := (squared_deviations.foldl (\u00b7 + \u00b7) 0) / Float.ofNat (valid_count - ddof)\n                   result = variance \u2227 \n                   result \u2265 0 \u2227\n                   \u00acresult.isNaN\n                 -- Case 2: All values are NaN or ddof >= valid_count\n                 else\n                   result.isNaN\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_percentile", "vc-description": "/- \n{\n  \"name\": \"numpy.percentile\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Compute the q-th percentile of the data along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.percentile.html\",\n  \"doc\": \"numpy.percentile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, weights=None, interpolation=None)\\n\\nCompute the q-th percentile of the data along the specified axis.\\n\\nReturns the q-th percentile(s) of the array elements.\\n\\nParameters\\n----------\\na : array_like of real numbers\\n    Input array or object that can be converted to an array.\\nq : array_like of float\\n    Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.\\nout : ndarray, optional\\n    Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output.\\noverwrite_input : bool, optional\\n    If True, then allow the input array a to be modified by intermediate calculations, to save memory.\\nmethod : str, optional\\n    This parameter specifies the method to use for estimating the percentile. Default is 'linear'.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nweights : array_like, optional\\n    An array of weights associated with the values in a.\\ninterpolation : str, optional\\n    Deprecated name for the method keyword argument.\\n\\nReturns\\n-------\\npercentile : scalar or ndarray\\n    If q is a single percentile and axis=None, then the result is a scalar. Otherwise, an array is returned.\",\n}\n-/\n\n/-  Compute the q-th percentile of the data in a vector.\n    For a sorted vector, the q-th percentile is the value below which q percent of the data falls.\n    This implementation focuses on the fundamental mathematical definition of percentiles. -/\n\n/-  Specification: percentile computes the q-th percentile value correctly.\n    The percentile is defined as the value v such that at least q% of the data\n    is less than or equal to v, and at least (100-q)% of the data is greater than or equal to v.\n\n    Mathematical properties:\n    1. The percentile value must be within the range of the data (or interpolated between values)\n    2. Special cases: q=0 gives minimum, q=100 gives maximum\n    3. The result is bounded by the minimum and maximum values in the array -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def percentile {n : Nat} (arr : Vector Float (n + 1)) (q : Float) : Id Float :=\n  sorry", "vc-theorems": "theorem percentile_spec {n : Nat} (arr : Vector Float (n + 1)) (q : Float) \n    (h_valid_q : 0 \u2264 q \u2227 q \u2264 100) :\n    \u2983\u231c0 \u2264 q \u2227 q \u2264 100\u231d\u2984\n    percentile arr q\n    \u2983\u21d3result => \u231c\n      -- The result is bounded by the minimum and maximum values in the array\n      (\u2200 i : Fin (n + 1), arr.get i \u2264 result \u2192 \n        \u2203 j : Fin (n + 1), arr.get j \u2265 result) \u2227\n      (\u2200 i : Fin (n + 1), arr.get i \u2265 result \u2192 \n        \u2203 j : Fin (n + 1), arr.get j \u2264 result) \u2227\n      -- Special cases\n      (q = 0 \u2192 \u2200 i : Fin (n + 1), result \u2264 arr.get i) \u2227\n      (q = 100 \u2192 \u2200 i : Fin (n + 1), arr.get i \u2264 result)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_quantile", "vc-description": "/- \n{\n  \"name\": \"numpy.quantile\",\n  \"category\": \"Order statistics\",\n  \"description\": \"Compute the q-th quantile of the data along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.quantile.html\",\n  \"doc\": \"numpy.quantile(a, q, axis=None, out=None, overwrite_input=False, method='linear', keepdims=False, *, weights=None, interpolation=None)\\n\\nCompute the q-th quantile of the data along the specified axis.\\n\\nParameters\\n----------\\na : array_like of real numbers\\n    Input array or object that can be converted to an array.\\nq : array_like of float\\n    Quantile or sequence of quantiles to compute, which must be between 0 and 1 inclusive.\\naxis : {int, tuple of int, None}, optional\\n    Axis or axes along which the quantiles are computed.\\nout : ndarray, optional\\n    Alternative output array in which to place the result.\\noverwrite_input : bool, optional\\n    If True, then allow the input array a to be modified by intermediate calculations.\\nmethod : str, optional\\n    This parameter specifies the method to use for estimating the quantile.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nweights : array_like, optional\\n    An array of weights associated with the values in a.\\ninterpolation : str, optional\\n    Deprecated name for the method keyword argument.\\n\\nReturns\\n-------\\nquantile : scalar or ndarray\\n    If q is a single quantile and axis=None, then the result is a scalar.\",\n}\n-/\n\n/-  Compute the q-th quantile of the data in a vector -/\n\n/-  Specification: quantile returns a value that has the property that \n    approximately q proportion of the data is less than or equal to it -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def quantile {n : Nat} (a : Vector Float (n + 1)) (q : Float) \n    (h_valid : 0 \u2264 q \u2227 q \u2264 1) : Id Float :=\n  sorry", "vc-theorems": "theorem quantile_spec {n : Nat} (a : Vector Float (n + 1)) (q : Float) \n    (h_valid : 0 \u2264 q \u2227 q \u2264 1) :\n    \u2983\u231c0 \u2264 q \u2227 q \u2264 1\u231d\u2984\n    quantile a q h_valid\n    \u2983\u21d3result => \u231c\n      -- The result is within the range of the input data\n      (\u2203 i : Fin (n + 1), a.get i \u2264 result) \u2227\n      (\u2203 i : Fin (n + 1), result \u2264 a.get i) \u2227\n      -- For 0-quantile, result should be \u2264 minimum\n      (q = 0 \u2192 \u2200 i : Fin (n + 1), result \u2264 a.get i) \u2227\n      -- For 1-quantile, result should be \u2265 maximum  \n      (q = 1 \u2192 \u2200 i : Fin (n + 1), a.get i \u2264 result)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_std", "vc-description": "/-  numpy.std: Compute the standard deviation along the specified axis.\n\n    Returns the standard deviation, a measure of the spread of a distribution,\n    of the array elements. The standard deviation is computed for the flattened\n    array by default, otherwise over the specified axis.\n\n    The standard deviation is the square root of the average of the squared\n    deviations from the mean: std = sqrt(mean((x - x.mean())**2)).\n\n    With ddof parameter, the divisor used in calculations is N - ddof,\n    where N represents the number of elements. The \"Delta Degrees of Freedom\"\n    parameter adjusts the divisor in the standard deviation calculation.\n-/\n\n/-  Specification: numpy.std returns the standard deviation of all elements.\n\n    The standard deviation is computed as the square root of the variance:\n    std = sqrt(sum((x_i - mean)\u00b2) / (N - ddof))\n\n    Key properties:\n    1. ddof must be less than the number of elements to avoid division by zero\n    2. The result is always non-negative (square root of non-negative variance)\n    3. When ddof = 0, uses population standard deviation (divide by N)\n    4. When ddof = 1, uses sample standard deviation (divide by N-1)\n    5. Mathematical correctness: the formula exactly matches NumPy's implementation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_std {n : Nat} (a : Vector Float (n + 1)) (ddof : Nat := 0) : Id Float :=\n  sorry", "vc-theorems": "theorem numpy_std_spec {n : Nat} (a : Vector Float (n + 1)) (ddof : Nat) (h_ddof : ddof < n + 1) :\n    \u2983\u231cddof < n + 1\u231d\u2984\n    numpy_std a ddof\n    \u2983\u21d3result => \u231c\n      let N := n + 1\n      let mean := (List.sum (a.toList)) / Float.ofNat N\n      let squared_deviations := a.toList.map (fun x => (x - mean) * (x - mean))\n      let variance := (List.sum squared_deviations) / Float.ofNat (N - ddof)\n      result = Float.sqrt variance \u2227\n      result \u2265 0 \u2227\n      (\u2200 i : Fin (n + 1), a.get i = mean \u2192 result = 0) \u2227\n      (N - ddof > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "statistics_var", "vc-description": "/- \n{\n  \"name\": \"numpy.var\",\n  \"category\": \"Averages and variances\",\n  \"description\": \"Compute the variance along the specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.var.html\",\n  \"doc\": \"numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, *, where=<no value>)\\n\\nCompute the variance along the specified axis.\\n\\nReturns the variance of the array elements, a measure of the spread of a distribution. The variance is computed for the flattened array by default, otherwise over the specified axis.\\n\\nParameters\\n----------\\na : array_like\\n    Array containing numbers whose variance is desired. If a is not an array, a conversion is attempted.\\naxis : None or int or tuple of ints, optional\\n    Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.\\ndtype : data-type, optional\\n    Type to use in computing the variance. For arrays of integer type the default is float64; for arrays of float types it is the same as the array type.\\nout : ndarray, optional\\n    Alternate output array in which to place the result. It must have the same shape as the expected output.\\nddof : int, optional\\n    \\\"Delta Degrees of Freedom\\\": the divisor used in the calculation is N - ddof, where N represents the number of elements. By default ddof is zero.\\nkeepdims : bool, optional\\n    If this is set to True, the axes which are reduced are left in the result as dimensions with size one.\\nwhere : array_like of bool, optional\\n    Elements to include in the variance.\\n\\nReturns\\n-------\\nvariance : ndarray, see dtype parameter above\\n    If out=None, returns a new array containing the variance; otherwise, a reference to the output array is returned.\\n\\nNotes\\n-----\\nThe variance is the average of the squared deviations from the mean, i.e., var = mean(x - x.mean())**2.\\n\\nThe mean is typically calculated as x.sum() / N, where N = len(x). If, however, ddof is specified, the divisor N - ddof is used instead. In standard statistical practice, ddof=1 provides an unbiased estimator of the variance of a hypothetical infinite population. ddof=0 provides a maximum likelihood estimate of the variance for normally distributed variables.\",\n}\n-/\n\n/-  Compute the variance of the elements in a vector with specified delta degrees of freedom.\n    The variance is the average of the squared deviations from the mean. -/\n\n/-  Specification: var computes the variance as the average of squared deviations from the mean,\n    divided by (n + 1 - ddof). The variance measures the spread of a distribution.\n\n    Mathematical properties:\n    1. The result is always non-negative\n    2. The variance is zero if and only if all elements are equal\n    3. The computation requires ddof < n + 1 to ensure a positive divisor\n    4. The variance equals the expected value of squared deviations from the mean\n    5. Translation invariance: var(a + c) = var(a) for any constant c\n    6. Scaling property: var(c * a) = c^2 * var(a) for any constant c\n\n    The variance formula implemented is:\n    var = (1/(n+1-ddof)) * sum_{i=0}^{n} (a[i] - mean)^2\n    where mean = (1/(n+1)) * sum_{i=0}^{n} a[i]\n\n    This specification captures both the mathematical definition of variance\n    and its key properties. When ddof=0, this gives the population variance;\n    when ddof=1, this gives the sample variance (unbiased estimator). -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def var {n : Nat} (a : Vector Float (n + 1)) (ddof : Nat) (h : ddof < n + 1) : Id Float :=\n  sorry", "vc-theorems": "theorem var_spec {n : Nat} (a : Vector Float (n + 1)) (ddof : Nat) (h : ddof < n + 1) :\n    \u2983\u231cddof < n + 1\u231d\u2984\n    var a ddof h\n    \u2983\u21d3result => \u231cresult \u2265 0 \u2227\n                 (result = 0 \u2194 \u2200 i j : Fin (n + 1), a.get i = a.get j) \u2227\n                 (\u2200 (c : Float), \u2200 (b : Vector Float (n + 1)), \n                   (\u2200 i : Fin (n + 1), b.get i = a.get i + c) \u2192 \n                   var b ddof h = result) \u2227\n                 (\u2200 (c : Float), c \u2260 0 \u2192 \u2200 (b : Vector Float (n + 1)), \n                   (\u2200 i : Fin (n + 1), b.get i = c * a.get i) \u2192 \n                   var b ddof h = c^2 * result)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_capitalize", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.capitalize\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return a copy of a with only the first character of each element capitalized\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.capitalize.html\",\n  \"doc\": \"Return a copy of \\`a\\` with only the first character of each element capitalized.\\n\\nFor byte strings, this method is locale-dependent.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array of strings\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\\n\\nExamples\\n--------\\n>>> np.strings.capitalize(['hello', 'world'])\\narray(['Hello', 'World'], dtype='<U5')\",\n}\n-/\n\n/-  Return a copy of a with only the first character of each element capitalized -/\n\n/-  Specification: capitalize returns a vector where each string has only its first character capitalized -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def capitalize {n : Nat} (a : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem capitalize_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    capitalize a\n    \u2983\u21d3r => \u231c\u2200 i : Fin n,\n      let original := a.get i\n      let result := r.get i\n      -- Length preservation: result has same length as original\n      (result.length = original.length) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Core property: the result is the capitalized version of the original\n      (result = original.capitalize) \u2227\n      -- Idempotence property: capitalizing a capitalized string doesn't change it\n      (result.capitalize = result) \u2227\n      -- Sanity check: applying capitalize to empty string gives empty string\n      (original = \"\" \u2192 result = \"\") \u2227\n      -- Mathematical property: the operation is deterministic\n      (result = original.capitalize)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_center", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.center\",\n  \"category\": \"String operations\",\n  \"description\": \"Return a copy of a with its elements centered in a string of length width\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.center.html\",\n  \"doc\": \"Return a copy of a with its elements centered in a string of length width.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nwidth : array_like, with any integer dtype\\n    The length of the resulting strings, unless \\`\\`width < str_len(a)\\`\\`.\\nfillchar : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    The padding character to use. Default is space.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\\n\\nExamples\\n--------\\n>>> c = np.array(['a1b2','1b2a','b2a1','2a1b']); c\\narray(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='<U4')\\n>>> np.strings.center(c, width=9)\\narray(['   a1b2  ', '   1b2a  ', '   b2a1  ', '   2a1b  '], dtype='<U9')\",\n}\n-/\n\n/-  numpy.strings.center: Return a copy of a with its elements centered in a string of length width.\n\n    Centers strings in a field of given width with optional fill character.\n    If the original string length is greater than or equal to the target width,\n    the original string is returned unchanged. Otherwise, the string is padded\n    symmetrically with the fill character to reach the target width.\n\n    From NumPy documentation:\n    - Parameters: a (array_like with StringDType), width (array_like with integer dtype), \n                  fillchar (optional, default ' ') - The padding character\n    - Returns: out (ndarray) - Output array with centered strings\n\n    Mathematical Properties:\n    1. Length preservation: If original.length >= width, return original unchanged\n    2. Symmetric padding: If original.length < width, pad equally on both sides\n    3. Padding balance: Left and right padding differ by at most 1 character\n    4. Character preservation: Original string appears as substring in result\n    5. Width compliance: Result length equals max(original.length, width)\n-/\n\n/-  Specification: numpy.strings.center returns a vector where each element is the\n    corresponding element from the input centered in a field of the specified width.\n\n    Mathematical Properties:\n    1. Length preservation: If original string length >= target width, return original\n    2. Symmetric padding: If original string length < target width, pad symmetrically\n    3. Padding balance: Left and right padding counts differ by at most 1\n    4. Character preservation: Original string appears as contiguous substring\n    5. Width compliance: Result length equals max(original.length, target_width)\n    6. Fill character usage: Padding uses the specified fill character exclusively\n\n    Precondition: True (no special preconditions for string centering)\n    Postcondition: For all indices i, result[i] is the centered version of a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def center {n : Nat} (a : Vector String n) (width : Vector Nat n) (fillchar : Char := ' ') : Id (Vector String n) :=\n  return Vector.ofFn (fun i => \n    let str := a.get i\n    let w := width.get i\n    if str.length \u2265 w then \n      str \n    else \n      let padding := w - str.length\n      let left_pad := padding / 2\n      let right_pad := padding - left_pad\n      String.mk (List.replicate left_pad fillchar) ++ str ++ String.mk (List.replicate right_pad fillchar))", "vc-theorems": "theorem center_spec {n : Nat} (a : Vector String n) (width : Vector Nat n) (fillchar : Char := ' ') :\n    \u2983\u231cTrue\u231d\u2984\n    center a width fillchar\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      -- Length preservation: If original string length >= target width, return original\n      ((a.get i).length \u2265 width.get i \u2192 r.get i = a.get i) \u2227\n      -- Width compliance: Result length equals max(original.length, target_width)\n      (r.get i).length = max (a.get i).length (width.get i) \u2227\n      -- Symmetric padding: If original string length < target width, pad symmetrically\n      ((a.get i).length < width.get i \u2192 \n        \u2203 (left_pad right_pad : Nat), \n          left_pad + (a.get i).length + right_pad = width.get i \u2227\n          -- Padding should be as equal as possible (differ by at most 1)\n          (left_pad = right_pad \u2228 left_pad = right_pad + 1) \u2227\n          -- Left padding is floor(padding/2), right padding is ceiling(padding/2)\n          left_pad = (width.get i - (a.get i).length) / 2 \u2227\n          right_pad = (width.get i - (a.get i).length) - left_pad \u2227\n          -- Result string structure: left_pad + original + right_pad\n          r.get i = (String.mk (List.replicate left_pad fillchar)) ++ (a.get i) ++ (String.mk (List.replicate right_pad fillchar)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_count", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.count\",\n  \"category\": \"String information\",\n  \"description\": \"Returns an array with the number of non-overlapping occurrences of substring sub in the range [start, end]\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.count.html\",\n  \"doc\": \"Returns an array with the number of non-overlapping occurrences of substring \\`sub\\` in the range [\\`start\\`, \\`end\\`].\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsub : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    The substring to search for.\\nstart, end : array_like, with any integer dtype, optional\\n    The range to look in, interpreted as slice notation.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints\",\n}\n-/\n\n/-  numpy.strings.count: Returns an array with the number of non-overlapping occurrences \n    of substring sub in the range [start, end] for each element.\n\n    For each string in the input array, counts how many times the substring appears\n    without overlapping matches within the specified range. The search is performed\n    within the range [start, end) where start and end are character indices.\n-/\n\n/-  Specification: numpy.strings.count returns the number of non-overlapping occurrences \n    of substring within the specified range for each element.\n\n    Preconditions:\n    - start \u2264 end for all elements (valid range)\n    - start and end indices are valid (within string bounds)\n    - substring is not empty for all elements (to avoid infinite loops)\n\n    Postconditions:\n    - Result is non-negative for all elements\n    - For each element, the count represents non-overlapping occurrences of substring\n    - If substring is longer than search range, count is 0\n    - The count is maximal (greedy non-overlapping matching)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def count {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem count_spec {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n)\n    (h_range : \u2200 i : Fin n, start.get i \u2264 endPos.get i) \n    (h_bounds_start : \u2200 i : Fin n, 0 \u2264 start.get i \u2227 start.get i \u2264 (a.get i).length) \n    (h_bounds_end : \u2200 i : Fin n, 0 \u2264 endPos.get i \u2227 endPos.get i \u2264 (a.get i).length) \n    (h_nonempty : \u2200 i : Fin n, sub.get i \u2260 \"\") :\n    \u2983\u231c\u2200 i : Fin n, start.get i \u2264 endPos.get i \u2227 \n                   0 \u2264 start.get i \u2227 start.get i \u2264 (a.get i).length \u2227\n                   0 \u2264 endPos.get i \u2227 endPos.get i \u2264 (a.get i).length \u2227 \n                   sub.get i \u2260 \"\"\u231d\u2984\n    count a sub start endPos\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Result is non-negative\n      result.get i \u2265 0 \u2227\n      -- If substring is empty, count is 0 (handled by precondition)\n      -- If substring is longer than search range, count is 0\n      ((sub.get i).length > Int.natAbs (endPos.get i - start.get i) \u2192 result.get i = 0) \u2227\n      -- The count represents the maximum number of non-overlapping occurrences\n      (\u2203 positions : List Nat,\n        -- All positions are valid and within the specified range\n        (\u2200 p \u2208 positions, \n          Int.natAbs (start.get i) \u2264 p \u2227 \n          p + (sub.get i).length \u2264 Int.natAbs (endPos.get i) \u2227\n          p + (sub.get i).length \u2264 (a.get i).length \u2227\n          -- The substring matches at this position (simplified check)\n          ((a.get i).drop p).take (sub.get i).length = sub.get i) \u2227\n        -- Positions are sorted and non-overlapping\n        (positions.Pairwise (\u00b7 \u2264 \u00b7)) \u2227\n        (\u2200 j k : Nat, j < k \u2192 j < positions.length \u2192 k < positions.length \u2192\n          positions[j]! + (sub.get i).length \u2264 positions[k]!) \u2227\n        -- The result equals the number of positions found\n        result.get i = positions.length \u2227\n        -- This is the maximum possible count (optimality)\n        (\u2200 other_positions : List Nat,\n          (\u2200 p \u2208 other_positions, \n            Int.natAbs (start.get i) \u2264 p \u2227 \n            p + (sub.get i).length \u2264 Int.natAbs (endPos.get i) \u2227\n            p + (sub.get i).length \u2264 (a.get i).length \u2227\n            ((a.get i).drop p).take (sub.get i).length = sub.get i) \u2227\n          (other_positions.Pairwise (\u00b7 \u2264 \u00b7)) \u2227\n          (\u2200 j k : Nat, j < k \u2192 j < other_positions.length \u2192 k < other_positions.length \u2192\n            other_positions[j]! + (sub.get i).length \u2264 other_positions[k]!) \u2192\n          other_positions.length \u2264 positions.length))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_decode", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.decode\",\n  \"category\": \"String encoding\",\n  \"description\": \"Decode byte strings using the codec\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.decode.html\",\n  \"doc\": \"Calls \\`\\`bytes.decode\\`\\` element-wise.\\n\\nParameters\\n----------\\na : array_like, with \\`bytes_\\` dtype\\n    Input byte array\\nencoding : str, optional\\n    The name of an encoding. Default is 'utf-8'\\nerrors : str, optional\\n    Specifies how to handle encoding errors.\\n    Default is 'strict'\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`str_\\` dtype\",\n}\n-/\n\n/-  numpy.strings.decode: Decode byte strings using the codec\n\n    Calls bytes.decode element-wise on a vector of byte strings.\n    Converts bytes to strings using the specified encoding.\n\n    This function takes a vector of byte strings and returns a vector\n    of decoded strings. The decoding process depends on the encoding\n    parameter, with UTF-8 being the default.\n-/\n\n/-  Specification: numpy.strings.decode returns a vector where each element is the decoded string\n    from the corresponding byte array in the input vector.\n\n    Mathematical Properties:\n    1. Element-wise decoding: result[i] = decode(a[i]) for all i\n    2. Deterministic behavior: same input produces same output\n    3. Empty byte arrays decode to empty strings\n    4. Identity property: decoding is consistent with the specified encoding\n    5. Length preservation: decoding preserves structural properties\n    6. Error handling: behavior depends on error mode when invalid sequences are encountered\n\n    Precondition: ByteArray elements are well-formed\n    Postcondition: Each element is the decoded string using the specified encoding with proper error handling\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def decode {n : Nat} (a : Vector ByteArray n) (encoding : String := \"utf-8\") (errors : String := \"strict\") : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem decode_spec {n : Nat} (a : Vector ByteArray n) (encoding : String := \"utf-8\") (errors : String := \"strict\") :\n    \u2983\u231c\u2200 i : Fin n, (a.get i).size \u2265 0\u231d\u2984\n    decode a encoding errors\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n                  -- Basic well-formedness: decoded strings are valid\n                  (result.get i).length \u2265 0 \u2227\n\n                  -- Deterministic behavior: identical inputs produce identical outputs\n                  (\u2200 j : Fin n, a.get i = a.get j \u2192 result.get i = result.get j) \u2227\n\n                  -- Empty byte arrays decode to empty strings\n                  ((a.get i).size = 0 \u2192 result.get i = \"\") \u2227\n\n                  -- Identity property: encoding then decoding with same parameters is identity for valid strings\n                  (encoding = \"utf-8\" \u2192 \u2200 s : String,\n                    (\u2203 ba : ByteArray, ba = s.toUTF8 \u2227 a.get i = ba) \u2192\n                    result.get i = s) \u2227\n\n                  -- Error handling consistency: strict mode fails on invalid sequences\n                  (errors = \"strict\" \u2192\n                    (\u2203 valid_utf8 : Prop, valid_utf8 \u2228 result.get i = \"\")) \u2227\n\n                  -- Length relationship: non-empty valid byte arrays produce strings\n                  ((a.get i).size > 0 \u2227 encoding = \"utf-8\" \u2192\n                    (result.get i).length > 0 \u2228 errors \u2260 \"strict\") \u2227\n\n                  -- Encoding consistency: result depends on encoding parameter\n                  (\u2200 enc1 enc2 : String, enc1 \u2260 enc2 \u2192\n                    decode a enc1 errors \u2260 decode a enc2 errors \u2228\n                    (\u2200 j : Fin n, (a.get j).size = 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_encode", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.encode\",\n  \"category\": \"String encoding\",\n  \"description\": \"Encode strings using the codec\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.encode.html\",\n  \"doc\": \"Calls \\`\\`str.encode\\`\\` element-wise.\\n\\nParameters\\n----------\\na : array_like, with \\`str_\\` or \\`StringDType\\` dtype\\n    Input string array\\nencoding : str, optional\\n    The name of an encoding. Default is 'utf-8'\\nerrors : str, optional\\n    Specifies how to handle encoding errors.\\n    Default is 'strict'\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`bytes_\\` dtype\",\n}\n-/\n\n/-  numpy.strings.encode: Encode strings using the codec\n\n    Calls str.encode element-wise on a vector of strings.\n    Converts strings to byte arrays using the specified encoding.\n\n    This function takes a vector of strings and returns a vector\n    of encoded byte arrays. The encoding process depends on the encoding\n    parameter, with UTF-8 being the default.\n-/\n\n/-  Specification: numpy.strings.encode returns a vector where each element is the encoded byte array\n    from the corresponding string in the input vector.\n\n    Key properties:\n    1. Deterministic encoding: same input produces same output\n    2. Empty strings encode to empty byte arrays\n    3. Encoding preserves string order and length\n    4. For UTF-8 encoding, ASCII characters are preserved with same byte length\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def encode {n : Nat} (a : Vector String n) (encoding : String := \"utf-8\") (errors : String := \"strict\") : Id (Vector ByteArray n) :=\n  sorry", "vc-theorems": "theorem encode_spec {n : Nat} (a : Vector String n) (encoding : String := \"utf-8\") (errors : String := \"strict\") :\n    \u2983\u231cTrue\u231d\u2984\n    encode a encoding errors\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                  -- Deterministic encoding: same input produces same output\n                  (\u2200 j : Fin n, a.get i = a.get j \u2192 result.get i = result.get j) \u2227\n                  -- Empty strings encode to empty byte arrays\n                  (a.get i = \"\" \u2192 (result.get i).size = 0) \u2227\n                  -- Non-empty strings produce non-empty byte arrays\n                  (a.get i \u2260 \"\" \u2192 (result.get i).size > 0) \u2227\n                  -- For UTF-8 encoding, ASCII strings have predictable byte length\n                  (encoding = \"utf-8\" \u2192 \n                    (\u2200 c : Char, c \u2208 (a.get i).toList \u2192 c.toNat < 128) \u2192 \n                      (result.get i).size = (a.get i).length) \u2227\n                  -- Encoding size relationship: encoded size is at least the string length\n                  (encoding = \"utf-8\" \u2192 (result.get i).size \u2265 (a.get i).length)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_endswith", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.endswith\",\n  \"category\": \"String information\",\n  \"description\": \"Returns a boolean array which is True where the string element in a ends with suffix, otherwise False\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.endswith.html\",\n  \"doc\": \"Returns a boolean array which is \\`True\\` where the string element in \\`a\\` ends with \\`suffix\\`, otherwise \\`False\\`.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsuffix : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nstart, end : array_like, with any integer dtype, optional\\n    With optional \\`start\\`, test beginning at that position. With optional \\`end\\`, stop comparing at that position.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  Check if strings in array end with given suffixes -/\n\n/-  Specification: endswith returns boolean array indicating which strings end with corresponding suffixes -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def endswith {n : Nat} (a : Vector String n) (suffix : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem endswith_spec {n : Nat} (a : Vector String n) (suffix : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    endswith a suffix\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      -- Main specification: result matches String.endsWith for each pair\n      (r.get i = (a.get i).endsWith (suffix.get i)) \u2227\n      -- Mathematical property: if result is true, suffix appears at the end\n      (r.get i = true \u2192 \n        (suffix.get i).length \u2264 (a.get i).length \u2227\n        (a.get i).drop ((a.get i).length - (suffix.get i).length) = (suffix.get i)) \u2227\n      -- Mathematical property: if result is false, suffix does not appear at the end\n      (r.get i = false \u2192 \n        (suffix.get i).length > (a.get i).length \u2228\n        (a.get i).drop ((a.get i).length - (suffix.get i).length) \u2260 (suffix.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_equal", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.equal\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return (x1 == x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.equal.html\",\n  \"doc\": \"Return (x1 == x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.equal: Return (x1 == x2) element-wise for string arrays.\n\n    Performs element-wise string comparison between two vectors of strings.\n    Returns a boolean vector indicating whether corresponding strings are equal.\n\n    This function compares strings lexicographically and returns True for each\n    position where the strings are identical, False otherwise.\n-/\n\n/-  Specification: numpy.strings.equal returns element-wise equality comparison.\n\n    Precondition: True (no special preconditions for string equality)\n    Postcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\n    Mathematical Properties:\n    - Core property: Each element of result is the boolean comparison of corresponding strings\n    - Equivalence: result[i] is true if and only if x1[i] equals x2[i]\n    - Reflexivity: If input vectors are identical, all result elements are true\n    - Type-safe: Result vector has same length as input vectors\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def equal {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem equal_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    equal x1 x2\n    \u2983\u21d3result => \u231c-- Core property: result[i] = (x1[i] == x2[i]) for all indices\n                 (\u2200 i : Fin n, result.get i = (x1.get i == x2.get i)) \u2227\n                 -- Equivalence: result[i] is true iff strings are equal\n                 (\u2200 i : Fin n, (result.get i = true \u2194 x1.get i = x2.get i)) \u2227\n                 -- Reflexivity: if inputs are the same, result is all true\n                 (x1 = x2 \u2192 \u2200 i : Fin n, result.get i = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_expandtabs", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.expandtabs\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return a copy of each string element where all tab characters are replaced by spaces\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.expandtabs.html\",\n  \"doc\": \"Return a copy of each string element where all tab characters are replaced by one or more spaces.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\ntabsize : array_like, with any integer dtype, optional\\n    Replace tabs with \\`tabsize\\` number of spaces. Default is 8.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\",\n}\n-/\n\n/-  Expand tabs in strings to spaces with configurable tab size -/\n\n/-  Specification: expandtabs replaces tab characters with appropriate number of spaces -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def expandtabs {n : Nat} (a : Vector String n) (tabsize : Vector Nat n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem expandtabs_spec {n : Nat} (a : Vector String n) (tabsize : Vector Nat n) \n    (h_positive : \u2200 i : Fin n, tabsize.get i > 0) :\n    \u2983\u231c\u2200 i : Fin n, tabsize.get i > 0\u231d\u2984\n    expandtabs a tabsize\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let orig_str := a.get i\n      let result_str := r.get i\n      let tab_sz := tabsize.get i\n      -- Core property: result contains no tab characters\n      (\u2200 c \u2208 result_str.toList, c \u2260 '\\t') \u2227\n      -- Identity property: strings without tabs remain unchanged\n      (orig_str.toList.all (\u00b7 \u2260 '\\t') \u2192 result_str = orig_str) \u2227\n      -- Length property: result is at least as long as original\n      (result_str.length \u2265 orig_str.length) \u2227\n      -- Tab expansion property: tabs are replaced by 1 to tab_sz spaces\n      (orig_str.toList.contains '\\t' \u2192 result_str.length > orig_str.length) \u2227\n      -- Character preservation: non-tab characters appear in same relative order\n      (\u2203 (mapping : Nat \u2192 Nat), \n        (\u2200 j : Nat, j < orig_str.length \u2192 \n          orig_str.toList[j]! \u2260 '\\t' \u2192 \n          mapping j < result_str.length \u2227 \n          result_str.toList[mapping j]! = orig_str.toList[j]!) \u2227\n        (\u2200 j k : Nat, j < k \u2192 k < orig_str.length \u2192 \n          orig_str.toList[j]! \u2260 '\\t' \u2192 orig_str.toList[k]! \u2260 '\\t' \u2192 \n          mapping j < mapping k))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_find", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.find\",\n  \"category\": \"String information\",\n  \"description\": \"For each element, return the lowest index in the string where substring sub is found\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.find.html\",\n  \"doc\": \"For each element, return the lowest index in the string where substring \\`sub\\` is found, such that \\`sub\\` is contained in the range [\\`start\\`, \\`end\\`].\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsub : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nstart, end : array_like, with any integer dtype, optional\\n    The range to look in, interpreted as slice notation.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints. Returns -1 if \\`sub\\` is not found.\",\n}\n-/\n\n/-  For each element, return the lowest index in the string where substring is found -/\n\n/-  Specification: find returns the lowest index where substring is found within range, or -1 if not found -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def find {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem find_spec {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) :\n    \u2983\u231c\u2200 i : Fin n, 0 \u2264 start.get i \u2227 start.get i \u2264 endPos.get i \u2227 endPos.get i < (a.get i).length\u231d\u2984\n    find a sub start endPos\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Case 1: substring not found (returns -1)\n      (result.get i = -1 \u2194 \n        \u2200 pos : Nat, start.get i \u2264 pos \u2227 pos \u2264 endPos.get i \u2227 pos + (sub.get i).length \u2264 (a.get i).length \u2192 \n          \u00ac(((a.get i).drop pos).take (sub.get i).length = sub.get i)) \u2227\n      -- Case 2: substring found (returns non-negative index)\n      (result.get i \u2265 0 \u2192 \n        -- Result is within valid range\n        start.get i \u2264 result.get i \u2227 \n        result.get i \u2264 endPos.get i \u2227\n        result.get i + (sub.get i).length \u2264 (a.get i).length \u2227\n        -- Substring actually found at this position\n        ((a.get i).drop (Int.natAbs (result.get i))).take (sub.get i).length = sub.get i \u2227\n        -- This is the LOWEST index where substring is found (minimality property)\n        (\u2200 pos : Nat, start.get i \u2264 pos \u2227 pos < Int.natAbs (result.get i) \u2192 \n          \u00ac(((a.get i).drop pos).take (sub.get i).length = sub.get i))) \u2227\n      -- Sanity check 1: empty substring is found at start position\n      (sub.get i = \"\" \u2192 result.get i = start.get i) \u2227\n      -- Sanity check 2: substring longer than remaining string cannot be found\n      (start.get i + (sub.get i).length > (a.get i).length \u2192 result.get i = -1) \u2227\n      -- Sanity check 3: if start > end, no substring can be found\n      (start.get i > endPos.get i \u2192 result.get i = -1)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_greater", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.greater\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return the truth value of (x1 > x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.greater.html\",\n  \"doc\": \"Return the truth value of (x1 > x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.greater: Return the truth value of (x1 > x2) element-wise for string arrays.\n\n    Performs element-wise string comparison between two vectors of strings.\n    Returns a boolean vector indicating whether corresponding strings from x1 \n    are lexicographically greater than corresponding strings from x2.\n\n    This function compares strings lexicographically and returns True for each\n    position where x1[i] > x2[i] in lexicographic ordering, False otherwise.\n-/\n\n/-  Specification: numpy.strings.greater returns element-wise lexicographic comparison.\n\n    Precondition: True (no special preconditions for string comparison)\n    Postcondition: For all indices i, result[i] = (x1[i] > x2[i])\n\n    Mathematical Properties:\n    - Asymmetric: if greater x1 x2 is True at position i, then greater x2 x1 is False at position i\n    - Transitive: if greater x1 x2 and greater x2 x3 are both True at position i, then greater x1 x3 is True at position i\n    - Irreflexive: greater x x returns all False (no string is greater than itself)\n    - Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n    - Decidable: String comparison is decidable for all strings\n    - Type-safe: Result vector has same length as input vectors\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def greater {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem greater_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    greater x1 x2\n    \u2983\u21d3result => \u231c-- Core property: result[i] = (x1[i] > x2[i]) for all indices\n                 (\u2200 i : Fin n, result.get i = (x1.get i > x2.get i)) \u2227\n                 -- Asymmetry: if x1[i] > x2[i], then NOT (x2[i] > x1[i])\n                 (\u2200 i : Fin n, result.get i = true \u2192 \u00ac(x2.get i > x1.get i)) \u2227\n                 -- Irreflexivity: no string is greater than itself\n                 (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = false) \u2227\n                 -- Transitivity property (partial): if x1[i] > x2[i] and we have x3, then x1[i] > x3[i] when x3[i] < x2[i]\n                 (\u2200 i : Fin n, result.get i = true \u2192 \u2200 s : String, s < x2.get i \u2192 x1.get i > s) \u2227\n                 -- Decidability: result is always boolean (true or false)\n                 (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_greater_equal", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.greater_equal\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return the truth value of (x1 >= x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.greater_equal.html\",\n  \"doc\": \"Return the truth value of (x1 >= x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.greater_equal: Return the truth value of (x1 >= x2) element-wise for string arrays.\n\n    Performs element-wise string comparison between two vectors of strings.\n    Returns a boolean vector indicating whether each string in x1 is greater than or equal \n    to the corresponding string in x2 using lexicographic ordering.\n\n    This function compares strings lexicographically and returns True for each\n    position where x1[i] >= x2[i], False otherwise.\n\n    Examples:\n    - greater_equal [\"apple\", \"banana\"] [\"apple\", \"banana\"] = [true, true]\n    - greater_equal [\"zebra\", \"apple\"] [\"apple\", \"banana\"] = [true, false]\n    - greater_equal [\"a\", \"bb\"] [\"aa\", \"b\"] = [false, true]\n-/\n\n/-  Specification: numpy.strings.greater_equal returns element-wise greater-than-or-equal comparison.\n\n    This specification captures the mathematical properties of lexicographic string comparison:\n\n    1. Core Property: Each position compares strings lexicographically\n    2. Reflexive Property: Every string is >= itself\n    3. Antisymmetric Property: If s1 >= s2 and s2 >= s1, then s1 = s2\n    4. Transitive Property: If s1 >= s2 and s2 >= s3, then s1 >= s3\n    5. Total Ordering: For any two strings, either s1 >= s2 or s2 >= s1 (or both)\n    6. Consistency: Result is deterministic for same inputs\n\n    Precondition: True (no special preconditions for string comparison)\n    Postcondition: Element-wise lexicographic greater-than-or-equal comparison\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def greater_equal {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem greater_equal_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    greater_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i >= x2.get i) \u2227\n                 -- Reflexive property: every string is >= itself\n                 (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = true) \u2227\n                 -- Antisymmetric property captured through string equality\n                 (\u2200 i : Fin n, x1.get i >= x2.get i \u2192 x2.get i >= x1.get i \u2192 x1.get i = x2.get i) \u2227\n                 -- Deterministic property: same inputs yield same outputs\n                 (\u2200 y1 y2 : Vector String n, y1 = x1 \u2192 y2 = x2 \u2192 \n                  (do let r' \u2190 greater_equal y1 y2; pure r') = (do let r \u2190 greater_equal x1 x2; pure r)) \u2227\n                 -- Empty string properties\n                 (\u2200 i : Fin n, x1.get i = \"\" \u2192 x2.get i = \"\" \u2192 result.get i = true) \u2227\n                 (\u2200 i : Fin n, x1.get i \u2260 \"\" \u2192 x2.get i = \"\" \u2192 result.get i = true)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_index", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.index\",\n  \"category\": \"String information\",\n  \"description\": \"Like find, but raises ValueError when the substring is not found\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.index.html\",\n  \"doc\": \"Like \\`find\\`, but raises \\`ValueError\\` when the substring is not found.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsub : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nstart, end : array_like, with any integer dtype, optional\\n    The range to look in, interpreted as slice notation.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints.\\n\\nRaises\\n------\\nValueError\\n    If substring not found.\",\n}\n-/\n\n/-  For each element, return the lowest index in the string where substring is found.\n    Unlike find, this function requires that the substring be found in each string,\n    ensuring all results are non-negative indices. -/\n\n/-  Specification: index returns the lowest index where substring is found within range.\n    The key difference from find is that index has a stronger precondition:\n    the substring must exist in each string within the specified range. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def index {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem index_spec {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) :\n    \u2983\u231c\u2200 i : Fin n, \n      -- Valid range bounds\n      0 \u2264 start.get i \u2227 start.get i \u2264 endPos.get i \u2227\n      endPos.get i \u2264 (a.get i).length \u2227\n      -- Substring must exist in each string within the range\n      \u2203 j : Nat, (start.get i).toNat \u2264 j \u2227 \n        j + (sub.get i).length \u2264 min (endPos.get i + 1).toNat (a.get i).length \u2227\n        ((a.get i).drop j).take (sub.get i).length = sub.get i\u231d\u2984\n    index a sub start endPos\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Result is always non-negative (no -1 values like find)\n      result.get i \u2265 0 \u2227\n      -- Result is within the valid search range\n      start.get i \u2264 result.get i \u2227 \n      result.get i \u2264 endPos.get i \u2227\n      -- The substring is found at the returned index\n      Int.natAbs (result.get i) + (sub.get i).length \u2264 (a.get i).length \u2227\n      ((a.get i).drop (Int.natAbs (result.get i))).take (sub.get i).length = sub.get i \u2227\n      -- This is the lowest (leftmost) index where substring is found in the range\n      (\u2200 j : Nat, (start.get i).toNat \u2264 j \u2227 j < Int.natAbs (result.get i) \u2192 \n        \u00ac(((a.get i).drop j).take (sub.get i).length = sub.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isalnum", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isalnum\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isalnum.html\",\n  \"doc\": \"Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.isalnum: Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\n\n    For each string in the input vector, this function checks if:\n    1. The string is non-empty (has at least one character)\n    2. All characters in the string are alphanumeric (letters or digits)\n\n    Returns a boolean vector where True indicates the string meets both criteria,\n    and False indicates the string is either empty or contains non-alphanumeric characters.\n\n    This follows the Python str.isalnum() behavior which returns False for empty strings\n    and True only if all characters are alphanumeric.\n-/\n\n/-  Specification: numpy.strings.isalnum returns element-wise alphanumeric check.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = (a[i] is non-empty and all characters in a[i] are alphanumeric)\n\n    Mathematical Properties:\n    - Empty strings return False: \u2200 i, a.get i = \"\" \u2192 result.get i = false\n    - Non-empty alphanumeric strings return True: \u2200 i, a.get i \u2260 \"\" \u2227 (a.get i).all Char.isAlphanum \u2192 result.get i = true\n    - Strings with non-alphanumeric characters return False: \u2200 i, a.get i \u2260 \"\" \u2227 \u00ac((a.get i).all Char.isAlphanum) \u2192 result.get i = false\n    - Single alphanumeric characters return True: \u2200 i, (a.get i).length = 1 \u2227 ((a.get i).get! 0).isAlphanum \u2192 result.get i = true\n\n    The core invariant is that the result is true if and only if the string is non-empty and all characters are alphanumeric.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isalnum {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isalnum_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isalnum a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (a.get i \u2260 \"\" \u2227 (a.get i).all Char.isAlphanum)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isalpha", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isalpha\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isalpha.html\",\n  \"doc\": \"Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.isalpha: Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\n\n    Tests whether all characters in each string are alphabetic letters.\n    A string is considered alphabetic if:\n    1. It contains at least one character\n    2. All characters are alphabetic (a-z, A-Z)\n\n    Empty strings return false.\n    Strings with numbers, symbols, or whitespace return false.\n-/\n\n/-  Specification: numpy.strings.isalpha returns a vector where each element indicates\n    whether the corresponding string element contains only alphabetic characters\n    and has at least one character.\n\n    Key properties:\n    1. Empty strings always return false\n    2. Non-empty strings return true iff all characters are alphabetic\n    3. Alphabetic characters are those satisfying Char.isAlpha (a-z, A-Z)\n    4. Strings with digits, whitespace, or symbols return false\n    5. The function is applied element-wise to each string in the vector\n\n    Mathematical properties:\n    - Monotonicity: removing non-alphabetic characters from a string cannot make isalpha false\n    - Compositionality: isalpha(s) = (s.length > 0) \u2227 (\u2200 c \u2208 s, Char.isAlpha c)\n    - Deterministic: same input always produces same output\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isalpha {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  a.map (fun s => s \u2260 \"\" \u2227 s.toList.all Char.isAlpha)", "vc-theorems": "theorem isalpha_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isalpha a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Core property: result matches the definition\n      result.get i = (a.get i \u2260 \"\" \u2227 (a.get i).toList.all Char.isAlpha) \u2227\n      -- Sanity check: empty strings are always false\n      (a.get i = \"\" \u2192 result.get i = false) \u2227\n      -- Sanity check: non-empty strings are true iff all chars are alphabetic\n      (a.get i \u2260 \"\" \u2192 (result.get i \u2194 (a.get i).toList.all Char.isAlpha)) \u2227\n      -- Mathematical property: if result is true, then string is non-empty\n      (result.get i = true \u2192 a.get i \u2260 \"\") \u2227\n      -- Mathematical property: if result is true, then all chars are alphabetic\n      (result.get i = true \u2192 (a.get i).toList.all Char.isAlpha) \u2227\n      -- Mathematical property: if string has non-alphabetic char, result is false\n      (\u2203 c \u2208 (a.get i).toList, \u00acChar.isAlpha c \u2192 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isdecimal", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isdecimal\",\n  \"category\": \"String information\",\n  \"description\": \"For each element, return True if there are only decimal characters in the element\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isdecimal.html\",\n  \"doc\": \"For each element, return True if there are only decimal characters in the element.\\n\\nDecimal characters include digit characters, and all characters that can be used to form decimal-radix numbers.\\n\\nParameters\\n----------\\na : array_like, with \\`str_\\` or \\`StringDType\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  For each element, return True if there are only decimal characters in the element -/\n\n/-  \nSpecification: isdecimal returns True for each element if all characters in the string \nare decimal characters (including digit characters and all characters that can be used \nto form decimal-radix numbers), and False otherwise.\n\nA decimal character is one that can be used to form decimal-radix numbers. This includes:\n- ASCII digits (0-9)  \n- Unicode decimal characters (e.g., Arabic-Indic digits like U+0660)\n- Does NOT include superscript/subscript digits or other numeric characters\n\nNote: For simplicity, we use c.isDigit which covers decimal characters in most practical cases.\n\nKey properties:\n- Empty strings return False\n- Strings with only decimal characters return True\n- Strings with non-decimal characters return False\n- Mixed decimal/non-decimal characters return False\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isdecimal {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isdecimal_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isdecimal a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        (result.get i = true \u2194 \n            ((a.get i).length > 0 \u2227 \n             \u2200 c : Char, c \u2208 (a.get i).toList \u2192 c.isDigit = true)) \u2227\n        -- Empty string property: empty strings always return false\n        (a.get i = \"\" \u2192 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isdigit", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isdigit\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isdigit.html\",\n  \"doc\": \"Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.isdigit: Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise.\n\n    Tests whether all characters in each string are digits.\n    A string is considered to satisfy isdigit if:\n    1. It contains at least one character (non-empty)\n    2. All characters are digits (0-9)\n\n    Empty strings return false.\n    Strings with any non-digit characters return false.\n    Strings with only digits return true.\n\n    This follows the Python str.isdigit() behavior which returns False for empty strings\n    and True only if all characters are numeric digits.\n-/\n\n/-  Specification: numpy.strings.isdigit returns a vector where each element indicates\n    whether the corresponding string element contains only digits and is non-empty.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = true if and only if:\n    1. The string a[i] is non-empty (not equal to empty string)\n    2. All characters in a[i] are digits (satisfy Char.isDigit)\n\n    Properties:\n    - Empty strings return False\n    - Strings with only numeric characters (0-9) return True\n    - Strings with any non-numeric characters return False\n    - Single digit characters return True\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isdigit {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isdigit_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isdigit a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (a.get i \u2260 \"\" \u2227 (a.get i).all Char.isDigit)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_islower", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.islower\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.islower.html\",\n  \"doc\": \"Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.islower: Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\n\n    Tests whether all cased characters in each string are lowercase.\n    A string is considered to satisfy islower if:\n    1. It contains at least one cased character (letters that have uppercase/lowercase versions)\n    2. All cased characters are lowercase\n    3. Non-cased characters (numbers, symbols, whitespace) are ignored for the check\n\n    Examples:\n    - Empty string \"\" \u2192 false (no cased characters)\n    - \"123\" \u2192 false (no cased characters)\n    - \"abc\" \u2192 true (all lowercase, has cased characters)\n    - \"ABC\" \u2192 false (has uppercase)\n    - \"aBc\" \u2192 false (has uppercase)\n    - \"abc123\" \u2192 true (has lowercase, no uppercase)\n    - \"   \" \u2192 false (no cased characters)\n-/\n\n/-  Specification: numpy.strings.islower returns a vector where each element indicates\n    whether the corresponding string element has all cased characters in lowercase\n    and contains at least one cased character.\n\n    Mathematical Properties:\n    1. A string is considered \"islower\" if it has at least one cased character AND\n       all cased characters are lowercase\n    2. Empty strings return false (no cased characters)\n    3. Strings with only non-cased characters (digits, symbols, whitespace) return false\n    4. Strings with any uppercase letters return false\n    5. Strings with at least one lowercase letter and no uppercase letters return true\n\n    Edge Cases:\n    - Empty string: false (no cased characters)\n    - \"123\": false (no cased characters) \n    - \"abc\": true (all lowercase, has cased characters)\n    - \"ABC\": false (has uppercase)\n    - \"aBc\": false (has uppercase)\n    - \"abc123\": true (has lowercase, no uppercase)\n    - \"   \": false (no cased characters)\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def islower {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem islower_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    islower a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = \n      ((\u2203 c \u2208 (a.get i).toList, c.isAlpha \u2227 c.isLower) \u2227 \n       (\u2200 c \u2208 (a.get i).toList, c.isAlpha \u2192 c.isLower))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isspace", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isspace\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isspace.html\",\n  \"doc\": \"Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.isspace: Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\n\n    Tests whether all characters in each string are whitespace characters.\n    A string is considered whitespace if:\n    1. It contains at least one character (non-empty)\n    2. All characters are whitespace (space, tab, newline, form feed, carriage return, etc.)\n\n    Behavior:\n    - Empty strings return false\n    - Strings with only whitespace characters return true\n    - Strings with any non-whitespace character return false\n\n    Examples:\n    - \" \" (single space) \u2192 true\n    - \"\\t\" (tab) \u2192 true  \n    - \"\\n\" (newline) \u2192 true\n    - \"  \\t\\n  \" (mixed whitespace) \u2192 true\n    - \"\" (empty string) \u2192 false\n    - \"a\" (letter) \u2192 false\n    - \" a \" (space + letter + space) \u2192 false\n-/\n\n/-  Specification: numpy.strings.isspace returns a vector where each element indicates\n    whether the corresponding string element contains only whitespace characters\n    and has at least one character.\n\n    The function performs element-wise whitespace checking with the following properties:\n    1. Empty strings always return false\n    2. Strings with only whitespace characters return true\n    3. Strings with any non-whitespace character return false\n    4. Common whitespace characters include: space, tab, newline, carriage return, etc.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = true if and only if:\n    1. The string a[i] is non-empty\n    2. All characters in a[i] are whitespace characters\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isspace {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isspace_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isspace a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (a.get i \u2260 \"\" \u2227 (a.get i).toList.all fun c => c.isWhitespace) \u2227\n                 -- Sanity check: Empty strings return false\n                 (a.get i = \"\" \u2192 result.get i = false) \u2227\n                 -- Mathematical property: Result is boolean (trivially true but explicit)\n                 (result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_istitle", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.istitle\",\n  \"category\": \"String information\",\n  \"description\": \"Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.istitle.html\",\n  \"doc\": \"Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  numpy.strings.istitle: Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\n\n    A string is considered titlecased if:\n    1. It contains at least one character\n    2. Each word starts with an uppercase letter followed by lowercase letters\n    3. Words are separated by non-alphabetic characters\n    4. There is at least one cased character in the string\n\n    Examples:\n    - \"Title Case\" \u2192 True\n    - \"Numpy Is Great\" \u2192 True  \n    - \"numpy is great\" \u2192 False\n    - \"NUMPY IS GREAT\" \u2192 False\n    - \"\" \u2192 False\n    - \"123\" \u2192 False\n-/\n\n/-  Specification: numpy.strings.istitle returns a vector where each element indicates\n    whether the corresponding string element is titlecased.\n\n    Mathematical properties:\n    1. Empty strings return False\n    2. Strings with no alphabetic characters return False\n    3. Strings where every word starts with uppercase followed by lowercase return True\n    4. Words are defined as sequences of alphabetic characters separated by non-alphabetic characters\n    5. At least one cased character must be present\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Helper function to check if a string is titlecased according to Python's str.istitle() logic -/\ndef isTitlecased (s : String) : Bool :=\n  if s.isEmpty then false\n  else\n    let chars := s.toList\n    let hasCasedChar := chars.any (fun c => c.isUpper || c.isLower)\n    if \u00achasCasedChar then false\n    else\n      let rec checkTitleCase (cs : List Char) (expectUpper : Bool) : Bool :=\n        match cs with\n        | [] => true\n        | c :: rest =>\n          if c.isUpper then\n            if expectUpper then checkTitleCase rest false\n            else false\n          else if c.isLower then\n            if expectUpper then false\n            else checkTitleCase rest false\n          else\n            checkTitleCase rest true\n      checkTitleCase chars true", "vc-helpers": "", "vc-definitions": "def istitle {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem istitle_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    istitle a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = isTitlecased (a.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_isupper", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.isupper\",\n  \"category\": \"String information\",\n  \"description\": \"Return true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isupper.html\",\n  \"doc\": \"Return true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  Checks if all cased characters in each string are uppercase and there is at least one character -/\n\n/-  Specification: isupper returns true for each element if all cased characters \n    in the string are uppercase and there is at least one character, false otherwise.\n    Mathematical properties:\n    1. Empty strings return false\n    2. Strings with no cased characters return false  \n    3. Strings with mixed case return false\n    4. Strings with all cased characters uppercase return true -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def isupper {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem isupper_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    isupper a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n                   let s := a.get i\n                   let chars := s.toList\n                   result.get i = (chars.length > 0 \u2227 \n                                  (\u2203 c \u2208 chars, c.isAlpha) \u2227\n                                  (\u2200 c \u2208 chars, c.isAlpha \u2192 c.isUpper))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_join", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.join\",\n  \"category\": \"String operations\",\n  \"description\": \"Return a string which is the concatenation of the strings in the sequence seq\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.join.html\",\n  \"doc\": \"Return a string which is the concatenation of the strings in the sequence \\`seq\\`.\\n\\nParameters\\n----------\\nsep : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nseq : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.join: Return a string which is the concatenation of the strings in the sequence seq.\n\n    For each pair of separator and sequence, join the elements of the sequence using the separator.\n    This function operates element-wise on vectors, where each element of the result is obtained\n    by joining the corresponding elements of the sequence vector using the corresponding separator.\n\n    The function treats each string in the sequence as a sequence of characters, and joins them\n    with the separator string. For example, join('-', 'abc') produces 'a-b-c'.\n\n    From NumPy documentation:\n    - Parameters: sep (array_like) - Separator string(s), seq (array_like) - Sequence(s) to join\n    - Returns: out (ndarray) - Output array with joined strings\n    - Examples: join('-', 'osd') \u2192 'o-s-d', join(['-', '.'], ['ghc', 'osd']) \u2192 ['g-h-c', 'o.s.d']\n\n    Mathematical Properties:\n    1. Element-wise operation: result[i] = join(sep[i], seq[i])\n    2. Character separation: joins individual characters of each string in seq\n    3. Empty separator handling: join('', s) = s (no separation)\n    4. Empty sequence handling: join(sep, '') = '' (empty result)\n    5. Single character sequences: join(sep, 'a') = 'a' (no separator needed)\n-/\n\n/-  Specification: numpy.strings.join returns a vector where each element is the result\n    of joining the characters of the corresponding sequence element with the separator.\n\n    This function performs element-wise string joining operations. For each index i,\n    it takes the string seq[i], treats it as a sequence of characters, and joins them\n    using sep[i] as the separator.\n\n    Mathematical Properties:\n    1. Element-wise correctness: For each i, result[i] is formed by joining characters\n       of seq[i] with sep[i]\n    2. Character-level operation: Each character in seq[i] is separated by sep[i]\n    3. Empty string handling: join(sep, '') = '' for any separator\n    4. Single character handling: join(sep, 'c') = 'c' (no separator added)\n    5. Multiple character handling: join('-', 'abc') = 'a-b-c'\n    6. Length property: For non-empty strings with length > 1, the result length is\n       original_length + (original_length - 1) * separator_length\n    7. Preservation of empty inputs: Empty strings remain empty regardless of separator\n    8. Character order preservation: Characters appear in the same order as in input\n\n    Sanity checks:\n    - Result vector has same length as input vectors\n    - Empty sequences produce empty results\n    - Single character sequences produce the original character\n    - Multiple character sequences are properly separated\n    - Each result character is either from the original string or the separator\n    - No characters are lost or duplicated (except separators)\n\n    Precondition: True (no special preconditions for string joining)\n    Postcondition: Each result element is the join of characters from the corresponding\n                   sequence element using the corresponding separator, with proper\n                   length and character ordering properties\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def join {n : Nat} (sep seq : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem join_spec {n : Nat} (sep seq : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    join sep seq\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let s := seq.get i\n      let separator := sep.get i\n      let expected_result := if s.length \u2264 1 then s \n                           else String.intercalate separator (s.toList.map String.singleton)\n      -- Core correctness property\n      result.get i = expected_result \u2227\n      -- Length property for non-trivial cases\n      (s.length > 1 \u2192 (result.get i).length = s.length + (s.length - 1) * separator.length) \u2227\n      -- Empty string preservation\n      (s.length = 0 \u2192 result.get i = \"\") \u2227\n      -- Single character preservation  \n      (s.length = 1 \u2192 result.get i = s) \u2227\n      -- Non-empty result for non-empty input\n      (s.length > 0 \u2192 (result.get i).length > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_less", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.less\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return the truth value of (x1 < x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.less.html\",\n  \"doc\": \"Return the truth value of (x1 < x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.less: Return the truth value of (x1 < x2) element-wise for string arrays.\n\n    Performs element-wise string comparison between two vectors of strings.\n    Returns a boolean vector indicating whether corresponding strings from x1 \n    are lexicographically less than corresponding strings from x2.\n\n    This function compares strings lexicographically and returns True for each\n    position where x1[i] < x2[i] in lexicographic ordering, False otherwise.\n-/\n\n/-  Specification: numpy.strings.less returns element-wise lexicographic comparison.\n\n    This function performs element-wise lexicographic comparison between two vectors\n    of strings, returning a boolean vector where each element indicates whether\n    the corresponding element in x1 is lexicographically less than the corresponding\n    element in x2.\n\n    Precondition: True (no special preconditions for string comparison)\n    Postcondition: For all indices i, result[i] = (x1[i] < x2[i])\n\n    Mathematical Properties:\n    - Asymmetric: if less x1 x2 is True at position i, then less x2 x1 is False at position i\n    - Transitive: if less x1 x2 and less x2 x3 are both True at position i, then less x1 x3 is True at position i\n    - Irreflexive: less x x returns all False (no string is less than itself)\n    - Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n    - Decidable: String comparison is decidable for all strings\n    - Type-safe: Result vector has same length as input vectors\n\n    String Comparison Properties:\n    - Empty string is less than any non-empty string\n    - Lexicographic ordering follows dictionary order (case-sensitive)\n    - Comparison is based on Unicode code point values\n    - Preserves strict ordering properties of the underlying string type\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def less {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem less_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    less x1 x2\n    \u2983\u21d3result => \u231c-- Core property: result[i] = (x1[i] < x2[i]) for all indices\n                 (\u2200 i : Fin n, result.get i = (x1.get i < x2.get i)) \u2227\n                 -- Asymmetry: if x1[i] < x2[i], then NOT (x2[i] < x1[i])\n                 (\u2200 i : Fin n, result.get i = true \u2192 \u00ac(x2.get i < x1.get i)) \u2227\n                 -- Irreflexivity: no string is less than itself\n                 (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = false) \u2227\n                 -- Transitivity property: if x1[i] < x2[i] and we have a third string x3[i], transitivity holds\n                 (\u2200 i : Fin n, result.get i = true \u2192 \u2200 s : String, x2.get i < s \u2192 x1.get i < s) \u2227\n                 -- Decidability: result is always boolean (true or false)\n                 (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false) \u2227\n                 -- Empty string property: empty string is less than any non-empty string\n                 (\u2200 i : Fin n, x1.get i = \"\" \u2192 x2.get i \u2260 \"\" \u2192 result.get i = true) \u2227\n                 -- Non-empty string property: non-empty string is not less than empty string\n                 (\u2200 i : Fin n, x1.get i \u2260 \"\" \u2192 x2.get i = \"\" \u2192 result.get i = false) \u2227\n                 -- Length invariant: result has same length as input vectors  \n                 (result.toList.length = n) \u2227\n                 -- Consistency with String's built-in less-than operator\n                 (\u2200 i : Fin n, result.get i = true \u2194 x1.get i < x2.get i) \u2227\n                 -- Prefix property: if s1 is a proper prefix of s2, then s1 < s2\n                 (\u2200 i : Fin n, (x1.get i).isPrefixOf (x2.get i) \u2192 x1.get i \u2260 x2.get i \u2192 result.get i = true) \u2227\n                 -- Strict ordering: if result[i] is true, then x1[i] and x2[i] are different\n                 (\u2200 i : Fin n, result.get i = true \u2192 x1.get i \u2260 x2.get i) \u2227\n                 -- Totality of comparison: for any two strings, exactly one of <, =, > holds\n                 (\u2200 i : Fin n, result.get i = true \u2228 x1.get i = x2.get i \u2228 x2.get i < x1.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_less_equal", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.less_equal\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return the truth value of (x1 <= x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.less_equal.html\",\n  \"doc\": \"Return the truth value of (x1 <= x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.less_equal: Return the truth value of (x1 <= x2) element-wise for string arrays.\n\n    Performs element-wise string comparison between two vectors of strings.\n    Returns a boolean vector indicating whether each string in x1 is lexicographically \n    less than or equal to the corresponding string in x2.\n\n    This function compares strings lexicographically and returns True for each\n    position where x1[i] <= x2[i], False otherwise.\n-/\n\n/-  Specification: numpy.strings.less_equal returns element-wise less-than-or-equal comparison.\n\n    Precondition: True (no special preconditions for string comparison)\n    Postcondition: For all indices i, result[i] = (x1[i] <= x2[i])\n\n    Mathematical Properties:\n    - Reflexive: less_equal x x returns all True (x <= x is always true)\n    - Antisymmetric: if less_equal x y and less_equal y x are both True, then equal x y is True\n    - Transitive: if less_equal x y and less_equal y z are both True, then less_equal x z is True\n    - Total order: for any x, y either less_equal x y or less_equal y x (or both)\n    - Consistency with equality: if x = y, then less_equal x y = True\n    - Decidable: String comparison is decidable for all strings\n    - Type-safe: Result vector has same length as input vectors\n    - Lexicographic ordering: String comparison follows lexicographic ordering\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def less_equal {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem less_equal_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    less_equal x1 x2\n    \u2983\u21d3result => \u231c-- Core property: result[i] = (x1[i] <= x2[i]) for all indices\n                 (\u2200 i : Fin n, result.get i = (x1.get i <= x2.get i)) \u2227\n                 -- Equivalence: result[i] is true iff x1[i] <= x2[i]\n                 (\u2200 i : Fin n, (result.get i = true \u2194 x1.get i <= x2.get i)) \u2227\n                 -- Reflexivity: if inputs are the same, result is all true\n                 (x1 = x2 \u2192 \u2200 i : Fin n, result.get i = true) \u2227\n                 -- Consistency with string equality: if strings are equal, result is true\n                 (\u2200 i : Fin n, x1.get i = x2.get i \u2192 result.get i = true) \u2227\n                 -- Antisymmetry: if x1[i] <= x2[i] and x2[i] <= x1[i], then x1[i] = x2[i]\n                 (\u2200 i : Fin n, (x1.get i <= x2.get i) \u2227 (x2.get i <= x1.get i) \u2192 x1.get i = x2.get i) \u2227\n                 -- Transitivity preservation: consistent with transitive nature of string ordering\n                 (\u2200 i : Fin n, \u2200 z : String, x1.get i <= z \u2227 z <= x2.get i \u2192 x1.get i <= x2.get i) \u2227\n                 -- Decidability: result is always boolean (true or false)\n                 (\u2200 i : Fin n, result.get i = true \u2228 result.get i = false)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_ljust", "vc-description": "/-  numpy.strings.ljust: Return an array with the elements left-justified in a string of length width.\n\n    Left-justifies each string in the input array by padding it with the specified\n    fill character (default is space) to reach the specified width. If the original\n    string is longer than or equal to the width, it remains unchanged.\n\n    Parameters:\n    - a: Input array of strings\n    - width: Target width for each string\n    - fillchar: Character to use for padding (must be exactly one character)\n\n    Returns:\n    - Array where each string is left-justified to the specified width\n-/\n\n/-  Specification: ljust returns a vector where each string is left-justified\n    to the specified width using the given fill character.\n\n    Mathematical Properties:\n    - Length preservation: Result length is max(original_length, width)\n    - Identity: Strings already >= width remain unchanged\n    - Left-justification: Original content preserved as prefix, padding on right\n    - Minimality: No unnecessary padding beyond required width\n    - Fillchar constraint: Padding uses specified fill character\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ljust {n : Nat} (a : Vector String n) (width : Nat) (fillchar : String) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem ljust_spec {n : Nat} (a : Vector String n) (width : Nat) (fillchar : String)\n    (h_fillchar : fillchar.length = 1) :\n    \u2983\u231cfillchar.length = 1\u231d\u2984\n    ljust a width fillchar\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        let orig := a.get i\n        let res := result.get i\n        -- Core mathematical properties of left-justification\n        -- 1. Length invariant: result length is exactly max(orig.length, width)\n        res.length = max orig.length width \u2227\n        -- 2. Identity morphism: strings already >= width are unchanged (f(x) = x when |x| >= w)\n        (orig.length \u2265 width \u2192 res = orig) \u2227\n        -- 3. Padding morphism: strings < width are extended (f(x) = x ++ p when |x| < w)\n        (orig.length < width \u2192 \n            res.length = width \u2227\n            (\u2203 padding : String, res = orig ++ padding \u2227 \n                padding.length = width - orig.length) \u2227\n            -- Left-justification property: original is preserved as prefix\n            res.startsWith orig) \u2227\n        -- 4. Minimality constraint: no over-padding (efficient operation)\n        (orig.length \u2265 width \u2192 res.length = orig.length) \u2227\n        -- 5. Exactness constraint: padding achieves exact width requirement\n        (orig.length < width \u2192 res.length = width) \u2227\n        -- 6. Consistency constraint: all operations preserve the vector structure\n        (orig.length = 0 \u2192 res.length = width)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_lower", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.lower\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return an array with the elements converted to lowercase\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.lower.html\",\n  \"doc\": \"Return an array with the elements of \\`a\\` converted to lowercase.\\n\\nFor byte strings, this method is locale-dependent.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\\n\\nExamples\\n--------\\n>>> np.strings.lower(['HELLO', 'WORLD'])\\narray(['hello', 'world'], dtype='<U5')\",\n}\n-/\n\n/-  numpy.strings.lower: Return an array with the elements converted to lowercase.\n\n    Converts each string element in the input vector to lowercase. This transformation\n    applies to all alphabetic characters while preserving non-alphabetic characters\n    (digits, punctuation, whitespace) unchanged.\n\n    The function preserves the shape of the input array and handles empty strings\n    appropriately by returning them unchanged.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n    - Returns: out (ndarray) - Output array with elements converted to lowercase\n\n    Mathematical Properties:\n    1. Element-wise transformation: result[i] = lower(a[i]) for all i\n    2. Length preservation: result[i].length = a[i].length for all i\n    3. Case transformation: uppercase letters become lowercase, others unchanged\n    4. Idempotent: lower(lower(x)) = lower(x)\n    5. Preserves vector length: result.size = a.size\n-/\n\n/-  Specification: numpy.strings.lower returns a vector where each string element\n    is converted to lowercase.\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element is correctly converted to lowercase\n    2. Length preservation: Each transformed string has the same length as the original\n    3. Case transformation: Uppercase letters become lowercase, others unchanged\n    4. Idempotent property: Applying lower twice gives the same result as applying it once\n    5. Empty string handling: Empty strings remain empty\n    6. Character-level correctness: Each character is correctly transformed\n\n    Precondition: True (no special preconditions for lowercase conversion)\n    Postcondition: For all indices i, result[i] is the lowercase version of a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lower {n : Nat} (a : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem lower_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    lower a\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Fundamental correctness: result matches Lean's built-in toLower\n      (result = original.toLower) \u2227\n      -- Length preservation: result has same length as original\n      (result.length = original.length) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Character-level transformation: each character is correctly converted\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          result.get? \u27e8j\u27e9 = some origChar.toLower) \u2227\n      -- Idempotent property: applying lower twice gives same result as once\n      (result.toLower = result) \u2227\n      -- Case preservation: non-alphabetic characters remain unchanged\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          (\u00acorigChar.isAlpha \u2192 result.get? \u27e8j\u27e9 = some origChar)) \u2227\n      -- Alphabetic transformation: uppercase letters become lowercase\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          (origChar.isUpper \u2192 result.get? \u27e8j\u27e9 = some origChar.toLower))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_lstrip", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.lstrip\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a copy with the leading characters removed\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.lstrip.html\",\n  \"doc\": \"For each element in \\`a\\`, return a copy with the leading characters removed.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nchars : array_like with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    The characters to be removed. If None, whitespace characters are removed.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.lstrip: For each element in a vector, return a copy with the leading characters removed.\n\n    Removes leading characters from each string element in the input vector. The behavior\n    depends on the chars parameter:\n    - If chars is None, whitespace characters are removed from the beginning\n    - If chars is provided, any combination of those characters is removed from the beginning\n\n    The function preserves the shape of the input array and handles empty strings\n    appropriately by returning them unchanged.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n                  chars (optional) - Characters to remove from the beginning\n    - Returns: out (ndarray) - Output array with leading characters removed\n\n    Mathematical Properties:\n    1. Element-wise transformation: result[i] = lstrip(a[i], chars) for all i\n    2. Length preservation or reduction: result[i].length \u2264 a[i].length for all i\n    3. Prefix removal: result[i] is a suffix of a[i] for all i\n    4. Character set removal: only characters in chars are removed from the beginning\n    5. Preserves vector length: result.size = a.size\n-/\n\n/-  Specification: numpy.strings.lstrip returns a vector where each string element\n    has its leading characters removed according to the chars parameter.\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element is correctly processed for leading character removal\n    2. Length preservation or reduction: Each result string is no longer than the original\n    3. Prefix removal: Each result is a suffix of the original string\n    4. Character set stripping: Only characters in chars are removed from the beginning\n    5. Whitespace default: When chars is None, whitespace characters are removed\n    6. Stopping condition: Stripping stops at the first non-matching character\n    7. Empty string handling: Empty strings remain empty\n    8. No middle/end modification: Characters beyond the leading portion are unchanged\n\n    Precondition: True (no special preconditions for lstrip)\n    Postcondition: For all indices i, result[i] is a[i] with leading characters removed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def lstrip {n : Nat} (a : Vector String n) (chars : Option String) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem lstrip_spec {n : Nat} (a : Vector String n) (chars : Option String) :\n    \u2983\u231cTrue\u231d\u2984\n    lstrip a chars\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Fundamental correctness: result matches expected behavior\n      (chars.isNone \u2192 result = original.trimLeft) \u2227\n      -- Length preservation or reduction: result is no longer than original\n      (result.length \u2264 original.length) \u2227\n      -- Suffix property: result is a suffix of original\n      (\u2203 k : Nat, k \u2264 original.length \u2227 result = original.drop k) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Character removal correctness: when chars is provided\n      (chars.isSome \u2192\n        \u2203 k : Nat, k \u2264 original.length \u2227 \n        result = original.drop k \u2227\n        -- All stripped characters are in the chars set\n        (\u2200 j : Nat, j < k \u2192 \n          \u2203 c : Char, original.get? \u27e8j\u27e9 = some c \u2227 c \u2208 chars.get!.toList) \u2227\n        -- The first non-stripped character (if any) is not in chars\n        (k < original.length \u2192 \n          \u2203 c : Char, original.get? \u27e8k\u27e9 = some c \u2227 c \u2209 chars.get!.toList)) \u2227\n      -- Minimal stripping: no more characters should be removed\n      (chars.isSome \u2192 \n        \u2200 k' : Nat, k' < result.length \u2192 \n          \u2203 c : Char, result.get? \u27e8k'\u27e9 = some c \u2227 c \u2209 chars.get!.toList) \u2227\n      -- Idempotent-like property: applying lstrip to result with same chars removes nothing\n      (chars.isSome \u2192 \n        \u2200 c : Char, result.get? \u27e80\u27e9 = some c \u2192 c \u2209 chars.get!.toList)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_mod", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.mod\",\n  \"category\": \"String operations\",\n  \"description\": \"Return (a % i), that is pre-Python 2.6 string formatting (interpolation), element-wise for a pair of array_likes of string objects\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.mod.html\",\n  \"doc\": \"Return (a % i), that is pre-Python 2.6 string formatting (interpolation), element-wise for a pair of array_likes of string objects.\\n\\nFor example, if \\`a = '%.2f hours'\\` and \\`i = 2.5\\`, the result is '2.50 hours'.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\ni : array_like\\n    A single Python object, or a sequence of objects, used for filling in the format string.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.mod: Return (a % i), that is pre-Python 2.6 string formatting \n    (interpolation), element-wise for a pair of array_likes of string objects.\n\n    This function performs string formatting element-wise on vectors of format strings \n    and replacement values. Each element of the result is the formatted string obtained \n    by interpolating the corresponding value into the format string.\n\n    This is equivalent to Python's old-style string formatting using the % operator \n    for each element pair. The function handles various format specifiers like %s, %i, \n    %f, etc., and produces appropriately formatted strings.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Format strings with placeholders\n                  values (array_like) - Values to interpolate into format strings\n    - Returns: out (ndarray) - The formatted strings, element-wise\n\n    Mathematical Properties:\n    1. Element-wise formatting: result[i] = format(a[i], values[i])\n    2. Preserves vector length: result.size = a.size = values.size\n    3. Format correctness: each result follows the format specification\n    4. Type preservation: maintains string type characteristics\n    5. Handles various format specifiers: %s, %i, %f, %d, etc.\n-/\n\n/-  Specification: numpy.strings.mod returns a vector where each element is the \n    result of formatting the corresponding format string with its value.\n\n    Mathematical Properties:\n    1. Identity Property: Format strings without % specifiers remain unchanged\n    2. Substitution Property: Format strings with % specifiers get interpolated\n    3. Empty String Property: Empty format strings produce empty results\n    4. Non-empty Preservation: Non-empty format strings with specifiers produce non-empty results\n    5. Length Monotonicity: Result length is non-negative and preserves structural properties\n    6. Format Preservation: The result maintains the original format structure with substitutions\n\n    Key format specifiers handled:\n    - %s: String representation\n    - %i, %d: Integer formatting\n    - %f: Floating point formatting\n    - %x, %X: Hexadecimal formatting\n    - And other standard format specifiers\n\n    Precondition: True (function handles format string validation internally)\n    Postcondition: For all indices i, result[i] represents the formatted string\n                  where format string a[i] is applied to value values[i], satisfying\n                  the mathematical properties of string formatting operations\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def mod {n : Nat} (a values : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem mod_spec {n : Nat} (a values : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    mod a values\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let format_str := a.get i\n      let value_str := values.get i\n      let formatted := result.get i\n      -- Core mathematical properties of string formatting\n      (formatted.length \u2265 0) \u2227\n      -- Identity property: format strings without format specifiers remain unchanged\n      (\u00acformat_str.contains '%' \u2192 formatted = format_str) \u2227\n      -- Substitution property: format strings with specifiers get interpolated\n      (format_str.contains '%' \u2192 formatted \u2260 format_str \u2228 format_str = \"\") \u2227\n      -- Empty format string property\n      (format_str = \"\" \u2192 formatted = \"\") \u2227\n      -- Non-empty format strings with specifiers produce non-empty results\n      (format_str.contains '%' \u2227 format_str \u2260 \"\" \u2192 formatted.length > 0) \u2227\n      -- Monotonicity: non-empty format strings don't produce empty results unless they were empty\n      (format_str.length > 0 \u2192 formatted.length \u2265 0) \u2227\n      -- Preservation: the result contains the original format structure with substitutions\n      (format_str.contains '%' \u2192 \n        (formatted.length \u2265 format_str.length - 2 \u2228 formatted.length = 0))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_multiply", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.multiply\",\n  \"category\": \"String operations\",\n  \"description\": \"Return (a * i), that is string multiple concatenation, element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.multiply.html\",\n  \"doc\": \"Return (a * i), that is string multiple concatenation, element-wise.\\n\\nValues in \\`i\\` of less than 0 are treated as 0 (which yields an empty string).\\n\\nParameters\\n----------\\na : array_like, with \\`np.bytes_\\` or \\`np.str_\\` dtype\\n    Input array of strings\\ni : array_like, with any integer dtype\\n    Number of times to repeat each string\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of strings\\n\\nExamples\\n--------\\n>>> np.strings.multiply('Hello ', 3)\\narray('Hello Hello Hello ', dtype='<U18')\",\n}\n-/\n\n/-  Return (a * i), that is string multiple concatenation, element-wise.\n    Values in i of less than 0 are treated as 0 (which yields an empty string). -/\n\n/-  Specification: multiply performs element-wise string repetition.\n    Each output string is the corresponding input string repeated the specified number of times.\n    Negative repetition counts produce empty strings. This comprehensive specification\n    captures the core mathematical properties of string multiplication in NumPy. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def repeat_string (s : String) (n : Int) : String :=\n  if n \u2264 0 then \"\" else\n  let rec aux (count : Nat) (acc : String) : String :=\n    if count = 0 then acc\n    else aux (count - 1) (s ++ acc)\n  aux n.natAbs \"\"\n  \ndef multiply {n : Nat} (a : Vector String n) (i : Vector Int n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem multiply_spec {n : Nat} (a : Vector String n) (i : Vector Int n) :\n    \u2983\u231cTrue\u231d\u2984\n    multiply a i\n    \u2983\u21d3result => \u231c-- Core property: Element-wise string repetition\n                 (\u2200 j : Fin n, result.get j = repeat_string (a.get j) (i.get j)) \u2227\n                 -- Zero/negative repetition property: Always yields empty string\n                 (\u2200 j : Fin n, i.get j \u2264 0 \u2192 result.get j = \"\") \u2227\n                 -- Identity property: Multiplying by 1 yields the original string\n                 (\u2200 j : Fin n, i.get j = 1 \u2192 result.get j = a.get j) \u2227\n                 -- Zero property: Multiplying by 0 yields empty string\n                 (\u2200 j : Fin n, i.get j = 0 \u2192 result.get j = \"\") \u2227\n                 -- Empty string property: Empty strings remain empty regardless of repetition\n                 (\u2200 j : Fin n, a.get j = \"\" \u2192 result.get j = \"\")\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_not_equal", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.not_equal\",\n  \"category\": \"String comparison\",\n  \"description\": \"Return (x1 != x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.not_equal.html\",\n  \"doc\": \"Return (x1 != x2) element-wise.\\n\\nFor string arrays, performs element-wise string comparison.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays with string dtype.\\n    If \\`\\`x1.shape != x2.shape\\`\\`, they must be broadcastable to a common\\n    shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless \\`\\`dtype=object\\`\\` is passed.\",\n}\n-/\n\n/-  numpy.strings.not_equal: Return (x1 != x2) element-wise for string arrays.\n\n    Performs element-wise string inequality comparison between two vectors of strings.\n    Returns a boolean vector indicating whether corresponding strings are not equal.\n\n    This function compares strings lexicographically and returns True for each\n    position where the strings are different, False where they are identical.\n-/\n\n/-  Specification: numpy.strings.not_equal returns element-wise inequality comparison.\n\n    Precondition: True (no special preconditions for string inequality)\n    Postcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\n    Mathematical Properties:\n    - Irreflexive: not_equal x x returns all False\n    - Symmetric: not_equal x y = not_equal y x  \n    - Negation of equality: not_equal x y = \u00ac(equal x y)\n    - Decidable: String inequality is decidable for all strings\n    - Type-safe: Result vector has same length as input vectors\n    - Complementary: for any two strings s1 and s2, exactly one of (s1 = s2) or (s1 \u2260 s2) holds\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def not_equal {n : Nat} (x1 x2 : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem not_equal_spec {n : Nat} (x1 x2 : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    not_equal x1 x2\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = (x1.get i \u2260 x2.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_partition", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.partition\",\n  \"category\": \"String operations\",\n  \"description\": \"Partition each element in a around sep\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.partition.html\",\n  \"doc\": \"Partition each element in \\`a\\` around \\`sep\\`.\\n\\nFor each element in \\`a\\`, split the element at the first occurrence of \\`sep\\`, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, the first item of the tuple will contain the whole string, and the second and third ones will be empty strings.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\nsep : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Separator to split each string element in \\`a\\`\\n\\nReturns\\n-------\\nout : 3-tuple of ndarrays\\n    Three arrays of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types, with shapes (1,) + a.shape, (...,)\",\n}\n-/\n\n/-  numpy.strings.partition: Partition each element in a around sep.\n\n    Partitions each string in the input vector at the first occurrence of the separator.\n    Returns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\n    For each element in the input array, splits the element at the first occurrence\n    of the separator, and returns three vectors containing the part before the separator,\n    the separator itself, and the part after the separator. If the separator is not found,\n    the first vector contains the whole string, and the second and third vectors contain\n    empty strings.\n\n    From NumPy documentation:\n    - Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n    - Returns: 3-tuple of ndarrays with StringDType\n\n    Mathematical Properties:\n    1. Partition semantics: For each string s, if sep occurs at position i, then:\n       - before = s[0:i]\n       - separator = sep (if found) or \"\" (if not found)\n       - after = s[i+len(sep):] (if found) or \"\" (if not found)\n    2. Completeness: before ++ separator ++ after = original string (when sep is found)\n    3. First occurrence: Only splits at the first occurrence of sep\n    4. Not found case: If sep not in string, returns (original_string, \"\", \"\")\n    5. Preserves vector length: All three result vectors have the same length as input\n-/\n\n/-  Specification: numpy.strings.partition returns a 3-tuple of vectors where each\n    element is partitioned around the first occurrence of the separator.\n\n    Mathematical Properties:\n    1. Partition correctness: For each index i, the result satisfies partition semantics\n    2. Completeness: When separator is found, concatenation reconstructs original string\n    3. First occurrence: Only the first occurrence of separator is used for partitioning\n    4. Not found case: When separator is not found, returns (original, \"\", \"\")\n    5. Preserves vector length: All result vectors have the same length as input\n    6. Separator consistency: The separator part contains the actual separator or empty string\n\n    Precondition: True (no special preconditions for string partitioning)\n    Postcondition: For all indices i, the partition satisfies the partition semantics\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def partition {n : Nat} (a : Vector String n) (sep : String) : Id (Vector String n \u00d7 Vector String n \u00d7 Vector String n) :=\n  sorry", "vc-theorems": "theorem partition_spec {n : Nat} (a : Vector String n) (sep : String) :\n    \u2983\u231cTrue\u231d\u2984\n    partition a sep\n    \u2983\u21d3result => \u231clet (before, separator, after) := result\n                 \u2200 i : Fin n, \n                   let original := a.get i\n                   let before_i := before.get i\n                   let sep_i := separator.get i\n                   let after_i := after.get i\n                   -- Fundamental partition property: parts reconstruct original string\n                   before_i ++ sep_i ++ after_i = original \u2227\n                   -- Separator correctness: either the separator or empty string\n                   (sep_i = sep \u2228 sep_i = \"\") \u2227\n                   -- Case 1: Separator found - the separator part is exactly the separator\n                   (sep_i = sep \u2192 sep_i = sep) \u2227\n                   -- Case 2: Separator not found - before contains whole string, others empty\n                   (sep_i = \"\" \u2192 after_i = \"\" \u2227 before_i = original) \u2227\n                   -- Length preservation: total length is preserved\n                   original.length = before_i.length + sep_i.length + after_i.length\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_replace", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.replace\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a copy of the string with occurrences of substring old replaced by new\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.replace.html\",\n  \"doc\": \"For each element in `a`, return a copy of the string with occurrences of substring `old` replaced by `new`.\\n\\nParameters\\n----------\\na : array_like, with `StringDType`, `bytes_` or `str_` dtype\\nold : array_like, with `StringDType`, `bytes_` or `str_` dtype\\nnew : array_like, with `StringDType`, `bytes_` or `str_` dtype\\ncount : array_like, with any integer dtype, optional\\n    Maximum number of occurrences to replace. -1 (the default) means replace all occurrences.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of `StringDType`, `bytes_` or `str_` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.replace: For each element in a, return a copy of the string with \n    occurrences of substring old replaced by new.\n\n    Replaces occurrences of the substring 'old' with 'new' in each string element.\n    The replacement is done from left to right, and if count is specified, only\n    the first 'count' occurrences are replaced. If count is -1 or negative,\n    all occurrences are replaced.\n-/\n\n/-  Specification for numpy.strings.replace: Returns a vector where each element is the\n    result of replacing occurrences of old substring with new substring.\n\n    Mathematical Properties:\n    1. Element-wise replacement: Each result element is the original string with replacements\n    2. Count limiting: If count[i] >= 0, at most count[i] replacements are made\n    3. Complete replacement: If count[i] < 0, all occurrences are replaced\n    4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]\n    5. Zero count behavior: If count[i] = 0, no replacements occur\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def replace {n : Nat} (a : Vector String n) (old : Vector String n) (new : Vector String n) (count : Vector Int n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem replace_spec {n : Nat} (a : Vector String n) (old : Vector String n) (new : Vector String n) (count : Vector Int n) :\n    \u2983\u231c\u2200 i : Fin n, count.get i = 0 \u2228 old.get i \u2260 \"\"\u231d\u2984\n    replace a old new count\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Zero count behavior: if count is 0, no replacements occur\n      (count.get i = 0 \u2192 result.get i = a.get i) \u2227\n      -- Identity property: if old doesn't occur, result equals original\n      ((\u2200 pos : Nat, pos + (old.get i).length \u2264 (a.get i).length \u2192 \n        \u00ac(((a.get i).drop pos).take (old.get i).length = old.get i)) \u2192 \n        result.get i = a.get i) \u2227\n      -- Basic replacement property: result contains the transformed string\n      (\u2203 (num_replacements : Nat),\n        -- Number of replacements is bounded by count (if non-negative)\n        (count.get i \u2265 0 \u2192 num_replacements \u2264 Int.natAbs (count.get i)) \u2227\n        -- If count is negative, all possible non-overlapping occurrences are replaced\n        (count.get i < 0 \u2192 \n          \u2203 positions : List Nat,\n            positions.length = num_replacements \u2227\n            (\u2200 p \u2208 positions, \n              p + (old.get i).length \u2264 (a.get i).length \u2227\n              ((a.get i).drop p).take (old.get i).length = old.get i) \u2227\n            -- Positions are sorted and non-overlapping\n            (positions.Pairwise (\u00b7 \u2264 \u00b7)) \u2227\n            (\u2200 j k : Nat, j < k \u2192 j < positions.length \u2192 k < positions.length \u2192\n              positions[j]! + (old.get i).length \u2264 positions[k]!)) \u2227\n        -- If count is non-negative, we replace min(count, total_occurrences)\n        (count.get i \u2265 0 \u2192 \n          \u2203 total_occurrences : Nat,\n            num_replacements = min (Int.natAbs (count.get i)) total_occurrences \u2227\n            (\u2203 positions : List Nat,\n              positions.length = total_occurrences \u2227\n              (\u2200 p \u2208 positions, \n                p + (old.get i).length \u2264 (a.get i).length \u2227\n                ((a.get i).drop p).take (old.get i).length = old.get i) \u2227\n              -- Positions are sorted and non-overlapping\n              (positions.Pairwise (\u00b7 \u2264 \u00b7)) \u2227\n              (\u2200 j k : Nat, j < k \u2192 j < positions.length \u2192 k < positions.length \u2192\n                positions[j]! + (old.get i).length \u2264 positions[k]!))))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rfind", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rfind\",\n  \"category\": \"String information\",\n  \"description\": \"For each element, return the highest index in the string where substring sub is found, such that sub is contained within [start, end]\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rfind.html\",\n  \"doc\": \"For each element, return the highest index in the string where substring \\`sub\\` is found, such that \\`sub\\` is contained within [\\`start\\`, \\`end\\`].\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsub : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    The substring to search for.\\nstart, end : array_like, with any integer dtype, optional\\n    The range to look in, interpreted as slice notation.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints. Returns -1 if \\`sub\\` is not found.\",\n}\n-/\n\n/-  For each element, return the highest index in the string where substring is found -/\n\n/-  Specification: rfind returns the highest index where substring is found within range, or -1 if not found -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rfind {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem rfind_spec {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) :\n    \u2983\u231c\u2200 i : Fin n, 0 \u2264 start.get i \u2227 start.get i \u2264 endPos.get i\u231d\u2984\n    rfind a sub start endPos\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Basic range constraint: result is -1 or within string bounds\n      (result.get i = -1 \u2228 (0 \u2264 result.get i \u2227 result.get i < (a.get i).length)) \u2227\n      -- If result is -1, no occurrence of substring within the specified range\n      (result.get i = -1 \u2192 \n        \u2200 j : Nat, start.get i \u2264 j \u2227 j + (sub.get i).length \u2264 Int.natAbs (endPos.get i) + 1 \u2227 \n                   j + (sub.get i).length \u2264 (a.get i).length \u2192 \n          \u00acString.startsWith ((a.get i).drop j) (sub.get i)) \u2227\n      -- If result is non-negative, it's the rightmost valid occurrence\n      (result.get i \u2265 0 \u2192 \n        -- The result is within the search range\n        start.get i \u2264 result.get i \u2227 \n        result.get i + (sub.get i).length \u2264 endPos.get i + 1 \u2227\n        -- The substring matches at this position\n        String.startsWith ((a.get i).drop (Int.natAbs (result.get i))) (sub.get i) \u2227\n        -- This is the rightmost occurrence within the range\n        (\u2200 j : Int, result.get i < j \u2227 j + (sub.get i).length \u2264 endPos.get i + 1 \u2227 \n                    start.get i \u2264 j \u2227 j + (sub.get i).length \u2264 (a.get i).length \u2192 \n          \u00acString.startsWith ((a.get i).drop (Int.natAbs j)) (sub.get i)))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rindex", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rindex\",\n  \"category\": \"String information\",\n  \"description\": \"Like rfind, but raises ValueError when the substring is not found\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rindex.html\",\n  \"doc\": \"Like \\`rfind\\`, but raises \\`ValueError\\` when the substring is not found.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsub : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nstart, end : array_like, with any integer dtype, optional\\n    The range to look in, interpreted as slice notation.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints.\\n\\nRaises\\n------\\nValueError\\n    If substring not found.\",\n}\n-/\n\n/-  For each element, return the highest index in the string where substring is found.\n    Unlike rfind, this function requires that the substring be found in each string,\n    ensuring all results are non-negative indices. -/\n\n/-  Specification: rindex returns the highest index where substring is found within range.\n    The key difference from rfind is that rindex has a stronger precondition:\n    the substring must exist in each string within the specified range. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rindex {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) : Id (Vector Int n) :=\n  sorry", "vc-theorems": "theorem rindex_spec {n : Nat} (a : Vector String n) (sub : Vector String n) (start : Vector Int n) (endPos : Vector Int n) :\n    \u2983\u231c\u2200 i : Fin n, \n      -- Valid range bounds\n      0 \u2264 start.get i \u2227 start.get i \u2264 endPos.get i \u2227\n      endPos.get i \u2264 (a.get i).length \u2227\n      -- Substring must exist in each string within the range (precondition for rindex)\n      \u2203 j : Nat, (start.get i).toNat \u2264 j \u2227 \n        j + (sub.get i).length \u2264 min (endPos.get i + 1).toNat (a.get i).length \u2227\n        ((a.get i).drop j).take (sub.get i).length = sub.get i\u231d\u2984\n    rindex a sub start endPos\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      -- Result is always non-negative (no -1 values like rfind)\n      result.get i \u2265 0 \u2227\n      -- Result is within the valid search range\n      start.get i \u2264 result.get i \u2227 \n      result.get i \u2264 endPos.get i \u2227\n      -- The substring is found at the returned index\n      Int.natAbs (result.get i) + (sub.get i).length \u2264 (a.get i).length \u2227\n      ((a.get i).drop (Int.natAbs (result.get i))).take (sub.get i).length = sub.get i \u2227\n      -- This is the highest (rightmost) index where substring is found in the range\n      (\u2200 j : Nat, Int.natAbs (result.get i) < j \u2227 j + (sub.get i).length \u2264 min (endPos.get i + 1).toNat (a.get i).length \u2192 \n        \u00ac(((a.get i).drop j).take (sub.get i).length = sub.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rjust", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rjust\",\n  \"category\": \"String operations\",\n  \"description\": \"Return an array with the elements of a right-justified in a string of length width\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rjust.html\",\n  \"doc\": \"Return an array with the elements of \\`a\\` right-justified in a string of length \\`width\\`.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nwidth : array_like, with any integer dtype\\n    The length of the resulting strings, unless \\`\\`width < str_len(a)\\`\\`.\\nfillchar : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    The character to use for padding. Default is space.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.rjust: Return an array with the elements of a right-justified in a string of length width.\n\n    Right-justifies each string in the input array by padding it with the specified\n    fill character (default is space) to reach the specified width. If the original\n    string is longer than or equal to the width, it remains unchanged.\n\n    Parameters:\n    - a: Input array of strings\n    - width: Target width for each string\n    - fillchar: Character to use for padding (must be exactly one character)\n\n    Returns:\n    - Array where each string is right-justified to the specified width\n\n    Mathematical Properties:\n    1. Length preservation: If original.length >= width, return original unchanged\n    2. Right-justification: If original.length < width, pad on the left with fillchar\n    3. Padding placement: Original string appears as suffix in the result\n    4. Character preservation: Original string appears as contiguous substring\n    5. Width compliance: Result length equals max(original.length, width)\n-/\n\n/-  Specification: rjust returns a vector where each string is right-justified\n    to the specified width using the given fill character.\n\n    Mathematical Properties:\n    - Length preservation: Result length is max(original_length, width)\n    - Identity: Strings already >= width remain unchanged\n    - Right-justification: Original content preserved as suffix, padding on left\n    - Minimality: No unnecessary padding beyond required width\n    - Fillchar constraint: Padding uses specified fill character\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rjust {n : Nat} (a : Vector String n) (width : Nat) (fillchar : String) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem rjust_spec {n : Nat} (a : Vector String n) (width : Nat) (fillchar : String)\n    (h_fillchar : fillchar.length = 1) :\n    \u2983\u231cfillchar.length = 1\u231d\u2984\n    rjust a width fillchar\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n        let orig := a.get i\n        let res := result.get i\n        -- Core mathematical properties of right-justification\n        -- 1. Length invariant: result length is exactly max(orig.length, width)\n        res.length = max orig.length width \u2227\n        -- 2. Identity morphism: strings already >= width are unchanged (f(x) = x when |x| >= w)\n        (orig.length \u2265 width \u2192 res = orig) \u2227\n        -- 3. Padding morphism: strings < width are extended (f(x) = p ++ x when |x| < w)\n        (orig.length < width \u2192 \n            res.length = width \u2227\n            (\u2203 padding : String, res = padding ++ orig \u2227 \n                padding.length = width - orig.length) \u2227\n            -- Right-justification property: original is preserved as suffix\n            res.endsWith orig) \u2227\n        -- 4. Minimality constraint: no over-padding (efficient operation)\n        (orig.length \u2265 width \u2192 res.length = orig.length) \u2227\n        -- 5. Exactness constraint: padding achieves exact width requirement\n        (orig.length < width \u2192 res.length = width) \u2227\n        -- 6. Consistency constraint: all operations preserve the vector structure\n        (orig.length = 0 \u2192 res.length = width)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rpartition", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rpartition\",\n  \"category\": \"String operations\",\n  \"description\": \"Partition each element in a around the right-most separator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rpartition.html\",\n  \"doc\": \"Partition (split) each element around the right-most separator.\\n\\nFor each element in `a`, split the element at the last occurrence of `sep`, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, the third item of the tuple will contain the whole string, and the first and second ones will be empty strings.\\n\\nParameters\\n----------\\na : array_like, with `StringDType`, `bytes_` or `str_` dtype\\n    Input array\\nsep : array_like, with `StringDType`, `bytes_` or `str_` dtype\\n    Right-most separator to split each string element in `a`\\n\\nReturns\\n-------\\nout : 3-tuple of ndarrays\\n    Three arrays of `StringDType`, `bytes_` or `str_` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.rpartition: Partition each element in a around the right-most separator.\n\n    Partitions each string in the input vector at the last occurrence of the separator.\n    Returns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\n    For each element in the input array, splits the element at the last occurrence\n    of the separator, and returns three vectors containing the part before the separator,\n    the separator itself, and the part after the separator. If the separator is not found,\n    the third vector contains the whole string, and the first and second vectors contain\n    empty strings.\n\n    From NumPy documentation:\n    - Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n    - Returns: 3-tuple of ndarrays with StringDType\n\n    Mathematical Properties:\n    1. Right partition semantics: For each string s, if sep occurs at position i (rightmost), then:\n       - before = s[0:i]\n       - separator = sep (if found) or \"\" (if not found)\n       - after = s[i+len(sep):] (if found) or \"\" (if not found)\n    2. Completeness: before ++ separator ++ after = original string (when sep is found)\n    3. Last occurrence: Only splits at the last occurrence of sep\n    4. Not found case: If sep not in string, returns (\"\", \"\", original_string)\n    5. Preserves vector length: All three result vectors have the same length as input\n-/\n\n/-  Specification: numpy.strings.rpartition returns a 3-tuple of vectors where each\n    element is partitioned around the last occurrence of the separator.\n\n    Mathematical Properties:\n    1. Right partition correctness: For each index i, the result satisfies rpartition semantics\n    2. Completeness: When separator is found, concatenation reconstructs original string\n    3. Last occurrence: Only the last occurrence of separator is used for partitioning\n    4. Not found case: When separator is not found, returns (\"\", \"\", original)\n    5. Preserves vector length: All result vectors have the same length as input\n    6. Separator consistency: The separator part contains the actual separator or empty string\n\n    Precondition: True (no special preconditions for string partitioning)\n    Postcondition: For all indices i, the partition satisfies the rpartition semantics\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rpartition {n : Nat} (a : Vector String n) (sep : String) : Id (Vector String n \u00d7 Vector String n \u00d7 Vector String n) :=\n  sorry", "vc-theorems": "theorem rpartition_spec {n : Nat} (a : Vector String n) (sep : String) :\n    \u2983\u231cTrue\u231d\u2984\n    rpartition a sep\n    \u2983\u21d3result => \u231clet (before, separator, after) := result\n                 \u2200 i : Fin n, \n                   let original := a.get i\n                   let before_i := before.get i\n                   let sep_i := separator.get i\n                   let after_i := after.get i\n                   -- Partition property: reconstructs original string\n                   before_i ++ sep_i ++ after_i = original \u2227\n                   -- Separator correctness: either the separator or empty string\n                   (sep_i = sep \u2228 sep_i = \"\") \u2227\n                   -- If separator is found, the separator part matches\n                   (sep_i = sep \u2192 sep_i = sep) \u2227\n                   -- If separator is not found, first two parts are empty and after contains whole string\n                   (sep_i = \"\" \u2192 before_i = \"\" \u2227 after_i = original)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rsplit", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rsplit\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a list of the words in the string, using sep as the delimiter string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rsplit.html\",\n  \"doc\": \"For each element in \\`a\\`, return a list of the words in the string, using \\`sep\\` as the delimiter string.\\n\\nSplits from the right.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsep : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    If \\`sep\\` is not specified or None, any whitespace string is a separator.\\nmaxsplit : array_like, with any integer dtype, optional\\n    If \\`maxsplit\\` is given, at most \\`maxsplit\\` splits are done.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of objects\",\n}\n-/\n\n/-  For each element in a vector, return a list of the words in the string, using sep as the delimiter string.\n    Splits from the right, meaning that splits are made from the right side of the string. -/\n\n/-  Specification: rsplit splits each string in the vector from the right using the given separator.\n    The resulting vector contains lists of strings where each list represents the split parts\n    of the corresponding input string. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rsplit {n : Nat} (a : Vector String n) (sep : String) (maxsplit : Nat) : Id (Vector (List String) n) :=\n  sorry", "vc-theorems": "theorem rsplit_spec {n : Nat} (a : Vector String n) (sep : String) (maxsplit : Nat) :\n    \u2983\u231csep \u2260 \"\"\u231d\u2984 \n    rsplit a sep maxsplit\n    \u2983\u21d3result => \u231c\n      -- Each element in result corresponds to an element in input a\n      (\u2200 i : Fin n, (result.get i).length > 0) \u2227\n      -- When maxsplit is 0, no splitting occurs\n      (maxsplit = 0 \u2192 \u2200 i : Fin n, result.get i = [a.get i]) \u2227\n      -- The number of splits is at most maxsplit for each string\n      (\u2200 i : Fin n, (result.get i).length \u2264 maxsplit + 1) \u2227\n      -- When joined back together with separator, we get the original string\n      (\u2200 i : Fin n, maxsplit = 0 \u2192 String.intercalate sep (result.get i) = a.get i) \u2227\n      -- If separator doesn't exist in string, result is single element list\n      (\u2200 i : Fin n, (a.get i).splitOn sep = [a.get i] \u2192 result.get i = [a.get i]) \u2227\n      -- Empty strings split to empty list or single empty string\n      (\u2200 i : Fin n, a.get i = \"\" \u2192 result.get i = [\"\"]) \u2227\n      -- The split respects the right-to-left order (last occurrences split first)\n      (\u2200 i : Fin n, \u2200 parts : List String, result.get i = parts \u2192 \n        parts.length > 1 \u2192 \n        String.intercalate sep parts = a.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_rstrip", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.rstrip\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a copy with the trailing characters removed\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.rstrip.html\",\n  \"doc\": \"For each element in \\`a\\`, return a copy with the trailing characters removed.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nchars : array_like with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    The characters to be removed. If None, whitespace characters are removed.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  For each element in a vector, return a copy with the trailing characters removed. -/\n\n/-  Specification: numpy.strings.rstrip removes trailing characters from each string in the vector.\n\n    rstrip removes trailing characters from the end of each string. If chars is None, \n    whitespace characters are removed. If chars is provided, any combination of those \n    characters is removed from the end.\n\n    Mathematical Properties:\n    1. Element-wise transformation: Each string is processed independently\n    2. Trailing character removal: Only characters at the end are removed\n    3. Maximal stripping: Remove as many trailing characters as possible\n    4. Character set filtering: Only characters in the specified set are removed\n    5. Whitespace default: When chars is None, whitespace characters are removed\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n                  chars (optional) - Characters to remove, whitespace if None\n    - Returns: out (ndarray) - Output array with trailing characters removed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def rstrip {n : Nat} (a : Vector String n) (chars : Option String) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem rstrip_spec {n : Nat} (a : Vector String n) (chars : Option String) :\n    \u2983\u231cTrue\u231d\u2984\n    rstrip a chars\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let stripped := result.get i\n      -- Case 1: When chars is None, use trimRight (removes whitespace)\n      (chars.isNone \u2192 stripped = original.trimRight) \u2227\n      -- Case 2: When chars is provided, remove characters from that set\n      (chars.isSome \u2192 \n        \u2203 suffix : String, \n          -- The result is the original string with the suffix removed\n          (original = stripped ++ suffix) \u2227\n          -- The suffix consists only of characters from the chars set\n          (\u2200 c : Char, c \u2208 suffix.toList \u2192 c \u2208 chars.get!.toList) \u2227\n          -- Maximal stripping: result doesn't end with any character from chars set\n          (stripped = \"\" \u2228 \n           \u2200 c : Char, c \u2208 chars.get!.toList \u2192 \n             stripped.back \u2260 c) \u2227\n          -- Length constraint: result is never longer than original\n          (stripped.length \u2264 original.length))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_split", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.split\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a list of the words in the string, using sep as the delimiter string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.split.html\",\n  \"doc\": \"For each element in \\`a\\`, return a list of the words in the string, using \\`sep\\` as the delimiter string.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nsep : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    If \\`sep\\` is not specified or None, any whitespace string is a separator.\\nmaxsplit : array_like, with any integer dtype, optional\\n    If \\`maxsplit\\` is given, at most \\`maxsplit\\` splits are done.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of objects\",\n}\n-/\n\n/-  For each element in a vector of strings, return a list of the words in the string, using sep as the delimiter string -/\n\n/-  Specification: split returns a vector where each string is split into a list of substrings \n    based on the separator, with proper handling of maxsplit constraints and reconstruction properties -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def split {n : Nat} (a : Vector String n) (sep : String) (maxsplit : Option Nat) : Id (Vector (List String) n) :=\n  sorry", "vc-theorems": "theorem split_spec {n : Nat} (a : Vector String n) (sep : String) (maxsplit : Option Nat) \n    (h_sep_nonempty : sep \u2260 \"\") :\n    \u2983\u231csep \u2260 \"\"\u231d\u2984\n    split a sep maxsplit\n    \u2983\u21d3result => \u231c\n      \u2200 i : Fin n, \n        let parts := result.get i\n        let original := a.get i\n        -- Basic correctness: none of the parts equal the separator\n        (\u2200 part \u2208 parts, part \u2260 sep) \u2227\n        -- If maxsplit is specified, respect the limit\n        (match maxsplit with\n         | none => True\n         | some limit => parts.length \u2264 limit + 1) \u2227\n        -- The result is non-empty (at least contains the original string if no splits)\n        parts.length \u2265 1 \u2227\n        -- If original is empty, return empty string as single element\n        (original.isEmpty \u2192 parts = [\"\"]) \u2227\n        -- If original equals separator, return empty parts\n        (original = sep \u2192 parts = [\"\", \"\"]) \u2227\n        -- The parts when joined with separator should reconstruct the original (up to maxsplit)\n        (match maxsplit with\n         | none => String.intercalate sep parts = original\n         | some limit => \n           if parts.length \u2264 limit + 1 then\n             String.intercalate sep parts = original\n           else\n             -- When maxsplit is reached, last part contains remaining string\n             parts.length = limit + 1 \u2227 \n             String.intercalate sep (parts.take limit) ++ sep ++ (parts.get \u27e8limit, by sorry\u27e9) = original)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_splitlines", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.splitlines\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a list of the lines in the element, breaking at line boundaries\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.splitlines.html\",\n  \"doc\": \"For each element in \\`a\\`, return a list of the lines in the element, breaking at line boundaries.\\n\\nLine breaks are not included in the resulting list unless keepends is given and true.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nkeepends : bool, optional\\n    Line breaks are not included in the resulting list unless keepends is given and true.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of objects\",\n}\n-/\n\n/-  For each element in a vector of strings, return a list of the lines in the element, breaking at line boundaries -/\n\n/-  Specification: splitlines returns a vector where each string is split into a list of lines\n    based on line boundaries, with proper handling of keepends and line break characters -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def splitlines {n : Nat} (a : Vector String n) (keepends : Bool) : Id (Vector (List String) n) :=\n  sorry", "vc-theorems": "theorem splitlines_spec {n : Nat} (a : Vector String n) (keepends : Bool) :\n    \u2983\u231cTrue\u231d\u2984\n    splitlines a keepends\n    \u2983\u21d3result => \u231c\n      \u2200 i : Fin n, \n        let lines := result.get i\n        let original := a.get i\n        -- The result is always non-empty (at least contains one element)\n        lines.length \u2265 1 \u2227\n        -- If original is empty, return empty string as single element\n        (original.isEmpty \u2192 lines = [\"\"]) \u2227\n        -- If original has no line breaks, return original as single element\n        (\u00acoriginal.contains '\\n' \u2227 \u00acoriginal.contains '\\r' \u2192 lines = [original]) \u2227\n        -- If keepends is false, no line in result contains line break characters\n        (\u00ackeepends \u2192 \u2200 line \u2208 lines, \u00acline.contains '\\n' \u2227 \u00acline.contains '\\r') \u2227\n        -- If keepends is false, no line endings in result\n        (\u00ackeepends \u2192 \u2200 line \u2208 lines, \u00acline.endsWith \"\\n\" \u2227 \u00acline.endsWith \"\\r\" \u2227 \u00acline.endsWith \"\\r\\n\") \u2227\n        -- If keepends is true, only the last line may lack line ending\n        (keepends \u2192 \u2200 j : Fin lines.length, j.val < lines.length - 1 \u2192 \n          let line := lines.get j\n          line.endsWith \"\\n\" \u2228 line.endsWith \"\\r\" \u2228 line.endsWith \"\\r\\n\") \u2227\n        -- Basic reconstruction property: joining with newlines gives back normalized original\n        (\u00ackeepends \u2192 String.intercalate \"\\n\" lines = (original.replace \"\\r\\n\" \"\\n\").replace \"\\r\" \"\\n\") \u2227\n        -- Line count property: lines should be related to line break count\n        (\u00acoriginal.contains '\\n' \u2227 \u00acoriginal.contains '\\r' \u2192 lines.length = 1) \u2227\n        -- Empty string property\n        (original = \"\" \u2192 lines = [\"\"]) \u2227\n        -- Single newline property\n        (original = \"\\n\" \u2192 (if keepends then lines = [\"\\n\"] else lines = [\"\", \"\"]))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_startswith", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.startswith\",\n  \"category\": \"String information\",\n  \"description\": \"Returns a boolean array which is True where the string element in a starts with prefix, otherwise False\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.startswith.html\",\n  \"doc\": \"Returns a boolean array which is \\`True\\` where the string element in \\`a\\` starts with \\`prefix\\`, otherwise \\`False\\`.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nprefix : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nstart, end : array_like, with any integer dtype, optional\\n    With optional \\`start\\`, test beginning at that position. With optional \\`end\\`, stop comparing at that position.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n}\n-/\n\n/-  Check if strings in array start with given prefixes -/\n\n/-  Specification: startswith returns boolean array indicating which strings start with corresponding prefixes -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def startswith {n : Nat} (a : Vector String n) (prefixes : Vector String n) : Id (Vector Bool n) :=\n  sorry", "vc-theorems": "theorem startswith_spec {n : Nat} (a : Vector String n) (prefixes : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    startswith a prefixes\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      -- Main specification: result matches String.startsWith for each pair\n      (r.get i = (a.get i).startsWith (prefixes.get i)) \u2227\n      -- Mathematical property: if result is true, prefix appears at the beginning\n      (r.get i = true \u2192 \n        (prefixes.get i).length \u2264 (a.get i).length \u2227\n        (a.get i).take (prefixes.get i).length = (prefixes.get i)) \u2227\n      -- Mathematical property: if result is false, prefix does not appear at the beginning\n      (r.get i = false \u2192 \n        (prefixes.get i).length > (a.get i).length \u2228\n        (a.get i).take (prefixes.get i).length \u2260 (prefixes.get i))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_str_len", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.str_len\",\n  \"category\": \"String information\",\n  \"description\": \"Returns the length of each element\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.str_len.html\",\n  \"doc\": \"Returns the length of each element.\\n\\nFor byte strings, this is the number of bytes. For Unicode strings, this is the number of Unicode code points.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of ints\",\n}\n-/\n\n/-  Returns the length of each string element in the vector.\n    For Unicode strings, this counts the number of Unicode code points. -/\n\n/-  Specification: str_len returns the length (number of Unicode code points) of each string element.\n\n    Preconditions: None (str_len is defined for all strings)\n\n    Postconditions:\n    - The result vector has the same size as the input vector\n    - Each element in the result corresponds to the length of the corresponding input string\n    - Length is always non-negative (natural number)\n    - Empty strings have length 0\n    - Length is measured in Unicode code points for Unicode strings\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def str_len {n : Nat} (a : Vector String n) : Id (Vector Nat n) :=\n  sorry", "vc-theorems": "theorem str_len_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    str_len a\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Basic correctness: result contains the length of each string\n      result.get i = (a.get i).length \u2227\n      -- Non-negativity: lengths are always non-negative (natural numbers)\n      result.get i \u2265 0 \u2227\n      -- Empty string property: empty strings have length 0\n      (a.get i = \"\" \u2194 result.get i = 0) \u2227\n      -- Single character property: single characters have length 1\n      (a.get i \u2260 \"\" \u2227 (a.get i).drop 1 = \"\" \u2192 result.get i = 1) \u2227\n      -- Monotonicity property: longer strings have lengths \u2265 shorter prefixes\n      (\u2200 k : Nat, k \u2264 (a.get i).length \u2192 \n        ((a.get i).take k).length \u2264 result.get i) \u2227\n      -- Deterministic property: same string always gives same length\n      (\u2200 j : Fin n, a.get i = a.get j \u2192 result.get i = result.get j) \u2227\n      -- Concatenation property: length is additive for concatenation\n      (\u2200 s1 s2 : String, a.get i = s1 ++ s2 \u2192 \n        result.get i = s1.length + s2.length)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_strip", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.strip\",\n  \"category\": \"String operations\",\n  \"description\": \"For each element in a, return a copy with the leading and trailing characters removed\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.strip.html\",\n  \"doc\": \"For each element in \\`a\\`, return a copy with the leading and trailing characters removed.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nchars : array_like with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype, optional\\n    The characters to be removed. If None, whitespace characters are removed.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input types\",\n}\n-/\n\n/-  numpy.strings.strip: For each element in a vector, return a copy with the leading and trailing characters removed.\n\n    Removes both leading and trailing characters from each string element in the input vector.\n    This is a combination of lstrip and rstrip operations. The behavior depends on the chars parameter:\n    - If chars is None, whitespace characters are removed from both ends\n    - If chars is provided, any combination of those characters is removed from both ends\n\n    The function preserves the shape of the input array and handles empty strings\n    appropriately by returning them unchanged.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n                  chars (optional) - Characters to remove from both ends\n    - Returns: out (ndarray) - Output array with leading and trailing characters removed\n\n    Mathematical Properties:\n    1. Element-wise transformation: result[i] = strip(a[i], chars) for all i\n    2. Length preservation or reduction: result[i].length \u2264 a[i].length for all i\n    3. Substring property: result[i] is a substring of a[i] for all i\n    4. Character set removal: only characters in chars are removed from both ends\n    5. Preserves vector length: result.size = a.size\n    6. Combination of lstrip and rstrip: strip(s) = rstrip(lstrip(s))\n-/\n\n/-  Specification: numpy.strings.strip returns a vector where each string element\n    has its leading and trailing characters removed according to the chars parameter.\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element is correctly processed for both leading and trailing character removal\n    2. Length preservation or reduction: Each result string is no longer than the original\n    3. Substring property: Each result is a substring of the original string\n    4. Character set stripping: Only characters in chars are removed from both ends\n    5. Whitespace default: When chars is None, whitespace characters are removed\n    6. Maximal stripping: Remove as many characters as possible from both ends\n    7. Empty string handling: Empty strings remain empty\n    8. Middle preservation: Characters in the middle of the string are unchanged\n    9. Composition property: strip combines lstrip and rstrip functionality\n    10. Idempotent-like property: applying strip to result with same chars removes nothing\n\n    Precondition: True (no special preconditions for strip)\n    Postcondition: For all indices i, result[i] is a[i] with leading and trailing characters removed\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def strip {n : Nat} (a : Vector String n) (chars : Option String) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem strip_spec {n : Nat} (a : Vector String n) (chars : Option String) :\n    \u2983\u231cTrue\u231d\u2984\n    strip a chars\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Fundamental correctness: result matches expected behavior\n      (chars.isNone \u2192 result = original.trim) \u2227\n      -- Length preservation or reduction: result is no longer than original\n      (result.length \u2264 original.length) \u2227\n      -- Substring property: result is a substring of original\n      (\u2203 start : Nat, \u2203 len : Nat, \n        start + len \u2264 original.length \u2227 \n        result = original.extract \u27e8start\u27e9 \u27e8start + len\u27e9) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Character removal correctness: when chars is provided\n      (chars.isSome \u2192\n        \u2203 start : Nat, \u2203 len : Nat,\n        start + len \u2264 original.length \u2227 \n        result = original.extract \u27e8start\u27e9 \u27e8start + len\u27e9 \u2227\n        -- All stripped leading characters are in the chars set\n        (\u2200 j : Nat, j < start \u2192 \n          \u2203 c : Char, original.get? \u27e8j\u27e9 = some c \u2227 c \u2208 chars.get!.toList) \u2227\n        -- All stripped trailing characters are in the chars set\n        (\u2200 j : Nat, start + len < j \u2192 j < original.length \u2192\n          \u2203 c : Char, original.get? \u27e8j\u27e9 = some c \u2227 c \u2208 chars.get!.toList) \u2227\n        -- The first non-stripped character (if any) is not in chars\n        (start < original.length \u2192 start + len > start \u2192\n          \u2203 c : Char, original.get? \u27e8start\u27e9 = some c \u2227 c \u2209 chars.get!.toList) \u2227\n        -- The last non-stripped character (if any) is not in chars\n        (start + len > 0 \u2192 start + len \u2264 original.length \u2192\n          \u2203 c : Char, original.get? \u27e8start + len - 1\u27e9 = some c \u2227 c \u2209 chars.get!.toList)) \u2227\n      -- Maximal stripping: result cannot have leading or trailing chars from the set removed\n      (chars.isSome \u2192 \n        (result = \"\" \u2228 \n         (\u2200 c : Char, c \u2208 chars.get!.toList \u2192 \n           result.get? \u27e80\u27e9 \u2260 some c \u2227 result.back \u2260 c))) \u2227\n      -- Composition property: strip is equivalent to rstrip(lstrip(...))\n      (chars.isSome \u2192\n        \u2203 intermediate : String,\n        -- First apply lstrip\n        (\u2203 k : Nat, k \u2264 original.length \u2227 \n         intermediate = original.drop k \u2227\n         (\u2200 j : Nat, j < k \u2192 \n           \u2203 c : Char, original.get? \u27e8j\u27e9 = some c \u2227 c \u2208 chars.get!.toList) \u2227\n         (k < original.length \u2192 \n           \u2203 c : Char, original.get? \u27e8k\u27e9 = some c \u2227 c \u2209 chars.get!.toList)) \u2227\n        -- Then apply rstrip to get final result\n        (\u2203 suffix : String, \n          intermediate = result ++ suffix \u2227\n          (\u2200 c : Char, c \u2208 suffix.toList \u2192 c \u2208 chars.get!.toList) \u2227\n          (result = \"\" \u2228 \n           \u2200 c : Char, c \u2208 chars.get!.toList \u2192 result.back \u2260 c))) \u2227\n      -- Middle preservation: characters that remain are in the same order\n      (\u2200 j k : Nat, j < k \u2192 k < result.length \u2192 \n        \u2203 origJ origK : Nat, j < origJ \u2192 origJ < origK \u2192 origK < original.length \u2192\n          result.get? \u27e8j\u27e9 = original.get? \u27e8origJ\u27e9 \u2227 \n          result.get? \u27e8k\u27e9 = original.get? \u27e8origK\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_swapcase", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.swapcase\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.swapcase.html\",\n  \"doc\": \"Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa.\\n\\nFor byte strings, this method is locale-dependent.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\",\n}\n-/\n\n/-  Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa -/\n\n/-  Specification: numpy.strings.swapcase returns a vector where each string element\n    has its case swapped (uppercase becomes lowercase and vice versa).\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element has its alphabetic characters case-swapped\n    2. Length preservation: Each transformed string has the same length as the original\n    3. Case transformation: Uppercase\u2192lowercase, lowercase\u2192uppercase, non-alpha unchanged\n    4. Involutive property: swapcase(swapcase(x)) = x\n    5. Empty string handling: Empty strings remain empty\n    6. Character-level correctness: Each character is correctly transformed\n\n    Precondition: True (no special preconditions for case swapping)\n    Postcondition: For all indices i, result[i] is the case-swapped version of a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def swapcase {n : Nat} (a : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem swapcase_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    swapcase a\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Length preservation: result has same length as original\n      (result.length = original.length) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Character-level transformation: each character is correctly converted\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          result.get? \u27e8j\u27e9 = some (if origChar.isLower then origChar.toUpper \n                                    else if origChar.isUpper then origChar.toLower \n                                    else origChar)) \u2227\n      -- Involutive property: applying swapcase twice gives original string\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          let swappedOnce := if origChar.isLower then origChar.toUpper \n                           else if origChar.isUpper then origChar.toLower \n                           else origChar\n          let swappedTwice := if swappedOnce.isLower then swappedOnce.toUpper \n                             else if swappedOnce.isUpper then swappedOnce.toLower \n                             else swappedOnce\n          swappedTwice = origChar) \u2227\n      -- Case transformation specifics\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          (origChar.isLower \u2192 result.get? \u27e8j\u27e9 = some origChar.toUpper) \u2227\n          (origChar.isUpper \u2192 result.get? \u27e8j\u27e9 = some origChar.toLower) \u2227\n          (\u00acorigChar.isAlpha \u2192 result.get? \u27e8j\u27e9 = some origChar))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_translate", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.translate\",\n  \"category\": \"String transformation\",\n  \"description\": \"For each element in a, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.translate.html\",\n  \"doc\": \"For each element in \\`a\\`, return a copy of the string where all characters occurring in the optional argument \\`deletechars\\` are removed, and the remaining characters have been mapped through the given translation table.\\n\\nParameters\\n----------\\na : array_like, with \\`bytes_\\` dtype\\ntable : array_like with \\`bytes_\\` dtype and shape (1, 256)\\n    String of 256 bytes. Characters to map to (length 256)\\ndeletechars : array_like, with \\`bytes_\\` dtype, optional\\n    Characters to delete. If not given, no deletion occurs.\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`bytes_\\` dtype\",\n}\n-/\n\n/-  numpy.strings.translate: For each element in a, return a copy of the string where \n    all characters occurring in deletechars are removed, and the remaining characters \n    have been mapped through the given translation table.\n\n    This function performs character-level transformation on byte strings by first\n    removing characters specified in deletechars, then translating each remaining\n    character using a 256-byte translation table.\n-/\n\n/-  Specification for numpy.strings.translate: Returns a vector where each element is \n    the result of character deletion followed by character translation.\n\n    Mathematical Properties:\n    1. Element-wise transformation: Each result element is derived from the corresponding input\n    2. Two-stage process: First deletion, then translation\n    3. Deletion completeness: All occurrences of characters in deletechars are removed\n    4. Translation mapping: Each remaining byte is mapped through the translation table\n    5. Order preservation: Relative order of non-deleted characters is maintained\n    6. Empty string handling: Empty strings remain empty after transformation\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def translate {n m : Nat} (a : Vector String n) (table : Vector UInt8 256) \n    (deletechars : Vector UInt8 m) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem translate_spec {n m : Nat} (a : Vector String n) (table : Vector UInt8 256) \n    (deletechars : Vector UInt8 m) :\n    \u2983\u231cTrue\u231d\u2984\n    translate a table deletechars\n    \u2983\u21d3result => \u231c\u2200 i : Fin n,\n      -- Length property: result length \u2264 original length (due to deletion)\n      (result.get i).length \u2264 (a.get i).length \u2227\n\n      -- Deletion property: no character from deletechars appears in result\n      (\u2200 c : Char, c \u2208 (result.get i).data \u2192\n        \u00ac(\u2203 j : Fin m, c.toNat.toUInt8 = deletechars.get j)) \u2227\n\n      -- Translation property: each character in result comes from table translation\n      (\u2200 c : Char, c \u2208 (result.get i).data \u2192\n        \u2203 (orig_char : UInt8) (table_idx : Fin 256),\n          orig_char = table_idx.val.toUInt8 \u2227\n          c = Char.ofNat (table.get table_idx).toNat \u2227\n          -- The original character existed in input and wasn't deleted\n          (\u2203 orig_char_val : Char, orig_char_val \u2208 (a.get i).data \u2227\n            orig_char_val.toNat.toUInt8 = orig_char \u2227\n            \u00ac(\u2203 j : Fin m, orig_char = deletechars.get j))) \u2227\n\n      -- Completeness property: all non-deleted characters are translated and included\n      (\u2200 orig_char : Char, orig_char \u2208 (a.get i).data \u2192\n        \u00ac(\u2203 j : Fin m, orig_char.toNat.toUInt8 = deletechars.get j) \u2192\n        \u2203 translated_char : Char, translated_char \u2208 (result.get i).data \u2227\n          \u2203 table_idx : Fin 256,\n            orig_char.toNat = table_idx.val \u2227\n            translated_char = Char.ofNat (table.get table_idx).toNat) \u2227\n\n      -- Identity on empty deletechars: if no characters to delete, only translation occurs\n      (m = 0 \u2192 (result.get i).length = (a.get i).length \u2227\n        (result.get i).data.length = (a.get i).data.length \u2227\n        \u2200 k : Nat, k < (a.get i).data.length \u2192\n          \u2203 table_idx : Fin 256,\n            (a.get i).data[k]!.toNat = table_idx.val \u2227\n            (result.get i).data[k]! = Char.ofNat (table.get table_idx).toNat) \u2227\n\n      -- Empty string preservation: empty inputs produce empty outputs  \n      ((a.get i).length = 0 \u2192 (result.get i).length = 0)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_upper", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.upper\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return an array with the elements converted to uppercase\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.upper.html\",\n  \"doc\": \"Return an array with the elements converted to uppercase.\\n\\nFor byte strings, this method is locale-dependent.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\",\n}\n-/\n\n/-  numpy.strings.upper: Return an array with the elements converted to uppercase.\n\n    Converts each string element in the input vector to uppercase. This transformation\n    applies to all alphabetic characters while preserving non-alphabetic characters\n    (digits, punctuation, whitespace) unchanged.\n\n    The function preserves the shape of the input array and handles empty strings\n    appropriately by returning them unchanged.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n    - Returns: out (ndarray) - Output array with elements converted to uppercase\n\n    Mathematical Properties:\n    1. Element-wise transformation: result[i] = upper(a[i]) for all i\n    2. Length preservation: result[i].length = a[i].length for all i\n    3. Case transformation: lowercase letters become uppercase, others unchanged\n    4. Idempotent: upper(upper(x)) = upper(x)\n    5. Preserves vector length: result.size = a.size\n-/\n\n/-  Specification: numpy.strings.upper returns a vector where each string element\n    is converted to uppercase.\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element is correctly converted to uppercase\n    2. Length preservation: Each transformed string has the same length as the original\n    3. Case transformation: Lowercase letters become uppercase, others unchanged\n    4. Idempotent property: Applying upper twice gives the same result as applying it once\n    5. Empty string handling: Empty strings remain empty\n    6. Character-level correctness: Each character is correctly transformed\n\n    Precondition: True (no special preconditions for uppercase conversion)\n    Postcondition: For all indices i, result[i] is the uppercase version of a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def upper {n : Nat} (a : Vector String n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem upper_spec {n : Nat} (a : Vector String n) :\n    \u2983\u231cTrue\u231d\u2984\n    upper a\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Fundamental correctness: result matches Lean's built-in toUpper\n      (result = original.toUpper) \u2227\n      -- Length preservation: result has same length as original\n      (result.length = original.length) \u2227\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 \u2192 result = \"\") \u2227\n      -- Character-level transformation: each character is correctly converted\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          result.get? \u27e8j\u27e9 = some origChar.toUpper) \u2227\n      -- Idempotent property: applying upper twice gives same result as once\n      (result.toUpper = result) \u2227\n      -- Case preservation: non-alphabetic characters remain unchanged\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          (\u00acorigChar.isAlpha \u2192 result.get? \u27e8j\u27e9 = some origChar)) \u2227\n      -- Alphabetic transformation: lowercase letters become uppercase\n      (\u2200 j : Nat, j < original.length \u2192 \n        \u2203 origChar : Char, \n          original.get? \u27e8j\u27e9 = some origChar \u2227 \n          (origChar.isLower \u2192 result.get? \u27e8j\u27e9 = some origChar.toUpper))\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "strings_zfill", "vc-description": "/- \n{\n  \"name\": \"numpy.strings.zfill\",\n  \"category\": \"String operations\",\n  \"description\": \"Return the numeric string left-filled with zeros\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.zfill.html\",\n  \"doc\": \"Return the numeric string left-filled with zeros.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\nwidth : array_like, with any integer dtype\\n    Width of string to left-fill elements in \\`a\\`\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\",\n}\n-/\n\n/-  numpy.strings.zfill: Return the numeric string left-filled with zeros.\n\n    Zero-fills each string in the input array by padding it with leading zeros\n    to reach the specified width. If the original string is longer than or equal\n    to the width, it remains unchanged. This function is specifically designed\n    for numeric strings and handles sign prefixes appropriately.\n\n    The function behaves like Python's str.zfill() method:\n    - Pads strings with leading zeros to reach the target width\n    - Preserves sign characters ('+' or '-') at the beginning\n    - Returns original string if it's already >= target width\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n                  width (int) - Target width for zero-filling\n    - Returns: out (ndarray) - Output array with zero-filled strings\n\n    Mathematical Properties:\n    1. Length invariant: result length is max(original_length, width)\n    2. Identity: strings already >= width remain unchanged\n    3. Zero-padding: shorter strings get leading zeros\n    4. Sign preservation: leading '+' or '-' characters are preserved\n    5. Minimality: no over-padding beyond required width\n-/\n\n/-  Specification: numpy.strings.zfill returns a vector where each string element\n    is zero-filled to the specified width.\n\n    Mathematical Properties:\n    1. Length invariant: Result length is exactly max(original_length, width)\n    2. Identity morphism: Strings already >= width are unchanged\n    3. Zero-padding morphism: Shorter strings get leading zeros\n    4. Sign preservation: Leading '+' or '-' characters are preserved\n    5. Minimality: No over-padding beyond required width\n    6. Numeric string handling: Appropriate behavior for numeric strings\n\n    The function implements the mathematical transformation:\n    f(s, w) = s if |s| >= w\n    f(s, w) = zeros(w - |s|) ++ s if |s| < w and s has no sign\n    f(s, w) = sign ++ zeros(w - |s|) ++ s[1:] if |s| < w and s starts with sign\n\n    Precondition: width >= 0 (non-negative width requirement)\n    Postcondition: Each element is correctly zero-filled to target width\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def zfill {n : Nat} (a : Vector String n) (width : Nat) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem zfill_spec {n : Nat} (a : Vector String n) (width : Nat) :\n    \u2983\u231cTrue\u231d\u2984\n    zfill a width\n    \u2983\u21d3r => \u231c\u2200 i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Core mathematical properties of zero-filling\n      -- 1. Length invariant: result length is exactly max(orig.length, width)\n      result.length = max original.length width \u2227\n      -- 2. Identity morphism: strings already >= width are unchanged\n      (original.length \u2265 width \u2192 result = original) \u2227\n      -- 3. Zero-padding for short strings without signs\n      (original.length < width \u2227 \n       original.length > 0 \u2227 \n       original.get? \u27e80\u27e9 \u2260 some '+' \u2227 \n       original.get? \u27e80\u27e9 \u2260 some '-' \u2192 \n         \u2203 padding : String, result = padding ++ original \u2227 \n           padding.length = width - original.length \u2227\n           (\u2200 j : Nat, j < padding.length \u2192 padding.get? \u27e8j\u27e9 = some '0')) \u2227\n      -- 4. Sign preservation: leading '+' or '-' are preserved at start\n      (original.length < width \u2227 \n       original.length > 0 \u2227 \n       (original.get? \u27e80\u27e9 = some '+' \u2228 original.get? \u27e80\u27e9 = some '-') \u2192 \n         \u2203 sign : Char, \u2203 rest : String, \u2203 padding : String,\n           original.get? \u27e80\u27e9 = some sign \u2227\n           (sign = '+' \u2228 sign = '-') \u2227\n           original = sign.toString ++ rest \u2227\n           result = sign.toString ++ padding ++ rest \u2227\n           padding.length = width - original.length \u2227\n           (\u2200 j : Nat, j < padding.length \u2192 padding.get? \u27e8j\u27e9 = some '0')) \u2227\n      -- 5. Empty string handling: empty strings become all zeros\n      (original.length = 0 \u2192 \n         result.length = width \u2227 \n         (\u2200 j : Nat, j < width \u2192 result.get? \u27e8j\u27e9 = some '0')) \u2227\n      -- 6. Minimality constraint: no over-padding\n      (original.length \u2265 width \u2192 result.length = original.length) \u2227\n      -- 7. Exactness constraint: padding achieves exact width requirement\n      (original.length < width \u2192 result.length = width) \u2227\n      -- 8. Correctness constraint: result contains original content\n      (original.length < width \u2227 original.length > 0 \u2227 \n       original.get? \u27e80\u27e9 \u2260 some '+' \u2227 original.get? \u27e80\u27e9 \u2260 some '-' \u2192 \n         result.drop (width - original.length) = original) \u2227\n      -- 9. Zero character constraint: padding uses only '0' characters\n      (original.length < width \u2192 \n         \u2200 j : Nat, j < (width - original.length) \u2192 result.get? \u27e8j\u27e9 = some '0')\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufunc___call__", "vc-description": "/- \n{\n  \"name\": \"ufunc.__call__\",\n  \"category\": \"Core Method\",\n  \"description\": \"Call the ufunc on the given arguments\",\n  \"signature\": \"ufunc.__call__(*args, out=None, where=True, casting='same_kind', order='K', dtype=None, subok=True, signature=None, extobj=None)\",\n  \"parameters\": {\n    \"args\": \"Input arrays\",\n    \"out\": \"Location(s) for the result\",\n    \"where\": \"Condition to select where the operation should occur\",\n    \"casting\": \"Controls what kind of data casting may occur\",\n    \"order\": \"Memory layout order\",\n    \"dtype\": \"Output data type\",\n    \"subok\": \"If True, subclasses will be passed through\",\n    \"signature\": \"Generalized ufunc signature\",\n    \"extobj\": \"Buffer size, error mode, and error callback function\"\n  }\n}\n-/\n\n/-  Apply a binary universal function elementwise to two vectors.\n    This represents the core __call__ behavior for binary ufuncs like add, multiply, etc. -/\n\n/-  Specification: ufunc.__call__ applies the operation elementwise to input vectors.\n    The result has the same shape as the inputs (broadcasting to common shape) and\n    each element is computed by applying the operation to corresponding elements. -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ufunc_call {n : Nat} (op : Float \u2192 Float \u2192 Float) (a b : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem ufunc_call_spec {n : Nat} (op : Float \u2192 Float \u2192 Float) (a b : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    ufunc_call op a b\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = op (a.get i) (b.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufunc_accumulate", "vc-description": "/- \n{\n  \"name\": \"ufunc.accumulate\",\n  \"category\": \"Accumulation Method\",\n  \"description\": \"Accumulate the result of applying operator to all elements\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ufunc.accumulate.html\",\n  \"signature\": \"ufunc.accumulate(array, axis=0, dtype=None, out=None)\",\n  \"parameters\": {\n    \"array\": \"Input array\",\n    \"axis\": \"Axis along which to accumulate\",\n    \"dtype\": \"Data type for intermediate results\",\n    \"out\": \"Location for the result\"\n  },\n  \"example\": \"np.add.accumulate([2, 3, 5])  # Returns [2, 5, 10]\\nnp.multiply.accumulate([2, 3, 5])  # Returns [2, 6, 30]\",\n  \"notes\": [\n    \"Returns array of same shape with intermediate results\",\n    \"For add.accumulate, equivalent to cumsum()\",\n    \"For multiply.accumulate, equivalent to cumprod()\"\n  ]\n}\n-/\n\n/-  \nUniversal function accumulate method: Accumulate the result of applying a binary operator\nto all elements in a vector.\n\nFor a binary operation `op` and input vector [a\u2081, a\u2082, a\u2083, ..., a\u2099], returns:\n[a\u2081, op(a\u2081, a\u2082), op(op(a\u2081, a\u2082), a\u2083), ..., op(op(...op(a\u2081, a\u2082), a\u2083), ..., a\u2099)]\n\nThis generalizes cumulative operations:\n- When op = (+), this becomes cumsum: [a\u2081, a\u2081+a\u2082, a\u2081+a\u2082+a\u2083, ...]\n- When op = (*), this becomes cumprod: [a\u2081, a\u2081*a\u2082, a\u2081*a\u2082*a\u2083, ...]\n\nThe result has the same shape as the input array.\n-/\n\n/-  \nSpecification: accumulate applies a binary operator cumulatively to produce\nintermediate results at each position.\n\nPrecondition: True (works for any vector and binary operation)\nPostcondition:\n- Result has same length as input\n- First element equals first element of input (when n > 0)\n- Each subsequent element is the result of applying the operator to the previous \n  accumulated result and the current element\n- Mathematically: result[i] = op(op(...op(a[0], a[1]), a[2]), ..., a[i])\n\nMathematical Properties:\n- result[0] = a[0] (when n > 0)\n- result[i] = op(result[i-1], a[i]) for i > 0 (recurrence relation)\n- Each element represents the accumulated result of the operation from start to that position\n- The operation is applied left-associatively: ((a[0] op a[1]) op a[2]) op ... op a[i]\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def accumulate {n : Nat} (op : Float \u2192 Float \u2192 Float) (a : Vector Float n) : Id (Vector Float n) :=\n  sorry", "vc-theorems": "theorem accumulate_spec {n : Nat} (op : Float \u2192 Float \u2192 Float) (a : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    accumulate op a\n    \u2983\u21d3result => \u231c\n      -- Result has same length as input\n      result.toList.length = n \u2227\n      -- For non-empty vectors, first element equals first element of input\n      (n > 0 \u2192 result.get \u27e80, sorry\u27e9 = a.get \u27e80, sorry\u27e9) \u2227\n      -- Recurrence relation: each element is op applied to previous result and current element\n      (\u2200 i : Fin n, i.val > 0 \u2192 \n        result.get i = op (result.get \u27e8i.val - 1, sorry\u27e9) (a.get i)) \u2227\n      -- Cumulative accumulation property: each element is the left-associative fold of all previous elements\n      (n > 0 \u2192 \u2200 i : Fin n, result.get i = (a.toList.take (i.val + 1)).tail.foldl op (a.get \u27e80, sorry\u27e9))\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufunc_outer", "vc-description": "/- \n{\n  \"name\": \"ufunc.outer\",\n  \"category\": \"Outer Product Method\",\n  \"description\": \"Apply ufunc to all pairs (a, b) with a in A and b in B\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ufunc.outer.html\",\n  \"signature\": \"ufunc.outer(A, B, /, **kwargs)\",\n  \"parameters\": {\n    \"A\": \"First input array\",\n    \"B\": \"Second input array\",\n    \"**kwargs\": \"Additional keyword arguments passed to the ufunc\"\n  },\n  \"example\": \"np.multiply.outer([1, 2, 3], [4, 5, 6])\\n# Returns:\\n# array([[ 4,  5,  6],\\n#        [ 8, 10, 12],\\n#        [12, 15, 18]])\",\n  \"notes\": [\n    \"Result has dimension A.ndim + B.ndim\",\n    \"More general than numpy.outer which only works on 1-D arrays\"\n  ]\n}\n-/\n\n/-  \nUniversal function outer method: Apply a binary operator to all pairs (a, b) \nwith a in A and b in B.\n\nFor two 1-D vectors A = [a\u2081, a\u2082, ..., a\u2098] and B = [b\u2081, b\u2082, ..., b\u2099], \nthe outer product produces an m\u00d7n matrix where result[i,j] = op(A[i], B[j]).\n\nThis generalizes the concept of outer product beyond just multiplication:\n- When op = (*), this becomes the traditional outer product\n- When op = (+), this becomes the sum of all pairs\n- When op = (^), this becomes the power of all pairs\n\nThe result has shape (m, n) where m is the length of A and n is the length of B.\n-/\n\n/-  \nSpecification: outer applies a binary operator to all pairs of elements\nfrom two input vectors, producing a matrix result.\n\nPrecondition: True (works for any two vectors and binary operation)\nPostcondition:\n- Result has dimensions m \u00d7 n (outer dimensions of input vectors)\n- Each element result[i][j] equals op(a[i], b[j])\n- The result preserves the structure of the Cartesian product of the inputs\n- All pairs (i,j) with i \u2208 [0..m-1] and j \u2208 [0..n-1] are covered exactly once\n\nMathematical Properties:\n- result[i][j] = op(a[i], b[j]) for all valid i, j\n- The result matrix has the same number of rows as the first input vector\n- The result matrix has the same number of columns as the second input vector\n- For commutative operations: outer(op, a, b)[i][j] = outer(op, b, a)[j][i]\n- For associative operations: outer preserves the algebraic structure\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def outer {m n : Nat} (op : Float \u2192 Float \u2192 Float) (a : Vector Float m) (b : Vector Float n) : \n    Id (Vector (Vector Float n) m) :=\n  sorry", "vc-theorems": "theorem outer_spec {m n : Nat} (op : Float \u2192 Float \u2192 Float) (a : Vector Float m) (b : Vector Float n) :\n    \u2983\u231cTrue\u231d\u2984\n    outer op a b\n    \u2983\u21d3result => \u231c\n      -- Result has correct outer dimensions\n      result.size = m \u2227\n      -- Each row has correct inner dimension\n      (\u2200 i : Fin m, (result.get i).size = n) \u2227\n      -- Each element is the result of applying the operator to the corresponding pair\n      (\u2200 i : Fin m, \u2200 j : Fin n, (result.get i).get j = op (a.get i) (b.get j)) \u2227\n      -- Structural property: result represents all pairs from Cartesian product\n      (\u2200 i : Fin m, \u2200 j : Fin n, \u2203 ai bj, ai = a.get i \u2227 bj = b.get j \u2227 (result.get i).get j = op ai bj)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufunc_reduce", "vc-description": "/- \n{\n  \"name\": \"ufunc.reduce\",\n  \"category\": \"Reduction Method\",\n  \"description\": \"Reduces array's dimension by applying ufunc along specified axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ufunc.reduce.html\",\n  \"signature\": \"ufunc.reduce(array, axis=0, dtype=None, out=None, keepdims=False, initial=<no value>, where=True)\",\n  \"parameters\": {\n    \"array\": \"Array to be reduced\",\n    \"axis\": \"Axis or axes along which to reduce\",\n    \"dtype\": \"Data type for intermediate computations\",\n    \"out\": \"Location for the result\",\n    \"keepdims\": \"If True, axes which are reduced are left as dimensions with size one\",\n    \"initial\": \"Starting value for the reduction\",\n    \"where\": \"Boolean array for selective reduction\"\n  },\n  \"example\": \"np.multiply.reduce([2,3,5])  # Returns 30\\nnp.add.reduce([[1,2],[3,4]], axis=0)  # Returns [4, 6]\",\n  \"notes\": [\n    \"For add.reduce, equivalent to sum()\",\n    \"For multiply.reduce, equivalent to prod()\",\n    \"Supports multi-axis reduction\"\n  ]\n}\n-/\n\n/-  Reduces an array by applying a binary operation repeatedly along an axis.\n    For 1D arrays, this applies the operation successively to pairs of elements. -/\n\n/-  Specification: reduce applies a binary operation repeatedly to reduce an array to a single value.\n    The operation is applied left-associatively: ((a[0] op a[1]) op a[2]) op ... op a[n-1] -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def reduce {n : Nat} (op : Float \u2192 Float \u2192 Float) (arr : Vector Float (n + 1)) : Id Float :=\n  sorry", "vc-theorems": "theorem reduce_spec {n : Nat} (op : Float \u2192 Float \u2192 Float) (arr : Vector Float (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    reduce op arr\n    \u2983\u21d3result => \u231c(n = 0 \u2192 result = arr.get \u27e80, Nat.zero_lt_succ _\u27e9) \u2227\n                 (n > 0 \u2192 \u2203 (fold_fn : Fin (n + 1) \u2192 Float), \n                          fold_fn \u27e80, Nat.zero_lt_succ _\u27e9 = arr.get \u27e80, Nat.zero_lt_succ _\u27e9 \u2227\n                          (\u2200 i : Fin n, fold_fn \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9 = \n                            op (fold_fn \u27e8i.val, Nat.lt_succ_of_lt i.isLt\u27e9) \n                               (arr.get \u27e8i.val + 1, Nat.succ_lt_succ i.isLt\u27e9)) \u2227\n                          result = fold_fn \u27e8n, Nat.lt_succ_self _\u27e9)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufunc_reduceat", "vc-description": "/- \n{\n  \"name\": \"ufunc.reduceat\",\n  \"category\": \"Reduction Method\",\n  \"description\": \"Performs a (local) reduce with specified slices over a single axis\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ufunc.reduceat.html\",\n  \"signature\": \"ufunc.reduceat(array, indices, axis=0, dtype=None, out=None)\",\n  \"parameters\": {\n    \"array\": \"Input array\",\n    \"indices\": \"Indices specifying slice boundaries\",\n    \"axis\": \"Axis along which to apply reduceat\",\n    \"dtype\": \"Data type for intermediate computations\",\n    \"out\": \"Location for the result\"\n  },\n  \"notes\": [\n    \"Applies reduction to specified slices of the array\",\n    \"Useful for segmented reductions\"\n  ]\n}\n-/\n\n/-  \nUniversal function reduceat method: Performs reductions on specified slices of an array.\n\nFor each index pair (indices[i], indices[i+1]), applies the reduction operation \nto the slice array[indices[i]:indices[i+1]].\n\nSpecial behavior:\n- For the last index, reduces from indices[i] to the end of the array\n- If indices[i] >= indices[i+1], uses only the element at indices[i]\n- Output length equals the number of indices provided\n\nExample: np.add.reduceat([1,2,3,4,5,6,7,8], [0,4,1,5]) applies addition to slices:\n- [1,2,3,4] -> 10\n- [2,3,4,5] -> 14  \n- [5,6,7,8] -> 26\nResult: [10, 14, 26]\n-/\n\n/-  \nSpecification: reduceat applies a binary operation to reduce specified slices of an array.\n\nThis captures the core behavior of NumPy's ufunc.reduceat method:\n1. For each index i in the indices vector, compute a slice of the input array\n2. Apply the binary operation to reduce that slice to a single value\n3. Return a vector of these reduced values\n\nPrecondition: Both input array and indices must be non-empty\nPostcondition: \n- Result has same length as indices vector\n- For each index position i:\n  - If i < m-1: reduce slice from indices[i] to indices[i+1] (exclusive)\n  - If i = m-1: reduce slice from indices[i] to end of array\n  - If indices[i] >= indices[i+1]: use single element at indices[i]\n- Each slice reduction follows left-associative folding\n- Empty slices are handled by returning the identity or single element\n\nMathematical Properties:\n- Segmented reduction: each output element corresponds to a specific segment\n- Associativity: the reduction operation is applied left-associatively\n- Boundary handling: last index always reduces to end of array\n- Non-increasing indices: handled by single element selection\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def reduceat {n m : Nat} (op : Float \u2192 Float \u2192 Float) (arr : Vector Float n) \n    (indices : Vector (Fin n) m) : Id (Vector Float m) :=\n  sorry", "vc-theorems": "theorem reduceat_spec {n m : Nat} (op : Float \u2192 Float \u2192 Float) (arr : Vector Float n) \n    (indices : Vector (Fin n) m) (h_arr_nonempty : n > 0) (h_indices_nonempty : m > 0) :\n    \u2983\u231cn > 0 \u2227 m > 0\u231d\u2984\n    reduceat op arr indices\n    \u2983\u21d3result => \u231c\n      -- Result has same length as indices\n      result.toList.length = m \u2227\n      -- For each index position, the result is computed according to reduceat rules\n      (\u2200 i : Fin m, \n        -- For non-last indices: handle slice [indices[i], indices[i+1])\n        (i.val < m - 1 \u2192 \n          let start_idx := indices.get i\n          let end_idx := indices.get \u27e8i.val + 1, sorry\u27e9\n          -- Case 1: Normal forward slice (start < end)\n          (start_idx.val < end_idx.val \u2192 \n            \u2203 (slice_elements : List Float),\n            -- Extract elements from start to end-1\n            slice_elements = (List.range (end_idx.val - start_idx.val)).map \n              (fun offset => arr.get \u27e8start_idx.val + offset, sorry\u27e9) \u2227\n            slice_elements.length > 0 \u2227\n            -- Apply left-associative reduction\n            result.get i = slice_elements.foldl op slice_elements.head!) \u2227\n          -- Case 2: Backward or equal indices (start >= end)\n          (start_idx.val \u2265 end_idx.val \u2192 \n            result.get i = arr.get start_idx)) \u2227\n        -- For the last index: reduce from indices[i] to end of array\n        (i.val = m - 1 \u2192 \n          let start_idx := indices.get i\n          let slice_elements := (List.range (n - start_idx.val)).map \n            (fun offset => arr.get \u27e8start_idx.val + offset, sorry\u27e9)\n          slice_elements.length > 0 \u2227\n          result.get i = slice_elements.foldl op slice_elements.head!)) \u2227\n      -- Mathematical properties of the reduction operation\n      (\u2200 slice : List Float, slice.length > 0 \u2192 \n        -- Single element case\n        (slice.length = 1 \u2192 slice.foldl op slice.head! = slice.head!) \u2227\n        -- Multiple element case follows left-associative folding\n        (slice.length > 1 \u2192 \n          slice.foldl op slice.head! = \n          match slice with\n          | [] => 0  -- Never reached due to length > 0\n          | [a] => a\n          | a :: rest => rest.foldl op a)) \u2227\n      -- Boundary conditions\n      (\u2200 i : Fin m, \n        -- All indices are within bounds\n        (indices.get i).val < n \u2227\n        -- Result elements are well-defined\n        \u2203 (reduction_result : Float), result.get i = reduction_result)\n    \u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_frompyfunc", "vc-description": "/-  numpy.frompyfunc: Takes a function and returns a universal function that applies it element-wise.\n\n    Creates a universal function (ufunc) from a Python function. The resulting ufunc\n    applies the original function element-wise to input arrays. For simplicity, we\n    model this for the common case of a unary function (nin=1, nout=1).\n\n    In our Vector-based model, this takes a function \u03b1 \u2192 \u03b2 and returns a function\n    that applies it element-wise to Vector \u03b1 n, producing Vector \u03b2 n.\n\n    This function enables the creation of vectorized operations from arbitrary functions,\n    which is a core capability of NumPy's universal function system.\n-/\n\n/-  Specification: numpy.frompyfunc creates a vectorized version of a function\n    that applies the original function element-wise.\n\n    Precondition: True (any function can be vectorized)\n    Postcondition: For all indices i, the result at index i equals func applied\n    to the input at index i.\n\n    This captures the essential property that frompyfunc creates an element-wise\n    mapping from the original function, preserving the functional behavior\n    while extending it to work with vectors.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def numpy_frompyfunc {\u03b1 \u03b2 : Type} {n : Nat} (func : \u03b1 \u2192 \u03b2) (input : Vector \u03b1 n) : Id (Vector \u03b2 n) :=\n  sorry", "vc-theorems": "theorem numpy_frompyfunc_spec {\u03b1 \u03b2 : Type} {n : Nat} (func : \u03b1 \u2192 \u03b2) (input : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_frompyfunc func input\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = func (input.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_identity", "vc-description": "/- \n{\n  \"name\": \"identity\",\n  \"description\": \"The identity value for the ufunc\",\n  \"details\": \"Value such that func(x, identity) == x for all x\",\n  \"examples\": {\n    \"add.identity\": \"0\",\n    \"multiply.identity\": \"1\",\n    \"logical_and.identity\": \"True\",\n    \"logical_or.identity\": \"False\"\n  }\n}\n-/\n\n/-  ufunc.identity: Get the identity element for a ufunc operation.\n\n    Returns the identity element for a given binary operation, which is the value\n    that when combined with any other value using that operation, leaves the other\n    value unchanged. For example:\n    - Addition: identity is 0 (x + 0 = x)\n    - Multiplication: identity is 1 (x * 1 = x)\n    - Logical AND: identity is True (x \u2227 True = x)\n    - Logical OR: identity is False (x \u2228 False = x)\n\n    Some operations may have no identity element, in which case None is returned.\n-/\n\n/-  Specification: ufunc_identity returns the identity element if it exists.\n\n    Precondition: The operation is a valid binary function\n    Postcondition: If an identity element exists, applying the operation with\n                   that element leaves any other element unchanged\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ufunc_identity (op : Float \u2192 Float \u2192 Float) : Id (Option Float) :=\n  sorry", "vc-theorems": "theorem ufunc_identity_spec (op : Float \u2192 Float \u2192 Float) :\n    \u2983\u231cTrue\u231d\u2984\n    ufunc_identity op\n    \u2983\u21d3result => \u231cmatch result with\n      | some id => \u2200 x : Float, op x id = x \u2227 op id x = x\n      | none => \u00ac\u2203 id : Float, \u2200 x : Float, op x id = x \u2227 op id x = x\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_nargs", "vc-description": "/- \n{\n  \"name\": \"nargs\",\n  \"description\": \"The number of arguments the ufunc accepts\",\n  \"details\": \"Equal to nin + nout\"\n}\n-/\n\n/-  numpy.ufunc.nargs: Returns the total number of arguments the ufunc accepts.\n\n    This attribute represents the sum of input and output arguments for a ufunc.\n    For example, np.add has nin=2, nout=1, so nargs=3.\n\n    This is a read-only attribute that provides metadata about the ufunc's signature.\n-/\n\n/-  Specification: numpy.ufunc.nargs returns nin + nout\n\n    Precondition: True (no special preconditions for reading metadata)\n    Postcondition: The result equals the sum of input and output arguments\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Structure representing a NumPy universal function (ufunc) with its metadata -/\nstructure Ufunc where\n  /-- Number of input arguments the ufunc accepts -/\n  nin : Nat\n  /-- Number of output arguments the ufunc produces -/\n  nout : Nat\n  deriving Repr, DecidableEq", "vc-helpers": "", "vc-definitions": "def numpy_nargs (ufunc : Ufunc) : Id Nat :=\n  sorry", "vc-theorems": "theorem numpy_nargs_spec (ufunc : Ufunc) :\n    \u2983\u231cTrue\u231d\u2984\n    numpy_nargs ufunc\n    \u2983\u21d3result => \u231cresult = ufunc.nin + ufunc.nout\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_nout", "vc-description": "/- \n{\n  \"name\": \"nout\",\n  \"description\": \"The number of output arguments\",\n  \"examples\": {\n    \"add.nout\": \"1\",\n    \"modf.nout\": \"2\",\n    \"divmod.nout\": \"2\"\n  }\n}\n-/\n\n/-  Returns the number of output arguments for a given ufunc.\n    This corresponds to the nout attribute of NumPy ufuncs. -/\n\n/-  Specification: nout returns the number of output arguments of the ufunc.\n\n    This specification captures the essential mathematical properties of the nout attribute:\n\n    1. **Correctness**: The function returns exactly the nout_val field from the ufunc structure\n    2. **Lower bound**: The result is always \u2265 1, since all ufuncs can produce at least one output\n    3. **Type safety**: The result is a natural number representing a count\n    4. **Determinism**: Given the same ufunc, nout always returns the same value\n\n    Mathematical properties:\n    - \u2200 ufunc : UFunc, nout(ufunc) = ufunc.nout_val  \n    - \u2200 ufunc : UFunc, nout(ufunc) \u2265 1\n    - nout is a pure function (no side effects)\n\n    Examples from NumPy documentation:\n    - add.nout = 1 (binary operation with single output)\n    - modf.nout = 2 (returns fractional and integral parts)\n    - divmod.nout = 2 (returns quotient and remainder) -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nset_option linter.missingDocs false\nopen Std.Do\n\n/-- Represents a universal function (ufunc) type that captures basic metadata about \n    the number of inputs and outputs. In NumPy, this would be the ufunc object itself. -/\nstructure UFunc where\n  /-- Number of input arguments the ufunc accepts -/\n  nin : Nat      \n  /-- Number of output arguments the ufunc produces -/\n  nout_val : Nat \n  /-- Proof that nout_val is always at least 1, since all ufuncs can take output arguments -/\n  h_nout_pos : nout_val \u2265 1", "vc-helpers": "", "vc-definitions": "def nout (ufunc : UFunc) : Id Nat :=\n  pure ufunc.nout_val", "vc-theorems": "theorem nout_spec (ufunc : UFunc) :\n    \u2983\u231cTrue\u231d\u2984\n    nout ufunc\n    \u2983\u21d3result => \u231cresult = ufunc.nout_val \u2227 result \u2265 1\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_ntypes", "vc-description": "/- \n{\n  \"name\": \"ntypes\",\n  \"description\": \"The number of supported input/output type combinations\"\n}\n-/\n\n/-  numpy.ufunc.ntypes: Returns the number of supported input/output type combinations\n    for a universal function.\n\n    The ntypes attribute represents the number of numerical NumPy types on which\n    the ufunc can operate. This is a key characteristic that determines the\n    type flexibility of different NumPy universal functions.\n\n    For example:\n    - np.add.ntypes returns around 22 (supports most numerical types)\n    - np.exp.ntypes returns around 10 (fewer supported types)\n    - np.remainder.ntypes returns around 16 (intermediate support)\n-/\n\n/-  Specification: ntypes returns the count of supported type combinations\n    for a ufunc, which must be a positive number for any valid ufunc.\n\n    Precondition: The input represents valid type combinations for a ufunc\n    Postcondition: The result is the exact count of type combinations,\n                  which is non-zero for any functional ufunc and equals\n                  the length of the type combinations vector.\n-/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def ntypes {n : Nat} (ufunc_type_combinations : Vector String n) : Id Nat :=\n  sorry", "vc-theorems": "theorem ntypes_spec {n : Nat} (ufunc_type_combinations : Vector String (n + 1)) :\n    \u2983\u231cTrue\u231d\u2984\n    ntypes ufunc_type_combinations\n    \u2983\u21d3result => \u231cresult = n + 1 \u2227 result > 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_signature", "vc-description": "/- \n{\n  \"name\": \"signature\",\n  \"description\": \"Core signature for generalized ufuncs\",\n  \"details\": \"Defines core dimensionality of inputs and outputs\",\n  \"example\": \"matmul.signature: '(n,k),(k,m)->(n,m)'\"\n}\n-/\n\n/-  Parse a ufunc signature string into a structured representation -/\n\n/-  Specification: parseSignature correctly parses ufunc signature strings -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- A signature represents the core dimensionality pattern for a generalized ufunc -/\nstructure UfuncSignature where\n  /-- Input dimension patterns as list of dimension lists -/\n  inputs : List (List String)\n  /-- Output dimension patterns as list of dimension lists -/\n  outputs : List (List String)\n  /-- All unique dimension names used in the signature -/\n  dimension_names : List String\nderiving Repr", "vc-helpers": "", "vc-definitions": "def parseSignature {n : Nat} (sig : Vector String n) : Id UfuncSignature :=\n  sorry", "vc-theorems": "theorem parseSignature_spec {n : Nat} (sig : Vector String n) \n    (h_valid : n > 0) :\n    \u2983\u231cn > 0\u231d\u2984\n    parseSignature sig\n    \u2983\u21d3result => \u231c\n      -- The parsed signature preserves essential structure\n      (result.inputs.length > 0 \u2228 result.outputs.length > 0) \u2227\n      -- All dimension names in inputs are included in dimension_names\n      (\u2200 input_dims \u2208 result.inputs,\n        \u2200 dim_name \u2208 input_dims,\n        dim_name \u2208 result.dimension_names) \u2227\n      -- All dimension names in outputs are included in dimension_names  \n      (\u2200 output_dims \u2208 result.outputs,\n        \u2200 dim_name \u2208 output_dims,\n        dim_name \u2208 result.dimension_names) \u2227\n      -- Dimension names list contains only valid identifiers\n      (\u2200 dim_name \u2208 result.dimension_names,\n        dim_name.length > 0) \u2227\n      -- Result is well-formed (has inputs or outputs)\n      (result.inputs.length + result.outputs.length > 0)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_types", "vc-description": "/- \n{\n  \"name\": \"types\",\n  \"description\": \"List of supported data type signatures\",\n  \"details\": \"Shows input->output type mappings\",\n  \"example\": \"add.types: ['??->?', 'bb->b', 'BB->B', 'hh->h', ...]\"\n}\n-/\n\n/-  Returns the list of supported data type signatures for a universal function -/\n\n/-  Specification: types returns formatted type signatures as strings -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do\n\n/-- Data type character codes used in NumPy ufunc type signatures -/\ninductive TypeCode where\n  | bool     : TypeCode  -- '?'\n  | byte     : TypeCode  -- 'b' \n  | ubyte    : TypeCode  -- 'B'\n  | short    : TypeCode  -- 'h'\n  | ushort   : TypeCode  -- 'H'\n  | int      : TypeCode  -- 'i'\n  | uint     : TypeCode  -- 'I'\n  | long     : TypeCode  -- 'l'\n  | ulong    : TypeCode  -- 'L'\n  | longlong : TypeCode  -- 'q'\n  | ulonglong: TypeCode  -- 'Q'\n  | float32  : TypeCode  -- 'f'\n  | float64  : TypeCode  -- 'd'\n  | longdouble: TypeCode -- 'g'\n  | complex64: TypeCode  -- 'F'\n  | complex128: TypeCode -- 'D'\n  | clongdouble: TypeCode -- 'G'\n  | object   : TypeCode  -- 'O'\n\n/-- Type signature representing input->output mapping for ufuncs -/\nstructure TypeSignature where\n  input_types : List TypeCode\n  output_type : TypeCode\n\n/-- Convert TypeCode to character representation -/\ndef typeCodeToChar (tc : TypeCode) : Char :=\n  match tc with\n  | TypeCode.bool => '?'\n  | TypeCode.byte => 'b'\n  | TypeCode.ubyte => 'B'\n  | TypeCode.short => 'h'\n  | TypeCode.ushort => 'H'\n  | TypeCode.int => 'i'\n  | TypeCode.uint => 'I'\n  | TypeCode.long => 'l'\n  | TypeCode.ulong => 'L'\n  | TypeCode.longlong => 'q'\n  | TypeCode.ulonglong => 'Q'\n  | TypeCode.float32 => 'f'\n  | TypeCode.float64 => 'd'\n  | TypeCode.longdouble => 'g'\n  | TypeCode.complex64 => 'F'\n  | TypeCode.complex128 => 'D'\n  | TypeCode.clongdouble => 'G'\n  | TypeCode.object => 'O'\n/-- Format a type signature as a string (input1input2...->output) -/\ndef formatTypeSignature (sig : TypeSignature) : String :=\n  let input_chars := sig.input_types.map typeCodeToChar\n  let input_str := String.mk input_chars\n  s!\"{input_str}->{typeCodeToChar sig.output_type}\"", "vc-helpers": "", "vc-definitions": "def types {n : Nat} (ufunc_signatures : Vector TypeSignature n) : Id (Vector String n) :=\n  sorry", "vc-theorems": "theorem types_spec {n : Nat} (ufunc_signatures : Vector TypeSignature n) :\n    \u2983\u231cTrue\u231d\u2984\n    types ufunc_signatures\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, \n      result.get i = formatTypeSignature (ufunc_signatures.get i) \u2227\n      (ufunc_signatures.get i).input_types.length > 0\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
{"id": "ufuncs_vectorize", "vc-description": "/- \n{\n  \"name\": \"numpy.vectorize\",\n  \"category\": \"Ufunc Creation\",\n  \"description\": \"Generalized function class that converts a Python function into a vectorized function\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html\",\n  \"signature\": \"numpy.vectorize(pyfunc=np.NoValue, otypes=None, doc=None, excluded=None, cache=False, signature=None)\",\n  \"parameters\": {\n    \"pyfunc\": \"Python function or method to vectorize\",\n    \"otypes\": \"Output data types (list of dtypes)\",\n    \"doc\": \"Docstring for the vectorized function\",\n    \"excluded\": \"Set of strings or integers representing arguments to exclude from vectorization\",\n    \"cache\": \"If True, cache the first function call to determine output types\",\n    \"signature\": \"Generalized universal function signature\"\n  },\n  \"notes\": [\n    \"Primarily for convenience, not performance\",\n    \"Essentially implements a for-loop\",\n    \"Supports decorator syntax\",\n    \"Can exclude specific arguments from vectorization\"\n  ],\n  \"example\": \"def myfunc(a, b):\\n    return a - b if a > b else a + b\\n\\nvfunc = np.vectorize(myfunc)\\nresult = vfunc([1, 2, 3, 4], 2)  # Returns [3, 4, 1, 2]\"\n}\n-/\n\n/-  Vectorizes a scalar function to operate element-wise on vectors.\n    Takes a function f and applies it element-wise to input vectors,\n    producing a new vector with the same size. -/\n\n/-  Specification: vectorize applies the given function element-wise to the input vector.\n    The result vector has the same size and each element is the function applied to \n    the corresponding element of the input vector.\n\n    Properties verified:\n    1. Element-wise application: each output element equals f applied to corresponding input\n    2. Size preservation: output vector has same size as input vector\n    3. Order preservation: relative positions of elements are maintained\n    4. Functional purity: result depends only on function f and input vector\n    -/", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nopen Std.Do", "vc-helpers": "", "vc-definitions": "def vectorize {n : Nat} {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (arr : Vector \u03b1 n) : Id (Vector \u03b2 n) :=\n  sorry", "vc-theorems": "theorem vectorize_spec {n : Nat} {\u03b1 \u03b2 : Type} (f : \u03b1 \u2192 \u03b2) (arr : Vector \u03b1 n) :\n    \u2983\u231cTrue\u231d\u2984\n    vectorize f arr\n    \u2983\u21d3result => \u231c\u2200 i : Fin n, result.get i = f (arr.get i)\u231d\u2984 := by\n  sorry", "vc-postamble": "", "qa_metadata": {"definitions_with_sorry": [], "score": 301, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 301}}
