vc-description: |-
  /- 
  {
    "name": "numpy.polynomial.polynomial.polyvander3d",
    "category": "Standard polynomials",
    "description": "Pseudo-Vandermonde matrix of given degrees.",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyvander3d.html",
    "doc": "Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\n    then The pseudo-Vandermonde matrix is defined by\n\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,\n\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\n    the powers of `x`, `y`, and `z`.\n\n    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\n\n    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the\n    same up to roundoff. This equivalence is useful both for least squares\n    fitting and for the evaluation of a large number of 3-D polynomials\n    of the same degrees and sample points.\n\n    Parameters\n    ----------\n    x, y, z : array_like\n        Arrays of point coordinates, all of the same shape. The dtypes will\n        be converted to either float64 or complex128 depending on whether\n        any of the elements are complex. Scalars are converted to 1-D\n        arrays.\n    deg : list of ints\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n    Returns\n    -------\n    vander3d : ndarray\n        The shape of the returned matrix is ``x.shape + (order,)``, where\n        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will\n        be the same as the converted `x`, `y`, and `z`.\n\n    See Also\n    --------\n    polyvander, polyvander3d, polyval2d, polyval3d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from numpy.polynomial import polynomial as P\n    >>> x = np.asarray([-1, 2, 1])\n    >>> y = np.asarray([1, -2, -3])\n    >>> z = np.asarray([2, 2, 5])\n    >>> l, m, n = [2, 2, 1]\n    >>> deg = [l, m, n]\n    >>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)\n    >>> V\n    array([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,\n             -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],\n           [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,\n             -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],\n           [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,\n            -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])\n\n    We can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,\n    and ``0 <= k <= n``\n\n    >>> i, j, k = 2, 1, 0\n    >>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k\n    array([ True,  True,  True])",
  }
  -/

  /-  Pseudo-Vandermonde matrix of given degrees for 3D polynomials.
      Returns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k
      for 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg. -/

  /-  Specification: polyvander3d creates a pseudo-Vandermonde matrix where each entry
      satisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.
      The matrix has dimensions n × ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial
      terms x^i * y^j * z^k for 0 ≤ i ≤ xDeg, 0 ≤ j ≤ yDeg, and 0 ≤ k ≤ zDeg. -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def polyvander3d {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) : 
      Id (Vector (Vector Float ((xDeg + 1) * (yDeg + 1) * (zDeg + 1))) n) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem polyvander3d_spec {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) :
      ⦃⌜True⌝⦄
      polyvander3d x y z xDeg yDeg zDeg
      ⦃⇓V => ⌜∀ p : Fin n, ∀ i : Fin (xDeg + 1), ∀ j : Fin (yDeg + 1), ∀ k : Fin (zDeg + 1),
              let colIdx := (yDeg + 1) * (zDeg + 1) * i.val + (zDeg + 1) * j.val + k.val
              let colIdxFin : Fin ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) := 
                ⟨colIdx, by sorry⟩
              (V.get p).get colIdxFin = (x.get p) ^ (Float.ofNat i.val) * (y.get p) ^ (Float.ofNat j.val) * (z.get p) ^ (Float.ofNat k.val)⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
