vc-description: |-
  /- 
  {
    "name": "numpy.fft.irfft",
    "description": "Computes the inverse of rfft",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.fft.irfft.html",
    "doc": "numpy.fft.irfft(a, n=None, axis=-1, norm=None, out=None)\n\nComputes the inverse of rfft. It performs the inverse of the one-dimensional discrete Fourier Transform for real input, such that irfft(rfft(a), len(a)) == a within numerical accuracy.\n\nParameters:\n- a: Input array\n- n: Optional length of transformed axis (default calculates based on input)\n- axis: Axis to compute inverse FFT (default is last axis)\n- norm: Normalization mode (\"backward\", \"ortho\", \"forward\")\n- out: Optional output array\n\nReturns:\n- Real-valued ndarray transformed along specified axis\n\nNotes:\n- Handles Hermitian-symmetric input from rfft\n- Requires specifying original data length to avoid information loss\n- Can resample a series via Fourier interpolation\n\nExample:\nnp.fft.irfft([1, -1j, -1])\n# Returns: array([0., 1., 0., 0.])",
  }
  -/
  
  /-  Computes the inverse of rfft (real-valued inverse FFT) -/
  
  /-  Specification: irfft computes the inverse of rfft with proper length restoration -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do
  
  /-- Complex number type for FFT operations -/
  structure Complex where
    /-- Real part of the complex number -/
    re : Float
    /-- Imaginary part of the complex number -/
    im : Float
  
  /-- Helper function to check if a vector is Hermitian-symmetric -/
  def isHermitianSymmetric {n : Nat} (a : Vector Complex n) : Prop :=
    ∀ i : Fin n, ∀ j : Fin n, (i.val + j.val = n - 1) → 
      (a.get i).re = (a.get j).re ∧ (a.get i).im = -(a.get j).im

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def irfft {k : Nat} (a : Vector Complex k) (n : Nat) : Id (Vector Float n) :=

vc-implementation: |-
  -- <vc-implementation>
    sorry
  -- </vc-implementation>

vc-condition: |-
  theorem irfft_spec {k : Nat} (a : Vector Complex k) (n : Nat) 
      (h_length : n = 2 * (k - 1)) 
      (h_hermitian : isHermitianSymmetric a) 
      (h_nonempty : k > 0) :
      ⦃⌜n = 2 * (k - 1) ∧ isHermitianSymmetric a ∧ k > 0⌝⦄
      irfft a n
      ⦃⇓result => ⌜
        -- Length preservation: output length matches specified n
        (result.toList.length = n) ∧
        -- DC component preservation: first element is real when input DC is real
        ((a.get ⟨0, h_nonempty⟩).im = 0 → 
          ∃ i : Fin n, result.get i = (a.get ⟨0, h_nonempty⟩).re) ∧
        -- Symmetry property: result has the symmetry properties of real-valued inverse FFT
        (∀ i : Fin n, ∀ j : Fin n, (i.val + j.val = n) → 
          result.get i = result.get j) ∧
        -- Hermitian input constraint: the input must be Hermitian-symmetric
        (isHermitianSymmetric a) ∧
        -- Length relationship: output length is twice the input length minus 2
        (n = 2 * (k - 1))
      ⌝⦄ := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-

