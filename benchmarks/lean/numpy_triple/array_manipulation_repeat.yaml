vc-description: |-
  /-  Repeat elements of a vector a specified number of times.
      Each element is repeated consecutively. -/

  /-  Specification: repeat creates a vector where each element from the input 
      appears consecutively 'repeats' times. The resulting vector has size n * repeats.
      
      For a vector [a₀, a₁, ..., aₙ₋₁] and repeats = r, the result is:
      [a₀, a₀, ..., a₀, a₁, a₁, ..., a₁, ..., aₙ₋₁, aₙ₋₁, ..., aₙ₋₁]
       \___r times___/  \___r times___/       \______r times______/
       
      Mathematical properties:
      1. Each element appears exactly 'repeats' times consecutively
      2. The total size is n * repeats
      3. Element at index i comes from input element at index ⌊i/repeats⌋
      4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  import Init.Data.Vector.Basic
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def «repeat» {α : Type} {n : Nat} (a : Vector α n) (repeats : Nat) : Id (Vector α (n * repeats)) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem repeat_spec {α : Type} {n : Nat} (a : Vector α n) (repeats : Nat) (h_pos : repeats > 0) :
      ⦃⌜repeats > 0⌝⦄
      «repeat» a repeats
      ⦃⇓result => ⌜(∀ i : Fin (n * repeats), 
                     ∃ (k : Fin n), 
                       i.val / repeats = k.val ∧ 
                       result.get i = a.get k) ∧
                    (∀ k : Fin n, ∀ j : Fin repeats,
                     ∃ (idx : Fin (n * repeats)),
                       idx.val = k.val * repeats + j.val ∧
                       result.get idx = a.get k)⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
