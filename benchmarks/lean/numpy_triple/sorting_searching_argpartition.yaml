vc-description: |-
  /-  Perform an indirect partition along the given axis.
      Returns an array of indices that partition the input array such that
      the kth element is in its final sorted position and all smaller
      elements are moved before it and all larger elements behind it. -/

  /-  Specification: argpartition returns indices that correctly partition the array.
      The kth element is in its final sorted position, with all smaller elements
      before it and all larger elements after it. -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def argpartition {n : Nat} (a : Vector Float n) (kth : Fin n) : Id (Vector (Fin n) n) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem argpartition_spec {n : Nat} (a : Vector Float n) (kth : Fin n) :
      ⦃⌜True⌝⦄
      argpartition a kth
      ⦃⇓indices => ⌜
        -- The indices form a valid permutation of 0..n-1
        (∀ i : Fin n, ∃ j : Fin n, indices.get j = i) ∧
        (∀ i j : Fin n, i ≠ j → indices.get i ≠ indices.get j) ∧
        -- Partition property: all elements before kth position are ≤ kth element
        (∀ i : Fin n, i < kth → a.get (indices.get i) ≤ a.get (indices.get kth)) ∧
        -- Partition property: all elements after kth position are ≥ kth element
        (∀ i : Fin n, kth < i → a.get (indices.get kth) ≤ a.get (indices.get i))
      ⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
