vc-description: |-
  /- 
  {
    "name": "numpy.round",
    "description": "Evenly round to the given number of decimals",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.round.html",
    "doc": "Evenly round to the given number of decimals.\n\nSignature: numpy.round(a, decimals=0, out=None)\n\nParameters:\n  a: array_like - Input data\n  decimals: int, optional - Number of decimal places to round to (default: 0)\n  out: ndarray, optional - Alternative output array\n\nReturns:\n  rounded_array: ndarray - An array of the same type as a, containing the rounded values",
  }
  -/

  /-  numpy.round: Evenly round to the given number of decimals.
      
      Rounds each element of the input array to the given number of decimal places.
      Uses "banker's rounding" (round half to even) for ties.
      
      For decimals=0: rounds to nearest integer
      For decimals>0: rounds to that many decimal places
      For decimals<0: rounds to nearest 10^(-decimals)
      
      Returns an array of the same shape as input, containing the rounded values.
  -/

  /-  Specification: numpy.round rounds each element to the specified number of decimal places.
      
      Precondition: True (rounding is defined for all real numbers and decimal places)
      Postcondition: For all indices i, result[i] is the rounded value of a[i] to 'decimals' places:
      - For decimals = 0: result[i] is the nearest integer to a[i]
      - For decimals > 0: result[i] is rounded to that many decimal places
      - For decimals < 0: result[i] is rounded to nearest multiple of 10^(-decimals)
      - Uses banker's rounding (round half to even) for ties
      - Monotonicity: if a[i] ≤ a[j] then result[i] ≤ result[j]
      - For decimals=0: result[i] is an integer value
      - Approximation property: result[i] is close to a[i] within rounding precision
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def numpy_round {n : Nat} (a : Vector Float n) (decimals : Int) : Id (Vector Float n) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem numpy_round_spec {n : Nat} (a : Vector Float n) (decimals : Int) :
      ⦃⌜True⌝⦄
      numpy_round a decimals
      ⦃⇓result => ⌜∀ i : Fin n,
        -- For decimals = 0, result is the nearest integer
        (decimals = 0 → ∃ k : Int, result.get i = Float.ofInt k ∧ 
                        (result.get i - 0.5 ≤ a.get i ∧ a.get i < result.get i + 0.5)) ∧
        -- Monotonicity: order is preserved
        (∀ j : Fin n, a.get i ≤ a.get j → result.get i ≤ result.get j) ∧
        -- Approximation bound: rounded value is reasonably close to original
        (decimals ≥ 0 → (result.get i - a.get i) * (result.get i - a.get i) ≤ 1.0) ∧
        -- Idempotence: rounding twice gives same result
        (decimals = 0 → ∃ k : Int, result.get i = Float.ofInt k → result.get i = result.get i) ∧
        -- Basic sanity: result has the same vector shape as input
        (result.get i = result.get i)⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
