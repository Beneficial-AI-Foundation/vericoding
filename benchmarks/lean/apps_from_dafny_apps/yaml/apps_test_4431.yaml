vc-preamble: |-
  def ValidInput (n k : Nat) (s : String) (available : List Char) : Prop :=
    n = s.length ∧
    k = available.length ∧
    ∀ i j, 0 ≤ i ∧ i < j ∧ j < available.length → available[i]! ≠ available[j]!

  def CountValidSubstrings (s : String) (availableSet : List Char) : Nat :=
    sorry

  def GetMaximalValidSegments (s : String) (availableSet : List Char) (startIdx : Nat) : List Nat :=
    sorry

  def GetNextSegmentLength (s : String) (availableSet : List Char) (startIdx : Nat) : Nat :=
    sorry

  def SkipInvalidChars (s : String) (availableSet : List Char) (startIdx : Nat) : Nat :=
    sorry

  def SumSegmentCounts (segments : List Nat) : Nat :=
    sorry

  @[reducible, simp]
  def solve_precond (n k : Nat) (s : String) (available : List Char) : Prop :=
    ValidInput n k s available

vc-helpers: |-

vc-definitions: |-
  def solve (n k : Nat) (s : String) (available : List Char) (h_precond : solve_precond n k s available) : Nat :=
    sorry

vc-theorems: |-
  @[reducible, simp]
  def solve_postcond (n k : Nat) (s : String) (available : List Char) (result : Nat) (h_precond : solve_precond n k s available) : Prop :=
    result ≤ n * (n + 1) / 2 ∧
    result = CountValidSubstrings s available

  theorem solve_spec_satisfied (n k : Nat) (s : String) (available : List Char) (h_precond : solve_precond n k s available) :
      solve_postcond n k s available (solve n k s available h_precond) h_precond := by
    sorry

vc-postamble: |-