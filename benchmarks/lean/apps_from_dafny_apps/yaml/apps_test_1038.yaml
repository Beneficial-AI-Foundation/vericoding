vc-preamble: |-
  -- <vc-preamble>
  def ValidInput (a b : Int) : Prop :=
    0 ≤ a ∧ a ≤ b

  def XorInt (x y : Int) : Int :=
    if x = 0 ∧ y = 0 then 0
    else if x = 0 then y
    else if y = 0 then x
    else
      let bit_x := x % 2
      let bit_y := y % 2
      let xor_bit := if bit_x ≠ bit_y then 1 else 0
      xor_bit + 2 * XorInt (x / 2) (y / 2)
  termination_by x.natAbs + y.natAbs
  decreasing_by
    simp_wf
    sorry

  def XorRange (a b : Int) : Int :=
    if a = b then a
    else XorInt a (XorRange (a + 1) b)
  termination_by (b - a).natAbs
  decreasing_by
    simp_wf
    sorry

  @[reducible, simp]
  def solve_precond (a b : Int) : Prop :=
    ValidInput a b
  -- </vc-preamble>

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  -- <vc-definitions>
  def solve (a b : Int) (_ : solve_precond a b) : Int :=
    sorry
  -- </vc-definitions>

vc-theorems: |-
  -- <vc-theorems>
  @[reducible, simp]
  def solve_postcond (a b : Int) (result : Int) (_ : solve_precond a b) : Prop :=
    result = XorRange a b ∧ result ≥ 0

  theorem solve_spec_satisfied (a b : Int) (h_precond : solve_precond a b) :
      solve_postcond a b (solve a b h_precond) h_precond := by
    sorry
  -- </vc-theorems>

vc-postamble: |-