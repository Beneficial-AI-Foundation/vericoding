vc-preamble: |-
  def ValidPermutation (p : List Int) (n : Int) : Prop :=
    p.length = n.natAbs ∧ n ≥ 1 ∧
    (∀ i, 0 ≤ i ∧ i < n → 1 ≤ p[i.natAbs]! ∧ p[i.natAbs]! ≤ n) ∧
    (∀ i j, 0 ≤ i ∧ i < j ∧ j < n → p[i.natAbs]! ≠ p[j.natAbs]!)

  def countRecordsFromIndex (s : List Int) (idx : Int) (maxSoFar : Int) : Int :=
    sorry

  def countRecords (s : List Int) : Int :=
    if s.length = 0 then 0
    else 1 + countRecordsFromIndex s 1 (s[0]!)

  def indexOf (p : List Int) (toRemove : Int) : Int :=
    sorry

  def countRecordsAfterRemoval (p : List Int) (toRemove : Int) : Int :=
    let filtered := (List.range (p.length - 1)).map (fun i =>
      let iInt := Int.ofNat i
      if indexOf p toRemove ≤ iInt then p[i + 1]! else p[i]!)
    countRecords filtered

  @[reducible, simp]
  def solve_precond (n : Int) (p : List Int) : Prop :=
    ValidPermutation p n

vc-helpers: |-

vc-definitions: |-
  def solve (n : Int) (p : List Int) (h_precond : solve_precond n p) : Int :=
    sorry

vc-theorems: |-
  @[reducible, simp]
  def solve_postcond (n : Int) (p : List Int) (result : Int) (h_precond : solve_precond n p) : Prop :=
    1 ≤ result ∧ result ≤ n ∧
    result ∈ p ∧
    (∀ x, x ∈ p → countRecordsAfterRemoval p result ≥ countRecordsAfterRemoval p x) ∧
    (∀ x, x ∈ p ∧ countRecordsAfterRemoval p x = countRecordsAfterRemoval p result → result ≤ x)

  theorem solve_spec_satisfied (n : Int) (p : List Int) (h_precond : solve_precond n p) :
      solve_postcond n p (solve n p h_precond) h_precond := by
    sorry

vc-postamble: |-