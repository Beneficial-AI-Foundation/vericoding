vc-preamble: |-
  -- <vc-preamble>
  def ValidInput (stdin_input : String) : Prop :=
    stdin_input.length > 0

  def SplitLinesFuncHelper (s : String) (i : Nat) (current : String) (acc : List String) : List String :=
    sorry

  def SplitLinesFunc (s : String) : List String :=
    SplitLinesFuncHelper s 0 "" []

  def StringToIntHelper (s : String) : Int :=
    sorry

  def StringToInt (s : String) : Int :=
    sorry

  def IntToStringHelper (n : Int) : String :=
    sorry

  def IntToString (n : Int) : String :=
    sorry

  def ExpectedOutput (stdin_input : String) : String :=
    let lines := SplitLinesFunc stdin_input
    if lines.length ≥ 1 then
      let n := StringToInt (lines[0]!)
      if n = 1 then "Hello World\n"
      else if n ≠ 1 ∧ lines.length ≥ 3 then
        let a := StringToInt (lines[1]!)
        let b := StringToInt (lines[2]!)
        IntToString (a + b) ++ "\n"
      else ""
    else ""

  @[reducible, simp]
  def solve_precond (stdin_input : String) : Prop :=
    ValidInput stdin_input
  -- </vc-preamble>

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  -- <vc-definitions>
  def solve (stdin_input : String) (h_precond : solve_precond stdin_input) : String :=
    sorry
  -- </vc-definitions>

vc-theorems: |-
  -- <vc-theorems>
  @[reducible, simp]
  def solve_postcond (stdin_input : String) (result : String) (h_precond : solve_precond stdin_input) : Prop :=
    result = ExpectedOutput stdin_input

  theorem solve_spec_satisfied (stdin_input : String) (h_precond : solve_precond stdin_input) :
      solve_postcond stdin_input (solve stdin_input h_precond) h_precond := by
    sorry
  -- </vc-theorems>

vc-postamble: |-