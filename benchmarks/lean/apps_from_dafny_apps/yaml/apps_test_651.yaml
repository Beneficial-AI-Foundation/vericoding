vc-preamble: |-
  -- Helper function declarations (assumed to exist)
  def SplitLines (input : String) : List String := sorry
  def ParseTwoInts (line : String) : Int × Int := sorry
  def CountOccurrences (lines : List String) (n m : Int) (c : Char) : Int := sorry
  def FindStart (lines : List String) (n m : Int) : Int × Int := sorry
  def FindEnd (lines : List String) (n m : Int) : Int × Int := sorry
  def CountPermutationsReachingGoal (lines : List String) (n m : Int) (path : String) (start end_pos : Int × Int) : Int := sorry
  def StringToInt (s : String) : Int := sorry

  def ValidPathString (path : String) : Prop :=
    ∀ i, 0 ≤ i ∧ i < path.length → '0' ≤ path.data[Int.natAbs i]! ∧ path.data[Int.natAbs i]! ≤ '3'

  def HasValidDimensions (lines : List String) : Prop :=
    lines.length ≥ 1 →
    let dimensions := ParseTwoInts (lines[0]!)
    let n := dimensions.1
    let m := dimensions.2
    n > 0 ∧ m > 0 ∧ lines.length ≥ Int.natAbs (n + 2)

  def HasValidGrid (lines : List String) : Prop :=
    lines.length ≥ 1 →
    let dimensions := ParseTwoInts (lines[0]!)
    let n := dimensions.1
    let m := dimensions.2
    n > 0 ∧ m > 0 ∧ lines.length ≥ Int.natAbs (n + 2) ∧
    ∀ i, 1 ≤ i ∧ i ≤ n ∧ Int.natAbs i < lines.length →
      ∀ j, 0 ≤ j ∧ Int.natAbs j < (lines[Int.natAbs i]!).length ∧ j < m →
        (lines[Int.natAbs i]!).data[Int.natAbs j]! ∈ ['.', '#', 'S', 'E']

  def HasStartAndEnd (lines : List String) : Prop :=
    lines.length ≥ 1 →
    let dimensions := ParseTwoInts (lines[0]!)
    let n := dimensions.1
    let m := dimensions.2
    n > 0 ∧ m > 0 ∧ lines.length ≥ Int.natAbs (n + 2) ∧
    (∃ i j, 1 ≤ i ∧ i ≤ n ∧ Int.natAbs i < lines.length ∧ 0 ≤ j ∧ Int.natAbs j < (lines[Int.natAbs i]!).length ∧ j < m ∧ (lines[Int.natAbs i]!).data[Int.natAbs j]! = 'S') ∧
    (∃ i j, 1 ≤ i ∧ i ≤ n ∧ Int.natAbs i < lines.length ∧ 0 ≤ j ∧ Int.natAbs j < (lines[Int.natAbs i]!).length ∧ j < m ∧ (lines[Int.natAbs i]!).data[Int.natAbs j]! = 'E') ∧
    CountOccurrences lines n m 'S' = 1 ∧
    CountOccurrences lines n m 'E' = 1

  def HasValidPath (lines : List String) : Prop :=
    lines.length ≥ 1 →
    let dimensions := ParseTwoInts (lines[0]!)
    let n := dimensions.1
    let m := dimensions.2
    n > 0 ∧ m > 0 ∧ lines.length ≥ Int.natAbs (n + 2) ∧
    ValidPathString (lines[Int.natAbs (n + 1)]!)

  def ValidInput (input : String) : Prop :=
    let lines := SplitLines input
    lines.length ≥ 3 ∧
    HasValidDimensions lines ∧
    HasValidGrid lines ∧
    HasStartAndEnd lines ∧
    HasValidPath lines

  def ValidResult (result : String) : Prop :=
    result.length > 0 ∧
    ∀ c, c ∈ result.toList → ('0' ≤ c ∧ c ≤ '9') ∨ c = '\n'

  def CountValidWays (input : String) : Int :=
    let lines := SplitLines input
    let dimensions := ParseTwoInts (lines[0]!)
    let n := dimensions.1
    let m := dimensions.2
    let start := FindStart lines n m
    let end_pos := FindEnd lines n m
    let path := lines[Int.natAbs (n + 1)]!
    CountPermutationsReachingGoal lines n m path start end_pos

  @[reducible, simp]
  def solve_precond (stdin_input : String) : Prop :=
    stdin_input.length > 0

vc-helpers: |-

vc-definitions: |-
  def solve (stdin_input : String) (h_precond : solve_precond stdin_input) : String :=
    sorry

vc-theorems: |-
  @[reducible, simp]
  def solve_postcond (stdin_input : String) (result : String) (h_precond : solve_precond stdin_input) : Prop :=
    ValidResult result ∧
    (let numResult := StringToInt (if '\n' ∈ result.toList then result.take (result.length - 1) else result)
     0 ≤ numResult ∧ numResult ≤ 24) ∧
    (ValidInput stdin_input →
     let numResult := StringToInt (if '\n' ∈ result.toList then result.take (result.length - 1) else result)
     numResult = CountValidWays stdin_input) ∧
    (¬ValidInput stdin_input →
     StringToInt (if '\n' ∈ result.toList then result.take (result.length - 1) else result) = 0)

  theorem solve_spec_satisfied (stdin_input : String) (h_precond : solve_precond stdin_input) :
      solve_postcond stdin_input (solve stdin_input h_precond) h_precond := by
    sorry

vc-postamble: |-