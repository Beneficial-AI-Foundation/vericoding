vc-preamble: |-
  def is_binary_string (s : String) : Prop :=
    ∀ i, i < s.length → s.data[i]! = '0' ∨ s.data[i]! = '1'

  def is_valid_integer (s : String) : Prop :=
    s.length > 0 ∧ (s.data[0]! ≠ '0' ∨ s.length = 1) ∧ 
    ∀ i, i < s.length → '0' ≤ s.data[i]! ∧ s.data[i]! ≤ '9'

  def count_char (s : String) (c : Char) : Int :=
    (s.toList.filter (· = c)).length

  def abs_diff_count (s : String) (h : is_binary_string s) : Int :=
    let count0 := count_char s '0'
    let count1 := count_char s '1'
    if count1 ≥ count0 then count1 - count0 else count0 - count1

  def char_of_digit (d : Int) (h : 0 ≤ d ∧ d ≤ 9) : Char :=
    match d with
    | 0 => '0'
    | 1 => '1'
    | 2 => '2'
    | 3 => '3'
    | 4 => '4'
    | 5 => '5'
    | 6 => '6'
    | 7 => '7'
    | 8 => '8'
    | 9 => '9'
    | _ => '0'

  def int_to_string : Int → String
    | n => if n = 0 then "0"
           else if n > 0 ∧ n < 10 then String.mk [char_of_digit n (by sorry)]
           else if n > 0 then int_to_string (n / 10) ++ String.mk [char_of_digit (n % 10) (by sorry)]
           else ""
  termination_by n => Int.natAbs n

  def string_to_int (s : String) (h : is_valid_integer s) : Int :=
    sorry

  def string_slice (s : String) (start_pos end_pos : Nat) : String :=
    String.mk (s.toList.drop start_pos |>.take (end_pos - start_pos))

  @[reducible, simp]
  def solve_precond (stdin_input : String) : Prop :=
    stdin_input.length > 0 ∧
    (∃ i, i < stdin_input.length ∧ stdin_input.data[i]! = '\n') ∧
    (∃ newline_pos, newline_pos < stdin_input.length ∧ 
     stdin_input.data[newline_pos]! = '\n' ∧
     newline_pos + 1 < stdin_input.length ∧
     ∃ binary_end, newline_pos + 1 ≤ binary_end ∧ binary_end ≤ stdin_input.length ∧
     (binary_end = stdin_input.length ∨ stdin_input.data[binary_end]! = '\n') ∧
     is_valid_integer (string_slice stdin_input 0 newline_pos) ∧
     is_binary_string (string_slice stdin_input (newline_pos + 1) binary_end))

vc-helpers: |-

vc-definitions: |-
  def solve (stdin_input : String) (h_precond : solve_precond stdin_input) : String :=
    sorry

vc-theorems: |-
  @[reducible, simp]
  def solve_postcond (stdin_input : String) (result : String) (h_precond : solve_precond stdin_input) : Prop :=
    result.length > 0 ∧
    result.data[result.length - 1]! = '\n' ∧
    (∃ newline_pos, newline_pos < stdin_input.length ∧ 
     stdin_input.data[newline_pos]! = '\n' ∧
     newline_pos + 1 < stdin_input.length ∧
     ∃ binary_end, newline_pos + 1 ≤ binary_end ∧ binary_end ≤ stdin_input.length ∧
     (binary_end = stdin_input.length ∨ stdin_input.data[binary_end]! = '\n') ∧
     is_binary_string (string_slice stdin_input (newline_pos + 1) binary_end) ∧
     result = int_to_string (abs_diff_count (string_slice stdin_input (newline_pos + 1) binary_end) (by sorry)) ++ "\n")

  theorem solve_spec_satisfied (stdin_input : String) (h_precond : solve_precond stdin_input) :
      solve_postcond stdin_input (solve stdin_input h_precond) h_precond := by
    sorry

vc-postamble: |-