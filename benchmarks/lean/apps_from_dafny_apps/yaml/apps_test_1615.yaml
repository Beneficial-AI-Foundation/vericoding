vc-preamble: |-
  -- <vc-preamble>
  -- Helper functions and predicates translated from Dafny
  def SplitLines (s : String) : List String := sorry
  def ParsesAsIntegers (line : String) (a b : Int) : Prop := sorry
  def ContainsNewline (s : String) : Bool := sorry
  def IsNumericOutput (s : String) : Bool := sorry
  def IntToString (n : Int) : String := sorry
  def MaxInt (a b : Int) : Int := max a b
  def MinInt (a b : Int) : Int := min a b

  def ValidInputFormat (s : String) : Prop :=
    let lines := SplitLines s
    lines.length ≥ 1 ∧
    ∃ n k : Nat, 
      ParsesAsIntegers (lines[0]!) n k ∧ n > 0 ∧ k > 0 ∧ lines.length ≥ n + 1 ∧
      (∀ i, 1 ≤ i ∧ i ≤ n ∧ i < lines.length → 
        ∃ a b : Int, ParsesAsIntegers (lines[i]!) a b)

  def ParsedCorrectly (input : String) (n k : Nat) (segments : List (Int × Int)) : Prop :=
    let lines := SplitLines input
    lines.length ≥ n + 1 ∧ segments.length = n ∧
    ParsesAsIntegers (lines[0]!) n k ∧
    (∀ i, 0 ≤ i ∧ i < n ∧ i + 1 < lines.length → 
      ParsesAsIntegers (lines[i + 1]!) (segments[i]!).1 (segments[i]!).2)

  def IsValidOutput (s : String) : Prop :=
    s.length > 0 ∧ 
    (∀ i, i + 1 = s.length → s.data[i]! = '\n') ∧ 
    (∀ i, i < s.length - 1 → s.data[i]! ≠ '\n') ∧
    IsNumericOutput (s.take (s.length - 1))

  def SegmentLength (segment : Int × Int) : Nat :=
    let maxVal := MaxInt segment.1 segment.2
    let minVal := MinInt segment.1 segment.2
    if maxVal ≥ minVal then Int.natAbs (maxVal - minVal + 1) else 1

  def TotalCoverage (segments : List (Int × Int)) : Nat :=
    match segments with
    | [] => 0
    | s :: rest => SegmentLength s + TotalCoverage rest

  def MinMovesToDivisible (segments : List (Int × Int)) (k : Nat) : Nat :=
    if k = 0 then 0 else
      let totalCoverage := TotalCoverage segments
      let remainder := totalCoverage % k
      if remainder = 0 then 0 else k - remainder

  @[reducible, simp]
  def solve_precond (stdin_input : String) : Prop :=
    stdin_input.length > 0 ∧
    ((∀ i, i + 1 = stdin_input.length → stdin_input.data[i]! = '\n') ∨ ¬ContainsNewline stdin_input)
  -- </vc-preamble>

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  -- <vc-definitions>
  def solve (stdin_input : String) (h_precond : solve_precond stdin_input) : String :=
    sorry
  -- </vc-definitions>

vc-theorems: |-
  -- <vc-theorems>
  @[reducible, simp]
  def solve_postcond (stdin_input : String) (result : String) (h_precond : solve_precond stdin_input) : Prop :=
    (result.length = 0 ∨ (∀ i, i + 1 = result.length → result.data[i]! = '\n')) ∧
    (ValidInputFormat stdin_input → 
      ∃ n k : Nat, ∃ segments : List (Int × Int),
        n > 0 ∧ k > 0 ∧ segments.length = n ∧
        ParsedCorrectly stdin_input n k segments ∧
        result = IntToString (MinMovesToDivisible segments k) ++ "\n") ∧
    (ValidInputFormat stdin_input → IsValidOutput result) ∧
    (¬ValidInputFormat stdin_input → 
      (result = "" ∨ (result.length > 0 ∧ (∀ i, i + 1 = result.length → result.data[i]! = '\n'))))

  theorem solve_spec_satisfied (stdin_input : String) (h_precond : solve_precond stdin_input) :
      solve_postcond stdin_input (solve stdin_input h_precond) h_precond := by
    sorry
  -- </vc-theorems>

vc-postamble: |-