vc-preamble: |-
  -- <vc-preamble>
  noncomputable def splitLinesFunc : String → List String := sorry
  noncomputable def splitSpacesFunc : String → List String := sorry
  noncomputable def stringToIntFunc : String → Nat := sorry
  noncomputable def intToStringFunc : Nat → String := sorry
  noncomputable def joinLinesSeq : List String → String := sorry

  def minStepsToZero (n k : Nat) (hk : k ≥ 2) : Nat :=
    if n = 0 then 0
    else if n % k = 0 then 1 + minStepsToZero (n / k) k hk
    else (n % k) + minStepsToZero (n - (n % k)) k hk
  termination_by n
  decreasing_by
    simp_wf
    · have h1 : k ≥ 2 := hk
      have h2 : n > 0 := by omega
      have h3 : n % k = 0 := by assumption
      have h4 : n / k < n := Nat.div_lt_self h2 h1
      exact h4
    · omega

  def isValidNumber (s : String) : Prop :=
    s.length ≥ 1 ∧
    (s = "0" ∨ (s.data[0]! ≠ '0' ∧ ∀ i, i < s.length → '0' ≤ s.data[i]! ∧ s.data[i]! ≤ '9')) ∧
    ∀ i, i < s.length → '0' ≤ s.data[i]! ∧ s.data[i]! ≤ '9'

  def validTestCase (line : String) : Prop :=
    let parts := splitSpacesFunc line
    parts.length = 2 ∧
    isValidNumber (parts[0]!) ∧
    isValidNumber (parts[1]!) ∧
    let n := stringToIntFunc (parts[0]!)
    let k := stringToIntFunc (parts[1]!)
    n ≥ 1 ∧ k ≥ 2

  def validInput (input : String) : Prop :=
    input.length > 0 ∧
    let lines := splitLinesFunc input
    lines.length ≥ 1 ∧
    isValidNumber (lines[0]!) ∧
    let t := stringToIntFunc (lines[0]!)
    t ≥ 1 ∧ t ≤ 100 ∧
    lines.length ≥ t + 1 ∧
    ∀ i, 1 ≤ i ∧ i ≤ t → validTestCase (lines[i]!)

  noncomputable def expectedOutput (input : String) : String :=
    let lines := splitLinesFunc input
    let t := stringToIntFunc (lines[0]!)
    let results := (List.range t).map (fun i =>
      let parts := splitSpacesFunc (lines[i + 1]!)
      let n := stringToIntFunc (parts[0]!)
      let k := stringToIntFunc (parts[1]!)
      intToStringFunc (minStepsToZero n k (by sorry)))
    joinLinesSeq results

  @[reducible, simp]
  def solve_precond (input : String) : Prop :=
    input.length > 0 ∧ validInput input
  -- </vc-preamble>

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  -- <vc-definitions>
  noncomputable def solve (input : String) (h_precond : solve_precond input) : String :=
    sorry
  -- </vc-definitions>

vc-theorems: |-
  -- <vc-theorems>
  @[reducible, simp]
  def solve_postcond (input : String) (result : String) (h_precond : solve_precond input) : Prop :=
    result.length ≥ 0 ∧
    (∀ i, i < result.length → result.data[i]! ≠ '\x00') ∧
    result = expectedOutput input

  theorem solve_spec_satisfied (input : String) (h_precond : solve_precond input) :
      solve_postcond input (solve input h_precond) h_precond := by
    sorry
  -- </vc-theorems>

vc-postamble: |-