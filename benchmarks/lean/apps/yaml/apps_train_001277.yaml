vc-description: |-
  /-
  Snackdown 2019 is coming! There are two rounds (round A and round B) after the qualification round. From both of them, teams can qualify to the pre-elimination round. According to the rules, in each of these two rounds, teams are sorted in descending order by their score and each team with a score greater or equal to the score of the team at the $K=1500$-th place advances to the pre-elimination round (this means it is possible to have more than $K$ qualified teams from each round in the case of one or more ties after the $K$-th place).
  Today, the organizers ask you to count the number of teams which would qualify for the pre-elimination round from round A for a given value of $K$ (possibly different from $1500$). They provided the scores of all teams to you; you should ensure that all teams scoring at least as many points as the $K$-th team qualify.
  
  -----Input-----
  - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.
  - The first line of each test case contains two space-separated integers $N$ and $K$.
  - The second line contains $N$ space-separated integers $S_1, S_2, \dots, S_N$.
  
  -----Output-----
  For each test case, print a single line containing one integer — the number of qualified teams.
  
  -----Constraints-----
  - $1 \le T \le 1,000$
  - $1 \le K \le N \le 10^5$
  - $1 \le S_i \le 10^9$ for each valid $i$
  - the sum of $N$ for all test cases does not exceed $10^6$
  
  -----Example Input-----
  2
  5 1
  3 5 2 4 5
  6 4
  6 5 4 3 2 1
  
  -----Example Output-----
  2
  4
  -/

vc-preamble: |-
  def count_qualified_teams (n : Nat) (k : Nat) (scores : List Int) : Nat := sorry
  
  theorem count_qualified_teams_bounds (n : Nat) (k : Nat) (scores : List Int) 
      (h1 : k > 0)
      (h2 : k ≤ scores.length)
      (h3 : scores.length = n) :
      k ≤ count_qualified_teams n k scores ∧ count_qualified_teams n k scores ≤ n := sorry
  
  def list_max (l : List Int) : Int := 
    match l with
    | [] => 0
    | x::xs => List.foldl max x xs

vc-helpers: |-

vc-definitions: |-
  def list_unique (l : List Int) : Prop :=
    ∀ (i j : Fin l.length), i.val ≠ j.val → l[i] ≠ l[j]

vc-theorems: |-
  theorem count_qualified_teams_deterministic (n : Nat) (k : Nat) (scores : List Int)
      (h1 : k > 0)
      (h2 : k ≤ scores.length)
      (h3 : scores.length = n) :
      count_qualified_teams n k scores = count_qualified_teams n k scores := sorry
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval count_qualified_teams 5 1 [3, 5, 2, 4, 5]
  
  /-
  info: 4
  -/
  -- #guard_msgs in
  -- #eval count_qualified_teams 6 4 [6, 5, 4, 3, 2, 1]
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval count_qualified_teams 4 2 [10, 10, 8, 8]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

