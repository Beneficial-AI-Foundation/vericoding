vc-description: |-
  /-
  For this exercise you will create a global flatten method. The method takes in any number of arguments and flattens them into a single array. If any of the arguments passed in are an array then the individual objects within the array will be flattened so that they exist at the same level as the other arguments. Any nested arrays, no matter how deep, should be flattened into the single array result.
  
  The following are examples of how this function would be used and what the expected results would be:
  
  ```python
  flatten(1, [2, 3], 4, 5, [6, [7]]) # returns [1, 2, 3, 4, 5, 6, 7]
  flatten('a', ['b', 2], 3, None, [[4], ['c']]) # returns ['a', 'b', 2, 3, None, 4, 'c']
  ```
  -/

vc-preamble: |-
  def flatten {α : Type} : List (List α) → List α 
    | [] => sorry
    | x :: xs => sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def isNestedList {α : Type} : List (List α) → Bool
    | [] => sorry
    | x :: xs => sorry

vc-theorems: |-
  theorem flatten_preserves_elements {α : Type} (lst : List (List α)) (inner : List α) :
    inner ∈ lst →
    ∀ x ∈ inner, x ∈ (flatten lst) :=
  sorry
  
  theorem flatten_identity_on_simple_list {α : Type} (lst : List α) :
    flatten [lst] = lst :=
  sorry
  
  theorem flatten_length_simple {α : Type} (lst : List α) :
    List.length (flatten [lst]) = List.length lst :=
  sorry
  
  theorem flatten_nested_ints (lst : List (List Int)) (n : Int) : 
    n ∈ (flatten lst) →
    ∃ inner : List Int, inner ∈ lst ∧ n ∈ inner :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

