vc-description: |-
  /-
  A [Word Square](https://en.wikipedia.org/wiki/Word_square) is a set of words written out in a square grid, such that the same words can be read both horizontally and vertically. The number of words, equal to the number of letters in each word, is known as the *order* of the square.
  
  For example, this is an *order* `5` square found in the ruins of Herculaneum:
  
  ![](https://i.gyazo.com/e226262e3ada421d4323369fb6cf66a6.jpg)
  
  Given a string of various uppercase `letters`, check whether a *Word Square* can be formed from it. 
  
  Note that you should use each letter from `letters` the exact number of times it occurs in the string. If a *Word Square* can be formed, return `true`, otherwise return `false`.
  
  __Example__
  
    * For `letters = "SATORAREPOTENETOPERAROTAS"`, the output should be
    `WordSquare(letters) = true`.
      It is possible to form a *word square* in the example above.
  
    * For `letters = "AAAAEEEENOOOOPPRRRRSSTTTT"`, (which is sorted form of `"SATORAREPOTENETOPERAROTAS"`), the output should also be
    `WordSquare(letters) = true`.
  
    * For `letters = "NOTSQUARE"`, the output should be
    `WordSquare(letters) = false`.
  
  __Input/Output__
  
  * [input] string letters
  
    A string of uppercase English letters.
  
    Constraints: `3 ≤ letters.length ≤ 100`.
  
  * [output] boolean
  
    `true`, if a Word Square can be formed;
  
    `false`, if a Word Square cannot be formed.
  -/

vc-preamble: |-
  def word_square (s : String) : Bool := sorry
  
  theorem non_square_length_strings_are_false {s : String} 
    (h : ∃ n : Nat, n * n ≠ s.length) : 
    word_square s = false := sorry
  
  def countChar (c : Char) (s : List Char) : Nat :=
    (s.filter (fun x => x = c)).length

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def count_odd_occurrences (s : String) : Nat :=
    let chars := s.toList
    let counts := chars.map (fun c => countChar c chars)
    (counts.filter (fun n => n % 2 = 1)).length

vc-theorems: |-
  theorem all_same_letter_square_strings_are_valid (n : Nat) :
    word_square (String.mk (List.replicate (n*n) 'A')) = true := sorry
  
  theorem alternating_letters_within_bounds (n : Nat) (h : n ≥ 2) :
    let letters := List.replicate (n*n) 'A'
    word_square (String.mk letters) = true := sorry
  
  theorem odd_count_characters_within_bounds (s : String) :
    let n := s.length
    if n*n ≠ s.length then
      word_square s = false
    else 
      word_square s = (count_odd_occurrences s ≤ n) := sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval word_square "SATORAREPOTENETOPERAROTAS"
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval word_square "NOTSQUARE"
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval word_square "CARDAREAREARDART"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

