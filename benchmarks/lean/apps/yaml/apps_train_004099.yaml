vc-description: |-
  /-
  Implement a function which behaves like the uniq command in UNIX.
  
  It takes as input a sequence and returns a sequence in which all duplicate elements following each other have been reduced to one instance.
  
  Example:
  
  ```
  ["a", "a", "b", "b", "c", "a", "b", "c"]  =>  ["a", "b", "c", "a", "b", "c"]
  ```
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def uniq {α} [BEq α] (lst : List α) : List α :=
    sorry

vc-theorems: |-
  theorem uniq_no_consecutive_duplicates {α} [BEq α] (lst : List α) :
    let result := uniq lst
    ∀ i, i < result.length - 1 → result[i]? ≠ result[i+1]? :=
  sorry
  
  theorem uniq_elements_from_original {α} [BEq α] (lst : List α) :
    ∀ x ∈ uniq lst, x ∈ lst :=
  sorry
  
  theorem uniq_length_le_input {α} [BEq α] (lst : List α) :
    (uniq lst).length ≤ lst.length :=
  sorry
  
  theorem uniq_preserves_first_occurrence {α} [BEq α] [DecidableEq α] (lst : List α) :
    ∀ val ∈ uniq lst,
    lst.findIdx? (fun x => decide (x = val)) = lst.findIdx? (fun x => decide (x = val)) :=
  sorry
  
  theorem uniq_all_none [BEq α] (lst : List (Option α)) (h : lst.length > 0) (h2 : ∀ x ∈ lst, x = none) :
    (uniq lst).length = 1 :=
  sorry
  
  theorem uniq_all_identical {α} [BEq α] (lst : List α) (x : α) (h : lst.length > 0) (h2 : ∀ y ∈ lst, y = x) :
    (uniq lst).length = 1 :=
  sorry
  
  /-
  info: ['a', 'b', 'c', 'a', 'b', 'c']
  -/
  -- #guard_msgs in
  -- #eval uniq ["a", "a", "b", "b", "c", "a", "b", "c", "c"]
  
  /-
  info: ['a', 'b', 'c']
  -/
  -- #guard_msgs in
  -- #eval uniq ["a", "a", "a", "b", "b", "b", "c", "c", "c"]
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval uniq []
  
  /-
  info: [None, 'a']
  -/
  -- #guard_msgs in
  -- #eval uniq [None, "a", "a"]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

