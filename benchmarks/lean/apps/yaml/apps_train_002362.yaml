vc-description: |-
  /-
  You are given an array A of strings.
  A move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.
  Two strings S and T are special-equivalent if after any number of moves onto S, S == T.
  For example, S = "zzxy" and T = "xyzz" are special-equivalent because we may make the moves "zzxy" -> "xzzy" -> "xyzz" that swap S[0] and S[2], then S[1] and S[3].
  Now, a group of special-equivalent strings from A is a non-empty subset of A such that:
  
  Every pair of strings in the group are special equivalent, and;
  The group is the largest size possible (ie., there isn't a string S not in the group such that S is special equivalent to every string in the group)
  
  Return the number of groups of special-equivalent strings from A.
  
  Example 1:
  Input: ["abcd","cdab","cbad","xyzz","zzxy","zzyx"]
  Output: 3
  Explanation: 
  One group is ["abcd", "cdab", "cbad"], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.
  
  The other two groups are ["xyzz", "zzxy"] and ["zzyx"].  Note that in particular, "zzxy" is not special equivalent to "zzyx".
  
  Example 2:
  Input: ["abc","acb","bac","bca","cab","cba"]
  Output: 3
  
  Note:
  
  1 <= A.length <= 1000
  1 <= A[i].length <= 20
  All A[i] have the same length.
  All A[i] consist of only lowercase letters.
  -/

vc-preamble: |-
  def numSpecialEquivGroups (strings : List String) : Nat :=
    sorry
  
  def isSpecialEquivalent (s1 s2 : String) : Bool :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def belongsToGroup (s : String) (g : Nat) : Bool :=
    sorry
  
  -- Theorem: Number of groups is bounded by list size

vc-theorems: |-
  theorem num_groups_bounded (strings : List String) : 
    1 ≤ numSpecialEquivGroups strings ∧ numSpecialEquivGroups strings ≤ strings.length :=
    sorry
  
  -- Theorem: Special equivalent strings belong to same group
  
  theorem special_equiv_same_group (s1 s2 : String) :
    isSpecialEquivalent s1 s2 = true →
    ∃ g, belongsToGroup s1 g = true ∧ belongsToGroup s2 g = true :=
    sorry 
  
  -- Theorem: Upper bound for unique strings
  
  theorem unique_strings_bound (strings : List String) (h : strings.Nodup) :
    numSpecialEquivGroups strings ≤ strings.length :=
    sorry
  
  -- Theorem: Function is permutation invariant
  
  theorem permutation_invariant (strings : List String) :
    numSpecialEquivGroups strings = numSpecialEquivGroups strings.reverse :=
    sorry
  
  /-
  info: 3
  -/
  -- #guard_msgs in
  -- #eval numSpecialEquivGroups ["abcd", "cdab", "cbad", "xyzz", "zzxy", "zzyx"]
  
  /-
  info: 3
  -/
  -- #guard_msgs in
  -- #eval numSpecialEquivGroups ["abc", "acb", "bac", "bca", "cab", "cba"]
  
  /-
  info: 4
  -/
  -- #guard_msgs in
  -- #eval numSpecialEquivGroups ["aa", "bb", "ab", "ba"]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

