vc-description: |-
  /-
  # Task
   Your Informatics teacher at school likes coming up with new ways to help you understand the material. When you started studying numeral systems, he introduced his own numeral system, which he's convinced will help clarify things. His numeral system has base 26, and its digits are represented by English capital letters - `A for 0, B for 1, and so on`.
  
   The teacher assigned you the following numeral system exercise: given a one-digit `number`, you should find all unordered pairs of one-digit numbers whose values add up to the `number`.
  
  # Example
  
   For `number = 'G'`, the output should be `["A + G", "B + F", "C + E", "D + D"]`
  
   Translating this into the decimal numeral system we get: number = 6, so it is `["0 + 6", "1 + 5", "2 + 4", "3 + 3"]`.
  
  # Input/Output
  
   - `[input]` string(char in C#) `number`
  
     A character representing a correct one-digit number in the new numeral system.
  
     Constraints: `'A' ≤ number ≤ 'Z'.`
  
   - `[output]` a string array
  
     An array of strings in the format "letter1 + letter2", where "letter1" and "letter2" are correct one-digit numbers in the new numeral system. The strings should be sorted by "letter1".
  
     Note that "letter1 + letter2" and "letter2 + letter1" are equal pairs and we don't consider them to be different.
  -/

vc-preamble: |-
  def isUpperCase (c : Char) : Bool :=
    sorry
  
  def toLetterIndex (c : Char) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def new_numeral_system (letter : Char) : List String :=
    sorry

vc-theorems: |-
  theorem correct_format {letter : Char} : 
    ∀ s ∈ new_numeral_system letter, 
      s.length = 5 ∧ s.data.get ⟨1, sorry⟩ = ' ' ∧ 
      s.data.get ⟨2, sorry⟩ = '+' ∧ 
      s.data.get ⟨3, sorry⟩ = ' ' := by
    sorry
  
  theorem valid_letters {letter : Char} :
    ∀ s ∈ new_numeral_system letter,
      let first := s.data.get ⟨0, sorry⟩
      let last := s.data.get ⟨4, sorry⟩
      isUpperCase first ∧ 
      isUpperCase last ∧
      first ≤ letter ∧ 
      last ≤ letter := by
    sorry
  
  theorem correct_sum {letter : Char} :
    ∀ s ∈ new_numeral_system letter,
      let first := s.data.get ⟨0, sorry⟩
      let last := s.data.get ⟨4, sorry⟩
      toLetterIndex first + toLetterIndex last = toLetterIndex letter := by
    sorry
  
  theorem left_side_sorted {letter : Char} :
    let leftSide := (new_numeral_system letter).map (fun s => s.data.get ⟨0, sorry⟩)
    ∀ i j, i < j → j < leftSide.length → leftSide[i]! ≤ leftSide[j]! := by
    sorry
  
  theorem middle_pair_equal {letter : Char} :
    toLetterIndex letter % 2 = 0 →
      let result := new_numeral_system letter
      let midIdx := toLetterIndex letter / 2
      let middle := result[midIdx]!
      middle.data.get ⟨0, sorry⟩ = middle.data.get ⟨4, sorry⟩ := by
    sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

