vc-description: |-
  /-
  Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.
  
  Example 1:
  Input: num = 14
  Output: 6
  Explanation: 
  Step 1) 14 is even; divide by 2 and obtain 7. 
  Step 2) 7 is odd; subtract 1 and obtain 6.
  Step 3) 6 is even; divide by 2 and obtain 3. 
  Step 4) 3 is odd; subtract 1 and obtain 2. 
  Step 5) 2 is even; divide by 2 and obtain 1. 
  Step 6) 1 is odd; subtract 1 and obtain 0.
  
  Example 2:
  Input: num = 8
  Output: 4
  Explanation: 
  Step 1) 8 is even; divide by 2 and obtain 4. 
  Step 2) 4 is even; divide by 2 and obtain 2. 
  Step 3) 2 is even; divide by 2 and obtain 1. 
  Step 4) 1 is odd; subtract 1 and obtain 0.
  
  Example 3:
  Input: num = 123
  Output: 12
  
  Constraints:
  
  0 <= num <= 10^6
  -/

vc-preamble: |-
  def number_of_steps (n: Nat) : Nat := sorry
  
  def is_power_of_two (n: Nat) : Bool := sorry

vc-helpers: |-

vc-definitions: |-
  def simulation_loop (n steps: Nat) : Nat :=
    match n with
    | 0 => steps
    | n+1 => if n % 2 = 0 
             then simulation_loop (n / 2) (steps + 1)
             else simulation_loop (n - 1) (steps + 1)

vc-theorems: |-
  theorem number_of_steps_nonneg (n: Nat) : 
    number_of_steps n ≥ 0 := sorry
  
  theorem zero_steps :
    number_of_steps 0 = 0 := sorry
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval number_of_steps 14
  
  /-
  info: 4
  -/
  -- #guard_msgs in
  -- #eval number_of_steps 8
  
  /-
  info: 12
  -/
  -- #guard_msgs in
  -- #eval number_of_steps 123

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

