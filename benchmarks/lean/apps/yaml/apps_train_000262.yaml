vc-description: |-
  /-
  Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.
  
  Example 1:
  
  Input: nums = [1,0,0,0,1,0,0,1], k = 2
  Output: true
  Explanation: Each of the 1s are at least 2 places away from each other.
  
  Example 2:
  
  Input: nums = [1,0,0,1,0,1], k = 2
  Output: false
  Explanation: The second 1 and third 1 are only one apart from each other.
  Example 3:
  Input: nums = [1,1,1,1,1], k = 0
  Output: true
  
  Example 4:
  Input: nums = [0,1,0,1], k = 1
  Output: true
  
  Constraints:
  
  1 <= nums.length <= 10^5
  0 <= k <= nums.length
  nums[i] is 0 or 1
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def k_length_apart (nums : List Nat) (k : Nat) : Bool :=
    sorry

vc-theorems: |-
  theorem k_distance_property {nums : List Nat} {k : Nat} 
    (h1 : ∀ x ∈ nums, x ≤ 1)
    (h2 : k > 0)
    (h3 : k_length_apart nums k = true) :
    ∀ i j, i < nums.length → j < nums.length → 
      (nums.get ⟨i, sorry⟩ = 1 ∧ nums.get ⟨j, sorry⟩ = 1 ∧ i < j) → 
      j - i > k :=
  sorry
  
  theorem no_ones_property {nums : List Nat} {k : Nat}
    (h1 : ∀ x ∈ nums, x ≤ 1)
    (h2 : 1 ∉ nums) :
    k_length_apart nums k = true :=
  sorry
  
  theorem consecutive_ones_property {nums : List Nat} {k : Nat} {i : Nat}
    (h1 : ∀ x ∈ nums, x ≤ 1)
    (h2 : k > 0)
    (h3 : i < nums.length - 1)
    (h4 : nums.get ⟨i, sorry⟩ = 1)
    (h5 : nums.get ⟨i+1, sorry⟩ = 1) :
    k_length_apart nums k = false :=
  sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval k_length_apart [1, 0, 0, 0, 1, 0, 0, 1] 2
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval k_length_apart [1, 0, 0, 1, 0, 1] 2
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval k_length_apart [0, 1, 0, 1] 1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

