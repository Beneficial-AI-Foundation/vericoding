vc-description: |-
  /-
  Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.
  Return the number of closed islands.
  
  Example 1:
  
  Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
  Output: 2
  Explanation: 
  Islands in gray are closed because they are completely surrounded by water (group of 1s).
  Example 2:
  
  Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
  Output: 1
  
  Example 3:
  Input: grid = [[1,1,1,1,1,1,1],
                 [1,0,0,0,0,0,1],
                 [1,0,1,1,1,0,1],
                 [1,0,1,0,1,0,1],
                 [1,0,1,1,1,0,1],
                 [1,0,0,0,0,0,1],
                 [1,1,1,1,1,1,1]]
  Output: 2
  
  Constraints:
  
  1 <= grid.length, grid[0].length <= 100
  0 <= grid[i][j] <=1
  -/

vc-preamble: |-
  def Grid := List (List Nat)
  
  def closed_island (grid : Grid) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def listSum (l: List Nat) : Nat :=
    match l with
    | [] => 0
    | x::xs => x + listSum xs

vc-theorems: |-
  theorem closed_island_non_negative (grid: Grid) : 
    closed_island grid ≥ 0 :=
    sorry
  
  theorem closed_island_less_than_zeros (grid: Grid) :
    let countZeros (row: List Nat) := List.length (List.filter (λ x => x = 0) row)
    closed_island grid ≤ listSum (List.map countZeros grid) :=
    sorry
  
  theorem closed_island_small_grid (grid: Grid) (h1: grid.length < 3 ∨ (List.head! grid).length < 3) :
    closed_island grid = 0 :=
    sorry
  
  theorem closed_island_all_ones (grid: Grid) 
    (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1) :
    closed_island grid = 0 :=
    sorry
  
  theorem closed_island_all_zeros (grid: Grid)
    (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 0) :
    closed_island grid = 0 :=
    sorry
  
  theorem closed_island_simple_case_3x3 (grid: Grid)
    (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :
    closed_island grid = 1 :=
    sorry
  
  theorem closed_island_simple_case_4x4 (grid: Grid)
    (h1: grid = [[1,1,1,1], [1,0,0,1], [1,0,0,1], [1,1,1,1]]) :
    closed_island grid = 1 :=
    sorry
  
  theorem closed_island_mutates_to_ones (grid: Grid)
    (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :
    let _ := closed_island grid
    ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1 :=
    sorry
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval closed_island [[1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0]]
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval closed_island [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]]
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval closed_island [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

