vc-description: |-
  /-
  Given an array of size N$N$ and two integers K$K$ and S$S$, the special sum of a subarray is defined as follows:
  
  (Sum of all elements of the subarray) * (K$K$ - p$p$ * S$S$)
  
  Where p$p$ = number of distinct prime factors of “product of all elements of the subarray”.
  
  Find the maximum special sum by considering all non-empty subarrays of the given array.
  
  -----Input-----
  - First line contains 3 integers N$N$, K$K$ and S$S$.     
  - Second line contains N$N$ integers, the elements of the array.  
  
  -----Output-----
  Output a single integer. The maximum special sum considering all non-empty subarrays of the array.
  
  -----Constraints:-----
  - 1≤N,K,S≤105$ 1 \leq N, K, S \leq 10^5 $ 
  - 0≤K/S≤20$ 0 \leq K / S \leq 20 $ 
  - 1<$ 1 < $ Any element of array <105$ < 10^5 $
  
  -----Sample Input-----
  4 10 2
  
  14 2 7 15
  
  -----Sample Output-----
  138
  
  -----Sample Explanation-----
  Consider the subarray {14, 2, 7}
  
  Total number of distinct prime factors in it is 2 (2 and 7).
  
  Therefore, value of special sum is (14 + 2 + 7) * (10 - 2 * 2) = 138.
  
  This is the subarray with the maximum special sum.
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def fac (n : Nat) : List Nat := sorry
  
  def max_special_sum (n k s : Nat) (arr : List Nat) : Nat := sorry

vc-theorems: |-
  theorem fac_product (n : Nat) (h : n ≥ 2) :
    let factors := fac n
    factors.foldl (· * ·) 1 = n := sorry
  
  theorem fac_all_prime (n : Nat) (h : n ≥ 2) :
    let factors := fac n
    ∀ p ∈ factors,
      ∀ i : Nat, 2 ≤ i → i < p → ¬(p % i = 0) := sorry
  
  theorem fac_ascending (n : Nat) (h : n ≥ 2) :
    let factors := fac n 
    ∀ i j, i < j → i < factors.length → j < factors.length →
      factors.get! i ≤ factors.get! j := sorry
  
  theorem max_special_sum_exists (n k s : Nat) (arr : List Nat) (h₁ : n > 0) (h₂ : k > 0) (h₃ : s > 0) :
    ∃ i j : Nat, i ≤ j ∧ j < arr.length ∧
    let subarray := arr.take (j+1) |>.drop i
    let curr_sum := subarray.foldl (· + ·) 0
    let prod := subarray.foldl (· * ·) 1
    let prime_factors := (fac prod).eraseDups
    max_special_sum n k s arr = curr_sum * (k - prime_factors.length * s) := sorry
  
  theorem max_special_sum_single (k s : Nat) (h₁ : k > 0) (h₂ : s > 0) :
    let arr := [2]
    max_special_sum 1 k s arr = 2 * (k - (fac 2).eraseDups.length * s) := sorry
  
  /-
  info: 138
  -/
  -- #guard_msgs in
  -- #eval max_special_sum 4 10 2 [14, 2, 7, 15]
  
  /-
  info: 27
  -/
  -- #guard_msgs in
  -- #eval max_special_sum 3 5 1 [2, 3, 4]
  
  /-
  info: 45
  -/
  -- #guard_msgs in
  -- #eval max_special_sum 2 8 3 [6, 9]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

