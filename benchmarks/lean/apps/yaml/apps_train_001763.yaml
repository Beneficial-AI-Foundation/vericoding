vc-description: |-
  /-
  A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).
  
  Given a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.
  
  Examples:
  Input: sx = 1, sy = 1, tx = 3, ty = 5
  Output: True
  Explanation:
  One series of moves that transforms the starting point to the target is:
  (1, 1) -> (1, 2)
  (1, 2) -> (3, 2)
  (3, 2) -> (3, 5)
  
  Input: sx = 1, sy = 1, tx = 2, ty = 2
  Output: False
  
  Input: sx = 1, sy = 1, tx = 1, ty = 1
  Output: True
  
  Note:
  
         sx, sy, tx, ty will all be integers in the range [1, 10^9].
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def can_transform_point (sx sy tx ty : Nat) : Bool := sorry 
  
  theorem same_point_always_true {sx sy : Nat} : 
    can_transform_point sx sy sx sy = true := sorry

vc-theorems: |-
  theorem target_less_than_start_always_false {sx sy tx ty : Nat} :
    (tx < sx ∨ ty < sy) → can_transform_point sx sy tx ty = false := sorry
  
  theorem no_valid_moves_if_too_far {sx sy tx ty : Nat} :
    (sx > tx ∧ sy > ty) → can_transform_point sx sy tx ty = false := sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval can_transform_point 1 1 3 5
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval can_transform_point 1 1 2 2
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval can_transform_point 1 1 1 1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

