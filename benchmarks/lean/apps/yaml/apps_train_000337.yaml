vc-description: |-
  /-
  Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
  Return the number of nice sub-arrays.
  
  Example 1:
  Input: nums = [1,1,2,1,1], k = 3
  Output: 2
  Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
  
  Example 2:
  Input: nums = [2,4,6], k = 1
  Output: 0
  Explanation: There is no odd numbers in the array.
  
  Example 3:
  Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
  Output: 16
  
  Constraints:
  
  1 <= nums.length <= 50000
  1 <= nums[i] <= 10^5
  1 <= k <= nums.length
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def number_of_subarrays (nums: List Int) (k: Int) : Int := sorry
  
  theorem non_negative_output {nums: List Int} {k: Int} 
    (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100) (h2: 1 ≤ k ∧ k ≤ 100) : 
    number_of_subarrays nums k ≥ 0 := sorry

vc-theorems: |-
  theorem zero_when_k_too_large {nums: List Int} {k: Int}
    (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100) (h2: 1 ≤ k ∧ k ≤ 100)
    (h3: k > nums.length) :
    number_of_subarrays nums k = 0 := sorry
  
  theorem k_zero_or_negative_fails {nums: List Int} {k: Int}
    (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100) (h2: k ≤ 0) :
    ¬ ∃ result, number_of_subarrays nums k = result := sorry
  
  theorem result_invariant_under_even_multiplication {nums: List Int} {k: Int}
    (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100) (h2: 1 ≤ k ∧ k ≤ 100) :
    number_of_subarrays nums k = number_of_subarrays (nums.map (λ x => if x % 2 = 0 then x * 2 else x)) k := sorry
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval number_of_subarrays [1, 1, 2, 1, 1] 3
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval number_of_subarrays [2, 4, 6] 1
  
  /-
  info: 16
  -/
  -- #guard_msgs in
  -- #eval number_of_subarrays [2, 2, 2, 1, 2, 2, 1, 2, 2, 2] 2

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

