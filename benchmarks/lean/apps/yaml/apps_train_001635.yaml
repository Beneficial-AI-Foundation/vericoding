vc-description: |-
  /-
  Consider a sequence `u` where u is defined as follows:
  
  1. The number `u(0) = 1` is the first one in `u`.
  2. For each `x` in `u`, then `y = 2 * x + 1` and `z = 3 * x + 1` must be in `u` too.
  3. There are no other numbers in `u`.
  
  Ex: 
  `u = [1, 3, 4, 7, 9, 10, 13, 15, 19, 21, 22, 27, ...]`
  
  1 gives 3 and 4, then 3 gives 7 and 10, 4 gives 9 and 13, then 7 gives 15 and 22 and so on...
  
  ## Task: 
  Given parameter `n` the function `dbl_linear` (or dblLinear...) returns the element `u(n)` of 
  the ordered (with <) sequence `u` (so, there are no duplicates).
  
  ## Example:
  `dbl_linear(10) should return 22`
  
  ## Note:
  Focus attention on efficiency
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def dbl_linear (n : Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem dbl_linear_positive (n : Nat) : 
    dbl_linear n > 0 := sorry
  
  theorem dbl_linear_strictly_increasing {n₁ n₂ : Nat} (h : n₁ < n₂) : 
    dbl_linear n₁ < dbl_linear n₂ := sorry
  
  theorem dbl_linear_base_case : 
    dbl_linear 0 = 1 := sorry
  
  theorem dbl_linear_sequence_rule {n : Nat} (h : dbl_linear n > 1) :
    ∃ i < n, dbl_linear n = 2 * dbl_linear i + 1 ∨ dbl_linear n = 3 * dbl_linear i + 1 := sorry
  
  /-
  info: 22
  -/
  -- #guard_msgs in
  -- #eval dbl_linear 10
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval dbl_linear 0
  
  /-
  info: 57
  -/
  -- #guard_msgs in
  -- #eval dbl_linear 20

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

