vc-description: |-
  /-
  This is simple version of harder [Square Sums](/kata/square-sums).
  
  # Square sums
  
  Write function `square_sums_row` (or `squareSumsRow`/`SquareSumsRow` depending on language rules) that, given integer number `N` (in range `2..43`), returns array of integers `1..N` arranged in a way, so sum of each 2 consecutive numbers is a square.
  
  Solution is valid if and only if following two criterias are met:
  1. Each number in range `1..N` is used once and only once.
  2. Sum of each 2 consecutive numbers is a perfect square.
  
  ### Example
  For N=15 solution could look like this:
  
  `[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]`
  
  ### Verification
  
  1. All numbers are used once and only once. When sorted in ascending order array looks like this:
  
  `[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]`
  
  2. Sum of each 2 consecutive numbers is a perfect square:
  
  ```
     16    16     16     16     16     16     16
     /+\   /+\    /+\    /+\    /+\    /+\    /+\
  [ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]
        \+/    \+/    \+/    \+/    \+/    \+/    \+/
         9     25      9     25      9     25      9
  
  9 = 3*3
  16 = 4*4
  25 = 5*5
  ```
  
  If there is no solution, return `false` (or, `None` in scala). For example if `N=5`, then numbers `1,2,3,4,5` cannot be put into square sums row: `1+3=4`, `4+5=9`, but
  `2` has no pairs and cannot link `[1,3]` and `[4,5]`
  
  # Have fun!
  
  Harder version of this Kata is [here](/kata/square-sums).
  -/

vc-preamble: |-
  def is_perfect_square (n : Nat) : Bool :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def square_sums_row (n : Nat) : Option (List Nat) :=
    sorry

vc-theorems: |-
  theorem square_sums_row_length {n : Nat} {result : List Nat} :
    square_sums_row n = some result → result.length = n :=
    sorry
  
  theorem square_sums_row_elements {n : Nat} {result : List Nat} :
    square_sums_row n = some result → 
    result = (List.map (λ x => x + 1) (List.range n)) :=
    sorry
  
  theorem square_sums_row_adjacent_pairs {n : Nat} {result : List Nat} :
    square_sums_row n = some result →
    ∀ i, i < result.length - 1 →
    is_perfect_square (result[i]! + result[i+1]!) = true :=
    sorry
  
  theorem square_sums_row_impossible_cases :
    (square_sums_row 2 = none) ∧
    (square_sums_row 3 = none) ∧ 
    (square_sums_row 5 = none) ∧
    (square_sums_row 24 = none) :=
    sorry
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval square_sums_row 5
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval square_sums_row 24
  
  /-
  info: 15
  -/
  -- #guard_msgs in
  -- #eval len square_sums_row(15)
  
  /-
  info: list(range(1, 16))
  -/
  -- #guard_msgs in
  -- #eval sorted result

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

