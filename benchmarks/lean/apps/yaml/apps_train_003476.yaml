vc-description: |-
  /-
  ## Problem
  
  There are `n` apples that need to be divided into four piles. We need two mysterious number `x` and `y`. Let The number of first pile equals to `x+y`, the number of second pile equals to `x-y`, the number of third pile equals to `x*y`, the number of fourth pile equals to `x/y`. We need to calculate how many apples are there in each pile.
  
  Of course, there won't be so many unknowns. We know the total number of apples(`n`) and the second mysterious number(`y`). 
  
  For example: there are 48 apples need to divided into four piles. y=3. that is, 1st pile should be x+3, 2nd pile should be x-3, 3rd pile should be x*3, 4th pile should be x/3.
  Do you know how much `x` is? `x` should be 9, because:
  ```
  (9 + 3) + (9 - 3) + (9 * 3) + (9 / 3) = 12 + 6 + 27 + 3 = 48
  ```
  So, 48 apples should be divided into `12, 6, 27, 3`.
  
  ## Task
  
  Complete function `fourPiles()`/`four_piles()` that accepts two arguments `n` and `y`, return an array contains the number of for piles. Each element in the result array should be a positive integer. If can not divide, please return `[]`.
  
  ## Examples
  
  ```
  fourPiles 48 3 -- [12,6,27,3]  
  //The elements are arranged in sequence according to:
  //   x+y,x-y,x*y,x/y
  
  fourPiles 100 4 -- [20,12,64,4]  
  -- Verify correctness:
  -- x=16,y=4
  (16+4) + (16-4) + (16*4) + (16/4) -- 100
  
  -- Edge case:
  fourPiles 25 4  -- []  -- [8,0,16,1] is not a correct answer
  
  fourPiles 24 4  -- []  -- can not divide
  ```
  -/

vc-preamble: |-
  def four_piles (n : Nat) (y : Nat) : Option (List Nat) := sorry
  
  def sum_list : List Nat → Nat 
    | [] => 0
    | (h :: t) => h + sum_list t

vc-helpers: |-

vc-definitions: |-
  def nth : List Nat → Nat → Option Nat 
    | [], _ => none
    | (h :: t), 0 => some h
    | (h :: t), n+1 => nth t n

vc-theorems: |-
  theorem four_piles_properties_solution (n y : Nat) (h1 : n > 0) (h2 : y > 0) (h3 : y ≤ 100) : 
    match four_piles n y with
    | some result => 
      -- Result has length 4
      result.length = 4 ∧ 
      -- Elements follow x+y, x-y, x*y, x/y pattern for some x
      ∃ x : Nat, 
        (nth result 0 = some (x + y)) ∧
        (nth result 1 = some (x - y)) ∧
        (nth result 2 = some (x * y)) ∧
        (nth result 3 = some (x / y)) ∧
      -- Elements are positive
      (∀ i ∈ result, i > 0) ∧
      -- Sum equals input n  
      sum_list result = n
    | none =>
      -- If no solution, divmod has remainder
      let prod := n * y
      let denom := (y + 1) * (y + 1)
      prod % denom ≠ 0 ∨ (prod / denom = y)
    := sorry
  
  theorem four_piles_properties_positive (n y : Nat) (h1 : n > 0) (h2 : y > 0) :
    match four_piles n y with
    | some result => ∀ x ∈ result, x > 0
    | none => True
    := sorry
  
  theorem four_piles_properties_sum (n y : Nat) (h1 : n > 0) (h2 : y > 0) :
    match four_piles n y with
    | some result => sum_list result = n  
    | none => True
    := sorry
  
  /-
  info: [12, 6, 27, 3]
  -/
  -- #guard_msgs in
  -- #eval four_piles 48 3
  
  /-
  info: [20, 12, 64, 4]
  -/
  -- #guard_msgs in
  -- #eval four_piles 100 4
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval four_piles 25 4

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

