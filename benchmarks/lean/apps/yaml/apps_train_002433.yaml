vc-description: |-
  /-
  Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time.
  Return that integer.
  
  Example 1:
  Input: arr = [1,2,2,6,6,6,6,7,10]
  Output: 6
  
  Constraints:
  
  1 <= arr.length <= 10^4
  0 <= arr[i] <= 10^5
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def find_special_integer (nums : List Int) : Int :=
  sorry

vc-theorems: |-
  theorem special_int_exists (nums : List Int) (h : nums ≠ []) :
    let result := find_special_integer nums
    let count := (nums.filter (· = result)).length 
    count ≥ nums.length / 4 ∨ result = nums.getLast h := by
  sorry
  
  theorem result_in_array (nums : List Int) (h : nums ≠ []) :
    let result := find_special_integer nums
    result ∈ nums := by
  sorry
  
  theorem all_same_number (nums : List Int) (h1 : nums.length ≥ 4) 
      (h2 : ∀ x ∈ nums, x = nums[0]) :
    find_special_integer nums = nums[0] := by
  sorry
  
  theorem binary_array (nums : List Int) (h1 : nums.length ≥ 2)
      (h2 : ∀ x ∈ nums, x = 0 ∨ x = 1) :
    let result := find_special_integer nums
    result = 0 ∨ result = 1 := by
  sorry
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval find_special_integer [1, 2, 2, 6, 6, 6, 6, 7, 10]
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval find_special_integer [1, 1, 1, 2, 3]
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval find_special_integer [1, 1]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

