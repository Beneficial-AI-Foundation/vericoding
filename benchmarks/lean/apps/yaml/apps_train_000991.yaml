vc-description: |-
  /-
  There are $N$ cities on a circle, numbered $1$ through $N$. For each $i$ ($1 \le i \le N-1$), cities $i$ and $i+1$ are directly connected by a bidirectional road with length $A_i$, and cities $N$ and $1$ are also directly connected by a bidirectional road with length $A_N$. However, we do not know the lengths of some roads.
  For each city $i$, we do know that it has an opposite city — formally, there is a city $j \neq i$ such that the clockwise distance between cities $i$ and $j$ is equal to the counterclockwise distance between these cities.
  Please find the lengths of all roads in such a way that the above condition is satisfied and the sum of lengths of all roads is minimised.
  
  -----Input-----
  - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.
  - The first line of the input contains a single integer $N$.
  - The second line contains $N$ space-separated integers $A_1, A_2, \dots, A_N$. For each valid $i$, $A_i = -1$ denotes that the length of road $i$ is unknown.
  
  -----Output-----
  For each test case, print a line containing the string "NO" if there is no solution or "YES" otherwise. If a solution exists, print a second line containing $N$ space-separated positive integers — the lengths of all roads in your solution. Each of these integers should be $\le 10^9$. If there are multiple solutions, you may print any one.
  
  -----Constraints-----
  - $1 \le T \le 100$
  - $3 \le N \le 10^5$
  - $1 \le A_i \le 10^9$ or $A_i = -1$ for each valid $i$
  - the sum of $N$ for all test cases does not exceed $3\cdot 10^5$
  
  -----Subtasks-----
  Subtask #1 (10 points): $N \le 4$
  Subtask #2 (20 points): $A_i = \pm 1$ for each valid $i$
  Subtask #3 (70 points): original constraints
  
  -----Example Input-----
  4
  4
  1 1 1 1
  4
  1 1 1 2
  4
  1 -1 -1 4
  4
  1 -1 2 -1
  
  -----Example Output-----
  YES
  1 1 1 1
  NO
  YES
  1 4 1 4
  NO
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def solve_circular_roads (n : Nat) (road_lengths : List Int) : (String × Option (List Nat)) :=
  sorry

vc-theorems: |-
  theorem valid_solution_odd_n (n : Nat) (road_lengths : List Int) (h : n % 2 = 1) :
    solve_circular_roads n road_lengths = ("NO", none) :=
  sorry
  
  theorem valid_solution_props {n : Nat} {road_lengths : List Int} 
    (h : n % 2 = 0) (result : String × Option (List Nat)) 
    (h2 : result = solve_circular_roads n road_lengths) :
    (result.1 = "NO" ∨ 
     (result.1 = "YES" ∧ 
      (∀ roads : List Nat, result.2 = some roads → 
        roads.length = n ∧
        (∀ (i : Nat) (h3 : i < road_lengths.length) (h4 : i < roads.length),
           road_lengths.get ⟨i, h3⟩ ≠ -1 → roads.get ⟨i, h4⟩ = road_lengths.get ⟨i, h3⟩) ∧
        (∀ (i : Nat) (h3 : i < roads.length) (h4 : i + n/2 < roads.length),
           roads.get ⟨i, h3⟩ = roads.get ⟨i + n/2, h4⟩)))) :=
  sorry
  
  theorem all_negative_one_has_solution (n : Nat) (h : n % 2 = 0) :
    let road_lengths := List.replicate n (-1 : Int)
    let result := solve_circular_roads n road_lengths
    result.1 = "YES" ∧ 
    (∀ roads : List Nat, result.2 = some roads →
      ∀ x ∈ roads, x = 1) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

