vc-description: |-
  /-
  Given a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order.
  
  The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.
  
  Example:
  Input: [[1,2], [3], [3], []] 
  Output: [[0,1,3],[0,2,3]] 
  Explanation: The graph looks like this:
  0--->1
  |    |
  v    v
  2--->3
  There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.
  
  Note:
  
         The number of nodes in the graph will be in the range [2, 15].
         You can print different paths in any order, but you should keep the order of nodes inside one path.
  -/

vc-preamble: |-
  def Graph := List (List Nat)
  
  def find_all_paths (g: Graph) : List (List Nat) := sorry

vc-helpers: |-

vc-definitions: |-
  def is_valid_dag (g: Graph) : Bool := sorry
  
  def verify_paths (g: Graph) (paths: List (List Nat)) : Bool := sorry

vc-theorems: |-
  theorem paths_start_end_valid (g: Graph) (paths: List (List Nat)) 
    (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :
    ∀ p ∈ paths, p.head? = some 0 ∧ 
                 p.getLast? = some (g.length - 1) := sorry
  
  theorem paths_follow_edges (g: Graph) (paths: List (List Nat)) 
    (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :
    ∀ p ∈ paths, ∀ i < p.length - 1, 
      (p.get! (i+1)) ∈ (g.get! (p.get! i)) := sorry
  
  theorem paths_are_unique (g: Graph) (paths: List (List Nat))
    (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :
    ∀ p₁ ∈ paths, ∀ p₂ ∈ paths, p₁ = p₂ ∨ p₁ ≠ p₂ := sorry
  
  theorem linear_graph_single_path (n: Nat) (h: n ≥ 2) :
    let g : Graph := List.map (fun i => if i < n-1 then [i+1] else []) (List.range n)
    let paths := find_all_paths g
    paths.length = 1 ∧ paths.head? = some (List.range n) := sorry
  
  theorem complete_dag_valid_paths (n: Nat) (h: n ≥ 3) :
    let g : Graph := List.map (fun i => List.filter (fun j => j > i ∧ j < n) (List.range n)) (List.range n)
    let paths := find_all_paths g
    verify_paths g paths = true := sorry
  
  /-
  info: sorted(expected1)
  -/
  -- #guard_msgs in
  -- #eval sorted find_all_paths(graph1)
  
  /-
  info: sorted(expected3)
  -/
  -- #guard_msgs in
  -- #eval sorted find_all_paths(graph3)

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

