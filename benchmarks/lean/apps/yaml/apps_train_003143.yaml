vc-description: |-
  /-
  You will be given two strings `a` and `b` consisting of lower case letters, but `a` will have at most one asterix character. The asterix (if any) can be replaced with an arbitrary sequence (possibly empty) of lowercase letters. No other character of string `a` can be replaced. If it is possible to replace the asterix in `a` to obtain string `b`, then string `b` matches the pattern. 
  
  If the string matches, return `true` else `false`. 
  
  ```
  For example:
  solve("code*s","codewars") = true, because we can replace the asterix(*) with "war" to match the second string. 
  solve("codewar*s","codewars") = true, because we can replace the asterix(*) with "" to match the second string. 
  solve("codewars","codewars") = true, because the strings already match.
  solve("a","b") = false
  ```
  More examples in test cases. 
  
  Good luck!
  -/

vc-preamble: |-
  def solve (pattern: String) (target: String) : Bool := sorry
  
  theorem identical_strings_match
    (s: String)
    (h: s.data.all (fun c => c ≠ '*')) :
    solve s s = true := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def stringAppend (s1 s2: String) : String := String.append s1 s2
  
  theorem wildcard_match
    (p s m: String)
    (h1: p.data.all (fun c => c ≠ '*'))
    (h2: s.data.all (fun c => c ≠ '*'))
    (h3: m.data.all (fun c => c ≠ '*')) :
    solve (stringAppend (stringAppend p "*") s) (stringAppend (stringAppend p m) s) = true := sorry

vc-theorems: |-
  theorem different_strings_no_match
    (s1 s2: String)
    (h1: s1.data.all (fun c => c ≠ '*'))
    (h2: s2.data.all (fun c => c ≠ '*'))
    (h3: s1 ≠ s2) :
    solve s1 s2 = false := sorry
  
  theorem multiple_wildcards_invalid
    (s1 s2: String)
    (h1: s1.data.all (fun c => c ≠ '*'))
    (h2: s2.data.all (fun c => c ≠ '*')) :
    solve (stringAppend (stringAppend (stringAppend s1 "*") s2) "*") "anything" = false := sorry
  
  theorem length_requirement
    (p s m: String)
    (h1: p.data.all (fun c => c ≠ '*'))
    (h2: s.data.all (fun c => c ≠ '*')) :
    (stringAppend (stringAppend p m) s).length ≥ (stringAppend (stringAppend p "*") s).length - 1 := sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval solve "code*s" "codewars"
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval solve "codewar*s" "codewars"
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval solve "code*warrior" "codewars"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

