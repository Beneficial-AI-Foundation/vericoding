vc-description: |-
  /-
  We like parsed SQL or PL/SQL blocks...
  
  You need to write function that return list of literals indices from source block, excluding "in" comments, OR return empty list if no literals found.
  
  input:
  some fragment of sql or pl/sql code
  
  output:
  list of literals indices [(start, end), ...] OR empty list
  
  Sample:
  ```
  get_textliterals("'this' is sample") -> [(0,6)]
  get_textliterals("'this' is sample 'too'") -> [(0, 6), (15, 20)]
  ```
  
  Text literal: any text between single quotes
  Sample:
  ```
    s := 'i am literal'
  ```
  Single-line comment: any text started with "--" 
  Sample:
  ```
    a := 1;
    -- this is single-line comment
  ```
  Multy-line comment: any text between /* */
  ```
    a := 1;
    /*
    this is long multy-line comment
    */
  ```
  
  Note: 
  1) handle single quote inside literal
  ```
    s := 'we can use quote '' in literal'
  ```  
  2) multy-line literal
  ```
   s := '
   this is literal too
   ';
  ```
  3) skip literal inside comment
  ```
  s := 'test'; --when comment started - this is not 'literal'
  ```
  4) any unclosed literal should be closed with last symbol of the source fragment
  ```
  s := 'test
  ```
  There is one literal in this code: "'test"
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def get_textliterals (code : String) : List (Nat × Nat) := sorry
  
  /- Valid result format ensures result is list of natural number pairs -/

vc-theorems: |-
  theorem valid_result_format (code : String) :
    ∀ result : List (Nat × Nat), result = get_textliterals code → 
    ∀ p ∈ result, ∃ (s e : Nat), p = (s, e) := sorry
  
  /- All ranges in result are valid positions within code length -/
  
  theorem valid_ranges (code : String) :
    ∀ p ∈ get_textliterals code, 
    let (s, e) := p
    s < e ∧ e ≤ code.length := sorry
  
  /- All result ranges start and end with single quotes -/
  
  theorem valid_quotes (code : String) :
    ∀ p ∈ get_textliterals code,
    let (s, e) := p
    s < code.length ∧ e ≤ code.length →
    code.data[s]! = '\'' ∧ 
    code.data[e - 1]! = '\'' := sorry
  
  /- Result ranges are non-overlapping and ordered -/
  
  theorem non_overlapping (code : String) :
    ∀ i, i < (get_textliterals code).length - 1 →
    let ranges := get_textliterals code
    let p₁ := ranges[i]!
    let p₂ := ranges[i+1]!
    p₁.2 ≤ p₂.1 := sorry
  
  /- Result ranges do not contain SQL comments -/
  
  theorem no_comments (code : String) :
    ∀ p ∈ get_textliterals code,
    let (s, e) := p
    s < code.length ∧ e ≤ code.length →
    ¬ (∃ i, i ≥ s ∧ i + 1 < e ∧
      ((code.data[i]! = '/' ∧ code.data[i+1]! = '*') ∨
       (code.data[i]! = '*' ∧ code.data[i+1]! = '/') ∨
       (code.data[i]! = '-' ∧ code.data[i+1]! = '-'))) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

