vc-description: |-
  /-
  There are some candies that need to be distributed to some children as fairly as possible (i.e. the variance of result needs to be as small as possible), but I don't know how to distribute them, so I need your help. Your assignment is to write a function with signature `distribute(m, n)` in which `m` represents how many candies there are, while `n` represents how many children there are. The function should return a container which includes the number of candies each child gains.
  
  # Notice
  1. *The candy can't be divided into pieces.*
  2. The list's order doesn't matter.
  
  # Requirements
  1. The case `m < 0` is equivalent to `m == 0`.
  2. If `n <= 0` the function should return an empty container. 
  3. If there isn't enough candy to distribute, you should fill the corresponding number with `0`.
  
  # Examples
  ```python
  distribute(-5,  0) # should be [] 
  distribute( 0,  0) # should be [] 
  distribute( 5,  0) # should be [] 
  distribute(10,  0) # should be [] 
  distribute(15,  0) # should be [] 
  distribute(-5, -5) # should be [] 
  distribute( 0, -5) # should be [] 
  distribute( 5, -5) # should be [] 
  distribute(10, -5) # should be [] 
  distribute(15, -5) # should be []
  distribute(-5, 10) # should be [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  distribute( 0, 10) # should be [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  distribute( 5, 10) # should be [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
  distribute(10, 10) # should be [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  distribute(15, 10) # should be [2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
  ```
  
  # Input
    1. m: Integer (m <= 100000)
    2. n: Integer (n <= 1000)
  
  # Output
    1. [Integer]
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def distribute (m n: Int) : List Int := sorry
  
  def sum : List Int → Int
    | [] => 0
    | x::xs => x + sum xs

vc-theorems: |-
  theorem nonpositive_n_returns_empty {m n : Int} (h: n ≤ 0) : 
    distribute m n = [] := sorry
  
  theorem nonpositive_m_distributes_zeros {m n : Int} (h₁: m ≤ 0) (h₂: n > 0) :
    let result := distribute m n
    (result.length = n) ∧ (∀ x ∈ result, x = 0) := sorry
  
  theorem distribution_properties {m n : Int} (h₁: m ≥ 0) (h₂: n > 0) :
    let result := distribute m n
    (result.length = n) ∧ 
    (sum result = m) ∧
    (∀ i j, i < result.length → j < result.length → 
      (result.get ⟨i, by sorry⟩ - result.get ⟨j, by sorry⟩ ≤ 1 ∧ 
       result.get ⟨j, by sorry⟩ - result.get ⟨i, by sorry⟩ ≤ 1)) ∧
    (∀ i, i < result.length - 1 → 
      result.get ⟨i, by sorry⟩ ≥ result.get ⟨i+1, by sorry⟩) := sorry
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval distribute 10 0
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval distribute 15 -5
  
  /-
  info: [0] * 10
  -/
  -- #guard_msgs in
  -- #eval distribute -5 10
  
  /-
  info: [2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
  -/
  -- #guard_msgs in
  -- #eval distribute 15 10

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

