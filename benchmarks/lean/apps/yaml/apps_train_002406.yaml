vc-description: |-
  /-
  The count-and-say sequence is the sequence of integers with the first five terms as following:
  
  1.     1
  2.     11
  3.     21
  4.     1211
  5.     111221
  
  1 is read off as "one 1" or 11.
  11 is read off as "two 1s" or 21.
  21 is read off as "one 2, then one 1" or 1211.
  
  Given an integer n, generate the nth term of the count-and-say sequence.
  
  Note: Each term of the sequence of integers will be represented as a string.
  
  Example 1:
  
  Input: 1
  Output: "1"
  
  Example 2:
  
  Input: 4
  Output: "1211"
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def countAndSay (n: Nat) : String :=
    sorry

vc-theorems: |-
  theorem countAndSay_one : countAndSay 1 = "1" :=
    sorry
  
  /- Every output is a string of nonzero length -/
  
  theorem countAndSay_nonempty (n: Nat) (h: n > 0) : 
    (countAndSay n).length > 0 :=
    sorry
  
  /- The output only contains ASCII digits -/
  
  theorem countAndSay_digits_only (n: Nat) (h: n > 0) : 
    ∀ p: String.Pos, 
      '0' ≤ (countAndSay n).get p ∧ (countAndSay n).get p ≤ '9' :=
    sorry
  
  /- Each count-and-say result follows from the previous number -/
  
  theorem countAndSay_inductive_step (n: Nat) (h: n > 1) :
    ∃ counts digits: List Nat, 
      counts.length = digits.length ∧ 
      (∀ d ∈ digits, d ≤ 9) ∧
      (∀ c ∈ counts, c > 0) ∧
      countAndSay n = String.join (List.map (λ (p: Nat × Nat) => toString p.1 ++ toString p.2) 
                                          (List.zip counts digits)) :=
    sorry
  
  /-
  info: '1'
  -/
  -- #guard_msgs in
  -- #eval count_and_say 1
  
  /-
  info: '1211'
  -/
  -- #guard_msgs in
  -- #eval count_and_say 4
  
  /-
  info: '111221'
  -/
  -- #guard_msgs in
  -- #eval count_and_say 5

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

