vc-description: |-
  /-
  Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.
  
  Example 1:
  Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
  Output: 9
  
  Example 2:
  Input: grid = [[1,1,0,0]]
  Output: 1
  
  Constraints:
  
  1 <= grid.length <= 100
  1 <= grid[0].length <= 100
  grid[i][j] is 0 or 1
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def largest1BorderedSquare (grid : List (List Nat)) : Nat := sorry
  
  theorem all_zeros (n : Nat) (h : n ≥ 1) : 
    let grid := List.replicate n (List.replicate n 0)
    largest1BorderedSquare grid = 0 := sorry

vc-theorems: |-
  theorem all_ones (n : Nat) (h : n ≥ 1) :
    let grid := List.replicate n (List.replicate n 1) 
    largest1BorderedSquare grid = n * n := sorry
  
  theorem perfect_square_2x2 (grid : List (List Nat)) 
    (h1 : grid.length = 2)
    (h2 : ∀ row ∈ grid, row.length = 2)
    (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :
    let result := largest1BorderedSquare grid
    result * result = result := sorry
  
  theorem bounds_3x3 (grid : List (List Nat))
    (h1 : grid.length = 3)
    (h2 : ∀ row ∈ grid, row.length = 3)
    (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :
    let result := largest1BorderedSquare grid
    let maxPossible := (min grid.length (grid.head?.getD []).length) ^ 2
    0 ≤ result ∧ result ≤ maxPossible := sorry
  
  /-
  info: 9
  -/
  -- #guard_msgs in
  -- #eval largest1BorderedSquare [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval largest1BorderedSquare [[1, 1, 0, 0]]
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval largest1BorderedSquare [[0, 0], [0, 0]]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

