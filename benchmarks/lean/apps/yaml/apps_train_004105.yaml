vc-description: |-
  /-
  Mrs Jefferson is a great teacher. One of her strategies that helped her to reach astonishing results in the learning process is to have some fun with her students. At school, she wants to make an arrangement of her class to play a certain game with her pupils. For that, she needs to create the arrangement with **the minimum amount of groups that have consecutive sizes**.
  
  Let's see. She has      ```14``` students. After trying a bit she could do the needed arrangement:
          ```[5, 4, 3, 2]```
  - one group of  ```5``` students
  - another group of      ```4``` students
  - then, another one of  ```3``` 
  - and finally, the smallest group of    ```2``` students.
  
  As the game was a success, she was asked to help to the other classes to teach and show the game. That's why she desperately needs some help to make this required arrangements that make her spend a lot of time. 
  
  To make things worse, she found out that there are some classes with some special number of students that is impossible to get that arrangement.
  
  Please, help this teacher!
  
  Your code will receive the number of students of the class. It should output the arrangement as an array with the consecutive sizes of the groups in decreasing order.
  
  For the special case that no arrangement of the required feature is possible the code should output     ```[-1] ```
  
  The value of n is unknown and may be pretty high because some classes joined to to have fun with the game.
  
  You may see more example tests in the Example Tests Cases Box.
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def shortest_arrang (n : Nat) : List Nat := sorry
  
  def is_valid_arrangement (arr : List Nat) (n : Nat) : Bool := sorry

vc-theorems: |-
  theorem shortest_arrang_properties (n : Nat) (h : n ≥ 3) :
    let result := shortest_arrang n
    (result = List.nil ∨ is_valid_arrangement result n) ∧
    (n % 2 = 1 → result = [n/2 + 1, n/2]) := sorry
  
  theorem shortest_arrang_uniqueness (n : Nat) (h : n ≥ 3) :
    let result := shortest_arrang n
    ∀ (i : Nat) (h : i < result.length),
    let test_arr := result
    result ≠ List.nil →
    (test_arr.foldl (· + ·) 0 = n ∧ 
     ∀ j < test_arr.length - 1, 
     test_arr.get ⟨j, sorry⟩ > test_arr.get ⟨j+1, sorry⟩) 
    → False := sorry
  
  theorem powers_of_two_give_empty (n : Nat) :
    (∃ k, n = 2^k) → shortest_arrang n = List.nil := sorry
  
  /-
  info: [5, 4, 3, 2]
  -/
  -- #guard_msgs in
  -- #eval shortest_arrang 14
  
  /-
  info: [-1]
  -/
  -- #guard_msgs in
  -- #eval shortest_arrang 16
  
  /-
  info: [33, 32]
  -/
  -- #guard_msgs in
  -- #eval shortest_arrang 65

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

