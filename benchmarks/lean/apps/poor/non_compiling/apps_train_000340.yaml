vc-description: |-
  /-
  Given an array nums of integers, you can perform operations on the array.
  
  In each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.
  
  You start with 0 points.  Return the maximum number of points you can earn by applying such operations.
  
  Example 1:
  
  Input: nums = [3, 4, 2]
  Output: 6
  Explanation: 
  Delete 4 to earn 4 points, consequently 3 is also deleted.
  Then, delete 2 to earn 2 points. 6 total points are earned.
  
  Example 2:
  
  Input: nums = [2, 2, 3, 3, 3, 4]
  Output: 9
  Explanation: 
  Delete 3 to earn 3 points, deleting both 2's and the 4.
  Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.
  9 total points are earned.
  
  Note:
  The length of nums is at most 20000.
  Each element nums[i] is an integer in the range [1, 10000].
  -/

vc-preamble: |-
  def delete_and_earn (nums : List Nat) : Nat := sorry
  
  def List.sum : List Nat → Nat 
    | [] => 0
    | (x::xs) => x + List.sum xs
  
  def List.maximum' : List Nat → Nat 
    | [] => 0
    | [x] => x
    | (x::xs) => max x (List.maximum' xs)
  
  def isConsecutive (nums : List Nat) : Bool := sorry
  
  def sumByParity (nums : List Nat) (isOdd : Bool) : Nat := 
    List.sum (List.filter (fun n => n % 2 = if isOdd then 1 else 0) nums)

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def isSpaced (nums : List Nat) : Bool := sorry
  
  theorem spaced_numbers (nums : List Nat) (h : nums.length ≥ 2) :
    isSpaced nums = true →
    delete_and_earn nums = List.sum nums := sorry

vc-theorems: |-
  theorem delete_and_earn_properties (nums : List Nat) :
    let result := delete_and_earn nums;
    (nums = [] → result = 0) ∧
    (nums ≠ [] →
      let max_num := List.maximum' nums;
      let max_count := (List.filter (fun x => x = max_num) nums).length;
      result ≥ max_num * max_count) ∧
    result ≤ List.sum nums := sorry
  
  theorem consecutive_numbers (nums : List Nat) (h : nums ≠ []) :
    isConsecutive nums = true →
    delete_and_earn nums = max (sumByParity nums true) (sumByParity nums false) := sorry
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval delete_and_earn [3, 4, 2]
  
  /-
  info: 9
  -/
  -- #guard_msgs in
  -- #eval delete_and_earn [2, 2, 3, 3, 3, 4]
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval delete_and_earn [2, 3, 4]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

