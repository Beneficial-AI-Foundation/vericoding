vc-description: |-
  /-
  In this kata, you have to define a function named **func** that will take a list as input.
  
  You must try and guess the pattern how we get the output number and return list - **[output number,binary representation,octal representation,hexadecimal representation]**, but **you must convert that specific number without built-in : bin,oct and hex functions.**
  
  Examples : 
  
  ```python
  func([12,13,6,3,6,45,123]) returns - [29,'11101','35','1d']
  
  func([1,9,23,43,65,31,63,99]) returns - [41,'101001','51','29']
  
  func([2,4,6,8,10,12,14,16,18,19]) returns - [10,'1010','12','a']
  ```
  -/

vc-preamble: |-
  def func (numbers : List Nat) : List (Nat ⊕ String) := sorry
  
  def toBinary (n : Nat) : String := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def toOctal (n : Nat) : String := sorry
  def toHex (n : Nat) : String := sorry

vc-theorems: |-
  theorem conversion_properties {numbers : List Nat} (h : numbers.length > 0) :
    let result := func numbers
    let expected_n := numbers.foldl (· + ·) 0 / numbers.length
    List.get! result 0 = .inl expected_n ∧ 
    List.get! result 1 = .inr (toBinary expected_n) ∧
    List.get! result 2 = .inr (toOctal expected_n) ∧
    List.get! result 3 = .inr (toHex expected_n) := sorry
  
  theorem length_properties {numbers : List Nat} (h : numbers.length > 0) :
    let result := func numbers
    result.length = 4 ∧
    (match List.get! result 0 with | .inl _ => true | .inr _ => false) ∧
    (∀ i, i > 0 → i < 4 → match List.get! result i with | .inl _ => false | .inr _ => true) := sorry
  
  theorem zero_case {numbers : List Nat} (h : numbers.length > 0) 
      (h' : ∀ x ∈ numbers, x = 0) :
    func numbers = [.inl 0, .inr "0", .inr "0", .inr "0"] := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

