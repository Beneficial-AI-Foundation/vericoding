vc-description: |-
  /-
  You are given a sequence of integers $A_1,A_2,…,A_N$ and a magical non-zero integer $x$
  You have to select a subsegment of sequence A (possibly empty), and replace the elements in that subsegment after dividing them by x.
  Formally, replace any one subsegment $A_l, A_{l+1}, ..., A_r$ with $A_l/x, A_{l+1}/x, ..., A_r/x$ where $l \leq r$
  What is the minimum possible sum you can obtain?
  Note: The given operation can only be performed once
  
  -----Input -----
  - The first line of the input contains two positive integer n denoting the size of array, and x
  denoting the magical integer
  - Next line contains $N$ space separated integers
  
  -----Output-----
  Single line containing one real number, denoting the minimum possible sum you can obtain. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-2}$
  
  -----Constraints-----
  - $1 \leq n \leq 10^3$
  - $1 \leq |x| \leq 10^3$
  - $ |A_i| \leq 10^3$
  
  -----Sample Input-----
  3 2
  1 -2 3
  
  -----Sample Output-----
  0.5
  
  -----Explanation-----
  Array 1 -2 3, selecting subsegment {3}, you get 1 -2 1.5, which gives $sum=0.5$
  -/

vc-preamble: |-
  def List.sum (l : List Int) : Int := 
    match l with
    | [] => 0
    | x :: xs => x + List.sum xs
  
  def List.sumFloat (l : List Float) : Float :=
    match l with
    | [] => 0
    | x :: xs => x + List.sumFloat xs

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def min_sum_after_division (n : Nat) (x : Nat) (arr : List Int) : Float := sorry
  
  theorem min_sum_properties_le_orig_sum {n : Nat} {x : Nat} {arr : List Int} 
    (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) 
    (h4 : x ≠ 0) :
    min_sum_after_division n x arr ≤ Float.ofInt (List.sum arr) := sorry

vc-theorems: |-
  theorem min_sum_properties_exists_real {n : Nat} {x : Nat} {arr : List Int}
    (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) 
    (h4 : x ≠ 0) :
    ∃ r : Float, min_sum_after_division n x arr = r := sorry
  
  theorem min_sum_properties_le_divided_sum {n : Nat} {x : Nat} {arr : List Int} {i j : Nat}
    (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)
    (h4 : i ≤ j) (h5 : j < arr.length) (h6 : x ≠ 0) :
    let divided_section := (arr.drop i).take (j-i+1) |>.map (fun a => Float.ofInt a / Float.ofNat x)
    let divided_sum := Float.ofInt (List.sum (arr.take i)) + 
                      List.sumFloat divided_section +
                      Float.ofInt (List.sum (arr.drop (j+1)))
    min_sum_after_division n x arr ≤ divided_sum := sorry
  
  theorem positive_array_nonneg {n : Nat} {x : Nat} {arr : List Int}
    (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)
    (h4 : ∀ a ∈ arr, a ≥ 0) (h5 : x ≠ 0) :
    min_sum_after_division n x arr ≥ 0 := sorry 
  
  theorem positive_array_le_sum {n : Nat} {x : Nat} {arr : List Int}
    (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) 
    (h4 : ∀ a ∈ arr, a ≥ 0) (h5 : x ≠ 0) :
    min_sum_after_division n x arr ≤ Float.ofInt (List.sum arr) := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

