vc-description: |-
  /- 
  -----Description-----
  This task requires writing a Lean 4 method that determines the length of the longest strictly increasing subsequence in a given array of integers.
  
  A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The subsequence must be strictly increasing, meaning each element must be greater than the one before it.
  
  The goal is to find the length of the longest such subsequence that can be formed from the input array.
  
  -----Input-----
  The input consists of one array:
  
  nums: An array of integers where nums[i] represents the ith element of the input sequence.
  
  -----Output-----
  The output is an integer:
  Returns the length of the longest strictly increasing subsequence in the input array.
  -/

vc-preamble: |-
  @[reducible, simp]
  def lengthOfLIS_precond (nums : List Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    let rec lisHelper (dp : List Int) (x : Int) : List Int :=
      let rec replace (l : List Int) (acc : List Int) : List Int :=
        match l with
        | [] => (acc.reverse ++ [x])
        | y :: ys => if x ≤ y then acc.reverse ++ (x :: ys) else replace ys (y :: acc)
      replace dp []
  
    let finalDP := nums.foldl lisHelper []
    finalDP.length
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def lengthOfLIS_postcond (nums : List Int) (result: Int) (h_precond : lengthOfLIS_precond (nums)) : Prop :=
    -- Helper function to check strictly increasing
    let rec isStrictlyIncreasing (l : List Int) : Bool :=
      match l with
      | [] | [_] => true
      | x :: y :: rest => x < y && isStrictlyIncreasing (y :: rest)
  
    -- Generate all subsequences
    let rec subsequences (xs : List Int) : List (List Int) :=
      match xs with
      | [] => [[]]
      | x :: xs' =>
        let rest := subsequences xs'
        rest ++ rest.map (fun r => x :: r)
  
    let allIncreasing := subsequences nums |>.filter (fun l => isStrictlyIncreasing l)
  
    allIncreasing.any (fun l => l.length = result) ∧
    allIncreasing.all (fun l => l.length ≤ result)
  
  theorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :
      lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "nums": "[10, 9, 2, 5, 3, 7, 101, 18]"
          },
          "expected": 4,
          "unexpected": [
              1,
              2,
              8
          ]
      },
      {
          "input": {
              "nums": "[0, 1, 0, 3, 2, 3]"
          },
          "expected": 4,
          "unexpected": [
              1,
              3,
              6
          ]
      },
      {
          "input": {
              "nums": "[7, 7, 7, 7, 7, 7, 7]"
          },
          "expected": 1,
          "unexpected": [
              0,
              6,
              7
          ]
      },
      {
          "input": {
              "nums": "[4, 10, 4, 3, 8, 9]"
          },
          "expected": 3,
          "unexpected": [
              1,
              2,
              6
          ]
      },
      {
          "input": {
              "nums": "[1, 3, 6, 7, 9, 4, 10, 5, 6]"
          },
          "expected": 6,
          "unexpected": [
              1,
              4,
              9
          ]
      }
  ]
  -/

