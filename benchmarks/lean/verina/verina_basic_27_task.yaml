vc-description: |-
  /- 
  -----Description-----
  This task requires writing a Lean 4 method that identifies the first repeated character in a given string. The method should return a tuple containing a Boolean value and a character. The Boolean value indicates whether any character in the string is repeated. If it is true, the accompanying character is the first character that appears more than once. If it is false, it indicates that there are no repeated characters in the string.
  
  -----Input-----
  The input consists of:
  s: A string.
  
  -----Output-----
  The output is a tuple (Bool × Char):
  - Returns true and the first repeated character in the string if any repeated character is found.
  - Returns false and an arbitrary character if no repeated characters are present.
  
  -----Note-----
  There are no preconditions; the method is expected to work for any non-null string.
  -/

vc-preamble: |-
  import Std.Data.HashSet
  
  @[reducible, simp]
  def findFirstRepeatedChar_precond (s : String) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def findFirstRepeatedChar (s : String) (h_precond : findFirstRepeatedChar_precond (s)) : Option Char :=

vc-implementation: |-
  -- <vc-implementation>
    let cs := s.toList
    let rec loop (i : Nat) (seen : Std.HashSet Char) : Option Char :=
      if i < cs.length then
        let c := cs[i]!
        if seen.contains c then
          some c
        else
          loop (i + 1) (seen.insert c)
      else
        -- When no repeated char is found, return (false, arbitrary char)
        none
    loop 0 Std.HashSet.empty
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def findFirstRepeatedChar_postcond (s : String) (result: Option Char) (h_precond : findFirstRepeatedChar_precond (s)) :=
    let cs := s.toList
    match result with
    | some c =>
      let secondIdx := cs.zipIdx.findIdx (fun (x, i) => x = c && i ≠ cs.idxOf c)
      -- Exists repeated char
      cs.count c ≥ 2 ∧
      -- There is no other repeated char before the found one
      List.Pairwise (· ≠ ·) (cs.take secondIdx)
    | none =>
      -- There is no repeated char
      List.Pairwise (· ≠ ·) cs
  
  theorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :
      findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "s": "abca"
          },
          "expected": "some ('a')",
          "unexpected": [
              "some ('b')",
              "some ('c')",
              "none"
          ]
      },
      {
          "input": {
              "s": "abcdef"
          },
          "expected": "none",
          "unexpected": [
              "some ('a')",
              "some ('z')"
          ]
      },
      {
          "input": {
              "s": "aabbcc"
          },
          "expected": "some ('a')",
          "unexpected": [
              "some ('b')",
              "some ('c')",
              "none"
          ]
      },
      {
          "input": {
              "s": ""
          },
          "expected": "none",
          "unexpected": [
              "some ('x')",
              "some ('y')"
          ]
      },
      {
          "input": {
              "s": "abbc"
          },
          "expected": "some ('b')",
          "unexpected": [
              "some ('a')",
              "some ('c')",
              "none"
          ]
      },
      {
          "input": {
              "s": "Aa"
          },
          "expected": "none",
          "unexpected": [
              "some ('A')",
              "some ('a')"
          ]
      }
  ]
  -/

