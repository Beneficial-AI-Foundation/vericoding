vc-description: |-
  /- 
  -----Description-----
  This task requires writing a Lean 4 method that moves all zeroes in a given integer list to the end, while preserving the relative order of the non-zero elements.
  
  The method `moveZeroes` processes the input list by separating the non-zero and zero elements. It then returns a new list formed by appending all non-zero elements followed by all the zero elements.
  
  -----Input-----
  The input is a single list of integers:
  xs: A list of integers (type: List Int), possibly containing zero and non-zero values.
  
  -----Output-----
  The output is a list of integers:
  Returns a list (type: List Int) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.
  -/

vc-preamble: |-
  @[reducible]
  def moveZeroes_precond (xs : List Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- Count how many times a specific value appears in the list
  -- </vc-helpers>

vc-signature: |-
  def moveZeroes (xs : List Int) (h_precond : moveZeroes_precond (xs)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    sorry
  -- </vc-implementation>

vc-condition: |-
  def countVal (val : Int) : List Int → Nat
    | [] => 0
    | x :: xs =>
      let rest := countVal val xs
      if x = val then rest + 1 else rest
  
  -- Check whether one list is a subsequence of another (preserving relative order)
  def isSubsequence (xs ys : List Int) : Bool :=
    match xs, ys with
    | [], _ => true
    | _ :: _, [] => false
    | x :: xt, y :: yt =>
      if x = y then isSubsequence xt yt else isSubsequence xs yt
  @[reducible]
  def moveZeroes_postcond (xs : List Int) (result: List Int) (h_precond : moveZeroes_precond (xs)) : Prop :=
    -- 1. All non-zero elements must maintain their relative order
    isSubsequence (xs.filter (fun x => x ≠ 0)) result = true ∧
  
    -- 2. All zeroes must be located at the end of the output list
    (result.dropWhile (fun x => x ≠ 0)).all (fun x => x = 0) ∧
  
    -- 3. The output must contain the same number of elements,
    --    and the number of zeroes must remain unchanged
    countVal 0 xs = countVal 0 result ∧
    xs.length = result.length
  
  theorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :
      moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "xs": "[0, 1, 0, 3, 12]"
          },
          "expected": "[1, 3, 12, 0, 0]",
          "unexpected": [
              "[0, 1, 3, 12, 0]"
          ]
      },
      {
          "input": {
              "xs": "[0, 0, 1]"
          },
          "expected": "[1, 0, 0]",
          "unexpected": [
              "[0, 1, 0]"
          ]
      },
      {
          "input": {
              "xs": "[1, 2, 3]"
          },
          "expected": "[1, 2, 3]",
          "unexpected": [
              "[1, 3, 2]",
              "[0, 1, 2, 3]"
          ]
      },
      {
          "input": {
              "xs": "[0, 0, 0]"
          },
          "expected": "[0, 0, 0]",
          "unexpected": [
              "[0, 0]",
              "[]",
              "[0]"
          ]
      },
      {
          "input": {
              "xs": "[]"
          },
          "expected": "[]",
          "unexpected": [
              "[0]"
          ]
      },
      {
          "input": {
              "xs": "[4, 0, 5, 0, 6]"
          },
          "expected": "[4, 5, 6, 0, 0]",
          "unexpected": [
              "[0, 4, 5, 6, 0]"
          ]
      },
      {
          "input": {
              "xs": "[0, 1]"
          },
          "expected": "[1, 0]",
          "unexpected": [
              "[0, 1]"
          ]
      },
      {
          "input": {
              "xs": "[1, 0]"
          },
          "expected": "[1, 0]",
          "unexpected": [
              "[0, 1]"
          ]
      },
      {
          "input": {
              "xs": "[2, 0, 0, 3]"
          },
          "expected": "[2, 3, 0, 0]",
          "unexpected": [
              "[0, 0, 2, 3]",
              "[2, 0, 3, 0]"
          ]
      }
  ]
  -/

