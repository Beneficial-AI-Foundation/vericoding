vc-description: |-
  /- 
  -----Description-----
  This problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.
  
  -----Input-----
  The input consists of:
  • s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.
  
  -----Output-----
  The output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.
  
  -----Note-----
  No additional preconditions are required. The method should correctly handle any list, including an empty list.
  -/

vc-preamble: |-
  @[reducible, simp]
  def SetToSeq_precond (s : List Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def SetToSeq (s : List Int) (h_precond : SetToSeq_precond (s)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    s.foldl (fun acc x => if acc.contains x then acc else acc ++ [x]) []
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def SetToSeq_postcond (s : List Int) (result: List Int) (h_precond : SetToSeq_precond (s)) :=
    -- Contains exactly the elements of the set
    result.all (fun a => a ∈ s) ∧ s.all (fun a => a ∈ result) ∧
    -- All elements are unique in the result
    result.all (fun a => result.count a = 1) ∧
    -- The order of elements in the result is preserved
    List.Pairwise (fun a b => (result.idxOf a < result.idxOf b) → (s.idxOf a < s.idxOf b)) result
  
  theorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :
      SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "s": "[1, 2, 2, 3, 1]"
          },
          "expected": "[1, 2, 3]",
          "unexpected": [
              "[1, 3, 2]",
              "[1, 2, 2, 3]",
              "[2, 1, 3]"
          ]
      },
      {
          "input": {
              "s": "[5, 5, 5, 5]"
          },
          "expected": "[5]",
          "unexpected": [
              "[5, 5]",
              "[]",
              "[6]"
          ]
      },
      {
          "input": {
              "s": "[]"
          },
          "expected": "[]",
          "unexpected": [
              "[1]",
              "[2]",
              "[0]"
          ]
      },
      {
          "input": {
              "s": "[11, 22, 33]"
          },
          "expected": "[11, 22, 33]",
          "unexpected": [
              "[33, 22, 11]",
              "[11, 11, 22, 33]",
              "[11, 33]"
          ]
      },
      {
          "input": {
              "s": "[3, 1, 4, 1, 5, 9, 2, 6, 5]"
          },
          "expected": "[3, 1, 4, 5, 9, 2, 6]",
          "unexpected": [
              "[3, 1, 4, 1, 5, 9, 2, 6, 5]",
              "[1, 3, 4, 5, 9, 2, 6]",
              "[3, 1, 4, 5, 9, 6]"
          ]
      }
  ]
  -/

