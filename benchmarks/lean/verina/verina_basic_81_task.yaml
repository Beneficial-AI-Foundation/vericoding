vc-description: |-
  /--
  -----Description-----
  This task involves performing integer division with remainder on natural numbers. Given two natural numbers, x (the dividend) and y (the divisor), the objective is to determine the quotient and remainder. When y is non-zero, the quotient and remainder should satisfy the condition that the dividend equals the divisor multiplied by the quotient plus the remainder, with the remainder being nonnegative and strictly less than y. In the case where y is zero, the result should indicate that no division is performed by returning x as the quotient and 0 as the remainder.
  
  -----Input-----
  The input consists of two natural numbers:
  • x: A natural number representing the dividend.
  • y: A natural number representing the divisor.
  
  -----Output-----
  The output is a pair of integers (r, q) where:
  • If y ≠ 0, then q is the quotient and r is the remainder such that:
     - q * Int.ofNat y + r = Int.ofNat x
     - 0 ≤ r < Int.ofNat y
     - 0 ≤ q
  • If y = 0, then the output is (Int.ofNat x, 0).
  
  -----Note-----
  The specification regarding the division properties applies only when y is non-zero. When y = 0, the function safely returns (x, 0) in its integer form.
  -/

vc-preamble: |-
  import Mathlib
  
  @[reducible, simp]
  def DivisionFunction_precond (x : Nat) (y : Nat) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  def divMod (x y : Nat) : Int × Int :=
    let q : Int := Int.ofNat (x / y)
    let r : Int := Int.ofNat (x % y)
    (r, q)
  -- </vc-helpers>

vc-signature: |-
  def DivisionFunction (x : Nat) (y : Nat) (h_precond : DivisionFunction_precond (x) (y)) : Int × Int :=

vc-implementation: |-
  -- <vc-implementation>
    if y = 0 then (Int.ofNat x, 0) else divMod x y
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def DivisionFunction_postcond (x : Nat) (y : Nat) (result: Int × Int) (h_precond : DivisionFunction_precond (x) (y)) :=
    let (r, q) := result;
    (y = 0 → r = Int.ofNat x ∧ q = 0) ∧
    (y ≠ 0 → (q * Int.ofNat y + r = Int.ofNat x) ∧ (0 ≤ r ∧ r < Int.ofNat y) ∧ (0 ≤ q))
  
  theorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :
      DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    unfold DivisionFunction_postcond DivisionFunction
    simp
    split
    {
      simp
      intro h₁
      contradiction
    }
    {
  
      have h_left : (¬y = 0 →
      (divMod x y).snd * ↑y + (divMod x y).fst = ↑x ∧
        (0 ≤ (divMod x y).fst ∧ (divMod x y).fst < ↑y) ∧ 0 ≤ (divMod x y).snd) := by
        intro h₁
        have h₁_left : (divMod x y).snd * ↑y + (divMod x y).fst = ↑x := by
          unfold divMod
          simp
          have h₁ := Int.ediv_add_emod' x y
          apply h₁
        have h₁_right : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) ∧ 0 ≤ (divMod x y).2 := by
          have h₂_left : (0 ≤ (divMod x y).1 ∧ (divMod x y).1 < ↑y) := by
            have h₃_left : 0 ≤ (divMod x y).1 := by
              unfold divMod
              simp
              rw [←Int.natCast_mod, ←Int.ofNat_eq_natCast]
              have ha := Int.zero_le_ofNat (x % y)
              apply ha
            have h₃_right : (divMod x y).1 < ↑y := by
              unfold divMod
              simp
              rw [←Int.natCast_mod]
              have ha := @Int.natMod_lt x y h₁
              rw [Int.natMod, ←Int.natCast_mod, Int.toNat_ofNat] at ha
              rw [←Mathlib.Tactic.Zify.natCast_lt]
              apply ha
            exact ⟨h₃_left, h₃_right⟩
  
          have h₂_right : 0 ≤ (divMod x y).2 := by
            unfold divMod
            simp
            rw [←Int.natCast_div]
            have ha := Int.natCast_nonneg (x / y)
            apply ha
          exact ⟨h₂_left, h₂_right⟩
        exact ⟨h₁_left, h₁_right⟩
      have h_right : (y = 0 → (divMod x y).fst = ↑x ∧ (divMod x y).snd = 0) := by
        intro h₀
        have h₁_left : (divMod x y).1 = ↑x := by
          unfold divMod
          simp
          rw [←Int.natCast_mod, h₀, Nat.mod_zero]
        have h₁_right : (divMod x y).snd = 0 := by
          unfold divMod
          simp
          rw [←Int.natCast_div, h₀, Nat.div_zero, ←@Int.cast_id 0]
          rfl
        exact ⟨h₁_left, h₁_right⟩
      constructor
      · simp_all [h_left]
      · simp_all [h_right]
    }
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "x": 10,
              "y": 3
          },
          "expected": "(1, 3)",
          "unexpected": [
              "(2, 2)",
              "(0, 3)",
              "(1, 4)"
          ]
      },
      {
          "input": {
              "x": 15,
              "y": 5
          },
          "expected": "(0, 3)",
          "unexpected": [
              "(3, 0)",
              "(1, 1)",
              "(0, 4)"
          ]
      },
      {
          "input": {
              "x": 7,
              "y": 2
          },
          "expected": "(1, 3)",
          "unexpected": [
              "(3, 1)",
              "(0, 7)",
              "(1, 2)"
          ]
      },
      {
          "input": {
              "x": 0,
              "y": 4
          },
          "expected": "(0, 0)",
          "unexpected": [
              "(0, 1)",
              "(1, 0)",
              "(2, 0)"
          ]
      },
      {
          "input": {
              "x": 10,
              "y": 0
          },
          "expected": "(10, 0)",
          "unexpected": [
              "(0, 10)",
              "(10, 1)",
              "(5, 5)"
          ]
      }
  ]
  -/

