vc-description: |-
  /- 
  -----Description-----
  This task requires writing a Lean 4 method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, "aaabbc" becomes [(’a’, 3), (’b’, 2), (’c’, 1)].
  
  The resulting encoded list must satisfy the following properties:
  1. No pair has a zero or negative run-length.
  2. Consecutive pairs in the encoding list must not have the same character.
  3. Decoding the output should return the original string.
  
  -----Input-----
  The input is a single string, `s`.
  
  -----Output-----
  The output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.
  -/

vc-preamble: |-
  @[reducible, simp]
  def runLengthEncode_precond (s : String) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def runLengthEncode (s : String) (h_precond : runLengthEncode_precond (s)) : List (Char × Nat) :=

vc-implementation: |-
  -- <vc-implementation>
    sorry
  -- </vc-implementation>

vc-condition: |-
  def decodeRLE (lst : List (Char × Nat)) : String :=
    match lst with
    | [] => ""
    | (ch, cnt) :: tail =>
      let repeated := String.mk (List.replicate cnt ch)
      repeated ++ decodeRLE tail
  @[reducible, simp]
  def runLengthEncode_postcond (s : String) (result: List (Char × Nat)) (h_precond : runLengthEncode_precond (s)) : Prop :=
    (∀ pair ∈ result, pair.snd > 0) ∧
    (∀ i : Nat, i < result.length - 1 → (result[i]!).fst ≠ (result[i+1]!).fst) ∧
    decodeRLE result = s
  
  theorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :
      runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "s": ""
          },
          "expected": "[]",
          "unexpected": [
              "[('x', 1)]"
          ]
      },
      {
          "input": {
              "s": "aaa"
          },
          "expected": "[('a', 3)]",
          "unexpected": [
              "[('a', 2), ('b', 3)]"
          ]
      },
      {
          "input": {
              "s": "abbbcccaa"
          },
          "expected": "[('a', 1), ('b', 3), ('c', 3), ('a', 2)]",
          "unexpected": [
              "[('a', 2), ('b', 3), ('c', 3), ('a', 2)]"
          ]
      },
      {
          "input": {
              "s": "xyz"
          },
          "expected": "[('x', 1), ('y', 1), ('z', 1)]",
          "unexpected": [
              "[('x', 3)]",
              "[('z', 1)]"
          ]
      },
      {
          "input": {
              "s": "aabbaa"
          },
          "expected": "[('a', 2), ('b', 2), ('a', 2)]",
          "unexpected": [
              "[('a', 2), ('b', 2), ('a', 3)]"
          ]
      }
  ]
  -/

