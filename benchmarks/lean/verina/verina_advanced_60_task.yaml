vc-description: |-
  /- 
  -----Description-----
  
  This task requires writing a Lean 4 method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.
  
  -----Input-----
  
  The input consists of a single list with no duplicate natural numbers:
  - nums: A list of natural numbers (Nat)
  
  -----Output-----
  
  The output is a tuple of two lists:
  - The first list contains all even numbers from the input list, in order.
  - The second list contains all odd numbers from the input list, in order.
  -/

vc-preamble: |-
  @[reducible]
  def partitionEvensOdds_precond (nums : List Nat) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def partitionEvensOdds (nums : List Nat) (h_precond : partitionEvensOdds_precond (nums)) : (List Nat × List Nat) :=

vc-implementation: |-
  -- <vc-implementation>
    let rec helper (nums : List Nat) : (List Nat × List Nat) :=
      match nums with
      | [] => ([], [])
      | x :: xs =>
        let (evens, odds) := helper xs
        if x % 2 == 0 then (x :: evens, odds)
        else (evens, x :: odds)
    helper nums
  -- </vc-implementation>

vc-condition: |-
  @[reducible]
  def partitionEvensOdds_postcond (nums : List Nat) (result: (List Nat × List Nat)) (h_precond : partitionEvensOdds_precond (nums)): Prop :=
    let evens := result.fst
    let odds := result.snd
    -- All elements from nums are in evens ++ odds, no extras
    evens ++ odds = nums.filter (fun n => n % 2 == 0) ++ nums.filter (fun n => n % 2 == 1) ∧
    evens.all (fun n => n % 2 == 0) ∧
    odds.all (fun n => n % 2 == 1)
  
  theorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :
      partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "nums": "[1, 2, 3, 4, 5, 6]"
          },
          "expected": "([2, 4, 6], [1, 3, 5])",
          "unexpected": [
              "([1, 3, 5], [2, 4, 6])"
          ]
      },
      {
          "input": {
              "nums": "[0, 7, 8, 9, 10]"
          },
          "expected": "([0, 8, 10], [7, 9])",
          "unexpected": [
              "([8, 0, 10], [9, 7])"
          ]
      },
      {
          "input": {
              "nums": "[]"
          },
          "expected": "([], [])",
          "unexpected": [
              "([0], [1])"
          ]
      },
      {
          "input": {
              "nums": "[2, 4, 6, 8]"
          },
          "expected": "([2, 4, 6, 8], [])",
          "unexpected": [
              "([], [2, 4, 6, 8])"
          ]
      },
      {
          "input": {
              "nums": "[1, 3, 5, 7]"
          },
          "expected": "([], [1, 3, 5, 7])",
          "unexpected": [
              "([1, 3, 5, 7], [])"
          ]
      }
  ]
  -/

