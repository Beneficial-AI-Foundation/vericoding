vc-description: |-
  /- 
  -----Description-----
  This task requires writing a Lean 4 function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.
  
  -----Input-----
  The input is a list of integers. For example, [1,2,3,4].
  
  -----Output-----
  The output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.
  -/

vc-preamble: |-
  @[reducible]
  def productExceptSelf_precond (nums : List Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- Helper: Compute prefix products.
  -- prefix[i] is the product of all elements in nums before index i.
  def computepref (nums : List Int) : List Int :=
    nums.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]
  
  -- Helper: Compute suffix products.
  -- suffix[i] is the product of all elements in nums from index i (inclusive) to the end.
  -- We reverse the list and fold, then reverse back.
  def computeSuffix (nums : List Int) : List Int :=
    let revSuffix := nums.reverse.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]
    revSuffix.reverse
  -- </vc-helpers>

vc-signature: |-
  def productExceptSelf (nums : List Int) (h_precond : productExceptSelf_precond (nums)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    let n := nums.length
    if n = 0 then []
    else
      let pref := computepref nums  -- length = n + 1, where prefix[i] = product of nums[0 ... i-1]
      let suffix := computeSuffix nums  -- length = n + 1, where suffix[i] = product of nums[i ... n-1]
      -- For each index i (0 ≤ i < n): result[i] = prefix[i] * suffix[i+1]
      -- Use array-style indexing as get! is deprecated
      List.range n |>.map (fun i => pref[i]! * suffix[i+1]!)
  -- </vc-implementation>

vc-condition: |-
  -- Specification Helper: Product of a list of Ints
  -- Defined locally if not available/imported
  def List.myprod : List Int → Int
    | [] => 1
    | x :: xs => x * xs.myprod
  @[reducible]
  def productExceptSelf_postcond (nums : List Int) (result: List Int) (h_precond : productExceptSelf_precond (nums)) : Prop :=
    nums.length = result.length ∧
    (List.range nums.length |>.all (fun i =>
      result[i]! = some (((List.take i nums).myprod) * ((List.drop (i+1) nums).myprod))))
  
  theorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :
      productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "nums": "[1, 2, 3, 4]"
          },
          "expected": "[24, 12, 8, 6]",
          "unexpected": [
              "[24, 12, 8, 0]",
              "[1, 2, 3, 4]"
          ]
      },
      {
          "input": {
              "nums": "[-1, 1, 0, -3, 3]"
          },
          "expected": "[0, 0, 9, 0, 0]",
          "unexpected": [
              "[0, 0, 0, 0, 0]"
          ]
      },
      {
          "input": {
              "nums": "[2, 3]"
          },
          "expected": "[3, 2]",
          "unexpected": [
              "[6]",
              "[6, 6]"
          ]
      },
      {
          "input": {
              "nums": "[5, 5, 5, 5]"
          },
          "expected": "[125, 125, 125, 125]",
          "unexpected": [
              "[5]",
              "[25, 25, 25, 25]"
          ]
      },
      {
          "input": {
              "nums": "[0, 1, 2]"
          },
          "expected": "[2, 0, 0]",
          "unexpected": [
              "[2, 1, 0]",
              "[2, 0]"
          ]
      }
  ]
  -/

