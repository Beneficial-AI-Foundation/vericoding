vc-description: |-
  /- 
  -----Description-----
  This test implements a function in Lean 4 that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.
  
  -----Input-----
  numbers: A list of integers.
  
  -----Output-----
  A natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.
  -/

vc-preamble: |-
  import Mathlib
  
  @[reducible, simp]
  def longestIncreasingSubsequence_precond (numbers : List Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def longestIncreasingSubsequence (numbers : List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Nat :=

vc-implementation: |-
  -- <vc-implementation>
    let rec buildTables : List Int → List Int → List Nat → Nat → Nat
      | [], _, lengths, _ =>
          let rec findMaxLength : List Nat → Nat
            | [] => 0
            | x :: xs =>
                let maxRest := findMaxLength xs
                if x > maxRest then x else maxRest
          findMaxLength lengths
      | currNum :: restNums, prevNums, lengths, idx =>
          let rec findLengthEndingAtCurr : List Int → List Nat → Nat → Nat
            | [], _, best => best
            | prevVal :: restVals, prevLen :: restLens, best =>
                if prevVal < currNum then
                  findLengthEndingAtCurr restVals restLens (max best prevLen)
                else
                  findLengthEndingAtCurr restVals restLens best
            | _, _, best => best
  
          let bestPrevLen := findLengthEndingAtCurr prevNums lengths 0
          let currLength := bestPrevLen + 1
          buildTables restNums (prevNums ++ [currNum]) (lengths ++ [currLength]) (idx + 1)
  
    match numbers with
    | [] => 0
    | [x] => 1
    | first :: rest => buildTables rest [first] [1] 1
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def longestIncreasingSubsequence_postcond (numbers : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Prop :=
    let allSubseq := (numbers.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse
    let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)
    increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)
  
  theorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :
      longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "numbers": "[10, 22, 9, 33, 21, 50, 41, 60]"
          },
          "expected": 5,
          "unexpected": [
              4,
              6,
              8
          ]
      },
      {
          "input": {
              "numbers": "[3, 10, 2, 1, 20]"
          },
          "expected": 3,
          "unexpected": [
              2,
              4,
              5
          ]
      },
      {
          "input": {
              "numbers": "[50, 3, 10, 7, 40, 80]"
          },
          "expected": 4,
          "unexpected": [
              3,
              5,
              6
          ]
      },
      {
          "input": {
              "numbers": "[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]"
          },
          "expected": 1,
          "unexpected": [
              0,
              2,
              10
          ]
      },
      {
          "input": {
              "numbers": "[1, 2, 3, 4, 5]"
          },
          "expected": 5,
          "unexpected": [
              1,
              4,
              6
          ]
      },
      {
          "input": {
              "numbers": "[]"
          },
          "expected": 0,
          "unexpected": [
              1,
              2,
              3
          ]
      },
      {
          "input": {
              "numbers": "[5]"
          },
          "expected": 1,
          "unexpected": [
              0,
              2
          ]
      },
      {
          "input": {
              "numbers": "[5, 5, 5, 5]"
          },
          "expected": 1,
          "unexpected": [
              0,
              4
          ]
      }
  ]
  -/

