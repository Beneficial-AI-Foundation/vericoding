{"id": "LV0000", "language": "lean", "source": "verina", "source_id": "verina_advanced_1_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function\nshould return the integer that appears only once.\n\n-----Input-----\nThe input is a non-empty list of integers:\n- nums: A list in which each integer appears exactly twice except for one element that appears only once.\n\n-----Output-----\nThe output is a single integer:\nReturns the unique integer that appears exactly once in the list.\n-/", "vc-preamble": "@[reducible]\ndef FindSingleNumber_precond (nums : List Int) : Prop :=\n  let numsCount := nums.map (fun x => nums.count x)\n  numsCount.all (fun count => count = 1 ∨ count = 2) ∧ numsCount.count 1 = 1", "vc-helpers": "def filterlist (x : Int) (nums : List Int) : List Int :=\n  let rec aux (lst : List Int) : List Int :=\n    match lst with\n    | []      => []\n    | y :: ys => if y = x then y :: aux ys else aux ys\n  aux nums", "vc-definitions": "def FindSingleNumber (nums : List Int) (h_precond : FindSingleNumber_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef FindSingleNumber_postcond (nums : List Int) (result: Int) (h_precond : FindSingleNumber_precond (nums)) : Prop :=\n  (nums.length > 0)\n  ∧\n  ((filterlist result nums).length = 1)\n  ∧\n  (∀ (x : Int),\n    x ∈ nums →\n    (x = result) ∨ ((filterlist x nums).length = 2))\n\ntheorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :\n    FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[2, 2]\"\n        }\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 2, 3, 3]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[2, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            1,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 2]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 3, 4, 4, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 3, 1, 3, 88, 88, 100, 100]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            100\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-1, -1, 7, 9, 7]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            -1,\n            7,\n            10\n        ]\n    }\n]\n-/"}
{"id": "LV0001", "language": "lean", "source": "verina", "source_id": "verina_advanced_2_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n-/", "vc-preamble": "@[reducible, simp]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True", "vc-helpers": "def intMax (x y : Int) : Int :=\n  if x < y then y else x", "vc-definitions": "def LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7]\",\n            \"b\": \"#[1, 2, 3, 4, 5, 6, 7]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[2, 4, 6, 8]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0002", "language": "lean", "source": "verina", "source_id": "verina_advanced_3_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the length of the logest common subsequence of two input arrays.\n\n-----Input-----\nThe input consists of two arrays:\na: The first array.\nb: The second array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of array a and b's longest common subsequence.\n-/", "vc-preamble": "@[reducible]\ndef LongestCommonSubsequence_precond (a : Array Int) (b : Array Int) : Prop :=\n  True", "vc-helpers": "def intMax (x y : Int) : Int :=\n  if x < y then y else x", "vc-definitions": "def LongestCommonSubsequence (a : Array Int) (b : Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef LongestCommonSubsequence_postcond (a : Array Int) (b : Array Int) (result: Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) : Prop :=\n  let allSubseq (arr : Array Int) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq a\n  let subseqB := allSubseq b\n  let commonSubseqLens := subseqA.filter (fun l => subseqB.contains l) |>.map (·.length)\n  commonSubseqLens.contains result ∧ commonSubseqLens.all (· ≤ result)\n\ntheorem LongestCommonSubsequence_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : LongestCommonSubsequence_precond (a) (b)) :\n    LongestCommonSubsequence_postcond (a) (b) (LongestCommonSubsequence (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7]\",\n            \"b\": \"#[1, 2, 3, 4, 5, 6, 7]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[2, 4, 6, 8]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0003", "language": "lean", "source": "verina", "source_id": "verina_advanced_4_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.\n\n-----Input-----\nThe input consists of an arrat:\na: The input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef LongestIncreasingSubsequence_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "def intMax (x y : Int) : Int :=\n  if x < y then y else x", "vc-definitions": "def LongestIncreasingSubsequence (a : Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LongestIncreasingSubsequence_postcond (a : Array Int) (result: Int) (h_precond : LongestIncreasingSubsequence_precond (a)) : Prop :=\n  let allSubseq := (a.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem LongestIncreasingSubsequence_spec_satisfied (a: Array Int) (h_precond : LongestIncreasingSubsequence_precond (a)) :\n    LongestIncreasingSubsequence_postcond (a) (LongestIncreasingSubsequence (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[5, 2, 8, 6, 3, 6, 9, 7]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, 1, 2, 1, 0]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 3, -2, -1, 7, 19, 3, 6, -4, 6, -7, 0, 9, 12, 10]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            3,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, -5, -3, 2, 4, 1, 0, -1, 3, 2, 0]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 7, 23, 14, -4, 21, 8, 2, -1, 9, 12, 2]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0004", "language": "lean", "source": "verina", "source_id": "verina_advanced_5_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that adds two non-empty linked lists representing non-negative integers.\nThe digits are stored in reverse order (i.e., the first element is the least significant digit).\nEach node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum\nas a linked list, also in reverse order.\n\n-----Input-----\nThe input consists of:\n- l1: A list of natural numbers representing the digits of the first number in reverse order.\n- l2: A list of natural numbers representing the digits of the second number in reverse order.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a list of digits (in reverse order) representing the sum of the two input numbers.\n-/", "vc-preamble": "@[reducible]\ndef addTwoNumbers_precond (l1 : List Nat) (l2 : List Nat) : Prop :=\n  l1.length > 0 ∧ l2.length > 0 ∧\n  (∀ d ∈ l1, d < 10) ∧ (∀ d ∈ l2, d < 10) ∧\n  (l1.getLast! ≠ 0 ∨ l1 = [0]) ∧\n  (l2.getLast! ≠ 0 ∨ l2 = [0])", "vc-helpers": "def listToNat : List Nat → Nat\n| []       => 0\n| d :: ds  => d + 10 * listToNat ds", "vc-definitions": "def addTwoNumbers (l1 : List Nat) (l2 : List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : List Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef addTwoNumbers_postcond (l1 : List Nat) (l2 : List Nat) (result: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) : Prop :=\n  listToNat result = listToNat l1 + listToNat l2 ∧\n  (∀ d ∈ result, d < 10) ∧\n  -- No leading zeros unless the result is zero\n  (result.getLast! ≠ 0 ∨ (l1 = [0] ∧ l2 = [0] ∧ result = [0]))\n\ntheorem addTwoNumbers_spec_satisfied (l1: List Nat) (l2: List Nat) (h_precond : addTwoNumbers_precond (l1) (l2)) :\n    addTwoNumbers_postcond (l1) (l2) (addTwoNumbers (l1) (l2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"l1\": \"[]\",\n            \"l2\": \"[]\"\n        }\n    },\n    {\n        \"input\": {\n            \"l1\": \"[0, 0]\",\n            \"l2\": \"[0, 0]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"l1\": \"[2,4,3]\",\n            \"l2\": \"[5,6,4]\"\n        },\n        \"expected\": \"[7,0,8]\",\n        \"unexpected\": [\n            \"[2,4,3]\",\n            \"[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l1\": \"[0]\",\n            \"l2\": \"[0]\"\n        },\n        \"expected\": \"[0]\",\n        \"unexpected\": [\n            \"[0,0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l1\": \"[9,9,9,9,9,9,9]\",\n            \"l2\": \"[9,9,9,9]\"\n        },\n        \"expected\": \"[8,9,9,9,0,0,0,1]\",\n        \"unexpected\": [\n            \"[9,9,9,9,9,9,9,9]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l1\": \"[1,2,3]\",\n            \"l2\": \"[4,5]\"\n        },\n        \"expected\": \"[5,7,3]\",\n        \"unexpected\": [\n            \"[5,7]\",\n            \"[5,7,4]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0005", "language": "lean", "source": "verina", "source_id": "verina_advanced_6_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.\n\nThe check is case-insensitive, meaning that both uppercase and lowercase vowels count.\n\n-----Input-----\nThe input consists of a string:\ns: A string of alphabetic characters (may include uppercase and lowercase)\n\n-----Output-----\nThe output is true or false:\nReturns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.\n-/", "vc-preamble": "@[reducible]\ndef allVowels_precond (s : String) : Prop :=\n  True", "vc-helpers": "def toLower (c : Char) : Char :=\n  if 'A' ≤ c && c ≤ 'Z' then\n    Char.ofNat (Char.toNat c + 32)\n  else\n    c\n\ndef normalize_str (s : String) : List Char :=\n  s.data.map toLower", "vc-definitions": "def allVowels (s : String) (h_precond : allVowels_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef allVowels_postcond (s : String) (result: Bool) (h_precond : allVowels_precond (s)) : Prop :=\n  let chars := normalize_str s\n  (result ↔ List.all ['a', 'e', 'i', 'o', 'u'] (fun v => chars.contains v))\n\ntheorem allVowels_spec_satisfied (s: String) (h_precond : allVowels_precond (s)) :\n    allVowels_postcond (s) (allVowels (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"education\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"education123\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"AEIOU\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"hello\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"apple orange union\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0006", "language": "lean", "source": "verina", "source_id": "verina_advanced_7_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that converts a binary number represented as a list of digits (0 or 1) into its corresponding decimal value. The list is ordered in big-endian format, meaning the most significant digit comes first.\nThe function should interpret the list as a binary number and return its decimal representation as a natural number.\n\n-----Input-----\nThe input is a list of natural numbers:\ndigits: A list of digits, each of which is either 0 or 1, representing a binary number in big-endian order.\n\n-----Output-----\nThe output is a natural number:\nReturns the decimal value of the binary number represented by the input list.\n-/", "vc-preamble": "@[reducible]\ndef binaryToDecimal_precond (digits : List Nat) : Prop :=\n  digits.all (fun d => d = 0 ∨ d = 1)", "vc-helpers": "", "vc-definitions": "def binaryToDecimal (digits : List Nat) (h_precond : binaryToDecimal_precond (digits)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef binaryToDecimal_postcond (digits : List Nat) (result: Nat) (h_precond : binaryToDecimal_precond (digits)) : Prop :=\n  result - List.foldl (λ acc bit => acc * 2 + bit) 0 digits = 0 ∧\n  List.foldl (λ acc bit => acc * 2 + bit) 0 digits - result = 0\n\ntheorem binaryToDecimal_spec_satisfied (digits: List Nat) (h_precond : binaryToDecimal_precond (digits)) :\n    binaryToDecimal_postcond (digits) (binaryToDecimal (digits) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"digits\": \"[2]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"digits\": \"[1, 0, 1]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            3,\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"[1, 1, 1, 1]\"\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            14,\n            16\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"[0, 0, 0]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"[1, 0, 0, 0, 0]\"\n        },\n        \"expected\": 16,\n        \"unexpected\": [\n            8,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"[1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0007", "language": "lean", "source": "verina", "source_id": "verina_advanced_8_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\n-----Input-----\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.\n-/", "vc-preamble": "@[reducible]\ndef canCompleteCircuit_precond (gas : List Int) (cost : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def canCompleteCircuit (gas : List Int) (cost : List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef canCompleteCircuit_postcond (gas : List Int) (cost : List Int) (result: Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Prop :=\n  let valid (start : Nat) := List.range gas.length |>.all (fun i =>\n    let acc := List.range (i + 1) |>.foldl (fun t j =>\n      let jdx := (start + j) % gas.length\n      t + gas[jdx]! - cost[jdx]!) 0\n    acc ≥ 0)\n  -- For result = -1: It's impossible to complete the circuit starting from any index\n  -- In other words, there's no starting point from which we can always maintain a non-negative gas tank\n  (result = -1 → (List.range gas.length).all (fun start => ¬ valid start)) ∧\n  -- For result ≥ 0: This is the valid starting point\n  -- When starting from this index, the gas tank never becomes negative during the entire circuit\n  (result ≥ 0 → result < gas.length ∧ valid result.toNat ∧ (List.range result.toNat).all (fun start => ¬ valid start))\n\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"gas\": \"[1, 2, 3, 4, 5]\",\n            \"cost\": \"[3, 4, 5, 1, 2]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            -1,\n            0,\n            1,\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[2, 3, 4]\",\n            \"cost\": \"[3, 4, 3]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[5, 1, 2, 3, 4]\",\n            \"cost\": \"[4, 4, 1, 5, 1]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            -1,\n            0,\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[3, 3, 4]\",\n            \"cost\": \"[3, 4, 4]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[1, 2, 3]\",\n            \"cost\": \"[1, 2, 3]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[1, 2, 3, 4]\",\n            \"cost\": \"[2, 2, 2, 2]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            -1,\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"gas\": \"[0, 0, 0]\",\n            \"cost\": \"[1, 1, 1]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0008", "language": "lean", "source": "verina", "source_id": "verina_advanced_9_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method of which given a number n and divisor d, it counts all the number that is smaller than\nn whose sum of digits is divisible by d.\n-----Input-----\nThe input consists of three Nat:\nn: Nat\nd:Nat where d > 0\n\n-----Output-----\nThe output is an Natural number:\nEnsure this match the count that satisfy the property.\n-/", "vc-preamble": "@[reducible]\ndef countSumDivisibleBy_precond (n : Nat) (d : Nat) : Prop :=\n  d > 0", "vc-helpers": "def sumOfDigits (x : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + (n % 10))\n  go x 0\n\ndef isSumDivisibleBy (x : Nat) (d:Nat) : Bool :=\n  (sumOfDigits x) % d = 0", "vc-definitions": "def countSumDivisibleBy (n : Nat) (d : Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef countSumDivisibleBy_postcond (n : Nat) (d : Nat) (result: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) : Prop :=\n  (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n))) - result = 0 ∧\n  result ≤ (List.length (List.filter (fun x => x < n ∧ (sumOfDigits x) % d = 0) (List.range n)))\n\ntheorem countSumDivisibleBy_spec_satisfied (n: Nat) (d: Nat) (h_precond : countSumDivisibleBy_precond (n) (d)) :\n    countSumDivisibleBy_postcond (n) (d) (countSumDivisibleBy (n) (d) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"n\": 1,\n            \"d\": 0\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0,\n            \"d\": 2\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1,\n            \"d\": 2\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10,\n            \"d\": 3\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 12,\n            \"d\": 2\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 20,\n            \"d\": 5\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            0,\n            10\n        ]\n    }\n]\n-/"}
{"id": "LV0009", "language": "lean", "source": "verina", "source_id": "verina_advanced_10_task", "vc-description": "/- \n-----Description-----\nhis task requires writing a Lean 4 method decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:\n\\[ n = \\prod p^e \\]\nIn other words, it determines the exponent e for each prime p.\n\n-----Input-----\nThe input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.\nn: The natural number to be factorized.\nprimes: A list of primes to decompose n into.\n\n-----Output-----\nThe output is `List (Nat × Nat)`:\nReturn a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.\n-/", "vc-preamble": "import Mathlib.Data.Nat.Prime.Defs\n\n@[reducible]\ndef findExponents_precond (n : Nat) (primes : List Nat) : Prop :=\n  primes.all (fun p => Nat.Prime p)", "vc-helpers": "", "vc-definitions": "def findExponents (n : Nat) (primes : List Nat) (h_precond : findExponents_precond (n) (primes)) : List (Nat × Nat) :=\n  sorry", "vc-theorems": "@[reducible]\ndef findExponents_postcond (n : Nat) (primes : List Nat) (result: List (Nat × Nat)) (h_precond : findExponents_precond (n) (primes)) : Prop :=\n  (n = result.foldl (fun acc (p, e) => acc * p ^ e) 1) ∧\n  result.all (fun (p, _) => p ∈ primes) ∧\n  primes.all (fun p => result.any (fun pair => pair.1 = p))\n\ntheorem findExponents_spec_satisfied (n: Nat) (primes: List Nat) (h_precond : findExponents_precond (n) (primes)) :\n    findExponents_postcond (n) (primes) (findExponents (n) (primes) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"n\": 6,\n            \"primes\": \"[6]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 6,\n            \"primes\": \"[2, 3]\"\n        },\n        \"expected\": \"[(2, 1), (3, 1)]\",\n        \"unexpected\": [\n            \"[(1, 2), (2, 3)]\",\n            \"[(2, 1), (3, 2)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 6285195213566005335561053533150026217291776,\n            \"primes\": \"[2, 3, 5]\"\n        },\n        \"expected\": \"[(2, 55), (3, 55), (5, 0)]\",\n        \"unexpected\": [\n            \"[(2, 2), (3, 55), (5, 59)]\",\n            \"[(2, 55), (3, 55), (7, 0)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 360,\n            \"primes\": \"[2, 3, 5]\"\n        },\n        \"expected\": \"[(2, 3), (3, 2), (5, 1)]\",\n        \"unexpected\": [\n            \"[(2, 3), (3, 2), (5, 0)]\",\n            \"[(2, 3), (3, 2), (7, 5)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 18903812908,\n            \"primes\": \"[2, 43, 823, 133543]\"\n        },\n        \"expected\": \"[(2, 2), (43, 1), (823, 1), (133543, 1)]\",\n        \"unexpected\": [\n            \"[(2, 2), (43, 4), (823, 0), (133543, 1)]\",\n            \"[(2, 2), (43, 1), (823, 2)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 114514,\n            \"primes\": \"[2, 31, 1847]\"\n        },\n        \"expected\": \"[(2, 1), (31, 1), (1847, 1)]\",\n        \"unexpected\": [\n            \"[(2, 1), (31, 1), (1847, 0)]\",\n            \"[(2, 1), (33, 1), (1847, 1)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 20241147794175,\n            \"primes\": \"[3, 5, 7, 11, 31, 47]\"\n        },\n        \"expected\": \"[(3, 3), (5, 2), (7, 1), (11, 3), (31, 1), (47, 3)]\",\n        \"unexpected\": [\n            \"[(0, 77), (17, 7)]\",\n            \"[(3, 3), (5, 2), (7, 1), (11, 3), (31, 1), (33, 2)]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0010", "language": "lean", "source": "verina", "source_id": "verina_advanced_11_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.\n\nIf such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than ⌊n/2⌋ times).\n\n-----Input-----\nThe input consists of a list of integers:\n- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.\n\n-----Output-----\nThe output is a single integer:\n- If a majority element exists in the input list, return that element.\n- If no majority element exists, return `-1`.\n-/", "vc-preamble": "@[reducible, simp]\ndef findMajorityElement_precond (lst : List Int) : Prop :=\n  True", "vc-helpers": "def countOccurrences (n : Int) (lst : List Int) : Nat :=\n  lst.foldl (fun acc x => if x = n then acc + 1 else acc) 0", "vc-definitions": "def findMajorityElement (lst : List Int) (h_precond : findMajorityElement_precond (lst)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findMajorityElement_postcond (lst : List Int) (result: Int) (h_precond : findMajorityElement_precond (lst)) : Prop :=\n  let count := fun x => (lst.filter (fun y => y = x)).length\n  let n := lst.length\n  let majority := count result > n / 2 ∧ lst.all (fun x => count x ≤ n / 2 ∨ x = result)\n  (result = -1 → lst.all (count · ≤ n / 2) ∨ majority) ∧\n  (result ≠ -1 → majority)\n\ntheorem findMajorityElement_spec_satisfied (lst: List Int) (h_precond : findMajorityElement_precond (lst)) :\n    findMajorityElement_postcond (lst) (findMajorityElement (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 1, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            1,\n            2,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[2, 2, 2, 2, 3, 3]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            3,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[5, 5, 5, 5, 5, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            0,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[-1, -1, -1, 2, 2]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[-3, -3, -3, -3, 1]\"\n        },\n        \"expected\": -3,\n        \"unexpected\": [\n            1,\n            -1\n        ]\n    }\n]\n-/"}
{"id": "LV0011", "language": "lean", "source": "verina", "source_id": "verina_advanced_12_task", "vc-description": "/- \n-----Description-----\nWrite a Lean 4 function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.\n\n-----Input-----\nlst: A list of integers.\n\n-----Output-----\nAn integer representing the first duplicated value if any exists, otherwise -1.\n-/", "vc-preamble": "@[reducible]\ndef firstDuplicate_precond (lst : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def firstDuplicate (lst : List Int) (h_precond : firstDuplicate_precond (lst)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef firstDuplicate_postcond (lst : List Int) (result: Int) (h_precond : firstDuplicate_precond (lst)) : Prop :=\n  -- if result = -1, then lst does not contain any duplicates\n  (result = -1 → List.Nodup lst) ∧\n  -- if result is not -1, then it is the first duplicate in lst\n  (result ≠ -1 →\n    lst.count result > 1 ∧\n    (lst.filter (fun x => lst.count x > 1)).head? = some result\n  )\n\ntheorem firstDuplicate_spec_satisfied (lst: List Int) (h_precond : firstDuplicate_precond (lst)) :\n    firstDuplicate_postcond (lst) (firstDuplicate (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3, 2, 4]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[5, 1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            1,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[7, 7, 7, 7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0012", "language": "lean", "source": "verina", "source_id": "verina_advanced_13_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.\n\nA chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.\n\nConstraints\n\n- 2\\leq N \\leq 2\\times 10^5\n- 1\\leq A_i,B_i \\leq 2N\n- A_1,\\dots,A_N,B_1,\\dots,B_N are all distinct\n- All input values are integers\n\n-----Input-----\nThe input consists of two parameters:\nN: A natural number representing the number of chords (2 ≤ N ≤ 2×10^5).\nchords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.\n\n-----Output-----\nThe output is a boolean value:\n- Returns true if there exists at least one pair of intersecting chords.\n- Returns false if no chords intersect.\n-/", "vc-preamble": "@[reducible]\ndef hasChordIntersection_precond (N : Nat) (chords : List (List Nat)) : Prop :=\n  N ≥ 2 ∧\n  chords.all (fun chord => chord.length = 2 ∧ chord[0]! ≥ 1 ∧ chord[0]! ≤ 2 * N ∧ chord[1]! ≥ 1 ∧ chord[1]! ≤ 2 * N) ∧\n  List.Nodup (chords.flatMap id)", "vc-helpers": "", "vc-definitions": "def hasChordIntersection (N : Nat) (chords : List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef hasChordIntersection_postcond (N : Nat) (chords : List (List Nat)) (result: Bool) (h_precond : hasChordIntersection_precond (N) (chords)) : Prop :=\n  let sortedChords := chords.map (fun chord =>\n    let a := chord[0]!\n    let b := chord[1]!\n    if a > b then [b, a] else [a, b]\n  )\n\n  let rec hasIntersection (chord1 : List Nat) (chord2 : List Nat) : Bool :=\n    let a1 := chord1[0]!\n    let b1 := chord1[1]!\n    let a2 := chord2[0]!\n    let b2 := chord2[1]!\n    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)\n\n  let rec checkAllPairs (chords : List (List Nat)) : Bool :=\n    match chords with\n    | [] => false\n    | x :: xs =>\n      if xs.any (fun y => hasIntersection x y) then true\n      else checkAllPairs xs\n\n  ((List.Pairwise (fun x y => !hasIntersection x y) sortedChords) → ¬ result) ∧\n  ((sortedChords.any (fun x => chords.any (fun y => hasIntersection x y))) → result)\n\ntheorem hasChordIntersection_spec_satisfied (N: Nat) (chords: List (List Nat)) (h_precond : hasChordIntersection_precond (N) (chords)) :\n    hasChordIntersection_postcond (N) (chords) (hasChordIntersection (N) (chords) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[1, 1]]\"\n        }\n    },\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[7, 1]]\"\n        }\n    },\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[0, 1]]\"\n        }\n    },\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[1, 0]]\"\n        }\n    },\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[1, 7]]\"\n        }\n    },\n    {\n        \"input\": {\n            \"N\": 0,\n            \"chords\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[1, 3], [4, 2], [5, 6]]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 3,\n            \"chords\": \"[[6, 1], [4, 3], [2, 5]]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 4,\n            \"chords\": \"[[2, 4], [3, 7], [8, 6], [5, 1]]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 2,\n            \"chords\": \"[[1, 2], [3, 4]]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0013", "language": "lean", "source": "verina", "source_id": "verina_advanced_14_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists an natural number x such that n = 4^x.\n\n-----Input-----\nThe input consists of one natural number:\nn: A natural number.\n\n-----Output-----\nThe output is a boolean value:\nReturn a boolean value that indicates whether the given natural number is a power of four. Return \"true\" if it is a power of four. Otherwise, return \"false\".\n-/", "vc-preamble": "@[reducible]\ndef ifPowerOfFour_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def ifPowerOfFour (n : Nat) (h_precond : ifPowerOfFour_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef ifPowerOfFour_postcond (n : Nat) (result: Bool) (h_precond : ifPowerOfFour_precond (n)) : Prop :=\n  result ↔ (∃ m:Nat, n=4^m)\n\ntheorem ifPowerOfFour_spec_satisfied (n: Nat) (h_precond : ifPowerOfFour_precond (n)) :\n    ifPowerOfFour_postcond (n) (ifPowerOfFour (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 8\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 16\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 64\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 95\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 100\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 256\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 520\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1024\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0014", "language": "lean", "source": "verina", "source_id": "verina_advanced_15_task", "vc-description": "/- \n-----Description-----\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.\n-/", "vc-preamble": "@[reducible]\ndef increasingTriplet_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def increasingTriplet (nums : List Int) (h_precond : increasingTriplet_precond (nums)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef increasingTriplet_postcond (nums : List Int) (result: Bool) (h_precond : increasingTriplet_precond (nums)) : Prop :=\n  let nums' := nums.zipIdx\n  (result →\n    nums'.any (fun (x, i) =>\n      nums'.any (fun (y, j) =>\n        nums'.any (fun (z, k) =>\n          i < j ∧ j < k ∧ x < y ∧ y < z\n        )\n      )\n    ))\n  ∧\n  (¬ result → nums'.all (fun (x, i) =>\n    nums'.all (fun (y, j) =>\n      nums'.all (fun (z, k) =>\n        i ≥ j ∨ j ≥ k ∨ x ≥ y ∨ y ≥ z\n      )\n    )\n  ))\n\ntheorem increasingTriplet_spec_satisfied (nums: List Int) (h_precond : increasingTriplet_precond (nums)) :\n    increasingTriplet_postcond (nums) (increasingTriplet (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 4, 3, 2, 1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 1, 5, 0, 4, 6]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 5, 0, 4, 1, 3]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 4, 3]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0015", "language": "lean", "source": "verina", "source_id": "verina_advanced_16_task", "vc-description": "/- \n-----Description-----\nImplement the insertion sort algorithm in Lean 4. The function takes a single list of integers\nas input and returns a new list that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting list must be sorted in ascending order.\nThe returned list must be a permutation of the input list (i.e., contain exactly the same elements).\n\n-----Input-----\nA single list of integers, denoted as xs.\n\n-----Output-----\nA list of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n-/", "vc-preamble": "@[reducible]\ndef insertionSort_precond (xs : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def insertionSort (xs : List Int) (h_precond : insertionSort_precond (xs)) : List Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef insertionSort_postcond (xs : List Int) (result: List Int) (h_precond : insertionSort_precond (xs)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm xs result\n\ntheorem insertionSort_spec_satisfied (xs: List Int) (h_precond : insertionSort_precond (xs)) :\n    insertionSort_postcond (xs) (insertionSort (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\",\n            \"[1, 2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[42]\"\n        },\n        \"expected\": \"[42]\",\n        \"unexpected\": [\n            \"[24]\",\n            \"[]\",\n            \"[42, 42]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[3, 1, 4, 2]\"\n        },\n        \"expected\": \"[1, 2, 3, 4]\",\n        \"unexpected\": [\n            \"[1, 3, 2, 4]\",\n            \"[4, 3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[5, -1, 0, 10, -1]\"\n        },\n        \"expected\": \"[-1, -1, 0, 5, 10]\",\n        \"unexpected\": [\n            \"[-1, -1, 0, 10, 5]\",\n            \"[10, 5, 0, -1, -1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[2, 2, 2, 2, 2]\"\n        },\n        \"expected\": \"[2, 2, 2, 2, 2]\",\n        \"unexpected\": [\n            \"[2, 2, 2, 2]\",\n            \"[]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0016", "language": "lean", "source": "verina", "source_id": "verina_advanced_17_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.\n\n-----Input-----\nThe input is:\n\nl: A list of integers to be sorted.\n\n-----Output-----\nThe output is:\n\nA list of integers that is sorted in non-decreasing order and is a permutation of the input list.\n-/", "vc-preamble": "@[reducible]\ndef insertionSort_precond (l : List Int) : Prop :=\n  True", "vc-helpers": "-- Helper function to insert an integer into a sorted list\ndef insertElement (x : Int) (l : List Int) : List Int :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n      if x <= y then\n        x :: y :: ys\n      else\n        y :: insertElement x ys\n\n-- Helper function to sort a list using insertion sort\ndef sortList (l : List Int) : List Int :=\n  match l with\n  | [] => []\n  | x :: xs =>\n      insertElement x (sortList xs)", "vc-definitions": "def insertionSort (l : List Int) (h_precond : insertionSort_precond (l)) : List Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef insertionSort_postcond (l : List Int) (result: List Int) (h_precond : insertionSort_precond (l)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm l result\n\ntheorem insertionSort_spec_satisfied (l: List Int) (h_precond : insertionSort_precond (l)) :\n    insertionSort_postcond (l) (insertionSort (l) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"l\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\",\n            \"[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[5]\"\n        },\n        \"expected\": \"[5]\",\n        \"unexpected\": [\n            \"[]\",\n            \"[5, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[1, 2, 3]\"\n        },\n        \"expected\": \"[1, 2, 3]\",\n        \"unexpected\": [\n            \"[3, 2, 1]\",\n            \"[2, 1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[3, 2, 1]\"\n        },\n        \"expected\": \"[1, 2, 3]\",\n        \"unexpected\": [\n            \"[3, 2, 1]\",\n            \"[2, 1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[4, 2, 2, 3]\"\n        },\n        \"expected\": \"[2, 2, 3, 4]\",\n        \"unexpected\": [\n            \"[4, 3, 2, 2]\",\n            \"[2, 3, 2, 4]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0017", "language": "lean", "source": "verina", "source_id": "verina_advanced_18_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.\n\n-----Input-----\nThe input consists of one natural number:\n- `n: Nat`: The number to check if it satisfies the Armstrong property.\n\n-----Output-----\nThe output is a boolean value:\n- `Bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.\n-/", "vc-preamble": "@[reducible]\ndef isArmstrong_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "def countDigits (n : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else go (n / 10) (acc + 1)\n  go n (if n = 0 then 1 else 0)\n\ndef sumPowers (n : Nat) (k : Nat) : Nat :=\n  let rec go (n acc : Nat) : Nat :=\n    if n = 0 then acc\n    else\n      let digit := n % 10\n      go (n / 10) (acc + digit ^ k)\n  go n 0", "vc-definitions": "def isArmstrong (n : Nat) (h_precond : isArmstrong_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef isArmstrong_postcond (n : Nat) (result: Bool) (h_precond : isArmstrong_precond (n)) : Prop :=\n  let n' := List.foldl (fun acc d => acc + d ^ countDigits n) 0 (List.map (fun c => c.toNat - '0'.toNat) (toString n).toList)\n  (result → (n = n')) ∧\n  (¬ result → (n ≠ n'))\n\ntheorem isArmstrong_spec_satisfied (n: Nat) (h_precond : isArmstrong_precond (n)) :\n    isArmstrong_postcond (n) (isArmstrong (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 153\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9474\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9475\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0018", "language": "lean", "source": "verina", "source_id": "verina_advanced_19_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.\n\n-----Input-----\nThe input consists of:\ns: A string to be checked.\n\n-----Output-----\nThe output is a boolean:\nReturns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.\n-/", "vc-preamble": "@[reducible]\ndef isCleanPalindrome_precond (s : String) : Prop :=\n  True", "vc-helpers": "-- Check if a character is an uppercase alphabet letter\ndef isUpperAlpha (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\n-- Check if a character is a lowercase alphabet letter\ndef isLowerAlpha (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\n-- Determine if a character is alphabetic\ndef isAlpha (c : Char) : Bool :=\n  isUpperAlpha c ∨ isLowerAlpha c\n\n-- Convert a single character to lowercase\ndef toLower (c : Char) : Char :=\n  if isUpperAlpha c then Char.ofNat (c.toNat + 32) else c\n\n-- Normalize a character: keep only lowercase letters\ndef normalizeChar (c : Char) : Option Char :=\n  if isAlpha c then some (toLower c) else none\n\n-- Normalize a string into a list of lowercase alphabetic characters\ndef normalizeString (s : String) : List Char :=\n  s.toList.foldr (fun c acc =>\n    match normalizeChar c with\n    | some c' => c' :: acc\n    | none    => acc\n  ) []\n\n-- Reverse the list\ndef reverseList (xs : List Char) : List Char :=\n  xs.reverse", "vc-definitions": "def isCleanPalindrome (s : String) (h_precond : isCleanPalindrome_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef isCleanPalindrome_postcond (s : String) (result: Bool) (h_precond : isCleanPalindrome_precond (s)) : Prop :=\n  let norm := normalizeString s\n  (result = true → norm = norm.reverse) ∧\n  (result = false → norm ≠ norm.reverse)\n\ntheorem isCleanPalindrome_spec_satisfied (s: String) (h_precond : isCleanPalindrome_precond (s)) :\n    isCleanPalindrome_postcond (s) (isCleanPalindrome (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"A man, a plan, a canal, Panama\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"No lemon, no melon\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"OpenAI\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Was it a car or a cat I saw?\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Hello, World!\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0019", "language": "lean", "source": "verina", "source_id": "verina_advanced_20_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that returns true if the input n is divisible by 8 or has 8 as one of it's digits.\n\n-----Input-----\nThe input consists of one integer:\nn: The main integer.\n\n-----Output-----\nThe output is an boolean:\nReturns true if the input is divisible by 8 or has 8 as one of it's digits.\n-/", "vc-preamble": "@[reducible]\ndef isItEight_precond (n : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isItEight (n : Int) (h_precond : isItEight_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef isItEight_postcond (n : Int) (result: Bool) (h_precond : isItEight_precond (n)) : Prop :=\n  let absN := Int.natAbs n;\n  (n % 8 == 0 ∨ ∃ i, absN / (10^i) % 10 == 8) ↔ result\n\ntheorem isItEight_spec_satisfied (n: Int) (h_precond : isItEight_precond (n)) :\n    isItEight_postcond (n) (isItEight (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 8\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 98\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1224\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 73\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 208\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -123456780\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -9999\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -123453\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0020", "language": "lean", "source": "verina", "source_id": "verina_advanced_21_task", "vc-description": "/- \n-----Description-----\nImplement a Lean 4 function that checks if a given string is a palindrome. A string is considered a palindrome\nif it reads the same forward and backward.\n\n-----Input-----\nThe input consists of a single string:\ns: A string\n\n-----Output-----\nThe output is a boolean:\nReturns true if s is a palindrome, false otherwise.\n-/", "vc-preamble": "@[reducible, simp]\ndef isPalindrome_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : String) (h_precond : isPalindrome_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isPalindrome_postcond (s : String) (result: Bool) (h_precond : isPalindrome_precond (s)) : Prop :=\n  (result → (s.toList == s.toList.reverse)) ∧\n  (¬ result → (s.toList ≠ [] ∧ s.toList != s.toList.reverse))\n\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"racecar\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abba\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"a\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0021", "language": "lean", "source": "verina", "source_id": "verina_advanced_22_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a list of integers follows a peak-valley pattern.\n\nA list follows this pattern if:\nA. It strictly increases at first,\nB. Then strictly decreases,\nC. Both parts are non-empty.\n\nExamples:\n- [1, 3, 5, 4, 2] -> true\n- [1, 2, 3] -> false\n- [5, 4, 3] -> false\n- [1, 2, 2, 1] -> false\n\n-----Input-----\nThe input consists of a list of integers:\n\n-----Output-----\nThe output is an integer:\nReturns true if the list has a peak-valley structure, false otherwise.\n-/", "vc-preamble": "@[reducible, simp]\ndef isPeakValley_precond (lst : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isPeakValley (lst : List Int) (h_precond : isPeakValley_precond (lst)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isPeakValley_postcond (lst : List Int) (result: Bool) (h_precond : isPeakValley_precond (lst)) : Prop :=\n  let len := lst.length\n  let validPeaks :=\n    List.range len |>.filter (fun p =>\n      1 ≤ p ∧ p < len - 1 ∧\n\n      -- check strictly increasing before peak\n      (List.range p).all (fun i =>\n        lst[i]! < lst[i + 1]!\n      ) ∧\n\n      -- check strictly decreasing after peak\n      (List.range (len - 1 - p)).all (fun i =>\n        lst[p + i]! > lst[p + i + 1]!\n      )\n    )\n  (validPeaks != [] → result) ∧\n  (validPeaks.length = 0 → ¬ result)\n\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 3, 5, 2, 1]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 1, 1, 1, 1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 10, 100, 1]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0022", "language": "lean", "source": "verina", "source_id": "verina_advanced_23_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given integer is a power of two.\nAn integer n is a power of two if there exists an integer x such that n = 2^x.\nThe method should return true if n is a power of two, and false otherwise.\nNote that negative numbers and zero are not powers of two.\n\n-----Input-----\nThe input consists of one integer:\nn: The integer to be tested.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists an integer x such that n = 2^x (with n > 0), otherwise false.\n-/", "vc-preamble": "@[reducible]\ndef isPowerOfTwo_precond (n : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isPowerOfTwo (n : Int) (h_precond : isPowerOfTwo_precond (n)) : Bool :=\n  sorry", "vc-theorems": "def pow (base : Int) (exp : Nat) : Int :=\n  match exp with\n  | 0 => 1\n  | n+1 => base * pow base n\n@[reducible]\ndef isPowerOfTwo_postcond (n : Int) (result: Bool) (h_precond : isPowerOfTwo_precond (n)) : Prop :=\n  if result then ∃ (x : Nat), (pow 2 x = n) ∧ (n > 0)\n  else ¬ (∃ (x : Nat), (pow 2 x = n) ∧ (n > 0))\n\ntheorem isPowerOfTwo_spec_satisfied (n: Int) (h_precond : isPowerOfTwo_precond (n)) :\n    isPowerOfTwo_postcond (n) (isPowerOfTwo (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 16\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -2\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 8\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0023", "language": "lean", "source": "verina", "source_id": "verina_advanced_24_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines the length of the longest strictly increasing subsequence in a given array of integers.\n\nA subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. The subsequence must be strictly increasing, meaning each element must be greater than the one before it.\n\nThe goal is to find the length of the longest such subsequence that can be formed from the input array.\n\n-----Input-----\nThe input consists of one array:\n\nnums: An array of integers where nums[i] represents the ith element of the input sequence.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array.\n-/", "vc-preamble": "@[reducible, simp]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef lengthOfLIS_postcond (nums : List Int) (result: Int) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  -- Helper function to check strictly increasing\n  let rec isStrictlyIncreasing (l : List Int) : Bool :=\n    match l with\n    | [] | [_] => true\n    | x :: y :: rest => x < y && isStrictlyIncreasing (y :: rest)\n\n  -- Generate all subsequences\n  let rec subsequences (xs : List Int) : List (List Int) :=\n    match xs with\n    | [] => [[]]\n    | x :: xs' =>\n      let rest := subsequences xs'\n      rest ++ rest.map (fun r => x :: r)\n\n  let allIncreasing := subsequences nums |>.filter (fun l => isStrictlyIncreasing l)\n\n  allIncreasing.any (fun l => l.length = result) ∧\n  allIncreasing.all (fun l => l.length ≤ result)\n\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            1,\n            2,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 0, 3, 2, 3]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            1,\n            3,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7, 7, 7, 7, 7, 7, 7]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            6,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[4, 10, 4, 3, 8, 9]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            2,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 6, 7, 9, 4, 10, 5, 6]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            1,\n            4,\n            9\n        ]\n    }\n]\n-/"}
{"id": "LV0024", "language": "lean", "source": "verina", "source_id": "verina_advanced_25_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing a Lean 4 method that finds the length of the longest strictly increasing subsequence in an array of integers. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.\n\n-----Input-----\nThe input consists of one parameter:\nnums: A list of integers representing the input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest strictly increasing subsequence in the input array.\n-/", "vc-preamble": "import Mathlib.Data.List.Basic\n\n@[reducible]\ndef lengthOfLIS_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "def maxInArray (arr : Array Nat) : Nat :=\n  arr.foldl (fun a b => if a ≥ b then a else b) 0", "vc-definitions": "def lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef lengthOfLIS_postcond (nums : List Int) (result: Nat) (h_precond : lengthOfLIS_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :\n    lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 0, 3, 2, 3]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7, 7, 7, 7, 7, 7, 7]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[4, 10, 4, 3, 8, 9]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 6, 7, 9, 4, 10, 5, 6]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10, 22, 9, 33, 21, 50, 41, 60, 80]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            16\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-2, -1]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0025", "language": "lean", "source": "verina", "source_id": "verina_advanced_26_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that generates all possible letter combinations from a string of digits based on the traditional telephone keypad letter mappings.\n\n-----Input-----\nThe input consists of a string (String). The string may be empty.\n\n-----Output-----\nThe output is a list of strings (List String) where each string represents a unique combination of letters corresponding to the input digits. If the input string is empty, the output is an empty list.\n\n-----Note-----\n\nHere is the mapping from the number to possible letters:\n2: a or b or c\n3: d or e or f\n4: g or h or i\n5: j or k or l\n6: m or n or o\n7: p or q or r or s\n8: t or u or v\n9: w or x or y or z\nother number or not a number: no letters\n-/", "vc-preamble": "@[reducible]\ndef letterCombinations_precond (digits : String) : Prop :=\n  True", "vc-helpers": "def digitToLetters (c : Char) : List Char :=\n  match c with\n  | '2' => ['a', 'b', 'c']\n  | '3' => ['d', 'e', 'f']\n  | '4' => ['g', 'h', 'i']\n  | '5' => ['j', 'k', 'l']\n  | '6' => ['m', 'n', 'o']\n  | '7' => ['p', 'q', 'r', 's']\n  | '8' => ['t', 'u', 'v']\n  | '9' => ['w', 'x', 'y', 'z']\n  | _ => []", "vc-definitions": "def letterCombinations (digits : String) (h_precond : letterCombinations_precond (digits)) : List String :=\n  sorry", "vc-theorems": "@[reducible]\ndef letterCombinations_postcond (digits : String) (result: List String) (h_precond : letterCombinations_precond (digits)) : Prop :=\n  if digits.isEmpty then\n    result = []\n  else if digits.toList.any (λ c => ¬(c ∈ ['2','3','4','5','6','7','8','9'])) then\n    result = []\n  else\n    let expected := digits.toList.map digitToLetters |>.foldl (λ acc ls => acc.flatMap (λ s => ls.map (λ c => s ++ String.singleton c)) ) [\"\"]\n    result.length = expected.length ∧ result.all (λ s => s ∈ expected) ∧ expected.all (λ s => s ∈ result)\n\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"digits\": \"\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[\\\"a\\\"]\",\n            \"[\\\"b\\\"]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"2\"\n        },\n        \"expected\": \"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n        \"unexpected\": [\n            \"[\\\"a\\\"]\",\n            \"[\\\"b\\\"]\",\n            \"[\\\"c\\\"]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"9\"\n        },\n        \"expected\": \"[\\\"w\\\", \\\"x\\\", \\\"y\\\", \\\"z\\\"]\",\n        \"unexpected\": [\n            \"[\\\"w\\\"]\",\n            \"[\\\"x\\\"]\",\n            \"[\\\"y\\\"]\",\n            \"[\\\"z\\\"]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"23\"\n        },\n        \"expected\": \"[\\\"ad\\\", \\\"ae\\\", \\\"af\\\", \\\"bd\\\", \\\"be\\\", \\\"bf\\\", \\\"cd\\\", \\\"ce\\\", \\\"cf\\\"]\",\n        \"unexpected\": [\n            \"[\\\"a\\\"]\",\n            \"[\\\"b\\\"]\",\n            \"[\\\"c\\\"]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"27\"\n        },\n        \"expected\": \"[\\\"ap\\\", \\\"aq\\\", \\\"ar\\\", \\\"as\\\", \\\"bp\\\", \\\"bq\\\", \\\"br\\\", \\\"bs\\\", \\\"cp\\\", \\\"cq\\\", \\\"cr\\\", \\\"cs\\\"]\",\n        \"unexpected\": [\n            \"[\\\"p\\\"]\",\n            \"[\\\"q\\\"]\",\n            \"[\\\"r\\\"]\",\n            \"[\\\"s\\\"]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"digits\": \"0\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[\\\"a\\\"]\",\n            \"[\\\"b\\\"]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0026", "language": "lean", "source": "verina", "source_id": "verina_advanced_27_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that computes the longest common subsequence (LCS) of two input strings.\nA subsequence of a string is a sequence that can be derived from the original string by deleting zero or more characters (not necessarily contiguous) without changing the order of the remaining characters.\nThe function should return a string that is:\n1) A subsequence of both input strings.\n2) As long as possible among all such common subsequences.\n\nIf multiple LCS answers exist (with the same maximum length), returning any one of them is acceptable.\n\n-----Input-----\ns1: The first input string.\ns2: The second input string.\n\n-----Output-----\nA string representing a longest common subsequence of s1 and s2.\n-/", "vc-preamble": "@[reducible]\ndef longestCommonSubsequence_precond (s1 : String) (s2 : String) : Prop :=\n  True", "vc-helpers": "partial def toCharList (s : String) : List Char :=\n  s.data\n\npartial def fromCharList (cs : List Char) : String :=\n  cs.foldl (fun acc c => acc.push c) \"\"\n\npartial def lcsAux (xs : List Char) (ys : List Char) : List Char :=\n  match xs, ys with\n  | [], _ => []\n  | _, [] => []\n  | x :: xs', y :: ys' =>\n    if x == y then\n      x :: lcsAux xs' ys'\n    else\n      let left  := lcsAux xs' (y :: ys')\n      let right := lcsAux (x :: xs') ys'\n      if left.length >= right.length then left else right", "vc-definitions": "def longestCommonSubsequence (s1 : String) (s2 : String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : String :=\n  sorry", "vc-theorems": "@[reducible]\ndef longestCommonSubsequence_postcond (s1 : String) (s2 : String) (result: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : Prop :=\n  let allSubseq (arr : List Char) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq s1.toList\n  let subseqB := allSubseq s2.toList\n  let commonSubseq := subseqA.filter (fun l => subseqB.contains l)\n  commonSubseq.contains result.toList ∧ commonSubseq.all (fun l => l.length ≤ result.length)\n\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s1\": \"abcde\",\n            \"s2\": \"ace\"\n        },\n        \"expected\": \"ace\",\n        \"unexpected\": [\n            \"ab\",\n            \"abc\",\n            \"bce\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s1\": \"aaaa\",\n            \"s2\": \"bbaaa\"\n        },\n        \"expected\": \"aaa\",\n        \"unexpected\": [\n            \"aaaaa\",\n            \"b\",\n            \"aaab\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s1\": \"xyz\",\n            \"s2\": \"abc\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \"x\",\n            \"y\",\n            \"a\",\n            \"abc\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s1\": \"axbxc\",\n            \"s2\": \"abxc\"\n        },\n        \"expected\": \"abxc\",\n        \"unexpected\": [\n            \"axc\",\n            \"abcx\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s1\": \"AGGTAB\",\n            \"s2\": \"GXTXAYB\"\n        },\n        \"expected\": \"GTAB\",\n        \"unexpected\": [\n            \"GGTAB\",\n            \"AGGTA\"\n        ]\n    }\n]\n-/"}
{"id": "LV0027", "language": "lean", "source": "verina", "source_id": "verina_advanced_28_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest sequence of consecutive integers present in a given list. The numbers do not need to appear in order. The elements are unique.\n\nA consecutive sequence consists of integers that can be arranged in increasing order with no gaps. Your function should find the longest such streak.\n\n-----Input-----\n- nums: A list of integers (no duplicates).\n\n-----Output-----\n- A natural number: the length of the longest consecutive sequence.\n-/", "vc-preamble": "import Std.Data.HashSet\nimport Mathlib\nopen Std\n\n@[reducible, simp]\ndef longestConsecutive_precond (nums : List Int) : Prop :=\n  List.Nodup nums", "vc-helpers": "", "vc-definitions": "def longestConsecutive (nums : List Int) (h_precond : longestConsecutive_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "def isConsecutive (seq : List Int) : Bool :=\n  seq.length = 0 ∨ seq.zipIdx.all (fun (x, i) => x = i + seq[0]!)\n@[reducible, simp]\ndef longestConsecutive_postcond (nums : List Int) (result: Nat) (h_precond : longestConsecutive_precond (nums)) : Prop :=\n  let sorted_nums := nums.mergeSort\n  let consec_sublist_lens := List.range nums.length |>.flatMap (fun start =>\n    List.range (nums.length - start + 1) |>.map (fun len => sorted_nums.extract start (start + len))) |>.filter isConsecutive |>.map (·.length)\n\n  (nums = [] → result = 0) ∧\n  (nums ≠ [] → consec_sublist_lens.contains result ∧ consec_sublist_lens.all (· ≤ result))\n\ntheorem longestConsecutive_spec_satisfied (nums: List Int) (h_precond : longestConsecutive_precond (nums)) :\n    longestConsecutive_postcond (nums) (longestConsecutive (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[100, 4, 200, 1, 3, 2]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 3, 7, 2, 5, 8, 4, 6, 1]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 0]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0028", "language": "lean", "source": "verina", "source_id": "verina_advanced_29_task", "vc-description": "/- \n-----Description-----\nYou are given a natural number array nums and a natural number k.\nThe frequency of an element x is the number of times it occurs in an array.\nAn array is called good if the frequency of each element in this array is less than or equal to k.\nReturn the length of the longest good subarray of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n-----Input-----\nThe input consists of an array of natural numbers nums and a natural number k:\nnums: an array of natural numbers.\nk: a natural number\n\n-----Output-----\nThe output is a natural number:\nReturn the length of the longest good subarray of nums.\n-/", "vc-preamble": "import Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef longestGoodSubarray_precond (nums : List Nat) (k : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def longestGoodSubarray (nums : List Nat) (k : Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef longestGoodSubarray_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Prop :=\n  let subArrays :=\n    List.range (nums.length + 1) |>.flatMap (fun start =>\n      List.range (nums.length - start + 1) |>.map (fun len =>\n        nums.drop start |>.take len))\n  let subArrayFreqs := subArrays.map (fun arr => arr.map (fun x => arr.count x))\n  let validSubArrays := subArrayFreqs.filter (fun arr => arr.all (fun x => x ≤ k))\n\n  (nums = [] ∧ result = 0) ∨\n  (nums ≠ [] ∧\n    validSubArrays.any (fun arr => arr.length = result) ∧\n    validSubArrays.all (fun arr => arr.length ≤ result))\n\ntheorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :\n    longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 1, 2, 3, 1, 2]\",\n            \"k\": 2\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 1, 2, 1, 2, 1, 2]\",\n            \"k\": 1\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 5, 5, 5, 5, 5, 5]\",\n            \"k\": 4\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1]\",\n            \"k\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 2, 1, 1, 3]\",\n            \"k\": 2\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            2,\n            3,\n            4,\n            6\n        ]\n    }\n]\n-/"}
{"id": "LV0029", "language": "lean", "source": "verina", "source_id": "verina_advanced_30_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.\n\nThe function should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing contiguous subarray. If the list is empty, the function should return 0.\n-/", "vc-preamble": "@[reducible]\ndef longestIncreasingStreak_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def longestIncreasingStreak (nums : List Int) (h_precond : longestIncreasingStreak_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef longestIncreasingStreak_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingStreak_precond (nums)) : Prop :=\n  -- Case 1: Empty list means result = 0\n  (nums = [] → result = 0) ∧\n\n  -- Case 2: If result > 0, there exists a streak of exactly that length\n  (result > 0 →\n    (List.range (nums.length - result + 1) |>.any (fun start =>\n      -- Check bounds are valid\n      start + result ≤ nums.length ∧\n      -- Check all consecutive pairs in this streak are increasing\n      (List.range (result - 1) |>.all (fun i =>\n        nums[start + i]! < nums[start + i + 1]!)) ∧\n      -- Check this streak can't be extended left (if possible)\n      (start = 0 ∨ nums[start - 1]! ≥ nums[start]!) ∧\n      -- Check this streak can't be extended right (if possible)\n      (start + result = nums.length ∨ nums[start + result - 1]! ≥ nums[start + result]!)))) ∧\n\n  -- Case 3: No streak longer than result exists\n  (List.range (nums.length - result) |>.all (fun start =>\n    List.range result |>.any (fun i =>\n      start + i + 1 ≥ nums.length ∨ nums[start + i]! ≥ nums[start + i + 1]!)))\n\ntheorem longestIncreasingStreak_spec_satisfied (nums: List Int) (h_precond : longestIncreasingStreak_precond (nums)) :\n    longestIncreasingStreak_postcond (nums) (longestIncreasingStreak (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 2, 4, 5, 6]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10, 20, 30, 40]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 5, 5, 5]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10, 9, 8, 7]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 1, 2, 3, 0, 1, 2, 3, 4]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0030", "language": "lean", "source": "verina", "source_id": "verina_advanced_31_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n-/", "vc-preamble": "import Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubseqLength_precond (xs : List Int) : Prop :=\n  True", "vc-helpers": "-- Generate all subsequences\ndef subsequences {α : Type} : List α → List (List α)\n  | [] => [[]]\n  | x :: xs =>\n    let subs := subsequences xs\n    subs ++ subs.map (fun s => x :: s)\n\n-- Check if a list is strictly increasing\ndef isStrictlyIncreasing : List Int → Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => if x < y then isStrictlyIncreasing (y :: rest) else false", "vc-definitions": "def longestIncreasingSubseqLength (xs : List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef longestIncreasingSubseqLength_postcond (xs : List Int) (result: Nat) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Prop :=\n  let allSubseq := (xs.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            2,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[4, 3, 2, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 3, 2, 4, 0, 5]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[5, 1, 6, 2, 7]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0031", "language": "lean", "source": "verina", "source_id": "verina_advanced_32_task", "vc-description": "/- \n-----Description-----\nThis test implements a function in Lean 4 that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.\n\n-----Input-----\nnumbers: A list of integers.\n\n-----Output-----\nA natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (numbers : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def longestIncreasingSubsequence (numbers : List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (numbers : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (numbers)) : Prop :=\n  let allSubseq := (numbers.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem longestIncreasingSubsequence_spec_satisfied (numbers: List Int) (h_precond : longestIncreasingSubsequence_precond (numbers)) :\n    longestIncreasingSubsequence_postcond (numbers) (longestIncreasingSubsequence (numbers) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"numbers\": \"[10, 22, 9, 33, 21, 50, 41, 60]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[3, 10, 2, 1, 20]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[50, 3, 10, 7, 40, 80]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            1,\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[5]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[5, 5, 5, 5]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0032", "language": "lean", "source": "verina", "source_id": "verina_advanced_33_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing the \"Longest Increasing Subsequence\" problem in Lean 4.\nGiven a list of integers, the function should compute the length of the longest strictly increasing\nsubsequence. A subsequence is formed by deleting zero or more elements without changing the order.\nIf the list is empty, the function should return 0.\n\n-----Input-----\n- nums: A list of integers.\n\n-----Output-----\n- A natural number representing the length of the longest strictly increasing subsequence.\n- If there is no increasing subsequence, return 0.\n-/", "vc-preamble": "import Mathlib.Data.List.Basic\n\n@[reducible, simp]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Nat) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 0, 3, 2, 3]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7, 7, 7, 7, 7]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[4, 10, 4, 3, 8, 9]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0033", "language": "lean", "source": "verina", "source_id": "verina_advanced_34_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the length of the longest strictly increasing subsequence from a given list of integers.\n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.\n-/", "vc-preamble": "import Mathlib.Data.List.Basic\n\n@[reducible]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (· < ·) l) |>.map (·.length)\n  increasingSubseqLens.contains result ∧ increasingSubseqLens.all (· ≤ result)\n\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            100\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 0, 3, 2, 3]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            100\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7, 7, 7, 7, 7, 7, 7]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            7,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 2, 4]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0034", "language": "lean", "source": "verina", "source_id": "verina_advanced_35_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the majority element in a list of integers. The majority element is the element that appears more than ⌊n/2⌋ times, where n is the list’s length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers of length ≥ 1, containing a majority element.\n\n-----Output-----\n- An integer: the element that appears more than ⌊n/2⌋ times.\n-/", "vc-preamble": "import Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  nums.length > 0 ∧ nums.any (fun x => nums.count x > nums.length / 2)", "vc-helpers": "", "vc-definitions": "def majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (nums.count result) > n / 2\n  ∧ ∀ x, x ≠ result → nums.count x ≤ n / 2\n\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3]\"\n        }\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 2, 1, 1, 1, 2, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 1, 1, 2, 3, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 0, 0, 0]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": []\n    }\n]\n-/"}
{"id": "LV0035", "language": "lean", "source": "verina", "source_id": "verina_advanced_36_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than ⌊n / 2⌋ times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\n-----Input-----\nThe input consists of one list:\nxs: A list of natural numbers (List Nat), where a majority element is guaranteed to exist.\n\n-----Output-----\nThe output is a natural number:\nReturns the element that appears more than half the time in the input list.\n-/", "vc-preamble": "@[reducible]\ndef majorityElement_precond (xs : List Nat) : Prop :=\n  xs.length > 0 ∧ xs.any (fun x => xs.count x > xs.length / 2)", "vc-helpers": "", "vc-definitions": "def majorityElement (xs : List Nat) (h_precond : majorityElement_precond (xs)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef majorityElement_postcond (xs : List Nat) (result: Nat) (h_precond : majorityElement_precond (xs)) : Prop :=\n  let count := xs.count result\n  count > xs.length / 2\n\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 3]\"\n        }\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[3, 3, 4, 2, 3, 3, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 1, 2, 1, 3, 1, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[2, 2, 2, 1, 1]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[9, 9, 9, 9, 1, 2, 3]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[5, 5, 5, 5, 5, 6, 7]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            6,\n            7\n        ]\n    }\n]\n-/"}
{"id": "LV0036", "language": "lean", "source": "verina", "source_id": "verina_advanced_37_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that returns the majority element from a list of integers.\n\nThe majority element is the one that appears more than ⌊n / 2⌋ times in the list, where n is the list's length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A list of integers (with at least one majority element).\n\n-----Output-----\nReturns the majority element — the value that appears more than ⌊n / 2⌋ times.\n-/", "vc-preamble": "@[reducible, simp]\ndef majorityElement_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def majorityElement (nums : List Int) (h_precond : majorityElement_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef majorityElement_postcond (nums : List Int) (result: Int) (h_precond : majorityElement_precond (nums)) : Prop :=\n  let n := nums.length\n  (List.count result nums > n / 2) ∧\n  nums.all (fun x => x = result ∨ List.count x nums ≤ n / 2)\n\ntheorem majorityElement_spec_satisfied (nums: List Int) (h_precond : majorityElement_precond (nums)) :\n    majorityElement_postcond (nums) (majorityElement (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 2, 1, 1, 1, 2, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[4, 4, 4, 4, 4, 2, 2, 3, 3]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[9, 8, 9, 9, 7, 9, 6, 9, 9]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            6,\n            7,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 0, 0, 0, 1]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[100000, 100000, 100000, 100000, -100000]\"\n        },\n        \"expected\": 100000,\n        \"unexpected\": [\n            -100000\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-1, -1, -1, -1, 0, 1, 2]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 5, 5, 5, 5, 5, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 3, 3, 3, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0037", "language": "lean", "source": "verina", "source_id": "verina_advanced_38_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing a Lean 4 method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals\nYou may assume you'll receive at least one interval\n\n-----Input-----\nThe input consists of a list of ordered pairs of intervals.\n-----Output-----\nThe output is an integer:\nReturn the largest span that is possible after removing one of the intervals.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxCoverageAfterRemovingOne_precond (intervals : List (Prod Nat Nat)) : Prop :=\n  intervals.length > 0", "vc-helpers": "", "vc-definitions": "def maxCoverageAfterRemovingOne (intervals : List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxCoverageAfterRemovingOne_postcond (intervals : List (Prod Nat Nat)) (result: Nat) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) : Prop :=\n  ∃ i < intervals.length,\n    let remaining := List.eraseIdx intervals i\n    let sorted := List.mergeSort remaining (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n    let merged := sorted.foldl (fun acc curr =>\n      match acc with\n      | [] => [curr]\n      | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n    ) []\n    let cov := merged.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n    result = cov ∧\n    ∀ j < intervals.length,\n      let rem_j := List.eraseIdx intervals j\n      let sort_j := List.mergeSort rem_j (fun (a b : Nat × Nat) => a.1 ≤ b.1)\n      let merged_j := sort_j.foldl (fun acc curr =>\n        match acc with\n        | [] => [curr]\n        | (s, e) :: rest => if curr.1 ≤ e then (s, max e curr.2) :: rest else curr :: acc\n      ) []\n      let cov_j := merged_j.reverse.foldl (fun acc (s, e) => acc + (e - s)) 0\n      cov ≥ cov_j\n\ntheorem maxCoverageAfterRemovingOne_spec_satisfied (intervals: List (Prod Nat Nat)) (h_precond : maxCoverageAfterRemovingOne_precond (intervals)) :\n    maxCoverageAfterRemovingOne_postcond (intervals) (maxCoverageAfterRemovingOne (intervals) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"intervals\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 3), (2, 5), (6, 8)]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 4), (2, 6), (8, 10), (9, 12)]\"\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            7,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 2), (2, 3), (3, 4)]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 10), (2, 3), (4, 5)]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            7,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(5, 6), (1, 2), (3, 4)]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            5,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0038", "language": "lean", "source": "verina", "source_id": "verina_advanced_39_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst.length > 0", "vc-helpers": "", "vc-definitions": "def maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"lst\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            1,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[5, 5, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[10, 1, 9]\"\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            1,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            0,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[0, 0, 0, 0]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0039", "language": "lean", "source": "verina", "source_id": "verina_advanced_40_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n-/", "vc-preamble": "@[reducible]\ndef maxOfList_precond (lst : List Nat) : Prop :=\n  lst ≠ []  -- Ensure the list is non-empty", "vc-helpers": "", "vc-definitions": "def maxOfList (lst : List Nat) (h_precond : maxOfList_precond (lst)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef maxOfList_postcond (lst : List Nat) (result: Nat) (h_precond : maxOfList_precond (lst)) : Prop :=\n  result ∈ lst ∧ ∀ x ∈ lst, x ≤ result\n\ntheorem maxOfList_spec_satisfied (lst: List Nat) (h_precond : maxOfList_precond (lst)) :\n    maxOfList_postcond (lst) (maxOfList (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"lst\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            1,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[5, 5, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[10, 1, 9]\"\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            1,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            0,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[0, 0, 0, 0]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0040", "language": "lean", "source": "verina", "source_id": "verina_advanced_41_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.\n-/", "vc-preamble": "@[reducible]\ndef maxOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def maxOfThree (a : Int) (b : Int) (c : Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef maxOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : maxOfThree_precond (a) (b) (c)) : Prop :=\n  (result >= a ∧ result >= b ∧ result >= c) ∧ (result = a ∨ result = b ∨ result = c)\n\ntheorem maxOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : maxOfThree_precond (a) (b) (c)) :\n    maxOfThree_postcond (a) (b) (c) (maxOfThree (a) (b) (c) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 2,\n            \"c\": 1\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            1,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 5,\n            \"b\": 5,\n            \"c\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            6,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 10,\n            \"b\": 20,\n            \"c\": 15\n        },\n        \"expected\": 20,\n        \"unexpected\": [\n            10,\n            15\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -1,\n            \"b\": -2,\n            \"c\": -3\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            -2,\n            -3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": -10,\n            \"c\": -5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -5,\n            -10\n        ]\n    }\n]\n-/"}
{"id": "LV0041", "language": "lean", "source": "verina", "source_id": "verina_advanced_42_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the function should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A list of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxProfit_precond (prices : List Nat) : Prop :=\n  True", "vc-helpers": "def updateMinAndProfit (price : Nat) (minSoFar : Nat) (maxProfit : Nat) : (Nat × Nat) :=\n  let newMin := Nat.min minSoFar price\n  let profit := if price > minSoFar then price - minSoFar else 0\n  let newMaxProfit := Nat.max maxProfit profit\n  (newMin, newMaxProfit)\n\ndef maxProfitAux (prices : List Nat) (minSoFar : Nat) (maxProfit : Nat) : Nat :=\n  match prices with\n  | [] => maxProfit\n  | p :: ps =>\n    let (newMin, newProfit) := updateMinAndProfit p minSoFar maxProfit\n    maxProfitAux ps newMin newProfit", "vc-definitions": "def maxProfit (prices : List Nat) (h_precond : maxProfit_precond (prices)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxProfit_postcond (prices : List Nat) (result: Nat) (h_precond : maxProfit_precond (prices)) : Prop :=\n  (result = 0 ∧ prices = []) ∨\n  (\n    -- All valid transactions have profit ≤ result (using pairwise)\n    List.Pairwise (fun ⟨pi, i⟩ ⟨pj, j⟩ => i < j → pj - pi ≤ result) prices.zipIdx ∧\n\n    -- There exists a transaction with profit = result (using any)\n    prices.zipIdx.any (fun ⟨pi, i⟩ =>\n      prices.zipIdx.any (fun ⟨pj, j⟩ =>\n        i < j ∧ pj - pi = result))\n  )\n\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"prices\": \"[7, 1, 5, 3, 6, 4]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"prices\": \"[7, 6, 4, 3, 1]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"prices\": \"[2, 4, 1]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"prices\": \"[1, 2]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"prices\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0042", "language": "lean", "source": "verina", "source_id": "verina_advanced_43_task", "vc-description": "/- \n------Description-----\nThis task requires writing a Lean 4 method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized.\n\nThe strength of a group is defined as the product of the selected student scores.\n\nYou can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset.\n\n----Input---\nnums: An non-empty list of integers.\n\n-----Output-----\n\nAn integer representing the maximum strength.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible]\ndef maxStrength_precond (nums : List Int) : Prop :=\n  nums ≠ []", "vc-helpers": "", "vc-definitions": "def maxStrength (nums : List Int) (h_precond : maxStrength_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef maxStrength_postcond (nums : List Int) (result: Int) (h_precond : maxStrength_precond (nums)) : Prop :=\n  let sublists := nums.sublists.filter (· ≠ [])\n  let products := sublists.map (List.foldl (· * ·) 1)\n  products.contains result ∧ products.all (· ≤ result)\n\ntheorem maxStrength_spec_satisfied (nums: List Int) (h_precond : maxStrength_precond (nums)) :\n    maxStrength_postcond (nums) (maxStrength (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[-2]\"\n        },\n        \"expected\": -2,\n        \"unexpected\": [\n            2,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, -1, -5, 2, 5, -9]\"\n        },\n        \"expected\": 1350,\n        \"unexpected\": [\n            270,\n            0,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-4, -5, -4]\"\n        },\n        \"expected\": 20,\n        \"unexpected\": [\n            80,\n            -80,\n            -5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, -3, 4]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            0,\n            -12\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, -1, -1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            -1,\n            -2\n        ]\n    }\n]\n-/"}
{"id": "LV0043", "language": "lean", "source": "verina", "source_id": "verina_advanced_44_task", "vc-description": "/- \n-----Description-----\nGiven an integer array arr and a positive integer k, this task requires writing a Lean 4 method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k,\nthe default return value should be 0.\n\n-----Input-----\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n-/", "vc-preamble": "@[reducible]\ndef maxSubarraySumDivisibleByK_precond (arr : Array Int) (k : Int) : Prop :=\n  k > 0", "vc-helpers": "", "vc-definitions": "def maxSubarraySumDivisibleByK (arr : Array Int) (k : Int) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef maxSubarraySumDivisibleByK_postcond (arr : Array Int) (k : Int) (result: Int) : Prop :=\n  let subarrays := List.range (arr.size) |>.flatMap (fun start =>\n    List.range (arr.size - start + 1) |>.map (fun len => arr.extract start (start + len)))\n  let divisibleSubarrays := subarrays.filter (fun subarray => subarray.size % k = 0 && subarray.size > 0)\n  let subarraySums := divisibleSubarrays.map (fun subarray => subarray.sum)\n  (result = 0 → subarraySums.length = 0) ∧\n  (result ≠ 0 → result ∈ subarraySums ∧ subarraySums.all (fun sum => sum ≤ result))\n\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5]\",\n            \"k\": 2\n        },\n        \"expected\": 14,\n        \"unexpected\": [\n            9,\n            5,\n            15,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, -2, 3, -4, 5]\",\n            \"k\": 3\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            5,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[]\",\n            \"k\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4]\",\n            \"k\": 1\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            3,\n            4,\n            7,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-2, 7, 1, 3]\",\n            \"k\": 2\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            8,\n            11,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-100, 0, 1]\",\n            \"k\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -99\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1999, 1, -1023, 12351, -9999]\",\n            \"k\": 2\n        },\n        \"expected\": 13328,\n        \"unexpected\": [\n            1999,\n            12351,\n            3329,\n            2352\n        ]\n    }\n]\n-/"}
{"id": "LV0044", "language": "lean", "source": "verina", "source_id": "verina_advanced_45_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the maximum subarray sum from a given list of integers.\nA subarray is a contiguous sequence of elements within the list.\nThe function should return the maximum sum that can be obtained from any subarray.\n\n-----Input-----\nThe input is a list of integers:\nxs: A list of integers (can include negative numbers).\n\n-----Output-----\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs.\nIf the list is empty, the result should be 0.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxSubarraySum_precond (xs : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def maxSubarraySum (xs : List Int) (h_precond : maxSubarraySum_precond (xs)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxSubarraySum_postcond (xs : List Int) (result: Int) (h_precond : maxSubarraySum_precond (xs)) : Prop :=\n  -- Find all possible subarrays and their sums\n  let subarray_sums := List.range (xs.length + 1) |>.flatMap (fun start =>\n    List.range' 1 (xs.length - start) |>.map (fun len =>\n      ((xs.drop start).take len).sum\n    ))\n\n  -- Check if there exists a subarray with sum equal to result\n  let has_result_subarray := subarray_sums.any (fun sum => sum == result)\n\n  -- Check if result is the maximum among all subarray sums\n  let is_maximum := subarray_sums.all (· ≤ result)\n\n  match xs with\n  | [] => result == 0\n  | _ => has_result_subarray ∧ is_maximum\n\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, -2, 3, 4, -1]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            6,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[-2, -3, -1, -5]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            -2,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[5, -1, 2, -1, 3]\"\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[4, -1, -2, 1, 5]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            8\n        ]\n    }\n]\n-/"}
{"id": "LV0045", "language": "lean", "source": "verina", "source_id": "verina_advanced_46_task", "vc-description": "/- \n-----Description-----\nThis test implements a function in Lean 4 that finds the maximum sum of any contiguous subarray within a list of integers. A subarray is a continuous section of the original array. If all integers in the list are negative, the function should return 0 (representing the empty subarray).\n\n-----Input-----\nnumbers: A list of integers that may contain positive, negative, or zero values.\n\n-----Output-----\nAn integer representing the maximum sum of any contiguous subarray. If the list is empty or contains only negative numbers, the function returns 0.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxSubarraySum_precond (numbers : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def maxSubarraySum (numbers : List Int) (h_precond : maxSubarraySum_precond (numbers)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxSubarraySum_postcond (numbers : List Int) (result: Int) (h_precond : maxSubarraySum_precond (numbers)) : Prop :=\n  let subArraySums :=\n    List.range (numbers.length + 1) |>.flatMap (fun start =>\n      List.range (numbers.length - start + 1) |>.map (fun len =>\n        numbers.drop start |>.take len |>.sum))\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\ntheorem maxSubarraySum_spec_satisfied (numbers: List Int) (h_precond : maxSubarraySum_precond (numbers)) :\n    maxSubarraySum_postcond (numbers) (maxSubarraySum (numbers) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"numbers\": \"[1, 2, 3, -2, 5]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            6,\n            10,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[-2, -3, 4, -1, -2, 1, 5, -3]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            5,\n            4,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[-1, -2, -3, -4]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            -10\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[5, -3, 2, 1, -2]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            3,\n            6,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[0, 0, 0, 0]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[10]\"\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            0,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[-5, 8, -3, 4, -1]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            8,\n            3,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0046", "language": "lean", "source": "verina", "source_id": "verina_advanced_47_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that merges all overlapping intervals from a given list of intervals.\n\nEach interval is represented as a pair [start, end], indicating the start and end of the interval. If two intervals overlap, they should be merged into a single interval that spans from the minimum start to the maximum end of the overlapping intervals.\n\nThe goal is to return a list of non-overlapping intervals that cover all the input intervals after merging.\n\n-----Input-----\nThe input consists of one array:\n\nintervals: An array of pairs of integers where intervals[i] = [startᵢ, endᵢ] represents the start and end of the ith interval.\n\n-----Output-----\nThe output is an array of pairs of integers:\nReturns the list of merged, non-overlapping intervals sorted by their start times.\n-/", "vc-preamble": "@[reducible, simp]\ndef mergeIntervals_precond (intervals : List (Prod Int Int)) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def mergeIntervals (intervals : List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : List (Prod Int Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef mergeIntervals_postcond (intervals : List (Prod Int Int)) (result: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : Prop :=\n  -- Check that all original intervals are covered by some result interval\n  let covered := intervals.all (fun (s, e) =>\n    result.any (fun (rs, re) => rs ≤ s ∧ e ≤ re))\n\n  -- Check that no intervals in the result overlap\n  let rec noOverlap (l : List (Prod Int Int)) : Bool :=\n    match l with\n    | [] | [_] => true\n    | (_, e1) :: (s2, e2) :: rest => e1 < s2 && noOverlap ((s2, e2) :: rest)\n\n  covered ∧ noOverlap result\n\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 3), (2, 6), (8, 10), (15, 18)]\"\n        },\n        \"expected\": \"[(1, 6), (8, 10), (15, 18)]\",\n        \"unexpected\": [\n            \"[(1, 3), (2, 6), (15, 19)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 4), (4, 5)]\"\n        },\n        \"expected\": \"[(1, 5)]\",\n        \"unexpected\": [\n            \"[(1, 4), (4, 5), (1, 6)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 10), (2, 3), (4, 5)]\"\n        },\n        \"expected\": \"[(1, 10)]\",\n        \"unexpected\": [\n            \"[(2, 3), (4, 5), (1, 5)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(1, 2), (3, 4), (5, 6)]\"\n        },\n        \"expected\": \"[(1, 2), (3, 4), (5, 6)]\",\n        \"unexpected\": [\n            \"[(1, 4), (5, 6), (1, 6)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"intervals\": \"[(5, 6), (1, 3), (2, 4)]\"\n        },\n        \"expected\": \"[(1, 4), (5, 6)]\",\n        \"unexpected\": [\n            \"[(1, 3), (2, 4), (1, 6)]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0047", "language": "lean", "source": "verina", "source_id": "verina_advanced_48_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing the merge sort algorithm in Lean 4 to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.\n\nThe merge sort algorithm works as follows:\n1. If the list has one element or is empty, it is already sorted.\n2. Otherwise, divide the list into two roughly equal parts.\n3. Recursively sort both halves.\n4. Merge the two sorted halves to produce a single sorted list.\n\nThe key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.\n\n-----Input-----\nThe input consists of one parameter:\nlist: A list of integers that needs to be sorted.\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from the input list, sorted in ascending order.\n-/", "vc-preamble": "@[reducible, simp]\ndef mergeSort_precond (list : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def mergeSort (list : List Int) (h_precond : mergeSort_precond (list)) : List Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef mergeSort_postcond (list : List Int) (result: List Int) (h_precond : mergeSort_precond (list)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm list result\n\ntheorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :\n    mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"list\": \"[5, 2, 9, 1, 5, 6]\"\n        },\n        \"expected\": \"[1, 2, 5, 5, 6, 9]\",\n        \"unexpected\": [\n            \"[5, 2, 9, 1, 5, 6]\",\n            \"[9, 6, 5, 5, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[3, 1, 4, 1, 5, 9, 2, 6]\"\n        },\n        \"expected\": \"[1, 1, 2, 3, 4, 5, 6, 9]\",\n        \"unexpected\": [\n            \"[3, 1, 4, 1, 5, 9, 2, 6]\",\n            \"[9, 6, 5, 4, 3, 2, 1, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[1]\"\n        },\n        \"expected\": \"[1]\",\n        \"unexpected\": [\n            \"[]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[5, 5, 5, 5]\"\n        },\n        \"expected\": \"[5, 5, 5, 5]\",\n        \"unexpected\": [\n            \"[5, 5, 5]\",\n            \"[5, 5, 5, 5, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[9, 8, 7, 6, 5, 4, 3, 2, 1]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5, 6, 7, 8, 9]\",\n        \"unexpected\": [\n            \"[9, 8, 7, 6, 5, 4, 3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"[5, 4, 3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"list\": \"[-3, -1, -5, -2]\"\n        },\n        \"expected\": \"[-5, -3, -2, -1]\",\n        \"unexpected\": [\n            \"[-3, -1, -5, -2]\",\n            \"[-1, -2, -3, -5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0048", "language": "lean", "source": "verina", "source_id": "verina_advanced_49_task", "vc-description": "/- \n-----Description-----\nImplement a Lean 4 function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.\n\n-----Input-----\nThe input consists of two lists of integers:\narr1: A sorted list of integers (ascending)\narr2: Another sorted list of integers (ascending)\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from arr1 and arr2, sorted in ascending order.\n-/", "vc-preamble": "@[reducible]\ndef mergeSortedLists_precond (arr1 : List Int) (arr2 : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr1 ∧ List.Pairwise (· ≤ ·) arr2", "vc-helpers": "", "vc-definitions": "def mergeSortedLists (arr1 : List Int) (arr2 : List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : List Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef mergeSortedLists_postcond (arr1 : List Int) (arr2 : List Int) (result: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧ List.isPerm (arr1 ++ arr2) result\n\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr1\": \"[3, 2, 1]\",\n            \"arr2\": \"[6, 5, 4]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr1\": \"[1, 3, 5]\",\n            \"arr2\": \"[2, 4, 6]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n        \"unexpected\": [\n            \"[1, 3, 5]\",\n            \"[2, 4, 6]\",\n            \"[1, 3, 2, 4, 5, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr1\": \"[]\",\n            \"arr2\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\",\n            \"[999]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr1\": \"[-2, 0, 1]\",\n            \"arr2\": \"[-3, -1]\"\n        },\n        \"expected\": \"[-3, -2, -1, 0, 1]\",\n        \"unexpected\": [\n            \"[-3, -1]\",\n            \"[0, 1]\",\n            \"[-2, 0, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr1\": \"[10, 20, 30]\",\n            \"arr2\": \"[5, 25, 35]\"\n        },\n        \"expected\": \"[5, 10, 20, 25, 30, 35]\",\n        \"unexpected\": [\n            \"[10, 20, 30]\",\n            \"[5, 25, 35]\",\n            \"[10, 20, 25, 30, 35]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr1\": \"[1, 2, 2]\",\n            \"arr2\": \"[2, 3, 3]\"\n        },\n        \"expected\": \"[1, 2, 2, 2, 3, 3]\",\n        \"unexpected\": [\n            \"[1, 2, 3]\",\n            \"[2, 2, 2, 3, 3]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0049", "language": "lean", "source": "verina", "source_id": "verina_advanced_50_task", "vc-description": "/- \n-----Description-----\nThis task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)\n-----Input-----\nThe input consists of two arrays:\na1: A sorted array of natural numbers\na2: A sorted array of natural numbers\n-----Output-----\nThe output is an array:\nReturns a new array with all elements from both input arrays (included once and only once)\nThe resulting array is sorted itself\n-/", "vc-preamble": "@[reducible]\ndef mergeSorted_precond (a1 : Array Nat) (a2 : Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) a1.toList ∧ List.Pairwise (· ≤ ·) a2.toList", "vc-helpers": "", "vc-definitions": "def mergeSorted (a1 : Array Nat) (a2 : Array Nat) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef mergeSorted_postcond (a1 : Array Nat) (a2 : Array Nat) (result: Array Nat) : Prop :=\n  List.Pairwise (· ≤ ·) result.toList ∧\n  result.toList.isPerm (a1.toList ++ a2.toList)\n\ntheorem mergeSorted_spec_satisfied (a1: Array Nat) (a2: Array Nat) :\n    mergeSorted_postcond (a1) (a2) (mergeSorted (a1) (a2)) := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a1\": \"#[3, 2, 1]\",\n            \"a2\": \"#[6, 5, 4]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a1\": \"#[1, 3, 5]\",\n            \"a2\": \"#[2, 4, 6]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5, 6]\",\n        \"unexpected\": [\n            \"#[1, 3, 5, 2, 4, 6]\",\n            \"#[2, 1, 3, 4, 5, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[]\",\n            \"a2\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[]\",\n            \"#[3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[1, 2, 3]\",\n            \"a2\": \"#[]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[]\",\n            \"#[3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[]\",\n            \"a2\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[1, 1, 2]\",\n            \"a2\": \"#[1, 2, 2]\"\n        },\n        \"expected\": \"#[1, 1, 1, 2, 2, 2]\",\n        \"unexpected\": [\n            \"#[1, 1, 2, 1, 2, 2]\",\n            \"#[1, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[10, 20, 30]\",\n            \"a2\": \"#[5, 15, 25]\"\n        },\n        \"expected\": \"#[5, 10, 15, 20, 25, 30]\",\n        \"unexpected\": [\n            \"#[10, 20, 30, 5, 15, 25]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[1, 3, 5, 7, 9]\",\n            \"a2\": \"#[2, 4, 6, 8, 10]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\",\n        \"unexpected\": [\n            \"#[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a1\": \"#[5, 5, 5]\",\n            \"a2\": \"#[5, 5, 5]\"\n        },\n        \"expected\": \"#[5, 5, 5, 5, 5, 5]\",\n        \"unexpected\": [\n            \"#[5, 5, 5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0050", "language": "lean", "source": "verina", "source_id": "verina_advanced_51_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\n-----Input-----\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n-/", "vc-preamble": "@[reducible, simp]\ndef mergeSorted_precond (a : List Int) (b : List Int) : Prop :=\n  List.Pairwise (· ≤ ·) a ∧ List.Pairwise (· ≤ ·) b", "vc-helpers": "def mergeSortedAux : List Int → List Int → List Int\n| [], ys => ys\n| xs, [] => xs\n| x :: xs', y :: ys' =>\n  if x ≤ y then\n    let merged := mergeSortedAux xs' (y :: ys')\n    x :: merged\n  else\n    let merged := mergeSortedAux (x :: xs') ys'\n    y :: merged", "vc-definitions": "def mergeSorted (a : List Int) (b : List Int) (h_precond : mergeSorted_precond (a) (b)) : List Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef mergeSorted_postcond (a : List Int) (b : List Int) (result: List Int) (h_precond : mergeSorted_precond (a) (b)) : Prop :=\n  List.Pairwise (· ≤ ·) result ∧\n  List.isPerm result (a ++ b)\n\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"[1, 2, 3]\",\n            \"b\": \"[6, 5, 4]\"\n        }\n    },\n    {\n        \"input\": {\n            \"a\": \"[3, 2, 1]\",\n            \"b\": \"[6, 5, 4]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"[1, 3, 5]\",\n            \"b\": \"[2, 4, 6]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n        \"unexpected\": [\n            \"[1, 3, 5]\",\n            \"[2, 4, 6]\",\n            \"[6, 5, 4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"[1, 2]\",\n            \"b\": \"[1, 2, 3]\"\n        },\n        \"expected\": \"[1, 1, 2, 2, 3]\",\n        \"unexpected\": [\n            \"[1, 2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"[]\",\n            \"b\": \"[4, 5]\"\n        },\n        \"expected\": \"[4, 5]\",\n        \"unexpected\": [\n            \"[]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"[0, 3, 4]\",\n            \"b\": \"[]\"\n        },\n        \"expected\": \"[0, 3, 4]\",\n        \"unexpected\": [\n            \"[4, 3, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"[1, 4, 6]\",\n            \"b\": \"[2, 3, 5]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n        \"unexpected\": [\n            \"[1, 4, 6, 2, 3, 5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0051", "language": "lean", "source": "verina", "source_id": "verina_advanced_52_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the minimum number of operations to collect the integers from 1 to k by performing the following removal operation on a list of integers.\n\nA removal operation consists of removing the last element from the list nums and adding it to your collection.\n\nThe goal is to determine how many elements must be removed from the end of the list until the set of collected elements (that are less than or equal to k) contains all integers from 1 to k, inclusive.\n\n-----Input-----\nThe input consists of a list and a positive integer:\nnums: A list of positive integers.\nk: A positive integer representing the target upper bound for the collection (i.e., we want to collect 1, 2, ..., k).\n\n-----Output-----\nThe output is an integer:\nReturn the minimum number of operations (elements removed from the end of nums) required to have collected all integers from 1 to k.\n\n-----Note-----\nIt is assumed that the input list contains all integers from 1 to k.\n-/", "vc-preamble": "@[reducible, simp]\ndef minOperations_precond (nums : List Nat) (k : Nat) : Prop :=\n  let target_nums := (List.range k).map (· + 1)\n  target_nums.all (fun n => List.elem n nums)", "vc-helpers": "", "vc-definitions": "def minOperations (nums : List Nat) (k : Nat) (h_precond : minOperations_precond (nums) (k)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef minOperations_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : minOperations_precond (nums) (k)) : Prop :=\n  -- define the list of elements processed after `result` operations\n  let processed := (nums.reverse).take result\n  -- define the target numbers to collect (1 to k)\n  let target_nums := (List.range k).map (· + 1)\n\n  -- condition 1: All target numbers must be present in the processed elements\n  let collected_all := target_nums.all (fun n => List.elem n processed)\n\n  -- condition 2: `result` must be the minimum number of operations.\n  -- This means either result is 0 (which implies k must be 0 as target_nums would be empty)\n  -- or result > 0, and taking one less operation (result - 1) is not sufficient\n  let is_minimal :=\n    if result > 0 then\n      -- if one fewer element is taken, not all target numbers should be present\n      let processed_minus_one := (nums.reverse).take (result - 1)\n      ¬ (target_nums.all (fun n => List.elem n processed_minus_one))\n    else\n      -- if result is 0, it can only be minimal if k is 0 (no targets required)\n      -- So if k=0, `collected_all` is true. If result=0, this condition `k==0` ensures minimality.\n      k == 0\n\n  -- overall specification:\n  collected_all ∧ is_minimal\n\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[5, 6, 7, 8, 9]\",\n            \"k\": 3\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 1, 5, 4, 2]\",\n            \"k\": 2\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            1,\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 1, 5, 4, 2]\",\n            \"k\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 5, 3, 1]\",\n            \"k\": 3\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            1,\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 4, 3, 2, 1]\",\n            \"k\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 4, 1, 2, 3]\",\n            \"k\": 3\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 2, 2, 1]\",\n            \"k\": 2\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[10, 1, 20, 2]\",\n            \"k\": 2\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3]\",\n            \"k\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0052", "language": "lean", "source": "verina", "source_id": "verina_advanced_53_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.\n\nA right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.\n\n-----Input-----\nThe input consists of a single list of integers:\nnums: A list (List Int) containing distinct positive integers.\n\n-----Output-----\nThe output is a single integer (Int):\n- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the list cannot be sorted using right shifts, return -1.\n-/", "vc-preamble": "@[reducible, simp]\ndef minimumRightShifts_precond (nums : List Int) : Prop :=\n  List.Nodup nums", "vc-helpers": "", "vc-definitions": "def minimumRightShifts (nums : List Int) (h_precond : minimumRightShifts_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef minimumRightShifts_postcond (nums : List Int) (result: Int) (h_precond : minimumRightShifts_precond (nums)) : Prop :=\n  let n := nums.length\n\n  let isSorted (l : List Int) := List.Pairwise (· ≤ ·) l\n  let rightShift (k : Nat) (l : List Int) := l.rotateRight k\n\n  -- specification logic based on the result value\n  if n <= 1 then result = 0 else -- specification for base cases\n\n  -- case 1: a non-negative result means a solution was found\n  (result ≥ 0 ∧\n   -- result corresponds to a valid shift count result < n\n   result < n ∧\n   -- applying result shifts results in a sorted list\n   isSorted (rightShift result.toNat nums) ∧\n   -- result is the minimum such non-negative shift count\n   (List.range result.toNat |>.all (fun j => ¬ isSorted (rightShift j nums)))\n  ) ∨\n\n  -- case 2: result is -1 means no solution exists within n shifts\n  (result = -1 ∧\n   -- for all possible shift counts k from 0 to n-1, the resulting list is not sorted\n   (List.range n |>.all (fun k => ¬ isSorted (rightShift k nums)))\n  )\n\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 4, 5, 1, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            -1,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 1, 4]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            -1,\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            1,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 1, 2, 3, 4]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            -1,\n            0,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 5, 2, 3, 4]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0053", "language": "lean", "source": "verina", "source_id": "verina_advanced_54_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the one missing number in a list of distinct natural numbers from 0 to n. The list contains exactly n numbers and all numbers are in the range [0, n], but one number in that range is missing.\n\nYour function must return the missing number. You may assume the input list contains no duplicates and only one number is missing.\n\n-----Input-----\n- nums: A list of natural numbers of length n, each in the range [0, n] with exactly one number missing.\n\n-----Output-----\n- A natural number: the missing number in the range [0, n] not present in the list.\n-/", "vc-preamble": "@[reducible]\ndef missingNumber_precond (nums : List Nat) : Prop :=\n  nums.all (fun x => x ≤ nums.length) ∧ List.Nodup nums", "vc-helpers": "", "vc-definitions": "def missingNumber (nums : List Nat) (h_precond : missingNumber_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef missingNumber_postcond (nums : List Nat) (result: Nat) (h_precond : missingNumber_precond (nums)) : Prop :=\n  let n := nums.length\n  (result ∈ List.range (n + 1)) ∧\n  ¬(result ∈ nums) ∧\n  ∀ x, (x ∈ List.range (n + 1)) → x ≠ result → x ∈ nums\n\ntheorem missingNumber_spec_satisfied (nums: List Nat) (h_precond : missingNumber_precond (nums)) :\n    missingNumber_postcond (nums) (missingNumber (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[0, 0, 1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 0, 1]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[9, 6, 4, 2, 3, 5, 7, 0, 1]\"\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            1,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0054", "language": "lean", "source": "verina", "source_id": "verina_advanced_55_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\n-----Input-----\nThe input consists of:\nxs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\n-----Output-----\nThe output is an integer:\nReturns the number that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n-/", "vc-preamble": "import Std.Data.HashMap\nopen Std\n\n@[reducible]\ndef mostFrequent_precond (xs : List Int) : Prop :=\n  xs ≠ []", "vc-helpers": "-- Build a frequency map from the list\ndef countMap (xs : List Int) : HashMap Int Nat :=\n  let step := fun m x =>\n    let current := m.getD x 0\n    m.insert x (current + 1)\n  let init := (HashMap.empty : HashMap Int Nat)\n  xs.foldl step init\n\n-- Compute the maximum frequency in the map\ndef getMaxFrequency (m : HashMap Int Nat) : Nat :=\n  let step := fun acc (_k, v) =>\n    if v > acc then v else acc\n  let init := 0\n  m.toList.foldl step init\n\n-- Extract all keys whose frequency == maxFreq\ndef getCandidates (m : HashMap Int Nat) (maxFreq : Nat) : List Int :=\n  let isTarget := fun (_k, v) => v = maxFreq\n  let extract := fun (k, _) => k\n  m.toList.filter isTarget |>.map extract\n\n-- Return the first candidate element from original list\ndef getFirstWithFreq (xs : List Int) (candidates : List Int) : Int :=\n  match xs.find? (fun x => candidates.contains x) with\n  | some x => x\n  | none => 0", "vc-definitions": "def mostFrequent (xs : List Int) (h_precond : mostFrequent_precond (xs)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef mostFrequent_postcond (xs : List Int) (result: Int) (h_precond : mostFrequent_precond (xs)) : Prop :=\n  let count := fun x => xs.countP (fun y => y = x)\n  result ∈ xs ∧\n  xs.all (fun x => count x ≤ count result) ∧\n  ((xs.filter (fun x => count x = count result)).head? = some result)\n\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 2, 3]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[4, 4, 5, 5, 4]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[9]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 3, 1, 2, 3, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[7, 7, 8, 8, 9, 9, 7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            8,\n            9\n        ]\n    }\n]\n-/"}
{"id": "LV0055", "language": "lean", "source": "verina", "source_id": "verina_advanced_56_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that moves all zeroes in a given integer list to the end, while preserving the relative order of the non-zero elements.\n\nThe method `moveZeroes` processes the input list by separating the non-zero and zero elements. It then returns a new list formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single list of integers:\nxs: A list of integers (type: List Int), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list (type: List Int) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n-/", "vc-preamble": "@[reducible]\ndef moveZeroes_precond (xs : List Int) : Prop :=\n  True", "vc-helpers": "-- Count how many times a specific value appears in the list", "vc-definitions": "def moveZeroes (xs : List Int) (h_precond : moveZeroes_precond (xs)) : List Int :=\n  sorry", "vc-theorems": "def countVal (val : Int) : List Int → Nat\n  | [] => 0\n  | x :: xs =>\n    let rest := countVal val xs\n    if x = val then rest + 1 else rest\n\n-- Check whether one list is a subsequence of another (preserving relative order)\ndef isSubsequence (xs ys : List Int) : Bool :=\n  match xs, ys with\n  | [], _ => true\n  | _ :: _, [] => false\n  | x :: xt, y :: yt =>\n    if x = y then isSubsequence xt yt else isSubsequence xs yt\n@[reducible]\ndef moveZeroes_postcond (xs : List Int) (result: List Int) (h_precond : moveZeroes_precond (xs)) : Prop :=\n  -- 1. All non-zero elements must maintain their relative order\n  isSubsequence (xs.filter (fun x => x ≠ 0)) result = true ∧\n\n  -- 2. All zeroes must be located at the end of the output list\n  (result.dropWhile (fun x => x ≠ 0)).all (fun x => x = 0) ∧\n\n  -- 3. The output must contain the same number of elements,\n  --    and the number of zeroes must remain unchanged\n  countVal 0 xs = countVal 0 result ∧\n  xs.length = result.length\n\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[0, 1, 0, 3, 12]\"\n        },\n        \"expected\": \"[1, 3, 12, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 1, 3, 12, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[0, 0, 1]\"\n        },\n        \"expected\": \"[1, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 1, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 3]\"\n        },\n        \"expected\": \"[1, 2, 3]\",\n        \"unexpected\": [\n            \"[1, 3, 2]\",\n            \"[0, 1, 2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[0, 0, 0]\"\n        },\n        \"expected\": \"[0, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 0]\",\n            \"[]\",\n            \"[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[4, 0, 5, 0, 6]\"\n        },\n        \"expected\": \"[4, 5, 6, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 4, 5, 6, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[0, 1]\"\n        },\n        \"expected\": \"[1, 0]\",\n        \"unexpected\": [\n            \"[0, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 0]\"\n        },\n        \"expected\": \"[1, 0]\",\n        \"unexpected\": [\n            \"[0, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[2, 0, 0, 3]\"\n        },\n        \"expected\": \"[2, 3, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 0, 2, 3]\",\n            \"[2, 0, 3, 0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0056", "language": "lean", "source": "verina", "source_id": "verina_advanced_57_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`.\nAll integers in both arrays are unique, and the length constraints are.\n\n-----Input-----\nThe input consists of two lists of integers:\nnums1: A list of integers, which is a subset of nums2.\nnums2: A list of integers containing all elements from nums1 and possibly additional elements.\n\n-----Output-----\nThe output is a list of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element\n-/", "vc-preamble": "@[reducible]\ndef nextGreaterElement_precond (nums1 : List Int) (nums2 : List Int) : Prop :=\n  List.Nodup nums1 ∧\n  List.Nodup nums2 ∧\n  nums1.all (fun x => x ∈ nums2)", "vc-helpers": "", "vc-definitions": "def nextGreaterElement (nums1 : List Int) (nums2 : List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : List Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef nextGreaterElement_postcond (nums1 : List Int) (nums2 : List Int) (result: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : Prop :=\n  result.length = nums1.length ∧\n\n  (List.range nums1.length |>.all (fun i =>\n    let val := nums1[i]!\n    let resultVal := result[i]!\n\n    let j := nums2.findIdx? (fun x => x == val)\n    match j with\n    | none => false\n    | some idx =>\n      let nextGreater := (List.range (nums2.length - idx - 1)).find? (fun k =>\n        let pos := idx + k + 1\n        nums2[pos]! > val\n      )\n\n      match nextGreater with\n      | none => resultVal = -1\n      | some offset => resultVal = nums2[idx + offset + 1]!\n  )) ∧\n  (result.all (fun val =>\n    val = -1 ∨ val ∈ nums2\n  ))\n\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums1\": \"[1, 3]\",\n            \"nums2\": \"[1, 2]\"\n        }\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[1, 1]\",\n            \"nums2\": \"[1, 2]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums1\": \"[4, 1, 2]\",\n            \"nums2\": \"[1, 3, 4, 2]\"\n        },\n        \"expected\": \"[-1, 3, -1]\",\n        \"unexpected\": [\n            \"[3, -1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[2, 4]\",\n            \"nums2\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": \"[3, -1]\",\n        \"unexpected\": [\n            \"[-1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[1]\",\n            \"nums2\": \"[1, 2]\"\n        },\n        \"expected\": \"[2]\",\n        \"unexpected\": [\n            \"[-1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[5]\",\n            \"nums2\": \"[5, 4, 3, 2, 1]\"\n        },\n        \"expected\": \"[-1]\",\n        \"unexpected\": [\n            \"[4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[1, 3, 5, 2, 4]\",\n            \"nums2\": \"[6, 5, 4, 3, 2, 1]\"\n        },\n        \"expected\": \"[-1, -1, -1, -1, -1]\",\n        \"unexpected\": [\n            \"[6, 5, 6, 3, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[1, 2, 3]\",\n            \"nums2\": \"[3, 2, 1, 4]\"\n        },\n        \"expected\": \"[4, 4, 4]\",\n        \"unexpected\": [\n            \"[-1, -1, -1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums1\": \"[4, 3, 2, 1]\",\n            \"nums2\": \"[4, 3, 2, 1]\"\n        },\n        \"expected\": \"[-1, -1, -1, -1]\",\n        \"unexpected\": [\n            \"[3, 2, 1, -1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0057", "language": "lean", "source": "verina", "source_id": "verina_advanced_58_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that returns the nth \"ugly number\". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.\n\nThe function should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.\n\n-----Input-----\nThe input is a natural number:\n\nn: The index (1-based) of the ugly number to return.\n\n-----Output-----\nThe output is a natural number:\nThe nth smallest ugly number.\n-/", "vc-preamble": "@[reducible, simp]\ndef nthUglyNumber_precond (n : Nat) : Prop :=\n  n > 0", "vc-helpers": "def nextUgly (seq : List Nat) (c2 c3 c5 : Nat) : (Nat × Nat × Nat × Nat) :=\n  let i2 := seq[c2]! * 2\n  let i3 := seq[c3]! * 3\n  let i5 := seq[c5]! * 5\n  let next := min i2 (min i3 i5)\n  let c2' := if next = i2 then c2 + 1 else c2\n  let c3' := if next = i3 then c3 + 1 else c3\n  let c5' := if next = i5 then c5 + 1 else c5\n  (next, c2', c3', c5')", "vc-definitions": "def nthUglyNumber (n : Nat) (h_precond : nthUglyNumber_precond (n)) : Nat :=\n  sorry", "vc-theorems": "def divideOut : Nat → Nat → Nat\n  | n, p =>\n    if h : p > 1 ∧ n > 0 ∧ n % p = 0 then\n      have : n / p < n := by\n        apply Nat.div_lt_self\n        · exact h.2.1  -- n > 0\n        · exact Nat.lt_of_succ_le (Nat.succ_le_of_lt h.1)  -- 1 < p, so 2 ≤ p\n      divideOut (n / p) p\n    else n\ntermination_by n p => n\n\ndef isUgly (x : Nat) : Bool :=\n  if x = 0 then\n    false\n  else\n    let n1 := divideOut x 2\n    let n2 := divideOut n1 3\n    let n3 := divideOut n2 5\n    n3 = 1\n@[reducible, simp]\ndef nthUglyNumber_postcond (n : Nat) (result: Nat) (h_precond : nthUglyNumber_precond (n)) : Prop :=\n  isUgly result = true ∧\n  ((List.range (result)).filter (fun i => isUgly i)).length = n - 1\n\ntheorem nthUglyNumber_spec_satisfied (n: Nat) (h_precond : nthUglyNumber_precond (n)) :\n    nthUglyNumber_postcond (n) (nthUglyNumber (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": 12,\n        \"unexpected\": [\n            13,\n            10,\n            15\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 15\n        },\n        \"expected\": 24,\n        \"unexpected\": [\n            20,\n            25\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            6,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 7\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            9,\n            10\n        ]\n    }\n]\n-/"}
{"id": "LV0058", "language": "lean", "source": "verina", "source_id": "verina_advanced_59_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n-/", "vc-preamble": "@[reducible]\ndef palindromeIgnoreNonAlnum_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def palindromeIgnoreNonAlnum (s : String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible]\ndef palindromeIgnoreNonAlnum_postcond (s : String) (result: Bool) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Prop :=\n  let cleaned := s.data.filter (fun c => c.isAlpha || c.isDigit) |>.map Char.toLower\nlet forward := cleaned\nlet backward := cleaned.reverse\n\nif result then\n  forward = backward\nelse\n  forward ≠ backward\n\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"A man, a plan, a canal: Panama\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"race a car\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"No 'x' in Nixon\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc!!cba?\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Hello, world!\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0059", "language": "lean", "source": "verina", "source_id": "verina_advanced_60_task", "vc-description": "/- \n-----Description-----\n\nThis task requires writing a Lean 4 method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\n-----Input-----\n\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (Nat)\n\n-----Output-----\n\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.\n-/", "vc-preamble": "@[reducible]\ndef partitionEvensOdds_precond (nums : List Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def partitionEvensOdds (nums : List Nat) (h_precond : partitionEvensOdds_precond (nums)) : (List Nat × List Nat) :=\n  sorry", "vc-theorems": "@[reducible]\ndef partitionEvensOdds_postcond (nums : List Nat) (result: (List Nat × List Nat)) (h_precond : partitionEvensOdds_precond (nums)): Prop :=\n  let evens := result.fst\n  let odds := result.snd\n  -- All elements from nums are in evens ++ odds, no extras\n  evens ++ odds = nums.filter (fun n => n % 2 == 0) ++ nums.filter (fun n => n % 2 == 1) ∧\n  evens.all (fun n => n % 2 == 0) ∧\n  odds.all (fun n => n % 2 == 1)\n\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4, 5, 6]\"\n        },\n        \"expected\": \"([2, 4, 6], [1, 3, 5])\",\n        \"unexpected\": [\n            \"([1, 3, 5], [2, 4, 6])\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 7, 8, 9, 10]\"\n        },\n        \"expected\": \"([0, 8, 10], [7, 9])\",\n        \"unexpected\": [\n            \"([8, 0, 10], [9, 7])\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": \"([], [])\",\n        \"unexpected\": [\n            \"([0], [1])\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 4, 6, 8]\"\n        },\n        \"expected\": \"([2, 4, 6, 8], [])\",\n        \"unexpected\": [\n            \"([], [2, 4, 6, 8])\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 5, 7]\"\n        },\n        \"expected\": \"([], [1, 3, 5, 7])\",\n        \"unexpected\": [\n            \"([1, 3, 5, 7], [])\"\n        ]\n    }\n]\n-/"}
{"id": "LV0060", "language": "lean", "source": "verina", "source_id": "verina_advanced_61_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.\n\n-----Input-----\nThe input is a list of integers. For example, [1,2,3,4].\n\n-----Output-----\nThe output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.\n-/", "vc-preamble": "@[reducible]\ndef productExceptSelf_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "-- Helper: Compute prefix products.\n-- prefix[i] is the product of all elements in nums before index i.\ndef computepref (nums : List Int) : List Int :=\n  nums.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n\n-- Helper: Compute suffix products.\n-- suffix[i] is the product of all elements in nums from index i (inclusive) to the end.\n-- We reverse the list and fold, then reverse back.\ndef computeSuffix (nums : List Int) : List Int :=\n  let revSuffix := nums.reverse.foldl (fun acc x => acc ++ [acc.getLast! * x]) [1]\n  revSuffix.reverse", "vc-definitions": "def productExceptSelf (nums : List Int) (h_precond : productExceptSelf_precond (nums)) : List Int :=\n  sorry", "vc-theorems": "-- Specification Helper: Product of a list of Ints\n-- Defined locally if not available/imported\ndef List.myprod : List Int → Int\n  | [] => 1\n  | x :: xs => x * xs.myprod\n@[reducible]\ndef productExceptSelf_postcond (nums : List Int) (result: List Int) (h_precond : productExceptSelf_precond (nums)) : Prop :=\n  nums.length = result.length ∧\n  (List.range nums.length |>.all (fun i =>\n    result[i]! = some (((List.take i nums).myprod) * ((List.drop (i+1) nums).myprod))))\n\ntheorem productExceptSelf_spec_satisfied (nums: List Int) (h_precond : productExceptSelf_precond (nums)) :\n    productExceptSelf_postcond (nums) (productExceptSelf (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": \"[24, 12, 8, 6]\",\n        \"unexpected\": [\n            \"[24, 12, 8, 0]\",\n            \"[1, 2, 3, 4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-1, 1, 0, -3, 3]\"\n        },\n        \"expected\": \"[0, 0, 9, 0, 0]\",\n        \"unexpected\": [\n            \"[0, 0, 0, 0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 3]\"\n        },\n        \"expected\": \"[3, 2]\",\n        \"unexpected\": [\n            \"[6]\",\n            \"[6, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5, 5, 5, 5]\"\n        },\n        \"expected\": \"[125, 125, 125, 125]\",\n        \"unexpected\": [\n            \"[5]\",\n            \"[25, 25, 25, 25]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 1, 2]\"\n        },\n        \"expected\": \"[2, 0, 0]\",\n        \"unexpected\": [\n            \"[2, 1, 0]\",\n            \"[2, 0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0061", "language": "lean", "source": "verina", "source_id": "verina_advanced_62_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\n-----Input-----\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\n-----Output-----\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.\n-/", "vc-preamble": "@[reducible]\ndef rain_precond (heights : List (Int)) : Prop :=\n  heights.all (fun h => h >= 0)", "vc-helpers": "", "vc-definitions": "def rain (heights : List (Int)) (h_precond : rain_precond (heights)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef rain_postcond (heights : List (Int)) (result: Int) (h_precond : rain_precond (heights)) : Prop :=\n  -- The result is the total amount of rainwater trapped by the given terrain\n  -- If there are fewer than 3 elements, no water can be trapped\n  result >= 0 ∧\n  -- The result is non-negative\n  if heights.length < 3 then result = 0 else\n    -- Water trapped at each position is min(maxLeft, maxRight) - height\n    result =\n      let max_left_at := λ i =>\n        let rec ml (j : Nat) (max_so_far : Int) : Int :=\n          if j > i then max_so_far\n          else ml (j+1) (max max_so_far (heights[j]!))\n          termination_by i + 1 - j\n        ml 0 0\n\n      let max_right_at := λ i =>\n        let rec mr (j : Nat) (max_so_far : Int) : Int :=\n          if j >= heights.length then max_so_far\n          else mr (j+1) (max max_so_far (heights[j]!))\n          termination_by heights.length - j\n        mr i 0\n\n      let water_at := λ i =>\n        max 0 (min (max_left_at i) (max_right_at i) - heights[i]!)\n\n      let rec sum_water (i : Nat) (acc : Int) : Int :=\n        if i >= heights.length then acc\n        else sum_water (i+1) (acc + water_at i)\n        termination_by heights.length - i\n\n      sum_water 0 0\n\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"heights\": \"[-1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"heights\": \"[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            -1,\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"heights\": \"[4, 2, 0, 3, 2, 5]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            -1,\n            8,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"heights\": \"[1, 1, 1]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            3,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"heights\": \"[10, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            5,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"heights\": \"[1, 10, 9, 11]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            -1,\n            9,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"heights\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            100\n        ]\n    }\n]\n-/"}
{"id": "LV0062", "language": "lean", "source": "verina", "source_id": "verina_advanced_63_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that counts the unique elements from a sorted array.\n\n-----Input-----\nThe input is a single list of integers:\nnums: An array of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a single integer:\nReturns the number of unique elements (k).\n-/", "vc-preamble": "@[reducible]\ndef removeDuplicates_precond (nums : List Int) : Prop :=\n  -- nums are sorted in non-decreasing order\n  List.Pairwise (· ≤ ·) nums", "vc-helpers": "", "vc-definitions": "def removeDuplicates (nums : List Int) (h_precond : removeDuplicates_precond (nums)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef removeDuplicates_postcond (nums : List Int) (result: Nat) (h_precond : removeDuplicates_precond (nums)) : Prop :=\n  result - nums.eraseDups.length = 0 ∧\n  nums.eraseDups.length ≤ result\n\ntheorem removeDuplicates_spec_satisfied (nums: List Int) (h_precond : removeDuplicates_precond (nums)) :\n    removeDuplicates_postcond (nums) (removeDuplicates (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 1, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-1, -1, 0, 1, 2, 2, 3]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 1, 1, 1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-100, -100, -100]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-100, -99, -99, -50, 0, 0, 100, 100]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            6,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[-1, 0, 0, 0, 1, 2, 2, 3, 4, 4, 5]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            6,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[100, 100, 100, 101, 102, 102, 103, 104, 105, 105]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7\n        ]\n    }\n]\n-/"}
{"id": "LV0063", "language": "lean", "source": "verina", "source_id": "verina_advanced_64_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (List Nat).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.\n-/", "vc-preamble": "@[reducible]\ndef removeElement_precond (lst : List Nat) (target : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def removeElement (lst : List Nat) (target : Nat) (h_precond : removeElement_precond (lst) (target)) : List Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef removeElement_postcond (lst : List Nat) (target : Nat) (result: List Nat) (h_precond : removeElement_precond (lst) (target)): Prop :=\n  -- 1. All elements equal to target are removed from the result.\n  -- 2. All other elements are preserved in order.\n  -- 3. No new elements are added.\n\n  -- Helper predicate: result contains exactly the elements of lst that are not equal to target, in order\n  let lst' := lst.filter (fun x => x ≠ target)\n  result.zipIdx.all (fun (x, i) =>\n    match lst'[i]? with\n    | some y => x = y\n    | none => false) ∧ result.length = lst'.length\n\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 3, 2, 4]\",\n            \"target\": 2\n        },\n        \"expected\": \"[1, 3, 4]\",\n        \"unexpected\": [\n            \"[1, 2, 3, 4]\",\n            \"[1, 2, 3]\",\n            \"[1, 4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[5, 5, 5, 5]\",\n            \"target\": 5\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[5]\",\n            \"[0]\",\n            \"[5, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[7, 8, 9]\",\n            \"target\": 4\n        },\n        \"expected\": \"[7, 8, 9]\",\n        \"unexpected\": [\n            \"[]\",\n            \"[7, 8]\",\n            \"[8, 9]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[]\",\n            \"target\": 3\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[3]\",\n            \"[0]\",\n            \"[1, 2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[0, 1, 0, 2, 0]\",\n            \"target\": 0\n        },\n        \"expected\": \"[1, 2]\",\n        \"unexpected\": [\n            \"[0, 1, 2]\",\n            \"[1]\",\n            \"[1, 0, 2]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0064", "language": "lean", "source": "verina", "source_id": "verina_advanced_65_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.\n\n-----Input-----\nThe input consists of:\ns: A string (which may be empty).\n\n-----Output-----\nThe output is a string:\nReturns a string where the characters are in reverse order from the original input.\n-/", "vc-preamble": "@[reducible]\ndef reverseString_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def reverseString (s : String) (h_precond : reverseString_precond (s)) : String :=\n  sorry", "vc-theorems": "@[reducible]\ndef reverseString_postcond (s : String) (result: String) (h_precond : reverseString_precond (s)) : Prop :=\n  result.length = s.length ∧ result.toList = s.toList.reverse\n\ntheorem reverseString_spec_satisfied (s: String) (h_precond : reverseString_precond (s)) :\n    reverseString_postcond (s) (reverseString (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"hello\"\n        },\n        \"expected\": \"olleh\",\n        \"unexpected\": [\n            \"hello\",\n            \"helo\",\n            \"hell\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"a\"\n        },\n        \"expected\": \"a\",\n        \"unexpected\": [\n            \"\",\n            \"aa\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \" \",\n            \"a\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"racecar\"\n        },\n        \"expected\": \"racecar\",\n        \"unexpected\": [\n            \"rceacar\",\n            \"raeccar\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Lean\"\n        },\n        \"expected\": \"naeL\",\n        \"unexpected\": [\n            \"Lean\",\n            \"aenL\"\n        ]\n    }\n]\n-/"}
{"id": "LV0065", "language": "lean", "source": "verina", "source_id": "verina_advanced_66_task", "vc-description": "/- \n-----Description-----\nGiven an input string \"words_str\", this task requires writing a Lean 4 function that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The function must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.\n\n-----Input-----\nwords_str: A string that may contain leading, trailing, or multiple spaces between words.\n\n-----Output-----\nA string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.\n-/", "vc-preamble": "@[reducible]\ndef reverseWords_precond (words_str : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def reverseWords (words_str : String) (h_precond : reverseWords_precond (words_str)) : String :=\n  sorry", "vc-theorems": "@[reducible]\ndef reverseWords_postcond (words_str : String) (result: String) (h_precond : reverseWords_precond (words_str)) : Prop :=\n  ∃ words : List String,\n    (words = (words_str.splitOn \" \").filter (fun w => w ≠ \"\")) ∧\n    result = String.intercalate \" \" (words.reverse)\n\ntheorem reverseWords_spec_satisfied (words_str: String) (h_precond : reverseWords_precond (words_str)) :\n    reverseWords_postcond (words_str) (reverseWords (words_str) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"words_str\": \"the sky is blue\"\n        },\n        \"expected\": \"blue is sky the\",\n        \"unexpected\": [\n            \"the sky is blue\",\n            \"sky the blue is\"\n        ]\n    },\n    {\n        \"input\": {\n            \"words_str\": \"  hello world  \"\n        },\n        \"expected\": \"world hello\",\n        \"unexpected\": [\n            \"hello world\",\n            \"worldhello\"\n        ]\n    },\n    {\n        \"input\": {\n            \"words_str\": \"a good   example\"\n        },\n        \"expected\": \"example good a\",\n        \"unexpected\": [\n            \"a good example\",\n            \"example a good\"\n        ]\n    },\n    {\n        \"input\": {\n            \"words_str\": \"  Bob    Loves  Alice   \"\n        },\n        \"expected\": \"Alice Loves Bob\",\n        \"unexpected\": [\n            \"Bob Loves Alice\",\n            \"Alice Loves Bob \"\n        ]\n    },\n    {\n        \"input\": {\n            \"words_str\": \"this lab is interesting\"\n        },\n        \"expected\": \"interesting is lab this\",\n        \"unexpected\": [\n            \"gnitseretni si bal siht\"\n        ]\n    }\n]\n-/"}
{"id": "LV0066", "language": "lean", "source": "verina", "source_id": "verina_advanced_67_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, \"aaabbc\" becomes [(’a’, 3), (’b’, 2), (’c’, 1)].\n\nThe resulting encoded list must satisfy the following properties:\n1. No pair has a zero or negative run-length.\n2. Consecutive pairs in the encoding list must not have the same character.\n3. Decoding the output should return the original string.\n\n-----Input-----\nThe input is a single string, `s`.\n\n-----Output-----\nThe output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.\n-/", "vc-preamble": "@[reducible, simp]\ndef runLengthEncode_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def runLengthEncode (s : String) (h_precond : runLengthEncode_precond (s)) : List (Char × Nat) :=\n  sorry", "vc-theorems": "def decodeRLE (lst : List (Char × Nat)) : String :=\n  match lst with\n  | [] => \"\"\n  | (ch, cnt) :: tail =>\n    let repeated := String.mk (List.replicate cnt ch)\n    repeated ++ decodeRLE tail\n@[reducible, simp]\ndef runLengthEncode_postcond (s : String) (result: List (Char × Nat)) (h_precond : runLengthEncode_precond (s)) : Prop :=\n  (∀ pair ∈ result, pair.snd > 0) ∧\n  (∀ i : Nat, i < result.length - 1 → (result[i]!).fst ≠ (result[i+1]!).fst) ∧\n  decodeRLE result = s\n\ntheorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :\n    runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[('x', 1)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"aaa\"\n        },\n        \"expected\": \"[('a', 3)]\",\n        \"unexpected\": [\n            \"[('a', 2), ('b', 3)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abbbcccaa\"\n        },\n        \"expected\": \"[('a', 1), ('b', 3), ('c', 3), ('a', 2)]\",\n        \"unexpected\": [\n            \"[('a', 2), ('b', 3), ('c', 3), ('a', 2)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"xyz\"\n        },\n        \"expected\": \"[('x', 1), ('y', 1), ('z', 1)]\",\n        \"unexpected\": [\n            \"[('x', 3)]\",\n            \"[('z', 1)]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"aabbaa\"\n        },\n        \"expected\": \"[('a', 2), ('b', 2), ('a', 2)]\",\n        \"unexpected\": [\n            \"[('a', 2), ('b', 2), ('a', 3)]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0067", "language": "lean", "source": "verina", "source_id": "verina_advanced_68_task", "vc-description": "/- \n-----Description-----\nThis task requires implementing a Run-Length Encoding (RLE) algorithm in Lean 4. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.\n\n-----Input-----\nThe input is a string consisting of any characters (including special characters and digits).\n\n-----Output-----\nThe output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:\n1. Alternate between characters and digits (e.g., \"a3b2\").\n2. Reconstruct to the original input when decoded.\n3. Be non-empty if and only if the input is non-empty.\n-/", "vc-preamble": "@[reducible]\ndef runLengthEncoder_precond (input : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def runLengthEncoder (input : String) (h_precond : runLengthEncoder_precond (input)) : String :=\n  sorry", "vc-theorems": "@[reducible]\ndef runLengthEncoder_postcond (input : String) (result: String) (h_precond : runLengthEncoder_precond (input)) : Prop :=\n  -- Helper functions\n  let chars : String → List Char := fun s => s.data\n\n  -- Parse encoded string into (char, count) pairs\n  let parseEncodedString : String → List (Char × Nat) :=\n    let rec parseState : List Char → Option Char → Option Nat → List (Char × Nat) → List (Char × Nat) :=\n      fun remaining currentChar currentCount acc =>\n        match remaining with\n        | [] =>\n          -- Add final pair if we have both char and count\n          match currentChar, currentCount with\n          | some c, some n => (c, n) :: acc\n          | _, _ => acc\n        | c :: cs =>\n          if c.isDigit then\n            match currentChar with\n            | none => [] -- Invalid format: digit without preceding character\n            | some ch =>\n              -- Update current count\n              let digit := c.toNat - 48\n              let newCount :=\n                match currentCount with\n                | none => digit\n                | some n => n * 10 + digit\n              parseState cs currentChar (some newCount) acc\n          else\n            -- We found a new character, save previous pair if exists\n            let newAcc :=\n              match currentChar, currentCount with\n              | some ch, some n => (ch, n) :: acc\n              | _, _ => acc\n            parseState cs (some c) none newAcc\n\n    fun s =>\n      let result := parseState (chars s) none none []\n      result.reverse\n\n  -- Format check: characters followed by at least one digit\n  let formatValid : Bool :=\n    let rec checkPairs (chars : List Char) (nowDigit : Bool) : Bool :=\n      match chars with\n      | [] => true\n      | c :: cs =>\n        if nowDigit && c.isDigit then\n          checkPairs cs true\n        else\n        -- Need at least one digit after character\n          match cs with\n          | [] => false -- Ending with character, no digits\n          | d :: ds =>\n            if d.isDigit then\n              checkPairs ds true\n            else\n              false -- No digit after character\n\n    checkPairs (chars result) false\n\n  -- Content validation\n  let contentValid : Bool :=\n    let pairs := parseEncodedString result\n    let expanded := pairs.flatMap (fun (c, n) => List.replicate n c)\n    expanded == chars input\n\n  -- Empty check\n  let nonEmptyValid : Bool :=\n    input.isEmpty = result.isEmpty\n\n  formatValid && contentValid && nonEmptyValid\n\ntheorem runLengthEncoder_spec_satisfied (input: String) (h_precond : runLengthEncoder_precond (input)) :\n    runLengthEncoder_postcond (input) (runLengthEncoder (input) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"input\": \"aaabbbcc\"\n        },\n        \"expected\": \"a3b3c2\",\n        \"unexpected\": [\n            \"a3b3\",\n            \"a3b3c2x\",\n            \"abc\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"!!!$$$%%%\"\n        },\n        \"expected\": \"!3$3%3\",\n        \"unexpected\": [\n            \"!3$3%\",\n            \"!!!$$$%%\",\n            \"!3$3%4\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"aaaaa\"\n        },\n        \"expected\": \"a5\",\n        \"unexpected\": [\n            \"a4\",\n            \"a6\",\n            \"a\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"abcd\"\n        },\n        \"expected\": \"a1b1c1d1\",\n        \"unexpected\": [\n            \"abcd\",\n            \"a1b1c1\",\n            \"a1b1c1d2\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \"a1\",\n            \" \"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"AaABb\"\n        },\n        \"expected\": \"A1a1A1B1b1\",\n        \"unexpected\": [\n            \"AaABb\",\n            \"A1a1A1B1\",\n            \"A1a1A1B1b2\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"wwwwwwwwwwwwwwwww\"\n        },\n        \"expected\": \"w17\",\n        \"unexpected\": [\n            \"w16\",\n            \"w18\",\n            \"w\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"a\"\n        },\n        \"expected\": \"a1\",\n        \"unexpected\": [\n            \"a\",\n            \"a2\",\n            \"\"\n        ]\n    },\n    {\n        \"input\": {\n            \"input\": \"  \"\n        },\n        \"expected\": \" 2\",\n        \"unexpected\": [\n            \" \",\n            \" 1\",\n            \" 3\"\n        ]\n    }\n]\n-/"}
{"id": "LV0068", "language": "lean", "source": "verina", "source_id": "verina_advanced_69_task", "vc-description": "/- \n-----Description-----\nGiven a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int — a sorted list of distinct integers in increasing order\ntarget : Int — the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n-/", "vc-preamble": "@[reducible]\ndef searchInsert_precond (xs : List Int) (target : Int) : Prop :=\n  List.Pairwise (· < ·) xs", "vc-helpers": "", "vc-definitions": "def searchInsert (xs : List Int) (target : Int) (h_precond : searchInsert_precond (xs) (target)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef searchInsert_postcond (xs : List Int) (target : Int) (result: Nat) (h_precond : searchInsert_precond (xs) (target)) : Prop :=\n  let allBeforeLess := (List.range result).all (fun i => xs[i]! < target)\n  let inBounds := result ≤ xs.length\n  let insertedCorrectly :=\n    result < xs.length → target ≤ xs[result]!\n  inBounds ∧ allBeforeLess ∧ insertedCorrectly\n\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"xs\": \"[2, 1]\",\n            \"target\": 5\n        }\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 1]\",\n            \"target\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, 3, 5, 6]\",\n            \"target\": 5\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 3, 5, 6]\",\n            \"target\": 2\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 3, 5, 6]\",\n            \"target\": 7\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[1, 3, 5, 6]\",\n            \"target\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\",\n            \"target\": 3\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[10]\",\n            \"target\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[10]\",\n            \"target\": 15\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0069", "language": "lean", "source": "verina", "source_id": "verina_advanced_70_task", "vc-description": "/- \n-----Description---\nThis task requires writing a Lean 4 method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n.\n\n-----Input-----\n\nThe input consists of:\n- nums: A list of integeris.\n\n----Output-----\n\nThe output is an integer.\n-/", "vc-preamble": "@[reducible]\ndef semiOrderedPermutation_precond (nums : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def semiOrderedPermutation (nums : List Int) (h_precond : semiOrderedPermutation_precond (nums)) : Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef semiOrderedPermutation_postcond (nums : List Int) (result: Int) (h_precond : semiOrderedPermutation_precond (nums)) : Prop :=\n  let n := nums.length\n  let pos1 := nums.idxOf 1\n  let posn := nums.idxOf (Int.ofNat n)\n  if pos1 > posn then\n    pos1 + n = result + 2 + posn\n  else\n    pos1 + n = result + 1 + posn\n\ntheorem semiOrderedPermutation_spec_satisfied (nums: List Int) (h_precond : semiOrderedPermutation_precond (nums)) :\n    semiOrderedPermutation_postcond (nums) (semiOrderedPermutation (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[2, 1, 4, 3]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 4, 1, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 3, 4, 2, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 1, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[2, 3, 1, 5, 4]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            4,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0070", "language": "lean", "source": "verina", "source_id": "verina_advanced_71_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that, given a binary string `s` and an integer `k`, finds the shortest contiguous substring that contains exactly `k` characters `'1'`.\n\nAmong all substrings of `s` that contain exactly `k` occurrences of `'1'`, return the one that is shortest in length. If there are multiple such substrings with the same length, return the lexicographically smallest one.\n\nIf no such substring exists, return the empty string.\n\n-----Input-----\n- s: A binary string (only consisting of characters `'0'` and `'1'`)\n- k: A natural number (k ≥ 0)\n\n-----Output-----\nA string representing the shortest substring of `s` that contains exactly `k` ones. If no such substring exists, return `\"\"`.\n-/", "vc-preamble": "@[reducible]\ndef shortestBeautifulSubstring_precond (s : String) (k : Nat) : Prop :=\n  s.toList.all (fun c => c = '0' ∨ c = '1')", "vc-helpers": "def countOnes (lst : List Char) : Nat :=\n  lst.foldl (fun acc c => if c = '1' then acc + 1 else acc) 0\n\ndef listToString (lst : List Char) : String :=\n  String.mk lst\ndef isLexSmaller (a b : List Char) : Bool :=\n  listToString a < listToString b\ndef allSubstrings (s : List Char) : List (List Char) :=\n  let n := s.length\n  (List.range n).flatMap (fun i =>\n    (List.range (n - i)).map (fun j =>\n      s.drop i |>.take (j + 1)))", "vc-definitions": "def shortestBeautifulSubstring (s : String) (k : Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : String :=\n  sorry", "vc-theorems": "@[reducible]\ndef shortestBeautifulSubstring_postcond (s : String) (k : Nat) (result: String) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : Prop :=\n  let chars := s.data\n  let substrings := (List.range chars.length).flatMap (fun i =>\n    (List.range (chars.length - i + 1)).map (fun len =>\n      chars.drop i |>.take len))\n  let isBeautiful := fun sub => countOnes sub = k\n  let beautiful := substrings.filter (fun sub => isBeautiful sub)\n  let targets := beautiful.map (·.asString) |>.filter (fun s => s ≠ \"\")\n  (result = \"\" ∧ targets = []) ∨\n  (result ∈ targets ∧\n   ∀ r ∈ targets, r.length ≥ result.length ∨ (r.length = result.length ∧ result ≤ r))\n\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"s\": \"2\",\n            \"k\": 1\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"100011001\",\n            \"k\": 3\n        },\n        \"expected\": \"11001\",\n        \"unexpected\": [\n            \"00011\",\n            \"10001\",\n            \"\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"1011\",\n            \"k\": 2\n        },\n        \"expected\": \"11\",\n        \"unexpected\": [\n            \"101\",\n            \"01\",\n            \"\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"000\",\n            \"k\": 1\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \"0\",\n            \"00\",\n            \"000\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"11111\",\n            \"k\": 3\n        },\n        \"expected\": \"111\",\n        \"unexpected\": [\n            \"11\",\n            \"1111\",\n            \"\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"10100101\",\n            \"k\": 2\n        },\n        \"expected\": \"101\",\n        \"unexpected\": [\n            \"010\",\n            \"1001\",\n            \"0101\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"1001001\",\n            \"k\": 2\n        },\n        \"expected\": \"1001\",\n        \"unexpected\": [\n            \"0010\",\n            \"0100\",\n            \"001\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"10010001\",\n            \"k\": 1\n        },\n        \"expected\": \"1\",\n        \"unexpected\": [\n            \"10\",\n            \"100\",\n            \"000\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"1001\",\n            \"k\": 0\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"10\",\n            \"100\",\n            \"1\"\n        ]\n    }\n]\n-/"}
{"id": "LV0071", "language": "lean", "source": "verina", "source_id": "verina_advanced_72_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that given an natural number n, returns the smallest prime factor that is less than 10. If none exist, return 0\n\n-----Input-----\nThe input consists of one natural number:\nn: The main natural number.\n\n-----Output-----\nThe output is an natural number:\nReturns the smallest prime factor that is less than 10 or, if none exist, 0\n-/", "vc-preamble": "@[reducible, simp]\ndef singleDigitPrimeFactor_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def singleDigitPrimeFactor (n : Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef singleDigitPrimeFactor_postcond (n : Nat) (result: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) : Prop :=\n  result ∈ [0, 2, 3, 5, 7] ∧\n  (result = 0 → (n = 0 ∨ [2, 3, 5, 7].all (n % · ≠ 0))) ∧\n  (result ≠ 0 → n ≠ 0 ∧ n % result == 0 ∧ (List.range result).all (fun x => x ∈ [2, 3, 5, 7] → n % x ≠ 0))\n\ntheorem singleDigitPrimeFactor_spec_satisfied (n: Nat) (h_precond : singleDigitPrimeFactor_precond (n)) :\n    singleDigitPrimeFactor_postcond (n) (singleDigitPrimeFactor (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 98\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            7,\n            8,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            4,\n            5,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 73\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 529\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            7,\n            8,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 161\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0072", "language": "lean", "source": "verina", "source_id": "verina_advanced_73_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.\n\n-----Input-----\nThe input consists of a list of natural numbers sorted in increasing order:\nl: The sorted list\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.\n-/", "vc-preamble": "@[reducible]\ndef smallestMissing_precond (l : List Nat) : Prop :=\n  List.Pairwise (· < ·) l", "vc-helpers": "", "vc-definitions": "def smallestMissing (l : List Nat) (h_precond : smallestMissing_precond (l)) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef smallestMissing_postcond (l : List Nat) (result: Nat) (h_precond : smallestMissing_precond (l)) : Prop :=\n  result ∉ l ∧ ∀ candidate : Nat, candidate < result → candidate ∈ l\n\ntheorem smallestMissing_spec_satisfied (l: List Nat) (h_precond : smallestMissing_precond (l)) :\n    smallestMissing_postcond (l) (smallestMissing (l) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"l\": \"[1, 1]\"\n        }\n    },\n    {\n        \"input\": {\n            \"l\": \"[1, 0]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"l\": \"[0, 1, 2, 4, 5]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            2,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[0, 1, 2, 3, 4]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            0,\n            1,\n            2,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[2, 3, 4, 5, 6]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3,\n            4,\n            5,\n            6\n        ]\n    }\n]\n-/"}
{"id": "LV0073", "language": "lean", "source": "verina", "source_id": "verina_advanced_74_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function called `solution` that takes a list of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.\n\n-----Input-----\nThe input is a list of natural numbers:\n`nums`: A list where each element is a natural number.\nConstraints:\n- The length of the list `nums` (n) is between 1 and 100 (inclusive).\n- Each element in `nums` is between 1 and 100 (inclusive).\n\n-----Output-----\nThe output is a natural number:\nReturns the total sum of squared distinct counts for all subarrays.\n-/", "vc-preamble": "import Std.Data.HashSet\nopen Std\n\n@[reducible]\ndef solution_precond (nums : List Nat) : Prop :=\n  1 ≤ nums.length ∧ nums.length ≤ 100 ∧ nums.all (fun x => 1 ≤ x ∧ x ≤ 100)", "vc-helpers": "", "vc-definitions": "def solution (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef solution_postcond (nums : List Nat) (result: Nat) : Prop :=\n  let n := nums.length;\n\n  let getSubarray_local := fun (i j : Nat) =>\n    (nums.drop i).take (j - i + 1);\n\n  let distinctCount_local := fun (l : List Nat) =>\n    let foldFn := fun (seen : List Nat) (x : Nat) =>\n      if seen.elem x then seen else x :: seen;\n    let distinctElems := l.foldl foldFn [];\n    distinctElems.length;\n\n  let square_local := fun (n : Nat) => n * n;\n\n  (1 <= n ∧ n <= 100 ∧ nums.all (fun x => 1 <= x ∧ x <= 100)) ->\n  (\n    result >= 0\n    ∧\n    let expectedSum : Nat :=\n      List.range n |>.foldl (fun (outerSum : Nat) (i : Nat) =>\n        let innerSum : Nat :=\n          List.range (n - i) |>.foldl (fun (currentInnerSum : Nat) (d : Nat) =>\n            let j := i + d;\n            let subarr := getSubarray_local i j;\n            let count := distinctCount_local subarr;\n            currentInnerSum + square_local count\n          ) 0\n        outerSum + innerSum\n      ) 0;\n\n    result = expectedSum\n  )\n\ntheorem solution_spec_satisfied (nums: List Nat) :\n    solution_postcond (nums) (solution (nums)) := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[]\"\n        }\n    },\n    {\n        \"input\": {\n            \"nums\": \"[101]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 1, 1]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 1]\"\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            12\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4]\"\n        },\n        \"expected\": 50,\n        \"unexpected\": []\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 2, 3, 1]\"\n        },\n        \"expected\": 62,\n        \"unexpected\": [\n            1,\n            2,\n            2,\n            3,\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0074", "language": "lean", "source": "verina", "source_id": "verina_advanced_75_task", "vc-description": "/- \n-----Description-----\nGiven a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane’s Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\n-----Input-----\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\n-----Output-----\nThe output is a single integer representing the maximum subarray sum.\n-/", "vc-preamble": "@[reducible, simp]\ndef task_code_precond (sequence : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=\n  let subArrays :=\n    List.range (sequence.length + 1) |>.flatMap (fun start =>\n      List.range (sequence.length - start + 1) |>.map (fun len =>\n        sequence.drop start |>.take len))\n  let subArraySums := subArrays.filter (· ≠ []) |>.map (·.sum)\n  subArraySums.contains result ∧ subArraySums.all (· ≤ result)\n\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"sequence\": \"[10, -4, 3, 1, 5, 6, -35, 12, 21, -1]\"\n        },\n        \"expected\": 33,\n        \"unexpected\": [\n            32,\n            34,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"sequence\": \"[2, 1, -4, 3, 4, -4, 6, 5, -5, 1]\"\n        },\n        \"expected\": 14,\n        \"unexpected\": [\n            13,\n            15,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"sequence\": \"[-1, -2, -3, -4, -5]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            -2,\n            0,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"sequence\": \"[7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            0,\n            1,\n            -7\n        ]\n    },\n    {\n        \"input\": {\n            \"sequence\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            14,\n            16,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0075", "language": "lean", "source": "verina", "source_id": "verina_advanced_76_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.\n\n-----Input-----\nThe input consists of two values:\nnums: A list of integers, possibly with duplicates.\nk: A natural number indicating how many of the most frequent elements to return. Assimng k <= # of distinct elements in nums.\n\n-----Output-----\nThe output is a list of integers:\nReturns exactly k integers representing the elements that appear most frequently in the input list in the order form the higher frequency to lower frequency.\nIf two numbers have the same frequency, use the order of the first occurance in nums.\n-/", "vc-preamble": "import Std\nopen Std\n\n@[reducible]\ndef topKFrequent_precond (nums : List Int) (k : Nat) : Prop :=\n  k ≤ nums.eraseDups.length", "vc-helpers": "", "vc-definitions": "def topKFrequent (nums : List Int) (k : Nat) (h_precond : topKFrequent_precond (nums) (k)) : List Int :=\n  sorry", "vc-theorems": "@[reducible]\ndef topKFrequent_postcond (nums : List Int) (k : Nat) (result: List Int) (h_precond : topKFrequent_precond (nums) (k)) : Prop :=\n  -- Result contains exactly k elements\n  result.length = k ∧\n\n  -- All elements in result appear in the original list\n  result.all (· ∈ nums) ∧\n\n  -- All elements in result are distinct\n  List.Pairwise (· ≠ ·) result ∧\n\n  -- For any element in result and any element not in result, the frequency of the\n  -- element in result is greater or equal\n  (result.all (fun x =>\n    nums.all (fun y =>\n      y ∉ result →\n        nums.count x > nums.count y ∨\n        (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n    ))) ∧\n\n  -- Elements in result are ordered by decreasing frequency\n  List.Pairwise (fun (x, i) (y, j) =>\n    i < j → nums.count x > nums.count y ∨\n    (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)\n  ) result.zipIdx\n\ntheorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :\n    topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3]\",\n            \"k\": 4\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 1, 1, 2, 2, 3]\",\n            \"k\": 2\n        },\n        \"expected\": \"[1, 2]\",\n        \"unexpected\": [\n            \"[1, 3]\",\n            \"[2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[4, 1, -1, 2, -1, 2, 3]\",\n            \"k\": 2\n        },\n        \"expected\": \"[-1, 2]\",\n        \"unexpected\": [\n            \"[-1, 4]\",\n            \"[4, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[5]\",\n            \"k\": 1\n        },\n        \"expected\": \"[5]\",\n        \"unexpected\": [\n            \"[]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[7, 7, 7, 8, 8, 9]\",\n            \"k\": 1\n        },\n        \"expected\": \"[7]\",\n        \"unexpected\": [\n            \"[8]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[]\",\n            \"k\": 0\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0076", "language": "lean", "source": "verina", "source_id": "verina_advanced_77_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 function that calculates how much water can be trapped between elevations after it rains. The input is a list of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\n-----Input-----\n- height: A list of natural numbers representing elevations.\n\n-----Output-----\n- A natural number: total units of water that can be trapped.\n-/", "vc-preamble": "@[reducible, simp]\ndef trapRainWater_precond (height : List Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def trapRainWater (height : List Nat) (h_precond : trapRainWater_precond (height)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef trapRainWater_postcond (height : List Nat) (result: Nat) (h_precond : trapRainWater_precond (height)) : Prop :=\n  let waterAt := List.range height.length |>.map (fun i =>\n    let lmax := List.take (i+1) height |>.foldl Nat.max 0\n    let rmax := List.drop i height |>.foldl Nat.max 0\n    Nat.min lmax rmax - height[i]!)\n\n  result - (waterAt.foldl (· + ·) 0) = 0 ∧ (waterAt.foldl (· + ·) 0) ≤ result\n\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"height\": \"[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"height\": \"[4, 2, 0, 3, 2, 5]\"\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"height\": \"[1, 0, 2]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"height\": \"[3, 0, 1, 3, 0, 5]\"\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"height\": \"[0, 1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"height\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1\n        ]\n    }\n]\n-/"}
{"id": "LV0077", "language": "lean", "source": "verina", "source_id": "verina_advanced_78_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that solves the Two Sum problem. Given a list of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.\n\n-----Input-----\nThe input consists of:\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\nThe output is a pair (tuple) of integers representing the indices of the two numbers in the input list that add up to the target.\n-/", "vc-preamble": "@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  let pairwiseSum := List.range nums.length |>.flatMap (fun i =>\n    nums.drop (i + 1) |>.map (fun y => nums[i]! + y))\n  nums.length > 1 ∧ pairwiseSum.count target = 1", "vc-helpers": "def findComplement (nums : List Int) (target : Int) (i : Nat) (x : Int) : Option Nat :=\n  let rec aux (nums : List Int) (j : Nat) : Option Nat :=\n    match nums with\n    | []      => none\n    | y :: ys => if x + y = target then some (i + j + 1) else aux ys (j + 1)\n  aux nums 0\n\ndef twoSumAux (nums : List Int) (target : Int) (i : Nat) : Prod Nat Nat :=\n  match nums with\n  | []      => panic! \"No solution exists\"\n  | x :: xs =>\n    match findComplement xs target i x with\n    | some j => (i, j)\n    | none   => twoSumAux xs target (i + 1)", "vc-definitions": "def twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Prod Nat Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Prod Nat Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  let i := result.fst;\n  let j := result.snd;\n  (i < j) ∧\n  (i < nums.length) ∧ (j < nums.length) ∧\n  (nums[i]!) + (nums[j]!) = target\n\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"[1, 2]\",\n            \"target\": 0\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[2, 7, 11, 15]\",\n            \"target\": 9\n        },\n        \"expected\": \"(0, 1)\",\n        \"unexpected\": [\n            \"(2, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 4]\",\n            \"target\": 6\n        },\n        \"expected\": \"(1, 2)\",\n        \"unexpected\": [\n            \"(0, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 3]\",\n            \"target\": 6\n        },\n        \"expected\": \"(0, 1)\",\n        \"unexpected\": [\n            \"(1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3, 4]\",\n            \"target\": 7\n        },\n        \"expected\": \"(2, 3)\",\n        \"unexpected\": [\n            \"(0, 1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 4, 3, 0]\",\n            \"target\": 0\n        },\n        \"expected\": \"(0, 3)\",\n        \"unexpected\": [\n            \"(1, 2)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0078", "language": "lean", "source": "verina", "source_id": "verina_advanced_79_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that implementing the \"Two Sum\" problem. Given a list of integers\nand a target integer, the function should return the indices of the two numbers that add up to\nthe target. If no valid pair exists, the function should return none. And the indices returned must\nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that\n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n-/", "vc-preamble": "@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Option (Nat × Nat) :=\n  sorry", "vc-theorems": "@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Option (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n    match result with\n    | none => List.Pairwise (· + · ≠ target) nums\n    | some (i, j) =>\n        i < j ∧\n        j < nums.length ∧\n        nums[i]! + nums[j]! = target ∧\n        -- i must be the first i\n        List.Pairwise (fun a b => a + b ≠ target) (nums.take i) ∧\n        List.all (nums.take i) (fun a => List.all (nums.drop i) (fun b => a + b ≠ target) ) ∧\n        -- j must be the first j\n        List.all (nums.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"[2, 7, 11, 15]\",\n            \"target\": 9\n        },\n        \"expected\": \"some (0, 1)\",\n        \"unexpected\": [\n            \"some (1, 2)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 2, 4]\",\n            \"target\": 6\n        },\n        \"expected\": \"some (1, 2)\",\n        \"unexpected\": [\n            \"some (0, 2)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[3, 3]\",\n            \"target\": 6\n        },\n        \"expected\": \"some (0, 1)\",\n        \"unexpected\": [\n            \"some (1, 1)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[1, 2, 3]\",\n            \"target\": 7\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some (0, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"[0, 4, 3, 0]\",\n            \"target\": 0\n        },\n        \"expected\": \"some (0, 3)\",\n        \"unexpected\": [\n            \"some (1, 2)\",\n            \"none\"\n        ]\n    }\n]\n-/"}
{"id": "LV0079", "language": "lean", "source": "verina", "source_id": "verina_advanced_80_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has exactly one solution, and you may not use the same element twice.\n\n-----Input-----\nThe input consists of:\nnums: An array of integers.\ntarget: An integer representing the target sum.\n\n-----Output-----\nThe output is an array of two integers:\nReturns the indices of the two numbers in the array that add up to the target. The indices should be sorted.\n-/", "vc-preamble": "@[reducible]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  -- The array must have at least 2 elements\n  nums.size ≥ 2 ∧\n\n  -- There exists exactly one pair of indices whose values sum to the target\n  (List.range nums.size).any (fun i =>\n    (List.range i).any (fun j => nums[i]! + nums[j]! = target)) ∧\n\n  -- No other pair sums to the target (ensuring uniqueness of solution)\n  ((List.range nums.size).flatMap (fun i =>\n    (List.range i).filter (fun j => nums[i]! + nums[j]! = target))).length = 1", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: Array Nat) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  -- Result contains exactly 2 indices\n  result.size = 2 ∧\n\n  -- The indices are valid (within bounds of the nums array)\n  result[0]! < nums.size ∧ result[1]! < nums.size ∧\n\n  -- The indices are in ascending order (sorted)\n  result[0]! < result[1]! ∧\n\n  -- The values at these indices sum to the target\n  nums[result[0]!]! + nums[result[1]!]! = target\n\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"#[0]\",\n            \"target\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"#[2, 7, 11, 15]\",\n            \"target\": 9\n        },\n        \"expected\": \"#[0, 1]\",\n        \"unexpected\": [\n            \"#[1, 0]\",\n            \"#[2, 3]\",\n            \"#[0, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[3, 2, 4]\",\n            \"target\": 6\n        },\n        \"expected\": \"#[1, 2]\",\n        \"unexpected\": [\n            \"#[0, 1]\",\n            \"#[0, 2]\",\n            \"#[0, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[3, 3]\",\n            \"target\": 6\n        },\n        \"expected\": \"#[0, 1]\",\n        \"unexpected\": [\n            \"#[1, 0]\",\n            \"#[2, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[1, 2, 3, 4, 5]\",\n            \"target\": 9\n        },\n        \"expected\": \"#[3, 4]\",\n        \"unexpected\": [\n            \"#[0, 4]\",\n            \"#[1, 3]\",\n            \"#[2, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[0, 4, 3, 0]\",\n            \"target\": 0\n        },\n        \"expected\": \"#[0, 3]\",\n        \"unexpected\": [\n            \"#[1, 2]\",\n            \"#[2, 1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0080", "language": "lean", "source": "verina", "source_id": "verina_advanced_81_task", "vc-description": "/- \n-----Description-----\nImplement a Lean 4 function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.\n\n-----Input-----\nThe input consists of a single list of integers:\narr: A list of integers.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.\n-/", "vc-preamble": "@[reducible, simp]\ndef uniqueSorted_precond (arr : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def uniqueSorted (arr : List Int) (h_precond : uniqueSorted_precond (arr)) : List Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef uniqueSorted_postcond (arr : List Int) (result: List Int) (h_precond : uniqueSorted_precond (arr)) : Prop :=\n  List.isPerm arr.eraseDups result ∧ List.Pairwise (· ≤ ·) result\n\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"[1, 1, 2, 3]\"\n        },\n        \"expected\": \"[1, 2, 3]\",\n        \"unexpected\": [\n            \"[1, 1, 2, 3]\",\n            \"[2, 3, 1]\",\n            \"[1, 3, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"[3, 3, 3]\"\n        },\n        \"expected\": \"[3]\",\n        \"unexpected\": [\n            \"[3, 3, 3]\",\n            \"[3, 3]\",\n            \"[3, 3, 3, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[0]\",\n            \"[1]\",\n            \"[999]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"[5, 2, 2, 5]\"\n        },\n        \"expected\": \"[2, 5]\",\n        \"unexpected\": [\n            \"[5, 2]\",\n            \"[2, 2, 5]\",\n            \"[2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"[1, 2, 3]\",\n            \"[2, 3, 4, 5]\",\n            \"[5, 4, 3, 2, 1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0081", "language": "lean", "source": "verina", "source_id": "verina_basic_1_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether two given integers have opposite signs. In other words, the method should return true if one integer is positive and the other is negative. Note that zero is considered neither positive nor negative; therefore, if either integer is zero, the method should return false.\n\n-----Input-----\nThe input consists of two integers:\na: An integer.\nb: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if one of the integers is positive and the other is negative (i.e., they have opposite signs).\nReturns false if both integers are either non-negative or non-positive, or if one (or both) is zero.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef hasOppositeSign_precond (a : Int) (b : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def hasOppositeSign (a : Int) (b : Int) (h_precond : hasOppositeSign_precond (a) (b)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasOppositeSign_postcond (a : Int) (b : Int) (result: Bool) (h_precond : hasOppositeSign_precond (a) (b)) :=\n  (((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → result) ∧\n  (¬((a < 0 ∧ b > 0) ∨ (a > 0 ∧ b < 0)) → ¬result)\n\ntheorem hasOppositeSign_spec_satisfied (a: Int) (b: Int) (h_precond : hasOppositeSign_precond (a) (b)) :\n    hasOppositeSign_postcond (a) (b) (hasOppositeSign (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": -5,\n            \"b\": 10\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 5,\n            \"b\": -10\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 5,\n            \"b\": 10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -5,\n            \"b\": -10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 10,\n            \"b\": 0\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": -10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -10,\n            \"b\": 0\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 0\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -1,\n            \"b\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 1,\n            \"b\": -1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0082", "language": "lean", "source": "verina", "source_id": "verina_basic_2_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.\n-/", "vc-preamble": "@[reducible, simp]\ndef findSmallest_precond (s : Array Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def findSmallest (s : Array Nat) (h_precond : findSmallest_precond (s)) : Option Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findSmallest_postcond (s : Array Nat) (result: Option Nat) (h_precond : findSmallest_precond (s)) :=\n  let xs := s.toList\n  match result with\n  | none => xs = []\n  | some r => r ∈ xs ∧ (∀ x, x ∈ xs → r ≤ x)\n\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"#[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\"\n        },\n        \"expected\": \"some (1)\",\n        \"unexpected\": [\n            \"some (2)\",\n            \"some (0)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[0, 1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"some (0)\",\n        \"unexpected\": [\n            \"some (1)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[1]\"\n        },\n        \"expected\": \"some (1)\",\n        \"unexpected\": [\n            \"some (0)\",\n            \"some (2)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[10, 10, 10]\"\n        },\n        \"expected\": \"some (10)\",\n        \"unexpected\": [\n            \"some (9)\",\n            \"some (0)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[3, 2, 2, 2, 2, 2, 2, 1]\"\n        },\n        \"expected\": \"some (1)\",\n        \"unexpected\": [\n            \"some (2)\",\n            \"some (0)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[0]\"\n        },\n        \"expected\": \"some (0)\",\n        \"unexpected\": [\n            \"some (1)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[100, 99, 98]\"\n        },\n        \"expected\": \"some (98)\",\n        \"unexpected\": [\n            \"some (99)\",\n            \"some (97)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[]\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some (0)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0083", "language": "lean", "source": "verina", "source_id": "verina_basic_3_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: An integer to check for divisibility by 11.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is divisible by 11.\nReturns false if the input number is not divisible by 11.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef isDivisibleBy11_precond (n : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isDivisibleBy11 (n : Int) (h_precond : isDivisibleBy11_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isDivisibleBy11_postcond (n : Int) (result: Bool) (h_precond : isDivisibleBy11_precond (n)) :=\n  (result → (∃ k : Int, n = 11 * k)) ∧ (¬ result → (∀ k : Int, ¬ n = 11 * k))\n\ntheorem isDivisibleBy11_spec_satisfied (n: Int) (h_precond : isDivisibleBy11_precond (n)) :\n    isDivisibleBy11_postcond (n) (isDivisibleBy11 (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 11\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 22\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 23\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 33\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 44\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -11\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -22\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -1\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 121\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 123\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0084", "language": "lean", "source": "verina", "source_id": "verina_basic_4_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\nk: An integer representing the position (1-based index) of the element to find.\n\n-----Output-----\nThe output is an integer:\nReturns the element at the kth position in the array.\n\n-----Note-----\nThe input k is assumed to be valid (between 1 and array length inclusive).\nThe array is assumed to be non-empty.\n-/", "vc-preamble": "@[reducible, simp]\ndef kthElement_precond (arr : Array Int) (k : Nat) : Prop :=\n  k ≥ 1 ∧ k ≤ arr.size", "vc-helpers": "", "vc-definitions": "def kthElement (arr : Array Int) (k : Nat) (h_precond : kthElement_precond (arr) (k)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef kthElement_postcond (arr : Array Int) (k : Nat) (result: Int) (h_precond : kthElement_precond (arr) (k)) :=\n  arr.any (fun x => x = result ∧ x = arr[k - 1]!)\n\ntheorem kthElement_spec_satisfied (arr: Array Int) (k: Nat) (h_precond : kthElement_precond (arr) (k)) :\n    kthElement_postcond (arr) (k) (kthElement (arr) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\",\n            \"k\": 0\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[10, 20, 30, 40, 50]\",\n            \"k\": 1\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            20,\n            30\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[10, 20, 30, 40, 50]\",\n            \"k\": 3\n        },\n        \"expected\": 30,\n        \"unexpected\": [\n            10,\n            40,\n            50\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[10, 20, 30, 40, 50]\",\n            \"k\": 5\n        },\n        \"expected\": 50,\n        \"unexpected\": [\n            10,\n            40\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[5]\",\n            \"k\": 1\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            0,\n            1\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\",\n            \"k\": 3\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\",\n            \"k\": 2\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[9, 9, 9]\",\n            \"k\": 2\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            0,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, -1, -2]\",\n            \"k\": 1\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, -1, -2]\",\n            \"k\": 2\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            -2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, -1, -2]\",\n            \"k\": 3\n        },\n        \"expected\": -2,\n        \"unexpected\": [\n            0,\n            -1\n        ]\n    }\n]\n-/"}
{"id": "LV0085", "language": "lean", "source": "verina", "source_id": "verina_basic_5_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that multiplies two integers. The method should return the product of the two input numbers.\n\n-----Input-----\nThe input consists of:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the two input integers (a * b).\n-/", "vc-preamble": "@[reducible, simp]\ndef multiply_precond (a : Int) (b : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def multiply (a : Int) (b : Int) (h_precond : multiply_precond (a) (b)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef multiply_postcond (a : Int) (b : Int) (result: Int) (h_precond : multiply_precond (a) (b)) :=\n  result - a * b = 0 ∧ a * b - result = 0\n\ntheorem multiply_spec_satisfied (a: Int) (b: Int) (h_precond : multiply_precond (a) (b)) :\n    multiply_postcond (a) (b) (multiply (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 4\n        },\n        \"expected\": 12,\n        \"unexpected\": [\n            0,\n            11,\n            15\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": -4\n        },\n        \"expected\": -12,\n        \"unexpected\": [\n            0,\n            -11,\n            12\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -3,\n            \"b\": 4\n        },\n        \"expected\": -12,\n        \"unexpected\": [\n            0,\n            -11,\n            12\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -3,\n            \"b\": -4\n        },\n        \"expected\": 12,\n        \"unexpected\": [\n            0,\n            11,\n            -12\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 5,\n            \"b\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0086", "language": "lean", "source": "verina", "source_id": "verina_basic_6_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef minOfThree_precond (a : Int) (b : Int) (c : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def minOfThree (a : Int) (b : Int) (c : Int) (h_precond : minOfThree_precond (a) (b) (c)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef minOfThree_postcond (a : Int) (b : Int) (c : Int) (result: Int) (h_precond : minOfThree_precond (a) (b) (c)) :=\n  (result <= a ∧ result <= b ∧ result <= c) ∧\n  (result = a ∨ result = b ∨ result = c)\n\ntheorem minOfThree_spec_satisfied (a: Int) (b: Int) (c: Int) (h_precond : minOfThree_precond (a) (b) (c)) :\n    minOfThree_postcond (a) (b) (c) (minOfThree (a) (b) (c) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 2,\n            \"c\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 5,\n            \"b\": 5,\n            \"c\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 10,\n            \"b\": 20,\n            \"c\": 15\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            15,\n            20,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -1,\n            \"b\": 2,\n            \"c\": 3\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            2,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 2,\n            \"b\": -3,\n            \"c\": 4\n        },\n        \"expected\": -3,\n        \"unexpected\": [\n            2,\n            4,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 2,\n            \"b\": 3,\n            \"c\": -5\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            2,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 0,\n            \"c\": 1\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": -1,\n            \"c\": 1\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -5,\n            \"b\": -2,\n            \"c\": -3\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            -2,\n            -3,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0087", "language": "lean", "source": "verina", "source_id": "verina_basic_7_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of odd natural numbers to consider (n should be non-negative).\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n-/", "vc-preamble": "@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def sumOfSquaresOfFirstNOddNumbers (n : Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumOfSquaresOfFirstNOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :=\n  result - (n * (2 * n - 1) * (2 * n + 1)) / 3 = 0 ∧\n  (n * (2 * n - 1) * (2 * n + 1)) / 3 - result = 0\n\ntheorem sumOfSquaresOfFirstNOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfSquaresOfFirstNOddNumbers_precond (n)) :\n    sumOfSquaresOfFirstNOddNumbers_postcond (n) (sumOfSquaresOfFirstNOddNumbers (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            9,\n            11,\n            12\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": 35,\n        \"unexpected\": [\n            30,\n            34,\n            36\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": 84,\n        \"unexpected\": [\n            80,\n            85,\n            90\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": 165,\n        \"unexpected\": [\n            160,\n            166,\n            170\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": 1330,\n        \"unexpected\": [\n            1320,\n            1331,\n            1340\n        ]\n    }\n]\n-/"}
{"id": "LV0088", "language": "lean", "source": "verina", "source_id": "verina_basic_8_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.\n\n-----Input-----\nThe input consists of two integers:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.\n-/", "vc-preamble": "@[reducible, simp]\ndef myMin_precond (a : Int) (b : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def myMin (a : Int) (b : Int) (h_precond : myMin_precond (a) (b)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myMin_postcond (a : Int) (b : Int) (result: Int) (h_precond : myMin_precond (a) (b)) :=\n  (result ≤ a ∧ result ≤ b) ∧\n  (result = a ∨ result = b)\n\ntheorem myMin_spec_satisfied (a: Int) (b: Int) (h_precond : myMin_precond (a) (b)) :\n    myMin_postcond (a) (b) (myMin (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 5\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            5,\n            4,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 10,\n            \"b\": 7\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            10,\n            8,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 4,\n            \"b\": 4\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            0,\n            8,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -3,\n            \"b\": 5\n        },\n        \"expected\": -3,\n        \"unexpected\": [\n            5,\n            0,\n            -5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": -5\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            3,\n            0,\n            -3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -3,\n            \"b\": -5\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            -3,\n            0,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": 10\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            10,\n            1,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 0,\n            \"b\": -10\n        },\n        \"expected\": -10,\n        \"unexpected\": [\n            0,\n            -1,\n            -5\n        ]\n    }\n]\n-/"}
{"id": "LV0089", "language": "lean", "source": "verina", "source_id": "verina_basic_9_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one common element between the two arrays.\nReturns false if there are no common elements shared by the arrays.\n\n-----Note-----\nBoth arrays are assumed to be non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef hasCommonElement_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0", "vc-helpers": "", "vc-definitions": "def hasCommonElement (a : Array Int) (b : Array Int) (h_precond : hasCommonElement_precond (a) (b)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasCommonElement_postcond (a : Array Int) (b : Array Int) (result: Bool) (h_precond : hasCommonElement_precond (a) (b)) :=\n  (∃ i j, i < a.size ∧ j < b.size ∧ a[i]! = b[j]!) ↔ result\n\ntheorem hasCommonElement_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : hasCommonElement_precond (a) (b)) :\n    hasCommonElement_postcond (a) (b) (hasCommonElement (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[3, 4, 5]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7, 8, 9]\",\n            \"b\": \"#[10, 11, 7]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[5, 6, 7, 8]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 1]\",\n            \"b\": \"#[1, 2, 1]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0]\",\n            \"b\": \"#[0]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0]\",\n            \"b\": \"#[-1, 1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0090", "language": "lean", "source": "verina", "source_id": "verina_basic_10_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\nn: An integer.\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the integer is greater than all elements in the array.\nReturns false if there is at least one element in the array that is greater than or equal to the integer.\n\n-----Note-----\nThe array is assumed to be non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef isGreater_precond (n : Int) (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "", "vc-definitions": "def isGreater (n : Int) (a : Array Int) (h_precond : isGreater_precond (n) (a)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isGreater_postcond (n : Int) (a : Array Int) (result: Bool) (h_precond : isGreater_precond (n) (a)) :=\n  (∀ i, (hi : i < a.size) → n > a[i]) ↔ result\n\ntheorem isGreater_spec_satisfied (n: Int) (a: Array Int) (h_precond : isGreater_precond (n) (a)) :\n    isGreater_postcond (n) (a) (isGreater (n) (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"n\": 0,\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 6,\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3,\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5,\n            \"a\": \"#[5, 5, 5]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -1,\n            \"a\": \"#[-10, -5, -3]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -3,\n            \"a\": \"#[-1, -2, -3]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0,\n            \"a\": \"#[0, -1, -2]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10,\n            \"a\": \"#[1, 2, 9, 3]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0091", "language": "lean", "source": "verina", "source_id": "verina_basic_11_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.\n\n-----Input-----\nThe input consists of a single value:\nn: A non-negative integer.\n\n-----Output-----\nThe output is an integer:\nReturns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.\n\n-----Note-----\nIt is assumed that the input number n is non-negative.\n-/", "vc-preamble": "@[reducible, simp]\ndef lastDigit_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def lastDigit (n : Nat) (h_precond : lastDigit_precond (n)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef lastDigit_postcond (n : Nat) (result: Nat) (h_precond : lastDigit_precond (n)) :=\n  (0 ≤ result ∧ result < 10) ∧\n  (n % 10 - result = 0 ∧ result - n % 10 = 0)\n\ntheorem lastDigit_spec_satisfied (n: Nat) (h_precond : lastDigit_precond (n)) :\n    lastDigit_postcond (n) (lastDigit (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 123\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            1,\n            23\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            10,\n            5,\n            9\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 987654321\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            9,\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            10,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 999\n        },\n        \"expected\": 9,\n        \"unexpected\": [\n            8,\n            99,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 45\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            0,\n            55\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 100\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            10,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            0,\n            6\n        ]\n    }\n]\n-/"}
{"id": "LV0092", "language": "lean", "source": "verina", "source_id": "verina_basic_12_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates the surface area of a cube based on the length of one of its edges. The method should compute the surface area using the standard formula for a cube.\n\n-----Input-----\nThe input consists of:\nsize: An natural number representing the length of an edge of the cube.\n\n-----Output-----\nThe output is an natural number:\nReturns the surface area of the cube.\n-/", "vc-preamble": "@[reducible, simp]\ndef cubeSurfaceArea_precond (size : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def cubeSurfaceArea (size : Nat) (h_precond : cubeSurfaceArea_precond (size)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef cubeSurfaceArea_postcond (size : Nat) (result: Nat) (h_precond : cubeSurfaceArea_precond (size)) :=\n  result - 6 * size * size = 0 ∧ 6 * size * size - result = 0\n\ntheorem cubeSurfaceArea_spec_satisfied (size: Nat) (h_precond : cubeSurfaceArea_precond (size)) :\n    cubeSurfaceArea_postcond (size) (cubeSurfaceArea (size) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"size\": 3\n        },\n        \"expected\": 54,\n        \"unexpected\": [\n            27,\n            48,\n            60\n        ]\n    },\n    {\n        \"input\": {\n            \"size\": 1\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"size\": 10\n        },\n        \"expected\": 600,\n        \"unexpected\": [\n            100,\n            500,\n            610\n        ]\n    },\n    {\n        \"input\": {\n            \"size\": 5\n        },\n        \"expected\": 150,\n        \"unexpected\": [\n            25,\n            100,\n            125\n        ]\n    },\n    {\n        \"input\": {\n            \"size\": 2\n        },\n        \"expected\": 24,\n        \"unexpected\": [\n            8,\n            16,\n            20\n        ]\n    }\n]\n-/"}
{"id": "LV0093", "language": "lean", "source": "verina", "source_id": "verina_basic_13_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.\n\n-----Input-----\nThe input consists of:\na: An array of integers (which may be empty or non-empty).\n\n-----Output-----\nThe output is an array of integers:\nReturns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.\n\n-----Note-----\nThere are no additional preconditions; the method should work correctly for any array of integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef cubeElements_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def cubeElements (a : Array Int) (h_precond : cubeElements_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef cubeElements_postcond (a : Array Int) (result: Array Int) (h_precond : cubeElements_precond (a)) :=\n  (result.size = a.size) ∧\n  (∀ i, i < a.size → result[i]! = a[i]! * a[i]! * a[i]!)\n\ntheorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :\n    cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\"\n        },\n        \"expected\": \"#[1, 8, 27, 64]\",\n        \"unexpected\": [\n            \"#[1, 4, 9, 16]\",\n            \"#[1, 8, 27, 63]\",\n            \"#[0, 0, 0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, -1, -2, 3]\"\n        },\n        \"expected\": \"#[0, -1, -8, 27]\",\n        \"unexpected\": [\n            \"#[0, 1, 8, -27]\",\n            \"#[0, -1, -8, 26]\",\n            \"#[1, -1, -8, 27]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[-1]\",\n            \"#[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5]\"\n        },\n        \"expected\": \"#[125]\",\n        \"unexpected\": [\n            \"#[5]\",\n            \"#[25]\",\n            \"#[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-3, -3]\"\n        },\n        \"expected\": \"#[-27, -27]\",\n        \"unexpected\": [\n            \"#[27, 27]\",\n            \"#[-9, -9]\",\n            \"#[-27, 27]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0094", "language": "lean", "source": "verina", "source_id": "verina_basic_14_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input string contains the character 'z' or 'Z'.\nReturns false if the input string does not contain the character 'z' or 'Z'.\n\n-----Note-----\nThere are no preconditions; the method will always work as strings and sequences are considered non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef containsZ_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def containsZ (s : String) (h_precond : containsZ_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef containsZ_postcond (s : String) (result: Bool) (h_precond : containsZ_precond (s)) :=\n  let cs := s.toList\n  (∃ x, x ∈ cs ∧ (x = 'z' ∨ x = 'Z')) ↔ result\n\ntheorem containsZ_spec_satisfied (s: String) (h_precond : containsZ_precond (s)) :\n    containsZ_postcond (s) (containsZ (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"hello\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"zebra\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Zebra\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"crazy\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"AZ\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Zz\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"no letter\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0095", "language": "lean", "source": "verina", "source_id": "verina_basic_15_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers (the array may be empty or non-empty).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one index where an element plus one equals the following element.\nReturns false if the array does not contain any consecutive numbers.\n\n-----Note-----\nThere are no additional preconditions; the method will function correctly regardless of the array's size.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef containsConsecutiveNumbers_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def containsConsecutiveNumbers (a : Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef containsConsecutiveNumbers_postcond (a : Array Int) (result: Bool) (h_precond : containsConsecutiveNumbers_precond (a)) :=\n  (∃ i, i < a.size - 1 ∧ a[i]! + 1 = a[i + 1]!) ↔ result\n\ntheorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :\n    containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 5]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 6]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 7, 8, 10]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[9, 9, 10]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, 3, 3]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0096", "language": "lean", "source": "verina", "source_id": "verina_basic_16_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that replaces every occurrence of a specified character within a string with a new character. The output should be a new string that maintains the same length as the input string, with all instances of the designated character replaced by the given substitute, and all other characters preserved unchanged.\n\n-----Input-----\nThe input consists of:\ns: A string in which the replacement will occur.\noldChar: The character within the string that needs to be replaced.\nnewChar: The character that will substitute for every occurrence of oldChar.\n\n-----Output-----\nThe output is a string that meets the following:\n- It has the same length as the input string.\n- All occurrences of oldChar in the input string are replaced with newChar.\n- All characters other than oldChar remain unchanged.\n\n-----Note-----\nThere are no preconditions; the method will always work. It is assumed that the input string is valid and non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef replaceChars_precond (s : String) (oldChar : Char) (newChar : Char) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def replaceChars (s : String) (oldChar : Char) (newChar : Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) : String :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceChars_postcond (s : String) (oldChar : Char) (newChar : Char) (result: String) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < cs.length →\n    (cs[i]! = oldChar → cs'[i]! = newChar) ∧\n    (cs[i]! ≠ oldChar → cs'[i]! = cs[i]!))\n\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"hello, world!\",\n            \"oldChar\": \",\",\n            \"newChar\": \";\"\n        },\n        \"expected\": \"hello; world!\",\n        \"unexpected\": [\n            \"hello, world!\",\n            \"hello world!\",\n            \"hello;world!\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"a,b.c\",\n            \"oldChar\": \",\",\n            \"newChar\": \":\"\n        },\n        \"expected\": \"a:b.c\",\n        \"unexpected\": [\n            \"a,b.c\",\n            \"a;b.c\",\n            \"ab:c\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"hello, world!\",\n            \"oldChar\": \"o\",\n            \"newChar\": \"O\"\n        },\n        \"expected\": \"hellO, wOrld!\",\n        \"unexpected\": [\n            \"hello, world!\",\n            \"hellO, world!\",\n            \"hello, wOrld!\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\",\n            \"oldChar\": \"x\",\n            \"newChar\": \"y\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \" \",\n            \"abc\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"test\",\n            \"oldChar\": \"x\",\n            \"newChar\": \"y\"\n        },\n        \"expected\": \"test\",\n        \"unexpected\": [\n            \"testy\",\n            \"tset\",\n            \"yxest\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"unchanged\",\n            \"oldChar\": \"u\",\n            \"newChar\": \"u\"\n        },\n        \"expected\": \"unchanged\",\n        \"unexpected\": [\n            \"nchanged\",\n            \"unchanged!\",\n            \"unchangEd\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"aaa\",\n            \"oldChar\": \"a\",\n            \"newChar\": \"b\"\n        },\n        \"expected\": \"bbb\",\n        \"unexpected\": [\n            \"aaa\",\n            \"abb\",\n            \"bba\"\n        ]\n    }\n]\n-/"}
{"id": "LV0097", "language": "lean", "source": "verina", "source_id": "verina_basic_17_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n-/", "vc-preamble": "@[reducible, simp]\ndef toLowercase_precond (s : String) : Prop :=\n  True", "vc-helpers": "def isUpperCase (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\ndef shift32 (c : Char) : Char :=\n  Char.ofNat (c.toNat + 32)", "vc-definitions": "def toLowercase (s : String) (h_precond : toLowercase_precond (s)) : String :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef toLowercase_postcond (s : String) (result: String) (h_precond : toLowercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i : Nat, i < s.length →\n    (isUpperCase cs[i]! → cs'[i]! = shift32 cs[i]!) ∧\n    (¬isUpperCase cs[i]! → cs'[i]! = cs[i]!))\n\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"Hello, World!\"\n        },\n        \"expected\": \"hello, world!\",\n        \"unexpected\": [\n            \"Hello, world!\",\n            \"HELLO, WORLD!\",\n            \"hello, World!\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"ABC\"\n        },\n        \"expected\": \"abc\",\n        \"unexpected\": [\n            \"ABC\",\n            \"Abc\",\n            \"aBC\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\"\n        },\n        \"expected\": \"abc\",\n        \"unexpected\": [\n            \"ABC\",\n            \"aBc\",\n            \"abC\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \" \",\n            \"empty\",\n            \"null\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"1234!@\"\n        },\n        \"expected\": \"1234!@\",\n        \"unexpected\": [\n            \"1234!#\",\n            \"12345!@\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"MixedCASE123\"\n        },\n        \"expected\": \"mixedcase123\",\n        \"unexpected\": [\n            \"Mixedcase123\",\n            \"mixedCASE123\",\n            \"MIXEDCASE123\"\n        ]\n    }\n]\n-/"}
{"id": "LV0098", "language": "lean", "source": "verina", "source_id": "verina_basic_18_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.\n\n-----Input-----\nThe input consists of:\nn: A non-negative integer.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the digits of the input integer.\n\n-----Note-----\nThe input is assumed to be a valid non-negative integer.\n-/", "vc-preamble": "@[reducible, simp]\ndef sumOfDigits_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def sumOfDigits (n : Nat) (h_precond : sumOfDigits_precond (n)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumOfDigits_postcond (n : Nat) (result: Nat) (h_precond : sumOfDigits_precond (n)) :=\n  result - List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) = 0 ∧\n  List.sum (List.map (fun c => Char.toNat c - Char.toNat '0') (String.toList (Nat.repr n))) - result = 0\n\ntheorem sumOfDigits_spec_satisfied (n: Nat) (h_precond : sumOfDigits_precond (n)) :\n    sumOfDigits_postcond (n) (sumOfDigits (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 12345\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            12,\n            16,\n            14\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            10,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 987654321\n        },\n        \"expected\": 45,\n        \"unexpected\": [\n            44,\n            46,\n            50\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 11111\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            6,\n            4,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1001\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            11\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9999\n        },\n        \"expected\": 36,\n        \"unexpected\": [\n            35,\n            37,\n            34\n        ]\n    }\n]\n-/"}
{"id": "LV0099", "language": "lean", "source": "verina", "source_id": "verina_basic_19_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.\n\n-----Input-----\nThe input consists of:\na: An array of integers. The array can be empty or have any length.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is sorted in non-decreasing order.\nReturns false if the array is not sorted in non-decreasing order.\n\n-----Note-----\nA true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.\n-/", "vc-preamble": "@[reducible, simp]\ndef isSorted_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isSorted (a : Array Int) (h_precond : isSorted_precond (a)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSorted_postcond (a : Array Int) (result: Bool) (h_precond : isSorted_precond (a)) :=\n  (∀ i, (hi : i < a.size - 1) → a[i] ≤ a[i + 1]) ↔ result\n\ntheorem isSorted_spec_satisfied (a: Array Int) (h_precond : isSorted_precond (a)) :\n    isSorted_postcond (a) (isSorted (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 4, 3, 2, 1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 2, 4, 5]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 2, 2, 2]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 2, 3]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0100", "language": "lean", "source": "verina", "source_id": "verina_basic_20_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.\n-/", "vc-preamble": "import Std.Data.HashSet\n\n@[reducible, simp]\ndef uniqueProduct_precond (arr : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def uniqueProduct (arr : Array Int) (h_precond : uniqueProduct_precond (arr)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef uniqueProduct_postcond (arr : Array Int) (result: Int) (h_precond : uniqueProduct_precond (arr)) :=\n  result - (arr.toList.eraseDups.foldl (· * ·) 1) = 0 ∧\n  (arr.toList.eraseDups.foldl (· * ·) 1) - result = 0\n\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[2, 3, 2, 4]\"\n        },\n        \"expected\": 24,\n        \"unexpected\": [\n            12,\n            30,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[5, 5, 5, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            25,\n            0,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, 2, 3]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-1, -2, -1, -3]\"\n        },\n        \"expected\": -6,\n        \"unexpected\": [\n            -1,\n            6,\n            -3\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[10, 10, 20, 20, 30]\"\n        },\n        \"expected\": 6000,\n        \"unexpected\": [\n            600,\n            0,\n            5000\n        ]\n    }\n]\n-/"}
{"id": "LV0101", "language": "lean", "source": "verina", "source_id": "verina_basic_21_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.\n\n-----Input-----\nThe input consists of two lists of integers:\nsub: A list of integers representing the potential sublist.\nmain: A list of integers in which to search for the sublist.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the first list appears as a contiguous sequence within the second list.\nReturns false if the first list does not appear as a contiguous sequence in the second list.\n\n-----Note-----\nThere are no preconditions for this method; the sequences are always non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef isSublist_precond (sub : List Int) (main : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isSublist (sub : List Int) (main : List Int) (h_precond : isSublist_precond (sub) (main)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSublist_postcond (sub : List Int) (main : List Int) (result: Bool) (h_precond : isSublist_precond (sub) (main)) :=\n  (∃ i, i + sub.length ≤ main.length ∧ sub = (main.drop i).take sub.length) ↔ result\n\ntheorem isSublist_spec_satisfied (sub: List Int) (main: List Int) (h_precond : isSublist_precond (sub) (main)) :\n    isSublist_postcond (sub) (main) (isSublist (sub) (main) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"sub\": \"[1, 2]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[2, 3]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[3, 1]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[4]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[5]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[]\",\n            \"main\": \"[3, 1, 2, 4]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[1, 2]\",\n            \"main\": \"[]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"sub\": \"[]\",\n            \"main\": \"[]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0102", "language": "lean", "source": "verina", "source_id": "verina_basic_22_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that identifies the dissimilar elements between two arrays of integers. In other words, the method should return an array containing all elements that appear in one input array but not in the other. The output array must contain no duplicate elements and the order of elements does not matter.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all distinct elements from both input arrays that are not present in the other array and should be sorted\n-/", "vc-preamble": "import Std.Data.HashSet\n\n@[reducible, simp]\ndef dissimilarElements_precond (a : Array Int) (b : Array Int) : Prop :=\n  True", "vc-helpers": "def inArray (a : Array Int) (x : Int) : Bool :=\n  a.any (fun y => y = x)", "vc-definitions": "def dissimilarElements (a : Array Int) (b : Array Int) (h_precond : dissimilarElements_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef dissimilarElements_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :=\n  result.all (fun x => inArray a x ≠ inArray b x)∧\n  result.toList.Pairwise (· ≤ ·) ∧\n  a.all (fun x => if x ∈ b then x ∉ result else x ∈ result) ∧\n  b.all (fun x => if x ∈ a then x ∉ result else x ∈ result)\n\ntheorem dissimilarElements_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : dissimilarElements_precond (a) (b)) :\n    dissimilarElements_postcond (a) (b) (dissimilarElements (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[3, 4, 5, 6]\"\n        },\n        \"expected\": \"#[1, 2, 5, 6]\",\n        \"unexpected\": [\n            \"#[1,2,3,4,5,6]\",\n            \"#[3,4]\",\n            \"#[1,3,5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 2]\",\n            \"b\": \"#[2, 3]\"\n        },\n        \"expected\": \"#[1, 3]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[3]\",\n            \"#[1,2,3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[4, 5]\"\n        },\n        \"expected\": \"#[4, 5]\",\n        \"unexpected\": [\n            \"#[4]\",\n            \"#[5]\",\n            \"#[]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7, 8]\",\n            \"b\": \"#[]\"\n        },\n        \"expected\": \"#[7, 8]\",\n        \"unexpected\": [\n            \"#[7]\",\n            \"#[8]\",\n            \"#[7, 8, 9]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[1,2]\",\n            \"#[1,2,3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5, 6]\",\n        \"unexpected\": [\n            \"#[1,2,3,4]\",\n            \"#[4,5,6]\",\n            \"#[1,2,3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, 0, 1]\",\n            \"b\": \"#[0]\"\n        },\n        \"expected\": \"#[-1, 1]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[-1,0,1]\",\n            \"#[-1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0103", "language": "lean", "source": "verina", "source_id": "verina_basic_23_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates the difference between the maximum and minimum values in an array of integers. In other words, the method should determine the highest and lowest numbers in the array and return the result of subtracting the minimum from the maximum.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference between the largest and the smallest values in the input array.\n\n-----Note-----\nThe input array is assumed to be non-empty.\n-/", "vc-preamble": "@[reducible, simp]\ndef differenceMinMax_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "", "vc-definitions": "def differenceMinMax (a : Array Int) (h_precond : differenceMinMax_precond (a)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef differenceMinMax_postcond (a : Array Int) (result: Int) (h_precond : differenceMinMax_precond (a)) :=\n  result + (a.foldl (fun acc x => if x < acc then x else acc) (a[0]!)) = (a.foldl (fun acc x => if x > acc then x else acc) (a[0]!))\n\ntheorem differenceMinMax_spec_satisfied (a: Array Int) (h_precond : differenceMinMax_precond (a)) :\n    differenceMinMax_postcond (a) (differenceMinMax (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\"\n        },\n        \"expected\": 8,\n        \"unexpected\": [\n            7,\n            9,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30, 40, 50]\"\n        },\n        \"expected\": 40,\n        \"unexpected\": [\n            30,\n            35,\n            45\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-10, -20, -30, -40, -50]\"\n        },\n        \"expected\": 40,\n        \"unexpected\": [\n            30,\n            41,\n            20\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 5, 5, 5]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            5,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, -1, 2, -2]\"\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            0,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0104", "language": "lean", "source": "verina", "source_id": "verina_basic_24_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference computed as the first even number minus the first odd number found in the array.\n\n-----Note-----\nThe input array is assumed to be non-empty and to contain at least one even number and one odd number.\n-/", "vc-preamble": "def isEven (n : Int) : Bool :=\nn % 2 == 0\n\ndef isOdd (n : Int) : Bool :=\nn % 2 != 0\n\n@[reducible, simp]\ndef firstEvenOddDifference_precond (a : Array Int) : Prop :=\n  a.size > 1 ∧\n  (∃ x ∈ a, isEven x) ∧\n  (∃ x ∈ a, isOdd x)", "vc-helpers": "", "vc-definitions": "def firstEvenOddDifference (a : Array Int) (h_precond : firstEvenOddDifference_precond (a)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef firstEvenOddDifference_postcond (a : Array Int) (result: Int) (h_precond : firstEvenOddDifference_precond (a)) :=\n  ∃ i j, i < a.size ∧ j < a.size ∧ isEven (a[i]!) ∧ isOdd (a[j]!) ∧\n    result = a[i]! - a[j]! ∧\n    (∀ k, k < i → isOdd (a[k]!)) ∧ (∀ k, k < j → isEven (a[k]!))\n\ntheorem firstEvenOddDifference_spec_satisfied (a: Array Int) (h_precond : firstEvenOddDifference_precond (a)) :\n    firstEvenOddDifference_postcond (a) (firstEvenOddDifference (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[2]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[2, 3, 4, 5]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            -2,\n            1,\n            -3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 4, 6, 8]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7, 2, 9, 4]\"\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            -3,\n            -6,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 2, 3, 3]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            1,\n            0,\n            -2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 2, 2]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            -1\n        ]\n    }\n]\n-/"}
{"id": "LV0105", "language": "lean", "source": "verina", "source_id": "verina_basic_25_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.\n\n-----Output-----\nThe output is a pair consisting of:\n- An integer representing the sum of the first n natural numbers.\n- A floating-point number representing the average of the first n natural numbers.\n\n-----Note-----\nThe input n must be a positive integer.\n-/", "vc-preamble": "@[reducible, simp]\ndef sumAndAverage_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def sumAndAverage (n : Nat) (h_precond : sumAndAverage_precond (n)) : Int × Float :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumAndAverage_postcond (n : Nat) (result: Int × Float) (h_precond : sumAndAverage_precond (n)) :=\n  (n = 0 → result == (0, 0.0)) ∧\n  (n > 0 →\n    result.1 == n * (n + 1) / 2 ∧\n    result.2 == ((n * (n + 1) / 2).toFloat) / (n.toFloat))\n\ntheorem sumAndAverage_spec_satisfied (n: Nat) (h_precond : sumAndAverage_precond (n)) :\n    sumAndAverage_postcond (n) (sumAndAverage (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": \"(15, 3.0)\",\n        \"unexpected\": [\n            \"(14, 2.8)\",\n            \"(16, 3.2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": \"(1, 1.0)\",\n        \"unexpected\": [\n            \"(0, 0.0)\",\n            \"(2, 2.0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": \"(55, 5.5)\",\n        \"unexpected\": [\n            \"(50, 5.0)\",\n            \"(60, 6.0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": \"(0, 0.0)\",\n        \"unexpected\": [\n            \"(1, 0.1)\",\n            \"(-1, -0.1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": \"(3, 1.5)\",\n        \"unexpected\": [\n            \"(2, 1.0)\",\n            \"(4, 2.0)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0106", "language": "lean", "source": "verina", "source_id": "verina_basic_26_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.\n\n-----Input-----\nThe input consists of:\nn: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is even.\nReturns false if the input number is odd.\n\n-----Note-----\nThere are no preconditions; the method will always work for any integer input.\n-/", "vc-preamble": "@[reducible, simp]\ndef isEven_precond (n : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isEven (n : Int) (h_precond : isEven_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isEven_postcond (n : Int) (result: Bool) (h_precond : isEven_precond (n)) :=\n  (result → n % 2 = 0) ∧ (¬ result → n % 2 ≠ 0)\n\ntheorem isEven_spec_satisfied (n: Int) (h_precond : isEven_precond (n)) :\n    isEven_postcond (n) (isEven (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 7\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -2\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": -3\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0107", "language": "lean", "source": "verina", "source_id": "verina_basic_27_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that identifies the first repeated character in a given string. The method should return a tuple containing a Boolean value and a character. The Boolean value indicates whether any character in the string is repeated. If it is true, the accompanying character is the first character that appears more than once. If it is false, it indicates that there are no repeated characters in the string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a tuple (Bool × Char):\n- Returns true and the first repeated character in the string if any repeated character is found.\n- Returns false and an arbitrary character if no repeated characters are present.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n-/", "vc-preamble": "import Std.Data.HashSet\n\n@[reducible, simp]\ndef findFirstRepeatedChar_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def findFirstRepeatedChar (s : String) (h_precond : findFirstRepeatedChar_precond (s)) : Option Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findFirstRepeatedChar_postcond (s : String) (result: Option Char) (h_precond : findFirstRepeatedChar_precond (s)) :=\n  let cs := s.toList\n  match result with\n  | some c =>\n    let secondIdx := cs.zipIdx.findIdx (fun (x, i) => x = c && i ≠ cs.idxOf c)\n    -- Exists repeated char\n    cs.count c ≥ 2 ∧\n    -- There is no other repeated char before the found one\n    List.Pairwise (· ≠ ·) (cs.take secondIdx)\n  | none =>\n    -- There is no repeated char\n    List.Pairwise (· ≠ ·) cs\n\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"abca\"\n        },\n        \"expected\": \"some ('a')\",\n        \"unexpected\": [\n            \"some ('b')\",\n            \"some ('c')\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abcdef\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some ('a')\",\n            \"some ('z')\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"aabbcc\"\n        },\n        \"expected\": \"some ('a')\",\n        \"unexpected\": [\n            \"some ('b')\",\n            \"some ('c')\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some ('x')\",\n            \"some ('y')\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abbc\"\n        },\n        \"expected\": \"some ('b')\",\n        \"unexpected\": [\n            \"some ('a')\",\n            \"some ('c')\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"Aa\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some ('A')\",\n            \"some ('a')\"\n        ]\n    }\n]\n-/"}
{"id": "LV0108", "language": "lean", "source": "verina", "source_id": "verina_basic_28_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given natural number is prime. A number (with n ≥ 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: A natural number (Nat) such that n ≥ 2.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).\nReturns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).\n\n-----Note-----\nThe input is expected to satisfy the condition n ≥ 2.\n-/", "vc-preamble": "@[reducible, simp]\ndef isPrime_precond (n : Nat) : Prop :=\n  n ≥ 2", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) (h_precond : isPrime_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isPrime_postcond (n : Nat) (result: Bool) (h_precond : isPrime_precond (n)) :=\n  (result → (List.range' 2 (n - 2)).all (fun k => n % k ≠ 0)) ∧\n  (¬ result → (List.range' 2 (n - 2)).any (fun k => n % k = 0))\n\ntheorem isPrime_spec_satisfied (n: Nat) (h_precond : isPrime_precond (n)) :\n    isPrime_postcond (n) (isPrime (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"n\": 0\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 11\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 12\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 13\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    }\n]\n-/"}
{"id": "LV0109", "language": "lean", "source": "verina", "source_id": "verina_basic_29_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that removes an element from a given array of integers at a specified index. The resulting array should contain all the original elements except for the one at the given index. Elements before the removed element remain unchanged, and elements after it are shifted one position to the left.\n\n-----Input-----\nThe input consists of:\n• s: An array of integers.\n• k: A natural number representing the index of the element to remove (0-indexed).\n\n-----Output-----\nThe output is an array of integers that:\n• Has a length one less than the input array.\n• Contains the same elements as the input array, except that the element at index k is omitted.\n• Preserves the original order with elements after the removed element shifted left by one position.\n\n-----Note-----\nIt is assumed that k is a valid index (0 ≤ k < the length of the array).\n-/", "vc-preamble": "@[reducible, simp]\ndef removeElement_precond (s : Array Int) (k : Nat) : Prop :=\n  k < s.size", "vc-helpers": "", "vc-definitions": "def removeElement (s : Array Int) (k : Nat) (h_precond : removeElement_precond (s) (k)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeElement_postcond (s : Array Int) (k : Nat) (result: Array Int) (h_precond : removeElement_precond (s) (k)) :=\n  result.size = s.size - 1 ∧\n  (∀ i, i < k → result[i]! = s[i]!) ∧\n  (∀ i, i < result.size → i ≥ k → result[i]! = s[i + 1]!)\n\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"s\": \"#[1]\",\n            \"k\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"#[1, 2, 3, 4, 5]\",\n            \"k\": 2\n        },\n        \"expected\": \"#[1, 2, 4, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 5]\",\n            \"#[1, 3, 4, 5]\",\n            \"#[2, 3, 4, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[10, 20, 30, 40]\",\n            \"k\": 0\n        },\n        \"expected\": \"#[20, 30, 40]\",\n        \"unexpected\": [\n            \"#[10, 30, 40]\",\n            \"#[10, 20, 30, 40]\",\n            \"#[20, 30, 40, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[10, 20, 30, 40]\",\n            \"k\": 3\n        },\n        \"expected\": \"#[10, 20, 30]\",\n        \"unexpected\": [\n            \"#[20, 30, 40]\",\n            \"#[10, 20, 40]\",\n            \"#[10, 30, 40]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[7]\",\n            \"k\": 0\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[7]\",\n            \"#[0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0110", "language": "lean", "source": "verina", "source_id": "verina_basic_30_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\n-----Note-----\nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.\n-/", "vc-preamble": "@[reducible, simp]\ndef elementWiseModulo_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size ∧ a.size > 0 ∧\n  (∀ i, i < b.size → b[i]! ≠ 0)", "vc-helpers": "", "vc-definitions": "def elementWiseModulo (a : Array Int) (b : Array Int) (h_precond : elementWiseModulo_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseModulo_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :=\n  result.size = a.size ∧\n  (∀ i, i < result.size → result[i]! = a[i]! % b[i]!)\n\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1]\",\n            \"b\": \"#[4, 0]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30]\",\n            \"b\": \"#[3, 7, 5]\"\n        },\n        \"expected\": \"#[1, 6, 0]\",\n        \"unexpected\": [\n            \"#[1, 0, 0]\",\n            \"#[0, 6, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[100, 200, 300, 400]\",\n            \"b\": \"#[10, 20, 30, 50]\"\n        },\n        \"expected\": \"#[0, 0, 0, 0]\",\n        \"unexpected\": [\n            \"#[0, 0, 0, 1]\",\n            \"#[1, 0, 0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-10, -20, 30]\",\n            \"b\": \"#[3, -7, 5]\"\n        },\n        \"expected\": \"#[2, 1, 0]\",\n        \"unexpected\": [\n            \"#[-1, -5, 0]\",\n            \"#[-1, -6, 1]\",\n            \"#[0, -6, 0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0111", "language": "lean", "source": "verina", "source_id": "verina_basic_31_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a string:\nReturns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.\n\n-----Note-----\nThere are no preconditions since the method assumes that the input string is always valid (i.e., non-null).\n-/", "vc-preamble": "@[reducible, simp]\ndef toUppercase_precond (s : String) : Prop :=\n  True", "vc-helpers": "def isLowerCase (c : Char) : Bool :=\n  'a' ≤ c ∧ c ≤ 'z'\n\ndef shiftMinus32 (c : Char) : Char :=\n  Char.ofNat ((c.toNat - 32) % 128)", "vc-definitions": "def toUppercase (s : String) (h_precond : toUppercase_precond (s)) : String :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef toUppercase_postcond (s : String) (result: String) (h_precond : toUppercase_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) ∧\n  (∀ i, i < s.length →\n    (isLowerCase cs[i]! → cs'[i]! = shiftMinus32 cs[i]!) ∧\n    (¬isLowerCase cs[i]! → cs'[i]! = cs[i]!))\n\ntheorem toUppercase_spec_satisfied (s: String) (h_precond : toUppercase_precond (s)) :\n    toUppercase_postcond (s) (toUppercase (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"Hello, World!\"\n        },\n        \"expected\": \"HELLO, WORLD!\",\n        \"unexpected\": [\n            \"hello, world!\",\n            \"HeLLo, WORld!\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\"\n        },\n        \"expected\": \"ABC\",\n        \"unexpected\": [\n            \"AbC\",\n            \"abc\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"ABC\"\n        },\n        \"expected\": \"ABC\",\n        \"unexpected\": [\n            \"abc\",\n            \"aBC\",\n            \"Abc\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"123!?@\"\n        },\n        \"expected\": \"123!?@\",\n        \"unexpected\": [\n            \"123!@?\",\n            \"321!?@\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \" \",\n            \"a\"\n        ]\n    }\n]\n-/"}
{"id": "LV0112", "language": "lean", "source": "verina", "source_id": "verina_basic_32_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.\n\n-----Input-----\nThe input consists of:\na: An array of integers (assumed to be non-empty).\n\n-----Output-----\nThe output is an array of integers:\nReturns a new array where:\n- The former last element becomes the first element.\n- The former first element becomes the last element.\n- All other elements remain unchanged.\n-/", "vc-preamble": "import Mathlib\n\ndef swapFirstAndLast_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "", "vc-definitions": "def swapFirstAndLast (a : Array Int) (h_precond: swapFirstAndLast_precond a) : Array Int :=\n  sorry", "vc-theorems": "-- Theorem: The last element of the input array should be the first element of the modified array; The first element of the input array should be the last element of the modified array; All other elements remain unchanged\n@[reducible, simp]\ndef swapFirstAndLast_postcond (a : Array Int) (result : Array Int) (h_precond: swapFirstAndLast_precond a) : Prop :=\n  result.size = a.size ∧\n  result[0]! = a[a.size - 1]! ∧\n  result[result.size - 1]! = a[0]! ∧\n  (List.range (result.size - 2)).all (fun i => result[i + 1]! = a[i + 1]!)\n\ntheorem swapFirstAndLast_spec_satisfied (a : Array Int) (h_precond: swapFirstAndLast_precond a) :\n    swapFirstAndLast_postcond a (swapFirstAndLast a h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"#[5, 2, 3, 4, 1]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[5, 4, 3, 2, 1]\",\n            \"#[2, 3, 4, 5, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\"\n        },\n        \"expected\": \"#[10]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[5]\",\n            \"#[11]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2]\"\n        },\n        \"expected\": \"#[2, 1]\",\n        \"unexpected\": [\n            \"#[1, 2]\",\n            \"#[2, 2]\",\n            \"#[1, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[3, 2, 1]\",\n        \"unexpected\": [\n            \"#[1, 2, 3]\",\n            \"#[3, 1, 2]\",\n            \"#[2, 1, 3]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0113", "language": "lean", "source": "verina", "source_id": "verina_basic_33_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that returns the smallest natural number missing from a given sorted list of natural numbers. In other words, starting from 0, the method should identify the first natural number that does not appear in the list. The input list is assumed to be sorted in non-decreasing order and contains only natural numbers (including 0).\n\n-----Input-----\nThe input consists of:\ns: A list of natural numbers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that does not appear in the input list.\n\n-----Note-----\nIt is assumed that the input list is sorted and contains only natural numbers.\n-/", "vc-preamble": "@[reducible, simp]\ndef smallestMissingNumber_precond (s : List Nat) : Prop :=\n  List.Pairwise (· ≤ ·) s", "vc-helpers": "", "vc-definitions": "def smallestMissingNumber (s : List Nat) (h_precond : smallestMissingNumber_precond (s)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef smallestMissingNumber_postcond (s : List Nat) (result: Nat) (h_precond : smallestMissingNumber_precond (s)) :=\n  ¬ List.elem result s ∧ (∀ k : Nat, k < result → List.elem k s)\n\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"s\": \"[3, 2, 1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"[0, 1, 2, 6, 9]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[4, 5, 10, 11]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[0, 1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[0, 2, 3, 4]\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0114", "language": "lean", "source": "verina", "source_id": "verina_basic_34_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all the even numbers from the input array. Specifically:\n- Every element in the output array is an even integer.\n- All even integers present in the input array are included in the output array.\n- The relative order of the even integers is preserved as in the input array.\n\n-----Note-----\nThere are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).\n-/", "vc-preamble": "@[reducible, simp]\ndef findEvenNumbers_precond (arr : Array Int) : Prop :=\n  True", "vc-helpers": "def isEven (n : Int) : Bool :=\n  n % 2 = 0", "vc-definitions": "def findEvenNumbers (arr : Array Int) (h_precond : findEvenNumbers_precond (arr)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : findEvenNumbers_precond (arr)) :=\n  (∀ x, x ∈ result → isEven x ∧ x ∈ arr.toList) ∧\n  (∀ x, x ∈ arr.toList → isEven x → x ∈ result) ∧\n  (∀ x y, x ∈ arr.toList → y ∈ arr.toList →\n    isEven x → isEven y →\n    arr.toList.idxOf x ≤ arr.toList.idxOf y →\n    result.toList.idxOf x ≤ result.toList.idxOf y)\n\ntheorem findEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5, 6]\"\n        },\n        \"expected\": \"#[2, 4, 6]\",\n        \"unexpected\": [\n            \"#[1, 2, 3]\",\n            \"#[2, 3, 4, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[7, 8, 10, 13, 14]\"\n        },\n        \"expected\": \"#[8, 10, 14]\",\n        \"unexpected\": [\n            \"#[7, 8, 10]\",\n            \"#[8, 14]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 3, 5, 7]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, -2, -3, -4, 5]\"\n        },\n        \"expected\": \"#[0, -2, -4]\",\n        \"unexpected\": [\n            \"#[0, -3, -4]\",\n            \"#[-2, -4]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0115", "language": "lean", "source": "verina", "source_id": "verina_basic_35_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that rearranges an array of integers by moving all zero values to the end of the array. The method should ensure that the relative order of the non-zero elements remains the same, the overall size of the array is unchanged, and the number of zeroes in the array stays constant.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array where:\n- The length is the same as that of the input array.\n- All zero values are positioned at the end.\n- The relative order of non-zero elements is preserved.\n- The count of zero values remains the same as in the input array.\n\n-----Note-----\nThere are no preconditions; the method will always work for any array of integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef MoveZeroesToEnd_precond (arr : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def MoveZeroesToEnd (arr : Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef MoveZeroesToEnd_postcond (arr : Array Int) (result: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :=\n  let firstResZeroIdx := result.toList.idxOf 0\n  List.isPerm result.toList arr.toList ∧\n  result.toList.take firstResZeroIdx = arr.toList.filter (· ≠ 0) ∧\n  result.toList.drop firstResZeroIdx = arr.toList.filter (· = 0)\n\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[0, 1, 0, 3, 12]\"\n        },\n        \"expected\": \"#[1, 3, 12, 0, 0]\",\n        \"unexpected\": [\n            \"#[0, 1, 0, 3, 12]\",\n            \"#[1, 0, 3, 12, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, 0, 1]\"\n        },\n        \"expected\": \"#[1, 0, 0]\",\n        \"unexpected\": [\n            \"#[0, 0, 1]\",\n            \"#[0, 1, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[1, 3, 2]\",\n            \"#[2, 1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, 0, 0]\"\n        },\n        \"expected\": \"#[0, 0, 0]\",\n        \"unexpected\": [\n            \"#[1, 0, 0]\",\n            \"#[0, 1, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0116", "language": "lean", "source": "verina", "source_id": "verina_basic_36_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string’s length and leave all other characters unmodified.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a string:\n- The returned string must have the same length as the input string.\n- Every space, comma, or dot in the input string is replaced with a colon.\n- All other characters remain unchanged.\n\n-----Note-----\nThere are no preconditions; the input string is assumed to be non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef replaceWithColon_precond (s : String) : Prop :=\n  True", "vc-helpers": "def isSpaceCommaDot (c : Char) : Bool :=\n  if c = ' ' then true\n  else if c = ',' then true\n  else if c = '.' then true\n  else false", "vc-definitions": "def replaceWithColon (s : String) (h_precond : replaceWithColon_precond (s)) : String :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceWithColon_postcond (s : String) (result: String) (h_precond : replaceWithColon_precond (s)) :=\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length ∧\n  (∀ i, i < s.length →\n    (isSpaceCommaDot cs[i]! → cs'[i]! = ':') ∧\n    (¬isSpaceCommaDot cs[i]! → cs'[i]! = cs[i]!))\n\ntheorem replaceWithColon_spec_satisfied (s: String) (h_precond : replaceWithColon_precond (s)) :\n    replaceWithColon_postcond (s) (replaceWithColon (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"Hello, world. How are you?\"\n        },\n        \"expected\": \"Hello::world::How:are:you?\",\n        \"unexpected\": [\n            \"Hello,world,How,are,you?\",\n            \"Hello: world: How: are: you?\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"No-changes!\"\n        },\n        \"expected\": \"No-changes!\",\n        \"unexpected\": [\n            \"No changes!\",\n            \"No\\u2013changes!\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \",. \"\n        },\n        \"expected\": \":::\",\n        \"unexpected\": [\n            \"::\",\n            \";:;\",\n            \"::: \"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": \"\",\n        \"unexpected\": [\n            \" \",\n            \"a\"\n        ]\n    }\n]\n-/"}
{"id": "LV0117", "language": "lean", "source": "verina", "source_id": "verina_basic_37_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of integers sorted in non-decreasing order.\n• target: An integer representing the value to search for.\n\n-----Output-----\nThe output is an integer:\n• If the target is found, the method returns the index of its first occurrence.\n• If the target is not found, the method returns -1.\n\n-----Note-----\n• The input array must be sorted in non-decreasing order.\n• The array is guaranteed to remain unmodified after the method executes.\n-/", "vc-preamble": "@[reducible, simp]\ndef findFirstOccurrence_precond (arr : Array Int) (target : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList", "vc-helpers": "", "vc-definitions": "def findFirstOccurrence (arr : Array Int) (target : Int) (h_precond : findFirstOccurrence_precond (arr) (target)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findFirstOccurrence_postcond (arr : Array Int) (target : Int) (result: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = target ∧\n    (∀ i : Nat, i < result.toNat → arr[i]! ≠ target)) ∧\n  (result = -1 →\n    (∀ i : Nat, i < arr.size → arr[i]! ≠ target))\n\ntheorem findFirstOccurrence_spec_satisfied (arr: Array Int) (target: Int) (h_precond : findFirstOccurrence_precond (arr) (target)) :\n    findFirstOccurrence_postcond (arr) (target) (findFirstOccurrence (arr) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr\": \"#[3, 2, 1]\",\n            \"target\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 2, 3, 4, 5]\",\n            \"target\": 2\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 2, 3, 4, 5]\",\n            \"target\": 6\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5]\",\n            \"target\": 1\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5]\",\n            \"target\": 5\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5]\",\n            \"target\": 0\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0118", "language": "lean", "source": "verina", "source_id": "verina_basic_38_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if every character in the string is identical.\nReturns false if there is at least one differing character.\n-/", "vc-preamble": "@[reducible, simp]\ndef allCharactersSame_precond (s : String) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def allCharactersSame (s : String) (h_precond : allCharactersSame_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef allCharactersSame_postcond (s : String) (result: Bool) (h_precond : allCharactersSame_precond (s)) :=\n  let cs := s.toList\n  (result → List.Pairwise (· = ·) cs) ∧\n  (¬ result → (cs ≠ [] ∧ cs.any (fun x => x ≠ cs[0]!)))\n\ntheorem allCharactersSame_spec_satisfied (s: String) (h_precond : allCharactersSame_precond (s)) :\n    allCharactersSame_postcond (s) (allCharactersSame (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"aaa\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"aba\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"a\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"bbbb\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"bbab\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0119", "language": "lean", "source": "verina", "source_id": "verina_basic_39_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----\nThe input consists of:\n• l: A list of integers.\n• n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----\nThe output is a list of integers:\n• Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----\n• The precondition requires that n is non-negative.\n• If the input list is empty, it should be returned unchanged.\n-/", "vc-preamble": "@[reducible, simp]\ndef rotateRight_precond (l : List Int) (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def rotateRight (l : List Int) (n : Nat) (h_precond : rotateRight_precond (l) (n)) : List Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef rotateRight_postcond (l : List Int) (n : Nat) (result: List Int) (h_precond : rotateRight_precond (l) (n)) :=\n  result.length = l.length ∧\n  (∀ i : Nat, i < l.length →\n    let len := l.length\n    let rotated_index := Int.toNat ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n    result[i]? = l[rotated_index]?)\n\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"l\": \"[1, 2, 3, 4, 5]\",\n            \"n\": 2\n        },\n        \"expected\": [\n            4,\n            5,\n            1,\n            2,\n            3\n        ],\n        \"unexpected\": [\n            [\n                5,\n                1,\n                2,\n                3,\n                4\n            ],\n            [\n                3,\n                4,\n                5,\n                1,\n                2\n            ]\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[1, 2, 3, 4, 5]\",\n            \"n\": 7\n        },\n        \"expected\": [\n            4,\n            5,\n            1,\n            2,\n            3\n        ],\n        \"unexpected\": [\n            [\n                5,\n                1,\n                2,\n                3,\n                4\n            ],\n            [\n                3,\n                4,\n                5,\n                1,\n                2\n            ]\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[1, 2, 3, 4, 5]\",\n            \"n\": 0\n        },\n        \"expected\": [\n            1,\n            2,\n            3,\n            4,\n            5\n        ],\n        \"unexpected\": [\n            [\n                5,\n                1,\n                2,\n                3,\n                4\n            ],\n            [\n                4,\n                5,\n                1,\n                2,\n                3\n            ]\n        ]\n    },\n    {\n        \"input\": {\n            \"l\": \"[]\",\n            \"n\": 2\n        },\n        \"expected\": [],\n        \"unexpected\": [\n            [\n                0\n            ],\n            [\n                42\n            ]\n        ]\n    }\n]\n-/"}
{"id": "LV0120", "language": "lean", "source": "verina", "source_id": "verina_basic_40_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.\n\n-----Input-----\nThe input consists of:\ns: An array of integers containing at least two elements.\n\n-----Output-----\nThe output is an integer:\nReturns the second-smallest number in the input array.\n\n-----Note-----\n- The input array is guaranteed to contain at least two elements and is non-null.\n- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.\n- The original array must remain unmodified.\n-/", "vc-preamble": "@[reducible, simp]\ndef secondSmallest_precond (s : Array Int) : Prop :=\n  s.size > 1", "vc-helpers": "def minListHelper : List Int → Int\n| [] => panic! \"minListHelper: empty list\"\n| [_] => panic! \"minListHelper: singleton list\"\n| a :: b :: [] => if a ≤ b then a else b\n| a :: b :: c :: xs =>\n    let m := minListHelper (b :: c :: xs)\n    if a ≤ m then a else m\n\ndef minList (l : List Int) : Int :=\n  minListHelper l\n\ndef secondSmallestAux (s : Array Int) (i minIdx secondIdx : Nat) : Int :=\n  if i ≥ s.size then\n    s[secondIdx]!\n  else\n    let x    := s[i]!\n    let m    := s[minIdx]!\n    let smin := s[secondIdx]!\n    if x < m then\n      secondSmallestAux s (i + 1) i minIdx\n    else if x < smin then\n      secondSmallestAux s (i + 1) minIdx i\n    else\n      secondSmallestAux s (i + 1) minIdx secondIdx\ntermination_by s.size - i", "vc-definitions": "def secondSmallest (s : Array Int) (h_precond : secondSmallest_precond (s)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef secondSmallest_postcond (s : Array Int) (result: Int) (h_precond : secondSmallest_precond (s)) :=\n  (∃ i, i < s.size ∧ s[i]! = result) ∧\n  (∃ j, j < s.size ∧ s[j]! < result ∧\n    ∀ k, k < s.size → s[k]! ≠ s[j]! → s[k]! ≥ result)\n\ntheorem secondSmallest_spec_satisfied (s: Array Int) (h_precond : secondSmallest_precond (s)) :\n    secondSmallest_postcond (s) (secondSmallest (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"s\": \"#[1]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"#[5, 3, 1, 4, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[7, 2, 5, 3]\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[10, 20]\"\n        },\n        \"expected\": 20,\n        \"unexpected\": [\n            10,\n            30,\n            25\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[20, 10]\"\n        },\n        \"expected\": 20,\n        \"unexpected\": [\n            10,\n            30,\n            15\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[3, 1, 2]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0121", "language": "lean", "source": "verina", "source_id": "verina_basic_41_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is empty or if all elements in the array are identical.\nReturns false if the array contains at least two distinct elements.\n\n-----Note-----\nThe input array is assumed to be non-null.\n-/", "vc-preamble": "@[reducible, simp]\ndef hasOnlyOneDistinctElement_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "", "vc-definitions": "def hasOnlyOneDistinctElement (a : Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasOnlyOneDistinctElement_postcond (a : Array Int) (result: Bool) (h_precond : hasOnlyOneDistinctElement_precond (a)) :=\n  let l := a.toList\n  (result → List.Pairwise (· = ·) l) ∧\n  (¬ result → (l.any (fun x => x ≠ l[0]!)))\n\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (a)) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 1]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 1]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, 4, 5, 6]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 0, 0]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 1, 0]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0122", "language": "lean", "source": "verina", "source_id": "verina_basic_42_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a natural number (Nat):\nReturns a non-negative count representing the number of digit characters found in the input string.\n\n-----Note-----\nThere are no additional preconditions; the method works for any provided string.\n-/", "vc-preamble": "@[reducible, simp]\ndef countDigits_precond (s : String) : Prop :=\n  True", "vc-helpers": "def isDigit (c : Char) : Bool :=\n  '0' ≤ c ∧ c ≤ '9'", "vc-definitions": "def countDigits (s : String) (h_precond : countDigits_precond (s)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef countDigits_postcond (s : String) (result: Nat) (h_precond : countDigits_precond (s)) :=\n  result - List.length (List.filter isDigit s.toList) = 0 ∧\n  List.length (List.filter isDigit s.toList) - result = 0\n\ntheorem countDigits_spec_satisfied (s: String) (h_precond : countDigits_precond (s)) :\n    countDigits_postcond (s) (countDigits (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"123abc456\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            5,\n            7,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"no digits here!\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"1234567890\"\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            9,\n            11,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"a1b2c3\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"0\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            8,\n            9\n        ]\n    }\n]\n-/"}
{"id": "LV0123", "language": "lean", "source": "verina", "source_id": "verina_basic_43_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the method should calculate the sum: 1⁴ + 3⁴ + 5⁴ + ... for the first n odd numbers.\n\n-----Input-----\nThe input consists of:\nn: A non-negative natural number representing the number of odd natural numbers to consider.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the fourth power of the first n odd natural numbers.\n\n-----Note-----\nThe input n is assumed to be a non-negative integer.\nThe correctness of the result is established by a theorem that relates the computed sum to a specific formula.\n-/", "vc-preamble": "@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def sumOfFourthPowerOfOddNumbers (n : Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumOfFourthPowerOfOddNumbers_postcond (n : Nat) (result: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :=\n  15 * result = n * (2 * n + 1) * (7 + 24 * n^3 - 12 * n^2 - 14 * n)\n\ntheorem sumOfFourthPowerOfOddNumbers_spec_satisfied (n: Nat) (h_precond : sumOfFourthPowerOfOddNumbers_precond (n)) :\n    sumOfFourthPowerOfOddNumbers_postcond (n) (sumOfFourthPowerOfOddNumbers (n) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            2,\n            0,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": 82,\n        \"unexpected\": [\n            81,\n            83,\n            80\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": 707,\n        \"unexpected\": [\n            706,\n            708,\n            700\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": 3108,\n        \"unexpected\": [\n            3107,\n            3109,\n            3000\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 5\n        },\n        \"expected\": 9669,\n        \"unexpected\": [\n            9668,\n            9670,\n            9000\n        ]\n    }\n]\n-/"}
{"id": "LV0124", "language": "lean", "source": "verina", "source_id": "verina_basic_44_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef isOddAtIndexOdd_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "def isOdd (n : Int) : Bool :=\n  n % 2 == 1", "vc-definitions": "def isOddAtIndexOdd (a : Array Int) (h_precond : isOddAtIndexOdd_precond (a)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isOddAtIndexOdd_postcond (a : Array Int) (result: Bool) (h_precond : isOddAtIndexOdd_precond (a)) :=\n  result ↔ (∀ i, (hi : i < a.size) → isOdd i → isOdd (a[i]))\n\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7, 9]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8, 10]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 1, 0, 1]\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 2, 4, 6]\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0125", "language": "lean", "source": "verina", "source_id": "verina_basic_45_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.\n\n-----Input-----\nThe input consists of:\nlst: A list of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product resulting from multiplying the first even number and the first odd number found in the list.\n\n-----Note-----\nThe input list is assumed to contain at least one even number and one odd number.\n-/", "vc-preamble": "def isEven (n : Int) : Bool :=\n  n % 2 = 0\n\ndef isOdd (n : Int) : Bool :=\n  n % 2 ≠ 0\n\ndef firstEvenOddIndices (lst : List Int) : Option (Nat × Nat) :=\n  let evenIndex := lst.findIdx? isEven\n  let oddIndex := lst.findIdx? isOdd\n  match evenIndex, oddIndex with\n  | some ei, some oi => some (ei, oi)\n  | _, _ => none\n@[reducible, simp]\ndef findProduct_precond (lst : List Int) : Prop :=\n  lst.length > 1 ∧\n  (∃ x ∈ lst, isEven x) ∧\n  (∃ x ∈ lst, isOdd x)", "vc-helpers": "", "vc-definitions": "def findProduct (lst : List Int) (h_precond : findProduct_precond (lst)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findProduct_postcond (lst : List Int) (result: Int) (h_precond : findProduct_precond (lst)) :=\n  match firstEvenOddIndices lst with\n  | some (ei, oi) => result = lst[ei]! * lst[oi]!\n  | none => True\n\ntheorem findProduct_spec_satisfied (lst: List Int) (h_precond : findProduct_precond (lst)) :\n    findProduct_postcond (lst) (findProduct (lst) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"lst\": \"[2]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"lst\": \"[2, 3, 4, 5]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            8,\n            0,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[2, 4, 3, 6]\"\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            8,\n            0,\n            24\n        ]\n    },\n    {\n        \"input\": {\n            \"lst\": \"[1, 2, 5, 4]\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            5,\n            0,\n            10\n        ]\n    }\n]\n-/"}
{"id": "LV0126", "language": "lean", "source": "verina", "source_id": "verina_basic_46_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.\n\n-----Input-----\nThe input consists of:\narr: A sorted array of integers in non-decreasing order.\nelem: An integer whose last occurrence position is to be determined.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the last occurrence of the specified integer in the array if it exists.\nReturns -1 if the integer is not found in the array.\n\n-----Note-----\nThe input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.\n-/", "vc-preamble": "@[reducible, simp]\ndef lastPosition_precond (arr : Array Int) (elem : Int) : Prop :=\n  List.Pairwise (· ≤ ·) arr.toList", "vc-helpers": "", "vc-definitions": "def lastPosition (arr : Array Int) (elem : Int) (h_precond : lastPosition_precond (arr) (elem)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef lastPosition_postcond (arr : Array Int) (elem : Int) (result: Int) (h_precond : lastPosition_precond (arr) (elem)) :=\n  (result ≥ 0 →\n    arr[result.toNat]! = elem ∧ (arr.toList.drop (result.toNat + 1)).all (· ≠ elem)) ∧\n  (result = -1 → arr.toList.all (· ≠ elem))\n\ntheorem lastPosition_spec_satisfied (arr: Array Int) (elem: Int) (h_precond : lastPosition_precond (arr) (elem)) :\n    lastPosition_postcond (arr) (elem) (lastPosition (arr) (elem) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr\": \"#[3, 2, 1]\",\n            \"elem\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 2, 3, 4, 5]\",\n            \"elem\": 2\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 2, 3, 4, 5]\",\n            \"elem\": 6\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 2, 3, 4, 5]\",\n            \"elem\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            3,\n            4,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1]\",\n            \"elem\": 1\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 1, 1, 1]\",\n            \"elem\": 1\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[2, 2, 3, 3, 3]\",\n            \"elem\": 3\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            2,\n            3,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0127", "language": "lean", "source": "verina", "source_id": "verina_basic_47_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the sum of all elements in the input array.\n\n-----Note-----\n- The input array is assumed not to be null.\n-/", "vc-preamble": "@[reducible, simp]\ndef arraySum_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "theorem eq_of_sub_zero_and_ge (a b : Int) : a = b → a - b = 0 ∧ a ≥ b := by\n  omega", "vc-definitions": "def arraySum (a : Array Int) (h_precond : arraySum_precond (a)) : Int :=\n  sorry", "vc-theorems": "def sumTo (a : Array Int) (n : Nat) : Int :=\n  if n = 0 then 0\n  else sumTo a (n - 1) + a[n - 1]!\n@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (result: Int) (h_precond : arraySum_precond (a)) :=\n  result - sumTo a a.size = 0 ∧\n  result ≥ sumTo a a.size\n\ntheorem arraySum_spec_satisfied (a: Array Int) (h_precond : arraySum_precond (a)) :\n    arraySum_postcond (a) (arraySum (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            14,\n            10,\n            16\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[13, 14, 15, 16, 17]\"\n        },\n        \"expected\": 75,\n        \"unexpected\": [\n            74,\n            76,\n            70\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -2, -3]\"\n        },\n        \"expected\": -6,\n        \"unexpected\": [\n            -5,\n            -7,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, -10]\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            5,\n            -5,\n            10\n        ]\n    }\n]\n-/"}
{"id": "LV0128", "language": "lean", "source": "verina", "source_id": "verina_basic_48_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.\n\n-----Input-----\nThe input consists of a single natural number:\nn: A non-negative natural number (Nat).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there exists an integer such that its square equals the input n.\nReturns false if no integer squared equals the input n.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef isPerfectSquare_precond (n : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isPerfectSquare (n : Nat) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isPerfectSquare_postcond (n : Nat) (result : Bool) : Prop :=\n  result ↔ ∃ i : Nat, i * i = n\n\ntheorem isPerfectSquare_spec_satisfied (n : Nat) :\n    isPerfectSquare_postcond n (isPerfectSquare n) := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"n\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 4\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 9\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 2\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 3\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 10\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 16\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 25\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"n\": 26\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0129", "language": "lean", "source": "verina", "source_id": "verina_basic_49_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that searches an array of integers to locate the first odd number. The method should return a pair where the first element is a Boolean indicating whether an odd number was found, and the second element is the index of that odd number if found, or -1 if no odd number exists. When an odd number is found, the method should return the smallest index at which an odd number occurs.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a pair (Bool, Int):\n- If the Boolean is true, then the integer represents the smallest index of an odd number in the array.\n- If the Boolean is false, then there are no odd numbers in the array, and the accompanying integer is -1.\n\n-----Note-----\n- The input array is assumed to be non-null.\n- If multiple odd numbers are present, the index returned should correspond to the first occurrence.\n-/", "vc-preamble": "@[reducible, simp]\ndef findFirstOdd_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "def isOdd (x : Int) : Bool :=\n  x % 2 ≠ 0", "vc-definitions": "def findFirstOdd (a : Array Int) (h_precond : findFirstOdd_precond (a)) : Option Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findFirstOdd_postcond (a : Array Int) (result: Option Nat) (h_precond : findFirstOdd_precond (a)) :=\n  match result with\n  | some idx => idx < a.size ∧ isOdd (a[idx]!) ∧\n    (∀ j, j < idx → ¬ isOdd (a[j]!))\n  | none => ∀ i, i < a.size → ¬ isOdd (a[i]!)\n\ntheorem findFirstOdd_spec_satisfied (a: Array Int) (h_precond : findFirstOdd_precond (a)) :\n    findFirstOdd_postcond (a) (findFirstOdd (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8]\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some (0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, 4, 6, 8]\"\n        },\n        \"expected\": \"some (0)\",\n        \"unexpected\": [\n            \"some (1)\",\n            \"some (2)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 5, 8]\"\n        },\n        \"expected\": \"some (2)\",\n        \"unexpected\": [\n            \"some (0)\",\n            \"some (1)\",\n            \"some (3)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": \"some (0)\",\n        \"unexpected\": [\n            \"some (1)\",\n            \"none\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2]\"\n        },\n        \"expected\": \"none\",\n        \"unexpected\": [\n            \"some (0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"some (0)\",\n        \"unexpected\": [\n            \"some (1)\",\n            \"some (2)\",\n            \"none\"\n        ]\n    }\n]\n-/"}
{"id": "LV0130", "language": "lean", "source": "verina", "source_id": "verina_basic_50_task", "vc-description": "/- \n-----Description-----\nThis task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is an integer that represents the absolute value of the input. Specifically:\n• If x is non-negative, the output is x.\n• If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).\n\n-----Note-----\nThis function should correctly handle zero, positive, and negative integers.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef Abs_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Abs (x : Int) (h_precond : Abs_precond (x)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Abs_postcond (x : Int) (result: Int) (h_precond : Abs_precond (x)) :=\n  (x ≥ 0 → x = result) ∧ (x < 0 → x + result = 0)\n\ntheorem Abs_spec_satisfied (x: Int) (h_precond : Abs_precond (x)) :\n    Abs_postcond (x) (Abs (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            -5,\n            0,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            1,\n            -5\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            -5,\n            -10,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            -10,\n            0,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -10\n        },\n        \"expected\": 10,\n        \"unexpected\": [\n            -10,\n            -1,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0131", "language": "lean", "source": "verina", "source_id": "verina_basic_51_task", "vc-description": "/- \n-----Description-----\nThis task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array’s size.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers that is assumed to be sorted in non-decreasing order.\n• key: An integer to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:\n• It is between 0 and the size of the array.\n• Every element before the returned index is less than the key.\n• If the returned index equals the size of the array, then all elements are less than the key.\n• Every element from the index onwards is greater than or equal to the key.\n\n-----Note-----\nIt is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.\n-/", "vc-preamble": "@[reducible, simp]\ndef BinarySearch_precond (a : Array Int) (key : Int) : Prop :=\n  List.Pairwise (· ≤ ·) a.toList", "vc-helpers": "def binarySearchLoop (a : Array Int) (key : Int) (lo hi : Nat) : Nat :=\n  if lo < hi then\n    let mid := (lo + hi) / 2\n    if (a[mid]! < key) then binarySearchLoop a key (mid + 1) hi\n    else binarySearchLoop a key lo mid\n  else\n    lo", "vc-definitions": "def BinarySearch (a : Array Int) (key : Int) (h_precond : BinarySearch_precond (a) (key)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef BinarySearch_postcond (a : Array Int) (key : Int) (result: Nat) (h_precond : BinarySearch_precond (a) (key)) :=\n  result ≤ a.size ∧\n  ((a.take result).all (fun x => x < key)) ∧\n  ((a.drop result).all (fun x => x ≥ key))\n\ntheorem BinarySearch_spec_satisfied (a: Array Int) (key: Int) (h_precond : BinarySearch_precond (a) (key)) :\n    BinarySearch_postcond (a) (key) (BinarySearch (a) (key) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[3, 2, 1]\",\n            \"key\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7, 9]\",\n            \"key\": 5\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"1\",\n            \"3\",\n            \"4\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7, 9]\",\n            \"key\": 6\n        },\n        \"expected\": \"3\",\n        \"unexpected\": [\n            \"2\",\n            \"4\",\n            \"5\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8]\",\n            \"key\": 1\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8]\",\n            \"key\": 10\n        },\n        \"expected\": \"4\",\n        \"unexpected\": [\n            \"3\",\n            \"5\",\n            \"6\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 1, 1]\",\n            \"key\": 1\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    }\n]\n-/"}
{"id": "LV0132", "language": "lean", "source": "verina", "source_id": "verina_basic_52_task", "vc-description": "/- \n-----Description-----\nThis task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. This array can be empty or non-empty.\n\n-----Output-----\nThe output is an array of integers that:\n• Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).\n• Has the same size as the input array.\n• Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.\n\n-----Note-----\nThe implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.\n-/", "vc-preamble": "@[reducible, simp]\ndef BubbleSort_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "def swap (a : Array Int) (i j : Nat) : Array Int :=\n  let temp := a[i]!\n  let a₁ := a.set! i (a[j]!)\n  a₁.set! j temp\n\ndef bubbleInner (j i : Nat) (a : Array Int) : Array Int :=\n  if j < i then\n    let a' := if a[j]! > a[j+1]! then swap a j (j+1) else a\n    bubbleInner (j+1) i a'\n  else\n    a\n\ndef bubbleOuter (i : Nat) (a : Array Int) : Array Int :=\n  if i > 0 then\n    let a' := bubbleInner 0 i a\n    bubbleOuter (i - 1) a'\n  else\n    a", "vc-definitions": "def BubbleSort (a : Array Int) (h_precond : BubbleSort_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef BubbleSort_postcond (a : Array Int) (result: Array Int) (h_precond : BubbleSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm result.toList a.toList\n\ntheorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :\n    BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[5, 4, 3, 2, 1]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"#[5, 4, 3, 2, 1]\",\n            \"#[2, 3, 1, 4, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"#[5, 4, 3, 2, 1]\",\n            \"#[1, 3, 2, 4, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, 1, 2, 1, 5]\"\n        },\n        \"expected\": \"#[1, 1, 2, 3, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 1, 5]\",\n            \"#[3, 1, 2, 5, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\"\n        },\n        \"expected\": \"#[10]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[10, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[4, 4, 4, 2, 2, 8]\"\n        },\n        \"expected\": \"#[2, 2, 4, 4, 4, 8]\",\n        \"unexpected\": [\n            \"#[2, 4, 4, 2, 4, 8]\",\n            \"#[4, 2, 4, 2, 4, 8]\",\n            \"#[2, 4, 2, 4, 4, 8]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0133", "language": "lean", "source": "verina", "source_id": "verina_basic_53_task", "vc-description": "/- \n-----Description-----\nThis problem asks for a method to determine the sum of the first N natural numbers. The task focuses on computing the total when given an input N, ensuring that the value is 0 when N is 0 and correctly calculated for positive values of N.\n\n-----Input-----\nThe input consists of:\n• N: A natural number (Nat) representing the count of the first natural numbers to sum.\n\n-----Output-----\nThe output is a natural number (Nat), which is the sum of the first N natural numbers computed as: N * (N + 1) / 2.\n\n-----Note-----\nThe computation leverages a recursive implementation. There are no additional preconditions beyond providing a valid natural number.\n-/", "vc-preamble": "@[reducible, simp]\ndef CalSum_precond (N : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def CalSum (N : Nat) (h_precond : CalSum_precond (N)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef CalSum_postcond (N : Nat) (result: Nat) (h_precond : CalSum_precond (N)) :=\n  2 * result = N * (N + 1)\n\ntheorem CalSum_spec_satisfied (N: Nat) (h_precond : CalSum_precond (N)) :\n    CalSum_postcond (N) (CalSum (N) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"N\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 5\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            10,\n            16,\n            20\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 10\n        },\n        \"expected\": 55,\n        \"unexpected\": [\n            54,\n            56,\n            50\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 20\n        },\n        \"expected\": 210,\n        \"unexpected\": [\n            200,\n            220,\n            205\n        ]\n    }\n]\n-/"}
{"id": "LV0134", "language": "lean", "source": "verina", "source_id": "verina_basic_54_task", "vc-description": "/- \n-----Description-----\nThis task is about determining the minimum absolute difference between any pair of integers, where one integer is taken from the first sorted array and the other integer is taken from the second sorted array. The focus is on accurately finding the smallest absolute difference between any two elements from the arrays, independent of the specific techniques or programming language used.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers, sorted in non-decreasing order and guaranteed to be non-empty.\n• b: An array of integers, also sorted in non-decreasing order and non-empty.\n\n-----Output-----\nThe output is a natural number (Nat) representing the minimum absolute difference between any element a[i] from the first array and b[j] from the second array.\n\n-----Note-----\n• It is assumed that both arrays are non-empty.\n• The arrays are assumed to be sorted in non-decreasing order.\n-/", "vc-preamble": "@[reducible, simp]\ndef CanyonSearch_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size > 0 ∧ b.size > 0 ∧ List.Pairwise (· ≤ ·) a.toList ∧ List.Pairwise (· ≤ ·) b.toList", "vc-helpers": "def canyonSearchAux (a : Array Int) (b : Array Int) (m n d : Nat) : Nat :=\n  if m < a.size ∧ n < b.size then\n    let diff : Nat := ((a[m]! - b[n]!).natAbs)\n    let new_d := if diff < d then diff else d\n    if a[m]! <= b[n]! then\n      canyonSearchAux a b (m + 1) n new_d\n    else\n      canyonSearchAux a b m (n + 1) new_d\n  else\n    d\ntermination_by a.size + b.size - m - n", "vc-definitions": "def CanyonSearch (a : Array Int) (b : Array Int) (h_precond : CanyonSearch_precond (a) (b)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef CanyonSearch_postcond (a : Array Int) (b : Array Int) (result: Nat) (h_precond : CanyonSearch_precond (a) (b)) :=\n  (a.any (fun ai => b.any (fun bi => result = (ai - bi).natAbs))) ∧\n  (a.all (fun ai => b.all (fun bi => result ≤ (ai - bi).natAbs)))\n\ntheorem CanyonSearch_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : CanyonSearch_precond (a) (b)) :\n    CanyonSearch_postcond (a) (b) (CanyonSearch (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5]\",\n            \"b\": \"#[2, 4, 6]\"\n        },\n        \"expected\": \"1\",\n        \"unexpected\": [\n            \"0\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-5, -2, 0]\",\n            \"b\": \"#[1, 3]\"\n        },\n        \"expected\": \"1\",\n        \"unexpected\": [\n            \"0\",\n            \"2\",\n            \"5\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30]\",\n            \"b\": \"#[5, 15, 25]\"\n        },\n        \"expected\": \"5\",\n        \"unexpected\": [\n            \"3\",\n            \"7\",\n            \"10\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"b\": \"#[3]\"\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-10, -5, 0, 5, 10]\",\n            \"b\": \"#[-3, 2, 8]\"\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"1\",\n            \"3\",\n            \"4\"\n        ]\n    }\n]\n-/"}
{"id": "LV0135", "language": "lean", "source": "verina", "source_id": "verina_basic_55_task", "vc-description": "/- \n-----Description-----\nThis task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.\n\n-----Input-----\nThe input consists of two elements:\n• a: An element of type Int.\n• b: An element of type Int.\n\n-----Output-----\nThe output is a Boolean:\n• Returns true if a equals b.\n• Returns false if a does not equal b.\n-/", "vc-preamble": "@[reducible, simp]\ndef Compare_precond (a : Int) (b : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Compare (a : Int) (b : Int) (h_precond : Compare_precond (a) (b)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Compare_postcond (a : Int) (b : Int) (result: Bool) (h_precond : Compare_precond (a) (b)) :=\n  (a = b → result = true) ∧ (a ≠ b → result = false)\n\ntheorem Compare_spec_satisfied (a: Int) (b: Int) (h_precond : Compare_precond (a) (b)) :\n    Compare_postcond (a) (b) (Compare (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 1,\n            \"b\": 1\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 1,\n            \"b\": 2\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0136", "language": "lean", "source": "verina", "source_id": "verina_basic_56_task", "vc-description": "/- \n-----Description-----\nThe problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n• src: An array of integers representing the source array.\n• sStart: A natural number indicating the starting index in src from where to begin copying.\n• dest: An array of integers representing the destination array.\n• dStart: A natural number indicating the starting index in dest where the segment will be replaced.\n• len: A natural number specifying the number of elements to copy.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same size as the destination array (dest).\n• Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.\n• Under the preconditions that src.size ≥ sStart + len and dest.size ≥ dStart + len, guarantees that:\n  - All elements with indices less than dStart remain as in dest.\n  - All elements with indices greater than or equal to dStart + len remain as in dest.\n  - For each index i with 0 ≤ i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\n-----Note-----\nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.\n-/", "vc-preamble": "@[reducible, simp]\ndef copy_precond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) : Prop :=\n  src.size ≥ sStart + len ∧\n  dest.size ≥ dStart + len", "vc-helpers": "def updateSegment : Array Int → Array Int → Nat → Nat → Nat → Array Int\n  | r, src, sStart, dStart, 0 => r\n  | r, src, sStart, dStart, n+1 =>\n      let rNew := r.set! (dStart + n) (src[sStart + n]!)\n      updateSegment rNew src sStart dStart n", "vc-definitions": "def copy (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef copy_postcond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (result: Array Int) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :=\n  result.size = dest.size ∧\n  (∀ i, i < dStart → result[i]! = dest[i]!) ∧\n  (∀ i, dStart + len ≤ i → i < result.size → result[i]! = dest[i]!) ∧\n  (∀ i, i < len → result[dStart + i]! = src[sStart + i]!)\n\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"src\": \"#[10, 20, 30]\",\n            \"sStart\": 1,\n            \"dest\": \"#[1, 2, 3, 4]\",\n            \"dStart\": 2,\n            \"len\": 3\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"src\": \"#[10, 20, 30, 40, 50]\",\n            \"sStart\": 1,\n            \"dest\": \"#[1, 2, 3, 4, 5, 6]\",\n            \"dStart\": 3,\n            \"len\": 2\n        },\n        \"expected\": \"#[1, 2, 3, 20, 30, 6]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 10, 30, 6]\",\n            \"#[1, 2, 3, 20, 40, 6]\",\n            \"#[1, 2, 20, 30, 6, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"src\": \"#[5, 6, 7, 8]\",\n            \"sStart\": 0,\n            \"dest\": \"#[9, 9, 9, 9, 9]\",\n            \"dStart\": 1,\n            \"len\": 3\n        },\n        \"expected\": \"#[9, 5, 6, 7, 9]\",\n        \"unexpected\": [\n            \"#[9, 9, 5, 7, 9]\",\n            \"#[9, 5, 7, 6, 9]\",\n            \"#[9, 5, 6, 9, 9]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"src\": \"#[100, 200]\",\n            \"sStart\": 0,\n            \"dest\": \"#[1, 2, 3]\",\n            \"dStart\": 1,\n            \"len\": 0\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[1, 0, 3]\",\n            \"#[0, 2, 3]\",\n            \"#[1, 2, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"src\": \"#[10, 20, 30, 40, 50]\",\n            \"sStart\": 0,\n            \"dest\": \"#[0, 0, 0, 0, 0]\",\n            \"dStart\": 0,\n            \"len\": 5\n        },\n        \"expected\": \"#[10, 20, 30, 40, 50]\",\n        \"unexpected\": [\n            \"#[10, 20, 30, 40, 60]\",\n            \"#[0, 20, 30, 40, 50]\",\n            \"#[10, 20, 30, 40, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"src\": \"#[7, 8, 9, 10]\",\n            \"sStart\": 2,\n            \"dest\": \"#[1, 2, 3, 4, 5, 6]\",\n            \"dStart\": 4,\n            \"len\": 2\n        },\n        \"expected\": \"#[1, 2, 3, 4, 9, 10]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 9, 4, 10]\",\n            \"#[1, 2, 9, 4, 3, 10]\",\n            \"#[1, 2, 3, 4, 10, 9]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0137", "language": "lean", "source": "verina", "source_id": "verina_basic_57_task", "vc-description": "/- \n-----Description-----\nThis task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.\n\n-----Input-----\nThe input consists of:\n• numbers: An array of integers (which may be empty or non-empty).\n• threshold: An integer that serves as the comparison threshold.\n\n-----Output-----\nThe output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.\n\n-----Note-----\nThere are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.\n-/", "vc-preamble": "@[reducible, simp]\ndef CountLessThan_precond (numbers : Array Int) (threshold : Int) : Prop :=\n  True", "vc-helpers": "def countLessThan (numbers : Array Int) (threshold : Int) : Nat :=\n  let rec count (i : Nat) (acc : Nat) : Nat :=\n    if i < numbers.size then\n      let new_acc := if numbers[i]! < threshold then acc + 1 else acc\n      count (i + 1) new_acc\n    else\n      acc\n  count 0 0", "vc-definitions": "def CountLessThan (numbers : Array Int) (threshold : Int) (h_precond : CountLessThan_precond (numbers) (threshold)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef CountLessThan_postcond (numbers : Array Int) (threshold : Int) (result: Nat) (h_precond : CountLessThan_precond (numbers) (threshold)) :=\n  result - numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 = 0 ∧\n  numbers.foldl (fun count n => if n < threshold then count + 1 else count) 0 - result = 0\n\ntheorem CountLessThan_spec_satisfied (numbers: Array Int) (threshold: Int) (h_precond : CountLessThan_precond (numbers) (threshold)) :\n    CountLessThan_postcond (numbers) (threshold) (CountLessThan (numbers) (threshold) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"numbers\": \"#[1, 2, 3, 4, 5]\",\n            \"threshold\": 3\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"3\",\n            \"1\",\n            \"0\"\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"#[]\",\n            \"threshold\": 10\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"#[-1, 0, 1]\",\n            \"threshold\": 0\n        },\n        \"expected\": \"1\",\n        \"unexpected\": [\n            \"0\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"#[5, 6, 7, 2, 1]\",\n            \"threshold\": 5\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"3\",\n            \"4\",\n            \"1\"\n        ]\n    },\n    {\n        \"input\": {\n            \"numbers\": \"#[3, 3, 3, 3]\",\n            \"threshold\": 3\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    }\n]\n-/"}
{"id": "LV0138", "language": "lean", "source": "verina", "source_id": "verina_basic_58_task", "vc-description": "/- \n-----Description-----\nThis task involves transforming an array of integers by doubling each element.\n\n-----Input-----\nThe input consists of:\n• s: An array of integers.\n\n-----Output-----\nThe output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.\n\n-----Note-----\nThe implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.\n-/", "vc-preamble": "@[reducible, simp]\ndef double_array_elements_precond (s : Array Int) : Prop :=\n  True", "vc-helpers": "def double_array_elements_aux (s_old s : Array Int) (i : Nat) : Array Int :=\n  if i < s.size then\n    let new_s := s.set! i (2 * (s_old[i]!))\n    double_array_elements_aux s_old new_s (i + 1)\n  else\n    s", "vc-definitions": "def double_array_elements (s : Array Int) (h_precond : double_array_elements_precond (s)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef double_array_elements_postcond (s : Array Int) (result: Array Int) (h_precond : double_array_elements_precond (s)) :=\n  result.size = s.size ∧ ∀ i, i < s.size → result[i]! = 2 * s[i]!\n\ntheorem double_array_elements_spec_satisfied (s: Array Int) (h_precond : double_array_elements_precond (s)) :\n    double_array_elements_postcond (s) (double_array_elements (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[0]\",\n            \"#[-1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"#[2, 4, 6, 8, 10]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[2, 4, 6, 8, 9]\",\n            \"#[0, 4, 6, 8, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[0, -1, 5]\"\n        },\n        \"expected\": \"#[0, -2, 10]\",\n        \"unexpected\": [\n            \"#[0, -1, 5]\",\n            \"#[1, -2, 10]\",\n            \"#[0, 0, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[100]\"\n        },\n        \"expected\": \"#[200]\",\n        \"unexpected\": [\n            \"#[100]\",\n            \"#[0]\",\n            \"#[201]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[-3, -4]\"\n        },\n        \"expected\": \"#[-6, -8]\",\n        \"unexpected\": [\n            \"#[3, -4]\",\n            \"#[-6, -7]\",\n            \"#[-6, -9]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0139", "language": "lean", "source": "verina", "source_id": "verina_basic_59_task", "vc-description": "/- \n-----Description-----\nGiven an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is a tuple (a, b) where:\n• a = 2 * x\n• b = 4 * x\n\n-----Note-----\nThere are no additional preconditions; the method is defined for all integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef DoubleQuadruple_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def DoubleQuadruple (x : Int) (h_precond : DoubleQuadruple_precond (x)) : (Int × Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef DoubleQuadruple_postcond (x : Int) (result: (Int × Int)) (h_precond : DoubleQuadruple_precond (x)) :=\n  result.fst = 2 * x ∧ result.snd = 2 * result.fst\n\ntheorem DoubleQuadruple_spec_satisfied (x: Int) (h_precond : DoubleQuadruple_precond (x)) :\n    DoubleQuadruple_postcond (x) (DoubleQuadruple (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(1, 0)\",\n            \"(0, 1)\",\n            \"(-1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 1\n        },\n        \"expected\": \"(2, 4)\",\n        \"unexpected\": [\n            \"(2, 2)\",\n            \"(1, 4)\",\n            \"(3, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -1\n        },\n        \"expected\": \"(-2, -4)\",\n        \"unexpected\": [\n            \"(-2, -2)\",\n            \"(-1, -4)\",\n            \"(-3, -4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10\n        },\n        \"expected\": \"(20, 40)\",\n        \"unexpected\": [\n            \"(20, 20)\",\n            \"(10, 40)\",\n            \"(20, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5\n        },\n        \"expected\": \"(-10, -20)\",\n        \"unexpected\": [\n            \"(-10, -10)\",\n            \"(-5, -20)\",\n            \"(-15, -20)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0140", "language": "lean", "source": "verina", "source_id": "verina_basic_60_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.\n\n-----Input-----\nThe input consists of one parameter:\n• arr: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n• Contains exactly all even numbers from the input array, preserving their original order.\n• Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.\n\n-----Note-----\nThere are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.\n-/", "vc-preamble": "@[reducible, simp]\ndef FindEvenNumbers_precond (arr : Array Int) : Prop :=\n  True", "vc-helpers": "def isEven (n : Int) : Bool :=\n  n % 2 = 0", "vc-definitions": "def FindEvenNumbers (arr : Array Int) (h_precond : FindEvenNumbers_precond (arr)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef FindEvenNumbers_postcond (arr : Array Int) (result: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :=\n  result.all (fun x => isEven x && x ∈ arr) ∧\n  List.Pairwise (fun (x, i) (y, j) => if i < j then arr.idxOf x ≤ arr.idxOf y else true) (result.toList.zipIdx)\n\ntheorem FindEvenNumbers_spec_satisfied (arr: Array Int) (h_precond : FindEvenNumbers_precond (arr)) :\n    FindEvenNumbers_postcond (arr) (FindEvenNumbers (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5, 6]\"\n        },\n        \"expected\": \"#[2, 4, 6]\",\n        \"unexpected\": [\n            \"#[2, 4, 5]\",\n            \"#[1, 2, 3, 4]\",\n            \"#[2, 3, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[0, -2, 3, -4, 7]\"\n        },\n        \"expected\": \"#[0, -2, -4]\",\n        \"unexpected\": [\n            \"#[0, 3, -4]\",\n            \"#[0, -2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 3, 5, 7]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[0, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[2, 4, 8, 10]\"\n        },\n        \"expected\": \"#[2, 4, 8, 10]\",\n        \"unexpected\": [\n            \"#[2, 4, 8, 9]\",\n            \"#[2, 4, 8, 10, 12]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1, 2]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0141", "language": "lean", "source": "verina", "source_id": "verina_basic_61_task", "vc-description": "/- \n-----Description-----\nThis task involves determining whether every character in a provided string is a digit. The objective is to check if all characters fall within the standard digit range, returning true if they do and false otherwise.\n\n-----Input-----\nThe input consists of:\n• s: A string whose characters will be analyzed to determine if they are all digits.\n\n-----Output-----\nThe output is a boolean value:\n• true if every character in the string is a digit;\n• false if at least one character is not a digit (note that the empty string returns true).\n\n-----Note-----\nIt is assumed that the input is a well-formed string. The function uses an iterator to examine every character.\n-/", "vc-preamble": "@[reducible, simp]\ndef allDigits_precond (s : String) : Prop :=\n  True", "vc-helpers": "def isDigit (c : Char) : Bool :=\n  (c ≥ '0') && (c ≤ '9')", "vc-definitions": "def allDigits (s : String) (h_precond : allDigits_precond (s)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef allDigits_postcond (s : String) (result: Bool) (h_precond : allDigits_precond (s)) :=\n  (result = true ↔ ∀ c ∈ s.toList, isDigit c)\n\ntheorem allDigits_spec_satisfied (s: String) (h_precond : allDigits_precond (s)) :\n    allDigits_postcond (s) (allDigits (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"123456\"\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"s\": \"123a56\"\n        },\n        \"expected\": false,\n        \"unexpected\": [true]\n    },\n    {\n        \"input\": {\n            \"s\": \"\"\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"s\": \"007\"\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"s\": \"98 76\"\n        },\n        \"expected\": false,\n        \"unexpected\": [true]\n    }\n]\n-/"}
{"id": "LV0142", "language": "lean", "source": "verina", "source_id": "verina_basic_62_task", "vc-description": "/- \n-----Description-----\nThe problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• key: An integer representing the value to search for in the array.\n\n-----Output-----\nThe output is an integer which represents:\n• The index in the array where the key is found, provided that the index is in the range [0, a.size).\n• -1 if the key is not present in the array.\nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----\nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.\n-/", "vc-preamble": "@[reducible, simp]\ndef Find_precond (a : Array Int) (key : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Find (a : Array Int) (key : Int) (h_precond : Find_precond (a) (key)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Find_postcond (a : Array Int) (key : Int) (result: Int) (h_precond : Find_precond (a) (key)) :=\n  (result = -1 ∨ (result ≥ 0 ∧ result < Int.ofNat a.size))\n  ∧ ((result ≠ -1) → (a[(Int.toNat result)]! = key ∧ ∀ (i : Nat), i < Int.toNat result → a[i]! ≠ key))\n  ∧ ((result = -1) → ∀ (i : Nat), i < a.size → a[i]! ≠ key)\n\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"key\": 3\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 7, 5, 9]\",\n            \"key\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            2,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8]\",\n            \"key\": 5\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"key\": 10\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            0,\n            1,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, -3, -1, -3]\",\n            \"key\": -3\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0143", "language": "lean", "source": "verina", "source_id": "verina_basic_63_task", "vc-description": "/- \n-----Description-----\nThe task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.\n\n-----Input-----\nThe input consists of:\n• numbers: A list of floating-point numbers.\n• threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered \"close.\"\n\n-----Output-----\nThe output is a boolean value:\n• true – if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.\n• false – if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.\n\n-----Note-----\nIt is assumed that the list of numbers is provided and that the threshold is non-negative.\n-/", "vc-preamble": "@[reducible, simp]\ndef has_close_elements_precond (numbers : List Float) (threshold : Float) : Prop :=\n  threshold ≥ 0.0", "vc-helpers": "def absDiff (a b : Float) : Float :=\n  if a - b < 0.0 then b - a else a - b", "vc-definitions": "def has_close_elements (numbers : List Float) (threshold : Float) (h_precond : has_close_elements_precond (numbers) (threshold)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef has_close_elements_postcond (numbers : List Float) (threshold : Float) (result: Bool) (h_precond : has_close_elements_precond (numbers) (threshold)) :=\n  ¬ result ↔ (List.Pairwise (fun a b => absDiff a b ≥ threshold) numbers)\n\ntheorem has_close_elements_spec_satisfied (numbers: List Float) (threshold: Float) (h_precond : has_close_elements_precond (numbers) (threshold)) :\n    has_close_elements_postcond (numbers) (threshold) (has_close_elements (numbers) (threshold) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"numbers\": \"[1.0, 2.0, 3.0]\",\n            \"threshold\": -1.0\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"numbers\": \"[1.0, 2.0, 3.0]\",\n            \"threshold\": 1.5\n        },\n        \"expected\": true,\n        \"unexpected\": []\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[10.0, 12.0, 15.0]\",\n            \"threshold\": 1.5\n        },\n        \"expected\": false,\n        \"unexpected\": []\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[5.0, 5.0]\",\n            \"threshold\": 0.1\n        },\n        \"expected\": true,\n        \"unexpected\": []\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[]\",\n            \"threshold\": 2.0\n        },\n        \"expected\": false,\n        \"unexpected\": []\n    },\n    {\n        \"input\": {\n            \"numbers\": \"[0.0, 0.5, 1.1, 2.2]\",\n            \"threshold\": 0.6\n        },\n        \"expected\": true,\n        \"unexpected\": []\n    }\n]\n-/"}
{"id": "LV0144", "language": "lean", "source": "verina", "source_id": "verina_basic_64_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n• All characters before the insertion position (atPos) remain unchanged.\n• The new characters from nl are inserted starting at index atPos.\n• The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----\nThe input consists of:\n• oline: An array of characters representing the original sequence.\n• l: A natural number indicating how many characters from oline to consider.\n• nl: An array of characters to be inserted into oline.\n• p: A natural number indicating how many characters from nl to consider for insertion.\n• atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----\nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:\n• Contain the original characters from index 0 up to (but not including) atPos.\n• Have the next p characters equal to the characters from nl.\n• Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----\nIt is assumed that:\n• atPos is within the range [0, l].\n• l does not exceed the size of oline.\n• p does not exceed the size of nl.\n-/", "vc-preamble": "@[reducible, simp]\ndef insert_precond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) : Prop :=\n  l ≤ oline.size ∧\n  p ≤ nl.size ∧\n  atPos ≤ l", "vc-helpers": "", "vc-definitions": "def insert (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef insert_postcond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (result: Array Char) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :=\n  result.size = l + p ∧\n  (List.range p).all (fun i => result[atPos + i]! = nl[i]!) ∧\n  (List.range atPos).all (fun i => result[i]! = oline[i]!) ∧\n  (List.range (l - atPos)).all (fun i => result[atPos + p + i]! = oline[atPos + i]!)\n\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n  {\n    \"input\": {\n        \"oline\": \"#['a','b','c']\",\n        \"l\": 5,\n        \"nl\": \"#['X','Y']\",\n        \"p\": 3,\n        \"atPos\": 2\n    }\n  }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"oline\": \"#['a','b','c','d','e']\",\n            \"l\": 5,\n            \"nl\": \"#['X','Y']\",\n            \"p\": 2,\n            \"atPos\": 2\n        },\n        \"expected\": \"#['a','b','X','Y','c','d','e']\",\n        \"unexpected\": [\n            \"#['a','b','X','Y','c','d']\",\n            \"#['a','b','X','Y','c','d','f']\",\n            \"#['a','X','b','Y','c','d','e']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"oline\": \"#['H','e','l','l','o']\",\n            \"l\": 5,\n            \"nl\": \"#['W','o','r','l','d']\",\n            \"p\": 5,\n            \"atPos\": 0\n        },\n        \"expected\": \"#['W','o','r','l','d','H','e','l','l','o']\",\n        \"unexpected\": [\n            \"#['H','e','l','l','o','W','o','r','l','d']\",\n            \"#['W','o','r','l','d','H','e','l','l','o','!']\",\n            \"#['W','o','r','l','d','W','o','r','l','d']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"oline\": \"#['L','e','a','n']\",\n            \"l\": 4,\n            \"nl\": \"#['4']\",\n            \"p\": 1,\n            \"atPos\": 4\n        },\n        \"expected\": \"#['L','e','a','n','4']\",\n        \"unexpected\": [\n            \"#['L','e','a','n']\",\n            \"#['L','e','a','n',' ']\",\n            \"#['4','L','e','a','n']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"oline\": \"#['T','e','s','t']\",\n            \"l\": 4,\n            \"nl\": \"#[]\",\n            \"p\": 0,\n            \"atPos\": 2\n        },\n        \"expected\": \"#['T','e','s','t']\",\n        \"unexpected\": [\n            \"#['T','e','s']\",\n            \"#['T','s','t','e']\",\n            \"#['t','e','s','T']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"oline\": \"#['1','2','3','4','5','6']\",\n            \"l\": 5,\n            \"nl\": \"#['a','b','c']\",\n            \"p\": 3,\n            \"atPos\": 3\n        },\n        \"expected\": \"#['1','2','3','a','b','c','4','5']\",\n        \"unexpected\": [\n            \"#['1','2','3','a','b','c','4','5','6']\",\n            \"#['1','2','3','4','a','b','c','5','6']\",\n            \"#['1','2','3','a','b','4','c','5','6']\"\n        ]\n    }\n]\n-/"}
{"id": "LV0145", "language": "lean", "source": "verina", "source_id": "verina_basic_65_task", "vc-description": "/- \n-----Description-----\nThis task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r ≤ N and N < (r + 1) * (r + 1).\n\n-----Input-----\nThe input consists of:\n• N: A natural number.\n\n-----Output-----\nThe output is a natural number r that meets the following conditions:\n• r * r ≤ N\n• N < (r + 1) * (r + 1)\n\n-----Note-----\nThe implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.\n-/", "vc-preamble": "@[reducible, simp]\ndef SquareRoot_precond (N : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def SquareRoot (N : Nat) (h_precond : SquareRoot_precond (N)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SquareRoot_postcond (N : Nat) (result: Nat) (h_precond : SquareRoot_precond (N)) :=\n  result * result ≤ N ∧ N < (result + 1) * (result + 1)\n\ntheorem SquareRoot_spec_satisfied (N: Nat) (h_precond : SquareRoot_precond (N)) :\n    SquareRoot_postcond (N) (SquareRoot (N) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"N\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 1\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 15\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 16\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"N\": 26\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6,\n            7\n        ]\n    }\n]\n-/"}
{"id": "LV0146", "language": "lean", "source": "verina", "source_id": "verina_basic_66_task", "vc-description": "/- \n-----Description-----\nThis task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.\n\n-----Input-----\nThe input consists of a single integer:\n• x: An integer to be evaluated.\n\n-----Output-----\nThe output is a boolean value:\n• true if x is even (x mod 2 equals 0).\n• false if x is odd.\n\n-----Note-----\nNo additional preconditions are required. The method should work correctly for any integer value.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef ComputeIsEven_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def ComputeIsEven (x : Int) (h_precond : ComputeIsEven_precond (x)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef ComputeIsEven_postcond (x : Int) (result: Bool) (h_precond : ComputeIsEven_precond (x)) :=\n  result = true ↔ ∃ k : Int, x = 2 * k\n\ntheorem ComputeIsEven_spec_satisfied (x: Int) (h_precond : ComputeIsEven_precond (x)) :\n    ComputeIsEven_postcond (x) (ComputeIsEven (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 4\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"x\": 7\n        },\n        \"expected\": false,\n        \"unexpected\": [true]\n    },\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"x\": -2\n        },\n        \"expected\": true,\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"x\": -3\n        },\n        \"expected\": false,\n        \"unexpected\": [true]\n    }\n]\n-/"}
{"id": "LV0147", "language": "lean", "source": "verina", "source_id": "verina_basic_67_task", "vc-description": "/- \n-----Description-----\nThis task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.\n\n-----Input-----\nThe input consists of:\n• x: A list of characters (List Char). The list can be empty or non-empty.\n\n-----Output-----\nThe output is a Boolean value (Bool):\n• Returns true if the input list is a palindrome.\n• Returns false otherwise.\n\n-----Note-----\nAn empty list is considered a palindrome. The function does not impose any additional preconditions.\n-/", "vc-preamble": "@[reducible, simp]\ndef IsPalindrome_precond (x : List Char) : Prop :=\n  True", "vc-helpers": "def isPalindromeHelper (x : List Char) (i j : Nat) : Bool :=\n  if i < j then\n    match x[i]?, x[j]? with\n    | some ci, some cj =>\n      if ci ≠ cj then false else isPalindromeHelper x (i + 1) (j - 1)\n    | _, _ => false  -- This case should not occur due to valid indices\n  else true", "vc-definitions": "def IsPalindrome (x : List Char) (h_precond : IsPalindrome_precond (x)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef IsPalindrome_postcond (x : List Char) (result: Bool) (h_precond : IsPalindrome_precond (x)) :=\n  result ↔ ∀ i : Nat, i < x.length → (x[i]! = x[x.length - i - 1]!)\n\ntheorem IsPalindrome_spec_satisfied (x: List Char) (h_precond : IsPalindrome_precond (x)) :\n    IsPalindrome_postcond (x) (IsPalindrome (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": \"[]\"\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [\n            \"false\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": \"['a']\"\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [\n            \"false\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": \"['a', 'b', 'a']\"\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [\n            \"false\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": \"['a', 'b', 'c']\"\n        },\n        \"expected\": \"false\",\n        \"unexpected\": [\n            \"true\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": \"['r', 'a', 'c', 'e', 'c', 'a', 'r']\"\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [\n            \"false\"\n        ]\n    }\n]\n-/"}
{"id": "LV0148", "language": "lean", "source": "verina", "source_id": "verina_basic_68_task", "vc-description": "/- \n-----Description-----\nThe task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• e: An integer representing the target to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) which is:\n• The index of the first occurrence of the target integer if found.\n• The size of the array if the target integer is not present.\n\n-----Note-----\nThere are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array’s size if the element is absent.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  result ≤ a.size ∧ (result = a.size ∨ a[result]! = e) ∧ (∀ i, i < result → a[i]! ≠ e)\n\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 5, 7, 9]\",\n            \"e\": 5\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"1\",\n            \"3\",\n            \"4\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 4, 6, 8]\",\n            \"e\": 5\n        },\n        \"expected\": \"4\",\n        \"unexpected\": [\n            \"1\",\n            \"3\",\n            \"5\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 5, 5]\",\n            \"e\": 5\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 9, 8, 7]\",\n            \"e\": 10\n        },\n        \"expected\": \"0\",\n        \"unexpected\": [\n            \"1\",\n            \"2\",\n            \"3\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 3, 4]\",\n            \"e\": 3\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            \"1\",\n            \"3\",\n            \"4\"\n        ]\n    }\n]\n-/"}
{"id": "LV0149", "language": "lean", "source": "verina", "source_id": "verina_basic_69_task", "vc-description": "/- \n-----Description-----\nThis problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• e: An integer representing the element to search for.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index of the first occurrence of e in the array.\n• If the element e exists in the array, the index n will satisfy the conditions specified above.\n\n-----Note-----\nIt is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i]! = e.\nThe implementation uses a helper function to iterate through the array recursively.\n-/", "vc-preamble": "@[reducible, simp]\ndef LinearSearch_precond (a : Array Int) (e : Int) : Prop :=\n  ∃ i, i < a.size ∧ a[i]! = e", "vc-helpers": "def linearSearchAux (a : Array Int) (e : Int) (n : Nat) : Nat :=\n  if n < a.size then\n    if a[n]! = e then n else linearSearchAux a e (n + 1)\n  else\n    0", "vc-definitions": "def LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=\n  (result < a.size) ∧ (a[result]! = e) ∧ (∀ k : Nat, k < result → a[k]! ≠ e)\n\ntheorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :\n    LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"e\": 6\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"e\": 3\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30, 40, 50]\",\n            \"e\": 10\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 4, 3, 2, 1]\",\n            \"e\": 1\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            0,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, 0, 1, 2]\",\n            \"e\": -1\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7, 8, 7, 9, 7]\",\n            \"e\": 7\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            2,\n            3,\n            4\n        ]\n    }\n]\n-/"}
{"id": "LV0150", "language": "lean", "source": "verina", "source_id": "verina_basic_70_task", "vc-description": "/- \n-----Description-----\nThis task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.\n\n-----Input-----\nThe input consists of:\n• a: An array of elements (for testing purposes, you can assume it is an array of integers).\n• P: A predicate function on the elements (represented as a string for test cases, e.g., \"fun x => x > 5\"). It is assumed that at least one element in the array satisfies P.\n\n-----Output-----\nThe output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.\n• The index returned is less than the size of the array.\n• The element at the returned index satisfies P.\n• All elements before the returned index do not satisfy P.\n\n-----Note-----\nIt is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.\n-/", "vc-preamble": "@[reducible, simp]\ndef LinearSearch3_precond (a : Array Int) (P : Int -> Bool) : Prop :=\n  ∃ i, i < a.size ∧ P (a[i]!)", "vc-helpers": "", "vc-definitions": "def LinearSearch3 (a : Array Int) (P : Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LinearSearch3_postcond (a : Array Int) (P : Int -> Bool) (result: Nat) (h_precond : LinearSearch3_precond (a) (P)) :=\n  result < a.size ∧ P (a[result]!) ∧ (∀ k, k < result → ¬ P (a[k]!))\n\ntheorem LinearSearch3_spec_satisfied (a: Array Int) (P: Int -> Bool) (h_precond : LinearSearch3_precond (a) (P)) :\n    LinearSearch3_postcond (a) (P) (LinearSearch3 (a) (P) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"P\": \"fun x => x > 10\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[4, 7, 2, 9]\",\n            \"P\": \"fun x => x > 5\"\n        },\n        \"expected\": 1,\n        \"unexpected\": [\n            0,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 8, 6, 4, 2]\",\n            \"P\": \"fun x => x < 5\"\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            0,\n            1,\n            4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 3, 1, 2]\",\n            \"P\": \"fun x => x == 1\"\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            0,\n            1,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 1, 2, 3]\",\n            \"P\": \"fun x => x == 0\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[9, 9, 9, 9]\",\n            \"P\": \"fun x => x == 9\"\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            2,\n            3\n        ]\n    }\n]\n-/"}
{"id": "LV0151", "language": "lean", "source": "verina", "source_id": "verina_basic_71_task", "vc-description": "/- \n-----Description-----\nThis problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical.\n\n-----Input-----\nThe input consists of:\n• str1: A list of characters.\n• str2: A list of characters.\n\n-----Output-----\nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:\n• Its length is less than or equal to the length of each input list.\n• It is exactly the prefix of both str1 and str2.\n• It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----\nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.\n-/", "vc-preamble": "@[reducible, simp]\ndef LongestCommonPrefix_precond (str1 : List Char) (str2 : List Char) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def LongestCommonPrefix (str1 : List Char) (str2 : List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) : List Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef LongestCommonPrefix_postcond (str1 : List Char) (str2 : List Char) (result: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :=\n  (result.length ≤ str1.length) ∧ (result = str1.take result.length) ∧\n  (result.length ≤ str2.length) ∧ (result = str2.take result.length) ∧\n  (result.length = str1.length ∨ result.length = str2.length ∨\n    (str1[result.length]? ≠ str2[result.length]?))\n\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"str1\": \"['a', 'b', 'c']\",\n            \"str2\": \"['a', 'b', 'd']\"\n        },\n        \"expected\": \"['a', 'b']\",\n        \"unexpected\": [\n            \"['a']\",\n            \"['a', 'b', 'c']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"str1\": \"['x', 'y', 'z']\",\n            \"str2\": \"['x', 'y', 'z']\"\n        },\n        \"expected\": \"['x', 'y', 'z']\",\n        \"unexpected\": [\n            \"['x', 'y']\",\n            \"['x', 'z']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"str1\": \"['w', 'o']\",\n            \"str2\": \"['w', 'o', 'w']\"\n        },\n        \"expected\": \"['w', 'o']\",\n        \"unexpected\": [\n            \"['w']\",\n            \"['o']\",\n            \"['w', 'o', 'w']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"str1\": \"['a', 'x']\",\n            \"str2\": \"['b', 'y']\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"['a']\",\n            \"['b']\"\n        ]\n    },\n    {\n        \"input\": {\n            \"str1\": \"[]\",\n            \"str2\": \"['h', 'e', 'l', 'l', 'o']\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"['h']\",\n            \"['e']\"\n        ]\n    }\n]\n-/"}
{"id": "LV0152", "language": "lean", "source": "verina", "source_id": "verina_basic_72_task", "vc-description": "/- \n-----Description-----\nThe problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• b: An integer to be appended to the array.\n\n-----Output-----\nThe output is an array of integers which represents the original array with the element b added at the end. That is, the output array’s list representation equals a.toList concatenated with [b].\n\n-----Note-----\nThere are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.\n-/", "vc-preamble": "@[reducible, simp]\ndef append_precond (a : Array Int) (b : Int) : Prop :=\n  True", "vc-helpers": "def copy (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copy a (i + 1) (acc.push (a[i]!))\n  else\n    acc", "vc-definitions": "def append (a : Array Int) (b : Int) (h_precond : append_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef append_postcond (a : Array Int) (b : Int) (result: Array Int) (h_precond : append_precond (a) (b)) :=\n  (List.range' 0 a.size |>.all (fun i => result[i]! = a[i]!)) ∧\n  result[a.size]! = b ∧\n  result.size = a.size + 1\n\ntheorem append_spec_satisfied (a: Array Int) (b: Int) (h_precond : append_precond (a) (b)) :\n    append_postcond (a) (b) (append (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": 4\n        },\n        \"expected\": \"#[1, 2, 3, 4]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 0]\",\n            \"#[1, 2, 4, 3]\",\n            \"#[4, 1, 2, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": 0\n        },\n        \"expected\": \"#[0]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[]\",\n            \"#[0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 6]\",\n            \"b\": -1\n        },\n        \"expected\": \"#[5, 6, -1]\",\n        \"unexpected\": [\n            \"#[5, -1, 6]\",\n            \"#[5, 6, 0]\",\n            \"#[6, 5, -1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 0]\",\n            \"b\": 1\n        },\n        \"expected\": \"#[0, 0, 0, 1]\",\n        \"unexpected\": [\n            \"#[1, 0, 0, 0]\",\n            \"#[0, 1, 0, 0]\",\n            \"#[0, 0, 1, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-2, -3]\",\n            \"b\": -4\n        },\n        \"expected\": \"#[-2, -3, -4]\",\n        \"unexpected\": [\n            \"#[-2, -4, -3]\",\n            \"#[-2, -3, 0]\",\n            \"#[-3, -2, -4]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0153", "language": "lean", "source": "verina", "source_id": "verina_basic_73_task", "vc-description": "/- \n-----Description-----\nDetermine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----\nThe input consists of:\n• s: A string that is to be matched.\n• p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----\nThe output is a Boolean value:\n• Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.\n• Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----\nIt is assumed that both strings provided have the same length.\n-/", "vc-preamble": "@[reducible, simp]\ndef Match_precond (s : String) (p : String) : Prop :=\n  s.toList.length = p.toList.length", "vc-helpers": "", "vc-definitions": "def Match (s : String) (p : String) (h_precond : Match_precond (s) (p)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Match_postcond (s : String) (p : String) (result: Bool) (h_precond : Match_precond (s) (p)) :=\n  (result = true ↔ ∀ n : Nat, n < s.toList.length → ((s.toList[n]! = p.toList[n]!) ∨ (p.toList[n]! = '?')))\n\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"s\": \"abc\",\n            \"p\": \"ac\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"abc\",\n            \"p\": \"a?c\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"hello\",\n            \"p\": \"he?lo\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"world\",\n            \"p\": \"w?rld\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"test\",\n            \"p\": \"te?t\"\n        },\n        \"expected\": true,\n        \"unexpected\": [\n            false\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"abc\",\n            \"p\": \"abd\"\n        },\n        \"expected\": false,\n        \"unexpected\": [\n            true\n        ]\n    }\n]\n-/"}
{"id": "LV0154", "language": "lean", "source": "verina", "source_id": "verina_basic_74_task", "vc-description": "/- \n-----Description-----\nThis task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).\n\n-----Output-----\nThe output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:\n• It is greater than or equal to every element in the array.\n• It is exactly equal to one of the elements in the array.\n\n-----Note-----\nIt is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.\n-/", "vc-preamble": "@[reducible, simp]\ndef maxArray_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "def maxArray_aux (a : Array Int) (index : Nat) (current : Int) : Int :=\n  if index < a.size then\n    let new_current := if current > a[index]! then current else a[index]!\n    maxArray_aux a (index + 1) new_current\n  else\n    current", "vc-definitions": "def maxArray (a : Array Int) (h_precond : maxArray_precond (a)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxArray_postcond (a : Array Int) (result: Int) (h_precond : maxArray_precond (a)) :=\n  (∀ (k : Nat), k < a.size → result >= a[k]!) ∧ (∃ (k : Nat), k < a.size ∧ result = a[k]!)\n\ntheorem maxArray_spec_satisfied (a: Array Int) (h_precond : maxArray_precond (a)) :\n    maxArray_postcond (a) (maxArray (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 3, 4, 1, 2]\"\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            3,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            6,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -5, -3, -4]\"\n        },\n        \"expected\": -1,\n        \"unexpected\": [\n            -3,\n            -4\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-10, -20, -30, -5, -15]\"\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            -10,\n            -15,\n            -20\n        ]\n    }\n]\n-/"}
{"id": "LV0155", "language": "lean", "source": "verina", "source_id": "verina_basic_75_task", "vc-description": "/- \n-----Description-----\nThis task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (the array is assumed to be non-empty).\n\n-----Output-----\nThe output is an integer that:\n• Is the smallest element from the input array.\n• Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.\n\n-----Note-----\nIt is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.\n-/", "vc-preamble": "@[reducible, simp]\ndef minArray_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "def loop (a : Array Int) (i : Nat) (currentMin : Int) : Int :=\n  if i < a.size then\n    let newMin := if currentMin > a[i]! then a[i]! else currentMin\n    loop a (i + 1) newMin\n  else\n    currentMin", "vc-definitions": "def minArray (a : Array Int) (h_precond : minArray_precond (a)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef minArray_postcond (a : Array Int) (result: Int) (h_precond : minArray_precond (a)) :=\n  (∀ i : Nat, i < a.size → result <= a[i]!) ∧ (∃ i : Nat, i < a.size ∧ result = a[i]!)\n\ntheorem minArray_spec_satisfied (a: Array Int) (h_precond : minArray_precond (a)) :\n    minArray_postcond (a) (minArray (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[5, 3, 8, 2, 7]\"\n        },\n        \"expected\": \"2\",\n        \"unexpected\": [\n            3,\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 10, 10]\"\n        },\n        \"expected\": \"10\",\n        \"unexpected\": [\n            0,\n            5,\n            11\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -5, 3, 0]\"\n        },\n        \"expected\": \"-5\",\n        \"unexpected\": [\n            -1,\n            0,\n            3\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[42]\"\n        },\n        \"expected\": \"42\",\n        \"unexpected\": [\n            0,\n            -42,\n            100\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[3, -2, 0, -2, 5]\"\n        },\n        \"expected\": \"-2\",\n        \"unexpected\": [\n            0,\n            3,\n            5\n        ]\n    }\n]\n-/"}
{"id": "LV0156", "language": "lean", "source": "verina", "source_id": "verina_basic_76_task", "vc-description": "/- \n-----Description-----\nThis task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.\n\n-----Input-----\nThe input consists of two integers:\n• x: The first integer.\n• y: The second integer.\n\n-----Output-----\nThe output is an integer representing the minimum of the two input integers:\n• Returns x if x is less than or equal to y.\n• Returns y if x is greater than y.\n-/", "vc-preamble": "@[reducible, simp]\ndef myMin_precond (x : Int) (y : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def myMin (x : Int) (y : Int) (h_precond : myMin_precond (x) (y)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myMin_postcond (x : Int) (y : Int) (result: Int) (h_precond : myMin_precond (x) (y)) :=\n  (x ≤ y → result = x) ∧ (x > y → result = y)\n\ntheorem myMin_spec_satisfied (x: Int) (y: Int) (h_precond : myMin_precond (x) (y)) :\n    myMin_postcond (x) (y) (myMin (x) (y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 3,\n            \"y\": 5\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            5,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10,\n            \"y\": 7\n        },\n        \"expected\": 7,\n        \"unexpected\": [\n            10,\n            17\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 4,\n            \"y\": 4\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            0,\n            8\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5,\n            \"y\": 0\n        },\n        \"expected\": -5,\n        \"unexpected\": [\n            0,\n            -4\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 0,\n            \"y\": -10\n        },\n        \"expected\": -10,\n        \"unexpected\": [\n            0,\n            -8\n        ]\n    }\n]\n-/"}
{"id": "LV0157", "language": "lean", "source": "verina", "source_id": "verina_basic_77_task", "vc-description": "/- \n-----Description-----\nThis task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of arrays of natural numbers.\n• index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).\n• index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).\n• val: A natural number which is the new value to set at the specified inner index.\n\n-----Output-----\nThe output is an array of arrays of natural numbers that:\n• Has the same overall structure as the input.\n• Contains all original inner arrays unchanged except for the inner array at position index1.\n• In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.\n\n-----Note-----\nIt is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.\n-/", "vc-preamble": "@[reducible, simp]\ndef modify_array_element_precond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) : Prop :=\n  index1 < arr.size ∧\n  index2 < (arr[index1]!).size", "vc-helpers": "def updateInner (a : Array Nat) (idx val : Nat) : Array Nat :=\n  a.set! idx val", "vc-definitions": "def modify_array_element (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) : Array (Array Nat) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef modify_array_element_postcond (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) (result: Array (Array Nat)) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :=\n  (∀ i, i < arr.size → i ≠ index1 → result[i]! = arr[i]!) ∧\n  (∀ j, j < (arr[index1]!).size → j ≠ index2 → (result[index1]!)[j]! = (arr[index1]!)[j]!) ∧\n  ((result[index1]!)[index2]! = val)\n\ntheorem modify_array_element_spec_satisfied (arr: Array (Array Nat)) (index1: Nat) (index2: Nat) (val: Nat) (h_precond : modify_array_element_precond (arr) (index1) (index2) (val)) :\n    modify_array_element_postcond (arr) (index1) (index2) (val) (modify_array_element (arr) (index1) (index2) (val) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr\": \"#[#[1, 2, 3], #[4, 5, 6]]\",\n            \"index1\": 1,\n            \"index2\": 3,\n            \"val\": 99\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[#[1, 2, 3], #[4, 5, 6]]\",\n            \"index1\": 0,\n            \"index2\": 1,\n            \"val\": 99\n        },\n        \"expected\": \"#[#[1, 99, 3], #[4, 5, 6]]\",\n        \"unexpected\": [\n            \"#[#[1, 2, 3], #[4, 99, 6]]\",\n            \"#[#[1, 99, 3], #[4, 5, 7]]\",\n            \"#[#[99, 1, 3], #[4, 5, 6]]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[#[7, 8], #[9, 10]]\",\n            \"index1\": 1,\n            \"index2\": 0,\n            \"val\": 0\n        },\n        \"expected\": \"#[#[7, 8], #[0, 10]]\",\n        \"unexpected\": [\n            \"#[#[7, 0], #[9, 10]]\",\n            \"#[#[7, 8], #[9, 0]]\",\n            \"#[#[0, 8], #[9, 10]]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[#[0, 0, 0]]\",\n            \"index1\": 0,\n            \"index2\": 2,\n            \"val\": 5\n        },\n        \"expected\": \"#[#[0, 0, 5]]\",\n        \"unexpected\": [\n            \"#[#[0, 5, 0]]\",\n            \"#[#[5, 0, 0]]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]\",\n            \"index1\": 2,\n            \"index2\": 1,\n            \"val\": 100\n        },\n        \"expected\": \"#[#[3, 4, 5], #[6, 7, 8], #[9, 100, 11]]\",\n        \"unexpected\": [\n            \"#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]\",\n            \"#[#[3, 4, 5], #[6, 7, 8], #[9, 7, 11]]\",\n            \"#[#[3, 4, 5], #[6, 7, 8], #[100, 10, 11]]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[#[1]]\",\n            \"index1\": 0,\n            \"index2\": 0,\n            \"val\": 42\n        },\n        \"expected\": \"#[#[42]]\",\n        \"unexpected\": [\n            \"#[#[1]]\",\n            \"#[#[0]]\",\n            \"#[#[99]]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0158", "language": "lean", "source": "verina", "source_id": "verina_basic_78_task", "vc-description": "/- \n-----Description-----\nGiven two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.\n\n-----Input-----\nThe input consists of two integers:\n• x: An integer.\n• y: An integer.\n\n-----Output-----\nThe output is a tuple of two integers:\n• The first element is x + y.\n• The second element is x - y.\n\n-----Note-----\nIt is assumed that x and y are valid integers. There are no additional constraints on the inputs.\n-/", "vc-preamble": "@[reducible, simp]\ndef MultipleReturns_precond (x : Int) (y : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def MultipleReturns (x : Int) (y : Int) (h_precond : MultipleReturns_precond (x) (y)) : (Int × Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef MultipleReturns_postcond (x : Int) (y : Int) (result: (Int × Int)) (h_precond : MultipleReturns_precond (x) (y)) :=\n  result.1 = x + y ∧ result.2 + y = x\n\ntheorem MultipleReturns_spec_satisfied (x: Int) (y: Int) (h_precond : MultipleReturns_precond (x) (y)) :\n    MultipleReturns_postcond (x) (y) (MultipleReturns (x) (y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 3,\n            \"y\": 2\n        },\n        \"expected\": \"(5, 1)\",\n        \"unexpected\": [\n            \"(6, 2)\",\n            \"(5, 2)\",\n            \"(4, 1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -2,\n            \"y\": 3\n        },\n        \"expected\": \"(1, -5)\",\n        \"unexpected\": [\n            \"(-1, 5)\",\n            \"(2, -3)\",\n            \"(1, 5)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 0,\n            \"y\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(1, 0)\",\n            \"(0, 1)\",\n            \"(-1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10,\n            \"y\": 5\n        },\n        \"expected\": \"(15, 5)\",\n        \"unexpected\": [\n            \"(14, 5)\",\n            \"(15, 6)\",\n            \"(10, 5)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5,\n            \"y\": -10\n        },\n        \"expected\": \"(-15, 5)\",\n        \"unexpected\": [\n            \"(-15, -5)\",\n            \"(-5, 15)\",\n            \"(-10, 0)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0159", "language": "lean", "source": "verina", "source_id": "verina_basic_79_task", "vc-description": "/- \n-----Description-----\nGiven a nonempty array of integers and a valid index x (with 1 ≤ x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (assumed to be nonempty).\n• x: A natural number (Nat) such that 1 ≤ x < a.size.\n\n-----Output-----\nThe output is a pair (m, p) where:\n• m is the maximum value among the first x elements of the array.\n• p is an index in the array, with x ≤ p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size − 1.\n\n-----Note-----\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 ≤ x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.\n-/", "vc-preamble": "@[reducible, simp]\ndef onlineMax_precond (a : Array Int) (x : Nat) : Prop :=\n  a.size > 0 ∧ x < a.size", "vc-helpers": "def findBest (a : Array Int) (x : Nat) (i : Nat) (best : Int) : Int :=\n  if i < x then\n    let newBest := if a[i]! > best then a[i]! else best\n    findBest a x (i + 1) newBest\n  else best\n\ndef findP (a : Array Int) (x : Nat) (m : Int) (i : Nat) : Nat :=\n  if i < a.size then\n    if a[i]! > m then i else findP a x m (i + 1)\n  else a.size - 1", "vc-definitions": "def onlineMax (a : Array Int) (x : Nat) (h_precond : onlineMax_precond (a) (x)) : Int × Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef onlineMax_postcond (a : Array Int) (x : Nat) (result: Int × Nat) (h_precond : onlineMax_precond (a) (x)) :=\n  let (m, p) := result;\n  (x ≤ p ∧ p < a.size) ∧\n  (∀ i, i < x → a[i]! ≤ m) ∧\n  (∃ i, i < x ∧ a[i]! = m) ∧\n  ((p < a.size - 1) → (∀ i, i < p → a[i]! < a[p]!)) ∧\n  ((∀ i, x ≤ i → i < a.size → a[i]! ≤ m) → p = a.size - 1)\n\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"x\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[3, 7, 5, 2, 9]\",\n            \"x\": 3\n        },\n        \"expected\": \"(7, 4)\",\n        \"unexpected\": [\n            \"(7, 3)\",\n            \"(5, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 10, 5, 1]\",\n            \"x\": 2\n        },\n        \"expected\": \"(10, 3)\",\n        \"unexpected\": [\n            \"(10, 2)\",\n            \"(7, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 3, 3, 3, 1]\",\n            \"x\": 2\n        },\n        \"expected\": \"(3, 4)\",\n        \"unexpected\": [\n            \"(2, 4)\",\n            \"(3, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 4, 4, 6, 2]\",\n            \"x\": 2\n        },\n        \"expected\": \"(5, 3)\",\n        \"unexpected\": [\n            \"(4, 2)\",\n            \"(5, 2)\",\n            \"(6, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 8, 7, 7, 7]\",\n            \"x\": 3\n        },\n        \"expected\": \"(8, 4)\",\n        \"unexpected\": [\n            \"(7, 4)\",\n            \"(8, 3)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0160", "language": "lean", "source": "verina", "source_id": "verina_basic_80_task", "vc-description": "/- \n-----Description-----\nThis task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• key: An integer representing the element whose occurrence is to be checked.\n\n-----Output-----\nThe output is a Boolean value that:\n• Is true if the key appears exactly once in the array.\n• Is false otherwise.\n\n-----Note-----\nThe function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.\n-/", "vc-preamble": "@[reducible, simp]\ndef only_once_precond (a : Array Int) (key : Int) : Prop :=\n  True", "vc-helpers": "def only_once_loop {T : Type} [DecidableEq T] (a : Array T) (key : T) (i keyCount : Nat) : Bool :=\n  if i < a.size then\n    match a[i]? with\n    | some val =>\n        let newCount := if val = key then keyCount + 1 else keyCount\n        only_once_loop a key (i + 1) newCount\n    | none => keyCount == 1\n  else\n    keyCount == 1", "vc-definitions": "def only_once (a : Array Int) (key : Int) (h_precond : only_once_precond (a) (key)) : Bool :=\n  sorry", "vc-theorems": "def count_occurrences {T : Type} [DecidableEq T] (a : Array T) (key : T) : Nat :=\n  a.foldl (fun cnt x => if x = key then cnt + 1 else cnt) 0\n@[reducible, simp]\ndef only_once_postcond (a : Array Int) (key : Int) (result: Bool) (h_precond : only_once_precond (a) (key)) :=\n  ((count_occurrences a key = 1) → result) ∧\n  ((count_occurrences a key ≠ 1) → ¬ result)\n\ntheorem only_once_spec_satisfied (a: Array Int) (key: Int) (h_precond : only_once_precond (a) (key)) :\n    only_once_postcond (a) (key) (only_once (a) (key) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"key\": 2\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 2, 3, 4]\",\n            \"key\": 2\n        },\n        \"expected\": \"false\",\n        \"unexpected\": [true]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 1, 1, 1]\",\n            \"key\": 1\n        },\n        \"expected\": \"false\",\n        \"unexpected\": [true]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\",\n            \"key\": 10\n        },\n        \"expected\": \"true\",\n        \"unexpected\": [false]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"key\": 5\n        },\n        \"expected\": \"false\",\n        \"unexpected\": [true]\n    }\n]\n-/"}
{"id": "LV0161", "language": "lean", "source": "verina", "source_id": "verina_basic_81_task", "vc-description": "/- \n-----Description-----\nThis task involves performing integer division with remainder on natural numbers. Given two natural numbers, x (the dividend) and y (the divisor), the objective is to determine the quotient and remainder. When y is non-zero, the quotient and remainder should satisfy the condition that the dividend equals the divisor multiplied by the quotient plus the remainder, with the remainder being nonnegative and strictly less than y. In the case where y is zero, the result should indicate that no division is performed by returning x as the quotient and 0 as the remainder.\n\n-----Input-----\nThe input consists of two natural numbers:\n• x: A natural number representing the dividend.\n• y: A natural number representing the divisor.\n\n-----Output-----\nThe output is a pair of integers (r, q) where:\n• If y ≠ 0, then q is the quotient and r is the remainder such that:\n   - q * Int.ofNat y + r = Int.ofNat x\n   - 0 ≤ r < Int.ofNat y\n   - 0 ≤ q\n• If y = 0, then the output is (Int.ofNat x, 0).\n\n-----Note-----\nThe specification regarding the division properties applies only when y is non-zero. When y = 0, the function safely returns (x, 0) in its integer form.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef DivisionFunction_precond (x : Nat) (y : Nat) : Prop :=\n  True", "vc-helpers": "def divMod (x y : Nat) : Int × Int :=\n  let q : Int := Int.ofNat (x / y)\n  let r : Int := Int.ofNat (x % y)\n  (r, q)", "vc-definitions": "def DivisionFunction (x : Nat) (y : Nat) (h_precond : DivisionFunction_precond (x) (y)) : Int × Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef DivisionFunction_postcond (x : Nat) (y : Nat) (result: Int × Int) (h_precond : DivisionFunction_precond (x) (y)) :=\n  let (r, q) := result;\n  (y = 0 → r = Int.ofNat x ∧ q = 0) ∧\n  (y ≠ 0 → (q * Int.ofNat y + r = Int.ofNat x) ∧ (0 ≤ r ∧ r < Int.ofNat y) ∧ (0 ≤ q))\n\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 10,\n            \"y\": 3\n        },\n        \"expected\": \"(1, 3)\",\n        \"unexpected\": [\n            \"(2, 2)\",\n            \"(0, 3)\",\n            \"(1, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 15,\n            \"y\": 5\n        },\n        \"expected\": \"(0, 3)\",\n        \"unexpected\": [\n            \"(3, 0)\",\n            \"(1, 1)\",\n            \"(0, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 7,\n            \"y\": 2\n        },\n        \"expected\": \"(1, 3)\",\n        \"unexpected\": [\n            \"(3, 1)\",\n            \"(0, 7)\",\n            \"(1, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 0,\n            \"y\": 4\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 0)\",\n            \"(2, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10,\n            \"y\": 0\n        },\n        \"expected\": \"(10, 0)\",\n        \"unexpected\": [\n            \"(0, 10)\",\n            \"(10, 1)\",\n            \"(5, 5)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0162", "language": "lean", "source": "verina", "source_id": "verina_basic_82_task", "vc-description": "/- \n-----Description-----\nThis task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n• Has a length equal to the original array's length minus one.\n• Contains the same elements as the input array except for the first element.\n• Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.\n\n-----Note-----\nIt is assumed that the input array is non-empty.\n-/", "vc-preamble": "@[reducible, simp]\ndef remove_front_precond (a : Array Int) : Prop :=\n  a.size > 0", "vc-helpers": "def copyFrom (a : Array Int) (i : Nat) (acc : Array Int) : Array Int :=\n  if i < a.size then\n    copyFrom a (i + 1) (acc.push (a[i]!))\n  else\n    acc", "vc-definitions": "def remove_front (a : Array Int) (h_precond : remove_front_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef remove_front_postcond (a : Array Int) (result: Array Int) (h_precond : remove_front_precond (a)) :=\n  a.size > 0 ∧ result.size = a.size - 1 ∧ (∀ i : Nat, i < result.size → result[i]! = a[i + 1]!)\n\ntheorem remove_front_spec_satisfied (a: Array Int) (h_precond : remove_front_precond (a)) :\n    remove_front_postcond (a) (remove_front (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"#[2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[3, 4, 5]\",\n            \"#[2, 3, 4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30]\"\n        },\n        \"expected\": \"#[20, 30]\",\n        \"unexpected\": [\n            \"#[10, 20, 30]\",\n            \"#[10, 30]\",\n            \"#[10, 20]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, -1, -2, -3]\"\n        },\n        \"expected\": \"#[-1, -2, -3]\",\n        \"unexpected\": [\n            \"#[0, -1, -2, -3]\",\n            \"#[-1, -3]\",\n            \"#[-2, -3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[7]\",\n            \"#[0]\",\n            \"#[7, 7]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[100, 0, 50]\"\n        },\n        \"expected\": \"#[0, 50]\",\n        \"unexpected\": [\n            \"#[100, 0, 50]\",\n            \"#[50]\",\n            \"#[0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0163", "language": "lean", "source": "verina", "source_id": "verina_basic_83_task", "vc-description": "/- \n-----Description-----\nThis task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.\n\n-----Input-----\nThe input consists of two parameters:\n• a: An Array of integers representing the first part of the concatenated array.\n• b: An Array of integers representing the second part of the concatenated array.\n\n-----Output-----\nThe output is an Array of integers that satisfies the following:\n• The length of the output array is equal to the sum of the lengths of arrays a and b.\n• The first part of the output array (indices 0 to a.size - 1) is identical to array a.\n• The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.\n\n-----Note-----\nNo additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.\n-/", "vc-preamble": "@[reducible, simp]\ndef concat_precond (a : Array Int) (b : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def concat (a : Array Int) (b : Array Int) (h_precond : concat_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef concat_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : concat_precond (a) (b)) :=\n  result.size = a.size + b.size\n    ∧ (∀ k, k < a.size → result[k]! = a[k]!)\n    ∧ (∀ k, k < b.size → result[k + a.size]! = b[k]!)\n\ntheorem concat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : concat_precond (a) (b)) :\n    concat_postcond (a) (b) (concat (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 5, 4]\",\n            \"#[4, 5, 1, 2, 3]\",\n            \"#[1, 2, 4, 3, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"b\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[1, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\",\n            \"b\": \"#[20, 30, 40]\"\n        },\n        \"expected\": \"#[10, 20, 30, 40]\",\n        \"unexpected\": [\n            \"#[10, 20, 30]\",\n            \"#[20, 30, 40, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -2]\",\n            \"b\": \"#[0]\"\n        },\n        \"expected\": \"#[-1, -2, 0]\",\n        \"unexpected\": [\n            \"#[-1, 0, -2]\",\n            \"#[0, -1, -2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7, 8, 9]\",\n            \"b\": \"#[]\"\n        },\n        \"expected\": \"#[7, 8, 9]\",\n        \"unexpected\": [\n            \"#[7, 8]\",\n            \"#[8, 9]\",\n            \"#[]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0164", "language": "lean", "source": "verina", "source_id": "verina_basic_84_task", "vc-description": "/- \n-----Description-----\nYou are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of integers.\n• k: An integer used as the threshold for replacement.\n\n-----Output-----\nThe output is an array of integers that satisfies the following conditions:\n• For every index i, if arr[i] is greater than k, then the returned array at index i is -1.\n• For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.\n\n-----Note-----\nIt is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.\n-/", "vc-preamble": "@[reducible, simp]\ndef replace_precond (arr : Array Int) (k : Int) : Prop :=\n  True", "vc-helpers": "def replace_loop (oldArr : Array Int) (k : Int) : Nat → Array Int → Array Int\n| i, acc =>\n  if i < oldArr.size then\n    if (oldArr[i]!) > k then\n      replace_loop oldArr k (i+1) (acc.set! i (-1))\n    else\n      replace_loop oldArr k (i+1) acc\n  else\n    acc", "vc-definitions": "def replace (arr : Array Int) (k : Int) (h_precond : replace_precond (arr) (k)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replace_postcond (arr : Array Int) (k : Int) (result: Array Int) (h_precond : replace_precond (arr) (k)) :=\n  (∀ i : Nat, i < arr.size → (arr[i]! > k → result[i]! = -1)) ∧\n  (∀ i : Nat, i < arr.size → (arr[i]! ≤ k → result[i]! = arr[i]!))\n\ntheorem replace_spec_satisfied (arr: Array Int) (k: Int) (h_precond : replace_precond (arr) (k)) :\n    replace_postcond (arr) (k) (replace (arr) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 5, 3, 10]\",\n            \"k\": 4\n        },\n        \"expected\": \"#[1, -1, 3, -1]\",\n        \"unexpected\": [\n            \"#[1, 5, 3, 10]\",\n            \"#[1, -1, 3, 10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-1, 0, 1, 2]\",\n            \"k\": 2\n        },\n        \"expected\": \"#[-1, 0, 1, 2]\",\n        \"unexpected\": [\n            \"#[0, 0, 1, 2]\",\n            \"#[-1, 0, 1, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[100, 50, 100]\",\n            \"k\": 100\n        },\n        \"expected\": \"#[100, 50, 100]\",\n        \"unexpected\": [\n            \"#[100, 50, -1]\",\n            \"#[100, 50, 50]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-5, -2, 0, 3]\",\n            \"k\": -3\n        },\n        \"expected\": \"#[-5, -1, -1, -1]\",\n        \"unexpected\": [\n            \"#[-5, -2, -1, -1]\",\n            \"#[-5, -1, 0, -1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3]\",\n            \"k\": 5\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[1, 3, 3]\",\n            \"#[1, 2, -1]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0165", "language": "lean", "source": "verina", "source_id": "verina_basic_85_task", "vc-description": "/- \n-----Description-----\nThis problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers, which may be empty, contain one element, or many elements.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input array.\n• Contains the same elements as the input array, but in reverse order.\n• For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.\n\n-----Note-----\nThere are no specific preconditions; the method should correctly handle any array of integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef reverse_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "def reverse_core (arr : Array Int) (i : Nat) : Array Int :=\n  if i < arr.size / 2 then\n    let j := arr.size - 1 - i\n    let temp := arr[i]!\n    let arr' := arr.set! i (arr[j]!)\n    let arr'' := arr'.set! j temp\n    reverse_core arr'' (i + 1)\n  else\n    arr", "vc-definitions": "def reverse (a : Array Int) (h_precond : reverse_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef reverse_postcond (a : Array Int) (result: Array Int) (h_precond : reverse_precond (a)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → result[i]! = a[a.size - 1 - i]!)\n\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond (a)) :\n    reverse_postcond (a) (reverse (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\"\n        },\n        \"expected\": \"#[5, 4, 3, 2, 1]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[5, 3, 4, 2, 1]\",\n            \"#[2, 3, 4, 5, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30, 40]\"\n        },\n        \"expected\": \"#[40, 30, 20, 10]\",\n        \"unexpected\": [\n            \"#[10, 20, 30, 40]\",\n            \"#[40, 20, 30, 10]\",\n            \"#[30, 20, 10, 40]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[-1]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\"\n        },\n        \"expected\": \"#[7]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[7, 7]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, 0, 1]\"\n        },\n        \"expected\": \"#[1, 0, -1]\",\n        \"unexpected\": [\n            \"#[-1, 0, 1]\",\n            \"#[0, 1, -1]\",\n            \"#[1, -1, 0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0166", "language": "lean", "source": "verina", "source_id": "verina_basic_86_task", "vc-description": "/- \n-----Description-----\nThis task requires writing a Lean 4 method that rotates an array of integers to the left by a specified offset.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (which may be empty or non-empty).\n• offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input array.\n• For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.\n\n-----Note-----\nIf the array is empty, the method should return an empty array.\n-/", "vc-preamble": "@[reducible, simp]\ndef rotate_precond (a : Array Int) (offset : Int) : Prop :=\n  offset ≥ 0", "vc-helpers": "def rotateAux (a : Array Int) (offset : Int) (i : Nat) (len : Nat) (b : Array Int) : Array Int :=\n  if i < len then\n    let idx_int : Int := (Int.ofNat i + offset) % (Int.ofNat len)\n    let idx_int_adjusted := if idx_int < 0 then idx_int + Int.ofNat len else idx_int\n    let idx_nat : Nat := Int.toNat idx_int_adjusted\n    let new_b := b.set! i (a[idx_nat]!)\n    rotateAux a offset (i + 1) len new_b\n  else b", "vc-definitions": "def rotate (a : Array Int) (offset : Int) (h_precond : rotate_precond (a) (offset)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef rotate_postcond (a : Array Int) (offset : Int) (result: Array Int) (h_precond : rotate_precond (a) (offset)) :=\n  result.size = a.size ∧\n  (∀ i : Nat, i < a.size →\n    result[i]! = a[Int.toNat ((Int.ofNat i + offset) % (Int.ofNat a.size))]!)\n\ntheorem rotate_spec_satisfied (a: Array Int) (offset: Int) (h_precond : rotate_precond (a) (offset)) :\n    rotate_postcond (a) (offset) (rotate (a) (offset) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"offset\": -1\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"offset\": 2\n        },\n        \"expected\": \"#[3, 4, 5, 1, 2]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[2, 3, 4, 5, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30, 40]\",\n            \"offset\": 1\n        },\n        \"expected\": \"#[20, 30, 40, 10]\",\n        \"unexpected\": [\n            \"#[10, 20, 30, 40]\",\n            \"#[40, 10, 20, 30]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[]\",\n            \"offset\": 5\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[7]\",\n            \"offset\": 0\n        },\n        \"expected\": \"#[7]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[8]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -2, -3, -4]\",\n            \"offset\": 3\n        },\n        \"expected\": \"#[-4, -1, -2, -3]\",\n        \"unexpected\": [\n            \"#[-1, -2, -3, -4]\",\n            \"#[-3, -4, -1, -2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 10, 15]\",\n            \"offset\": 5\n        },\n        \"expected\": \"#[15, 5, 10]\",\n        \"unexpected\": [\n            \"#[5, 10, 15]\",\n            \"#[10, 15, 5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0167", "language": "lean", "source": "verina", "source_id": "verina_basic_87_task", "vc-description": "/- \n-----Description-----\nThis problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (Array Int).\n\n-----Output-----\nThe output is an array of integers that is:\n• Sorted in non-decreasing order.\n• A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.\n\n-----Note-----\nIt is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.\n-/", "vc-preamble": "@[reducible, simp]\ndef SelectionSort_precond (a : Array Int) : Prop :=\n  True", "vc-helpers": "def findMinIndexInRange (arr : Array Int) (start finish : Nat) : Nat :=\n  let indices := List.range (finish - start)\n  indices.foldl (fun minIdx i =>\n    let currIdx := start + i\n    if arr[currIdx]! < arr[minIdx]! then currIdx else minIdx\n  ) start\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  if i < a.size && j < a.size && i ≠ j then\n    let temp := a[i]!\n    let a' := a.set! i a[j]!\n    a'.set! j temp\n  else a", "vc-definitions": "def SelectionSort (a : Array Int) (h_precond : SelectionSort_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SelectionSort_postcond (a : Array Int) (result: Array Int) (h_precond : SelectionSort_precond (a)) :=\n  List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm a.toList result.toList\n\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[3, 1, 2]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[3, 1, 2]\",\n            \"#[2, 3, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0]\"\n        },\n        \"expected\": \"#[0]\",\n        \"unexpected\": [\n            \"#[0, 0]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 4, 3, 2, 1]\"\n        },\n        \"expected\": \"#[1, 2, 3, 4, 5]\",\n        \"unexpected\": [\n            \"#[5, 4, 3, 2, 1]\",\n            \"#[1, 5, 4, 3, 2]\",\n            \"#[1, 2, 4, 3, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2, 2, 1, 4]\"\n        },\n        \"expected\": \"#[1, 2, 2, 4]\",\n        \"unexpected\": [\n            \"#[2, 1, 2, 4]\",\n            \"#[1, 2, 4, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, -5, 0, 3]\"\n        },\n        \"expected\": \"#[-5, 0, 3, 10]\",\n        \"unexpected\": [\n            \"#[10, -5, 3, 0]\",\n            \"#[0, -5, 3, 10]\",\n            \"#[3, -5, 10, 0]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0168", "language": "lean", "source": "verina", "source_id": "verina_basic_88_task", "vc-description": "/- \n-----Description-----\nThis task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.\n\n-----Input-----\nThe input consists of:\n• xs: A list of integer elements.\n\n-----Output-----\nThe output is an array of elements of type integer that:\n• Has a size equal to the length of the input list xs.\n• Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.\n\n-----Note-----\nThere are no additional preconditions; the method should work correctly for any list of elements.\nA corresponding specification is provided stating that the array’s size equals the list’s length and that each element is preserved.\n-/", "vc-preamble": "@[reducible, simp]\ndef ToArray_precond (xs : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def ToArray (xs : List Int) (h_precond : ToArray_precond (xs)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef ToArray_postcond (xs : List Int) (result: Array Int) (h_precond : ToArray_precond (xs)) :=\n  result.size = xs.length ∧ ∀ (i : Nat), i < xs.length → result[i]! = xs[i]!\n\ntheorem ToArray_spec_satisfied (xs: List Int) (h_precond : ToArray_precond (xs)) :\n    ToArray_postcond (xs) (ToArray (xs) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"xs\": \"[1, 2, 3]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[1, 2]\",\n            \"#[1, 2, 3, 4]\",\n            \"#[3, 2, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1]\",\n            \"#[1, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[0, -1, 5]\"\n        },\n        \"expected\": \"#[0, -1, 5]\",\n        \"unexpected\": [\n            \"#[-1, 0, 5]\",\n            \"#[0, 5]\",\n            \"#[0, -1, 4]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[7]\"\n        },\n        \"expected\": \"#[7]\",\n        \"unexpected\": [\n            \"#[]\",\n            \"#[0, 7]\",\n            \"#[8]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"xs\": \"[100, 200, 300, 400]\"\n        },\n        \"expected\": \"#[100, 200, 300, 400]\",\n        \"unexpected\": [\n            \"#[100, 200, 300]\",\n            \"#[100, 300, 200, 400]\",\n            \"#[400, 300, 200, 100]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0169", "language": "lean", "source": "verina", "source_id": "verina_basic_89_task", "vc-description": "/- \n-----Description-----\nThis problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----\nThe input consists of:\n• s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----\nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----\nNo additional preconditions are required. The method should correctly handle any list, including an empty list.\n-/", "vc-preamble": "@[reducible, simp]\ndef SetToSeq_precond (s : List Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def SetToSeq (s : List Int) (h_precond : SetToSeq_precond (s)) : List Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SetToSeq_postcond (s : List Int) (result: List Int) (h_precond : SetToSeq_precond (s)) :=\n  -- Contains exactly the elements of the set\n  result.all (fun a => a ∈ s) ∧ s.all (fun a => a ∈ result) ∧\n  -- All elements are unique in the result\n  result.all (fun a => result.count a = 1) ∧\n  -- The order of elements in the result is preserved\n  List.Pairwise (fun a b => (result.idxOf a < result.idxOf b) → (s.idxOf a < s.idxOf b)) result\n\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"[1, 2, 2, 3, 1]\"\n        },\n        \"expected\": \"[1, 2, 3]\",\n        \"unexpected\": [\n            \"[1, 3, 2]\",\n            \"[1, 2, 2, 3]\",\n            \"[2, 1, 3]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[5, 5, 5, 5]\"\n        },\n        \"expected\": \"[5]\",\n        \"unexpected\": [\n            \"[5, 5]\",\n            \"[]\",\n            \"[6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[]\"\n        },\n        \"expected\": \"[]\",\n        \"unexpected\": [\n            \"[1]\",\n            \"[2]\",\n            \"[0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[11, 22, 33]\"\n        },\n        \"expected\": \"[11, 22, 33]\",\n        \"unexpected\": [\n            \"[33, 22, 11]\",\n            \"[11, 11, 22, 33]\",\n            \"[11, 33]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"[3, 1, 4, 1, 5, 9, 2, 6, 5]\"\n        },\n        \"expected\": \"[3, 1, 4, 5, 9, 2, 6]\",\n        \"unexpected\": [\n            \"[3, 1, 4, 1, 5, 9, 2, 6, 5]\",\n            \"[1, 3, 4, 5, 9, 2, 6]\",\n            \"[3, 1, 4, 5, 9, 6]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0170", "language": "lean", "source": "verina", "source_id": "verina_basic_90_task", "vc-description": "/- \n-----Description-----\nThe task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----\nThe input consists of:\n• a: A non-empty 2D array of integers (Array (Array Int)). The array is guaranteed to contain at least one element.\n• key: An integer value (Int) to search for in the array.\n\n-----Output-----\nThe output is a pair of integers (Int × Int):\n• If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.\n• If the key is not found, the function returns (-1, -1).\n\n-----Note-----\nIt is assumed that the input 2D array is sorted by rows and columns.\n-/", "vc-preamble": "@[reducible, simp]\ndef SlopeSearch_precond (a : Array (Array Int)) (key : Int) : Prop :=\n  List.Pairwise (·.size = ·.size) a.toList ∧\n  a.all (fun x => List.Pairwise (· ≤ ·) x.toList) ∧\n  (\n    a.size = 0 ∨ (\n      (List.range (a[0]!.size)).all (fun i =>\n        List.Pairwise (· ≤ ·) (a.map (fun x => x[i]!)).toList\n      )\n    )\n  )", "vc-helpers": "@[reducible, simp]\ndef get2d (a : Array (Array Int)) (i j : Int) : Int :=\n  (a[Int.toNat i]!)[Int.toNat j]!", "vc-definitions": "def SlopeSearch (a : Array (Array Int)) (key : Int) (h_precond : SlopeSearch_precond (a) (key)) : (Int × Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SlopeSearch_postcond (a : Array (Array Int)) (key : Int) (result: (Int × Int)) (h_precond : SlopeSearch_precond (a) (key)) :=\n  let (m, n) := result;\n  (m ≥ 0 ∧ m < a.size ∧ n ≥ 0 ∧ n < (a[0]!).size ∧ get2d a m n = key) ∨\n  (m = -1 ∧ n = -1 ∧ a.all (fun x => x.all (fun e => e ≠ key)))\n\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[#[1, 3, 2], #[0, 6, 5], #[7, 8, 9]]\",\n            \"key\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\",\n            \"key\": 5\n        },\n        \"expected\": \"(1, 1)\",\n        \"unexpected\": [\n            \"(1, 2)\",\n            \"(0, 1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\",\n            \"key\": 3\n        },\n        \"expected\": \"(0, 2)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\",\n            \"key\": 10\n        },\n        \"expected\": \"(-1, -1)\",\n        \"unexpected\": [\n            \"(1, 1)\",\n            \"(2, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[#[1, 2, 3, 4]]\",\n            \"key\": 4\n        },\n        \"expected\": \"(0, 3)\",\n        \"unexpected\": [\n            \"(0, 2)\",\n            \"(1, 3)\",\n            \"(0, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[#[1], #[2], #[3], #[4]]\",\n            \"key\": 3\n        },\n        \"expected\": \"(2, 0)\",\n        \"unexpected\": [\n            \"(1, 0)\",\n            \"(2, 1)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0171", "language": "lean", "source": "verina", "source_id": "verina_basic_91_task", "vc-description": "/- \n-----Description-----\nThis task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.\n\n-----Input-----\nThe input consists of two integers:\n• X: An integer representing the first value.\n• Y: An integer representing the second value.\n\n-----Output-----\nThe output is a pair (Int × Int) that:\n• Contains the original Y as the first element.\n• Contains the original X as the second element.\n\n-----Note-----\nThere are no additional preconditions. The function simply swaps the two input values.\n-/", "vc-preamble": "@[reducible, simp]\ndef Swap_precond (X : Int) (Y : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Swap (X : Int) (Y : Int) (h_precond : Swap_precond (X) (Y)) : Int × Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Swap_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : Swap_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\ntheorem Swap_spec_satisfied (X: Int) (Y: Int) (h_precond : Swap_precond (X) (Y)) :\n    Swap_postcond (X) (Y) (Swap (X) (Y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"X\": 1,\n            \"Y\": 2\n        },\n        \"expected\": \"(2, 1)\",\n        \"unexpected\": [\n            \"(1, 2)\",\n            \"(2, 2)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 0,\n            \"Y\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": -1,\n            \"Y\": 5\n        },\n        \"expected\": \"(5, -1)\",\n        \"unexpected\": [\n            \"(-1, 5)\",\n            \"(5, 5)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 100,\n            \"Y\": -100\n        },\n        \"expected\": \"(-100, 100)\",\n        \"unexpected\": [\n            \"(100, -100)\",\n            \"(-100, -100)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 42,\n            \"Y\": 42\n        },\n        \"expected\": \"(42, 42)\",\n        \"unexpected\": [\n            \"(41, 42)\",\n            \"(42, 41)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0172", "language": "lean", "source": "verina", "source_id": "verina_basic_92_task", "vc-description": "/- \n-----Description-----\nThis problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.\n\n-----Input-----\nThe input consists of two integers:\n• X: The first integer.\n• Y: The second integer.\n\n-----Output-----\nThe output is a tuple of two integers (Int × Int) where:\n• The first element is equal to Y.\n• The second element is equal to X.\n\n-----Note-----\nThere are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.\n-/", "vc-preamble": "@[reducible, simp]\ndef SwapArithmetic_precond (X : Int) (Y : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def SwapArithmetic (X : Int) (Y : Int) (h_precond : SwapArithmetic_precond (X) (Y)) : (Int × Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SwapArithmetic_postcond (X : Int) (Y : Int) (result: (Int × Int)) (h_precond : SwapArithmetic_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\ntheorem SwapArithmetic_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapArithmetic_precond (X) (Y)) :\n    SwapArithmetic_postcond (X) (Y) (SwapArithmetic (X) (Y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"X\": 3,\n            \"Y\": 4\n        },\n        \"expected\": \"(4, 3)\",\n        \"unexpected\": [\n            \"(3, 4)\",\n            \"(3, 3)\",\n            \"(4, 4)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": -1,\n            \"Y\": 10\n        },\n        \"expected\": \"(10, -1)\",\n        \"unexpected\": [\n            \"(-1, 10)\",\n            \"(10, 1)\",\n            \"(-10, -1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 0,\n            \"Y\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 0)\",\n            \"(-1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 100,\n            \"Y\": 50\n        },\n        \"expected\": \"(50, 100)\",\n        \"unexpected\": [\n            \"(100, 50)\",\n            \"(50, 50)\",\n            \"(100, 100)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": -5,\n            \"Y\": -10\n        },\n        \"expected\": \"(-10, -5)\",\n        \"unexpected\": [\n            \"(-5, -10)\",\n            \"(-10, -10)\",\n            \"(-5, -5)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0173", "language": "lean", "source": "verina", "source_id": "verina_basic_93_task", "vc-description": "/- \n-----Description-----\nThis task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\n-----Input-----\nThe input consists of:\n• X: A UInt8 value.\n• Y: A UInt8 value.\n\n-----Output-----\nThe output is a pair of UInt8 values (newX, newY) where:\n• newX is equal to the original Y.\n• newY is equal to the original X.\n\n-----Note-----\nThere are no additional preconditions; the function is meant to work correctly for any pair of UInt8 values by leveraging bitwise xor operations.\n-/", "vc-preamble": "@[reducible, simp]\ndef SwapBitvectors_precond (X : UInt8) (Y : UInt8) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def SwapBitvectors (X : UInt8) (Y : UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) : UInt8 × UInt8 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SwapBitvectors_postcond (X : UInt8) (Y : UInt8) (result: UInt8 × UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :=\n  result.fst = Y ∧ result.snd = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"X\": 0,\n            \"Y\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 5,\n            \"Y\": 10\n        },\n        \"expected\": \"(10, 5)\",\n        \"unexpected\": [\n            \"(5, 10)\",\n            \"(10, 10)\",\n            \"(5, 5)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 255,\n            \"Y\": 1\n        },\n        \"expected\": \"(1, 255)\",\n        \"unexpected\": [\n            \"(255, 1)\",\n            \"(1, 254)\",\n            \"(0, 255)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 128,\n            \"Y\": 64\n        },\n        \"expected\": \"(64, 128)\",\n        \"unexpected\": [\n            \"(128, 64)\",\n            \"(64, 64)\",\n            \"(0, 128)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 15,\n            \"Y\": 15\n        },\n        \"expected\": \"(15, 15)\",\n        \"unexpected\": [\n            \"(15, 16)\",\n            \"(16, 15)\",\n            \"(14, 15)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0174", "language": "lean", "source": "verina", "source_id": "verina_basic_94_task", "vc-description": "/- \n-----Description-----\nThis task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n• s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n• The output array has the same size as the input array.\n• Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.\n-/", "vc-preamble": "@[reducible, simp]\ndef iter_copy_precond (s : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def iter_copy (s : Array Int) (h_precond : iter_copy_precond (s)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef iter_copy_postcond (s : Array Int) (result: Array Int) (h_precond : iter_copy_precond (s)) :=\n  (s.size = result.size) ∧ (∀ i : Nat, i < s.size → s[i]! = result[i]!)\n\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"s\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[1, 2, 3]\",\n        \"unexpected\": [\n            \"#[1, 3, 2]\",\n            \"#[1, 2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[10, 20, 30, 40]\"\n        },\n        \"expected\": \"#[10, 20, 30, 40]\",\n        \"unexpected\": [\n            \"#[10, 20, 30]\",\n            \"#[10, 20, 40, 30]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[]\"\n        },\n        \"expected\": \"#[]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[-1, -2, -3]\"\n        },\n        \"expected\": \"#[-1, -2, -3]\",\n        \"unexpected\": [\n            \"#[-1, -3, -2]\",\n            \"#[-1, -2]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"s\": \"#[5, 5, 5, 5]\"\n        },\n        \"expected\": \"#[5, 5, 5, 5]\",\n        \"unexpected\": [\n            \"#[5, 5, 5]\",\n            \"#[5, 5, 5, 0]\",\n            \"#[0, 5, 5, 5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0175", "language": "lean", "source": "verina", "source_id": "verina_basic_95_task", "vc-description": "/- \n-----Description-----\nThis problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of integers.\n• i: An integer representing the first index (0-indexed) whose element is to be swapped.\n• j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----\nThe output is an array of integers which:\n• Has the same size as the input array.\n• Contains the element originally at index i in position j and the element originally at index j in position i.\n• Leaves all other elements unchanged.\n\n-----Note-----\nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., Int.toNat i and Int.toNat j are less than arr.size).\n-/", "vc-preamble": "@[reducible, simp]\ndef swap_precond (arr : Array Int) (i : Int) (j : Int) : Prop :=\n  i ≥ 0 ∧\n  j ≥ 0 ∧\n  Int.toNat i < arr.size ∧\n  Int.toNat j < arr.size", "vc-helpers": "", "vc-definitions": "def swap (arr : Array Int) (i : Int) (j : Int) (h_precond : swap_precond (arr) (i) (j)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef swap_postcond (arr : Array Int) (i : Int) (j : Int) (result: Array Int) (h_precond : swap_precond (arr) (i) (j)) :=\n  (result[Int.toNat i]! = arr[Int.toNat j]!) ∧\n  (result[Int.toNat j]! = arr[Int.toNat i]!) ∧\n  (∀ (k : Nat), k < arr.size → k ≠ Int.toNat i → k ≠ Int.toNat j → result[k]! = arr[k]!)\n\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4]\",\n            \"i\": -1,\n            \"j\": 2\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4, 5]\",\n            \"i\": 1,\n            \"j\": 3\n        },\n        \"expected\": \"#[1, 4, 3, 2, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[1, 3, 2, 4, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[10, 20, 30, 40]\",\n            \"i\": 0,\n            \"j\": 3\n        },\n        \"expected\": \"#[40, 20, 30, 10]\",\n        \"unexpected\": [\n            \"#[10, 40, 30, 20]\",\n            \"#[10, 20, 40, 30]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[7, 8, 9]\",\n            \"i\": 1,\n            \"j\": 2\n        },\n        \"expected\": \"#[7, 9, 8]\",\n        \"unexpected\": [\n            \"#[8, 7, 9]\",\n            \"#[9, 8, 7]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[1, 2, 3, 4]\",\n            \"i\": 0,\n            \"j\": 0\n        },\n        \"expected\": \"#[1, 2, 3, 4]\",\n        \"unexpected\": [\n            \"#[1, 2, 4, 3]\",\n            \"#[4, 2, 3, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"arr\": \"#[-1, -2, -3]\",\n            \"i\": 0,\n            \"j\": 2\n        },\n        \"expected\": \"#[-3, -2, -1]\",\n        \"unexpected\": [\n            \"#[-1, -2, -3]\",\n            \"#[-3, -1, -2]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0176", "language": "lean", "source": "verina", "source_id": "verina_basic_96_task", "vc-description": "/- \n-----Description-----\nThis task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.\n\n-----Input-----\nThe input consists of two integers:\n• X: An integer value.\n• Y: Another integer value.\n\n-----Output-----\nThe output is a tuple (Int × Int) where:\n• The first element is equal to Y.\n• The second element is equal to X.\n\n-----Note-----\nThere are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.\n-/", "vc-preamble": "@[reducible, simp]\ndef SwapSimultaneous_precond (X : Int) (Y : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def SwapSimultaneous (X : Int) (Y : Int) (h_precond : SwapSimultaneous_precond (X) (Y)) : Int × Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef SwapSimultaneous_postcond (X : Int) (Y : Int) (result: Int × Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :=\n  result.1 = Y ∧ result.2 = X ∧\n  (X ≠ Y → result.fst ≠ X ∧ result.snd ≠ Y)\n\ntheorem SwapSimultaneous_spec_satisfied (X: Int) (Y: Int) (h_precond : SwapSimultaneous_precond (X) (Y)) :\n    SwapSimultaneous_postcond (X) (Y) (SwapSimultaneous (X) (Y) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"X\": 3,\n            \"Y\": 4\n        },\n        \"expected\": \"(4, 3)\",\n        \"unexpected\": [\n            \"(3, 4)\",\n            \"(3, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": -10,\n            \"Y\": 20\n        },\n        \"expected\": \"(20, -10)\",\n        \"unexpected\": [\n            \"(20, -20)\",\n            \"(-10, 20)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 0,\n            \"Y\": 0\n        },\n        \"expected\": \"(0, 0)\",\n        \"unexpected\": [\n            \"(0, 1)\",\n            \"(1, 0)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": 123,\n            \"Y\": -456\n        },\n        \"expected\": \"(-456, 123)\",\n        \"unexpected\": [\n            \"(123, -456)\",\n            \"(-123, 456)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"X\": -1,\n            \"Y\": -2\n        },\n        \"expected\": \"(-2, -1)\",\n        \"unexpected\": [\n            \"(-1, -2)\",\n            \"(-2, 2)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0177", "language": "lean", "source": "verina", "source_id": "verina_basic_97_task", "vc-description": "/- \n-----Description-----\nThis task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).\n\n-----Output-----\nThe output is an array of integers where:\n• The element at index j is set to 60.\n• All other elements remain the same as in the input array.\n\n-----Note-----\nIt is assumed that j is a valid index (0 ≤ j < a.size).\n-/", "vc-preamble": "@[reducible, simp]\ndef TestArrayElements_precond (a : Array Int) (j : Nat) : Prop :=\n  j < a.size", "vc-helpers": "", "vc-definitions": "def TestArrayElements (a : Array Int) (j : Nat) (h_precond : TestArrayElements_precond (a) (j)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef TestArrayElements_postcond (a : Array Int) (j : Nat) (result: Array Int) (h_precond : TestArrayElements_precond (a) (j)) :=\n  (result[j]! = 60) ∧ (∀ k, k < a.size → k ≠ j → result[k]! = a[k]!)\n\ntheorem TestArrayElements_spec_satisfied (a: Array Int) (j: Nat) (h_precond : TestArrayElements_precond (a) (j)) :\n    TestArrayElements_postcond (a) (j) (TestArrayElements (a) (j) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"j\": 5\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5]\",\n            \"j\": 2\n        },\n        \"expected\": \"#[1, 2, 60, 4, 5]\",\n        \"unexpected\": [\n            \"#[1, 2, 3, 4, 5]\",\n            \"#[1, 60, 3, 4, 5]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[60, 30, 20]\",\n            \"j\": 1\n        },\n        \"expected\": \"#[60, 60, 20]\",\n        \"unexpected\": [\n            \"#[60, 30, 20]\",\n            \"#[60, 30, 60]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30]\",\n            \"j\": 0\n        },\n        \"expected\": \"#[60, 20, 30]\",\n        \"unexpected\": [\n            \"#[10, 20, 30]\",\n            \"#[10, 60, 30]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 10, 15]\",\n            \"j\": 2\n        },\n        \"expected\": \"#[5, 10, 60]\",\n        \"unexpected\": [\n            \"#[5, 10, 15]\",\n            \"#[5, 60, 15]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0]\",\n            \"j\": 0\n        },\n        \"expected\": \"#[60]\",\n        \"unexpected\": [\n            \"#[0]\",\n            \"#[70]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0178", "language": "lean", "source": "verina", "source_id": "verina_basic_98_task", "vc-description": "/- \n-----Description-----\nThis task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.\n\n-----Input-----\nThe input consists of a single integer:\nx: An integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the input integer and 3.\n\n-----Note-----\nThere are no additional preconditions.\n-/", "vc-preamble": "@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            -1,\n            1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 2\n        },\n        \"expected\": 6,\n        \"unexpected\": [\n            4,\n            5,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -4\n        },\n        \"expected\": -12,\n        \"unexpected\": [\n            -8,\n            -10,\n            -16\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10\n        },\n        \"expected\": 30,\n        \"unexpected\": [\n            20,\n            25,\n            35\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -1\n        },\n        \"expected\": -3,\n        \"unexpected\": [\n            -2,\n            -4,\n            0\n        ]\n    }\n]\n-/"}
{"id": "LV0179", "language": "lean", "source": "verina", "source_id": "verina_basic_99_task", "vc-description": "/- \n-----Description-----\nThis task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is an integer that represents three times the input value.\n\n-----Note-----\nThe implementation uses two different branches based on the value of x (i.e., x < 18 or x ≥ 18), but both branches guarantee that the result equals 3*x.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 10\n        },\n        \"expected\": 30,\n        \"unexpected\": [\n            20,\n            25,\n            35\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 18\n        },\n        \"expected\": 54,\n        \"unexpected\": [\n            50,\n            56,\n            60\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5\n        },\n        \"expected\": -15,\n        \"unexpected\": [\n            -10,\n            -20,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 25\n        },\n        \"expected\": 75,\n        \"unexpected\": [\n            70,\n            80,\n            65\n        ]\n    }\n]\n-/"}
{"id": "LV0180", "language": "lean", "source": "verina", "source_id": "verina_basic_100_task", "vc-description": "/- \n-----Description-----\nThis task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is an integer that represents three times the input integer.\n• If x = 0, the output will be 0.\n• Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.\n\n-----Note-----\nThere are no additional preconditions. It is assumed that x is a valid integer.\n-/", "vc-preamble": "import Mathlib\n\n@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 1\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -2\n        },\n        \"expected\": -6,\n        \"unexpected\": [\n            -4,\n            -2,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 10\n        },\n        \"expected\": 30,\n        \"unexpected\": [\n            20,\n            40,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -5\n        },\n        \"expected\": -15,\n        \"unexpected\": [\n            -10,\n            -5,\n            15\n        ]\n    }\n]\n-/"}
{"id": "LV0181", "language": "lean", "source": "verina", "source_id": "verina_basic_101_task", "vc-description": "/- \n-----Description-----\nThis problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.\n\n-----Input-----\nThe input consists of:\n• x: An integer representing the value to be tripled.\n\n-----Output-----\nThe output is an integer that is three times the input value (i.e., 3 * x).\n\n-----Note-----\nThe implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.\n-/", "vc-preamble": "@[reducible, simp]\ndef Triple_precond (x : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def Triple (x : Int) (h_precond : Triple_precond (x)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef Triple_postcond (x : Int) (result: Int) (h_precond : Triple_precond (x)) :=\n  result / 3 = x ∧ result / 3 * 3 = result\n\ntheorem Triple_spec_satisfied (x: Int) (h_precond : Triple_precond (x)) :\n    Triple_postcond (x) (Triple (x) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"x\": 0\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 1\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -1\n        },\n        \"expected\": -3,\n        \"unexpected\": [\n            -2,\n            0,\n            -1\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": 5\n        },\n        \"expected\": 15,\n        \"unexpected\": [\n            14,\n            16,\n            10\n        ]\n    },\n    {\n        \"input\": {\n            \"x\": -10\n        },\n        \"expected\": -30,\n        \"unexpected\": [\n            -20,\n            -40,\n            -10\n        ]\n    }\n]\n-/"}
{"id": "LV0182", "language": "lean", "source": "verina", "source_id": "verina_basic_102_task", "vc-description": "/- \n-----Description-----\nThis task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 ≤ i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.\n\n-----Input-----\nThe input consists of:\n• nums: An array of integers.\n• target: An integer representing the desired sum.\n\n-----Output-----\nThe output is a pair of natural numbers (i, j) that satisfy:\n• 0 ≤ i < j < nums.size.\n• nums[i] + nums[j] = target.\n• Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].\n\n-----Note-----\nIt is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.\n-/", "vc-preamble": "@[reducible, simp]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size > 1 ∧ ¬ List.Pairwise (fun a b => a + b ≠ target) nums.toList", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : (Nat × Nat) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result: (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) :=\n  let (i, j) := result\n  -- two sum holds\n  i < j ∧ j < nums.size ∧ nums[i]! + nums[j]! = target ∧\n  -- i must be the first i\n  List.Pairwise (fun a b => a + b ≠ target) (nums.toList.take i) ∧\n  List.all (nums.toList.take i) (fun a => List.all (nums.toList.drop i) (fun b => a + b ≠ target) ) ∧\n  -- j must be the first j\n  List.all (nums.toList.drop (j + 1)) (fun a => a + nums[j]! ≠ target)\n\ntheorem twoSum_spec_satisfied (nums: Array Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"nums\": \"#[1]\",\n            \"target\": 11\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"nums\": \"#[2, 7, 11, 15]\",\n            \"target\": 9\n        },\n        \"expected\": \"(0, 1)\",\n        \"unexpected\": [\n            \"(0, 2)\",\n            \"(1, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[3, 2, 4]\",\n            \"target\": 6\n        },\n        \"expected\": \"(1, 2)\",\n        \"unexpected\": [\n            \"(0, 2)\",\n            \"(0, 1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[-1, 0, 1, 2]\",\n            \"target\": 1\n        },\n        \"expected\": \"(0, 3)\",\n        \"unexpected\": [\n            \"(1, 2)\",\n            \"(2, 3)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[5, 75, 25]\",\n            \"target\": 100\n        },\n        \"expected\": \"(1, 2)\",\n        \"unexpected\": [\n            \"(0, 2)\",\n            \"(0, 1)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"nums\": \"#[1, 2, 3, 4, 5]\",\n            \"target\": 9\n        },\n        \"expected\": \"(3, 4)\",\n        \"unexpected\": [\n            \"(2, 4)\",\n            \"(1, 3)\"\n        ]\n    }\n]\n-/"}
{"id": "LV0183", "language": "lean", "source": "verina", "source_id": "verina_basic_103_task", "vc-description": "/- \n-----Description-----\nThis problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. The array must contain at least 8 elements.\n\n-----Output-----\nThe output is an array of integers that meets the following criteria:\n• The element at index 4 is updated to its original value plus 3.\n• The element at index 7 is set to 516.\n• All other elements in the array remain the same as in the input array.\n\n-----Note-----\nIt is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.\n-/", "vc-preamble": "@[reducible, simp]\ndef UpdateElements_precond (a : Array Int) : Prop :=\n  a.size ≥ 8", "vc-helpers": "", "vc-definitions": "def UpdateElements (a : Array Int) (h_precond : UpdateElements_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef UpdateElements_postcond (a : Array Int) (result: Array Int) (h_precond : UpdateElements_precond (a)) :=\n  result[4]! = (a[4]!) + 3 ∧\n  result[7]! = 516 ∧\n  (∀ i, i < a.size → i ≠ 4 → i ≠ 7 → result[i]! = a[i]!)\n\ntheorem UpdateElements_spec_satisfied (a: Array Int) (h_precond : UpdateElements_precond (a)) :\n    UpdateElements_postcond (a) (UpdateElements (a) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4, 5, 6]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[0, 1, 2, 3, 4, 5, 6, 7, 8]\"\n        },\n        \"expected\": \"#[0, 1, 2, 3, 7, 5, 6, 516, 8]\",\n        \"unexpected\": [\n            \"#[0, 1, 2, 3, 4, 5, 6, 516, 8]\",\n            \"#[0, 1, 2, 3, 7, 5, 6, 7, 8]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10, 20, 30, 40, 50, 60, 70, 80]\"\n        },\n        \"expected\": \"#[10, 20, 30, 40, 53, 60, 70, 516]\",\n        \"unexpected\": [\n            \"#[10, 20, 30, 40, 50, 60, 70, 80]\",\n            \"#[10, 20, 30, 40, 53, 60, 70, 80]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10]\"\n        },\n        \"expected\": \"#[-1, -2, -3, -4, -2, -6, -7, 516, -9, -10]\",\n        \"unexpected\": [\n            \"#[-1, -2, -3, -4, -5, -6, -7, 516, -9, -10]\",\n            \"#[-1, -2, -3, -4, -2, -6, -7, -8, -9, -10]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 0, 0, 0, 0, 0, 0]\"\n        },\n        \"expected\": \"#[0, 0, 0, 0, 3, 0, 0, 516]\",\n        \"unexpected\": [\n            \"#[0, 0, 0, 0, 0, 0, 0, 516]\",\n            \"#[0, 0, 0, 0, 3, 0, 0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[5, 5, 5, 5, 5, 5, 5, 5]\"\n        },\n        \"expected\": \"#[5, 5, 5, 5, 8, 5, 5, 516]\",\n        \"unexpected\": [\n            \"#[5, 5, 5, 5, 5, 5, 5, 5]\",\n            \"#[5, 5, 5, 5, 8, 5, 5, 5]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0184", "language": "lean", "source": "verina", "source_id": "verina_basic_104_task", "vc-description": "/- \n-----Description-----\nThis problem involves combining two maps by creating a new map that includes every key from both inputs. When a key is found in both maps, the value from the second map is used in the result.\n\n-----Input-----\nThe input consists of:\n• m1: A Map (represented as a list of key-value pairs) where each key is of type Int and each value is of type Int.\n• m2: A Map (similarly represented) where keys may overlap with m1.\n\n-----Output-----\nThe output is a Map that meets the following conditions:\n• Every key present in m2 is present in the result.\n• Every key present in m1 is also present in the result.\n• For keys that appear in both maps, the resulting value is the one from m2.\n• For keys that appear only in m1, the resulting value remains unchanged.\n• No keys outside those present in m1 or m2 are included in the result.\n• The entries in the map should be sorted\n\n-----Note-----\nIt is assumed that the Map structure ensures key uniqueness in the final result using BEq for key comparison.\n-/", "vc-preamble": "structure Map (K V : Type) [BEq K] [BEq V] where\n  entries : List (K × V)\nderiving Inhabited\n\ninstance  (K V : Type) [BEq K] [BEq V] : BEq (Map K V) where\n  beq m1 m2 := List.length m1.entries = List.length m2.entries ∧ List.beq m1.entries m2.entries\n\ndef empty {K V : Type} [BEq K] [BEq V] : Map K V := ⟨[]⟩\n\ndef insert {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) (v : V) : Map K V :=\n  let entries := m.entries.filter (fun p => ¬(p.1 == k)) ++ [(k, v)]\n  ⟨entries⟩\n\n@[reducible, simp]\ndef update_map_precond (m1 : Map Int Int) (m2 : Map Int Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def update_map (m1 : Map Int Int) (m2 : Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Map Int Int :=\n  sorry", "vc-theorems": "def find? {K V : Type} [BEq K] [BEq V] (m : Map K V) (k : K) : Option V :=\n  m.entries.find? (fun p => p.1 == k) |>.map (·.2)\n@[reducible, simp]\ndef update_map_postcond (m1 : Map Int Int) (m2 : Map Int Int) (result: Map Int Int) (h_precond : update_map_precond (m1) (m2)) : Prop :=\n  List.Pairwise (fun a b => a.1 ≤ b.1) result.entries ∧\n  m2.entries.all (fun x => find? result x.1 = some x.2) ∧\n  m1.entries.all (fun x =>\n    match find? m2 x.1 with\n    | some _ => true\n    | none => find? result x.1 = some x.2\n  ) ∧\n  result.entries.all (fun x =>\n    match find? m1 x.1 with\n    | some v => match find? m2 x.1 with\n      | some v' => x.2 = v'\n      | none => x.2 = v\n    | none => find? m2 x.1 = some x.2\n  )\n\ntheorem update_map_spec_satisfied (m1: Map Int Int) (m2: Map Int Int) (h_precond : update_map_precond (m1) (m2)) :\n    update_map_postcond (m1) (m2) (update_map (m1) (m2) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"m1\": \"⟨[(1, 10), (2, 20)]⟩\",\n            \"m2\": \"⟨[(2, 30), (3, 40)]⟩\"\n        },\n        \"expected\": \"⟨[(1, 10), (2, 30), (3, 40)]⟩\",\n        \"unexpected\": [\n            \"⟨[(1, 10), (2, 20), (3, 40)]⟩\",\n            \"⟨[(1, 10), (2, 20)]⟩\",\n            \"⟨[(2, 30), (3, 40)]⟩\"\n        ]\n    },\n    {\n        \"input\": {\n            \"m1\": \"⟨[(1, 100)]⟩\",\n            \"m2\": \"⟨[(1, 200)]⟩\"\n        },\n        \"expected\": \"⟨[(1, 200)]⟩\",\n        \"unexpected\": [\n            \"⟨[(1, 100)]⟩\",\n            \"⟨[(1, 200), (1, 100)]⟩\",\n            \"⟨[]⟩\"\n        ]\n    },\n    {\n        \"input\": {\n            \"m1\": \"⟨[(5, 50), (6, 60)]⟩\",\n            \"m2\": \"⟨[]⟩\"\n        },\n        \"expected\": \"⟨[(5, 50), (6, 60)]⟩\",\n        \"unexpected\": [\n            \"⟨[(5, 50)]⟩\",\n            \"⟨[(6, 60)]⟩\",\n            \"⟨[(5, 50), (6, 60), (7, 70)]⟩\"\n        ]\n    },\n    {\n        \"input\": {\n            \"m1\": \"⟨[]⟩\",\n            \"m2\": \"⟨[(7, 70)]⟩\"\n        },\n        \"expected\": \"⟨[(7, 70)]⟩\",\n        \"unexpected\": [\n            \"⟨[]⟩\",\n            \"⟨[(0, 70)]⟩\",\n            \"⟨[(7, 0)]⟩\"\n        ]\n    },\n    {\n        \"input\": {\n            \"m1\": \"⟨[(1, 1), (2, 2), (3, 3)]⟩\",\n            \"m2\": \"⟨[(2, 20), (4, 40)]⟩\"\n        },\n        \"expected\": \"⟨[(1, 1), (2, 20), (3, 3), (4, 40)]⟩\",\n        \"unexpected\": [\n            \"⟨[(1, 1), (2, 2), (3, 3)]⟩\",\n            \"⟨[(1, 1), (2, 20), (3, 3)]⟩\",\n            \"⟨[(1, 1), (2, 20), (3, 3), (4, 30)]⟩\"\n        ]\n    }\n]\n-/"}
{"id": "LV0185", "language": "lean", "source": "verina", "source_id": "verina_basic_105_task", "vc-description": "/- \n-----Description-----\nThis task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.\n\n-----Input-----\nThe input consists of two arrays:\n• a: An array of integers.\n• b: An array of integers (should be of equal length to a for the specification to hold).\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input arrays.\n• For each index i, the output array contains the product a[i] * b[i].\n• In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.\n\n-----Note-----\nIt is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.\n-/", "vc-preamble": "@[reducible, simp]\ndef arrayProduct_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size", "vc-helpers": "def loop (a b : Array Int) (len : Nat) : Nat → Array Int → Array Int\n  | i, c =>\n    if i < len then\n      let a_val := if i < a.size then a[i]! else 0\n      let b_val := if i < b.size then b[i]! else 0\n      let new_c := Array.set! c i (a_val * b_val)\n      loop a b len (i+1) new_c\n    else c", "vc-definitions": "def arrayProduct (a : Array Int) (b : Array Int) (h_precond : arrayProduct_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arrayProduct_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arrayProduct_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i, i < a.size → a[i]! * b[i]! = result[i]!)\n\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": \"#[4, 10, 18]\",\n        \"unexpected\": [\n            \"#[4, 10, 17]\",\n            \"#[0, 10, 18]\",\n            \"#[4, 10, 20]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 0]\",\n            \"b\": \"#[1, 2, 3]\"\n        },\n        \"expected\": \"#[0, 0, 0]\",\n        \"unexpected\": [\n            \"#[1, 0, 0]\",\n            \"#[0, 1, 0]\",\n            \"#[0, 0, 1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, 2, -3]\",\n            \"b\": \"#[3, -4, 5]\"\n        },\n        \"expected\": \"#[-3, -8, -15]\",\n        \"unexpected\": [\n            \"#[-3, -8, -14]\",\n            \"#[-3, -7, -15]\",\n            \"#[-2, -8, -15]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[2]\",\n            \"b\": \"#[10]\"\n        },\n        \"expected\": \"#[20]\",\n        \"unexpected\": [\n            \"#[10]\",\n            \"#[0]\",\n            \"#[30]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[2, 2, 2, 2]\"\n        },\n        \"expected\": \"#[2, 4, 6, 8]\",\n        \"unexpected\": [\n            \"#[2, 4, 6, 9]\",\n            \"#[1, 4, 6, 8]\",\n            \"#[2, 5, 6, 8]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0186", "language": "lean", "source": "verina", "source_id": "verina_basic_106_task", "vc-description": "/- \n-----Description-----\nThe task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.\n\n-----Input-----\nThe input consists of two parameters:\n• a: An array of integers.\n• b: An array of integers.\nNote: Both arrays must have the same length.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same size as the input arrays.\n• Contains elements where each element at index i is computed as a[i]! + b[i]! from the input arrays.\n\n-----Note-----\nIt is assumed that the two input arrays have equal lengths.\n-/", "vc-preamble": "@[reducible, simp]\ndef arraySum_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size", "vc-helpers": "", "vc-definitions": "def arraySum (a : Array Int) (b : Array Int) (h_precond : arraySum_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arraySum_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arraySum_precond (a) (b)) :=\n  (result.size = a.size) ∧ (∀ i : Nat, i < a.size → a[i]! + b[i]! = result[i]!)\n\ntheorem arraySum_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arraySum_precond (a) (b)) :\n    arraySum_postcond (a) (b) (arraySum (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3, 4]\",\n            \"b\": \"#[5, 6, 7]\"\n        }\n    }\n]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": \"#[1, 2, 3]\",\n            \"b\": \"#[4, 5, 6]\"\n        },\n        \"expected\": \"#[5, 7, 9]\",\n        \"unexpected\": [\n            \"#[5, 6, 9]\",\n            \"#[4, 7, 9]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[0, 0, 0]\",\n            \"b\": \"#[0, 0, 0]\"\n        },\n        \"expected\": \"#[0, 0, 0]\",\n        \"unexpected\": [\n            \"#[0, 0, 1]\",\n            \"#[1, 0, 0]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[-1, 2, 3]\",\n            \"b\": \"#[1, -2, 4]\"\n        },\n        \"expected\": \"#[0, 0, 7]\",\n        \"unexpected\": [\n            \"#[0, 1, 7]\",\n            \"#[0, 0, 6]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[10]\",\n            \"b\": \"#[-10]\"\n        },\n        \"expected\": \"#[0]\",\n        \"unexpected\": [\n            \"#[1]\",\n            \"#[-1]\"\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": \"#[100, 200, 300]\",\n            \"b\": \"#[100, 200, 300]\"\n        },\n        \"expected\": \"#[200, 400, 600]\",\n        \"unexpected\": [\n            \"#[200, 400, 601]\",\n            \"#[199, 400, 600]\",\n            \"#[200, 399, 600]\"\n        ]\n    }\n]\n-/"}
{"id": "LV0187", "language": "lean", "source": "verina", "source_id": "verina_basic_107_task", "vc-description": "/- \n-----Description-----\nThis task involves computing the average of two integers. The objective is to determine a value that closely approximates the true arithmetic mean when using integer division, ensuring that the result reflects the necessary rounding behavior.\n\n-----Input-----\nThe input consists of:\n• a: An integer.\n• b: An integer.\n\n-----Output-----\nThe output is an integer representing the computed average of a and b using integer division.\n\n-----Note-----\nThe specification requires that the computed average satisfies the condition that 2 * avg is between (a + b - 1) and (a + b + 1), ensuring that the result meets the expected rounding boundaries.\n-/", "vc-preamble": "@[reducible, simp]\ndef ComputeAvg_precond (a : Int) (b : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def ComputeAvg (a : Int) (b : Int) (h_precond : ComputeAvg_precond (a) (b)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef ComputeAvg_postcond (a : Int) (b : Int) (result: Int) (h_precond : ComputeAvg_precond (a) (b)) :=\n  2 * result = a + b - ((a + b) % 2)\n\ntheorem ComputeAvg_spec_satisfied (a: Int) (b: Int) (h_precond : ComputeAvg_precond (a) (b)) :\n    ComputeAvg_postcond (a) (b) (ComputeAvg (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"a\": 4,\n            \"b\": 6\n        },\n        \"expected\": 5,\n        \"unexpected\": [\n            4,\n            6,\n            7\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 5\n        },\n        \"expected\": 4,\n        \"unexpected\": [\n            3,\n            5,\n            6\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": 3,\n            \"b\": 4\n        },\n        \"expected\": 3,\n        \"unexpected\": [\n            2,\n            4,\n            5\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -3,\n            \"b\": 7\n        },\n        \"expected\": 2,\n        \"unexpected\": [\n            1,\n            3,\n            0\n        ]\n    },\n    {\n        \"input\": {\n            \"a\": -5,\n            \"b\": 5\n        },\n        \"expected\": 0,\n        \"unexpected\": [\n            1,\n            -1,\n            2\n        ]\n    }\n]\n-/"}
{"id": "LV0188", "language": "lean", "source": "verina", "source_id": "verina_basic_108_task", "vc-description": "/- \n-----Description-----\nThe problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\n-----Input-----\nThe input consists of:\n• operations: A list of integers representing sequential operations.\n\n-----Output-----\nThe output is a tuple consisting of:\n• An array of integers representing the partial sums. The array’s size is one more than the number of operations, starting with 0 and where for each index i such that 0 ≤ i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n• A boolean value that is true if there exists an index i (with 1 ≤ i ≤ operations.length) such that the i-th partial sum is negative, and false otherwise.\n\n-----Note-----\nThe function should also correctly handle an empty list of operations.\n-/", "vc-preamble": "@[reducible, simp]\ndef below_zero_precond (operations : List Int) : Prop :=\n  True", "vc-helpers": "def buildS (operations : List Int) : Array Int :=\n  let sList := operations.foldl\n    (fun (acc : List Int) (op : Int) =>\n      let last := acc.getLast? |>.getD 0\n      acc.append [last + op])\n    [0]\n  Array.mk sList", "vc-definitions": "def below_zero (operations : List Int) (h_precond : below_zero_precond (operations)) : (Array Int × Bool) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef below_zero_postcond (operations : List Int) (result: (Array Int × Bool)) (h_precond : below_zero_precond (operations)) :=\n  let s := result.1\n  let result := result.2\n  s.size = operations.length + 1 ∧\n  s[0]? = some 0 ∧\n  (List.range (s.size - 1)).all (fun i => s[i + 1]? = some (s[i]! + operations[i]!)) ∧\n  ((result = true) → ((List.range (operations.length)).any (fun i => s[i + 1]! < 0))) ∧\n  ((result = false) → s.all (· ≥ 0))\n\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n  sorry", "vc-postamble": "/-\n-- Invalid Inputs\n[]\n-- Tests\n[\n    {\n        \"input\": {\n            \"operations\": \"[1, 2, 3]\"\n        },\n        \"expected\": \"(#[0, 1, 3, 6], false)\",\n        \"unexpected\": [\n            \"(#[0, 1, 3, 5], false)\",\n            \"(#[0, 2, 3, 6], false)\",\n            \"(#[0, 1, 3, 6], true)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"operations\": \"[-1, 2, -1]\"\n        },\n        \"expected\": \"(#[0, -1, 1, 0], true)\",\n        \"unexpected\": [\n            \"(#[0, -1, 1, 0], false)\",\n            \"(#[0, -1, 0, 0], true)\",\n            \"(#[0, -2, 1, 0], true)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"operations\": \"[]\"\n        },\n        \"expected\": \"(#[0], false)\",\n        \"unexpected\": [\n            \"(#[0], true)\",\n            \"(#[0, 0], false)\",\n            \"(#[0, 1], false)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"operations\": \"[0, 0, 0]\"\n        },\n        \"expected\": \"(#[0, 0, 0, 0], false)\",\n        \"unexpected\": [\n            \"(#[0, 0, 0, 0], true)\",\n            \"(#[0, 0, 0], false)\",\n            \"(#[0, 0, 1, 0], false)\"\n        ]\n    },\n    {\n        \"input\": {\n            \"operations\": \"[10, -20, 5]\"\n        },\n        \"expected\": \"(#[0, 10, -10, -5], true)\",\n        \"unexpected\": [\n            \"(#[0, 10, -10, -5], false)\",\n            \"(#[0, 10, -9, -5], true)\",\n            \"(#[0, 10, -10, -6], true)\"\n        ]\n    }\n]\n-/"}
