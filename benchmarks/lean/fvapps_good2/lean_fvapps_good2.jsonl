{"id": "fvapps_000000", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) (words : List String) : List Int :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_output_structure (n : Nat) (words : List String) :\n  let result := solve n words\n  (result = [-1] ∨\n   (result.length ≥ 1 ∧\n    ∀ x ∈ result, ∃ i : Int, x = i ∧\n    let count := result[0]!\n    result.length = count + 1 ∧\n    ∀ i ∈ result.tail, 1 ≤ i ∧ i ≤ n)) :=\nsorry\n\ntheorem solve_minimal_flips (n : Nat) (words : List String) :\n  let result := solve n words\n  result ≠ [-1] →\n  let zeros_to_ones := (words.filter (λ w => w.front = '0' ∧ w.back = '1')).length\n  let ones_to_zeros := (words.filter (λ w => w.front = '1' ∧ w.back = '0')).length\n  let min_flips := (abs (zeros_to_ones - ones_to_zeros)) / 2\n  result[0]! = min_flips :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3]\n-/\n#guard_msgs in\n#eval solve 4 [\"0001\", \"1000\", \"0011\", \"0111\"]\n\n/-\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve 3 [\"010\", \"101\", \"0\"]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 2 [\"00000\", \"00001\"]"}
{"id": "fvapps_000001", "vc-description": "", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def solve_max_diagonal_moves (n m k : Int) : Int :=\n  sorry", "vc-theorems": "theorem result_bound (n m k : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) (h3: 0 <= k ∧ k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  r = -1 ∨ r ≤ k :=\nsorry\n\ntheorem result_parity (n m k : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) (h3: 0 <= k ∧ k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  let max_dist := max (abs n) (abs m)\n  r ≠ -1 → (r % 2 = max_dist % 2 ∨ r % 2 = (max_dist - 1) % 2) :=\nsorry\n\ntheorem insufficient_moves (n : Int) (h: 1 <= n ∧ n <= 1000) :\n  let k := abs n - 1\n  solve_max_diagonal_moves n n k = -1 :=\nsorry\n\ntheorem symmetry (n m : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) :\n  let k := max (abs n) (abs m) * 2\n  let r1 := solve_max_diagonal_moves n m k\n  let r2 := solve_max_diagonal_moves (-n) m k\n  let r3 := solve_max_diagonal_moves n (-m) k\n  let r4 := solve_max_diagonal_moves (-n) (-m) k\n  r1 = r2 ∧ r2 = r3 ∧ r3 = r4 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 2 2 3\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 4 3 7\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 10 1 9"}
{"id": "fvapps_000003", "vc-description": "/- Helper function to sum a list -/\n\n/- Helper function to get maximum of non-empty list -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- max_water_difference result is greater than or equal to max barrel -/\n\n/- max_water_difference result is less than or equal to sum of all barrels -/\n\n/- max_water_difference does not modify input list -/\n\n/- Helper function to sort list descending -/\n\n/- Helper function to take first n elements -/\n\n/- max_water_difference returns sum of k+1 largest values -/", "vc-preamble": "def listSum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + listSum xs\n\ndef listMaximum : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | x :: xs => if x > listMaximum xs then x else listMaximum xs\n\ndef takeFront : Nat → List Nat → List Nat\n  | 0, _ => []\n  | _, [] => []\n  | n+1, x :: xs => x :: takeFront n xs", "vc-helpers": "", "vc-definitions": "def max_water_difference (n : Nat) (k : Nat) (barrels : List Nat) : Nat :=\n  sorry\n\ndef sortDescending (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem max_water_diff_equals_k_plus_one_largest\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  max_water_difference n k barrels =\n    listSum (takeFront (k+1) (sortDescending barrels)) :=\nsorry\n\ntheorem max_water_diff_ge_max_barrel\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n)\n  (h₃ : barrels ≠ []) :\n  max_water_difference n k barrels ≥ listMaximum barrels :=\nsorry\n\ntheorem max_water_diff_le_total_sum\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  max_water_difference n k barrels ≤ listSum barrels :=\nsorry\n\ntheorem max_water_diff_preserves_input\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  let original := barrels\n  let _ := max_water_difference n k barrels\n  barrels = original :=\nsorry", "vc-postamble": "/-\ninfo: 10\n-/\n#guard_msgs in\n#eval max_water_difference 4 1 [5, 5, 5, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_water_difference 3 2 [0, 0, 0]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval max_water_difference 5 2 [1, 2, 3, 4, 5]"}
{"id": "fvapps_000007", "vc-description": "/- The heap maintains the min-heap property after insertions -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- The heap extracts elements in sorted order -/\n\n/- Single value insertion and extraction works correctly -/", "vc-preamble": "def Heap := List Int", "vc-helpers": "", "vc-definitions": "def ins (l : Heap) (x : Int) : Heap :=\nsorry\n\ndef pop (l : Heap) : Int × Heap :=\nsorry", "vc-theorems": "theorem heap_maintains_min_property {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  ∀ i, 2 ≤ i → i < h'.length →\n    match h'.get? i, h'.get? (i/2) with\n    | some vi, some vp => vi ≥ vp\n    | _, _ => True :=\nsorry\n\ntheorem heap_gives_sorted_output {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  let rec extract (h : Heap) (n : Nat) : List Int :=\n    match n with\n    | 0 => []\n    | n+1 => match pop h with\n      | (x, h') => x :: extract h' n\n  ∀ i j xi xj, i < j → j < (extract h' h'.length).length →\n    (extract h' h'.length).get? i = some xi →\n    (extract h' h'.length).get? j = some xj →\n    xi ≤ xj :=\nsorry\n\ntheorem heap_single_value (x : Int) :\n  let h := ins [] x\n  pop h = (x, []) :=\nsorry", "vc-postamble": "/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_election 3 [[1, 5], [2, 10], [2, 8]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_election 7 [[0, 1], [3, 1], [1, 1], [6, 1], [1, 1], [4, 1], [4, 1]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_election 6 [[2, 6], [2, 3], [2, 8], [2, 7], [4, 4], [5, 5]]"}
{"id": "fvapps_000009", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_alice_score (s : String) : Nat :=\n  sorry\n\ndef countOnes (s : String) : Nat :=\n  sorry\n\ndef sortByLengthDesc (ls : List String) : List String :=\n  sorry\n\ndef getAlternateSum (ls : List String) : Nat :=\n  sorry", "vc-theorems": "theorem result_not_exceed_input_length\n  (s : String) :\n  count_alice_score s ≤ s.length :=\nsorry\n\ntheorem result_nonnegative\n  (s : String) :\n  count_alice_score s ≥ 0 :=\nsorry\n\ntheorem empty_or_zeros_returns_zero\n  (s : String) :\n  (s.isEmpty ∨ s.all (· = '0')) → count_alice_score s = 0 :=\nsorry\n\ntheorem all_ones_full_score\n  (s : String) :\n  s.all (· = '1') →\n  s.length > 0 →\n  count_alice_score s = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_alice_score \"01111001\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_alice_score \"111111\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_alice_score \"101010101\""}
{"id": "fvapps_000011", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_grid_area (s : String) : Nat :=\n  sorry\n\ndef min_width_height_from_path (s : String) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem min_grid_area_positive (s : String) :\n  min_grid_area s > 0 := by\n  sorry\n\ntheorem min_grid_area_nonempty (s : String) (h : s.length > 0) :\n  min_grid_area s ≥ 2 := by\n  sorry\n\ntheorem min_grid_area_empty :\n  min_grid_area \"\" = 1 := by\n  sorry\n\ntheorem min_grid_area_single_char (c : Char) (h : c = 'W' ∨ c = 'A' ∨ c = 'S' ∨ c = 'D') :\n  min_grid_area (String.mk [c]) = 2 := by\n  sorry\n\ntheorem min_grid_area_bounds (s : String) :\n  let (w, h) := min_width_height_from_path s\n  min_grid_area s ≥ min (w * h) 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval min_grid_area \"DSAWWAW\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_grid_area \"D\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_grid_area \"WA\""}
{"id": "fvapps_000019", "vc-description": "", "vc-preamble": "def maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs\n\ndef listToFinset (l : List Nat) : List Nat :=\n  l.eraseDups", "vc-helpers": "", "vc-definitions": "def windowsOfSize (l : List Nat) (size : Nat) : List (List Nat) :=\n  sorry\n\ndef min_subscriptions (n k d : Nat) (shows : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_subscriptions_output_bounds\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x ∧ x ≤ 100) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min n (maximum shows)\n  let result := min_subscriptions n k d shows\n  1 ≤ result ∧ result ≤ (listToFinset shows).length :=\nsorry\n\ntheorem min_subscriptions_window_size_one\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  min_subscriptions n k 1 shows = 1 :=\nsorry\n\ntheorem min_subscriptions_window_size_equals_length\n  (shows : List Nat)\n  (k : Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x)\n  (h3 : 1 ≤ k) :\n  let n := shows.length\n  min_subscriptions n k n shows = (listToFinset shows).length :=\nsorry\n\ntheorem min_subscriptions_repeated_elements\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := n\n  min_subscriptions n k d shows = min_subscriptions (2*n) k d (shows ++ shows) :=\nsorry\n\ntheorem min_subscriptions_sliding_window\n  (shows : List Nat)\n  (window_size : Nat)\n  (h1 : shows.length ≥ 2)\n  (h2 : window_size ≥ 2)\n  (h3 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min window_size n\n  let result := min_subscriptions n k d shows\n  let windows := windowsOfSize shows d\n  let min_unique := (windows.map (fun w => (listToFinset w).length)).foldl Nat.min n\n  result = min_unique :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subscriptions 5 2 2 [1, 2, 1, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_subscriptions 9 3 3 [3, 3, 3, 2, 2, 2, 1, 1, 1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_subscriptions 4 10 4 [10, 8, 6, 4]"}
{"id": "fvapps_000022", "vc-description": "-- Result is always non-negative\n\n-- k=1 returns original number\n\n-- k>1 implies result >= input", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_seq (a k : Nat) : Nat :=\n  sorry\n\ndef hasZeroDigit (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem calc_seq_basic_properties {a k : Nat} (ha : a > 0) (hk : k > 0) :\n  let result := calc_seq a k\n\n  result ≥ 0 ∧\n\n  calc_seq a 1 = a ∧\n\n  (k > 1 → result ≥ a) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval calc_seq 1 4\n\n/-\ninfo: 487\n-/\n#guard_msgs in\n#eval calc_seq 487 1\n\n/-\ninfo: 628\n-/\n#guard_msgs in\n#eval calc_seq 487 7"}
{"id": "fvapps_000030", "vc-description": "/- Main theorem combining several properties of solve_string_alternation:\n  1. Output is non-negative\n  2. Output is less than string length\n  3. Output relates to number of adjacent duplicates\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Perfectly alternating strings require no operations -/\n\n/- For strings of all same characters, result depends on length -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_string_alternation (n : Nat) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_string_alternation_properties (s : String) (n : Nat)\n  (h1 : s.length = n) (h2 : n > 0) (h3 : ∀c ∈ s.data, c = '0' ∨ c = '1') :\n  let result := solve_string_alternation n s\n  let adjacent_same := (List.zip s.data s.data.tail).filter (fun p => p.1 = p.2) |>.length\n  (result ≥ 0) ∧\n  (result < n) ∧\n  (result = (adjacent_same + adjacent_same % 2) / 2) :=\nsorry\n\ntheorem solve_string_alternation_perfect_alt (n : Nat) (h : n ≥ 2) :\n  let s := String.mk (List.map (fun i => if i % 2 = 0 then '0' else '1') (List.range n))\n  solve_string_alternation n s = 0 :=\nsorry\n\ntheorem solve_string_alternation_all_same (n : Nat) (h : n > 0) :\n  let s := String.mk (List.replicate n '0')\n  solve_string_alternation n s = ((n-1) + (n-1) % 2) / 2 :=\nsorry", "vc-postamble": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_string_alternation 2 \"10\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_string_alternation 4 \"0110\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_string_alternation 8 \"11101000\""}
{"id": "fvapps_000038", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\n  sorry\n\ndef solve_card_game (n k1 k2 : Nat) (arr1 arr2 : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem card_game_returns_bool (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = true ∨\n  solve_card_game n k1 k2 arr1 arr2 = false :=\nsorry\n\ntheorem card_game_compares_maxes (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = (maximum arr1 > maximum arr2) :=\nsorry\n\ntheorem empty_lists_error (n : Nat) :\n  ∀ (arr1 arr2 : List Int),\n  arr1.length = 0 → arr2.length = 0 →\n  solve_card_game n 0 0 arr1 arr2 = default :=\nsorry\n\ntheorem equal_maxes_false (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : arr1.length > 0) (h2 : arr2.length > 0)\n  (h3 : maximum arr2 = maximum arr1) :\n  solve_card_game n arr1.length arr2.length arr1 arr2 = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 2 1 1 [2] [1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve_card_game 5 2 3 [2, 3] [1, 4, 5]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 3 1 2 [3] [1, 2]"}
{"id": "fvapps_000043", "vc-description": "", "vc-preamble": "def list_maximum (l : List Nat) : Nat :=\n  l.foldl Nat.max 0", "vc-helpers": "", "vc-definitions": "def solve_dishes (n : Nat) (a : List Nat) (b : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_dishes_leq_max_cook_time (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    solve_dishes n a b ≤ list_maximum a :=\nsorry\n\ntheorem solve_dishes_non_negative (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    solve_dishes n a b ≥ 0 :=\nsorry\n\ntheorem solve_dishes_valid_solution (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    let result := solve_dishes n a b\n    let remaining := result - (List.range n).foldl (λ acc i =>\n      if a[i]! > result then acc + b[i]! else acc) 0\n    remaining ≥ 0 :=\nsorry\n\ntheorem same_cook_and_wait_times (n : Nat) (times : List Nat)\n    (h1 : n ≥ 1) (h2 : times.length = n) (h3 : ∀ x ∈ times, x ≥ 1) :\n    solve_dishes n times times ≤ list_maximum times :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_dishes 4 [3, 7, 4, 5] [2, 1, 2, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_dishes 4 [1, 2, 3, 4] [3, 3, 3, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dishes 2 [1, 2] [10, 10]"}
{"id": "fvapps_000046", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_rock_paper_scissors (s: String) : String :=\nsorry\n\ndef beats (move1 move2 : Char) : Bool :=\nsorry\n\ndef getMostFrequentMove (s : String) : Char :=\nsorry", "vc-theorems": "theorem length_preservation (s : String) :\n  s.length > 0 → (solve_rock_paper_scissors s).length = s.length :=\nsorry\n\ntheorem valid_moves (s : String) (i : String.Pos) :\n  s.length > 0 →\n  (solve_rock_paper_scissors s).get i = 'R' ∨\n  (solve_rock_paper_scissors s).get i = 'P' ∨\n  (solve_rock_paper_scissors s).get i = 'S' :=\nsorry\n\ntheorem uniform_response (s : String) :\n  s.length > 0 → ∀ i j : String.Pos,\n  (solve_rock_paper_scissors s).get i = (solve_rock_paper_scissors s).get j :=\nsorry\n\ntheorem beats_most_frequent (s : String) (h: s.length > 0):\n  let mostFrequent := getMostFrequentMove s\n  let firstChar := (solve_rock_paper_scissors s).front\n  beats firstChar mostFrequent :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: len(test_input)\n-/\n#guard_msgs in\n#eval len solve_rock_paper_scissors(test_input)"}
{"id": "fvapps_000053", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_sequence (n : Nat) (comp_str : String) : (List Nat × List Nat) :=\n  sorry\n\ndef verifySequenceMatchesComparisons (seq : List Nat) (comps : List Char) : Bool :=\n  sorry", "vc-theorems": "theorem sequence_length_matches_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  min_seq.length = n ∧ max_seq.length = n :=\nsorry\n\ntheorem sequences_follow_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  verifySequenceMatchesComparisons min_seq (comp_str.data) ∧\n  verifySequenceMatchesComparisons max_seq (comp_str.data) :=\nsorry\n\ntheorem sequences_use_consecutive_integers\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  ∀ k, k ≤ n → (k ∈ min_seq ↔ k ≤ n ∧ k > 0) ∧\n               (k ∈ max_seq ↔ k ≤ n ∧ k > 0) :=\nsorry\n\ntheorem single_value_edge_case\n  {n : Nat} :\n  n = 1 →\n  solve_sequence n \"\" = ([1], [1]) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set min3\n\n/-\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set max3"}
{"id": "fvapps_000059", "vc-description": "/- Properties for all-negative-ones case -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Main property about adjacent differences being bounded by result -/\n\n/- Property about the x value working for -1 positions -/\n\n/- Property about result types and non-negativity -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_differences (n : Nat) (arr : List Int) : Int × Int :=\nsorry", "vc-theorems": "theorem all_neg_ones_result {n : Nat} {arr : List Int}\n  (h : ∀ x ∈ arr, x = -1) :\n  solve_array_differences n arr = (0, 0) :=\nsorry\n\ntheorem adjacent_differences_bounded {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ∀ i < arr.length - 1,\n    arr[i]! ≠ -1 → arr[i+1]! ≠ -1 →\n    (arr[i]! - arr[i+1]!).natAbs ≤ ans :=\nsorry\n\ntheorem x_value_maintains_bound {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ∀ i < arr.length,\n    arr[i]! = -1 →\n    (i > 0 → arr[i-1]! ≠ -1 → (arr[i-1]! - x).natAbs ≤ ans) ∧\n    (i < arr.length - 1 → arr[i+1]! ≠ -1 → (x - arr[i+1]!).natAbs ≤ ans) :=\nsorry\n\ntheorem result_properties {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ans ≥ 0 :=\nsorry", "vc-postamble": "/-\ninfo: (1, 11)\n-/\n#guard_msgs in\n#eval solve_array_differences 5 [-1, 10, -1, 12, -1]\n\n/-\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval solve_array_differences 2 [-1, -1]\n\n/-\ninfo: (1, 2)\n-/\n#guard_msgs in\n#eval solve_array_differences 4 [1, -1, 3, -1]"}
{"id": "fvapps_000065", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sorted (l : List Int) : Bool :=\n  sorry\n\ndef solve_gift_distribution (n : Nat) (a b : List Int) : List Int × List Int :=\n  sorry\n\ndef List.sort (l : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem gift_distribution_output {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  (necklace.sorted = true) ∧ (bracelet.sorted = true) := by\n  sorry\n\ntheorem gift_distribution_nonempty {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace.length > 0 ∧ bracelet.length > 0 := by\n  sorry\n\ntheorem gift_distribution_preserves_elements {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace = a.sort ∧ bracelet = b.sort := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000066", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "inductive Even : Nat → Prop where\n  | zero : Even 0\n  | plus_two : (n : Nat) → Even n → Even (n + 2)", "vc-helpers": "", "vc-definitions": "def solve_string_swaps (n: Nat) (s t: String) : String × List (Nat × Nat) :=\n  sorry\n\ndef apply_swaps (s t: String) (swaps: List (Nat × Nat)) : String × String :=\n  sorry\n\ndef count_chars (s: String) : Char → Nat :=\n  sorry", "vc-theorems": "theorem identical_strings_always_possible\n  (n: Nat) (s: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s s\n  res.1 = \"Yes\" ∧ res.2.length ≤ 2 * n :=\nsorry\n\ntheorem valid_solution\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s t\n  res.1 = \"Yes\" →\n    (res.2.length ≤ 2 * n ∧\n     ∃ final_s final_t,\n       (apply_swaps s t res.2) = (final_s, final_t) ∧\n       final_s = final_t) ∧\n  res.1 = \"No\" →\n    res.2 = [] :=\nsorry\n\ntheorem character_count_invariant\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s t\n  let char_counts := count_chars (s ++ t)\n  res.1 = \"Yes\" ↔ ∀ c, Even (char_counts c) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000069", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_replacements (n k : Nat) (s : String) : Nat :=\n  sorry\n\ndef is_palindrome (s : String) : Bool :=\n  sorry\n\ndef max_char_count (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem min_replacements_nonneg (n k : Nat) (s : String) :\n  min_replacements n k s ≥ 0 :=\nsorry\n\ntheorem min_replacements_bounded (n k : Nat) (s : String) :\n  min_replacements n k s ≤ n :=\nsorry\n\ntheorem uniform_string_zero (n k : Nat) (s : String) :\n  s = String.mk (List.replicate n 'a') →\n  min_replacements n (min k n) s = 0 :=\nsorry\n\ntheorem min_replacements_type (n k : Nat) (s : String) :\n  min_replacements n k s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_replacements 6 2 \"abaaba\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_replacements 6 3 \"abaaba\"\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval min_replacements 36 9 \"hippopotomonstrosesquippedaliophobia\""}
{"id": "fvapps_000070", "vc-description": "", "vc-preamble": "def sum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def solve_array_zeroes (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_array_zeroes_nonnegative (n : Nat) (arr : List Int) :\n  solve_array_zeroes n arr ≥ 0 :=\nsorry\n\ntheorem solve_array_zeroes_all_positives (n : Nat) (arr : List Int) :\n  (List.all arr (fun x => x ≥ 0)) → solve_array_zeroes n arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 5, -3, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_array_zeroes 2 [1, -1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 2, -3, 4]"}
{"id": "fvapps_000090", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def intList (n : Nat) : List Int :=\nsorry\n\ndef isValidPermutation (n : Nat) (result : List Int) : Bool :=\nsorry\n\ndef satisfiesQConstraints (result : List Int) (q : List Int) : Bool :=\nsorry\n\ndef solvePermutationCode (n : Nat) (q : List Int) : List Int :=\nsorry", "vc-theorems": "theorem single_element_property (n : Nat) :\n  n > 0 → n ≤ 10 →\n  let q := [Int.ofNat n]\n  let result := solvePermutationCode 1 q\n  result = [Int.ofNat n] ∨ result = [-1] :=\nsorry\n\ntheorem strictly_increasing_property (n : Nat) :\n  n > 0 → n ≤ 10 →\n  let q := intList n\n  let result := solvePermutationCode n q\n  isValidPermutation n result = true ∧\n  satisfiesQConstraints result q = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 4, 5, 2]\n-/\n#guard_msgs in\n#eval solve_permutation_code 5 [1, 3, 4, 5, 5]\n\n/-\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 4 [1, 1, 3, 4]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 1 [1]"}
{"id": "fvapps_000098", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def clean_binary_string (n : Nat) (s : String) : String :=\nsorry\n\ndef string_of_zeros (n : Nat) : String :=\nsorry\n\ndef string_of_ones (n : Nat) : String :=\nsorry", "vc-theorems": "theorem clean_preserves_all_zeros (n : Nat) :\n  clean_binary_string n (string_of_zeros n) = string_of_zeros n :=\nsorry\n\ntheorem clean_preserves_all_ones (n : Nat) :\n  clean_binary_string n (string_of_ones n) = string_of_ones n :=\nsorry\n\ntheorem clean_preserves_monotonic_transitions (n : Nat) (s : String) :\n  s = \"0001\" ∨ s = \"0011\" ∨ s = \"0111\" → clean_binary_string n s = s :=\nsorry\n\ntheorem clean_shortens_alternating (n : Nat) :\n  clean_binary_string 4 \"0101\" = \"001\" :=\nsorry\n\ntheorem clean_shortens_complex_pattern (n : Nat) :\n  clean_binary_string 8 \"11001101\" = \"01\" :=\nsorry\n\ntheorem clean_reduces_to_minimal (n : Nat) :\n  clean_binary_string 6 \"100110\" = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '0001111111'\n-/\n#guard_msgs in\n#eval clean_binary_string 10 \"0001111111\"\n\n/-\ninfo: '001'\n-/\n#guard_msgs in\n#eval clean_binary_string 4 \"0101\"\n\n/-\ninfo: '01'\n-/\n#guard_msgs in\n#eval clean_binary_string 8 \"11001101\""}
{"id": "fvapps_000102", "vc-description": "", "vc-preamble": "def countEmptyRows (grid : List (List Nat)) : Nat :=\n  (grid.filter (fun row => row.all (fun x => x = 0))).length\n\ndef countEmptyCols (n m : Nat) (grid : List (List Nat)) : Nat :=\n  let isEmptyCol (j : Nat) := (List.range n).all (fun i =>\n    match grid.get? i with\n    | none => true\n    | some row => match row.get? j with\n      | none => true\n      | some x => x = 0)\n  (List.range m).filter isEmptyCol |>.length", "vc-helpers": "", "vc-definitions": "def solve_game (n m : Nat) (grid : List (List Nat)) : String :=\n  sorry", "vc-theorems": "theorem solve_game_returns_valid_winner (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : ∀ row ∈ grid, row.length = m)\n  (h5 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  solve_game n m grid = \"Ashish\" ∨ solve_game n m grid = \"Vivek\" :=\nsorry\n\ntheorem winner_depends_on_empty_lines (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : ∀ row ∈ grid, row.length = m)\n  (h5 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let empty_rows := countEmptyRows grid\n  let empty_cols := countEmptyCols n m grid\n  let min_empty := min empty_rows empty_cols\n  solve_game n m grid = \"Ashish\" ↔ min_empty % 2 = 1 :=\nsorry\n\ntheorem all_zeros_grid (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 0)\n  solve_game n m grid = (if min n m % 2 = 1 then \"Ashish\" else \"Vivek\") :=\nsorry\n\ntheorem no_empty_lines (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 1)\n  solve_game n m grid = \"Vivek\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 0]]\n\n/-\ninfo: 'Ashish'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 1]]\n\n/-\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 3 [[1, 0, 1], [1, 1, 0]]"}
{"id": "fvapps_000104", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_magic_candies (n : Nat) (k : Nat) (candies : List Nat) : Nat :=\n  sorry\n\ndef list_minimum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_magic_candies_minimum_case\n  (k : Nat)\n  (h1 : k ≥ 1) (h2 : k ≤ 1000) :\n  solve_magic_candies 2 k [1, 1] = k - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_magic_candies 2 2 [1, 1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 5 [1, 2, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 7 [3, 2, 2]"}
{"id": "fvapps_000107", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef sum (xs : List Nat) : Nat :=\n  sorry\n\ndef min_divisions (n : Nat) (boxes : List Nat) : Int :=\n  sorry", "vc-theorems": "theorem min_divisions_properties (n : Nat) (boxes : List Nat)\n  (h1 : n ≥ 1) (h2 : ∀ x ∈ boxes, isPowerOfTwo x = true) :\n  let result := min_divisions n boxes;\n  (result ≠ -1 →\n    (result ≥ 0 ∧\n     sum boxes ≥ n)) ∧\n  (sum boxes < n →\n    result = -1) := by\n  sorry\n\ntheorem min_divisions_with_sum (boxes : List Nat)\n  (h : ∀ x ∈ boxes, isPowerOfTwo x = true) :\n  let n := sum boxes;\n  let result := min_divisions n boxes;\n  result = 0 ∨ result = -1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_divisions *test1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_divisions *test2\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_divisions *test3"}
{"id": "fvapps_000108", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_peaks (window : List Nat) : Nat :=\n  sorry\n\ndef solve_door_peaks (n k : Nat) (arr : List Nat) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem peaks_atleast_one {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (peaks, _) := solve_door_peaks n k arr\n  peaks ≥ 1 :=\nsorry\n\ntheorem position_in_range {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (_, pos) := solve_door_peaks n k arr\n  1 ≤ pos ∧ pos ≤ n - k + 1 :=\nsorry\n\ntheorem peaks_match_window {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (peaks, pos) := solve_door_peaks n k arr\n  let window := arr.take k\n  count_peaks window = peaks - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 8 6 [1, 2, 4, 1, 2, 4, 1, 2]\n\n/-\ninfo: (2, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 5 3 [3, 2, 3, 2, 1]\n\n/-\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_door_peaks 10 4 [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]"}
{"id": "fvapps_000115", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_naruto_seals (n m : Nat) (rows cols : List (List Nat)) : List (List Nat) :=\nsorry\n\ndef is_valid_matrix (result : List (List Nat)) (n m : Nat) (rows cols : List (List Nat)) : Bool :=\nsorry\n\ndef makeMatrix (n m : Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem dimensions_check (n m : Nat) (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  List.length result = n ∧ ∀ row ∈ result, List.length row = m :=\nsorry\n\ntheorem permutations_check (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 5) (h3 : 0 < m) (h4 : m ≤ 5) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  is_valid_matrix result n m matrix matrix = true :=\nsorry\n\ntheorem single_cell_check :\n  solve_naruto_seals 1 1 [[1]] [[1]] = [[1]] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000116", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_teams (n: Nat) (x: Nat) (skills: List Nat) : Nat :=\n  sorry\n\ndef list_sort (l: List Nat) : List Nat :=\n  sorry\n\ndef list_sum (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_teams_bounds\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: ∀ s ∈ skills, s ≥ 1 ∧ s ≤ 100) :\n  let result := max_teams n x skills\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_teams_sort_invariant\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h: skills.length = n) :\n  max_teams n x skills = max_teams n x (list_sort skills) :=\nsorry\n\ntheorem max_teams_impossible_target\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: x > (list_sum skills) * n) :\n  max_teams n x skills = 0 :=\nsorry\n\ntheorem max_teams_min_requirement\n  (n: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: ∀ s ∈ skills, s ≥ 1) :\n  max_teams n 1 skills = (List.filter (λ s => s ≥ 1) skills).length :=\nsorry\n\ntheorem max_teams_empty\n  (x: Nat) :\n  max_teams 0 x [] = 0 :=\nsorry\n\ntheorem max_teams_uniform_skills\n  (n: Nat) (skill: Nat)\n  (h1: skill ≥ 1)\n  (h2: skill ≤ 100) :\n  max_teams n skill (List.replicate n skill) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_teams 5 10 [7, 11, 2, 9, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_teams 4 8 [2, 4, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_teams 4 11 [1, 3, 3, 7]"}
{"id": "fvapps_000119", "vc-description": "", "vc-preamble": "def abs (x: Nat) (y: Nat) : Nat :=\nif x ≥ y then x - y else y - x", "vc-helpers": "", "vc-definitions": "def solve_min_skill_diff (n: Nat) (arr: List Nat) : Nat :=\nsorry\n\ndef list_max (xs: List Nat) : Nat :=\nsorry\n\ndef list_min (xs: List Nat) : Nat :=\nsorry\n\ndef list_sort (xs: List Nat) : List Nat :=\nsorry\n\ndef list_differences (xs: List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_skill_diff_properties {n: Nat} {arr: List Nat} (h1: n < arr.length) (h2: 1 ≤ n) (h3: arr.length ≥ 2)\n(h4: ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 1000) :\n  let result := solve_min_skill_diff n arr\n  result ≥ 0 ∧ result ≤ list_max arr - list_min arr :=\nsorry\n\ntheorem identical_values_property {arr: List Nat} (h1: arr.length ≥ 2)\n(h2: ∀ x ∈ arr, x = 1) :\n  let n := arr.length / 2\n  solve_min_skill_diff n arr = 0 :=\nsorry\n\ntheorem sorted_sequence_property {n: Nat} {arr: List Nat}\n(h1: n < arr.length) (h2: 1 ≤ n) (h3: 2 ≤ arr.length) (h4: arr.length ≤ 20)\n(h5: ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100) :\n  let result := solve_min_skill_diff n arr\n  let sorted := list_sort arr\n  let diffs := list_differences sorted\n  result ∈ diffs :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 1 [1, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 3 [6, 5, 4, 1, 2, 3]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 5 [13, 4, 20, 13, 2, 5, 8, 3, 17, 16]"}
{"id": "fvapps_000120", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Int) : Int :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry\n\ndef take (n : Nat) (l : List Int) : List Int :=\n  sorry\n\ndef drop (n : Nat) (l : List Int) : List Int :=\n  sorry\n\ndef map (f : Int → Int) (l : List Int) : List Int :=\n  sorry\n\ndef maxScore (cards : List Int) (k : Nat) : Int :=\n  sorry", "vc-theorems": "", "vc-postamble": ""}
{"id": "fvapps_000123", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def super_pow (base : Int) (exponent_digits : List Int) : Int :=\n  sorry\n\ndef pow_mod (base exp m : Int) : Int :=\n  sorry", "vc-theorems": "theorem super_pow_range (base : Int) (exp_digits : List Int)\n  (h1 : base > 0)\n  (h2 : exp_digits.length > 0)\n  (h3 : exp_digits.length ≤ 10)\n  (h4 : ∀ d ∈ exp_digits, 0 ≤ d ∧ d ≤ 9) :\n  let result := super_pow base exp_digits\n  0 ≤ result ∧ result < 1337 :=\nsorry\n\ntheorem super_pow_small_exp (base : Int) (exp_digit : Int)\n  (h1 : base > 0)\n  (h2 : 0 ≤ exp_digit)\n  (h3 : exp_digit < 5) :\n  super_pow base [exp_digit] = pow_mod base exp_digit 1337 :=\nsorry\n\ntheorem super_pow_zero (base : Int)\n  (h : base > 0) :\n  super_pow base [0] = 1 :=\nsorry\n\ntheorem super_pow_one (base : Int) (exp_digits : List Int)\n  (h1 : exp_digits.length > 0)\n  (h2 : exp_digits.length ≤ 5)\n  (h3 : ∀ d ∈ exp_digits, 0 ≤ d ∧ d ≤ 9) :\n  super_pow 1 exp_digits = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval super_pow 2 [3]\n\n/-\ninfo: 1024\n-/\n#guard_msgs in\n#eval super_pow 2 [1, 0]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval super_pow 3 [2]"}
{"id": "fvapps_000125", "vc-description": "-- Empty list cases\n\n-- Scaling property\n\n-- Basic properties", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def profitable_schemes (G : Nat) (P : Nat) (group : List Nat) (profit : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem profitable_schemes_non_negative (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit ≥ 0 :=\nsorry\n\ntheorem profitable_schemes_mod_bound (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit < MOD :=\nsorry\n\ntheorem profitable_schemes_empty_zero_profit (G : Nat) :\n  profitable_schemes G 0 [] [] = 1 :=\nsorry\n\ntheorem profitable_schemes_empty_positive_profit (G P : Nat) :\n  P > 0 → profitable_schemes G P [] [] = 0 :=\nsorry\n\ntheorem profitable_schemes_scaling (G P : Nat) (group profit : List Nat) :\n  group ≠ [] →\n  profit.length = group.length →\n  profitable_schemes G P group profit =\n  profitable_schemes G (2 * P) group (List.map (fun p => 2 * p) profit) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval profitable_schemes 5 3 [2, 2] [2, 3]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval profitable_schemes 10 5 [2, 3, 5] [6, 7, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval profitable_schemes 1 1 [1] [1]"}
{"id": "fvapps_000126", "vc-description": "", "vc-preamble": "def makeParens (n : Nat) : String :=\n  match n with\n  | 0 => \"\"\n  | n+1 => \"(\" ++ makeParens n", "vc-helpers": "", "vc-definitions": "def calculate (s : String) : Int :=\nsorry", "vc-theorems": "theorem single_number {n : Int} (h : -1000 ≤ n ∧ n ≤ 1000) :\n  calculate s!\"{n}\" = n :=\nsorry\n\ntheorem addition {a b : Int} (h : -100 ≤ a ∧ a ≤ 100 ∧ -100 ≤ b ∧ b ≤ 100) :\n  calculate s!\"{a}+{b}\" = a + b :=\nsorry\n\ntheorem nested_parentheses {n : Int} (h : -50 ≤ n ∧ n ≤ 50) :\n  calculate s!\"{makeParens n.toNat}1{makeParens n.toNat}\" = 1 :=\nsorry\n\ntheorem parentheses_operations {a b : Int} (h : -50 ≤ a ∧ a ≤ 50 ∧ -50 ≤ b ∧ b ≤ 50) :\n  calculate s!\"({a})+({b})\" = a + b ∧\n  calculate s!\"({a})-({b})\" = a - b :=\nsorry\n\ntheorem whitespace_invariance (spaces : String) (h : ∀ c ∈ spaces.data, c = ' ') :\n  calculate \"1+2\" = calculate s!\"{spaces}1{spaces}+{spaces}2{spaces}\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calculate \"\"1 + 1\"\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calculate \"\" 2-1 + 2 \"\"\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval calculate \"\"(1+(4+5+2)-3)+(6+8)\"\""}
{"id": "fvapps_000128", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.repeat (s : String) (n : Nat) : String :=\n  sorry\n\ndef number_of_arrays (s : String) (k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_digit_valid {d : Char} {k : Nat}\n  (h1 : d ∈ ['1', '2', '3', '4', '5', '6', '7', '8', '9'])\n  (h2 : k > 0)\n  : number_of_arrays (String.mk [d]) k = if (d.toNat - 48) ≤ k then 1 else 0 :=\nsorry\n\ntheorem single_zero_invalid {k : Nat} (h : k > 0)\n  : number_of_arrays \"0\" k = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10000\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval number_of_arrays \"1317\" 2000"}
{"id": "fvapps_000131", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def balanced_string (s : String) : Int :=\nsorry\n\ndef has_equal_quarters (s : String) : Bool :=\nsorry\n\ndef count_char (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem invalid_length_returns_negative {s : String} :\n  (s.length % 4 ≠ 0) → balanced_string s = -1 :=\nsorry\n\ntheorem result_within_bounds {s : String} :\n  balanced_string s ≠ -1 →\n  0 ≤ balanced_string s ∧ balanced_string s ≤ s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval balanced_string \"QWER\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval balanced_string \"QQWE\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval balanced_string \"QQQW\""}
{"id": "fvapps_000137", "vc-description": "/- Output is bounded between 0 and string length -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Already sorted columns need 0 deletions -/\n\n/- Reverse sorted columns need at most string length deletions -/\n\n/- Identical strings need 0 deletions -/\n\n-- imagine this is the input with sorted columns\n\n-- imagine this is input with reverse sorted columns", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minDeletionSize (A : List (List Char)) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (A : List (List Char)) (h : A.all (λ s => s.length = A.head!.length)) :\n  let result := minDeletionSize A\n  0 ≤ result ∧ result ≤ A.head!.length :=\nsorry\n\ntheorem sorted_columns_zero_deletions (A : List (List Char)) (h : A.all (λ s => s.length = A.head!.length)) :\n  let sorted_columns := A\n  minDeletionSize sorted_columns = 0 :=\nsorry\n\ntheorem reverse_sorted_most_deletions (A : List (List Char)) (h₁ : A ≠ []) (h₂ : A.all (λ s => s.length = A.head!.length)) :\n  let reverse_sorted := A\n  minDeletionSize reverse_sorted ≤ A.head!.length :=\nsorry\n\ntheorem identical_strings_zero_deletions (A : List (List Char)) (s : List Char)\n    (h₁ : A ≠ []) (h₂ : A.all (λ str => str = s)) :\n  minDeletionSize A = 0 :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_deletion_size [\"ca\", \"bb\", \"ac\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_deletion_size [\"xc\", \"yb\", \"za\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_deletion_size [\"zyx\", \"wvu\", \"tsr\"]"}
{"id": "fvapps_000139", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numRescueBoats (people : List Nat) (limit : Nat) : Nat :=\n  sorry\n\ndef listMax (l : List Nat) : Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry\n\ndef listSort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem rescue_boats_minimum (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit ≥ (people.length + 1) / 2 := by\n  sorry\n\ntheorem rescue_boats_maximum (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit ≤ people.length := by\n  sorry\n\ntheorem rescue_boats_deterministic (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit = numRescueBoats people limit := by\n  sorry\n\ntheorem single_person_per_boat (weights : List Nat) (h : weights ≠ []) :\n  let min_limit := listMin weights\n  numRescueBoats weights min_limit = weights.length := by\n  sorry\n\ntheorem sorted_same_result (people : List Nat) (limit : Nat)\n    (h1 : people.length ≥ 2) (h2 : ∀ x ∈ people, x ≤ 100) (h3 : limit ≤ 100) :\n  numRescueBoats people limit = numRescueBoats (listSort people) limit := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRescueBoats [1, 2] 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 2, 2, 1] 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 5, 3, 4] 5"}
{"id": "fvapps_000141", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_fruit (tree : List Nat) : Nat :=\nsorry\n\ndef maxSubseqLengthWithTwoTypes (tree : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem total_fruit_bounds {tree : List Nat} (h : tree ≠ []) :\n  1 ≤ total_fruit tree ∧ total_fruit tree ≤ tree.length :=\nsorry\n\ntheorem total_fruit_min_length {tree : List Nat} (h : tree.length ≥ 3) :\n  total_fruit tree ≥ 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [0, 1, 2, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 3, 2, 2]"}
{"id": "fvapps_000148", "vc-description": "", "vc-preamble": "axiom List.maximum' : List Int → Int\n\naxiom List.Sorted : List Int → Prop\n\ndef partitioned_at (p : Nat) (nums : List Int) : Prop :=\n  let left := (nums.take p)\n  let right := (nums.drop p)\n  let left_max := List.maximum' left\n  (∀ x ∈ left, x ≤ left_max) ∧\n  (∀ x ∈ right, x ≥ left_max)", "vc-helpers": "", "vc-definitions": "def partition_disjoint (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem partition_point_valid : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  1 ≤ res ∧ res ≤ nums.length :=\nsorry\n\ntheorem partition_left_properties : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let left_max := List.maximum' left\n  ∀ x ∈ left, x ≤ left_max :=\nsorry\n\ntheorem partition_right_properties : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  ∀ x ∈ right, x ≥ left_max :=\nsorry\n\ntheorem sorted_list_partitions_at_one : ∀ nums, nums.length ≥ 2 →\n  List.Sorted nums →\n  partition_disjoint nums = 1 :=\nsorry\n\ntheorem no_smaller_elements_after_partition : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  ¬∃ x ∈ right, x < left_max :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [5, 0, 3, 8, 6]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval partition_disjoint [1, 1, 1, 0, 6, 12]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [3, 1, 2, 4, 5]"}
{"id": "fvapps_000149", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef hasThreeRepeated (s : String) : Bool :=\n  sorry\n\ndef strongPasswordChecker (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem output_non_negative (s : String) :\n  strongPasswordChecker s ≥ 0 :=\nsorry\n\ntheorem valid_password_needs_no_changes (s : String) :\n  (s.length ≥ 6 ∧ s.length ≤ 20 ∧\n   s.any isLower ∧\n   s.any isUpper ∧\n   s.any isDigit ∧\n   ¬hasThreeRepeated s) →\n  strongPasswordChecker s = 0 :=\nsorry\n\ntheorem short_password_minimum_changes (s : String) :\n  s.length < 6 →\n  strongPasswordChecker s ≥ 6 - s.length :=\nsorry\n\ntheorem long_password_minimum_changes (s : String) :\n  s.length > 20 →\n  strongPasswordChecker s ≥ s.length - 20 :=\nsorry\n\ntheorem missing_categories_minimum_changes (s : String) :\n  let missing := (if s.any isLower then 0 else 1) +\n                 (if s.any isUpper then 0 else 1) +\n                 (if s.any isDigit then 0 else 1)\n  strongPasswordChecker s ≥ missing :=\nsorry\n\ntheorem repeated_chars_minimum_changes (s : String) :\n  (∀ c : Char, c ∈ s.data → c = 'a') →\n  s.length ≥ 3 →\n  strongPasswordChecker s ≥ s.length / 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"a\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"aA1\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"1337C0d3\""}
{"id": "fvapps_000150", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_distance (positions : List Nat) (m : Nat) : Nat :=\n  sorry\n\ndef can_place_balls (distance : Nat) (sorted_pos : List Nat) (m : Nat) : Bool :=\nsorry", "vc-theorems": "theorem max_distance_bounds {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  result ≥ 0 ∧\n  result ≤ (positions[positions.length-1]! - positions[0]!) :=\nsorry\n\ntheorem max_distance_placement {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  can_place_balls result positions m = true :=\nsorry\n\ntheorem max_distance_maximal {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  result < (positions[positions.length-1]! - positions[0]!) →\n  can_place_balls (result + 1) positions m = false :=\nsorry\n\ntheorem max_distance_input_preservation {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length) :\n  positions = positions :=\nsorry\n\ntheorem max_distance_edge_cases :\n  max_distance [1, 1000000000] 2 = 999999999 ∧\n  max_distance [1,2,3] 3 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 7] 3\n\n/-\ninfo: 999999999\n-/\n#guard_msgs in\n#eval max_distance [5, 4, 3, 2, 1, 1000000000] 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 5, 6] 4"}
{"id": "fvapps_000154", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubsequence (s₁ s₂ : String) : Bool :=\nsorry\n\ndef shortestCommonSupersequence (s₁ s₂ : String) : String :=\nsorry", "vc-theorems": "theorem scs_contains_both_strings (s₁ s₂ : String) :\n  let result := shortestCommonSupersequence s₁ s₂\n  isSubsequence s₁ result = true ∧ isSubsequence s₂ result = true :=\nsorry\n\ntheorem scs_same_string (s : String) :\n  shortestCommonSupersequence s s = s :=\nsorry\n\ntheorem scs_length_bounds (s₁ s₂ : String) :\n  let result := shortestCommonSupersequence s₁ s₂\n  result.length ≥ max s₁.length s₂.length ∧\n  result.length ≤ s₁.length + s₂.length :=\nsorry\n\ntheorem scs_empty_string (s : String) :\n  shortestCommonSupersequence \"\" s = s ∧\n  shortestCommonSupersequence s \"\" = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'cabac'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"abac\" \"cab\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len shortest_common_supersequence(\"abc\", \"def\")\n\n/-\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"aaaaa\" \"aa\""}
{"id": "fvapps_000161", "vc-description": "", "vc-preamble": "def stringToList (s : String) : List Char := s.data\n\ndef listToString (l : List Char) : String := String.mk l\n\ndef charListOrdered (l₁ l₂ : List Char) : Bool :=\n  match l₁, l₂ with\n  | [], [] => true\n  | x::xs, y::ys => if x.val < y.val then true\n                    else if x.val = y.val then charListOrdered xs ys\n                    else false\n  | _, _ => false\n\ndef countChar (c : Char) (s : String) : Nat :=\n  s.data.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def minInteger (num : String) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem minInteger_length (num : String) (k : Nat) :\n  (minInteger num k).length = num.length :=\nsorry\n\ntheorem minInteger_leq_input (num : String) (k : Nat) :\n  minInteger num k ≤ num :=\nsorry\n\ntheorem minInteger_zero_k (num : String) :\n  minInteger num 0 = num :=\nsorry\n\ntheorem minInteger_monotonic (num : String) (k₁ k₂ : Nat) :\n  k₁ ≤ k₂ → minInteger num k₂ ≤ minInteger num k₁ :=\nsorry\n\ntheorem minInteger_char_count (num : String) (k : Nat) (c : Char) :\n  countChar c (minInteger num k) = countChar c num :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '1342'\n-/\n#guard_msgs in\n#eval minInteger \"4321\" 4\n\n/-\ninfo: '010'\n-/\n#guard_msgs in\n#eval minInteger \"100\" 1\n\n/-\ninfo: '36789'\n-/\n#guard_msgs in\n#eval minInteger \"36789\" 1000"}
{"id": "fvapps_000163", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_flips (a b c : Nat) : Nat :=\nsorry\n\ndef count_ones (n : Nat) : Nat :=\nsorry\n\ndef bitwise_or (a b : Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_flips_non_negative (a b c : Nat) :\n  min_flips a b c ≥ 0 :=\nsorry\n\ntheorem min_flips_identity_left (c : Nat) :\n  min_flips c 0 c = 0 :=\nsorry\n\ntheorem min_flips_identity_right (c : Nat) :\n  min_flips 0 c c = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_flips 2 6 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_flips 4 2 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_flips 1 2 3"}
{"id": "fvapps_000167", "vc-description": "-- Output is between 0 and length of array\n\n-- There exists some subarray of length result that when removed makes array non-decreasing\n\n-- Cannot remove fewer elements to make array non-decreasing\n\n-- Sorted array returns 0\n\n-- Small arrays", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_length_of_shortest_subarray (arr : List Int) : Nat :=\n  sorry\n\ndef isNonDecreasing (l : List Int) : Bool :=\n  sorry\n\ndef removeSubarray (arr : List Int) (start : Nat) (len : Nat) : List Int :=\n  sorry", "vc-theorems": "theorem output_bounds (arr : List Int) :\n  let result := find_length_of_shortest_subarray arr\n  0 ≤ result ∧ result ≤ arr.length :=\nsorry\n\ntheorem valid_removal_exists (arr : List Int) (h : arr ≠ []) :\n  let result := find_length_of_shortest_subarray arr\n  ∃ i : Nat, i + result ≤ arr.length ∧\n    isNonDecreasing (removeSubarray arr i result) :=\nsorry\n\ntheorem cannot_remove_fewer (arr : List Int) (h : arr ≠ []) :\n  let result := find_length_of_shortest_subarray arr\n  result = 0 → isNonDecreasing arr\n  ∧\n  result > 0 → ∀ i : Nat, i + (result - 1) ≤ arr.length →\n    ¬isNonDecreasing (removeSubarray arr i (result - 1)) :=\nsorry\n\ntheorem sorted_returns_zero (arr : List Int) (h : arr ≠ []) :\n  isNonDecreasing arr → find_length_of_shortest_subarray arr = 0 :=\nsorry\n\ntheorem small_arrays (arr : List Int) :\n  arr.length ≤ 1 → find_length_of_shortest_subarray arr = 0\n  ∧\n  (arr.length = 2 →\n    find_length_of_shortest_subarray arr =\n      if arr.get! 0 ≤ arr.get! 1 then 0 else 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3, 10, 4, 2, 3, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [5, 4, 3, 2, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3]"}
{"id": "fvapps_000169", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxDiff (n : Nat) : Nat :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem maxDiff_single_digit (n : Nat) (h : n < 10) : maxDiff n = 8 :=\nsorry\n\ntheorem maxDiff_properties (n : Nat) :\n  n ≥ 10 →\n  maxDiff n ≥ 0 ∧\n  maxDiff n ≤ 999999 :=\nsorry\n\ntheorem maxDiff_nonnegative (n : Nat) : maxDiff n ≥ 0 :=\nsorry", "vc-postamble": "-- Helper function to get number of digits\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 888\n-/\n#guard_msgs in\n#eval maxDiff 555\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval maxDiff 9\n\n/-\ninfo: 820000\n-/\n#guard_msgs in\n#eval maxDiff 123456"}
{"id": "fvapps_000170", "vc-description": "", "vc-preamble": "def Even (n : Nat) : Prop := ∃ k, n = 2 * k\n\ndef countOdds (xs : List Int) : Nat :=\n  xs.foldl (fun acc x => if x % 2 = 1 then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def can_arrange (arr : List Int) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem can_arrange_result_type (arr : List Int) (k : Nat) :\n  can_arrange arr k = true ∨ can_arrange arr k = false :=\nsorry\n\ntheorem can_arrange_even_length {arr : List Int} {k : Nat} :\n  can_arrange arr k = true → List.length arr % 2 = 0 :=\nsorry\n\ntheorem can_arrange_k_one {arr : List Int} :\n  can_arrange arr 1 = true ↔ List.length arr % 2 = 0 :=\nsorry\n\ntheorem can_arrange_k_two {arr : List Int} :\n  can_arrange arr 2 = true →\n  Even (countOdds arr) :=\nsorry\n\ntheorem can_arrange_empty {k : Nat} :\n  can_arrange [] k = true :=\nsorry\n\ntheorem can_arrange_singleton {x : Int} {k : Nat} :\n  can_arrange [x] k = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 10, 6, 7, 8, 9] 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 6] 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [-1, 1, -2, 2, -3, 3, -4, 4] 3"}
{"id": "fvapps_000173", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- We'll use substring operations instead of direct char manipulation -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isScramble (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem equal_strings_are_scramble (s : String) :\n  isScramble s s = true :=\nsorry\n\ntheorem different_lengths_not_scramble (s : String) :\n  isScramble s (s ++ \"a\") = false :=\nsorry\n\ntheorem different_chars_not_scramble (s : String) (h : s.length > 0) :\n  ∀ (s2 : String), s.length = s2.length → (∃ c, s.contains c ≠ s2.contains c) →\n  isScramble s s2 = false :=\nsorry\n\ntheorem length_two_strings_scramble (s1 s2 : String) :\n  s1.length = 2 → s2.length = 2 → (∀ c, s1.contains c = s2.contains c) →\n  isScramble s1 s2 = true :=\nsorry\n\ntheorem scramble_symmetric (s1 s2 : String) :\n  isScramble s1 s2 = isScramble s2 s1 :=\nsorry\n\ntheorem empty_strings_are_scramble :\n  isScramble \"\" \"\" = true :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"great\" \"rgeat\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_scramble \"abcde\" \"caebd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"a\" \"a\""}
{"id": "fvapps_000177", "vc-description": "", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def min_refuel_stops (target : Nat) (start_fuel : Nat) (stations : List (Nat × Nat)) : Int :=\n  sorry", "vc-theorems": "theorem min_refuel_stops_result_valid (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result ≥ -1 :=\nsorry\n\ntheorem min_refuel_stops_sufficient_start_fuel (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  start_fuel ≥ target →\n  min_refuel_stops target start_fuel stations = 0 :=\nsorry\n\ntheorem min_refuel_stops_impossible (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let total_fuel := start_fuel + list_sum (stations.map Prod.snd)\n  total_fuel < target →\n  min_refuel_stops target start_fuel stations = -1 :=\nsorry\n\ntheorem min_refuel_stops_stations_ordered (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  stations.length > 0 →\n  ∀ i : Nat, i < stations.length - 1 →\n  (stations.get! i).1 ≤ (stations.get! (i+1)).1 :=\nsorry\n\ntheorem min_refuel_stops_bound (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result ≠ -1 →\n  result ≤ stations.length :=\nsorry\n\ntheorem min_refuel_stops_empty_stations_sufficient (start_fuel target : Nat) :\n  target ≤ start_fuel →\n  min_refuel_stops target start_fuel [] = 0 :=\nsorry\n\ntheorem min_refuel_stops_empty_stations_insufficient (start_fuel target : Nat) :\n  start_fuel < target →\n  min_refuel_stops target start_fuel [] = -1 :=\nsorry\n\ntheorem min_refuel_stops_zero_start_fuel (target : Nat) (stations : List (Nat × Nat)) :\n  min_refuel_stops target 0 stations = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_refuel_stops 1 1 []\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 1 [[10, 100]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 10 [[10, 60], [20, 30], [30, 30], [60, 40]]"}
{"id": "fvapps_000184", "vc-description": "", "vc-preamble": "def list_sum (xs: List Nat) : Nat :=\nxs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def min_operations_max_profit (customers: List Nat) (boarding_cost: Nat) (running_cost: Nat) : Int :=\nsorry", "vc-theorems": "theorem min_operations_result_valid\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x ≤ 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    result = -1 ∨ result > 0 :=\nsorry\n\ntheorem min_operations_max_rotations\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x ≤ 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    let total := list_sum customers\n    let max_rotations := total / 4 + (if total % 4 = 0 then 0 else 1)\n    result = -1 ∨ result ≤ max_rotations + total :=\nsorry\n\ntheorem high_running_cost_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: customers.length ≤ 10)\n  (h3: boarding_cost > 0)\n  (h4: boarding_cost ≤ 10)\n  (h5: ∀ x ∈ customers, x ≤ 10)\n  : min_operations_max_profit customers boarding_cost 1000 = -1 :=\nsorry\n\ntheorem high_profit_scenario_profitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost ≥ 100)\n  (h3: ∀ x ∈ customers, x ≥ 100 ∧ x ≤ 1000)\n  : min_operations_max_profit customers boarding_cost 1 > 0 :=\nsorry\n\ntheorem no_customers_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x = 0)\n  : min_operations_max_profit customers boarding_cost running_cost = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_operations_max_profit [8, 3] 5 6\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_operations_max_profit [10, 9, 6] 6 4\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_operations_max_profit [3, 4, 0, 5, 1] 1 92"}
{"id": "fvapps_000187", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "def countValidDigits (digits : List String) (n : Nat) : Nat :=\n  (digits.filter (fun d => d.toNat?.getD 0 ≤ n)).length", "vc-helpers": "", "vc-definitions": "def atMostNGivenDigitSet (digits : List String) (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_nonnegative {digits : List String} {n : Nat} :\n  0 ≤ atMostNGivenDigitSet digits n :=\nsorry\n\ntheorem result_within_max_possible {digits : List String} {n : Nat} :\n  let max_len := toString n |>.length\n  atMostNGivenDigitSet digits n ≤ (digits.length ^ max_len) :=\nsorry\n\ntheorem single_digit_result {digits : List String} {n : Nat} :\n  n < 10 →\n  atMostNGivenDigitSet digits n = countValidDigits digits n :=\nsorry\n\ntheorem empty_digit_list_fails (n : Nat) :\n  atMostNGivenDigitSet [] n = 0 :=\nsorry\n\ntheorem single_digit_basic_cases_1 :\n  atMostNGivenDigitSet [\"1\"] 1 = 1 :=\nsorry\n\ntheorem single_digit_basic_cases_2 :\n  atMostNGivenDigitSet [\"9\"] 10 = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000189", "vc-description": "", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + sum t\n\ndef listRange (n : Nat) : List Int :=\n  (List.range n).map Int.ofNat", "vc-helpers": "", "vc-definitions": "def min_set_size (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem min_set_size_positive (arr : List Int) (h : arr ≠ []) :\n  min_set_size arr > 0 :=\nsorry\n\ntheorem min_set_size_upper_bound (arr : List Int) (h : arr ≠ []) :\n  min_set_size arr ≤ arr.length :=\nsorry\n\ntheorem min_set_size_removes_half (arr : List Int) (h : arr ≠ []) :\n  let countMap := arr.map (fun x => (arr.filter (· = x)).length)\n  let removed := countMap.take (min_set_size arr)\n  sum removed ≥ arr.length / 2 :=\nsorry\n\ntheorem min_set_size_all_same (arr : List Int) (h : arr ≠ []) :\n  (∀ i j, i < arr.length → j < arr.length → arr[i]! = arr[j]!) →\n  min_set_size arr = 1 :=\nsorry\n\ntheorem min_set_size_all_unique (n : Nat) :\n  min_set_size (listRange n) = (n + 1) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_set_size [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_set_size [7, 7, 7, 7, 7, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval min_set_size [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"}
{"id": "fvapps_000191", "vc-description": "-- Basic properties\n\n-- For prime numbers\n\n-- For prime powers\n\n-- For products\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def is_prime (n : Int) : Prop :=\n  n > 1 ∧ ∀ k, 2 ≤ k → k < n → ¬(n % k = 0)", "vc-helpers": "", "vc-definitions": "def sum_of_prime_factors (n : Int) : Int :=\n  sorry\n\ndef pow (base exp : Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_prime_factors_positive {n : Int} (h : n ≥ 2) :\n  sum_of_prime_factors n > 0 ∧ sum_of_prime_factors n ≤ n :=\nsorry\n\ntheorem sum_prime_factors_nonpositive {n : Int} (h : n ≤ 1) :\n  sum_of_prime_factors n = 0 :=\nsorry\n\ntheorem sum_prime_factors_of_prime {n : Int} (h : is_prime n) :\n  sum_of_prime_factors n = n :=\nsorry\n\ntheorem sum_prime_factors_of_prime_power {p k : Int}\n  (hp : is_prime p) (hk : k > 0) :\n  sum_of_prime_factors (pow p k) = p :=\nsorry\n\ntheorem sum_prime_factors_of_product {a b : Int} (ha : a ≥ 2) (hb : b ≥ 2) :\n  sum_of_prime_factors (a * b) ≤ sum_of_prime_factors a + sum_of_prime_factors b :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000192", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSubarraySumCircular (nums : List Int) : Int :=\nsorry\n\ndef isEmpty (nums : List Int) : Bool :=\nsorry\n\ndef maxElem (nums : List Int) : Int :=\nsorry\n\ndef sumList (nums : List Int) : Int :=\nsorry\n\ndef isAllPositive (nums : List Int) : Bool :=\nsorry\n\ndef isAllNegative (nums : List Int) : Bool :=\nsorry\n\ndef rotate (nums : List Int) (i : Nat) : List Int :=\nsorry", "vc-theorems": "theorem single_element (nums : List Int) (h : nums.length = 1) (first : Int) :\n  nums = [first] → maxSubarraySumCircular nums = first :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, 3, -2, 1]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [5, -3, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, -3, -1]"}
{"id": "fvapps_000195", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_consecutive (nums : List Int) : Nat :=\nsorry\n\ndef removeDuplicates (nums : List Int) : List Int :=\nsorry\n\ndef sortList (nums : List Int) : List Int :=\nsorry", "vc-theorems": "theorem output_nonnegative (nums : List Int) :\n  longest_consecutive nums ≥ 0 :=\nsorry\n\ntheorem same_as_deduplicated (nums : List Int) :\n  longest_consecutive nums = longest_consecutive (removeDuplicates nums) :=\nsorry\n\ntheorem sorted_same_as_unsorted (nums : List Int) :\n  nums ≠ [] → longest_consecutive nums = longest_consecutive (sortList nums) :=\nsorry\n\ntheorem output_leq_input_len (nums : List Int) :\n  longest_consecutive nums ≤ nums.length :=\nsorry\n\ntheorem empty_list_zero (nums : List Int) :\n  nums = [] → longest_consecutive nums = 0 :=\nsorry\n\ntheorem single_element_one (nums : List Int) (x : Int) :\n  nums = [x] → longest_consecutive nums = 1 :=\nsorry\n\ntheorem reversed_same (nums : List Int) :\n  nums ≠ [] → longest_consecutive nums = longest_consecutive nums.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_consecutive [100, 4, 200, 1, 3, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval longest_consecutive [1, 2, 0, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_consecutive []"}
{"id": "fvapps_000209", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def myPow (x : Float) (n : Int) : Float :=\n  sorry\n\ndef isClose (a b : Float) (relTol absTol : Float := 0.0) : Bool :=\n  sorry", "vc-theorems": "theorem myPow_matches_mathPow {x : Float} {n : Int}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10)\n  (n_range : -5 ≤ n ∧ n ≤ 5) :\n  isClose (myPow x n) (Float.pow x (Float.ofInt n)) (relTol := 1e-5) (absTol := 1e-5) :=\nsorry\n\ntheorem myPow_zero_exponent {x : Float}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10) :\n  myPow x 0 = 1.0 :=\nsorry\n\ntheorem myPow_inverse_property {x : Float} {n : Int}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10)\n  (n_range : 1 ≤ n ∧ n ≤ 2) :\n  isClose ((myPow x n) * (myPow x (-n))) 1.0 (relTol := 1e-5) (absTol := 1e-5) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000211", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isGoodArray (nums : List Nat) : Bool :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef listGcd (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem good_array_gcd {nums : List Nat} (h : nums ≠ []) :\n  isGoodArray nums = true ↔ listGcd nums = 1\n  :=\nsorry\n\ntheorem multiples_not_good {n : Nat} (h : n ≥ 2) :\n  isGoodArray [n, 2*n, 3*n, 4*n] = false\n  :=\nsorry\n\ntheorem scale_makes_not_good {nums : List Nat} (h : nums ≠ []) :\n  isGoodArray (nums.map (· * 2)) = false\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[12, 5, 7, 23]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[29, 6, 10]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isGoodArray #[3, 6]"}
{"id": "fvapps_000213", "vc-description": "", "vc-preamble": "def countUnique (l: List Nat) : Nat :=\n  (List.foldl (fun acc x => if acc.contains x then acc else x::acc) [] l).length", "vc-helpers": "", "vc-definitions": "def subarrayBitwiseORs (nums: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_is_nonnegative {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≥ 0 :=\nsorry\n\ntheorem result_upper_bound {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≤ (nums.length * (nums.length + 1)) / 2 :=\nsorry\n\ntheorem single_element_subarray {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≥ countUnique nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [0]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 1, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 2, 4]"}
{"id": "fvapps_000217", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_dup_substring (s : String) : String :=\nsorry\n\ndef isSubstringOf (sub str : String) : Bool :=\nsorry\n\ndef countOccurrences (needle haystack : String) (start : Nat) : Nat :=\nsorry\n\ndef hasLongerDuplicate (s : String) (len : Nat) : Bool :=\nsorry", "vc-theorems": "theorem longest_dup_occurs_twice {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  if result.length > 0 then\n    countOccurrences result s 0 ≥ 2\n  else True :=\nsorry\n\ntheorem no_longer_duplicate_exists {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  ∀ len, len > result.length →\n  hasLongerDuplicate s len = false :=\nsorry\n\ntheorem longest_dup_is_substring {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  isSubstringOf result s = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000222", "vc-description": "", "vc-preamble": "def isPerfectSquare (n: Nat) : Bool :=\n  match n with\n  | 0 => true\n  | n + 1 =>\n    let sq := sqrt n\n    sq * sq = n", "vc-helpers": "", "vc-definitions": "def sqrt (n: Nat) : Nat :=\nsorry\n\ndef numSquarefulPerms (A: List Nat) : Nat :=\nsorry\n\ndef factorial (n: Nat) : Nat :=\nsorry", "vc-theorems": "theorem output_bounds\n  (A: List Nat)\n  (h1: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :\n  let result := numSquarefulPerms A\n  0 ≤ result ∧ result ≤ factorial A.length :=\nsorry\n\ntheorem valid_permutations\n  (A: List Nat)\n  (h1: A.length ≥ 2)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)\n  (h3: numSquarefulPerms A > 0) :\n  ∃ i, i < A.length - 1 ∧ isPerfectSquare (A[i]! + A[i+1]!) :=\nsorry\n\ntheorem identical_elements\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)\n  (x: Nat)\n  (h3: x = A[0]!) :\n  numSquarefulPerms (List.replicate A.length x) = 0 ∨\n  numSquarefulPerms (List.replicate A.length x) = 1 :=\nsorry\n\ntheorem sorting_invariance\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :\n  numSquarefulPerms A = numSquarefulPerms (List.reverse A) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 17, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numSquarefulPerms [2, 2, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 1]"}
{"id": "fvapps_000223", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestOnes (A : List Nat) (K : Nat) : Nat :=\nsorry\n\ndef isConsecutiveOnes (A : List Nat) (n : Nat) : Prop :=\nsorry\n\ndef maxConsecutiveOnes (A : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem longestOnes_upper_bound (A : List Nat) (K : Nat) :\n  longestOnes A K ≤ A.length :=\nsorry\n\ntheorem longestOnes_min_bound (A : List Nat) (K : Nat) (n : Nat) :\n  isConsecutiveOnes A n → n ≤ longestOnes A K :=\nsorry\n\ntheorem longestOnes_zero_k (A : List Nat) :\n  longestOnes A 0 = maxConsecutiveOnes A :=\nsorry\n\ntheorem longestOnes_large_k (A : List Nat) (K : Nat) :\n  K ≥ A.length → longestOnes A K = A.length :=\nsorry\n\ntheorem longestOnes_single_zero (K : Nat) :\n  longestOnes [0] K = min 1 K :=\nsorry\n\ntheorem longestOnes_single_one (K : Nat) :\n  longestOnes [1] K = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0] 2\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval longestOnes [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1] 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 1] 2"}
{"id": "fvapps_000224", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_vowels (s : String) (k : Nat) : Nat :=\nsorry\n\ndef count_vowels (s : String) : Nat :=\nsorry\n\ndef is_vowel (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem max_vowels_monotonic {s : String} {k : Nat}\n  (h1 : k < String.length s) :\n  max_vowels s k ≤ max_vowels s (k + 1) :=\nsorry\n\ntheorem max_vowels_empty {k : Nat}\n  (h1 : k > 0) :\n  max_vowels \"\" k = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_vowels \"abciiidef\" 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_vowels \"leetcode\" 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_vowels \"rhythms\" 4"}
{"id": "fvapps_000230", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_parens_to_add (s : String) : Nat :=\nsorry\n\ndef is_balanced (s : String) : Bool :=\nsorry\n\ndef count_char (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem empty_string : min_parens_to_add \"\" = 0 :=\nsorry\n\ntheorem unmatched_open (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n '(')) = n :=\nsorry\n\ntheorem unmatched_close (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n ')')) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_parens_to_add \"())\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_parens_to_add \"(((\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_parens_to_add \"()\""}
{"id": "fvapps_000236", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def frequency_sort (s : String) : String :=\n  sorry\n\ndef countOccurrences (c : Char) (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem frequency_sort_maintains_length (s : String) :\n  (frequency_sort s).length = s.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000242", "vc-description": "", "vc-preamble": "def splitIntoWords (s : String) : List String := s.split (· == ' ')\n\ndef wordCount (s : String) : Nat := (splitIntoWords s).length", "vc-helpers": "", "vc-definitions": "def replace_words (dict : List String) (sentence : String) : String :=\nsorry", "vc-theorems": "theorem replace_words_output_length_matches_input\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  wordCount (replace_words dict sentence) = words.length :=\nsorry\n\ntheorem replace_words_output_words_valid\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  ∀ (i : Nat) (h : i < words.length),\n    result[i]! = words[i]! ∨ result[i]! ∈ dict :=\nsorry\n\ntheorem replace_words_replacement_preserves_prefix\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  ∀ (i : Nat) (h : i < words.length),\n    result[i]! ∈ dict → words[i]!.startsWith result[i]! :=\nsorry\n\ntheorem empty_dict_preserves_input\n  (dict : List String) (word : String) (h_dict : dict = []) :\n  replace_words dict word = word :=\nsorry\n\ntheorem replace_words_idempotent\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (h_dict : dict.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let once := replace_words dict sentence\n  let twice := replace_words dict once\n  once = twice :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'the cat was rat by the bat'\n-/\n#guard_msgs in\n#eval replace_words [\"cat\", \"bat\", \"rat\"] \"the cattle was rattled by the battery\"\n\n/-\ninfo: 'a a a'\n-/\n#guard_msgs in\n#eval replace_words [\"a\", \"aa\", \"aaa\"] \"aa aaa aaaa\""}
{"id": "fvapps_000243", "vc-description": "", "vc-preamble": "def sumOfSubarray (arr : List Int) (i j : Nat) : Int :=\n  (arr.take j).drop i |>.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def minSumOfLengths (arr : List Int) (target : Int) : Int :=\n  sorry", "vc-theorems": "theorem edge_cases_return_negative_one (target : Int) :\n  minSumOfLengths [] target = -1 ∧\n  minSumOfLengths [1] (2 : Int) = -1 ∧\n  minSumOfLengths [0] (0 : Int) = -1 :=\nsorry\n\ntheorem valid_result_bounds {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ target ∧ target ≤ 1000)\n  (h3 : arr ≠ [])\n  (h4 : minSumOfLengths arr target ≠ -1) :\n  2 ≤ minSumOfLengths arr target ∧ minSumOfLengths arr target ≤ arr.length :=\nsorry\n\ntheorem negative_result_implies_no_valid_subarrays {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 0 ≤ x ∧ x ≤ 10)\n  (h2 : 0 ≤ target ∧ target ≤ 20)\n  (h3 : ¬∃ i j, 0 ≤ i ∧ i < j ∧ j ≤ arr.length ∧\n       sumOfSubarray arr i j = target) :\n  minSumOfLengths arr target = -1 :=\nsorry\n\ntheorem negative_one_implies_no_non_overlapping_subarrays {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10)\n  (h2 : 1 ≤ target ∧ target ≤ 20)\n  (h3 : arr.length ≥ 4)\n  (h4 : minSumOfLengths arr target = -1) :\n  ¬∃ i j k l,\n    0 ≤ i ∧ i < j ∧ j ≤ k ∧ k < l ∧ l ≤ arr.length ∧\n    sumOfSubarray arr i j = target ∧\n    sumOfSubarray arr k l = target :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [3, 2, 2, 4, 3] 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [7, 3, 4, 7] 7\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [4, 3, 2, 6, 2, 3, 4] 6"}
{"id": "fvapps_000244", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.rectangular (grid : List (List α)) : Bool :=\n  sorry\n\ndef contains_cycle (grid : List (List Char)) : Bool :=\n  sorry", "vc-theorems": "theorem contains_cycle_empty_raises : ∀ (grid : List (List Char)),\n  grid = [] ∨ grid.head?.map (λ row => row = []) = some true →\n  contains_cycle grid = false :=\nsorry\n\ntheorem contains_cycle_returns_bool : ∀ (grid : List (List Char)),\n  grid ≠ [] →\n  grid.head?.map (λ row => row ≠ []) = some true →\n  grid.rectangular = true →\n  (contains_cycle grid = true ∨ contains_cycle grid = false) :=\nsorry\n\ntheorem contains_cycle_all_same_char : ∀ (c : Char) (n : Nat),\n  n > 0 →\n  let grid := List.replicate n (List.replicate n c);\n  contains_cycle grid = (n > 1) :=\nsorry\n\ntheorem contains_cycle_checkerboard : ∀ (n : Nat),\n  n ≥ 2 →\n  let grid := List.map (λ i => List.map (λ j => if (i+j)%2 = 0 then 'a' else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = false :=\nsorry\n\ntheorem contains_cycle_border : ∀ (n : Nat),\n  n ≥ 3 →\n  let grid := List.map (λ i => List.map (λ j =>\n    if i = 0 ∨ i = n-1 ∨ j = 0 ∨ j = n-1\n    then 'a'\n    else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"a\", \"a\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"a\", \"a\", \"a\"]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"c\", \"c\", \"c\", \"a\"], [\"c\", \"d\", \"c\", \"c\"], [\"c\", \"c\", \"e\", \"c\"], [\"f\", \"c\", \"c\", \"c\"]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"b\", \"b\"], [\"b\", \"z\", \"b\"], [\"b\", \"b\", \"a\"]]"}
{"id": "fvapps_000249", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Nat) : Nat :=\nsorry\n\ndef listMax (l : List Nat) : Nat :=\nsorry\n\ndef findMinMoves (machines : List Nat) : Int :=\nsorry", "vc-theorems": "theorem find_min_moves_non_negative\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  findMinMoves machines ≥ 0 :=\nsorry\n\ntheorem find_min_moves_preserves_sum\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  sum machines = machines.length * (sum machines / machines.length) :=\nsorry\n\ntheorem find_min_moves_lower_bound\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  findMinMoves machines ≥\n    max (listMax machines - sum machines / machines.length) 0 :=\nsorry\n\ntheorem find_min_moves_negative_one\n  {machines : List Nat}\n  (h : findMinMoves machines = -1) :\n  sum machines % machines.length ≠ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_moves [1, 0, 5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_moves [0, 3, 0]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_moves [0, 2, 0]"}
{"id": "fvapps_000254", "vc-description": "", "vc-preamble": "def ceil_div (a b : Nat) : Nat :=\n  (a + b - 1) / b\n\ndef list_max (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | (x::xs) => List.foldl max x xs", "vc-helpers": "", "vc-definitions": "def find_smallest_divisor (nums : List Nat) (threshold : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_element_case {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length = 1)\n  (h2 : threshold > 0)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000000)\n  (h4 : threshold ≤ 1000000) :\n  find_smallest_divisor nums threshold = ceil_div nums[0] threshold :=\nsorry\n\ntheorem result_bounded {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length > 0)\n  (h2 : nums.length ≤ 10)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100)\n  (h4 : 1 ≤ threshold ∧ threshold ≤ 100) :\n  1 ≤ find_smallest_divisor nums threshold ∧\n  find_smallest_divisor nums threshold ≤ list_max nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_smallest_divisor [1, 2, 5, 9] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_smallest_divisor [2, 3, 5, 7, 11] 11\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_smallest_divisor [19] 5"}
{"id": "fvapps_000255", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def wiggleMaxLength (arr : List Int) : Nat :=\nsorry\n\ndef isSorted (l : List Int) : Bool :=\nsorry", "vc-theorems": "theorem wiggle_length_bounds (arr : List Int) :\n  0 ≤ wiggleMaxLength arr ∧ wiggleMaxLength arr ≤ arr.length :=\nsorry\n\ntheorem monotonic_increasing_bound (arr : List Int) :\n  arr.length > 1 → isSorted arr = true → wiggleMaxLength arr ≤ 2 :=\nsorry\n\ntheorem small_array_property (arr : List Int) :\n  arr.length < 2 → wiggleMaxLength arr = arr.length :=\nsorry\n\ntheorem monotonic_decreasing_bound (arr : List Int) :\n  arr.length > 1 → isSorted (List.reverse arr) = true → wiggleMaxLength arr ≤ 2 :=\nsorry\n\ntheorem shift_invariance (arr : List Int) (k : Int) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (· + k)) :=\nsorry\n\ntheorem scale_invariance (arr : List Int) (k : Int) (h : k ≠ 0) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (· * k)) :=\nsorry\n\ntheorem reverse_invariance (arr : List Int) :\n  wiggleMaxLength arr = wiggleMaxLength (List.reverse arr) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 7, 4, 9, 2, 5]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"id": "fvapps_000256", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_kth_largest (nums : List Int) (k : Nat) : Int :=\n  sorry\n\ndef max_list (l : List Int) : Int :=\n  sorry\n\ndef min_list (l : List Int) : Int :=\n  sorry\n\ndef sort_desc (l : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem find_kth_largest_element_membership\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (find_kth_largest nums k) ∈ nums :=\nsorry\n\ntheorem find_kth_largest_lower_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (nums.filter (fun x => x ≥ find_kth_largest nums k)).length ≥ k :=\nsorry\n\ntheorem find_kth_largest_upper_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (nums.filter (fun x => x > find_kth_largest nums k)).length < k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 1, 5, 6, 4] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 3, 1, 2, 4, 5, 5, 6] 4\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [2, 1, 3, 4, 5, 6] 2"}
{"id": "fvapps_000257", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Solution := String\n\ndef isSolvable (words : List String) (result : String) : Bool :=\n  sorry\n\ndef isAlpha (s : String) : Bool :=\n  sorry\n\ndef isUpper (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem valid_solution_constraints {words : List String} {result : String}\n  (h1 : ∀ w ∈ words, isAlpha w ∧ isUpper w)\n  (h2 : isAlpha result ∧ isUpper result)\n  (h3 : words.length > 0)\n  (h4 : ∀ w ∈ words, w.length > 0)\n  (h5 : result.length ≥ words.foldr (fun w acc => max w.length acc) 0) :\n  ∃ solution : Bool, isSolvable words result = solution :=\nsorry\n\ntheorem known_valid_cases_work\n  (h1 : isSolvable [\"SEND\", \"MORE\"] \"MONEY\" = true)\n  (h2 : isSolvable [\"SIX\", \"SEVEN\", \"SEVEN\"] \"TWENTY\" = true) :\n  ∀ words result,\n    (words = [\"SEND\", \"MORE\"] ∧ result = \"MONEY\") ∨\n    (words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ result = \"TWENTY\") →\n    isSolvable words result = true :=\nsorry\n\ntheorem modified_valid_case_exists_solution\n  {words result : String}\n  (h1 : words.length > 0)\n  (h2 : result.length > 0)\n  (h3 : ∃ (orig_words : List String) (orig_result : String),\n        ((orig_words = [\"SEND\", \"MORE\"] ∧ orig_result = \"MONEY\") ∨\n         (orig_words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ orig_result = \"TWENTY\")) ∧\n        words.length = orig_result.length) :\n  ∃ solution : Bool, isSolvable [words] result = solution :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000258", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_non_overlapping (nums: List Int) (target: Int) : Nat :=\n  sorry\n\ndef abs (n: Int) : Nat :=\n  sorry\n\ndef sum_list (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_non_overlapping_non_negative (nums: List Int) (target: Int) :\n  max_non_overlapping nums target ≥ 0 :=\nsorry\n\ntheorem max_non_overlapping_bounded_by_length (nums: List Int) (target: Int) :\n  max_non_overlapping nums target ≤ nums.length :=\nsorry\n\ntheorem max_non_overlapping_empty_list (target: Int) :\n  max_non_overlapping [] target = 0 :=\nsorry\n\ntheorem max_non_overlapping_all_zeros (n: Nat) :\n  max_non_overlapping (List.replicate n 0) 0 = n :=\nsorry\n\ntheorem max_non_overlapping_self_consistent (nums: List Int) (target: Int) :\n  max_non_overlapping nums target = max_non_overlapping nums target :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [1, 1, 1, 1, 1] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [-1, 3, 5, 1, 4, 2, -9] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_non_overlapping [0, 0, 0] 0"}
{"id": "fvapps_000259", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_good_splits (s : String) : Nat :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry\n\ndef uniqueChars (s : String) : Bool :=\nsorry", "vc-theorems": "theorem num_good_splits_bounds (s : String) (h : s.length > 0) :\n  num_good_splits s ≤ s.length - 1 ∧ num_good_splits s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_good_splits \"aacaba\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_good_splits \"abcd\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval num_good_splits \"aaaaa\""}
{"id": "fvapps_000263", "vc-description": "-- Length property\n\n-- Character set property\n\n-- Adjacent character property\n\n-- Empty string property", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_happy_string (n k : Nat) : String :=\n  sorry\n\ndef all_chars_abc (s : String) : Bool :=\n  sorry\n\ndef no_adjacent_same (s : String) : Bool :=\n  sorry\n\ndef starts_with_a (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem happy_string_properties (n k : Nat)\n  (h1 : 0 < n) (h2 : n ≤ 10) (h3 : 0 < k) (h4 : k ≤ 1000) :\n  let s := get_happy_string n k\n  let max_possible := 3 * 2^(n-1)\n\n  (s.length = n ∨ s.length = 0) ∧\n\n  all_chars_abc s ∧\n\n  (s.length > 1 → no_adjacent_same s) ∧\n\n  ((k > max_possible → s.length = 0) ∧\n   (k ≤ max_possible → s.length = n)) :=\nsorry\n\ntheorem n1_special_case (k : Nat)\n  (h1 : 0 < k) (h2 : k ≤ 10) :\n  let s := get_happy_string 1 k\n  (k ≤ 3 → (s = \"a\" ∨ s = \"b\" ∨ s = \"c\")) ∧\n  (k > 3 → s = \"\") :=\nsorry\n\ntheorem k1_special_case (n : Nat)\n  (h1 : 0 < n) (h2 : n ≤ 5) :\n  let s := get_happy_string n 1\n  s.length = n ∧\n  starts_with_a s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval get_happy_string 1 3\n\n/-\ninfo: 'cab'\n-/\n#guard_msgs in\n#eval get_happy_string 3 9\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval get_happy_string 1 4"}
{"id": "fvapps_000270", "vc-description": "-- proof that nodupes ≠ []", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_times_all_blue (lights : List Nat) : Nat :=\n  sorry\n\ndef remove_duplicates (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (lights : List Nat) (h : lights ≠ []) :\n  let valid := lights.filter (fun x => x ≤ lights.length)\n  let nodupes := remove_duplicates valid\n  0 ≤ num_times_all_blue nodupes ∧ num_times_all_blue nodupes ≤ nodupes.length :=\nsorry\n\ntheorem permutation_correctness {n : Nat} (lights : List Nat)\n  (h1 : lights.length = n)\n  (h2 : ∀ x, x ∈ lights → x ≤ n)\n  (h3 : ∀ x, x ∈ lights → (lights.filter (· = x)).length = 1) :\n  num_times_all_blue lights =\n    (List.range lights.length).foldl\n      (fun acc i =>\n        let rightmost := (lights.take (i+1)).foldl Nat.max 0\n        if i+1 = rightmost then acc + 1 else acc)\n      0 :=\nsorry\n\ntheorem invariants (lights : List Nat) (h : lights ≠ []) :\n  let valid := lights.filter (fun x => x ≤ lights.length)\n  let nodupes := remove_duplicates valid\n  let h2 := sorry\n  (nodupes.getLast h2 = nodupes.length → num_times_all_blue nodupes ≥ 1) ∧\n  num_times_all_blue nodupes ≤ nodupes.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_times_all_blue [2, 1, 3, 5, 4]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_times_all_blue [3, 2, 4, 1, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_times_all_blue [4, 1, 2, 3]"}
{"id": "fvapps_000275", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSideLength (mat: List (List Int)) (threshold: Int) : Int :=\n  sorry\n\ndef minElem (list: List Int) : Int :=\n  sorry\n\ndef sumList (list: List Int) : Int :=\n  sorry\n\ndef listSum (list: List Int) : Int :=\n  sorry\n\ndef floorSqrt (n: Int) : Int :=\n  sorry", "vc-theorems": "theorem maxSideLength_bounds {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length) :\n  let result := maxSideLength mat threshold\n  0 ≤ result ∧ result ≤ min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_low_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : threshold < minElem (mat.map minElem)) :\n  maxSideLength mat threshold = 0 :=\nsorry\n\ntheorem maxSideLength_high_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : threshold ≥ listSum (mat.map sumList)) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_zero_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : ∀ row ∈ mat, ∀ x ∈ row, x = 0)\n  (h3 : threshold ≥ 0) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_ones_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : ∀ row ∈ mat, ∀ x ∈ row, x = 1) :\n  maxSideLength mat threshold ≤ floorSqrt threshold :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2]] 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSideLength [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]] 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]] 6"}
{"id": "fvapps_000276", "vc-description": "", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\nsorry\n\ndef minimum (l : List Int) : Int :=\nsorry\n\ndef smallest_distance_pair : List Int → Nat → Int :=\nsorry", "vc-theorems": "theorem smallest_distance_pair_properties {nums : List Int} {k : Nat}\n    (h1 : nums.length ≥ 2)\n    (h2 : k ≥ 1)\n    (h3 : k ≤ (nums.length * (nums.length - 1)) / 2)\n    (h4 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :\n    let result := smallest_distance_pair nums k;\n    result ≥ 0 ∧\n    result ≤ maximum nums - minimum nums :=\nsorry\n\ntheorem identical_elements {n : List Int} (h : n.length ≥ 2) :\n  smallest_distance_pair (List.replicate n.length (n.get! 0)) 1 = 0 :=\nsorry\n\ntheorem sorted_input_equivalence {nums : List Int} (h : nums.length ≥ 2) :\n  smallest_distance_pair nums 1 = smallest_distance_pair (nums.reverse.reverse) 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 1, 3] 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 3, 1] 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 6, 1] 3"}
{"id": "fvapps_000286", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def least_interval (tasks : List Char) (n : Nat) : Nat :=\n  sorry\n\ndef countFrequencies (tasks : List Char) : List Nat :=\n  sorry\n\ndef maxFrequency (tasks : List Char) : Nat :=\n  sorry\n\ndef maxFrequencyCount (tasks : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem least_interval_zero_cooldown (tasks : List Char) (h : tasks ≠ []) :\n  least_interval tasks 0 = tasks.length :=\nsorry\n\ntheorem least_interval_basic_properties (tasks : List Char) (n : Nat) (h : tasks ≠ []) :\n  let result := least_interval tasks n\n  let max_freq := maxFrequency tasks\n  let max_freq_count := maxFrequencyCount tasks\n  let min_possible := (max_freq - 1) * (n + 1) + max_freq_count\n  result ≥ tasks.length ∧ result ≥ min_possible :=\nsorry\n\ntheorem least_interval_upper_bound (tasks : List Char) (n : Nat) (h : tasks ≠ []) :\n  least_interval tasks n ≤ tasks.length * (n + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"] 2\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\"] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"B\", \"C\", \"D\"] 0"}
{"id": "fvapps_000294", "vc-description": "", "vc-preamble": "def List.min_length (a b : List α) : Nat :=\n  min a.length b.length\n\ndef List.everyOther : List α → List α\n  | [] => []\n  | [x] => [x]\n  | x :: _ :: xs => x :: everyOther xs", "vc-helpers": "", "vc-definitions": "def max_uncrossed_lines (a b : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_uncrossed_lines_nonnegative (a b : List Nat) :\n  max_uncrossed_lines a b ≥ 0 :=\nsorry\n\ntheorem max_uncrossed_lines_upper_bound (a b : List Nat) :\n  max_uncrossed_lines a b ≤ min a.length b.length :=\nsorry\n\ntheorem max_uncrossed_lines_empty (a b : List Nat) :\n  a = [] ∨ b = [] → max_uncrossed_lines a b = 0 :=\nsorry\n\ntheorem max_uncrossed_lines_identical (a : List Nat) :\n  max_uncrossed_lines a a = a.length :=\nsorry\n\ntheorem max_uncrossed_lines_reverse (a b : List Nat) :\n  max_uncrossed_lines a b = max_uncrossed_lines a.reverse b.reverse :=\nsorry\n\ntheorem max_uncrossed_lines_edge_cases :\n  max_uncrossed_lines [] [] = 0 ∧\n  max_uncrossed_lines [1] [] = 0 ∧\n  max_uncrossed_lines [] [1] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 4, 2] [1, 2, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [2, 5, 1, 2, 5] [10, 5, 2, 1, 5, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 3, 7, 1, 7, 5] [1, 9, 2, 5, 1]"}
{"id": "fvapps_000296", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_sum_after_partitioning (arr : List Int) (k : Nat) : Int :=\nsorry\n\ndef sum (l : List Int) : Int :=\nsorry\n\ndef max (l : List Int) : Int :=\nsorry\n\ndef len (l : List Int) : Nat :=\nsorry", "vc-theorems": "theorem result_bounds {arr : List Int} {k : Nat}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0)\n  (h3 : k > 0)\n  (h4 : k ≤ 100) :\n  sum arr ≤ max_sum_after_partitioning arr k ∧\n  max_sum_after_partitioning arr k ≤ len arr * max arr :=\nsorry\n\ntheorem k_equals_one {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0) :\n  max_sum_after_partitioning arr 1 = sum arr :=\nsorry\n\ntheorem k_equals_length {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0) :\n  max_sum_after_partitioning arr arr.length = len arr * max arr :=\nsorry\n\ntheorem single_element {arr : List Int} {k : Nat}\n  (h1 : arr.length = 1)\n  (h2 : k > 0) :\n  max_sum_after_partitioning arr k = arr[0] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 84\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 15, 7, 9, 2, 5, 10] 3\n\n/-\ninfo: 83\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 4, 1, 5, 7, 3, 6, 1, 9, 9, 3] 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1] 1"}
{"id": "fvapps_000301", "vc-description": "", "vc-preamble": "def countMaxOccurrences (arr : List Int) : Nat :=\n  let counts := arr.map (λ x => arr.count x)\n  counts.foldl Nat.max 0", "vc-helpers": "", "vc-definitions": "def longestArithSeqLength (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem min_length_at_least_two {arr : List Int} (h : arr.length ≥ 1) :\n  longestArithSeqLength arr ≥ 2 :=\nsorry\n\ntheorem dupes_counted_properly {arr : List Int} (h : arr.length ≥ 2) :\n  longestArithSeqLength arr ≥ countMaxOccurrences arr :=\nsorry\n\ntheorem arithmetic_sequence_preserved {arr : List Int} (h₁ : arr.length ≥ 3) (h₂ : arr.length ≤ 10) :\n  let diff := arr[1]! - arr[0]!\n  let arithSeq := (List.range arr.length).map (λ i => arr[0]! + diff * (Int.ofNat i))\n  longestArithSeqLength arithSeq = arithSeq.length :=\nsorry\n\ntheorem reverse_same_result {arr : List Int} (h : arr.length ≥ 2) :\n  longestArithSeqLength arr = longestArithSeqLength arr.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [3, 6, 9, 12]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval longestArithSeqLength [9, 4, 7, 2, 10]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [20, 1, 15, 3, 10, 5, 8]"}
{"id": "fvapps_000302", "vc-description": "/- Function that returns the largest number not exceeding n whose digits are monotone increasing -/\n\n/- Helper function to compare Options -/\n\n/- For any number n, its monotone increasing digits result will have digits in non-decreasing order\n    and will not exceed the original number n -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- For any number n, its monotone increasing digits result is maximal - incrementing any digit\n    would either make it exceed n or break the monotone increasing property -/\n\n/- Single digit numbers remain unchanged when applying monotone increasing digits -/\n\n/- Numbers that are already monotone increasing remain unchanged -/", "vc-preamble": "def optionLE (a b : Option Nat) : Prop :=\n  match a, b with\n  | some x, some y => x ≤ y\n  | none, _ => True\n  | _, none => False", "vc-helpers": "", "vc-definitions": "def getDigits (n : Nat) : List Nat :=\nsorry\n\ndef monotoneIncreasingDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_is_monotone_increasing (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  (∀ i j : Nat, i < j → j < digits.length → optionLE (digits[i]?) (digits[j]?)) ∧\n  result ≤ n :=\nsorry\n\ntheorem largest_possible_result (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  ∀ i : Nat, i < digits.length →\n    let digit := digits[i]?\n    match digit with\n    | none => True\n    | some d => d = 9 ∨\n      (let incrementedDigits := digits.set i (d + 1)\n       let incrementedNum := incrementedDigits.foldl (fun acc d => acc * 10 + d) 0\n       incrementedNum > n ∨\n       ¬(∀ j k : Nat, j < k → k < incrementedDigits.length →\n           optionLE (incrementedDigits[j]?) (incrementedDigits[k]?))) :=\nsorry\n\ntheorem single_digit_unchanged (n : Nat) :\n  n < 10 → monotoneIncreasingDigits n = n :=\nsorry\n\ntheorem already_monotone_unchanged (n : Nat) :\n  let digits := getDigits n\n  (∀ i j : Nat, i < j → j < digits.length → optionLE (digits[i]?) (digits[j]?)) →\n  monotoneIncreasingDigits n = n :=\nsorry", "vc-postamble": "/-\ninfo: 9\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 10\n\n/-\ninfo: 1234\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 1234\n\n/-\ninfo: 299\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 332"}
{"id": "fvapps_000304", "vc-description": "", "vc-preamble": "def sumList (l : List Int) : Int :=\n  l.foldl (· + ·) 0\n\ndef toNat (i : Int) : Nat :=\n  if i ≤ 0 then 0 else i.natAbs", "vc-helpers": "", "vc-definitions": "def shortestSubarray (arr : List Int) (k : Int) : Int :=\n  sorry", "vc-theorems": "theorem impossible_cases (k : Int) :\n  shortestSubarray [] k = -1 ∧\n  shortestSubarray [0] k = -1 ∧\n  shortestSubarray [0,0] k = -1 :=\nsorry\n\ntheorem positive_only (arr : List Int) (k : Int) (h1 : ∀ x ∈ arr, 0 < x) (h2 : 0 < k) :\n  let result := shortestSubarray arr k\n  if result = -1 then\n    ∀ start len : Nat, start + len ≤ arr.length →\n      sumList ((arr.take (start + len)).drop start) < k\n  else\n    (∃ start : Nat, start + (toNat result) ≤ arr.length ∧\n      sumList ((arr.take (start + (toNat result))).drop start) ≥ k) ∧\n    (∀ len : Nat, len < (toNat result) → ∀ start : Nat, start + len ≤ arr.length →\n      sumList ((arr.take (start + len)).drop start) < k) :=\nsorry\n\ntheorem result_bounds (arr : List Int) (k : Int) (h1 : 0 < k) (h2 : ¬arr.isEmpty) :\n  let result := shortestSubarray arr k\n  if result = -1 then True\n  else 1 ≤ result ∧ result ≤ arr.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortestSubarray [1] 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval shortestSubarray [1, 2] 4\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval shortestSubarray [2, -1, 2] 3"}
{"id": "fvapps_000310", "vc-description": "", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def maxSizeSlices (slices: List Nat) : Nat :=\nsorry\n\ndef maxList : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (maxList xs)\n\ndef sortList : List Nat → List Nat :=\nsorry", "vc-theorems": "theorem max_size_bounds {slices : List Nat}\n  (h1: slices.length ≥ 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  let result := maxSizeSlices slices\n  result > 0 ∧\n  result ≤ sumList slices ∧\n  result ≥ maxList slices :=\nsorry\n\ntheorem max_size_elements {slices : List Nat}\n  (h1: slices.length ≥ 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  let n := slices.length\n  maxSizeSlices slices ≤ sumList (List.take (n/3) (sortList slices)) :=\nsorry\n\ntheorem min_case_three {slices : List Nat}\n  (h1: slices.length = 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  maxSizeSlices slices = maxList slices :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSizeSlices [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval maxSizeSlices [8, 9, 8, 6, 1, 1]\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval maxSizeSlices [4, 1, 2, 5, 8, 3, 1, 9, 7]"}
{"id": "fvapps_000312", "vc-description": "", "vc-preamble": "def maxList : List Nat → Nat\n  | [] => 0\n  | (x::xs) => max x (maxList xs)", "vc-helpers": "", "vc-definitions": "def minOperations (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem minOperations_nonnegative (nums : List Nat) :\n  minOperations nums ≥ 0 :=\nsorry\n\ntheorem minOperations_at_least_nonzero_count (nums : List Nat) :\n  minOperations nums ≥ (nums.filter (λ x => x > 0)).length :=\nsorry\n\ntheorem minOperations_at_least_max_bits (nums : List Nat) :\n  nums.length > 0 → nums ≠ [] →\n  minOperations nums ≥ (String.length (toString (maxList nums))).pred :=\nsorry\n\ntheorem minOperations_all_zeros (nums : List Nat) :\n  (∀ x ∈ nums, x = 0) → minOperations nums = 0 :=\nsorry\n\ntheorem minOperations_nonzero_lower_bound (nums : List Nat) :\n  (∀ x ∈ nums, x > 0) → minOperations nums ≥ nums.length :=\nsorry\n\ntheorem minOperations_powers_two_bound (nums : List Nat) (max : Nat) :\n  nums.length > 0 →\n  (∀ x ∈ nums, ∃ n, x = 2^n) →\n  max = maxList nums →\n  minOperations nums ≤ (String.length (toString max)) + nums.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval minOperations [1, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval minOperations [2, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval minOperations [4, 2, 5]"}
{"id": "fvapps_000313", "vc-description": "/- If two strings are compared with checkIfCanBreak, they must have same length -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A string can always break itself -/\n\n/- The break relationship is symmetric -/\n\n/- A sorted string can always break its unsorted version -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkIfCanBreak (s1 s2 : String) : Bool :=\n  sorry", "vc-theorems": "theorem check_if_can_break_same_length (s1 s2 : String) :\n  checkIfCanBreak s1 s2 → String.length s1 = String.length s2 :=\nsorry\n\ntheorem check_if_can_break_reflexive (s : String) :\n  checkIfCanBreak s s = true :=\nsorry\n\ntheorem check_if_can_break_symmetric (s1 s2 : String) :\n  checkIfCanBreak s1 s2 = checkIfCanBreak s2 s1 :=\nsorry\n\ntheorem sorted_string_breaks_unsorted (s sorted : String)\n  (h : ∀ i j : String.Pos, i < j → sorted.get i ≤ sorted.get j)\n  (h2 : sorted.length = s.length)\n  (h3 : ∀ c, c ∈ sorted.data ↔ c ∈ s.data) :\n  checkIfCanBreak sorted s = true :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"abc\" \"xya\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_if_can_break \"abe\" \"acd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"leetcodee\" \"interview\""}
{"id": "fvapps_000314", "vc-description": "-- Define sorted property\n\n-- All results are natural numbers and input list remains sorted\n\n-- Empty list produces positive result\n\n-- Result is non-negative for small n\n\n-- Specific cases", "vc-preamble": "def isSorted (as : List Nat) : Prop :=\n  ∀ i j, i < j → j < as.length → as[i]! ≤ as[j]!", "vc-helpers": "", "vc-definitions": "def min_patches (nums : List Nat) (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_patches_basic_properties {nums : List Nat} {n : Nat}\n  (h : isSorted nums) :\n  let result := min_patches nums n\n  Nat.zero ≤ result ∧ isSorted nums := by\n  sorry\n\ntheorem min_patches_empty_list {n : Nat} :\n  let result := min_patches [] n\n  0 < result := by\n  sorry\n\ntheorem min_patches_small_n {nums : List Nat} (n : Nat)\n  (h₁ : isSorted nums)\n  (h₂ : nums ≠ [])\n  (h₃ : ∀ x ∈ nums, n < x) :\n  0 ≤ min_patches nums n := by\n  sorry\n\ntheorem min_patches_minimal_cases_1 :\n  min_patches [1] 1 = 0 := by\n  sorry\n\ntheorem min_patches_minimal_cases_2 :\n  min_patches [2] 1 = 1 := by\n  sorry\n\ntheorem min_patches_minimal_cases_3 :\n  min_patches [1,2] 2 = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_patches [1, 3] 6\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_patches [1, 5, 10] 20\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_patches [1, 2, 2] 5"}
{"id": "fvapps_000316", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxDistance (grid : List (List Int)) : Int :=\n  sorry\n\ndef rotateGrid (grid : List (List Int)) : List (List Int) :=\n  sorry", "vc-theorems": "theorem maxDistance_bounds (grid : List (List Int)) :\n  let result := maxDistance grid\n  result ≥ -1 ∧ (result ≠ -1 → result ≤ 2 * grid.length) :=\nsorry\n\ntheorem maxDistance_all_water (grid : List (List Int)) :\n  (∀ row ∈ grid, ∀ cell ∈ row, cell = 0) →\n  maxDistance grid = -1 :=\nsorry\n\ntheorem maxDistance_all_land (grid : List (List Int)) :\n  (∀ row ∈ grid, ∀ cell ∈ row, cell = 1) →\n  maxDistance grid = -1 :=\nsorry\n\ntheorem maxDistance_rotation {grid : List (List Int)} :\n  maxDistance grid = maxDistance (rotateGrid grid) :=\nsorry\n\ntheorem maxDistance_edge_cases :\n  maxDistance [[1]] = -1 ∧\n  maxDistance [[0]] = -1 ∧\n  maxDistance [[1,0],[0,0]] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maxDistance [[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}
{"id": "fvapps_000319", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find132pattern (nums : List Int) : Bool :=\n  sorry\n\ndef has_132_pattern_brute_force (nums : List Int) : Bool :=\n  sorry\n\ndef isSorted (nums : List Int) (cmp : Int → Int → Bool) : Bool :=\n  sorry", "vc-theorems": "theorem find132pattern_matches_bruteforce {nums : List Int} :\n  find132pattern nums = has_132_pattern_brute_force nums :=\nsorry\n\ntheorem short_sequences_return_false {nums : List Int} :\n  List.length nums ≤ 2 → find132pattern nums = false :=\nsorry\n\ntheorem monotonic_increasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x ≤ y) → find132pattern nums = false :=\nsorry\n\ntheorem monotonic_decreasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x ≥ y) → find132pattern nums = false :=\nsorry\n\ntheorem same_elements_no_pattern {nums : List Int} {x : Int} :\n  nums.length ≥ 3 → nums = List.replicate nums.length x → find132pattern nums = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval find132pattern [1, 2, 3, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [3, 1, 4, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [-1, 3, 2, 0]"}
{"id": "fvapps_000321", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def isWhitespace (c : Char) : Bool := c = ' ' || c = '\\t' || c = '\\n' || c = '\\r'", "vc-helpers": "", "vc-definitions": "def is_numeric (s : String) : Bool :=\nsorry\n\ndef isInteger (s : String) : Bool :=\nsorry\n\ndef isDecimal (s : String) : Bool :=\nsorry", "vc-theorems": "theorem integer_pattern (s : String)\n  (h : isInteger s) :\n  is_numeric s = true :=\nsorry\n\ntheorem decimal_pattern (s : String)\n  (h : isDecimal s) :\n  is_numeric s = true :=\nsorry\n\ntheorem invalid_chars (s : String)\n  (h₁ : s.length > 0)\n  (h₂ : ∀ c ∈ s.data, c ∈ ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n                           'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n                           'x', 'y', 'z', 'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I',\n                           'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n                           'U', 'V', 'W', 'X', 'Y', 'Z', '!', '@', '#', '$', '%',\n                           '^', '&', '*', '(', ')', '_', '{', '}', '[', ']', ';',\n                           ':', '<', '>', '?'])\n  (h₃ : ∀ c ∈ s.data, c ≠ 'e' ∧ c ≠ 'E') :\n  is_numeric s = false :=\nsorry\n\ntheorem whitespace_handling (s : String) (ws : String)\n  (h₁ : ∀ c ∈ ws.data, isWhitespace c)\n  (h₂ : isInteger s ∨ isDecimal s)\n  (h₃ : s.trim ≠ \"\") :\n  is_numeric (ws ++ s ++ ws) = is_numeric s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000323", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_palindromic_substrings (s: String) : Nat :=\n  sorry\n\ndef is_palindrome (s : String) : Bool :=\n  sorry\n\ndef string_reverse (s : String) : String :=\n  sorry\n\ndef string_repeat (c : Char) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem minimum_palindromes (s : String) (h : s.length > 0) :\n  count_palindromic_substrings s ≥ s.length :=\nsorry\n\ntheorem empty_string :\n  count_palindromic_substrings \"\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"abc\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"aaa\"\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"racecar\""}
{"id": "fvapps_000331", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simplify_path (s : String) : String :=\nsorry\n\ndef is_valid_path_segment (s : String) : Bool :=\nsorry\n\ndef splitString (s : String) (c : Char) : List String :=\nsorry", "vc-theorems": "theorem dot_references_resolve\n  {segments : List String}\n  (valid_segs : ∀ s ∈ segments, s = \".\" ∨ s = \"..\" ∨ is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let result := simplify_path path\n  result.startsWith \"/\" ∧ \".\" ∉ splitString result '/'\n  :=\nsorry\n\ntheorem redundant_slashes\n  (slashes : String)\n  (h : ∀ c ∈ slashes.toList, c = '/') :\n  simplify_path slashes = \"/\"\n  :=\nsorry\n\ntheorem idempotent\n  {segments : List String}\n  (valid_segs : ∀ s ∈ segments, is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let once := simplify_path path\n  simplify_path once = once\n  :=\nsorry\n\ntheorem root_path :\n  simplify_path \"/\" = \"/\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '/home'\n-/\n#guard_msgs in\n#eval simplify_path \"/home/\"\n\n/-\ninfo: '/c'\n-/\n#guard_msgs in\n#eval simplify_path \"/a/./b/../../c/\"\n\n/-\ninfo: '/home/foo'\n-/\n#guard_msgs in\n#eval simplify_path \"/home//foo/\""}
{"id": "fvapps_000338", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def contains_permutation (s1 s2 : String) : Bool :=\n  sorry\n\ndef IsPermutation (s1 s2 : String) : Prop :=\n  sorry", "vc-theorems": "theorem contains_permutation_empty_string {s : String} :\n  contains_permutation \"\" s = true :=\nsorry\n\ntheorem contains_permutation_shorter_string {s1 s2 : String} :\n  s2.length < s1.length → contains_permutation s1 s2 = false :=\nsorry\n\ntheorem contains_permutation_self {s : String} :\n  contains_permutation s s = true :=\nsorry\n\ntheorem contains_permutation_concat {s : String} :\n  contains_permutation s (s ++ s) = true :=\nsorry\n\ntheorem contains_permutation_permutation_invariant {s1 s2 s1_perm : String} :\n  IsPermutation s1 s1_perm →\n  contains_permutation s1 s2 = contains_permutation s1_perm s2 :=\nsorry\n\ntheorem contains_permutation_single_char {c : Char} {s : String} :\n  contains_permutation (String.mk [c]) s = String.contains s c :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidbaooo\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidboaoo\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"hello\" \"ooolleoabceh\""}
{"id": "fvapps_000339", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_sum_with_deletion (arr : List Int) : Int :=\n  sorry\n\ndef list_maximum (arr : List Int) : Int :=\n  sorry\n\ndef list_sum (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem positive_scaling {arr : List Int} {scale : Int}\n  (h : arr ≠ []) (hs : scale > 0) :\n  maximum_sum_with_deletion (List.map (· * scale) arr) =\n  maximum_sum_with_deletion arr * scale :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, 0, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, -2, 3]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [-1, -1, -1, -1]"}
{"id": "fvapps_000356", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unique_letter_string (s : String) : Nat :=\nsorry\n\ndef string_reverse (s : String) : String :=\nsorry\n\ndef string_append_char (s : String) (c : Char) : String :=\nsorry", "vc-theorems": "theorem unique_letter_string_positive (s : String) (h : s.length > 0) :\n  unique_letter_string s > 0 :=\nsorry\n\ntheorem unique_letter_string_reverse_invariant (s : String) (h : s.length > 0) :\n  unique_letter_string s = unique_letter_string (string_reverse s) :=\nsorry\n\ntheorem unique_letter_string_monotone (s : String) (h : s.length > 0)\n  (h1 : 0 < s.length) :\n  unique_letter_string (string_append_char s (s.get 0)) > unique_letter_string s :=\nsorry\n\ntheorem unique_letter_string_bounded (s : String) (h : s.length > 0) :\n  unique_letter_string s < 1000000007 :=\nsorry\n\ntheorem unique_letter_string_single_char (s : String) (h : s.length = 1) :\n  unique_letter_string s = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABC\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABA\"\n\n/-\ninfo: 92\n-/\n#guard_msgs in\n#eval unique_letter_string \"LEETCODE\""}
{"id": "fvapps_000362", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numBusesToDestination (routes: List (List Nat)) (source: Nat) (target: Nat) : Int :=\n  sorry\n\ndef findMaxInList (l: List Nat) : Nat :=\n  sorry\n\ndef findMaxInRoutes (routes: List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem impossible_path_property\n  (routes: List (List Nat))\n  (h: routes ≠ [])\n  (h2: ∀ r ∈ routes, r ≠ []) :\n  let maxStop := findMaxInRoutes routes\n  numBusesToDestination routes 0 (maxStop + 1) = -1 :=\nsorry\n\ntheorem result_range_property\n  (routes: List (List Nat))\n  (h: routes ≠ [])\n  (h2: ∀ r ∈ routes, r ≠ [])\n  (start: Nat)\n  (route: List Nat)\n  (routeEnd: Nat)\n  (h3: route ∈ routes)\n  (h4: routeEnd ∈ route) :\n  numBusesToDestination routes start routeEnd ≥ -1 :=\nsorry\n\ntheorem empty_routes_property\n  (routes: List (List Nat))\n  (h: routes = [] ∨ routes = [[]]) :\n  numBusesToDestination routes 1 2 = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 7], [3, 6, 7]] 1 6\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 3], [3, 4, 5]] 1 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2], [2, 3], [3, 4]] 1 4"}
{"id": "fvapps_000364", "vc-description": "", "vc-preamble": "def lastElem (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => lastElem xs", "vc-helpers": "", "vc-definitions": "def max_profit (k : Nat) (prices : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_price_zero_profit (k : Nat) (p : Nat) :\n  max_profit k [p] = 0 := sorry\n\nprivate def pairwise_profits (prices : List Nat) : Nat :=\n  sorry\n\nprivate def isSorted (l : List Nat) : Prop :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_profit 2 [2, 4, 1]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_profit 2 [3, 2, 6, 5, 0, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_profit 1 [1, 2, 3, 4]"}
{"id": "fvapps_000366", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_gap (nums : List Nat) : Nat :=\n  sorry\n\ndef Permutation (l1 l2 : List α) : Prop :=\n  sorry\n\ndef sort (l : List α) (lt : α → α → Bool) : List α :=\n  sorry", "vc-theorems": "theorem maximum_gap_empty_or_singleton {nums : List Nat} :\n  nums.length ≤ 1 → maximum_gap nums = 0 :=\nsorry\n\ntheorem maximum_gap_nonnegative {nums : List Nat} :\n  maximum_gap nums ≥ 0 :=\nsorry\n\ntheorem maximum_gap_bounded {nums : List Nat} :\n  nums.length > 0 →\n  maximum_gap nums ≤ List.foldl Nat.max 0 nums - List.foldl Nat.min 0 nums :=\nsorry\n\ntheorem maximum_gap_is_max_consecutive_diff {nums : List Nat} (h : nums.length > 1) :\n  let sorted := sort nums (fun x y => x < y)\n  let gaps := List.zipWith (fun x y => y - x) sorted (List.drop 1 sorted)\n  maximum_gap nums = List.foldl Nat.max 0 gaps :=\nsorry\n\ntheorem maximum_gap_permutation_invariant {nums₁ nums₂ : List Nat} :\n  nums₁.length > 1 →\n  Permutation nums₁ nums₂ →\n  maximum_gap nums₁ = maximum_gap nums₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [3, 6, 9, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maximum_gap [10]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [1, 2, 2, 5, 7, 10]"}
{"id": "fvapps_000370", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSum (nums1 : List Nat) (nums2 : List Nat) : Nat :=\n  sorry\n\ndef hasCommonElements (l1 l2 : List Nat) : List Nat :=\n  sorry\n\ndef sumUniqueElements (l1 l2 : List Nat) : Nat :=\n  sorry\n\ndef sumCommonElements (l1 l2 : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxsum_positive (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  maxSum nums1 nums2 ≥ 0 :=\nsorry\n\ntheorem maxsum_under_modulo (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  maxSum nums1 nums2 < 10^9 + 7 :=\nsorry\n\ntheorem maxsum_lower_bound (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let common := sumCommonElements nums1 nums2\n  let unique1 := sumUniqueElements nums1 nums2\n  let unique2 := sumUniqueElements nums2 nums1\n  maxSum nums1 nums2 ≥ min (unique1 + common) (unique2 + common) % (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval maxSum [2, 4, 5, 8, 10] [4, 6, 8, 9]\n\n/-\ninfo: 109\n-/\n#guard_msgs in\n#eval maxSum [1, 3, 5, 7, 9] [3, 5, 100]\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval maxSum [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]"}
{"id": "fvapps_000372", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_subarray_len (target : Nat) (nums : List Nat) : Nat :=\nsorry\n\ndef sum_list (l : List Nat) : Nat :=\nsorry\n\ndef slice (l : List Nat) (start : Nat) (len : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_subarray_len_empty {target : Nat} :\n  min_subarray_len target [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subarray_len 7 [2, 3, 1, 2, 4, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 5 []\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 10 [1, 1, 1]"}
{"id": "fvapps_000374", "vc-description": "/- Helper function to get spread after removing a node -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_malware_spread (graph : List (List Int)) (initial : List Int) : Int :=\nsorry\n\ndef get_spread (graph : List (List Int)) (initial : List Int) (removed : Int) : Int :=\nsorry", "vc-theorems": "theorem result_in_initial {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  initial.contains result = true :=\nsorry\n\ntheorem smallest_among_equal_spreads {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  ∀ node : Int,\n    node ∈ initial →\n    node < result →\n    get_spread graph initial node ≥ get_spread graph initial result :=\nsorry\n\ntheorem valid_graph_properties {graph : List (List Int)} :\n  let n := graph.length\n  graph.length > 0 →\n  (∀ row ∈ graph, row.length = n) →\n  (∀ (i j : Nat), i < n → j < n →\n    (graph.get! i).get! j = (graph.get! i).get! j) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 0], [0, 0, 1]] [0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 1], [0, 1, 1]] [0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]] [0, 1]"}
{"id": "fvapps_000379", "vc-description": "", "vc-preamble": "def sum_list (l : List Int) : Int :=\nl.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def split_array_same_average (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem split_array_verification {arr : List Int}\n  (h : split_array_same_average arr = true)\n  (h1 : arr.length ≥ 2)\n  (h2 : ∀ x ∈ arr, x ≥ 0 ∧ x ≤ 100) :\n  ∃ (subset1 subset2 : List Int),\n    subset1 ≠ [] ∧\n    subset2 ≠ [] ∧\n    (∀ x, x ∈ subset1 ∨ x ∈ subset2 ↔ x ∈ arr) ∧\n    (sum_list subset1) * subset2.length = (sum_list subset2) * subset1.length :=\nsorry\n\ntheorem single_element_false {x : Int} (h : x ≥ 1 ∧ x ≤ 10) :\n  split_array_same_average [x] = false :=\nsorry\n\ntheorem identical_elements_splittable {x : Int} {n : Nat}\n  (h : n ≥ 2) :\n  split_array_same_average (List.replicate n x) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [3, 1, 2]"}
{"id": "fvapps_000381", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getMaxRepetitions (s1: String) (n1: Nat) (s2: String) (n2: Nat) : Nat :=\n  sorry\n\ndef is_subsequence (s1 s2: String) : Bool :=\n  sorry", "vc-theorems": "theorem result_non_negative (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 ≥ 0 :=\nsorry\n\ntheorem result_positive_implies_common_chars (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 > 0 → ∃ c, c ∈ s2.data ∧ c ∈ s1.data :=\nsorry\n\ntheorem monotonic_in_n1 (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 (n1 + 1) s2 n2 ≥ getMaxRepetitions s1 n1 s2 n2 :=\nsorry\n\ntheorem monotonic_in_s1_length (s1: String) (n1: Nat) (s2: String) (n2: Nat)\n  (h1: s1.length > 0) (h2: s2.length > 0) :\n  getMaxRepetitions (s1 ++ s1) n1 s2 n2 ≥ getMaxRepetitions s1 n1 s2 n2 :=\nsorry\n\ntheorem same_string_division (s: String) :\n  getMaxRepetitions s 3 s 2 = 3 / 2 :=\nsorry\n\ntheorem impossible_match (s1: String) (n1: Nat) :\n  (∀ c, c ∈ s1.data → c ≠ 'c') →\n  getMaxRepetitions s1 n1 \"c\" 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"acb\" 4 \"ab\" 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"aaa\" 3 \"aa\" 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"baba\" 2 \"ba\" 1"}
{"id": "fvapps_000382", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef count_char (s : String) (c : Char) : Nat :=\n  sorry\n\ndef numWays (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem numWays_non_negative (s : String) :\n  numWays s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numWays \"10101\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval numWays \"1001\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numWays \"0000\""}
{"id": "fvapps_000383", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nth_ugly_number (n a b c : Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef count_divisible (num a b c : Nat) : Nat :=\nsorry", "vc-theorems": "theorem ugly_number_divisible (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  let result := find_nth_ugly_number n a b c\n  result % a = 0 ∨ result % b = 0 ∨ result % c = 0 :=\nsorry\n\ntheorem ugly_number_positive (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c > 0 :=\nsorry\n\ntheorem ugly_number_min_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c ≥ min a (min b c) :=\nsorry\n\ntheorem ugly_number_max_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c ≤ n * min a (min b c) :=\nsorry\n\ntheorem ugly_number_equal_divisors (a : Nat) (h : a > 0) :\n  find_nth_ugly_number 1 a a a = a :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 3 2 3 5\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 4 2 3 4\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 5 2 11 13"}
{"id": "fvapps_000384", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_to_equal (nums : List Int) : Nat :=\n  sorry\n\ndef abs (x : Int) : Nat :=\n  sorry\n\ndef sort (nums : List Int) : List Int :=\n  sorry\n\ndef median (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (nums : List Int) :\n  0 ≤ min_moves_to_equal nums :=\nsorry\n\ntheorem min_moves_equal_median (nums : List Int) (h : nums ≠ []) :\n  min_moves_to_equal nums = nums.foldl (fun acc x => acc + abs (x - median nums)) 0 :=\nsorry\n\ntheorem identical_nums_zero_moves (n : Int) (nums : List Int) (h : ∀ x ∈ nums, x = n) :\n  min_moves_to_equal nums = 0 :=\nsorry\n\ntheorem order_invariant (nums : List Int) :\n  min_moves_to_equal nums = min_moves_to_equal (sort nums) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 1, 1]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 10, 2, 9]"}
{"id": "fvapps_000386", "vc-description": "/- For any natural number k, smallest_repunit_div_by_k(k) is either -1 or between 1 and k inclusive -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Certain numbers like 2,4,5,6,8,10 should return -1 as no repunit divides them -/\n\n/- If the result is not -1, then the repunit number of that length should be divisible by k -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def smallest_repunit_div_by_k (k : Nat) : Int :=\nsorry", "vc-theorems": "theorem output_range (k : Nat) :\n  let result := smallest_repunit_div_by_k k\n  result = -1 ∨ (1 ≤ result ∧ result ≤ k) :=\nsorry\n\ntheorem invalid_inputs :\n  smallest_repunit_div_by_k 2 = -1 ∧\n  smallest_repunit_div_by_k 4 = -1 ∧\n  smallest_repunit_div_by_k 5 = -1 ∧\n  smallest_repunit_div_by_k 6 = -1 ∧\n  smallest_repunit_div_by_k 8 = -1 ∧\n  smallest_repunit_div_by_k 10 = -1 :=\nsorry\n\ntheorem result_divisibility (k : Nat) (result : Int) :\n  smallest_repunit_div_by_k k = result →\n  result ≠ -1 →\n  ∃ repunit : Nat, repunit % k = 0 :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 3"}
{"id": "fvapps_000389", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_encoding (s : String) : Bool :=\n  sorry\n\ndef count_decodings (s : String) : Nat :=\n  sorry\n\ndef num_decodings (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_strings (s : String) :\n  is_valid_encoding s → num_decodings s = count_decodings s :=\nsorry\n\ntheorem invalid_strings (s : String) :\n  ¬is_valid_encoding s → num_decodings s = 0 :=\nsorry\n\ntheorem empty_string :\n  num_decodings \"\" = 0 :=\nsorry\n\ntheorem starting_zero (s : String) :\n  s.length > 0 → s.front = '0' → num_decodings s = 0 :=\nsorry\n\ntheorem short_valid_numbers (s : String) :\n  is_valid_encoding s → s.length ≤ 6 → num_decodings s = count_decodings s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_decodings \"12\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_decodings \"226\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval num_decodings \"06\""}
{"id": "fvapps_000390", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest_rectangle_area (heights : List Nat) : Nat :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listModify (l : List Nat) (i : Nat) (f : Nat → Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem largest_rectangle_area_non_negative (heights : List Nat) :\n  0 ≤ largest_rectangle_area heights :=\nsorry\n\ntheorem largest_rectangle_area_upper_bound (heights : List Nat) :\n  heights ≠ [] →\n  largest_rectangle_area heights ≤ (List.length heights) * (listMaximum heights) :=\nsorry\n\ntheorem largest_rectangle_area_at_least_max_height (heights : List Nat) :\n  heights ≠ [] →\n  largest_rectangle_area heights ≥ listMaximum heights :=\nsorry\n\ntheorem largest_rectangle_area_empty (heights : List Nat) :\n  heights = [] →\n  largest_rectangle_area heights = 0 :=\nsorry\n\ntheorem largest_rectangle_area_tall_column (heights : List Nat) :\n  heights ≠ [] →\n  let tall_height := (listMaximum heights) + 1\n  let new_heights := heights ++ [tall_height]\n  largest_rectangle_area new_heights ≥ tall_height :=\nsorry\n\ntheorem largest_rectangle_area_monotonic (heights : List Nat) (i : Nat) :\n  i < List.length heights →\n  let increased := listModify heights i (· + 1)\n  largest_rectangle_area increased ≥ largest_rectangle_area heights :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 5, 6, 2, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_rectangle_area []"}
{"id": "fvapps_000391", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSumDivThree (nums: List Nat) : Nat :=\n  sorry\n\ndef sum (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxSumDivThree_divisible_by_3 (nums: List Nat) :\n  maxSumDivThree nums % 3 = 0 :=\nsorry\n\ntheorem maxSumDivThree_bounded (nums: List Nat) :\n  maxSumDivThree nums ≤ sum nums :=\nsorry\n\ntheorem maxSumDivThree_nonnegative (nums: List Nat) :\n  maxSumDivThree nums ≥ 0 :=\nsorry\n\ntheorem maxSumDivThree_all_divisible (nums: List Nat)\n  (h: ∀ n ∈ nums, n % 3 = 0) :\n  maxSumDivThree nums = sum nums :=\nsorry\n\ntheorem maxSumDivThree_none_divisible (nums: List Nat)\n  (h1: nums ≠ [])\n  (h2: ∀ n ∈ nums, n % 3 ≠ 0) :\n  maxSumDivThree nums ≤ sum nums ∧\n  maxSumDivThree nums % 3 = 0 :=\nsorry\n\ntheorem maxSumDivThree_monotonic (nums: List Nat) :\n  maxSumDivThree nums ≤ maxSumDivThree (nums ++ [3]) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval maxSumDivThree [3, 6, 5, 1, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSumDivThree [4]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval maxSumDivThree [1, 2, 3, 4, 4]"}
{"id": "fvapps_000394", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def listMin (xs : List Int) : Float :=\n  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl min h t)\n\ndef listMax (xs : List Int) : Float :=\n  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl max h t)\n\ndef listSum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => h + listSum t", "vc-helpers": "", "vc-definitions": "def array_stats (numbers: List Int) : Float × Float × Float × Float :=\n  sorry\n\ndef sorted (xs : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem array_stats_empty :\n  array_stats [] = (0, 0, 0, 0) :=\nsorry\n\ntheorem array_stats_mean (numbers: List Int) (h: numbers ≠ []) :\n  let (mean, _, _, _) := array_stats numbers\n  (mean - Float.ofInt (listSum numbers) / Float.ofInt numbers.length).abs < 1e-10 :=\nsorry\n\ntheorem array_stats_minmax (numbers: List Int) (h: numbers ≠ []) :\n  let (_, _, min_val, max_val) := array_stats numbers\n  min_val = listMin numbers ∧\n  max_val = listMax numbers :=\nsorry\n\ntheorem array_stats_ordering (numbers: List Int) (h: numbers ≠ []) :\n  let (mean, median, min_val, max_val) := array_stats numbers\n  min_val ≤ median ∧ median ≤ max_val ∧\n  min_val ≤ mean ∧ mean ≤ max_val :=\nsorry\n\ntheorem array_stats_median_even (numbers: List Int) (h: numbers ≠ [])\n  (h2: numbers.length % 2 = 0) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt ((List.get! s ((numbers.length)/2 - 1)) + (List.get! s (numbers.length/2)))/2).abs < 1e-10 :=\nsorry\n\ntheorem array_stats_median_odd (numbers: List Int) (h: numbers ≠ [])\n  (h2: numbers.length % 2 = 1) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt (List.get! s (numbers.length/2))).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000398", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_best_value (arr : List Nat) (target : Nat) : Nat :=\n  sorry\n\ndef sum_capped_vals (arr : List Nat) (cap : Nat) : Nat :=\n  sorry\n\ndef list_maximum (arr : List Nat) (h : arr ≠ []) : Nat :=\n  sorry\n\ndef abs (n : Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_best_value_bounds {arr : List Nat} {target : Nat} (h : arr ≠ []) :\n  let result := find_best_value arr target\n  0 ≤ result ∧ result ≤ list_maximum arr h :=\nsorry\n\ntheorem find_best_value_minimizes {arr : List Nat} {target : Nat} (h : arr ≠ []) :\n  let result := find_best_value arr target\n  let curr_diff := abs (sum_capped_vals arr result - target)\n  let less := max 0 (result - 1)\n  let more := min (list_maximum arr h) (result + 1)\n  curr_diff ≤ abs (sum_capped_vals arr less - target) ∧\n  curr_diff ≤ abs (sum_capped_vals arr more - target) :=\nsorry\n\ntheorem find_best_value_target_one {arr : List Nat} (h : arr ≠ []) :\n  let result := find_best_value arr 1\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_best_value [4, 9, 3] 10\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_best_value [2, 3, 5] 10\n\n/-\ninfo: 11361\n-/\n#guard_msgs in\n#eval find_best_value [60864, 25176, 27249, 21296, 20204] 56803"}
{"id": "fvapps_000400", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_power (x : Int) : Int :=\n  sorry\n\ndef getKth (lo hi k : Int) : Int :=\n  sorry", "vc-theorems": "theorem get_power_always_terminates (x : Int)\n  (h : x ≥ 1) :\n  get_power x ≥ 0 :=\nsorry\n\ntheorem getKth_input_validation (lo hi k : Int)\n  (h1 : lo ≥ 1)\n  (h2 : hi ≥ 1)\n  (h3 : lo ≤ hi)\n  (h4 : k ≥ 1)\n  (h5 : k ≤ hi - lo + 1) :\n  lo ≤ getKth lo hi k ∧ getKth lo hi k ≤ hi :=\nsorry\n\ntheorem getKth_sorting_property (lo hi : Int)\n  (h1 : lo ≥ 1)\n  (h2 : hi ≥ 1)\n  (h3 : lo ≤ hi)\n  (k1 k2 : Int)\n  (h4 : k1 ≥ 1)\n  (h5 : k2 ≥ 1)\n  (h6 : k1 ≤ hi - lo + 1)\n  (h7 : k2 ≤ hi - lo + 1)\n  (h8 : k1 < k2) :\n  get_power (getKth lo hi k1) < get_power (getKth lo hi k2) ∨\n  (get_power (getKth lo hi k1) = get_power (getKth lo hi k2) ∧\n   getKth lo hi k1 ≤ getKth lo hi k2) :=\nsorry\n\ntheorem getKth_single_element (x : Int)\n  (h : x ≥ 1) :\n  getKth x x 1 = x :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval getKth 12 15 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval getKth 7 11 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval getKth 1 1 1"}
{"id": "fvapps_000402", "vc-description": "", "vc-preamble": "def M := 1000000007", "vc-helpers": "", "vc-definitions": "def numRollsToTarget (d f t : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem impossible_target (d f t : Nat) :\n  (t < d ∨ t > d*f) → numRollsToTarget d f t = 0 :=\nsorry\n\ntheorem single_die_possible (f t : Nat) :\n  1 ≤ t ∧ t ≤ f → numRollsToTarget 1 f t = 1 :=\nsorry\n\ntheorem single_die_impossible (f t : Nat) :\n  (t < 1 ∨ t > f) → numRollsToTarget 1 f t = 0 :=\nsorry\n\ntheorem above_max_target (d f : Nat) :\n  numRollsToTarget d f (d*f+1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 1 6 3\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 6 7\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 5 10"}
{"id": "fvapps_000403", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def break_palindrome (s : String) : String :=\nsorry\n\ndef is_palindrome (s : String) : Bool :=\nsorry\n\ndef strRepeat (c : Char) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem single_char_palindrome (n : Nat) (h : n = 1) :\n  break_palindrome (strRepeat 'a' n) = \"\" :=\nsorry\n\ntheorem all_a_string_breaks_to_b (s : String) (h₁ : s.length ≥ 2) (h₂ : ∀ c ∈ s.data, c = 'a') :\n  break_palindrome s = (s.dropRight 1).push 'b' :=\nsorry\n\ntheorem break_gives_different_string (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  break_palindrome s ≠ s :=\nsorry\n\ntheorem break_gives_non_palindrome (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  is_palindrome (break_palindrome s) = false :=\nsorry\n\ntheorem break_preserves_length (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  (break_palindrome s).length = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'aaccba'\n-/\n#guard_msgs in\n#eval break_palindrome \"abccba\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval break_palindrome \"a\"\n\n/-\ninfo: 'ab'\n-/\n#guard_msgs in\n#eval break_palindrome \"aa\""}
{"id": "fvapps_000404", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_winner (arr : List Int) (k : Int) : Int :=\n  sorry\n\ndef List.maximum (l : List Int) : Int :=\n  sorry\n\ndef List.maximum' (l : List Int) (h : l ≠ []) : Int :=\n  sorry\n\ndef List.findIndex (l : List Int) (p : Int → Bool) : Nat :=\n  sorry\n\ndef List.sorted (l : List Int) (r : Int → Int → Bool) : Prop :=\n  sorry", "vc-theorems": "theorem winner_exists_in_array (arr : List Int) (h : arr ≠ []) :\n  ∀ k, k > 0 → get_winner arr k ∈ arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval get_winner [2, 1, 3, 5, 4, 6, 7] 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_winner [3, 2, 1] 10\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval get_winner [1, 9, 8, 2, 3, 7, 6, 4, 5] 7"}
{"id": "fvapps_000406", "vc-description": "/- For a valid graph input, the output is either 0, 1 or 2 -/\n\n/- The cat-mouse game output range theorem only applies to valid graphs -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A graph is valid if:\n1. It is non-empty\n2. Each node's neighbors are valid indices into the graph -/", "vc-preamble": "def IsValidGraph (graph : List (List Nat)) : Prop :=\n  graph ≠ [] ∧\n  ∀ neighbors ∈ graph, ∀ x ∈ neighbors, x < graph.length", "vc-helpers": "", "vc-definitions": "def CatMouseGame (graph : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem cat_mouse_game_output_range (graph : List (List Nat)) :\n  CatMouseGame graph = 0 ∨ CatMouseGame graph = 1 ∨ CatMouseGame graph = 2 :=\nsorry\n\ntheorem cat_mouse_game_output_range_valid (graph : List (List Nat)) :\n  IsValidGraph graph →\n  CatMouseGame graph = 0 ∨ CatMouseGame graph = 1 ∨ CatMouseGame graph = 2 :=\nsorry", "vc-postamble": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3], [], []]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval cat_mouse_game [[1, 3], [0], [3], [0, 2]]"}
{"id": "fvapps_000407", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findMedianSortedArrays (nums1 : List Int) (nums2 : List Int) : Float :=\n  sorry\n\ndef getMedian (l : List Int) : Float :=\n  sorry\n\ndef mergeSorted (l1 l2 : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem findMedianSortedArrays_correct (nums1 nums2 : List Int)\n  (h : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = getMedian (mergeSorted nums1 nums2) := by\n  sorry\n\ntheorem findMedianSortedArrays_symmetric (nums1 nums2 : List Int)\n  (h : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = findMedianSortedArrays nums2 nums1 := by\n  sorry\n\ntheorem findMedianSortedArrays_bounded (nums1 nums2 : List Int)\n  (h1 : ∀ x ∈ nums1, -1000 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, -1000 ≤ x ∧ x ≤ 1000)\n  (h3 : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  -1000 ≤ findMedianSortedArrays nums1 nums2 ∧\n  findMedianSortedArrays nums1 nums2 ≤ 1000 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 3] #[2]\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 2] #[3, 4]\n\n/-\ninfo: 3.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1] #[2, 3, 4, 5]"}
{"id": "fvapps_000410", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countVowels (s : String) : List Char → Bool :=\n  sorry\n\ndef verifySubstringVowels (s : String) (start length : Nat) : Bool :=\n  sorry\n\ndef findLongestEvenVowelSubstring (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_is_valid_length (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  0 ≤ result ∧ result ≤ s.length :=\nsorry\n\ntheorem result_has_even_vowels (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  result > 0 →\n  ∃ i : Nat, i + result ≤ s.length ∧ verifySubstringVowels s i result :=\nsorry\n\ntheorem no_longer_valid_substring_exists (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  ∀ length : Nat, result < length → length ≤ s.length →\n  ∀ i : Nat, i + length ≤ s.length →\n  ¬(verifySubstringVowels s i length) :=\nsorry\n\ntheorem edge_cases_empty :\n  findLongestEvenVowelSubstring \"\" = 0 :=\nsorry\n\ntheorem edge_cases_single_nonvowel (c : Char) (h : c ∉ ['a', 'e', 'i', 'o', 'u']) :\n  findLongestEvenVowelSubstring (String.mk [c]) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"eleetminicoworoep\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"leetcodeisgreat\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"bcbcbc\""}
{"id": "fvapps_000412", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isPalindrome (s : String) : Bool :=\nsorry\n\ndef find_longest_palindrome (s : String) : String :=\nsorry\n\ndef String.isSubstringOf (sub str : String) : Bool :=\nsorry\n\ndef String.substring (str : String) (start len : Nat) : String :=\nsorry", "vc-theorems": "theorem find_longest_palindrome_is_substring (s : String) :\n  (find_longest_palindrome s).isSubstringOf s = true :=\nsorry\n\ntheorem find_longest_palindrome_is_palindrome (s : String) :\n  (find_longest_palindrome s).isPalindrome = true :=\nsorry\n\ntheorem find_longest_palindrome_length (s : String) :\n  (find_longest_palindrome s).length ≥ min 1 s.length :=\nsorry\n\ntheorem find_longest_palindrome_maximal (s : String) (start len : Nat) :\n  let substr := String.substring s start len\n  substr.isPalindrome = true → (find_longest_palindrome s).length ≥ substr.length :=\nsorry\n\ntheorem nonempty_input_nonempty_output (s : String) (h : s.length > 0) :\n  (find_longest_palindrome s).length > 0 :=\nsorry\n\ntheorem palindrome_input_returns_itself (s : String) (h : s.isPalindrome = true) :\n  find_longest_palindrome s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"cbbd\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"a\""}
{"id": "fvapps_000413", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_arithmetic_subsequence (arr: List Int) (diff: Int) : Nat :=\n  sorry\n\ndef countOccurrences (xs : List Int) (x : Int) : Nat :=\n  sorry\n\ndef maxOccurrences (xs : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem las_length_bounded {arr: List Int} {diff: Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr diff ≤ arr.length :=\nsorry\n\ntheorem las_non_negative {arr: List Int} {diff: Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr diff ≥ 0 :=\nsorry\n\ntheorem las_zero_diff {arr: List Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr 0 = maxOccurrences arr :=\nsorry\n\ntheorem las_reverse_symmetry {arr: List Int} {diff: Int} :\n  arr ≠ [] → diff > 0 →\n    longest_arithmetic_subsequence arr diff =\n    longest_arithmetic_subsequence arr.reverse (-diff) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 2, 3, 4] 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 3, 5, 7] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 5, 7, 8, 5, 3, 4, 2, 1] -2"}
{"id": "fvapps_000416", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reordered_power_of_2 (n : Nat) : Bool :=\nsorry\n\ndef get_powers_of_2 (max_digits : Nat) : List Nat :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef sorted_digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem power_2_permutations_property {n : Nat} (h : reordered_power_of_2 n = true) :\n  ∃ p, (p = 2^(Nat.log2 p)) ∧ sorted_digits n = sorted_digits p :=\nsorry\n\ntheorem single_digit_property {n : Nat} (h : List.length (digits n) = 1) :\n  reordered_power_of_2 n = (n = 1 ∨ n = 2 ∨ n = 4 ∨ n = 8) :=\nsorry\n\ntheorem leading_zeros_property {n : Nat} (h : n < 10) :\n  reordered_power_of_2 n = reordered_power_of_2 (10 * n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval reordered_power_of_2 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 16"}
{"id": "fvapps_000421", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_subarray_mins (nums : List Nat) : Nat :=\n  sorry\n\ndef list_min (l : List Nat) : Nat :=\n  sorry\n\ndef list_max (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sum_subarray_mins_non_negative (nums : List Nat) :\n  sum_subarray_mins nums ≥ 0 :=\nsorry\n\ntheorem sum_subarray_mins_modulo_bound (nums : List Nat) :\n  sum_subarray_mins nums < 10^9 + 7 :=\nsorry\n\ntheorem sum_subarray_mins_singleton (n : Nat) :\n  sum_subarray_mins [n] = n :=\nsorry\n\ntheorem sum_subarray_mins_min_bound {nums : List Nat} (h : nums.length ≥ 2) :\n  sum_subarray_mins nums ≥ list_min nums :=\nsorry\n\ntheorem sum_subarray_mins_append_larger {nums : List Nat} (h : nums.length ≥ 2) :\n  let max := list_max nums\n  sum_subarray_mins (nums ++ [max + 1]) % (10^9 + 7) ≥ sum_subarray_mins nums % (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 17\n-/\n#guard_msgs in\n#eval sum_subarray_mins [3, 1, 2, 4]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_subarray_mins [1]\n\n/-\ninfo: 444\n-/\n#guard_msgs in\n#eval sum_subarray_mins [11, 81, 94, 43, 3]"}
{"id": "fvapps_000431", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def consecutive_numbers_sum (n : Nat) : Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\ndef isSquare (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem result_always_positive (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n ≥ 1 :=\nsorry\n\ntheorem result_less_than_input (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n ≤ n :=\nsorry\n\ntheorem known_edge_cases :\n  consecutive_numbers_sum 1 = 1 ∧\n  consecutive_numbers_sum 2 = 1 ∧\n  consecutive_numbers_sum 3 = 2 ∧\n  consecutive_numbers_sum 4 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 9\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 15"}
{"id": "fvapps_000439", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findMin (arr : List Int) : Int :=\n  sorry\n\ndef rotateList (xs : List Int) (n : Nat) : List Int :=\n  sorry\n\ndef listMin (xs : List Int) : Int :=\n  sorry", "vc-theorems": "theorem findMin_singleton (n : Int) :\n  findMin [n] = n :=\nsorry\n\ntheorem findMin_pair (a b : Int) :\n  findMin [a, b] = min a b :=\nsorry\n\ntheorem findMin_triple (a b c : Int) :\n  findMin [a, b, c] = min (min a b) c :=\nsorry\n\ntheorem findMin_rotated_sorted_unique {nums : List Int} (h1 : nums.length ≥ 4)\n    (h2 : List.Pairwise (· ≠ ·) nums) (h3 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :\n  findMin (rotateList nums (nums.length / 2)) = listMin nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [3, 4, 5, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval findMin [4, 5, 6, 7, 0, 1, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [1, 2, 3, 4, 5]"}
{"id": "fvapps_000440", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isContinuationByte (x : Nat) : Bool :=\n  sorry\n\ndef countRequiredBytes (firstByte : Nat) : Int :=\n  sorry\n\ndef validUtf8 (data : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem valid_utf8_property (data : List Nat) (h : ∀ x ∈ data, x ≤ 255) :\n  validUtf8 data = true →\n  ∃ i : Nat,\n    i < data.length ∧\n    let required := countRequiredBytes (data.get ⟨i, sorry⟩)\n    required ≥ 0 ∧\n    i + required < data.length ∧\n    ∀ j, i + 1 ≤ j ∧ j ≤ i + required →\n      isContinuationByte (data.get ⟨j, sorry⟩) = true :=\nsorry\n\ntheorem valid_utf8_property_contra (data : List Nat) (h : ∀ x ∈ data, x ≤ 255) :\n  validUtf8 data = false →\n  ∃ i : Nat,\n    i < data.length ∧\n    (countRequiredBytes (data.get ⟨i, sorry⟩) < 0 ∨\n     i + countRequiredBytes (data.get ⟨i, sorry⟩) ≥ data.length ∨\n     ∃ j, i + 1 ≤ j ∧ j ≤ i + countRequiredBytes (data.get ⟨i, sorry⟩) ∧\n       isContinuationByte (data.get ⟨j, sorry⟩) = false) :=\nsorry\n\ntheorem ascii_always_valid (data : List Nat) (h : ∀ x ∈ data, x ≤ 127) :\n  validUtf8 data = true :=\nsorry\n\ntheorem continuation_bytes_invalid (data : List Nat) (h1 : data ≠ [])\n    (h2 : ∀ x ∈ data, x ≥ 128 ∧ x ≤ 191) :\n  validUtf8 data = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [197, 130, 1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_utf8 [235, 140, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [240, 162, 138, 147]"}
{"id": "fvapps_000442", "vc-description": "", "vc-preamble": "def list_maximum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| [x] => x\n| x::xs => max x (list_maximum xs)\n\ndef list_sum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def min_difficulty (difficulties: List Nat) (days: Nat) : Int :=\nsorry\n\ndef list_sort (l: List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_difficulty_invalid_days {difficulties : List Nat} {days : Nat} :\n  days > difficulties.length → min_difficulty difficulties days = -1\n  :=\nsorry\n\ntheorem min_difficulty_lb_max {difficulties : List Nat} {days : Nat} :\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties days ≥ list_maximum difficulties\n  :=\nsorry\n\ntheorem min_difficulty_lb_sum_min {difficulties : List Nat} {days : Nat} :\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties days ≥ list_sum (List.take days (list_sort difficulties))\n  :=\nsorry\n\ntheorem min_difficulty_single_day {difficulties : List Nat} :\n  difficulties.length > 0 →\n  min_difficulty difficulties 1 = list_maximum difficulties\n  :=\nsorry\n\ntheorem min_difficulty_monotonic {difficulties : List Nat} {days : Nat} :\n  days > 1 →\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties (days-1) ≥ 0 →\n  min_difficulty difficulties days ≥ min_difficulty difficulties (days-1)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_difficulty [6, 5, 4, 3, 2, 1] 2\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_difficulty [9, 9, 9] 4\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difficulty [1, 1, 1] 3"}
{"id": "fvapps_000444", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_swap (n : Nat) : Nat :=\nsorry\n\ndef countDigit (d n : Nat) : Nat :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem maximum_swap_result_ge (n : Nat) :\n  maximum_swap n ≥ n :=\nsorry\n\ntheorem maximum_swap_edge_cases :\n  maximum_swap 0 = 0 ∧\n  maximum_swap 1 = 1 ∧\n  maximum_swap 10 = 10 ∧\n  maximum_swap 99 = 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7236\n-/\n#guard_msgs in\n#eval maximum_swap 2736\n\n/-\ninfo: 9973\n-/\n#guard_msgs in\n#eval maximum_swap 9973\n\n/-\ninfo: 9913\n-/\n#guard_msgs in\n#eval maximum_swap 1993"}
{"id": "fvapps_000445", "vc-description": "", "vc-preamble": "def isValidGrid (grid: Grid) : Bool :=\n  match grid with\n  | [] => false\n  | row::rows =>\n    match row with\n    | [] => false\n    | _::_ =>\n      let width := row.length\n      rows.all (λ r => r.length = width)", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef isPrintable (grid: Grid) : Bool :=\n  sorry", "vc-theorems": "theorem grid_validity {grid: Grid} (h: isValidGrid grid) :\n  ∃ (row: List Nat) (rows: List (List Nat)), grid = row::rows :=\nsorry\n\ntheorem printable_returns_bool (grid: Grid) :\n  isPrintable grid = true ∨ isPrintable grid = false :=\nsorry\n\ntheorem single_color_printable {grid: Grid} (h1: isValidGrid grid)\n  (h2: ∀ (i j: Nat) (hi: i < grid.length) (hj: j < (grid.get ⟨i, hi⟩).length),\n    (grid.get ⟨i, hi⟩).get ⟨j, hj⟩ = 1) :\n  isPrintable grid = true :=\nsorry\n\ntheorem symmetric_grid_printable_rotation {grid: Grid} {n: Nat}\n  (h1: isValidGrid grid)\n  (h2: grid.length = n)\n  (h3: ∀ (i: Nat) (hi: i < grid.length),\n    (grid.get ⟨i, hi⟩).length = n) :\n  isPrintable grid = isPrintable (List.map List.reverse grid).reverse :=\nsorry\n\ntheorem known_cases :\n  (isPrintable [[1,1], [1,1]] = true) ∧\n  (isPrintable [[1]] = true) ∧\n  (isPrintable [[1,2], [2,1]] = false) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 1, 3, 3], [1, 1, 3, 4], [5, 5, 1, 4]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isPrintable [[1, 2, 1], [2, 1, 2], [1, 2, 1]]"}
{"id": "fvapps_000452", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countServers (grid : List (List Nat)) : Nat :=\nsorry\n\ndef is_valid_grid (grid : List (List Nat)) : Bool :=\nsorry\n\ndef count_ones (grid : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem countServers_non_negative (grid : List (List Nat)) :\n  is_valid_grid grid → countServers grid ≥ 0 :=\nsorry\n\ntheorem countServers_upper_bound (grid : List (List Nat)) :\n  is_valid_grid grid → countServers grid ≤ count_ones grid :=\nsorry\n\ntheorem single_server_result (grid : List (List Nat)) :\n  is_valid_grid grid → count_ones grid = 1 → countServers grid = 0 :=\nsorry\n\ntheorem empty_grid_zero {m n : Nat} (grid : List (List Nat)) :\n  m > 0 → n > 0 →\n  grid = List.replicate m (List.replicate n 0) →\n  countServers grid = 0 :=\nsorry\n\ntheorem full_grid_count {n : Nat} (grid : List (List Nat)) :\n  n ≥ 2 →\n  grid = List.replicate n (List.replicate n 1) →\n  countServers grid = n * n :=\nsorry\n\ntheorem diagonal_only_zero {n : Nat} (grid : List (List Nat)) :\n  n ≥ 2 →\n  grid = List.map\n    (fun i => List.map (fun j => if i = j then 1 else 0) (List.range n))\n    (List.range n) →\n  countServers grid = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [0, 1]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [1, 1]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval countServers [[1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1]]"}
{"id": "fvapps_000453", "vc-description": "", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef diffSum (nums : List Int) : Int :=\n  match nums with\n  | [] => 0\n  | [_] => 0\n  | x :: xs => List.foldl (fun acc (pair : Int × Int) => acc + abs (pair.1 - pair.2)) 0 (List.zip (x::xs) xs)", "vc-helpers": "", "vc-definitions": "def maxValueAfterReverse (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem maxValueAfterReverse_nonnegative (nums : List Int) :\n  maxValueAfterReverse nums ≥ 0 :=\nsorry\n\ntheorem maxValueAfterReverse_geq_base (nums : List Int) :\n  maxValueAfterReverse nums ≥ diffSum nums :=\nsorry\n\ntheorem maxValueAfterReverse_small_lists {nums : List Int} (h : nums.length ≤ 2) :\n  match nums with\n  | [] => maxValueAfterReverse nums = 0\n  | [_] => maxValueAfterReverse nums = 0\n  | [x, y] => maxValueAfterReverse nums = abs (x - y)\n  | _ => True\n  :=\nsorry\n\ntheorem maxValueAfterReverse_monotonic_defined (nums : List Int) (h : nums.length ≥ 3) :\n  ∃ (n n' : Int), maxValueAfterReverse nums = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 3, 1, 5, 4]\n\n/-\ninfo: 68\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 4, 9, 24, 2, 1, 10]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [1, 2, 3, 4, 5]"}
{"id": "fvapps_000465", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def range_sum (nums : List Nat) (n : Nat) (left right : Nat) : Nat :=\n  sorry\n\ndef partialSums (nums : List Nat) (n : Nat) : List Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem range_sum_output_properties {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 1000)\n  (h4 : left ≥ 1 ∧ right ≥ 1)\n  (h5 : left ≤ 20 ∧ right ≤ 20) :\n  let result := range_sum nums n left right\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem range_sum_monotonic {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : left < right)\n  (h4 : right ≤ n) :\n  range_sum nums n left (right-1) ≤ range_sum nums n left right :=\nsorry\n\ntheorem range_sum_single_element {nums : List Nat} {n k : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : k ≤ n)\n  (h4 : k > 0) :\n  let pSums := partialSums nums n\n  ∀ h : k - 1 < pSums.length,\n  range_sum nums n k k = pSums.get ⟨k-1, h⟩ :=\nsorry\n\ntheorem range_sum_full_range {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 100) :\n  range_sum nums n 1 (n * (n+1) / 2) > 0 :=\nsorry\n\ntheorem range_sum_first_element {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty) :\n  range_sum nums n 1 1 = listMin nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 5\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 3 4\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 10"}
{"id": "fvapps_000474", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def primePalindrome (n : Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem primePalindrome_geq_input\n  (n : Nat)\n  (h1 : n ≥ 2)\n  (h2 : n ≤ 19990) :\n  primePalindrome n ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval primePalindrome 6\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval primePalindrome 8\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval primePalindrome 13"}
{"id": "fvapps_000476", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin (n : Nat) : String :=\nsorry\n\ndef query_string (s : String) (n : Nat) : Bool :=\nsorry\n\ndef containsSubstring (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem query_string_with_all_prefixes (n : Nat) (h : 0 < n ∧ n ≤ 20) :\n  let binary_nums := String.join (List.map bin (List.range n))\n  query_string binary_nums n = true\n  :=\nsorry\n\ntheorem query_string_correct (s : String) (n : Nat) (h : 0 < n ∧ n ≤ 20) :\n  query_string s n = true ↔\n    ∀ i : Nat, 1 ≤ i ∧ i ≤ n → containsSubstring s (bin i)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"0110\" 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval query_string \"0110\" 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"11011\" 2"}
{"id": "fvapps_000477", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def kth_smallest_in_sorted_matrix (matrix : List (List Int)) (k : Nat) : Int :=\nsorry\n\ndef is_sorted (row : List Int) : Bool :=\nsorry\n\ndef is_matrix_sorted (matrix : List (List Int)) : Bool :=\nsorry", "vc-theorems": "theorem empty_rows_handled_raises\n  (matrix : List (List Int))\n  (h1 : matrix = [] ∨ ¬∃row ∈ matrix, row ≠ []) :\n  ∀k, k ≠ 0 → kth_smallest_in_sorted_matrix matrix k = default :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15]] 8\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 2], [3, 4]] 3\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15], [], []] 8"}
{"id": "fvapps_000478", "vc-description": "", "vc-preamble": "def isSorted (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)\n\ndef isStrictlyDecreasing (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x > y && isStrictlyDecreasing (y::rest)\n\ndef hasNoDups (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | x::xs => !(xs.contains x) && hasNoDups xs", "vc-helpers": "", "vc-definitions": "def max_width_ramp (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem max_width_ramp_non_negative (nums : List Int) :\n  max_width_ramp nums ≥ 0 :=\nsorry\n\ntheorem max_width_ramp_upper_bound (nums : List Int) :\n  max_width_ramp nums ≤ max 0 (nums.length - 1) :=\nsorry\n\ntheorem max_width_ramp_small_lists (nums : List Int) :\n  nums.length ≤ 1 → max_width_ramp nums = 0 :=\nsorry\n\ntheorem max_width_ramp_valid_ramp_exists (nums : List Int) (h : max_width_ramp nums > 0) :\n  ∃ i j, ∃ (hi : i < nums.length) (hj : j < nums.length),\n         i < j ∧ j - i ≥ max_width_ramp nums ∧\n         (nums.get ⟨i, hi⟩) ≤ (nums.get ⟨j, hj⟩) :=\nsorry\n\ntheorem max_width_ramp_monotonic_increasing (nums : List Int) :\n  nums.length > 1 →\n  isSorted nums = true →\n  max_width_ramp nums = nums.length - 1 :=\nsorry\n\ntheorem max_width_ramp_strictly_decreasing (nums : List Int) :\n  nums.length > 0 →\n  isStrictlyDecreasing nums = true →\n  hasNoDups nums = true →\n  max_width_ramp nums = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_width_ramp [6, 0, 8, 2, 1, 5]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_width_ramp [9, 8, 1, 0, 1, 9, 4, 0, 4, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_width_ramp [1, 0]"}
{"id": "fvapps_000481", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "def is_valid_string (s : String) (a_count b_count : Nat) : Prop :=\n  count_char s 'a' = a_count ∧\n  count_char s 'b' = b_count ∧\n  ¬contains_substring \"aaa\" s ∧\n  ¬contains_substring \"bbb\" s", "vc-helpers": "", "vc-definitions": "def strWithout3a3b (a b : Nat) : String :=\n  sorry\n\ndef count_char (s : String) (c : Char) : Nat :=\n  sorry\n\ndef contains_substring (s main : String) : Bool :=\n  sorry", "vc-theorems": "theorem equal_counts {n : Nat} (h : n > 0) :\n  let s := strWithout3a3b n n\n  is_valid_string s n n ∧ s.length = 2 * n\n  :=\nsorry\n\ntheorem double_a_count {n : Nat} :\n  let s := strWithout3a3b (2 * n) n\n  is_valid_string s (2 * n) n ∧ s.length = 3 * n\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000483", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestDecomposition (s : String) : Nat :=\n  sorry\n\ndef isReversed (s : String) : Bool :=\n  sorry\n\ndef allCharsSame (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem decomposition_length {s : String} (h : s ≠ \"\") :\n  1 ≤ longestDecomposition s ∧ longestDecomposition s ≤ s.length :=\nsorry\n\ntheorem concatenated_decomposition {s : String} (h : s ≠ \"\") :\n  longestDecomposition (s ++ s) ≥ 2 * longestDecomposition s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval longestDecomposition \"ghiabcdefhelloadamhelloabcdefghi\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longestDecomposition \"merchant\"\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval longestDecomposition \"antaprezatepzapreanta\""}
{"id": "fvapps_000484", "vc-description": "", "vc-preamble": "def sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def lastStoneWeightII (stones : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem lastStoneWeight_nonNegative (stones : List Nat) :\n  lastStoneWeightII stones ≥ 0 :=\nsorry\n\ntheorem lastStoneWeight_upperBound (stones : List Nat) :\n  lastStoneWeightII stones ≤ sum stones :=\nsorry\n\ntheorem lastStoneWeight_identical_pairs (stones : List Nat) :\n  stones.length = 2 → stones[0]! = stones[1]! → lastStoneWeightII stones = 0 :=\nsorry\n\ntheorem lastStoneWeight_single_stone (stones : List Nat) (x : Nat) :\n  stones = [x] → lastStoneWeightII stones = x :=\nsorry\n\ntheorem lastStoneWeight_identical_values (stones : List Nat) (x : Nat) :\n  (∀ i, i < stones.length → stones[i]! = x) → lastStoneWeightII stones ≤ x :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 7, 4, 1, 8, 1]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval lastStoneWeightII [1, 1, 1]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 2]"}
{"id": "fvapps_000485", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_increment_for_unique (nums : List Int) : Nat :=\n  sorry\n\ndef sorted (l : List Int) : List Int :=\n  sorry\n\ndef makeUnique (nums : List Int) : List Int :=\n  sorry\n\ndef sumList (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_increment_nonneg (nums : List Int) :\n  min_increment_for_unique nums ≥ 0 :=\nsorry\n\ntheorem min_increment_empty (nums : List Int) :\n  nums = [] → min_increment_for_unique nums = 0 :=\nsorry\n\ntheorem min_increment_single (nums : List Int) (x : Int) :\n  nums = [x] → min_increment_for_unique nums = 0 :=\nsorry\n\ntheorem min_increment_sort_invariant (nums : List Int) :\n  min_increment_for_unique nums = min_increment_for_unique (sorted nums) :=\nsorry\n\ntheorem min_increment_makes_unique (nums : List Int) :\n  let result := sorted nums\n  let incremented := makeUnique result\n  min_increment_for_unique nums = (sumList incremented - sumList result) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_increment_for_unique [1, 2, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_increment_for_unique [3, 2, 1, 2, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_increment_for_unique []"}
{"id": "fvapps_000490", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortest_palindrome (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef stringReverse (s : String) : String :=\nsorry", "vc-theorems": "theorem shortest_palindrome_contains_original (s : String) :\n  (shortest_palindrome s).endsWith s :=\nsorry\n\ntheorem shortest_palindrome_is_palindrome (s : String) :\n  isPalindrome (shortest_palindrome s) = true :=\nsorry\n\ntheorem shortest_palindrome_minimal_length (s : String) :\n  (shortest_palindrome s).length ≤ 2 * s.length :=\nsorry\n\ntheorem shortest_palindrome_empty_single_char (s : String) :\n  s = \"\" ∨ s.length = 1 → shortest_palindrome s = s :=\nsorry\n\ntheorem shortest_palindrome_starts_with_reversed_suffix (s : String) :\n  s ≠ \"\" →\n  let result := shortest_palindrome s\n  let suffixLen := result.length - s.length\n  suffixLen > 0 →\n  (result.take suffixLen) = stringReverse (s.takeRight suffixLen) :=\nsorry\n\ntheorem shortest_palindrome_single_char_string (s : String) (c : Char) :\n  s.all (· = c) → shortest_palindrome s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'aaacecaaa'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"aacecaaa\"\n\n/-\ninfo: 'dcbabcd'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"abcd\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"a\""}
{"id": "fvapps_000494", "vc-description": "-- Result has balanced parentheses\n\n-- Result is a subsequence of input\n\n-- Strings without parens are unchanged\n\n-- Empty string case\n\n-- Only open brackets become empty\n\n-- Only close brackets become empty\n\n-- All chars in result are valid", "vc-preamble": "inductive CharIn (s : String) where\n  | mk (c : Char) (h : s.data.contains c) : CharIn s", "vc-helpers": "", "vc-definitions": "def validParens (s : String) : Bool :=\nsorry\n\ndef isSubsequence (s1 s2 : String) : Bool :=\nsorry\n\ndef minRemoveToMakeValid (s : String) : String :=\nsorry", "vc-theorems": "theorem result_contains_valid_chars (s : String) :\n  ∀ c, (minRemoveToMakeValid s).data.contains c →\n    c = '(' ∨ c = ')' ∨ c = 'a' ∨ c = 'b' ∨ c = 'c' :=\nsorry\n\ntheorem result_has_balanced_parens (s : String) :\n  validParens (minRemoveToMakeValid s) :=\nsorry\n\ntheorem result_is_subsequence (s : String) :\n  isSubsequence (minRemoveToMakeValid s) s :=\nsorry\n\ntheorem no_parens_unchanged (s : String) :\n  (∀ c, s.data.contains c → c ≠ '(' ∧ c ≠ ')') →\n  minRemoveToMakeValid s = s :=\nsorry\n\ntheorem empty_string :\n  minRemoveToMakeValid \"\" = \"\" :=\nsorry\n\ntheorem only_open_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n '(')) = \"\" :=\nsorry\n\ntheorem only_close_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n ')')) = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'lee(t(c)o)de'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"lee(t(c)o)de)\"\n\n/-\ninfo: 'ab(c)d'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"a)b(c)d\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"))((\""}
{"id": "fvapps_000504", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef modular_pow (base exponent modulus : Nat) : Nat :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry\n\ndef find_max_totient_ratio (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_totient_ratio_small_values :\n  find_max_totient_ratio 2 = 2 ∧\n  find_max_totient_ratio 4 = 3 ∧\n  find_max_totient_ratio 10 = 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 4"}
{"id": "fvapps_000505", "vc-description": "", "vc-preamble": "def sorted (xs : List Nat) : Prop :=\n  ∀ i j, i < j → i < xs.length → j < xs.length →\n    xs[i]! ≤ xs[j]!", "vc-helpers": "", "vc-definitions": "def count_inversions (arr : List Nat) (n : Nat) (m : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_inversions_non_negative (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m ≥ 0 :=\nsorry\n\ntheorem count_inversions_sorted_zero (arr : List Nat) (n : Nat) (m : Nat) :\n  sorted arr → count_inversions arr n m = 0 :=\nsorry\n\ntheorem count_inversions_scale_invariant (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m = count_inversions (List.map (· * 2) arr) n m :=\nsorry\n\ntheorem count_inversions_monotone (arr : List Nat) (n : Nat) (m1 m2 : Nat) :\n  m1 ≤ m2 → count_inversions arr n m1 ≤ count_inversions arr n m2 :=\nsorry\n\ntheorem count_inversions_single_element (n m : Nat) (a : Nat) :\n  count_inversions [a] n m = 0 :=\nsorry\n\ntheorem count_inversions_same_elements (n m a : Nat) :\n  count_inversions [a,a,a] n m = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval count_inversions [2, 1, 3] 3 3\n\n/-\ninfo: 30000\n-/\n#guard_msgs in\n#eval count_inversions [99, 2, 1000, 24] 4 100"}
{"id": "fvapps_000513", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def perfect_square_range_query (arr : List Nat) (queries : List (Nat × Nat × Nat)) : List String :=\nsorry\n\ndef is_perfect_square (n : Nat) : Bool :=\nsorry\n\ndef product_range (arr : List Nat) (s e : Nat) : Nat :=\nsorry", "vc-theorems": "theorem query_response_format\n  (arr : List Nat) (queries : List (Nat × Nat × Nat)) :\n  let result := perfect_square_range_query arr queries\n  let type_1_count := (queries.filter (fun q => q.fst = 1)).length\n  result.length = type_1_count ∧\n  result.all (fun r => r = \"YES\" ∨ r = \"NO\") :=\nsorry\n\ntheorem array_update_consistency\n  (arr : List Nat) (queries : List (Nat × Nat × Nat)) (i : Nat) (h : i < queries.length) :\n  let result := perfect_square_range_query arr queries\n  let q := queries[i]'h\n  (q.fst = 1 →\n    let product := product_range arr (q.2.1 - 1) (q.2.2)\n    (result[i]? = some \"YES\") = is_perfect_square product) :=\nsorry\n\ntheorem single_element_range\n  (arr : List Nat) (i : Nat) (h : i < arr.length) :\n  let queries := List.range arr.length |>.map (fun i => (1, i+1, i+1))\n  let result := perfect_square_range_query arr queries\n  result[i]? = some (if is_perfect_square (arr[i]'h) then \"YES\" else \"NO\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000520", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_antimatching (n m : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef vertex_degree (v : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem antimatching_nonnegative (n m : Nat) (edges : List (Nat × Nat)) :\n  solve_antimatching n m edges ≥ 0 :=\nsorry\n\ntheorem antimatching_empty_graph (n : Nat) :\n  solve_antimatching n 0 [] = 0 :=\nsorry\n\ntheorem antimatching_single_vertex :\n  solve_antimatching 1 0 [] = 0 :=\nsorry\n\ntheorem antimatching_single_edge :\n  solve_antimatching 2 1 [(1,2)] = 1 :=\nsorry\n\ntheorem antimatching_triangle :\n  solve_antimatching 3 3 [(1,2), (2,3), (1,3)] = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_antimatching 3 3 [(1, 2), (1, 3), (2, 3)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_antimatching 4 2 [(1, 2), (3, 4)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_antimatching 5 0 []"}
{"id": "fvapps_000526", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_subset_with_mex (n m : Nat) (arr : List Nat) : Int :=\n  sorry\n\ndef mex (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_largest_subset_result_valid (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  result ≤ n :=\nsorry\n\ntheorem find_largest_subset_result_cases (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  (result = -1 ∨ result = n ∨ result = n - (List.count m arr)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 3 [1, 2, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 4 2 [1, 3, 4, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 5 [1, 2, 3]"}
{"id": "fvapps_000532", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_ball_bounces (n: Nat) : Nat :=\nsorry\n\ndef isPowerOfTwo (n: Nat) : Bool :=\nsorry\n\ndef allOnesInBinary (n: Nat) : Bool :=\nsorry\n\ndef countOnesInBinary (n: Nat) : Nat :=\nsorry", "vc-theorems": "theorem non_negative_result (distance : Nat) :\n  count_ball_bounces distance ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 13\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ball_bounces 16"}
{"id": "fvapps_000540", "vc-description": "", "vc-preamble": "def count_fibonacci_sequence (arr : List Int) : Nat :=\n  let rec helper (i : Nat) (curr_max curr_fib : Nat) : Nat :=\n    if i ≥ arr.length then curr_max\n    else match arr.get? i, arr.get? (i-1), arr.get? (i-2) with\n    | some x, some y, some z =>\n      if x = y + z then\n        helper (i+1) (max curr_max (curr_fib + 1)) (curr_fib + 1)\n      else\n        helper (i+1) curr_max 2\n    | _, _, _ => curr_max\n  termination_by arr.length - i\n  helper 2 2 2", "vc-helpers": "", "vc-definitions": "def find_max_sequence_length (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_sequence_length_empty :\n  find_max_sequence_length 0 [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 5 [2, 3, 5, 1, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 3 [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_sequence_length 2 [1, 2]"}
{"id": "fvapps_000541", "vc-description": "", "vc-preamble": "def manhattan_distance (x y : Int) : Nat :=\n  Int.natAbs x + Int.natAbs y", "vc-helpers": "", "vc-definitions": "def find_robot_position (t : Nat) : Int × Int :=\n  sorry", "vc-theorems": "theorem coordinates_are_integers (t : Nat) (h : t > 0) :\n  let (x, y) := find_robot_position t\n  True :=\nsorry\n\ntheorem position_uniqueness (t : Nat) (h : t > 0) :\n  find_robot_position t = find_robot_position t :=\nsorry\n\ntheorem first_position_is_up :\n  find_robot_position 1 = (0, 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (0, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 1\n\n/-\ninfo: (-1, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 2\n\n/-\ninfo: (2, 4)\n-/\n#guard_msgs in\n#eval find_robot_position 50"}
{"id": "fvapps_000555", "vc-description": "", "vc-preamble": "def factorial (n : Nat) : Nat :=\n  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n\n\ndef containsChar (s : String) (c : Char) : Bool :=\n  s.data.contains c", "vc-helpers": "", "vc-definitions": "def count_distinct_sequences (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem count_distinct_basic_properties (s : String) :\n  let result := count_distinct_sequences s\n  result ≤ factorial s.length ∧\n  0 < result ∧\n  result = result\n  :=\nsorry\n\ntheorem count_distinct_special_substring (s : String) :\n  let result := count_distinct_sequences s\n  ((containsChar s 'k' ∧ containsChar s 'a' ∧ containsChar s 'r') ∨\n   (containsChar s 's' ∧ containsChar s 'h' ∧ containsChar s 'i')) →\n  result < factorial s.length\n  :=\nsorry\n\ntheorem count_distinct_karshi_all_letters (s : String) :\n  let result := count_distinct_sequences s\n  (containsChar s 'k' ∧ containsChar s 'a' ∧ containsChar s 'r' ∧\n   containsChar s 's' ∧ containsChar s 'h' ∧ containsChar s 'i') →\n  result < factorial s.length - factorial (s.length - 2)\n  :=\nsorry\n\ntheorem count_distinct_exact_karshi (s : String) :\n  s.length = 6 →\n  (s.data.toArray.qsort (· < ·) = \"karshi\".data.toArray.qsort (· < ·)) →\n  count_distinct_sequences s = factorial 6 - 2 * factorial 4\n  :=\nsorry\n\ntheorem count_distinct_length_properties (s : String) :\n  let result := count_distinct_sequences s\n  (s.length ≤ 2 → result = factorial s.length) ∧\n  (s.length > 6 ∧ containsChar s 'k' ∧ containsChar s 'a' ∧\n   containsChar s 'r' ∧ containsChar s 's' ∧ containsChar s 'h' ∧\n   containsChar s 'i' →\n    result = factorial s.length - 2 * factorial (s.length - 2) + factorial (s.length - 4))\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"karp\"\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"abcd\""}
{"id": "fvapps_000556", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reduce_recipe (ingredients : List Nat) : List Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef gcdl (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem reduce_recipe_proportions (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  let result := reduce_recipe ingredients\n  ∀ i j, i < ingredients.length → j < ingredients.length →\n    ingredients[i]! * result[j]! = ingredients[j]! * result[i]! :=\nsorry\n\ntheorem reduce_recipe_gcd (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  gcdl (reduce_recipe ingredients) = 1 :=\nsorry\n\ntheorem gcd_divides (a b : Nat) (h₁ : a > 0) (h₂ : b > 0) :\n  let g := gcd a b\n  g ∣ a ∧ g ∣ b :=\nsorry\n\ntheorem gcd_commutative (a b : Nat) (h₁ : a > 0) (h₂ : b > 0) :\n  gcd a b = gcd b a :=\nsorry\n\ntheorem reduce_recipe_nat (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  ∀ x, x ∈ reduce_recipe ingredients → x > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval reduce_recipe [4, 4]\n\n/-\ninfo: [2, 3, 4]\n-/\n#guard_msgs in\n#eval reduce_recipe [2, 3, 4]\n\n/-\ninfo: [1, 5, 3, 2]\n-/\n#guard_msgs in\n#eval reduce_recipe [3, 15, 9, 6]"}
{"id": "fvapps_000559", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_subarray (arr : List Int) : List Int :=\nsorry\n\ndef sum_list (l : List Int) : Int :=\nsorry\n\ndef all_subarrays_bounded_by_negatives (arr : List Int) : List (List Int) :=\nsorry", "vc-theorems": "theorem all_positive_returns_full_array {arr : List Int}\n  (h : ∀ x ∈ arr, x ≥ 0) (nonempty : arr ≠ []) :\n  find_max_subarray arr = arr :=\nsorry\n\ntheorem sum_is_maximal {arr : List Int} (nonempty : arr ≠ []) :\n  let result := find_max_subarray arr\n  let result_sum := sum_list result\n  ∀ subarray ∈ all_subarrays_bounded_by_negatives arr,\n    sum_list subarray ≤ result_sum :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000567", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_make_sequence_good (n : Nat) (sequence : List Int) : String :=\nsorry\n\ndef sum_nonnegative (l : List Int) : Int :=\nsorry\n\ndef sum_negative (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem sequence_result_is_yes_or_no (n : Nat) (sequence : List Int) :\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" ∨ result = \"NO\" :=\nsorry\n\ntheorem yes_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"YES\" →\n  sum_nonnegative sequence ≥ Int.natAbs (sum_negative sequence) :=\nsorry\n\ntheorem no_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"NO\" →\n  sum_nonnegative sequence < Int.natAbs (sum_negative sequence) :=\nsorry\n\ntheorem single_element_sequence (x : Int) :\n  can_make_sequence_good 1 [x] = (if x ≥ 0 then \"YES\" else \"NO\") :=\nsorry\n\ntheorem sequence_length_valid (sequence : List Int) :\n  let n := sequence.length\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" ∨ result = \"NO\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 1 [-1]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 2 [1, 2]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 3 [1, -2, 3]"}
{"id": "fvapps_000569", "vc-description": "-- Result is non-negative\n\n-- Result is less than or equal to n\n\n-- GCD divides both numbers\n\n-- GCD is positive\n\n-- GCD is largest such number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_evil_sorcerer (n : Nat) (p : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_evil_sorcerer_properties {n : Nat} {p : List Nat}\n  (n_pos : n > 0) (p_pos : ∀ x ∈ p, x > 0) :\n  let result := solve_evil_sorcerer n p\n\n  result ≥ 0 ∧\n\n  result ≤ n := by\n  sorry\n\ntheorem gcd_properties {a b : Nat} (a_pos : a > 0) (b_pos : b > 0) :\n  let g := gcd a b\n\n  (a % g = 0 ∧ b % g = 0) ∧\n\n  g > 0 ∧\n\n  ∀ i, g < i → i ≤ min a b → ¬(a % i = 0 ∧ b % i = 0) := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 4 [5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 6 [2, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 1 [20201220]"}
{"id": "fvapps_000572", "vc-description": "-- GCD theorems\n\n-- Pizza cuts theorems", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def gcd (a b : Int) : Int :=\n  sorry\n\ndef minPizzaCuts (n : Nat) (angles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_positive {a b : Int} (h : a ≠ 0 ∨ b ≠ 0) :\n  gcd (abs a) (abs b) > 0 :=\nsorry\n\ntheorem gcd_divides {a b : Int} :\n  let d := gcd (abs a) (abs b)\n  (a ≠ 0 → abs a % d = 0) ∧\n  (b ≠ 0 → abs b % d = 0) :=\nsorry\n\ntheorem minPizzaCuts_nonnegative {n : Nat} {angles : List Nat} :\n  minPizzaCuts n angles ≥ 0 :=\nsorry\n\ntheorem minPizzaCuts_upper_bound {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles + n ≤ 360 :=\nsorry\n\ntheorem minPizzaCuts_rotation_invariant {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles =\n  minPizzaCuts n (List.map (fun x => (x + 45) % 360) angles) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_pizza_cuts 4 [0, 90, 180, 270]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [90, 210]\n\n/-\ninfo: 358\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [0, 1]"}
{"id": "fvapps_000581", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_stone_array (n k : Nat) (A : List Int) : List Int :=\n  sorry\n\ndef list_maximum (l : List Int) : Int :=\n  sorry\n\ndef list_minimum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem stone_array_output_length {n k : Nat} {A : List Int} :\n  List.length (solve_stone_array n k A) = List.length A :=\nsorry\n\ntheorem stone_array_zero_k {n : Nat} {A : List Int} :\n  solve_stone_array n 0 A = A :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000582", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_valid_shifts (n : Nat) (nums : List Nat) : Nat :=\nsorry\n\ndef verify_shift (arr : List Nat) (shift_pos : Nat) : Bool :=\nsorry", "vc-theorems": "theorem result_bounds (n : Nat) (nums : List Nat)\n  (h1 : 2 ≤ n) (h2 : n ≤ 20) (h3 : nums.length = n) :\n  0 ≤ count_valid_shifts n nums ∧ count_valid_shifts n nums ≤ n :=\nsorry\n\ntheorem all_same_gives_zero (n : Nat)\n  (h1 : 2 ≤ n) (h2 : n ≤ 20) :\n  count_valid_shifts n (List.replicate n 1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_valid_shifts 4 [1, 2, 1, 1]"}
{"id": "fvapps_000604", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isInfixOf (sub str : String) : Bool :=\nsorry\n\ndef substr (s : String) (i len : Nat) : String :=\nsorry\n\ndef find_stem (words : List String) : String :=\nsorry", "vc-theorems": "theorem stem_exists_in_all_words (words : List String) :\n  let stem := find_stem words\n  ∀ word ∈ words, isInfixOf stem word :=\nsorry\n\ntheorem stem_is_substring_of_first_word (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  isInfixOf stem (words.get ⟨0, h⟩) :=\nsorry\n\ntheorem stem_length_consistency (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  let first := words.get ⟨0, h⟩\n  ∀ i j, i < j → j ≤ first.length →\n    let substring := substr first i (j-i)\n    (∀ word ∈ words, isInfixOf substring word) →\n    substring.length ≤ stem.length ∨\n    (substring.length = stem.length ∧ stem ≤ substring) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'grace'\n-/\n#guard_msgs in\n#eval find_stem [\"grace\", \"graceful\", \"disgraceful\", \"gracefully\"]\n\n/-\ninfo: 'cat'\n-/\n#guard_msgs in\n#eval find_stem [\"cat\", \"catch\", \"cathedral\"]\n\n/-\ninfo: 'python'\n-/\n#guard_msgs in\n#eval find_stem [\"python\", \"pythonic\", \"pythoness\"]"}
{"id": "fvapps_000606", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_numbers (nums : List Int) : List String :=\n  sorry\n\ndef isSorted (l : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem sort_numbers_ascending (nums : List Int) :\n  let result := sort_numbers nums;\n  result.length = nums.length ∧\n  isSorted (result.map String.toInt!) := by\n  sorry\n\ntheorem sort_numbers_idempotent_list (nums : List Int) :\n  sort_numbers nums = sort_numbers nums := by\n  sorry\n\ntheorem sort_numbers_bounds (nums : List Int) (h : nums ≠ []) :\n  let result := sort_numbers nums\n  let vals := result.map String.toInt!\n  vals.head! ≤ vals.getLast! ∧\n  ∀ x ∈ vals, vals.head! ≤ x ∧ x ≤ vals.getLast! := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000607", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def cristo_sutra (input : List Nat) : List String :=\nsorry\n\ndef parseResults (strs : List String) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem cristo_sutra_length (input : List Nat) :\n  input.length > 0 → (cristo_sutra input).length = input.length :=\nsorry\n\ntheorem cristo_sutra_base_cases :\n  cristo_sutra [1] = [\"0 1\"] ∧\n  cristo_sutra [2] = [\"2 1\"] ∧\n  cristo_sutra [3] = [\"3 2\"] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000608", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry\n\ndef count_valid_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_subarrays_singleton (x : Nat) :\n  solve_subarrays 1 [x] = 0 :=\nsorry\n\ntheorem solve_subarrays_alternating_nonneg (n : Nat) :\n  let arr := List.replicate (2*n) 100000000 ++ List.replicate (2*n) 900000000\n  solve_subarrays (4*n) arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_subarrays 3 [100000000, 900000000, 100000000]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 1 [900000000]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 2 [100000000, 100000000]"}
{"id": "fvapps_000610", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gameWinner (config : String) : String :=\nsorry\n\ndef countBlacksBeforeWhite (s : String) : Nat :=\nsorry\n\ndef countBlacksAfterWhite (s : String) : Nat :=\nsorry", "vc-theorems": "theorem gameWinner_returns_valid_player (config : String) :\n  (gameWinner config = \"Chef\" ∨ gameWinner config = \"Aleksa\") :=\nsorry\n\ntheorem chef_wins_equal_blacks (config : String)\n  (h : countBlacksBeforeWhite config = countBlacksAfterWhite config) :\n  gameWinner config = \"Chef\" :=\nsorry\n\ntheorem aleksa_wins_unequal_blacks (config : String)\n  (h : countBlacksBeforeWhite config ≠ countBlacksAfterWhite config) :\n  gameWinner config = \"Aleksa\" :=\nsorry\n\ntheorem chef_wins_single_white (config : String)\n  (h : config = \"W\") :\n  gameWinner config = \"Chef\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Chef'\n-/\n#guard_msgs in\n#eval game_winner \"W\"\n\n/-\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BW\"\n\n/-\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BWBB\""}
{"id": "fvapps_000614", "vc-description": "", "vc-preamble": "def list_max (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl Nat.max h t\n\ndef list_min (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl Nat.min h t", "vc-helpers": "", "vc-definitions": "def find_tallest_mountain (n : Nat) (heights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_tallest_in_list {n : Nat} {heights : List Nat} (h : heights ≠ []) :\n  find_tallest_mountain n heights ∈ heights\n  :=\nsorry\n\ntheorem length_preserved {n : Nat} {heights : List Nat} :\n  heights.length = n →\n  heights.length = n\n  :=\nsorry\n\ntheorem single_mountain_height {height : Nat} :\n  find_tallest_mountain 1 [height] = height\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_tallest_mountain 5 [4, 7, 6, 3, 1]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval find_tallest_mountain 3 [10, 20, 30]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_tallest_mountain 1 [5]"}
{"id": "fvapps_000617", "vc-description": "", "vc-preamble": "def listMax : List Int → Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)\n\ndef listSum : List Int → Int\n  | [] => 0\n  | (x::xs) => x + listSum xs", "vc-helpers": "", "vc-definitions": "def count_quadruples (n : Nat) (target : Int) (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem count_quadruples_returns_natural\n  (nums : List Int) (target : Int) (h : nums.length ≥ 4) :\n  count_quadruples nums.length target nums ≥ 0 :=\nsorry\n\ntheorem count_quadruples_binary_for_four\n  (nums : List Int) (target : Int) (h : nums.length = 4) :\n  count_quadruples nums.length target nums = 0 ∨\n  count_quadruples nums.length target nums = 1 :=\nsorry\n\ntheorem insufficient_elements_gives_zero\n  (nums : List Int) (target : Int) (h : nums.length < 4) :\n  count_quadruples nums.length target nums = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_quadruples 6 20 [3, 1, 1, 2, 5, 10]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_quadruples 6 13 [1, 2, 3, 4, 5, 4]"}
{"id": "fvapps_000618", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_parens (s : String) : Bool :=\nsorry\n\ndef max_nested_depth (s : String) : Nat :=\nsorry\n\ndef solve_balanced_parens (n : Nat) (k : Nat) : String :=\nsorry", "vc-theorems": "theorem balanced_parens_properties (n k : Nat) (h1 : n > 0) (h2 : k > 0) (h3 : n ≤ 100) (h4 : k ≤ 100) :\n  let result := solve_balanced_parens n k\n  if result = \"-1\" then\n    k = 2 ∨ k = 4 ∨ n % 2 ≠ 0 ∨ n = k\n  else\n    result.length = n ∧\n    (∀ c, c ∈ result.data → c = '(' ∨ c = ')') ∧\n    is_valid_parens result :=\nsorry\n\ntheorem odd_k_cases (n : Nat) (h1 : n > 1) (h2 : n ≤ 100) (h3 : n % 2 = 0) :\n  let k := 3\n  let result := solve_balanced_parens n k\n  if result ≠ \"-1\" then\n    result = String.mk (List.replicate (n/2) '(' ++ List.replicate (n/2) ')') else True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 4 2\n\n/-\ninfo: '(())(())'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 8 6"}
{"id": "fvapps_000623", "vc-description": "-- Result should be non-negative\n\n-- Cooldown should not exceed max time window plus delay\n\n-- Monotonicity with respect to delay\n\n-- Known values\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def list_maximum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.max x\n\ndef list_minimum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.min x", "vc-helpers": "", "vc-definitions": "def solve_spaceship_cooldown (n d : Nat) (arrivals : List Nat) : Float :=\n  sorry", "vc-theorems": "theorem spaceship_cooldown_nonnegative\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≥ 0 :=\nsorry\n\ntheorem spaceship_cooldown_upper_bound\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≤\n    ((list_maximum arrivals) - (list_minimum arrivals)).toFloat + d.toFloat :=\nsorry\n\ntheorem spaceship_cooldown_monotone_delay\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≤ solve_spaceship_cooldown n (d + 1) arrivals :=\nsorry\n\ntheorem spaceship_cooldown_known_value1 :\n  solve_spaceship_cooldown 3 2 [3, 2, 3] = 1.5 :=\nsorry\n\ntheorem spaceship_cooldown_known_value2 :\n  solve_spaceship_cooldown 2 1 [5, 6] = 2.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000624", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_legendary_prime_game (n: Nat) (p a b: List Nat) : Nat :=\nsorry\n\ndef is_prime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem single_prime_result_bounds (n: Nat) (h: n > 0) (h2: n ≤ 5):\n  let p := List.replicate n 2\n  let a := List.replicate n 1\n  let b := List.replicate n 1\n  let result := solve_legendary_prime_game n p a b\n  result > 0 ∧ result < (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 540\n-/\n#guard_msgs in\n#eval solve_legendary_prime_game 3 [2, 3, 5] [2, 1, 2] [1, 1, 1]"}
{"id": "fvapps_000627", "vc-description": "-- Result is non-negative\n\n-- Result is at most input length\n\n-- Single character sequence reduces to at most 1\n\n-- Palindrome property", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_string_length (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem min_string_length_non_negative (s : String) (h : s.length > 0) :\n  min_string_length s ≥ 0 :=\nsorry\n\ntheorem min_string_length_upper_bound (s : String) (h : s.length > 0) :\n  min_string_length s ≤ s.length :=\nsorry\n\ntheorem min_string_length_same_char (s : String) (h : s.length > 0)\n  (h' : ∀ (i j : String.Pos), s.get i = s.get j) :\n  min_string_length s ≤ 1 :=\nsorry\n\ntheorem min_string_length_palindrome (s : String) (h : s.length > 0) :\n  min_string_length s = min_string_length (reverseString s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_string_length \"abccd\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_string_length \"abbac\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_string_length \"aaaa\""}
{"id": "fvapps_000629", "vc-description": "", "vc-preamble": "def is_valid_operation (op : List Nat) : Bool :=\nmatch op with\n| h::t =>\n  if h = 1 then t.length = 2 && List.head! t ≥ 1 && List.get! t 1 ≥ 1\n  else if h = 2 then t.length = 3 && List.head! t ≥ 1 && List.get! t 1 ≥ List.head! t\n  else false\n| [] => false", "vc-helpers": "", "vc-definitions": "def hill_jumping_competition (n : Nat) (heights : List Nat) (operations : List (List Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem hill_jumping_result_length (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  (hill_jumping_competition n heights operations).length =\n    (List.filter (fun op => List.head! op = 1) operations).length :=\nsorry\n\ntheorem hill_jumping_bounds (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  List.all (hill_jumping_competition n heights operations) (fun x => x ≥ 1 ∧ x ≤ n) :=\nsorry\n\ntheorem hill_jumping_preserves_heights (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  let original := heights\n  let _ := hill_jumping_competition n heights operations\n  heights = original :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 5 [1, 2, 3, 4, 5] [[1, 1, 2], [2, 3, 4, -1], [1, 1, 2]]\n\n/-\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 3 [1, 3, 2] [[1, 1, 1], [2, 1, 2, 1], [1, 1, 1]]"}
{"id": "fvapps_000630", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidGrid (grid : List (List Char)) : Bool :=\n  sorry\n\ndef countOnes (grid : List (List Char)) : Nat :=\n  sorry\n\ndef isGravityConsistent (grid : List (List Char)) (force : Char) : Bool :=\n  sorry\n\ndef solveParticleGrid (n m : Nat) (grid : List (List Char)) (forces : List Char) : List (List Char) :=\n  sorry", "vc-theorems": "theorem grid_dimensions {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  List.length result = n ∧\n  ∀ row ∈ result, List.length row = m :=\nsorry\n\ntheorem grid_valid_chars {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  ∀ row ∈ result, ∀ c ∈ row, c = '0' ∨ c = '1' :=\nsorry\n\ntheorem preserved_ones_count {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  countOnes grid = countOnes result :=\nsorry\n\ntheorem final_gravity_consistent {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid)\n  (h2 : forces ≠ []) :\n  let result := solveParticleGrid n m grid forces\n  let lastForce := List.getLast forces h2\n  isGravityConsistent result lastForce :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000634", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def game (n : Nat) (health : List Nat) (laser_energy : Nat) : Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem game_result_non_negative (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy ≥ 0 :=\nsorry\n\ntheorem game_result_bounded (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy ≤ n :=\nsorry\n\ntheorem game_empty_list (laser_energy : Nat) :\n  game 0 [] laser_energy = 0 :=\nsorry\n\ntheorem game_zero_energy (n : Nat) (health : List Nat) (h : health ≠ []) :\n  game n health 0 = 0 :=\nsorry\n\ntheorem game_energy_threshold (n : Nat) (health : List Nat) (laser_energy : Nat)\n  (h1 : health ≠ []) (h2 : laser_energy < listMin health) :\n  game n health laser_energy = 0 :=\nsorry\n\ntheorem game_sufficient_energy (n : Nat) (health : List Nat) (h : health ≠ []) :\n  game n health (2 * listSum health) = n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000643", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MODULO := 1000000007\n\ndef sum_odds_in_range (l r : Nat) : Nat :=\n  sorry\n\ndef solve_alternate_odd_sum (d l r : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_non_negative (d l r : Nat) :\n  solve_alternate_odd_sum d l r ≥ 0 :=\nsorry\n\ntheorem same_start_end_even (d l : Nat) :\n  l % 2 = 0 →\n  solve_alternate_odd_sum d l l = 0 :=\nsorry\n\ntheorem empty_range (d : Nat) :\n  ∀ l r : Nat, r < l →\n  solve_alternate_odd_sum d l r = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 114\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 10 33\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 2 1 7\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 1 9"}
{"id": "fvapps_000652", "vc-description": "", "vc-preamble": "def min_list (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl min h t", "vc-helpers": "", "vc-definitions": "def can_complete_team (N : Nat) (S : Nat) (prices : List Nat) (positions : List Nat) : String :=\nsorry", "vc-theorems": "theorem empty_lists :\n  can_complete_team 0 0 [] [] = \"no\" :=\nsorry\n\ntheorem all_defenders_or_forwards_only (p₁ p₂ p₃ : Nat) :\n  can_complete_team 3 50 [p₁, p₂, p₃] [0, 0, 0] = \"no\" ∧\n  can_complete_team 3 50 [p₁, p₂, p₃] [1, 1, 1] = \"no\" :=\nsorry\n\ntheorem valid_input_result {N S : Nat} {prices positions : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : positions.length = N)\n  (h₅ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₆ : ∀ p ∈ positions, p = 0 ∨ p = 1)\n  (h₇ : positions.get! 0 = 0)\n  (h₈ : positions.get! 1 = 1) :\n  can_complete_team N S prices positions = \"yes\" ∨\n  can_complete_team N S prices positions = \"no\" :=\nsorry\n\ntheorem valid_input_cost {N S : Nat} {prices positions : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : positions.length = N)\n  (h₅ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₆ : ∀ p ∈ positions, p = 0 ∨ p = 1)\n  (h₇ : positions.get! 0 = 0)\n  (h₈ : positions.get! 1 = 1) :\n  let min_defender := min_list (List.filterMap (λ i => if positions.get! i = 0 then some (prices.get! i) else none) (List.range N))\n  let min_forward := min_list (List.filterMap (λ i => if positions.get! i = 1 then some (prices.get! i) else none) (List.range N))\n  100 - S ≥ min_defender + min_forward ↔ can_complete_team N S prices positions = \"yes\" :=\nsorry\n\ntheorem team_costs {N S : Nat} {prices : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₅ : can_complete_team N S prices (List.map (λ i => i % 2) (List.range N)) = \"yes\") :\n  100 - S ≥ min_list (List.filterMap (λ i => if i % 2 = 0 then some (prices.get! i) else none) (List.range N)) +\n           min_list (List.filterMap (λ i => if i % 2 = 1 then some (prices.get! i) else none) (List.range N)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'yes'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [3, 8, 6, 5] [0, 1, 1, 0]\n\n/-\ninfo: 'no'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [5, 7, 6, 5] [0, 1, 1, 0]"}
{"id": "fvapps_000669", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUniform (s : String) : String :=\n  sorry\n\ndef countTransitions (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry\n\ndef swapBits (s : String) : String :=\n  sorry", "vc-theorems": "theorem uniform_string_result_valid {s : String} (h : s.length > 0) :\n  isUniform s = \"uniform\" ∨ isUniform s = \"non-uniform\" :=\nsorry\n\ntheorem all_same_chars_uniform {s : String} (h₁ : s.length > 0)\n  (h₂ : ∀ (i j : String.Pos), s.get i = s.get j) :\n  isUniform s = \"uniform\" :=\nsorry\n\ntheorem transitions_gt_two_nonuniform {s : String} (h₁ : s.length > 0)\n  (h₂ : countTransitions s > 2) :\n  isUniform s = \"non-uniform\" :=\nsorry\n\ntheorem transitions_leq_two_uniform {s : String} (h₁ : s.length > 0)\n  (h₂ : countTransitions s ≤ 2) :\n  isUniform s = \"uniform\" :=\nsorry\n\ntheorem uniform_reverse_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (reverseString s) :=\nsorry\n\ntheorem uniform_swap_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (swapBits s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"00000000\"\n\n/-\ninfo: 'non-uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10101010\"\n\n/-\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10000001\""}
{"id": "fvapps_000674", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def factorial (n : Nat) : Nat :=\n  sorry\n\ndef calculate_factorials (nums : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem empty_list_factorial :\n  calculate_factorials [] = [] :=\nsorry\n\ntheorem factorial_zero :\n  calculate_factorials [0] = [1] :=\nsorry\n\ntheorem factorial_one :\n  calculate_factorials [1] = [1] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000678", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_consecutive_power (arr : List Int) (k : Nat) : Int :=\nsorry\n\ndef sum_sublist (l : List Int) (i : Nat) (len : Nat) : Int :=\nsorry\n\ndef list_sum (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem find_max_consecutive_power_is_k_consecutive\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length) :\n  ∃ i, i + k ≤ arr.length ∧\n    find_max_consecutive_power arr k = sum_sublist arr i k :=\nsorry\n\ntheorem find_max_consecutive_power_is_maximum\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length) :\n  ∀ i, i + k ≤ arr.length →\n    sum_sublist arr i k ≤ find_max_consecutive_power arr k :=\nsorry\n\ntheorem find_max_consecutive_power_equals_sum_when_k_equals_length\n  {arr : List Int} :\n  find_max_consecutive_power arr arr.length = list_sum arr :=\nsorry\n\ntheorem find_max_consecutive_power_nonnegative\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length)\n  (h_nonneg : ∀ x ∈ arr, 0 ≤ x) :\n  0 ≤ find_max_consecutive_power arr k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, 2, 3, 4, 5] 3\n\n/-\ninfo: -3\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [-1, -2, -3, -4, -5] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, -2, 3, -4, 5] 3"}
{"id": "fvapps_000679", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def phi (n : Nat) : Nat :=\n  sorry\n\ndef solve_passcode (a m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem phi_positive (n : Nat) (h : n > 0) : phi n > 0 :=\nsorry\n\ntheorem phi_upper_bound (n : Nat) : phi n ≤ n :=\nsorry\n\ntheorem phi_one : phi 1 = 1 :=\nsorry\n\ntheorem solve_passcode_positive (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m > 0 :=\nsorry\n\ntheorem solve_passcode_upper_bound (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m ≤ m :=\nsorry\n\ntheorem solve_passcode_one (a : Nat) (h : a > 0) :\n  solve_passcode a 1 = 1 :=\nsorry\n\ntheorem solve_passcode_coprime (a m : Nat) (h₁ : a > 0) (h₂ : m > 0)\n  (h₃ : Nat.gcd a m = 1) :\n  solve_passcode a m = phi m :=\nsorry\n\ntheorem solve_passcode_gcd (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m = phi (m / Nat.gcd a m) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_passcode 4 9\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_passcode 5 10\n\n/-\ninfo: 9999999966\n-/\n#guard_msgs in\n#eval solve_passcode 42 9999999967"}
{"id": "fvapps_000681", "vc-description": "-- arbitrary large value", "vc-preamble": "def listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => List.foldl min h t\n\ndef findMinValidPath (costs : List (List Nat)) : Nat :=\n  let range4 := [0, 1, 2, 3]\n  let maxVal := 10000\n  let bank1 := costs.head!\n  let bank2 := costs.get! 1\n  listMin (List.map (fun w1 =>\n    listMin (List.map (fun w2 =>\n      if w1 ≠ w2 then bank1[w1]! + bank2[w2]! else maxVal\n    ) range4)\n  ) range4)", "vc-helpers": "", "vc-definitions": "def minRobberyCost (n : Nat) (costs : List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem single_bank_result (costs : List (List Nat))\n  (h1 : costs.length = 1)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 1 costs = listMin (costs.head!) := by\nsorry\n\ntheorem two_banks_positive (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs > 0 := by\nsorry\n\ntheorem two_banks_lower_bound (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs ≥ listMin (costs.head!) + listMin (costs.get! 1) := by\nsorry\n\ntheorem two_banks_min_path (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs = findMinValidPath costs := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 3 [[4, 7, 2, 9], [5, 6, 4, 7], [2, 6, 4, 3]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_robbery_cost 2 [[1, 2, 3, 4], [5, 6, 7, 8]]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 1 [[10, 20, 30, 40]]"}
{"id": "fvapps_000682", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_optimal_split (N k : Nat) (powers : List Nat) : Nat :=\nsorry\n\ndef calc_product (values : List Nat) (split : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_optimal_split_properties1 {N k : Nat} {powers : List Nat} (h1: N ≥ 2) (h2: k ≥ 1)\n    (h3: powers.length = N) (h4: ∀ x ∈ powers, x ≤ 10) :\n    let result := find_optimal_split N k powers\n    1 ≤ result ∧ result ≤ N-1 :=\nsorry\n\ntheorem find_optimal_split_properties2 {N k : Nat} {powers : List Nat} (h1: N ≥ 2) (h2: k ≥ 1)\n    (h3: powers.length = N) (h4: ∀ x ∈ powers, x ≤ 10) :\n    let values := powers.map (fun p => k^p)\n    let result := find_optimal_split N k powers\n    let optimal_product := calc_product values result\n    ∀ i, 1 ≤ i → i < N → calc_product values i ≤ optimal_product :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_optimal_split 5 2 [1, 1, 3, 3, 5]"}
{"id": "fvapps_000685", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveEugeneHomework (a n m : Nat) : Nat :=\n  sorry\n\ndef repeatedNum (a n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_eugene_homework_range (a n m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^9)\n  (hn : 1 ≤ n ∧ n ≤ 100)\n  (hm : 2 ≤ m ∧ m ≤ 10^9) :\n  let result := solveEugeneHomework a n m\n  0 ≤ result ∧ result < m :=\nsorry\n\ntheorem solve_eugene_homework_correct (a n m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^9)\n  (hn : 1 ≤ n ∧ n ≤ 100)\n  (hm : 2 ≤ m ∧ m ≤ 10^9) :\n  solveEugeneHomework a n m = repeatedNum a n % m :=\nsorry\n\ntheorem modulo_one_is_zero (a n : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^6)\n  (hn : 1 ≤ n ∧ n ≤ 100) :\n  solveEugeneHomework a n 1 = 0 :=\nsorry\n\ntheorem single_repeat (a m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^6)\n  (hm : 2 ≤ m ∧ m ≤ 10^6) :\n  solveEugeneHomework a 1 m = a % m :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_eugene_homework 12 2 17\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_eugene_homework 523 3 11\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_eugene_homework 1000 3 7"}
{"id": "fvapps_000687", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef list_maximum : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (list_maximum xs)", "vc-helpers": "", "vc-definitions": "def min_trips (n : Nat) (k : Nat) (weights : List Nat) : Int :=\nsorry", "vc-theorems": "theorem min_trips_basic_properties\n  (weights : List Nat) (k : Nat) (n : Nat) (h1 : n = weights.length) :\n  let result := min_trips n k weights\n  ((∃ w ∈ weights, w > k) → result = -1) ∧\n  ((∀ w ∈ weights, w ≤ k) →\n    result > 0 ∧\n    result ≤ n ∧\n    result * k ≥ list_sum weights) :=\nsorry\n\ntheorem min_trips_monotonic\n  (weights : List Nat) (n : Nat) (h1 : n = weights.length) :\n  let k₁ := list_maximum weights\n  let k₂ := k₁ + 1\n  min_trips n k₁ weights ≥ min_trips n k₂ weights :=\nsorry\n\ntheorem min_trips_zero_weights\n  (k : Nat) (weights : List Nat) (n : Nat) (h1 : n = weights.length)\n  (h2 : ∀ w ∈ weights, w = 0) :\n  let result := min_trips n k weights\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_trips 1 1 [2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_trips 2 4 [1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_trips 3 6 [3, 4, 2]"}
{"id": "fvapps_000690", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef find_max_gcd (arr : List Nat) : Nat :=\n  sorry\n\ndef gcd_of_list (numbers : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_returns_valid : ∀ (n : Nat) (arr : List Nat),\n  arr ≠ [] → solve n arr = arr.head! ∨ solve n arr = arr.getLast! :=\nsorry\n\ntheorem solve_optimality : ∀ (n : Nat) (arr : List Nat),\n  arr ≠ [] →\n  (arr.length = 1 → solve n arr = arr.head!) ∧\n  (arr.length > 1 → solve n arr ≥ arr.head! ∧ solve n arr ≥ arr.getLast!) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 1 [2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 3 [6, 9, 3]\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval solve 4 [12, 18, 24, 36]"}
{"id": "fvapps_000693", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def isEven (x : Int) : Bool :=\n  x % 2 == 0", "vc-helpers": "", "vc-definitions": "def can_find_odd_multiple (n : Nat) (arr : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem all_even_no_odd_multiple {n : Nat} {arr : List Int} :\n  (∀ x ∈ arr, isEven x = true) →\n  can_find_odd_multiple n arr = false :=\nsorry\n\ntheorem single_number_case (x : Int) :\n  can_find_odd_multiple 1 [x] = (!isEven x) :=\nsorry\n\ntheorem gcd_property {n : Nat} {arr : List Int} :\n  n = arr.length →\n  can_find_odd_multiple n arr = true ∨ can_find_odd_multiple n arr = false :=\nsorry\n\ntheorem parity_preservation {n : Nat} {arr : List Int} :\n  can_find_odd_multiple n arr = can_find_odd_multiple n arr :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000694", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.index {α} [BEq α] (xs : List α) (x : α) : Nat :=\n  sorry\n\ndef check_subsequence (s1 : String) (s2 : String) : String :=\n  sorry", "vc-theorems": "theorem sequence_is_subsequence_of_itself (seq : List Nat) (h : seq.length > 0) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  check_subsequence (toString seq) (toString seq) = \"Yes\" :=\nsorry\n\ntheorem invalid_element_not_subsequence (seq : List Nat) (invalid : Nat) (h1 : seq.length > 0) :\n  (∀ x ∈ seq, x > 0 ∧ x ≤ 100) →\n  invalid > 100 ∧ invalid ≤ 200 →\n  check_subsequence (toString seq) (toString invalid) = \"No\" :=\nsorry\n\ntheorem first_element_is_subsequence (seq : List Nat) (h : seq.length > 1) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  check_subsequence (toString seq) (toString (seq.get! 0)) = \"Yes\" :=\nsorry\n\ntheorem consecutive_elements_subsequence (seq : List Nat) (start : Nat)\n  (h1 : seq.length ≥ 3) (h2 : start < seq.length - 1) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  let subseq := (seq.drop start).take 2\n  ∀ i < subseq.length - 1,\n    seq.index (subseq[i]!) < seq.index (subseq[i+1]!) →\n  check_subsequence (toString seq) (toString subseq) = \"Yes\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 2 3 4 5 6\" \"2 3 4\"\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval check_subsequence \"22 5 6 33 1 4\" \"4 15\"\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 3 4 2\" \"1 2\""}
{"id": "fvapps_000696", "vc-description": "", "vc-preamble": "def string_reverse (s : String) : String :=\n  ⟨s.data.reverse⟩", "vc-helpers": "", "vc-definitions": "def calculate_string_weight (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem length_weight_relationship {s : String}\n  (h : ∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  s.length ≤ calculate_string_weight s ∧ calculate_string_weight s ≤ 27 * s.length :=\nsorry\n\ntheorem invariant_under_reversal {s : String}\n  (h : ∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  calculate_string_weight s = calculate_string_weight (string_reverse s) :=\nsorry\n\ntheorem weight_additive {s1 s2 : String}\n  (h1 : ∀ c ∈ s1.data, 'A' ≤ c ∧ c ≤ 'Z')\n  (h2 : ∀ c ∈ s2.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  calculate_string_weight (s1 ++ s2) = calculate_string_weight s1 + calculate_string_weight s2 :=\nsorry\n\ntheorem a_highest_weight :\n  calculate_string_weight \"A\" > calculate_string_weight \"Z\" :=\nsorry\n\ntheorem a_weight_27 :\n  calculate_string_weight \"A\" = 27 :=\nsorry\n\ntheorem z_weight_2 :\n  calculate_string_weight \"Z\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval calculate_string_weight \"A\"\n\n/-\ninfo: 65\n-/\n#guard_msgs in\n#eval calculate_string_weight \"AND\""}
{"id": "fvapps_000697", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def leastPrimeDivisors (n : Nat) : List Nat :=\n  sorry\n\ndef dividing_machine (n m : Nat) (arr : List Nat) (ops : List (List Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem least_prime_divisors_are_prime (n : Nat) :\n  (∀ p ∈ leastPrimeDivisors n, p > 1) ∧\n  (∀ p ∈ leastPrimeDivisors n, ∀ i : Nat, 2 ≤ i ∧ i * i ≤ p → p % i ≠ 0) :=\nsorry\n\ntheorem dividing_machine_valid_result {n m : Nat} {arr : List Nat} {ops : List (List Nat)}\n  (h_ops : ∀ op ∈ ops, op.length = 3 ∧\n          (op.get! 0 < 2 ∧ 1 ≤ op.get! 1 ∧ op.get! 1 ≤ op.get! 2 ∧ op.get! 2 ≤ n)) :\n  (dividing_machine n m arr ops).length = (ops.filter (fun op => op.get! 0 = 1)).length ∧\n  ∀ x ∈ dividing_machine n m arr ops, x ≥ 1 :=\nsorry\n\ntheorem single_number_valid {x : Nat} (h : x ≥ 1) :\n  let result := dividing_machine 1 1 [x] [[1,1,1]]\n  result.length = 1 ∧ result.get! 0 ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [5, 3, 5, 11]\n-/\n#guard_msgs in\n#eval dividing_machine 6 7 [2, 5, 8, 10, 3, 44] [[1, 2, 6], [0, 2, 3], [1, 2, 6], [0, 4, 6], [1, 1, 6], [0, 1, 6], [1, 4, 6]]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval dividing_machine 2 2 [1, 3] [[0, 2, 2], [1, 1, 2]]"}
{"id": "fvapps_000702", "vc-description": "/- Helper function for calculating palindrome count -/\n\n/- Calculated palindromes are non-negative integers less than modulus -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Binary exponentiation results are within valid modulo range -/\n\n/- Binary exponentiation of anything to power 0 equals 1 -/\n\n/- Binary exponentiation of x to power 1 equals x mod p -/\n\n/- Known values for small inputs -/\n\n/- Results differ between consecutive odd and even inputs -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin_expo (x n p : Nat) : Nat :=\n  sorry\n\ndef calculate_palindromes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem palindrome_count_bounds (n : Nat) (h : 0 < n) :\n  let result := calculate_palindromes n\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem bin_expo_bounds (x n p : Nat) :\n  let result := bin_expo x n p\n  0 ≤ result ∧ result < p :=\nsorry\n\ntheorem bin_expo_zero (x p : Nat) :\n  bin_expo x 0 p = 1 :=\nsorry\n\ntheorem bin_expo_one (x p : Nat) :\n  bin_expo x 1 p = x % p :=\nsorry\n\ntheorem small_n_cases :\n  calculate_palindromes 1 = 26 ∧\n  calculate_palindromes 2 = 52 ∧\n  calculate_palindromes 3 = 728 :=\nsorry\n\ntheorem palindrome_parity (n : Nat) (h : 0 < n) :\n  n % 2 = 1 → calculate_palindromes n ≠ calculate_palindromes (n + 1) :=\nsorry", "vc-postamble": "/-\ninfo: 26\n-/\n#guard_msgs in\n#eval calculate_palindromes 1\n\n/-\ninfo: 52\n-/\n#guard_msgs in\n#eval calculate_palindromes 2\n\n/-\ninfo: 728\n-/\n#guard_msgs in\n#eval calculate_palindromes 3"}
{"id": "fvapps_000705", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_permutation (n : Nat) (k : Nat) (indices : List Nat) : (String × List Nat) :=\n  sorry\n\ndef is_valid_permutation (perm : List Nat) : Bool :=\n  sorry\n\ndef check_indices_descending (perm indices : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem basic_case_1 :\n  solve_permutation 1 1 [1] = (\"YES\", [1]) :=\nsorry\n\ntheorem basic_case_2 :\n  solve_permutation 2 1 [1] = (\"NO\", []) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000707", "vc-description": "", "vc-preamble": "def count_char (c : Char) (s : List Char) : Nat :=\n  (s.filter (fun x => x = c)).length\n\ndef sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def max_meals (ingredients : List (List Char)) : Nat :=\n  sorry", "vc-theorems": "theorem max_meals_non_negative (ingredients : List (List Char)) :\n  max_meals ingredients ≥ 0 := by\nsorry\n\ntheorem max_meals_bounded_by_c (ingredients : List (List Char)) :\n  max_meals ingredients ≤ (sum_list (ingredients.map (count_char 'c'))) / 2 := by\nsorry\n\ntheorem max_meals_bounded_by_o (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'o')) := by\nsorry\n\ntheorem max_meals_bounded_by_d (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'd')) := by\nsorry\n\ntheorem max_meals_bounded_by_e (ingredients : List (List Char)) :\n  max_meals ingredients ≤ (sum_list (ingredients.map (count_char 'e'))) / 2 := by\nsorry\n\ntheorem max_meals_bounded_by_h (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'h')) := by\nsorry\n\ntheorem max_meals_bounded_by_f (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'f')) := by\nsorry\n\ntheorem max_meals_empty_list :\n  max_meals [] = 0 := by\nsorry\n\ntheorem max_meals_doubles (ingredients : List (List Char)) :\n  ingredients ≠ [] →\n  max_meals (ingredients.map (fun s => s ++ s)) ≥ max_meals ingredients := by\nsorry\n\ntheorem max_meals_with_invalid_chars (ingredients : List (List Char)) :\n  max_meals ingredients ≥ 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_meals [\"cplusplus\", \"oscar\", \"deck\", \"fee\", \"hat\", \"near\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_meals [\"code\", \"hacker\", \"chef\", \"chaby\", \"dumbofe\"]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_meals [\"codechef\", \"chefcode\", \"fehcedoc\", \"cceeohfd\", \"codechef\"]"}
{"id": "fvapps_000710", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Matrix := List (List Int)", "vc-helpers": "", "vc-definitions": "def StrMatrix := List String\n\ndef solve_matrix_moves (n m : Nat) (matrix : StrMatrix) : Matrix :=\n  sorry\n\ndef replicate_zeros (n : Nat) (m : Nat) : List String :=\n  sorry\n\ndef create_matrix_with_one (n m : Nat) : StrMatrix :=\n  sorry", "vc-theorems": "theorem matrix_dimensions {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  result.length = n ∧\n  ∀ (row : List Int), List.elem row result → row.length = m :=\nsorry\n\ntheorem matrix_all_zeros {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  ∀ (row : List Int), List.elem row result →\n  ∀ (x : Int), List.elem x row → x = -1 :=\nsorry\n\ntheorem single_one {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let i := n / 2\n  let j := m / 2\n  let matrix := create_matrix_with_one n m\n  let result := solve_matrix_moves n m matrix\n  (List.get! result i |>.get! j) = 0 ∧\n  (∀ k, k < m → k ≠ j → (List.get! result i |>.get! k) = 1) ∧\n  (∀ k, k < n → k ≠ i → (List.get! result k |>.get! j) = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000713", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.padRight (default : α) (n : Nat) (xs : List α) : List α :=\n  sorry\n\ndef find_weird_distance (n : Nat) (alice_speeds : List Nat) (bob_speeds : List Nat) : Nat :=\n  sorry\n\ndef running_sum_equal (alice_speeds bob_speeds : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem identical_speeds_sum_to_length\n  (n : Nat)\n  (h1 : n > 0)\n  (h2 : n ≤ 100) :\n  find_weird_distance n (List.replicate n 1) (List.replicate n 1) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_weird_distance 4 [1, 3, 3, 4] [1, 2, 4, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [2, 3] [3, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [3, 3] [3, 3]"}
{"id": "fvapps_000714", "vc-description": "", "vc-preamble": "def lexMin (s: String) : String :=\n  s.data.foldl (fun acc c => if c < acc.get! 0 then String.mk [c] else acc) (String.mk [s.get! 0])", "vc-helpers": "", "vc-definitions": "def find_smallest_palindrome (len: Nat) (s: String) : String :=\nsorry", "vc-theorems": "theorem find_smallest_palindrome_result_length\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  (find_smallest_palindrome len s).length = 1 :=\nsorry\n\ntheorem find_smallest_palindrome_in_original\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  s.contains ((find_smallest_palindrome len s).get! 0) = true :=\nsorry\n\ntheorem find_smallest_palindrome_lexmin\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  find_smallest_palindrome len s = lexMin s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'y'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 2 \"zy\"\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 1 \"cd\"\n\n/-\ninfo: 'm'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 3 \"mom\""}
{"id": "fvapps_000718", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef check_land_split (x y : Nat) : String :=\n  sorry", "vc-theorems": "theorem is_prime_properties (n : Nat) (h : n ≤ 1000) :\n  (n < 2 → is_prime n = false) ∧\n  (is_prime n = true → n ≥ 2) ∧\n  (is_prime n = true → ∀ i : Nat, 2 ≤ i → i ≤ 100 → ¬(n % i = 0)) :=\nsorry\n\ntheorem check_land_split_properties (x y : Nat) (h₁ : x ≤ 100) (h₂ : y ≤ 100) (h₃ : y ≤ x) :\n  (check_land_split x y = \"YES\" ∨ check_land_split x y = \"NO\") ∧\n  (check_land_split x y = \"NO\" ↔ is_prime (x*x - y*y)) :=\nsorry\n\ntheorem check_land_split_equal_sides (x : Nat) (h : x ≤ 100) :\n  check_land_split x x = \"YES\" :=\nsorry\n\ntheorem check_land_split_zero_inner (x : Nat) (h : x ≤ 100) :\n  check_land_split x 0 = \"NO\" ↔ is_prime (x*x) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 7 5\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval check_land_split 6 5\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 10 8"}
{"id": "fvapps_000719", "vc-description": "/- The army power is always at least 1 for positive inputs -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The army power is monotonic increasing -/\n\n/- Known base cases for the army power function -/\n\n/- The army power is bounded above by n -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_army_power (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem army_power_always_positive (n : Nat) (h : n ≥ 1) :\n  calc_army_power n ≥ 1 :=\nsorry\n\ntheorem army_power_monotonic (n : Nat) (h : n > 1) :\n  calc_army_power n ≥ calc_army_power (n-1) :=\nsorry\n\ntheorem army_power_base_cases :\n  (calc_army_power 1 = 1) ∧ (calc_army_power 4 = 2) :=\nsorry\n\ntheorem army_power_bounded (n : Nat) (h : n ≥ 1) :\n  calc_army_power n ≤ n :=\nsorry", "vc-postamble": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_army_power 24\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_army_power 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_army_power 4"}
{"id": "fvapps_000722", "vc-description": "", "vc-preamble": "def list_product : List Nat → Nat\n  | [] => 1\n  | x :: xs => x * list_product xs\n\ndef list_sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def compute_super_factor_sum (n : Nat) : Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem compute_super_factor_sum_positive (n : Nat) (h : n ≥ 2) :\n  compute_super_factor_sum n > 0 :=\nsorry\n\ntheorem compute_super_factor_sum_primes (n : Nat) (h1 : n ≥ 2) (h2 : is_prime n = true) :\n  compute_super_factor_sum n = n :=\nsorry\n\ntheorem compute_super_factor_sum_multiplicative (a b : Nat) (h1 : a ≥ 1) (h2 : b ≥ 1) :\n  compute_super_factor_sum (a * b) ≥ min (compute_super_factor_sum a) (compute_super_factor_sum b) :=\nsorry\n\ntheorem compute_super_factor_sum_product_relation (factors : List Nat)\n  (h1 : ∀ x ∈ factors, x ≥ 2) (h2 : factors.length > 0) :\n  compute_super_factor_sum (list_product factors) ≥\n  list_sum (List.map compute_super_factor_sum (List.filter (fun x => x > 1) factors)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 6\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 7\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 12"}
{"id": "fvapps_000726", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t", "vc-helpers": "", "vc-definitions": "def min_temple_operations (n : Nat) (heights : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_temple_operations_nonnegative (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  min_temple_operations n heights ≥ 0 :=\nsorry\n\ntheorem min_temple_operations_preserves_input (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  heights = heights :=\nsorry\n\ntheorem min_temple_operations_bounded_by_sum (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  min_temple_operations n heights ≤ list_sum heights :=\nsorry\n\ntheorem min_temple_operations_perfect (heights : List Nat) :\n  heights = [1,2,3,2,1] →\n  min_temple_operations 5 heights = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_temple_operations 3 [1, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_temple_operations 4 [1, 1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_temple_operations 5 [1, 2, 6, 2, 1]"}
{"id": "fvapps_000727", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minArraySize (height : Nat) : Nat := (2 ^ height) - 1\n\ndef calcMaxProduct (height : Nat) (values : List Nat) : Nat :=\nsorry\n\ndef treeProduct (values : List Nat) (height : Nat) : Nat :=\nsorry", "vc-theorems": "theorem calc_max_product_zero_height (values : List Nat) :\n  calcMaxProduct 0 values = 0 := by\n  sorry\n\ntheorem calc_max_product_bounds {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length ≥ minArraySize height) :\n  0 ≤ calcMaxProduct height values ∧ calcMaxProduct height values < 1000000007 := by\n  sorry\n\ntheorem tree_product_monotonic {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length ≥ minArraySize height)\n  (h3 : ∀ x ∈ values, x > 0) :\n  let scaledValues := values.map (· * 2)\n  treeProduct scaledValues height > treeProduct values height := by\n  sorry\n\ntheorem min_array_size_valid (height : Nat) :\n  minArraySize height = 2^height - 1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_product 2 #[1, 2, 3]\n\n/-\ninfo: 105\n-/\n#guard_msgs in\n#eval calc_max_product 3 #[3, 1, 5, 2, 6, 4, 7]"}
{"id": "fvapps_000729", "vc-description": "/- If solveDie returns [0], it indicates no valid configuration exists.\n    Otherwise, returns a valid die configuration that works with the input sequence. -/\n\n/- If there are adjacent equal numbers in the input sequence,\n    no valid die configuration exists -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveDie (n : Nat) (nums : List Nat) : List Nat :=\n  sorry\n\ndef isValidConfig (config : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem die_configuration_theorem (n : Nat) (nums : List Nat) :\n  let result := solveDie n nums\n  result = [0] ∨ isValidConfig result ∧\n    ∀ i : Nat, i + 1 < n →\n      nums[i]! ≠ nums[i+1]! ∧\n      nums[i+1]! ≠ result[nums[i]! - 1]! :=\nsorry\n\ntheorem adjacent_same_numbers_theorem (n : Nat) (nums : List Nat) :\n  (∃ i : Nat, i + 1 < n ∧ nums[i]! = nums[i+1]!) →\n  solveDie n nums = [0] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000732", "vc-description": "/- Basic properties -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Sorting property -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_min_wire_length (n : Nat) (has_electricity : String) (coordinates : List Nat) : Nat :=\n  sorry\n\ndef isSorted (l : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem min_wire_length_non_negative (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : ∃ i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates ≥ 0 :=\nsorry\n\ntheorem min_wire_length_bounded (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : ∃ i < n, has_electricity.data.get! i = '1')\n  (h5 : coordinates.length ≥ 1) :\n  solve_min_wire_length n has_electricity coordinates ≤ (coordinates.getLast! - coordinates.head!) :=\nsorry\n\ntheorem min_wire_length_all_electrified (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : ∀ i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates = 0 :=\nsorry\n\ntheorem min_wire_length_requires_sorted (n : Nat) (has_electricity : String) (coordinates unsorted : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : unsorted.length = n)\n  (h5 : coordinates ≠ unsorted)\n  (h6 : coordinates ≠ []) :\n  solve_min_wire_length n has_electricity coordinates ≠\n  solve_min_wire_length n has_electricity unsorted :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_wire_length 2 \"01\" [1, 2]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_wire_length 3 \"100\" [1, 5, 6]"}
{"id": "fvapps_000735", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\n  sorry\n\ndef check_divisible_permutations (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem check_divisible_permutations_valid_output (n : Nat) :\n  n > 0 → check_divisible_permutations n = 0 ∨ check_divisible_permutations n = 1 :=\nsorry\n\ntheorem check_divisible_permutations_single_digits :\n  check_divisible_permutations 1 = 0 ∧ check_divisible_permutations 2 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_divisible_permutations 19\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 385\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 246"}
{"id": "fvapps_000736", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.minimum (l : List Nat) : Nat :=\n  sorry\n\ndef List.sort (l: List Nat) : List Nat :=\n  sorry\n\ndef find_common_divisors (nums: List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem find_common_divisors_contains_prime_factors {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 1 ∧ n ≤ 100) :\n  ∀ i: Nat, 2 ≤ i ∧ i ≤ List.minimum nums →\n  (∀ n ∈ nums, n % i = 0) →\n  (∀ j, 2 ≤ j ∧ j < i → i % j ≠ 0) →\n  i ∈ find_common_divisors nums :=\nsorry\n\ntheorem find_common_divisors_sorted {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  find_common_divisors nums = List.sort (find_common_divisors nums) :=\nsorry\n\ntheorem find_common_divisors_greater_than_one {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  ∀ x ∈ find_common_divisors nums, x > 1 :=\nsorry\n\ntheorem find_common_divisors_bounded_by_min {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  ∀ x ∈ find_common_divisors nums, x ≤ List.minimum nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval find_common_divisors [38, 6, 34]\n\n/-\ninfo: [2, 3, 6]\n-/\n#guard_msgs in\n#eval find_common_divisors [12, 18, 24]\n\n/-\ninfo: [5]\n-/\n#guard_msgs in\n#eval find_common_divisors [10, 15, 20]"}
{"id": "fvapps_000737", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef find_min_potatoes (x y : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_min_potatoes_returns_prime_sum\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x ≤ 1000) (h4 : y ≤ 1000) :\n  let result := find_min_potatoes x y\n  result ≥ 0 ∧ isPrime (x + y + result) = true := by\n  sorry\n\ntheorem find_min_potatoes_with_equal_inputs\n  (x : Nat) (h1 : x > 0) (h2 : x ≤ 1000) :\n  let result := find_min_potatoes x x\n  isPrime (2*x + result) = true := by\n  sorry\n\ntheorem find_min_potatoes_reasonable_bounds\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x ≤ 100) (h4 : y ≤ 100) :\n  find_min_potatoes x y ≤ x + y := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_potatoes 4 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 1"}
{"id": "fvapps_000740", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\nsorry\n\ndef find_max_prime_factor (nums : List Nat) : Nat :=\nsorry\n\ndef get_prime_factors_count (nums : List Nat) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem result_is_prime_factor\n  (nums : List Nat)\n  (h1 : ∀ x ∈ nums, x ≥ 2 ∧ x ≤ 10000)\n  (h2 : nums.length > 0) :\n  let result := find_max_prime_factor nums\n  let factors := get_prime_factors_count nums\n  ∃ freq, (result, freq) ∈ factors :=\nsorry\n\ntheorem all_same_prime\n  (nums : List Nat)\n  (h : ∀ x ∈ nums, x = 2)\n  (h2 : nums.length > 0) :\n  find_max_prime_factor nums = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 2, 15, 6, 8, 5, 10]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_prime_factor [4, 8, 12, 15]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 5, 7, 11]"}
{"id": "fvapps_000744", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_convert_binary_strings (s p : String) : String :=\nsorry\n\ndef count_ones (s : String) : Nat :=\nsorry\n\ndef has_adjacent_ones (s : String) : Bool :=\nsorry", "vc-theorems": "theorem same_string_convertible (s : String)\n  (h : s ≠ \"\") :\n  can_convert_binary_strings s s = \"Yes\" :=\nsorry\n\ntheorem conversion_preserves_ones (s p : String)\n  (h1 : s ≠ \"\") (h2 : p ≠ \"\")\n  (h3 : s.length = p.length) :\n  (can_convert_binary_strings s p = \"Yes\") ↔ (count_ones s = count_ones p) :=\nsorry\n\ntheorem cannot_convert_ones_to_zeros (s p : String)\n  (h1 : s ≠ \"\")\n  (h2 : s.length = p.length)\n  (h3 : has_adjacent_ones s = true)\n  (h4 : p = s.replace \"11\" \"00\") :\n  can_convert_binary_strings s p = \"No\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"00\" \"00\"\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"101\" \"010\"\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"0110\" \"0011\""}
{"id": "fvapps_000747", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_rectangle_areas (n : Nat) (numbers : List Nat) : Nat × Nat :=\nsorry\n\ndef maximumTwoProduct (l : List Nat) : Nat :=\nsorry\n\ndef minimumTwoProduct (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_rectangle_areas_ordering\n  (numbers : List Nat)\n  (h : numbers.length ≥ 2) :\n  let (max_area, min_area) := find_rectangle_areas numbers.length numbers\n  max_area ≥ min_area :=\nsorry\n\ntheorem find_rectangle_areas_minimal\n  (numbers : List Nat)\n  (h : numbers = [1, 1]) :\n  find_rectangle_areas 2 numbers = (1, 1) :=\nsorry\n\ntheorem find_rectangle_areas_preserves_input\n  (numbers : List Nat)\n  (h : numbers.length ≥ 2) :\n  let original := numbers\n  let _ := find_rectangle_areas numbers.length numbers\n  numbers = original :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (20, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 5 [4, 2, 1, 5, 3]\n\n/-\ninfo: (12, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 4 [1, 2, 3, 4]\n\n/-\ninfo: (30, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 6 [5, 4, 3, 2, 1, 6]"}
{"id": "fvapps_000749", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_mex (n : Nat) (parents : List Nat) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tree_mex_positive (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents → solve_tree_mex n parents > 0 :=\nsorry\n\ntheorem tree_mex_ge_nodes (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents → solve_tree_mex n parents ≥ n :=\nsorry\n\ntheorem tree_mex_monotonic (n : Nat) (parents : List Nat) :\n  n > 2 →\n  is_valid_tree n parents →\n  solve_tree_mex n parents > solve_tree_mex (n-1) (parents.take (n-2)) :=\nsorry\n\ntheorem line_tree_formula (n : Nat) :\n  n ≥ 2 →\n  solve_tree_mex n (List.map (fun i => i) (List.range (n-1))) = n * (n+1) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_mex 3 [1, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_tree_mex 5 [1, 1, 2, 2]"}
{"id": "fvapps_000766", "vc-description": "/- The function always returns positive integers -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The first 5 elements follow a specific pattern -/\n\n/- For odd positions after 3, each number is previous number plus 1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nth_number (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_nth_number_positive (n : Nat) (h : n > 0) :\n  find_nth_number n > 0 :=\nsorry\n\ntheorem sequence_initial_pattern :\n  find_nth_number 1 = 1 ∧\n  find_nth_number 2 = 6 ∧\n  find_nth_number 3 = 7 ∧\n  find_nth_number 4 = 36 ∧\n  find_nth_number 5 = 37 :=\nsorry\n\ntheorem odd_index_increment (n : Nat) (h1 : n > 3) (h2 : n % 2 = 1) :\n  find_nth_number n = find_nth_number (n-1) + 1 :=\nsorry", "vc-postamble": "/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_nth_number 3\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval find_nth_number 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_nth_number 1"}
{"id": "fvapps_000771", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_snuffles_array (n d : Nat) (arr : List Int) : Int :=\n  sorry\n\ndef verify_solution (n d: Nat) (arr : List Int) : Bool :=\n  sorry\n\ndef list_sum (xs : List Int) : Int :=\n  sorry", "vc-theorems": "theorem snuffles_array_properties {n d : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : d > 0)\n  (h3 : d ≤ n)\n  (h4 : arr.length = n) :\n  let result := solve_snuffles_array n d arr\n  (result ≥ 0 → verify_solution n d arr = true) ∧\n  (result = -1 →\n    (∃ i : Nat, i < d ∧\n      let group := (List.range arr.length).filter (fun j => j % d = i)\n      let group_sum := list_sum (group.map (fun j => arr.get! j))\n      let group_avg := group_sum / group.length\n      group_avg ≠ (list_sum arr / arr.length))) :=\nsorry\n\ntheorem all_equal_array_zero {n : Nat} {x : Int}\n  (h1 : n > 0) :\n  solve_snuffles_array n 1 (List.replicate n x) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_snuffles_array 5 2 [1, 4, 5, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_snuffles_array 3 1 [1, 4, 1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_snuffles_array 4 2 [3, 4, 3, 5]"}
{"id": "fvapps_000772", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def count_possible_strings (n : Nat) (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem count_possible_strings_short_input (n : Nat) (s : String) :\n  n ≤ s.length → count_possible_strings n s = 0 :=\nsorry\n\ntheorem count_possible_strings_long_input (n : Nat) (s : String) :\n  n > s.length → count_possible_strings n s > 0 :=\nsorry\n\ntheorem count_possible_strings_monotone_in_string_length (s : String) :\n  let n := s.length + 2\n  count_possible_strings n s > count_possible_strings n (s.append \"a\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1326\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"a\"\n\n/-\ninfo: 76\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"ab\""}
{"id": "fvapps_000777", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DAYS : List String := [\"saturday\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n\ndef indexOfDay (day: String) : Nat :=\nsorry\n\ndef solveCompetitionDuration (startDay endDay: String) (l r: Nat) : String ⊕ Nat :=\nsorry", "vc-theorems": "theorem competition_duration_impossible {startDay endDay: String} {l r: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"impossible\") :\n  ∀ x, l ≤ x → x ≤ r →\n    x % 7 ≠ ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :=\nsorry\n\ntheorem competition_duration_many {startDay endDay: String} {l r: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"many\") :\n  ∃ x y, l ≤ x ∧ x < y ∧ y ≤ r ∧\n    x % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) ∧\n    y % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :=\nsorry\n\ntheorem competition_duration_specific {startDay endDay: String} {l r n: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inr n) :\n  l ≤ n ∧ n ≤ r ∧\n  n % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) ∧\n  (∀ x, l ≤ x → x < n → x % 7 ≠ n % 7) ∧\n  n + 7 > r :=\nsorry\n\ntheorem same_day_property {day: String}\n  (h: day ∈ DAYS) :\n  solveCompetitionDuration day day 1 20 = Sum.inr 7 ∨\n  solveCompetitionDuration day day 1 20 = Sum.inl \"many\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 2 4\n\n/-\ninfo: 'many'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"monday\" \"wednesday\" 1 20\n\n/-\ninfo: 'impossible'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 3 5"}
{"id": "fvapps_000780", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_min (n : Nat) (seq : String) : Int × Int :=\nsorry\n\ndef maximum : List Int → Int :=\nsorry\n\ndef minimum : List Int → Int :=\nsorry", "vc-theorems": "theorem find_max_min_permutation_invariant {nums1 nums2 : List Int} (n : Nat)\n  (seq1 seq2 : String)\n  (h1 : n = nums1.length)\n  (h2 : n = nums2.length)\n  (h3 : seq1 = String.intercalate \" \" (List.map toString nums1))\n  (h4 : seq2 = String.intercalate \" \" (List.map toString nums2))\n  (h5 : nums2.isPerm nums1) :\n  find_max_min n seq1 = find_max_min n seq2 :=\nsorry\n\ntheorem find_max_min_single_element (n : Nat) (x : Int) (seq : String)\n  (h1 : n = 1)\n  (h2 : seq = toString x) :\n  find_max_min n seq = (x, x) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (9, 2)\n-/\n#guard_msgs in\n#eval find_max_min 5 \"3 2 7 9 4\"\n\n/-\ninfo: (10, 5)\n-/\n#guard_msgs in\n#eval find_max_min 3 \"10 5 8\"\n\n/-\ninfo: (1000, 250)\n-/\n#guard_msgs in\n#eval find_max_min 4 \"1000 250 750 500\""}
{"id": "fvapps_000804", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_components (n: Nat) (edges: List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_tree (n: Nat) (edges: List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem line_graph_components {n: Nat} (h: n ≥ 2) :\n  let edges := List.range (n-1) |>.map (λi => (i+1, i+2))\n  find_max_components n edges = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 7 [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_components 3 [(1, 2), (2, 3)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 4 [(1, 2), (1, 3), (1, 4)]"}
{"id": "fvapps_000812", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_interesting_subsequences (n k : Nat) (a : List Nat) : Nat :=\n  sorry\n\ndef isSorted (l : List Nat) : Bool :=\n  sorry\n\ndef sortList (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem count_interesting_subsequences_properties (n k : Nat) (a : List Nat)\n    (h1 : n > 0) (h2 : k > 0) (h3 : List.length a > 0) :\n    k ≤ List.length a →\n    0 ≤ count_interesting_subsequences n k a :=\nsorry\n\ntheorem sorted_input_equivalence (a : List Nat)\n    (h1 : List.length a ≥ 2) :\n    let k := List.length a / 2\n    count_interesting_subsequences (List.length a) k (sortList a) =\n    count_interesting_subsequences (List.length a) k a :=\nsorry\n\ntheorem kth_element_boundary (a : List Nat)\n    (h1 : List.length a ≥ 2) (h2 : List.length a ≤ 10) :\n    let k := List.length a / 2\n    let sorted := sortList a\n    k > 0 →\n    k ≤ List.length a →\n    ∃ x, List.elem x a ∧ x = List.get! sorted (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 4 2 [1, 2, 3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 3 2 [2, 2, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 5 3 [1, 1, 2, 2, 3]"}
{"id": "fvapps_000823", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tweet_clicks (n : Nat) (clicks : List String) : List Nat :=\nsorry\n\ndef is_valid_click_command (n : Nat) (s : String) : Bool :=\nsorry\n\ndef get_tweet_count (prev : Nat) (cmd : String) : Nat :=\nsorry", "vc-theorems": "theorem output_length_matches_input {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  (solve_tweet_clicks n clicks).length = clicks.length :=\nsorry\n\ntheorem counts_are_nonnegative {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  ∀ x ∈ solve_tweet_clicks n clicks, 0 ≤ x ∧ x ≤ n :=\nsorry\n\ntheorem closeall_resets_to_zero {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  ∀ (i : Nat) (h : i < clicks.length),\n  clicks.get ⟨i, h⟩ = \"CLOSEALL\" →\n  (solve_tweet_clicks n clicks).get ⟨i, by rw [output_length_matches_input h1 h2 h3]; exact h⟩ = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 2, 3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 3 [\"CLICK 1\", \"CLICK 2\", \"CLICK 3\", \"CLICK 2\", \"CLOSEALL\", \"CLICK 1\"]\n\n/-\ninfo: [1, 2, 0]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 2 [\"CLICK 1\", \"CLICK 2\", \"CLOSEALL\"]\n\n/-\ninfo: [1, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 4 [\"CLICK 1\", \"CLICK 1\", \"CLICK 2\"]"}
{"id": "fvapps_000827", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef take_last (n : Nat) (l : List Nat) : List Nat :=\n  let rev := l.reverse\n  (rev.take n).reverse", "vc-helpers": "", "vc-definitions": "def find_max_team_score (n : Nat) (ratings : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_max_team_score_upper_bound\n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≤ list_sum (take_last 3 ratings) :=\nsorry\n\ntheorem find_max_team_score_lower_bound\n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≥ list_sum (ratings.take 3) :=\nsorry\n\ntheorem find_max_team_score_three_elements\n  (ratings : List Nat) (h : ratings.length = 3) :\n  find_max_team_score ratings.length ratings = list_sum ratings :=\nsorry\n\ntheorem find_max_team_score_consecutive\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) (hi : i + 2 < ratings.length) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i]! + ratings[i+1]! + ratings[i+2]! :=\nsorry\n\ntheorem find_max_team_score_wrapping\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i % ratings.length]! +\n    ratings[(i + 1) % ratings.length]! +\n    ratings[(i + 2) % ratings.length]! :=\nsorry\n\ntheorem find_max_team_score_all_equal\n  (n : Nat) (h : n ≥ 3) :\n  find_max_team_score n (List.replicate n 1) = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [10, 40, 30, 30, 20, 0, 0]\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [50, 20, 30, 10, 40, 15, 25]\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval find_max_team_score 3 [10, 20, 30]"}
{"id": "fvapps_000829", "vc-description": "", "vc-preamble": "def list_max : List Nat → Nat\n| [] => 0\n| (x::xs) => max x (list_max xs)\n\ndef list_min : List Nat → Nat\n| [] => 0\n| (x::xs) => min x (list_min xs)", "vc-helpers": "", "vc-definitions": "def gcd : Nat → Nat → Nat\n| a, b =>\nsorry\n\ndef max_gcd_sum : List Nat → Nat\n| xs =>\nsorry", "vc-theorems": "theorem matches_reference (nums : List Nat) (h : ∀ x ∈ nums, x > 0) :\n  ∃ result, max_gcd_sum nums = result := by\n  sorry\n\ntheorem output_larger_than_input (nums : List Nat) (h : ∀ x ∈ nums, x > 0) :\n  max_gcd_sum nums ≥ list_max nums ∧ max_gcd_sum nums ≥ list_min nums := by\n  sorry\n\ntheorem duplicate_handling (nums : List Nat) (dupes : List Nat)\n  (h : ∀ x ∈ nums, x > 0) (h2 : ∀ x ∈ dupes, x ∈ nums) :\n  max_gcd_sum nums = max_gcd_sum (nums ++ dupes) := by\n  sorry\n\ntheorem single_element (x : Nat) (h : x > 0) :\n  max_gcd_sum [x] = 2 * x := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval max_gcd_sum [4, 4, 7, 6]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gcd_sum [2, 2, 2]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval max_gcd_sum [3, 6, 9, 12]"}
{"id": "fvapps_000835", "vc-description": "", "vc-preamble": "def isDescending (l : List Nat) : Prop :=\n  ∀ i j, i < l.length → j < l.length → i < j →\n    match l.get? i, l.get? j with\n    | some x, some y => x ≥ y\n    | _, _ => True", "vc-helpers": "", "vc-definitions": "def max_race_wins (n : Nat) (my_times : List Nat) (opp_times: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_race_wins_result_bounds {n : Nat} {my_times opp_times : List Nat}\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : ∀ x ∈ my_times, 1 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ x ∈ opp_times, 1 ≤ x ∧ x ≤ 1000) :\n  let result := max_race_wins n my_times opp_times\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_race_wins_length {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : n > 0)\n  (h2 : my_times_out.length = n)\n  (h3 : opp_times_out.length = n)\n  (h4 : max_race_wins n my_times opp_times > 0) : True :=\nsorry\n\ntheorem max_race_wins_sorted {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : max_race_wins n my_times opp_times > 0)\n  (h2 : isDescending my_times_out)\n  (h3 : isDescending opp_times_out) : True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 3 [5, 4, 1] [5, 4, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_race_wins 2 [3, 1] [2, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 4 [5, 4, 3, 2] [6, 5, 4, 1]"}
{"id": "fvapps_000838", "vc-description": "", "vc-preamble": "def list_maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef nat_ceil_div (a b : Nat) : Nat :=\n  (a + b - 1) / b", "vc-helpers": "", "vc-definitions": "def min_banana_speed (pile_count : Nat) (hours : Nat) (piles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem edge_cases_singleton_one :\n  min_banana_speed 1 1 [1] = 1 :=\nsorry\n\ntheorem edge_cases_singleton_hundred :\n  min_banana_speed 1 1 [100] = 100 :=\nsorry\n\ntheorem edge_cases_two_ones :\n  min_banana_speed 2 2 [1, 1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_banana_speed 3 3 [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_banana_speed 3 4 [1, 2, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_banana_speed 4 5 [4, 3, 2, 7]"}
{"id": "fvapps_000842", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def pow (x: Int) (n: Nat) : Int :=\n  match n with\n  | 0 => 1\n  | n + 1 => x * pow x n", "vc-helpers": "", "vc-definitions": "def calculate_special_sum (n: Int) (k: Int) : Int :=\n  sorry\n\ndef solve_case (n: Int) (k: Int) : String :=\n  sorry", "vc-theorems": "theorem calculate_special_sum_nonnegative\n  (n: Int) (k: Int)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  calculate_special_sum n k ≥ 0 :=\nsorry\n\ntheorem calculate_special_sum_upper_bound\n  (n: Int) (k: Int) (power: Nat)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100)\n  (hp: pow k power ≤ n) :\n  calculate_special_sum n k ≤ (n * (n+1))/2 :=\nsorry\n\ntheorem calculate_special_sum_negative_input\n  (n: Int) (k: Int)\n  (hn: n < 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  calculate_special_sum n k = 0 :=\nsorry\n\ntheorem solve_case_format\n  (n: Int) (k: Int)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  solve_case n k = \"Case #1: \" ++ toString (calculate_special_sum n k) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000844", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_beautiful_subarrays (n k : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef is_valid_array (arr : List Nat) (n : Nat) : Bool :=\n  sorry\n\ndef list_sorted (arr : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem array_bounds (n k : Nat) (arr : List Nat) :\n  1 ≤ n ∧ n ≤ 100 ∧\n  1 ≤ k ∧ k ≤ 100 ∧\n  arr.length = n ∧\n  (∀ x ∈ arr, 1 ≤ x ∧ x ≤ 2000) →\n  0 ≤ count_beautiful_subarrays n k arr :=\nsorry\n\ntheorem single_element_arrays (n k : Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 →\n  n ≤ count_beautiful_subarrays n k (List.replicate n 1) :=\nsorry\n\ntheorem sorted_vs_unsorted (n k : Nat) (arr : List Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 ∧\n  is_valid_array arr n →\n  count_beautiful_subarrays n k (list_sorted arr) = count_beautiful_subarrays n k arr :=\nsorry\n\ntheorem minimal_case (k : Nat) :\n  1 ≤ k ∧ k ≤ 10 →\n  count_beautiful_subarrays 1 k [1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 3 3 [1, 2, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 1 1 [1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 2 2 [2, 1]"}
{"id": "fvapps_000847", "vc-description": "", "vc-preamble": "def is_direction (c : Char) : Bool :=\n  c = 'U' || c = 'D' || c = 'L' || c = 'R'", "vc-helpers": "", "vc-definitions": "def solve_ant_grid (R C : Nat) (grid : List String) : Nat :=\n  sorry\n\ndef make_empty_string (n : Nat) (c : Char) : String :=\n  sorry\n\ndef count_directions (grid : List String) : Nat :=\n  sorry", "vc-theorems": "theorem solve_ant_grid_output_props (R C : Nat) (grid : List String)\n  (h : R > 0 ∧ C > 0) :\n  let result := solve_ant_grid R C grid;\n  result ≥ 0 :=\nsorry\n\ntheorem empty_grid_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : ∀ (row : String), row ∈ grid → ∀ (c : Char), c ∈ row.data → (c = '-' ∨ c = '#')) :\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem single_ant_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : count_directions grid ≤ 1) :\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem all_empty_grid_zero (R C : Nat) (h : R > 0 ∧ C > 0) :\n  let empty_row := make_empty_string C '-';\n  let grid := List.replicate R empty_row;\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem all_walls_grid_zero (R C : Nat) (h : R > 0 ∧ C > 0) :\n  let wall_row := make_empty_string C '#';\n  let grid := List.replicate R wall_row;\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem single_ant_top_left_zero (R C : Nat) (ant : Char)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : is_direction ant) :\n  let first_row := (String.push (make_empty_string (C-1) '-') ant);\n  let empty_row := make_empty_string C '-';\n  let rest_rows := List.replicate (R-1) empty_row;\n  let grid := first_row :: rest_rows;\n  solve_ant_grid R C grid = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"R--\", \"---\", \"--U\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 1 4 [\"-R-L\"]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"-D-\", \"R-L\", \"-U-\"]"}
{"id": "fvapps_000855", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Float.ofString! (s: String) : Float := (Float.ofString? s).get!", "vc-helpers": "", "vc-definitions": "def Float.ofString? (s: String) : Option Float :=\nsorry\n\ndef calculate_donut_areas (radii : List Int) : List String :=\nsorry", "vc-theorems": "theorem calculate_donut_areas_length_match (radii : List Int) :\n  (calculate_donut_areas radii).length = radii.length :=\nsorry\n\ntheorem calculate_donut_areas_decimal_format (radii : List Int) (result : String) :\n  result ∈ calculate_donut_areas radii →\n  (∃ n d : String, result = n ++ \".\" ++ d ∧ d.length = 2) :=\nsorry\n\ntheorem calculate_donut_areas_accuracy (radius : Int) :\n  let area := calculate_donut_areas [radius]\n  let expected := (Float.ofInt (radius * radius)) * 3.14\n  let actual := Float.ofString! area.head!\n  (actual - expected).abs < 0.01 :=\nsorry\n\ntheorem calculate_donut_areas_negative_valid (radii : List Int)\n  (h : ∀ r ∈ radii, r < 0) :\n  (calculate_donut_areas radii).length = radii.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000864", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_proxy_attendance (D : Nat) (S : String) : Int :=\n  sorry\n\ndef countP (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_range {D : Nat} {S : String} (h : D ≥ 5) (h2 : D ≤ 100) (h3 : S.length = D) :\n  let result := solve_proxy_attendance D S\n  result = -1 ∨ result ≥ 0 :=\nsorry\n\ntheorem all_present {D : Nat} (h : D ≥ 5) (h2 : D ≤ 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'P')) = 0 :=\nsorry\n\ntheorem too_many_absences {D : Nat} (h : D ≥ 5) (h2 : D ≤ 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'A')) = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 9 \"PAAPPAPPP\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 5 \"PAAAA\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 8 \"PPPPPPPP\""}
{"id": "fvapps_000867", "vc-description": "", "vc-preamble": "def list_max : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (list_max xs)\n\ndef iterate_steps (i j steps : Nat) : Nat × Nat :=\n  match steps with\n  | 0 => (i, j)\n  | n+1 =>\n    let (cur_i, cur_j) := iterate_steps i j n\n    if cur_i ≤ cur_j then\n      (cur_i + cur_j, cur_j)\n    else\n      (cur_i, cur_j + cur_i)", "vc-helpers": "", "vc-definitions": "def find_min_steps (i j : Nat) (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_min_steps_nonnegative {i j : Nat} {nums : List Nat} :\n  find_min_steps i j nums ≥ 0 :=\nsorry\n\ntheorem find_min_steps_monotonic {i j target : Nat} (hi : i > 1) (hj : j > 1) :\n  find_min_steps i j [target] ≤ find_min_steps (i-1) (j-1) [target] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 1 2 [5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_steps 2 2 [3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_steps 1 1 [3, 4, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 2 1 [5]"}
{"id": "fvapps_000878", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n-- Not vertical\n\n-- Avoid division by zero", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Float) : Float :=\nsorry\n\ndef IsFinite (x : Float) : Prop := sorry\n\ndef find_mirror_position (x1 y1 x2 y2 : Float) : Float :=\n  sorry", "vc-theorems": "theorem valid_mirror_position_basic_properties\n  (x1 y1 x2 y2 : Float)\n  (h1 : abs (x2 - x1) > 1e-6)\n  (h2 : abs (y2 + y1) > 1e-6)\n  : IsFinite (find_mirror_position x1 y1 x2 y2) := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000879", "vc-description": "", "vc-preamble": "def max : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (max xs)", "vc-helpers": "", "vc-definitions": "def sum : List Nat → Nat\n| [] => 0\n| (x::xs) => x + sum xs\n\ndef can_cyborg_escape (n : Nat) (target : Nat) (powers : List Nat) : Bool :=\nsorry\n\ndef reverse : List Nat → List Nat :=\nsorry", "vc-theorems": "theorem target_less_than_max_always_possible\n  (powers : List Nat) (target : Nat) (h1 : powers ≠ []) :\n  target ≤ max powers → can_cyborg_escape (powers.length) target powers = true := by\nsorry\n\ntheorem target_greater_than_sum_impossible\n  (powers : List Nat) (extra : Nat) (h1 : powers ≠ []) :\n  let target := sum powers + extra + 1\n  can_cyborg_escape (powers.length) target powers = false := by\nsorry\n\ntheorem symmetric_input\n  (powers : List Nat) (h1 : powers ≠ []) :\n  let target := sum powers / 2\n  can_cyborg_escape (powers.length) target powers =\n    can_cyborg_escape (powers.length) target (reverse powers) := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 4 8 [5, 1, 4, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 3 4 [3, 1, 2]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_cyborg_escape 2 7 [5, 5]"}
{"id": "fvapps_000882", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_valid_snake_procession (report : String) : String :=\nsorry\n\ndef is_valid_segment (s₁ s₂ : Char) : Bool :=\nsorry", "vc-theorems": "theorem valid_snake_formations (report : String) :\n  (∀ i j : String.Pos, j.1 = i.1 + 1 →\n    (report.get i = '.' ∨ (report.get i = 'H' ∧ report.get j = 'T'))) →\n  check_valid_snake_procession report = \"Valid\" :=\nsorry\n\ntheorem balanced_counts_if_valid (report : String) :\n  check_valid_snake_procession report = \"Valid\" →\n  let h_count := report.toList.filter (· = 'H') |>.length\n  let t_count := report.toList.filter (· = 'T') |>.length\n  h_count = t_count :=\nsorry\n\ntheorem running_count_bounds_if_valid (report : String) (n : Nat) :\n  check_valid_snake_procession report = \"Valid\" →\n  n ≤ report.length →\n  let h_count := (report.take n).toList.filter (· = 'H') |>.length\n  let t_count := (report.take n).toList.filter (· = 'T') |>.length\n  let count := h_count - t_count\n  count ≥ 0 ∧ count ≤ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"..H..T...HTH....T.\"\n\n/-\ninfo: 'Invalid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"H..H..T..T\"\n\n/-\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"HT\""}
{"id": "fvapps_000887", "vc-description": "-- Helper functions for max/min\n\n-- Non-negative result\n\n-- Evenly spaced points\n\n-- Result bounded by max distance\n\n-- Special case for k=2\n\n-- Sorting invariance\n\n-- Evenly spaced integers\n\n-- simplified for theorem statement", "vc-preamble": "def listMax (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => List.foldl max h t\n\ndef listMin (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => List.foldl min h t\n\ndef listToSorted (xs : List Int) : List Int :=\n  match xs with\n  | [] => []\n  | (h::t) => h :: t\n\ndef generateRange (n : Nat) : List Int :=\n  List.map Int.ofNat (List.range n)", "vc-helpers": "", "vc-definitions": "def find_max_min_distance (n k : Nat) (x : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_min_distance_nonneg\n    {n k : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n)\n    (h4 : x.length = n)\n    (h5 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x ≥ 0 :=\nsorry\n\ntheorem find_max_min_distance_bounded\n    {n k : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n)\n    (h4 : x.length = n)\n    (h5 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x ≤ listMax x - listMin x :=\nsorry\n\ntheorem find_max_min_distance_k2\n    {n : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : x.length = n)\n    (h3 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x ≤ listMax x - listMin x :=\nsorry\n\ntheorem find_max_min_distance_sort_invariant\n    {n : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : x.length = n)\n    (h3 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x = find_max_min_distance n 2 (listToSorted x) :=\nsorry\n\ntheorem find_max_min_distance_evenly_spaced\n    {n k : Nat}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n) :\n    find_max_min_distance n k (generateRange n) = (n-1) / (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_min_distance 2 2 [1, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 5 3 [1, 2, 8, 4, 9]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 4 2 [1, 2, 3, 4]"}
{"id": "fvapps_000888", "vc-description": "", "vc-preamble": "def fst_minus (a b : Nat) : Nat :=\n  if a ≥ b then a - b else b - a", "vc-helpers": "", "vc-definitions": "def abs (n : Nat) : Nat :=\nsorry\n\ndef list_sum (l : List Nat) : Nat :=\nsorry\n\ndef min_delivery_time (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem min_delivery_time_non_negative (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) :\n  min_delivery_time n m k deliveries ≥ 0 :=\nsorry\n\ntheorem min_delivery_time_same_point (n : Nat) :\n  let m := n\n  let deliveries := [(1,1,1,1)]\n  min_delivery_time n m 1 deliveries = 0 :=\nsorry\n\ntheorem min_delivery_time_bounded (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) :\n  min_delivery_time n m k deliveries ≤\n    list_sum (deliveries.map (fun (d: Nat × Nat × Nat × Nat) =>\n      let (x1, y1, x2, y2) := d\n      2 * (fst_minus x1 x2 + fst_minus y1 y2))) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_delivery_time 5 4 3 [[2, 3, 4, 1], [1, 4, 5, 2], [3, 3, 5, 3]]\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval min_delivery_time 10 2 3 [[1, 2, 10, 2], [2, 1, 9, 1], [4, 1, 7, 1]]"}
{"id": "fvapps_000891", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_min_pairs (n : Nat) (k : Int) (arr : List Int) : Int × Nat :=\n  sorry\n\ndef count_pairs_with_diff (arr : List Int) (k : Int) (min_diff : Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_min_pairs_nonneg_diff (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  min_diff ≥ 0 := by\n  sorry\n\ntheorem solve_min_pairs_positive_count (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (_, count) := solve_min_pairs n k arr\n  count > 0 := by\n  sorry\n\ntheorem solve_min_pairs_count_accurate (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, count) := solve_min_pairs n k arr\n  count_pairs_with_diff arr k min_diff = count := by\n  sorry\n\ntheorem solve_min_pairs_minimal (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  ∀ i j, 0 ≤ i ∧ i < n ∧ j > i ∧ j < n →\n    let diff := arr[i]! + arr[j]! - k\n    if diff ≥ 0 then diff ≥ min_diff else -diff ≥ min_diff := by\n  sorry\n\ntheorem solve_min_pairs_permutation_invariant (n : Nat) (k : Int) (arr1 arr2 : List Int)\n  (h1: n ≥ 2) (h2: arr1.length = n) (h3: arr2.length = n)\n  (h4: arr2.Perm arr1) :\n  solve_min_pairs n k arr1 = solve_min_pairs n k arr2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: (1, 4)\n-/\n#guard_msgs in\n#eval solve_min_pairs 4 9 [4, 4, 2, 6]\n\n/-\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_min_pairs 2 10 [3, 5]\n\n/-\ninfo: (4, 3)\n-/\n#guard_msgs in\n#eval solve_min_pairs 3 12 [4, 4, 4]"}
{"id": "fvapps_000902", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_bulb_fluctuations (n: Nat) : Nat :=\n  sorry\n\ndef sqrt (n: Nat) : Nat :=\n  sorry\n\ndef countSquaresNotDiv3 (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_non_negative (n: Nat) :\n  solve_bulb_fluctuations n ≥ 0 :=\nsorry\n\ntheorem output_less_than_input (n: Nat) :\n  solve_bulb_fluctuations n ≤ n :=\nsorry\n\ntheorem matches_edge_cases_0 :\n  solve_bulb_fluctuations 0 = 0 :=\nsorry\n\ntheorem matches_edge_cases_1 :\n  solve_bulb_fluctuations 1 = 1 :=\nsorry\n\ntheorem matches_edge_cases_2 :\n  solve_bulb_fluctuations 2 = 1 :=\nsorry\n\ntheorem matches_edge_cases_3 :\n  solve_bulb_fluctuations 3 = 1 :=\nsorry\n\ntheorem matches_edge_cases_9 :\n  solve_bulb_fluctuations 9 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 20\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 100"}
{"id": "fvapps_000904", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_pattern (n : Nat) : List (List Nat) :=\n  sorry\n\ndef sumRange (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem triangle_numbers (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  ∀ i, i < n → (pattern.get! i).get! 0 = sumRange 1 (i+2) :=\nsorry\n\ntheorem pattern_differences (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  ∀ i j, i < n → j + 1 < (pattern.get! i).length →\n    let row := pattern.get! i\n    let diff := row.get! (j+1) - row.get! j\n    if j + i + 1 < n\n      then diff = j + i + 1\n      else diff = 2*n - (j + i + 1) - 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000923", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Building := Int × Int × Int × Int\n\ndef av (buildings : List Building) : Int :=\n  sorry\n\ndef val (buildings : List Building) : Int :=\n  sorry\n\ndef diff (l1 l2 : List Building) : List Building :=\n  sorry", "vc-theorems": "theorem av_nonnegative (buildings : List Building) :\n  av buildings ≥ 0 :=\nsorry\n\ntheorem val_nonnegative (buildings : List Building) :\n  val buildings ≥ 0 :=\nsorry\n\ntheorem av_sum_fourth (buildings : List Building) :\n  av buildings = buildings.foldl (λ acc b => acc + b.2.2.2) 0 :=\nsorry\n\ntheorem val_sum_third (buildings : List Building) :\n  val buildings = buildings.foldl (λ acc b => acc + b.2.2.1) 0 :=\nsorry\n\ntheorem diff_properties (l1 l2 : List Building) :\n  ∀ x ∈ diff l1 l2, x ∈ l1 ∧ x ∉ l2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000928", "vc-description": "/- Helper function to get the minimum value from a list -/\n\n/- Helper function to get the maximum value from a list -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def list_max (xs : List Float) : Float :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl max x\n\ndef list_min (xs : List Float) : Float :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl min x", "vc-helpers": "", "vc-definitions": "def Point := Float × Float\n\ndef calc_expected_area (n: Nat) (vertices: List Point) : Float :=\n  sorry", "vc-theorems": "theorem area_is_non_negative {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  calc_expected_area n vertices ≥ 0 :=\nsorry\n\ntheorem area_smaller_than_bounding_box {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  let xs := vertices.map (·.1)\n  let ys := vertices.map (·.2)\n  calc_expected_area n vertices ≤ (list_max xs - list_min xs) * (list_max ys - list_min ys) + 1e-10 :=\nsorry\n\ntheorem area_invariant_under_translation {n: Nat} {vertices: List Point}\n  {dx dy: Float} :\n  vertices.length = n → n ≥ 3 →\n  let translated := vertices.map (fun (x, y) => (x + dx, y + dy))\n  (calc_expected_area n vertices - calc_expected_area n translated).abs < 1e-10 :=\nsorry\n\ntheorem area_scales_quadratically {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  let scaled := vertices.map (fun (x, y) => (2*x, 2*y))\n  (calc_expected_area n scaled - 4 * calc_expected_area n vertices).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000939", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_path_costs (n: Nat) (parents: List Nat) (values: List Nat) : List Nat :=\n  sorry\n\ndef is_valid_tree (n: Nat) (parents: List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem output_length_matches_input\n  (n: Nat) (values: List Nat) (parents: List Nat) :\n  (n > 0) →\n  (n > values.length → True) →\n  (parents = List.replicate (n-1) 1) →\n  (calculate_path_costs n parents (values.take n)).length = n :=\nsorry\n\ntheorem path_costs_increase_with_depth\n  (n: Nat) (parent_nodes: List Nat) (values: List Nat) :\n  (n ≥ 2) →\n  (parent_nodes.length = n-1) →\n  (values.length ≥ n) →\n  (is_valid_tree n parent_nodes = true) →\n  ∀ i, i ≥ 1 → i < n →\n    let result := calculate_path_costs n parent_nodes (values.take n)\n    result.length = n →\n    (i-1) < parent_nodes.length →\n    parent_nodes[i-1]! - 1 < result.length →\n    result[i]! ≥ result[parent_nodes[i-1]! - 1]! :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000943", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.maximum (l : List Int) : Int :=\nsorry\n\ndef List.minimum (l : List Int) : Int :=\nsorry\n\ndef List.sort (l : List Int) : List Int :=\nsorry\n\ndef find_min_height_diff (n : Nat) (k : Nat) (heights : List Int) : Int :=\nsorry", "vc-theorems": "theorem find_min_height_diff_single_window {n : Nat} {heights : List Int}\n  (h1 : heights.length > 0)\n  (h2 : heights.length = n)\n  : find_min_height_diff n 1 heights = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_height_diff 5 3 [10, 15, 11, 14, 12]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_height_diff 4 2 [4, 2, 1, 3]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval find_min_height_diff 6 4 [5, 10, 15, 20, 25, 30]"}
{"id": "fvapps_000944", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_diff (N : Nat) (K : Nat) (arr : List Int) : Int :=\nsorry\n\ndef list_max (arr : List Int) : Int :=\nsorry\n\ndef list_min (arr : List Int) : Int :=\nsorry\n\ndef list_sort (arr : List Int) : List Int :=\nsorry", "vc-theorems": "theorem find_max_diff_non_negative (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr ≥ 0 :=\nsorry\n\ntheorem find_max_diff_reverse_invariant (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr = find_max_diff N K arr.reverse :=\nsorry\n\ntheorem find_max_diff_single_element (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length = 1) :\n  find_max_diff N K arr = 2 * K :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_diff 4 3 [4, 2, 5, 1]\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval find_max_diff 3 5 [2, 5, 3]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_diff 2 2 [1, 3]"}
{"id": "fvapps_000952", "vc-description": "-- Result is non-negative\n\n-- Result is at most the range of skills\n\n-- Result is at most any adjacent difference in sorted elements\n\n-- Result is invariant under list reordering\n\n-- n must match list length", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_horse_skill_diff (n : Nat) (skills : List Nat) : Nat :=\nsorry\n\ndef list_max (l : List Nat) : Nat :=\nsorry\n\ndef list_min (l : List Nat) : Nat :=\nsorry\n\ndef list_sort (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_horse_skill_diff_nonneg {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) :\n  min_horse_skill_diff n skills ≥ 0 :=\nsorry\n\ntheorem min_horse_skill_diff_le_range {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) :\n  min_horse_skill_diff n skills ≤ list_max skills - list_min skills :=\nsorry\n\ntheorem min_horse_skill_diff_le_adjacent {n : Nat} {skills : List Nat} {i : Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) (h3 : i < skills.length - 1) :\n  min_horse_skill_diff n skills ≤\n    (list_sort skills).get! (i+1) - (list_sort skills).get! i :=\nsorry\n\ntheorem min_horse_skill_diff_order_inv {n : Nat} {skills shuffled : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2)\n  (h3 : list_sort skills = list_sort shuffled) :\n  min_horse_skill_diff n skills = min_horse_skill_diff n shuffled :=\nsorry\n\ntheorem min_horse_skill_diff_invalid {n : Nat} {skills : List Nat}\n  (h : skills.length ≠ n) :\n  min_horse_skill_diff n skills = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 5 [4, 9, 1, 32, 13]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 3 [4, 5, 6]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 4 [1, 10, 100, 1000]"}
{"id": "fvapps_000956", "vc-description": "", "vc-preamble": "def powers_of_two : List Nat :=\n  let rec mk_powers : Nat → List Nat\n    | 0 => []\n    | n+1 => if (2^n ≤ 1000) then (2^n)::(mk_powers n) else mk_powers n\n  mk_powers 10", "vc-helpers": "", "vc-definitions": "def find_longest_dividing_subsequence (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem length_bounds {nums: List Nat}\n  (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n  (h2: nums.length > 0) :\n  1 ≤ find_longest_dividing_subsequence nums ∧\n  find_longest_dividing_subsequence nums ≤ nums.length :=\nsorry\n\ntheorem powers_of_two_sequence :\n  find_longest_dividing_subsequence powers_of_two = powers_of_two.length :=\nsorry\n\ntheorem sorted_divisible_sequence {nums: List Nat}\n  (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n  (h2: nums.length ≥ 2)\n  (h3: ∀ (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val → (nums.get j) % (nums.get i) = 0)\n  (h4: ∀ (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val → nums.get i ≤ nums.get j) :\n  find_longest_dividing_subsequence nums = nums.length :=\nsorry\n\ntheorem edge_case_singleton :\n  find_longest_dividing_subsequence [1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 3, 7, 8, 14, 39, 145, 76, 320]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 11, 16, 12, 36, 60, 71, 17, 29, 144, 288, 129, 432, 993]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [1, 2, 4, 8]"}
{"id": "fvapps_000963", "vc-description": "/- Signature for the main function -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidPolygon (vertices: List (Int × Int)) : Bool :=\nsorry\n\ndef calculateMinCost (vertices: List (Int × Int)) (stripes: List (Float × Int)) : Nat :=\nsorry", "vc-theorems": "theorem min_cost_positive (vertices: List (Int × Int)) (stripes: List (Float × Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  calculateMinCost vertices stripes > 0 :=\nsorry\n\ntheorem min_cost_integer (vertices: List (Int × Int)) (stripes: List (Float × Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  ∃ n: Nat, calculateMinCost vertices stripes = n :=\nsorry\n\ntheorem empty_stripes_error (vertices: List (Int × Int))\n  (h1: isValidPolygon vertices = true) :\n  ∀ result, calculateMinCost vertices [] ≠ result :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (1000, 0), (1000, 2000), (0, 2000)] [(1000, 10), (2000, 15)]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (4, 0), (2, 3)] [(5, 2)]"}
{"id": "fvapps_000967", "vc-description": "", "vc-preamble": "def get_max_leads (rounds : List (Nat × Nat)) : Nat × Nat :=\n  rounds.foldl (fun acc r =>\n    let p1Total := acc.1 + r.1\n    let p2Total := acc.2 + r.2\n    if p1Total > p2Total\n    then (p1Total - p2Total, acc.2)\n    else (acc.1, p2Total - p1Total)\n  ) (0, 0)", "vc-helpers": "", "vc-definitions": "def find_winner_and_max_lead (rounds : List (Nat × Nat)) : Nat × Nat :=\nsorry", "vc-theorems": "theorem winner_is_valid (rounds : List (Nat × Nat)) :\n  let (winner, _) := find_winner_and_max_lead rounds\n  winner = 1 ∨ winner = 2 :=\nsorry\n\ntheorem max_lead_nonnegative (rounds : List (Nat × Nat)) :\n  let (_, maxLead) := find_winner_and_max_lead rounds\n  maxLead ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (1, 58)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(140, 82), (89, 134), (90, 110), (112, 106), (88, 90)]\n\n/-\ninfo: (1, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(10, 5), (20, 15), (30, 25)]\n\n/-\ninfo: (2, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(5, 10), (15, 20), (25, 30)]"}
{"id": "fvapps_000973", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_chakra_needed (n m : Nat) (soint_powers soint_levels sofloat_powers sofloat_levels : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_chakra_cases :\n  (min_chakra_needed 1 1 [10] [1] [5] [1] = 0) ∧\n  (min_chakra_needed 2 2 [10, 20] [1, 2] [5, 15] [1, 2] = 0) ∧\n  (min_chakra_needed 2 3 [10, 20] [1, 2] [5, 5, 18] [2, 2, 1] = 8) ∧\n  (min_chakra_needed 2 2 [10, 10] [1, 1] [20, 20] [1, 1] = 20) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000976", "vc-description": "", "vc-preamble": "def List.firstElem (l : List Nat) (h : l.length > 0) : Nat :=\n  match l with\n  | [] => by contradiction\n  | x::_ => x", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef find_largest_gcd_1_subarray (arr : List Nat) : Int :=\n  sorry\n\ndef reduce_gcd (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_one_returns_full_length {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 1)\n    (h3 : reduce_gcd arr = 1) :\n  find_largest_gcd_1_subarray arr = arr.length :=\nsorry\n\ntheorem non_gcd_one_returns_negative {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 1)\n    (h3 : reduce_gcd arr > 1) :\n  find_largest_gcd_1_subarray arr = -1 :=\nsorry\n\ntheorem return_bounds {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 2) :\n  find_largest_gcd_1_subarray arr = -1 ∨\n  (1 ≤ find_largest_gcd_1_subarray arr ∧ find_largest_gcd_1_subarray arr ≤ arr.length) :=\nsorry\n\ntheorem same_elements_no_gcd_one {arr : List Nat} (h1 : arr.length ≥ 2)\n    (h2 : ∀ x ∈ arr, ∀ y ∈ arr, x = y) :\n  ∀ x ∈ arr, x ≠ 1 → find_largest_gcd_1_subarray arr = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [7, 2]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [2, 2, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [6, 10, 15, 25]"}
{"id": "fvapps_000977", "vc-description": "", "vc-preamble": "def triangular_num (n : Nat) : Nat :=\nn * (n + 1) / 2", "vc-helpers": "", "vc-definitions": "def solve_disjoint_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_disjoint_subarrays_output_bounds {n : Nat} {arr : List Nat}\n  (hn : n > 0)\n  (harr_size : arr.length = n)\n  (harr_bounds : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 1000) :\n  let result := solve_disjoint_subarrays n arr\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem solve_disjoint_subarrays_singleton {arr : List Nat}\n  (hsingle : arr.length = 1)\n  (hbound : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10) :\n  solve_disjoint_subarrays 1 arr = 1 :=\nsorry\n\ntheorem solve_disjoint_subarrays_all_equal {n : Nat} {arr : List Nat}\n  (hn : n > 1)\n  (harr_size : arr.length = n)\n  (harr_bounds : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10)\n  (hall_equal : ∀ x ∈ arr, x = arr.head!) :\n  solve_disjoint_subarrays n arr = (triangular_num n) * (triangular_num n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 2 [3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 3 [1, 2, 2]\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 5 [1, 1, 2, 2, 2]"}
{"id": "fvapps_000979", "vc-description": "/- The output is a natural number between 0 and n-k -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- A pattern matches against itself at least once -/\n\n/- Basic cases work correctly -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_running_patterns (n : Nat) (k : Nat) (distances : List Nat) (recorded : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_running_patterns_bounds (n k : Nat) (distances recorded : List Nat)\n    (hn : n ≥ 2) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)\n    (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j)\n    (hrec : recorded.length = k) :\n    let result := solve_running_patterns n k distances recorded\n    0 ≤ result ∧ result ≤ n - k :=\nsorry\n\ntheorem solve_running_patterns_self_match (n k : Nat) (distances : List Nat)\n    (hn : n ≥ 3) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)\n    (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j) :\n    let diffs := List.zipWith (fun x y => x - y) (distances.drop 1) distances\n    let pattern := List.take k diffs\n    solve_running_patterns n k distances pattern ≥ 1 :=\nsorry\n\ntheorem solve_running_patterns_basic_cases :\n    solve_running_patterns 2 1 [1,2] [1] = 1 ∧\n    solve_running_patterns 3 1 [1,2,3] [1] = 2 :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 1 [1, 5, 10, 12, 14] [5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 2 [5, 8, 13, 16, 21] [3, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 3 [2, 6, 8, 11, 16] [2, 3, 5]"}
{"id": "fvapps_000980", "vc-description": "", "vc-preamble": "inductive MessageType where\n  | chef\n  | brother\n  | both\n  | none\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def isUpper (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry\n\ndef countUpper (s : String) : Nat :=\nsorry\n\ndef countLower (s : String) : Nat :=\nsorry\n\ndef classify_message (N : Nat) (K : Nat) (s : String) : MessageType :=\nsorry", "vc-theorems": "theorem classify_message_properties {N K : Nat} {s : String} :\n  let upper := countUpper s\n  let lower := countLower s\n  match classify_message N K s with\n  | MessageType.chef => lower > K ∧ upper ≤ K\n  | MessageType.brother => upper > K ∧ lower ≤ K\n  | MessageType.both => upper ≤ K ∧ lower ≤ K\n  | MessageType.none => upper > K ∧ lower > K\n  :=\nsorry\n\ntheorem all_upper {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'A')) = MessageType.brother :=\nsorry\n\ntheorem all_lower {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'a')) = MessageType.chef :=\nsorry\n\ntheorem empty_k_large {N : Nat} (h : N > 1) {s : String} :\n  classify_message N 0 s = MessageType.none :=\nsorry\n\ntheorem empty_k_small {N : Nat} (h : N = 1) {s : String} :\n  classify_message N 0 s ≠ MessageType.none :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'chef'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"frauD\"\n\n/-\ninfo: 'brother'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"FRAUD\"\n\n/-\ninfo: 'both'\n-/\n#guard_msgs in\n#eval classify_message 4 4 \"Life\""}
{"id": "fvapps_000981", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_nice (s: List Char) : Bool :=\n  sorry\n\ndef count_nice_strings (s: List Char) : Nat :=\n  sorry", "vc-theorems": "theorem count_nice_strings_non_negative (s: List Char) :\n  count_nice_strings s ≥ 0 :=\nsorry\n\ntheorem count_nice_strings_upper_bound (s: List Char) :\n  count_nice_strings s ≤ (s.length * (s.length + 1)) / 2 :=\nsorry\n\ntheorem empty_string_has_zero_nice (s: List Char) :\n  s.length = 0 → count_nice_strings s = 0 :=\nsorry\n\ntheorem is_nice_min_length (s: List Char) :\n  is_nice s → s.length ≥ 2 :=\nsorry\n\ntheorem small_strings_not_nice (s: List Char) :\n  s.length ≤ 1 → ¬(is_nice s) :=\nsorry\n\ntheorem nice_string_conditions (s: List Char) (i: Nat) :\n  is_nice s →\n  (∀ i, i < s.length → s.get! 0 = s.get! i) ∨\n  (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) > Char.toNat (s.get! (i-1))) ∨\n  (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) < Char.toNat (s.get! (i-1))) :=\nsorry\n\ntheorem nice_string_has_nice_count (s: List Char) :\n  s.length ≥ 2 →\n  is_nice s →\n  count_nice_strings s ≥ 1 :=\nsorry\n\ntheorem count_matches_actual_nice (s: List Char) :\n  count_nice_strings s =\n    (List.foldl (fun acc i =>\n      acc + List.foldl (fun inner_acc j =>\n        if is_nice (List.take (j + 1) (List.drop i s))\n        then inner_acc + 1\n        else inner_acc)\n      0 (List.range (s.length - i)))\n    0 (List.range s.length)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"aaa\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abc\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abbc\""}
{"id": "fvapps_000994", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def countChanges (arr : List Nat) : Nat :=\n  let indices := List.range (arr.length - 1)\n  indices.foldl (fun acc i =>\n    if h : i < arr.length ∧ i + 1 < arr.length then\n      if arr[i]'h.left ≠ arr[i+1]'h.right then\n        acc + 1\n      else acc\n    else acc) 0", "vc-helpers": "", "vc-definitions": "def find_sequence (arr : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem find_sequence_non_negative (arr : List Nat) :\n  ∀ x ∈ find_sequence arr, x ≥ 0 :=\nsorry\n\ntheorem find_sequence_trailing_zero (arr : List Nat) :\n  arr.length > 0 → arr.getLast! = 0 →\n  (find_sequence arr).getLast! = 0 :=\nsorry\n\ntheorem find_sequence_run_lengths (arr : List Nat) (pos : Nat) (h : pos < arr.length) :\n  let val := arr[pos]'h\n  let run_length := (find_sequence arr).get! pos\n  ∃ actual_count : Nat,\n    (∀ i, pos ≤ i ∧ i < pos + actual_count →\n      ∃ h' : i < arr.length, arr[i]'h' = val) ∧\n    (val = 0 ∧ pos + actual_count = arr.length → run_length = 0) ∧\n    (¬(val = 0 ∧ pos + actual_count = arr.length) → run_length = actual_count) :=\nsorry\n\ntheorem find_sequence_length (arr : List Nat) :\n  arr.length > 0 →\n  (find_sequence arr).length = 1 + countChanges arr :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000997", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def power (x y : Nat) : Nat :=\n  sorry\n\ndef order (x : Nat) : Nat :=\n  sorry\n\ndef is_armstrong (x : Nat) : String :=\n  sorry\n\ndef check_numbers (numbers : List Nat) : List String :=\n  sorry", "vc-theorems": "theorem power_properties (x : Nat) (y : Nat) :\n  (y = 0 → power x y = 1) ∧\n  (y = 1 → power x y = x) ∧\n  (y = 2 → power x y = x * x) :=\nsorry\n\ntheorem order_properties (x : Nat) :\n  (x = 0 → order x = 0) ∧\n  (0 < x ∧ x < 10 → order x = 1) ∧\n  (10 ≤ x ∧ x < 100 → order x = 2) :=\nsorry\n\ntheorem is_armstrong_properties (x : Nat) :\n  (x < 10 → is_armstrong x = \"FEELS GOOD\") ∧\n  (is_armstrong x = \"FEELS GOOD\" ∨ is_armstrong x = \"FEELS BAD\") :=\nsorry\n\ntheorem check_numbers_properties (numbers : List Nat) :\n  (numbers = [] → check_numbers numbers = []) ∧\n  (List.length (check_numbers numbers) = List.length numbers) ∧\n  (∀ x ∈ check_numbers numbers, x = \"FEELS GOOD\" ∨ x = \"FEELS BAD\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['FEELS GOOD', 'FEELS BAD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [153, 11, 1634]\n\n/-\ninfo: ['FEELS GOOD', 'FEELS GOOD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [370, 371, 407]\n\n/-\ninfo: ['FEELS BAD', 'FEELS BAD', 'FEELS BAD']\n-/\n#guard_msgs in\n#eval check_numbers [123, 555, 999]"}
{"id": "fvapps_001000", "vc-description": "-- Positive sides\n\n-- Height matches\n\n-- Area matches\n\n-- Ordered sides\n\n-- Simplified String validation since we lack string manipulation operations\n\n-- Triangle inequality", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_triangle (h : Int) (s : Int) : Int × Int × Int :=\n  sorry\n\ndef format_output (triangle : Int × Int × Int) : String :=\n  sorry", "vc-theorems": "theorem find_triangle_valid_output {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000000) (s_bound : s ≤ 1000000) :\n  let (a, b, c) := find_triangle h s\n  if a ≠ -1 then\n    a > 0 ∧ b > 0 ∧ c > 0 ∧\n    c = h ∧\n    a * b / 2 = s ∧\n    a ≤ b\n  else True :=\nsorry\n\ntheorem format_output_valid {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000000) (s_bound : s ≤ 1000000) :\n  let result := format_output (find_triangle h s)\n  if result ≠ \"-1\" then\n\n    result.length > 0\n  else True :=\nsorry\n\ntheorem triangle_inequality {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000) (s_bound : s ≤ 1000) :\n  let (a, b, c) := find_triangle h s\n  if a ≠ -1 then\n    a + b > c ∧ b + c > a ∧ a + c > b\n  else True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '3.000000 4.000000 5.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(5, 6)\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval format_output find_triangle(6, 10)\n\n/-\ninfo: '285168.817674 546189.769984 616153.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(616153, 77878145466)"}
{"id": "fvapps_001007", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_crowds (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_crowds_nonnegative (n : Nat) :\n  solve_crowds n ≥ 0 ∧ solve_crowds n < MOD :=\nsorry\n\ntheorem solve_crowds_small_n (n : Nat) (h : n ≤ 2) :\n  solve_crowds n = 0 :=\nsorry\n\ntheorem solve_crowds_upper_bound (n : Nat) (h : n ≥ 3) :\n  solve_crowds n < 2^n :=\nsorry\n\ntheorem solve_crowds_known_values_3 :\n  solve_crowds 3 = 1 :=\nsorry\n\ntheorem solve_crowds_known_values_4 :\n  solve_crowds 4 = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_crowds 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_crowds 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_crowds 2"}
{"id": "fvapps_001014", "vc-description": "", "vc-preamble": "def MOD := 1000000007\n\ndef isVowel (c : Char) : Bool :=\n  match c.toLower with\n  | 'a' | 'e' | 'i' | 'o' | 'u' => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def solveBinaryNames (name : String) : Nat :=\n  sorry", "vc-theorems": "theorem binary_names_result_range\n  (name : String)\n  (h : ∃ c ∈ name.data, c.isAlpha) :\n  0 ≤ solveBinaryNames name ∧ solveBinaryNames name < MOD :=\nsorry\n\ntheorem only_letters_matter\n  (name : String)\n  (h : ∃ c ∈ name.data, c.isAlpha) :\n  solveBinaryNames name = solveBinaryNames (String.mk (name.data.filter Char.isAlpha)) :=\nsorry\n\ntheorem all_vowels_zero\n  (name : String)\n  (h₁ : name.length > 0)\n  (h₂ : ∀ c ∈ name.data, isVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :=\nsorry\n\ntheorem all_consonants_one\n  (name : String)\n  (h₁ : name.length > 0)\n  (h₂ : ∀ c ∈ name.data, c.isAlpha ∧ ¬isVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 173\n-/\n#guard_msgs in\n#eval solve_binary_names \"codechef\""}
{"id": "fvapps_001018", "vc-description": "", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0\n\ndef allEqual (l : List Nat) : Prop :=\n  ∀ x y, x ∈ l → y ∈ l → x = y\n\ndef uniqueCount (l : List Nat) : Nat :=\n  (l.eraseDups).length", "vc-helpers": "", "vc-definitions": "def find_max_distinct_subarray_sum (n k : Nat) (arr : List Nat) : Int :=\n  sorry", "vc-theorems": "theorem max_distinct_subarray_sum_within_bounds\n  {n k : Nat} {arr : List Nat} (h1 : k ≤ n) (h2 : n = arr.length)\n  (h3 : ∀ x, x ∈ arr → 1 ≤ x ∧ x ≤ 100) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 ∨\n  result ≤ (List.range (n - k + 1)).foldl (fun acc i =>\n    max acc (sum ((arr.take (i + k)).drop i))) 0 :=\nsorry\n\ntheorem identical_elements_sum_first_k\n  {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n) (h2 : n = arr.length)\n  (h3 : allEqual arr) (h4 : ∀ x, x ∈ arr → x > 0) :\n  find_max_distinct_subarray_sum n k arr = sum (arr.take k) :=\nsorry\n\ntheorem distinct_count_consistent\n  {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n) (h2 : n = arr.length) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 ∨\n  ∀ i, i + k ≤ n →\n    sum ((arr.take (i + k)).drop i) = result →\n    uniqueCount ((arr.take (i + k)).drop i) = uniqueCount arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 10 6 [8, 8, 3, 5, 3, 8, 5, 7, 7, 7]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 5 3 [1, 2, 1, 2, 3]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 4 2 [5, 5, 5, 5]"}
{"id": "fvapps_001019", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestValidPrefix (s : String) : Nat :=\n  sorry\n\ndef isValid (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_non_negative (s : String) :\n  longestValidPrefix s ≥ 0 :=\nsorry\n\ntheorem result_not_exceed_length (s : String) :\n  longestValidPrefix s ≤ String.length s :=\nsorry\n\ntheorem result_is_even (s : String) :\n  longestValidPrefix s % 2 = 0 :=\nsorry\n\ntheorem next_char_makes_invalid (s : String) :\n  longestValidPrefix s < String.length s →\n  let withNext := s.take (longestValidPrefix s + 1)\n  ¬isValid withNext :=\nsorry\n\ntheorem perfect_pairs_full_length (n : Nat) :\n  let s := String.mk (List.append (List.replicate n '<') (List.replicate n '>'))\n  longestValidPrefix s = 2 * n :=\nsorry\n\ntheorem empty_string_zero :\n  longestValidPrefix \"\" = 0 :=\nsorry\n\ntheorem single_right_zero :\n  longestValidPrefix \">\" = 0 :=\nsorry\n\ntheorem single_left_zero :\n  longestValidPrefix \"<\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<<>>\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"><\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<>>>\""}
{"id": "fvapps_001029", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def value (a b : Nat) (op : String) : Nat :=\n  sorry\n\ndef solve_expression (expr : String) : Nat :=\n  sorry", "vc-theorems": "theorem value_commutativity {a b : Nat} {op : String} (h : op = \"&\" ∨ op = \"|\") :\n  value a b op = value b a op := by\n  sorry\n\ntheorem value_nonnegativity {a b : Nat} {op : String} (h : op = \"&\" ∨ op = \"|\" ∨ op = \"^\") :\n  value a b op ≥ 0 := by\n  sorry\n\ntheorem solve_expr_type {expr : String} :\n  ∃ (n : Nat), solve_expression expr = n := by\n  sorry\n\ntheorem solve_expr_nonneg {expr : String} :\n  solve_expression expr ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 43\n-/\n#guard_msgs in\n#eval solve_expression \"3^40|10^2\"\n\n/-\ninfo: 95\n-/\n#guard_msgs in\n#eval solve_expression \"92^95|56&2&3\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_expression \"1&2|3\""}
{"id": "fvapps_001031", "vc-description": "/- For any list of test cases, the length of results matches the input length -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Each remainder in the result is correctly computed -/\n\n/- All remainders are non-negative and less than their divisors -/\n\n/- Division by one always yields zero remainder -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_remainders (cases : List String) : List Nat :=\nsorry", "vc-theorems": "theorem find_remainders_length (cases : List String) :\n  (find_remainders cases).length = cases.length :=\nsorry\n\ntheorem find_remainders_correct (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 →\n  find_remainders [test_case] = [a % b] :=\nsorry\n\ntheorem find_remainders_bounds (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 →\n  let r := (find_remainders [test_case]).head!\n  0 ≤ r ∧ r < b :=\nsorry\n\ntheorem find_remainders_div_by_one (a : Nat) (h : a > 0) :\n  find_remainders [s!\"{a} 1\"] = [0] :=\nsorry", "vc-postamble": "/-\ninfo: [1, 100, 10]\n-/\n#guard_msgs in\n#eval find_remainders [\"1 2\", \"100 200\", \"40 15\"]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_remainders [\"7 3\"]\n\n/-\ninfo: [0, 3]\n-/\n#guard_msgs in\n#eval find_remainders [\"10 2\", \"15 4\"]"}
{"id": "fvapps_001032", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | (x::xs) => x + sum_list xs\n\ndef list_get (xs : List Nat) (i : Nat) : Option Nat :=\n  match xs, i with\n  | [], _ => none\n  | (x::_), 0 => some x\n  | (_::xs), n+1 => list_get xs n", "vc-helpers": "", "vc-definitions": "def make_grid (n m : Nat) (house_coords : List (Nat × Nat)) : List String :=\nsorry\n\ndef solve_house_distances (n m : Nat) (grid : List String) : List Nat :=\nsorry", "vc-theorems": "theorem house_distances_properties\n  (n m : Nat) (coords : List (Nat × Nat))\n  (h_n : n > 0) (h_m : m > 0)\n  (h_coords : coords.length ≥ 2)\n  (h_valid : ∀ (p : Nat × Nat), p ∈ coords → p.1 < n ∧ p.2 < m)\n  (h_unique : ∀ (p q : Nat × Nat), p ∈ coords → q ∈ coords → p = q ∨ p ≠ q) :\n  let result := solve_house_distances n m (make_grid n m coords);\n  let num_pairs := (coords.length * (coords.length - 1)) / 2;\n  result.length = n + m - 2 ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  sum_list result = num_pairs ∧\n  (sum_list result > 0 →\n   ∀ i x, i < result.length → list_get result i = some x → x > 0 → i + 1 ≥ 1) :=\nsorry\n\ntheorem minimal_case\n  (n m : Nat)\n  (h_n : n ≥ 2) (h_m : m ≥ 2) :\n  let corner_houses := [(0,0), (n-1,m-1)];\n  let result := solve_house_distances n m (make_grid n m corner_houses);\n  list_get result (n+m-3) = some 1 ∧\n  sum_list result = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001034", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_tile_count (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_non_negative_and_bounded (n : Nat) :\n  let result := solve_tile_count n\n  0 ≤ result ∧ result < MOD := by\n  sorry\n\ntheorem modulo_consistency (n : Nat) :\n  solve_tile_count n = solve_tile_count n % MOD := by\n  sorry\n\ntheorem base_cases_correct :\n  solve_tile_count 0 = 1 ∧\n  solve_tile_count 1 = 2 ∧\n  solve_tile_count 2 = 6 ∧\n  solve_tile_count 3 = 16 ∧\n  solve_tile_count 4 = 42 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_tile_count 2\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_tile_count 3\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval solve_tile_count 4"}
{"id": "fvapps_001038", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def process_bit_queries (x : Nat) (queries : List (List Nat)) : List String :=\nsorry\n\ndef countOnes (n : Nat) : Nat :=\nsorry\n\ndef drop {α} (n : Nat) (xs : List α) : List α :=\nsorry", "vc-theorems": "theorem binary_conversion_preserves_number (x : Nat) (h : x < 2^64) (pos : Nat)\n(h2 : pos > 0 ∧ pos < 64) :\n  process_bit_queries x [[1, pos]] =\n    [if x &&& (1 <<< (pos - 1)) ≠ 0 then \"ON\" else \"OFF\"] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001055", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_trimming (n : Nat) (parents : List Nat) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tree_trimming_bounds {n : Nat} {parents : List Nat}\n  (h1 : n ≥ 2) (h2 : is_valid_tree n parents = true) :\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem small_tree_optimum {n : Nat} {parents : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 3) (h3 : is_valid_tree n parents = true) :\n  solve_tree_trimming n parents = n :=\nsorry\n\ntheorem line_tree_bounds {n : Nat}\n  (h : n ≥ 2) :\n  let parents := List.range (n-1)\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem star_tree_bounds {n : Nat}\n  (h : n ≥ 2) :\n  let parents := List.replicate (n-1) 1\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_trimming 13 [1, 1, 1, 1, 1, 4, 3, 4, 4, 3, 4, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_trimming 3 [1, 1]"}
{"id": "fvapps_001064", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef alternating_elements : List Nat → List Nat\n  | [] => []\n  | [x] => [x]\n  | x::_::xs => x :: alternating_elements xs", "vc-helpers": "", "vc-definitions": "def max_stones_removed (n : Nat) (piles : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_stones_removed_identity (n : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n piles = max_stones_removed n piles :=\nsorry\n\ntheorem max_stones_removed_n_independent (n₁ n₂ : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n₁ piles = max_stones_removed n₂ piles :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval max_stones_removed 4 [4, 3, 2, 1]"}
{"id": "fvapps_001066", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def nc3 (n : Nat) : Nat :=\n  sorry\n\ndef solve (n : Nat) (c : Nat) (k : Nat) (lines : List (List Nat)) (v : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem nc3_nonnegative (n : Nat) :\n  nc3 n ≥ 0 :=\nsorry\n\ntheorem nc3_zero_for_small_n (n : Nat) :\n  n < 3 → nc3 n = 0 :=\nsorry\n\ntheorem nc3_formula (n : Nat) :\n  nc3 n = n * (n-1) * (n-2) / 6 :=\nsorry\n\ntheorem solve_nonnegative (n c k : Nat) (lines : List (List Nat)) (v : List Nat) :\n  solve n c k lines v ≥ 0 :=\nsorry\n\ntheorem solve_bounded_by_combinations\n  (n c k : Nat) (lines : List (List Nat)) (v : List Nat)\n  (validLines := List.filter (fun line => line.get! 2 ≤ c) lines) :\n  solve n c k lines v ≤ nc3 validLines.length :=\nsorry\n\ntheorem solve_empty :\n  solve 0 1 1 [] [1] = 0 :=\nsorry\n\ntheorem solve_minimal :\n  solve 1 1 1 [[0,0,1]] [1] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 7 2 13 [[1, 10, 1], [1, 14, 2], [6, 4, 1], [2, 2, 1], [0, 12, 2], [2, 11, 2], [0, 6, 1]] [8, 10]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 6 1 20 [[1, 5, 1], [2, 11, 1], [4, 0, 1], [6, 8, 1], [0, 11, 1], [3, 3, 1]] [9]"}
{"id": "fvapps_001069", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_cooking_time (n: Nat) (times: List Nat) : Nat :=\n  sorry\n\ndef list_maximum (l: List Nat) : Nat :=\n  sorry\n\ndef list_sorted_take (l: List Nat) (n: Nat) : List Nat :=\n  sorry\n\ndef list_sum (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_cooking_time_lower_bound_half_sum {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times ≥ (list_sum usedTimes) / 2 := by\n  sorry\n\ntheorem min_cooking_time_lower_bound_max {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  min_cooking_time n times ≥ list_maximum (times.take n) := by\n  sorry\n\ntheorem min_cooking_time_upper_bound_sum {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times ≤ list_sum usedTimes := by\n  sorry\n\ntheorem min_cooking_time_equal_times {n: Nat} (h1: 1 ≤ n) (h2: n ≤ 100) :\n  let times := List.replicate n 10\n  min_cooking_time n times = ((n + 1) / 2) * 10 := by\n  sorry\n\ntheorem min_cooking_time_single_item {times: List Nat} (h: times.length ≥ 1) :\n  min_cooking_time 1 times = list_maximum times := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [2, 2, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [1, 2, 3]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_cooking_time 4 [2, 3, 4, 5]"}
{"id": "fvapps_001071", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_goodness_sum (a b : Nat) : Nat :=\n  sorry\n\ndef MOD := 1000000007\n\ndef num_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem monotonic_increasing (n : Nat) (h : 1 < n) (h2 : n ≤ 10000) :\n  calculate_goodness_sum 1 (n-1) ≤ calculate_goodness_sum 1 n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 75\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 9 12\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 1 5\n\n/-\ninfo: 66\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 10 12"}
{"id": "fvapps_001078", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_path_profits (n: Nat) (values: List Nat) (edges: List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_valid_tree (n: Nat) (edges: List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem single_node_case (n: Nat) (values: List Nat) :\n  n = 1 → solve_max_path_profits n values [] = 0 := by\n  sorry\n\ntheorem valid_inputs_result_properties (n: Nat) (values: List Nat) (edges: List (Nat × Nat)) :\n  n ≥ 2 →\n  values.length ≥ n →\n  is_valid_tree n edges = true →\n  let result := solve_max_path_profits n values edges\n  (result ≥ 0 ∧ result ≤ 10^9 + 7) := by\n  sorry\n\ntheorem line_graph_properties (n: Nat) (values: List Nat) :\n  n ≥ 2 →\n  values.length ≥ n →\n  let edges := List.range (n-1) |>.map (fun i => (i+1, i+2))\n  let result := solve_max_path_profits n values edges\n  result ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval solve_max_path_profits 4 [1, 2, 3, 4] [(1, 2), (2, 3), (2, 4)]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval solve_max_path_profits 5 [1, 2, 3, 4, 5] [(1, 2), (2, 3), (3, 4), (4, 5)]"}
{"id": "fvapps_001081", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_operations_to_alternating (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef is_alternating (s : String) : Bool :=\n  sorry\n\ndef make_alternating_01 (n : Nat) : String :=\n  sorry\n\ndef make_alternating_10 (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem uniform_string_flips (n : Nat) (c : Char) :\n  let s := String.mk (List.replicate n c)\n  let ops := min_operations_to_alternating n s\n  ops = n/2 ∨ ops = (n+1)/2 :=\nsorry\n\ntheorem length_result_bounded (n : Nat) (s : String) :\n  s.length = n →\n  let ops := min_operations_to_alternating n s\n  0 ≤ ops ∧ ops ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1011\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1111\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 6 \"101010\""}
{"id": "fvapps_001085", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def seriesSumSolver (n : Nat) : String :=\nsorry\n\ndef squaredSum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem series_sum_solver_returns_valid_name (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 1000000) :\n    seriesSumSolver n = \"Ravi\" ∨ seriesSumSolver n = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_alternates (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 10000) :\n    (seriesSumSolver n = \"Ravi\" ↔ squaredSum n % 2 = 0) :=\nsorry\n\ntheorem series_sum_solver_consistent (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 1000000) :\n    seriesSumSolver n = seriesSumSolver n :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_1 :\n    seriesSumSolver 1 = \"Ravi\" ∨ seriesSumSolver 1 = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_2 :\n    seriesSumSolver 2 = \"Ravi\" ∨ seriesSumSolver 2 = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_3 :\n    seriesSumSolver 1000000 = \"Ravi\" ∨ seriesSumSolver 1000000 = \"Jhon\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Jhon'\n-/\n#guard_msgs in\n#eval series_sum_solver 2\n\n/-\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 3\n\n/-\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 4"}
{"id": "fvapps_001090", "vc-description": "-- Result is a string\n\n-- Last part is capitalized original\n\n-- Other parts are initials\n\n-- Result is a string\n\n-- Parts lengths match\n\n-- Initials format\n\n-- Last name is starts with uppercase", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidNamePart (s: String) : Bool :=\n  sorry\n\ndef formatName (input: List String) : String :=\n  sorry\n\ndef formatNameStr (input: String) : String :=\n  sorry", "vc-theorems": "theorem format_name_list_properties {parts: List String}\n  (h: ∃ p ∈ parts, isValidNamePart p = true) :\n  let result := formatName parts\n  let resultParts := result.split (· = ' ')\n\n  result.length ≥ 0 ∧\n\n  resultParts.getLast! = (parts.getLast!).capitalize ∧\n\n  (parts.length > 1 →\n    ∀ i < parts.length - 1,\n    resultParts[i]! = s!\"{(parts[i]!).get 0}.\") :=\nsorry\n\ntheorem format_name_string_properties {input: String}\n  (h: ∃ c ∈ input.data, c.isAlpha) :\n  let validParts := (input.split (· = ' ')).filter isValidNamePart\n  let result := formatNameStr input\n  let resultParts := result.split (· = ' ')\n  (validParts.length > 0) →\n\n  result.length ≥ 0 ∧\n\n  resultParts.length = validParts.length ∧\n\n  (validParts.length > 1 →\n    ∀ i < validParts.length - 1,\n    (resultParts[i]!).endsWith \".\" ∧\n    (resultParts[i]!).length = 2) ∧\n\n  (resultParts.getLast!).get 0 ≥ 'A' ∧\n  (resultParts.getLast!).get 0 ≤ 'Z' :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"gandhi\"\n\n/-\ninfo: 'M. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"mahatma gandhI\"\n\n/-\ninfo: 'M. K. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"Mohndas KaramChand gandhi\""}
{"id": "fvapps_001094", "vc-description": "-- Result contains only numbers appearing more than k times\n\n-- All numbers appearing more than k times are in result\n\n-- Result is sorted\n\n-- All result elements exist in input array", "vc-preamble": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def find_frequent_numbers (n : Nat) (k : Nat) (arr : List Nat) : List Nat :=\n  sorry\n\ndef count {α} [BEq α] (as : List α) (a : α) : Nat :=\n  sorry\n\ndef uniqueSort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem frequent_numbers_properties\n  (n : Nat) (k : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k ≤ 19)\n  (h3 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  let result := find_frequent_numbers n k arr\n\n  ∀ num ∈ result, count arr num > k\n\n  ∧ ∀ num ∈ arr, count arr num > k → num ∈ result\n\n  ∧ isSorted result\n\n  ∧ ∀ num ∈ result, num ∈ arr :=\nsorry\n\ntheorem k_zero_returns_unique\n  (n : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  find_frequent_numbers n 0 arr = uniqueSort arr :=\nsorry\n\ntheorem large_k_returns_empty\n  (n : Nat) (k extra : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k = n + extra)\n  (h3 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  find_frequent_numbers n k arr = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [2, 5]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 5 1 [5, 2, 1, 2, 5]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 6 2 [1, 1, 1, 2, 2, 3]\n\n/-\ninfo: [1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 4 0 [4, 2, 3, 1]"}
{"id": "fvapps_001100", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_gift_pair (n : Nat) (prices : List Nat) : String :=\nsorry\n\ndef process_test_cases (numCases : Nat) (cases : List (Nat × List Nat)) : List String :=\nsorry\n\ndef permutation (xs : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem find_gift_pair_order_independence (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n (permutation prices) :=\nsorry\n\ntheorem find_gift_pair_result (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = \"Accepted\" ∨ find_gift_pair n prices = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_deterministic (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n prices :=\nsorry\n\ntheorem process_test_cases_preserves_result (n : Nat) (prices : List Nat) :\n  let test_cases := [(n, prices)]\n  let results := process_test_cases 1 test_cases\n  results.length = 1 ∧\n  results[0]! = find_gift_pair n prices :=\nsorry\n\ntheorem find_gift_pair_empty : find_gift_pair 0 [] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_single : find_gift_pair 1 [1000] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_too_small : find_gift_pair 3 [1, 1, 1] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_too_large : find_gift_pair 3 [2001, 2001, 2001] = \"Rejected\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 5 [10, 2, 1000, 50, 1000]\n\n/-\ninfo: 'Rejected'\n-/\n#guard_msgs in\n#eval find_gift_pair 3 [500, 500, 500]\n\n/-\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 4 [1000, 1000, 50, 60]"}
{"id": "fvapps_001106", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n-- Output type properties", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_binary_flips (n k : Nat) (s : String) : Nat × String :=\nsorry\n\ndef is_alternating (s : String) : Bool :=\nsorry\n\ndef check_consecutive (s : String) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem binary_flips_basic_properties {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 0) (h3 : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (flips, result) := solve_binary_flips n k s\n\n  flips ≥ 0 ∧\n  result.length = n ∧\n  (∀ c ∈ result.data, c = '0' ∨ c = '1') :=\nsorry\n\ntheorem k_one_alternating {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) := solve_binary_flips n 1 s\n  is_alternating result = true :=\nsorry\n\ntheorem k_gt_one_consecutive {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 1) (h3 : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) := solve_binary_flips n k s\n  check_consecutive result k = true :=\nsorry\n\ntheorem k_equals_n_no_flips {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (flips, result) := solve_binary_flips n n s\n  flips = 0 ∧ result = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001111", "vc-description": "", "vc-preamble": "def mkPos (s : String) (i : Nat) (h : i < s.length) : String.Pos := ⟨i⟩", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : String) : Bool :=\nsorry\n\ndef countPalindromeCompletions (s : String) : Nat :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem countPalindromeCompletions_nonnegative (s : String) :\n  countPalindromeCompletions s ≥ 0 :=\nsorry\n\ntheorem countPalindromeCompletions_impossible_case (s : String) (i : Nat)\n  (h1 : i < s.length / 2)\n  (h2 : i < s.length)\n  (h3 : s.length - 1 - i < s.length)\n  (h4 : s.get (mkPos s i h2) ≠ '?' ∧ s.get (mkPos s (s.length - 1 - i) h3) ≠ '?')\n  (h5 : s.get (mkPos s i h2) ≠ s.get (mkPos s (s.length - 1 - i) h3)) :\n  countPalindromeCompletions s = 0 :=\nsorry\n\ntheorem countPalindromeCompletions_bounded (s : String) :\n  countPalindromeCompletions s ≤ 10000009 :=\nsorry\n\ntheorem countPalindromeCompletions_all_question_marks (s : String) (h : ∀ c ∈ s.data, c = '?') :\n  countPalindromeCompletions s = (26 ^ ((s.length + 1) / 2)) % 10000009 :=\nsorry\n\ntheorem countPalindromeCompletions_no_question_marks (s : String) (h : '?' ∉ s.data) :\n  countPalindromeCompletions s = if isPalindrome s then 1 else 0 :=\nsorry\n\ntheorem countPalindromeCompletions_deterministic (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions s :=\nsorry\n\ntheorem countPalindromeCompletions_symmetry (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions (reverseString s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"?\"\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"??\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"aba\""}
{"id": "fvapps_001112", "vc-description": "/- Every positive number can be decomposed into a sum of squares,\n    and the count of squares is positive and not larger than the input number -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The decomposition count equals 1 for perfect squares -/\n\n/- Basic results for small numbers -/\n\n/- The sum of squares used in decomposition equals the input number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_squares (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_squares_basic_properties (n : Nat) (h : n > 0) :\n  let result := count_squares n\n  0 < result ∧ result ≤ n :=\nsorry\n\ntheorem count_squares_perfect (n : Nat) (h : n > 0) :\n  count_squares (n * n) = 1 :=\nsorry\n\ntheorem count_squares_small_numbers :\n  count_squares 1 = 1 ∧\n  count_squares 2 = 2 ∧\n  count_squares 3 = 3 :=\nsorry\n\ntheorem count_squares_sum_property (n : Nat) (h : n > 0) :\n  ∃ (squares : List Nat),\n    squares.length ≤ count_squares n ∧\n    (∀ x ∈ squares, ∃ k, x = k * k) ∧\n    (squares.foldl (· + ·) 0 = n) :=\nsorry", "vc-postamble": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 85\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_squares 114\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 10"}
{"id": "fvapps_001118", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_helper_thanks (n : Int) : String :=\nsorry\n\ndef solve_multiple_cases (nums : List Int) : List String :=\nsorry", "vc-theorems": "theorem solve_helper_thanks_result_valid (n : Int) :\n  (solve_helper_thanks n = \"-1\") ∨\n  (solve_helper_thanks n = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_length (nums : List Int) :\n  (solve_multiple_cases nums).length = nums.length :=\nsorry\n\ntheorem solve_helper_thanks_condition (n : Int) :\n  (n < 10) = (solve_helper_thanks n = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_valid_results (nums : List Int) :\n  ∀ x ∈ solve_multiple_cases nums,\n    (x = \"-1\") ∨ (x = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_condition (nums : List Int) :\n  ∀ (i : Nat), i < nums.length →\n    ((nums[i]! < 10) =\n     ((solve_multiple_cases nums)[i]! = \"Thanks for helping Chef!\")) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: test1_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [1, 12, -5]\n\n/-\ninfo: test2_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [-20, 0, 20]\n\n/-\ninfo: test3_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [9, 10]"}
{"id": "fvapps_001120", "vc-description": "", "vc-preamble": "def count_char (s : String) (c : Char) : Nat :=\n  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def count_ciel_number_prices (menu_items : List String) : Nat :=\n  sorry", "vc-theorems": "theorem count_result_bounded (menu_items : List String) :\n  0 ≤ count_ciel_number_prices menu_items ∧\n  count_ciel_number_prices menu_items ≤ menu_items.length :=\nsorry\n\ntheorem count_result_bounded_with_format\n  (menu_items : List String)\n  (h : ∀ item ∈ menu_items, ∃ words price, item = words ++ \" \" ++ price ∧ price.all (λ c => '0' ≤ c ∧ c ≤ '9')) :\n  0 ≤ count_ciel_number_prices menu_items ∧\n  count_ciel_number_prices menu_items ≤ menu_items.length :=\nsorry\n\ntheorem count_ciel_numbers_positive\n  (menu_items : List String)\n  (h : ∃ item ∈ menu_items,\n    let price := (item.split (· = ' ')).getLast!\n    price.all (λ c => c = '8' ∨ c = '5' ∨ c = '3') ∧\n    count_char price '8' ≥ count_char price '5' ∧\n    count_char price '5' ≥ count_char price '3') :\n  count_ciel_number_prices menu_items > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"milk 58\", \"Ciel\"s Drink 80\", \"The curry 2nd edition 888888\", \"rice omelet 85855\", \"unagi 1\", \"The first and last letters can be a space 358\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"menu 8\", \"special 853\", \"dessert 123\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"item 44\", \"item2 77\"]"}
{"id": "fvapps_001128", "vc-description": "-- Result should never be negative\n\n-- If k is less than min(arr), result should be 0\n\n-- If k equals min(arr), result should be at least length of array\n\n-- Single element array returns 1 if element equals k, 0 otherwise\n\n-- For array of identical elements, result is n*(n+1)/2\n\n-- For any k, result with k should be >= result with k+1", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_subarrays_with_min (arr : List Int) (k : Int) : Nat :=\n  sorry\n\ndef list_min (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem count_subarrays_nonneg {arr : List Int} {k : Int}\n  (h1 : arr ≠ []) :\n  count_subarrays_with_min arr k ≥ 0 :=\nsorry\n\ntheorem count_subarrays_less_than_min {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : k < list_min arr) :\n  count_subarrays_with_min arr k = 0 :=\nsorry\n\ntheorem count_subarrays_equals_min {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : k = list_min arr) :\n  count_subarrays_with_min arr k ≥ arr.length :=\nsorry\n\ntheorem count_subarrays_single_elem {arr : List Int} {k : Int}\n  (h1 : arr.length = 1) :\n  count_subarrays_with_min arr k = if arr.head! = k then 1 else 0 :=\nsorry\n\ntheorem count_subarrays_identical_elems {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : ∀ x ∈ arr, x = k) :\n  count_subarrays_with_min arr k = (arr.length * (arr.length + 1)) / 2 :=\nsorry\n\ntheorem count_subarrays_monotonic {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : ∀ x ∈ arr, x > 0) :\n  count_subarrays_with_min arr k ≥ count_subarrays_with_min arr (k+1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [2, 2] 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [3] 3"}
{"id": "fvapps_001133", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveBalancedDigits (s : String) : Nat :=\n  sorry\n\ndef makeBalancedString (m n : Nat) : String :=\n  sorry", "vc-theorems": "theorem equal_fours_and_sevens {n : Nat} (h : n > 0) (h2 : n ≤ 50) :\n  let s := makeBalancedString n n\n  let result := solveBalancedDigits s\n  result ≥ 1 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem arbitrary_fours_and_sevens {m n : Nat}\n  (h1 : m > 0) (h2 : m ≤ 50) (h3 : n > 0) (h4 : n ≤ 50) :\n  let s := makeBalancedString m n\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem valid_string_bounds {s : String}\n  (h : s.length > 0) (h2 : s.length ≤ 50)\n  (h3 : ∀ c ∈ s.data, c = '4' ∨ c = '7') :\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"47\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"4477\""}
{"id": "fvapps_001136", "vc-description": "-- Properties relating to lcm and gcd with same inputs\n\n-- Properties with 1\n\n-- Commutativity properties\n\n-- Solution validation\n\n-- Deterministic output", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lcm (a b : Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef solve_lovers_lcm (n : Nat) : String :=\nsorry", "vc-theorems": "theorem lcm_self (n : Nat) : lcm n n = n :=\nsorry\n\ntheorem gcd_self (n : Nat) (h : n > 0) : gcd n n = n :=\nsorry\n\ntheorem lcm_one (n : Nat) (h : n > 0) : lcm n 1 = n :=\nsorry\n\ntheorem gcd_one (n : Nat) (h : n > 0) : gcd n 1 = 1 :=\nsorry\n\ntheorem lcm_comm (a b : Nat) : lcm a b = lcm b a :=\nsorry\n\ntheorem gcd_comm (a b : Nat) : gcd a b = gcd b a :=\nsorry\n\ntheorem solve_lovers_valid_output (n : Nat) (h : n > 0) :\n  solve_lovers_lcm n = \"Nova's gonna kill me\" ∨\n  solve_lovers_lcm n = \"YESS(sunglass emo)\" :=\nsorry\n\ntheorem solve_lovers_deterministic (n : Nat) :\n  solve_lovers_lcm n = solve_lovers_lcm n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 111\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 10\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 100"}
{"id": "fvapps_001140", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def canSplitEvenly (n : Nat) : Bool :=\n  sorry\n\ndef countPossibleSwaps (n : Nat) : Nat :=\n  sorry\n\ndef solveSwaps (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_swaps_returns_valid_count (n : Nat) (h : n > 0) :\n  let result := solveSwaps n\n  result ≥ 0 ∧ result ≤ countPossibleSwaps n ∧\n  (¬canSplitEvenly n → result = 0) :=\nsorry\n\ntheorem solve_swaps_small_sequences (n : Nat) (h1 : n > 0) (h2 : n ≤ 2) :\n  solveSwaps n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_swaps 7"}
{"id": "fvapps_001142", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitSum (n : Nat) : Nat :=\n  sorry\n\ndef isDivisibleByDigitSum (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem isDivisibleByDigitSum_spec (n : Nat) (h : n > 0) :\n  let ds := digitSum n\n  isDivisibleByDigitSum n = \"Yes\" ↔ n % ds = 0\n  :=\nsorry\n\ntheorem isDivisibleByDigitSum_returns_valid_result (n : Nat) (h : n > 0) :\n  isDivisibleByDigitSum n = \"Yes\" ∨ isDivisibleByDigitSum n = \"No\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 16\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 27\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 45"}
{"id": "fvapps_001155", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Int) : Int :=\nsorry\n\ndef min_travel_time (n a b c d p q y : Nat) (cities : List Int) : Nat :=\nsorry", "vc-theorems": "theorem min_travel_time_non_negative (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities ≥ 0 :=\nsorry\n\ntheorem min_travel_time_upper_bound (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities ≤ (abs (cities[b-1] - cities[a-1])) * p :=\nsorry\n\ntheorem min_travel_time_identical_cities (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4)\n  (h15 : cities[a-1] = cities[b-1]) :\n  min_travel_time n a b c d p q y cities = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 3 2 4 3 2 4 [1, 2, 3, 4]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 4 2 3 2 1 10 [0, 1, 2, 3]"}
{"id": "fvapps_001162", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUpper (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef isSpace (c : Char) : Bool :=\nsorry\n\ndef count_elements (s : String) : Nat × Nat × Nat :=\nsorry", "vc-theorems": "theorem count_elements_totals (s : String) :\n  let (uppers, digits, spaces) := count_elements s\n  let total := uppers + digits + spaces\n  total ≤ s.length :=\nsorry\n\ntheorem empty_string :\n  count_elements \"\" = (0, 0, 0) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001167", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef solve_f_n (n : Nat) : Nat :=\n  sorry\n\ndef direct_calc (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem base_cases :\n  solve_f_n 1 = 1 ∧\n  solve_f_n 2 = 2 ∧\n  solve_f_n 3 = 12 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_f_n 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_f_n 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_f_n 2"}
{"id": "fvapps_001179", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_max_moves (n : Nat) : Nat :=\n  sorry\n\ndef isqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem calc_max_moves_non_negative (x : Nat) :\n  calc_max_moves x ≥ 0 :=\nsorry\n\ntheorem calc_max_moves_monotonic (x : Nat) :\n  x > 0 → calc_max_moves x ≥ calc_max_moves (x-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_moves 3\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_max_moves 8\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calc_max_moves 9"}
{"id": "fvapps_001180", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_anagram_pairs (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem find_anagram_pairs_nonneg (s : String) :\n  find_anagram_pairs s ≥ 0 :=\nsorry\n\ntheorem find_anagram_pairs_empty_or_single (s : String) :\n  s.length ≤ 1 → find_anagram_pairs s = 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001191", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_good_group (s : String) : Nat :=\n  sorry\n\ndef is_good_group (s : String) : Bool :=\n  sorry\n\ndef substring (s : String) (start len : Nat) : String :=\n  sorry\n\ndef get_char (s : String) (i : Nat) : Char :=\n  sorry", "vc-theorems": "theorem find_max_good_result_bounds {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  1 ≤ res ∧ res ≤ s.length :=\nsorry\n\ntheorem exists_valid_substring {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  ∃ start : Nat, start + res ≤ s.length ∧\n    is_good_group (substring s start res) :=\nsorry\n\ntheorem no_longer_good_groups {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  ∀ len : Nat, len > res → len ≤ s.length →\n    ∀ i : Nat, i + len ≤ s.length →\n      ¬is_good_group (substring s i len) :=\nsorry\n\ntheorem same_digit_max_length {s : String} (h : s.length > 0)\n  (h_same : ∀ i j : Nat, i < s.length → j < s.length →\n            get_char s i = get_char s j) :\n  find_max_good_group s = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_good_group \"123343\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_good_group \"95665\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_good_group \"2323\""}
{"id": "fvapps_001195", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_possible_ascii_chars (s: String) : String :=\n  sorry\n\ndef hasDuplicates (s: List α) : Bool :=\n  sorry", "vc-theorems": "theorem output_is_uppercase_ascii (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    result.all (fun c => 65 ≤ c.toNat ∧ c.toNat ≤ 90) ∧\n    ¬hasDuplicates result.data :=\nsorry\n\ntheorem chars_derive_from_input (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    let input_chars := input.data\n    ∀ c ∈ result.data, ∃ d ∈ input_chars, d.toNat = (c.toNat / 10) + '0'.toNat :=\nsorry\n\ntheorem small_digits_give_empty (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '4'))\n    (h_size: input.length > 0) :\n    find_possible_ascii_chars input = \"\" :=\nsorry\n\ntheorem duplicates_are_removed (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    ¬hasDuplicates result.data :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'A'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"65\"\n\n/-\ninfo: 'AB'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"566\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"11\""}
{"id": "fvapps_001210", "vc-description": "", "vc-preamble": "def countOnes (s : String) : Nat :=\n  s.data.filter (· = '1') |>.length", "vc-helpers": "", "vc-definitions": "def solve_virus_spread (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_virus_spread_type (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le 0 (solve_virus_spread N init_pop D isolations) ∧\n  Nat.le (solve_virus_spread N init_pop D isolations) N :=\nsorry\n\ntheorem solve_virus_spread_no_infected (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  (∀ c, c ∈ init_pop.data → c ≠ '1') →\n  solve_virus_spread N init_pop D isolations = 0 :=\nsorry\n\ntheorem solve_virus_spread_no_isolation (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  D = 0 →\n  solve_virus_spread N init_pop D isolations = countOnes init_pop :=\nsorry\n\ntheorem solve_virus_spread_monotonic (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le (countOnes init_pop) (solve_virus_spread N init_pop D isolations) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_virus_spread 9 \"000010000\" 3 [2, 5, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_virus_spread 5 \"00001\" 1 [5]"}
{"id": "fvapps_001215", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_time_for_multiple_of_nine (n : Nat) : Nat :=\n  sorry\n\ndef digit_sum (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_within_bounds (n : Nat) (h : n > 0) :\n  let result := min_time_for_multiple_of_nine n\n  result ≥ 0 ∧ result ≤ 8 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 1989\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 86236\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 90210"}
{"id": "fvapps_001221", "vc-description": "/- The result of solve_gem_game is never negative -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- When m=1, result follows pattern based on n being even/odd -/\n\n/- For m > (n+1)/2, result equals m -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_gem_game (n m : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_gem_game_nonneg (n m : Nat) :\n  solve_gem_game n m ≥ 0 :=\nsorry\n\ntheorem solve_gem_game_m_one (n : Nat) :\n  solve_gem_game n 1 = if n % 2 = 0 then n/2 else n/2 + 1 :=\nsorry\n\ntheorem solve_gem_game_large_m (n m : Nat) (h : m > (n+1)/2) :\n  solve_gem_game n m = m :=\nsorry", "vc-postamble": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_gem_game 4 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_gem_game 6 3\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_gem_game 10 1"}
{"id": "fvapps_001222", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def base5 (n : Nat) : List Nat :=\nsorry\n\ndef seq (n : Nat) : Nat :=\nsorry\n\ndef get_kth_magical_number (k : Nat) : Nat :=\nsorry\n\ndef digitList (n : Nat) : List Nat :=\nsorry\n\ndef isEvenDigit (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem base5_zero :\n  base5 0 = [] :=\nsorry\n\ntheorem base5_digits_bounded (n : Nat) :\n  ∀ d ∈ base5 n, 0 ≤ d ∧ d ≤ 4 :=\nsorry\n\ntheorem magical_increasing (k : Nat) :\n  k > 1 →\n  get_kth_magical_number (k-1) < get_kth_magical_number k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_kth_magical_number 2\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval get_kth_magical_number 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval get_kth_magical_number 1"}
{"id": "fvapps_001230", "vc-description": "", "vc-preamble": "def countStars (s : String) : Nat :=\n  s.toList.filter (· = '*') |>.length\n\ndef listSum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def Grid := List String\n\ndef isValidGrid (grid : Grid) : Bool :=\n  sorry\n\ndef solveHauntedLand (grid : Grid) : Nat :=\n  sorry", "vc-theorems": "theorem solve_haunted_land_output_valid (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid ≥ 0 :=\nsorry\n\ntheorem empty_grid_returns_zero (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : ∀ (row : String), List.contains grid row → ¬ row.contains '*') :\n  solveHauntedLand grid = 0 :=\nsorry\n\ntheorem single_house_returns_one (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : listSum (grid.map countStars) = 1) :\n  solveHauntedLand grid = 1 :=\nsorry\n\ntheorem result_bounded_by_dimensions (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid ≤ max grid.length (grid.head?.map String.length |>.getD 0) :=\nsorry\n\ntheorem inhabited_houses_positive_time (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : ∃ (row : String), List.contains grid row ∧ row.contains '*') :\n  solveHauntedLand grid ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"*.\", \"..\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_haunted_land [\".*..\", \"***.\", \".*..\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"...\", \"...\"]"}
{"id": "fvapps_001233", "vc-description": "", "vc-preamble": "def permutation (l1 l2 : List Nat) : Prop :=\n  l1.length = l2.length ∧ ∀ x, x ∈ l1 ↔ x ∈ l2", "vc-helpers": "", "vc-definitions": "def min_elements_needed (N K : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_elements_non_negative (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr ≥ 0 :=\nsorry\n\ntheorem min_elements_upper_bound (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr ≤ K :=\nsorry\n\ntheorem min_elements_complete_powers (N K : Nat) (arr : List Nat) :\n  (∀ i : Nat, i < K → (2^i) ∈ arr) →\n  min_elements_needed N K arr = 0 :=\nsorry\n\ntheorem min_elements_empty (K : Nat) :\n  min_elements_needed 0 K [] = K :=\nsorry\n\ntheorem min_elements_singleton_min (K : Nat) :\n  min_elements_needed 1 K [1] = K - 1 :=\nsorry\n\ntheorem min_elements_singleton_max (K : Nat) :\n  min_elements_needed 1 K [2^K] = K :=\nsorry\n\ntheorem min_elements_perm_invariant (N K : Nat) (arr₁ arr₂ : List Nat) :\n  permutation arr₁ arr₂ →\n  min_elements_needed N K arr₁ = min_elements_needed N K arr₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_elements_needed 2 2 [3, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_elements_needed 7 3 [3, 7, 5, 4, 6, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_elements_needed 1 3 [2]"}
{"id": "fvapps_001243", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binaryStringToDecimal (s : String) : Nat :=\nsorry\n\ndef isVowel (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem result_in_valid_range (s : String) (h : s.length > 0) :\n  binaryStringToDecimal s < 10^9 + 7 ∧ binaryStringToDecimal s ≥ 0 :=\nsorry\n\ntheorem all_vowels_max_value (s : String) (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, isVowel c) :\n  binaryStringToDecimal s = (2^s.length - 1) % (10^9 + 7) :=\nsorry\n\ntheorem all_consonants_zero (s : String) (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, ¬isVowel c) :\n  binaryStringToDecimal s = 0 :=\nsorry\n\ntheorem same_vowel_positions_equal (s1 s2 : String)\n  (h1 : s1.length > 0)\n  (h2 : s1.length = s2.length)\n  (h3 : ∀ (i : String.Pos), isVowel (s1.get i) = isVowel (s2.get i)) :\n  binaryStringToDecimal s1 = binaryStringToDecimal s2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"hello\"\n\n/-\ninfo: 31\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"aeiou\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"xyz\""}
{"id": "fvapps_001249", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_symmetric_zero_diag (B : List (List Nat)) : List (List Nat) :=\nsorry\n\ndef solve (N: Nat) (Q: Nat) (B: List (List Nat)) (queries: List (Nat × List Nat)) : List (List Nat) :=\nsorry\n\ndef get_A (B: List (List Int)) : List Int :=\nsorry\n\ndef update_B (B: List (List Nat)) (p: Nat) (R: List Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem solve_shape_correct {N Q: Nat} {B: List (List Nat)} {queries: List (Nat × List Nat)}\n  (h1: N = 3)\n  (h2: List.length B = N)\n  (h3: ∀ row ∈ B, List.length row = N)\n  (h4: List.length queries ≥ 1)\n  (h5: List.length queries ≤ 3)\n  : let result := solve N Q B queries\n    List.length result = List.length queries + 1 ∧\n    ∀ row ∈ result, List.length row = N :=\nsorry\n\ntheorem distances_preserved {A: List Int} {N: Nat}\n  (h1: List.length A = N)\n  (h2: N = 3)\n  : let B := List.map (λ i => List.map (λ j => Int.natAbs (A.get ⟨i, by sorry⟩ - A.get ⟨j, by sorry⟩)) (List.range N)) (List.range N)\n    let reconstructed := get_A (B.map (List.map Int.ofNat))\n    ∀ (i j : Fin reconstructed.length),\n    Int.natAbs (reconstructed.get i - reconstructed.get j) = (B.get ⟨i.val, by sorry⟩).get ⟨j.val, by sorry⟩ :=\nsorry\n\ntheorem update_B_symmetric {N p: Nat} {R: List Nat}\n  (h1: N ≥ 2)\n  (h2: N ≤ 5)\n  (h3: p < N)\n  (h4: List.length R ≥ N)\n  : let B := List.replicate N (List.replicate N 0)\n    let updated := update_B B p (List.take N R)\n    ∀ (i j : Fin N),\n    (updated.get ⟨i.val, by sorry⟩).get ⟨j.val, by sorry⟩ =\n    (updated.get ⟨j.val, by sorry⟩).get ⟨i.val, by sorry⟩ :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001250", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_obtain_k (n : Nat) (k : Nat) (edges : List (Nat × Nat)) (values : List Nat) : String :=\nsorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem can_obtain_k_returns_valid_output (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  (can_obtain_k n k edges values = \"YES\") ∨ (can_obtain_k n k edges values = \"NO\") :=\nsorry\n\ntheorem can_obtain_k_identical_values_consistent (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (h1 : is_valid_tree n edges = true) :\n  let values := List.replicate n 1\n  can_obtain_k n k edges values = can_obtain_k n k edges values :=\nsorry\n\ntheorem can_obtain_k_valid_edges (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  edges.length = n - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 6 85 [(1, 2), (2, 3), (2, 4), (4, 5), (3, 6)] [3, 5, 4, 7, 1, 9]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 3 4 [(1, 2), (1, 3)] [2, 3, 1]\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_obtain_k 4 100 [(1, 2), (2, 3), (2, 4)] [3, 4, 2, 5]"}
{"id": "fvapps_001252", "vc-description": "-- Helper definition for valid graphs", "vc-preamble": "def is_valid_graph (n: Nat) (roads: List (Nat × Nat)) : Prop :=\n  ∀ (u v: Nat), (u,v) ∈ roads →\n    (1 ≤ u ∧ u ≤ n) ∧\n    (1 ≤ v ∧ v ≤ n) ∧\n    (u ≠ v) ∧\n    (∀ (u' v': Nat), (u',v') ∈ roads → (u',v') = (u,v) ∨ (u',v') ≠ (u,v))", "vc-helpers": "", "vc-definitions": "def solve_city_paths (n: Nat) (roads: List (Nat × Nat)) (start: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_city_paths_single_node :\n  solve_city_paths 1 [] 1 = 1 :=\nsorry\n\ntheorem solve_city_paths_two_nodes :\n  solve_city_paths 2 [(1,2)] 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_city_paths 3 [(1, 2), (1, 3)] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_city_paths 5 [(1, 2), (1, 3), (2, 4), (2, 5)] 1"}
{"id": "fvapps_001260", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def nextPermutation (arr : List Int) : List Int :=\nsorry\n\ndef solve (n k : Nat) (perms : List (List Int)) : List (List Int) :=\nsorry\n\ndef isPermutation (arr1 arr2 : List Int) : Bool :=\nsorry\n\ndef isSortedDesc (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem next_permutation_preserves_elements (arr : List Int) :\n  isPermutation arr (nextPermutation arr) = true :=\nsorry\n\ntheorem next_permutation_idempotent_at_max {arr : List Int}\n  (h : isSortedDesc arr) :\n  nextPermutation arr = arr :=\nsorry\n\ntheorem next_permutation_lexicographically_larger {arr : List Int} :\n  nextPermutation arr ≥ arr ∨ isSortedDesc arr :=\nsorry\n\ntheorem solve_returns_correct_length (n k : Nat) (perms : List (List Int)) :\n  (solve n k perms).length = perms.length :=\nsorry\n\ntheorem solve_preserves_permutations (n k : Nat) (perms : List (List Int)) :\n  ∀ i, i < perms.length →\n    isPermutation (perms.get ⟨i, sorry⟩) ((solve n k perms).get ⟨i, sorry⟩) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001262", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isString : (s : String) → Bool :=\nsorry\n\ndef canReorderString : (s : String) → String :=\nsorry\n\ndef countChar (c : Char) (s : String) : Nat :=\nsorry\n\ndef isValidLifetime (s : String) : Bool :=\nsorry", "vc-theorems": "theorem canReorderString_valid_output (s : String) :\n  (canReorderString s = \"YES\") ∨ (canReorderString s = \"NO\") :=\nsorry\n\ntheorem canReorderString_matches_validity (s : String) :\n  canReorderString s = (if isValidLifetime s then \"YES\" else \"NO\") :=\nsorry\n\ntheorem exactly_nine_chars (s : String) (h : s.length = 9) :\n  countChar 'L' s ≥ 2 →\n  countChar 'T' s ≥ 2 →\n  countChar 'I' s ≥ 2 →\n  countChar 'M' s ≥ 2 →\n  countChar 'E' s ≥ 1 →\n  canReorderString s = \"YES\" :=\nsorry\n\ntheorem more_than_nine_chars (s : String) (h : s.length > 9) :\n  countChar 'L' s ≥ 2 →\n  countChar 'T' s ≥ 2 →\n  countChar 'I' s ≥ 2 →\n  countChar 'M' s ≥ 2 →\n  countChar 'E' s ≥ 2 →\n  canReorderString s = \"YES\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEAZAZAITLME\"\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LLLTTTIIIMMMEEEAHA\"\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEM\""}
{"id": "fvapps_001263", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_messi_passing (n_passes: Nat) (k_teammates: Nat) : Nat :=\nsorry", "vc-theorems": "theorem two_passes_equals_teammates {k: Nat} (h: k ≤ 1000) (h2: k ≥ 1) :\n  solve_messi_passing 2 k = k :=\nsorry\n\ntheorem result_bounded_by_power {n k: Nat} (h1: n ≥ 2) (h2: n ≤ 1000)\n    (h3: k ≥ 1) (h4: k ≤ 1000) :\n  solve_messi_passing n k ≤ k^(n-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_messi_passing 2 4\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 4 2\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 3 3"}
{"id": "fvapps_001267", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.size {α} : List α → Nat\n  | [] => 0\n  | _::xs => 1 + xs.size\n\ndef sequence_generator (n k : Nat) : List Int :=\n  sorry\n\ndef count_positive_prefixes (seq : List Int) : Nat :=\n  sorry\n\ndef sumList (xs : List Int) : Int :=\n  sorry\n\ndef Int.abs (i : Int) : Nat :=\n  sorry", "vc-theorems": "theorem sequence_length (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n  (sequence_generator n k).size = n :=\nsorry\n\ntheorem sequence_elements (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) (h3 : i < n) :\n  let seq := sequence_generator n k\n  ∀ i : Nat, i < n → Int.abs (seq.get ⟨i, sorry⟩) = i + 1 :=\nsorry\n\ntheorem positive_prefix_count (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n  count_positive_prefixes (sequence_generator n k) ≤ min k n :=\nsorry\n\ntheorem all_positive_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n n\n  (∀ i : Nat, i < n → seq.get ⟨i, sorry⟩ > 0) ∧\n  seq = List.map (Int.ofNat ∘ Nat.succ) (List.range n) :=\nsorry\n\ntheorem all_negative_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n 0\n  (∀ i : Nat, i < n → seq.get ⟨i, sorry⟩ < 0) ∧\n  seq = List.map (fun i => -Int.ofNat (i + 1)) (List.range n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval sequence_generator 3 3"}
{"id": "fvapps_001268", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_divisor (nums: List Nat) : Int :=\n  sorry\n\ndef is_divides_all (d: Nat) (nums: List Nat) : Bool :=\n  sorry\n\ndef gcd (a b: Nat) : Nat :=\n  sorry\n\ndef list_gcd (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_divides_all_numbers (nums: List Nat) :\n  let result := find_min_divisor nums\n  result ≠ -1 → is_divides_all result.toNat nums = true := by\n  sorry\n\ntheorem negative_one_means_no_common_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 → list_gcd nums = 1 := by\n  sorry\n\ntheorem result_is_minimal_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result ≠ -1 →\n  ∀ d: Nat, 2 ≤ d → d < result.toNat →\n  is_divides_all d nums = false := by\n  sorry\n\ntheorem result_is_valid_number (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 ∨ result ≥ 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [2, 4, 8]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_divisor [4, 7, 5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [12, 18, 24]"}
{"id": "fvapps_001277", "vc-description": "", "vc-preamble": "def list_max (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs\n\ndef list_unique (l : List Int) : Prop :=\n  ∀ (i j : Fin l.length), i.val ≠ j.val → l[i] ≠ l[j]", "vc-helpers": "", "vc-definitions": "def count_qualified_teams (n : Nat) (k : Nat) (scores : List Int) : Nat :=\nsorry", "vc-theorems": "theorem count_qualified_teams_bounds (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k ≤ scores.length)\n    (h3 : scores.length = n) :\n    k ≤ count_qualified_teams n k scores ∧ count_qualified_teams n k scores ≤ n :=\nsorry\n\ntheorem count_qualified_teams_deterministic (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k ≤ scores.length)\n    (h3 : scores.length = n) :\n    count_qualified_teams n k scores = count_qualified_teams n k scores :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 5 1 [3, 5, 2, 4, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_qualified_teams 6 4 [6, 5, 4, 3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 4 2 [10, 10, 8, 8]"}
{"id": "fvapps_001282", "vc-description": "/- Basic properties about operation counting -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Helper function to count non-lucky digits -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calcMinOpsLuckyNum (n : String) : Nat :=\n  sorry\n\ndef countNonLuckyDigits (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_is_nonnegative (n : String) :\n  calcMinOpsLuckyNum n ≥ 0 :=\nsorry\n\ntheorem max_ops_is_length (n : String) :\n  calcMinOpsLuckyNum n ≤ n.length :=\nsorry\n\ntheorem ops_equals_non_lucky_digits (n : String) :\n  calcMinOpsLuckyNum n = countNonLuckyDigits n :=\nsorry", "vc-postamble": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"25\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"46\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"99\""}
{"id": "fvapps_001290", "vc-description": "", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs\n\ndef isSorted : List String → Bool\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)", "vc-helpers": "", "vc-definitions": "def countDigits (a b : Nat) : String :=\nsorry", "vc-theorems": "theorem countDigits_format_valid {a b : Nat} (h : a ≤ b) (n : Nat) (h1 : n < 10^4) :\n  let result := countDigits a b\n  let pairs := (result.split (· = ' '))\n  pairs.length = 10 ∧\n  (∀ p ∈ pairs, ∃ d c, (p.split (· = ':')) = [d, c] ∧\n     d ∈ [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] ∧\n     (∀ ch ∈ c.data, ch.isDigit)) ∧\n  isSorted (pairs.map (fun p => ((p.split (· = ':')).get! 0))) :=\nsorry\n\ntheorem countDigits_count_valid {a b : Nat} (h : a ≤ b) :\n  let result := countDigits a b\n  let counts := ((result.split (· = ' ')).map\n    (fun p => String.toNat! ((p.split (· = ':')).get! 1)))\n  let digitCount := (List.range (b - a + 1)).map\n    (fun i => (toString (i + a)).length)\n  sumList counts = sumList digitCount :=\nsorry\n\ntheorem countDigits_single_num_valid (n : Nat) :\n  let result := countDigits n n\n  let counts := ((result.split (· = ' ')).map\n    (fun p => String.toNat! ((p.split (· = ':')).get! 1)))\n  ∀ d : Nat, d < 10 →\n    (counts.get! d) = ((toString n).data.filter\n      (fun c => c = (toString d).data.get! 0)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0'\n-/\n#guard_msgs in\n#eval count_digits 10 15\n\n/-\ninfo: '0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1'\n-/\n#guard_msgs in\n#eval count_digits 912 912\n\n/-\ninfo: '0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120'\n-/\n#guard_msgs in\n#eval count_digits 900 999"}
{"id": "fvapps_001291", "vc-description": "", "vc-preamble": "def lcm (a b : Nat) : Nat := Nat.div (a * b) (gcd a b)", "vc-helpers": "", "vc-definitions": "def min_candies_for_party (people_counts: List Nat) (remainder: Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry", "vc-theorems": "theorem remainder_divides_result (people_counts: List Nat) (remainder: Nat) (count: Nat)\n  (h: count ∈ people_counts) (h2: count > 0) :\n  count ∣ (min_candies_for_party people_counts remainder - remainder) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 3] 1\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 4, 6] 1\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [5] 2"}
{"id": "fvapps_001293", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_n (k : Nat) : Nat :=\n  sorry\n\ndef count_steps_to_zero (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_largest_n_returns_valid (k : Nat) (h : k > 0) (h2 : k ≤ 1000) :\n  find_largest_n k ≥ 0 :=\nsorry\n\ntheorem find_largest_n_edge_cases :\n  find_largest_n 1 = 0 ∧\n  find_largest_n 2 = 9 ∧\n  find_largest_n 3 = 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval find_largest_n 2\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_largest_n 3\n\n/-\ninfo: 170\n-/\n#guard_msgs in\n#eval find_largest_n 100"}
{"id": "fvapps_001298", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encodeAscii (s : String) : String :=\n  sorry\n\ndef decodeAsciiMessage (s : String) : String :=\n  sorry", "vc-theorems": "theorem decode_matches_input {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    decodeAsciiMessage (encodeAscii s) = s :=\nsorry\n\ntheorem decoded_chars_in_ascii_range {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    ∀ c ∈ (decodeAsciiMessage (encodeAscii s)).data,\n      32 ≤ c.toNat ∧ c.toNat ≤ 126 :=\nsorry\n\ntheorem encoded_is_numeric {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    ∀ c ∈ (encodeAscii s).data, c.isDigit :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"721011081081113287111114108100\"\n\n/-\ninfo: 'Welcome to India'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"871011089911110910132116111327311010010597\""}
{"id": "fvapps_001302", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_permutation_divisible_by_3 (n : Nat) : Nat :=\nsorry\n\ndef sum_digits (n : Nat) : Nat :=\nsorry\n\ndef get_digits (n : Nat) : List Nat :=\nsorry\n\ndef sort_digits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem check_permutation_returns_binary (n : Nat) :\n  check_permutation_divisible_by_3 n = 0 ∨ check_permutation_divisible_by_3 n = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 18\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 308\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 123"}
{"id": "fvapps_001318", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_plates_max_deliciousness (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef countLeadingZeros (arr : List Nat) : Nat :=\nsorry\n\ndef countTrailingZeros (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_plates_result_bounds {n : Nat} {arr : List Nat}\n  (h : arr.length = n) (h2 : n > 0) :\n  let result := min_plates_max_deliciousness n arr\n  1 ≤ result ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 4 [1, 2, 3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 5 [3, 2, 0, 3, 0]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 3 [0, 0, 0]"}
{"id": "fvapps_001319", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tourist_spots (n : Nat) (roads : List String) : Float :=\nsorry\n\ndef isValidRoad : String → Bool :=\nsorry", "vc-theorems": "theorem solve_tourist_spots_output_is_float (n : Nat) (roads : List String)\n    (h : n ≥ 2) (h2 : roads.length > 0) :\n  ∃ (f : Float), solve_tourist_spots n roads = f :=\nsorry\n\ntheorem solve_tourist_spots_total_weight\n    {n : Nat} {roads : List String} {weights : List Float}\n    (h : n ≥ 2)\n    (h2 : roads.length > 0)\n    (h3 : weights = roads.map (fun r => sorry)) :\n  solve_tourist_spots n roads ≤ weights.foldl (. + .) 0.0 :=\nsorry\n\ntheorem solve_tourist_spots_invalid_input\n    {n : Nat} {roads : List String}\n    (h : n ≥ 2)\n    (h2 : ∃ r ∈ roads, ¬ isValidRoad r) :\n  solve_tourist_spots n roads = 0.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001328", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_temp_difference (today_high today_low normal_high normal_low : Int) : String :=\nsorry\n\ndef String.contains? (s : String) (substr : String) : Bool :=\nsorry\n\ndef String.toFloat (s : String) : Float :=\nsorry\n\ndef Int.toFloat (i : Int) : Float :=\nsorry", "vc-theorems": "theorem temp_diff_result_format (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  ∃ (diff : String) (dir : String),\n    result = diff ++ \" DEGREE(S) \" ++ dir ++ \" NORMAL\" ∧\n    (dir = \"ABOVE\" ∨ dir = \"BELOW\") :=\nsorry\n\ntheorem temp_diff_nonnegative (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let parts := result.splitOn \" DEGREE(S) \"\n  let diff := parts[0]!\n  String.toFloat diff ≥ 0 :=\nsorry\n\ntheorem temp_diff_direction (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let avg_today : Float := (today_high.toFloat + today_low.toFloat) / 2\n  let avg_normal : Float := (normal_high.toFloat + normal_low.toFloat) / 2\n  (avg_today > avg_normal → result.contains? \"ABOVE\") ∧\n  (avg_today ≤ avg_normal → result.contains? \"BELOW\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001334", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_pizza_time (n : Nat) (k : Nat) (s : String) : Nat :=\n  sorry\n\ndef count_ones (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem max_pizza_time_bounds (n k: Nat) (s: String) :\n  n > 0 → s.length = n →\n  let result := max_pizza_time n k s\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_pizza_time_upper_bound (n k: Nat) (s: String) :\n  n > 0 → s.length = n →\n  max_pizza_time n k s ≤ n :=\nsorry\n\ntheorem max_pizza_time_all_ones (n: Nat) :\n  n > 0 →\n  let s := String.mk (List.replicate n '1')\n  max_pizza_time n 0 s = n :=\nsorry\n\ntheorem max_pizza_time_all_zeros (n: Nat) :\n  n > 0 →\n  let s := String.mk (List.replicate n '0')\n  let k := n / 2\n  max_pizza_time n k s = k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pizza_time 13 2 \"0101110000101\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_pizza_time 6 3 \"100001\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_pizza_time 5 2 \"10001\""}
{"id": "fvapps_001344", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_cheat_possibilities (a b : Nat) : Int :=\n  sorry\n\ndef countDivisors (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem same_numbers_returns_negative_one\n  {x : Nat} (h : x > 0) (h2 : x ≤ 1000) :\n  solve_cheat_possibilities x x = -1 :=\nsorry\n\ntheorem result_is_symmetric\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a ≤ 1000) (h4 : b ≤ 1000) :\n  solve_cheat_possibilities a b = solve_cheat_possibilities b a :=\nsorry\n\ntheorem result_is_nonnegative_for_different\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a ≤ 1000) (h4 : b ≤ 1000) (h5 : a ≠ b) :\n  solve_cheat_possibilities a b ≥ 0 :=\nsorry\n\ntheorem perfect_squares_have_odd_factors\n  {n : Nat} (h1 : n > 0) (h2 : n ≤ 100) :\n  solve_cheat_possibilities 0 (n * n) % 2 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 2 6\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 5 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 10 14"}
{"id": "fvapps_001355", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_xor_parity (n m : Nat) (arr queries : List Nat) : List String :=\n  sorry\n\ndef popCount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_xor_parity_output_format {n m : Nat} {arr queries : List Nat}\n    (h1 : arr.length > 0) (h2 : queries.length > 0)\n    (h3 : arr.length = n) (h4 : queries.length = m) :\n    let result := solve_xor_parity n m arr queries\n    result.length = queries.length ∧\n    ∀ r ∈ result,\n      ∃ evens odds : Nat,\n        r = toString evens ++ \" \" ++ toString odds ∧\n        evens + odds = arr.length :=\nsorry\n\ntheorem solve_xor_parity_idempotent {n : Nat} {arr : List Nat} {query : Nat}\n    (h : arr.length > 0) (h2 : arr.length = n) :\n    solve_xor_parity n 1 arr [query] = solve_xor_parity n 1 arr [query] :=\nsorry\n\ntheorem solve_xor_parity_singleton {x query : Nat} :\n    let result := solve_xor_parity 1 1 [x] [query]\n    let r := result[0]!\n    let evens := (r.splitOn \" \")[0]!.toNat!\n    let odds := (r.splitOn \" \")[1]!.toNat!\n    evens + odds = 1 ∧\n    (if (popCount (x.xor query)) % 2 = 0\n     then evens = 1 ∧ odds = 0\n     else evens = 0 ∧ odds = 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['2 4']\n-/\n#guard_msgs in\n#eval solve_xor_parity 6 1 [4, 2, 15, 9, 8, 8] [3]\n\n/-\ninfo: ['0 2']\n-/\n#guard_msgs in\n#eval solve_xor_parity 2 1 [1, 2] [3]\n\n/-\ninfo: ['0 1']\n-/\n#guard_msgs in\n#eval solve_xor_parity 1 1 [5] [7]"}
{"id": "fvapps_001360", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_race_encounters (x : Int) (r speed1 speed2 : Float) : Int :=\n  sorry\n\ndef abs (x : Float) : Float :=\n  sorry", "vc-theorems": "theorem race_encounters_non_negative\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 ≥ -1 :=\nsorry\n\ntheorem race_encounters_less_than_laps\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 < x :=\nsorry\n\ntheorem race_encounters_speed_symmetry\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r speed2 speed1 :=\nsorry\n\ntheorem race_encounters_speed_scaling\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r (2 * speed1) (2 * speed2) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 3 10 2 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_race_encounters 2 20 5 10\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 4 15 3 6"}
{"id": "fvapps_001361", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def decryptPassword (rules : List (Char × Char)) (encrypted : String) : String :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry\n\ndef replaceChar (s : String) (oldChar newChar : Char) : String :=\n  sorry", "vc-theorems": "theorem zero_rules_preserve_number {num : Nat} (h : num ≤ 1000000) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  stringToNat decrypted = num\n  :=\nsorry\n\ntheorem zero_rules_no_leading_zeros {num : Nat} (h : num ≤ 1000000) (h2 : num ≠ 0) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  ¬(decrypted.get 0 = '0')\n  :=\nsorry\n\ntheorem zero_rules_single_zero :\n  decryptPassword [] \"0\" = \"0\"\n  :=\nsorry\n\ntheorem simple_substitutions_preserve_number\n  {rules : List (Char × Char)}\n  {num : Nat}\n  (h1 : num ≤ 1000000)\n  (h2 : ∀ r1 r2, r1 ∈ rules → r2 ∈ rules → r1.1 = r2.1 → r1 = r2)\n  (h3 : ∀ r, r ∈ rules → r.1 ∈ \"abcdefghijklmnopqrstuvwxyz\".data)\n  (h4 : ∀ r, r ∈ rules → r.2 ∈ \"0123456789\".data)\n  (h5 : rules.length ≤ 5) :\n  let numStr := toString num\n  let encrypted := rules.foldl (fun acc r => replaceChar acc r.2 r.1) numStr\n  let decrypted := decryptPassword rules encrypted\n  stringToNat decrypted = num\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '3'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"5\", \"3\"), (\"3\", \"1\")] \"5\"\n\n/-\ninfo: '1800'\n-/\n#guard_msgs in\n#eval decrypt_password [] \"01800.00\"\n\n/-\ninfo: '321.33098'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"x\", \"0\"), (\"d\", \"3\"), (\"#\", \".\")] \"0xd21#dd098x\""}
{"id": "fvapps_001363", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Matrix := List String\n\ndef Query := Nat × Char", "vc-helpers": "", "vc-definitions": "def Result := String\n\ndef check_matrix_exists (L R : Nat) (matrix : Matrix) (queries : List Query) : List Result :=\n  sorry\n\ndef all_same_matrix (c : Char) (L R : Nat) : Matrix :=\n  sorry", "vc-theorems": "theorem check_matrix_exists_results_match_queries\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  List.length results = List.length queries :=\nsorry\n\ntheorem check_matrix_exists_valid_results\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  ∀ r ∈ results, r = \"yes\" ∨ r = \"no\" :=\nsorry\n\ntheorem check_matrix_exists_size_constraint\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  ∀ (q : Query) (r : Result),\n    (q, r) ∈ List.zip queries results →\n    q.1 > min L R → r = \"no\" :=\nsorry\n\ntheorem check_matrix_exists_all_same_char\n  (matrix : Matrix) (queries : List Query) (L R : Nat) (c : Char) :\n  let all_same := all_same_matrix c L R\n  let results := check_matrix_exists L R all_same queries\n  ∀ (q : Query) (r : Result),\n    (q, r) ∈ List.zip queries results →\n    (q.2 = c → r = \"yes\" ↔ q.1 ≤ min L R) ∧\n    (q.2 ≠ c → r = \"no\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001364", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_make_palindrome (s : String) : Bool :=\nsorry\n\ndef process_test_case (s : String) : String :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem palindrome_stays_true {s : String} :\n  s = reverse s → can_make_palindrome s = true :=\nsorry\n\ntheorem single_char_is_palindrome {s : String} :\n  s.length = 1 → can_make_palindrome s = true :=\nsorry\n\ntheorem reverse_preserves_palindrome {s : String} :\n  can_make_palindrome s = can_make_palindrome (reverse s) :=\nsorry\n\ntheorem process_returns_yes_no {s : String}\n  (h : s.length > 0) :\n  process_test_case s = \"YES\" ∨ process_test_case s = \"NO\" :=\nsorry\n\ntheorem process_matches_can_make {s : String} :\n  (process_test_case s = \"YES\") = can_make_palindrome s :=\nsorry\n\ntheorem basic_palindrome_cases :\n  can_make_palindrome \"a\" ∧\n  can_make_palindrome \"aa\" ∧\n  can_make_palindrome \"aba\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"aaa\"\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval process_test_case \"abc\"\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"abdbca\""}
{"id": "fvapps_001368", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n-- max of all valid partition numbers\n\n-- equal to integer value of s or 0", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_max_gcd (s : String) (m x y : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_properties (a b : Int) (h : b ≠ 0) :\n  let g := gcd a.natAbs b.natAbs\n  g > 0 ∧ a.natAbs % g = 0 ∧ b.natAbs % g = 0 :=\nsorry\n\ntheorem solve_max_gcd_basic_properties\n  (s : String) (m x y : Nat)\n  (h1 : s.length > 0)\n  (h2 : s.length ≤ 10)\n  (h3 : m ≤ 5)\n  (h4 : m > 0)\n  (h5 : x ≤ 3)\n  (h6 : y ≤ 3)\n  (h7 : x ≤ y) :\n  let result := solve_max_gcd s m x y\n  result ≥ 0 ∧\n  result ≤ (sorry)\n  :=\nsorry\n\ntheorem solve_max_gcd_partition_bounds\n  (s : String)\n  (h1 : s.length > 0)\n  (h2 : s.length ≤ 5) :\n  let m := s.length\n  let full_partition := solve_max_gcd s m 0 m\n  let single_partition := solve_max_gcd s m 0 0\n  full_partition ≥ 0 ∧\n  (single_partition = sorry ∨ single_partition = 0)\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001371", "vc-description": "-- Function signature we're reasoning about\n\n-- Properties from hypothesis test\n\n-- Helper definition for checking if building at index i is safe\n\n-- Edge cases", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.replicate (s : String) (n : Nat) : String :=\nsorry\n\ndef count_safe_buildings (s : String) : Nat :=\nsorry\n\ndef isSafeBuilding (s : String) (i : Nat) : Bool :=\nsorry", "vc-theorems": "theorem count_safe_buildings_equals_safe_spots (s : String) :\n  count_safe_buildings s =\n    (List.range s.length).foldl (fun acc i =>\n      if isSafeBuilding s i then acc + 1 else acc) 0 :=\nsorry\n\ntheorem count_safe_buildings_nonnegative (s : String) :\n  count_safe_buildings s ≥ 0 :=\nsorry\n\ntheorem count_safe_buildings_bounded (s : String) :\n  count_safe_buildings s ≤ s.length :=\nsorry\n\ntheorem all_zeros_returns_length (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"0\" n) = n :=\nsorry\n\ntheorem all_ones_returns_zero (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"1\" n) = 0 :=\nsorry\n\ntheorem empty_string_returns_zero :\n  count_safe_buildings \"\" = 0 :=\nsorry\n\ntheorem single_zero_returns_one :\n  count_safe_buildings \"0\" = 1 :=\nsorry\n\ntheorem single_one_returns_zero :\n  count_safe_buildings \"1\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_safe_buildings \"010\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_safe_buildings \"10001\"\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_safe_buildings \"0000000\""}
{"id": "fvapps_001378", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def maxList (l : List Nat) : Float :=\n  Float.ofNat (l.foldl max 0)\n\ndef listXor (l : List Nat) : Float :=\n  Float.ofNat (l.foldl Nat.xor 0)", "vc-helpers": "", "vc-definitions": "def calculate_expected_beauty (n : Nat) (beauties : List Nat) (probs : List Float) : Float :=\n  sorry", "vc-theorems": "theorem expected_beauty_bounds {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (h3 : ∀ p ∈ probs, 0 ≤ p ∧ p ≤ 1)\n    (h4 : beauties.length > 0)\n    : 0 ≤ calculate_expected_beauty n beauties probs ∧\n      calculate_expected_beauty n beauties probs ≤ maxList beauties :=\nsorry\n\ntheorem probabilities_zero_one {n : Nat} {beauties : List Nat}\n    (h1 : beauties.length = n)\n    : calculate_expected_beauty n beauties (List.replicate n 0) = 0 ∧\n      calculate_expected_beauty n beauties (List.replicate n 1) =\n        listXor beauties :=\nsorry\n\ntheorem symmetry {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (σ : List.Perm beauties (beauties.take n))\n    (τ : List.Perm probs (probs.take n))\n    : calculate_expected_beauty n beauties probs =\n      calculate_expected_beauty n (beauties.take n) (probs.take n) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001384", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Point := Int × Int\n\ndef length (points : Rectangle) : Float :=\n  let (l, _, _, _, _) := calculate_rectangle_characteristics points\n  l\n\ndef width (points : Rectangle) : Float :=\n  let (_, w, _, _, _) := calculate_rectangle_characteristics points\n  w\n\ndef area (points : Rectangle) : Float :=\n  let (_, _, a, _, _) := calculate_rectangle_characteristics points\n  a\n\ndef perimeter (points : Rectangle) : Float :=\n  let (_, _, _, p, _) := calculate_rectangle_characteristics points\n  p\n\ndef diagonal (points : Rectangle) : Float :=\n  let (_, _, _, _, d) := calculate_rectangle_characteristics points\n  d", "vc-helpers": "", "vc-definitions": "def Rectangle := List Point\n\ndef calculate_rectangle_characteristics (points : Rectangle) : Float × Float × Float × Float × Float :=\n  sorry", "vc-theorems": "theorem length_positive (points : Rectangle) :\n  length points > 0 :=\nsorry\n\ntheorem width_positive (points : Rectangle) :\n  width points > 0 :=\nsorry\n\ntheorem area_is_length_times_width (points : Rectangle) :\n  area points = length points * width points :=\nsorry\n\ntheorem perimeter_formula (points : Rectangle) :\n  perimeter points = 2 * (length points + width points) :=\nsorry\n\ntheorem diagonal_formula (points : Rectangle) :\n  diagonal points = Float.sqrt (length points * length points + width points * width points) :=\nsorry\n\ntheorem diagonal_larger_than_sides (points : Rectangle) :\n  diagonal points > length points ∧ diagonal points > width points :=\nsorry\n\ntheorem measurements_match_points (points : Rectangle) (h : points.length = 4) :\n  ∃ x1 x2 y1 y2 : Int,\n    (x2 > x1 ∧ y2 > y1) ∧\n    points = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)] ∧\n    length points = Float.ofInt (x2 - x1) ∧\n    width points = Float.ofInt (y2 - y1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001385", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_troops_to_ruin (s: String) : Nat :=\nsorry\n\ndef isPalindrome (s: String) : Bool :=\nsorry", "vc-theorems": "theorem min_troops_bounds (s: String) :\n  let result := find_min_troops_to_ruin s\n  0 ≤ result ∧ result ≤ 2 :=\nsorry\n\ntheorem empty_string_troops (s: String) :\n  s = \"\" → find_min_troops_to_ruin s = 0 :=\nsorry\n\ntheorem palindrome_troops (s: String) :\n  s ≠ \"\" ∧ isPalindrome s → find_min_troops_to_ruin s = 1 :=\nsorry\n\ntheorem non_palindrome_troops (s: String) :\n  s ≠ \"\" ∧ ¬isPalindrome s → find_min_troops_to_ruin s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abbabaab\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abba\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"ab\""}
{"id": "fvapps_001402", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_contiguous_subsequence (N Q K : Nat) (A : List Nat) (S : String) : List Nat :=\nsorry\n\ndef count_max_consecutive_ones (A : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_length_matches_question_marks {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  (longest_contiguous_subsequence N Q K A S).length =\n    (S.data.filter (. = '?')).length :=\nsorry\n\ntheorem results_bounded_by_k {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x ≤ K :=\nsorry\n\ntheorem results_non_negative {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x ≥ 0 :=\nsorry\n\ntheorem zero_array_gives_zero_result {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x = 0) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x = 0 :=\nsorry\n\ntheorem single_question_mark_result {N K : Nat} {A : List Nat}\n  (h1 : N > 0) (h2 : K > 0)\n  (h3 : ∀ x ∈ A, x ≤ 1)\n  (h4 : (longest_contiguous_subsequence N 1 K A \"?\").length > 0) :\n  (longest_contiguous_subsequence N 1 K A \"?\")[0]! = min (count_max_consecutive_ones A) K :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 3, 3]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 5 5 3 [1, 1, 0, 1, 1] \"?!?!?\"\n\n/-\ninfo: [1, 1, 1]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 3 3 2 [1, 0, 1] \"???\"\n\n/-\ninfo: [4, 4]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 4 2 4 [1, 1, 1, 1] \"??\""}
{"id": "fvapps_001413", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLeapYear (year : Int) : Bool :=\n  sorry\n\ndef isValidDate (year month day : Int) : Bool :=\n  sorry\n\ndef countCorrectPills (dateStr : String) : Int :=\n  sorry", "vc-theorems": "theorem valid_date_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  1 ≤ month ∧ month ≤ 12 →\n  1 ≤ day ∧ day ≤ 31 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry\n\ntheorem leap_year_feb29_count (year : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  isLeapYear year →\n  let result := countCorrectPills s!\"{year}:02:29\"\n  result ≥ 1 :=\nsorry\n\ntheorem thirty_day_months_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  (month = 4 ∨ month = 6 ∨ month = 9 ∨ month = 11) →\n  1 ≤ day ∧ day ≤ 30 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry\n\ntheorem thirtyone_day_months_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  (month = 1 ∨ month = 3 ∨ month = 5 ∨ month = 7 ∨ month = 8 ∨ month = 10 ∨ month = 12) →\n  1 ≤ day ∧ day ≤ 31 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2019:03:31\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2020:02:28\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2000:12:31\""}
{"id": "fvapps_001417", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.toHexString (n: Nat) : String :=\n  sorry\n\ndef String.trimLeftZeros (s: String) : String :=\n  sorry\n\ndef hexToDecimal (l: List String) : List Nat :=\n  sorry", "vc-theorems": "theorem hex_to_decimal_length (l: List String) :\n  l.length = (hexToDecimal l).length := by\n  sorry\n\ntheorem hex_to_decimal_non_negative (l: List String) (i: Nat) (h: i < (hexToDecimal l).length) :\n  (hexToDecimal l).get ⟨i, h⟩ ≥ 0 := by\n  sorry\n\ntheorem hex_to_decimal_roundtrip (l: List String) :\n  let converted := hexToDecimal l\n  let back_to_hex := converted.map Nat.toHexString\n  let normalized := l.map String.trimLeftZeros\n  back_to_hex = normalized := by\n  sorry\n\ntheorem hex_to_decimal_increasing (l: List String) (i: Nat) (h₁: i < l.length) (h₂: i < (hexToDecimal l).length) :\n  let num := l.get ⟨i, h₁⟩\n  num.length > 1 →\n  (hexToDecimal l).get ⟨i, h₂⟩ > 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [10]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\"]\n\n/-\ninfo: [6691]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"1A23\"]\n\n/-\ninfo: [10, 6691, 11306]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\", \"1A23\", \"2C2A\"]"}
{"id": "fvapps_001419", "vc-description": "/- Any valid result should be either -1 or non-negative -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Trivial 1x1 grid case should return 0 -/\n\n/- Any valid result should not exceed grid dimensions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_robots_meeting (n m k1 k2 : Nat) (grid : Array (Array Nat)) : Int :=\n  sorry", "vc-theorems": "theorem result_valid_range {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 ∨ result ≥ 0 := by\n  sorry\n\ntheorem trivial_case :\n  let grid := #[#[0]]\n  solve_robots_meeting 1 1 1 1 grid = 0 := by\n  sorry\n\ntheorem result_bounds {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 ∨ result ≤ n * m := by\n  sorry", "vc-postamble": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]"}
{"id": "fvapps_001422", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countDigit (n : Nat) (d : Nat) : Nat :=\nsorry\n\ndef find_max_digit_frequency (nums : List Nat) (target : Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_digit_freq_in_list (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) :\n  find_max_digit_frequency nums target ∈ nums :=\nsorry\n\ntheorem max_digit_freq_is_max (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) :\n  ∀ n ∈ nums, countDigit (find_max_digit_frequency nums target) target ≥\n              countDigit n target :=\nsorry\n\ntheorem no_target_returns_first (nums : List Nat) (target : Nat)\n  (h : nums ≠ [])\n  (h2 : ∀ n ∈ nums, countDigit n target = 0) :\n  find_max_digit_frequency nums target = nums.head! :=\nsorry\n\ntheorem same_freq_returns_first (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) (n : Nat) (hn : n ∈ nums) :\n  countDigit n target = countDigit (find_max_digit_frequency nums target) target →\n  n = find_max_digit_frequency nums target ∨\n  nums.findIdx (. = n) > nums.findIdx (. = find_max_digit_frequency nums target) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '1323'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"345\", \"1323\", \"165\", \"98\", \"456\"] \"3\"\n\n/-\ninfo: '335'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"335\", \"876\", \"98\", \"1323\", \"349\"] \"3\""}
{"id": "fvapps_001423", "vc-description": "/- Helper function that converts a string to a sorted char array for anagram comparison -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def stringToSortedArray (s : String) : Array Char :=\n  (s.data.toArray).qsort (· ≤ ·)", "vc-helpers": "", "vc-definitions": "def find_anagram_positions (haystack : String) (needle : String) : String :=\n  sorry", "vc-theorems": "theorem output_format {s : String} :\n  let result := find_anagram_positions s \"test\"\n  result.startsWith \"The antidote is found in\" ∧\n  result.endsWith \".\" :=\nsorry\n\ntheorem identical_word_not_counted {word : String} :\n  word ≠ \"\" →\n  find_anagram_positions word word = \"The antidote is found in .\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001424", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_anagrams (s : String) : Nat :=\nsorry\n\ndef manual_count_anagrams (s : String) : Nat :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_anagrams_positive (s : String) (h : s.length > 0) :\n  count_anagrams s ≥ 0 ∧ count_anagrams s < 10^9 + 7 :=\nsorry\n\ntheorem count_anagrams_letter_order_invariant (s : String) (h : s.length > 0) :\n  count_anagrams s = count_anagrams s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"ab\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_anagrams \"aa\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"aA\"\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval count_anagrams \"AAbaz\""}
{"id": "fvapps_001429", "vc-description": "/- If the input string length is odd, min_ops_for_self_destruct returns -1 -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- If the input string contains only 0s or only 1s, min_ops_for_self_destruct returns -1 -/\n\n/- If min_ops_for_self_destruct returns a non-negative result, it is bounded by half the string length -/\n\n/- For balanced strings with equal counts of 0s and 1s and even length, min_ops_for_self_destruct returns 0 -/\n\n/- The result equals half the absolute difference between counts of 0s and 1s when not -1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_ops_for_self_destruct (s : String) : Int :=\n  sorry", "vc-theorems": "theorem odd_length_returns_negative (s : String) :\n  String.length s % 2 = 1 → min_ops_for_self_destruct s = -1 := by\n  sorry\n\ntheorem all_ones_or_zeroes_returns_negative (s : String) :\n  (∀c ∈ s.data, c = '0') ∨ (∀c ∈ s.data, c = '1') →\n  min_ops_for_self_destruct s = -1 := by\n  sorry\n\ntheorem result_bounds (s : String) :\n  min_ops_for_self_destruct s ≠ -1 →\n  0 ≤ min_ops_for_self_destruct s ∧ min_ops_for_self_destruct s ≤ String.length s / 2 := by\n  sorry\n\ntheorem balanced_strings_need_zero_ops (s : String) :\n  String.length s % 2 = 0 →\n  (s.data.filter (· = '0')).length = (s.data.filter (· = '1')).length →\n  min_ops_for_self_destruct s = 0 := by\n  sorry\n\ntheorem operations_count (s : String) :\n  min_ops_for_self_destruct s ≠ -1 →\n  min_ops_for_self_destruct s =\n    (Int.natAbs ((s.data.filter (· = '0')).length - (s.data.filter (· = '1')).length)) / 2 := by\n  sorry", "vc-postamble": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"001101\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"1101\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"110\""}
{"id": "fvapps_001437", "vc-description": "-- Result should be greater than or equal to input\n\n-- Result should have same number of digits as input\n\n-- Result changes should not exceed k\n\n-- k=0 means unchanged\n\n-- With enough k, all digits become 9", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numDigits (n : Nat) : Nat :=\n  sorry\n\ndef maximizeStockPrice (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maximize_stock_price_properties (n k : Nat) (h1 : n ≤ 999999) (h2 : k ≤ 10) :\n  let result := maximizeStockPrice n k;\n\n  result ≥ n\n\n  ∧ numDigits result = numDigits n\n\n  ∧ ∃ changes, changes ≤ k\n\n  ∧ (k = 0 → result = n) :=\nsorry\n\ntheorem maximize_stock_price_saturated (n k : Nat) (h1 : k ≥ numDigits n) :\n  let result := maximizeStockPrice n k;\n\n  result = n :=\nsorry\n\ntheorem maximize_stock_price_edge_cases :\n  maximizeStockPrice 0 0 = 0\n  ∧ maximizeStockPrice 1 1 = 9\n  ∧ maximizeStockPrice 9 1 = 9\n  ∧ maximizeStockPrice 99 1 = 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9983\n-/\n#guard_msgs in\n#eval maximize_stock_price 4483 2\n\n/-\ninfo: 9234\n-/\n#guard_msgs in\n#eval maximize_stock_price 1234 1\n\n/-\ninfo: 9999\n-/\n#guard_msgs in\n#eval maximize_stock_price 9999 4"}
{"id": "fvapps_001440", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_bad_luck (strings : List String) : Nat :=\nsorry\n\ndef countChar (c : Char) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem find_min_bad_luck_non_negative (strings : List String) :\n  find_min_bad_luck strings ≥ 0 :=\nsorry\n\ntheorem find_min_bad_luck_leq_min_len (strings : List String) :\n  strings ≠ [] → find_min_bad_luck strings ≤ List.foldr (fun s acc => min s.length acc) (strings[0]!.length) strings.tail :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"ab\", \"ba\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aa\", \"bb\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aabb\", \"abab\", \"baab\"]"}
{"id": "fvapps_001443", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_path_number : String → Nat\n  | s =>\nsorry\n\ndef MOD : Nat := 1000000007\n\ndef mkString (c : String) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem find_path_number_positive (s : String) :\n  find_path_number s > 0 := by\nsorry\n\ntheorem find_path_number_within_bounds (s : String) :\n  find_path_number s < MOD := by\nsorry\n\ntheorem find_path_number_empty :\n  find_path_number \"\" = 1 := by\nsorry\n\ntheorem find_path_number_single_char :\n  find_path_number \"l\" = 2 ∧ find_path_number \"r\" = 4 := by\nsorry\n\ntheorem find_path_number_concat_bounds (s : String) :\n  find_path_number (s ++ s) < MOD := by\nsorry\n\ntheorem find_path_number_lr_distinct (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  find_path_number (mkString \"l\" n) ≠\n  find_path_number (mkString \"r\" n) := by\nsorry\n\ntheorem find_path_number_modulo (s : String) :\n  find_path_number s = find_path_number s % MOD := by\nsorry\n\ntheorem find_path_number_concat_distinct (s1 s2 : String)\n  (h1 : s1 ≠ \"\") (h2 : s2 ≠ \"\") :\n  find_path_number (s1 ++ s2) ≠ find_path_number s1 ∧\n  find_path_number (s1 ++ s2) ≠ find_path_number s2 := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_path_number \"lrl\"\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval find_path_number \"rll\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_path_number \"r\""}
{"id": "fvapps_001450", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_yalalovichik_substrings (s: String) : Nat :=\n  sorry\n\ndef longest_run (s: String) : Nat :=\n  sorry", "vc-theorems": "theorem count_always_nonnegative (s: String) (h: s.length > 0):\n  count_yalalovichik_substrings s ≥ 0 :=\nsorry\n\ntheorem single_char_count (c: Char):\n  count_yalalovichik_substrings (String.singleton c) = 1 :=\nsorry\n\ntheorem repeated_single_char (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"a\")\n  count_yalalovichik_substrings s = n :=\nsorry\n\ntheorem alternating_chars (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"ab\")\n  count_yalalovichik_substrings s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"xxx\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aa\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aaa\""}
{"id": "fvapps_001451", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_valid_bracket_sequence (n : Nat) : List Nat :=\n  sorry\n\ndef analyze_brackets (n : Nat) (brackets : List Nat) : Nat × Nat × Nat × Nat :=\n  sorry", "vc-theorems": "theorem minimal_valid_case :\n  analyze_brackets 2 [1,2] = (1,1,2,1) :=\nsorry\n\ntheorem nested_depth_increases :\n  (analyze_brackets 4 [1,1,2,2]).1 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (2, 4, 6, 9)\n-/\n#guard_msgs in\n#eval analyze_brackets 20 [1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2]\n\n/-\ninfo: (1, 1, 2, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 2 [1, 2]\n\n/-\ninfo: (2, 2, 6, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 8 [1, 1, 2, 1, 2, 2, 1, 2]"}
{"id": "fvapps_001452", "vc-description": "/- Helper for String operations -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def make_zero_matrix (n m : Nat) : List String :=\n  List.replicate n (String.mk (List.replicate m '0'))\n\ndef make_one_matrix (n m : Nat) : List String :=\n  List.replicate n (String.mk (List.replicate m '1'))", "vc-helpers": "", "vc-definitions": "def String.replicate (n : Nat) (c : Char) : String :=\n  sorry\n\ndef List.modifyNth {α : Type} (idx : Nat) (f : α → α) (xs : List α) : List α :=\n  sorry\n\ndef process_matrix_queries (n m : Nat) (matrix : List String) (queries : List (List Nat)) : List String :=\n  sorry", "vc-theorems": "theorem empty_queries_preserves_matrix (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 10) (h4 : m ≤ 10)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [] = matrix :=\nsorry\n\ntheorem single_element_query_sets_one (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 5) (h4 : m ≤ 5)\n    (h5 : matrix = make_zero_matrix n m)\n    (i j : Nat) (h6 : i ≤ n) (h7 : j ≤ m) :\n    process_matrix_queries n m matrix [[i, j, i, j]] =\n    List.modifyNth (i - 1)\n      (fun s => s.take (j - 1) ++ \"1\" ++ s.drop j)\n      matrix :=\nsorry\n\ntheorem full_matrix_query_sets_all_ones (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 5) (h4 : m ≤ 5)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [[1, 1, n, m]] =\n    make_one_matrix n m :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001456", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_magnet_attract (n k : Nat) (s : String) : Nat :=\nsorry\n\ndef countChar (s : String) (c : Char) : Nat :=\nsorry\n\ndef String.atN (s : String) (n : Nat) : Char :=\nsorry\n\ndef countAdjacentPairs (n : Nat) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem max_magnet_blocked_by_x {n k : Nat} {s : String} :\n  (∀ i j, 0 ≤ i → i < n → 0 ≤ j → j < n →\n    s.atN i = 'M' → s.atN j = 'I' →\n    ∃ x, min i j ≤ x ∧ x ≤ max i j ∧ s.atN x = 'X') →\n  max_magnet_attract n k s = 0 :=\nsorry\n\ntheorem max_magnet_distance_zero {n : Nat} {s : String} :\n  max_magnet_attract n 0 s ≤ countAdjacentPairs n s :=\nsorry\n\ntheorem max_magnet_output_nonNeg {n k : Nat} {s : String} :\n  max_magnet_attract n k s ≥ 0 :=\nsorry\n\ntheorem max_magnet_output_bounded {n k : Nat} {s : String} :\n  max_magnet_attract n k s ≤ min (countChar s 'M') (countChar s 'I') :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_magnet_attract 4 5 \"I::M\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 9 10 \"MIM_XII:M\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 5 3 \"MI:IM\""}
{"id": "fvapps_001458", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_profit_path (n : Nat) (edges : List (Nat × Nat × Int)) (queries : List (Nat × Nat)) : List Int :=\nsorry\n\ndef isConnectedTree (edges : List (Nat × Nat × Int)) : Prop :=\nsorry\n\ndef isValidPath (edges : List (Nat × Nat × Int)) (start finish : Nat) (path : List Nat) : Prop :=\nsorry", "vc-theorems": "theorem singleton_tree_zero (u v : Nat)\n  (h : u = 1 ∧ v = 1) :\n  solve_max_profit_path 1 [] [(u, v)] = [0] :=\nsorry\n\ntheorem line_graph_max_profit (edges : List (Nat × Nat × Int))\n  (h_edges : edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) :\n  solve_max_profit_path 4 edges [(1, 4)] = [3] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001469", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def MOD : Nat := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_zombie_cars (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_zombie_cars_output_range (n k : Nat) :\n  n ≥ 1 → k ≥ 1 → solve_zombie_cars n k < MOD :=\nsorry\n\ntheorem solve_zombie_cars_k_one (n k : Nat) :\n  n ≥ 1 → k = 1 → solve_zombie_cars n k = if n = 1 then 1 else 0 :=\nsorry\n\ntheorem solve_zombie_cars_formula (n k : Nat) :\n  n ≥ 1 → k ≥ 1 →\n  solve_zombie_cars n k = (k * (k-1)^(n-1)) % MOD :=\nsorry\n\ntheorem solve_zombie_cars_known_values :\n  solve_zombie_cars 2 2 = 2 ∧\n  solve_zombie_cars 3 3 = 12 ∧\n  solve_zombie_cars 4 3 = 24 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001476", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def is_valid_shot (n : Nat) (shot : Nat × Nat) : Bool :=\n  1 ≤ shot.1 ∧ shot.1 ≤ n ∧ shot.2 ≥ 1", "vc-helpers": "", "vc-definitions": "def solve_parrot_hunt (n : Nat) (init_parrots : List Nat) (num_shots : Nat) (shots : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_parrot_hunt_no_shots_preserves_input\n  (n : Nat) (init_parrots : List Nat) (h : init_parrots.length = n) :\n  solve_parrot_hunt n init_parrots 0 [] = init_parrots :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001477", "vc-description": "", "vc-preamble": "def natLeBool (a b : Nat) : Bool :=\n  if a ≤ b then true else false", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef calculate_offense_ways (n : Nat) (numbers : List Nat) : Nat :=\nsorry\n\ndef isSorted (l : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem result_range {n : Nat} {numbers : List Nat} :\n  let result := calculate_offense_ways n numbers\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem single_number {x : Nat} :\n  x > 0 →\n  calculate_offense_ways 1 [x] = x :=\nsorry\n\ntheorem impossible_combinations_zero :\n  calculate_offense_ways 2 [1, 1] = 0 ∧\n  calculate_offense_ways 3 [2, 2, 2] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval calculate_offense_ways 1 [4]\n\n/-\ninfo: 45\n-/\n#guard_msgs in\n#eval calculate_offense_ways 2 [10, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_offense_ways 4 [2, 3, 1, 3]"}
{"id": "fvapps_001480", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry\n\ndef findOptimalAttack (n : Nat) (edges : List (Nat × Nat)) : Nat × Nat :=\n  sorry\n\ndef getAdjList (n : Nat) (edges : List (Nat × Nat)) : List (List Nat) :=\n  sorry\n\ndef componentSize (adj : List (List Nat)) (start visited : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_optimal_attack_output_bounds {n : Nat} {edges : List (Nat × Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges\n  1 ≤ attack_node ∧ attack_node ≤ n ∧\n  1 ≤ max_subgraph ∧ max_subgraph ≤ n-1 :=\nsorry\n\ntheorem breaking_point_subgraph_sizes {n : Nat} {edges : List (Nat × Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges;\n  let adj := getAdjList n edges;\n  ∀ node neighbors, neighbors = (adj.get? (attack_node-1)).getD [] →\n  node ∈ neighbors →\n  componentSize adj [node] [attack_node] ≤ max_subgraph :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001482", "vc-description": "/- Output is always within valid mod range -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Function is deterministic for same input -/\n\n/- First values are monotonically increasing -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD : Nat := 10^9 + 7\n\ndef solve_prime_sum (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_prime_sum_output_range (n: Nat) :\n  solve_prime_sum n < MOD :=\nsorry\n\ntheorem solve_prime_sum_deterministic (n: Nat) :\n  solve_prime_sum n = solve_prime_sum n :=\nsorry\n\ntheorem solve_prime_sum_monotone_init :\n  solve_prime_sum 1 < solve_prime_sum 2 :=\nsorry", "vc-postamble": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_prime_sum 1\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_prime_sum 2\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval solve_prime_sum 3"}
{"id": "fvapps_001483", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef lcm (a b : Nat) : Nat :=\n  sorry\n\ndef find_gcd_lcm_pairs (pairs : List (Nat × Nat)) : List (Nat × Nat) :=\n  sorry", "vc-theorems": "theorem gcd_divides {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let g := gcd x y\n  x % g = 0 ∧ y % g = 0 :=\nsorry\n\ntheorem lcm_dividedby {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let l := lcm x y\n  l % x = 0 ∧ l % y = 0 :=\nsorry\n\ntheorem gcd_lcm_product {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y * lcm x y = x * y :=\nsorry\n\ntheorem gcd_upper_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y ≤ min x y :=\nsorry\n\ntheorem lcm_lower_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  lcm x y ≥ max x y :=\nsorry\n\ntheorem same_number_gcd_lcm {n : Nat} (h : n > 0) :\n  gcd n n = n ∧ lcm n n = n :=\nsorry\n\ntheorem find_gcd_lcm_pairs_preserves_length {pairs : List (Nat × Nat)} :\n  pairs.length = (find_gcd_lcm_pairs pairs).length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001484", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_jewels (jewels stones : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem count_jewels_properties_non_negative (jewels stones : String) :\n  count_jewels jewels stones ≥ 0 :=\nsorry\n\ntheorem count_jewels_bounded_by_stones (jewels stones : String) :\n  count_jewels jewels stones ≤ stones.length :=\nsorry\n\ntheorem count_jewels_empty_jewels (stones : String) :\n  count_jewels \"\" stones = 0 :=\nsorry\n\ntheorem count_jewels_empty_stones (jewels : String) :\n  count_jewels jewels \"\" = 0 :=\nsorry\n\ntheorem count_jewels_duplicates (jewels stones : String) :\n  count_jewels (jewels ++ jewels) stones = count_jewels jewels stones :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_jewels \"abc\" \"abcdef\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_jewels \"aA\" \"abAZ\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_jewels \"what\" \"none\""}
{"id": "fvapps_001495", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_sequence (a b n : Nat) : Nat :=\nsorry\n\ndef bitXor (a b : Nat) : Nat :=\nsorry\n\ndef bitNot (a : Nat) : Nat :=\nsorry\n\ndef bitLength (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_sequence_nonnegative (a b n : Nat) :\n  n > 0 → n ≤ 3 → solve_sequence a b n ≥ 0 :=\nsorry\n\ntheorem solve_sequence_first (a b : Nat) :\n  solve_sequence a b 1 = a :=\nsorry\n\ntheorem solve_sequence_second (a b : Nat) :\n  solve_sequence a b 2 = b :=\nsorry\n\ntheorem solve_sequence_symmetric (a b : Nat) :\n  solve_sequence a b 3 = solve_sequence b a 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_sequence 10 12 2"}
{"id": "fvapps_001500", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_series (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_series_increases (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  solve_series (n+1) > solve_series n :=\nsorry\n\ntheorem solve_series_one :\n  solve_series 1 = 1 :=\nsorry\n\ntheorem solve_series_large_bound (n : Nat) (h : n = 1000000) :\n  solve_series n < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 561\n-/\n#guard_msgs in\n#eval solve_series 8\n\n/-\ninfo: 1081\n-/\n#guard_msgs in\n#eval solve_series 10\n\n/-\ninfo: 31\n-/\n#guard_msgs in\n#eval solve_series 3"}
{"id": "fvapps_001503", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n m : Nat) : List Nat :=\nsorry\n\ndef cell_advance_hero1 (row col n m k : Nat) : (Nat × Nat) :=\nsorry\n\ndef cell_advance_hero2 (row col n m k : Nat) : (Nat × Nat) :=\nsorry\n\ndef find_destroyed_cells (advance : Nat → Nat → Nat → Nat → Nat → (Nat × Nat)) (n m k : Nat) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem solve_output_range {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.length result = n * m ∧\n  ∀ x, x ∈ result → 1 ≤ x ∧ x ≤ n * m * 2 := by\n  sorry\n\ntheorem solve_first_last {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.head! result ≥ List.getLast! result ∧\n  List.getLast! result ≥ 1 := by\n  sorry\n\ntheorem cell_advance_hero1_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero1 row col n m k;\n  1 ≤ result.2 ∧ result.2 ≤ m := by\n  sorry\n\ntheorem cell_advance_hero2_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero2 row col n m k;\n  1 ≤ result.1 ∧ result.1 ≤ n := by\n  sorry\n\ntheorem destroyed_cells_bounds {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (∀ p ∈ cells1, 1 ≤ p.1 ∧ p.1 ≤ n ∧ 1 ≤ p.2 ∧ p.2 ≤ m) ∧\n  (∀ p ∈ cells2, 1 ≤ p.1 ∧ p.1 ≤ n ∧ 1 ≤ p.2 ∧ p.2 ≤ m) := by\n  sorry\n\ntheorem destroyed_cells_start {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (1, 1) ∈ cells1 ∧ (1, 1) ∈ cells2 := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_001504", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef calculate_possible_schedules (n : Nat) : Nat :=\n  sorry\n\ndef pow (base n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem calculate_possible_schedules_mod_bounds (n : Nat) :\n  0 ≤ calculate_possible_schedules n ∧ calculate_possible_schedules n < MOD :=\nsorry\n\ntheorem calculate_possible_schedules_odd_even_match (n : Nat) :\n  calculate_possible_schedules n =\n    if n % 2 = 0\n    then ((pow 3 n) + 3) % MOD\n    else ((pow 3 n) - 3) % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 2\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 3\n\n/-\ninfo: 240\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 5"}
{"id": "fvapps_001507", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_m (n : Nat) (nums : List Nat) : Int :=\nsorry\n\ndef hasAllOnes (n : Nat) : Bool :=\nsorry\n\ndef hasPowerOfTwo (n : Int) (pos : Nat) : Bool :=\nsorry", "vc-theorems": "theorem all_ones_returns_negative_one (nums : List Nat) :\n  (∃ n ∈ nums, hasAllOnes n = true) →\n  find_min_m 1 nums = -1 :=\nsorry\n\ntheorem result_nonnegative_when_valid (nums : List Nat) :\n  (¬∃ n ∈ nums, hasAllOnes n = true) →\n  find_min_m 1 nums ≥ 0 :=\nsorry\n\ntheorem result_is_power_of_two_sum (nums : List Nat) (i : Nat) :\n  let result := find_min_m 1 nums\n  result ≠ -1 →\n  hasPowerOfTwo result i = true →\n  ∃ k, result = 2^k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_m 1 [5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_m 1 [7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_m 1 [10]"}
{"id": "fvapps_001513", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubstring (sub : String) (orig : String) : Bool :=\nsorry\n\ndef hasAllChars (sub : String) (orig : String) : Bool :=\nsorry\n\ndef substr (s : String) (i j : Nat) : String :=\nsorry\n\ndef findSubString (s : String) : String :=\nsorry", "vc-theorems": "theorem find_sub_string_is_substring\n  (s : String) (h : s.length > 0) :\n  isSubstring (findSubString s) s :=\nsorry\n\ntheorem find_sub_string_has_all_chars\n  (s : String) (h : s.length > 0) :\n  hasAllChars (findSubString s) s :=\nsorry\n\ntheorem find_sub_string_is_minimal\n  (s : String) (h : s.length > 0)\n  (i j : Nat) (h1 : i < s.length) (h2 : j ≤ s.length) (h3 : i < j) :\n  let sub := substr s i j\n  let result := findSubString s\n  sub.length < result.length → ¬(hasAllChars sub s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001534", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def modInv (a n : Nat) : Nat :=\n  sorry\n\ndef solve_factorial_spell (input : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_factorial_spell_output_length\n  (input : List Nat)\n  : List.length (solve_factorial_spell input) = List.length input :=\nsorry\n\ntheorem solve_factorial_spell_modulo_bounds\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length (solve_factorial_spell input))\n  : (List.get! (solve_factorial_spell input) i) < 1589540031 :=\nsorry\n\ntheorem solve_factorial_spell_zero_case\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length input)\n  (h2 : List.get! input i = 0)\n  : List.get! (solve_factorial_spell input) i = 1 :=\nsorry\n\ntheorem solve_factorial_spell_consecutive_ratio\n  (input : List Nat)\n  (i : Nat)\n  (h1 : i + 1 < List.length input)\n  (h2 : List.get! input (i + 1) = List.get! input i + 1)\n  (h3 : List.get! input i > 0)\n  : (List.get! (solve_factorial_spell input) (i + 1) *\n     (modInv (List.get! (solve_factorial_spell input) i) 1589540031)) % 1589540031 =\n    List.get! input (i + 1) :=\nsorry\n\ntheorem solve_factorial_spell_input_bound\n  (input : List Nat)\n  (h : ∃ i, i < List.length input ∧ List.get! input i > 100000)\n  : solve_factorial_spell input = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_factorial_spell [1, 2, 3, 4]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_factorial_spell [5]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_factorial_spell [6, 7]"}
{"id": "fvapps_001538", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_filter_pattern : String → Bool :=\nsorry\n\ndef valid_photo_pattern : String → Bool :=\nsorry\n\ndef process_chefgram_filters : String → List String → Nat :=\nsorry", "vc-theorems": "theorem size_threshold_consistency\n  (n : Nat)\n  (h1 : n ∈ [1000, 1024, 1048]) :\n  let photo := String.mk (List.replicate 10 'w')\n  let filter := \"+-+-+-+-+-\"\n  let filters := List.replicate n filter\n  let result := process_chefgram_filters photo filters\n  0 ≤ result ∧ result < 10^9 + 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wwwwwwwwww\" [\"+-+-+-+-+-\", \"----------\", \"+---------\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wbwbwbwbwb\" [\"+-+-+-+-+-\", \"+-+-------\", \"----+-+-+-\"]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"bbbbbbbbbb\" [\"----------\", \"----------\"]"}
{"id": "fvapps_001550", "vc-description": "", "vc-preamble": "def Matrix (α : Type u) (n : Nat) := Array (Array α)", "vc-helpers": "", "vc-definitions": "def standardDeterminant {n : Nat} (M : Matrix Int n) : Int :=\nsorry\n\ndef identityMatrix (n : Nat) : Matrix Int n :=\nsorry\n\ndef zeroMatrix (n : Nat) : Matrix Int n :=\nsorry\n\ndef scaleMatrix {n : Nat} (c : Int) (M : Matrix Int n) : Matrix Int n :=\nsorry\n\ndef determinant {n : Nat} (M : Matrix Int n) : Int :=\nsorry", "vc-theorems": "theorem determinant_matches_standard_implementation {n : Nat} (M : Matrix Int n) :\n  determinant M = standardDeterminant M :=\nsorry\n\ntheorem determinant_identity {n : Nat} :\n  determinant (identityMatrix n) = 1 :=\nsorry\n\ntheorem determinant_zero {n : Nat} :\n  determinant (zeroMatrix n) = 0 :=\nsorry\n\ntheorem determinant_scaling {n : Nat} (M : Matrix Int n) (c : Int) :\n  determinant (scaleMatrix c M) = c^n * determinant M :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval determinant #[[5]]\n\n/-\ninfo: -2\n-/\n#guard_msgs in\n#eval determinant #[[1, 2], [3, 4]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval determinant #[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}
{"id": "fvapps_001554", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def primeFactors (n : Nat) : List Nat :=\n  sorry\n\ndef find_spec_prod_part (n : Nat) (mode : String) : String ⊕ (List Nat × Nat) :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem prime_find_spec_prod_part (n : Nat) (h : n ≥ 2) :\n  is_prime n = true →\n  find_spec_prod_part n \"max\" = Sum.inl \"It is a prime number\" ∧\n  find_spec_prod_part n \"min\" = Sum.inl \"It is a prime number\" :=\nsorry\n\ntheorem partition_product_equals_input (n : Nat) (h1 : n ≥ 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (max_parts, _), Sum.inr (min_parts, _) =>\n    (max_parts.foldl Nat.mul 1 = n) ∧\n    (min_parts.foldl Nat.mul 1 = n)\n  | _, _ => False\n  :=\nsorry\n\ntheorem min_max_relationship (n : Nat) (h1 : n ≥ 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (_, max_score), Sum.inr (_, min_score) => max_score ≥ min_score\n  | _, _ => False\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001556", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def who_is_winner (moves : List String) : String :=\n  sorry\n\ndef columnHeight (moves : List String) (col : String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_result_states (moves : List String) :\n  let result := who_is_winner moves\n  result = \"Red\" ∨ result = \"Yellow\" ∨ result = \"Draw\" := by\n  sorry\n\ntheorem column_height_bound (moves : List String) (col : String) :\n  columnHeight moves col ≤ 6 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"G_Red\", \"B_Yellow\"]\n\n/-\ninfo: 'Red'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Yellow\", \"B_Red\", \"B_Yellow\", \"C_Red\", \"G_Yellow\", \"C_Red\", \"C_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"F_Yellow\", \"E_Red\", \"D_Yellow\"]\n\n/-\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"C_Yellow\", \"E_Red\", \"G_Yellow\", \"B_Red\", \"D_Yellow\", \"B_Red\", \"B_Yellow\", \"G_Red\", \"C_Yellow\", \"C_Red\", \"D_Yellow\", \"F_Red\", \"E_Yellow\", \"A_Red\", \"A_Yellow\", \"G_Red\", \"A_Yellow\", \"F_Red\", \"F_Yellow\", \"D_Red\", \"B_Yellow\", \"E_Red\", \"D_Yellow\", \"A_Red\", \"G_Yellow\", \"D_Red\", \"D_Yellow\", \"C_Red\"]"}
{"id": "fvapps_001558", "vc-description": "-- Main theorems based on property tests", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def parse_int (s : String) : Nat :=\n  sorry\n\ndef normalize_text (s : String) : String :=\n  sorry\n\ndef int_to_english (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem parse_int_inverse (n : Nat) (h : n ≤ 999) :\n  parse_int (int_to_english n) = n :=\nsorry\n\ntheorem parse_int_specific_example :\n  parse_int \"one hundred twenty three\" = 123 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval parse_int \"zero\"\n\n/-\ninfo: 123\n-/\n#guard_msgs in\n#eval parse_int \"one hundred twenty-three\"\n\n/-\ninfo: 200003\n-/\n#guard_msgs in\n#eval parse_int \"two hundred thousand three\""}
{"id": "fvapps_001561", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h::t) => h + list_sum t\n\ndef list_sorted : List Nat → Bool\n  | [] => true\n  | [_] => true\n  | (a::b::rest) => a ≤ b && list_sorted (b::rest)\n\ndef list_all (l : List Nat) (p : Nat → Bool) : Bool :=\n  List.all l p\n\ndef square (n : Nat) : Nat := n * n", "vc-helpers": "", "vc-definitions": "def decompose (n : Nat) : Option (List Nat) :=\nsorry", "vc-theorems": "theorem decompose_valid (n : Nat) (result : List Nat) :\n  decompose n = some result →\n  (list_sum (List.map square result) = n * n) ∧\n  list_sorted result = true ∧\n  list_all result (λ x => x > 0) = true ∧\n  list_all result (λ x => x < n) = true :=\nsorry\n\ntheorem decompose_2_impossible :\n  decompose 2 = none :=\nsorry\n\ntheorem decompose_3_impossible :\n  decompose 3 = none :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 4, 10]\n-/\n#guard_msgs in\n#eval decompose 11\n\n/-\ninfo: [1, 3, 5, 8, 49]\n-/\n#guard_msgs in\n#eval decompose 50\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval decompose 4"}
{"id": "fvapps_001566", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Int) : Bool :=\nsorry\n\ndef reverse_num (n : Int) : Int :=\nsorry\n\ndef sq_cub_rev_prime (n : Int) : Int :=\nsorry", "vc-theorems": "theorem is_prime_basic_cases :\n  ¬is_prime 1 ∧ is_prime 2 ∧ ¬is_prime 4 ∧ is_prime 5 :=\nsorry\n\ntheorem is_prime_nonpositive (n : Int) :\n  n ≤ 0 → ¬is_prime n :=\nsorry\n\ntheorem is_prime_no_small_divisors {n : Int} (h1 : 2 ≤ n) (h2 : n ≤ 1000) :\n  is_prime n → ∀ i : Int, 2 ≤ i ∧ i * i ≤ n → ¬(i ∣ n) :=\nsorry\n\ntheorem sq_cub_rev_prime_properties (n : Int) (h : 1 ≤ n ∧ n ≤ 39) :\n  sq_cub_rev_prime n > 0 ∧\n  sq_cub_rev_prime n = sq_cub_rev_prime n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 89\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 1\n\n/-\ninfo: 271\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 2\n\n/-\ninfo: 325\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 3"}
{"id": "fvapps_001567", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "def countChar (c : Char) (l : List Char) : Nat :=\n  l.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def pawnMoveTracker (moves : List String) : List (List Char) :=\nsorry", "vc-theorems": "theorem empty_moves_initial_position (moves : List String) :\n  moves = [] →\n  let board := pawnMoveTracker moves\n  (board.length = 8 ∧\n   (∀ row ∈ board, row.length = 8) ∧\n   (∀ i, i < 8 → (board.get! 1).get! i = 'p') ∧\n   (∀ i, i < 8 → (board.get! 6).get! i = 'P')) :=\nsorry\n\ntheorem valid_moves_invariants (moves : List String) :\n  let board := pawnMoveTracker moves\n  (board.length = 8 ∧\n   (∀ row ∈ board, row.length = 8) ∧\n   let whitePawns := (board.foldl (fun acc row => acc + countChar 'P' row) 0)\n   let blackPawns := (board.foldl (fun acc row => acc + countChar 'p' row) 0)\n   0 ≤ whitePawns ∧ whitePawns ≤ 8 ∧\n   0 ≤ blackPawns ∧ blackPawns ≤ 8) :=\nsorry\n\ntheorem valid_first_white_move (file : Char) (rank : Char) :\n  file ∈ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] →\n  rank = '4' →\n  let move := String.mk [file, rank]\n  let board := pawnMoveTracker [move]\n  ((board.get! 6).get! (file.toNat - 'a'.toNat) = '.' ∧\n   (board.get! 4).get! (file.toNat - 'a'.toNat) = 'P') :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001568", "vc-description": "/- For any natural number n, solve returns a single digit (0-9) -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- solve is idempotent: calling it twice gives same result as once -/\n\n/- solve returns single digit for boundary values -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_returns_single_digit (n : Nat) :\n  solve n ≤ 9 :=\nsorry\n\ntheorem solve_idempotent (n : Nat) :\n  solve n = solve (solve n) :=\nsorry\n\ntheorem solve_boundaries_single_digit :\n  solve 1 ≤ 9 ∧\n  solve (10^9) ≤ 9 ∧\n  solve (10^18) ≤ 9 :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 100\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 55\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 123456\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 999999999999999999\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1000000000000000000"}
{"id": "fvapps_001569", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CHARS := ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n\ndef int_to_base_n (num : Nat) (base : Nat) : String :=\nsorry\n\ndef is_polydivisible (s : String) (base : Nat) : Bool :=\nsorry", "vc-theorems": "theorem single_digit_polydivisible {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length) :\n  ∀ (digit : Char), digit ∈ CHARS.take base → is_polydivisible digit.toString base :=\nsorry\n\ntheorem base_conversion_result_bool {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length)\n  (decimal_num : Nat) :\n  let base_n := int_to_base_n decimal_num base\n  ∃ (b : Bool), is_polydivisible base_n base = b :=\nsorry\n\ntheorem zero_polydivisible {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length) :\n  is_polydivisible \"0\" base = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123\" 10\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_polydivisible \"1234\" 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123220\" 6"}
{"id": "fvapps_001574", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countOnes (a b : Nat) : Nat :=\nsorry\n\ndef toBinary (n : Nat) : List Nat :=\nsorry\n\ndef countBinaryOnes (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem countOnes_non_negative\n  (a b : Nat)\n  (h1 : 0 < a) (h2 : a ≤ 10^6)\n  (h3 : 0 < b) (h4 : b ≤ 10^6) :\n  0 ≤ countOnes a b :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval countOnes 4 7\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval countOnes 5 5\n\n/-\ninfo: 14846928141\n-/\n#guard_msgs in\n#eval countOnes 1 1000000000"}
{"id": "fvapps_001575", "vc-description": "", "vc-preamble": "def DIGS : List String := [\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"]\n\ndef POWS : List String := [\"\", \"十\", \"百\", \"千\", \"万\"]\n\ndef NEG : String := \"负\"", "vc-helpers": "", "vc-definitions": "def to_chinese_numeral (n : Int) : String :=\nsorry", "vc-theorems": "theorem sign_property {n : Int} :\n  n < 0 → (to_chinese_numeral n).startsWith NEG ∧\n  n ≥ 0 → ¬(to_chinese_numeral n).startsWith NEG :=\nsorry\n\ntheorem char_validation {n : Int} :\n  ∀ c : Char, c ∈ (to_chinese_numeral n).data →\n    c ∈ (NEG.data ++ (String.join DIGS).data ++ (String.join POWS).data) :=\nsorry\n\ntheorem single_digit {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 9) :\n  to_chinese_numeral n = DIGS[n.toNat - 1]! :=\nsorry\n\ntheorem teen_numbers {n : Int} (h1 : 10 ≤ n) (h2 : n ≤ 19) :\n  (to_chinese_numeral n).startsWith \"十\" ∧\n  (n > 10 → ∃ c : Char, c ∈ (String.join DIGS).data ∧\n    (to_chinese_numeral n).data[1]? = some c) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '一百二十三点四五'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 123.45\n\n/-\ninfo: '负一千零四'\n-/\n#guard_msgs in\n#eval to_chinese_numeral -1004\n\n/-\ninfo: '一万零四点零零五'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 10004.005"}
{"id": "fvapps_001576", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_inc_dec (n : Int) : Nat :=\n  sorry\n\ndef xCy (n m : Int) : Int :=\n  sorry", "vc-theorems": "theorem total_inc_dec_non_negative (x : Int) :\n  x ≥ 0 → total_inc_dec x ≥ 1 :=\nsorry\n\ntheorem total_inc_dec_negative (x : Int) :\n  x < 0 → total_inc_dec x = 0 :=\nsorry\n\ntheorem total_inc_dec_monotonic (x : Int) :\n  x > 0 → total_inc_dec x > total_inc_dec (x-1) :=\nsorry\n\ntheorem xCy_non_negative (x y : Int) :\n  y ≤ x → xCy x y ≥ 0 :=\nsorry\n\ntheorem xCy_int_valued (x y : Int) :\n  y ≤ x → ∃ n : Int, xCy x y = n :=\nsorry\n\ntheorem xCy_symmetry (x y : Int) :\n  y ≤ x ∧ y > 0 → xCy x y = xCy x (x-y) :=\nsorry\n\ntheorem xCy_invalid (x y : Int) :\n  y > x → xCy x y = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval total_inc_dec 0\n\n/-\ninfo: 475\n-/\n#guard_msgs in\n#eval total_inc_dec 3\n\n/-\ninfo: 4954\n-/\n#guard_msgs in\n#eval total_inc_dec 5"}
{"id": "fvapps_001577", "vc-description": "", "vc-preamble": "def char_list_eq (l1 l2 : List Char) : Prop :=\n  ∀ c : Char, c ∈ l1 ↔ c ∈ l2", "vc-helpers": "", "vc-definitions": "def middle_permutation (s : String) : String :=\nsorry", "vc-theorems": "theorem middle_permutation_symmetric (s : String) :\n  middle_permutation s = middle_permutation s := by\nsorry\n\ntheorem middle_permutation_length (s : String) :\n  (middle_permutation s).length = s.length := by\nsorry\n\ntheorem middle_permutation_chars (s : String) :\n  char_list_eq s.data (middle_permutation s).data := by\nsorry\n\ntheorem middle_permutation_valid (s : String) :\n  ∃ perm : List Char, middle_permutation s = String.mk perm ∧\n    ∃ (π : List Char → List Char),\n      perm = π s.data ∧\n      (∀ (l : List Char), (π l).length = l.length) ∧\n      (∀ (l : List Char), char_list_eq (π l) l) := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bac'\n-/\n#guard_msgs in\n#eval middle_permutation \"abc\"\n\n/-\ninfo: 'bdca'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcd\"\n\n/-\ninfo: 'cbxda'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcdx\""}
{"id": "fvapps_001580", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : String) : Bool :=\n  sorry\n\ndef isSubstring (sub str : String) : Bool :=\n  sorry\n\ndef longest_palindrome (s : String) : String :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry\n\ndef substring (s : String) (i j : Nat) : String :=\n  sorry", "vc-theorems": "theorem output_is_palindrome {s : String} :\n  let result := longest_palindrome s\n  result = \"\" ∨ (result = reverseString result ∧ isSubstring result s)\n  := by\nsorry\n\ntheorem output_is_maximum_length {s : String} :\n  let result := longest_palindrome s\n  ∀ (i j : Nat), i ≤ s.length → j ≤ s.length →\n    let substr := substring s i j\n    substr = reverseString substr →\n    substr.length ≤ result.length\n  := by\nsorry\n\ntheorem empty_and_single_char_inputs {s : String} :\n  (s = \"\" → longest_palindrome s = \"\") ∧\n  (s.length = 1 → longest_palindrome s = s)\n  := by\nsorry\n\ntheorem palindrome_input_returns_itself {s : String} :\n  s ≠ \"\" →\n  s = reverseString s →\n  longest_palindrome s = s\n  := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bab'\n-/\n#guard_msgs in\n#eval longest_palindrome \"babad\"\n\n/-\ninfo: 'abababa'\n-/\n#guard_msgs in\n#eval longest_palindrome \"abababa\"\n\n/-\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval longest_palindrome \"cbbd\""}
{"id": "fvapps_001584", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multiply (n k: Nat) : Nat :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem multiply_positive (n k: Nat)\n  (h1: n > 0) (h2: k > 0) : multiply n k > 0 :=\nsorry\n\ntheorem multiply_one (k: Nat)\n  (h: k > 0) : multiply 1 k = 1 :=\nsorry\n\ntheorem multiply_k1_is_one (n: Nat)\n  (h: n > 0) : multiply n 1 = 1 :=\nsorry\n\ntheorem multiply_monotone_k (n k: Nat)\n  (h1: n > 0) (h2: k > 1) :\n  multiply n k ≥ multiply n (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval multiply 24 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval multiply 100 1\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval multiply 20 3"}
{"id": "fvapps_001585", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def almost_everywhere_zero (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef comb (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef num_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem aez_valid_inputs (n : Nat) (k : Nat) :\n  let result := almost_everywhere_zero n k\n  result ≥ 0 :=\nsorry\n\ntheorem aez_zero_k (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 0 = 1 :=\nsorry\n\ntheorem aez_k_greater_than_digits (n : Nat) (k : Nat) (h1 : n > 0) (h2 : k > num_digits n) :\n  almost_everywhere_zero n k = 0 :=\nsorry\n\ntheorem comb_properties (n k : Nat) :\n  let result := comb n k\n  (k > n → result = 0) ∧\n  ((k = 0 ∨ k = n) → result ≤ 1) ∧\n  (k ≤ n → comb n k = comb n (n-k)) :=\nsorry\n\ntheorem aez_single_nonzero (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 1 ≥ num_digits n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 100 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 11 2\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 20 2"}
{"id": "fvapps_001587", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_of_squares (n : Nat) : Nat :=\nsorry\n\ndef one_square (n : Nat) : Bool :=\nsorry\n\ndef two_squares (n : Nat) : Bool :=\nsorry\n\ndef three_squares (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem sum_of_squares_range (n : Nat) (h : n ≥ 1) :\n  1 ≤ sum_of_squares n ∧ sum_of_squares n ≤ 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_squares 15\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 16\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sum_of_squares 17\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 999887641\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_squares 999950886"}
{"id": "fvapps_001588", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def green (n : Nat) : Nat :=\n  sorry\n\ndef first_5_green_numbers (n : Nat) (h : n > 0 ∧ n ≤ 5) :\n  green n = match n with\n    | 1 => 1\n    | 2 => 5\n    | 3 => 6\n    | 4 => 25\n    | 5 => 76\n    | _ => 0 :=\n  sorry\n\ndef green_number_positive (n : Nat) (h : n > 0) :\n  green n > 0 :=\n  sorry\n\ndef green_numbers_ordered (n : Nat) (h : n > 1) :\n  green n > green (n-1) :=\n  sorry\n\ndef green_numbers_unique (n m : Nat) (h1 : n > 0) (h2 : m > 0) (h3 : n ≠ m) :\n  green n ≠ green m :=\n  sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval green 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval green 2\n\n/-\ninfo: 76\n-/\n#guard_msgs in\n#eval green 5"}
{"id": "fvapps_001589", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\nsorry\n\ndef digits_sorted (n : Nat) : List Nat :=\nsorry\n\ndef digits_sorted_desc (n : Nat) : List Nat :=\nsorry\n\ndef next_bigger (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem next_bigger_larger (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 → result > n :=\nsorry\n\ntheorem next_bigger_same_digits (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 →\n  ∀ (r : Nat), result = r → (digits_sorted n = digits_sorted r) :=\nsorry\n\ntheorem next_bigger_minimal (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 →\n  ∀ x, n < x → x < result → digits_sorted x ≠ digits_sorted n :=\nsorry\n\ntheorem next_bigger_none_exists (n : Nat) :\n  next_bigger n = -1 ↔ digits n = digits_sorted_desc n :=\nsorry\n\ntheorem next_bigger_single_digit (n : Nat) :\n  n < 10 → next_bigger n = -1 :=\nsorry\n\ntheorem next_bigger_output_type (n : Nat) :\n  ∃ i : Int, next_bigger n = i :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval next_bigger 12\n\n/-\ninfo: 531\n-/\n#guard_msgs in\n#eval next_bigger 513\n\n/-\ninfo: 2071\n-/\n#guard_msgs in\n#eval next_bigger 2017\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval next_bigger 9876543210"}
{"id": "fvapps_001592", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumDigits (n : Nat) : Nat :=\nsorry\n\ndef isAscending (n : Nat) : Bool :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry\n\ndef find_all (sumDig digs : Nat) : Option (Nat × Nat × Nat) :=\nsorry", "vc-theorems": "theorem empty_for_impossible_sums (sumDig digs : Nat) :\n  (sumDig > 9 * digs ∨ sumDig < digs) → find_all sumDig digs = none :=\nsorry\n\ntheorem valid_output_format {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (count, first, last) := res\n  count > 0 ∧\n  numDigits first = digs ∧\n  numDigits last = digs ∧\n  first ≤ last :=\nsorry\n\ntheorem solutions_have_correct_sum {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (_, first, last) := res\n  sumDigits first = sumDig ∧\n  sumDigits last = sumDig :=\nsorry\n\ntheorem solutions_are_ascending {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (_, first, last) := res\n  isAscending first ∧\n  isAscending last :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [8, 118, 334]\n-/\n#guard_msgs in\n#eval find_all 10 3\n\n/-\ninfo: [1, 999, 999]\n-/\n#guard_msgs in\n#eval find_all 27 3\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval find_all 84 4"}
{"id": "fvapps_001593", "vc-description": "", "vc-preamble": "inductive ValidPart : Type where\n  | empty : ValidPart\n  | single (n : Int) : ValidPart\n  | range (s e : Int) (h : s < e) : ValidPart", "vc-helpers": "", "vc-definitions": "def solution (xs : List Int) : String :=\nsorry\n\ndef parseAsInt (s : String) : Option Int :=\nsorry\n\ndef isValidPart (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solution_empty_list : solution [] = \"\" := by\nsorry\n\ntheorem solution_valid_parts (xs : List Int) :\n  ∀ p ∈ (solution xs).splitOn \",\", isValidPart p = true := by\nsorry\n\ntheorem solution_nonempty_input (xs : List Int) (h : xs ≠ []) :\n  solution xs ≠ \"\" := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '-6,-3-1,3-5,7-11,14,15,17-20'\n-/\n#guard_msgs in\n#eval solution [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\n\n/-\ninfo: '-3--1,2,10,15,16,18-20'\n-/\n#guard_msgs in\n#eval solution [-3, -2, -1, 2, 10, 15, 16, 18, 19, 20]\n\n/-\ninfo: '1-5'\n-/\n#guard_msgs in\n#eval solution [1, 2, 3, 4, 5]"}
{"id": "fvapps_001607", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_smaller (n : Nat) : Int :=\nsorry\n\ndef has_same_digits (n m : Nat) : Bool :=\nsorry", "vc-theorems": "theorem next_smaller_result_positive (n : Nat) (h: n ≥ 10) :\n  next_smaller n = -1 ∨ next_smaller n > 0 :=\nsorry\n\ntheorem single_digit_returns_negative_one (n : Nat) (h: n < 10) :\n  next_smaller n = -1 :=\nsorry\n\ntheorem zero_returns_negative_one :\n  next_smaller 0 = -1 :=\nsorry\n\ntheorem result_preserves_number_of_digits (n : Nat) (h: n ≥ 10) :\n  next_smaller n ≠ -1 →\n  (String.length (toString (next_smaller n).natAbs) = String.length (toString n)) ∧\n  next_smaller n < n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval next_smaller 21\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval next_smaller 1027\n\n/-\ninfo: 123456789\n-/\n#guard_msgs in\n#eval next_smaller 123456798"}
{"id": "fvapps_001608", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isNStraightHand (hand : List Int) (w : Int) : Bool :=\n  sorry\n\ndef isConsecutive (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem div_by_w_necessary {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w ≤ 10000) (hh : List.length hand > 0) :\n  isNStraightHand hand w → List.length hand % w = 0 :=\nsorry\n\ntheorem w_one_always_true {hand : List Int} (hh : List.length hand > 0) :\n  isNStraightHand hand 1 = true :=\nsorry\n\ntheorem monotonic_w {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w < List.length hand) (hh : List.length hand > 0) :\n  isNStraightHand hand w → ¬isNStraightHand hand (w + 1) :=\nsorry\n\ntheorem consecutive_numbers_possible {hand : List Int}\n  (hh : List.length hand > 0)\n  (h_len : List.length hand ≥ 2)\n  (h_consec : isConsecutive hand)\n  (h_div : List.length hand % 3 = 0) :\n  isNStraightHand hand 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 6, 2, 3, 4, 7, 8] 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 4, 5] 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 1, 2, 2, 3, 3] 3"}
{"id": "fvapps_001611", "vc-description": "", "vc-preamble": "structure FormatResult where\n  isStartF : Bool\n  containsAssign : Bool\n\ndef checkFormat (s : String) : FormatResult :=\n  { isStartF := s.data.head? = some 'f',\n    containsAssign := s.data.contains '=' }", "vc-helpers": "", "vc-definitions": "def calculateSequences : List Int → List String :=\nsorry\n\ndef extractValue (s : String) : String :=\nsorry\n\ndef extractNumber (s : String) : Int :=\nsorry", "vc-theorems": "theorem list_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let fmt := checkFormat x\n    fmt.isStartF ∧ fmt.containsAssign :=\nsorry\n\ntheorem value_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n ≥ 5 ∨ n ≤ -51 → val = \"MAGNA NIMIS!\") ∧\n    (n ≤ 3 → val.data.contains '.') :=\nsorry\n\ntheorem order_matches_reversed {inputs : List Int} :\n  let result := calculateSequences inputs\n  let nums := result.map extractNumber\n  nums = inputs.reverse :=\nsorry\n\ntheorem known_values {inputs : List Int} (h : inputs.length > 0) :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n = 0 → val = \"0.00\") ∧\n    (n = 1 → val = \"6.00\") ∧\n    (n = -1 → val = \"-4.00\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval calculate_sequences [0, 1, -2, -3, -4, -5, -6, -7, -8, -9, 10]"}
{"id": "fvapps_001621", "vc-description": "-- Cube sum matches formula\n\n-- Perfect squares are identified correctly\n\n-- Product of perfect squares is perfect square\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_cube_sum (n : Nat) : Nat :=\nsorry\n\ndef is_perfect_square (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem cube_sum_matches_formula (n : Nat) :\n  calculate_cube_sum n = ((n * (n + 1)) / 2) ^ 2 :=\nsorry\n\ntheorem perfect_square_properties (n : Nat) (h : n > 1) :\n  (is_perfect_square (n * n) = true) ∧\n  (is_perfect_square (n * n + 1) = false) ∧\n  (is_perfect_square (n * n - 1) = false) :=\nsorry\n\ntheorem perfect_square_product (n : Nat) :\n  is_perfect_square n = true → is_perfect_square (n * n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001622", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def Graph := List (List Nat)", "vc-helpers": "", "vc-definitions": "def is_valid_graph (g : Graph) : Bool :=\nsorry\n\ndef find_most_popular_friend (friend_lists : List String) : Nat × Float :=\nsorry", "vc-theorems": "theorem most_popular_friend_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  1 ≤ popular ∧ popular ≤ friend_lists.length :=\nsorry\n\ntheorem notoriety_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  0 ≤ notoriety ∧ notoriety ≤ Float.ofNat friend_lists.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001628", "vc-description": "/- Query function is consistent for matrices with small values (1-25) -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Query function is consistent for matrices with large values (26-50) -/\n\n/- Result matrix has correct dimensions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_matrix_guessing (n m K : Nat) (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem solve_matrix_query_consistency_small {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  1 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 25 :=\nsorry\n\ntheorem solve_matrix_query_consistency_large {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  26 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 50 :=\nsorry\n\ntheorem basic_dimensions {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  result.length = n ∧ ∀ row ∈ result, row.length = m :=\nsorry", "vc-postamble": "/-\ninfo: n\n-/\n#guard_msgs in\n#eval len solve_matrix_guessing(n, m, c, mock_query_func)\n\n/-\ninfo: m\n-/\n#guard_msgs in\n#eval len result[0]"}
{"id": "fvapps_001633", "vc-description": "", "vc-preamble": "def isValidDistribution (s : String) : Bool :=\n  s = \"uniform\" || s = \"poisson\"", "vc-helpers": "", "vc-definitions": "def identify_distribution (samples : List Int) : String :=\n  sorry", "vc-theorems": "theorem identify_distribution_valid (samples : List Int)\n  (h : samples.length ≥ 2) :\n  isValidDistribution (identify_distribution samples) :=\nsorry\n\ntheorem identify_distribution_deterministic (samples : List Int) :\n  identify_distribution samples = identify_distribution samples :=\nsorry\n\ntheorem identify_distribution_uniform (samples : List Int) :\n  samples.length ≥ 2 → identify_distribution samples = \"uniform\" :=\nsorry\n\ntheorem identify_distribution_poisson (samples : List Int) :\n  samples.length ≥ 2 → identify_distribution samples = \"poisson\" :=\nsorry\n\ntheorem identify_distribution_scale_invariant (samples : List Int)\n  (scale : Int) (h : scale ≠ 0) :\n  identify_distribution samples =\n  identify_distribution (samples.map (· * scale)) :=\nsorry\n\ntheorem identify_distribution_order_invariant (samples₁ samples₂ : List Int)\n  (h : samples₁.length = samples₂.length)\n  (h2 : ∀ x, x ∈ samples₁ ↔ x ∈ samples₂) :\n  identify_distribution samples₁ = identify_distribution samples₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [1, 2, 3, 2, 1]\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [10, 8, 9, 8, 12]\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [-5, -4, -3, -4, -5]"}
{"id": "fvapps_001634", "vc-description": "", "vc-preamble": "def minimum (lst : List Int) : Option Int := lst.foldl (fun min x => match min with\n  | none => some x\n  | some m => if x < m then some x else some m) none\n\ndef maximum (lst : List Int) : Option Int := lst.foldl (fun max x => match max with\n  | none => some x\n  | some m => if x > m then some x else some m) none", "vc-helpers": "", "vc-definitions": "def find_min_index (lst : List Int) : Int :=\nsorry\n\ndef find_max_index (lst : List Int) : Int :=\nsorry\n\ndef find_second_max (lst : List Int) : Option Int :=\nsorry", "vc-theorems": "theorem min_index_empty (lst : List Int) :\n  lst = [] → find_min_index lst = -1 :=\nsorry\n\ntheorem min_index_valid (lst : List Int) (result : Int) :\n  result = find_min_index lst →\n  result ≠ -1 →\n  (∃ min : Int, minimum lst = some min ∧\n   0 ≤ result ∧ result < lst.length ∧\n   lst.get ⟨result.toNat, sorry⟩ = min ∧\n   lst.count min = 1) :=\nsorry\n\ntheorem min_index_duplicate (lst : List Int) :\n  find_min_index lst = -1 →\n  lst ≠ [] →\n  (∃ min : Int, minimum lst = some min ∧ lst.count min > 1) :=\nsorry\n\ntheorem max_index_empty (lst : List Int) :\n  lst = [] → find_max_index lst = -1 :=\nsorry\n\ntheorem max_index_valid (lst : List Int) (result : Int) :\n  result = find_max_index lst →\n  result ≠ -1 →\n  (∃ max : Int, maximum lst = some max ∧\n   0 ≤ result ∧ result < lst.length ∧\n   lst.get ⟨result.toNat, sorry⟩ = max ∧\n   lst.count max = 1) :=\nsorry\n\ntheorem max_index_duplicate (lst : List Int) :\n  find_max_index lst = -1 →\n  lst ≠ [] →\n  (∃ max : Int, maximum lst = some max ∧ lst.count max > 1) :=\nsorry\n\ntheorem second_max_short (lst : List Int) :\n  lst.length < 2 → find_second_max lst = none :=\nsorry\n\ntheorem second_max_valid (lst : List Int) (result : Int) :\n  find_second_max lst = some result →\n  (∃ max : Int, maximum lst = some max ∧\n   result < max ∧\n   (∀ x, x ∈ lst → ¬(result < x ∧ x < max)) ∧\n   result ∈ lst) :=\nsorry\n\ntheorem second_max_none (lst : List Int) :\n  find_second_max lst = none →\n  lst.length ≥ 2 →\n  (∃ x : Int, ∀ y ∈ lst, y = x) :=\nsorry\n\ntheorem results_from_input (lst : List Int) :\n  let min_idx := find_min_index lst\n  let max_idx := find_max_index lst\n  let second := find_second_max lst\n  (min_idx ≠ -1 → (∃ x, lst.get ⟨min_idx.toNat, sorry⟩ = x ∧ x ∈ lst)) ∧\n  (max_idx ≠ -1 → (∃ x, lst.get ⟨max_idx.toNat, sorry⟩ = x ∧ x ∈ lst)) ∧\n  (second.isSome → (Option.get! second) ∈ lst) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_second_max [4, 1, 2, 3, 5]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval find_second_max [1, 1, 1, 1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_second_max [1, 2, 3, 3]"}
{"id": "fvapps_001639", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPerfectSquare (n : Nat) : Bool :=\n  sorry\n\ndef generateValidBoard (size : Nat) : List (List Nat) :=\n  sorry\n\ndef validateSudoku (board : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem invalid_size_board {n : Nat} :\n  n > 0 → ¬(isPerfectSquare n) →\n  validateSudoku (List.replicate n (List.replicate n 1)) = false :=\nsorry\n\ntheorem valid_size_board {n : Nat} :\n  n > 0 → n ≤ 3 →\n  validateSudoku (generateValidBoard (n * n)) = true :=\nsorry\n\ntheorem duplicate_in_row {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 0 ∧ (board.head!).length > 1\n    then board.set 0 ((board.get! 0).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry\n\ntheorem duplicate_in_column {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 1\n    then board.set 1 ((board.get! 1).set 0 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry\n\ntheorem duplicate_in_square {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 1\n    then board.set 1 ((board.get! 1).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku [[7, 8, 4, 1, 5, 9, 3, 2, 6], [5, 3, 9, 6, 7, 2, 8, 4, 1], [6, 1, 2, 4, 3, 8, 7, 5, 9], [9, 2, 8, 7, 1, 5, 4, 6, 3], [3, 5, 7, 8, 4, 6, 1, 9, 2], [4, 6, 1, 9, 2, 3, 5, 8, 7], [8, 7, 6, 3, 9, 4, 2, 1, 5], [2, 4, 3, 5, 6, 1, 9, 7, 8], [1, 9, 5, 2, 8, 7, 6, 3, 4]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validate_sudoku invalid_board\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku valid_small"}
{"id": "fvapps_001646", "vc-description": "", "vc-preamble": "def listSum (lst : List Int) : Int := lst.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def isPrime (n : Int) : Bool :=\nsorry\n\ndef primeFactor (n: Int) : List Int :=\nsorry\n\ndef sumForList (lst : List Int) : List (Int × Int) :=\nsorry", "vc-theorems": "theorem results_are_prime_factors {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  ∀ pt, pt ∈ sumForList lst →\n    isPrime pt.1 = true ∧\n    ∃ x, x ∈ lst ∧ x % pt.1 = 0 :=\nsorry\n\ntheorem sums_are_correct {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  ∀ pt, pt ∈ sumForList lst →\n    pt.2 = listSum (lst.filter (fun x => x % pt.1 = 0)) :=\nsorry\n\ntheorem factors_ordered {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  List.Pairwise (· ≤ ·) (List.map Prod.fst (sumForList lst)) :=\nsorry\n\ntheorem all_prime_factors_included {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  (∀ p, p ∈ List.map Prod.fst (sumForList lst) →\n    (∃ x, x ∈ lst ∧ x % p = 0 ∧ isPrime p = true)) ∧\n  (∀ x, x ∈ lst → ∀ p, p ∈ primeFactor x →\n    p ∈ List.map Prod.fst (sumForList lst)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [[2, 12], [3, 27], [5, 15]]\n-/\n#guard_msgs in\n#eval sum_for_list [12, 15]\n\n/-\ninfo: [[2, 30], [3, 0], [5, 0]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 30, -45]\n\n/-\ninfo: [[2, 54], [3, 135], [5, 90], [7, 21]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 21, 24, 30, 45]"}
{"id": "fvapps_001653", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidMaze (maze : List String) : Bool :=\nsorry\n\ndef hasExit (maze : List String) : Bool :=\nsorry\n\ndef isKateAt (maze : List String) (i j : Nat) : Bool :=\nsorry", "vc-theorems": "theorem maze_properties (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1) :\n  hasExit maze = true ∨ hasExit maze = false :=\nsorry\n\ntheorem invalid_maze_no_kate (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 0) :\n  ∃ e, hasExit maze = e → False :=\nsorry\n\ntheorem edge_escape (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1)\n  (h3 : ∃ (i j : Nat),\n    (i = 0 ∨ i = maze.length - 1 ∨ j = 0 ∨ j = (maze.get! 0).length - 1) ∧\n    isKateAt maze i j = true) :\n  hasExit maze = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_exit [\"# ##\", \"# k#\", \"####\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval has_exit [\"####\", \"# k#\", \"####\"]"}
{"id": "fvapps_001659", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def path_finder (maze : String) : Bool :=\nsorry\n\ndef stringReplicate (n : Nat) (s : String) : String :=\nsorry\n\ndef stringJoin (l : List String) (sep : String) : String :=\nsorry\n\ndef makeList (n : Nat) (c : Char) : List Char :=\nsorry\n\ndef listToString (l : List Char) : String :=\nsorry\n\ndef make_maze (cells : List Char) : String :=\nsorry", "vc-theorems": "theorem empty_maze_always_solvable (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let row := stringReplicate n \".\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = true :=\nsorry\n\ntheorem border_wall_maze_unsolvable (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let row := stringReplicate n \"W\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = false :=\nsorry\n\ntheorem random_valid_maze_returns_bool (cells : List Char)\n  (h1 : cells.length ≥ 4) (h2 : cells.length ≤ 100)\n  (h3 : ∀ c ∈ cells, c = '.' ∨ c = 'W')\n  (h4 : ∃ n : Nat, n * n = cells.length)\n  (h5 : cells ≠ [] → cells[0] = '.')\n  (h6 : cells ≠ [] → cells[cells.length - 1] = '.') :\n  (path_finder (make_maze cells)) = true ∨ (path_finder (make_maze cells)) = false :=\nsorry\n\ntheorem single_path_solvable :\n  path_finder \"..W\\nW.W\\n...\" = true :=\nsorry\n\ntheorem path_to_self_exists (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let cells := makeList (n*n) '.'\n  path_finder (make_maze cells) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval path_finder \"\\n\".join([\".W.\", \".W.\", \"...\"])\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder maze2"}
{"id": "fvapps_001663", "vc-description": "", "vc-preamble": "def Term := String\n\ndef Equation := String\n\ndef Solution := List (String × Int)", "vc-helpers": "", "vc-definitions": "def solve_equations : List Equation → Option Solution\n  | _ =>\nsorry\n\ndef equation_vars : Equation → List String\n  | _ =>\nsorry\n\ndef solution_vars : Solution → List String\n  | _ => sorry\n\ndef verify_solution (equations : List Equation) (solution : Option Solution) : Bool :=\nsorry", "vc-theorems": "theorem solution_variables_match_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  ∀ v, (∃ eq ∈ equations, v ∈ equation_vars eq) ↔ v ∈ solution_vars s :=\nsorry\n\ntheorem underdetermined_system_no_solution :\n  solve_equations [\"x + y = 1\"] = none :=\nsorry\n\ntheorem solution_satisfies_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  verify_solution equations (some s) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_equations [\"2x + 4y + 6z = 18\", \"3y + 3z = 6\", \"x + 2y = z - 3\"]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval solve_equations [\"x + y = 2\", \"x + y = 3\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_equations [\"x = 1\"]"}
{"id": "fvapps_001664", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Nat) : Nat :=\n  sorry\n\ndef isValidPos (pos : String) : Bool :=\n  sorry\n\ndef knight (s e : String) : Nat :=\n  sorry", "vc-theorems": "theorem knight_valid_range {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e) :\n  let m := knight s e\n  0 ≤ m ∧ m ≤ 6 :=\nsorry\n\ntheorem knight_same_position {p : String}\n  (h : isValidPos p) :\n  knight p p = 0 :=\nsorry\n\ntheorem knight_diagonal_adjacent {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e)\n  (h3 : abs ((s.get! ⟨0⟩).toNat - (e.get! ⟨0⟩).toNat) = 1)\n  (h4 : abs ((s.get! ⟨1⟩).toNat - (e.get! ⟨1⟩).toNat) = 1) :\n  knight s e = 2 :=\nsorry\n\ntheorem knight_symmetric {p t : String}\n  (h1 : isValidPos p) (h2 : isValidPos t) :\n  knight p t = knight t p :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval knight \"a3\" \"b5\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval knight \"a1\" \"c5\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval knight \"d5\" \"d5\""}
{"id": "fvapps_001667", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_interesting (number : Nat) (awesome_phrases : Array Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isRoundNumber (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem is_interesting_result_valid (n : Nat) (phrases : Array Nat) :\n  let result := is_interesting n phrases\n  result = 0 ∨ result = 1 ∨ result = 2 :=\nsorry\n\ntheorem small_numbers_boring (n : Nat) (h : n < 98) :\n  is_interesting n #[] = 0 :=\nsorry\n\ntheorem awesome_phrases_direct_match (n : Nat) (phrases : Array Nat)\n  (h1 : n ≥ 100) (h2 : phrases.contains n = true) :\n  is_interesting n phrases = 2 :=\nsorry\n\ntheorem awesome_phrases_nearby_match (n : Nat) (phrases : Array Nat)\n  (h1 : n ≥ 98) (h2 : phrases.contains (n + 1) = true ∨ phrases.contains (n + 2) = true) :\n  is_interesting n phrases ≥ 1 :=\nsorry\n\ntheorem palindrome_direct_match (n : Nat) (h1 : n ≥ 100)\n  (h2 : isPalindrome n = true) :\n  is_interesting n #[] = 2 :=\nsorry\n\ntheorem palindrome_nearby_match (n : Nat) (h1 : n ≥ 98)\n  (h2 : isPalindrome (n + 1) = true ∨ isPalindrome (n + 2) = true)\n  (h3 : n + 1 ≥ 100 ∨ n + 2 ≥ 100) :\n  is_interesting n #[] ≥ 1 :=\nsorry\n\ntheorem incrementing_sequences (n : Nat)\n  (h : n = 123 ∨ n = 234 ∨ n = 345 ∨ n = 456 ∨ n = 567 ∨ n = 678 ∨ n = 789 ∨ n = 890) :\n  is_interesting n #[] = 2 :=\nsorry\n\ntheorem decrementing_sequences (n : Nat)\n  (h : n = 987 ∨ n = 876 ∨ n = 765 ∨ n = 654 ∨ n = 543 ∨ n = 432 ∨ n = 321) :\n  is_interesting n #[] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval is_interesting 3 #[1337, 256]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval is_interesting 1336 #[1337, 256]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval is_interesting 1000 #[1337, 256]"}
{"id": "fvapps_001674", "vc-description": "/- Base case properties -/\n\n/- Main invariant properties for any input -/\n\n/- Minimal result property -/\n\n/- Helper lemma to relate get_steps to collatz_steps -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def collatz_steps (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef get_steps (n : Nat) (len : Nat) : String :=\n  sorry", "vc-theorems": "theorem collatz_steps_D : collatz_steps 1 \"D\" = 2 :=\nsorry\n\ntheorem collatz_steps_U : collatz_steps 1 \"U\" = 1 :=\nsorry\n\ntheorem collatz_steps_geq_input {n : Nat} {s : String} (h : n > 0) :\n  collatz_steps n s ≥ n :=\nsorry\n\ntheorem collatz_steps_minimal {n : Nat} {s : String} (h : n > 0) (h2 : collatz_steps n s > 1) :\n  ∀ m, m < collatz_steps n s → ¬(get_steps m (String.length s)).startsWith s :=\nsorry\n\ntheorem get_steps_matches {n : Nat} {s : String} (h : n > 0) :\n  (get_steps (collatz_steps n s) (String.length s)).startsWith s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001680", "vc-description": "", "vc-preamble": "structure PrimeFactor where\n  prime : Nat\n  power : Nat", "vc-helpers": "", "vc-definitions": "def isqrt (n : Nat) : Nat :=\nsorry\n\ndef isPrime (p : Nat) : Bool :=\nsorry\n\ndef factorize (n : Nat) : List PrimeFactor :=\nsorry", "vc-theorems": "theorem isqrt_upper_bound (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  r * r ≤ n :=\nsorry\n\ntheorem isqrt_next_exceeds (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  (r + 1) * (r + 1) > n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval trailing_zeros 15 10\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval trailing_zeros 7 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval trailing_zeros 30 10"}
{"id": "fvapps_001681", "vc-description": "", "vc-preamble": "def name_of_mystery : String :=\n  \"Gray code\"", "vc-helpers": "", "vc-definitions": "def mystery (n : Nat) : Nat :=\n  sorry\n\ndef mystery_inv (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem mystery_inverse : ∀ n : Nat, n < 2^32 →\n  mystery (mystery_inv n) = n ∧ mystery_inv (mystery n) = n :=\nsorry\n\ntheorem mystery_preserves_non_negative : ∀ n : Nat,\n  mystery n ≥ 0 ∧ mystery_inv n ≥ 0 :=\nsorry\n\ntheorem mystery_bit_length : ∀ n : Nat, n < 2^16 →\n  n.log2 - (mystery n).log2 ≤ 1 ∧\n  n.log2 - (mystery_inv n).log2 ≤ 1 :=\nsorry\n\ntheorem mystery_name_is_gray_code :\n  name_of_mystery = \"Gray code\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval mystery 6\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval mystery_inv 5\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval mystery mystery_inv(10)\n\n/-\ninfo: 'Gray code'\n-/\n#guard_msgs in\n#eval name_of_mystery"}
{"id": "fvapps_001693", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mouse_path (s : String) : Option Nat :=\nsorry\n\ndef check_corner (orientations : List Char) : Bool :=\nsorry\n\ndef check_intersect (rectas : List ((Int × Int) × (Int × Int))) : Bool :=\nsorry\n\ndef calc_area (points : List (Int × Int)) : Nat :=\nsorry\n\ndef add_point (direction : Char) (distance : Nat) (points : List (Int × Int)) : List (Int × Int) :=\nsorry", "vc-theorems": "theorem mouse_path_returns_none_or_natural (s : String) :\n  match mouse_path s with\n  | none => True\n  | some n => n ≥ 0\n  :=\nsorry\n\ntheorem check_corner_single_orientation {o : Char} (orientations : List Char) :\n  (∀ x ∈ orientations, x = o) → check_corner orientations = false :=\nsorry\n\ntheorem check_intersect_symmetry (rectas : List ((Int × Int) × (Int × Int))) :\n  check_intersect rectas = check_intersect rectas.reverse :=\nsorry\n\ntheorem calc_area_nonnegative (points : List (Int × Int)) :\n  calc_area points ≥ 0 :=\nsorry\n\ntheorem add_point_preserves_coordinate (direction : Char) (distance : Nat) (points : List (Int × Int)) :\n  let newPoints := add_point direction distance [(0,0)]\n  (direction = 'N' ∨ direction = 'S') →\n    (newPoints.get! 0).1 = (newPoints.get! 1).1 ∧\n  (direction = 'E' ∨ direction = 'O') →\n    (newPoints.get! 0).2 = (newPoints.get! 1).2\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 49\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5R9R4R4L3\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"2R2R2L2L\""}
{"id": "fvapps_001694", "vc-description": "", "vc-preamble": "def TestEmulator := Nat × Nat × Nat", "vc-helpers": "", "vc-definitions": "def height (n m : Nat) : Nat :=\nsorry\n\ndef solve (e : TestEmulator) : Nat :=\nsorry", "vc-theorems": "theorem height_nonnegative (n m : Nat) :\n  height n m ≥ 0 :=\nsorry\n\ntheorem height_when_n_geq_m (n m : Nat) :\n  n ≥ m → height n m = 2^m - 1 :=\nsorry\n\ntheorem solve_bounded_by_break_floor (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  solve (eggs, drops, break_floor) ≤ break_floor :=\nsorry\n\ntheorem solve_positive (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  solve (eggs, drops, break_floor) > 0 :=\nsorry\n\ntheorem solve_respects_constraints (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  let e := (eggs, drops, break_floor)\n  solve e ≤ eggs ∧ solve e ≤ drops :=\nsorry\n\ntheorem emulator_below_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 1 →\n  solve (eggs, drops - 1, break_floor - 1) = 0 :=\nsorry\n\ntheorem emulator_at_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 1 → break_floor > 0 →\n  solve (eggs - 1, drops - 2, break_floor) > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve TestEmulator(1, 10, 5)\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval solve TestEmulator(2, 10, 20)\n\n/-\ninfo: 55\n-/\n#guard_msgs in\n#eval solve TestEmulator(3, 14, 55)"}
{"id": "fvapps_001696", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def b (n : Int) : String :=\nsorry\n\ndef d (s : String) : Int :=\nsorry\n\ndef skrzat (mode : String) (input : Int ⊕ String) : String :=\nsorry\n\ndef is_valid_binary (s : String) : Bool :=\nsorry", "vc-theorems": "theorem bidirectional_conversion : ∀ (n : Int),\n  let bin := b n; d bin = n :=\nsorry\n\ntheorem binary_valid : ∀ (n : Int),\n  is_valid_binary (b n) = true :=\nsorry\n\ntheorem skrzat_binary_format : ∀ (binary : String),\n  is_valid_binary binary = true →\n  ∃ n : Int, skrzat \"b\" (Sum.inr binary) = s!\"From binary: {binary} is {n}\" :=\nsorry\n\ntheorem skrzat_decimal_format : ∀ (decimal : Int),\n  ∃ binary : String,\n    skrzat \"d\" (Sum.inl decimal) = s!\"From decimal: {decimal} is {binary}\" ∧\n    is_valid_binary binary = true :=\nsorry\n\ntheorem skrzat_invalid_base : ∀ (input : Int ⊕ String),\n  skrzat \"x\" input ≠ skrzat \"d\" input ∧ skrzat \"x\" input ≠ skrzat \"b\" input :=\nsorry\n\ntheorem positive_conversion : ∀ (n : Int),\n  n ≥ 0 →\n  let bin := b n\n  ¬bin.startsWith \"-\" ∧ d bin = n :=\nsorry\n\ntheorem zero_negative_conversion : ∀ (n : Int),\n  n ≤ 0 →\n  let bin := b n\n  d bin = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'From binary: 1001101 is 61'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"1001101\"\n\n/-\ninfo: 'From binary: 0111111 is -21'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"0111111\"\n\n/-\ninfo: 'From binary: 101001000100001 is 19937'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"101001000100001\"\n\n/-\ninfo: 'From decimal: -137 is 10001011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" -137\n\n/-\ninfo: 'From decimal: 137 is 110011001'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 137\n\n/-\ninfo: 'From decimal: 8191 is 110000000000011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 8191"}
{"id": "fvapps_001700", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Any valid path length must be non-negative -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pathFinder (maze : String) : Option Nat :=\nsorry", "vc-theorems": "theorem path_finder_result_exists (maze : String) :\n  ∃ (result : Option Nat), pathFinder maze = result := by\nsorry\n\ntheorem path_finder_empty_path :\n  pathFinder \"...\\n...\\n...\" ≠ none := by\nsorry\n\ntheorem path_finder_blocked_two_by_two :\n  pathFinder \"W.\\n.W\" = none := by\nsorry\n\ntheorem path_finder_all_blocked_except_ends :\n  pathFinder \".WW\\nWWW\\nWW.\" = none := by\nsorry\n\ntheorem path_finder_positive_length (maze : String) (n : Nat) :\n  pathFinder maze = some n → n > 0 := by\nsorry", "vc-postamble": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    ...\".replace(\"    \", \"\")\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    .W.\".replace(\"    \", \"\")\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \"...\\n    ...\\n    ...\".replace(\"    \", \"\")"}
{"id": "fvapps_001703", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_solution (board : List (List Nat)) : Bool :=\nsorry\n\ndef check_unique_1_to_9 (arr : List Nat) : Bool :=\nsorry\n\ndef get_box_elements (board : List (List Nat)) (box_i box_j : Nat) : List Nat :=\nsorry\n\ndef get_column (board : List (List Nat)) (j : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem valid_grid_properties (board : List (List Nat)) :\n  (∀ row ∈ board, check_unique_1_to_9 row) ∧\n  (∀ j, 0 ≤ j ∧ j < 9 → check_unique_1_to_9 (get_column board j)) ∧\n  (∀ i j, 0 ≤ i ∧ i < 3 ∧ 0 ≤ j ∧ j < 3 →\n    check_unique_1_to_9 (get_box_elements board (3*i) (3*j)))\n  → valid_solution board :=\nsorry\n\ntheorem invalid_numbers (board : List (List Nat)) :\n  (∃ row ∈ board, ∃ x ∈ row, x < 1 ∨ x > 9) →\n  ¬ valid_solution board :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 8], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]"}
{"id": "fvapps_001704", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_single_digit_addition (n : Nat) : Nat :=\nsorry\n\ndef compute_running_sum : Nat → Nat\n  | x => if x < 10 then x\n         else compute_running_sum (solve_single_digit_addition x)\ntermination_by x => x\ndecreasing_by simp_wf;\nsorry", "vc-theorems": "theorem result_is_single_digit (n : Nat) :\n  solve_single_digit_addition n ≤ 9 :=\nsorry\n\ntheorem result_equals_sum_of_digits (n : Nat) :\n  let result := solve_single_digit_addition n\n  let digit_sum := solve_single_digit_addition result\n  result = digit_sum :=\nsorry\n\ntheorem idempotent (n : Nat) :\n  let first_result := solve_single_digit_addition n\n  let second_result := solve_single_digit_addition first_result\n  first_result = second_result :=\nsorry\n\ntheorem equals_recursive_digit_sum (n : Nat) :\n  solve_single_digit_addition n = compute_running_sum n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001709", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isBalanced (s : String) : Bool :=\nsorry\n\ndef balancedParens (n : Nat) : List String :=\nsorry\n\ndef catalan (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem balanced_parens_output_is_balanced (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, isBalanced s = true :=\nsorry\n\ntheorem balanced_parens_length (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, s.length = 2 * n :=\nsorry\n\ntheorem balanced_parens_unique (n : Nat) (h : n ≤ 5) :\n  (balancedParens n).Nodup :=\nsorry\n\ntheorem balanced_parens_only_parens (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, ∀ c ∈ s.toList, c = '(' ∨ c = ')' :=\nsorry\n\ntheorem balanced_parens_catalan (n : Nat) (h : n ≤ 5) :\n  (balancedParens n).length = catalan n :=\nsorry\n\ntheorem balanced_parens_non_negative (n : Int) :\n  n ≥ 0 → ∃ (l : List String), l = balancedParens n.toNat :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['']\n-/\n#guard_msgs in\n#eval balanced_parens 0\n\n/-\ninfo: ['()']\n-/\n#guard_msgs in\n#eval balanced_parens 1\n\n/-\ninfo: ['(())', '()()']\n-/\n#guard_msgs in\n#eval balanced_parens 2\n\n/-\ninfo: ['((()))', '(()())', '(())()', '()(())', '()()()']\n-/\n#guard_msgs in\n#eval balanced_parens 3"}
{"id": "fvapps_001713", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def VALID_VALUES := ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n\ndef VALID_SUITS := ['S', 'H', 'D', 'C']\n\nstructure Card where\n  value : Char\n  suit : Char\n  deriving Repr\n\nstructure Hand where\n  cards : List Card\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def Hand.maxCount (h : Hand) : Nat :=\nsorry\n\ndef Hand.maxCard (h : Hand) : Char :=\nsorry\n\ndef Hand.remaining (h : Hand) : List Char :=\nsorry\n\ndef Hand.isFlush (h : Hand) : Bool :=\nsorry\n\ndef Hand.isStraight (h : Hand) : Bool :=\nsorry\n\ndef Hand.gt (h1 h2 : Hand) : Bool :=\nsorry", "vc-theorems": "theorem hand_initialization (cards : List Card) (h : Hand) :\n  cards.length = 5 ∧\n  ∀ c ∈ cards, c.value ∈ VALID_VALUES ∧ c.suit ∈ VALID_SUITS :=\nsorry\n\ntheorem hand_properties (h : Hand) :\n  1 ≤ h.maxCount ∧ h.maxCount ≤ 4 ∧\n  h.maxCard ∈ VALID_VALUES ∧\n  ∀ r ∈ h.remaining, r ∈ VALID_VALUES :=\nsorry\n\ntheorem hand_comparison_reflexive (h : Hand) :\n  ¬(Hand.gt h h) :=\nsorry\n\ntheorem hand_comparison_antisymmetric (h1 h2 : Hand) :\n  Hand.gt h1 h2 → ¬(Hand.gt h2 h1) :=\nsorry\n\ntheorem hand_comparison_transitive (h1 h2 : Hand) :\n  h1 = h2 → ¬(Hand.gt h1 h2) ∧ ¬(Hand.gt h2 h1) :=\nsorry\n\ntheorem straight_flush_beats_others (h : Hand) :\n  ¬(h.isStraight ∧ h.isFlush) →\n  Hand.gt (Hand.mk [\n    {value := 'A', suit := 'S'},\n    {value := 'K', suit := 'S'},\n    {value := 'Q', suit := 'S'},\n    {value := 'J', suit := 'S'},\n    {value := 'T', suit := 'S'}\n  ]) h :=\nsorry\n\ntheorem flush_consistency (h : Hand) :\n  h.isFlush → List.length (List.map Card.suit h.cards) = 5 ∧\n  ∀ (c1 c2 : Card), c1 ∈ h.cards → c2 ∈ h.cards → c1.suit = c2.suit :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001716", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Point := Float × Float\n\ndef convex_hull_area (points : List Point) : Float :=\n  sorry\n\ndef is_internal_point (p : Point) (points : List Point) : Prop :=\n  sorry", "vc-theorems": "theorem convex_hull_area_non_negative (points : List Point) :\n  convex_hull_area points ≥ 0 :=\nsorry\n\ntheorem convex_hull_area_less_than_three_points (points : List Point) :\n  points.length < 3 → convex_hull_area points = 0 :=\nsorry\n\ntheorem convex_hull_area_permutation_invariant {points perm : List Point} :\n  points.length > 0 →\n  points.Perm perm →\n  convex_hull_area points = convex_hull_area perm :=\nsorry\n\ntheorem convex_hull_area_internal_points {points : List Point} {p : Point} :\n  points.length ≥ 3 →\n  is_internal_point p points →\n  convex_hull_area (p::points) = convex_hull_area points :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0)]\n\n/-\ninfo: 4.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 2), (2, 2), (2, 0)]\n\n/-\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0), (1, 1), (2, 1)]"}
{"id": "fvapps_001718", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose_move (gameState : List Nat) : Nat × Nat :=\n  sorry\n\ndef nimSum (xs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem choose_move_valid {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  pileIdx < gameState.length ∧\n  0 < straws ∧\n  straws ≤ gameState[pileIdx]! :=\nsorry\n\ntheorem winning_move_reduces_nim_sum {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  let initialNimSum := nimSum gameState\n  let newState := gameState.set pileIdx (gameState[pileIdx]! - straws)\n  let newNimSum := nimSum newState\n  initialNimSum > 0 → newNimSum < initialNimSum :=\nsorry\n\ntheorem modify_nonempty_pile {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  gameState[pileIdx]! > 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001719", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_bc (url : String) (separator : String) : String :=\n  sorry\n\ndef containsStr (s : String) (sub : String) : Bool :=\n  sorry\n\ndef findStr (s : String) (sub : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem generate_bc_structure (paths : List String) (separator : String)\n  (h1 : paths.length ≥ 1) (h2 : paths.length ≤ 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url separator;\n  (result.startsWith \"<a href=\\\"/\\\">HOME</a>\" ∨\n   result.startsWith \"<span class=\\\"active\\\">HOME</span>\") ∧\n  result.endsWith \"</span>\" ∧\n  (containsStr result \"<span class=\\\"active\\\">\") ∧\n  ((result.split (· == separator.get! 0)).length ≥ 1) :=\nsorry\n\ntheorem generate_bc_protocol_stripping (url : String)\n  (h : containsStr url \"http://\" ∨ containsStr url \"https://\") :\n  let result := generate_bc url \"/\";\n  ¬containsStr result \"http://\" ∧\n  ¬containsStr result \"https://\" :=\nsorry\n\ntheorem generate_bc_long_segments (path : String)\n  (h : path.length > 30) :\n  let url := \"mysite.com/\" ++ path\n  let result := generate_bc url \" > \"\n  let spans := result.split (· == '>')\n  let lastSpan := spans[spans.length - 1]'(by sorry)\n  let content := (lastSpan.split (· == '>')).getLast!;\n  content.length < path.length :=\nsorry\n\ntheorem generate_bc_href_validity (paths : List String)\n  (h1 : paths.length ≥ 2) (h2 : paths.length ≤ 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url \" : \"\n  let segments := (result.split (· == ':')).dropLast;\n  ∀ s ∈ segments,\n    s.startsWith \"<a href=\\\"/\\\"\" ∧\n    s.endsWith \"</a>\" ∧\n    (findStr s \"\\\">\").isSome :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/pictures/holidays.html\" \" : \"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval generate_bc \"www.microsoft.com/docs/index.htm\" \" * \"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/very-long-url-to-make-a-silly-yet-meaningful-example/example.htm\" \" > \""}
{"id": "fvapps_001722", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "structure PlayingCards where\n  cards : List String\n  chars : List Char\n  encode : String → Option (List String)\n  decode : List String → Option String", "vc-helpers": "", "vc-definitions": "def validCharSet : String → Bool :=\nsorry\n\ndef isValidMessage (s : String) : Bool :=\nsorry\n\ndef isValidCard (s : String) : Bool :=\nsorry\n\ndef isValidDeck (d : List String) : Bool :=\nsorry\n\ndef defaultPlayingCards : PlayingCards :=\nsorry", "vc-theorems": "theorem encode_decode_roundtrip\n  {pc : PlayingCards} {msg : String} (h : isValidMessage msg) :\n  match (pc.encode msg) with\n  | none => True\n  | some encoded =>\n    (pc.decode encoded = some msg) ∧\n    (encoded.length = 52) ∧\n    (encoded.eraseDups = encoded) ∧\n    (∀ c, c ∈ encoded → c ∈ pc.cards)\n  :=\nsorry\n\ntheorem decode_encode_roundtrip\n  {pc : PlayingCards} {deck : List String} (h : isValidDeck deck) :\n  match (pc.decode deck) with\n  | none => True\n  | some decoded => pc.encode decoded = some deck\n  :=\nsorry\n\ntheorem invalid_message_returns_none\n  {pc : PlayingCards} {msg : String} :\n  (¬ msg.all (fun c => c ∈ pc.chars)) →\n  pc.encode msg = none\n  :=\nsorry\n\ntheorem invalid_deck_returns_none\n  {pc : PlayingCards} {deck : List String} :\n  (deck.length ≠ 52 ∨ deck.eraseDups.length ≠ 52) →\n  pc.decode deck = none\n  :=\nsorry\n\ntheorem empty_message_valid\n  (pc : PlayingCards) :\n  pc.encode \"\" ≠ none ∧\n  pc.decode (Option.get! (pc.encode \"\")) = some \"\"\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001723", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef statement1 (s : Nat) : Bool :=\n  sorry\n\ndef statement2 (p : Nat) : Bool :=\n  sorry\n\ndef statement3 (s : Nat) : Bool :=\n  sorry\n\ndef is_solution (a b : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem small_numbers_not_prime {n : Nat} (h : n ≤ 1) :\n  is_prime n = false :=\nsorry\n\ntheorem prime_divisibility {n : Nat} (h₁ : n ≥ 2) (h₂ : n ≤ 1000) :\n  is_prime n = true → ∀ i : Nat, 2 ≤ i ∧ i ≤ n^(1/2) → n % i ≠ 0 :=\nsorry\n\ntheorem statement1_even {s : Nat} (h : s % 2 = 0) :\n  statement1 s = false :=\nsorry\n\ntheorem statement1_prime_diff {s : Nat} (h : is_prime (s - 2)) :\n  statement1 s = false :=\nsorry\n\ntheorem statement2_type {p : Nat} (h₁ : p ≥ 4) (h₂ : p ≤ 100) :\n  statement2 p = true ∨ statement2 p = false :=\nsorry\n\ntheorem statement2_composite {p : Nat} (h₁ : p ≥ 4) (h₂ : p ≤ 100) :\n  statement2 p = true → ∃ i : Nat, 2 ≤ i ∧ i ≤ p^(1/2) ∧ p % i = 0 :=\nsorry\n\ntheorem statement3_type {s : Nat} (h₁ : s ≥ 4) (h₂ : s ≤ 100) :\n  statement3 s = true ∨ statement3 s = false :=\nsorry\n\ntheorem statement3_small {s : Nat} (h : s ≤ 3) :\n  statement3 s = false :=\nsorry\n\ntheorem is_solution_type {a b : Nat} (h₁ : a ≥ 2) (h₂ : a ≤ 50) (h₃ : b ≥ 2) (h₄ : b ≤ 50) :\n  is_solution a b = true ∨ is_solution a b = false :=\nsorry\n\ntheorem is_solution_constraints {a b : Nat} (h₁ : (a + b) % 2 = 0 ∨ is_prime (a * b)) :\n  is_solution a b = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval statement1 6\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval statement2 15\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solution 5 4"}
{"id": "fvapps_001727", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def trim : List (List Nat) → List (List Nat) :=\nsorry\n\ndef next_gen : List (List Nat) → List (List Nat) :=\nsorry\n\ndef get_generation : List (List Nat) → Nat → List (List Nat) :=\nsorry", "vc-theorems": "theorem static_block_pattern :\n  next_gen [[1,1], [1,1]] = [[1,1], [1,1]] :=\nsorry\n\ntheorem empty_grid_static :\n  next_gen [[]] = [[]] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001730", "vc-description": "-- First coin must be minimum of input list\n\n-- Result must be either -1 or >= first coin\n\n-- Input list should not be modified after operation\n\n-- Two coprime numbers should always have a solution", "vc-preamble": "def min_int (a b : Int) : Int := if a ≤ b then a else b\n\ndef list_minimum (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x :: xs => match xs with\n    | [] => x\n    | y :: ys => min_int x (list_minimum xs)", "vc-helpers": "", "vc-definitions": "def min_price (coins : List Int) : Int :=\nsorry", "vc-theorems": "theorem min_price_first_coin_min {coins : List Int} (h : coins.length ≥ 2) :\n  coins ≠ [] → coins.head! = list_minimum coins :=\nsorry\n\ntheorem min_price_result_bounds {coins : List Int} (h : coins.length ≥ 2) :\n  let result := min_price coins\n  result ≠ -1 → result ≥ coins.head! :=\nsorry\n\ntheorem min_price_preserves_input {coins : List Int} (h : coins.length ≥ 2) :\n  let original := coins\n  let _ := min_price coins\n  coins = original :=\nsorry\n\ntheorem coprime_has_solution {coins : List Int} (h : coins.length ≥ 2) :\n  Nat.gcd (coins.head!.toNat) (coins.get! 1).toNat = 1 →\n  min_price coins ≠ -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval min_price [3, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_price [4, 6]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_price [2, 3]"}
{"id": "fvapps_001731", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest_palindrom_from (n : Nat) : Nat :=\nsorry\n\ndef numeric_palindrome (arr : List Nat) : Nat :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem largest_palindrom_from_is_palindrome (n : Nat)\n  (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :\n  let result := toString (largest_palindrom_from n)\n  result = reverseString result :=\nsorry\n\ntheorem largest_palindrom_from_uses_input_digits (n : Nat)\n  (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :\n  let result := toString (largest_palindrom_from n)\n  ∀ d : Char, d ∈ result.data → d ∈ (toString n).data :=\nsorry\n\ntheorem numeric_palindrome_is_palindrome (nums : List Nat)\n  (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)\n  (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :=\nsorry\n\ntheorem numeric_palindrome_bound (nums : List Nat)\n  (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)\n  (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :\n  numeric_palindrome nums ≤ nums.foldr (·*·) 1 :=\nsorry\n\ntheorem numeric_palindrome_with_ones (nums : List Nat)\n  (h1 : nums.length ≥ 3) (h2 : nums.length ≤ 6)\n  (h3 : ∀ i, i < nums.length - 1 → nums.get ⟨i, sorry⟩ = 1)\n  (h4 : nums.getLast? = some 2) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001732", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def recoverSecret (triplets : List (List Char)) : String :=\nsorry\n\ndef isConsistentWithTriplets (result : String) (triplets : List (List Char)) : Bool :=\nsorry\n\ndef containsAllChars (result : String) (triplets : List (List Char)) : Bool :=\nsorry", "vc-theorems": "theorem recoverSecret_produces_string (triplets : List (List Char)) :\n  String.length (recoverSecret triplets) > 0 :=\nsorry\n\ntheorem recoverSecret_contains_all_chars (triplets : List (List Char)) :\n  containsAllChars (recoverSecret triplets) triplets = true :=\nsorry\n\ntheorem recoverSecret_consistent_with_triplets (triplets : List (List Char)) :\n  isConsistentWithTriplets (recoverSecret triplets) triplets = true :=\nsorry\n\ntheorem recoverSecret_basic_case :\n  recoverSecret [['a', 'b', 'c'], ['a', 'c', 'd']] = \"abcd\" :=\nsorry\n\ntheorem recoverSecret_complex_case :\n  recoverSecret [\n    ['t','u','p'],\n    ['w','h','i'],\n    ['t','s','u'],\n    ['a','t','s'],\n    ['h','a','p'],\n    ['t','i','s'],\n    ['w','h','s']\n  ] = \"whatisup\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'whatisup'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"t\", \"u\", \"p\"], [\"w\", \"h\", \"i\"], [\"t\", \"s\", \"u\"], [\"a\", \"t\", \"s\"], [\"h\", \"a\", \"p\"], [\"t\", \"i\", \"s\"], [\"w\", \"h\", \"s\"]]\n\n/-\ninfo: 'abcd'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"a\", \"b\", \"c\"], [\"a\", \"c\", \"d\"]]\n\n/-\ninfo: 'great'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"g\", \"r\", \"t\"], [\"e\", \"a\", \"t\"]]"}
{"id": "fvapps_001735", "vc-description": "", "vc-preamble": "structure Fraction where\n  num : Nat\n  denom : Nat", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\nsorry\n\ndef simplifiedFractions (n : Nat) : List String :=\nsorry\n\ndef stringToFraction (s : String) : Fraction :=\nsorry", "vc-theorems": "theorem fractions_are_valid {n : Nat} (h : n > 0) :\n  ∀ frac, frac ∈ simplifiedFractions n →\n    let f := stringToFraction frac\n    0 < f.num ∧ f.num < f.denom ∧ f.denom ≤ n ∧ gcd f.num f.denom = 1 :=\nsorry\n\ntheorem fractions_are_unique {n : Nat} (h : n > 0) :\n  ∀ x y, x ∈ simplifiedFractions n → y ∈ simplifiedFractions n →\n    x = y → stringToFraction x = stringToFraction y :=\nsorry\n\ntheorem all_simplified_fractions_included {n : Nat} (h : n > 0) :\n  ∀ i j : Nat, 1 ≤ i → i < j → j ≤ n → gcd i j = 1 →\n    ∃ frac, frac ∈ simplifiedFractions n ∧ stringToFraction frac = ⟨i, j⟩ :=\nsorry\n\ntheorem empty_for_n_less_than_2 :\n  simplifiedFractions 1 = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['1/2']\n-/\n#guard_msgs in\n#eval simplifiedFractions 2\n\n/-\ninfo: ['1/2', '1/3', '2/3']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(3)\n\n/-\ninfo: ['1/2', '1/3', '1/4', '2/3', '3/4']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(4)"}
{"id": "fvapps_001743", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Time := String\nderiving Inhabited\n\ndef alertNames (names : List String) (times : List Time) : List String :=\n  sorry\n\ndef parseTime (t : Time) : Nat :=\n  sorry", "vc-theorems": "theorem alertNames_output_ordered (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ i j, i < j → j < result.length → result[i]! ≤ result[j]! := by\nsorry\n\ntheorem alertNames_subset_of_input (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ x ∈ result, x ∈ names := by\nsorry\n\ntheorem alertNames_unique (names : List String) (times : List Time) :\n  let result := alertNames names times\n  List.Nodup result := by\nsorry\n\ntheorem alertNames_violation_exists (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ name ∈ result,\n    let personTimes := (List.zip names times).filterMap\n      (fun p => if p.1 = name then some (parseTime p.2) else none)\n    List.length personTimes ≥ 3 ∧\n    ∃ t0 t1 t2,\n      t0 ∈ personTimes ∧\n      t1 ∈ personTimes ∧\n      t2 ∈ personTimes ∧\n      t0 < t1 ∧ t1 < t2 ∧\n      t2 - t0 ≤ 100 := by\nsorry\n\ntheorem alertNames_short_inputs (names : List String) (times : List Time) :\n  List.length names ≤ 2 → alertNames names times = [] := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['daniel']\n-/\n#guard_msgs in\n#eval alert_names [\"daniel\", \"daniel\", \"daniel\", \"luis\", \"luis\", \"luis\", \"luis\"] [\"10:00\", \"10:40\", \"11:00\", \"09:00\", \"11:00\", \"13:00\", \"15:00\"]\n\n/-\ninfo: ['bob']\n-/\n#guard_msgs in\n#eval alert_names [\"alice\", \"alice\", \"alice\", \"bob\", \"bob\", \"bob\", \"bob\"] [\"12:01\", \"12:00\", \"18:00\", \"21:00\", \"21:20\", \"21:30\", \"23:00\"]\n\n/-\ninfo: ['clare', 'leslie']\n-/\n#guard_msgs in\n#eval alert_names [\"leslie\", \"leslie\", \"leslie\", \"clare\", \"clare\", \"clare\", \"clare\"] [\"13:00\", \"13:20\", \"14:00\", \"18:00\", \"18:51\", \"19:30\", \"19:49\"]"}
{"id": "fvapps_001744", "vc-description": "", "vc-preamble": "def Matrix (α : Type) := List (List α)", "vc-helpers": "", "vc-definitions": "def swim_time (grid : Matrix Nat) : Nat :=\nsorry\n\ndef can_reach (t : Nat) (grid : Matrix Nat) (i j : Nat) (visited : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem swim_time_non_negative (grid : Matrix Nat) :\n  swim_time grid ≥ 0 :=\nsorry\n\ntheorem swim_time_bounds {grid : Matrix Nat} (h : grid.length > 0) :\n  swim_time grid ≥ (grid.head!.head!) ∧\n  swim_time grid ≥ (grid.getLast!.getLast!) ∧\n  swim_time grid ≤ grid.length * grid.length :=\nsorry\n\ntheorem swim_time_monotonic {grid grid2 : Matrix Nat} {i j : Nat}\n  (h1 : i < grid.length)\n  (h2 : j < grid.length)\n  (h3 : ∀ x y, x ≠ i ∨ y ≠ j →\n    (grid.get! x).get! y = (grid2.get! x).get! y)\n  (h4 : (grid2.get! i).get! j = (grid.get! i).get! j + 1) :\n  swim_time grid2 ≥ swim_time grid :=\nsorry\n\ntheorem swim_time_path_exists (grid : Matrix Nat) :\n  can_reach (swim_time grid) grid 0 0 [] = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 2], [1, 3]]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval swim_time [[0, 1, 2, 3, 4], [24, 23, 22, 21, 5], [12, 13, 14, 15, 16], [11, 17, 18, 19, 20], [10, 9, 8, 7, 6]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 1], [2, 3]]"}
{"id": "fvapps_001751", "vc-description": "", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! < l[j]!", "vc-helpers": "", "vc-definitions": "def find_number_of_lis (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem number_of_lis_properties (nums : List Int) :\n  let result := find_number_of_lis nums\n  result ≥ 0 ∧\n  (nums = [] → result = 0)\n:= by\nsorry\n\ntheorem constant_list_property {n : Nat} (x : Int) :\n  find_number_of_lis (List.replicate n x) = n\n:= by\nsorry\n\ntheorem strictly_increasing_property (nums : List Int) (h : nums ≠ []) :\n  isSorted nums →\n  find_number_of_lis nums = 1\n:= by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 3, 5, 4, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_number_of_lis [2, 2, 2, 2, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 2, 4, 3, 5, 4, 7, 2]"}
{"id": "fvapps_001764", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validTicTacToe (board : List String) : Bool :=\nsorry\n\ndef hasWin (board : List String) (player : Char) : Bool :=\nsorry\n\ndef countChar (board : List String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem board_dimensions {board : List String} (h : validTicTacToe board) :\n  board.length = 3 ∧\n  (∀ row ∈ board, row.length = 3) ∧\n  (∀ row ∈ board, ∀ c ∈ row.data, c = 'X' ∨ c = 'O' ∨ c = ' ') :=\nsorry\n\ntheorem count_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  o_count ≤ x_count ∧ x_count - o_count ≤ 1 :=\nsorry\n\ntheorem winner_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  let x_wins := hasWin board 'X'\n  let o_wins := hasWin board 'O'\n  ¬(x_wins ∧ o_wins) ∧\n  ¬(x_wins ∧ x_count ≤ o_count) ∧\n  ¬(o_wins ∧ x_count ≠ o_count) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"O  \", \"   \", \"   \"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \" X \", \"   \"]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \"O O\", \"XOX\"]"}
{"id": "fvapps_001766", "vc-description": "/- Function that computes probability of frog being at target vertex after t steps -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (List Nat)) : Bool :=\nsorry\n\ndef frogPosition (n : Nat) (edges : List (List Nat)) (t : Nat) (target : Nat) : Float :=\nsorry", "vc-theorems": "theorem frog_position_probability (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob := frogPosition n edges t target\n  0 ≤ prob ∧ prob ≤ 1 ∧ 1 ≤ target ∧ target ≤ n :=\nsorry\n\ntheorem frog_position_deterministic (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob1 := frogPosition n edges t target\n  let prob2 := frogPosition n edges t target\n  prob1 = prob2 :=\nsorry\n\ntheorem frog_position_impossible_start (n : Nat) (edges : List (List Nat))\n    (target : Nat)\n    (h1 : isValidTree n edges = true)\n    (h2 : target ≠ 1) :\n  frogPosition n edges 0 target = 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001780", "vc-description": "/- For any non-empty n×n grid with all zeros, there exists a valid path to reach bottom right -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- For any n×n grid that is blocked except start position, no valid path exists -/\n\n/- For minimal 3×3 grid of all zeros, there exists a valid path -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minimum_moves (grid : Array (Array Nat)) : Int :=\nsorry", "vc-theorems": "theorem min_moves_empty_grid_reaches {n : Nat} (h : n ≥ 3) :\n  let grid := Array.mk (List.replicate n (Array.mk (List.replicate n (0:Nat))))\n  minimum_moves grid > 0 :=\nsorry\n\ntheorem min_moves_blocked_grid_unreachable {n : Nat} (h : n ≥ 3) :\n  let blockedGrid := Array.mk (List.replicate n (Array.mk (List.replicate n (1:Nat))))\n  let grid := blockedGrid.set! 0 (blockedGrid[0]!.set! 0 0) |>.set! 0 (blockedGrid[0]!.set! 1 0)\n  minimum_moves grid = -1 :=\nsorry\n\ntheorem min_moves_minimal_grid_reaches :\n  let grid := Array.mk [Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)]]\n  minimum_moves grid > 0 :=\nsorry", "vc-postamble": "/-\ninfo: 11\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0]]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0]]"}
{"id": "fvapps_001783", "vc-description": "-- simplified expected result for type checking", "vc-preamble": "def listSum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => h + listSum t", "vc-helpers": "", "vc-definitions": "def Matrix (α : Type) := List (List α)\n\ndef count_squares (matrix : Matrix Int) : Nat :=\n  sorry", "vc-theorems": "theorem all_ones_matrix_squares {m n : Nat} (h1 : m > 0) (h2 : n > 0) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_squares matrix = m * n\n  :=\nsorry\n\ntheorem binary_matrix_bounds (matrix : Matrix Int)\n  (h1 : matrix ≠ []) :\n  let result := count_squares matrix\n  let m := matrix.length\n  let n := (List.head! matrix).length\n  result ≥ 0 ∧\n  result ≤ m * n * (min m n)\n  :=\nsorry\n\ntheorem square_all_ones {n : Nat} (h : n > 0) :\n  let matrix := List.replicate n (List.replicate n 1)\n  count_squares matrix = n * (n + 1) * (2 * n + 1) / 6\n  :=\nsorry\n\ntheorem empty_and_edge_cases :\n  count_squares [[0]] = 0 ∧\n  count_squares [[1]] = 1 ∧\n  count_squares [[0, 0], [0, 0]] = 0\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval count_squares [[0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_squares [[1, 0, 1], [1, 1, 0], [1, 1, 0]]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_squares [[1, 1], [1, 1]]"}
{"id": "fvapps_001786", "vc-description": "", "vc-preamble": "def List.sorted : List Nat → Bool\n| [] => true\n| [_] => true\n| x :: y :: xs => x ≤ y ∧ sorted (y :: xs)\n\ndef applyFlips : List Nat → List Nat → List Nat\n| xs, [] => xs\n| xs, k::ks => applyFlips ((xs.take k).reverse ++ xs.drop k) ks", "vc-helpers": "", "vc-definitions": "def pancakeSort : List Nat → List Nat\n| xs =>\nsorry", "vc-theorems": "theorem pancakeSort_produces_valid_flips (arr : List Nat) :\n  ∀ k ∈ pancakeSort arr, 1 ≤ k ∧ k ≤ arr.length :=\nsorry\n\ntheorem pancakeSort_sorts (arr : List Nat) :\n  (applyFlips arr (pancakeSort arr)).sorted :=\nsorry\n\ntheorem pancakeSort_on_sorted_is_empty (arr : List Nat) :\n  arr.sorted → pancakeSort arr = [] :=\nsorry\n\ntheorem pancakeSort_reverses_reversed (arr : List Nat) :\n  arr = arr.reverse →\n  (applyFlips arr (pancakeSort arr)).sorted :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len pancake_sort(arr2)"}
{"id": "fvapps_001792", "vc-description": "-- Length is correct\n\n-- Is permutation of 1..n\n\n-- Beautiful property holds", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def beautiful_array (n : Nat) : List Nat :=\n  sorry\n\ndef is_permutation (arr : List Nat) (n : Nat) : Bool :=\n  sorry\n\ndef check_beautiful_property (arr : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem beautiful_array_correct (n : Nat) :\n  let arr := beautiful_array n\n  n > 0 → (\n\n    arr.length = n ∧\n\n    is_permutation arr n = true ∧\n\n    check_beautiful_property arr = true\n  ) :=\nsorry\n\ntheorem beautiful_array_small_cases :\n  ∀ n : Nat, n ≤ 5 → n > 0 →\n    let arr := beautiful_array n\n    arr.length = n ∧\n    is_permutation arr n = true ∧\n    check_beautiful_property arr = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 4\n\n/-\ninfo: [1, 5, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 5\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval beautiful_array 1"}
{"id": "fvapps_001797", "vc-description": "", "vc-preamble": "def Graph := List (List Nat)", "vc-helpers": "", "vc-definitions": "def find_all_paths (g: Graph) : List (List Nat) :=\nsorry\n\ndef is_valid_dag (g: Graph) : Bool :=\nsorry\n\ndef verify_paths (g: Graph) (paths: List (List Nat)) : Bool :=\nsorry", "vc-theorems": "theorem paths_start_end_valid (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths, p.head? = some 0 ∧\n               p.getLast? = some (g.length - 1) :=\nsorry\n\ntheorem paths_follow_edges (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths, ∀ i < p.length - 1,\n    (p.get! (i+1)) ∈ (g.get! (p.get! i)) :=\nsorry\n\ntheorem paths_are_unique (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p₁ ∈ paths, ∀ p₂ ∈ paths, p₁ = p₂ ∨ p₁ ≠ p₂ :=\nsorry\n\ntheorem linear_graph_single_path (n: Nat) (h: n ≥ 2) :\n  let g : Graph := List.map (fun i => if i < n-1 then [i+1] else []) (List.range n)\n  let paths := find_all_paths g\n  paths.length = 1 ∧ paths.head? = some (List.range n) :=\nsorry\n\ntheorem complete_dag_valid_paths (n: Nat) (h: n ≥ 3) :\n  let g : Graph := List.map (fun i => List.filter (fun j => j > i ∧ j < n) (List.range n)) (List.range n)\n  let paths := find_all_paths g\n  verify_paths g paths = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: sorted(expected1)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph1)\n\n/-\ninfo: sorted(expected3)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph3)"}
{"id": "fvapps_001801", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def kthSymbol (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef countOnes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem first_row_is_zero (k : Nat) (h : k > 0) :\n  kthSymbol 1 k = 0 :=\nsorry\n\ntheorem output_is_binary (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = 0 ∨ kthSymbol n k = 1 :=\nsorry\n\ntheorem first_position_zero (n : Nat) (h : n > 1) :\n  kthSymbol n 1 = 0 :=\nsorry\n\ntheorem kth_symbol_property (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = if n > 1 then countOnes (k-1) % 2 else 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 1 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 2 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval kth_symbol 4 5"}
{"id": "fvapps_001816", "vc-description": "-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSorted (l : List Int) : Bool :=\n  sorry\n\ndef k_smallest_pairs (nums1 nums2 : List Int) (k : Nat) : List (Int × Int) :=\n  sorry", "vc-theorems": "theorem k_smallest_pairs_size (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result ≤ k ∧ List.length result ≤ List.length nums1 * List.length nums2 :=\nsorry\n\ntheorem k_smallest_pairs_elements (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  ∀ pair ∈ result, (List.elem pair.1 nums1 ∧ List.elem pair.2 nums2) :=\nsorry\n\ntheorem k_smallest_pairs_ordered (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  ∀ i, i + 1 < result.length →\n    (result.get! i).1 + (result.get! i).2 ≤ (result.get! (i+1)).1 + (result.get! (i+1)).2 :=\nsorry\n\ntheorem k_smallest_pairs_min_sum (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  result ≠ [] →\n    (result.get! 0).1 + (result.get! 0).2 = nums1.get! 0 + nums2.get! 0 :=\nsorry\n\ntheorem k_smallest_pairs_all_combinations (nums1 nums2 : List Int)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let k := List.length nums1 * List.length nums2\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result = k ∧\n  ∀ x ∈ nums1, ∀ y ∈ nums2, ∃ pair ∈ result, pair = (x, y) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001819", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef shortest_bridge (grid: Grid) : Nat :=\n  sorry\n\ndef is_valid_grid (grid: Grid) : Bool :=\n  sorry\n\ndef has_two_islands (grid: Grid) : Bool :=\n  sorry", "vc-theorems": "theorem shortest_bridge_non_negative\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid ≥ 0 :=\nsorry\n\ntheorem shortest_bridge_less_than_dimensions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid < grid.length * (grid.head!).length :=\nsorry\n\ntheorem shortest_bridge_assumptions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  0 ≤ shortest_bridge grid ∧ shortest_bridge grid < grid.length * (grid.head!).length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1], [1, 0]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1, 0], [0, 0, 0], [0, 0, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]"}
{"id": "fvapps_001832", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def prev_perm_opt1 (arr : List Int) : List Int :=\nsorry\n\ndef list_sortFn : List Int → List Int :=\nsorry", "vc-theorems": "theorem prev_perm_length_preserved {arr : List Int} (h : arr ≠ []) :\n  (prev_perm_opt1 arr).length = arr.length :=\nsorry\n\ntheorem prev_perm_same_elements {arr : List Int} (h : arr ≠ []) :\n  list_sortFn (prev_perm_opt1 arr) = list_sortFn arr :=\nsorry\n\ntheorem prev_perm_sorted_unchanged {arr : List Int} (h : arr ≠ []) :\n  arr = list_sortFn arr → prev_perm_opt1 arr = arr :=\nsorry\n\ntheorem prev_perm_lexicographically_smaller {arr : List Int} (h : arr ≠ []) :\n  prev_perm_opt1 arr ≤ arr :=\nsorry\n\ntheorem prev_perm_idempotent {arr : List Int} (h : arr ≠ []) :\n  prev_perm_opt1 (prev_perm_opt1 arr) ≤ prev_perm_opt1 arr :=\nsorry\n\ntheorem prev_perm_singleton_unchanged {arr : List Int} (h : arr.length = 1) :\n  prev_perm_opt1 arr = arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 2, 1]\n\n/-\ninfo: [1, 7, 4, 6, 9]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [1, 9, 4, 6, 7]\n\n/-\ninfo: [1, 3, 1, 3]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 1, 1, 3]"}
{"id": "fvapps_001861", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.isSubsetOf (l1 l2 : List α) [BEq α] : Bool :=\n  sorry\n\ndef people_indexes (favorite_companies : List (List String)) : List Nat :=\n  sorry", "vc-theorems": "theorem people_indexes_valid_indices\n  (favorite_companies : List (List String)) :\n  let result := people_indexes favorite_companies\n  ∀ i ∈ result, i < favorite_companies.length :=\nsorry\n\ntheorem people_indexes_empty :\n  people_indexes [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [0, 1, 4]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"google\", \"microsoft\"], [\"google\", \"facebook\"], [\"google\"], [\"amazon\"]]\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"leetcode\", \"amazon\"], [\"facebook\", \"google\"]]\n\n/-\ninfo: [0, 1, 2, 3]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\"], [\"google\"], [\"facebook\"], [\"amazon\"]]"}
{"id": "fvapps_001879", "vc-description": "-- Helper functions", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortestCompletingWord (licensePlate : String) (words : List String) : Option String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef containsAllLetters (word : String) (plate : String) : Bool :=\nsorry", "vc-theorems": "theorem shortest_completing_word_in_wordlist (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∃ w ∈ words, w.toLower = result.toLower :=\nsorry\n\ntheorem completes_license_plate (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∀ c ∈ plate.toList, isAlpha c → c.toLower ∈ result.toLower.toList :=\nsorry\n\ntheorem is_shortest_valid_word (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∀ w ∈ words, containsAllLetters w plate → result.length ≤ w.length :=\nsorry\n\ntheorem case_insensitive (plate : String) (words : List String) :\n  shortestCompletingWord plate.toLower words = shortestCompletingWord plate.toUpper words :=\nsorry\n\ntheorem ignore_non_alpha (words : List String) :\n  shortestCompletingWord \"A1B2C3\" words = shortestCompletingWord \"ABC\" words :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'steps'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 PSt\" [\"step\", \"steps\", \"stripe\", \"stepple\"]\n\n/-\ninfo: 'pest'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 456\" [\"looks\", \"pest\", \"stew\", \"show\"]\n\n/-\ninfo: 'supper'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"PP\" [\"pair\", \"supper\"]"}
{"id": "fvapps_001880", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shoppingOffers (price : List Int) (special : List (List Int)) (needs : List Int) : Int :=\n  sorry\n\ndef isValidInput (price : List Int) (special : List (List Int)) (needs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem shoppingOffers_result_nonnegative\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 10)\n  (h_special : ∀ s ∈ special, ∀ x ∈ s, 0 ≤ x ∧ x ≤ 10)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 10)\n  (h_valid : isValidInput price special needs) :\n  0 ≤ shoppingOffers price special needs :=\nsorry\n\ntheorem shoppingOffers_not_exceed_list_price\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 10)\n  (h_special : ∀ s ∈ special, ∀ x ∈ s, 0 ≤ x ∧ x ≤ 10)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 10)\n  (h_valid : isValidInput price special needs) :\n  shoppingOffers price special needs ≤ (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :=\nsorry\n\ntheorem shoppingOffers_no_special_equals_list_price\n  (price : List Int) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 5)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 5)\n  (h_valid : isValidInput price [] needs) :\n  shoppingOffers price [] needs = (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 5] [[3, 0, 5], [1, 2, 10]] [3, 2]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 3, 4] [[1, 1, 0, 4], [2, 2, 1, 9]] [1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval shoppingOffers [1, 1, 1] [[1, 1, 0, 3], [2, 2, 1, 5]] [1, 1, 1]"}
{"id": "fvapps_001887", "vc-description": "-- Basic type constraints\n\n-- Result should be numeric\n\n-- Result differs from input\n\n-- Result length within ±1 of input length\n\n-- Result is palindromic\n\n-- Result doesn't start with '0'\n\n-- Result is closest palindrome (minimality)", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_closest_palindrome (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef allCharsNumeric (s : String) : Bool :=\nsorry\n\ndef toNat (s : String) : Nat :=\nsorry\n\ndef toString! (n : Nat) : String :=\nsorry", "vc-theorems": "theorem find_closest_palindrome_outputs_nonempty {n : String}\n  (h : isPalindrome n = false)\n  : String.length (find_closest_palindrome n) > 0 :=\nsorry\n\ntheorem find_closest_palindrome_is_numeric {n : String}\n  (h : isPalindrome n = false)\n  : allCharsNumeric (find_closest_palindrome n) = true :=\nsorry\n\ntheorem find_closest_palindrome_different {n : String}\n  (h : isPalindrome n = false)\n  : find_closest_palindrome n ≠ n :=\nsorry\n\ntheorem find_closest_palindrome_length {n : String}\n  (h : isPalindrome n = false)\n  : (String.length (find_closest_palindrome n)).sub (String.length n) ≤ 1 ∧\n    (String.length n).sub (String.length (find_closest_palindrome n)) ≤ 1 :=\nsorry\n\ntheorem find_closest_palindrome_is_palindrome {n : String}\n  (h : isPalindrome n = false)\n  : isPalindrome (find_closest_palindrome n) = true :=\nsorry\n\ntheorem find_closest_palindrome_no_leading_zero {n : String}\n  (h : isPalindrome n = false)\n  : String.get! (find_closest_palindrome n) 0 ≠ '0' :=\nsorry\n\ntheorem find_closest_palindrome_is_minimal {n : String}\n  (h : isPalindrome n = false)\n  (h2 : String.length n ≥ 1)\n  : let result := find_closest_palindrome n\n    let diff := (toNat result).sub (toNat n)\n    ∀ k : Nat,\n      k ≠ toNat n →\n      isPalindrome (toString! k) = true →\n      (k.sub (toNat n)).min ((toNat n).sub k) ≥ diff :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '121'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"123\"\n\n/-\ninfo: '999'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"1000\"\n\n/-\ninfo: '1001'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"999\""}
{"id": "fvapps_001888", "vc-description": "", "vc-preamble": "def isValid (matrix : List (List String)) : Prop :=\n  match matrix with\n  | [] => True\n  | h::t => ∀ row ∈ t, row.length = h.length", "vc-helpers": "", "vc-definitions": "def maximalSquare (matrix : List (List String)) : Nat :=\n  sorry", "vc-theorems": "theorem maximal_square_is_perfect_square (matrix : List (List String)) :\n  ∃ n : Nat, maximalSquare matrix = n * n :=\nsorry\n\ntheorem maximal_square_bounded (matrix : List (List String)) :\n  match matrix with\n  | [] => maximalSquare matrix = 0\n  | h::t =>\n    let result := maximalSquare matrix\n    let maxDim := min matrix.length h.length\n    0 ≤ result ∧ result ≤ maxDim * maxDim :=\nsorry\n\ntheorem maximal_square_all_zeros (matrix : List (List String))\n  (h₁ : matrix.length > 0)\n  (h₂ : ∀ (i : Nat) (j : Nat), i < matrix.length →\n        j < matrix.head!.length →\n        (matrix.get! i).get! j = \"0\") :\n  maximalSquare matrix = 0 :=\nsorry\n\ntheorem maximal_square_all_ones (matrix : List (List String))\n  (h₁ : matrix.length > 0)\n  (h₂ : ∀ (i : Nat) (j : Nat), i < matrix.length →\n        j < matrix.head!.length →\n        (matrix.get! i).get! j = \"1\") :\n  maximalSquare matrix = (min matrix.length matrix.head!.length) *\n                        (min matrix.length matrix.head!.length) :=\nsorry\n\ntheorem maximal_square_padding (matrix : List (List String))\n  (h : matrix.length > 0) :\n  let padRow := fun (row : List String) => \"0\" :: (row ++ [\"0\"])\n  let paddedMatrix := (List.replicate (matrix.head!.length + 2) \"0\") ::\n                      (matrix.map padRow) ++\n                      [List.replicate (matrix.head!.length + 2) \"0\"]\n  maximalSquare matrix = maximalSquare paddedMatrix :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"0\", \"1\", \"0\", \"0\"], [\"1\", \"0\", \"1\", \"1\", \"1\"], [\"1\", \"1\", \"1\", \"1\", \"1\"], [\"1\", \"0\", \"0\", \"1\", \"0\"]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"1\"], [\"1\", \"1\"]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maximal_square [[\"0\"]]"}
{"id": "fvapps_001889", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sort (l : List α) (f : α → α → Bool) : List α :=\n  sorry\n\ndef custom_sort_string (s t : String) : String :=\n  sorry", "vc-theorems": "theorem length_preserved {s t : String} (h : s.length > 0) :\n  (custom_sort_string s t).length = t.length :=\nsorry\n\ntheorem chars_preserved {s t : String} (h : s.length > 0) :\n  List.sort (custom_sort_string s t).data (· ≤ ·) = List.sort t.data (· ≤ ·) :=\nsorry\n\ntheorem single_char_pattern {s t : String} (h1 : s.length = 1) (h2 : t.length > 0) :\n  s.get 0 ∈ t.data →\n  (custom_sort_string s t).startsWith (String.mk (List.replicate (t.data.count (s.get 0)) (s.get 0))) :=\nsorry\n\ntheorem idempotent {s t : String} (h : s.length > 0) :\n  custom_sort_string s (custom_sort_string s t) = custom_sort_string s t :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'kqeep'\n-/\n#guard_msgs in\n#eval custom_sort_string \"kqep\" \"pekeq\"\n\n/-\ninfo: 'zyxw'\n-/\n#guard_msgs in\n#eval custom_sort_string \"abc\" \"zyxw\""}
{"id": "fvapps_001894", "vc-description": "", "vc-preamble": "def listSum (l: List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef closed_island (grid : Grid) : Nat :=\n  sorry", "vc-theorems": "theorem closed_island_non_negative (grid: Grid) :\n  closed_island grid ≥ 0 :=\nsorry\n\ntheorem closed_island_less_than_zeros (grid: Grid) :\n  let countZeros (row: List Nat) := List.length (List.filter (λ x => x = 0) row)\n  closed_island grid ≤ listSum (List.map countZeros grid) :=\nsorry\n\ntheorem closed_island_small_grid (grid: Grid) (h1: grid.length < 3 ∨ (List.head! grid).length < 3) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_all_ones (grid: Grid)\n  (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_all_zeros (grid: Grid)\n  (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 0) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_simple_case_3x3 (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  closed_island grid = 1 :=\nsorry\n\ntheorem closed_island_simple_case_4x4 (grid: Grid)\n  (h1: grid = [[1,1,1,1], [1,0,0,1], [1,0,0,1], [1,1,1,1]]) :\n  closed_island grid = 1 :=\nsorry\n\ntheorem closed_island_mutates_to_ones (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  let _ := closed_island grid\n  ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval closed_island [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]"}
{"id": "fvapps_001896", "vc-description": "", "vc-preamble": "def is_valid_time (hours mins: Nat) : Prop :=\n  hours < 24 ∧ mins < 60", "vc-helpers": "", "vc-definitions": "def find_latest_time (digits: List Nat) : String :=\n  sorry\n\ndef is_valid_time_str (s: String) : Bool :=\n  sorry\n\ndef time_to_minutes (time: String) : Nat :=\n  sorry", "vc-theorems": "theorem find_latest_time_gives_valid_result {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d ≤ 9) :\n  is_valid_time_str (find_latest_time digits) = true :=\nsorry\n\ntheorem find_latest_time_invalid_when_all_large {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: (∀ d ∈ digits, d ≥ 6) ∨ (∀ d ∈ digits, d > 2)) :\n  find_latest_time digits = \"\" :=\nsorry\n\ntheorem find_latest_time_zeros {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d = 0) :\n  find_latest_time digits = \"00:00\" :=\nsorry\n\ntheorem find_latest_time_is_maximum {digits: List Nat} {result: String}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d ≤ 9)\n  (h3: result = find_latest_time digits)\n  (h4: result ≠ \"\") :\n  ∀ (h1 h2 m1 m2: Nat),\n  h1 ∈ digits → h2 ∈ digits → m1 ∈ digits → m2 ∈ digits →\n  is_valid_time (h1 * 10 + h2) (m1 * 10 + m2) →\n  time_to_minutes result ≥ (h1 * 10 + h2) * 60 + (m1 * 10 + m2) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '23:41'\n-/\n#guard_msgs in\n#eval find_latest_time [1, 2, 3, 4]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval find_latest_time [5, 5, 5, 5]\n\n/-\ninfo: '00:00'\n-/\n#guard_msgs in\n#eval find_latest_time [0, 0, 0, 0]"}
{"id": "fvapps_001898", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef maxSumRangeQuery (nums : List Nat) (requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ndef listSortDescending (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem maxSumRangeQuery_bounded\n  (nums : List Nat)\n  (requests : List (Nat × Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : ∀ r ∈ requests, r.1 ≤ r.2 ∧ r.2 < nums.length) :\n  0 ≤ maxSumRangeQuery nums requests ∧ maxSumRangeQuery nums requests < MOD :=\nsorry\n\ntheorem maxSumRangeQuery_deterministic\n  (nums : List Nat)\n  (requests : List (Nat × Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : ∀ r ∈ requests, r.1 ≤ r.2 ∧ r.2 < nums.length) :\n  maxSumRangeQuery nums requests = maxSumRangeQuery nums requests :=\nsorry\n\ntheorem maxSumRangeQuery_single_request\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  let requests := [(0, nums.length - 1)]\n  maxSumRangeQuery nums requests = (listSum nums) % MOD :=\nsorry\n\ntheorem maxSumRangeQuery_overlapping_bounds\n  (nums : List Nat)\n  (h1 : nums.length > 1) :\n  let requests := [(0, nums.length / 2), (nums.length / 4, nums.length - 1)]\n  let sorted_prefix := (listSortDescending nums).take nums.length\n  maxSumRangeQuery nums requests ≤ (listSum sorted_prefix) * 2 % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5] [[1, 3], [0, 1]]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 6] [[0, 1]]\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 10] [[0, 2], [1, 3], [1, 1]]"}
{"id": "fvapps_001902", "vc-description": "", "vc-preamble": "def listContains (l : List Nat) (n : Nat) : Prop :=\n  n ∈ l", "vc-helpers": "", "vc-definitions": "def countOnes (n : Nat) : Nat :=\n  sorry\n\ndef circularPermutation (n : Nat) (start : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem circularPermutation_length (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).length = 2^n :=\nsorry\n\ntheorem circularPermutation_starts_with_start (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).head! = start :=\nsorry\n\ntheorem circularPermutation_contains_all_numbers (n : Nat) (start : Nat)\n  (h : start < 2^n) (k : Nat) (hk : k < 2^n):\n  listContains (circularPermutation n start) k :=\nsorry\n\ntheorem circularPermutation_adjacent_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) (i : Nat) (h2 : i < (circularPermutation n start).length - 1) :\n  countOnes ((circularPermutation n start)[i]! ^^^ (circularPermutation n start)[i+1]!) = 1 :=\nsorry\n\ntheorem circularPermutation_first_last_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  countOnes ((circularPermutation n start).head! ^^^ (circularPermutation n start).getLast!) = 1 :=\nsorry\n\ntheorem circularPermutation_invalid_start (n : Nat) (start : Nat)\n  (h : start ≥ 2^n) :\n  circularPermutation n start = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 2 3\n\n/-\ninfo: [2, 6, 7, 5, 4, 0, 1, 3]\n-/\n#guard_msgs in\n#eval circular_permutation 3 2\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 1 0"}
{"id": "fvapps_001920", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_valid_pairs (s : String) : Nat :=\n  sorry\n\ndef complement (s : String) : String :=\nsorry", "vc-theorems": "theorem count_valid_pairs_bounds {s : String} (h : s.length ≥ 3) (h2 : s.length ≤ 8) :\n  let n := s.length\n  0 ≤ count_valid_pairs s ∧ count_valid_pairs s ≤ (n-1)*(n-2)/2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"010101\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_pairs \"11001100\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"0000\""}
{"id": "fvapps_001923", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def abs (n : Nat) (m : Nat) : Nat :=\n  if n ≥ m then n - m else m - n", "vc-helpers": "", "vc-definitions": "def solve_median_smoothing (n : Nat) (seq : List Nat) : Nat × Option (List Nat) :=\n  sorry\n\ndef is_sorted_window (arr : List Nat) (i : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem median_smoothing_properties\n  (n : Nat) (seq : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : ∀ x ∈ seq, x ≤ 1)\n  (steps : Nat) (result : Option (List Nat)) :\n  let (steps', result') := solve_median_smoothing n seq\n  match result' with\n  | none => steps' < 0\n  | some res =>\n    steps' ≥ 0 ∧\n    res.length = n ∧\n    (∀ i, 0 < i → i < res.length - 1 → is_sorted_window res i) ∧\n    (seq.length > 0 → res.length > 0 → List.head! res = List.head! seq) ∧\n    (seq.length > 0 → res.length > 0 → List.getLast res (by sorry) = List.getLast seq (by sorry))\n  :=\nsorry\n\ntheorem constant_sequence_property\n  (n : Nat) (seq : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : ∀ x ∈ seq, x = 0) :\n  let (steps, result) := solve_median_smoothing n seq\n  steps = 0 ∧ result = some seq :=\nsorry\n\ntheorem alternating_sequence_property\n  (n : Nat)\n  (h : n ≥ 3) :\n  let seq := List.map (fun i => i % 2) (List.range n)\n  let (steps, result) := solve_median_smoothing n seq\n  steps ≥ 0 ∧\n  match result with\n  | none => False\n  | some res =>\n    ∀ i, i + 1 < res.length →\n    abs (List.get! res i) (List.get! res (i+1)) ≤ 1\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001924", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_path (n : Nat) (vectors : List (Int × Int)) : List Int :=\n  sorry\n\ndef compute_final_position (vectors : List (Int × Int)) (path : List Int) : Int × Int :=\n  sorry\n\ndef verify_path_length (x : Int) (y : Int) : Bool :=\n  sorry", "vc-theorems": "theorem find_path_correct_length {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  n = vectors.length → path.length = n :=\nsorry\n\ntheorem find_path_valid_elements {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  n = vectors.length → ∀ x ∈ path, x = 1 ∨ x = -1 :=\nsorry\n\ntheorem find_path_bounded_result {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  n = vectors.length →\n  verify_path_length final_pos.1 final_pos.2 = true :=\nsorry\n\ntheorem single_vector_axis_bounded {n : Nat} :\n  n > 0 → n ≤ 50 →\n  let vectors := List.replicate n (1000000, 0)\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  verify_path_length final_pos.1 final_pos.2 = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001940", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_questions (n : Nat) : List Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\ndef isPrimePower (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem find_min_questions_output_type (n : Nat) :\n  ∀ x ∈ find_min_questions n, x ≤ n := by\n  sorry\n\ntheorem find_min_questions_ordering (n : Nat) :\n  ∀ (l : List Nat), l = find_min_questions n →\n    ∀ i, i + 1 < l.length →\n      l.get! i > l.get! (i + 1) →\n      isPrime (l.get! (i + 1)) := by\n  sorry\n\ntheorem find_min_questions_empty_for_one :\n  find_min_questions 1 = [] := by\n  sorry\n\ntheorem find_min_questions_nonempty_for_gt_one (n : Nat) :\n  n > 1 →\n  (find_min_questions n).length > 0 ∧\n  ∀ x ∈ find_min_questions n, x ≥ 2 := by\n  sorry\n\ntheorem find_min_questions_prime_powers (n : Nat) :\n  ∀ x ∈ find_min_questions n, isPrimePower x := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval len find_min_questions(4)\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval len find_min_questions(6)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_min_questions(1)"}
{"id": "fvapps_001943", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (s : String) : Bool :=\n  sorry\n\ndef solve_palindrome_cuts (s : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem solve_result_in_valid_range\n  (s : String)\n  (h : s.length > 0) :\n  let result := solve_palindrome_cuts s\n  result = none ∨ result = some 1 ∨ result = some 2 :=\nsorry\n\ntheorem palindrome_gives_impossible\n  (s : String)\n  (h : is_palindrome s = true) :\n  solve_palindrome_cuts s = none :=\nsorry\n\ntheorem result_one_implies_palindrome_rotation\n  (s : String)\n  (h : solve_palindrome_cuts s = some 1) :\n  ∃ i : Nat, i ≤ s.length ∧\n    is_palindrome (s.drop i ++ s.take i) = true :=\nsorry\n\ntheorem result_preserves_length\n  (s : String)\n  (h : s.length > 0) :\n  (solve_palindrome_cuts s).isSome → s.length > 0 :=\nsorry\n\ntheorem repeated_char_impossible\n  (c : Char)\n  (n : Nat)\n  (h : n > 0) :\n  solve_palindrome_cuts (String.mk (List.replicate n c)) = none :=\nsorry\n\ntheorem short_strings_impossible\n  (s : String)\n  (h : s.length ≤ 2) :\n  solve_palindrome_cuts s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"nolon\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"otto\"\n\n/-\ninfo: 'Impossible'\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"qqqq\""}
{"id": "fvapps_001944", "vc-description": "-- Parse result into nums\n\n-- Parse result into nums", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_circle_arrangement (n : Nat) : String :=\n  sorry\n\ndef validate_arrangement (n : Nat) (result : String) : Bool :=\n  sorry", "vc-theorems": "theorem solve_returns_string {n : Nat} :\n  ∃ s : String, solve_circle_arrangement n = s\n  :=\nsorry\n\ntheorem solve_starts_with_yes_or_is_no {n : Nat} :\n  let result := solve_circle_arrangement n\n  result.startsWith \"YES\\n\" ∨ result = \"NO\"\n  :=\nsorry\n\ntheorem result_validates {n : Nat} :\n  validate_arrangement n (solve_circle_arrangement n) = true\n  :=\nsorry\n\ntheorem validates_checks_length {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n\n    nums.length = 2 * n\n  :=\nsorry\n\ntheorem validates_checks_unique_nums {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n\n    nums = List.range (2 * n)\n  :=\nsorry\n\ntheorem validates_checks_consecutive_sums {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n    let doubled := nums ++ nums\n    ∃ sums : List Nat,\n      ∃ maxSum minSum : Nat,\n        maxSum - minSum ≤ 1\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES\\n2 3 6 1 4 5'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 3\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 4\n\n/-\ninfo: 'YES\\n2 1'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 1"}
{"id": "fvapps_001957", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unite_linked_lists (n : Nat) (arr : List (List Nat)) : List (List Nat) :=\n  sorry\n\ndef is_valid_linked_list (n : Nat) (arr : List (List Nat)) : Bool :=\n  sorry\n\ndef count_lists (n : Nat) (arr : List (List Nat)) : Nat :=\n  sorry\n\ndef is_connected (n : Nat) (arr : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem unite_linked_lists_preserves_size {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    List.length (unite_linked_lists n arr) = List.length arr :=\nsorry\n\ntheorem unite_linked_lists_maintains_validity {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    is_valid_linked_list n (unite_linked_lists n arr) :=\nsorry\n\ntheorem unite_linked_lists_creates_connection {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    is_connected n (unite_linked_lists n arr) :=\nsorry\n\ntheorem unite_linked_lists_reduces_count {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    count_lists n (unite_linked_lists n arr) = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001959", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_winning_knights (n : Nat) (m : Nat) (fights : List (Nat × Nat × Nat)) : List Nat :=\nsorry\n\ndef is_valid_result (n : Nat) (fights : List (Nat × Nat × Nat)) (result : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem find_winning_knights_valid_output (n m : Nat) (fights : List (Nat × Nat × Nat))\n  (h1 : 1 ≤ n) (h2 : n ≤ 100) (h3 : 1 ≤ m) (h4 : m ≤ 100)\n  (h5 : ∀ (f : Nat × Nat × Nat), f ∈ fights →\n    let (l,r,x) := f\n    1 ≤ l ∧ l ≤ x ∧ x ≤ r ∧ r ≤ n) :\n  let result := find_winning_knights n m fights\n  result.length = n ∧\n  (∀ x ∈ result, 0 ≤ x ∧ x ≤ n) ∧\n  is_valid_result n fights result :=\nsorry\n\ntheorem single_fight_winner_pattern (n : Nat) (h : 2 ≤ n) (h2 : n ≤ 10) :\n  let fights := [(1, n, 1)]\n  let result := find_winning_knights n 1 fights\n  result.length = n ∧\n  result.head? = some 0 ∧\n  (∀ x ∈ result.tail, x = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001968", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 10^9 + 7\n\ndef process_queries (s : String) (queries : List (Char × String)) : Nat :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem process_queries_mod (s : String) (queries : List (Char × String)) :\n  0 ≤ process_queries s queries ∧ process_queries s queries < MOD :=\nsorry\n\ntheorem process_queries_empty (s : String) :\n  process_queries s [] = (stringToNat s % MOD) :=\nsorry\n\ntheorem process_queries_replacement (s : String) (d r : Char) :\n  s.length > 0 →\n  s.contains d →\n  process_queries s [(d,r.toString)] ≠ stringToNat s % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 10031003\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"2\", \"00\"]]\n\n/-\ninfo: 1212\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"3\", \"\"]]\n\n/-\ninfo: 777\n-/\n#guard_msgs in\n#eval process_queries \"222\" [[\"2\", \"0\"], [\"0\", \"7\"]]"}
{"id": "fvapps_001979", "vc-description": "/- Helper function to get maximum of a list -/\n\n/- Main solve function signature -/\n\n/- Result of solve is always a natural number -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- Result is at least the maximum weight in the input weights -/\n\n/- For singleton input, result equals the single weight -/\n\n/- Properties for small cases (n ≤ 3) -/", "vc-preamble": "def list_max (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| (x::xs) => List.foldl Nat.max x xs", "vc-helpers": "", "vc-definitions": "def make_tree_edges (n : Nat) (edge_weights : List Nat) : List (Nat × Nat × Nat) :=\nsorry\n\ndef solve (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem solve_produces_nat (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) :\n  solve n weights roads ≥ 0 :=\nsorry\n\ntheorem solve_at_least_max_weight (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat))\n  (h : weights ≠ []) :\n  solve n weights roads ≥ list_max weights :=\nsorry\n\ntheorem solve_singleton (w : Nat) :\n  solve 1 [w] [] = w :=\nsorry\n\ntheorem solve_small_cases (n : Nat) (weights : List Nat) (h₁ : n ≤ 3) (h₂ : weights.length = n)\n  (h₃ : weights ≠ []) :\n  let roads := List.map (fun i => (i + 1, i + 2, 1)) (List.range (n-1))\n  solve n weights roads ≥ list_max weights :=\nsorry", "vc-postamble": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve 3 [1, 3, 3] [[1, 2, 2], [1, 3, 2]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve 5 [6, 3, 2, 5, 0] [[1, 2, 10], [2, 3, 3], [2, 4, 1], [1, 5, 1]]\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval solve 1 [42] []"}
{"id": "fvapps_001980", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_operations (n : Nat) (arr : List Int) : List (Nat × Nat × List Int) :=\nsorry\n\ndef verify_operations (n : Nat) (arr : List Int) (ops : List (Nat × Nat × List Int)) : Bool :=\nsorry\n\ndef valid_operation (n : Nat) (op : Nat × Nat × List Int) : Bool :=\nsorry", "vc-theorems": "theorem solve_array_operations_properties\n  (n : Nat) (arr : List Int) (h : 0 < n) (h2 : n ≤ 100) :\n  let ops := solve_array_operations n arr\n  List.length ops = 3 ∧\n  (∀ op ∈ ops, valid_operation n op) ∧\n  verify_operations n arr ops :=\nsorry\n\ntheorem solve_array_single_element\n  (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let arr := [1]\n  let ops := solve_array_operations 1 arr\n  List.length ops = 3 ∧\n  ops[0]! = (1, 1, [0]) ∧\n  ops[1]! = (1, 1, [0]) ∧\n  ops[2]! = (1, 1, [-1]) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001981", "vc-description": "", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_alternative_math (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_range (nums : List Nat) (h : nums ≠ []) :\n  solve_alternative_math nums < MOD :=\nsorry\n\ntheorem solve_single_elem (n : Nat) :\n  solve_alternative_math [n] = n % MOD :=\nsorry\n\ntheorem solve_deterministic (nums : List Nat) (h : nums.length ≥ 2) :\n  solve_alternative_math nums = solve_alternative_math nums :=\nsorry\n\ntheorem solve_odd_length {nums : List Nat} (h1 : nums.length ≥ 3) (h2 : nums.length % 2 = 1) :\n  solve_alternative_math nums < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 6, 9, 12, 15]\n\n/-\ninfo: 1000000006\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 7, 5, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_alternative_math [1]"}
{"id": "fvapps_001985", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\n  sorry\n\ndef minimum (l : List Int) : Int :=\n  sorry\n\ndef min_difference_sum (n k : Nat) (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_difference_sum_non_negative\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k ≤ n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr ≥ 0 :=\nsorry\n\ntheorem min_difference_sum_upper_bound\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k ≤ n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr ≤ (maximum arr - minimum arr) * k :=\nsorry\n\ntheorem min_difference_sum_k_equals_n\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr = 0 :=\nsorry\n\ntheorem min_difference_sum_k_equals_one\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = 1)\n  (h3 : n > 1) :\n  min_difference_sum n k arr = maximum arr - minimum arr :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_difference_sum 3 2 [1, 2, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_difference_sum 5 2 [3, -5, 3, -5, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difference_sum 6 3 [4, 3, 4, 3, 2, 5]"}
{"id": "fvapps_001990", "vc-description": "", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef list_take (n : Nat) (l : List Nat) : List Nat :=\n  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take n t\n\ndef list_replicate (n : Nat) (v : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n+1 => v :: list_replicate n v", "vc-helpers": "", "vc-definitions": "def solve_discount_shopping (n_discounts : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) : Nat :=\n  sorry\n\ndef list_sort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  0 ≤ solve_discount_shopping n_discounts discount_values n_items item_values :=\nsorry\n\ntheorem discount_shopping_upper_bound\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  solve_discount_shopping n_discounts discount_values n_items item_values ≤ list_sum item_values :=\nsorry\n\ntheorem discount_shopping_min_items\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  let sorted_items := list_sort item_values\n  let min_disc := match discount_values with\n                  | [] => n_items\n                  | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values ≥ min_items_sum :=\nsorry\n\ntheorem identical_items_result\n  (n_discounts : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h2 : 1 ≤ n_items ∧ n_items ≤ 5)\n  (h3 : 1 ≤ item_value ∧ item_value ≤ 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values := list_replicate n_items item_value\n  let result := solve_discount_shopping n_discounts discount_values n_items item_values\n  result % item_value = 0 ∧ result ≤ item_value * n_items :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 200\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [2] 4 [50, 50, 100, 100]\n\n/-\ninfo: 150\n-/\n#guard_msgs in\n#eval solve_discount_shopping 2 [2, 3] 5 [50, 50, 50, 50, 50]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [1] 7 [1, 1, 1, 1, 1, 1, 1]"}
{"id": "fvapps_001992", "vc-description": "", "vc-preamble": "def MOD : Nat := 998244353", "vc-helpers": "", "vc-definitions": "def solve_biscuit_game (n : Nat) (biscuits : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_range (n : Nat) (biscuits : List Nat) :\n  n > 0 → 0 ≤ solve_biscuit_game n biscuits ∧ solve_biscuit_game n biscuits < MOD :=\nsorry\n\ntheorem zero_biscuits (n : Nat) (len : Nat) :\n  n > 0 → solve_biscuit_game n (List.replicate len 0) = 0 :=\nsorry\n\ntheorem equal_distribution (n : Nat) (biscuits : List Nat) :\n  n > 0 → biscuits ≠ [] →\n  0 ≤ solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) ∧\n  solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) < MOD :=\nsorry\n\ntheorem single_player (n : Nat) (biscuits : List Nat) :\n  n = 1 → biscuits ≠ [] → solve_biscuit_game n biscuits = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_biscuit_game 5 [0, 0, 0, 0, 35]"}
{"id": "fvapps_002001", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "structure SegTree where\n  size : Nat\n  answer : Array Nat\n  opened : Array Nat\n  closed : Array Nat\nderiving Inhabited", "vc-helpers": "", "vc-definitions": "def next_pow_2 (n: Nat) : Nat :=\nsorry\n\ndef SegTree.build (self : SegTree) (s : String) : SegTree :=\nsorry\n\ndef solve_brackets (s: String) (queries: List (Nat × Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem next_pow_2_properties (n: Nat) (h: n ≥ 1) :\n  let result := next_pow_2 n\n  result ≥ n ∧\n  result &&& (result - 1) = 0 ∧\n  (result / 2 < n ∨ n = 1) :=\nsorry\n\ntheorem segtree_build_properties (s : String) (h: s.length > 0) :\n  let tree := SegTree.build (SegTree.mk s.length #[] #[] #[]) s\n  tree.answer.size = 2 * tree.size ∧\n  tree.opened.size = 2 * tree.size ∧\n  tree.closed.size = 2 * tree.size ∧\n  ∀ i < s.length,\n    let idx := tree.size + i\n    (tree.opened.get! idx = 0 ∨ tree.opened.get! idx = 1) ∧\n    (tree.closed.get! idx = 0 ∨ tree.closed.get! idx = 1) ∧\n    tree.opened.get! idx + tree.closed.get! idx ≤ 1 :=\nsorry\n\ntheorem solve_brackets_properties (s: String) (queries: List (Nat × Nat))\n  (h₁: s.length > 0)\n  (h₂: ∀ q, q ∈ queries →\n    q.1 > 0 ∧ q.2 > 0 ∧ q.1 ≤ q.2 ∧ q.2 ≤ s.length) :\n  let results := solve_brackets s queries\n  (∀ r, r ∈ results → r ≥ 0) ∧\n  (∀ r, r ∈ results → r % 2 = 0) ∧\n  (∀ q r, q ∈ queries → r ∈ results →\n    r ≤ 2 * (q.2 - q.1 + 1) ∧\n    (r > 0 → q.2 - q.1 ≥ 1)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002008", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_min_bytecoins (n : Nat) (m : Nat) (votes : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  sorry\n\ndef count_votes_for_party (votes : List (Nat × Nat)) (party : Nat) : Nat :=\n  sorry\n\ndef max_list (l : List Nat) : Nat :=\n  sorry\n\ndef increase_first_vote_cost (votes : List (Nat × Nat)) : List (Nat × Nat) :=\n  sorry", "vc-theorems": "theorem calculate_min_bytecoins_non_negative (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000) :\n  calculate_min_bytecoins n m votes ≥ 0 :=\nsorry\n\ntheorem calculate_min_bytecoins_upper_bound (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000) :\n  calculate_min_bytecoins n m votes ≤ list_sum (votes.map (λ v => v.2)) :=\nsorry\n\ntheorem calculate_min_bytecoins_party1_winning (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000)\n  (party1_votes := count_votes_for_party votes 1)\n  (other_parties_max := max_list (List.range m |>.map (λ i => count_votes_for_party votes (i + 2))))\n  (h_winning : party1_votes > other_parties_max) :\n  calculate_min_bytecoins n m votes = 0 :=\nsorry\n\ntheorem calculate_min_bytecoins_monotone (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000)\n  (increased_votes := increase_first_vote_cost votes) :\n  calculate_min_bytecoins n m increased_votes ≥ calculate_min_bytecoins n m votes :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 1 2 [[1, 100]]\n\n/-\ninfo: 500\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 400], [5, 900]]\n\n/-\ninfo: 600\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 800], [5, 900]]"}
{"id": "fvapps_002012", "vc-description": "-- Simplified gaps for type checking", "vc-preamble": "structure BridgeProblemInputs where\n  n : Nat\n  m : Nat\n  islands : List (List Int)\n  bridges : List Int\n\ndef get_indices (result : String) : List Nat :=\n  if result = \"No\" then []\n  else string_to_nat_array (result.splitOn \"\\n\").head!", "vc-helpers": "", "vc-definitions": "def solve_bridge_problem (n m : Nat) (islands : List (List Int)) (bridges : List Int) : String :=\nsorry\n\ndef verify_bridge_placement (bridges : List Int) (gaps : List (Int × Int)) (result : String) : Bool :=\nsorry\n\ndef string_to_nat_array (s : String) : List Nat :=\nsorry", "vc-theorems": "theorem result_format_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  (result = \"No\") ∨\n  (∃ nums : List Nat, result = s!\"Yes\\n{nums}\" ∧ nums.length = n - 1) :=\nsorry\n\ntheorem bridge_placement_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let gaps := List.range (n-1) |>.map (λ i => (1, 1))\n  verify_bridge_placement bridges gaps result = true :=\nsorry\n\ntheorem bridge_indices_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let indices := get_indices result\n  result = \"No\" ∨\n  (∀ i ∈ indices, 1 ≤ i ∧ i ≤ m) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes\\n2 3 1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 4 4 [[1, 4], [7, 8], [9, 10], [12, 14]] [4, 5, 3, 8]\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 2 [[11, 14], [17, 18]] [2, 9]\n\n/-\ninfo: 'Yes\\n1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 1 [[1, 1], [1000000000000000000, 1000000000000000000]] [999999999999999999]"}
{"id": "fvapps_002014", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef color_jewelry (n : Nat) : Nat × List Nat :=\n  sorry", "vc-theorems": "theorem k_bounds (n : Nat) (h : n ≥ 1) :\n  let (k, colors) := color_jewelry n\n  k = 1 ∨ k = 2 :=\nsorry\n\ntheorem large_n_coloring (n : Nat) (h1 : n > 2) :\n  let (k, colors) := color_jewelry n\n  k = 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002015", "vc-description": "", "vc-preamble": "def Card := Nat\n\ndef Pile := List Card", "vc-helpers": "", "vc-definitions": "def Game := List (Nat × Pile)\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ndef solve_card_game (g : Game) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem solve_card_game_returns_tuple (g : Game) :\n  let (a, b) := solve_card_game g\n  a ≥ 0 ∧ b ≥ 0 :=\nsorry\n\ntheorem sum_scores_equals_input (g : Game) :\n  let (a, b) := solve_card_game g\n  let total := g.map (fun p => listSum p.2) |> listSum\n  a + b = total :=\nsorry\n\ntheorem first_pile_split_correctly (g : Game) (h : g ≠ []) :\n  let first := g.head h\n  let k := first.1 / 2 + 1\n  let first_sum := listSum first.2\n  let rest_sum := g.tail.map (fun p => listSum p.2) |> listSum\n  let (a, b) := solve_card_game g\n  a + b = first_sum + rest_sum :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: (101, 10)\n-/\n#guard_msgs in\n#eval solve_card_game [[1, 100], [2, 1, 10]]\n\n/-\ninfo: (30, 15)\n-/\n#guard_msgs in\n#eval solve_card_game [[9, 2, 8, 6, 5, 9, 4, 7, 1, 3]]\n\n/-\ninfo: (18, 18)\n-/\n#guard_msgs in\n#eval solve_card_game [[3, 1, 3, 2], [3, 5, 4, 6], [2, 8, 7]]"}
{"id": "fvapps_002018", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (points : List (Nat × Nat)) : List Nat :=\nsorry\n\ndef sqrt (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_output_length {points : List (Nat × Nat)} :\n  points.length = (solve points).length :=\nsorry\n\ntheorem solve_output_bound {points : List (Nat × Nat)} (i : Fin points.length) :\n  let (a, b) := points.get i\n  let sqrt_ab := sqrt (a * b)\n  ∃ j : Fin (solve points).length, (solve points).get j ≤ 2 * sqrt_ab :=\nsorry\n\ntheorem solve_output_nonneg {points : List (Nat × Nat)} (i : Fin (solve points).length) :\n  0 ≤ (solve points).get i :=\nsorry\n\ntheorem solve_one_input :\n  solve [(1, 1)] = [0] :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve [(1, 4)]\n\n/-\ninfo: [12, 4]\n-/\n#guard_msgs in\n#eval solve [(10, 5), (3, 3)]\n\n/-\ninfo: [0, 0, 1, 1, 2]\n-/\n#guard_msgs in\n#eval solve [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]"}
{"id": "fvapps_002019", "vc-description": "", "vc-preamble": "def count_odd_frequencies (weights : List Nat) : Nat :=\n  let freqs := weights.foldl (fun acc x =>\n    match acc.find? (fun p => p.1 = x) with\n    | some p => acc.erase p ++ [(p.1, p.2 + 1)]\n    | none => acc ++ [(x, 1)]\n    ) []\n  (freqs.filter (fun p => p.2 % 2 = 1)).length", "vc-helpers": "", "vc-definitions": "def min_steps_to_lift (n : Nat) (weights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_steps_nonneg (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≥ 0 :=\nsorry\n\ntheorem min_steps_upper_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≤ n :=\nsorry\n\ntheorem min_steps_odd_freq_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≥ count_odd_frequencies weights :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_steps_to_lift 5 [1, 1, 2, 3, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_steps_to_lift 4 [0, 1, 2, 3]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval min_steps_to_lift 13 [92, 194, 580495, 0, 10855, 41704, 13, 96429, 33, 213, 0, 92, 140599]"}
{"id": "fvapps_002020", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def list_count {α} [BEq α] (p : α → Bool) (l : List α) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (if p x then 1 else 0) + list_count p xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def solve_hacknet (n A cf cm m : Nat) (skills : List Nat) : Nat × List Nat :=\n  sorry", "vc-theorems": "theorem solution_invariants {n A cf cm m : Nat} {skills ans : List Nat} {max_level : Nat}\n  (h : solve_hacknet n A cf cm m skills = (max_level, ans)) :\n  (ans.length = n) ∧\n  (∀ x ∈ ans, x ≤ A) ∧\n  (list_sum (List.map (λ i => max 0 ((ans.get! i) - (skills.get! i)))\n    (List.range n)) ≤ m) ∧\n  (max_level = cf * (list_count (λ x => x == A) ans) + cm * (List.foldl min A ans)) :=\nsorry\n\ntheorem zero_money {n A cf : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A cf 1 0 skills = (0, skills) :=\nsorry\n\ntheorem infinite_money {n A : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A 1 1 (Nat.max A 0) skills =\n    (n + A, List.replicate n A) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002025", "vc-description": "", "vc-preamble": "def isSorted (l : List Char) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def findSmallestSubstring (m : Nat) (s : String) : String :=\nsorry", "vc-theorems": "theorem find_smallest_substring_lowercase (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c.isLower ∨ r = \"\" :=\nsorry\n\ntheorem find_smallest_substring_sorted (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  isSorted r.data ∨ r = \"\" :=\nsorry\n\ntheorem find_smallest_substring_length (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  r.length ≤ s.length :=\nsorry\n\ntheorem find_smallest_substring_chars_subset (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c ∈ s.data :=\nsorry\n\ntheorem find_smallest_substring_alternating (m : Nat) :\n  let s := \"ababab\"\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c = 'a' ∨ c = 'b' :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"cbabc\"\n\n/-\ninfo: 'aab'\n-/\n#guard_msgs in\n#eval find_smallest_substring 2 \"abcab\"\n\n/-\ninfo: 'aaabb'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"bcabcbaccba\""}
{"id": "fvapps_002027", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- We can represent permutation invariance by showing that if we have\n    two lists with the same elements (possibly in different order),\n    they produce the same result -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def stones_game (n : Nat) (stones : List Nat) : String :=\nsorry", "vc-theorems": "theorem stones_game_output_valid (n : Nat) (stones : List Nat) :\n  stones_game n stones = \"YES\" ∨ stones_game n stones = \"NO\" :=\nsorry\n\ntheorem stones_game_consistent (stones : List Nat) :\n  let n := stones.length\n  stones_game n stones = stones_game n stones :=\nsorry\n\ntheorem stones_game_permutation_invariant (stones stones_permuted : List Nat) :\n  stones.length = stones_permuted.length →\n  stones_game stones.length stones = stones_game stones_permuted.length stones_permuted :=\nsorry\n\ntheorem stones_game_identical_stones (n : Nat) :\n  let stones := List.replicate n 1\n  stones_game n stones = stones_game n stones :=\nsorry", "vc-postamble": "/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 1 [5]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval stones_game 2 [1, 2]\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 3 [34, 44, 21]"}
{"id": "fvapps_002029", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def running_sum (xs: List Int) : List Int :=\n  match xs with\n  | [] => []\n  | x::xs' => x :: (running_sum xs').map (λ s => s + x)", "vc-helpers": "", "vc-definitions": "def Operation := List Int\n\ndef solve_sequence_ops (ops: List Operation) : List Float :=\n  sorry", "vc-theorems": "theorem sequence_ops_result_properties (ops: List Operation) :\n  let result := solve_sequence_ops ops\n  (result.length = ops.length) ∧\n  (∀ x ∈ result, -1000000 ≤ x ∧ x ≤ 1000000) :=\nsorry\n\ntheorem remove_maintains_min_size (ops: List Operation) :\n  let remove_count := (ops.filter (λ op => op.head! = 3)).length\n  remove_count ≤ ops.length :=\nsorry\n\ntheorem append_only_averages (values: List Int)\n  (h1: ∀ x ∈ values, 1 ≤ x ∧ x ≤ 1000)\n  (h2: values.length ≥ 1 ∧ values.length ≤ 10) :\n  let ops := values.map (λ x => [2, x])\n  let result := solve_sequence_ops ops\n  ∀ i: Nat, i < values.length →\n    let sum := (running_sum values)[i]!\n    Float.abs (result[i]! - Float.ofInt (sum + 0) / Float.ofNat (i + 2)) < 0.000001 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002031", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def scheduleRepairs (requests : List (Nat × Nat)) : List (Nat × Nat) :=\nsorry\n\ndef isNonOverlapping (intervals : List (Nat × Nat)) : Bool :=\nsorry\n\ndef totalDurationPreserved (requests : List (Nat × Nat)) (result : List (Nat × Nat)) : Bool :=\nsorry\n\ndef allPositive (intervals : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem schedule_repairs_non_overlapping (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true :=\nsorry\n\ntheorem schedule_repairs_preserves_duration (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  totalDurationPreserved requests result = true :=\nsorry\n\ntheorem schedule_repairs_all_positive (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  allPositive result = true :=\nsorry\n\ntheorem schedule_repairs_preserves_length (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  result.length = requests.length :=\nsorry\n\ntheorem schedule_repairs_handles_same_start (requests : List (Nat × Nat))\n  (h : ∀ p ∈ requests, p.fst = 1) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true ∧ totalDurationPreserved requests result = true :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [(9, 10), (1, 3), (4, 7)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(9, 2), (7, 3), (2, 4)]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval schedule_repairs [(1000000000, 1000000), (1000000000, 1000000), (100000000, 1000000), (1000000000, 1000000)]\n\n/-\ninfo: [(1, 5000000)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(1, 5000000)]"}
{"id": "fvapps_002032", "vc-description": "", "vc-preamble": "abbrev min' (a b : Nat) : Nat := if a ≤ b then a else b\n\ndef list_maximum (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => List.foldl Nat.max x xs", "vc-helpers": "", "vc-definitions": "def solve_carrot_game (n : Nat) (A : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem carrot_game_output_length {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  (solve_carrot_game n A).length = n :=\nsorry\n\ntheorem carrot_game_max_preserved {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  list_maximum (solve_carrot_game n A) = list_maximum A :=\nsorry\n\ntheorem carrot_game_elements_valid {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  ∀ x ∈ (solve_carrot_game n A),\n    x ∈ A ∨ ∃ (i : Fin (A.length - 1)),\n      x = min' (A[i]) (A[i.val + 1]) :=\nsorry\n\ntheorem carrot_game_identical_elements {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n)\n  (h3 : ∀ x ∈ A, x = 5) :\n  ∀ x ∈ (solve_carrot_game n A), x = 5 :=\nsorry\n\ntheorem carrot_game_last_element_is_max {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  List.getLast! (solve_carrot_game n A) = list_maximum A :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 3, 5, 5]\n-/\n#guard_msgs in\n#eval solve_carrot_game 4 [1, 2, 3, 5]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_carrot_game 5 [1000000000, 1000000000, 1000000000, 1000000000, 1]\n\n/-\ninfo: [2, 8, 8]\n-/\n#guard_msgs in\n#eval solve_carrot_game 3 [2, 8, 2]"}
{"id": "fvapps_002035", "vc-description": "", "vc-preamble": "def DisjointSet := Nat → Nat", "vc-helpers": "", "vc-definitions": "def is_valid_relationship (n : Nat) (relationships : List (Nat × Nat × Nat)) : Bool :=\nsorry\n\ndef solve_love_triangles (n : Nat) (relationships : List (Nat × Nat × Nat)) : Nat :=\nsorry\n\ndef DisjointSet.find_set (ds : DisjointSet) (x : Nat) : Nat :=\nsorry\n\ndef DisjointSet.union (ds : DisjointSet) (x y : Nat) : DisjointSet :=\nsorry", "vc-theorems": "theorem empty_relationships_power_two (n : Nat) (h : n > 0) :\n  solve_love_triangles n [] = (2^(n-1)) % (10^9 + 7) :=\nsorry\n\ntheorem result_within_modulo_bounds (n : Nat) (relationships : List (Nat × Nat × Nat)) :\n  0 ≤ solve_love_triangles n relationships ∧\n  solve_love_triangles n relationships < 10^9 + 7 :=\nsorry\n\ntheorem contradictory_relationships_zero (n : Nat) (h : n ≥ 2) :\n  solve_love_triangles n [(1,2,1), (2,1,0)] = 0 :=\nsorry\n\ntheorem result_modularity (n : Nat) (relationships : List (Nat × Nat × Nat)) :\n  solve_love_triangles n relationships % (10^9 + 7) =\n  solve_love_triangles n relationships :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_love_triangles 3 []\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 0)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 1)]"}
{"id": "fvapps_002036", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_lost_milk (n: Nat) (cows: List Nat) : Nat :=\nsorry\n\ndef count_facing (cows: List Nat) (dir: Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_lost_milk_non_negative (n: Nat) (cows: List Nat) :\n  min_lost_milk n cows ≥ 0 :=\nsorry\n\ntheorem min_lost_milk_length (n: Nat) (cows: List Nat) :\n  cows.length = n → True :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 4 [0, 0, 1, 0]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_lost_milk 5 [1, 0, 1, 0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 2 [1, 0]"}
{"id": "fvapps_002039", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_startups (n : Nat) (arr : List Int) : Nat :=\n  sorry\n\ndef pow (base : Nat) (exp : Nat) (m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_in_valid_range (n : Nat) (arr : List Int) (h₁ : n > 0) (h₂ : arr.length = n) :\n  let result := solve_startups n arr\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem array_length_matches_n (n : Nat) (arr : List Int)\n  (h₁ : n > 0) (h₂ : arr.length ≥ 1) :\n  let truncated := (List.replicate n arr.head!).take n\n  let result := solve_startups n truncated\n  0 ≤ result ∧ result < 1000000007 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_startups 3 [-1, -1, -1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_startups 2 [2, -1]\n\n/-\ninfo: 755808950\n-/\n#guard_msgs in\n#eval solve_startups 40 [3, 3, -1, -1, 4, 4, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 4, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3]"}
{"id": "fvapps_002040", "vc-description": "", "vc-preamble": "def factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def count_valid_permutations (n : Nat) (edges : List (Nat × Nat)) : Nat :=\nsorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem valid_tree_construction (n : Nat) (edges : List (Nat × Nat))\n  (h1 : is_valid_tree n edges) :\n  let result := count_valid_permutations n edges\n  ∃ (k : Nat), result = k ∧\n    k > 0 ∧\n    k ≤ n * factorial n :=\nsorry\n\ntheorem mod_result (n : Nat) (edges : List (Nat × Nat)) :\n  let result := count_valid_permutations n edges\n  result < 998244353 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval count_valid_permutations 4 [(1, 2), (1, 3), (2, 4)]\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval count_valid_permutations n [(1, 2), (1, 3), (1, 4)]\n\n/-\ninfo: 144\n-/\n#guard_msgs in\n#eval count_valid_permutations 6 [(2, 1), (3, 2), (4, 1), (5, 4), (1, 6)]"}
{"id": "fvapps_002042", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry\n\ndef solve_tree_values (n : Nat) (parents : List Nat) (sums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem single_node_tree (n : Int) (h : n > 0) :\n  solve_tree_values 1 [] [n] = n :=\nsorry\n\ntheorem star_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3 : ∀ p ∈ parents, p = 1)\n  (h4 : values.length = n)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if ∃ v ∈ values, v < 0\n  then result ≥ -1\n  else result ≥ values.get! 0 :=\nsorry\n\ntheorem path_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3 : values.length = n)\n  (h4 : ∀ (i : Nat), i < parents.length → parents.get! i ≤ i + 1)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if ∃ v ∈ values, v < 0\n  then result ≥ -1\n  else result ≥ values.get! 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 1, 1, 1] [1, -1, -1, -1, -1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 2, 3, 1] [1, -1, 2, -1, -1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_tree_values 3 [1, 2] [2, -1, 1]"}
{"id": "fvapps_002044", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t", "vc-helpers": "", "vc-definitions": "def solve_dominos (n : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_dominos_non_negative (n : Nat) (arr : List Nat) :\n  solve_dominos n arr ≥ 0 := by\n  sorry\n\ntheorem solve_dominos_max_bound (n : Nat) (arr : List Nat) :\n  solve_dominos n arr ≤ (list_sum arr / 2) := by\n  sorry\n\ntheorem solve_dominos_single_column (h : Nat) :\n  solve_dominos 1 [h] = h / 2 := by\n  sorry\n\ntheorem solve_dominos_unit_heights (n : Nat) (arr : List Nat)\n  (h : ∀ x ∈ arr, x = 1) :\n  solve_dominos n arr = arr.length / 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 5 [3, 2, 2, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dominos 5 [1, 1, 1, 1, 1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 3 [3, 3, 3]"}
{"id": "fvapps_002045", "vc-description": "-- Result is positive\n\n-- Result not larger than min value\n\n-- Remainder property\n\n-- Maximum value property", "vc-preamble": "def isSorted (l : List Nat) : Prop :=\nmatch l with\n| [] => True\n| x::xs => match xs with\n  | [] => True\n  | y::_ => x ≤ y ∧ isSorted xs", "vc-helpers": "", "vc-definitions": "def get_max_beauty (n k : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem get_max_beauty_properties\n  (n k : Nat) (arr : List Nat)\n  (h₁ : n > 0)\n  (h₂ : n ≤ 100)\n  (h₃ : k ≤ 100)\n  (h₄ : arr.length > 0)\n  (h₅ : arr.length ≤ 100)\n  (h₆ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  (h₇ : isSorted arr)\n  (h₈ : arr.Nodup) :\n  let result := get_max_beauty n k arr\n\n  result > 0 ∧\n\n  result ≤ arr.head! ∧\n\n  (∀ x ∈ arr, x % result ≤ k) ∧\n\n  ∀ i ∈ List.range 10,\n    i < arr.head! - result + 1 →\n    ∃ x ∈ arr, x % (result + i + 1) > k :=\nsorry\n\ntheorem same_k_different_n\n  (arr : List Nat)\n  (h₁ : arr.length ≥ 2)\n  (h₂ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  (h₃ : isSorted arr)\n  (h₄ : arr.Nodup) :\n  get_max_beauty arr.length 1 arr = get_max_beauty (arr.length - 1) 1 arr :=\nsorry\n\ntheorem k_zero_case\n  (n : Nat)\n  (arr : List Nat)\n  (h₁ : n > 0 ∧ n ≤ 10)\n  (h₂ : arr.length > 0 ∧ arr.length ≤ 10)\n  (h₃ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000) :\n  let result := get_max_beauty n 0 arr\n  ∀ x ∈ arr, x % result = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_beauty 6 1 [3, 6, 10, 12, 13, 16]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_beauty 5 3 [8, 21, 52, 15, 77]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval get_max_beauty 13 11 [55, 16, 26, 40, 84, 80, 48, 52, 25, 43, 75, 21, 58]"}
{"id": "fvapps_002046", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_possible (a b : String) : Bool :=\n  sorry\n\ndef count_ones (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem ones_diff_bounds (a b : String) :\n  is_possible a b →\n  count_ones b ≤ ((count_ones a + 1) / 2) * 2\n  ∧\n  ¬is_possible a b →\n  count_ones b > ((count_ones a + 1) / 2) * 2 :=\nsorry\n\ntheorem same_string_always_possible (s : String) :\n  is_possible s s :=\nsorry\n\ntheorem all_zeros_possible (s zeros : String) :\n  (∀ c ∈ zeros.data, c = '0') →\n  s.length = zeros.length →\n  is_possible s zeros :=\nsorry\n\ntheorem length_invariant (s ones : String) :\n  (∀ c ∈ ones.data, c = '1') →\n  is_possible s ones ↔\n  ones.length ≤ ((count_ones s + 1) / 2) * 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"01011\" \"0110\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_possible \"0011\" \"1110\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"1\" \"0\""}
{"id": "fvapps_002053", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_substring_ways (s t : String) : Nat :=\nsorry\n\ndef is_substring (s t : String) : Bool :=\nsorry", "vc-theorems": "theorem count_substring_ways_nonnegative (s t : String) :\n  0 ≤ count_substring_ways s t ∧ count_substring_ways s t < 1000000007 :=\nsorry\n\ntheorem substring_gives_nonzero (s t : String)\n  (h : t.length > 0)\n  (h2 : is_substring s t = true) :\n  0 < count_substring_ways s t :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_substring_ways \"ababa\" \"aba\"\n\n/-\ninfo: 274201\n-/\n#guard_msgs in\n#eval count_substring_ways \"welcometoroundtwohundredandeightytwo\" \"d\"\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval count_substring_ways \"ddd\" \"d\""}
{"id": "fvapps_002054", "vc-description": "", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs\n\ndef list_sum_of_largest (arr : List Nat) (n : Nat) : Nat :=\n  sum_list ((List.toArray arr |>.qsort (· ≥ ·) |>.toList).take n)", "vc-helpers": "", "vc-definitions": "def find_max_fun_factor (n d m : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem empty_above_m (n d : Nat) (arr : List Nat)\n  (h1 : 0 < n ∧ n ≤ 100)\n  (h2 : 0 < d ∧ d ≤ 10)\n  (h3 : arr.length = n)\n  (h4 : ∀ x ∈ arr, x < 1000) :\n  find_max_fun_factor n d 1000 arr = list_sum_of_largest arr n :=\nsorry\n\ntheorem single_element (n d m : Nat) (arr : List Nat)\n  (h1 : 0 < n ∧ n ≤ 100)\n  (h2 : 0 < d ∧ d ≤ 10)\n  (h3 : 0 ≤ m ∧ m ≤ 100)\n  (h4 : arr.length = n)\n  (h5 : ∀ x ∈ arr, x = 0) :\n  find_max_fun_factor n d m arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 48\n-/\n#guard_msgs in\n#eval find_max_fun_factor 5 2 11 #[8, 10, 15, 23, 5]\n\n/-\ninfo: 195\n-/\n#guard_msgs in\n#eval find_max_fun_factor 20 2 16 #[20, 5, 8, 2, 18, 16, 2, 16, 16, 1, 5, 16, 2, 13, 6, 16, 4, 17, 21, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_max_fun_factor 1 1 0 #[0]"}
{"id": "fvapps_002065", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_permutation_with_prefix_products (n : Nat) : List Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef check_prefix_products (result : List Nat) (n : Nat) : Bool :=\nsorry\n\ndef is_valid_permutation (result : List Nat) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem output_properties (n : Nat) (h : n ≥ 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length > 0 →\n    result.length = n ∧\n    result.head? = some 1 ∧\n    result.getLast? = some n ∧\n    is_valid_permutation result n ∧\n    check_prefix_products result n ∧\n    (is_prime n ∨ n = 4) :=\nsorry\n\ntheorem output_properties_empty (n : Nat) (h : n ≥ 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length = 0 →\n    ¬is_prime n ∧ n ≠ 4 :=\nsorry\n\ntheorem prime_numbers_have_solution (n : Nat) (h : is_prime n) :\n  let result := find_permutation_with_prefix_products n\n  result.length = n ∧\n  check_prefix_products result n :=\nsorry\n\ntheorem composite_numbers_have_no_solution (n : Nat) (h1 : n ≥ 6) (h2 : ¬is_prime n) (h3 : n ≠ 4) :\n  (find_permutation_with_prefix_products n).length = 0 :=\nsorry\n\ntheorem special_case_four :\n  find_permutation_with_prefix_products 4 = [1, 3, 2, 4] ∧\n  check_prefix_products [1, 3, 2, 4] 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: list(range(7))\n-/\n#guard_msgs in\n#eval sorted [1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_permutation_with_prefix_products(6)"}
{"id": "fvapps_002067", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n-- Length matches k\n\n-- Sizes sum to n\n\n-- All partitions have same sum", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def check_possible_partition (n k : Nat) (arr : List Nat) : Option (List Nat) :=\nsorry\n\ndef getPrefixSums (arr : List Nat) (sizes : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem validate_partition_properties {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n)\n  (h2 : 0 < sumList arr) :\n  match check_possible_partition n k arr with\n  | none => True\n  | some result =>\n\n    result.length = k ∧\n\n    sumList result = n ∧\n\n    let partitions := getPrefixSums arr result;\n    match partitions with\n    | [] => True\n    | hd::_ => List.all partitions (fun x => x = hd) :=\nsorry\n\ntheorem impossible_partition {arr : List Nat}\n  (h : 0 < arr.length) :\n  check_possible_partition arr.length (arr.length + 1) arr = none :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002070", "vc-description": "", "vc-preamble": "def MOD : Nat := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_binary_string (s : String) : Nat :=\nsorry\n\ndef is_binary_string (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_binary_string_properties {s : String} (h : is_binary_string s = true) :\n  let result := solve_binary_string s\n  0 ≤ result ∧ result ≤ MOD :=\nsorry\n\ntheorem all_zeros {s : String} (h : ∀ c ∈ s.data, c = '0') :\n  solve_binary_string s = s.length :=\nsorry\n\ntheorem mod_property {s : String} (h : is_binary_string s = true) :\n  solve_binary_string s < MOD :=\nsorry\n\ntheorem split_ones {s : String} (h : is_binary_string s = true)\n  (h2 : s.data.filter (· = '1') = []) :\n  solve_binary_string s = String.length s :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_binary_string \"000\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_binary_string \"0101\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_binary_string \"0001111\""}
{"id": "fvapps_002072", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compute_lipschitz_sums (arr : List Nat) (queries : List (Nat × Nat)) : List Nat :=\nsorry\n\ndef sort (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem array_properties {arr : List Nat} (h: arr.length ≥ 2)\n  (hb: ∀ x, x ∈ arr → x ≤ 10^8) :\n  let result := compute_lipschitz_sums arr [(1, arr.length)]\n  result.length = 1 ∧\n  ∀ x, x ∈ result → x ≥ 0 :=\nsorry\n\ntheorem constant_array_sums {arr : List Nat} {queries : List (Nat × Nat)}\n  (h: arr.length ≥ 2)\n  (hconst: ∀ (i j : Fin arr.length), arr[i] = arr[j])\n  (hq: ∀ p, p ∈ queries → p.1 ≤ p.2 ∧ p.2 ≤ arr.length) :\n  ∀ x, x ∈ compute_lipschitz_sums arr queries → x = 0 :=\nsorry\n\ntheorem query_bounds_valid {arr : List Nat} {queries : List (Nat × Nat)}\n  (h: arr.length ≥ 2)\n  (hq: ∀ p, p ∈ queries → p.1 ≤ p.2 ∧ p.2 ≤ arr.length) :\n  let results := compute_lipschitz_sums arr queries\n  results.length = queries.length :=\nsorry\n\ntheorem monotonic_increasing_minimal {arr : List Nat}\n  (h: arr.length ≥ 2)\n  (hb: ∀ x, x ∈ arr → x ≤ 10) :\n  let sorted := sort arr\n  let orig_sum := (compute_lipschitz_sums arr [(1, arr.length)]).head!\n  let sorted_sum := (compute_lipschitz_sums sorted [(1, arr.length)]).head!\n  sorted_sum ≤ orig_sum :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: [17, 82, 23, 210]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [1, 5, 2, 9, 1, 3, 4, 2, 1, 7] [(2, 4), (3, 8), (7, 10), (1, 9)]\n\n/-\ninfo: [2, 0, 22, 59, 16, 8]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [5, 7, 7, 4, 6, 6, 2] [(1, 2), (2, 3), (2, 6), (1, 7), (4, 7), (3, 5)]\n\n/-\ninfo: [100000000, 100000000]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [100000000, 0] [(1, 2), (1, 2)]"}
{"id": "fvapps_002076", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_xor_tree (n : Nat) (edges : List (Nat × Nat)) (init : List Nat) (goal : List Nat) : List Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem basic_properties {n : Nat} {xor_values : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 20) (h3 : ∀ x ∈ xor_values, x = 0 ∨ x = 1)\n  (h4 : xor_values.length = n) :\n  let edges := List.map (fun i => (i + 2, (i + 2)/2)) (List.range (n-1))\n  let goal := xor_values\n  let init := List.replicate n 0\n  let result := solve_xor_tree n edges init goal\n  (∀ x ∈ result, x ≥ 1 ∧ x ≤ n) :=\nsorry\n\ntheorem single_node_zero {init goal : List Nat}\n  (h1 : init.length = 1) (h2 : goal.length = 1)\n  (h3 : init = [0]) (h4 : goal = [0]) :\n  solve_xor_tree 1 [] init goal = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len solve_xor_tree(n, edges, init, goal)"}
{"id": "fvapps_002077", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Int) : Int :=\nsorry\n\ndef calc_fraction (n : Int) : Int × Int :=\nsorry\n\ndef fraction_to_str (frac : Int × Int) : String :=\nsorry", "vc-theorems": "theorem calc_fraction_valid_output {n : Int} (h : n ≥ 2) :\n  let (num, den) := calc_fraction n\n  den > 0 ∧ gcd num.natAbs den.natAbs = 1 :=\nsorry\n\ntheorem fraction_to_str_format {n : Int} (h : n ≥ 2) :\n  let frac := calc_fraction n\n  let str := fraction_to_str frac\n  ∃ num den : String,\n    str = num ++ \"/\" ++ den ∧\n    (frac.1 = String.toInt! num) ∧\n    (frac.2 = String.toInt! den) :=\nsorry\n\ntheorem gcd_properties {a b : Int} (ha : a > 0) (hb : b > 0) :\n  let g := gcd a b\n  g > 0 ∧ a % g = 0 ∧ b % g = 0 :=\nsorry\n\ntheorem calc_fraction_two :\n  calc_fraction 2 = (1, 6) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: '1/6'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(2)\n\n/-\ninfo: '7/30'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(3)\n\n/-\ninfo: '5/14'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(6)"}
{"id": "fvapps_002090", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_chain_length (n m : Nat) (edges : List (Nat × Nat)) : Int :=\nsorry\n\ndef to_adj_matrix (n : Nat) (edges : List (Nat × Nat)) : List (List Nat) :=\nsorry\n\ndef is_bipartite (adj : List (List Nat)) (colors : List Int) (start n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem bipartite_property (n m : Nat) (edges : List (Nat × Nat)) :\n  let result := solve_max_chain_length n m edges\n  let adj := to_adj_matrix n edges\n  ∀ colors : List Int,\n  result ≠ -1 →\n  colors.length = n →\n  (∀ i < n, colors[i]! = -1 ∨ colors[i]! = 0 ∨ colors[i]! = 1) →\n  ∀ start < n,\n  is_bipartite adj colors start n = true :=\nsorry\n\ntheorem empty_graph_property (n m : Nat) (edges : List (Nat × Nat)) :\n  m = 0 →\n  solve_max_chain_length n m edges = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_max_chain_length 5 4 [(1, 2), (2, 3), (3, 4), (3, 5)]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 6 [(1, 2), (2, 3), (1, 3), (3, 4), (2, 4), (1, 4)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 2 [(1, 3), (2, 4)]"}
{"id": "fvapps_002095", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_psychos (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef is_sorted_desc (arr : List Nat) : Bool :=\n  sorry\n\ndef is_strictly_sorted_asc (arr : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem empty_single_array :\n  solve_psychos 0 [] = 0 ∧\n  ∀ x : Nat, solve_psychos 1 [x] = 0 :=\nsorry\n\ntheorem solve_psychos_bounds :\n  ∀ (n : Nat) (arr : List Nat),\n  arr.length = n →\n  0 ≤ solve_psychos n arr ∧\n  solve_psychos n arr ≤ n - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_psychos 10 [10, 9, 7, 8, 6, 5, 3, 4, 2, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_psychos 6 [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_psychos 6 [6, 5, 4, 3, 2, 1]"}
{"id": "fvapps_002098", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_dfs (n : Nat) (parents : List Nat := []) : List Float :=\nsorry\n\ndef is_valid_tree (parents : List Nat) : Bool :=\nsorry\n\ndef abs (x : Float) : Float :=\nsorry", "vc-theorems": "theorem single_node_properties (n : Nat) (h : n = 1) :\n  let result := solve_tree_dfs n\n  (result.length = 1) ∧\n  (abs (result[0]! - 1.0) < 0.000001) :=\nsorry\n\ntheorem valid_tree_properties {n : Nat} {parents : List Nat}\n  (h : is_valid_tree parents = true) :\n  let result := solve_tree_dfs (n + 1) parents\n  (result.length = n + 1) ∧\n  (abs (result[0]! - 1.0) < 0.000001) ∧\n  (∀ i p, i < parents.length → p = parents[i]! → result[i+1]! > result[p-1]!) ∧\n  (∀ x, x ∈ result → x ≥ 1.0) ∧\n  (∀ x, x ∈ result → x ≤ Float.ofNat (n + 1)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002102", "vc-description": "/- Helper function to process a string by replacing kh sequences -/\n\n/- Helper function to process a string by replacing u with oo -/\n\n/- Helper function to fully process a string with all replacements -/", "vc-preamble": "def processString (s: String) : String := processKh (processU s)\n\ndef unique {α} [BEq α] (l: List α) : List α :=\n  l.foldl (fun acc x => if acc.elem x then acc else x :: acc) []", "vc-helpers": "", "vc-definitions": "def count_distinct_names (words: List String) : Nat :=\nsorry\n\ndef processKh (s: String) : String :=\nsorry\n\ndef processU (s: String) : String :=\nsorry", "vc-theorems": "theorem count_distinct_names_bounded (words: List String) (h: words ≠ []) :\n  let result := count_distinct_names words\n  result ≤ words.length ∧ result ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_distinct_names [\"mihail\", \"oolyana\", \"kooooper\", \"hoon\", \"ulyana\", \"koouper\", \"mikhail\", \"khun\", \"kuooper\", \"kkkhoon\"]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_names [\"hariton\", \"hkariton\", \"buoi\", \"kkkhariton\", \"boooi\", \"bui\", \"khariton\", \"boui\", \"boi\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_names [\"alex\", \"alex\"]"}
{"id": "fvapps_002103", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry\n\ndef maxHappiness (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem maxHappiness_valid_tree (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges → True :=\nsorry\n\ntheorem maxHappiness_nonnegative (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges → maxHappiness n k edges ≥ 0 :=\nsorry\n\ntheorem maxHappiness_zero_when_k_geq_n (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges →\n  k ≥ n →\n  maxHappiness n k edges = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_happiness 7 4 [(1, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_happiness 4 1 [(1, 2), (1, 3), (2, 4)]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval max_happiness 8 5 [(7, 5), (1, 7), (6, 1), (3, 7), (8, 3), (2, 1), (4, 5)]"}
{"id": "fvapps_002126", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countValidBitSwaps (n : Nat) (a : String) (b : String) : Nat :=\n  sorry\n\ndef stringRepeat (s : String) (n : Nat) : String :=\n  sorry\n\ndef makeAlternatingString (n : Nat) (startBit : String) : String :=\n  sorry", "vc-theorems": "theorem countValidBitSwaps_returns_natural (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  ∃ (m : Nat), countValidBitSwaps n a b = m := by\nsorry\n\ntheorem countValidBitSwaps_nonnegative (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  countValidBitSwaps n a b ≥ 0 := by\nsorry\n\ntheorem countValidBitSwaps_all_zeros (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"0\" n) (stringRepeat \"0\" n) = 0 := by\nsorry\n\ntheorem countValidBitSwaps_all_ones (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"1\" n) (stringRepeat \"1\" n) = 0 := by\nsorry\n\ntheorem countValidBitSwaps_alternating (n : Nat) :\n  let alt1 := makeAlternatingString n \"0\"\n  let alt2 := makeAlternatingString n \"1\"\n  ∃ (m : Nat), countValidBitSwaps n alt1 alt2 = m := by\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 5 \"01011\" \"11001\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 6 \"011000\" \"010011\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 2 \"00\" \"00\""}
{"id": "fvapps_002129", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isRegular (s : String) : Bool :=\n  sorry\n\ndef findRegularSubsequence (s : String) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem find_regular_subsequence_properties\n  (input : String)\n  (k : Nat)\n  (h1 : isRegular input = true)\n  (h2 : k % 2 = 0)\n  (h3 : k ≤ input.length)\n  : let result := findRegularSubsequence input k\n    (result.length = k) ∧\n    (isRegular result = true) ∧\n    (∀ c, c ∈ result.data → c = '(' ∨ c = ')') ∧\n    (result.data.count '(' = result.data.count ')') ∧\n    (∀ c, c ∈ result.data → c ∈ input.data) :=\nsorry\n\ntheorem find_regular_subsequence_minimal_case :\n  (findRegularSubsequence \"()\" 2 = \"()\") ∧\n  (findRegularSubsequence \"()\" 0 = \"\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002131", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sub (a b : List α) : Bool :=\nsorry\n\ndef sub_string (a b : String) : Bool :=\nsorry\n\ndef subword (t : List Int) (ord_ar : List Int) (n : Int) : List Int :=\nsorry\n\ndef bin_s (l r : Int) (f : Int → Bool) : Int := sorry\n\n@[simp] theorem sub_empty (a : List α) :\n  sub a [] = true := sorry\n\n@[simp] theorem sub_longer (a s : List α) :\n  List.length s > List.length a → sub a s = false := sorry\n\n@[simp] theorem sub_refl (a : List α) :\n  sub a a = true := sorry\n\n@[simp] theorem sub_string_empty (a b : String) :\n  sub_string a \"\" = true := sorry\n\n@[simp] theorem sub_string_longer (a b : String) :\n  String.length b > String.length a → sub_string a b = false := sorry\n\n@[simp] theorem sub_string_refl (a : String) :\n  sub_string a a = true :=\nsorry", "vc-theorems": "theorem subword_length (t : List Int) (ord_ar : List Int) (n : Int) :\n  List.length t = List.length ord_ar →\n  List.length (subword t ord_ar n) ≤ List.length t :=\nsorry\n\ntheorem bin_search_bounds (l r : Int) (f : Int → Bool) :\n  r > l + 1 →\n  let res := bin_s l r f\n  l ≤ res ∧ res ≤ r :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"ababcba\" \"abb\" [5, 3, 4, 1, 7, 6, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve \"bbbabb\" \"bb\" [1, 6, 3, 4, 2, 5]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve \"cacaccccccacccc\" \"cacc\" [10, 9, 14, 5, 1, 7, 15, 3, 6, 12, 4, 8, 11, 13, 2]"}
{"id": "fvapps_002137", "vc-description": "", "vc-preamble": "def BinaryIndexedTree : Type := Unit", "vc-helpers": "", "vc-definitions": "def BinaryIndexedTree.mk (n : Nat) : BinaryIndexedTree :=\nsorry\n\ndef BinaryIndexedTree.add (self : BinaryIndexedTree) (i : Nat) (x : Int) : Unit :=\nsorry\n\ndef BinaryIndexedTree.sum (self : BinaryIndexedTree) (i : Nat) : Int :=\nsorry\n\ndef BinaryIndexedTree.sum_range (self : BinaryIndexedTree) (l r : Nat) : Int :=\nsorry\n\ndef BinaryIndexedTree.data (self : BinaryIndexedTree) : List Int :=\nsorry\n\ndef solve (n : Nat) (perm : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem bit_init_properties (n : Nat) (h : n > 0) :\n  let bit := BinaryIndexedTree.mk n\n  List.length (BinaryIndexedTree.data bit) = n + 1 ∧\n  List.all (BinaryIndexedTree.data bit) (λ x => x = 0) :=\nsorry\n\ntheorem bit_add_sum_properties (n i : Nat) (x : Int) (h1 : n > 0) (h2 : i > 0) (h3 : i ≤ n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := BinaryIndexedTree.add bit i x\n  BinaryIndexedTree.sum bit i = x ∧ BinaryIndexedTree.sum bit n = x :=\nsorry\n\ntheorem bit_range_sum_property (n l r : Nat) (h1 : n > 0) (h2 : l > 0) (h3 : r > 0)\n  (h4 : l ≤ r) (h5 : r ≤ n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := List.foldl (λ b i => BinaryIndexedTree.add b (i + l) 1) bit (List.range (r - l + 1))\n  BinaryIndexedTree.sum_range bit' l r = r - l + 1 :=\nsorry\n\ntheorem solve_properties (n : Nat) (perm : List Nat) (h1 : n > 0)\n  (h2 : List.length perm = n)\n  (h3 : ∀ i j, i < j → perm.get! i < perm.get! j)\n  (h4 : List.Nodup perm) :\n  let result := solve n perm\n  List.length result = n ∧\n  List.all result (λ x => x ≥ 0) ∧\n  result.head? = some 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1, 3, 6, 10]\n-/\n#guard_msgs in\n#eval solve 5 [5, 4, 3, 2, 1]\n\n/-\ninfo: [0, 0, 0]\n-/\n#guard_msgs in\n#eval solve 3 [1, 2, 3]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 1 [1]"}
{"id": "fvapps_002138", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_max_popcount (l r : Nat) : Nat :=\n  sorry\n\ndef popcount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_in_range (l r : Nat) :\n  let ordered_l := min l r\n  let ordered_r := max l r\n  let result := get_max_popcount ordered_l ordered_r\n  ordered_l ≤ result ∧ result ≤ ordered_r :=\nsorry\n\ntheorem same_number (x : Nat) :\n  get_max_popcount x x = x :=\nsorry\n\ntheorem consecutive_numbers (x : Nat) :\n  popcount (get_max_popcount x (x + 1)) ≥ popcount x :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval get_max_popcount 1 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_popcount 2 4\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_popcount 1 10"}
{"id": "fvapps_002140", "vc-description": "", "vc-preamble": "def list_max (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (list_max xs)", "vc-helpers": "", "vc-definitions": "def solve_tree_zeros (n : Nat) (edges : List (Nat × Nat)) (values : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_tree_zeros_nonnegative (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  solve_tree_zeros n edges values ≥ 0 :=\nsorry\n\ntheorem solve_tree_zeros_finite (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  ∃ (k : Nat), solve_tree_zeros n edges values = k :=\nsorry\n\ntheorem solve_tree_zeros_bounds (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  solve_tree_zeros n edges values ≥ list_max (values.map Int.natAbs) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_zeros 3 [(1, 2), (1, 3)] [1, -1, 1]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_tree_zeros 5 [(2, 3), (4, 5), (2, 5), (1, 3)] [0, 2, 1, 4, 3]\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_tree_zeros 10 [(5, 6), (8, 2), (9, 3), (4, 1), (6, 10), (9, 8), (7, 10), (7, 4), (5, 2)] [0, -6, -9, -1, -5, -4, -2, -7, -8, -3]"}
{"id": "fvapps_002153", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def create_maze (T : Nat) : Nat × Nat × Nat × List (Nat × Nat × Nat × Nat) :=\nsorry\n\ndef is_valid_door (door : Nat × Nat × Nat × Nat) (n m : Nat) : Bool :=\nsorry\n\ndef are_doors_unique (doors : List (Nat × Nat × Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem minimal_maze_properties (T : Nat) (h : T > 0) (h2 : T ≤ 5) :\n  let (n, m, k, doors) := create_maze T\n  n = 4 ∧\n  m = 4 ∧\n  k ≥ 3 ∧\n  k ≤ 6 :=\nsorry\n\ntheorem large_maze_properties (T : Nat) (h : T ≥ 6^4) (h2 : T < 6^5) :\n  let (n, m, k, doors) := create_maze T\n  n = 12 ∧\n  m = 12 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002159", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bitadd (idx : Nat) (val : Int) (bit : Array Int) : Array Int :=\n  sorry\n\ndef bitsum (idx : Nat) (bit : Array Int) : Int :=\n  sorry", "vc-theorems": "theorem bitadd_inverse (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx (-val) (bitadd idx val bit)) = bitsum idx bit :=\nsorry\n\ntheorem bitadd_retrieval (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx val bit) = bitsum idx bit + val :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002160", "vc-description": "/- For a valid allocation, the number of games per stadium for each team differs by at most 2 -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The allocation list has the same length as the input game list -/\n\n/- Empty game list produces empty allocation -/\n\n/- Basic case works: two teams, one game, one stadium -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def allocate_stadium_games (n m k : Nat) (games : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem stadium_balance {n k : Nat} {games : List (Nat × Nat)} {allocation : List Nat}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1)\n  (h3 : allocation = allocate_stadium_games n games.length k games)\n  (h4 : ∀ g, g ∈ games → g.1 ≤ n ∧ g.2 ≤ n ∧ g.1 < g.2)\n  (h5 : ∀ s, s ∈ allocation → s ≥ 1 ∧ s ≤ k) :\n  ∀ t, t ≤ n →\n    ∀ s1 s2, s1 ≤ k → s2 ≤ k →\n      Nat.sub ((games.zip allocation).filter (λ p => (p.1.1 = t ∨ p.1.2 = t) ∧ p.2 = s1) |>.length)\n              ((games.zip allocation).filter (λ p => (p.1.1 = t ∨ p.1.2 = t) ∧ p.2 = s2) |>.length) ≤ 2 :=\nsorry\n\ntheorem allocation_length_eq_games {n k : Nat} {games : List (Nat × Nat)}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1) :\n  (allocate_stadium_games n games.length k games).length = games.length :=\nsorry\n\ntheorem empty_games_empty_allocation {n k : Nat}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1) :\n  allocate_stadium_games n 0 k [] = [] :=\nsorry\n\ntheorem minimum_viable_case :\n  allocate_stadium_games 2 1 1 [(1, 2)] = [1] :=\nsorry", "vc-postamble": "/-\ninfo: m\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)"}
{"id": "fvapps_002161", "vc-description": "", "vc-preamble": "def abs (n : Nat) (m : Nat) : Nat :=\n  if n ≥ m then n - m else m - n", "vc-helpers": "", "vc-definitions": "def solve_fireworks (n m d : Nat) (fireworks : List (Nat × Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem fireworks_total_balls_bound {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  solve_fireworks n m d fireworks ≤ (fireworks.foldl (fun acc p => acc + p.2.1) 0) + n :=\nsorry\n\ntheorem fireworks_timestamps_increasing {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  ∀ i, i < fireworks.length - 1 →\n    (fireworks.get ⟨i, sorry⟩).2.2 < (fireworks.get ⟨i+1, sorry⟩).2.2 :=\nsorry\n\ntheorem fireworks_positions_valid {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  ∀ f ∈ fireworks, 1 ≤ f.1 ∧ f.1 ≤ n :=\nsorry\n\ntheorem single_firework_result {n balls d : Nat} {pos : Nat}\n  (h1 : n > 0) (h2 : balls > 0) (h3 : d > 0) (h4 : pos = n/2) :\n  solve_fireworks n 1 d [(pos, balls, 1)] =\n    balls - (List.range n).foldl (fun m i => min m (abs pos (i + 1))) (abs pos 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: -31\n-/\n#guard_msgs in\n#eval solve_fireworks 50 3 1 [(49, 1, 1), (26, 1, 4), (6, 1, 10)]\n\n/-\ninfo: 1992\n-/\n#guard_msgs in\n#eval solve_fireworks 10 2 1 [(1, 1000, 4), (9, 1000, 4)]\n\n/-\ninfo: 418\n-/\n#guard_msgs in\n#eval solve_fireworks 30 8 2 [(15, 97, 3), (18, 64, 10), (20, 14, 20), (16, 18, 36), (10, 23, 45), (12, 60, 53), (17, 93, 71), (11, 49, 85)]"}
{"id": "fvapps_002172", "vc-description": "/- For any valid input arrays A and B of length N, the output is non-negative and less than 2^30 -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The result is symmetric with respect to input arrays -/\n\n/- When both input arrays are identical, the result is even -/\n\n/- When both input arrays contain only zeros, the result is zero -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compute_xor_sum (N : Nat) (A B : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) (h3 : ∀ x ∈ A, x ≤ 1000000) (h4 : ∀ x ∈ B, x ≤ 1000000) :\n  compute_xor_sum N A B ≥ 0 ∧ compute_xor_sum N A B < 2^30 :=\nsorry\n\ntheorem symmetry (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) :\n  compute_xor_sum N A B = compute_xor_sum N B A :=\nsorry\n\ntheorem identical_arrays (N : Nat) (A : List Nat) (h : A.length = N) :\n  2 ∣ compute_xor_sum N A A :=\nsorry\n\ntheorem zero_arrays (N : Nat) :\n  compute_xor_sum N (List.replicate N 0) (List.replicate N 0) = 0 :=\nsorry", "vc-postamble": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 2 [1, 2] [3, 4]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval compute_xor_sum 6 [4, 6, 0, 0, 3, 3] [0, 5, 6, 5, 0, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 5 [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]"}
{"id": "fvapps_002174", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_game (n : Nat) (r : Nat) (initial : List Int) (changes : List (Nat × Int)) : List Float :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry\n\ndef list_average (l : List Int) : Float :=\n  sorry\n\ndef list_update (l : List Int) (idx : Nat) (val : Int) : List Int :=\n  sorry\n\ndef float_close (a b : Float) : Bool :=\n  sorry", "vc-theorems": "theorem solve_game_result_length {n r : Nat} {initial : List Int} {changes : List (Nat × Int)} :\n  initial.length = 2^n →\n  (∀ change, change ∈ changes → change.1 < 2^n) →\n  (solve_game n r initial changes).length = r + 1 :=\nsorry\n\ntheorem solve_game_averages {n r : Nat} {initial : List Int} {changes : List (Nat × Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : ∀ change, change ∈ changes → change.1 < 2^n)\n  (i : Fin r)\n  (h_changes_length : changes.length > i.val)\n  (h_result_length : (solve_game n r initial changes).length > i.val) :\n  let updated := list_update initial ((changes.get ⟨i.val, h_changes_length⟩).1) ((changes.get ⟨i.val, h_changes_length⟩).2)\n  float_close ((solve_game n r initial changes).get ⟨i.val, h_result_length⟩) (list_average updated) :=\nsorry\n\ntheorem solve_game_final_average {n r : Nat} {initial : List Int} {changes : List (Nat × Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : ∀ change, change ∈ changes → change.1 < 2^n)\n  (h_r : r > 0)\n  (h_changes_length : changes.length ≥ r)\n  (h_idx : r - 1 < changes.length)\n  (h_result_length : r < (solve_game n r initial changes).length) :\n  let final_update := list_update initial ((changes.get ⟨r-1, h_idx⟩).1) ((changes.get ⟨r-1, h_idx⟩).2)\n  float_close ((solve_game n r initial changes).get ⟨r, h_result_length⟩) (list_average final_update) :=\nsorry\n\ntheorem solve_game_no_changes {n : Nat} {initial : List Int}\n  (h_init : initial.length = 2^n)\n  (h_all_ones : ∀ x, x ∈ initial → x = 1)\n  (h_length : 0 < (solve_game n 0 initial []).length) :\n  (solve_game n 0 initial []).length = 1 ∧\n  float_close ((solve_game n 0 initial []).get ⟨0, h_length⟩) 1.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002175", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef List.sort (l: List Nat) : List Nat :=\n  sorry\n\ndef solve_minimized_workload (n: Nat) (p: Nat) (workloads: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem workload_result_bounds (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p > 0) (h4: p ≤ 10)\n  (h5: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h6: workloads.length > 0) (h7: workloads.length ≤ 100) :\n  let result := solve_minimized_workload n p workloads\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem workload_p_one_special_case (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p = 1)\n  (h4: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h5: workloads.length > 0) (h6: workloads.length ≤ 100) :\n  let result := solve_minimized_workload n p workloads\n  result = n % 2 ∧ (result = 0 ∨ result = 1) :=\nsorry\n\ntheorem workload_sort_invariant (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p > 0) (h4: p ≤ 10)\n  (h5: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h6: workloads.length > 0) (h7: workloads.length ≤ 100) :\n  solve_minimized_workload n p workloads =\n  solve_minimized_workload n p (List.sort workloads) :=\nsorry\n\ntheorem workload_length_matches_n (p: Nat) (workloads: List Nat)\n  (h1: p > 0) (h2: p ≤ 10)\n  (h3: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h4: workloads.length > 0) (h5: workloads.length ≤ 100) :\n  let n := workloads.length\n  let result := solve_minimized_workload n p workloads\n  0 ≤ result ∧ result < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_minimized_workload 5 2 [2, 3, 4, 4, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_minimized_workload 3 1 [2, 10, 1000]\n\n/-\ninfo: 146981438\n-/\n#guard_msgs in\n#eval solve_minimized_workload 4 5 [0, 1, 1, 100]"}
{"id": "fvapps_002177", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_cyclic_permutation (n m q : Nat) (p : List Nat) (a : List Nat) (queries : List (Nat × Nat)) : String :=\n  sorry\n\ndef String.reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem result_is_valid_binary_string {n m q : Nat} {p a : List Nat} {queries : List (Nat × Nat)}\n  (h₁ : n > 0) (h₂ : m > 0) (h₃ : q > 0)\n  (h₄ : p.length = n) (h₅ : a.length = m)\n  (h₆ : queries.length = q)\n  (h₇ : ∀ x ∈ p, 1 ≤ x ∧ x ≤ n)\n  (h₈ : ∀ x ∈ a, 1 ≤ x ∧ x ≤ n)\n  (h₉ : ∀ q ∈ queries, 1 ≤ q.1 ∧ q.1 ≤ m ∧ 1 ≤ q.2 ∧ q.2 ≤ m ∧ q.1 ≤ q.2) :\n  let result := solve_cyclic_permutation n m q p a queries\n  result.length = q ∧ ∀ c ∈ result.data, c = '0' ∨ c = '1' :=\nsorry\n\ntheorem query_ordering_invariant {n m q : Nat} {p a : List Nat} {queries : List (Nat × Nat)}\n  (h₁ : n > 0) (h₂ : m > 0) (h₃ : q > 0)\n  (h₄ : p.length = n) (h₅ : a.length = m)\n  (h₆ : queries.length = q)\n  (h₇ : ∀ x ∈ p, 1 ≤ x ∧ x ≤ n)\n  (h₈ : ∀ x ∈ a, 1 ≤ x ∧ x ≤ n)\n  (h₉ : ∀ q ∈ queries, 1 ≤ q.1 ∧ q.1 ≤ m ∧ 1 ≤ q.2 ∧ q.2 ≤ m ∧ q.1 ≤ q.2) :\n  solve_cyclic_permutation n m q p a queries =\n  String.reverse (solve_cyclic_permutation n m q p a (List.reverse queries)) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: '110'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 3 6 3 [2, 1, 3] [1, 2, 3, 1, 2, 3] [[1, 5], [2, 6], [3, 5]]\n\n/-\ninfo: '010'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 2 4 3 [2, 1] [1, 1, 2, 2] [[1, 2], [2, 3], [3, 4]]\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 1 1 1 [1] [1] [[1, 1]]"}
{"id": "fvapps_002178", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countEmptyParabolas (points : List (Int × Int)) : Nat :=\n  sorry\n\ndef makeParabolaPoints (a h k : Int) (n : Nat) : List (Int × Int) :=\n  sorry", "vc-theorems": "theorem countEmptyParabolas_nonnegative (points : List (Int × Int)) :\n  countEmptyParabolas points ≥ 0 := by\n  sorry\n\ntheorem countEmptyParabolas_single_point (point : Int × Int) :\n  countEmptyParabolas [point] = 0 := by\n  sorry\n\ntheorem countEmptyParabolas_through_parabola_points (a h k : Int) :\n  a ≠ 0 →\n  countEmptyParabolas (makeParabolaPoints a h k 5) ≥ 1 := by\n  sorry\n\ntheorem countEmptyParabolas_duplicate_x_values (points : List (Int × Int)) :\n  let deduped := points.foldl (fun acc (x, y) =>\n    match acc.find? (fun (x', _) => x' = x) with\n    | none => acc ++ [(x, y)]\n    | some (x', y') =>\n      if y > y'\n      then acc.map (fun (x'', y'') => if x'' = x then (x, y) else (x'', y''))\n      else acc\n    ) []\n  countEmptyParabolas points = countEmptyParabolas deduped := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-1, 0), (0, 2), (1, 0)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, -1)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-751115, -925948)]"}
{"id": "fvapps_002179", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\nsorry\n\ndef checkNumbersFriends (a b : Nat) : Bool :=\nsorry\n\ndef countLonelyNumbers (n : Nat) : Nat :=\nsorry\n\ndef isTriangle (a b c : Nat) : Bool :=\nsorry\n\ndef solveTestCases (nums : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem gcd_positive (a b : Nat) : a > 0 → b > 0 → gcd a b > 0 :=\nsorry\n\ntheorem not_self_friends (a : Nat) : a > 0 →\n  checkNumbersFriends a a = false :=\nsorry\n\ntheorem lonely_numbers_bounds (n : Nat) : n > 0 →\n  countLonelyNumbers n ≤ n :=\nsorry\n\ntheorem gcd_divides (a b : Nat) : a > 0 → b > 0 →\n  a % (gcd a b) = 0 ∧ b % (gcd a b) = 0 :=\nsorry\n\ntheorem gcd_symmetric (a b : Nat) : a > 0 → b > 0 → gcd a b = gcd b a :=\nsorry\n\ntheorem triangle_inequality (a b c : Nat) : a > 0 → b > 0 → c > 0 →\n  isTriangle a b c = true →\n    a + b > c ∧ b + c > a ∧ a + c > b :=\nsorry\n\ntheorem triangle_symmetric (a b c : Nat) : a > 0 → b > 0 → c > 0 →\n  isTriangle a b c = isTriangle b c a ∧\n  isTriangle b c a = isTriangle c a b :=\nsorry\n\ntheorem friends_symmetric (a b : Nat) : a > 0 → b > 0 →\n  checkNumbersFriends a b = checkNumbersFriends b a :=\nsorry\n\ntheorem one_is_lonely : countLonelyNumbers 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 3, 3]\n-/\n#guard_msgs in\n#eval solve_test_cases [1, 5, 10]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_test_cases [1]\n\n/-\ninfo: [3, 7]\n-/\n#guard_msgs in\n#eval solve_test_cases [10, 20]"}
{"id": "fvapps_002180", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "def BIT (n : Nat) : Type := Unit", "vc-helpers": "", "vc-definitions": "def BIT.add (bit : BIT n) (i j v : Nat) : Unit :=\nsorry\n\ndef BIT.get_val (bit : BIT n) (i : Nat) : Nat :=\nsorry\n\ndef BIT.mk (n : Nat) : BIT n :=\nsorry\n\ndef solve_tree_queries (n : Nat) (costs : List Nat) (edges : List (List Nat)) (queries : List (List Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem bit_get_after_add (n i : Nat) (h : i < n) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 1 :=\nsorry\n\ntheorem bit_accumulate_adds (n i : Nat) (h : i < n - 1) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 2 :=\nsorry\n\ntheorem solve_tree_queries_initial_cost\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (h : n ≥ 2) :\n  let queries := [[2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 :=\nsorry\n\ntheorem solve_tree_queries_update\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (val : Nat) (h : n ≥ 2) :\n  let queries := [[1,1,val], [2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 + val :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002181", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_rectangle_pairs (n : Nat) (rectangles : List (Nat × Nat × Nat)) : Nat :=\n  sorry\n\ndef sqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem non_negative_result (n : Nat) (rectangles : List (Nat × Nat × Nat)) :\n  count_rectangle_pairs n rectangles ≥ 0 :=\nsorry\n\ntheorem single_rect_count (rect : Nat × Nat × Nat) (count : Nat)\n    (h : rect.2.2 = count) :\n  let factors := (List.range (sqrt count)).filter (fun i => count % i = 0)\n  count_rectangle_pairs 1 [rect] = if sqrt count * sqrt count = count\n    then 2 * factors.length - 1\n    else 2 * factors.length :=\nsorry\n\ntheorem result_bounded_by_min_count (n : Nat) (rectangles : List (Nat × Nat × Nat))\n    (h : rectangles ≠ []) :\n  count_rectangle_pairs n rectangles ≤\n    List.foldl Nat.min ((List.head! rectangles).2.2)\n      (List.tail! rectangles |>.map (fun r => r.2.2)) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 1 [(1, 1, 9)]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(2, 3, 20), (2, 4, 40)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(1, 2, 5), (2, 3, 5)]"}
{"id": "fvapps_002188", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_shortest_non_subsequence (s : String) : String :=\n  sorry\n\ndef is_subsequence (needle haystack : String) : Bool :=\n  sorry\n\ndef generate_strings (length : Nat) : List String :=\n  sorry\n\ndef all_chars_in_range (s : String) : Bool :=\n  sorry\n\ndef all_lower (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_is_valid_string (s : String) :\n  let result := find_shortest_non_subsequence s\n  (result.length > 0) ∧ (all_lower result) := by\n  sorry\n\ntheorem result_is_minimal (s : String) :\n  let result := find_shortest_non_subsequence s\n  ∀ n : Nat, n < result.length →\n  ∀ possible : String, possible.length = n →\n  is_subsequence possible s := by\n  sorry\n\ntheorem result_for_all_letters {s : String} :\n  s.length = 26 →\n  (∀ c : Char, c.isLower → s.contains c) →\n  find_shortest_non_subsequence s = \"aa\" := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'b'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"atcoderregularcontest\"\n\n/-\ninfo: 'aa'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"abcdefghijklmnopqrstuvwxyz\"\n\n/-\ninfo: 'aca'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"frqnvhydscshfcgdemurlfrutcpzhopfotpifgepnqjxupnskapziurswqazdwnwbgdhyktfyhqqxpoidfhjdakoxraiedxskywuepzfniuyskxiyjpjlxuqnfgmnjcvtlpnclfkpervxmdbvrbrdn\""}
{"id": "fvapps_002190", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkTreeWithDistances (N : Nat) (distances : List Nat) : List (Nat × Nat) ⊕ Unit :=\n  sorry\n\ndef isValidTree (N : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem arbitrary_inputs_valid {N : Nat} {distances : List Nat}\n  (h1 : N ≥ 2) (h2 : N ≤ 20) (h3 : distances.length = N) :\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :=\nsorry\n\ntheorem identical_distances_invalid {N : Nat} (h : N ≥ 2) :\n  let distances := List.replicate N N\n  checkTreeWithDistances N distances = .inr () :=\nsorry\n\ntheorem sequential_distances_valid {N : Nat} (h1 : N ≥ 2) (h2 : N ≤ 20) :\n  let distances := List.range N\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :=\nsorry\n\ntheorem edge_cases :\n  (checkTreeWithDistances 2 [1,1] = .inr ()) ∧\n  (checkTreeWithDistances 2 [0,0] = .inr ()) ∧\n  (match checkTreeWithDistances 3 [3,4,5] with\n   | .inl edges => isValidTree 3 edges = true\n   | .inr _ => False) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: N1 - 1\n-/\n#guard_msgs in\n#eval len result\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval check_tree_with_distances 2 [1, 2]\n\n/-\ninfo: N3 - 1\n-/\n#guard_msgs in\n#eval len result"}
{"id": "fvapps_002208", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def Grid := List (List Char)", "vc-helpers": "", "vc-definitions": "def solve_rock_puzzle (n m : Nat) : Grid × (Nat × Nat) :=\nsorry\n\ndef count_arrows (grid : Grid) : Nat :=\nsorry\n\ndef is_square_grid (grid : Grid) : Bool :=\nsorry\n\ndef valid_start_pos (pos : Nat × Nat) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_rock_puzzle_dimensions {n : Nat} (h : n > 0) :\n  let (grid, start_pos) := solve_rock_puzzle n n\n  List.length grid = n ∧\n  is_square_grid grid = true ∧\n  valid_start_pos start_pos n = true :=\nsorry\n\ntheorem valid_characters {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  ∀ (i : Nat), i < List.length grid →\n  ∀ (j : Nat), j < List.length (List.get! grid i) →\n  let c := List.get! (List.get! grid i) j\n  c = '^' ∨ c = 'v' ∨ c = '<' ∨ c = '>' ∨ c = '.' :=\nsorry\n\ntheorem has_arrows {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  count_arrows grid > 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002211", "vc-description": "", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | h::t => h + sum_list t", "vc-helpers": "", "vc-definitions": "def min_cost_to_cut_trees (n : Nat) (heights : List Nat) (costs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≥ 0 :=\nsorry\n\ntheorem min_cost_upper_bound (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≤ sum_list (heights.map (· * costs.head!)) :=\nsorry\n\ntheorem min_cost_last_worker_bound (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length ≥ 2)\n  (h2 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 100)\n  (h3 : costs.length = heights.length)\n  (h4 : ∀ c ∈ costs, c ≤ 100)\n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees heights.length heights costs ≥ heights.getLast! * costs.getLast! :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 0]\n\n/-\ninfo: 138\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 6 [1, 2, 3, 10, 20, 30] [6, 5, 4, 3, 2, 0]"}
{"id": "fvapps_002213", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidPermutation (arr : List Int) : Bool :=\n  sorry\n\ndef solveNextPermutation (n : Nat) (arr : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem single_element_case {n : Nat} (h : n > 0) (h2 : n ≤ 100) :\n  solveNextPermutation 1 [-1] = [1] := by\n  sorry\n\ntheorem all_minus_ones {n : Nat} (h : n > 0) (h2 : n ≤ 20) :\n  let result := solveNextPermutation n (List.replicate n (-1))\n  isValidPermutation result ∧\n  result = (List.range n).map (fun x => Int.ofNat (x + 1)) := by\n  sorry\n\ntheorem sequential_pointers {n : Nat} (h : n > 1) (h2 : n ≤ 20) :\n  let nextVals := (List.range n).map (fun x => Int.ofNat (x + 2))\n  let result := solveNextPermutation n nextVals\n  isValidPermutation result := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval solve_next_permutation 3 [2, 3, 4]\n\n/-\ninfo: [2, 1]\n-/\n#guard_msgs in\n#eval solve_next_permutation 2 [3, 3]\n\n/-\ninfo: [3, 1, 2, 4]\n-/\n#guard_msgs in\n#eval solve_next_permutation 4 [4, -1, 4, 5]"}
{"id": "fvapps_002239", "vc-description": "", "vc-preamble": "def MOD := 998244353", "vc-helpers": "", "vc-definitions": "def solve_test (n : Nat) (numbers : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_test_within_mod_bounds\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n ≥ 1) (h3 : n ≤ 9)\n  (h4 : ∀ x ∈ numbers, 1 ≤ x ∧ x ≤ 10^9) :\n  0 ≤ solve_test n numbers ∧ solve_test n numbers < MOD :=\nsorry\n\ntheorem solve_test_order_independent\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n ≥ 1) (h3 : n ≤ 9)\n  (h4 : ∀ x ∈ numbers, 1 ≤ x ∧ x ≤ 10^9) :\n  solve_test n numbers = solve_test n numbers.reverse :=\nsorry\n\ntheorem solve_test_large_identical_numbers\n  (n : Nat) (v : Nat) (h1 : n ≥ 2) (h2 : n ≤ 9) (h3 : v = 10^9)\n  (numbers : List Nat) (h4 : numbers = List.replicate n v) :\n  0 ≤ solve_test n numbers ∧ solve_test n numbers < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 2 [1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [1, 31, 12]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [12345, 67, 84]\n\n/-\ninfo: 31680\n-/\n#guard_msgs in\n#eval solve_test 9 [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"id": "fvapps_002240", "vc-description": "", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef calculate_movable_sum (n d : Nat) (haybales : List Nat) : Nat :=\n  let rec aux : Nat → Nat → Nat\n    | 0, acc => acc\n    | i+1, acc =>\n      let moves := d / (i+1)\n      let val := match haybales.get? i with\n        | none => 0\n        | some x => min moves x\n      aux i (acc + val)\n  aux (n-1) 0", "vc-helpers": "", "vc-definitions": "def solve_haystack (n : Nat) (d : Nat) (haybales : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_haystack_within_first_pile_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≥ (haybales.get ⟨0, sorry⟩) := by\n  sorry\n\ntheorem solve_haystack_within_total_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≤ list_sum haybales := by\n  sorry\n\ntheorem solve_haystack_within_movable_limit {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≤\n    (haybales.get ⟨0, sorry⟩) + calculate_movable_sum n d haybales := by\n  sorry\n\ntheorem solve_haystack_single_pile {d : Nat} {hay : Nat} :\n  solve_haystack 1 d [hay] = hay := by\n  sorry\n\ntheorem solve_haystack_zero_days {n : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n 0 haybales = haybales.get ⟨0, sorry⟩ := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_haystack 4 5 [1, 0, 3, 2]\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval solve_haystack 2 2 [100, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haystack 1 8 [0]"}
{"id": "fvapps_002250", "vc-description": "", "vc-preamble": "abbrev M : Nat := 1000000007\n\ndef list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def solve_sequence_sum (n m : Nat) (sequence : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_sequence_sum_nonneg (n m : Nat) (sequence : List Nat) :\n  solve_sequence_sum n m sequence ≥ 0 :=\nsorry\n\ntheorem solve_sequence_sum_special_case :\n  solve_sequence_sum 1 1 [0] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_sequence_sum 3 5 [1, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_sequence_sum 1 1 [0]"}
{"id": "fvapps_002252", "vc-description": "-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Matrix := List (List Char)\n\ndef is_valid_adjacency_matrix (m: Matrix) : Bool :=\nsorry\n\ndef is_symmetric (m: Matrix) : Bool :=\nsorry\n\ndef generate_graph (k: Nat) : Nat × Matrix :=\nsorry", "vc-theorems": "theorem generated_graph_is_valid (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_valid_adjacency_matrix matrix = true :=\nsorry\n\ntheorem generated_graph_is_symmetric (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_symmetric matrix = true :=\nsorry\n\ntheorem size_properties (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  n ≤ 4 * k ∧\n  matrix.length = n ∧\n  List.all matrix (fun row => row.length = n) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002253", "vc-description": "", "vc-preamble": "def in_bounds (x y : Int) : Bool :=\n-100000 ≤ x ∧ x ≤ 100000 ∧ -100000 ≤ y ∧ y ≤ 100000", "vc-helpers": "", "vc-definitions": "def Position := Int × Int × Bool × Bool × Bool × Bool\n\ndef find_robot_gather_point (robots : List Position) : List Int :=\nsorry", "vc-theorems": "theorem gather_point_valid (robots : List Position) :\n  let result := find_robot_gather_point robots\n  (result.length = 1 ∧ result = [0]) ∨\n  (result.length = 3 ∧\n   result.get! 0 = 1 ∧\n   let x := result.get! 1\n   let y := result.get! 2\n   in_bounds x y ∧\n   ∀ (robot : Position),\n   robot ∈ robots →\n   let (rx, ry, can_left, can_up, can_right, can_down) := robot\n   (¬can_left → x ≥ rx) ∧\n   (¬can_right → x ≤ rx) ∧\n   (¬can_up → y ≤ ry) ∧\n   (¬can_down → y ≥ ry)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, -1, -2]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[-1, -2, 0, 0, 0, 0], [-1, -2, 0, 0, 0, 0]]\n\n/-\ninfo: [1, 2, 5]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1, 5, 1, 1, 1, 1], [2, 5, 0, 1, 0, 1], [3, 5, 1, 0, 0, 0]]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1337, 1337, 0, 1, 1, 1], [1336, 1337, 1, 1, 0, 1]]"}
{"id": "fvapps_002259", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_to_equalize (n : Nat) (candies : List Nat) (oranges : List Nat) : Nat :=\n  sorry\n\ndef list_max (l : List Nat) : Nat :=\n  sorry\n\ndef list_min (l : List Nat) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≥ 0 :=\nsorry\n\ntheorem min_moves_lower_bound (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≥\n    max\n      (list_max candies - list_min candies)\n      (list_max oranges - list_min oranges) :=\nsorry\n\ntheorem min_moves_upper_bound (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≤\n    (list_sum (candies.map (λ x => x - list_min candies))) +\n    (list_sum (oranges.map (λ x => x - list_min oranges))) :=\nsorry\n\ntheorem identical_lists_zero_moves (n : Nat) (v : Nat) :\n  min_moves_to_equalize n (List.replicate n v) (List.replicate n v) = 0 :=\nsorry\n\ntheorem min_moves_symmetric (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges = min_moves_to_equalize n oranges candies :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [3, 5, 6] [3, 2, 3]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 1]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [10, 12, 8] [7, 5, 4]"}
{"id": "fvapps_002262", "vc-description": "/- Theorem stating that result is always a valid index or 0 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Theorem stating that sorted ascending arrays return 0 -/\n\n/- Theorem stating that single element arrays return 0 -/\n\n/- Theorem stating that constant arrays return 0 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findShortestPrefix (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_shortest_prefix_bounds {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0) :\n  let result := findShortestPrefix n arr\n  0 ≤ result ∧ result < n :=\nsorry\n\ntheorem find_shortest_prefix_sorted_asc {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : ∀ i j, i < j → j < arr.length → arr[i]! ≤ arr[j]!) :\n  findShortestPrefix n arr = 0 :=\nsorry\n\ntheorem find_shortest_prefix_single {arr : List Int}\n  (h : arr.length = 1) :\n  findShortestPrefix 1 arr = 0 :=\nsorry\n\ntheorem find_shortest_prefix_constant {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : ∀ i j, i < arr.length → j < arr.length → arr[i]! = arr[j]!) :\n  findShortestPrefix n arr = 0 :=\nsorry", "vc-postamble": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 4 [1, 2, 3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_shortest_prefix 7 [4, 3, 3, 8, 4, 5, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 3 [1, 1, 1]"}
{"id": "fvapps_002263", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_required (n : Nat) : Nat :=\n  sorry\n\ndef nat_sqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (n : Nat) (h : n > 0) :\n  min_moves_required n ≥ 0 :=\nsorry\n\ntheorem min_moves_less_than_input (n : Nat) (h : n > 0) :\n  min_moves_required n ≤ n :=\nsorry\n\ntheorem min_moves_monotonic (n : Nat) (h : n > 1) :\n  min_moves_required n ≥ min_moves_required (n-1) :=\nsorry\n\ntheorem min_moves_base_case :\n  min_moves_required 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_required 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves_required 5\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval min_moves_required 42"}
{"id": "fvapps_002266", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_leaf_removal (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem leaf_removal_basic_properties {n k : Nat} {edges : List (Nat × Nat)}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 1)\n    (h3 : k ≤ 5)\n    (h4 : is_valid_tree n edges = true) :\n    let result := solve_leaf_removal n k edges\n    result ≥ 0 ∧ result ≤ (n + k - 1) / k :=\nsorry\n\ntheorem leaf_removal_single_node {k : Nat}\n    (h : k ≥ 1) :\n    solve_leaf_removal 1 k [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_leaf_removal 8 3 [(1, 2), (1, 5), (7, 6), (6, 8), (3, 1), (6, 4), (6, 1)]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_leaf_removal 10 3 [(1, 2), (1, 10), (2, 3), (1, 5), (1, 6), (2, 4), (7, 10), (10, 9), (8, 10)]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_leaf_removal 5 1 [(1, 2), (2, 3), (4, 3), (5, 3)]"}
{"id": "fvapps_002267", "vc-description": "", "vc-preamble": "def isSorted (arr : List Int) : Prop :=\n  ∀ i j, i < j → j < arr.length → arr[i]! ≤ arr[j]!\n\ndef isStrictlySorted (arr : List Int) : Prop :=\n  ∀ i j, i < j → j < arr.length → arr[i]! < arr[j]!", "vc-helpers": "", "vc-definitions": "def minimum_operations (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (arr : List Int) (h : arr ≠ []) :\n  0 ≤ minimum_operations arr ∧ minimum_operations arr ≤ arr.length :=\nsorry\n\ntheorem sorted_unique_needs_zero {arr : List Int} (h1 : arr ≠ [])\n  (h2 : isStrictlySorted arr) :\n  minimum_operations arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [4, 7, 2, 3, 9]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [3, 5, 8, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum_operations [1, 4, 5, 7, 12]"}
{"id": "fvapps_002269", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_garland (n k : Nat) (s : String) : Nat :=\nsorry\n\ndef is_valid_garland (n k : Nat) (s : String) : Bool :=\nsorry\n\ndef count_zeros (s : String) : Nat :=\nsorry\n\ndef all_ones (s : String) : Bool :=\nsorry\n\ndef all_zeros (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_garland_nonnegative (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  solve_garland n k s ≥ 0 :=\nsorry\n\ntheorem solve_garland_bounded_by_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  solve_garland n k s ≤ count_zeros s :=\nsorry\n\ntheorem solve_garland_all_ones (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  all_ones s →\n  solve_garland n k s = 0 :=\nsorry\n\ntheorem solve_garland_all_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  all_zeros s →\n  solve_garland n k s ≤ (n + k - 1) / k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_garland 9 2 \"010001010\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_garland 9 3 \"111100000\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_garland 1 1 \"0\""}
{"id": "fvapps_002270", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_frog_jumps (s : String) : Nat :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem frog_jumps_positive_bound (s : String) :\n  solve_frog_jumps s ≥ 1 :=\nsorry\n\ntheorem frog_jumps_upper_bound (s : String) :\n  solve_frog_jumps s ≤ s.length + 2 :=\nsorry\n\ntheorem frog_jumps_consecutive_r (s : String) :\n  solve_frog_jumps s = solve_frog_jumps (s.replace \"R\" \"RR\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LRLRRLL\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"L\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LLR\""}
{"id": "fvapps_002271", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingDistance (s1 s2 : String) : Nat :=\n  sorry\n\ndef verifyResult (result : String) (strings : List String) : Bool :=\n  sorry\n\ndef findSimilarString (strings : List String) (n m : Nat) : String :=\n  sorry\n\ndef isLower (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem find_similar_string_properties {strings : List String} {n m : Nat}\n  (h1 : n = strings.length)\n  (h2 : m > 0)\n  (h3 : ∀ s ∈ strings, s.length = m)\n  (result := findSimilarString strings n m) :\n    (result = \"-1\" ∨ result.length = m) ∧\n    (result = \"-1\" ∨ ∀ c ∈ result.data, isLower c) ∧\n    verifyResult result strings\n  :=\nsorry\n\ntheorem binary_strings_property {strings : List String} {n m : Nat}\n  (h1 : strings.length = 2)\n  (h2 : strings.head!.length = strings.tail!.head!.length)\n  (h3 : ∀ s ∈ strings, ∀ c ∈ s.data, c = 'a' ∨ c = 'b')\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :=\nsorry\n\ntheorem small_inputs_property {strings : List String} {n m : Nat}\n  (h1 : strings.length ≤ 3)\n  (h2 : strings.length > 0)\n  (h3 : ∀ s ∈ strings, s.length = strings.head!.length)\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval find_similar_string [\"aaaa\", \"bbbb\"] 2 4\n\n/-\ninfo: 'aaa'\n-/\n#guard_msgs in\n#eval find_similar_string [\"baa\", \"aaa\", \"aab\"] 3 3"}
{"id": "fvapps_002273", "vc-description": "", "vc-preamble": "def isSorted {α : Type u} [Ord α] [LE α] (xs : List α) : Prop :=\n  match xs with\n  | [] => True\n  | [_] => True\n  | x :: y :: rest => x ≤ y ∧ isSorted (y :: rest)", "vc-helpers": "", "vc-definitions": "def min_ops_to_sort {α : Type u} [Ord α] (arr : List α) : Nat :=\n  sorry", "vc-theorems": "theorem translation_invariant (arr : List Int) (k : Int) :\n  min_ops_to_sort arr = min_ops_to_sort (arr.map (fun x => x + k)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [4, 7, 2, 2, 9]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [3, 5, 8, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_to_sort [1, 2, 2, 4, 5]"}
{"id": "fvapps_002279", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_candy_gift (n : Nat) (candies : List Nat) : Nat :=\n  sorry\n\ndef count_occurrences (a : Nat) (l : List Nat) : Nat :=\n  sorry\n\ndef frequency_list (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_candy_gift_bounded\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  solve_candy_gift n candies ≤ n :=\nsorry\n\ntheorem solve_candy_gift_nonnegative\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  0 ≤ solve_candy_gift n candies :=\nsorry\n\ntheorem solve_candy_gift_monotonic_frequencies\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  let freqs := frequency_list candies\n  let result := solve_candy_gift n candies\n  ∀ i j, i < j → i < freqs.length → j < freqs.length →\n  let take_i := if i = 0 then result else min ((freqs.get! (i-1))-1) (freqs.get! i)\n  let take_j := if j = 0 then result else min ((freqs.get! (j-1))-1) (freqs.get! j)\n  take_i ≥ take_j :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_candy_gift 8 [1, 4, 8, 4, 5, 6, 3, 8]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval solve_candy_gift 16 [2, 1, 3, 3, 4, 3, 4, 4, 1, 3, 2, 2, 2, 4, 1, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_candy_gift 9 [2, 2, 4, 4, 4, 7, 7, 7, 7]"}
{"id": "fvapps_002280", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_sort (n : Nat) (arr : List Nat) : List Nat :=\nsorry\n\ndef List.sort (l : List Nat) : List Nat :=\nsorry\n\ndef List.swap3 (l : List α) (pos : Nat) : List α :=\nsorry", "vc-theorems": "theorem sort_already_sorted {n : Nat} {arr : List Nat} (h1 : n ≥ 3)\n  (h2 : arr = List.range' 1 n) :\n  solve_array_sort n arr = [0] :=\nsorry\n\ntheorem sort_result_correctness {n : Nat} {arr : List Nat} (h1 : n ≥ 3)\n  (h2 : arr.length = n)\n  (result : List Nat) (h3 : result = solve_array_sort n arr) :\n  result = [0] ∨ result = [Nat.zero] ∨\n  (match result with\n  | [] => False\n  | num_moves :: moves =>\n    moves.length = num_moves ∧\n    let final := moves.foldl\n      (λ acc pos => acc.swap3 (pos-1)) arr;\n    final.sort = List.range' 1 n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [1, 2, 3, 4, 5]\n\n/-\ninfo: [6, 3, 1, 3, 2, 2, 3]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [5, 4, 3, 2, 1]\n\n/-\ninfo: [4, 3, 3, 4, 4]\n-/\n#guard_msgs in\n#eval solve_array_sort 6 [1, 2, 3, 3, 6, 4]"}
{"id": "fvapps_002292", "vc-description": "", "vc-preamble": "def perfect_numbers : List Int := [6, 28, 496, 8128, 33550336, 8589869056]\n\ndef small_perfect_numbers : List Int := [6, 28, 496, 8128]", "vc-helpers": "", "vc-definitions": "def check_perfect_number (n : Int) : Bool :=\n  sorry", "vc-theorems": "theorem known_perfect_numbers (n : Int) (h : n ∈ perfect_numbers) :\n  check_perfect_number n = true :=\nsorry\n\ntheorem most_numbers_not_perfect {n : Int} (h₁ : n ≥ 1) (h₂ : n ≤ 1000000)\n  (h₃ : n ∉ small_perfect_numbers) :\n  check_perfect_number n = false :=\nsorry\n\ntheorem non_positive_not_perfect {n : Int} (h : n ≤ 0) :\n  check_perfect_number n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_perfect_number 28\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 12\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 1"}
{"id": "fvapps_002295", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def subtract_product_and_sum (n : Nat) : Int :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef product_of_list (l : List Nat) : Nat :=\nsorry\n\ndef sum_of_list (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_digit_zero (n : Nat) (h : n > 0 ∧ n < 10) :\n  subtract_product_and_sum n = 0 :=\nsorry\n\ntheorem three_digit_bounds (n : Nat) (h : n ≥ 100 ∧ n ≤ 999) :\n  subtract_product_and_sum n ≤ 729 ∧ subtract_product_and_sum n ≥ -27 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 234\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 4421\n\n/-\ninfo: -2\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 111"}
{"id": "fvapps_002299", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def third_max (nums : List Int) : Int :=\nsorry\n\ndef max (nums : List Int) : Int :=\nsorry\n\ndef uniqueSorted (nums : List Int) : List Int :=\nsorry", "vc-theorems": "theorem third_max_is_in_list {nums : List Int} (h : nums ≠ []) :\n  third_max nums ∈ nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval third_max [1, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [2, 2, 3, 1]"}
{"id": "fvapps_002302", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTriplet (arr : List Int) (i j k a b c : Nat) : Bool :=\n  sorry\n\ndef countTripletsBruteforce (arr : List Int) (a b c : Nat) : Nat :=\n  sorry\n\ndef countGoodTriplets (arr : List Int) (a b c : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem countGoodTriplets_matches_bruteforce\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length ≥ 3)\n    (h2 : arr.length ≤ 20)\n    (h3 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100)\n    (h4 : a ≤ 50 ∧ b ≤ 50 ∧ c ≤ 50) :\n    countGoodTriplets arr a b c = countTripletsBruteforce arr a b c :=\nsorry\n\ntheorem countGoodTriplets_nonnegative\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length ≥ 3)\n    (h2 : arr.length ≤ 20) :\n    0 ≤ countGoodTriplets arr a b c :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_good_triplets [3, 0, 1, 1, 9, 7] 7 2 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 1, 2, 2, 3] 0 0 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 2, 3, 4, 5] 1 1 1"}
{"id": "fvapps_002303", "vc-description": "", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def searchInsert (nums : List Int) (target : Int) : Nat :=\n  sorry", "vc-theorems": "theorem searchInsert_valid_index\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    0 ≤ result ∧ result ≤ nums.length :=\nsorry\n\ntheorem searchInsert_left_smaller\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    ∀ i, i < result → nums[i]! < target :=\nsorry\n\ntheorem searchInsert_right_greater_eq\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    ∀ i, result ≤ i → i < nums.length → nums[i]! ≥ target :=\nsorry\n\ntheorem searchInsert_maintains_order\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    let inserted := (nums.take result).append (target :: nums.drop result)\n    isSorted inserted :=\nsorry\n\ntheorem searchInsert_identity\n    {nums : List Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums)\n    {i : Nat} (h3 : i < nums.length) :\n    searchInsert nums nums[i]! = List.findIdx (· = nums[i]!) nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 7"}
{"id": "fvapps_002306", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def contains_duplicate (nums : List Int) : Bool :=\n  sorry\n\ndef eraseDups (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem contains_duplicate_matches_set_size {nums : List Int} :\n  contains_duplicate nums = (nums.length ≠ (eraseDups nums).length) :=\nsorry\n\ntheorem contains_duplicate_set_membership {nums : List Int} :\n  contains_duplicate nums = ∃ i j, i < j ∧ j < nums.length ∧ nums[i]! = nums[j]! :=\nsorry\n\ntheorem unique_list_returns_false {nums : List Int}\n  (h : ∀ i j, i < j → j < nums.length → nums[i]! ≠ nums[j]!) :\n  ¬contains_duplicate nums :=\nsorry\n\ntheorem repeated_element_returns_true {nums : List Int} (h : nums ≠ []) :\n  contains_duplicate (nums ++ nums.take 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]"}
{"id": "fvapps_002308", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_anagram (s t : String) : Bool :=\n  sorry\n\ndef reverse (s : String) : String :=\n  sorry\n\ndef isPermutation (s t : String) : Bool :=\n  sorry", "vc-theorems": "theorem string_is_anagram_of_itself (s : String) :\n  is_anagram s s = true :=\nsorry\n\ntheorem different_length_strings_not_anagrams {s t : String}\n  (h : s.length ≠ t.length) :\n  is_anagram s t = false :=\nsorry\n\ntheorem reversed_string_is_anagram (s : String) :\n  is_anagram s (reverse s) = true :=\nsorry\n\ntheorem permuted_string_is_anagram (s t : String)\n  (h : isPermutation s t) :\n  is_anagram s t = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"anagram\" \"nagaram\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_anagram \"rat\" \"car\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"hello\" \"hello\""}
{"id": "fvapps_002312", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add_strings (a b : String) : String :=\n  sorry\n\ndef int_to_str (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem add_strings_matches_int_addition\n  (a b : Nat) (h1 : a ≤ 10^6) (h2 : b ≤ 10^6) :\n  add_strings (int_to_str a) (int_to_str b) = int_to_str (a + b) :=\nsorry\n\ntheorem add_zero_right (n : Nat) (h : n ≤ 10^6) :\n  add_strings (int_to_str n) \"0\" = int_to_str n :=\nsorry\n\ntheorem add_zero_left (n : Nat) (h : n ≤ 10^6) :\n  add_strings \"0\" (int_to_str n) = int_to_str n :=\nsorry\n\ntheorem add_strings_commutative (n : Nat) (h : n ≤ 10^6) :\n  add_strings (int_to_str n) (int_to_str 42) =\n  add_strings (int_to_str 42) (int_to_str n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '172'\n-/\n#guard_msgs in\n#eval add_strings \"123\" \"49\"\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval add_strings \"0\" \"0\"\n\n/-\ninfo: '1000'\n-/\n#guard_msgs in\n#eval add_strings \"999\" \"1\""}
{"id": "fvapps_002319", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_k_diff_pairs (nums : List Int) (k : Int) : Int :=\n  sorry\n\ndef countOccurrences (nums : List Int) (x : Int) : Nat :=\n  sorry\n\ndef dedup (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem k_diff_pairs_property :\n  ∀ (nums : List Int) (k : Int),\n  let result := find_k_diff_pairs nums k\n  result ≥ 0 ∧ (k < 0 → result = 0) :=\nsorry\n\ntheorem positive_k_pairs_symmetric :\n  ∀ (nums : List Int) (k : Int),\n  k > 0 →\n  find_k_diff_pairs nums (-k) = 0 :=\nsorry\n\ntheorem k_diff_pairs_subset :\n  ∀ (nums : List Int) (k : Int),\n  k > 0 →\n  nums.length > 0 →\n  let subset := nums.take (nums.length / 2)\n  find_k_diff_pairs subset k ≤ find_k_diff_pairs nums k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [3, 1, 4, 1, 5] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 2, 3, 4, 5] 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 3, 1, 5, 4] 0"}
{"id": "fvapps_002321", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUppercase (c : Char) : Bool :=\nsorry\n\ndef toCharList (s : String) : List Char :=\nsorry\n\ndef removeDashes (s : String) : String :=\nsorry\n\ndef licenseKeyFormatting (s : String) (k : Nat) : String :=\nsorry", "vc-theorems": "theorem license_key_uppercase (s : String) (k : Nat) :\n  ∀ c ∈ toCharList (licenseKeyFormatting s k), isUppercase c = true\n  :=\nsorry\n\ntheorem license_key_same_length (s : String) (k : Nat) :\n  String.length (removeDashes (licenseKeyFormatting s k)) =\n  String.length (removeDashes s)\n  :=\nsorry\n\ntheorem license_key_group_sizes (s : String) (k : Nat) :\n  let result := licenseKeyFormatting s k\n  let groups := String.splitOn result \"-\"\n  groups.length ≤ 1 ∨\n  (∀ g ∈ groups.tail, String.length g = k) ∧ String.length groups.head! ≤ k\n  :=\nsorry\n\ntheorem license_key_empty (k : Nat) :\n  licenseKeyFormatting \"\" k = \"\"\n  :=\nsorry\n\ntheorem license_key_single_dash (k : Nat) :\n  licenseKeyFormatting \"-\" k = \"\"\n  :=\nsorry\n\ntheorem license_key_no_dashes (s : String) (k : Nat) :\n  (∀ c ∈ toCharList s, c ≠ '-') →\n  removeDashes (licenseKeyFormatting s k) = String.mk (List.map Char.toUpper (toCharList s))\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5F3Z-2E9W'\n-/\n#guard_msgs in\n#eval license_key_formatting \"5F3Z-2e-9-w\" 4\n\n/-\ninfo: '2-5G-3J'\n-/\n#guard_msgs in\n#eval license_key_formatting \"2-5g-3-J\" 2\n\n/-\ninfo: 'A-B-C'\n-/\n#guard_msgs in\n#eval license_key_formatting \"a-b-c\" 1"}
{"id": "fvapps_002322", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countTrailingOnes : List Nat → Nat\n  | [] => 0\n  | xs => sorry\n\ndef is_one_bit_character (bits : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem ends_with_zero {bits : List Nat} (h : bits ≠ []) :\n  bits.getLast (by exact h) = 0 →\n  is_one_bit_character bits = true ∨ is_one_bit_character bits = false :=\nsorry\n\ntheorem all_zeros_is_true {bits : List Nat} (h : bits ≠ []) :\n  (bits.all (fun x => x = 0)) →\n  is_one_bit_character bits = true :=\nsorry\n\ntheorem trailing_ones_parity {bits : List Nat} (h : bits.length ≥ 2) :\n  is_one_bit_character bits = (countTrailingOnes (bits.dropLast) % 2 = 0) :=\nsorry\n\ntheorem edge_cases_hold :\n  (is_one_bit_character [0] = true) ∧\n  (is_one_bit_character [0, 0] = true) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 0, 0]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 1, 1, 0]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [0, 0]"}
{"id": "fvapps_002324", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (s : String) : Bool :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem empty_string_is_palindrome :\n  is_palindrome \"\" = true :=\nsorry\n\ntheorem string_plus_reverse_is_palindrome {s : String} :\n  is_palindrome (s ++ reverseString s) = true :=\nsorry\n\ntheorem case_insensitive {s : String} :\n  is_palindrome s = is_palindrome (s.toUpper) ∧\n  is_palindrome s = is_palindrome (s.toLower) :=\nsorry\n\ntheorem punctuation_invariant {s p c : Char} :\n  is_palindrome (String.mk [c]) = is_palindrome (String.mk [c, p]) :=\nsorry\n\ntheorem single_char_is_palindrome {c : Char} :\n  is_palindrome (String.mk [c]) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"A man, a plan, a canal: Panama\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"race a car\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"\""}
{"id": "fvapps_002326", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def splitString (s: String) : List String :=\n  sorry\n\ndef lengthOfLastWord (s: String) : Nat :=\n  sorry", "vc-theorems": "theorem length_of_last_word_nonnegative (s: String) :\n  lengthOfLastWord s ≥ 0 :=\nsorry\n\ntheorem length_of_last_word_matches_split (s: String) :\n  lengthOfLastWord s > 0 →\n  match splitString s with\n  | [] => True\n  | xs => lengthOfLastWord s = xs.getLast!.length\n  :=\nsorry\n\ntheorem length_of_last_word_empty_for_blank (s: String) :\n  s.trim.isEmpty → lengthOfLastWord s = 0 :=\nsorry\n\ntheorem length_of_last_word_ignores_trailing_spaces (s: String) :\n  lengthOfLastWord s = lengthOfLastWord s.trim :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello World\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval length_of_last_word \"   \"\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello   World   Program\""}
{"id": "fvapps_002327", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_str (haystack : String) (needle : String) : Int :=\n  sorry\n\ndef containsString (haystack needle : String) : Bool :=\n  sorry\n\ndef stringSlice (s : String) (start : Int) (last : Int) : String :=\n  sorry\n\ndef stringRepeat (s : String) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem empty_needle_returns_zero {haystack : String} :\n  find_str haystack \"\" = 0 := by\nsorry\n\ntheorem empty_haystack_nonempty_needle_returns_minus_one {needle : String} (h : needle ≠ \"\") :\n  find_str \"\" needle = -1 := by\nsorry\n\ntheorem needle_not_found_returns_minus_one {haystack needle : String}\n  (h : containsString haystack needle = false) :\n  find_str haystack needle = -1 := by\nsorry\n\ntheorem result_is_valid_index {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  0 ≤ r ∧ r < String.length haystack := by\nsorry\n\ntheorem result_points_to_needle {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  (stringSlice haystack r (r + String.length needle)) = needle := by\nsorry\n\ntheorem no_earlier_occurrence {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  containsString (stringSlice haystack 0 r) needle = false := by\nsorry\n\ntheorem repeated_needle_returns_zero {s : String} {n : Nat}\n  (h1 : s ≠ \"\") (h2 : n > 0) :\n  find_str (stringRepeat s n) s = 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_str \"hello\" \"ll\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_str \"aaaaa\" \"bba\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_str \"\" \"\""}
{"id": "fvapps_002329", "vc-description": "", "vc-preamble": "def makeBalloonsString (n : Nat) : String :=\n  String.join (List.replicate n \"balloon\")", "vc-helpers": "", "vc-definitions": "def max_balloons (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem max_balloons_nonnegative (text : String) :\n  max_balloons text ≥ 0 :=\nsorry\n\ntheorem max_balloons_upper_bound (text : String) :\n  max_balloons text ≤ text.length / 7 :=\nsorry\n\ntheorem max_balloons_has_needed_chars (text : String) (c : Char) :\n  let result := max_balloons text\n  let needed := match c with\n    | 'b' => result\n    | 'a' => result\n    | 'l' => 2 * result\n    | 'o' => 2 * result\n    | 'n' => result\n    | _ => 0\n  (text.toList.filter (· = c)).length ≥ needed :=\nsorry\n\ntheorem max_balloons_exact (n : Nat) :\n  max_balloons (makeBalloonsString n) = n :=\nsorry\n\ntheorem max_balloons_no_relevant_chars (text : String)\n  (h : ∀ c ∈ text.toList, c ∉ ['b', 'a', 'l', 'o', 'n']) :\n  max_balloons text = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_balloons \"nlaebolko\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_balloons \"loonbalxballpoon\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_balloons \"leetcode\""}
{"id": "fvapps_002334", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_palindrome_subseq (s : String) : Nat :=\nsorry\n\ndef is_palindrome (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem result_bounds (s : String) :\n  0 ≤ remove_palindrome_subseq s ∧ remove_palindrome_subseq s ≤ 2 :=\nsorry\n\ntheorem empty_string :\n  remove_palindrome_subseq \"\" = 0 :=\nsorry\n\ntheorem single_char_type (s : String) :\n  s.length = 1 → remove_palindrome_subseq s = 1 :=\nsorry\n\ntheorem only_valid_results (s : String) :\n  remove_palindrome_subseq s = 0 ∨\n  remove_palindrome_subseq s = 1 ∨\n  remove_palindrome_subseq s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"ababa\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"abb\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"baabb\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"\""}
{"id": "fvapps_002341", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def backspace_compare (s1: String) (s2: String) : Bool :=\n  sorry\n\ndef normalize_backspace (s: String) : String :=\n  sorry", "vc-theorems": "theorem backspace_compare_matches_naive (s1 s2: String) :\n  backspace_compare s1 s2 = (normalize_backspace s1 = normalize_backspace s2) :=\nby\nsorry\n\ntheorem self_compare (s: String) :\n  backspace_compare s s = true :=\nby\nsorry\n\ntheorem symmetric (s1 s2: String) :\n  backspace_compare s1 s2 = backspace_compare s2 s1 :=\nby\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab#c\" \"ad#c\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab##\" \"c#d#\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval backspace_compare \"a#c\" \"b\""}
{"id": "fvapps_002344", "vc-description": "/- Helper function to convert hex string to number (just for theorem statements) -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_hex (n : Int) : String :=\nsorry\n\ndef hexToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem to_hex_positive_integers (n : Nat) (h : n < 2^32) :\n  let result := to_hex n\n  (hexToNat result = n) ∧\n  (result.length ≤ 8) ∧\n  (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) :=\nsorry\n\ntheorem to_hex_negative_integers (n : Int) (h1 : -(2^31) ≤ n) (h2 : n < 0) :\n  let result := to_hex n\n  (result.length = 8) ∧\n  (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) ∧\n  (let value := hexToNat result\n   if value ≥ 2^31 then\n     value - 2^32 = n\n   else\n     value = n) :=\nsorry\n\ntheorem to_hex_zero :\n  to_hex 0 = \"0\" :=\nsorry\n\ntheorem to_hex_length (n : Int) :\n  let result := to_hex n\n  1 ≤ result.length ∧ result.length ≤ 8 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1a'\n-/\n#guard_msgs in\n#eval to_hex 26\n\n/-\ninfo: 'ffffffff'\n-/\n#guard_msgs in\n#eval to_hex -1\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval to_hex 0"}
{"id": "fvapps_002347", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def title_to_number (s : String) : Nat :=\n  sorry\n\ndef number_to_title (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem title_to_number_positive (title : String) :\n  title_to_number title > 0 := by\n  sorry\n\ntheorem title_to_number_monotone (title : String) :\n  (title.length > 1) →\n  title_to_number title > title_to_number (String.dropRight title 1) := by\n  sorry\n\ntheorem title_to_number_roundtrip (n : Nat) :\n  n > 0 → n ≤ 2^20 →\n  title_to_number (number_to_title n) = n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval title_to_number \"A\"\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval title_to_number \"AB\"\n\n/-\ninfo: 701\n-/\n#guard_msgs in\n#eval title_to_number \"ZY\""}
{"id": "fvapps_002356", "vc-description": "", "vc-preamble": "def list_sum (nums : List Nat) : Nat :=\n  List.foldl Nat.add 0 nums", "vc-helpers": "", "vc-definitions": "def rob (nums : List Nat) : Nat :=\n  sorry\n\ndef elementsAtEvenIndices (nums : List Nat) : List Nat :=\n  sorry\n\ndef elementsAtOddIndices (nums : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem rob_nonnegative (nums : List Nat) :\n  rob nums ≥ 0 :=\nsorry\n\ntheorem rob_even_indices_bound (nums : List Nat) (h : nums ≠ []) :\n  rob nums ≥ List.foldl Nat.max 0 (elementsAtEvenIndices nums) :=\nsorry\n\ntheorem rob_odd_indices_bound (nums : List Nat) (h : nums ≠ []) :\n  rob nums ≥ List.foldl Nat.max 0 (elementsAtOddIndices nums) :=\nsorry\n\ntheorem rob_minimum_of_first_two (nums : List Nat) (h : nums.length ≥ 2) :\n  rob nums ≥ Nat.max (nums.get ⟨0, sorry⟩) (nums.get ⟨1, sorry⟩) :=\nsorry\n\ntheorem rob_subset_sum (nums : List Nat) :\n  rob nums ≤ list_sum nums :=\nsorry\n\ntheorem rob_empty :\n  rob [] = 0 :=\nsorry\n\ntheorem rob_singleton (n : Nat) :\n  rob [n] = n :=\nsorry\n\ntheorem rob_pair (n m : Nat) :\n  rob [n, m] = Nat.max n m :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval rob [1, 2, 3, 1]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval rob [2, 7, 9, 3, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval rob [2, 1]"}
{"id": "fvapps_002362", "vc-description": "-- Theorem: Number of groups is bounded by list size\n\n-- Theorem: Special equivalent strings belong to same group\n\n-- Theorem: Upper bound for unique strings\n\n-- Theorem: Function is permutation invariant", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numSpecialEquivGroups (strings : List String) : Nat :=\n  sorry\n\ndef isSpecialEquivalent (s1 s2 : String) : Bool :=\n  sorry\n\ndef belongsToGroup (s : String) (g : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem num_groups_bounded (strings : List String) :\n  1 ≤ numSpecialEquivGroups strings ∧ numSpecialEquivGroups strings ≤ strings.length :=\nsorry\n\ntheorem special_equiv_same_group (s1 s2 : String) :\n  isSpecialEquivalent s1 s2 = true →\n  ∃ g, belongsToGroup s1 g = true ∧ belongsToGroup s2 g = true :=\nsorry\n\ntheorem unique_strings_bound (strings : List String) (h : strings.Nodup) :\n  numSpecialEquivGroups strings ≤ strings.length :=\nsorry\n\ntheorem permutation_invariant (strings : List String) :\n  numSpecialEquivGroups strings = numSpecialEquivGroups strings.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abcd\", \"cdab\", \"cbad\", \"xyzz\", \"zzxy\", \"zzyx\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"aa\", \"bb\", \"ab\", \"ba\"]"}
{"id": "fvapps_002365", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_cost_to_move_chips (positions: List Nat) : Nat :=\nsorry\n\ndef count_even (positions: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_cost_upper_bound (positions: List Nat) (h: positions ≠ []) :\n  min_cost_to_move_chips positions ≤ positions.length :=\nsorry\n\ntheorem min_cost_non_negative (positions: List Nat) :\n  min_cost_to_move_chips positions ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [2, 2, 2, 3, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 1000000000]"}
{"id": "fvapps_002366", "vc-description": "-- placeholder for sorting", "vc-preamble": "def List.sorted (xs : List Int) : List Int := xs\n\ndef evenIndexSum (xs : List Int) : Int :=\n  let rec loop : List Int → Int → Int → Int\n    | [], _, acc => acc\n    | (x::xs), i, acc => loop xs (i+1) (if i % 2 = 0 then acc + x else acc)\n  loop xs 0 0\n\ndef halfListSum (xs : List Int) : Int :=\n  let rec loop : List Int → Nat → Int → Int\n    | [], _, acc => acc\n    | _, 0, acc => acc\n    | (x::xs), n+1, acc => loop xs n (acc + x)\n  loop xs (xs.length / 2) 0", "vc-helpers": "", "vc-definitions": "def array_pair_sum (nums : List Int) : Int :=\nsorry", "vc-theorems": "theorem array_pair_sum_equals_even_indexed_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums = evenIndexSum (nums.sorted) :=\nsorry\n\ntheorem array_pair_sum_geq_smallest_half_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums ≥ halfListSum (nums.sorted) :=\nsorry\n\ntheorem array_pair_sum_positive {nums : List Int}\n  (h1 : nums.length % 2 = 0)\n  (h2 : ∀ x ∈ nums, x > 0) :\n  array_pair_sum nums > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 4, 3, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 2, 3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 1, 2, 2]"}
{"id": "fvapps_002371", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def repeatedSubstringPattern (s: String) : Bool :=\nsorry\n\ndef rotateString (s: String) : String :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry\n\ndef allCharsSame (s: String) : Bool :=\nsorry", "vc-theorems": "theorem repeatedSubstringPattern_single_char {s: String} :\n  s.length = 1 → ¬repeatedSubstringPattern s :=\nsorry\n\ntheorem repeatedSubstringPattern_rotation {s: String} (h: s.length ≥ 2) :\n  repeatedSubstringPattern s →\n  repeatedSubstringPattern (rotateString s) :=\nsorry\n\ntheorem repeatedSubstringPattern_doubled {s: String} (h: s.length > 0) :\n  repeatedSubstringPattern (s ++ s) :=\nsorry\n\ntheorem repeatedSubstringPattern_n_times {s: String} (n: Nat)\n    (h1: s.length > 0) (h2: n ≥ 3) (h3: n ≤ 10) :\n  repeatedSubstringPattern (String.append s (String.append s s)) :=\nsorry\n\ntheorem repeatedSubstringPattern_prime_length {s: String} (h1: s.length > 1) :\n  isPrime s.length →\n  ¬allCharsSame s →\n  ¬repeatedSubstringPattern s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abab\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"aba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abcabcabcabc\""}
{"id": "fvapps_002378", "vc-description": "", "vc-preamble": "def countChar (s : String) (c : Char) : Nat :=\n  s.toList.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def defang_ip_addr (s : String) : String :=\nsorry", "vc-theorems": "theorem defang_valid_ip_length {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  defanged.length = ip.length + 6 :=\nsorry\n\ntheorem defang_valid_ip_reversible {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  String.replace \"[.]\" \".\" defanged = ip :=\nsorry\n\ntheorem defang_valid_ip_count_dots {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  countChar defanged '[' = countChar ip '.' :=\nsorry\n\ntheorem defang_valid_ip_chars_match {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  let original_chars := ip.toList.filter (· ≠ '.')\n  let defanged_chars := defanged.toList.filter (fun c => c ≠ '[' ∧ c ≠ ']' ∧ c ≠ '.')\n  original_chars = defanged_chars :=\nsorry\n\ntheorem defang_generic_string_length (s : String) :\n  let defanged := defang_ip_addr s\n  defanged.length = s.length + (2 * countChar s '.') :=\nsorry\n\ntheorem defang_generic_string_reversible (s : String) :\n  let defanged := defang_ip_addr s\n  String.replace \"[.]\" \".\" defanged = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1[.]1[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"1.1.1.1\"\n\n/-\ninfo: '255[.]100[.]50[.]0'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"255.100.50.0\"\n\n/-\ninfo: '192[.]168[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"192.168.1.1\""}
{"id": "fvapps_002379", "vc-description": "/- Helper function for list sum -/\n\n/- Helper function to get nth element -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Helper function to check if one list is a permutation of another -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_be_equal (xs ys : List Int) : Bool :=\n  sorry\n\ndef isPerm (xs ys : List Int) : Bool :=\n  sorry\n\ndef listSum (xs : List Int) : Int :=\n  sorry\n\ndef getNth (xs : List Int) (n : Nat) : Int :=\n  sorry", "vc-theorems": "theorem identical_lists_are_equal (xs : List Int) :\n  can_be_equal xs xs = true :=\nsorry\n\ntheorem permuted_lists_are_equal {xs ys : List Int} :\n  isPerm xs ys → can_be_equal xs ys = true :=\nsorry\n\ntheorem different_value_not_equal {xs ys : List Int} (h1 : xs ≠ []) (h2 : ys ≠ []) :\n  (∃ i : Nat, getNth ys i = getNth xs i + (listSum xs + 1)) →\n  can_be_equal xs ys = false :=\nsorry\n\ntheorem different_length_not_equal {xs : List Int} (y : Int) :\n  can_be_equal xs (xs ++ [y]) = false :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [1, 2, 3, 4] [2, 4, 1, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [7] [7]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_be_equal [3, 7, 9] [3, 7, 11]"}
{"id": "fvapps_002384", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_power (s : List Char) : Nat :=\n  sorry\n\ndef max_run (s : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem max_power_lower_bound (s : List Char) (h : s.length > 0) :\n  max_power s ≥ 1 :=\nsorry\n\ntheorem max_power_upper_bound (s : List Char) :\n  max_power s ≤ s.length :=\nsorry\n\ntheorem max_power_equals_longest_run (s : List Char) (h : s.length > 0) :\n  max_power s = max_run s :=\nsorry\n\ntheorem max_power_single_char (s : List Char) (h : s.length > 0)\n  (h' : ∀ (i j : Fin s.length), s.get i = s.get j) :\n  max_power s = s.length :=\nsorry\n\ntheorem max_power_alternating (s : List Char) (h : s.length ≥ 2)\n  (h' : ∀ (i : Fin s.length),\n    if i.val % 2 = 0\n    then s.get i = 'a'\n    else s.get i = 'b') :\n  max_power s = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_power \"leetcode\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_power \"abbcccddddeeeeedcba\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_power \"tourist\""}
{"id": "fvapps_002390", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_isomorphic (s1 s2 : List Char) : Bool :=\n  sorry\n\ndef unique_chars (s : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem isomorphic_same_length {s1 s2 : List Char} :\n  s1.length ≠ s2.length → ¬is_isomorphic s1 s2 :=\nsorry\n\ntheorem isomorphic_identical_strings {s : List Char} :\n  is_isomorphic s s :=\nsorry\n\ntheorem isomorphic_reversible {s1 s2 : List Char} :\n  s1.length = s2.length →\n  is_isomorphic s1 s2 = is_isomorphic s2 s1 :=\nsorry\n\ntheorem isomorphic_preserves_uniqueness {s1 s2 : List Char} :\n  s1.length = s2.length →\n  is_isomorphic s1 s2 →\n  unique_chars s1 = unique_chars s2 :=\nsorry\n\ntheorem isomorphic_repeated_chars {s1 s2 : List Char} :\n  s1.length = s2.length →\n  s1.length ≥ 2 →\n  unique_chars s1 = 1 →\n  (is_isomorphic s1 s2 ↔ unique_chars s2 = 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"egg\" \"add\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_isomorphic \"foo\" \"bar\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"paper\" \"title\""}
{"id": "fvapps_002392", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort (as : List Nat) : List Nat :=\nsorry\n\ndef countMismatches (xs ys : List Nat) : Nat :=\nsorry\n\ndef height_checker (heights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem height_checker_singleton (x : Nat) :\n  height_checker [x] = 0 :=\nsorry\n\ntheorem height_checker_uniform (x n : Nat) :\n  n > 0 →\n  height_checker (List.replicate n x) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval height_checker [1, 1, 4, 2, 1, 3]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval height_checker [5, 1, 2, 3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval height_checker [1, 2, 3, 4, 5]"}
{"id": "fvapps_002393", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves (nums : List Int) : Int :=\nsorry\n\ndef list_minimum (nums : List Int) : Int :=\nsorry\n\ndef list_maximum (nums : List Int) : Int :=\nsorry\n\ndef list_sum (nums : List Int) : Int :=\nsorry", "vc-theorems": "theorem min_moves_non_negative (nums : List Int) (h : nums ≠ []) :\n  min_moves nums ≥ 0 :=\nsorry\n\ntheorem min_moves_equal_elements (n : Int) (len : Nat) (h : len ≥ 1) :\n  min_moves (List.replicate len n) = 0 :=\nsorry\n\ntheorem min_moves_upper_bound (nums : List Int) (h : nums ≠ []) :\n  let min_val := list_minimum nums\n  min_moves nums ≤ list_sum (nums.map (λ x => x - min_val)) :=\nsorry\n\ntheorem min_moves_monotonic (nums : List Int) (h : nums.length ≥ 2) :\n  let new_nums := nums ++ [list_maximum nums]\n  min_moves new_nums ≥ min_moves nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves [1, 1, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3, 4]"}
{"id": "fvapps_002396", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidEmail (s : String) : Bool :=\n  sorry\n\ndef numUniqueEmails (emails : List String) : Nat :=\n  sorry", "vc-theorems": "theorem numUniqueEmails_bounds (emails : List String) :\n  let result := numUniqueEmails emails\n  0 ≤ result ∧ result ≤ emails.length :=\nsorry\n\ntheorem numUniqueEmails_idempotent (emails : List String) :\n  emails ≠ [] →\n  numUniqueEmails (emails ++ emails) = numUniqueEmails emails :=\nsorry\n\ntheorem numUniqueEmails_dot_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let dotted := String.join [local_domain.get! 0, \"@\", local_domain.get! 1]\n  numUniqueEmails [email, dotted] = 1 :=\nsorry\n\ntheorem numUniqueEmails_plus_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let plusAdded := String.join [local_domain.get! 0, \"+anything@\", local_domain.get! 1]\n  numUniqueEmails [email, plusAdded] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_unique_emails [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.email@leetcode.com\"]"}
{"id": "fvapps_002398", "vc-description": "", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def find_distance_value (arr1 arr2 : List Int) (d : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_distance_value_non_negative\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 d ≥ 0 :=\nsorry\n\ntheorem find_distance_value_bounded\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 d ≤ arr1.length :=\nsorry\n\ntheorem find_distance_value_empty_arr2\n  (arr1 : List Int) (d : Nat)\n  (h : arr1 ≠ []) :\n  find_distance_value arr1 [] d = arr1.length :=\nsorry\n\ntheorem find_distance_value_zero_distance\n  (arr1 arr2 : List Int)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 0 =\n    (arr1.filter (fun x => x ∉ arr2)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [4, 5, 8] [10, 9, 1, 8] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [1, 4, 2, 3] [-4, -3, 6, 10, 20, 30] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_distance_value [2, 1, 100, 3] [-5, -2, 10, -3, 7] 6"}
{"id": "fvapps_002399", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_goat_latin (s : String) : String :=\nsorry\n\ndef splitString (s : String) : List String :=\nsorry\n\ndef getStringAt (words : List String) (i : Nat) : String :=\nsorry\n\ndef endsWith (s : String) (suffix : String) : Bool :=\nsorry\n\ndef dropRight (s : String) (n : Nat) : String :=\nsorry\n\ndef firstChar (s : String) : Char :=\nsorry\n\ndef dropFirst (s : String) : String :=\nsorry\n\ndef countChar (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem to_goat_latin_vowel_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let orig := splitString s\n  let result := splitString (to_goat_latin s)\n  let orig_word := getStringAt orig i\n  let transformed := dropRight (getStringAt result i) (2 + (i+1))\n  if (firstChar orig_word).toLower ∈ ['a', 'e', 'i', 'o', 'u'] then\n    transformed = orig_word\n  else\n    transformed = dropFirst orig_word ++ String.mk [firstChar orig_word] :=\nsorry\n\ntheorem to_goat_latin_trailing_a_count {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  countChar (getStringAt result i) 'a' ≥ i + 1 :=\nsorry\n\ntheorem to_goat_latin_preserves_word_count {s : String} :\n  (splitString s).length = (splitString (to_goat_latin s)).length :=\nsorry\n\ntheorem to_goat_latin_ma_suffix_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  let suffix := \"ma\" ++ String.mk (List.replicate (i+1) 'a')\n  endsWith (getStringAt result i) suffix :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval to_goat_latin \"I speak Goat Latin\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval to_goat_latin \"The quick brown fox\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval to_goat_latin \"Each word\""}
{"id": "fvapps_002403", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prefix_of_word (sentence search : String) : Int :=\n  sorry\n\ndef startsWith (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef words (s : String) : List String :=\n  sorry", "vc-theorems": "theorem empty_search_property {sentence : String} :\n  is_prefix_of_word sentence \"\" = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i love eating burger\" \"burg\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"this problem is an easy problem\" \"pro\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i am tired\" \"you\""}
{"id": "fvapps_002404", "vc-description": "-- 32-bit integer bounds", "vc-preamble": "def INT32_MAX : Int := 2^31 - 1\n\ndef INT32_MIN : Int := -(2^31)", "vc-helpers": "", "vc-definitions": "def reverse_integer (x : Int) : Int :=\nsorry", "vc-theorems": "theorem reverse_integer_sign (x : Int) :\n  let result := reverse_integer x\n  (result = 0) ∨ (result > 0 ∧ x > 0) ∨ (result < 0 ∧ x < 0) :=\nsorry\n\ntheorem reverse_integer_bounds (x : Int) :\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX :=\nsorry\n\ntheorem single_digit_numbers (x : Int) :\n  0 ≤ x ∧ x ≤ 9 →\n  reverse_integer x = x :=\nsorry\n\ntheorem trailing_zeros (x : Int) :\n  x > 0 →\n  x % 10 = 0 →\n  reverse_integer x < x :=\nsorry\n\ntheorem int32_bounds (x : Int) :\n  INT32_MIN ≤ x ∧ x ≤ INT32_MAX →\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX :=\nsorry\n\ntheorem overflow_cases :\n  reverse_integer 1534236469 = 0 ∧\n  reverse_integer (-2147483648) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 321\n-/\n#guard_msgs in\n#eval reverse_integer 123\n\n/-\ninfo: -321\n-/\n#guard_msgs in\n#eval reverse_integer -123\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval reverse_integer 120"}
{"id": "fvapps_002405", "vc-description": "", "vc-preamble": "def countLetters (s : String) : Nat :=\n  s.data.filter isAlpha |>.length\n\ndef countDigits (s : String) : Nat :=\n  s.data.filter isDigit |>.length", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef reformat (s : String) : String :=\nsorry", "vc-theorems": "theorem reformat_empty_string (s : String) :\n  let letters := s.data.filter isAlpha |>.length\n  let digits := s.data.filter isDigit |>.length\n  letters - digits > 1 ∨ digits - letters > 1 →\n  reformat s = \"\" :=\nsorry\n\ntheorem reformat_preserves_length (s : String) :\n  reformat s ≠ \"\" →\n  (reformat s).length = s.length :=\nsorry\n\ntheorem reformat_preserves_chars (s : String) :\n  reformat s ≠ \"\" →\n  (reformat s).data = s.data :=\nsorry\n\ntheorem reformat_alternates (s : String) :\n  reformat s ≠ \"\" →\n  ∀ i < (reformat s).length - 1,\n    (isAlpha ((reformat s).data[i]!) = !isAlpha ((reformat s).data[i+1]!)) :=\nsorry\n\ntheorem reformat_preserves_letter_count (s : String) :\n  reformat s ≠ \"\" →\n  countLetters (reformat s) = countLetters s :=\nsorry\n\ntheorem reformat_preserves_digit_count (s : String) :\n  reformat s ≠ \"\" →\n  countDigits (reformat s) = countDigits s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval reformat \"leetcode\""}
{"id": "fvapps_002406", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Every output is a string of nonzero length -/\n\n/- The output only contains ASCII digits -/\n\n/- Each count-and-say result follows from the previous number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countAndSay (n: Nat) : String :=\n  sorry", "vc-theorems": "theorem countAndSay_one : countAndSay 1 = \"1\" :=\nsorry\n\ntheorem countAndSay_nonempty (n: Nat) (h: n > 0) :\n  (countAndSay n).length > 0 :=\nsorry\n\ntheorem countAndSay_digits_only (n: Nat) (h: n > 0) :\n  ∀ p: String.Pos,\n    '0' ≤ (countAndSay n).get p ∧ (countAndSay n).get p ≤ '9' :=\nsorry\n\ntheorem countAndSay_inductive_step (n: Nat) (h: n > 1) :\n  ∃ counts digits: List Nat,\n    counts.length = digits.length ∧\n    (∀ d ∈ digits, d ≤ 9) ∧\n    (∀ c ∈ counts, c > 0) ∧\n    countAndSay n = String.join (List.map (λ (p: Nat × Nat) => toString p.1 ++ toString p.2)\n                                        (List.zip counts digits)) :=\nsorry", "vc-postamble": "/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval count_and_say 1\n\n/-\ninfo: '1211'\n-/\n#guard_msgs in\n#eval count_and_say 4\n\n/-\ninfo: '111221'\n-/\n#guard_msgs in\n#eval count_and_say 5"}
{"id": "fvapps_002407", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_freq (l: List Int) : Nat :=\n  sorry\n\ndef find_shortest_subarray (l : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem shortest_subarray_bounds {l : List Int} (h: l ≠ []) :\n  1 ≤ find_shortest_subarray l ∧ find_shortest_subarray l ≤ l.length :=\nsorry\n\ntheorem single_element_list {l : List Int} (h: l.length = 1) :\n  find_shortest_subarray l = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1, 4, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 1, 2, 2, 2, 1]"}
{"id": "fvapps_002408", "vc-description": "", "vc-preamble": "def is_strictly_increasing (nums : List Int) (i : Nat) : Bool :=\n  i > 0 && i < nums.length && nums[i]! > nums[i-1]!", "vc-helpers": "", "vc-definitions": "def find_length_of_lcis (nums : List Int) : Nat :=\nsorry\n\ndef count_max_increasing (nums : List Int) : Nat :=\nsorry", "vc-theorems": "theorem lcis_length_properties (nums : List Int) :\n  let result := find_length_of_lcis nums\n  result ≥ 0 ∧\n  result ≤ nums.length ∧\n  (nums.length = 0 → result = 0) ∧\n  (nums.length > 0 → result ≥ 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 4, 7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_length_of_lcis [2, 2, 2, 2, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 7]"}
{"id": "fvapps_002409", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingDistance (x y : Nat) : Nat :=\n  sorry\n\ndef bitLength (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem hamming_distance_symmetry (x y : Nat) :\n  hammingDistance x y = hammingDistance y x :=\nsorry\n\ntheorem hamming_distance_self (x : Nat) :\n  hammingDistance x x = 0 :=\nsorry\n\ntheorem hamming_distance_nonnegative (x y : Nat) :\n  hammingDistance x y ≥ 0 :=\nsorry\n\ntheorem hamming_distance_upper_bound (x y : Nat) :\n  hammingDistance x y ≤ max (bitLength x) (bitLength y) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_distance 1 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_distance 3 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_distance 0 7"}
{"id": "fvapps_002410", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def factorial (n : Nat) : Nat :=\n  sorry\n\ndef countTrailingZeroes (n : Nat) : Nat :=\n  sorry\n\ndef countActualZeros (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_matches_actual {n : Nat} (h : n ≤ 1000) :\n  countTrailingZeroes n = countActualZeros (factorial n) := by\n  sorry\n\ntheorem count_non_negative (n : Nat) :\n  countTrailingZeroes n ≥ 0 := by\n  sorry\n\ntheorem count_less_than_five {n : Nat} (h : n < 5) :\n  countTrailingZeroes n = 0 := by\n  sorry\n\ntheorem count_zero :\n  countTrailingZeroes 0 = 0 := by\n  sorry\n\ntheorem count_one :\n  countTrailingZeroes 1 = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 5\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 10"}
{"id": "fvapps_002417", "vc-description": "", "vc-preamble": "def isPalindrome (s : String) : Bool := s == reverse s", "vc-helpers": "", "vc-definitions": "def valid_palindrome (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem palindrome_basic (s : String) :\n  isPalindrome s → valid_palindrome s :=\nsorry\n\ntheorem single_char_palindrome (s : String) :\n  s.length ≤ 1 → valid_palindrome s :=\nsorry\n\ntheorem palindrome_remove_char (s : String) :\n  s.length > 1 → isPalindrome s →\n  valid_palindrome (s.take (s.length - 1)) :=\nsorry\n\ntheorem nearly_palindrome (s : String) (x : Char) :\n  s.length ≥ 3 →\n  let palindrome := s ++ reverse s\n  let middle := palindrome.length / 2\n  let nearly_pal := palindrome.take middle ++ String.mk [x] ++ palindrome.drop middle\n  valid_palindrome nearly_pal :=\nsorry\n\ntheorem non_palindrome (s : String) :\n  s.length ≥ 2 →\n  ¬(isPalindrome s) →\n  (let count := (List.zip s.data (reverse s).data).filter (fun p => p.1 ≠ p.2) |>.length\n   count > 2) →\n  ¬(valid_palindrome s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"aba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"abca\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_palindrome \"abc\""}
{"id": "fvapps_002421", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n| [] => 0\n| x::xs => x + list_sum xs\n\ndef list_get (l: List Nat) (i: Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => if i = 0 then x else list_get xs (i-1)", "vc-helpers": "", "vc-definitions": "def largest_triangle_perimeter (xs: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem perimeter_bounds {nums : List Nat} (h : nums.length ≥ 3) :\n  let result := largest_triangle_perimeter nums\n  (result = 0 ∨ (result > 0 ∧ result ≤ list_sum nums)) :=\nsorry\n\ntheorem triangle_inequality {nums : List Nat} (h : nums.length ≥ 3) :\n  let result := largest_triangle_perimeter nums\n  result > 0 →\n  ∃ i j k, i < nums.length ∧ j < nums.length ∧ k < nums.length ∧\n          i ≠ j ∧ j ≠ k ∧ i ≠ k ∧\n          list_get nums i < list_get nums j + list_get nums k ∧\n          result ≥ list_get nums i + list_get nums j + list_get nums k :=\nsorry\n\ntheorem order_independent {nums nums' : List Nat} (h : nums.length ≥ 3)\n  (h2 : nums.length = nums'.length)\n  (h3 : ∀ x, x ∈ nums ↔ x ∈ nums') :\n  largest_triangle_perimeter nums = largest_triangle_perimeter nums' :=\nsorry\n\ntheorem non_positive_result {nums : List Nat} (h : nums.length ≥ 3)\n  (h₂ : ∀ x ∈ nums, x = 0) :\n  largest_triangle_perimeter nums = 0 :=\nsorry\n\ntheorem minimal_cases_unit :\n  largest_triangle_perimeter [1,1,1] = 3 :=\nsorry\n\ntheorem minimal_cases_invalid :\n  largest_triangle_perimeter [1,1,2] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [2, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [1, 2, 1]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [3, 2, 3, 4]"}
{"id": "fvapps_002423", "vc-description": "", "vc-preamble": "def isSorted (nums: List Int) : Bool :=\n  match nums with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)", "vc-helpers": "", "vc-definitions": "def is_monotonic (nums: List Int) : Bool :=\nsorry", "vc-theorems": "theorem empty_or_single_element_lists_monotonic (nums: List Int) :\n  nums.length ≤ 1 → is_monotonic nums :=\nsorry\n\ntheorem identical_elements_monotonic (nums: List Int) (x: Int) (h: nums.length ≥ 2) :\n  (∀ i: Fin nums.length, nums.get i = x) → is_monotonic nums :=\nsorry\n\ntheorem sorted_lists_monotonic (nums: List Int) (h: nums.length ≥ 2) :\n  isSorted nums → is_monotonic nums :=\nsorry\n\ntheorem non_monotonic_lists_false (nums: List Int) (h: nums.length ≥ 3) :\n  (∀ i: Fin nums.length, ∀ j: Fin nums.length,\n    i.val + 1 = j.val → ¬(nums.get i ≤ nums.get j)) ∧\n  (∀ i: Fin nums.length, ∀ j: Fin nums.length,\n    i.val + 1 = j.val → ¬(nums.get i ≥ nums.get j)) →\n  ¬is_monotonic nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [1, 2, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [6, 5, 4, 4]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_monotonic [1, 3, 2]"}
{"id": "fvapps_002430", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countSpaces (s : String) : Nat :=\n  sorry\n\ndef split (s : String) : List String :=\n  sorry\n\ndef startsWith (s : String) (c : Char) : Bool :=\n  sorry\n\ndef reorderSpaces (s : String) : String :=\n  sorry", "vc-theorems": "theorem reorderSpaces_preserves_spaces (s : String) :\n  countSpaces s = countSpaces (reorderSpaces s) := by\n  sorry\n\ntheorem reorderSpaces_preserves_words (s : String) :\n  split s = split (reorderSpaces s) := by\n  sorry\n\ntheorem reorderSpaces_no_leading_spaces (s : String) :\n  ¬startsWith (reorderSpaces s) ' ' := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'this   is   a   sentence'\n-/\n#guard_msgs in\n#eval reorder_spaces \"  this   is  a sentence \"\n\n/-\ninfo: 'practice   makes   perfect '\n-/\n#guard_msgs in\n#eval reorder_spaces \" practice   makes   perfect\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval reorder_spaces \"a\""}
{"id": "fvapps_002442", "vc-description": "-- Earnings cannot be negative (this is implied by Nat return type)\n\n-- Earnings cannot exceed sum of requested prices\n\n-- Cannot sell more shoes than inventory\n\n-- Empty inventory yields zero earnings\n\n-- Order of inventory doesn't affect earnings", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_shoe_shop_earnings (num_shoes : Nat) (shoe_sizes : List Nat)\n    (customer_requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef count_successful_sales (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef sum_request_prices (requests : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem earnings_nonnegative\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests ≥ 0 :=\nsorry\n\ntheorem earnings_upper_bound\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests ≤\n    sum_request_prices customer_requests :=\nsorry\n\ntheorem sales_limited_by_inventory\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    count_successful_sales shoe_sizes customer_requests ≤ shoe_sizes.length :=\nsorry\n\ntheorem empty_inventory_zero_earnings (requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings 0 [] requests = 0 :=\nsorry\n\ntheorem inventory_order_invariant\n    (num_shoes : Nat) (shoe_sizes : List Nat) (requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes requests =\n    calculate_shoe_shop_earnings num_shoes shoe_sizes.reverse requests :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 200\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 10 [2, 3, 4, 5, 6, 8, 7, 6, 5, 18] [(6, 55), (6, 45), (6, 55), (4, 40), (18, 60), (10, 50)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 0 [] [(6, 55)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 1 [2] [(3, 50)]"}
{"id": "fvapps_002444", "vc-description": "/- For a list of valid email addresses, all should be returned unchanged -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of invalid email addresses, an empty list should be returned -/\n\n/- For a mixed list of valid and invalid emails, only valid ones should be returned -/\n\n/- Function should not crash on arbitrary string input -/", "vc-preamble": "def Email := String", "vc-helpers": "", "vc-definitions": "def validate_emails (emails : List Email) : List Email :=\nsorry\n\ndef isValidEmailFormat (e : Email) : Bool :=\nsorry", "vc-theorems": "theorem validate_valid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, isValidEmailFormat e) :\n  validate_emails emails = emails :=\nsorry\n\ntheorem validate_invalid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, ¬ isValidEmailFormat e) :\n  validate_emails emails = [] :=\nsorry\n\ntheorem validate_mixed_emails (emails : List Email)\n  (valid : List Email := emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :=\nsorry\n\ntheorem validate_arbitrary_input (inputs : List String) :\n  ∃ result, validate_emails inputs = result :=\nsorry", "vc-postamble": "/-\ninfo: ['DEXTER <dexter@hotmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"DEXTER <dexter@hotmail.com>\", \"VIRUS <virus!@variable.:p>\"]\n\n/-\ninfo: ['ALICE <alice123@gmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"ALICE <alice123@gmail.com>\"]\n\n/-\ninfo: ['CAROL <carol@xyz.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"INVALID <inv@k.>\", \"CAROL <carol@xyz.com>\"]"}
{"id": "fvapps_002446", "vc-description": "", "vc-preamble": "structure Date where\n  month : Nat\n  day : Nat\n  year : Nat", "vc-helpers": "", "vc-definitions": "def get_weekday_name (month : Nat) (day : Nat) (year : Nat) : String :=\nsorry\n\ndef IsValidDate (d : Date) : Prop :=\nsorry\n\ndef weekday (d : Date) : Nat :=\nsorry\n\ndef calendar_day_name (n : Nat) : String :=\nsorry\n\ndef IsUppercase (s : String) : Prop :=\nsorry\n\ndef IsValidWeekdayName (s : String) : Prop :=\nsorry", "vc-theorems": "theorem get_weekday_name_matches_calendar\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 ≤ m ∧ m ≤ 12)\n    (h2 : 1 ≤ d ∧ d ≤ 31)\n    (h3 : 1900 ≤ y ∧ y ≤ 2100)\n    (h4 : IsValidDate ⟨m, d, y⟩) :\n    get_weekday_name m d y = calendar_day_name (weekday ⟨m, d, y⟩) :=\nsorry\n\ntheorem get_weekday_name_returns_uppercase\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 ≤ m ∧ m ≤ 12)\n    (h2 : 1 ≤ d ∧ d ≤ 31)\n    (h3 : 1900 ≤ y ∧ y ≤ 2100) :\n    IsValidDate ⟨m, d, y⟩ →\n    (IsUppercase (get_weekday_name m d y) ∧\n     IsValidWeekdayName (get_weekday_name m d y)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'WEDNESDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 8 5 2015\n\n/-\ninfo: 'SUNDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 1 1 2023\n\n/-\ninfo: 'MONDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 12 25 2023"}
{"id": "fvapps_002447", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef check_palindromic_positives (nums : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem palindromic_positives_negative_number\n  {nums : List Int}\n  (h : ∃ x ∈ nums, x ≤ 0) :\n  check_palindromic_positives nums = false :=\nsorry\n\ntheorem palindromic_positives_all_positive\n  {nums : List Int}\n  (h : ∀ x ∈ nums, x > 0) :\n  check_palindromic_positives nums =\n    nums.any (fun x => isPalindrome x.toNat) :=\nsorry\n\ntheorem single_digits_palindromic\n  {nums : List Int}\n  (h1 : ∀ x ∈ nums, x > 0)\n  (h2 : ∀ x ∈ nums, x < 10) :\n  check_palindromic_positives nums = true :=\nsorry\n\ntheorem non_positive_false\n  {nums : List Int}\n  (h : ∀ x ∈ nums, x ≤ 0)\n  (h_nonempty : nums ≠ []) :\n  check_palindromic_positives nums = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 9, 61, 5, 14]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [-1, 9, 61, 5, 14]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 34, 56, 78]"}
{"id": "fvapps_002448", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_distinct_stamps (stamps : List String) : Nat :=\nsorry\n\ndef count_unique (l : List String) : Nat :=\nsorry", "vc-theorems": "theorem count_distinct_stamps_bounded (stamps : List String) :\n  count_distinct_stamps stamps ≤ stamps.length :=\nsorry\n\ntheorem count_distinct_stamps_deterministic (stamps : List String) :\n  count_distinct_stamps stamps = count_distinct_stamps stamps :=\nsorry\n\ntheorem count_distinct_stamps_nonnegative (stamps : List String) :\n  count_distinct_stamps stamps ≥ 0 :=\nsorry\n\ntheorem count_distinct_stamps_with_duplicates (stamps : List String) :\n  count_distinct_stamps (stamps ++ stamps) = count_distinct_stamps stamps :=\nsorry\n\ntheorem count_distinct_stamps_empty :\n  count_distinct_stamps [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"UK\", \"China\", \"USA\", \"France\", \"New Zealand\", \"UK\", \"France\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"India\", \"India\", \"India\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"Japan\", \"Korea\", \"China\"]"}
{"id": "fvapps_002449", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (s : List Char) : String :=\nsorry\n\ndef capitalize_name (s : String) : String :=\nsorry\n\ndef splitOn (s : String) (p : Char → Bool) : List String :=\nsorry\n\ndef front (s : String) : Char :=\nsorry\n\ndef drop (s : String) (n : Nat) : String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef toLower (s : String) : String :=\nsorry\n\ndef length (s : String) : Nat :=\nsorry", "vc-theorems": "theorem capitalize_name_preserves_word_count (s : String) :\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :=\nsorry\n\ntheorem words_start_with_uppercase (s : String) (word : String) :\n  word ∈ splitOn (capitalize_name s) (fun x => x = ' ') →\n  word.length > 0 →\n  isAlpha (word.front) →\n  isUpper (word.front) ∧ word.drop 1 = toLower (word.drop 1) :=\nsorry\n\ntheorem whitespace_only_preserves_length (s : String) :\n  (∀ c ∈ s.data, c = ' ') →\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :=\nsorry\n\ntheorem non_alpha_preserved (s : String) :\n  (∀ c ∈ s.data, !isAlpha c) →\n  s.length > 0 →\n  capitalize_name s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002454", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def split_lines (s : String) : List String :=\n  s.splitOn \"\\n\"", "vc-helpers": "", "vc-definitions": "def parse_html (s : String) : String :=\n  sorry\n\ndef is_lowercase_letter (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem single_tag_parse {tag : String}\n  (h : ∀ c, c ∈ tag.data → is_lowercase_letter c) :\n  parse_html s!\"<{tag}>\" = tag :=\nsorry\n\ntheorem tag_with_attrs_parse {tag : String} {attrs : List (String × String)}\n  (h1 : ∀ c, c ∈ tag.data → is_lowercase_letter c)\n  (h2 : ∀ (k v : String), (k, v) ∈ attrs → ∀ c, c ∈ k.data → is_lowercase_letter c) :\n  let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n  let html := s!\"<{tag} {attr_str}>\"\n  let result := split_lines (parse_html html)\n  result[0]! = tag ∧\n  (∀ i k v, attrs[i]! = (k,v) → result[i+1]! = s!\"-> {k} > {v}\") :=\nsorry\n\ntheorem multiple_tags_parse {tags : List String} {attrs_list : List (List (String × String))}\n  (h1 : tags.length > 0)\n  (h2 : attrs_list.length = tags.length)\n  (h3 : ∀ tag, tag ∈ tags → ∀ c, c ∈ tag.data → is_lowercase_letter c)\n  (h4 : ∀ attrs, attrs ∈ attrs_list → ∀ k v, (k,v) ∈ attrs → ∀ c, c ∈ k.data → is_lowercase_letter c) :\n  let html_parts := tags.zip attrs_list |>.map (fun (tag, attrs) =>\n    let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n    s!\"<{tag} {attr_str}>\"\n  )\n  let html := String.intercalate \"\\n\" html_parts\n  let result := split_lines (parse_html html)\n  ∀ i : Nat, i < tags.length →\n    result[i]! = tags[i]! ∧\n    ∀ j k v, attrs_list[i]![j]! = (k,v) →\n      result[i + j + 1]! = s!\"-> {k} > {v}\" :=\nsorry\n\ntheorem self_closing_tag_parse {tag : String}\n  (h : ∀ c, c ∈ tag.data → is_lowercase_letter c) :\n  parse_html s!\"<{tag}/>\" = tag :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002459", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_str_special (s : String) : String :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem sort_str_preserves_length (s : String) :\n  String.length (sort_str_special s) = String.length s := by\n  sorry\n\ntheorem sort_str_preserves_chars (s : String) :\n  String.toList (sort_str_special s) = String.toList s := by\n  sorry\n\ntheorem digits_ordered_by_parity_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hd1 : isDigit ((sort_str_special s).get i))\n    (hd2 : isDigit ((sort_str_special s).get j)) :\n    let d1 := (sort_str_special s).get i\n    let d2 := (sort_str_special s).get j\n    (d1.toNat % 2 = 0 → d2.toNat % 2 ≠ 1) ∧\n    (d1.toNat % 2 = d2.toNat % 2 → d1.toNat ≤ d2.toNat) := by\n  sorry\n\ntheorem letters_ordered_by_case_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hl1 : (isLower ((sort_str_special s).get i) ∨ isUpper ((sort_str_special s).get i)))\n    (hl2 : (isLower ((sort_str_special s).get j) ∨ isUpper ((sort_str_special s).get j))) :\n    let c1 := (sort_str_special s).get i\n    let c2 := (sort_str_special s).get j\n    (isUpper c1 → ¬isLower c2) ∧\n    ((isUpper c1 = isUpper c2) → c1 ≤ c2) := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_002460", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Array.shape (a : Array (Array α)) : Nat × Nat :=\n  sorry\n\ndef concatenate_arrays {α : Type} (n m p : Nat) (array1 array2 : Array (Array α)) :\n  Array (Array α) :=\n  sorry", "vc-theorems": "theorem concatenate_arrays_shape (n m p : Nat) (array1 array2 : Array (Array α)) :\n  (concatenate_arrays n m p array1 array2).shape = (n + m, p) :=\nsorry\n\ntheorem concatenate_arrays_preserves_first (n m p : Nat) (array1 array2 : Array (Array α)) :\n  ∀ i < n, (concatenate_arrays n m p array1 array2)[i]! = array1[i]! :=\nsorry\n\ntheorem concatenate_arrays_preserves_second (n m p : Nat) (array1 array2 : Array (Array α)) :\n  ∀ i < m, (concatenate_arrays n m p array1 array2)[n + i]! = array2[i]! :=\nsorry\n\ntheorem concatenate_arrays_singleton (n p : Nat) (value : α)\n  (array1 : Array (Array α)) (array2 : Array (Array α)) :\n  array2.size = 1 →\n  (∀ i < n, (array1[i]!).size = p) →\n  (array2[0]!).size = p →\n  (concatenate_arrays n 1 p array1 array2).shape = (n + 1, p) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002469", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n-- Properties for each element", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_transforms (input : String) : Array Float × Array Float × Array Float :=\nsorry\n\ndef transform_list (numbers : List Float) : Array Float × Array Float × Array Float :=\nsorry\n\ndef int_to_float (n : Int) : Float :=\nsorry", "vc-theorems": "theorem array_transforms_properties {numbers : List Float} (h : numbers.length > 0) :\n  let (floor_arr, ceil_arr, rint_arr) := transform_list numbers\n  let h_sizes : floor_arr.size = numbers.length ∧ ceil_arr.size = numbers.length ∧ rint_arr.size = numbers.length := by sorry\n\n  ∀ i : Fin numbers.length,\n    let idx : Nat := i.val\n    let h_floor : idx < floor_arr.size := by sorry\n    let h_ceil : idx < ceil_arr.size := by sorry\n    let h_rint : idx < rint_arr.size := by sorry\n\n    floor_arr[idx]'h_floor ≤ numbers[idx] ∧\n    ceil_arr[idx]'h_ceil ≥ numbers[idx] ∧\n    floor_arr[idx]'h_floor ≤ rint_arr[idx]'h_rint ∧\n    rint_arr[idx]'h_rint ≤ ceil_arr[idx]'h_ceil ∧\n    ceil_arr[idx]'h_ceil - floor_arr[idx]'h_floor ≤ 1 ∧\n    (rint_arr[idx]'h_rint - numbers[idx]).abs ≤ 0.5 :=\nsorry\n\ntheorem array_transforms_integers (n : Int) :\n  let res := array_transforms (toString n)\n  let floor_arr := res.1\n  let ceil_arr := res.2.1\n  let rint_arr := res.2.2\n  let h_size : 0 < floor_arr.size := by sorry\n\n  floor_arr = ceil_arr ∧\n  floor_arr = rint_arr ∧\n  floor_arr[0]'h_size = int_to_float n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002472", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Simplified complex number representation", "vc-preamble": "def ℂ := Float × Float\n\ndef mkComplex (r i : Float) : ℂ := (r, i)", "vc-helpers": "", "vc-definitions": "def magnitude : ℂ → Float :=\nsorry\n\ndef phase : ℂ → Float :=\nsorry", "vc-theorems": "theorem get_polar_coords_zero :\n  let z := mkComplex 0 0\n  magnitude z = 0 ∧ phase z = 0 := by\nsorry\n\ntheorem get_polar_coords_real_positive :\n  let z := mkComplex 1 0\n  magnitude z = 1 ∧ phase z = 0 := by\nsorry\n\ntheorem get_polar_coords_real_negative :\n  let z := mkComplex (-1) 0\n  magnitude z = 1 ∧ phase z = 3.141592653589793 := by\nsorry\n\ntheorem get_polar_coords_complex :\n  let z := mkComplex 1 2\n  Float.abs (magnitude z - 2.23606797749979) < 1e-10 ∧\n  Float.abs (phase z - 1.1071487177940904) < 1e-10 := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_002475", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numerical_triangle (n: Nat) : String :=\nsorry\n\ndef String.splitLines (s : String) : List String :=\nsorry\n\ndef String.allDigits (s : String) : Bool :=\nsorry\n\ndef String.toNat (s : String) : Option Nat :=\nsorry", "vc-theorems": "theorem numerical_triangle_increasing_length (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    ∀ i, 1 ≤ i → i < lines.length →\n    (lines.get! i).length > (lines.get! (i-1)).length :=\nsorry\n\ntheorem numerical_triangle_line_count (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    lines.length = n - 1 :=\nsorry\n\ntheorem numerical_triangle_valid_integers (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    ∀ line, line ∈ lines →\n    line.allDigits ∧\n    (∃ num, line.toNat = some num ∧ num > 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1\\n22\\n333\\n4444'\n-/\n#guard_msgs in\n#eval numerical_triangle 5\n\n/-\ninfo: '1\\n22'\n-/\n#guard_msgs in\n#eval numerical_triangle 3\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval numerical_triangle 2"}
{"id": "fvapps_002479", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def Matrix := Array (Array Float)", "vc-helpers": "", "vc-definitions": "def getRow (A : Matrix) (i : Nat) : Array Float :=\nsorry\n\ndef getCol (A : Matrix) (j : Nat) : Array Float :=\nsorry\n\ndef mean (A : Matrix) : Array Float :=\nsorry\n\ndef var (A : Matrix) : Array Float :=\nsorry\n\ndef std (A : Matrix) : Float :=\nsorry\n\ndef compute_stats (A : Matrix) : Array Float × Array Float × Float :=\nsorry", "vc-theorems": "theorem compute_stats_mean_property (A : Matrix) :\n  let (means, _, _) := compute_stats A\n  means = mean A :=\nsorry\n\ntheorem compute_stats_var_property (A : Matrix) :\n  let (_, vars, _) := compute_stats A\n  vars = var A :=\nsorry\n\ntheorem compute_stats_std_property (A : Matrix) :\n  let (_, _, stdev) := compute_stats A\n  stdev = std A :=\nsorry\n\ntheorem compute_stats_output_shape (A : Matrix) (h1 : A.size > 0) :\n  let (means, vars, _) := compute_stats A\n  means.size = A.size ∧ vars.size = (getRow A 0).size :=\nsorry\n\ntheorem compute_stats_empty (A : Matrix) (h : A.size = 0) :\n  compute_stats A = default :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002481", "vc-description": "", "vc-preamble": "def all_lt (x : Int) (l : List Int) : Prop :=\n  ∀ y, y ∈ l → y < x", "vc-helpers": "", "vc-definitions": "def find_runner_up_score (scores: List Int) : Int :=\n  sorry", "vc-theorems": "theorem duplicate_max_case :\n  find_runner_up_score [1, 2, 2] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 3, 6, 6, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 2, 3, 4, 4]\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval find_runner_up_score [-100, 0, 50, 100, 100]"}
{"id": "fvapps_002482", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def evaluatePolynomial (coeffs : List Float) (x : Float) : Float :=\n  sorry\n\ndef directPolynomial (coeffs : List Float) (x : Float) : Float :=\n  sorry", "vc-theorems": "theorem polynomial_evaluation_matches_direct\n  (coeffs : List Float) (x : Float)\n  (h1 : coeffs.length ≥ 1)\n  (h2 : coeffs.length ≤ 10)\n  (h3 : ∀ c ∈ coeffs, -1000000 ≤ c ∧ c ≤ 1000000)\n  (h4 : -100 ≤ x ∧ x ≤ 100) :\n  evaluatePolynomial coeffs x - directPolynomial coeffs x ≤ 1e-10 * directPolynomial coeffs x :=\nsorry\n\ntheorem polynomial_at_zero\n  (coeffs : List Float)\n  (h1 : coeffs ≠ [])\n  (h2 : coeffs.length ≤ 10)\n  (h3 : ∀ c ∈ coeffs, -1000000 ≤ c ∧ c ≤ 1000000) :\n  evaluatePolynomial coeffs 0 = coeffs.getLast h1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002483", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_top_three_chars (s : String) : String :=\n  sorry\n\ndef String.count (s : String) (c : String) : Nat :=\n  sorry", "vc-theorems": "theorem get_top_three_chars_valid_format (s : String)\n  (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, c.isLower) :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  1 ≤ lines.length ∧ lines.length ≤ 3 ∧\n  (∀ line ∈ lines, ∃ (char : String) (count : Nat),\n    line = s!\"{char} {count}\" ∧\n    char.length = 1 ∧\n    s.count char = count) ∧\n  (∀ i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    (parts1.get! 1).toNat! ≥ (parts2.get! 1).toNat!) ∧\n  (let chars := lines.map (λ l => (l.splitOn \" \").get! 0);\n   chars.eraseDups = chars) :=\nsorry\n\ntheorem get_top_three_chars_alphabetical_tiebreak (s : String)\n  (h : s.length ≥ 2)\n  (h2 : ∀ c ∈ s.data, c = 'a' ∨ c = 'b') :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  ∀ i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    let count1 := (parts1.get! 1).toNat!;\n    let count2 := (parts2.get! 1).toNat!;\n    let char1 := parts1.get! 0;\n    let char2 := parts2.get! 0;\n    count1 = count2 → char1 > char2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002488", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def student_union (n1 : Nat) (eng : String) (n2 : Nat) (fre : String) : Nat :=\nsorry\n\ndef stringToList (s : String) : List Int :=\nsorry\n\ndef removeDuplicates (l : List Int) : List Int :=\nsorry", "vc-theorems": "theorem student_union_leq_sum_lengths {n1 n2 : Nat} {eng fre : String} :\n  student_union n1 eng n2 fre ≤ n1 + n2 :=\nsorry\n\ntheorem student_union_equals_union_length {n1 n2 : Nat} {eng fre : String} :\n  ∃ l1 l2 : List Int,\n    l1 = stringToList eng ∧\n    l2 = stringToList fre ∧\n    student_union n1 eng n2 fre = (removeDuplicates (l1 ++ l2)).length :=\nsorry\n\ntheorem student_union_identical_lists {n : Nat} {nums : String} :\n  student_union n nums n nums = (removeDuplicates (stringToList nums)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval student_union 9 \"1 2 3 4 5 6 7 8 9\" 9 \"10 1 2 3 11 21 55 6 8\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"4 5 6\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"1 2 3\""}
{"id": "fvapps_002495", "vc-description": "", "vc-preamble": "def Operation := String × Int", "vc-helpers": "", "vc-definitions": "def DequeOp := List Operation\n\ndef splitString (s : String) : List String :=\n  sorry\n\ndef process_deque_operations (ops : List String) : String :=\n  sorry", "vc-theorems": "theorem append_only_operations_preserves_length\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\" ∨ (splitString op).get! 0 = \"appendleft\") :\n  (splitString (process_deque_operations ops)).length = ops.length :=\nsorry\n\ntheorem append_only_operations_preserves_elements\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\" ∨ (splitString op).get! 0 = \"appendleft\") :\n  ∃ perm : List String → List String,\n    perm (ops.map (λ op => (splitString op).get! 1)) =\n    splitString (process_deque_operations ops) :=\nsorry\n\ntheorem append_maintains_order\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\") :\n  (splitString (process_deque_operations ops)) =\n  ops.map (λ op => (splitString op).get! 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 2'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"append 2\", \"append 3\", \"appendleft 4\", \"pop\", \"popleft\"]\n\n/-\ninfo: '10 15'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 5\", \"appendleft 10\", \"pop\", \"append 15\"]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"appendleft 2\", \"popleft\", \"pop\"]"}
{"id": "fvapps_002503", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_palindrome_triangle (n: Nat) : String :=\n  sorry\n\ndef split_lines (s: String) : List String :=\n  sorry", "vc-theorems": "theorem palindrome_triangle_line_count {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.length = n :=\nsorry\n\ntheorem palindrome_triangle_lines_are_palindromes {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ line ∈ lines, line.data = (line.data.reverse) :=\nsorry\n\ntheorem palindrome_triangle_lines_increase {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ i, 0 < i → i < lines.length → (lines.get! i).length > (lines.get! (i-1)).length :=\nsorry\n\ntheorem palindrome_triangle_first_line {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.head! = \"1\" :=\nsorry\n\ntheorem palindrome_triangle_only_digits {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ line ∈ lines, ∀ c ∈ line.data, '0' ≤ c ∧ c ≤ '9' :=\nsorry\n\ntheorem palindrome_triangle_middle_increment {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ i, 0 < i → i < lines.length →\n    let line := lines.get! i\n    let mid := line.length / 2\n    ∀ j, j < mid → line.data[j]! = Char.ofNat ((j + 1) + '0'.toNat) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1\\n121\\n12321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 3\n\n/-\ninfo: '1\\n121\\n12321\\n1234321\\n123454321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 5\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 1"}
{"id": "fvapps_002504", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.product : List (List α) → List (List α)\n  | [] => [[]]\n  | (h :: t) => sorry\n\ndef sum [Add α] (l : List α) : α :=\n  sorry\n\ndef find_max_modular_sum (m : Nat) (lists : List (List Int)) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_modular_sum_bounds (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ []) :\n  let result := find_max_modular_sum m lists\n  0 ≤ result ∧ result < m := by\n  sorry\n\ntheorem find_max_modular_sum_matches_some_combo (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ []) :\n  let result := find_max_modular_sum m lists\n  ∃ combo ∈ List.product lists,\n    sum (combo.map (λ x => x * x)) % m = result := by\n  sorry\n\ntheorem find_max_modular_sum_mod_one (lists : List (List Int))\n    (h1 : lists ≠ [])\n    (h2 : ∀ l ∈ lists, l ≠ []) :\n  find_max_modular_sum 1 lists = 0 := by\n  sorry\n\ntheorem find_max_modular_sum_zeros (m : Nat) (lists : List (List Int))\n    (h1 : m > 1)\n    (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ [])\n    (h4 : ∀ l ∈ lists, ∀ x ∈ l, x = 0) :\n  find_max_modular_sum m lists = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 206\n-/\n#guard_msgs in\n#eval find_max_modular_sum 1000 [[5, 4], [7, 8, 9], [5, 7, 8, 9, 10]]\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval find_max_modular_sum 100 [[1, 2], [3, 4]]"}
{"id": "fvapps_002515", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlnum (c : Char) : Bool :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef check_string_properties (s : String) : List Bool :=\nsorry", "vc-theorems": "theorem check_string_properties_bool (s : String) :\n  ∀ x ∈ check_string_properties s, x = true ∨ x = false :=\nsorry\n\ntheorem alpha_implies_alnum (s : String) :\n  (check_string_properties s).get! 1 = true → (check_string_properties s).get! 0 = true :=\nsorry\n\ntheorem digit_implies_alnum (s : String) :\n  (check_string_properties s).get! 2 = true → (check_string_properties s).get! 0 = true :=\nsorry\n\ntheorem case_implies_alpha (s : String) :\n  ((check_string_properties s).get! 3 = true ∨ (check_string_properties s).get! 4 = true) →\n  (check_string_properties s).get! 1 = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002516", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_combinations_with_replacement (s : String) (k : Nat) : String :=\nsorry\n\ndef is_sorted (s : String) : Bool :=\nsorry\n\ndef all_chars_from (s : String) (chars : String) : Bool :=\nsorry\n\ndef all_length (s : String) (k : Nat) : Bool :=\nsorry\n\ndef no_duplicates (s : String) : Bool :=\nsorry", "vc-theorems": "theorem get_combinations_sorted (s : String) (k : Nat) :\n  is_sorted (get_combinations_with_replacement s k) = true :=\nsorry\n\ntheorem get_combinations_length (s : String) (k : Nat) :\n  all_length (get_combinations_with_replacement s k) k = true :=\nsorry\n\ntheorem get_combinations_chars (s : String) (k : Nat) :\n  all_chars_from (get_combinations_with_replacement s k) s = true :=\nsorry\n\ntheorem get_combinations_unique (s : String) (k : Nat) :\n  no_duplicates (get_combinations_with_replacement s k) = true :=\nsorry\n\ntheorem get_combinations_example1 :\n  get_combinations_with_replacement \"HACK\" 2 = \"AA\\nAC\\nAH\\nAK\\nCC\\nCH\\nCK\\nHH\\nHK\\nKK\" :=\nsorry\n\ntheorem get_combinations_example2 :\n  get_combinations_with_replacement \"XYZ\" 2 = \"XX\\nXY\\nXZ\\nYY\\nYZ\\nZZ\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002532", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def addsup (a1 a2 a3 : List Int) : List (Int × Int × Int) :=\n  sorry\n\ndef compare_arrays (arr1 arr2 : List (List Int)) : Bool :=\n  sorry", "vc-theorems": "theorem addsup_empty_input\n  (a1 a2 a3 : List Int)\n  : (a1 = [] ∨ a2 = []) → addsup a1 a2 a3 = [] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002533", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\nsorry\n\ndef stringReverse (s : String) : String :=\nsorry\n\ndef getMismatches (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_distance_property (s : String)\n    (h : s.length > 0)\n    (h2 : ∀ c ∈ s.data, c = 'a' ∨ c = 'b' ∨ c = 'c') :\n  let mismatches := getMismatches s\n  solve s = (mismatches = 1 ∨ (mismatches = 0 ∧ s.length % 2 = 1)) :=\nsorry\n\ntheorem solve_symmetry_property (s : String) (h : s.length > 0) :\n  solve s = solve (stringReverse s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbx\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"aa\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"ab\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abcba\""}
{"id": "fvapps_002541", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def two_sort (strings : List String) : String :=\nsorry\n\ndef countSubstring (haystack : String) (needle : String) : Nat :=\nsorry\n\ndef minimum (xs : List String) : String :=\nsorry\n\ndef splitString (s : String) (sep : String) : List String :=\nsorry", "vc-theorems": "theorem two_sort_separator_count (strings : List String)\n  (h : strings.length > 0) :\n  (countSubstring (two_sort strings) \"***\") = (minimum strings).length - 1 :=\nsorry\n\ntheorem two_sort_recovers_min (strings : List String)\n  (h : strings.length > 0) :\n  let result := two_sort strings\n  let parts := splitString result \"***\"\n  (String.join parts) = minimum strings :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'b***i***t***c***o***i***n'\n-/\n#guard_msgs in\n#eval two_sort [\"bitcoin\", \"take\", \"over\", \"the\", \"world\", \"maybe\", \"who\", \"knows\", \"perhaps\"]\n\n/-\ninfo: 'a***r***e'\n-/\n#guard_msgs in\n#eval two_sort [\"turns\", \"out\", \"random\", \"test\", \"cases\", \"are\", \"easier\", \"than\", \"writing\", \"out\", \"basic\", \"ones\"]\n\n/-\ninfo: 'L***e***t***s'\n-/\n#guard_msgs in\n#eval two_sort [\"Lets\", \"all\", \"go\", \"on\", \"holiday\", \"somewhere\", \"very\", \"cold\"]"}
{"id": "fvapps_002549", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def est_subsets {α : Type} [BEq α] [Hashable α] (arr : List α) : Nat :=\n  sorry\n\ndef list_unique_count {α : Type} [BEq α] [Hashable α] (arr : List α) : Nat :=\n  sorry", "vc-theorems": "theorem est_subsets_count_prop {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :=\nsorry\n\ntheorem est_subsets_nonneg {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr ≥ 0 :=\nsorry\n\ntheorem est_subsets_empty {α : Type} [BEq α] [Hashable α] :\n  est_subsets ([] : List α) = 0 :=\nsorry\n\ntheorem est_subsets_duplicates {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = est_subsets (arr ++ arr) :=\nsorry\n\ntheorem est_subsets_is_nat {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 3, 4]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [\"a\", \"b\", \"c\", \"d\", \"d\"]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 2, 3, 3, 3, 4]"}
{"id": "fvapps_002553", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isAlpha : Char → Bool :=\n  sorry\n\ndef changer : String → String :=\n  sorry", "vc-theorems": "theorem changer_length (s : String) :\n  s.length = (changer s).length :=\nsorry\n\ntheorem changer_nonalpha_unchanged {s : String} {i : String.Pos} {c : Char} :\n  c = s.get i → ¬(String.isAlpha c) → (changer s).get i = c :=\nsorry\n\ntheorem changer_empty :\n  changer \"\" = \"\" :=\nsorry\n\ntheorem changer_boundary_case :\n  changer \"abcxyz\" = \"bcdyzA\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'dbU30'\n-/\n#guard_msgs in\n#eval changer \"Cat30\"\n\n/-\ninfo: 'Ifmmp xpsmE'\n-/\n#guard_msgs in\n#eval changer \"Hello World\"\n\n/-\ninfo: 'A'\n-/\n#guard_msgs in\n#eval changer \"z\""}
{"id": "fvapps_002554", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def format_words (words : List String) : String :=\nsorry\n\ndef String.countSubstr (s1 s2 : String) : Nat :=\nsorry\n\ndef substringExists (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem format_words_empty_filtered :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).isEmpty →\n  format_words words = \"\" :=\nsorry\n\ntheorem format_words_contains_filtered :\n  ∀ (words : List String) (word : String),\n  word ≠ \"\" →\n  word ∈ words →\n  substringExists (format_words words) word = true :=\nsorry\n\ntheorem format_words_single_and :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).length > 1 →\n  substringExists (format_words words) \" and \" = true ∧\n  String.countSubstr (format_words words) \" and \" = 1 :=\nsorry\n\ntheorem format_words_no_and :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).length ≤ 1 →\n  substringExists (format_words words) \"and\" = false :=\nsorry\n\ntheorem format_words_maintains_order :\n  ∀ (words : List String),\n  ¬(words.filter (fun w => w ≠ \"\")).isEmpty →\n  let filtered := words.filter (fun w => w ≠ \"\")\n  substringExists (format_words words) filtered.head! ∧\n  substringExists (format_words words) filtered.getLast! ∧\n  format_words words = filtered.head! ∨\n  format_words words = filtered.head! ++ \", \" ++ filtered.getLast! ∨\n  format_words words = filtered.head! ++ \" and \" ++ filtered.getLast! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ninja, samurai and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"samurai\", \"ronin\"]\n\n/-\ninfo: 'ninja'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\"]\n\n/-\ninfo: 'ninja and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"\", \"ronin\"]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval format_words []"}
{"id": "fvapps_002556", "vc-description": "", "vc-preamble": "def valid_roles : List String :=\n  [\"Boss\", \"Truck Driver\", \"Warehouse Manager\", \"Sales Assistant\",\n   \"Admin\", \"Sales Manager\", \"Warehouse Picker\", \"Receptionist\", \"Trainee\"]", "vc-helpers": "", "vc-definitions": "def find_employees_role (name : String) : String :=\n  sorry", "vc-theorems": "theorem known_employee_roles_are_valid (name : String) (h : name.length > 0) :\n  let role := find_employees_role name\n  role = \"Does not work here!\" ∨ role ∈ valid_roles :=\nsorry\n\ntheorem returns_string (name : String) (h : name.length > 0) :\n  String.length (find_employees_role name) > 0 :=\nsorry\n\ntheorem unknown_single_name_returns_not_found (name : String) (h1 : name.length > 0)\n    (h2 : ¬(name.contains ' ')) :\n  find_employees_role name = \"Does not work here!\" :=\nsorry\n\ntheorem name_order_matters (first last : String)\n    (h1 : first.length > 0) (h2 : last.length > 0) :\n  let role1 := find_employees_role (first ++ \" \" ++ last)\n  let role2 := find_employees_role (last ++ \" \" ++ first)\n  (role1 ≠ \"Does not work here!\" ∧ role2 ≠ \"Does not work here!\") →\n  role1 ≠ role2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Truck Driver'\n-/\n#guard_msgs in\n#eval find_employees_role \"Morty Smith\"\n\n/-\ninfo: 'Admin'\n-/\n#guard_msgs in\n#eval find_employees_role \"Anna Bell\"\n\n/-\ninfo: 'Does not work here!'\n-/\n#guard_msgs in\n#eval find_employees_role \"Bell Jewel\""}
{"id": "fvapps_002559", "vc-description": "-- Property 1: Each step should be a valid permutation of original list\n\n-- Property 2: Each step should have one or more swaps from previous\n\n-- Property 3: Final state should be sorted\n\n-- Property 4: Number of steps should not exceed inversions\n\n-- Already sorted lists produce empty steps\n\n-- Empty list produces empty steps", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bubble (lst : List Int) : List (List Int) :=\nsorry\n\ndef isSorted (lst : List Int) : Bool :=\nsorry\n\ndef countInversions (lst : List Int) : Nat :=\nsorry", "vc-theorems": "theorem bubble_steps_are_permutations {lst : List Int} {step : List Int} :\n  step ∈ bubble lst → step.length = lst.length :=\nsorry\n\ntheorem bubble_steps_have_swaps {lst : List Int} {i : Nat} (h1 : i < (bubble lst).length) (h2 : i + 1 < (bubble lst).length) :\n  ∃ pos : Nat, pos < lst.length ∧\n    ((bubble lst).get ⟨i, h1⟩).get! pos ≠ ((bubble lst).get ⟨i+1, h2⟩).get! pos :=\nsorry\n\ntheorem bubble_final_step_sorted {lst : List Int} (h : bubble lst ≠ []) :\n  isSorted ((bubble lst).getLast h) :=\nsorry\n\ntheorem bubble_steps_bounded_by_inversions {lst : List Int} :\n  (bubble lst).length ≤ countInversions lst :=\nsorry\n\ntheorem bubble_sorted_empty {lst : List Int} :\n  isSorted lst → bubble lst = [] :=\nsorry\n\ntheorem bubble_empty :\n  bubble [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval bubble []\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval bubble [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n/-\ninfo: [[1, 3, 3, 4, 7, 2], [1, 3, 3, 4, 2, 7], [1, 3, 3, 2, 4, 7], [1, 3, 2, 3, 4, 7], [1, 2, 3, 3, 4, 7]]\n-/\n#guard_msgs in\n#eval bubble [1, 3, 3, 7, 4, 2]"}
{"id": "fvapps_002571", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def almostIncreasingSequence (seq : List Int) : Bool :=\nsorry\n\ndef countDescendingPairs (seq : List Int) : Nat :=\nsorry\n\ndef isStrictlyIncreasing (seq : List Int) : Bool :=\nsorry\n\ndef countDuplicates (seq : List Int) : Nat :=\nsorry", "vc-theorems": "theorem strictly_increasing_always_true {seq : List Int} :\n  isStrictlyIncreasing seq → almostIncreasingSequence seq :=\nsorry\n\ntheorem duplicate_elements_property {seq : List Int} :\n  countDuplicates seq > 1 → ¬almostIncreasingSequence seq :=\nsorry\n\ntheorem too_many_drops_always_false {seq : List Int} :\n  countDescendingPairs seq > 1 → ¬almostIncreasingSequence seq :=\nsorry\n\ntheorem single_removal_property {seq : List Int} (i : Nat) (h : i < seq.length) :\n  isStrictlyIncreasing (seq.take i ++ seq.drop (i+1)) →\n  almostIncreasingSequence seq :=\nsorry\n\ntheorem single_element_always_true {seq : List Int} :\n  seq.length = 1 → almostIncreasingSequence seq :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2, 1]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 2, 3]"}
{"id": "fvapps_002579", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n: Nat) : List Nat :=\nsorry\n\ndef visible_sum (n i: Nat) : Nat :=\nsorry\n\ndef min_visible_sum (n: Nat) : Nat :=\nsorry\n\ndef loneliest (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem loneliest_returns_bool (n: Nat) :\n  loneliest n = true ∨ loneliest n = false :=\nsorry\n\ntheorem loneliest_zero_one :\n  ∀ n: Nat, (∀ d: Nat, d ∈ (digits n) → d = 0 ∨ d = 1) →\n  loneliest n = true ↔ ∃ i, (digits n).get? i = some 1 ∧\n  (∀ j, j ≠ i → (digits n).get? j = some 0) :=\nsorry\n\ntheorem loneliest_same_digit :\n  ∀ n: Nat, (∀ i j: Nat, i < (digits n).length → j < (digits n).length →\n    (digits n).get ⟨i, sorry⟩ = (digits n).get ⟨j, sorry⟩) →\n  loneliest n = true ↔ (digits n).get ⟨0, sorry⟩ = 1 :=\nsorry\n\ntheorem loneliest_no_ones :\n  ∀ n: Nat, (∀ i: Nat, i < (digits n).length → (digits n).get ⟨i, sorry⟩ ≠ 1) →\n  loneliest n = false :=\nsorry\n\ntheorem loneliest_min_loneliness :\n  ∀ n: Nat, loneliest n = true ↔\n  (∃ i: Nat, (digits n).get? i = some 1 ∧\n   visible_sum n i = min_visible_sum n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 34315\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval loneliest 8854778\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 11111"}
{"id": "fvapps_002584", "vc-description": "", "vc-preamble": "def listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => t.foldl min h\n\npartial def minFactor (n : Nat) : Nat :=\n  if n ≤ 1 then 1 else\n  let rec find (k : Nat) : Nat :=\n    if k * k > n then n\n    else if n % k = 0 then k\n    else find (k + 1)\n  find 2", "vc-helpers": "", "vc-definitions": "def scf (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem scf_basic_properties (nums : List Nat) :\n  let result := scf nums\n  (nums ≠ [] → 1 ≤ result ∧ result ≤ listMin nums) ∧\n  (nums = [] → result = 1) ∧\n  (∀ n ∈ nums, n % result = 0) ∧\n  (result > 1 → ¬ ∃ k, 2 ≤ k ∧ k < result ∧ ∀ n ∈ nums, n % k = 0) :=\nsorry\n\ntheorem scf_identical_numbers (n : Nat) (h : n ≥ 2) :\n  let nums := List.replicate 5 n\n  scf nums = minFactor n :=\nsorry\n\ntheorem scf_nonpositive_inputs (nums : List Nat) (h : ∀ n ∈ nums, n = 0) :\n  scf nums = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval scf [200, 30, 18, 8, 64, 34]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval scf [21, 45, 51, 27, 33]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval scf []"}
{"id": "fvapps_002586", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "structure WeightedSum where\n  index : Nat\n  value : Int\n  deriving Repr\n\ndef makeWeightedSum (xs : List Int) : Int := match xs with\n  | [] => 0\n  | x::xs => x + makeWeightedSum xs", "vc-helpers": "", "vc-definitions": "def add (xs : List Int) : Int :=\nsorry", "vc-theorems": "theorem add_weighted_sum (xs : List Int) (h : xs ≠ []) :\n  ∃ n, add xs = n :=\nsorry\n\ntheorem add_single_number (x : Int) :\n  add [x] = x :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002587", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_sequence (s : String) : Nat :=\n  sorry\n\ndef isSubstring (sub str : String) : Bool :=\n  sorry\n\ndef substring (s : String) (start len : Nat) : String :=\n  sorry", "vc-theorems": "theorem short_strings (s : String) :\n  s.length < 5 → find_largest_sequence s = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 98765\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567898765\"\n\n/-\ninfo: 67890\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567890\"\n\n/-\ninfo: 12345\n-/\n#guard_msgs in\n#eval find_largest_sequence \"12345\""}
{"id": "fvapps_002590", "vc-description": "", "vc-preamble": "def numWordsList := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef sum (l : List Nat) : Nat := l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def numToWord (n : Nat) : String :=\nsorry\n\ndef wordToNum (s : String) : Option Nat :=\nsorry\n\ndef average_string (s : String) : String :=\nsorry", "vc-theorems": "theorem average_string_valid_nums (words : List String)\n  (h : ∀ w ∈ words, w ∈ numWordsList) (h2 : words ≠ []) :\n  let nums := words.filterMap wordToNum\n  let avg := sum nums / nums.length\n  average_string (String.intercalate \" \" words) = numToWord avg :=\nsorry\n\ntheorem average_string_empty :\n  average_string \"\" = \"n/a\" :=\nsorry\n\ntheorem average_string_invalid (s : String)\n  (h : ∃ w ∈ s.split (· = ' '), w ∉ numWordsList) :\n  average_string s = \"n/a\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'four'\n-/\n#guard_msgs in\n#eval average_string \"zero nine five two\"\n\n/-\ninfo: 'three'\n-/\n#guard_msgs in\n#eval average_string \"four six two three\"\n\n/-\ninfo: 'n/a'\n-/\n#guard_msgs in\n#eval average_string \"\""}
{"id": "fvapps_002592", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gimme (arr : List Float) : Nat :=\n  sorry\n\ndef sort (xs : List Float) : List Float :=\n  sorry\n\ndef sortInt (xs : List Int) : List Int :=\n  sorry\n\ndef gimmeInt (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem gimme_in_range {arr : List Float} (h : arr.length = 3) :\n  let res := gimme arr\n  0 ≤ res ∧ res ≤ 2 :=\nsorry\n\ntheorem gimme_gives_middle {arr : List Float} (h : arr.length = 3) :\n  let sorted := sort arr\n  let res := gimme arr\n  arr[res]! = sorted[1]! :=\nsorry\n\ntheorem gimme_integers_in_range {arr : List Int} (h : arr.length = 3) :\n  let res := gimmeInt arr\n  0 ≤ res ∧ res ≤ 2 :=\nsorry\n\ntheorem gimme_integers_middle {arr : List Int} (h : arr.length = 3) :\n  let sorted := sortInt arr\n  let res := gimmeInt arr\n  arr[res]! = sorted[1]! :=\nsorry\n\ntheorem gimme_preserves_input {arr : List Float} (h : arr.length = 3) :\n  let original := arr\n  let _ := gimme arr\n  arr = original :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [2, 3, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval gimme [5, 10, 14]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [-0.41, -23, 4]"}
{"id": "fvapps_002598", "vc-description": "/- For any integer minutes, the output matches expected day/time format -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Output repeats on weekly cycle -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def day_and_time (mins : Int) : String :=\nsorry", "vc-theorems": "theorem day_and_time_valid_format (mins : Int) :\n  let result := day_and_time mins\n  let parts := result.splitOn \" \"\n  let day := parts[0]!\n  let time := parts[1]!\n  let hours_mins := time.splitOn \":\"\n  let hours := hours_mins[0]!.toInt!\n  let minutes := hours_mins[1]!.toInt!\n  parts.length = 2 ∧\n  (day = \"Monday\" ∨ day = \"Tuesday\" ∨ day = \"Wednesday\" ∨\n   day = \"Thursday\" ∨ day = \"Friday\" ∨ day = \"Saturday\" ∨ day = \"Sunday\") ∧\n  0 ≤ hours ∧ hours ≤ 23 ∧\n  0 ≤ minutes ∧ minutes ≤ 59 :=\nsorry\n\ntheorem day_and_time_weekly_cycle (mins : Int) :\n  day_and_time mins = day_and_time (mins + 7*24*60) :=\nsorry", "vc-postamble": "/-\ninfo: 'Sunday 00:00'\n-/\n#guard_msgs in\n#eval day_and_time 0\n\n/-\ninfo: 'Saturday 23:57'\n-/\n#guard_msgs in\n#eval day_and_time -3\n\n/-\ninfo: 'Monday 00:07'\n-/\n#guard_msgs in\n#eval day_and_time 1447"}
{"id": "fvapps_002601", "vc-description": "-- minimum distance computation", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def peaceful_yard (yard : List String) (distance : Float) : Bool :=\n  sorry\n\ndef mkRow (n : Nat) : String :=\n  sorry\n\ndef updateRow (s : String) (pos : Nat) (c : Char) : String :=\n  sorry\n\ndef distance (p1 p2 : Nat × Nat) : Float :=\n  sorry\n\ndef replaceNth {α : Type} (xs : List α) (n : Nat) (v : α) : List α :=\n  sorry", "vc-theorems": "theorem empty_yard_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size ≥ 1) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  peaceful_yard yard distance = true :=\nsorry\n\ntheorem single_cat_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size ≥ 1) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  let midPos := size / 2\n  let catRow := updateRow (List.get! yard midPos) midPos 'L'\n  let yard' := replaceNth yard midPos catRow\n  peaceful_yard yard' distance = true :=\nsorry\n\ntheorem cats_distance_property\n  {size : Nat} {distance : Float} {catPositions : List (Nat × Nat × Char)}\n  (h1 : size ≥ 2) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30)\n  (h5 : catPositions.length ≤ 3)\n  (h6 : ∀ p ∈ catPositions, p.fst < size ∧ (p.snd.fst) < size ∧ (p.snd.snd) ∈ ['L', 'M', 'R']) :\n  let validPositions := catPositions.filter (λ p => p.fst < size ∧ (p.snd.fst) < size)\n  let emptyRow := mkRow size\n  let emptyYard := List.replicate size emptyRow\n  let yard := validPositions.foldl\n    (λ y p => replaceNth y p.fst (updateRow (List.get! y p.fst) (p.snd.fst) (p.snd.snd)))\n    emptyYard\n  peaceful_yard yard distance =\n    if validPositions.length ≤ 1\n    then true\n    else let positions := validPositions.map (λ p => (p.fst, p.snd.fst))\n         let minDist : Float := sorry\n         minDist ≥ distance :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"------------\", \"-L----------\", \"------------\", \"------------\", \"------------\"] 10\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"---M--------\", \"------------\", \"------------\", \"-------R----\", \"------------\"] 6\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"-----------L\", \"--R---------\", \"------------\", \"------------\", \"------------\", \"--M---------\"] 4"}
{"id": "fvapps_002615", "vc-description": "-- Result contains all original names\n\n-- Has & separator\n\n-- Has correct number of commas\n\n-- Last name appears after &", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def namelist (names : List (String × String)) : String :=\n  sorry\n\ndef containsSubstr (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef String.count (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem namelist_empty_list :\n  namelist [] = \"\" :=\nsorry\n\ntheorem namelist_single_name (name : String) :\n  namelist [(name, \"name\")] = name :=\nsorry\n\ntheorem namelist_multiple_names {n : ℕ} (names : List (String × String))\n  (h1 : names.length > 1)\n  (h2 : ∀ p ∈ names, p.2 = \"name\") :\n  let result := namelist names;\n  let all_names := names.map Prod.fst;\n\n  (∀ name ∈ all_names, containsSubstr result name)\n\n  ∧ containsSubstr result \" & \"\n\n  ∧ (String.count result ',' = names.length - 2)\n\n  ∧ (result.splitOn \" & \").get! 1 = names.getLast?.get!.1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bart, Lisa & Maggie'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}, {\"name\": \"Maggie\"}]\n\n/-\ninfo: 'Bart & Lisa'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval namelist []"}
{"id": "fvapps_002618", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.containsString (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef word_search (query : String) (seq : List String) : List String :=\n  sorry", "vc-theorems": "theorem word_search_returns_nonempty (query : String) (seq : List String) :\n  word_search query seq ≠ [] :=\nsorry\n\ntheorem word_search_none_means_no_matches (query : String) (seq : List String) :\n  word_search query seq = [\"None\"] →\n  ∀ x ∈ seq, ¬(String.containsString (String.toLower x) (String.toLower query)) :=\nsorry\n\ntheorem word_search_results_contain_query (query : String) (seq : List String) :\n  ∀ x ∈ word_search query seq,\n  word_search query seq ≠ [\"None\"] →\n  String.containsString (String.toLower x) (String.toLower query) :=\nsorry\n\ntheorem word_search_results_subset (query : String) (seq : List String) :\n  ∀ x ∈ word_search query seq,\n  word_search query seq ≠ [\"None\"] →\n  x ∈ seq :=\nsorry\n\ntheorem word_search_finds_all_matches (query : String) (seq : List String) :\n  word_search query seq ≠ [\"None\"] →\n  List.length (word_search query seq) =\n  List.length (List.filter (fun x => String.containsString (String.toLower x) (String.toLower query)) seq) :=\nsorry\n\ntheorem word_search_empty_seq (query : String) :\n  word_search query [] = [\"None\"] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"ab\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/-\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"aB\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/-\ninfo: ['None']\n-/\n#guard_msgs in\n#eval word_search \"abcd\" [\"za\", \"aB\", \"Abc\", \"zAB\", \"zbc\"]"}
{"id": "fvapps_002624", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_password (s : String) : String :=\n  sorry\n\ndef is_special_char (c : Char) : Bool :=\n  sorry\n\ndef has_lowercase (s : String) : Bool :=\n  sorry\n\ndef has_uppercase (s : String) : Bool :=\n  sorry\n\ndef has_digit (s : String) : Bool :=\n  sorry\n\ndef has_special (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem password_too_short {s : String} (h : s.length < 8) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_too_long {s : String} (h : s.length > 20) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_invalid_chars {s : String} (h : ∃ c ∈ s.data,\n  ¬(c.isLower ∨ c.isUpper ∨ c.isDigit ∨ is_special_char c)) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_missing_required_chars {s : String}\n  (h1 : s.length ≥ 8)\n  (h2 : s.length ≤ 20)\n  (h3 : ∀ c ∈ s.data, (c.isLower ∨ c.isUpper ∨ c.isDigit ∨ is_special_char c))\n  (h4 : ¬(has_lowercase s ∧ has_uppercase s ∧ has_digit s ∧ has_special s)) :\n  check_password s = \"not valid\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"\"\n\n/-\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"Password123\"\n\n/-\ninfo: 'valid'\n-/\n#guard_msgs in\n#eval check_password \"P@ssw0rd123\""}
{"id": "fvapps_002628", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def length_of_line (coords : List (List Int)) : String :=\nsorry\n\ndef string_to_float (s : String) : Float :=\nsorry\n\ndef int_to_float (i : Int) : Float :=\nsorry", "vc-theorems": "theorem length_matches_pythagorean\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let result := string_to_float (length_of_line coords)\n  let expected := Float.sqrt (int_to_float ((x2 - x1) ^ 2 + (y2 - y1) ^ 2))\n  Float.abs (result - expected) < 0.01 :=\nsorry\n\ntheorem length_commutative\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2) :\n  length_of_line coords = length_of_line [coords[1]!, coords[0]!] :=\nsorry\n\ntheorem same_point_zero\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2) :\n  length_of_line [coords[0]!, coords[0]!] = \"0.00\" :=\nsorry\n\ntheorem triangle_inequality\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let mx := (x1 + x2) / 2\n  let my := (y1 + y2) / 2\n  let midpoint := [mx, my]\n  let result := string_to_float (length_of_line coords)\n  let via_mid := string_to_float (length_of_line [coords[0]!, midpoint]) +\n                 string_to_float (length_of_line [midpoint, coords[1]!])\n  result ≤ via_mid + 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1.41'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [1, 1]]\n\n/-\ninfo: '0.00'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [0, 0]]\n\n/-\ninfo: '13.04'\n-/\n#guard_msgs in\n#eval length_of_line [[-3, 4], [10, 5]]"}
{"id": "fvapps_002630", "vc-description": "/- The solutions to x² - 4y² = n are well-formed lists of pairs of natural numbers -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Each solution pair satisfies the equation x² - 4y² = n -/\n\n/- Solutions contain only positive x values and nonnegative y values -/\n\n/- Solutions are ordered by descending x values -/\n\n/- For n = 90002, there are no solutions -/\n\n/- For n = 5, there is exactly one solution: [[3,1]] -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sol_equa (n : Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem sol_equa_well_formed (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    (∀ pair ∈ result, pair.length = 2) :=\nsorry\n\ntheorem sol_equa_satisfies_equation (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ pair ∈ result,\n      pair.get! 0 * pair.get! 0 - 4 * pair.get! 1 * pair.get! 1 = n :=\nsorry\n\ntheorem sol_equa_positive_values (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ pair ∈ result,\n      pair.get! 0 > 0 ∧ pair.get! 1 ≥ 0 :=\nsorry\n\ntheorem sol_equa_ordered (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ i < result.length - 1,\n      (result.get! i).get! 0 > (result.get! (i+1)).get! 0 :=\nsorry\n\ntheorem sol_equa_90002_empty :\n  sol_equa 90002 = [] :=\nsorry\n\ntheorem sol_equa_5_single :\n  sol_equa 5 = [[3,1]] :=\nsorry", "vc-postamble": "/-\ninfo: [[3, 1]]\n-/\n#guard_msgs in\n#eval sol_equa 5\n\n/-\ninfo: [[45003, 22501], [9003, 4499], [981, 467], [309, 37]]\n-/\n#guard_msgs in\n#eval sol_equa 90005\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval sol_equa 90002"}
{"id": "fvapps_002641", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_char (s : String) (c : Char) : Nat :=\nsorry\n\ndef take_prefix (s : String) (n : Nat) : String :=\nsorry\n\ndef is_balanced (s : String) (caps : String) : Bool :=\nsorry", "vc-theorems": "theorem single_char_caps_balance\n  (s : String)\n  (h : s.length > 0) :\n  is_balanced s \"xx\" = ((count_char s 'x') % 2 = 0) :=\nsorry\n\ntheorem empty_caps_always_balanced\n  (s : String) :\n  is_balanced s \"\" = true :=\nsorry\n\ntheorem standard_parens_properties\n  (s : String)\n  (h : is_balanced s \"()\") :\n  (count_char s '(' = count_char s ')') ∧\n  ∀ (p : Nat), p ≤ s.length →\n    count_char (take_prefix s p) '(' ≥ count_char (take_prefix s p) ')' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says yes!)\" \"()\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says no!\" \"()\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"-Hello Mother can you hear me?-\" \"--\""}
{"id": "fvapps_002645", "vc-description": "/- Minimum number of cards (2) requires only one faro cycle -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Faro cycles for even number of cards is always positive -/\n\n/- Standard deck of 52 cards requires exactly 8 faro cycles -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def faro_cycles (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem faro_cycles_min : faro_cycles 2 = 1 :=\nsorry\n\ntheorem faro_cycles_positive_small (n : Nat) :\n  n = 4 ∨ n = 8 → faro_cycles n > 0 :=\nsorry\n\ntheorem faro_cycles_standard_deck : faro_cycles 52 = 8 :=\nsorry", "vc-postamble": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval faro_cycles 2\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval faro_cycles 52\n\n/-\ninfo: 540\n-/\n#guard_msgs in\n#eval faro_cycles 542"}
{"id": "fvapps_002648", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def collatzLength (n : Nat) : Nat :=\n  sorry\n\ndef longestCollatz (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem longest_collatz_is_member {nums : List Nat} (h : nums ≠ []) :\n  ∀ n, n = longestCollatz nums → n ∈ nums :=\nsorry\n\ntheorem longest_collatz_is_longest {nums : List Nat} (h : nums.length ≥ 2) :\n  ∀ n ∈ nums, n ≠ longestCollatz nums →\n    collatzLength (longestCollatz nums) ≥ collatzLength n :=\nsorry\n\ntheorem identical_numbers_gives_first (n : Nat) (l : List Nat)\n  (h : ∀ x ∈ l, x = n) :\n  longestCollatz l = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [1, 5, 27, 4]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [64, 64, 27, 64]\n\n/-\ninfo: 75\n-/\n#guard_msgs in\n#eval longest_collatz [75, 226, 113, 340]"}
{"id": "fvapps_002651", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.replicate (n : Nat) (s : String) : String :=\n  sorry\n\ndef spam (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem spam_multiplication (n : Nat) : n ≤ 1000 → spam n = String.replicate n \"hue\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'hue'\n-/\n#guard_msgs in\n#eval spam 1\n\n/-\ninfo: 'huehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 6\n\n/-\ninfo: 'huehuehuehuehuehuehuehuehuehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 14"}
{"id": "fvapps_002657", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unusual_lex_order (words: List String) : List String :=\n  sorry\n\ndef reverse (s: String) : String :=\n  sorry", "vc-theorems": "theorem output_length_matches_input (words: List String) (h: words.length > 0) :\n  (unusual_lex_order words).length = words.length :=\nsorry\n\ntheorem output_contains_same_elements (words: List String) (h: words.length > 0) :\n  ∀ x, (x ∈ unusual_lex_order words ↔ x ∈ words) :=\nsorry\n\ntheorem reverse_sorted_by_reversed_strings (words: List String) (h: words.length > 0) :\n  ∀ (i: Nat) (h': i + 1 < (unusual_lex_order words).length),\n    let result := unusual_lex_order words\n    Option.isSome (result[i]?) ∧ Option.isSome (result[i+1]?) →\n    reverse (Option.get! result[i]?) ≤ reverse (Option.get! result[i+1]?) :=\nsorry\n\ntheorem idempotent (words: List String) (h: words.length > 0) :\n  unusual_lex_order (unusual_lex_order words) = unusual_lex_order words :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002661", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.hasSubstring (s1 s2 : String) : Bool :=\n  sorry\n\ndef areYouPlayingBanjo (name : String) : String :=\n  sorry", "vc-theorems": "theorem banjo_output_format (name : String) (h : name.length > 0) :\n  let result := areYouPlayingBanjo name\n  result.startsWith name ∧\n  result.endsWith \"banjo\" ∧\n  (result.hasSubstring \" plays banjo\" ∨ result.hasSubstring \" does not play banjo\") :=\nsorry\n\ntheorem starts_with_r_plays_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front = 'r' ∨ name.front = 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" plays banjo\" = true :=\nsorry\n\ntheorem not_r_does_not_play_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front ≠ 'r' ∧ name.front ≠ 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" does not play banjo\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Adam\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Ringo\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"rolf\""}
{"id": "fvapps_002665", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def per (n : Nat) : List Nat :=\nsorry\n\ndef productOfDigits (n : Nat) : Nat :=\nsorry\n\ndef digitsOfNat (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem per_empty_for_single_digit (n : Nat) :\n  n < 10 → per n = [] :=\nsorry\n\ntheorem per_decreasing {n : Nat} {result : List Nat} :\n  result = per n →\n  ∀ i, ∀ h : i < result.length - 1,\n  result.get ⟨i, sorry⟩ ≥ result.get ⟨i+1, sorry⟩ :=\nsorry\n\ntheorem per_bounded_length (n : Nat) :\n  (per n).length ≤ 100 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval per 1\n\n/-\ninfo: [54, 20, 0]\n-/\n#guard_msgs in\n#eval per 69\n\n/-\ninfo: [4996238671872, 438939648, 4478976, 338688, 27648, 2688, 768, 336, 54, 20, 0]\n-/\n#guard_msgs in\n#eval per 277777788888899"}
{"id": "fvapps_002666", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef hasDPCProperties (n : Nat) (s : String) : Bool :=\n  sorry\n\ndef dpcSequence (s : String) : Int :=\n  sorry", "vc-theorems": "theorem dpc_satisfies_properties (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result = -1 ∨ (∃ n : Nat, result = n ∧ hasDPCProperties n s) :=\nsorry\n\ntheorem dpc_is_minimal (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result ≠ -1 → ∀ n : Nat, n < result.toNat → ¬hasDPCProperties n s :=\nsorry\n\ntheorem dpc_result_bounds (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result = -1 ∨ (1 ≤ result ∧ result ≤ 1000000000) :=\nsorry\n\ntheorem all_divisible_has_solution (s : String)\n  (h1 : s.length > 0 ∧ s.length ≤ 10)\n  (h2 : ∀ c ∈ s.data, c = 'D') :\n  dpcSequence s ≠ -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDPDD\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval dpc_sequence \"DPCPDPPPDCPDPDPC\"\n\n/-\ninfo: 15782844\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDDDPDDCCCDDPDCCPCDCDDPCPCCDDCD\""}
{"id": "fvapps_002667", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def custom_christmas_tree (chars: String) (n: Nat) : String :=\nsorry\n\ndef splitLines (s: String) : List String :=\nsorry\n\ndef stringLength (s: String) : Nat :=\nsorry\n\ndef stringTrim (s: String) : String :=\nsorry", "vc-theorems": "theorem tree_structure_width (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  ∀ line ∈ splitLines tree, stringLength line ≤ 2 * n :=\nsorry\n\ntheorem trunk_structure (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let trunk_lines := (splitLines tree).drop n\n  (∀ line ∈ trunk_lines, stringTrim line = \"|\") ∧\n  trunk_lines.length = (n-1) / 3 + 1 :=\nsorry\n\ntheorem total_height (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  (splitLines tree).length = n + ((n-1) / 3 + 1) :=\nsorry\n\ntheorem tree_part_nonempty (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let tree_part := (splitLines tree).take n\n  ∀ line ∈ tree_part, stringTrim line ≠ \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002672", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitize (n : Nat) : List Nat :=\n  sorry\n\ndef digitsToNat (digits : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem digitize_single_digits {n : Nat} :\n  ∀ d ∈ digitize n, d ≤ 9 := by\n  sorry\n\ntheorem digitize_length_matches_input {n : Nat} :\n  (List.length (digitize n)) = String.length (toString n) := by\n  sorry\n\ntheorem digitize_reconstruction {n : Nat} :\n  n = digitsToNat (List.reverse (digitize n)) := by\n  sorry\n\ntheorem digitize_preserves_digits {n : Nat} :\n  List.map (fun d => toString d) (digitize n) =\n  (toString n).toList.map toString := by\n  sorry\n\ntheorem digitize_zero :\n  digitize 0 = [0] := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1, 3, 2, 5, 3]\n-/\n#guard_msgs in\n#eval digitize 35231\n\n/-\ninfo: [7, 5, 3, 2, 8, 5, 3, 2]\n-/\n#guard_msgs in\n#eval digitize 23582357\n\n/-\ninfo: [8, 3, 7, 4, 6, 7, 4, 8, 9]\n-/\n#guard_msgs in\n#eval digitize 984764738"}
{"id": "fvapps_002675", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef String.lines (s : String) : List String :=\nsorry\n\ndef toString (n : Int) : Char :=\nsorry", "vc-theorems": "theorem non_positive_returns_empty\n  (n : Int)\n  (h : n ≤ 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem output_format_empty\n  (n : Int)\n  (h : n = 1) :\n  pattern n = \"\" :=\nsorry\n\ntheorem output_format_content\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100)\n  (i : Nat)\n  (h3 : i > 0)\n  (h4 : i ≤ n/2) :\n  (pattern n).lines.get! (i-1) = String.mk (List.replicate (2*i) (toString (2*i))) :=\nsorry\n\ntheorem odd_even_equivalence\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100)\n  (h3 : n % 2 = 1) :\n  pattern n = pattern (n-1) :=\nsorry\n\ntheorem line_count\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100) :\n  (pattern n).lines.length = n/2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0\n\n/-\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 5"}
{"id": "fvapps_002676", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def switcher (arr : List Nat) : String :=\nsorry\n\ndef is_valid_input (arr : List Nat) : Bool :=\nsorry\n\ndef is_valid_output (s : String) : Bool :=\nsorry\n\ndef expected_map (n : Nat) : String :=\nsorry", "vc-theorems": "theorem switcher_properties (arr : List Nat) :\n  is_valid_input arr →\n  let result := switcher arr\n  (is_valid_output result) ∧\n  (result.length = (arr.filter (· ≠ 0)).length) ∧\n  (result = String.join (arr.map expected_map)) :=\nsorry\n\ntheorem switcher_all_zeros (arr : List Nat) :\n  arr.all (· = 0) →\n  switcher arr = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'codewars'\n-/\n#guard_msgs in\n#eval switcher [\"24\", \"12\", \"23\", \"22\", \"4\", \"26\", \"9\", \"8\"]\n\n/-\ninfo: 'btswmdsbd kkw'\n-/\n#guard_msgs in\n#eval switcher [\"25\", \"7\", \"8\", \"4\", \"14\", \"23\", \"8\", \"25\", \"23\", \"29\", \"16\", \"16\", \"4\"]\n\n/-\ninfo: 'o?bfbtpel'\n-/\n#guard_msgs in\n#eval switcher [\"12\", \"28\", \"25\", \"21\", \"25\", \"7\", \"11\", \"22\", \"15\"]"}
{"id": "fvapps_002691", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfSquares (l : List Int) : Int :=\n  sorry\n\ndef sumOfCubes (l : List Int) : Int :=\n  sorry\n\ndef array_madness (a b : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem array_madness_correct (a b : List Int) (h1 : a.length > 0) (h2 : b.length > 0) :\n  array_madness a b = (sumOfSquares a > sumOfCubes b) :=\nsorry\n\ntheorem small_numbers_property\n    (a b : List Int)\n    (h1 : a.length > 0)\n    (h2 : b.length > 0)\n    (ha : ∀ x ∈ a, 0 ≤ x ∧ x ≤ 10)\n    (hb : ∀ x ∈ b, 1 ≤ x ∧ x ≤ 10)\n    (h : sumOfSquares a ≤ sumOfCubes b) :\n  array_madness a b = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [4, 5, 6] [1, 2, 3]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval array_madness [1, 2] [2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [5, 6, 7] [1, 1, 1]"}
{"id": "fvapps_002699", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def what_is_the_time (time : String) : String :=\n  sorry\n\ndef is_valid_time (time : String) : Bool :=\n  sorry", "vc-theorems": "theorem mirror_time_format (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  (result.length = 5) ∧\n  (result.data.get ⟨2, by sorry⟩ = ':') ∧\n  (is_valid_time result = true) :=\nsorry\n\ntheorem mirror_time_symmetry (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  what_is_the_time (what_is_the_time time) = time :=\nsorry\n\ntheorem mirror_time_bounds (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  let hour := result.take 2\n  let minute := result.drop 3\n  (1 ≤ String.toNat! hour ∧ String.toNat! hour ≤ 12) ∧\n  (0 ≤ String.toNat! minute ∧ String.toNat! minute ≤ 59) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '05:25'\n-/\n#guard_msgs in\n#eval what_is_the_time \"06:35\"\n\n/-\ninfo: '12:01'\n-/\n#guard_msgs in\n#eval what_is_the_time \"11:59\"\n\n/-\ninfo: '11:58'\n-/\n#guard_msgs in\n#eval what_is_the_time \"12:02\""}
{"id": "fvapps_002702", "vc-description": "/- The withdraw function returns a valid solution for multiples of 10 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The withdraw function returns optimal solutions with limited 20s -/\n\n/- The withdraw function uses fifties efficiently -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def withdraw (n : Int) : (Int × Int × Int) :=\nsorry", "vc-theorems": "theorem withdraw_valid (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  hundreds ≥ 0 ∧ fifties ≥ 0 ∧ twenties ≥ 0 ∧\n  hundreds * 100 + fifties * 50 + twenties * 20 = amount :=\nsorry\n\ntheorem withdraw_optimal (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  twenties ≤ 4 :=\nsorry\n\ntheorem withdraw_fifty_efficient (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  fifties > 0 →\n  let remainder := amount - (hundreds * 100 + fifties * 50)\n  remainder ≥ 0 ∧ remainder % 20 = 0 :=\nsorry", "vc-postamble": "/-\ninfo: [0, 0, 2]\n-/\n#guard_msgs in\n#eval withdraw 40\n\n/-\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval withdraw 250\n\n/-\ninfo: [2, 0, 3]\n-/\n#guard_msgs in\n#eval withdraw 260"}
{"id": "fvapps_002706", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def chessboard (n: Nat) (m: Nat) : String :=\nsorry\n\ndef String.lines (s: String) : List String :=\nsorry\n\ndef String.characterAt (s: String) (i: Nat) : Char :=\nsorry", "vc-theorems": "theorem chessboard_empty_for_zero_dims {n m: Nat} :\n  (n = 0 ∨ m = 0) → chessboard n m = \"\" :=\nsorry\n\ntheorem chessboard_dimensions {n m: Nat} (h1 : n ≠ 0) (h2 : m ≠ 0) :\n  let lines := (chessboard n m).lines\n  lines.length = n ∧\n  ∀ l ∈ lines, l.length = m :=\nsorry\n\ntheorem chessboard_alternating_pattern {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let lines := (chessboard n m).lines\n  ∀ i j, i < n → j < m →\n    let line := lines[i]'(by sorry)\n    let char := line.characterAt j\n    ((i + j) % 2 = 0 → char = '*') ∧\n    ((i + j) % 2 ≠ 0 → char = '.') :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval chessboard 0 0\n\n/-\ninfo: '*.\\n.*'\n-/\n#guard_msgs in\n#eval chessboard 2 2\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval chessboard 8 8"}
{"id": "fvapps_002707", "vc-description": "/- The function check_DNA is symmetric: gives same result regardless of argument order -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Empty sequence matches any sequence -/\n\n/- Known complementary sequences match -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_DNA (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem check_DNA_symmetric (s1 s2 : String) :\n  check_DNA s1 s2 = check_DNA s2 s1 :=\nsorry\n\ntheorem check_DNA_empty (s : String) :\n  check_DNA s \"\" = true ∧ check_DNA \"\" s = true :=\nsorry\n\ntheorem check_DNA_basic_complement :\n  check_DNA \"ATGCTACG\" \"CGTAGCAT\" = true :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAT\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"GCTAGCACCCATTAGGAGATAC\" \"CTCCTAATGGGTG\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAA\""}
{"id": "fvapps_002708", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Int) : Int :=\n  sorry\n\ndef sum (lst : List Int) : Int :=\n  sorry\n\ndef modified_sum (lst : List Int) (p : Nat) : Int :=\n  sorry", "vc-theorems": "theorem modified_sum_p_one {lst : List Int} (h : lst ≠ []) :\n  modified_sum lst 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2, 3] 3\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2] 5\n\n/-\ninfo: 68\n-/\n#guard_msgs in\n#eval modified_sum [3, 5, 7] 2"}
{"id": "fvapps_002711", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Int) : Int :=\n  sorry\n\ndef peak (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem peak_equal_sums (arr : List Int) (h_size : arr.length > 0) :\n  let p := peak arr;\n  p ≠ -1 →\n  sum (arr.take (Int.toNat p)) = sum (arr.drop (Int.toNat (p + 1))) :=\nsorry\n\ntheorem peak_bounds (arr : List Int) :\n  let p := peak arr;\n  -1 ≤ p ∧ p < arr.length :=\nsorry\n\ntheorem peak_single_element (arr : List Int) (h : arr.length = 1) :\n  peak arr = 0 :=\nsorry\n\ntheorem peak_empty :\n  peak [] = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval peak [1, 2, 3, 5, 3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval peak [1, 12, 3, 3, 6, 3, 1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval peak [10, 20, 30, 40]"}
{"id": "fvapps_002714", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findLongest (s : String) : Nat :=\n  sorry\n\ndef isValidParens (s : String) : Bool :=\n  sorry\n\ndef substringFromTo (s : String) (i j : Nat) : String :=\n  sorry", "vc-theorems": "theorem findLongest_valid (s : String) :\n  let result := findLongest s\n  result ≤ s.length ∧\n  result % 2 = 0 :=\nsorry\n\ntheorem findLongest_optimal (s : String) :\n  let result := findLongest s\n  ∀ i j, i < s.length → j ≤ s.length → j > i →\n    let substr := substringFromTo s i j\n    isValidParens substr → substr.length ≤ result :=\nsorry\n\ntheorem findLongest_exists (s : String) :\n  let result := findLongest s\n  result > 0 →\n  ∃ i j, i < s.length ∧ j ≤ s.length ∧ j > i ∧\n    let substr := substringFromTo s i j\n    substr.length = result ∧\n    isValidParens substr :=\nsorry\n\ntheorem findLongest_matched_pairs (n : Nat) :\n  let s := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  findLongest s = 2 * n :=\nsorry\n\ntheorem findLongest_unmatched_surround (n : Nat) :\n  n > 0 →\n  let balanced := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  let s := \")\" ++ balanced ++ \"(\"\n  findLongest s = 2 * n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \")()\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \"((()\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest \"())(()))\""}
{"id": "fvapps_002720", "vc-description": "/- The result length is at least as long as the longest input -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The result length is at most the sum of input lengths -/\n\n/- The function is symmetric -/\n\n/- Strings of all dots combine to max length -/\n\n/- Strings of all stars combine to sum of lengths -/\n\n-- represents strings of only * and .", "vc-preamble": "def CombString := String", "vc-helpers": "", "vc-definitions": "def combs (a b : CombString) : Nat :=\nsorry", "vc-theorems": "theorem combs_min_length {a b : CombString} :\n  combs a b ≥ max a.length b.length :=\nsorry\n\ntheorem combs_max_length {a b : CombString} :\n  combs a b ≤ a.length + b.length :=\nsorry\n\ntheorem combs_symmetric {a b : CombString} :\n  combs a b = combs b a :=\nsorry\n\ntheorem combs_all_dots {a b : CombString}\n  (ha : ∀ c, c ∈ a.data → c = '.')\n  (hb : ∀ c, c ∈ b.data → c = '.') :\n  combs a b = max a.length b.length :=\nsorry\n\ntheorem combs_all_stars {a b : CombString}\n  (ha : ∀ c, c ∈ a.data → c = '*')\n  (hb : ∀ c, c ∈ b.data → c = '*') :\n  combs a b = a.length + b.length :=\nsorry", "vc-postamble": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*..*\" \"*.*\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*...*\" \"*.*\"\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval combs \"*..*.*\" \"*.***\""}
{"id": "fvapps_002721", "vc-description": "", "vc-preamble": "def sum_positives (arr : List Int) : Int :=\n  (arr.filter (fun x => x > 0)).foldl (· + ·) 0\n\ndef is_contiguous_subsequence_sum (arr : List Int) (target : Int) : Bool :=\n  let n := arr.length\n  let indices := List.range n\n  indices.any fun i =>\n    let subSeqLengths := List.range (n - i)\n    subSeqLengths.any fun len =>\n      let subseqSum := (List.range len).foldl (fun sum j =>\n        match arr.get? (i + j) with\n        | none => sum\n        | some v => sum + v\n      ) 0\n      subseqSum = target", "vc-helpers": "", "vc-definitions": "def largest_sum (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem largest_sum_nonnegative (arr : List Int) :\n  largest_sum arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum [-1, -2, -3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum []\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval largest_sum [1, 2, 3]\n\n/-\ninfo: 187\n-/\n#guard_msgs in\n#eval largest_sum [31, -41, 59, 26, -53, 58, 97, -93, -23, 84]"}
{"id": "fvapps_002725", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.substringExists (s : String) (sub : String) : Bool :=\nsorry\n\ndef alan_annoying_kid (phrase : String) : String :=\nsorry\n\ndef String.getWords (s : String) : List String :=\nsorry", "vc-theorems": "theorem alan_preserves_verb (phrase : String) (verb : String)\n  (h₁ : phrase.startsWith \"Today I\")\n  (h₂ : verb ∈ phrase.getWords) :\n  verb ∈ (alan_annoying_kid phrase).getWords :=\nsorry\n\ntheorem alan_response_structure (phrase : String) (h₁ : phrase.startsWith \"Today I\") :\n  let response := alan_annoying_kid phrase\n  response.startsWith \"I don't think you\" ∧\n  response.endsWith \"!\" ∧\n  response.substringExists \"today\" :=\nsorry\n\ntheorem alan_response_negation_negative (phrase : String) (h₁ : phrase.startsWith \"Today I didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you did\" ∧\n  response.substringExists \"it!\" :=\nsorry\n\ntheorem alan_response_negation_positive (phrase : String)\n  (h₁ : phrase.startsWith \"Today I\")\n  (h₂ : ¬phrase.substringExists \"didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you didn't\" ∧\n  response.substringExists \"at all!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I played football.\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I didn\"t play football.\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I cleaned the kitchen.\""}
{"id": "fvapps_002732", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sort (l : List α) : List α :=\n  sorry\n\ndef same (a b : List (List Int)) : Bool :=\n  sorry", "vc-theorems": "theorem same_reflexive (arr : List (List Int)) : same arr arr = true := by\n  sorry\n\ntheorem same_symmetric (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort →\n  same arr_a arr_b = true ∧ same arr_b arr_a = true := by\n  sorry\n\ntheorem same_single_array (nums : List Int) :\n  same [nums] [nums.reverse] = true := by\n  sorry\n\ntheorem same_order_invariant (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort →\n  same arr_a arr_b = true := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval same [[2, 5], [3, 6]] [[5, 2], [3, 6]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval same [] []\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval same [[2, 3], [3, 2]] [[2, 3]]"}
{"id": "fvapps_002737", "vc-description": "-- Helper function to parse year from photo string\n\n-- Helper function to parse image number from photo string\n\n-- Year between 1000-9999\n\n-- Positive image number", "vc-preamble": "def Photo := String\n\ndef Year := Nat\n\ndef ImgNum := Nat\n\ninstance : Inhabited Photo := ⟨\"\"⟩\n\ninstance : LT Year := ⟨Nat.lt⟩\n\ninstance : LT ImgNum := ⟨Nat.lt⟩\n\ninstance : HAdd ImgNum Nat ImgNum := ⟨Nat.add⟩\n\ninstance : LT (Year × ImgNum) := ⟨λ a b => a.1 < b.1 ∨ (a.1 = b.1 ∧ a.2 < b.2)⟩", "vc-helpers": "", "vc-definitions": "def sort_photos (photos : List Photo) : List Photo :=\n  sorry\n\ndef parse_year (photo : Photo) : Year :=\n  sorry\n\ndef parse_imgnum (photo : Photo) : ImgNum :=\n  sorry", "vc-theorems": "theorem sort_photos_length (photos : List Photo) :\n  photos ≠ [] →\n  photos.length > 0 →\n  let result := sort_photos photos\n  result.length = min photos.length 5 + 1 := by\n  sorry\n\ntheorem sort_photos_contains_originals (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ i, i < result.length - 1 → result[i]! ∈ photos := by\n  sorry\n\ntheorem sort_photos_sorted (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ i j, i < j → j < result.length - 1 →\n    (parse_year result[i]!, parse_imgnum result[i]!) <\n    (parse_year result[j]!, parse_imgnum result[j]!) := by\n  sorry\n\ntheorem sort_photos_last_increments (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  parse_year result[result.length-1]! = parse_year result[result.length-2]! ∧\n  parse_imgnum result[result.length-1]! = parse_imgnum result[result.length-2]! + 1 := by\n  sorry\n\ntheorem sort_photos_format_valid (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ p ∈ result, ∃ y n : Nat,\n    y ≥ 1000 ∧ y ≤ 9999 ∧\n    n > 0 ∧\n    parse_year p = y ∧\n    parse_imgnum p = n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\", \"2016.img2\", \"2015.img3\", \"2016.img4\", \"2013.img5\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img4\", \"2016.img5\", \"2016.img1\", \"2016.img3\", \"2016.img2\"]"}
{"id": "fvapps_002749", "vc-description": "/- If a word in the input string doesn't contain exclamation marks,\n    it remains unchanged in the output -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- No word in the output string ends with an exclamation mark -/\n\n/- If a word starts with exclamation marks in the input,\n    it starts with the same exclamation marks in the output -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove (s : String) : String :=\n  sorry", "vc-theorems": "theorem words_preserved (s : String) :\n  ∀ w, w ∈ (s.split (· = ' ')) →\n  (¬ ('!' ∈ w.data)) →\n  w ∈ (remove s).split (· = ' ') :=\nsorry\n\ntheorem no_trailing_exclamations (s : String) :\n  ∀ w, w ∈ (remove s).split (· = ' ') →\n  ¬ w.endsWith \"!\" :=\nsorry\n\ntheorem leading_exclamations_preserved (s : String) :\n  ∀ w w', w ∈ s.split (· = ' ') →\n  w' ∈ (remove s).split (· = ' ') →\n  w.startsWith \"!\" → w' = w ∨ w'.startsWith \"!\" :=\nsorry", "vc-postamble": "/-\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!\"\n\n/-\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!!!\"\n\n/-\ninfo: '!Hi'\n-/\n#guard_msgs in\n#eval remove \"!Hi!\"\n\n/-\ninfo: 'Hi Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi! Hi!\"\n\n/-\ninfo: '!!!Hi !!hi !hi'\n-/\n#guard_msgs in\n#eval remove \"!!!Hi !!hi!!! !hi\""}
{"id": "fvapps_002755", "vc-description": "/- Helper functions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ka_co_ka_de_ka_me (s: String) : String :=\nsorry\n\ndef isVowel (c: Char) : Bool :=\nsorry\n\ndef removeKa (s: String) : String :=\nsorry\n\ndef getConsonants (s: String) : String :=\nsorry", "vc-theorems": "theorem ka_prefix (word: String) :\n  String.isPrefixOf \"ka\" (ka_co_ka_de_ka_me word) :=\nsorry\n\ntheorem length_increases (word: String) :\n  word.length > 0 → (ka_co_ka_de_ka_me word).length > word.length :=\nsorry\n\ntheorem all_vowels (word: String) :\n  (∀ c ∈ word.data, isVowel c) →\n  ka_co_ka_de_ka_me word = \"ka\" ++ word :=\nsorry\n\ntheorem consonants_unchanged (word: String) :\n  getConsonants word = getConsonants (removeKa (ka_co_ka_de_ka_me word)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'kaa'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"a\"\n\n/-\ninfo: 'kamaikantekanakance'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"maintenance\"\n\n/-\ninfo: 'kaIkancokamprekahekansikabikalikatiekas'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"Incomprehensibilities\""}
{"id": "fvapps_002762", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Same theorems for real numbers -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def opposite (x : Int) : Int :=\nsorry\n\ndef opposite_real (x : Float) : Float :=\nsorry", "vc-theorems": "theorem double_negative_int (x : Int) :\n  opposite (opposite x) = x :=\nsorry\n\ntheorem double_negative_real (x : Float) :\n  opposite_real (opposite_real x) = x :=\nsorry\n\ntheorem zero_is_self_opposite :\n  opposite 0 = 0 :=\nsorry\n\ntheorem nonzero_not_self_opposite (x : Int) :\n  x ≠ 0 → opposite x ≠ x :=\nsorry\n\ntheorem sum_with_opposite_int (x : Int) :\n  x + opposite x = 0 :=\nsorry\n\ntheorem sum_with_opposite_real (x : Float) :\n  x + opposite_real x = 0 :=\nsorry", "vc-postamble": "/-\ninfo: -1\n-/\n#guard_msgs in\n#eval opposite 1\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval opposite -34\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval opposite 0"}
{"id": "fvapps_002763", "vc-description": "", "vc-preamble": "def pi : Float := 3.14159", "vc-helpers": "", "vc-definitions": "def volume (radius height : Float) : Nat :=\n  sorry", "vc-theorems": "theorem volume_zero :\n  volume 0 0 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- π is approximated as 3.14159 -/\n\n/-\ninfo: 153\n-/\n#guard_msgs in\n#eval volume 7 3\n\n/-\ninfo: 98520\n-/\n#guard_msgs in\n#eval volume 56 30\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval volume 0 0"}
{"id": "fvapps_002766", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef generate_number (squad : List Nat) (target : Nat) : Option Nat :=\n  sorry", "vc-theorems": "theorem generate_number_bounds {squad : List Nat} {n : Nat} :\n  1 ≤ n → n ≤ 99 →\n  ∀ result, generate_number squad n = some result →\n  1 ≤ result ∧ result ≤ 99 :=\nsorry\n\ntheorem generate_number_not_in_squad {squad : List Nat} {n : Nat} :\n  ∀ result, generate_number squad n = some result →\n  result ∉ squad :=\nsorry\n\ntheorem generate_number_digits_sum {squad : List Nat} {n : Nat} :\n  ∀ result, generate_number squad n = some result →\n  result ≠ n → sumOfDigits result = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 15, 69] 34\n\n/-\ninfo: 29\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 69] 11\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 38, 47, 56, 65, 69, 74, 83, 92] 11"}
{"id": "fvapps_002770", "vc-description": "", "vc-preamble": "def list_maximum (l : List Int) : Option Int :=\n  l.foldl (fun acc x => match acc with\n    | none => some x\n    | some m => some (max m x)) none", "vc-helpers": "", "vc-definitions": "def small_enough (numbers : List Int) (limit : Int) : Bool :=\n  sorry", "vc-theorems": "theorem small_enough_characterization (numbers : List Int) (limit : Int)\n    (h : numbers ≠ []) :\n  small_enough numbers limit = ((list_maximum numbers).getD 0 ≤ limit) :=\nsorry\n\ntheorem small_enough_at_maximum (numbers : List Int) (h : numbers ≠ []) :\n  let max_val := (list_maximum numbers).getD 0\n  small_enough numbers max_val = true ∧\n  small_enough numbers (max_val - 1) = false :=\nsorry\n\ntheorem small_enough_scaling (numbers : List Int) (factor : Int)\n    (h : numbers ≠ []) (h_pos : factor > 0) :\n  let max_val := (list_maximum numbers).getD 0\n  let scaled_numbers := numbers.map (· * factor)\n  small_enough scaled_numbers (max_val * factor) = small_enough numbers max_val :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [66, 101] 200\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval small_enough [78, 117, 110, 99, 104, 117, 107, 115] 100\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [101, 45, 75, 105, 99, 107] 107"}
{"id": "fvapps_002777", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (n : Nat) : List Nat :=\nsorry\n\ndef distinctDigitYear (year : Nat) : Nat :=\nsorry\n\ndef hasDistinctDigits (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem distinct_digit_year_greater_than_input (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  distinctDigitYear year > year :=\nsorry\n\ntheorem distinct_digit_year_has_four_digits (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  distinctDigitYear year ≥ 1000 :=\nsorry\n\ntheorem distinct_digit_year_has_distinct_digits (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  hasDistinctDigits (distinctDigitYear year) = true :=\nsorry\n\ntheorem distinct_digit_year_is_minimal (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  ∀ y, year < y → y < distinctDigitYear year →\n    hasDistinctDigits y = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2013\n-/\n#guard_msgs in\n#eval distinct_digit_year 1987\n\n/-\ninfo: 2014\n-/\n#guard_msgs in\n#eval distinct_digit_year 2013"}
{"id": "fvapps_002785", "vc-description": "", "vc-preamble": "def listSum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def reverse_strings (arr : List String) : List String :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem reverse_strings_length_preserved (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  let result := reverse_strings arr\n  (result.length = arr.length) ∧\n  (∀ i, i < arr.length → (result.get ⟨i, sorry⟩).length = (arr.get ⟨i, sorry⟩).length) :=\nsorry\n\ntheorem reverse_strings_is_reversible (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  reverse_strings (reverse_strings arr) = arr :=\nsorry\n\ntheorem reverse_strings_total_chars_preserved (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  let result := reverse_strings arr\n  (listSum (arr.map String.length)) = (listSum (result.map String.length)) ∧\n  String.reverse (String.join arr) = String.join result :=\nsorry\n\ntheorem reverse_strings_single_char (arr : List String)\n  (h : ∀ s ∈ arr, s.length = 1) :\n  String.join (reverse_strings arr) = String.reverse (String.join arr) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_strings [\"I\", \"like\", \"big\", \"butts\", \"and\", \"I\", \"cannot\", \"lie!\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_strings [\"?kn\", \"ipnr\", \"utotst\", \"ra\", \"tsn\", \"iksr\", \"uo\", \"yer\", \"ofebta\", \"eote\", \"vahu\", \"oyodpm\", \"ir\", \"hsyn\", \"amwoH\"]"}
{"id": "fvapps_002787", "vc-description": "", "vc-preamble": "def valid_letters := ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']\n\ndef score_map (c : Char) : Int :=\n  match c with\n  | 'w' => 4\n  | 'p' => 3\n  | 'b' => 2\n  | 's' => 1\n  | 'm' => -4\n  | 'q' => -3\n  | 'd' => -2\n  | 'z' => -1\n  | _ => 0", "vc-helpers": "", "vc-definitions": "def alphabet_war (s : String) : String :=\nsorry", "vc-theorems": "theorem alphabet_war_valid_output (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_invalid_chars (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_scoring (s : String) (h : s.all (λ c => c ∈ valid_letters)) :\n  let score := s.foldr (λ c acc => acc + score_map c) 0\n  if score > 0 then\n    alphabet_war s = \"Left side wins!\"\n  else if score < 0 then\n    alphabet_war s = \"Right side wins!\"\n  else\n    alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_opposing_sides (left right : String)\n  (h1 : left.all (λ c => c ∈ ['w', 'p', 'b', 's']))\n  (h2 : right.all (λ c => c ∈ ['m', 'q', 'd', 'z'])) :\n  alphabet_war (left ++ right) = \"Left side wins!\" ∨\n  alphabet_war (left ++ right) = \"Right side wins!\" ∨\n  alphabet_war (left ++ right) = \"Let's fight again!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/-\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"wq\"\n\n/-\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"zdqmwpbs\""}
{"id": "fvapps_002793", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Int :=\nsorry\n\ndef isVowel (c : Char) : Bool :=\nsorry\n\ndef isConsonant (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem solve_returns_nonnegative (s : String) :\n  solve s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval solve \"zodiac\"\n\n/-\ninfo: 57\n-/\n#guard_msgs in\n#eval solve \"strength\"\n\n/-\ninfo: 73\n-/\n#guard_msgs in\n#eval solve \"catchphrase\""}
{"id": "fvapps_002795", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef num_of_open_lockers (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem num_open_lockers_is_floor_sqrt (n : Nat) :\n  num_of_open_lockers n = sqrt n :=\nsorry\n\ntheorem num_open_lockers_nonnegative (n : Nat) :\n  num_of_open_lockers n ≥ 0 :=\nsorry\n\ntheorem num_open_lockers_squared_bound (n : Nat) :\n  (num_of_open_lockers n) * (num_of_open_lockers n) ≤ n :=\nsorry\n\ntheorem num_open_lockers_next_squared_bound (n : Nat) :\n  (num_of_open_lockers n + 1) * (num_of_open_lockers n + 1) > n :=\nsorry\n\ntheorem num_open_lockers_zero :\n  num_of_open_lockers 0 = 0 :=\nsorry\n\ntheorem num_open_lockers_one :\n  num_of_open_lockers 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval num_of_open_lockers 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_of_open_lockers 4\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval num_of_open_lockers 500"}
{"id": "fvapps_002798", "vc-description": "", "vc-preamble": "def sumList : List Int → Int\n  | [] => 0\n  | (h::t) => h + sumList t\n\ndef countList (x : Int) : List Int → Nat\n  | [] => 0\n  | (h::t) => (if h = x then 1 else 0) + countList x t\n\ninductive Perm : List Int → List Int → Prop where\n  | nil : Perm [] []\n  | cons : (x : Int) → {l₁ l₂ : List Int} → Perm l₁ l₂ → Perm (x::l₁) (x::l₂)", "vc-helpers": "", "vc-definitions": "def repeats (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem repeats_singles {arr : List Int} (h : arr.length ≥ 1) :\n  repeats arr = sumList (arr.filter (fun x => countList x arr = 1)) :=\nsorry\n\ntheorem repeats_duplicate_array {arr : List Int} (h : arr.length ≥ 1) :\n  repeats (arr ++ arr) = 0 :=\nsorry\n\ntheorem repeats_permutation {arr₁ arr₂ : List Int}\n  (h₁ : arr₁.length ≥ 2)\n  (h₂ : Perm arr₁ arr₂) :\n  repeats arr₁ = repeats arr₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval repeats [4, 5, 7, 5, 4, 8]\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval repeats [9, 10, 19, 13, 19, 13]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval repeats [16, 0, 11, 4, 8, 16, 0, 11]"}
{"id": "fvapps_002804", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.reverse (s : String) : String :=\nsorry\n\ndef split (s : String) (sep : String) : List String :=\nsorry\n\ndef reverse_sentence (s : String) : String :=\nsorry", "vc-theorems": "theorem word_count_preserved (words : List String) :\n  let sentence := \" \".intercalate words\n  let reversed := reverse_sentence sentence\n  (split sentence \" \").length = (split reversed \" \").length :=\nsorry\n\ntheorem empty_string :\n  reverse_sentence \"\" = \"\" :=\nsorry\n\ntheorem each_word_reversed (s : String) :\n  let original_words := split s \" \"\n  let result_words := split (reverse_sentence s) \" \"\n  ∀ i, i < original_words.length →\n    result_words[i]! = String.reverse original_words[i]! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_sentence \"Hello !Nhoj Want to have lunch?\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_sentence \"CodeWars rules!\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval reverse_sentence \"\""}
{"id": "fvapps_002809", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def how_many_measurements (n : Nat) : Nat :=\n  sorry\n\ndef log3ceil (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem measurements_non_negative (n : Nat) (h : n > 0) :\n  how_many_measurements n ≥ 0 :=\nsorry\n\ntheorem measurements_sufficient (n : Nat) (h : n > 0) :\n  3^(how_many_measurements n) ≥ n :=\nsorry\n\ntheorem edge_case_one :\n  how_many_measurements 1 = 0 :=\nsorry\n\ntheorem edge_case_two :\n  how_many_measurements 2 = 1 :=\nsorry\n\ntheorem edge_case_three :\n  how_many_measurements 3 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval how_many_measurements 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval how_many_measurements 8\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval how_many_measurements 100"}
{"id": "fvapps_002810", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def dropzone (fire : List Int) (dropzones : List (List Int)) : List Int :=\nsorry\n\ndef hypot (x y : Int) : Float :=\nsorry\n\ndef isClosestToFire (point fire : List Int) (points : List (List Int)) : Bool :=\nsorry\n\ndef isClosestToOrigin (point fire : List Int) (points : List (List Int)) : Bool :=\nsorry", "vc-theorems": "theorem dropzone_is_valid_point (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 → dropzone fire dropzones ∈ dropzones :=\nsorry\n\ntheorem dropzone_is_closest_to_fire (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 →\n  isClosestToFire (dropzone fire dropzones) fire dropzones = true :=\nsorry\n\ntheorem dropzone_is_closest_to_origin (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 →\n  isClosestToOrigin (dropzone fire dropzones) fire dropzones = true :=\nsorry\n\ntheorem single_dropzone (fire dropzone_single : List Int) :\n  fire.length = 2 → dropzone_single.length = 2 →\n  dropzone fire [dropzone_single] = dropzone_single :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [7, 9]\n-/\n#guard_msgs in\n#eval dropzone [6, 8] [[3, 2], [6, 1], [7, 9]]\n\n/-\ninfo: [5, 5]\n-/\n#guard_msgs in\n#eval dropzone [9, 2] [[1, 4], [9, 9], [5, 5]]\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval dropzone [1, 1] [[0, 1], [1, 0], [2, 2]]"}
{"id": "fvapps_002812", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def riders (stations : List Nat) : Nat :=\n  sorry\n\ndef calc_min_riders (stations: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem riders_positive (stations: List Nat) :\n  stations.all (fun x => x > 0 ∧ x ≤ 100) →\n  riders stations > 0 :=\nsorry\n\ntheorem riders_bounded (stations: List Nat) :\n  stations.all (fun x => x > 0 ∧ x ≤ 100) →\n  riders stations ≤ stations.length + 1 :=\nsorry\n\ntheorem riders_short_distances (stations: List Nat) :\n  stations.all (fun x => x ≤ 1) →\n  riders stations = 1 :=\nsorry\n\ntheorem riders_long_distances (stations: List Nat) :\n  stations.all (fun x => x ≥ 99 ∧ x ≤ 100) →\n  (riders stations = stations.length ∨ riders stations = stations.length + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval riders [18, 15]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval riders [43, 23, 40, 13]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval riders [33, 8, 16, 47, 30, 30, 46]"}
{"id": "fvapps_002823", "vc-description": "-- Helper for theorem statement", "vc-preamble": "def is_hex_string (s : String) : Bool :=\n  s.all is_hex_digit", "vc-helpers": "", "vc-definitions": "def bin_to_hex (b : String) : String :=\nsorry\n\ndef hex_to_bin (h : String) : String :=\nsorry\n\ndef is_hex_digit (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem hex_to_bin_roundtrip (h : String) :\n  is_hex_string h →\n  bin_to_hex (hex_to_bin h) =\n    if h = \"\" then \"0\"\n    else if h = \"0\" then \"0\"\n    else h :=\nsorry\n\ntheorem empty_and_zero_bin_to_hex :\n  bin_to_hex \"\" = \"0\" ∧\n  bin_to_hex \"0\" = \"0\" :=\nsorry\n\ntheorem empty_and_zero_hex_to_bin :\n  hex_to_bin \"\" = \"0\" ∧\n  hex_to_bin \"0\" = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000101\"\n\n/-\ninfo: '4d2'\n-/\n#guard_msgs in\n#eval bin_to_hex \"10011010010\"\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000\"\n\n/-\ninfo: '1111'\n-/\n#guard_msgs in\n#eval hex_to_bin \"00F\"\n\n/-\ninfo: '101'\n-/\n#guard_msgs in\n#eval hex_to_bin \"5\"\n\n/-\ninfo: '10011010010'\n-/\n#guard_msgs in\n#eval hex_to_bin \"04D2\""}
{"id": "fvapps_002826", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def prod_int_part (n: Nat) (min: Nat := 2) : Nat × List Nat :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem prod_int_part_output_structure (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.1 ≥ 0 ∧ result.2.all (λ x => x ≥ 2) :=\nsorry\n\ntheorem prime_numbers_return_empty (n: Nat) (h: n ≥ 2) :\n  isPrime n → prod_int_part n = (0, []) :=\nsorry\n\ntheorem factors_multiply_to_input (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.2 ≠ [] → result.2.foldl (·*·) 1 = n :=\nsorry\n\ntheorem factors_are_ordered (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.2.length > 1 →\n  ∀ i, i < result.2.length - 1 →\n  result.2[i]! ≤ result.2[i+1]! :=\nsorry\n\ntheorem min_parameter_respects_boundary (n min: Nat) (h1: n ≥ 2) (h2: min ≥ 2) :\n  let result := prod_int_part n min\n  result.2.all (λ x => x ≥ min) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, [2, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 18\n\n/-\ninfo: [10, [2, 2, 3, 5]]\n-/\n#guard_msgs in\n#eval prod_int_part 60\n\n/-\ninfo: [6, [2, 3, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 54\n\n/-\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 37\n\n/-\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 61"}
{"id": "fvapps_002827", "vc-description": "-- Empty inputs theorem\n\n-- Visible characters theorem", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def watch_pyramid_from_the_side (chars : Option String) : Option String :=\nsorry\n\ndef watch_pyramid_from_above (chars : Option String) : Option String :=\nsorry\n\ndef count_visible_characters_of_the_pyramid (chars : Option String) : Int :=\nsorry\n\ndef count_all_characters_of_the_pyramid (chars : Option String) : Int :=\nsorry", "vc-theorems": "theorem empty_inputs {chars : Option String} :\n  chars = none ∨ chars = some \"\" →\n  watch_pyramid_from_the_side chars = chars ∧\n  watch_pyramid_from_above chars = chars ∧\n  count_visible_characters_of_the_pyramid chars = -1 ∧\n  count_all_characters_of_the_pyramid chars = -1 :=\nsorry\n\ntheorem count_visible_chars {s : String} (h : s.length > 0) :\n  count_visible_characters_of_the_pyramid (some s) =\n    (2 * s.length - 1) * (2 * s.length - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side None\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid None\n\n/-\ninfo: expected_side\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"abc\"\n\n/-\ninfo: expected_above\n-/\n#guard_msgs in\n#eval watch_pyramid_from_above test_str\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid test_str\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval count_all_characters_of_the_pyramid test_str"}
{"id": "fvapps_002828", "vc-description": "-- placeholder split", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multiple_split (s : String) (delims : List String) : List String :=\n  sorry\n\ndef containsString (s : String) (sub : String) : Bool :=\n  sorry", "vc-theorems": "theorem multiple_split_nonempty_parts\n  (s : String) (delims : List String)\n  : ∀ (x : String), x ∈ multiple_split s delims → x.length > 0\n  := by\nsorry\n\ntheorem multiple_split_no_delims_in_result\n  (s : String) (delims : List String)\n  : ∀ (x : String) (d : String),\n    x ∈ multiple_split s delims →\n    d ∈ delims →\n    ¬ containsString x d\n  := by\nsorry\n\ntheorem multiple_split_empty_string\n  (delims : List String)\n  : multiple_split \"\" delims = []\n  := by\nsorry\n\ntheorem multiple_split_empty_delims\n  (s : String)\n  : multiple_split s [] = if s = \"\" then [] else [s]\n  := by\nsorry\n\ntheorem multiple_split_single_delim\n  (s : String) (delim : String)\n  (h : delim.length > 0)\n  : multiple_split s [delim] = (s.split (· == '.')).filter (fun x => x ≠ \"\")\n  := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['Hi', 'everybody']\n-/\n#guard_msgs in\n#eval multiple_split \"Hi everybody!\" [\" \", \"!\"]\n\n/-\ninfo: ['1', '2', '3']\n-/\n#guard_msgs in\n#eval multiple_split \"1+2-3\" [\"+\", \"-\"]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval multiple_split \"\" []"}
{"id": "fvapps_002829", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef arrayConversion (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem array_conversion_power_of_two_length\n  {n : Nat} {arr : List Nat}\n  (h1 : n ≥ 1) (h2 : n ≤ 5)\n  (h3 : arr.length = 2^n) :\n  isPowerOfTwo arr.length = true ∧\n  arrayConversion arr ≥ 0 :=\nsorry\n\ntheorem array_conversion_deterministic\n  {arr : List Nat}\n  (h : isPowerOfTwo arr.length = true) :\n  arrayConversion arr = arrayConversion arr :=\nsorry\n\ntheorem array_conversion_monotonic\n  {arr : List Nat} {i : Nat}\n  (h1 : isPowerOfTwo arr.length = true)\n  (h2 : i < arr.length) :\n  let arr' := arr.set i (arr[i] + 1)\n  arrayConversion arr' ≥ arrayConversion arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 186\n-/\n#guard_msgs in\n#eval array_conversion [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 64\n-/\n#guard_msgs in\n#eval array_conversion [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval array_conversion [3, 3, 5, 5]"}
{"id": "fvapps_002831", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def songDecoder (s : String) : String :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry", "vc-theorems": "theorem no_wub_in_output (s : String) :\n  ¬isSubstring \"WUB\" (songDecoder s) :=\nsorry\n\ntheorem no_leading_trailing_spaces (s : String) :\n  ¬(songDecoder s).startsWith \" \" ∧ ¬(songDecoder s).endsWith \" \" :=\nsorry\n\ntheorem no_multiple_spaces (s : String) :\n  ¬isSubstring \"  \" (songDecoder s) :=\nsorry\n\ntheorem idempotent (s : String) :\n  songDecoder (songDecoder s) = songDecoder s :=\nsorry\n\ntheorem output_properties (s : String) :\n  let result := songDecoder s\n  String.length result ≥ 0 ∧\n  ¬isSubstring \"  \" result ∧\n  ¬result.startsWith \" \" ∧\n  ¬result.endsWith \" \" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'WE ARE THE CHAMPIONS MY FRIEND'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\"\n\n/-\ninfo: 'A B C'\n-/\n#guard_msgs in\n#eval song_decoder \"AWUBBWUBC\"\n\n/-\ninfo: 'O IPVCQAFWY Q XHDKCPYKCTWWY V FZ'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWUBOWUBWUBWUBIPVCQAFWYWUBWUBWUBQWUBWUBWUBXHDKCPYKCTWWYWUBWUBWUBVWUBWUBWUBFZWUBWUB\""}
{"id": "fvapps_002832", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "structure IsSorted (xs : List Nat) : Prop where\n  sorted : ∀ i j, i < xs.length → j < xs.length → i ≤ j → xs[i]! ≤ xs[j]!", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef prime_factors_sum (n : Nat) : Nat :=\nsorry\n\ndef divisors_sum (n : Nat) : Nat :=\nsorry\n\ndef ds_multof_pfs (nMin nMax : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem is_prime_properties {n : Nat} :\n  (n < 2 → is_prime n = false) ∧\n  (is_prime n = true → n ≥ 2) ∧\n  (is_prime n = true → ∀ i : Nat, 2 ≤ i ∧ i ≤ sqrt n → n % i ≠ 0) :=\nsorry\n\ntheorem prime_factors_sum_properties {n : Nat} (h : n ≥ 2) :\n  prime_factors_sum n > 0 ∧\n  prime_factors_sum n ≤ n * n :=\nsorry\n\ntheorem ds_multof_pfs_properties {nMin nMax : Nat} (h : nMin ≤ nMax) :\n  let result := ds_multof_pfs nMin nMax\n  IsSorted result ∧\n  (∀ x ∈ result, nMin ≤ x ∧ x ≤ nMax) ∧\n  (∀ n ∈ result, prime_factors_sum n > 0 ∧ (divisors_sum n) % (prime_factors_sum n) = 0) ∧\n  (∀ i j, i < result.length → j < result.length → i ≠ j → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002835", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def last_digits (n : Nat) (d : Int) : List Nat :=\nsorry\n\ndef list_to_string (l : List Nat) : String :=\nsorry\n\ndef nat_to_string (n : Nat) : String :=\nsorry", "vc-theorems": "theorem last_digits_empty_for_nonpositive (n : Nat) (d : Int) :\n  d <= 0 → last_digits n d = [] :=\nsorry\n\ntheorem last_digits_length_bound (n : Nat) (d : Int) :\n  d > 0 → List.length (last_digits n d) = min d.toNat (nat_to_string n).length :=\nsorry\n\ntheorem last_digits_are_digits (n : Nat) (d : Int) (x : Nat) :\n  x ∈ last_digits n d → x ≤ 9 :=\nsorry\n\ntheorem last_digits_match_string_suffix (n : Nat) (d : Int) :\n  d > 0 → list_to_string (last_digits n d) = (nat_to_string n).takeRight d.toNat :=\nsorry\n\ntheorem last_digits_full_number (n : Nat) :\n  list_to_string (last_digits n ((nat_to_string n).length + 1)) = nat_to_string n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval last_digits 1 1\n\n/-\ninfo: [3, 7, 6, 7]\n-/\n#guard_msgs in\n#eval last_digits 123767 4\n\n/-\ninfo: [1, 3, 4, 3]\n-/\n#guard_msgs in\n#eval last_digits 1343 5"}
{"id": "fvapps_002841", "vc-description": "-- Result length should match total chars across merged words\n\n-- All input chars should appear in output in same quantities\n\n-- Number of words should roughly halve each iteration", "vc-preamble": "def countChar (c : Char) (s : String) : Nat :=\n  (s.toList.filter (· = c)).length", "vc-helpers": "", "vc-definitions": "def reverseAndCombineText (text : String) : String :=\nsorry", "vc-theorems": "theorem output_length_matches_input_chars (text : String) :\n  String.length (reverseAndCombineText text) =\n  String.length (String.replace text \" \" \"\") :=\nsorry\n\ntheorem chars_preserved (text : String) (c : Char) :\n  countChar c (String.replace text \" \" \"\") =\n  countChar c (reverseAndCombineText text) :=\nsorry\n\ntheorem halves_words_per_iteration (text : String) :\n  let wordCount := (text.split (· = ' ')).length\n  let maxIterations := if wordCount ≤ 1 then 0\n                       else (wordCount - 1).log2 + 1\n  ∀ result : String, result = reverseAndCombineText text →\n  (result.split (· = ' ')).length ≤\n    if wordCount ≤ 1 then 1 else wordCount / (2 ^ maxIterations) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'cbafed'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def\"\n\n/-\ninfo: 'defabcjklghi'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def ghi jkl\"\n\n/-\ninfo: 'trzwqfdstrteettr45hh4325543544hjhjh21lllll'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"234hh54 53455 sdfqwzrt rtteetrt hjhjh lllll12  44\""}
{"id": "fvapps_002848", "vc-description": "", "vc-preamble": "def ValidEvent : Type := String\n\ndef VALID_EVENTS : List ValidEvent :=\n  [\"cw\", \"CW\", \"cat\", \"CAT\", \"dog\", \"DOG\", \"movie\", \"MOVIE\"]", "vc-helpers": "", "vc-definitions": "def isValidEvent (event : String) : Bool :=\n  sorry\n\ndef howMuchCoffee (events : List String) : Nat ⊕ String :=\n  sorry", "vc-theorems": "theorem invalid_events_ignored (events : List String) :\n  (∀ e ∈ events, e ∉ VALID_EVENTS) →\n  howMuchCoffee events = .inl 0 :=\nsorry\n\ntheorem valid_events (events : List String) :\n  (∀ e ∈ events, e ∈ VALID_EVENTS) →\n  let total := events.foldl (fun acc e => acc + if e.all Char.isUpper then 2 else 1) 0\n  if total > 3\n  then howMuchCoffee events = .inr \"You need extra sleep\"\n  else howMuchCoffee events = .inl total :=\nsorry\n\ntheorem single_event_empty :\n  howMuchCoffee [] = .inl 0 :=\nsorry\n\ntheorem single_valid_event (event : String) :\n  event ∈ VALID_EVENTS →\n  howMuchCoffee [event] = .inl (if event.all Char.isUpper then 2 else 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval how_much_coffee []\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval how_much_coffee [\"CW\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\"]\n\n/-\ninfo: 'You need extra sleep'\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"DOG\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"cw=others\"]"}
{"id": "fvapps_002849", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isHexDigit (c : Char) : Bool :=\nsorry\n\ndef rgb (r g b : Int) : String :=\nsorry\n\ndef hexStringToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem rgb_output_format (r g b : Int) :\n  let result := rgb r g b\n  (result.length = 6) ∧\n  (result.data.all isHexDigit)\n  :=\nsorry\n\ntheorem rgb_valid_inputs (r g b : Int)\n  (hr : 0 ≤ r ∧ r ≤ 255)\n  (hg : 0 ≤ g ∧ g ≤ 255)\n  (hb : 0 ≤ b ∧ b ≤ 255) :\n  let result := rgb r g b\n  let r_hex := result.take 2\n  let g_hex := result.drop 2 |>.take 2\n  let b_hex := result.drop 4 |>.take 2\n  (hexStringToNat r_hex = r) ∧\n  (hexStringToNat g_hex = g) ∧\n  (hexStringToNat b_hex = b)\n  :=\nsorry\n\ntheorem rgb_negative_inputs (r g b : Int)\n  (hr : r < 0)\n  (hg : g < 0)\n  (hb : b < 0) :\n  rgb r g b = \"000000\"\n  :=\nsorry\n\ntheorem rgb_large_inputs (r g b : Int)\n  (hr : r > 255)\n  (hg : g > 255)\n  (hb : b > 255) :\n  rgb r g b = \"FFFFFF\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '000000'\n-/\n#guard_msgs in\n#eval rgb 0 0 0\n\n/-\ninfo: '010203'\n-/\n#guard_msgs in\n#eval rgb 1 2 3\n\n/-\ninfo: '00FF7D'\n-/\n#guard_msgs in\n#eval rgb -20 275 125"}
{"id": "fvapps_002853", "vc-description": "", "vc-preamble": "def validUsers : List String := [\"Timmy\", \"Alice\", \"Johny\", \"Roger\", \"Simon\", \"Admin\"]", "vc-helpers": "", "vc-definitions": "def validate (username password : String) : String :=\n  sorry", "vc-theorems": "theorem invalid_username {username password : String}\n  (h : username ∉ validUsers) :\n  validate username password = \"Wrong username or password!\" :=\nsorry\n\ntheorem injection_attempt {username password1 password2 : String}\n  (h : username ∈ validUsers) :\n  validate username (password1 ++ \"||\" ++ password2) = \"Wrong username or password!\" :=\nsorry\n\ntheorem injection_attempt_slash {username password1 password2 : String}\n  (h : username ∈ validUsers) :\n  validate username (password1 ++ \"//\" ++ password2) = \"Wrong username or password!\" :=\nsorry\n\ntheorem valid_login_timmy :\n  validate \"Timmy\" \"password\" = \"Successfully Logged in!\" :=\nsorry\n\ntheorem valid_login_alice :\n  validate \"Alice\" \"alice\" = \"Successfully Logged in!\" :=\nsorry\n\ntheorem valid_user_response {username password : String}\n  (h : username ∈ validUsers) :\n  validate username password = \"Successfully Logged in!\" ∨\n  validate username password = \"Wrong username or password!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"h4x0r\"\n\n/-\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Alice\" \"alice\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"||\"\"==\"\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Admin\" \"gs5bw\"||1==1//\""}
{"id": "fvapps_002864", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countOnes (n : Nat) : Nat :=\n  sorry\n\ndef shared_bits (a b : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem shared_bits_symmetric\n  {a b : Nat} : shared_bits a b = shared_bits b a := by\n  sorry\n\ntheorem shared_bits_self\n  {x : Nat} : shared_bits x x = (countOnes x > 1) := by\n  sorry\n\ntheorem shared_bits_and\n  {a b : Nat} : shared_bits a b = (countOnes (a &&& b) > 1) := by\n  sorry\n\ntheorem shared_bits_single_bit\n  {x : Nat} (h : x ≤ 1) : shared_bits x x = false := by\n  sorry\n\ntheorem shared_bits_powers_two\n  {p1 p2 : Nat} (h1 : ∃ k1, p1 = 2^k1) (h2 : ∃ k2, p2 = 2^k2) :\n  shared_bits p1 p2 = false := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 1 2\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 7 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval shared_bits 7 15"}
{"id": "fvapps_002865", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def delete_digit (n : Nat) : Nat :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem delete_digit_length (n : Nat) (h : n ≥ 10) :\n  (toString (delete_digit n)).length = (toString n).length - 1 :=\nsorry\n\ntheorem delete_digit_smaller (n : Nat) (h : n ≥ 10) :\n  delete_digit n < n :=\nsorry\n\ntheorem delete_digit_natural (n : Nat) (h : n ≥ 10) :\n  delete_digit n ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 52\n-/\n#guard_msgs in\n#eval delete_digit 152\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval delete_digit 1001\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval delete_digit 10"}
{"id": "fvapps_002866", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simple_transposition (s : String) : String :=\nsorry\n\ndef reverse_transposition (s : String) : String :=\nsorry\n\ndef stringTakeEveryNth (s : String) (start : Nat) : String :=\nsorry", "vc-theorems": "theorem length_preserved (s : String) :\n  (simple_transposition s).length = s.length :=\nsorry\n\ntheorem empty_and_single_char (s : String) :\n  s.length ≤ 1 → simple_transposition s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002867", "vc-description": "", "vc-preamble": "inductive CardIssuer where\n  | AMEX : CardIssuer\n  | Discover : CardIssuer\n  | Mastercard : CardIssuer\n  | VISA : CardIssuer\n  | Unknown : CardIssuer\nderiving BEq\n\ndef CardIssuer.toString : CardIssuer → String\n  | AMEX => \"AMEX\"\n  | Discover => \"Discover\"\n  | Mastercard => \"Mastercard\"\n  | VISA => \"VISA\"\n  | Unknown => \"Unknown\"", "vc-helpers": "", "vc-definitions": "def get_issuer (number : Nat) : String :=\nsorry", "vc-theorems": "theorem issuer_is_valid (n : Nat) :\n  let result := get_issuer n\n  result = \"AMEX\" ∨ result = \"Discover\" ∨ result = \"Mastercard\" ∨ result = \"VISA\" ∨ result = \"Unknown\" :=\nsorry\n\ntheorem amex_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"34\" ∨ digits.take 2 = \"37\") → get_issuer n = \"AMEX\" ∧\n  (digits.take 2 = \"35\" ∨ digits.take 2 = \"36\") → get_issuer n = \"Unknown\" :=\nsorry\n\ntheorem visa_length_rules (n : Nat) :\n  let digits := n.repr\n  (digits.get! 0 = '4' ∧ (digits.length = 13 ∨ digits.length = 16)) →\n    get_issuer n = \"VISA\" ∧\n  (digits.get! 0 = '4' ∧ ¬(digits.length = 13 ∨ digits.length = 16)) →\n    get_issuer n = \"Unknown\" :=\nsorry\n\ntheorem mastercard_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"51\" ∨ digits.take 2 = \"52\" ∨ digits.take 2 = \"53\" ∨ digits.take 2 = \"54\" ∨ digits.take 2 = \"55\") →\n  digits.length = 16 →\n  get_issuer n = \"Mastercard\" :=\nsorry\n\ntheorem discover_rules (n : Nat) :\n  let digits := n.repr\n  digits.startsWith \"6011\" ∧ digits.length = 16 →\n    get_issuer n = \"Discover\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111111\n\n/-\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111\n\n/-\ninfo: 'AMEX'\n-/\n#guard_msgs in\n#eval get_issuer 378282246310005\n\n/-\ninfo: 'Mastercard'\n-/\n#guard_msgs in\n#eval get_issuer 5105105105105100\n\n/-\ninfo: 'Discover'\n-/\n#guard_msgs in\n#eval get_issuer 6011111111111117\n\n/-\ninfo: 'Unknown'\n-/\n#guard_msgs in\n#eval get_issuer 9111111111111111"}
{"id": "fvapps_002868", "vc-description": "/- Returns the list of words in a string -/\n\n/- Invalid input types should return \"Not a chord\" -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Wrong number of notes (not equal to 3) should return \"Not a chord\" -/\n\n/- Invalid note names should return \"Not a chord\" -/\n\n/- Known major chords should return \"Major\" -/\n\n/- Known minor chords should return \"Minor\" -/\n\n/- Enharmonic equivalents should produce the same result -/\n\n/- The main function that determines if a chord is major, minor, or invalid -/", "vc-preamble": "def NoteNames : List String := [\"C\", \"C#\", \"Db\", \"D\", \"D#\", \"Eb\", \"E\", \"F\", \"F#\", \"Gb\", \"G\", \"G#\", \"Ab\", \"A\", \"A#\", \"Bb\", \"B\"]", "vc-helpers": "", "vc-definitions": "def minor_or_major (input : String) : String :=\nsorry\n\ndef splitString (s : String) : List String :=\nsorry", "vc-theorems": "theorem invalid_input_numeric (n : Nat) :\n  minor_or_major (toString n) = \"Not a chord\" :=\nsorry\n\ntheorem wrong_note_count (notes : String) :\n  (splitString notes).length ≠ 3 → minor_or_major notes = \"Not a chord\" :=\nsorry\n\ntheorem invalid_note_names (notes : String) :\n  (∃ note, note ∈ splitString notes ∧ note ∉ NoteNames) →\n  minor_or_major notes = \"Not a chord\" :=\nsorry\n\ntheorem known_major_chords :\n  minor_or_major \"C E G\" = \"Major\" ∧\n  minor_or_major \"F# A# C#\" = \"Major\" :=\nsorry\n\ntheorem known_minor_chords :\n  minor_or_major \"C Eb G\" = \"Minor\" ∧\n  minor_or_major \"F# A C#\" = \"Minor\" :=\nsorry\n\ntheorem enharmonic_equivalence (n1 n2 : String) (other1 other2 : String) :\n  ((n1 = \"C#\" ∧ n2 = \"Db\") ∨\n   (n1 = \"D#\" ∧ n2 = \"Eb\") ∨\n   (n1 = \"F#\" ∧ n2 = \"Gb\") ∨\n   (n1 = \"G#\" ∧ n2 = \"Ab\") ∨\n   (n1 = \"A#\" ∧ n2 = \"Bb\")) →\n  minor_or_major (s!\"{n1} {other1} {other2}\") =\n  minor_or_major (s!\"{n2} {other1} {other2}\") :=\nsorry", "vc-postamble": "/-\ninfo: 'Major'\n-/\n#guard_msgs in\n#eval minor_or_major \"C E G\"\n\n/-\ninfo: 'Minor'\n-/\n#guard_msgs in\n#eval minor_or_major \"C Eb G\"\n\n/-\ninfo: 'Not a chord'\n-/\n#guard_msgs in\n#eval minor_or_major \"C D G\""}
{"id": "fvapps_002878", "vc-description": "-- actual swapping implementation would go here", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSolved (board : List (List Nat)) : Bool :=\n  sorry\n\ndef isSequential (board : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem solved_board_generated {n : Nat} (h : n > 0) (h2 : n ≤ 5) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  isSolved board = isSequential board :=\nsorry\n\ntheorem arbitrary_boards_match_sequential (board : List (List Nat))\n  (h : board.length > 0)\n  (h2 : board.length ≤ 5)\n  (h3 : ∀ row ∈ board, row.length = board.length) :\n  isSolved board = isSequential board :=\nsorry\n\ntheorem single_swap_breaks_solution\n  {n : Nat} (h : n > 0) (h2 : n ≤ 5)\n  (pos1 pos2 : Nat) (h3 : pos1 ≠ pos2) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  let total_size := n * n\n  let pos1' := pos1 % total_size\n  let pos2' := pos2 % total_size\n  let row1 := pos1' / n\n  let col1 := pos1' % n\n  let row2 := pos2' / n\n  let col2 := pos2' % n\n  let swapped_board := sorry\n  ¬(isSolved swapped_board) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0], [3, 2]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0, 4], [3, 2, 7], [8, 5, 6]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_solved [[0, 1], [2, 3]]"}
{"id": "fvapps_002880", "vc-description": "-- Non-negativity\n\n-- Identity\n\n-- Symmetry\n\n-- Triangle inequality\n\n-- Empty string", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def levenshtein (s1 s2 : String) : Nat :=\n  sorry\n\ndef repeatChar (c : Char) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem levenshtein_nonneg (s1 s2 : String) :\n  levenshtein s1 s2 ≥ 0 :=\nsorry\n\ntheorem levenshtein_identity (s : String) :\n  levenshtein s s = 0 :=\nsorry\n\ntheorem levenshtein_symm (s1 s2 : String) :\n  levenshtein s1 s2 = levenshtein s2 s1 :=\nsorry\n\ntheorem levenshtein_triangle (s1 s2 s3 : String) :\n  levenshtein s1 s2 ≤ levenshtein s1 s3 + levenshtein s3 s2 :=\nsorry\n\ntheorem levenshtein_empty_string (s : String) :\n  levenshtein s \"\" = s.length :=\nsorry\n\ntheorem levenshtein_empty_string_rev (s : String) :\n  levenshtein \"\" s = s.length :=\nsorry", "vc-postamble": "-- Repeated char prepending\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval levenshtein \"kitten\" \"sitting\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval levenshtein \"book\" \"back\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval levenshtein \"peter\" \"peter\""}
{"id": "fvapps_002882", "vc-description": "", "vc-preamble": "def isSorted (cs : List Char) : Prop :=\n  ∀ i j, i < j → j < cs.length → cs[i]! ≤ cs[j]!", "vc-helpers": "", "vc-definitions": "def alphabetic (s : String) : Bool :=\nsorry", "vc-theorems": "theorem empty_string_alphabetic :\n  alphabetic \"\" = true :=\nsorry\n\ntheorem single_char_alphabetic (c : Char) :\n  alphabetic (String.singleton c) = true :=\nsorry\n\ntheorem alphabetic_iff_sorted (s : String) :\n  alphabetic s = true ↔ isSorted s.data :=\nsorry\n\ntheorem alphabetic_monotonic (s : String) :\n  alphabetic s = true →\n  ∀ i : Nat, i + 1 < s.length →\n  s.data[i]! ≤ s.data[i+1]! :=\nsorry\n\ntheorem concat_nonalpha_equiv_sorted (ss : List String) (h : ss ≠ []) :\n  (∀ s ∈ ss, alphabetic s = false) →\n  alphabetic (String.join ss) = true ↔ isSorted (String.join ss).data :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"door\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"cell\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval alphabetic \"kata\""}
{"id": "fvapps_002888", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def firstIndex (s: String) (c: Char) : Nat :=\n  sorry\n\ndef lastIndex (s: String) (c: Char) : Nat :=\n  sorry\n\ndef solve (s: String) : Char :=\n  sorry", "vc-theorems": "theorem solve_returns_char_from_input (s: String) (h: s.length > 0) :\n  ∃ p: String.Pos, solve s = s.get p :=\nsorry\n\ntheorem solve_returns_char_with_minimal_first_last_diff (s: String) (h: s.length > 0) :\n  ∀ c: Char,\n  firstIndex s (solve s) - lastIndex s (solve s)\n  ≤ firstIndex s c - lastIndex s c :=\nsorry\n\ntheorem solve_returns_lexicographically_first_when_tied (s: String) (h: s.length > 0) :\n  ∀ c: Char,\n  (firstIndex s c - lastIndex s c = firstIndex s (solve s) - lastIndex s (solve s))\n  → solve s ≤ c :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"a\"\n\n/-\ninfo: 'x'\n-/\n#guard_msgs in\n#eval solve \"axyzxyz\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"dcbadcba\""}
{"id": "fvapps_002889", "vc-description": "-- Result is sorted\n\n-- All numbers within bounds\n\n-- Each number divisible by sum of its digits", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef rthn_between (a b : Int) : List Int :=\n  sorry", "vc-theorems": "theorem rthn_between_ordered_bounds {a b : Int} (h : a ≤ b) (h₁ : 0 ≤ a) (h₂ : b ≤ 10000) :\n  let result := rthn_between a b\n\n  (∀ i j, i < j → i < List.length result → j < List.length result →\n    result[i]! ≤ result[j]!) ∧\n\n  (∀ x ∈ result, a ≤ x ∧ x ≤ b) ∧\n\n  (∀ x ∈ result, x % sumOfDigits (Int.toNat x) = 0) :=\nsorry\n\ntheorem rthn_between_same_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :\n  let result := rthn_between n n\n  (result ≠ [] →\n    List.length result = 1 ∧\n    result[0]! = n ∧\n    n % sumOfDigits (Int.toNat n) = 0) :=\nsorry\n\ntheorem rthn_between_inverted_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :\n  rthn_between n (n-1) = [] :=\nsorry\n\ntheorem rthn_between_edge_cases :\n  (rthn_between 0 0 = []) ∧\n  (rthn_between (-1) 10 = [10]) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [10, 12, 18, 20]\n-/\n#guard_msgs in\n#eval rthn_between 0 20\n\n/-\ninfo: [200, 201, 204, 207, 209, 210]\n-/\n#guard_msgs in\n#eval rthn_between 200 210\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval rthn_between 2200 2300"}
{"id": "fvapps_002892", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.max (l: List Nat) : Nat :=\n  sorry\n\ndef intToStr (n: Nat) : String :=\n  sorry\n\ndef strLen (s: String) : Nat :=\n  sorry\n\ndef splitLines (s: String) : List String :=\n  sorry\n\ndef stringToNat (s: String) : Nat :=\n  sorry\n\ndef print_nums (nums: List Nat) : String :=\n  sorry", "vc-theorems": "theorem print_nums_empty (nums: List Nat) :\n  nums = [] → print_nums nums = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002895", "vc-description": "/- The length of thue_morse(n) equals n and contains only 0's and 1's -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any longer sequence starts with the shorter sequence -/\n\n/- If n > 0, the sequence starts with 0 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def thue_morse (n : Nat) : String :=\nsorry", "vc-theorems": "theorem thue_morse_length (n : Nat) :\n  (thue_morse n).length = n ∧\n  ∀ p : String.Pos,\n    String.contains \"01\" ((thue_morse n).get p) :=\nsorry\n\ntheorem thue_morse_prefix_consistency (n : Nat) :\n  (thue_morse (n + 1)).take n = thue_morse n :=\nsorry\n\ntheorem thue_morse_starts_correct (n : Nat) (h : n > 0) :\n  ∃ p : String.Pos, (thue_morse n).get p = '0' :=\nsorry", "vc-postamble": "/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval thue_morse 1\n\n/-\ninfo: '01'\n-/\n#guard_msgs in\n#eval thue_morse 2\n\n/-\ninfo: '01101'\n-/\n#guard_msgs in\n#eval thue_morse 5\n\n/-\ninfo: '0110100110'\n-/\n#guard_msgs in\n#eval thue_morse 10"}
{"id": "fvapps_002897", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def textin (s : String) : String :=\n  sorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_is_string (s : String) :\n  textin s = textin s\n  := by\nsorry\n\ntheorem output_length_leq_input (s : String) :\n  (textin s).length ≤ s.length\n  := by\nsorry\n\ntheorem no_target_words (s : String) :\n  ¬containsSubstr (String.toLower (textin s)) \"two\" ∧\n  ¬containsSubstr (String.toLower (textin s)) \"too\" ∧\n  ¬containsSubstr (String.toLower (textin s)) \"to\"\n  := by\nsorry\n\ntheorem idempotent (s : String) :\n  textin (textin s) = textin s\n  := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_002905", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_bouncy (n : Nat) : Bool :=\nsorry\n\ndef digits_sorted (n : Nat) : Bool :=\nsorry\n\ndef digits_sorted_reverse (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem small_numbers_not_bouncy (n : Nat) (h : n < 100) :\n  ¬ is_bouncy n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002913", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (expr : String) : String :=\nsorry\n\ndef isBalanced (expr : String) : Bool :=\nsorry\n\ndef validateResult (result : String) : Bool :=\nsorry", "vc-theorems": "theorem single_variables_theorem (vars : List Char)\n  (h1 : ∀ c ∈ vars, 'a' ≤ c ∧ c ≤ 'z')\n  (h2 : vars.length ≥ 1)\n  (h3 : vars.length ≤ 10) :\n  let expr := String.mk vars\n  let result := solve expr\n  validateResult result ∧\n  (∀ v ∈ vars, result.data.contains v) :=\nsorry\n\ntheorem nested_parens_theorem (vars : List Char)\n  (h1 : ∀ c ∈ vars, c = 'x' ∨ c = 'y' ∨ c = 'z')\n  (h2 : vars.length ≥ 1)\n  (h3 : vars.length ≤ 5) :\n  let expr := vars.foldl (fun acc v => acc ++ \"-(\" ++ String.mk [v] ++ \")\") (String.mk [vars.head!])\n  let result := solve expr\n  validateResult result ∧\n  (∀ v ∈ vars, result.data.contains v) :=\nsorry\n\ntheorem arbitrary_expressions_theorem (expr : String)\n  (h1 : expr.length ≥ 1)\n  (h2 : expr.length ≤ 20)\n  (h3 : ∀ c ∈ expr.data, c = 'x' ∨ c = 'y' ∨ c = 'z' ∨ c = '(' ∨ c = ')' ∨ c = '+' ∨ c = '-')\n  (h4 : isBalanced expr) :\n  let result := solve expr\n  validateResult result ∧\n  (∀ c ∈ result.data, c.isAlpha → c ∈ expr.data) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'x-y-z'\n-/\n#guard_msgs in\n#eval solve \"x-(y+z)\"\n\n/-\ninfo: 'x-y+z'\n-/\n#guard_msgs in\n#eval solve \"x-(y-z)\"\n\n/-\ninfo: 'u-v+w+x+y-z'\n-/\n#guard_msgs in\n#eval solve \"u-(v-w-(x+y))-z\""}
{"id": "fvapps_002919", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_digits (n : Nat) : List Nat :=\nsorry\n\ndef is_narc (n : Nat) : Bool :=\nsorry\n\ndef is_narcissistic : List String → Bool :=\nsorry", "vc-theorems": "theorem get_digits_correct (n : Nat) :\n  get_digits n = (toString n).toList.map (fun c => c.toString.toNat!) :=\nsorry\n\ntheorem is_narc_sum_pow_digits (n : Nat) :\n  is_narc n = (n = ((get_digits n).map (fun d => d ^ (get_digits n).length)).foldl (· + ·) 0) :=\nsorry\n\ntheorem is_narcissistic_all (values : List String) :\n  is_narcissistic values = values.all (fun x =>\n    if let some n := x.toNat? then\n      is_narc n\n    else\n      false) :=\nsorry\n\ntheorem non_numeric_returns_false (s : String) :\n  ¬s.all Char.isDigit → ¬is_narcissistic [s] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_narcissistic 11\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic \"4\" 7 \"9\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic 407 8208"}
{"id": "fvapps_002922", "vc-description": "", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\ndef swap (l : List Int) (i j : Nat) (h1 : i < l.length) (h2 : j < l.length) : List Int :=\n  let arr := l.toArray\n  let tmp := arr[i]!\n  let arr := arr.set! i arr[j]!\n  let arr := arr.set! j tmp\n  arr.toList", "vc-helpers": "", "vc-definitions": "def count_inversions (lst : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem empty_list_zero_inversions :\n  count_inversions [] = 0 := by\n  sorry\n\ntheorem sorted_list_zero_inversions {lst : List Int} :\n  isSorted lst → count_inversions lst = 0 := by\n  sorry\n\ntheorem reversed_sorted_unique_inversions {lst : List Int} (h1 : List.Nodup lst) (h2 : isSorted lst) :\n  count_inversions (List.reverse lst) = (lst.length * (lst.length - 1)) / 2 := by\n  sorry\n\ntheorem single_swap_one_inversion {lst : List Int} (h1 : isSorted lst) (h2 : lst.length ≥ 2)\n  (h3 : lst[0]! ≠ lst[1]!)\n  (h4 : 0 < lst.length) (h5 : 1 < lst.length) :\n  count_inversions (swap lst 0 1 h4 h5) = 1 := by\n  sorry\n\ntheorem count_always_non_negative (lst : List Int) :\n  count_inversions lst ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[1, 2, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_inversions #[2, 1, 3]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 2, 1]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 3, 3, 3, 2, 1]"}
{"id": "fvapps_002925", "vc-description": "", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def list_minimum (lst : List Int) : Int :=\nsorry\n\ndef array_center (lst : List Int) : List Int :=\nsorry\n\ndef mean (lst : List Int) : Int :=\nsorry\n\ndef list_index_of (lst : List Int) (x : Int) : Nat :=\nsorry", "vc-theorems": "theorem array_center_is_subset {lst : List Int} (h : lst ≠ []) :\n  ∀ x, x ∈ array_center lst → x ∈ lst :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [4, 5]\n-/\n#guard_msgs in\n#eval array_center [8, 3, 4, 5, 2, 8]\n\n/-\ninfo: [1, 2, 1]\n-/\n#guard_msgs in\n#eval array_center [1, 3, 2, 1]\n\n/-\ninfo: [10, 11, 12, 13, 14]\n-/\n#guard_msgs in\n#eval array_center [10, 11, 12, 13, 14]"}
{"id": "fvapps_002926", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\nsorry\n\ndef sqrt (n : Int) : Int :=\nsorry\n\ndef big_primefac_div (n : Int) : Option (Int × Int) :=\nsorry\n\ndef abs (n : Int) : Int :=\nsorry\n\ndef isInteger (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem big_primefac_div_int_valid {n : Int}\n  (h : 2 ≤ n) (h2 : n ≤ 10^6) :\n  if isInteger n then\n    match big_primefac_div n with\n    | none => True\n    | some (p, d) => p > 0 ∧ d > 0\n  else\n    big_primefac_div n = none :=\nsorry\n\ntheorem big_primefac_div_valid_pos_int {n : Int}\n  (h : 2 ≤ n) (h2 : n ≤ 10^6) :\n  match big_primefac_div n with\n  | none => ∀ i, 2 ≤ i → i ≤ sqrt n → ¬(n % i = 0)\n  | some (p, d) =>\n    1 < p ∧ 1 < d ∧\n    n % p = 0 ∧ n % d = 0 :=\nsorry\n\ntheorem big_primefac_div_neg {n : Int}\n  (h : -10^6 ≤ n) (h2 : n ≤ -2) :\n  big_primefac_div n = big_primefac_div (abs n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [5, 50]\n-/\n#guard_msgs in\n#eval big_primefac_div 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval big_primefac_div 997\n\n/-\ninfo: [5, 900]\n-/\n#guard_msgs in\n#eval big_primefac_div -1800.0"}
{"id": "fvapps_002928", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def squares : Nat → List Nat\n| n =>\nsorry\n\ndef num_range : Nat → Int → Int → List Int\n| n, start, step =>\nsorry\n\ndef rand_range : Nat → Int → Int → List Int\n| n, mn, mx =>\nsorry\n\ndef primes : Nat → List Nat\n| n =>\nsorry", "vc-theorems": "theorem squares_length (n : Nat) : (squares n).length = n := by\n  sorry\n\ntheorem squares_values (n : Nat) (i : Nat) :\n  i < n → (squares n).get ⟨i, sorry⟩ = (i + 1) * (i + 1) := by\n  sorry\n\ntheorem num_range_length (n : Nat) (start step : Int) :\n  (num_range n start step).length = n := by\n  sorry\n\ntheorem num_range_start (n : Nat) (start step : Int) :\n  n > 0 → (num_range n start step).get ⟨0, sorry⟩ = start := by\n  sorry\n\ntheorem num_range_step (n : Nat) (start step : Int) :\n  n > 1 → (num_range n start step).get ⟨1, sorry⟩ - (num_range n start step).get ⟨0, sorry⟩ = step := by\n  sorry\n\ntheorem rand_range_length (n : Nat) (mn mx : Int) :\n  mn ≤ mx → (rand_range n mn mx).length = n := by\n  sorry\n\ntheorem rand_range_bounds (n : Nat) (mn mx : Int) (i : Nat) :\n  mn ≤ mx → i < n →\n  mn ≤ (rand_range n mn mx).get ⟨i, sorry⟩ ∧ (rand_range n mn mx).get ⟨i, sorry⟩ ≤ mx := by\n  sorry\n\ntheorem primes_length (n : Nat) :\n  (primes n).length = n := by\n  sorry\n\ntheorem primes_ordered (n : Nat) (i : Nat) :\n  n > 0 → i < n - 1 →\n  (primes n).get ⟨i, sorry⟩ < (primes n).get ⟨i + 1, sorry⟩ := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1, 4, 9, 16, 25]\n-/\n#guard_msgs in\n#eval squares 5\n\n/-\ninfo: [1, 4, 9]\n-/\n#guard_msgs in\n#eval squares 3\n\n/-\ninfo: [0, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval num_range 5 0 1\n\n/-\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval num_range 3 2 2\n\n/-\ninfo: [2, 3, 5, 7, 11]\n-/\n#guard_msgs in\n#eval primes 5"}
{"id": "fvapps_002930", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def polydivisible (n : Nat) : Bool :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef take_prefix (n : Nat) (len : Nat) : Nat :=\nsorry", "vc-theorems": "theorem polydivisible_characterization {n : Nat} :\n  polydivisible n ↔\n  (∀ i : Nat, i > 0 ∧ i ≤ (digits n).length →\n    take_prefix n i % i = 0) :=\nsorry\n\ntheorem single_digit_polydivisible {n : Nat} :\n  n > 0 ∧ n < 10 → polydivisible n :=\nsorry\n\ntheorem polydivisible_positive {n : Int} :\n  n ≤ 0 → polydivisible n.toNat = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 1232\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval polydivisible 123220\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 987654"}
{"id": "fvapps_002934", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef canBePalindromeWithOneRemoval (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem solve_result_valid (s : String) :\n  solve s = \"OK\" ∨ solve s = \"remove one\" ∨ solve s = \"not possible\" :=\nsorry\n\ntheorem ok_means_palindrome (s : String) :\n  solve s = \"OK\" → isPalindrome s :=\nsorry\n\ntheorem remove_one_means_possible_palindrome (s : String) :\n  solve s = \"remove one\" → canBePalindromeWithOneRemoval s :=\nsorry\n\ntheorem not_possible_means_neither (s : String) :\n  solve s = \"not possible\" → ¬isPalindrome s ∧ ¬canBePalindromeWithOneRemoval s :=\nsorry\n\ntheorem solve_symmetric (s : String) :\n  solve s = solve (reverse s) :=\nsorry\n\ntheorem single_char_ok (s : String) :\n  s.length = 1 → solve s = \"OK\" :=\nsorry\n\ntheorem two_chars_property (s : String) (h : s.length = 2) :\n  (s.front = s.back → solve s = \"OK\") ∧\n  (s.front ≠ s.back → solve s = \"remove one\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'OK'\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: 'remove one'\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/-\ninfo: 'not possible'\n-/\n#guard_msgs in\n#eval solve \"abbaab\""}
{"id": "fvapps_002938", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def omit_hashtag (message : String) (hashtag : String) : String :=\nsorry\n\ndef String.count (s t : String) : Nat :=\nsorry\n\ndef String.containsSubstring (s t : String) : Bool :=\nsorry", "vc-theorems": "theorem omit_hashtag_length (message hashtag : String) :\n  String.length (omit_hashtag message hashtag) ≤ String.length message :=\nsorry\n\ntheorem omit_hashtag_unchanged (message hashtag : String) :\n  ¬(String.containsSubstring message hashtag) → omit_hashtag message hashtag = message :=\nsorry\n\ntheorem omit_hashtag_count (message hashtag : String) (h1 : hashtag ≠ \"\")\n  (h2 : String.count message hashtag > 1) :\n  String.count (omit_hashtag message hashtag) hashtag = String.count message hashtag - 1 :=\nsorry\n\ntheorem omit_empty_hashtag (message : String) :\n  omit_hashtag message \"\" = message :=\nsorry\n\ntheorem omit_from_empty_message (hashtag : String) (h1 : hashtag ≠ \"\") :\n  omit_hashtag \"\" hashtag = \"\" :=\nsorry\n\ntheorem omit_hashtag_not_found (message hashtag : String)\n  (h1 : message ≠ \"\") (h2 : hashtag ≠ \"\") :\n  ¬(String.containsSubstring message hashtag) → omit_hashtag message hashtag = message :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sunny day!  #vvv'\n-/\n#guard_msgs in\n#eval omit_hashtag \"Sunny day! #lta #vvv\" \"#lta\"\n\n/-\ninfo: ' #picture_contest'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest\" \"#lta\"\n\n/-\ninfo: ' #picture_contest #lta'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest #lta\" \"#lta\""}
{"id": "fvapps_002947", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome (s : String) : Bool :=\nsorry\n\ndef isPalindromePair (s1 s2 : String) : Bool :=\nsorry\n\ndef palindromePairs (words : List String) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem palindrome_pairs_valid_indices\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ pair, pair ∈ result →\n    pair.1 < words.length ∧\n    pair.2 < words.length ∧\n    pair.1 ≠ pair.2 :=\nsorry\n\ntheorem palindrome_pairs_forms_palindrome\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ pair, pair ∈ result →\n    palindrome (words[pair.1]! ++ words[pair.2]!) :=\nsorry\n\ntheorem palindrome_pairs_complete\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ i j, i < words.length → j < words.length → i ≠ j →\n    palindrome (words[i]! ++ words[j]!) →\n    (i,j) ∈ result :=\nsorry\n\ntheorem palindrome_pairs_unique\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ p1 p2, p1 ∈ result → p2 ∈ result → p1 = p2 ∨ p1.1 ≠ p2.1 ∨ p1.2 ≠ p2.2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [[0, 1], [1, 0]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"bat\", \"tab\", \"cat\"]\n\n/-\ninfo: [[0, 3], [2, 4], [3, 0], [4, 2]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"dog\", \"cow\", \"tap\", \"god\", \"pat\"]\n\n/-\ninfo: [[0, 4], [1, 2], [2, 1]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [5777, \"dog\", \"god\", True, 75]"}
{"id": "fvapps_002954", "vc-description": "", "vc-preamble": "structure MultiTableOutput where\n  lines : List String\n  deriving Inhabited", "vc-helpers": "", "vc-definitions": "def multiTable (n : Nat) : String :=\nsorry\n\ndef String.count_spaces (s : String) : Nat :=\nsorry\n\ndef parseMultiTable (s : String) : MultiTableOutput :=\nsorry", "vc-theorems": "theorem multi_table_length (n : Nat) (h : n > 0) :\n  (parseMultiTable (multiTable n)).lines.length = 10 :=\nsorry\n\ntheorem multi_table_format (n : Nat) (h : n > 0) (i : Nat) (h2 : i > 0 ∧ i ≤ 10) :\n  let output := parseMultiTable (multiTable n)\n  let line := output.lines[i-1]!\n  ∃ num1 num2 result : String,\n    line = num1 ++ \" * \" ++ num2 ++ \" = \" ++ result ∧\n    String.toNat! num1 = i ∧\n    String.toNat! num2 = n ∧\n    String.toNat! result = i * n :=\nsorry\n\ntheorem multi_table_no_trailing_newline (n : Nat) (h : n > 0) :\n  let s := multiTable n\n  s.length > 0 ∧ s.data[s.length - 1]! ≠ '\\n' :=\nsorry\n\ntheorem multi_table_spacing (n : Nat) (h : n > 0) (line : String)\n  (h2 : line ∈ (parseMultiTable (multiTable n)).lines) :\n  line.count_spaces = 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 * 5 = 5\\n2 * 5 = 10\\n3 * 5 = 15\\n4 * 5 = 20\\n5 * 5 = 25\\n6 * 5 = 30\\n7 * 5 = 35\\n8 * 5 = 40\\n9 * 5 = 45\\n10 * 5 = 50'\n-/\n#guard_msgs in\n#eval multi_table 5\n\n/-\ninfo: '1 * 1 = 1\\n2 * 1 = 2\\n3 * 1 = 3\\n4 * 1 = 4\\n5 * 1 = 5\\n6 * 1 = 6\\n7 * 1 = 7\\n8 * 1 = 8\\n9 * 1 = 9\\n10 * 1 = 10'\n-/\n#guard_msgs in\n#eval multi_table 1\n\n/-\ninfo: '1 * 3 = 3\\n2 * 3 = 6\\n3 * 3 = 9\\n4 * 3 = 12\\n5 * 3 = 15\\n6 * 3 = 18\\n7 * 3 = 21\\n8 * 3 = 24\\n9 * 3 = 27\\n10 * 3 = 30'\n-/\n#guard_msgs in\n#eval multi_table 3"}
{"id": "fvapps_002963", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def vowel (c : Char) : Bool :=\nsorry\n\ndef solve (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_all_vowels (s : String)\n  (h₁ : s.length > 0)\n  (h₂ : ∀ c ∈ s.data, vowel c = true) :\n  solve s = s.length :=\nsorry\n\ntheorem solve_interspersed\n  (vowels : List String)\n  (consonants : List String)\n  (h₁ : vowels.length > 0)\n  (h₂ : ∀ s ∈ vowels, s.length > 0)\n  (h₃ : ∀ s ∈ vowels, ∀ c ∈ s.data, vowel c = true)\n  (h₄ : ∀ s ∈ consonants, ∀ c ∈ s.data, vowel c = false) :\n  let combined := List.zip vowels consonants\n  let s := String.join (combined.map (fun p => p.1 ++ p.2))\n  solve s ≥ (List.foldl (fun acc x => max acc x.length) 0 vowels) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002964", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_lucky (n : Nat) : Bool :=\n  sorry\n\ndef sum_of_digits (n : Nat) : Nat :=\n  sorry\n\ndef concat_digits (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem lucky_digit_sum_property (n : Nat) :\n  is_lucky n = (sum_of_digits n = 0 ∨ sum_of_digits n % 9 = 0) :=\nsorry\n\ntheorem lucky_concatenation (n : Nat) :\n  is_lucky n → (\n    is_lucky (concat_digits n 9) ∧\n    is_lucky (concat_digits n 99)\n  ) :=\nsorry\n\ntheorem lucky_edge_cases :\n  is_lucky 0 ∧ is_lucky 9 ∧ is_lucky 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 1892376\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_lucky 189237\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 0"}
{"id": "fvapps_002966", "vc-description": "", "vc-preamble": "def Room := (String × Nat)\n\ndef listSum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + listSum xs\n\ndef listAll : List Nat → (Nat → Bool) → Bool\n  | [], _ => true\n  | x::xs, p => p x && listAll xs p", "vc-helpers": "", "vc-definitions": "def meeting (rooms : List Room) (need : Nat) : String ⊕ List Nat :=\nsorry", "vc-theorems": "theorem meeting_zero_need {rooms : List Room} :\n  meeting rooms 0 = Sum.inl \"Game On\" :=\nsorry\n\ntheorem meeting_huge_need {rooms : List Room} {need : Nat} :\n  (need > listSum (rooms.map (fun r => max (r.2 - r.1.length) 0))) →\n  meeting rooms need = Sum.inl \"Not enough!\" :=\nsorry\n\ntheorem meeting_valid_solution {rooms : List Room} {need : Nat} {result : List Nat} :\n  meeting rooms need = Sum.inr result →\n  (\n    (result.length ≤ rooms.length) ∧\n    (listAll result (fun x => x ≥ 0)) ∧\n    (listSum result = need) ∧\n    (rooms.zip result).all (fun p =>\n      let room := p.1\n      let taken := p.2\n      taken ≤ max (room.2 - room.1.length) 0\n    )\n  ) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1, 3]\n-/\n#guard_msgs in\n#eval meeting [[\"XXX\", 3], [\"XXXXX\", 6], [\"XXXXXX\", 9]] 4\n\n/-\ninfo: 'Game On'\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 0\n\n/-\ninfo: [0, 2]\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 2"}
{"id": "fvapps_002970", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_exponent (n p : Int) : Option Int :=\n  sorry\n\ndef pow (x y : Int) : Int :=\n  sorry", "vc-theorems": "theorem get_exponent_divides {n p : Int} (h1 : n ≥ 2) (h2 : p ≥ 2) :\n  match get_exponent n p with\n  | none => False\n  | some k =>\n    (k = 0 → n % p ≠ 0) ∧\n    (k > 0 → n % (pow p k) = 0 ∧ n % (pow p (k + 1)) ≠ 0)\n  :=\nsorry\n\ntheorem get_exponent_nonnegative {n p : Int} (h1 : n ≥ 2) (h2 : p ≥ 2) :\n  match get_exponent n p with\n  | none => False\n  | some k => k ≥ 0\n  :=\nsorry\n\ntheorem get_exponent_invalid_divisor {n p : Int} (h : p ≤ 1) :\n  get_exponent n p = none :=\nsorry\n\ntheorem get_exponent_prime_power {n p : Int} (h1 : n ≥ 2) (h2 : p = 2) :\n  get_exponent (n * (pow p 5)) p = Option.some ((get_exponent n p).getD 0 + 5) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_exponent 27 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_exponent 28 2\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval get_exponent 10 0"}
{"id": "fvapps_002972", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Count of chars with odd occurrences -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome_rearranging (s : String) : Bool :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry\n\ndef String.repeating (c : Char) (n : Nat) : String :=\n  sorry\n\ndef odd_char_count (s : String) : Nat :=\nsorry", "vc-theorems": "theorem palindrome_rearranging_symmetry (s : String) :\n  palindrome_rearranging s = palindrome_rearranging (String.reverse s) :=\nsorry\n\ntheorem palindrome_rearranging_duplicates (s : String) (h : s.length > 0) :\n  palindrome_rearranging (s ++ s) = true :=\nsorry\n\ntheorem palindrome_rearranging_single_char (s : String) (h : s.length > 0) (c : Char) :\n  palindrome_rearranging (String.repeating c s.length) = true :=\nsorry\n\ntheorem palindrome_rearranging_empty_and_single (s : String) (h : s.length ≤ 1) :\n  palindrome_rearranging s = true :=\nsorry\n\ntheorem palindrome_rearranging_odd_counts (s : String) :\n  palindrome_rearranging s = (odd_char_count s ≤ 1) :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aabb\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"abbcabb\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aaabbb\""}
{"id": "fvapps_002975", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def divisible_by_three (s : String) : Bool :=\n  sorry\n\ndef digit_sum (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem divisible_by_three_matches_mod (n : Nat) :\n  divisible_by_three (toString n) = (n % 3 = 0) :=\nsorry\n\ntheorem divisible_by_three_digit_sum (n : Nat) :\n  divisible_by_three (toString n) = (digit_sum (toString n) % 3 = 0) :=\nsorry\n\ntheorem append_zeros_preserves_divisibility (n : Nat) (k : Nat) (h : 0 < k ∧ k ≤ 10) :\n  divisible_by_three (toString n ++ String.mk (List.replicate k '0')) =\n  divisible_by_three (toString n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"123\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval divisible_by_three \"88\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"963210456\""}
{"id": "fvapps_002977", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def uniqueDigitProducts (nums : List Nat) : Nat :=\n  sorry\n\ndef List.toSet (l : List α) : List α :=\n  sorry", "vc-theorems": "theorem uniqueDigitProducts_bounds_nat {nums : List Nat} (h : nums.length > 0) :\n  1 ≤ uniqueDigitProducts nums ∧ uniqueDigitProducts nums ≤ nums.length :=\nsorry\n\ntheorem uniqueDigitProducts_single_digits {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n ≤ 9) :\n  uniqueDigitProducts nums ≤ (List.toSet nums).length :=\nsorry\n\ntheorem uniqueDigitProducts_all_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n = 0) :\n  uniqueDigitProducts nums = 1 :=\nsorry\n\ntheorem uniqueDigitProducts_three_digit_no_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, 100 ≤ n ∧ n ≤ 999)\n  (h3 : ∀ n ∈ nums, ¬ toString n = \"0\") :\n  uniqueDigitProducts nums > 0 :=\nsorry\n\ntheorem uniqueDigitProducts_permutation {nums : List Nat}\n  (h : nums.length > 1) :\n  let n := nums[0]\n  let nums_with_perm := n :: nums\n  uniqueDigitProducts nums_with_perm ≥ uniqueDigitProducts nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval unique_digit_products [2, 8, 121, 42, 222, 23]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval unique_digit_products [239]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval unique_digit_products [100, 101, 111]"}
{"id": "fvapps_002983", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def roundIt (x : Float) : Int :=\nsorry\n\ndef floor (x : Float) : Int :=\nsorry\n\ndef ceil (x : Float) : Int :=\nsorry\n\ndef floatToStr (x : Float) : String :=\nsorry", "vc-theorems": "theorem round_it_decimals (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) <\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = ceil x :=\nsorry\n\ntheorem round_it_decimals_floor (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) >\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = floor x :=\nsorry\n\ntheorem round_it_decimals_equal_length (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) =\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = if x > 0 then ceil x else floor x :=\nsorry\n\ntheorem round_it_integers (n : Int) :\n  roundIt (Float.ofInt n) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval round_it 3.45\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval round_it 34.5\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval round_it 34.56"}
{"id": "fvapps_002988", "vc-description": "", "vc-preamble": "def iterativeReplace (s : String) (n : Nat) : String :=\n  match n with\n  | 0 => s\n  | n + 1 =>\n    if containsSubstr s \"797\"\n    then iterativeReplace (s.replace \"797\" \"77\") n\n    else s", "vc-helpers": "", "vc-definitions": "def seven_ate9 (s : String) : String :=\n  sorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\n  sorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\n  sorry", "vc-theorems": "theorem output_is_string {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).all (fun c => c.isDigit) :=\nsorry\n\ntheorem output_length_correct {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).length = s.length - (countSubstr s \"797\") :=\nsorry\n\ntheorem no_797_in_result {s : String} :\n  s.all (fun c => c.isDigit) →\n  ¬(containsSubstr (seven_ate9 s) \"797\") :=\nsorry\n\ntheorem only_797_modified {s : String} :\n  s.all (fun c => c.isDigit) →\n  seven_ate9 s = iterativeReplace s s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '7712312'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79712312\"\n\n/-\ninfo: '777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79797\"\n\n/-\ninfo: '7777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"7979797\""}
{"id": "fvapps_003000", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.toString (n : Nat) : String :=\n  sorry\n\ndef is_even (n : Nat) : Bool :=\n  sorry\n\ndef List.sort {α : Type} [Ord α] (as : List α) : List α :=\n  sorry\n\ndef even_digit_squares (start : Nat) (stop : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem is_even_matches_digit_check (x : Nat) :\n  is_even x = (Nat.toString x |>.data |>.all (fun d => (Char.toNat d - 48) % 2 = 0)) :=\nsorry\n\ntheorem even_digit_squares_properties {a b : Nat}\n  (h : a ≤ 1000000 ∧ b ≤ 1000000) :\n  let start := min a b\n  let stop := max a b\n  let result := even_digit_squares start stop\n  (∀ x ∈ result, x ≥ start ∧ x ≤ stop) ∧\n  (∀ x ∈ result, is_even x = true) ∧\n  (∀ x ∈ result, ∃ y:Nat, y * y = x) ∧\n  (result = List.sort result) :=\nsorry\n\ntheorem single_point_range {x : Nat} (h : x ≤ 1000000) :\n  let result := even_digit_squares x x\n  result ≠ [] →\n  (result.length = 1 ∧\n   result.head! = x ∧\n   is_even x = true ∧\n   ∃ y:Nat, y * y = x) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003004", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multi (l : List Int) : Int :=\nsorry\n\ndef add (l : List Int) : Int :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem multi_neutral (l : List Int) (h : l.length ≥ 1) :\n  multi (l ++ [1]) = multi l :=\nsorry\n\ntheorem multi_order_indep (l : List Int) (h : l.length ≥ 1) :\n  multi l = multi l.reverse :=\nsorry\n\ntheorem add_neutral (l : List Int) :\n  add (l ++ [0]) = add l :=\nsorry\n\ntheorem add_order_indep (l : List Int) :\n  add l = add l.reverse :=\nsorry\n\ntheorem add_recursive (l : List Int) (h : l ≠ []) :\n  add l = add (l.take (l.length - 1)) + l.getLast h :=\nsorry\n\ntheorem reverse_involution (s : String) :\n  reverse (reverse s) = s :=\nsorry\n\ntheorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :=\nsorry\n\ntheorem reverse_first_last_char (s : String) (h₁ : s.length > 0) :\n  let n := s.length\n  let rs := reverse s\n  rs.front = s.back ∧ rs.back = s.front :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 80\n-/\n#guard_msgs in\n#eval multi [8, 2, 5]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval add [1, 2, 3]\n\n/-\ninfo: 'olleh'\n-/\n#guard_msgs in\n#eval reverse \"hello\""}
{"id": "fvapps_003009", "vc-description": "/-\n  Main property theorems\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  Pattern theorems\n-/\n\n-- For n > 1, removing leading '1' from binary representation and appending '1'", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def circle_slash (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem circle_slash_range (n : Nat) (h : n > 0) :\n  1 ≤ circle_slash n ∧ circle_slash n ≤ n :=\nsorry\n\ntheorem circle_slash_odd_unless_power_of_two (n : Nat) (h : n > 0)\n  (h_not_power_2 : ¬∃k, n = 2^k) :\n  circle_slash n % 2 = 1 :=\nsorry\n\ntheorem circle_slash_power_of_two (k : Nat) :\n  circle_slash (2^k) = 1 :=\nsorry\n\ntheorem circle_slash_binary_pattern (n : Nat) (h : n > 1) :\n\n  circle_slash n = (n % (2^(Nat.log2 n))) * 2 + 1 :=\nsorry\n\ntheorem circle_slash_one :\n  circle_slash 1 = 1 :=\nsorry", "vc-postamble": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval circle_slash 5\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval circle_slash 11\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval circle_slash 16"}
{"id": "fvapps_003019", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome (n : Int) : String :=\nsorry\n\ndef isNumericPalindrome (n : Int) : Bool :=\nsorry\n\ndef contains (haystack : String) (needle : String) : Bool :=\nsorry\n\ndef stringToInt (s : String) : Option Int :=\nsorry", "vc-theorems": "theorem invalid_input_negative (n : Int) :\n  n < 0 → palindrome n = \"Not valid\"\n  :=\nsorry\n\ntheorem valid_input_contains_palindromes (n : Int) :\n  n ≥ 0 → palindrome n ≠ \"Not valid\" →\n  let result := palindrome n\n  let numStr := toString n\n  ∀ p ∈ result.split (· = ','),\n    (∃ s : String, s = p ∧ contains numStr s ∧\n      match stringToInt s with\n      | some i => isNumericPalindrome i\n      | none => false)\n  :=\nsorry\n\ntheorem valid_input_sorted_results (n : Int) :\n  n ≥ 0 → palindrome n ≠ \"Not valid\" →\n  let result := palindrome n\n  let nums := result.split (· = ',')\n  ∀ i j, i < j → j < nums.length →\n    match stringToInt (nums.get! i), stringToInt (nums.get! j) with\n    | some x, some y => x ≤ y\n    | _, _ => true\n  :=\nsorry\n\ntheorem no_palindromes_when_none_exist (n : Int) (numStr : String := toString n) :\n  n ≥ 0 →\n  (∀ s : String, contains numStr s →\n    match stringToInt s with\n    | some i => ¬isNumericPalindrome i\n    | none => true) →\n  palindrome n = \"No palindromes found\"\n  :=\nsorry\n\ntheorem invalid_input_float (f : Float) :\n  palindrome 0 = \"Not valid\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [22, 212, 343, 22122]\n-/\n#guard_msgs in\n#eval palindrome 34322122\n\n/-\ninfo: 'No palindromes found'\n-/\n#guard_msgs in\n#eval palindrome 1294\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome -123"}
{"id": "fvapps_003021", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_and_max (l d x : Nat) : List Nat :=\n  sorry\n\ndef sum_of_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_and_max_properties {l d x : Nat}\n  (h1: l ≤ d)\n  (h2: l > 0)\n  (h3: d ≤ 1000)\n  (h4: x ≤ 27)\n  (h5: ∃ n, l ≤ n ∧ n ≤ d ∧ sum_of_digits n = x) :\n  let result := min_and_max l d x\n  List.length result = 2 ∧\n  result[0]! ≤ result[1]! ∧\n  l ≤ result[0]! ∧ result[0]! ≤ d ∧\n  l ≤ result[1]! ∧ result[1]! ≤ d ∧\n  sum_of_digits result[0]! = x ∧\n  sum_of_digits result[1]! = x :=\nsorry\n\ntheorem min_and_max_identical_bounds {n : Nat}\n  (h1: n > 0)\n  (h2: n ≤ 1000) :\n  let x := sum_of_digits n\n  let result := min_and_max n n x\n  result[0]! = n ∧ result[1]! = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [109, 190]\n-/\n#guard_msgs in\n#eval min_and_max 100 200 10\n\n/-\ninfo: [505, 505]\n-/\n#guard_msgs in\n#eval min_and_max 500 505 10\n\n/-\ninfo: [104, 500]\n-/\n#guard_msgs in\n#eval min_and_max 99 501 5"}
{"id": "fvapps_003022", "vc-description": "-- Define the special case", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def trotter (n: Int) : Int :=\nsorry\n\ndef isInsomnia (n: Int) : Bool :=\nsorry", "vc-theorems": "theorem trotter_positive_multiple {n : Int} (h : n > 0) :\n  ∃ k : Int, trotter n = n * k ∧ k > 0 :=\nsorry\n\ntheorem trotter_zero :\n  isInsomnia (trotter 0) = true :=\nsorry\n\ntheorem trotter_nonzero {n : Int} (h : n > 0) :\n  trotter n > 0 :=\nsorry\n\ntheorem trotter_grows {n : Int} (h : n > 0) :\n  trotter n ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5076\n-/\n#guard_msgs in\n#eval trotter 1692\n\n/-\ninfo: 90\n-/\n#guard_msgs in\n#eval trotter 2\n\n/-\ninfo: 'INSOMNIA'\n-/\n#guard_msgs in\n#eval trotter 0"}
{"id": "fvapps_003024", "vc-description": "-- Theorem stating result is a single digit if not None\n\n-- Theorem stating if result exists, it must appear last in sequence\n\n-- Theorem for None case - either powers stabilize or never complete", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits_of (n : Nat) : List Nat :=\nsorry\n\ndef digit_sequence_of_powers (n : Nat) : List Nat :=\nsorry\n\ndef last_digit_to_appear (n : Nat) : Option Nat :=\nsorry", "vc-theorems": "theorem result_is_single_digit {n d : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = some d) :\n  0 ≤ d ∧ d ≤ 9 :=\nsorry\n\ntheorem appears_last {n d : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = some d)\n  (digits : List Nat)\n  (nonempty : digits ≠ [])\n  (valid_digits : ∀ x, x ∈ digits → x ≤ 9)\n  (is_sequence : digits = digit_sequence_of_powers n)\n  (h_len : digits.length > 0) :\n  d = digits[digits.length - 1]'(Nat.sub_lt h_len (by exact Nat.zero_lt_one)) :=\nsorry\n\ntheorem none_result_characterization {n : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = none) :\n  (∀ k : Nat, k > 1 → digits_of (n^k) = digits_of n) ∨\n  (∃ x : Nat, x ≤ 9 ∧ ∀ k : Nat, k ≤ 100 → x ∉ digits_of (n^k)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 8\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval last_digit_to_appear 100"}
{"id": "fvapps_003026", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_bill (s : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem total_bill_nonnegative (s : String) :\n  total_bill s ≥ 0 :=\nsorry\n\ntheorem total_bill_even (s : String) :\n  total_bill s % 2 = 0 :=\nsorry\n\ntheorem total_bill_spaces (s : String) :\n  total_bill s = total_bill (s.replace \" \" \"\") :=\nsorry\n\ntheorem total_bill_repeated (n : Nat) (s : String) :\n  s = String.mk (List.replicate n 'r') →\n  total_bill s = 2 * (n - n/5) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval total_bill \"rr\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval total_bill \"rr rrr\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval total_bill \"rrrrr rrrrr\""}
{"id": "fvapps_003027", "vc-description": "", "vc-preamble": "def Matrix (α : Type) [BEq α] := List (List α)", "vc-helpers": "", "vc-definitions": "def is_valid_matrix {α : Type} [BEq α] (m : Matrix α) : Bool :=\nsorry\n\ndef rotate_against_clockwise {α : Type} [BEq α] (m : Matrix α) (times : Nat) : Matrix α :=\nsorry\n\ndef get_matrix_dimensions {α : Type} [BEq α] (m : Matrix α) : Nat × Nat :=\nsorry", "vc-theorems": "theorem dimensions_preserved {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  let dims := get_matrix_dimensions m\n  get_matrix_dimensions (rotate_against_clockwise m 1) = dims :=\nsorry\n\ntheorem rotation_modulo {α : Type} [BEq α] (m : Matrix α) (times : Nat) :\n  is_valid_matrix m →\n  rotate_against_clockwise m times = rotate_against_clockwise m (times % 4) :=\nsorry\n\ntheorem four_rotations_identity {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  rotate_against_clockwise m 4 = m :=\nsorry\n\ntheorem single_column_dimensions {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  (∀ (row : List α), List.elem row m → List.length row = 1) →\n  let rotated := rotate_against_clockwise m 1\n  List.length rotated = List.length (List.head! m) ∧\n  ∀ (row : List α), List.elem row rotated → List.length row = List.length m :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2], [3, 4]] 1\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] 1\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval rotate_against_clockwise matrix2 2"}
{"id": "fvapps_003029", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Sum of empty nested lists is zero -/\n\n/- Sum of singleton list equals its element -/\n\n/- Sum of nested lists equals the sum of flattened list -/", "vc-preamble": "def listSum : List Int → Int\n  | [] => 0\n  | h :: t => h + listSum t", "vc-helpers": "", "vc-definitions": "def sumNested : List (List Int) → Int\n  | _ =>\nsorry\n\ndef flatten : List (List Int) → List Int\n  | _ =>\nsorry", "vc-theorems": "theorem sum_nested_equals_flatten_sum (l : List (List Int)) :\n  sumNested l = listSum (flatten l) := by\n  sorry\n\ntheorem sum_nested_empty_lists (l : List (List Int)) (h : ∀ x ∈ l, x = []) :\n  sumNested l = 0 := by\n  sorry\n\ntheorem sum_nested_singleton (n : Int) :\n  sumNested [[n]] = n := by\n  sorry", "vc-postamble": "/-\ninfo: 10\n-/\n#guard_msgs in\n#eval sum_nested [1, [2, [3, [4]]]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_nested [[[], []]]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval sum_nested [1, [1], [1, [1]], [1, [1], [1, [1]]]]"}
{"id": "fvapps_003034", "vc-description": "-- Properties for stairs function\n\n-- Properties for step function\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def stairs (n : Int) : String :=\nsorry\n\ndef step (n : Int) : String :=\nsorry\n\ndef splitLines (s : String) : List String :=\nsorry\n\ndef rightJustify (s : String) (width : Int) : String :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef listToString (l : List Nat) : String :=\nsorry\n\ndef stringContains (s : String) (c : Char) : Prop :=\nsorry", "vc-theorems": "theorem stairs_empty_for_invalid_input (n : Int) :\n  n < 1 → stairs n = \" \" :=\nsorry\n\ntheorem stairs_line_count (n : Int) :\n  n ≥ 1 → (splitLines (stairs n)).length = n.toNat :=\nsorry\n\ntheorem stairs_line_width (n : Int) (line : String) :\n  n ≥ 1 → line ∈ splitLines (stairs n) → line.length ≤ (4 * n - 1).toNat :=\nsorry\n\ntheorem stairs_right_justified (n : Int) (line : String) :\n  n ≥ 1 → line ∈ splitLines (stairs n) →\n  line = rightJustify line (4 * n - 1) :=\nsorry\n\ntheorem step_length_correct (n : Int) :\n  n ≥ 1 → (splitLines (step n)).length = (2 * n - 1).toNat :=\nsorry\n\ntheorem step_digits_only (n : Int) (c : Char) :\n  n ≥ 1 → stringContains (step n) c → isDigit c ∨ c = ' ' :=\nsorry\n\ntheorem step_sequence (n : Int) (i : Nat) :\n  n ≥ 1 → i < n.toNat →\n  let nums := splitLines (step n);\n  let expected := toString ((i + 1) % 10);\n  nums.get? i = some expected :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003035", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def berserk_rater (synopsis : List String) : String :=\n  sorry\n\ndef score (s : String) : Int :=\n  sorry\n\ndef String.hasSubstring (s₁ s₂ : String) : Bool :=\n  sorry", "vc-theorems": "theorem berserk_rater_output_format (synopsis : List String) :\n  let result := berserk_rater synopsis\n  (result = \"worstest episode ever\" ∨ result = \"bestest episode ever\" ∨ String.all result Char.isDigit) :=\nsorry\n\ntheorem berserk_rater_score_boundaries (synopsis : List String) :\n  let result := berserk_rater synopsis\n  let score_sum := List.foldl (· + ·) 0 (List.map (fun s => score s.toUpper) synopsis)\n  (result = \"worstest episode ever\" → score_sum < 0) ∧\n  (result = \"bestest episode ever\" → score_sum > 10) ∧\n  (result ≠ \"worstest episode ever\" ∧ result ≠ \"bestest episode ever\" →\n    0 ≤ result.toNat! ∧ result.toNat! ≤ 10) :=\nsorry\n\ntheorem score_function_output (s : String) :\n  let result := score s.toUpper\n  (result = 5 ∨ result = -2 ∨ result = -1) ∧\n  (s.toUpper.hasSubstring \"CLANG\" → result = 5) ∧\n  (s.toUpper.hasSubstring \"CG\" → (¬s.toUpper.hasSubstring \"CLANG\" → result = -2)) ∧\n  (¬s.toUpper.hasSubstring \"CLANG\" ∧ ¬s.toUpper.hasSubstring \"CG\" → result = -1) :=\nsorry\n\ntheorem score_precedence_clang_over_cg :\n  score \"CLANGCG\" = 5 ∧ score \"CGCLANG\" = 5 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'worstest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"is this the CG from a P2 game?\", \"Hell, no! Even the CG in the Dreamcast game was more fluid than this!\", \"Well, at least Gatsu does his clang even against a mere rabbit\", \"Hey, Cosette was not in this part of the story!\", \"Ops, everybody dead again! Well, how boring...\"]\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Farnese unable to shut the fuck up\", \"awful CG dogs assaulting everybody\", \"Gatsu clanging the pig apostle!\"]\n\n/-\ninfo: 'bestest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Holy chain knights being dicks\", \"Serpico almost getting clanged by Gatsu, but without losing his composure\", \"lame CG\", \"Luka getting kicked\", \"Gatsu going clang against the angels\", \"Gatsu clanging vs Mozgus, big time!\"]"}
{"id": "fvapps_003051", "vc-description": "", "vc-preamble": "structure SegmentInfo where\n  letter : Char\n  stars : String", "vc-helpers": "", "vc-definitions": "def get_strings (s : String) : String :=\nsorry\n\ndef is_alpha (c : Char) : Bool :=\nsorry\n\ndef to_lower (c : Char) : Char :=\nsorry\n\ndef parse_segment (s : String) : Option SegmentInfo :=\nsorry", "vc-theorems": "theorem get_strings_format_valid (s : String) (h : s ≠ \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\"\n  ∀ part ∈ segments,\n  part ≠ \"\" →\n  match parse_segment part with\n  | some info =>\n    is_alpha info.letter ∧\n    ∀ c ∈ info.stars.data, c = '*'\n  | none => False :=\nsorry\n\ntheorem get_strings_count_matches_freq (s : String) (h : s ≠ \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\" |>.filter (·≠ \"\")\n  ∀ seg ∈ segments,\n  match parse_segment seg with\n  | some info =>\n    let count := s.data.filter (fun c => to_lower c = to_lower info.letter) |>.length\n    info.stars.length = count\n  | none => False :=\nsorry\n\ntheorem get_strings_empty :\n  get_strings \"\" = \"\" :=\nsorry\n\ntheorem get_strings_example :\n  get_strings \"Chicago\" = \"c:**,h:*,i:*,a:*,g:*,o:*\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'c:**,h:*,i:*,a:*,g:*,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Chicago\"\n\n/-\ninfo: 'b:*,a:*,n:*,g:*,k:**,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Bangkok\"\n\n/-\ninfo: 'l:*,a:**,s:**,v:*,e:*,g:*'\n-/\n#guard_msgs in\n#eval get_strings \"Las Vegas\""}
{"id": "fvapps_003054", "vc-description": "-- Theorem: If a string has no beach words, sum is 0\n\n-- Theorem: Output is always non-negative and bounded by string length", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfABeach (s : String) : Nat :=\n  sorry\n\ndef substringExists (s : String) (substr : String) : Bool :=\n  sorry", "vc-theorems": "theorem no_beach_words (s : String) :\n  (¬ substringExists s \"sand\" ∧ ¬ substringExists s \"SAND\") →\n  (¬ substringExists s \"water\" ∧ ¬ substringExists s \"WATER\") →\n  (¬ substringExists s \"fish\" ∧ ¬ substringExists s \"FISH\") →\n  (¬ substringExists s \"sun\" ∧ ¬ substringExists s \"SUN\") →\n  sumOfABeach s = 0 :=\nsorry\n\ntheorem output_range (s : String) :\n  sumOfABeach s ≥ 0 ∧ sumOfABeach s ≤ s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"WAtErSlIde\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"GolDeNSanDyWateRyBeaChSuNN\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"gOfIshsunesunFiSh\""}
{"id": "fvapps_003056", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reducePyramid (base : List Int) : Int :=\n  sorry\n\ndef referencePyramidReduce (base : List Int) : Int :=\n  sorry", "vc-theorems": "theorem matches_reference_implementation {base : List Int}\n  (h : base.length > 0 ∧ base.length ≤ 10) :\n  reducePyramid base = referencePyramidReduce base :=\nsorry\n\ntheorem single_element {base : List Int}\n  (h : base.length = 1) :\n  reducePyramid base = base.get ⟨0, sorry⟩ :=\nsorry\n\ntheorem two_elements {base : List Int}\n  (h : base.length = 2) :\n  reducePyramid base = base.get ⟨0, sorry⟩ + base.get ⟨1, sorry⟩ :=\nsorry\n\ntheorem singleton_list (x : Int) :\n  reducePyramid [x] = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval reduce_pyramid [1]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 5]\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 9, 4]"}
{"id": "fvapps_003059", "vc-description": "", "vc-preamble": "abbrev sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs\n\ndef filterWithIndex (l : List Nat) (p : Nat → Nat → Bool) : List Nat :=\n  let rec helper : List Nat → Nat → List Nat\n    | [], _ => []\n    | (x :: xs), i => if p i x then x :: helper xs (i+1) else helper xs (i+1)\n  helper l 0", "vc-helpers": "", "vc-definitions": "def SJF (jobs : List Nat) (index : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_job_returns_itself {jobs : List Nat} {job : Nat} (h : jobs = [job]) :\n  SJF jobs 0 = job :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval SJF [100] 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval SJF [3, 10, 20, 1, 2] 0\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval SJF [3, 10, 10, 20, 1, 2] 1"}
{"id": "fvapps_003060", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findPrimesSextuplet (limit : Nat) : List Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem primes_sextuplet_length (limit : Nat) (h : limit ≥ 1000) :\n  (findPrimesSextuplet limit).length = 6 :=\nsorry\n\ntheorem primes_sextuplet_monotone (limit : Nat) (h : limit ≥ 1000) :\n  let result := findPrimesSextuplet limit\n  ∀ i j, i < j → i < result.length → j < result.length →\n  result[i]! < result[j]! :=\nsorry\n\ntheorem primes_sextuplet_all_prime (limit : Nat) (h : limit ≥ 1000) :\n  ∀ x ∈ findPrimesSextuplet limit, isPrime x = true :=\nsorry\n\ntheorem primes_sextuplet_diffs (limit : Nat) (h : limit ≥ 1000) :\n  let result := findPrimesSextuplet limit\n  let diffs := List.map (fun p => p.2 - p.1) (List.zip result result.tail)\n  diffs = [4,2,4,2,4] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [7, 11, 13, 17, 19, 23]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 70\n\n/-\ninfo: [97, 101, 103, 107, 109, 113]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 600\n\n/-\ninfo: [1091257, 1091261, 1091263, 1091267, 1091269, 1091273]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 2000000"}
{"id": "fvapps_003064", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_sierpinski_sequence (n : Nat) : List Nat :=\n  sorry\n\ndef find_closest_value (m : Nat) : Nat :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sequence_is_strictly_increasing {n : Nat} (h : 0 < n) (h2 : n ≤ 10000) :\n  let seq := generate_sierpinski_sequence n\n  ∀ i, i + 1 < seq.length → seq.get! i < seq.get! (i + 1) :=\nsorry\n\ntheorem sequence_first_values {n : Nat} (h : 0 < n) (h2 : n ≤ 10000) :\n  let seq := generate_sierpinski_sequence n\n  seq.length ≥ 4 → seq.take 4 = [4, 13, 69, 130] :=\nsorry\n\ntheorem closest_value_properties {m : Nat} (h : 0 < m) (h2 : m ≤ 10000) :\n  let closest := find_closest_value m\n  let seq := generate_sierpinski_sequence (m * 2)\n  (closest ∈ seq) ∧\n  (∀ x ∈ seq, abs (closest - m) ≤ abs (x - m)) ∧\n  (∀ x ∈ seq, abs (x - m) = abs (closest - m) → x > m → closest ≥ x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_closest_value 1\n\n/-\ninfo: 5074\n-/\n#guard_msgs in\n#eval find_closest_value 5000\n\n/-\ninfo: 14313\n-/\n#guard_msgs in\n#eval find_closest_value 14313\n\n/-\ninfo: 18720\n-/\n#guard_msgs in\n#eval find_closest_value 18332"}
{"id": "fvapps_003074", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def select_subarray (arr : List Int) : Nat × Int :=\n  sorry\n\ndef get_ratio (arr : List Int) (idx : Nat) : Float :=\n  sorry", "vc-theorems": "theorem select_subarray_index_bounds {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  (select_subarray arr).1 < arr.length := by\n  sorry\n\ntheorem select_subarray_matches_input {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  (select_subarray arr).2 = arr[(select_subarray arr).1]! := by\n  sorry\n\ntheorem select_subarray_minimum_ratio {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  ∀ i < arr.length,\n    get_ratio arr (select_subarray arr).1 ≤ get_ratio arr i := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, -8]\n-/\n#guard_msgs in\n#eval select_subarray [1, 23, 2, -8, 5]\n\n/-\ninfo: [2, 23]\n-/\n#guard_msgs in\n#eval select_subarray [1, 3, 23, 4, 2, -8, 5, 18]\n\n/-\ninfo: [[3, 100], [4, 200]]\n-/\n#guard_msgs in\n#eval select_subarray [10, 20, -30, 100, 200]"}
{"id": "fvapps_003075", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def my_crib (n : Nat) : String :=\n  sorry\n\ndef splitLines (s : String) : List String :=\n  sorry", "vc-theorems": "theorem crib_width_consistency {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let width := 4 + 3 + 6 * (n - 1)\n  let lines := splitLines (my_crib n)\n  ∀ line ∈ lines, line.length = width :=\nsorry\n\ntheorem crib_roof_top {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let first_line := lines.head?\n  ∀ line, first_line = some line → line.replace \" \" \"\" = line.replace \"_\" \"\" :=\nsorry\n\ntheorem crib_sloping_roof {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let roof_lines := lines.take (3 + 2*(n-1))\n  ∀ line ∈ roof_lines, (line.contains '/') ∧ (line.contains '\\\\') :=\nsorry\n\ntheorem crib_wall_structure {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let wall_lines := lines.drop (3 + 2*(n-1))\n  ∀ line ∈ wall_lines, line.startsWith \"|\" ∧ line.endsWith \"|\" :=\nsorry\n\ntheorem crib_bottom_line {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  ∀ last_line, lines.getLast? = some last_line → last_line.contains '_' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval my_crib 1\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval my_crib 2\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval my_crib 3"}
{"id": "fvapps_003081", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minimum (l : List Int) : Option Int :=\nsorry\n\ndef maximum (l : List Int) : Option Int :=\nsorry\n\ndef maximum_product (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem maximum_product_in_array (arr : List Int) (h : arr ≠ []) :\n  ∃ x ∈ arr, maximum_product arr = x :=\nsorry\n\ntheorem maximum_product_even_negatives (arr : List Int) (h : arr ≠ [])\n  (h_even : (arr.filter (λ x => x < 0)).length % 2 = 0) :\n  let pos := arr.filter (λ x => x ≥ 0)\n  let neg := arr.filter (λ x => x < 0)\n  pos ≠ [] → (∃ m, minimum pos = some m ∧ maximum_product arr = m) ∨\n  pos = [] → (∃ m, minimum neg = some m ∧ maximum_product arr = m) :=\nsorry\n\ntheorem maximum_product_odd_negatives (arr : List Int) (h : arr ≠ [])\n  (h_odd : (arr.filter (λ x => x < 0)).length % 2 = 1) :\n  let neg := arr.filter (λ x => x < 0)\n  (¬ arr.contains 0 → (∃ m, maximum neg = some m ∧ maximum_product arr = m)) ∧\n  (arr.contains 0 → (∃ m, minimum neg = some m ∧ maximum_product arr = m)) :=\nsorry\n\ntheorem maximum_product_multiple_zeros (arr : List Int) (h : arr ≠ [])\n  (h_zeros : (arr.filter (λ x => x = 0)).length > 1) :\n  ∃ m, minimum arr = some m ∧ maximum_product arr = m :=\nsorry\n\ntheorem maximum_product_single_element (x : Int) :\n  maximum_product [x] = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval maximum_product [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maximum_product [-1, 2, -3]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_product [-1, -2, -3]"}
{"id": "fvapps_003083", "vc-description": "/- Ensures cheapest_quote returns a non-negative float -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Ensures cheapest_quote is strictly monotonically increasing -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def cheapest_quote (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem cheapest_quote_non_negative (n : Nat) :\n  let result := cheapest_quote n\n  result ≥ 0 :=\nsorry\n\ntheorem cheapest_quote_monotonic (n : Nat) : n > 0 →\n  cheapest_quote n > cheapest_quote (n-1) :=\nsorry", "vc-postamble": "/-\ninfo: 3.95\n-/\n#guard_msgs in\n#eval cheapest_quote 41\n\n/-\ninfo: 2.52\n-/\n#guard_msgs in\n#eval cheapest_quote 26\n\n/-\ninfo: 48.06\n-/\n#guard_msgs in\n#eval cheapest_quote 499"}
{"id": "fvapps_003089", "vc-description": "", "vc-preamble": "def isConsonant (c : Char) : Bool :=\n  c ∈ ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n\ndef isVowel (c : Char) : Bool :=\n  c.toLower ∈ ['a', 'e', 'i', 'o', 'u']", "vc-helpers": "", "vc-definitions": "def short_form (s : String) : String :=\n  sorry", "vc-theorems": "theorem short_form_length {s : String} :\n  String.length (short_form s) ≤ String.length s :=\nsorry\n\ntheorem short_form_first_last {s : String} (h: String.length s > 0) :\n  (s.get! 0 = (short_form s).get! 0) ∧\n  (String.length s > 1 → s.get! (String.Pos.mk (s.length - 1)) = (short_form s).get! (String.Pos.mk ((short_form s).length - 1))) :=\nsorry\n\ntheorem short_form_consonants {s : String} (h : ∀ c, c ∈ s.data → isConsonant c) :\n  short_form s = s :=\nsorry\n\ntheorem short_form_case_preservation {s : String} :\n  ∀ c, c ∈ (short_form s).data → c ∈ s.data :=\nsorry\n\ntheorem short_form_middle_vowels_removed {s : String} :\n  ∀ i, 1 ≤ i → i < String.length (short_form s) - 1 →\n    ¬(isVowel ((short_form s).get! (String.Pos.mk i))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'asslt'\n-/\n#guard_msgs in\n#eval short_form \"assault\"\n\n/-\ninfo: 'rhythm'\n-/\n#guard_msgs in\n#eval short_form \"rhythm\"\n\n/-\ninfo: 'InSNe'\n-/\n#guard_msgs in\n#eval short_form \"InSaNe\""}
{"id": "fvapps_003090", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\nsorry\n\ndef get_factors (n : Nat) : List Nat :=\nsorry\n\ndef prime_factors (n : Nat) : String :=\nsorry", "vc-theorems": "theorem prime_factors_valid_format (n : Nat) (h : n ≥ 2) :\n  let result := prime_factors n\n  ∀ part : String,\n  part ∈ (String.split (prime_factors n) (· == ')')).filter (λ x => x ≠ \"\") →\n  (∃ base power : Nat,\n   ((String.contains part '*') →\n    part = s!\"{base}**{power}\" ∧\n    is_prime base ∧\n    power > 1) ∧\n   (¬String.contains part '*' →\n    part.toNat?.isSome ∧\n    is_prime part.toNat!)) :=\nsorry\n\ntheorem prime_factors_preserves_value (n : Nat) (h : n ≥ 2) :\n  let result := prime_factors n\n  let parts := (String.split result (· == ')')).filter (λ x => x ≠ \"\")\n  let reconstructed := parts.foldl\n    (λ acc part =>\n      if String.contains part '*'\n      then\n        let nums := String.split part (· == '*')\n        let base := (nums.get! 0).trim.toNat!\n        let power := (nums.get! 2).trim.toNat!\n        acc * (base ^ power)\n      else acc * part.trim.toNat!)\n    1\n  reconstructed = n :=\nsorry\n\ntheorem prime_number_input (p : Nat) (h₁ : p ≥ 2) (h₂ : is_prime p) :\n  prime_factors p = s!\"({p})\" :=\nsorry\n\ntheorem powers_of_two (n : Nat) (h : n ≥ 1) :\n  prime_factors (2^n) = s!\"(2**{n})\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003096", "vc-description": "", "vc-preamble": "def List.factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def List.unique {α} [BEq α] (xs : List α) : List α :=\nsorry\n\ndef slogan_maker (words: List String) : List String :=\nsorry\n\ndef containsString (s1 s2: String) : Bool :=\nsorry", "vc-theorems": "theorem slogan_maker_returns_string_list (words : List String) :\n  ∀ s, s ∈ slogan_maker words → s.length ≥ 0 :=\nsorry\n\ntheorem slogan_maker_contains_all_words (words : List String) :\n  ∀ slogan, slogan ∈ slogan_maker words →\n  ∀ word, word ∈ List.unique words →\n  containsString slogan word = true :=\nsorry\n\ntheorem slogan_maker_length (words : List String) :\n  (slogan_maker words).length = List.factorial (List.unique words).length :=\nsorry\n\ntheorem slogan_maker_order_independent (words₁ words₂ : List String) :\n  List.unique words₁ = List.unique words₂ →\n  slogan_maker words₁ = slogan_maker words₂ :=\nsorry\n\ntheorem slogan_maker_unique_results (words : List String) :\n  ∀ s₁ s₂, s₁ ∈ slogan_maker words → s₂ ∈ slogan_maker words →\n  s₁ = s₂ ∨ s₁ ≠ s₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['super']\n-/\n#guard_msgs in\n#eval slogan_maker [\"super\"]\n\n/-\ninfo: set(['super hot', 'hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\"])\n\n/-\ninfo: set(['super hot guacamole', 'super guacamole hot', 'hot super guacamole', 'hot guacamole super', 'guacamole super hot', 'guacamole hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\", \"guacamole\"])"}
{"id": "fvapps_003098", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef tv_remote (s : String) : Nat :=\nsorry", "vc-theorems": "theorem tv_remote_basic_properties (s : String) : tv_remote s ≥ 0 :=\nsorry\n\ntheorem tv_remote_empty_string : tv_remote \"\" = 0 :=\nsorry\n\ntheorem tv_remote_case_sensitivity (s : String) :\n  s ≠ \"\" → tv_remote (s.map Char.toUpper) ≥ tv_remote (s.map Char.toLower) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 69\n-/\n#guard_msgs in\n#eval tv_remote \"Code Wars\"\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval tv_remote \"A\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval tv_remote \"does\""}
{"id": "fvapps_003099", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rearranger (k : Nat) (nums : List Nat) : String :=\nsorry\n\ndef splitString (s : String) (sep : String) : List String :=\nsorry\n\ndef trim (s : String) : String :=\nsorry\n\ndef toNat! (s : String) : Nat :=\nsorry\n\ndef getFirst (l : List α) : α :=\nsorry\n\ndef replace (s : String) (target : String) (replacement : String) : String :=\nsorry\n\ndef sortString (s : String) : String :=\nsorry\n\ndef joinStrings (l : List String) : String :=\nsorry", "vc-theorems": "theorem rearranger_divisible (k : Nat) (nums : List Nat) :\n  k > 0 → nums.length > 0 →\n  let result := rearranger k nums\n  result ≠ \"There is no possible rearrangement\" →\n  let parts := splitString result \"generates:\"\n  let numberStr := getFirst (splitString (getFirst (parts.tail)) \"divisible by\")\n  let number := toNat! (trim numberStr)\n  number % k = 0 :=\nsorry\n\ntheorem rearranger_preserves_digits (k : Nat) (nums : List Nat) :\n  k > 0 → nums.length > 0 →\n  let result := rearranger k nums\n  result ≠ \"There is no possible rearrangement\" →\n  let input_digits := nums.map toString |> joinStrings |> sortString\n  let parts := splitString result \"generates:\"\n  let first_part := trim (replace (getFirst parts) \"Rearrangement:\" \"\")\n  let result_digits := splitString first_part \", \" |> joinStrings |> sortString\n  input_digits = result_digits :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003111", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_average [Add α] [Div α] [OfNat α 0] : List α → α\n  | [] => 0\n  | xs =>\nsorry\n\ndef list_min : List Float → Float\n  | [] => 0\n  | (x::xs) =>\nsorry\n\ndef list_max : List Float → Float\n  | [] => 0\n  | (x::xs) =>\nsorry\n\ndef list_sum : List Float → Float\n  | [] => 0\n  | (x::xs) =>\nsorry\n\ndef abs (x : Float) : Float :=\nsorry\n\ndef toFloat (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem find_average_empty {α} [Add α] [Div α] [OfNat α 0] (nums : List α) :\n  nums = [] → find_average nums = 0 := by\nsorry\n\ntheorem find_average_bounds (nums : List Float) (h : nums ≠ []) :\n  list_min nums ≤ find_average nums ∧\n  find_average nums ≤ list_max nums := by\nsorry\n\ntheorem find_average_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-10 := by\nsorry\n\ntheorem find_average_float_empty (nums : List Float) :\n  nums = [] → find_average nums = 0 := by\nsorry\n\ntheorem find_average_float_type (nums : List Float) (h : nums ≠ []) :\n  find_average nums + 0 = find_average nums := by\nsorry\n\ntheorem find_average_float_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-6 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_average [1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_average [1, 3, 5, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []"}
{"id": "fvapps_003112", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s1 s2 : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem solve_returns_valid_output (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve s1 s2 = 1 ∨ solve s1 s2 = 2 :=\nsorry\n\ntheorem solve_identical_chars (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0)\n    (h3 : ∀ (c : Char), s1.data.contains c → c = 'a')\n    (h4 : ∀ (c : Char), s2.data.contains c → c = 'a') :\n  solve s1 s2 = 2 :=\nsorry\n\ntheorem solve_with_duplicates (s : String)\n    (h1 : s.length ≥ 2) :\n  (∃ (c : Char), s.data.contains c ∧ countChar s c ≥ 2) → solve s \"\" = 1 ∧\n  (∀ (c : Char), s.data.contains c → countChar s c < 2) → solve s \"\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"abc\" \"xyz\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"eyfjy\" \"ooigv\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"qtkxttl\" \"utvohqk\""}
{"id": "fvapps_003118", "vc-description": "-- Numbers remain unchanged in output\n\n-- Word transformation rules for different numbers\n\n-- Text without number-word pairs remains unchanged", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sursurungal (s : String) : String :=\nsorry\n\ndef containsDigit (s : String) (d : Nat) : Prop :=\nsorry\n\ndef containsWordAfterNumber (s : String) (n : Nat) (w : String) : Prop :=\nsorry", "vc-theorems": "theorem sursurungal_preserves_numbers {s : String} :\n  ∀ n : Nat, containsDigit s n → containsDigit (sursurungal s) n :=\nsorry\n\ntheorem word_transformation_rules {s : String} (n : Nat) (w : String) :\n  containsWordAfterNumber (sursurungal s) n w →\n  match n with\n  | 1 => ¬(w.startsWith \"bu\") ∧ ¬(w.startsWith \"ga\") ∧ ¬(w.endsWith \"zo\")\n  | 2 => w.startsWith \"bu\" ∧ ¬(w.startsWith \"ga\") ∧ ¬(w.endsWith \"zo\")\n  | n => if n ≤ 9\n        then ¬(w.startsWith \"bu\") ∧ ¬(w.startsWith \"ga\") ∧ w.endsWith \"zo\"\n        else w.startsWith \"ga\" ∧ w.endsWith \"ga\" ∧ ¬(w.endsWith \"zo\") :=\nsorry\n\ntheorem unchanged_text_without_numbers (s : String) :\n  (∀ n : Nat, ¬containsDigit s n) →\n  sursurungal s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 tomato'\n-/\n#guard_msgs in\n#eval sursurungal \"1 tomato\"\n\n/-\ninfo: '2 bubanana'\n-/\n#guard_msgs in\n#eval sursurungal \"2 bananas\"\n\n/-\ninfo: '3 bananazo'\n-/\n#guard_msgs in\n#eval sursurungal \"3 bananas\"\n\n/-\ninfo: '10 gabananaga'\n-/\n#guard_msgs in\n#eval sursurungal \"10 bananas\"\n\n/-\ninfo: '6 birdzo with 2 buwing each'\n-/\n#guard_msgs in\n#eval sursurungal \"6 birds with 2 wings each\"\n\n/-\ninfo: '\\n3 pigzo\\nmet 1 wolf\\n2 buday ago'\n-/\n#guard_msgs in\n#eval sursurungal \"\\n3 pigs\\nmet 1 wolf\\n2 days ago\""}
{"id": "fvapps_003127", "vc-description": "", "vc-preamble": "def DnaBases : List Char := ['A', 'C', 'G', 'T']\n\ndef isValidDnaChar (c : Char) : Bool :=\n  match DnaBases.find? (· == c) with\n  | some _ => true\n  | none => false\n\ndef isValidDnaString (s : String) : Bool :=\n  match s.data.find? (fun c => !isValidDnaChar c) with\n  | some _ => false\n  | none => true", "vc-helpers": "", "vc-definitions": "def motif_locator (sequence motif : String) : List Nat :=\nsorry\n\ndef substring (s : String) (start len : Nat) : String :=\nsorry", "vc-theorems": "theorem motif_positions_valid (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (∀ p ∈ positions, 0 < p ∧ p ≤ sequence.length) ∧\n  (∀ p ∈ positions, substring sequence (p-1) motif.length = motif) :=\nsorry\n\ntheorem positions_ordered_nonoverlap (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (∀ i j, i < j → j < positions.length → positions[i]! ≤ positions[j]!) ∧\n  (∀ i, i < positions.length - 1 → positions[i+1]! - positions[i]! ≥ motif.length) :=\nsorry\n\ntheorem empty_sequence (motif : String)\n  (h : isValidDnaString motif) :\n  motif_locator \"\" motif = [] :=\nsorry\n\ntheorem motif_longer_than_seq :\n  motif_locator \"ACG\" \"ACGT\" = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"TTCCGGAACC\" \"CC\"\n\n/-\ninfo: [1, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTTACAACGTTAG\" \"ACGT\"\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTACGTACGT\" \"AAA\""}
{"id": "fvapps_003141", "vc-description": "", "vc-preamble": "def maximum? : List Int → Option Int\n  | [] => none\n  | x::xs => some (xs.foldl max x)\n\ndef minimum? : List Int → Option Int\n  | [] => none\n  | x::xs => some (xs.foldl min x)", "vc-helpers": "", "vc-definitions": "def isInertial (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem empty_array\n  : ∀ (arr : List Int), arr = [] → isInertial arr = false := by\n  sorry\n\ntheorem no_odds\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    (∀ x ∈ arr, x % 2 = 0) →\n    isInertial arr = false := by\n  sorry\n\ntheorem max_must_be_even\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    match maximum? arr with\n    | none => True\n    | some max => max % 2 = 1 → isInertial arr = false := by\n  sorry\n\ntheorem odds_vs_evens\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    (∃ x ∈ arr, x % 2 = 1) →\n    match maximum? arr with\n    | none => True\n    | some max =>\n      max % 2 = 0 →\n      let odds := arr.filter (fun x => x % 2 = 1)\n      let evens := arr.filter (fun x => x % 2 = 0 && x ≠ max)\n      odds ≠ [] →\n      evens ≠ [] →\n      match minimum? odds, maximum? evens with\n      | some min_odd, some max_even => isInertial arr = (min_odd > max_even)\n      | _, _ => True := by\n  sorry\n\ntheorem single_element\n  : ∀ (n : Int), isInertial [n] = false := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial []\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial [581, -384, 140, -287]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_inertial [11, 4, 20, 9, 2, 8]"}
{"id": "fvapps_003143", "vc-description": "", "vc-preamble": "def stringAppend (s1 s2: String) : String := String.append s1 s2", "vc-helpers": "", "vc-definitions": "def solve (pattern: String) (target: String) : Bool :=\nsorry", "vc-theorems": "theorem identical_strings_match\n  (s: String)\n  (h: s.data.all (fun c => c ≠ '*')) :\n  solve s s = true :=\nsorry\n\ntheorem wildcard_match\n  (p s m: String)\n  (h1: p.data.all (fun c => c ≠ '*'))\n  (h2: s.data.all (fun c => c ≠ '*'))\n  (h3: m.data.all (fun c => c ≠ '*')) :\n  solve (stringAppend (stringAppend p \"*\") s) (stringAppend (stringAppend p m) s) = true :=\nsorry\n\ntheorem different_strings_no_match\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c ≠ '*'))\n  (h2: s2.data.all (fun c => c ≠ '*'))\n  (h3: s1 ≠ s2) :\n  solve s1 s2 = false :=\nsorry\n\ntheorem multiple_wildcards_invalid\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c ≠ '*'))\n  (h2: s2.data.all (fun c => c ≠ '*')) :\n  solve (stringAppend (stringAppend (stringAppend s1 \"*\") s2) \"*\") \"anything\" = false :=\nsorry\n\ntheorem length_requirement\n  (p s m: String)\n  (h1: p.data.all (fun c => c ≠ '*'))\n  (h2: s.data.all (fun c => c ≠ '*')) :\n  (stringAppend (stringAppend p m) s).length ≥ (stringAppend (stringAppend p \"*\") s).length - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"code*s\" \"codewars\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"codewar*s\" \"codewars\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"code*warrior\" \"codewars\""}
{"id": "fvapps_003145", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encode_resistor_colors (ohm_str : String) : String :=\n  sorry\n\ndef String.toNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem resistor_colors_format {ohm_str : String}\n  (h : 10 ≤ ohm_str.toNat ∧ ohm_str.toNat ≤ 99000000) :\n  let result := encode_resistor_colors ohm_str\n  let colors := (result.split fun c => c = ' ')\n  (colors.length = 4) ∧\n  (colors[3]! = \"gold\") ∧\n  (∀ c ∈ colors, c ∈ [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\", \"gold\"]) :=\nsorry\n\ntheorem resistor_colors_value {ohm_str : String}\n  (h1 : ohm_str.contains 'k' →\n        1000 * (ohm_str.replace \"k\" \" \").toNat = ohm_str.toNat)\n  (h2 : ohm_str.contains 'M' →\n        1000000 * (ohm_str.replace \"M\" \" \").toNat = ohm_str.toNat)\n  (h3 : ¬ohm_str.contains 'k' ∧ ¬ohm_str.contains 'M' →\n        ohm_str.toNat = ohm_str.toNat)\n  (h4 : 10 ≤ ohm_str.toNat ∧ ohm_str.toNat ≤ 99000000) :\n  let result := encode_resistor_colors ohm_str\n  ohm_str.toNat = result.toNat :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003147", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reverseInvert (lst : List Int) : List Int :=\nsorry\n\ndef numReverse (n : Int) : Int :=\nsorry", "vc-theorems": "theorem reverseInvert_returns_list_of_ints {lst : List Int} :\n  ∀ x, x ∈ reverseInvert lst → x ∈ lst := by\nsorry\n\ntheorem reverseInvert_bounded {lst : List Int}\n    (h : ∀ x ∈ lst, -999 ≤ x ∧ x ≤ 999) :\n    ∀ (i : Fin lst.length),\n      let orig := lst.get i\n      let revNum := numReverse (Int.natAbs orig)\n      (reverseInvert lst).get ⟨i, by sorry⟩ = if orig > 0 then -revNum else revNum := by\nsorry\n\ntheorem reverseInvert_single_digits {lst : List Int} (h : ∀ x ∈ lst, 0 ≤ x ∧ x ≤ 9) :\n  ∀ (i : Fin lst.length),\n    (reverseInvert lst).get ⟨i, by sorry⟩ = -(lst.get i) := by\nsorry\n\ntheorem reverseInvert_length_preservation {lst : List Int} :\n  (reverseInvert lst).length = lst.length := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [-1, -2, -3, -4, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 2, 3, 4, 5]\n\n/-\ninfo: [-1, -21, -78, 24, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 12, \"a\", 3.4, 87, 99.9, -42, 50, 5.6]\n\n/-\ninfo: [9, 81, -99]\n-/\n#guard_msgs in\n#eval reverse_invert [-9, -18, 99]"}
{"id": "fvapps_003149", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def highlight (s : String) : String :=\nsorry\n\ndef colorFor (c : Char) : String :=\nsorry\n\ndef String.count (s : String) (sub : String) : Nat :=\nsorry", "vc-theorems": "theorem letter_get_correct_colors (c : Char) (h: c ∈ ['F', 'L', 'R']):\n  let color :=\n    match c with\n    | 'F' => \"pink\"\n    | 'L' => \"red\"\n    | 'R' => \"green\"\n    | _ => \"\"\n  colorFor c = color\n  :=\nsorry\n\ntheorem numbers_get_orange (c : Char) (h : c.isDigit) :\n  colorFor c = \"orange\" :=\nsorry\n\ntheorem consecutive_chars_single_span (s : String) (h: s.all (· = s.get! 0)) :\n  (highlight s).count \"<span\" = 1 :=\nsorry\n\ntheorem highlight_maintains_content (s : String) :\n  let stripped := (highlight s).replace \"<span\" \"\" |>.replace \"</span\" \"\" |>.replace \"style=\\\"color: pink\\\"\" \"\"\n                   |>.replace \"style=\\\"color: red\\\"\" \"\" |>.replace \"style=\\\"color: green\\\"\" \"\"\n                   |>.replace \"style=\\\"color: orange\\\"\" \"\"\n  stripped = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval highlight \"F3RF5LF7\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval highlight \"FFFR345F2LL\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval highlight \"FF(LF6(RF3)2)3\""}
{"id": "fvapps_003157", "vc-description": "", "vc-preamble": "def countOnes (n : Nat) : Nat :=\n  if n = 0 then 0\n  else if n % 2 = 1\n  then countOnes (n / 2) + 1\n  else countOnes (n / 2)", "vc-helpers": "", "vc-definitions": "def evil (n : Nat) : String :=\nsorry", "vc-theorems": "theorem evil_result_valid (n : Nat) :\n  (evil n = \"It's Evil!\") ∨ (evil n = \"It's Odious!\") :=\nsorry\n\ntheorem evil_xor_property (n m : Nat) :\n  let n_evil := evil n = \"It's Evil!\"\n  let m_evil := evil m = \"It's Evil!\"\n  let xor_evil := evil (n ^^^ m) = \"It's Evil!\"\n  (n_evil = m_evil) = xor_evil :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 1\n\n/-\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 2\n\n/-\ninfo: \"It's Evil!\"\n-/\n#guard_msgs in\n#eval evil 3"}
{"id": "fvapps_003165", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def isDigitChar (c : Char) : Bool :=\n  '0' ≤ c ∧ c ≤ '9'", "vc-helpers": "", "vc-definitions": "def make_triangle (m n : Nat) : String :=\n  sorry", "vc-theorems": "theorem make_triangle_valid_output_type {m n : Nat} :\n  ∀ r : String, r = make_triangle m n → (r = \"\" ∨ String.contains r '\\n') :=\nsorry\n\ntheorem make_triangle_digits_only {m n : Nat} (h : m ≤ n) (h2 : n - m + 1 ≤ 45) :\n  ∀ c : Char, c ∈ (make_triangle m n).toList →\n    (c = ' ' ∨ c = '\\n' ∨ isDigitChar c) :=\nsorry\n\ntheorem make_triangle_row_growth {m n : Nat} (h : m ≤ n) (h2 : n - m + 1 ≤ 45) :\n  let lines := String.split (make_triangle m n) (· = '\\n')\n  ∀ i : Nat, i < lines.length →\n    ∀ h : i < lines.length,\n    (String.split (String.trim (lines[i]'h)) (· = ' ')).length = i + 1 :=\nsorry\n\ntheorem make_triangle_total_elements {m n : Nat} (h : m ≤ n) :\n  let size := n - m + 1\n  let result := make_triangle m n\n  let lines := String.split result (· = '\\n')\n  result ≠ \"\" →\n  (lines.foldl (fun acc line =>\n    acc + (String.split (String.trim line) (· = ' ')).length) 0) = size :=\nsorry\n\ntheorem make_triangle_invalid_empty {m n : Nat} :\n  (m > n ∨ n - m + 1 > 45) → make_triangle m n = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003166", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (arr : List Char) (reach : Nat) : Nat :=\n  sorry\n\ndef numChar (c : Char) (arr : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem solve_empty {reach : Nat} :\n  solve [] reach = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"D\", \"C\", \"C\", \"D\", \"C\"] 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 1"}
{"id": "fvapps_003172", "vc-description": "", "vc-preamble": "def sum_list : List Int → Int\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def ones_counter (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem ones_counter_positive (nums : List Int) :\n  ∀ x ∈ ones_counter nums, x > 0\n:=\nsorry\n\ntheorem ones_counter_sum (nums : List Int) :\n  sum_list (ones_counter nums) = sum_list nums\n:=\nsorry\n\ntheorem ones_counter_grouped (nums : List Int) :\n  ones_counter nums =\n    let rec group_ones (ns : List Int) (acc : Int) (result : List Int) : List Int :=\n      match ns with\n      | [] => if acc > 0 then result ++ [acc] else result\n      | x::xs => if x = 1\n                 then group_ones xs (acc + 1) result\n                 else if acc > 0\n                      then group_ones xs 0 (result ++ [acc])\n                      else group_ones xs 0 result\n    group_ones nums 0 []\n:=\nsorry\n\ntheorem ones_counter_all_zeros {nums : List Int} (h : ∀ x ∈ nums, x = 0) :\n  ones_counter nums = []\n:=\nsorry\n\ntheorem ones_counter_all_ones {nums : List Int} (h : ∀ x ∈ nums, x = 1) (h' : nums ≠ []) :\n  ones_counter nums = [((List.length nums) : Int)]\n:=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval ones_counter [0, 0, 0, 0, 0, 0, 0, 0]\n\n/-\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval ones_counter [1, 1, 1, 0, 0, 1, 0, 1, 1, 0]\n\n/-\ninfo: [1, 2, 4, 1]\n-/\n#guard_msgs in\n#eval ones_counter [1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1]"}
{"id": "fvapps_003176", "vc-description": "", "vc-preamble": "def binary_units := [\"KiB\", \"MiB\", \"GiB\", \"TiB\"]\n\ndef metric_units := [\"kB\", \"MB\", \"GB\", \"TB\"]\n\ndef isValidIndex (i : Nat) : Prop :=\n  i < 4", "vc-helpers": "", "vc-definitions": "def memorysize_conversion (s : String) : String :=\nsorry", "vc-theorems": "theorem binary_units_length : binary_units.length = 4 :=\nsorry\n\ntheorem metric_units_length : metric_units.length = 4 :=\nsorry\n\ntheorem binary_to_metric_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 ≤ value) (h2 : value ≤ 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {binary_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith metric_units[unit_idx] :=\nsorry\n\ntheorem metric_to_binary_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 ≤ value) (h2 : value ≤ 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {metric_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith binary_units[unit_idx] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1.024 kB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"1 KiB\"\n\n/-\ninfo: '9.095 TiB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"10 TB\"\n\n/-\ninfo: '4.402 GB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"4.1 GiB\""}
{"id": "fvapps_003179", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\nsorry\n\ndef isPrime (n : Nat) : Bool :=\nsorry\n\ndef gap (g m n : Nat) : Option (Nat × Nat) :=\nsorry", "vc-theorems": "theorem prime_divisibility {n : Nat} (h : n ≥ 2) :\n  isPrime n = true →\n  ∀ i : Nat, 2 ≤ i → i ≤ sqrt n → n % i ≠ 0 :=\nsorry\n\ntheorem composite_divisibility {n : Nat} (h : n ≥ 2) :\n  isPrime n = false →\n  (∃ i : Nat, 2 ≤ i ∧ i ≤ sqrt n ∧ n % i = 0) ∨ n < 2 :=\nsorry\n\ntheorem gap_result_valid {g m n : Nat} (hm : m ≥ 2) (hn : n ≥ 2) :\n  ∀ result : Nat × Nat,\n  gap g m n = some result →\n  let (p₁, p₂) := result\n  (isPrime p₁ = true ∧ isPrime p₂ = true) ∧\n  p₂ - p₁ = g ∧\n  m ≤ p₁ ∧ p₁ ≤ p₂ ∧ p₂ ≤ n ∧\n  ∀ x : Nat, p₁ < x → x < p₂ → isPrime x = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 5]\n-/\n#guard_msgs in\n#eval gap 2 3 10\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval gap 6 100 110\n\n/-\ninfo: [163, 167]\n-/\n#guard_msgs in\n#eval gap 4 130 200"}
{"id": "fvapps_003180", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Int) : Int :=\n  sorry\n\ndef minimum (a x : Int) : Int :=\n  sorry", "vc-theorems": "theorem minimum_makes_number_divisible (a x : Int) (h : x ≠ 0) :\n  (a + minimum a x) % x = 0 ∨ (a - minimum a x) % x = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum 9 4\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum 10 6\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum 15 5"}
{"id": "fvapps_003189", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def threeAmigos (nums : List Int) : List Int :=\nsorry\n\ndef list_max (l : List Int) : Int :=\nsorry\n\ndef list_min (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem threeAmigos_valid_size {nums : List Int} :\n  let result := threeAmigos nums\n  List.length result = 0 ∨ List.length result = 3 :=\nsorry\n\ntheorem threeAmigos_consecutive {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨ ∃ i, i + 2 < List.length nums ∧\n    result = [nums[i]!, nums[i+1]!, nums[i+2]!] :=\nsorry\n\ntheorem threeAmigos_same_parity {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨ (∀ x ∈ result, x % 2 = result[0]! % 2) :=\nsorry\n\ntheorem threeAmigos_minimal_range {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨\n  (∀ i, i + 2 < List.length nums →\n    (∀ j, j ∈ [nums[i]!, nums[i+1]!, nums[i+2]!] → j % 2 = nums[i]! % 2) →\n    (list_max result - list_min result) ≤ (nums[i+2]! - nums[i]!)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [5, 3, 5]\n-/\n#guard_msgs in\n#eval three_amigos [1, 2, 34, 2, 1, 5, 3, 5, 7, 234, 2, 1]\n\n/-\ninfo: [2, 2, 2]\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 6, 8, 10, 2, 2, 2, 1, 1, 1, 5, 3]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 5, 3, 6, 3, 1, 56, 7, 6, 3, 12]"}
{"id": "fvapps_003196", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef predict_age (ages : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem predict_age_non_negative (ages : List Nat) :\n  0 ≤ predict_age ages :=\nsorry\n\ntheorem predict_age_is_nat (ages : List Nat) :\n  predict_age ages = predict_age ages :=\nsorry\n\ntheorem predict_age_order_independent (ages : List Nat) :\n  predict_age ages = predict_age ages.reverse :=\nsorry\n\ntheorem predict_age_zero :\n  predict_age [0] = 0 :=\nsorry\n\ntheorem predict_age_single (age : Nat) :\n  predict_age [age] = age / 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003200", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef circular_permutations (n : Nat) : List Nat :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry\n\ndef circular_prime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem circular_perms_length (n : Nat) (h : n > 0) :\n  List.length (circular_permutations n) = String.length (toString n) :=\nsorry\n\ntheorem circular_perms_digit_count (n : Nat) (h : n > 0) :\n  ∀ p ∈ circular_permutations n,\n    List.length (toString p).data = List.length (toString n).data :=\nsorry\n\ntheorem prime_basic_properties (n : Nat) :\n  is_prime n = true →\n    (n > 1 ∧\n     ∀ i, 2 ≤ i → i ≤ sqrt n → n % i ≠ 0) :=\nsorry\n\ntheorem circular_prime_properties (n : Nat) :\n  circular_prime n = true →\n    ∀ x ∈ circular_permutations n, is_prime x = true :=\nsorry\n\ntheorem circular_prime_symmetry (n : Nat) :\n  circular_prime n = true →\n    ∀ p ∈ circular_permutations n, circular_prime p = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 197\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circular_prime 179\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 7"}
{"id": "fvapps_003207", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def going (n : Nat) : Float :=\nsorry\n\ndef calc_series (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem going_range (n : Nat) :\n  1 ≤ going n ∧ going n ≤ 2 :=\nsorry\n\ntheorem going_matches_calc_series (n : Nat) :\n  n ≥ 1 → n ≤ 100 → Float.abs (going n - calc_series n) < 0.000001 :=\nsorry\n\ntheorem going_decimal_places (n : Nat) :\n  ∃ k : Nat, k ≤ 6 ∧ going n * Float.ofNat (10^k) = Float.floor (going n * Float.ofNat (10^k)) :=\nsorry\n\ntheorem going_specific_values :\n  going 1 = 1.0 ∧ going 5 = 1.275 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1.275\n-/\n#guard_msgs in\n#eval going 5\n\n/-\ninfo: 1.2125\n-/\n#guard_msgs in\n#eval going 6\n\n/-\ninfo: 1.173214\n-/\n#guard_msgs in\n#eval going 7"}
{"id": "fvapps_003209", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def timeToWords (time: String) : String :=\nsorry\n\ndef hasSubstring (s1 s2 : String) : Bool :=\nsorry\n\ndef endsWithStr (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem time_to_words_basic_format (hours : Nat) (minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 59) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  (hasSubstring result \"o'clock\" ∨ hasSubstring result \"past\" ∨\n   hasSubstring result \"to\" ∨ result = \"midnight\") :=\nsorry\n\ntheorem time_to_words_oclock (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:00\"\n  (hours = 0 → result = \"midnight\") ∧\n  (hours ≠ 0 → endsWithStr result \"o'clock\") :=\nsorry\n\ntheorem time_to_words_quarter_past (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:15\"\n  (hours = 0 → hasSubstring result \"quarter past midnight\") ∧\n  (hours ≠ 0 → hasSubstring result \"quarter past\") :=\nsorry\n\ntheorem time_to_words_half_past (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:30\"\n  (hours = 0 → hasSubstring result \"half past midnight\") ∧\n  (hours ≠ 0 → hasSubstring result \"half past\") :=\nsorry\n\ntheorem time_to_words_past_minutes (hours minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 29) (h_minutes_pos : minutes ≥ 1)\n  (h_not_quarter : minutes ≠ 15) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"past\" ∧ hasSubstring result \"minute\" ∧\n  (hasSubstring result \"minutes\" ↔ minutes ≠ 1) :=\nsorry\n\ntheorem time_to_words_to_minutes (hours minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 59) (h_minutes_low : minutes ≥ 31)\n  (h_not_quarter : minutes ≠ 45) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"to\" ∧ hasSubstring result \"minute\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: \"one o'clock\"\n-/\n#guard_msgs in\n#eval time_to_words \"13:00\"\n\n/-\ninfo: 'quarter past one'\n-/\n#guard_msgs in\n#eval time_to_words \"13:15\"\n\n/-\ninfo: 'midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"00:00\"\n\n/-\ninfo: 'quarter to midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"23:45\""}
{"id": "fvapps_003210", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encrypt (text : Option String) (n : Int) : Option String :=\n  sorry\n\ndef decrypt (text : Option String) (n : Int) : Option String :=\n  sorry", "vc-theorems": "theorem encrypt_decrypt_roundtrip {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  decrypt (encrypt (some text) n) n = some text :=\nsorry\n\ntheorem encrypt_edge_cases {text : Option String} {n : Int} (h1 : text = none ∨ text = some \"\") (h2 : n > 0) (h3 : n ≤ 10) :\n  encrypt text n = text :=\nsorry\n\ntheorem encrypt_invalid_n {text : String} {n : Int} (h1 : text.length > 0) (h2 : n ≤ 0) :\n  encrypt (some text) n = some text :=\nsorry\n\ntheorem encrypt_length_preserved {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  (encrypt (some text) n).map String.length = some text.length :=\nsorry\n\ntheorem encrypt_char_preservation {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  (encrypt (some text) n).map (fun s => s.data.toArray.qsort (· ≤ ·)) = some (text.data.toArray.qsort (· ≤ ·)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'hsi  etTi sats!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 1\n\n/-\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"hsi  etTi sats!\" 1\n\n/-\ninfo: 's eT ashi tist!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 2\n\n/-\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"s eT ashi tist!\" 2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\" 1\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval decrypt None 1"}
{"id": "fvapps_003212", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef isNonZeroDigit (c : Char) : Bool :=\nsorry\n\ndef look_and_say_sequence (s : String) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem sequence_preserves_digits (s : String) (n : Nat)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  ∀ c ∈ (look_and_say_sequence s n).data, isDigit c :=\nsorry\n\ntheorem sequence_length_monotonic (s : String) (n : Nat)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  (look_and_say_sequence s n).length ≤ (look_and_say_sequence s (n+1)).length :=\nsorry\n\ntheorem first_element_unchanged (s : String)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  look_and_say_sequence s 1 = s :=\nsorry\n\ntheorem repeating_digits_pattern (s : String)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  let result := look_and_say_sequence s 2\n  ∀ i < result.length / 2,\n    ∃ (p1 p2 : String.Pos),\n    isNonZeroDigit (result.get p1) ∧\n    isDigit (result.get p2) :=\nsorry\n\ntheorem known_repeating_sequence :\n  look_and_say_sequence \"22\" 9 = look_and_say_sequence \"22\" 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 1\n\n/-\ninfo: '21'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 3\n\n/-\ninfo: '111221'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 5\n\n/-\ninfo: '22'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"22\" 10\n\n/-\ninfo: '1114'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"14\" 2"}
{"id": "fvapps_003222", "vc-description": "-- For any natural number, narcissistic returns a boolean\n\n-- The narcissistic function returns true when the sum of each digit raised to\n-- the power of number of digits equals the original number\n\n-- Known narcissistic numbers", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def narcissistic (n : Nat) : Bool :=\n  sorry\n\ndef digit_power_sum (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem narcissistic_returns_bool (n : Nat) :\n  ∃ (b : Bool), narcissistic n = b :=\nsorry\n\ntheorem narcissistic_digit_power_sum (n : Nat) :\n  narcissistic n = (n = digit_power_sum n) :=\nsorry\n\ntheorem known_narcissistic_numbers :\n  narcissistic 0 = true ∧\n  narcissistic 1 = true ∧\n  narcissistic 2 = true ∧\n  narcissistic 3 = true ∧\n  narcissistic 4 = true ∧\n  narcissistic 5 = true ∧\n  narcissistic 6 = true ∧\n  narcissistic 7 = true ∧\n  narcissistic 8 = true ∧\n  narcissistic 9 = true ∧\n  narcissistic 153 = true ∧\n  narcissistic 370 = true ∧\n  narcissistic 371 = true ∧\n  narcissistic 407 = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 153\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 1634\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval narcissistic 123"}
{"id": "fvapps_003223", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flatten {α : Type} : List (List α) → List α\n  | [] =>\nsorry\n\ndef isNestedList {α : Type} : List (List α) → Bool\n  | [] =>\nsorry", "vc-theorems": "theorem flatten_preserves_elements {α : Type} (lst : List (List α)) (inner : List α) :\n  inner ∈ lst →\n  ∀ x ∈ inner, x ∈ (flatten lst) :=\nsorry\n\ntheorem flatten_identity_on_simple_list {α : Type} (lst : List α) :\n  flatten [lst] = lst :=\nsorry\n\ntheorem flatten_length_simple {α : Type} (lst : List α) :\n  List.length (flatten [lst]) = List.length lst :=\nsorry\n\ntheorem flatten_nested_ints (lst : List (List Int)) (n : Int) :\n  n ∈ (flatten lst) →\n  ∃ inner : List Int, inner ∈ lst ∧ n ∈ inner :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003224", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.lines (s : String) : List String :=\nsorry\n\ndef String.count (s : String) (c : Char) : Nat :=\nsorry\n\ndef sierpinski (n : Nat) : String :=\nsorry", "vc-theorems": "theorem sierpinski_base : sierpinski 0 = \"*\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003225", "vc-description": "", "vc-preamble": "def isPerfectSquare (n : Nat) : Prop :=\n  ∃ k : Nat, k * k = n", "vc-helpers": "", "vc-definitions": "def list_squared (m n : Nat) : List (Nat × Nat) :=\nsorry\n\ndef sumOfSquaredDivisors (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem list_squared_result_valid (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result,\n    ∃ (a b : Nat), pair = (a, b) ∧\n    m ≤ a ∧ a ≤ n :=\nsorry\n\ntheorem list_squared_divisors_sum (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result, pair.2 = sumOfSquaredDivisors pair.1 :=\nsorry\n\ntheorem list_squared_is_sorted (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ i, i + 1 < result.length →\n    (result[i]'sorry).1 < (result[i+1]'sorry).1 :=\nsorry\n\ntheorem list_squared_perfect_squares (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result, isPerfectSquare pair.2 :=\nsorry\n\ntheorem list_squared_single_point (n : Nat) (h : 0 < n) :\n  let result := list_squared n n\n  result = [] ∨ result = [(n, sumOfSquaredDivisors n)] :=\nsorry\n\ntheorem list_squared_empty (m n : Nat) :\n  m > n → list_squared m n = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [[1, 1], [42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 1 250\n\n/-\ninfo: [[42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 42 250\n\n/-\ninfo: [[287, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 250 500"}
{"id": "fvapps_003232", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def products (n : Nat) (k m : Nat) : List (List Nat) :=\nsorry\n\ndef eq_dice (dice : List Nat) : Nat :=\nsorry\n\ndef List.prod (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem eq_dice_single_die (n : Nat)\n  (h : 3 ≤ n ∧ n ≤ 20) :\n  eq_dice [n] = (products n 3 (min (n-1) 20)).length :=\nsorry\n\ntheorem eq_dice_small_pairs (d1 d2 : Nat)\n  (h1 : 3 ≤ d1 ∧ d1 ≤ 6)\n  (h2 : 3 ≤ d2 ∧ d2 ≤ 6) :\n  eq_dice [d1, d2] ≤ 5 :=\nsorry\n\ntheorem eq_dice_threes :\n  eq_dice [3, 3] = 0 :=\nsorry\n\ntheorem eq_dice_four :\n  eq_dice [4] = (products 4 3 3).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval eq_dice [6, 6]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval eq_dice [5, 6, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval eq_dice [3, 3]"}
{"id": "fvapps_003235", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) (a b : Nat) : String :=\nsorry\n\ndef length (s : String) : Nat :=\nsorry\n\ndef substring (s : String) (start : Nat) (len : Nat) : String :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem solve_length_preserved (s : String) (a b : Nat) (h : length s > 0) :\n  length (solve s a b) = length s :=\nsorry\n\ntheorem solve_preserves_outside_bounds (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) 0 start = substring s 0 start ∧\n  substring (solve s a b) finish (length s - finish) = substring s finish (length s - finish) :=\nsorry\n\ntheorem solve_reverses_middle (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) start (finish - start) = reverse (substring s start (finish - start)) :=\nsorry\n\ntheorem solve_identity_empty_range (s : String) (h : length s > 0) :\n  solve s 0 0 = s ∧\n  solve s (length s) (length s + 10) = s :=\nsorry\n\ntheorem solve_full_reversal (s : String) (h : length s > 0) :\n  solve s 0 (length s - 1) = reverse s :=\nsorry\n\ntheorem solve_single_char_identity (s : String) (idx : Nat) (h : length s > 0)\n  (limited_idx := min idx (length s - 1)) :\n  solve s limited_idx limited_idx = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003241", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def split (s : String) : List String :=\nsorry\n\ndef toNat (s : String) : Option Nat :=\nsorry\n\ndef scratch (tickets : List String) : Nat :=\nsorry", "vc-theorems": "theorem scratch_non_negative (tickets : List String) :\n  scratch tickets ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1100\n-/\n#guard_msgs in\n#eval scratch [\"tiger tiger tiger 100\", \"rabbit dragon snake 100\", \"rat ox pig 1000\", \"dog cock sheep 10\", \"horse monkey rat 5\", \"dog dog dog 1000\"]\n\n/-\ninfo: 350\n-/\n#guard_msgs in\n#eval scratch [\"cat cat cat 50\", \"dog dog dog 100\", \"pig pig pig 200\"]\n\n/-\ninfo: 500\n-/\n#guard_msgs in\n#eval scratch [\"owl eagle hawk 100\", \"cat mouse dog 200\", \"fish fish fish 500\"]"}
{"id": "fvapps_003242", "vc-description": "/- Helper function to check if string matches expected pattern -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Helper function to extract numeric values from amortization string output -/", "vc-preamble": "structure AmortValues where\n  num_payment : Int\n  payment : Int\n  principal : Int\n  interest : Int\n  balance : Float", "vc-helpers": "", "vc-definitions": "def amort (rate : Float) (bal : Int) (term : Int) (num_payments : Int) : String :=\nsorry\n\ndef extractValuesFromString (s : String) : AmortValues :=\nsorry\n\ndef matchesPattern (s : String) : Bool :=\nsorry", "vc-theorems": "theorem amort_output_format (rate : Float) (bal : Int) (term : Int) (num_payments : Int)\n  (h1 : rate ≥ 0.1) (h2 : rate ≤ 30.0)\n  (h3 : bal ≥ 1000) (h4 : bal ≤ 1000000)\n  (h5 : term ≥ 12) (h6 : term ≤ 360)\n  (h7 : num_payments ≥ 1) (h8 : num_payments ≤ term) :\n  let result := amort rate bal term num_payments\n  let values := extractValuesFromString result\n  (matchesPattern result) ∧\n  (values.num_payment = num_payments) ∧\n  (values.payment ≥ 0) ∧\n  (values.principal ≥ 0) ∧\n  (values.interest ≥ 0) ∧\n  (Int.natAbs (values.principal + values.interest - values.payment) ≤ 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003248", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validMorseChar (c : Char) : Bool :=\n  sorry\n\ndef encryption (s : String) : String :=\n  sorry", "vc-theorems": "theorem encryption_morse_chars\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ∀ c, c ∈ (encryption s).data → (c = '.' ∨ c = '-' ∨ c = ' ') :=\nsorry\n\ntheorem encryption_word_separation\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ((encryption s).splitOn \"   \").length = (s.splitOn \" \").length :=\nsorry\n\ntheorem encryption_letter_separation\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ∀ word, word ∈ ((encryption s).splitOn \"   \") →\n    ∀ letter, letter ∈ (word.splitOn \" \") →\n    letter.length > 0 :=\nsorry\n\ntheorem encryption_case_insensitive\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : encryption s = encryption s.toLower ∧\n    encryption s = encryption s.toUpper :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n-/\n#guard_msgs in\n#eval encryption \"HELLO WORLD\"\n\n/-\ninfo: '... --- ...'\n-/\n#guard_msgs in\n#eval encryption \"SOS\"\n\n/-\ninfo: '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-'\n-/\n#guard_msgs in\n#eval encryption \"THE QUICK BROWN FOX\""}
{"id": "fvapps_003253", "vc-description": "", "vc-preamble": "def countChar (c : Char) (s : List Char) : Nat :=\n  (s.filter (fun x => x = c)).length\n\ndef count_odd_occurrences (s : String) : Nat :=\n  let chars := s.toList\n  let counts := chars.map (fun c => countChar c chars)\n  (counts.filter (fun n => n % 2 = 1)).length", "vc-helpers": "", "vc-definitions": "def word_square (s : String) : Bool :=\nsorry", "vc-theorems": "theorem non_square_length_strings_are_false {s : String}\n  (h : ∃ n : Nat, n * n ≠ s.length) :\n  word_square s = false :=\nsorry\n\ntheorem all_same_letter_square_strings_are_valid (n : Nat) :\n  word_square (String.mk (List.replicate (n*n) 'A')) = true :=\nsorry\n\ntheorem alternating_letters_within_bounds (n : Nat) (h : n ≥ 2) :\n  let letters := List.replicate (n*n) 'A'\n  word_square (String.mk letters) = true :=\nsorry\n\ntheorem odd_count_characters_within_bounds (s : String) :\n  let n := s.length\n  if n*n ≠ s.length then\n    word_square s = false\n  else\n    word_square s = (count_odd_occurrences s ≤ n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"SATORAREPOTENETOPERAROTAS\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval word_square \"NOTSQUARE\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"CARDAREAREARDART\""}
{"id": "fvapps_003256", "vc-description": "", "vc-preamble": "def pi : Float := 3.14159", "vc-helpers": "", "vc-definitions": "def circle_area (radius : Float) : Option Float :=\n  sorry", "vc-theorems": "theorem circle_area_invalid_inputs {x : Float} (h : x ≤ 0) :\n  circle_area x = none :=\nsorry\n\ntheorem circle_area_positive_inputs {x : Float} (h : x > 0) :\n  match circle_area x with\n  | some result =>\n    result > 0\n  | none => False :=\nsorry\n\ntheorem circle_area_zero :\n  circle_area 0 = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area 0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area \"An integer\"\n\n/-\ninfo: 12.57\n-/\n#guard_msgs in\n#eval circle_area 2"}
{"id": "fvapps_003262", "vc-description": "", "vc-preamble": "def Result := String\nderiving Repr, BEq", "vc-helpers": "", "vc-definitions": "def alphabet_war (s : String) : Result :=\nsorry\n\ndef alphabet_war_valid_result (s : String) :\n  let result := alphabet_war s\n  result = \"Left side wins!\" ∨ result = \"Right side wins!\" ∨ result = \"Let's fight again!\" :=\nsorry\n\ndef only_left_letters_never_right (s : String) :\n  (∀ c ∈ s.data, c ∈ ['w', 'p', 'b', 's']) →\n  s.length > 0 →\n  alphabet_war s ≠ \"Right side wins!\" :=\nsorry\n\ndef only_right_letters_never_left (s : String) :\n  (∀ c ∈ s.data, c ∈ ['m', 'q', 'd', 'z']) →\n  s.length > 0 →\n  alphabet_war s ≠ \"Left side wins!\" :=\nsorry\n\ndef only_bombs_is_draw (s : String) :\n  (∀ c ∈ s.data, c = '*') →\n  s.length > 0 →\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ndef adjacent_bomb_nullifies (c : Char) :\n  c ∈ ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z'] →\n  alphabet_war (String.mk ['*', c]) = \"Let's fight again!\" ∧\n  alphabet_war (String.mk [c, '*']) = \"Let's fight again!\" :=\nsorry\n\ndef repeated_string_same_winner (s : String) :\n  (∀ c ∈ s.data, c ∈ ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']) →\n  s.length > 0 →\n  alphabet_war s = alphabet_war (s ++ s) :=\nsorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/-\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"z*dq*mw*pb*s\"\n\n/-\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"sz**z**zs\""}
{"id": "fvapps_003264", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_higher (start_value k : Nat) : Nat :=\nsorry\n\ndef sum_part (n : Nat) : Nat :=\nsorry\n\ndef qualified : Nat → List Nat :=\nsorry", "vc-theorems": "theorem sum_part_properties {n : Nat} (hn : n > 0 ∧ n ≤ 1000) :\n  sum_part n ≥ n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003267", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_average (marks: List Nat) : Nat :=\nsorry\n\ndef list_maximum (l: List Nat) : Nat :=\nsorry\n\ndef list_minimum (l: List Nat) : Nat :=\nsorry\n\ndef list_sum (l: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem average_in_bounds {marks: List Nat} (h: marks ≠ []) :\n  let avg := get_average marks\n  avg ≤ list_maximum marks ∧ avg ≥ list_minimum marks :=\nsorry\n\ntheorem average_equals_div_sum {marks: List Nat} (h: marks ≠ []) :\n  get_average marks = list_sum marks / marks.length :=\nsorry\n\ntheorem empty_list_error :\n  get_average [] = get_average [] → False :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_average [2, 2, 2, 2]\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval get_average [1, 5, 87, 45, 8, 8]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval get_average [2, 5, 13, 20, 16, 16, 10]"}
{"id": "fvapps_003268", "vc-description": "", "vc-preamble": "def repeat_str (s : String) (n : Nat) : String :=\nmatch n with\n| 0 => \"\"\n| n+1 => s ++ repeat_str s n", "vc-helpers": "", "vc-definitions": "def code_for_same_protein (seq1 : String) (seq2 : String) : Bool :=\nsorry", "vc-theorems": "theorem identical_sequences_match\n  (seq : String) :\n  code_for_same_protein seq seq = true :=\nsorry\n\ntheorem different_length_no_match\n  (n : Nat) :\n  code_for_same_protein (repeat_str \"ATG\" n) (repeat_str \"ATG\" (n + 1)) = false :=\nsorry\n\ntheorem different_length_sequences_no_match\n  (seq1 seq2 : String) :\n  seq1.length ≠ seq2.length →\n  code_for_same_protein seq1 seq2 = false :=\nsorry\n\ntheorem code_for_same_protein_reflexive\n  (seq : String) :\n  code_for_same_protein seq seq = true :=\nsorry\n\ntheorem code_for_same_protein_symmetric\n  (seq1 seq2 : String) :\n  code_for_same_protein seq1 seq2 = true →\n  code_for_same_protein seq2 seq1 = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTCGTCAATTTAA\" \"ATGTCGTCAATTTAA\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGTTCTAA\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGATATAA\""}
{"id": "fvapps_003270", "vc-description": "-- For any x,y > 0:\n-- If solve returns None, then sum not divisible by gcd\n-- If solve returns Some (a,b), then:\n--   a + b = sum, gcd(a,b) = gcd, a ≤ b\n\n-- For any x > 0:\n-- solve(2x, x) = (x,x)", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (sum gcd : Nat) : Option (Nat × Nat) :=\n  sorry\n\ndef gcd (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_properties (x y : Nat) (h1: x > 0) (h2: y > 0) :\n  let s := x + y\n  let g := gcd x y\n  match solve s g with\n  | none => s % g ≠ 0\n  | some (a, b) => a + b = s ∧ gcd a b = g ∧ a ≤ b\n  :=\nsorry\n\ntheorem solve_same_number (x : Nat) (h: x > 0) :\n  solve (2*x) x = some (x, x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 3]\n-/\n#guard_msgs in\n#eval solve 6 3\n\n/-\ninfo: [2, 6]\n-/\n#guard_msgs in\n#eval solve 8 2\n\n/-\ninfo: [4, 8]\n-/\n#guard_msgs in\n#eval solve 12 4"}
{"id": "fvapps_003273", "vc-description": "/- For positive integers, f(n) equals the sum of numbers from 1 to n -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For non-positive integers, f returns none -/\n\n/- For non-integer numeric inputs, f returns none -/\n\n/- For any non-numeric type α, f returns none -/\n\n/- f handles large inputs without overflow -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f (x : α) : Option Nat :=\nsorry", "vc-theorems": "theorem positive_integers_sum {n : Nat} (h : n > 0) :\n  f n = some (n * (n + 1) / 2) :=\nsorry\n\ntheorem non_positive_returns_none {n : Int} (h : n ≤ 0) :\n  f n = none :=\nsorry\n\ntheorem non_integer_returns_none (x : Float) :\n  f x = none :=\nsorry\n\ntheorem non_numeric_returns_none (α : Type) (x : α) :\n  f x = none :=\nsorry\n\ntheorem handles_large_inputs (n : Nat) :\n  f n ≠ none → ∃ m : Nat, f n = some m ∧ m > 0 :=\nsorry", "vc-postamble": "/-\ninfo: 5050\n-/\n#guard_msgs in\n#eval f 100\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval f 0\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval f 3.14"}
{"id": "fvapps_003275", "vc-description": "/- Helper functions -/\n\n/- Main theorems that match property tests -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\n  sorry\n\ndef String.strip (s : String) : String :=\n  sorry\n\ndef array (s : String) : Option String :=\n  sorry\n\ndef joinWithSpaces (xs : List String) : String :=\n  sorry", "vc-theorems": "theorem array_none_when_not_enough_commas (s : String) :\n  s.count ',' < 2 →\n  array s = none :=\nsorry\n\ntheorem array_processes_middle_elements (s : String) :\n  s.count ',' ≥ 2 →\n  array s = some (joinWithSpaces (List.map String.strip (List.drop 1 (List.take (List.length (String.splitOn \",\" s) - 1) (String.splitOn \",\" s))))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1,2\"\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval array \"1,2,3\"\n\n/-\ninfo: '2 3'\n-/\n#guard_msgs in\n#eval array \"1,2,3,4\""}
{"id": "fvapps_003277", "vc-description": "-- Helper function to simulate ceiling division", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def snail (column : Int) (day : Int) (night : Int) : Int :=\n  sorry\n\ndef ceilDiv (a b : Int) : Int :=\n  sorry", "vc-theorems": "theorem snail_result_positive {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night ≥ 0) :\n  snail column day night ≥ 1 :=\nsorry\n\ntheorem snail_reaches_top {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night ≥ 0) :\n  let result := snail column day night\n  (result * day) - ((result-1) * night) ≥ column :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval snail 3 2 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval snail 10 3 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval snail 5 10 3"}
{"id": "fvapps_003283", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubsequence (smaller larger : String) : Bool :=\n  sorry\n\ndef solve (n : Nat) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem solve_properties {n k : Nat} (h : k < (ToString.toString n).length) :\n  let result := solve n k\n  (result.length = (ToString.toString n).length - k) ∧\n  (isSubsequence result (ToString.toString n) = true) ∧\n  (result.toNat! ≤ n) :=\nsorry\n\ntheorem remove_zero_digits (n : Nat) :\n  solve n 0 = ToString.toString n :=\nsorry\n\ntheorem result_is_minimal {n k : Nat} (h1 : n ≥ 10) (h2 : k ≥ 1) (h3 : k < (ToString.toString n).length) :\n  let result := solve n k\n  ∀ (s : String),\n    isSubsequence s (ToString.toString n) = true →\n    s.length = (ToString.toString n).length - k →\n    result.toNat! ≤ s.toNat! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '05'\n-/\n#guard_msgs in\n#eval solve 123056 4\n\n/-\ninfo: '12456'\n-/\n#guard_msgs in\n#eval solve 1284569 2\n\n/-\ninfo: '12056'\n-/\n#guard_msgs in\n#eval solve 123056 1"}
{"id": "fvapps_003284", "vc-description": "", "vc-preamble": "def factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def List.prod : List Nat → Nat\n  | [] => 1\n  | x :: xs => x * prod xs\n\ndef isAscii (s : String) : Bool :=\n  sorry\n\ndef uniq_count (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem uniq_count_positive (s : String) :\n  uniq_count s > 0 :=\nsorry\n\ntheorem uniq_count_empty :\n  uniq_count \"\" = 1 :=\nsorry\n\ntheorem uniq_count_factorial_bound (s : String) :\n  uniq_count s ≤ factorial s.length :=\nsorry\n\ntheorem uniq_count_unique_chars {s : String} (h₁ : s ≠ \"\")\n  (h₂ : (s.toLower.data.eraseDups).length = s.length) :\n  uniq_count s = factorial s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval uniq_count \"ABC\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval uniq_count \"ABA\"\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval uniq_count \"AbcD\""}
{"id": "fvapps_003285", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def common_ground (s1 s2 : String) : String :=\n  sorry\n\ndef split (s : String) : List String :=\n  sorry", "vc-theorems": "theorem common_ground_subset (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result ≠ \"death\" →\n  (∀ w, w ∈ split result →\n    w ∈ split s1 ∧ w ∈ split s2) :=\nsorry\n\ntheorem common_ground_order (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result ≠ \"death\" →\n  ∀ i j, i < j → i < (split result).length → j < (split result).length →\n    let s2_words := split s2\n    let result_words := split result\n    s2_words.findIdx (· = result_words[i]!) <\n    s2_words.findIdx (· = result_words[j]!) :=\nsorry\n\ntheorem common_ground_no_overlap (s1 s2 : String) :\n  (∀ w1 w2, w1 ∈ split s1 → w2 ∈ split s2 → w1 ≠ w2) →\n  common_ground s1 s2 = \"death\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'eat chicken'\n-/\n#guard_msgs in\n#eval common_ground \"eat chicken\" \"eat chicken and rice\"\n\n/-\ninfo: 'drink a coke'\n-/\n#guard_msgs in\n#eval common_ground \"eat a burger and drink a coke\" \"drink a coke\"\n\n/-\ninfo: 'death'\n-/\n#guard_msgs in\n#eval common_ground \"i like turtles\" \"what are you talking about\""}
{"id": "fvapps_003292", "vc-description": "-- Helper function to count char occurrences in string\n\n-- If scramble returns true, first string is at least as long as second\n\n-- A string can always be scrambled to form itself\n\n-- If scramble is true, all chars in s2 appear at least as many times in s1\n\n-- Any non-empty string can be scrambled to form empty string\n\n-- Empty string cannot form non-empty string\n\n-- Strings with disjoint character sets cannot be scrambled", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def scramble (s1 s2 : String) : Bool :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem scramble_length_property (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 → scramble s1 s2 = true → s1.length ≥ s2.length :=\nsorry\n\ntheorem scramble_identical_strings (s : String) :\n  s.length > 0 → scramble s s = true :=\nsorry\n\ntheorem scramble_subset_property (s1 s2 : String) (c : Char) :\n  s1.length > 0 → s2.length > 0 → scramble s1 s2 = true →\n  (countChar s2 c) ≤ (countChar s1 c) :=\nsorry\n\ntheorem scramble_empty_second_string (s : String) :\n  s.length > 0 → scramble s \"\" = true :=\nsorry\n\ntheorem scramble_empty_first_string (c : Char) :\n  scramble \"\" (String.singleton c) = false :=\nsorry\n\ntheorem scramble_disjoint_alphabets (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 →\n  (∀ c, s1.contains c → ¬s2.contains c) →\n  scramble s1 s2 = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"rkqodlw\" \"world\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"cedewaraaossoqqyt\" \"codewars\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval scramble \"katas\" \"steak\""}
{"id": "fvapps_003293", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_consonants (s : List Char) : Nat :=\n  sorry\n\ndef isConsonant (c : Char) : Bool :=\n  sorry\n\ndef isVowel (c : Char) : Bool :=\n  sorry\n\ndef toLower (c : Char) : Char :=\n  sorry\n\ndef toCharList (s : String) : List Char :=\n  sorry", "vc-theorems": "theorem count_consonants_bounds {s : List Char} :\n  0 ≤ count_consonants s ∧ count_consonants s ≤ 21 :=\nsorry\n\ntheorem count_consonants_case_insensitive {s : List Char} :\n  count_consonants s = count_consonants (List.map toLower s) :=\nsorry\n\ntheorem count_consonants_letters_only {s s' : List Char}\n  (h : s' = List.filter Char.isAlpha s) :\n  count_consonants s = count_consonants s' :=\nsorry\n\ntheorem count_consonants_vowels_only {s : List Char}\n  (h : ∀ c, c ∈ s → isVowel c) :\n  count_consonants s = 0 :=\nsorry\n\ntheorem count_consonants_consonants_only {s : List Char} {n : Nat}\n  (h1 : ∀ c, c ∈ s → isConsonant c)\n  (h2 : n = (List.map toLower s).eraseDups.length) :\n  count_consonants s = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_consonants \"sillystring\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_consonants \"aeiou\"\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval count_consonants \"abcdefghijklmnopqrstuvwxyz\""}
{"id": "fvapps_003294", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_twos_complement (binary : String) (bits : Nat) : Int :=\nsorry\n\ndef from_twos_complement (n : Int) (bits : Nat) : String :=\nsorry\n\ndef removeWhitespace (s : String) : String :=\nsorry", "vc-theorems": "theorem twos_complement_roundtrip (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : n ≥ -(2^(bits-1))) (h4 : n ≤ 2^(bits-1) - 1) :\n  to_twos_complement (from_twos_complement n bits) bits = n :=\nsorry\n\ntheorem binary_roundtrip (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : String.length binary = bits)\n  (h4 : ∀ c ∈ binary.data, c = '0' ∨ c = '1') :\n  from_twos_complement (to_twos_complement binary bits) bits = binary :=\nsorry\n\ntheorem bit_length (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64) :\n  String.length (from_twos_complement n bits) = bits ∧\n  (∀ c ∈ (from_twos_complement n bits).data, c = '0' ∨ c = '1') :=\nsorry\n\ntheorem whitespace_handling (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : String.length (removeWhitespace binary) = bits)\n  (h4 : ∀ c ∈ (removeWhitespace binary).data, c = '0' ∨ c = '1') :\n  to_twos_complement binary bits = to_twos_complement (removeWhitespace binary) bits :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval to_twos_complement \"00000001\" 8\n\n/-\ninfo: '00000001'\n-/\n#guard_msgs in\n#eval from_twos_complement 1 8\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval to_twos_complement \"11111111\" 8\n\n/-\ninfo: '11111111'\n-/\n#guard_msgs in\n#eval from_twos_complement -1 8\n\n/-\ninfo: -1440552402\n-/\n#guard_msgs in\n#eval to_twos_complement \"1010 1010 0010 0010 1110 1010 0010 1110\" 32\n\n/-\ninfo: '10101010001000101110101000101110'\n-/\n#guard_msgs in\n#eval from_twos_complement -1440552402 32"}
{"id": "fvapps_003300", "vc-description": "", "vc-preamble": "def containsChar (s : String) (c : Char) : Bool :=\n  s.any (fun x => x == c)\n\ndef isDivisibleBy13AndNoUnluckyDigits (i : Nat) : Bool :=\n  i % 13 == 0 &&\n  !containsChar (toString i) '4' &&\n  !containsChar (toString i) '7'", "vc-helpers": "", "vc-definitions": "def unlucky_number (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem unlucky_number_non_negative (n : Nat) :\n  unlucky_number n ≥ 0 :=\nsorry\n\ntheorem unlucky_number_zero :\n  unlucky_number 0 = 1 :=\nsorry\n\ntheorem unlucky_number_twelve :\n  unlucky_number 12 = 1 :=\nsorry\n\ntheorem unlucky_number_thirteen :\n  unlucky_number 13 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval unlucky_number 20\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval unlucky_number 100\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval unlucky_number 1000"}
{"id": "fvapps_003305", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def isSorted (xs : List Nat) : Prop :=\n  ∀ i j, i < j → j < List.length xs → xs[i]! < xs[j]!", "vc-helpers": "", "vc-definitions": "def extra_perfect (n : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem extra_perfect_only_odd {n : Nat} :\n  ∀ x, x ∈ extra_perfect n → x % 2 = 1 :=\nsorry\n\ntheorem extra_perfect_bounded {n : Nat} :\n  ∀ x, x ∈ extra_perfect n → x ≤ n :=\nsorry\n\ntheorem extra_perfect_length {n : Nat} :\n  List.length (extra_perfect n) = (n + 1) / 2 :=\nsorry\n\ntheorem extra_perfect_binary_ones {n : Nat} :\n  ∀ x, x ∈ extra_perfect n →\n    ((x &&& 1) = 1) ∧\n    ((x &&& (1 <<< (Nat.log2 x))) = (1 <<< (Nat.log2 x))) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003319", "vc-description": "", "vc-preamble": "def COLOR_MAP : List (String × Nat) := [\n  (\"black\", 0), (\"brown\", 1), (\"red\", 2), (\"orange\", 3), (\"yellow\", 4),\n  (\"green\", 5), (\"blue\", 6), (\"violet\", 7), (\"gray\", 8), (\"white\", 9)\n]", "vc-helpers": "", "vc-definitions": "def decode_resistor_colors (bands : String) : String :=\nsorry\n\ndef String.toFloat (s : String) : Float :=\nsorry\n\ndef String.containsString (s : String) (substr : String) : Bool :=\nsorry", "vc-theorems": "theorem resistor_color_format\n  (first_band second_band multiplier : String)\n  (tolerance : Option String)\n  (h1 : first_band ∈ (COLOR_MAP.map (·.1)))\n  (h2 : second_band ∈ (COLOR_MAP.map (·.1)))\n  (h3 : multiplier ∈ (COLOR_MAP.map (·.1)))\n  (h4 : tolerance.getD \"\" ∈ [\"\", \"gold\", \"silver\"]) :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier} {tolerance.getD \"\"}\".trim)\n  (result.containsString \" ohms, \") ∧\n  (result.endsWith \"%\") ∧\n  (result.containsString \"\" ∨ result.containsString \"k\" ∨ result.containsString \"M\") :=\nsorry\n\ntheorem base_value_calculation\n  (first_band second_band multiplier : String)\n  (h1 : first_band ∈ [\"black\", \"brown\"])\n  (h2 : second_band ∈ [\"black\", \"brown\"])\n  (h3 : multiplier = \"black\") :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier}\")\n  let value := String.toFloat ((result.splitOn \" \").head!)\n  let expected :=\n    match COLOR_MAP.find? (·.1 = first_band), COLOR_MAP.find? (·.1 = second_band) with\n    | some (_, n1), some (_, n2) => Float.ofNat (n1 * 10 + n2)\n    | _, _ => 0.0\n  value = expected :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '47 ohms, 20%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet black\"\n\n/-\ninfo: '4.7k ohms, 5%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet red gold\"\n\n/-\ninfo: '1M ohms, 10%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"brown black green silver\""}
{"id": "fvapps_003321", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countChars (s : String) (c : Char) : Nat :=\n  sorry\n\ndef remove_exclamation_marks (s : String) : String :=\n  sorry", "vc-theorems": "theorem no_exclamation_in_result (s : String) :\n  ¬(remove_exclamation_marks s).contains '!' := by\nsorry\n\ntheorem length_after_removal (s : String) :\n  (remove_exclamation_marks s).length = s.length - (countChars s '!') := by\nsorry\n\ntheorem result_equals_remove_exclamation (s : String) :\n  (remove_exclamation_marks s).replace \"!\" \"\" = remove_exclamation_marks s := by\nsorry\n\ntheorem unchanged_without_exclamation (s : String) (h : ¬s.contains '!') :\n  remove_exclamation_marks s = s := by\nsorry\n\ntheorem concatenation_property (s₁ s₂ : String) :\n  remove_exclamation_marks s₁ ++ remove_exclamation_marks s₂ =\n  remove_exclamation_marks (s₁ ++ s₂) := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hello World!\"\n\n/-\ninfo: 'Hi Hello'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hi! Hello!\"\n\n/-\ninfo: 'Oh, no'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Oh, no!!!\""}
{"id": "fvapps_003329", "vc-description": "/- For any positive n, halving_sum(n) is at least n -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any positive n, halving_sum(n) is less than 2*n -/\n\n/- For powers of 2, halving_sum(n) equals 2*n - 1 -/\n\n/- Base cases for n=1 and n=2 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def halving_sum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem halving_sum_lower_bound (n : Nat) (h : n > 0) :\n  halving_sum n ≥ n :=\nsorry\n\ntheorem halving_sum_upper_bound (n : Nat) (h : n > 0) :\n  halving_sum n < 2*n :=\nsorry\n\ntheorem halving_sum_power_of_two (n : Nat) (h : n > 0)\n  (h_pow : ∃ k, n = 2^k) :\n  halving_sum n = 2*n - 1 :=\nsorry\n\ntheorem halving_sum_base_cases :\n  (halving_sum 1 = 1) ∧ (halving_sum 2 = 3) :=\nsorry", "vc-postamble": "/-\ninfo: 47\n-/\n#guard_msgs in\n#eval halving_sum 25\n\n/-\ninfo: 247\n-/\n#guard_msgs in\n#eval halving_sum 127\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval halving_sum 1"}
{"id": "fvapps_003332", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_key (s : String) : Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem find_key_edge_cases :\n  find_key \"0\" = 0 ∧ find_key \"1\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1080\n-/\n#guard_msgs in\n#eval find_key \"47b\"\n\n/-\ninfo: 9328\n-/\n#guard_msgs in\n#eval find_key \"2533\"\n\n/-\ninfo: 6912\n-/\n#guard_msgs in\n#eval find_key \"1ba9\""}
{"id": "fvapps_003335", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidKey (k : String) : Bool :=\n  sorry\n\ndef encode (text key : String) : String :=\n  sorry", "vc-theorems": "theorem encode_preserves_non_letters (text key : String) :\n  isValidKey key → ∀ i, ¬(text.get! i).isAlpha →\n  (encode text key).get! i = text.get! i :=\nsorry\n\ntheorem encode_preserves_case (text key : String) :\n  isValidKey key → ∀ i,\n  let c := text.get! i\n  let e := (encode text key).get! i\n  c.isAlpha → (c.isUpper = e.isUpper) :=\nsorry\n\ntheorem encode_duplicate_key_chars (text key : String) :\n  isValidKey key →\n  encode text key = encode text (String.mk (key.data.eraseDups)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cipher\"\n\n/-\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cccciiiiippphheeeeerrrrr\""}
{"id": "fvapps_003336", "vc-description": "", "vc-preamble": "def isValidInput (x : String) : Bool :=\n  x = \"goodpresent\" ∨ x = \"crap\" ∨ x = \"empty\" ∨ x = \"bang\" ∨ x = \"badpresent\" ∨ x = \"dog\"", "vc-helpers": "", "vc-definitions": "def present (x : String) (y : Int) : String :=\nsorry", "vc-theorems": "theorem present_goodpresent_length (y : Int) :\n  String.length (present \"goodpresent\" y) = String.length \"goodpresent\" :=\nsorry\n\ntheorem present_crap_fixed (y : Int) :\n  present \"crap\" y = \"acpr\" :=\nsorry\n\ntheorem present_empty_fixed (y : Int) :\n  present \"empty\" y = \"empty\" :=\nsorry\n\ntheorem present_badpresent_fixed (y : Int) :\n  present \"badpresent\" y = \"Take this back!\" :=\nsorry\n\ntheorem present_dog_contains_number (y : Int) :\n  ∃ s : String, s = toString y ∧ present \"dog\" y = s :=\nsorry\n\ntheorem present_invalid_input (x : String) (h : ¬isValidInput x) :\n  ∃ err, present x 0 = err :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Take this back!'\n-/\n#guard_msgs in\n#eval present \"badpresent\" 3\n\n/-\ninfo: 'pxxmy{n|nw}'\n-/\n#guard_msgs in\n#eval present \"goodpresent\" 9\n\n/-\ninfo: 'pass out from excitement 23 times'\n-/\n#guard_msgs in\n#eval present \"dog\" 23"}
{"id": "fvapps_003342", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (xs : List Int) : Int :=\nsorry\n\ndef minimum (xs : List Int) : Int :=\nsorry\n\ndef sorted (xs : List Int) : List Int :=\nsorry\n\ndef max_gap (xs : List Int) : Int :=\nsorry", "vc-theorems": "theorem max_gap_positive (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs ≥ 0 :=\nsorry\n\ntheorem max_gap_bounded_by_range (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs ≤ maximum xs - minimum xs :=\nsorry\n\ntheorem max_gap_in_consecutive_diffs (xs : List Int) (h : xs.length ≥ 2) :\n  ∃ i : Nat, i < xs.length - 1 ∧\n    max_gap xs = (sorted xs).get ⟨i+1, sorry⟩ - (sorted xs).get ⟨i, sorry⟩ :=\nsorry\n\ntheorem max_gap_reversal_invariant (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs = max_gap xs.reverse :=\nsorry\n\ntheorem max_gap_nonnegative_bounded (xs : List Int) (h : xs.length ≥ 2)\n  (h2 : ∀ x ∈ xs, x ≥ 0) :\n  max_gap xs ≤ maximum xs :=\nsorry\n\ntheorem max_gap_translation_invariant (xs : List Int) (c : Int) (h : xs.length ≥ 2) :\n  max_gap xs = max_gap (xs.map (· + c)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gap [13, 10, 2, 9, 5]\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval max_gap [-3, -27, -4, -2]\n\n/-\ninfo: 576\n-/\n#guard_msgs in\n#eval max_gap [-54, 37, 0, 64, -15, 640, 0]"}
{"id": "fvapps_003343", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef is_valid_password (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem valid_password_conditions (s : String) :\n  (s.length ≥ 8) →\n  (∃ c, c ∈ s.data ∧ isLower c) →\n  (∃ c, c ∈ s.data ∧ isUpper c) →\n  (∃ c, c ∈ s.data ∧ isDigit c) →\n  is_valid_password s = true :=\nsorry\n\ntheorem invalid_password_too_short (s : String) :\n  s.length < 8 →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_upper (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isUpper c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_lower (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isLower c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_digit (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isDigit c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem empty_password_invalid :\n  is_valid_password \"\" = false :=\nsorry\n\ntheorem short_password_invalid :\n  is_valid_password \"aA1\" = false :=\nsorry\n\ntheorem valid_min_length_password :\n  is_valid_password \"aaaaA111\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd1234\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd123\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"abcd1234\""}
{"id": "fvapps_003347", "vc-description": "/- Property: Output contains both inputs and format is consistent -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Property: Quotes appear in correct places only -/\n\n/- Property: Function is deterministic -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def quotable (name : String) (quote : String) : String :=\nsorry", "vc-theorems": "theorem quotable_format (name quote : String)\n  (h1 : ¬ String.contains name '\"')\n  (h2 : ¬ String.contains quote '\"') :\n  (quotable name quote).startsWith name ∧\n  (quotable name quote).endsWith ('\"'.toString ++ quote ++ '\"'.toString) ∧\n  String.contains (quotable name quote) ' ' :=\nsorry\n\ntheorem quotable_quotes_placement (name quote : String)\n  (h1 : ¬ String.contains name '\"')\n  (h2 : ¬ String.contains quote '\"') :\n  ((quotable name quote).data.filter (· = '\"')).length = 2 :=\nsorry\n\ntheorem quotable_deterministic (name quote : String) :\n  quotable name quote = quotable name quote :=\nsorry", "vc-postamble": "/-\ninfo: 'Grae said: \"Practice makes perfect\"'\n-/\n#guard_msgs in\n#eval quotable \"Grae\" \"Practice makes perfect\"\n\n/-\ninfo: 'Alex said: \"Python is great fun\"'\n-/\n#guard_msgs in\n#eval quotable \"Alex\" \"Python is great fun\"\n\n/-\ninfo: 'Bethany said: \"Yes, way more fun than R\"'\n-/\n#guard_msgs in\n#eval quotable \"Bethany\" \"Yes, way more fun than R\""}
{"id": "fvapps_003349", "vc-description": "", "vc-preamble": "def song_durations : List String :=\n  [\"03:36\", \"06:48\", \"04:27\", \"03:50\", \"04:32\", \"04:22\", \"03:30\", \"03:25\", \"04:34\"]", "vc-helpers": "", "vc-definitions": "def calculate_seconds (time_str : String) : Nat :=\n  sorry\n\ndef longest_possible (seconds : Int) : Option String :=\n  sorry", "vc-theorems": "theorem calculate_seconds_basic_properties {minutes seconds : Nat}\n  (h1 : minutes ≤ 59) (h2 : seconds ≤ 59) :\n  (calculate_seconds s!\"{minutes}:{seconds}\" = minutes * 60 + seconds) ∧\n  (calculate_seconds s!\"{minutes}:{seconds}\" ≥ 0) :=\nsorry\n\ntheorem longest_possible_properties (seconds : Int) :\n  match longest_possible seconds with\n  | some result =>\n    result ∈ song_durations ∧\n    calculate_seconds result ≤ seconds ∧\n    ∀ s ∈ song_durations,\n      calculate_seconds s ≤ seconds →\n      calculate_seconds s ≤ calculate_seconds result\n  | none =>\n    ∀ duration ∈ song_durations,\n      calculate_seconds duration > seconds :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'For Reasons Unknown'\n-/\n#guard_msgs in\n#eval longest_possible 215\n\n/-\ninfo: 'YYZ'\n-/\n#guard_msgs in\n#eval longest_possible 270\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval longest_possible 13\n\n/-\ninfo: 'Surfing With The Alien'\n-/\n#guard_msgs in\n#eval longest_possible 300"}
{"id": "fvapps_003350", "vc-description": "", "vc-preamble": "def valid_mersenne_numbers : List Int :=\n  [2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279]", "vc-helpers": "", "vc-definitions": "def valid_mersenne (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem valid_mersenne_returns_bool (n : Int) :\n  valid_mersenne n = true ∨ valid_mersenne n = false :=\nsorry\n\ntheorem valid_mersenne_outside_range {n : Int} :\n  (n < 1 ∨ n > 1279) → valid_mersenne n = false :=\nsorry\n\ntheorem valid_mersenne_deterministic (n : Int) :\n  valid_mersenne n = valid_mersenne n :=\nsorry\n\ntheorem valid_mersenne_in_set {n : Int} :\n  1 ≤ n ∧ n ≤ 1279 →\n  valid_mersenne n = true ↔ n ∈ valid_mersenne_numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_mersenne 11\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 127"}
{"id": "fvapps_003355", "vc-description": "/- For accessing array elements safely -/", "vc-preamble": "def get? {α : Type} (xs : List α) (i : Nat) : Option α :=\n  if h : i < xs.length then some (xs.get ⟨i, h⟩) else none", "vc-helpers": "", "vc-definitions": "def cog_RPM (cogs: List Nat) (n: Nat) : List Int :=\nsorry", "vc-theorems": "theorem single_cog_property {cogs : List Nat} {n : Nat} (h : cogs.length = 1) :\n  cog_RPM cogs 0 = [1, 1] :=\nsorry\n\ntheorem cog_direction_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length) :\n  ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n  ((x > 0) ↔ (n % 2 = 0)) ∧\n  ((y > 0) ↔ ((cogs.length - n) % 2 = 1)) :=\nsorry\n\ntheorem cog_ratio_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : ∀ i, get? cogs i ≠ none) :\n  match get? cogs n, get? cogs 0, get? cogs (cogs.length - 1) with\n  | some cn, some c0, some cl =>\n    ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n    x.natAbs = cn / c0 ∧\n    y.natAbs = cn / cl\n  | _, _, _ => True :=\nsorry\n\ntheorem identical_cogs_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : ∀ i j, i < cogs.length → j < cogs.length → get? cogs i = get? cogs j) :\n  ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n  x.natAbs = 1 ∧ y.natAbs = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100] 0\n\n/-\ninfo: [1, -1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 0\n\n/-\ninfo: [-1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 1"}
{"id": "fvapps_003356", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isEven (x : Int) : Bool :=\n  sorry\n\ndef isFloat (x : Float) : Bool :=\n  sorry\n\ndef isEvenFloat (x : Float) : Bool :=\n  sorry", "vc-theorems": "theorem even_plus_two (x : Int) :\n  isEven x = isEven (x + 2) :=\nsorry\n\ntheorem even_plus_one_diff (x : Int) :\n  isEven x ≠ isEven (x + 1) :=\nsorry\n\ntheorem times_two_even (x : Int) :\n  isEven (x * 2) = true :=\nsorry\n\ntheorem non_integer_float_not_even (x : Float) :\n  ¬isFloat x → isEvenFloat x = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_even 2\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 0.5"}
{"id": "fvapps_003361", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def morse_converter (s : String) : Nat :=\n  sorry\n\ndef convertToMorse (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem morse_converter_output_valid (s : String) :\n  let result := morse_converter s\n  result ≥ 0\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 11111\n-/\n#guard_msgs in\n#eval morse_converter \".----.----.----.----.----\"\n\n/-\ninfo: 207600\n-/\n#guard_msgs in\n#eval morse_converter \"..----------...-....----------\"\n\n/-\ninfo: 1234567890\n-/\n#guard_msgs in\n#eval morse_converter \".----..---...--....-.....-....--...---..----.-----\""}
{"id": "fvapps_003378", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countInversion (s : List Int) : Nat :=\nsorry\n\ndef isSorted (s : List Int) : Bool :=\nsorry\n\ndef isAntiSorted (s : List Int) : Bool :=\nsorry", "vc-theorems": "theorem countInversion_nonnegative (s : List Int) :\n  countInversion s ≥ 0 :=\nsorry\n\ntheorem countInversion_sorted_zero (s : List Int) :\n  isSorted s = true → countInversion s = 0 :=\nsorry\n\ntheorem countInversion_reverse_sorted_max (s : List Int) :\n  let maxInv := s.length * (s.length - 1) / 2\n  isAntiSorted s = true → countInversion s ≤ maxInv :=\nsorry\n\ntheorem countInversion_small_seq (s : List Int) :\n  s.length ≤ 1 → countInversion s = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_inversion (1, 2, 5, 3, 4, 7, 6)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversion (0, 1, 2, 3)\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_inversion (3, 2, 1, 0)"}
{"id": "fvapps_003386", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (nums : List Nat) : Nat :=\nsorry\n\ndef sums (l : List Nat) : List Nat :=\nsorry\n\ndef findMin (s : List Nat) : Nat :=\nsorry\n\ndef sortList (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem solve_returns_positive (nums : List Nat)\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 1000)\n  : solve nums > 0 :=\nsorry\n\ntheorem solve_order_invariant (nums : List Nat)\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 100)\n  : solve nums = solve (sortList nums) :=\nsorry\n\ntheorem solve_is_min_missing_sum {nums : List Nat}\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 10)\n  (h2 : nums.length ≤ 5)\n  : solve nums = findMin (sums nums) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003389", "vc-description": "", "vc-preamble": "def listSum : List Nat → Nat\n| [] => 0\n| x::xs => x + listSum xs\n\ndef listMin : List Nat → Nat\n| [] => 0\n| [x] => x\n| x::xs => min x (listMin xs)\n\ndef secondMin : List Nat → Nat\n| [] => 0\n| [_] => 0\n| l =>\n  let m := listMin l\n  listMin (l.filter (fun x => x ≠ m))", "vc-helpers": "", "vc-definitions": "def solve (chips : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_two_identical_bounded (a b : Nat)\n  (h₁ : a > 0)\n  (h₂ : b > 0) :\n  solve [a, a, b] ≤ (a + a + b) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve [1, 1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [1, 2, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve [8, 2, 8]"}
{"id": "fvapps_003400", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def proc_seq : List Nat → List Nat\n  | xs => sorry\n\ndef countPermNoLeadingZero (n : Nat) (m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem proc_seq_valid_output (nums : List Nat) :\n  let result := proc_seq nums\n  (result.length = 2 ∨ result.length = 4) ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  (result.length = 2 → result.head! = 1) ∧\n  (result.length = 4 →\n    result[1]! ≤ result[2]! ∧ result[1]! ≤ result[3]!) :=\nsorry\n\ntheorem proc_seq_leading_zeros (n : Nat) (h : n ≥ 100 ∧ n ≤ 999) :\n  let result := proc_seq [n, 0]\n  result.head! = countPermNoLeadingZero n 0 :=\nsorry\n\ntheorem proc_seq_small_nums {nums : List Nat} (h : 2 ≤ nums.length ∧ nums.length ≤ 3)\n  (h' : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 9) :\n  let result := proc_seq nums\n  (result.length = 2 ∨ result.length = 4) ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  (result.length = 2 → result.head! = 1) ∧\n  (result.length = 4 →\n    result[1]! ≤ result[2]! ∧ result[1]! ≤ result[3]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [8, 218, 379, 2388]\n-/\n#guard_msgs in\n#eval proc_seq 23 17 89\n\n/-\ninfo: [1, 2222]\n-/\n#guard_msgs in\n#eval proc_seq 22 22 22 22\n\n/-\ninfo: [4, 218, 358, 1152]\n-/\n#guard_msgs in\n#eval proc_seq 230 15 8"}
{"id": "fvapps_003405", "vc-description": "-- Length matches\n\n-- All counts are non-negative (satisfied by Nat type)\n\n-- Each count matches actual occurrences\n\n-- Count cannot exceed length of array1", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count {α} [BEq α] (a : α) (xs : List α) : Nat :=\n  sorry\n\ndef solve {α} [BEq α] (array1 array2 : List α) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_properties {α} [BEq α] (array1 array2 : List α)\n  (h1 : array1 ≠ []) (h2 : array2 ≠ []) :\n  let result := solve array1 array2;\n\n  result.length = array2.length\n\n  ∧ (∀ i elem, i < array2.length → array2.get ⟨i, by sorry⟩ = elem →\n      result.get ⟨i, by sorry⟩ = count elem array1)\n\n  ∧ ∀ x ∈ result, x ≤ array1.length :=\nsorry\n\ntheorem solve_identical_arrays {α} [BEq α] (array : List α)\n  (h : array ≠ []) :\n  let result := solve array array;\n  ∀ i c x, i < array.length →\n    result.get ⟨i, by sorry⟩ = c →\n    array.get ⟨i, by sorry⟩ = x →\n    c = count x array :=\nsorry\n\ntheorem solve_unique_array2 {α} [BEq α] (array1 array2 : List α)\n  (h1 : array1 ≠ []) (h2 : array2 ≠ [])\n  (unique : ∀ i j, i < array2.length → j < array2.length → i ≠ j →\n    array2.get ⟨i, by sorry⟩ ≠ array2.get ⟨j, by sorry⟩) :\n  solve array1 array2 = array2.map (λ x => count x array1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"abc\", \"xyz\", \"abcd\", \"cde\"] [\"abc\", \"cde\", \"uap\"]\n\n/-\ninfo: [2, 1, 2]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"xyz\", \"abc\", \"xyz\", \"cde\"] [\"abc\", \"cde\", \"xyz\"]\n\n/-\ninfo: [2, 0, 1]\n-/\n#guard_msgs in\n#eval solve [\"quick\", \"brown\", \"fox\", \"is\", \"quick\"] [\"quick\", \"abc\", \"fox\"]"}
{"id": "fvapps_003406", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def doors (n : Nat) : Nat :=\nsorry\n\ndef sqrt (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem doors_non_negative (n : Nat) :\n  doors n ≥ 0 :=\nsorry\n\ntheorem doors_squared_leq (n : Nat) :\n  (doors n) * (doors n) ≤ n :=\nsorry\n\ntheorem doors_plus_one_squared_gt (n : Nat) :\n  (doors n + 1) * (doors n + 1) > n :=\nsorry\n\ntheorem doors_perfect_squares (n : Nat) :\n  doors (n * n) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval doors 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval doors 10\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval doors 100"}
{"id": "fvapps_003407", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def greatest (x y n : Nat) : Nat :=\n  sorry\n\ndef smallest (x y n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem divisible_by_inputs {x y n : Nat} (hx : x > 0) (hy : y > 0) :\n  let g := greatest x y (max x y * 2)\n  let s := smallest x y (max x y * 2)\n  g % x = 0 ∧ g % y = 0 ∧ s % x = 0 ∧ s % y = 0 :=\nsorry\n\ntheorem bounds {x y n : Nat} (hx : x > 0) (hy : y > 0) (hn : n > 0) :\n  let g := greatest x y n\n  let s := smallest x y n\n  g < n ∧ s > n ∧ s > g :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval greatest 2 3 20\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval smallest 2 3 20\n\n/-\ninfo: 90\n-/\n#guard_msgs in\n#eval greatest 5 15 100\n\n/-\ninfo: 105\n-/\n#guard_msgs in\n#eval smallest 5 15 100\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval greatest 123 456 789\n\n/-\ninfo: 18696\n-/\n#guard_msgs in\n#eval smallest 123 456 789"}
{"id": "fvapps_003413", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_f1_eq_f2 (n : Nat) (k : Nat) : Nat :=\nsorry\n\ndef appears_in (d : Nat) (n : Nat) : Prop :=\nsorry", "vc-theorems": "theorem find_f1_eq_f2_basic_case_1 :\n  find_f1_eq_f2 542 5 = 547 :=\nsorry\n\ntheorem find_f1_eq_f2_generates_digits (n k : Nat) (testn := find_f1_eq_f2 n k) :\n  ∃ m : Nat, ∀ d : Nat, d < k → ∃ i : Nat, i ≤ m ∧ appears_in d (testn * i) :=\nsorry\n\ntheorem find_f1_eq_f2_basic_case_2 :\n  find_f1_eq_f2 1750 6 = 1799 :=\nsorry\n\ntheorem find_f1_eq_f2_greater_than_input (n k : Nat) :\n  find_f1_eq_f2 n k ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 547\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 542 5\n\n/-\ninfo: 1799\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 1750 6\n\n/-\ninfo: 14996\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 14990 7"}
{"id": "fvapps_003415", "vc-description": "/- For small perfect cubes (n ≤ 10), find_nb correctly returns n when given sum of first n cubes -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any volume that isn't sum of consecutive cubes, find_nb returns -1 -/\n\n/- find_nb returns -1 for non-positive inputs -/\n\n/- For valid inputs, find_nb returns a positive number that produces the input volume -/\n\n/- Any positive result from find_nb produces the claimed volume -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nb (n : Int) : Int :=\nsorry\n\ndef sum_cubes (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_nb_small_perfect_cubes (n : Nat) (h : n ≤ 10) :\n  find_nb (sum_cubes n) = n :=\nsorry\n\ntheorem find_nb_invalid_volumes {n : Int} (h : n > 0) :\n  find_nb n = -1 ∨ sum_cubes (find_nb n).toNat = n :=\nsorry\n\ntheorem find_nb_nonpositive {n : Int} (h : n ≤ 0) :\n  find_nb n = -1 :=\nsorry\n\ntheorem find_nb_valid_result (n : Nat) :\n  let volume := sum_cubes n\n  let result := find_nb volume\n  result > 0 ∧ sum_cubes result.toNat = volume :=\nsorry\n\ntheorem find_nb_produces_volume {n : Int} (h : find_nb n > 0) :\n  sum_cubes (find_nb n).toNat = n :=\nsorry", "vc-postamble": "/-\ninfo: 45\n-/\n#guard_msgs in\n#eval find_nb 1071225\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_nb 91716553919377\n\n/-\ninfo: 2022\n-/\n#guard_msgs in\n#eval find_nb 4183059834009"}
{"id": "fvapps_003418", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_dig (n: Nat) : Nat :=\nsorry\n\ndef is_happy (n: Nat) : Bool :=\nsorry\n\ndef performant_numbers (n: Nat) : List Nat :=\nsorry", "vc-theorems": "theorem sum_dig_nonnegative (n: Nat) :\n  sum_dig n ≥ 0 :=\nsorry\n\ntheorem sum_dig_upper_bound (n: Nat) (k: Nat) :\n  sum_dig n ≤ k * 81 :=\nsorry\n\ntheorem is_happy_bool_result (n: Nat) :\n  is_happy n = true ∨ is_happy n = false :=\nsorry\n\ntheorem known_happy_numbers (n: Nat) :\n  n = 1 ∨ n = 7 ∨ n = 10 ∨ n = 13 ∨ n = 19 ∨ n = 23 ∨ n = 28 ∨ n = 31 →\n  is_happy n = true :=\nsorry\n\ntheorem known_unhappy_numbers (n: Nat) :\n  n = 2 ∨ n = 3 ∨ n = 4 ∨ n = 5 ∨ n = 6 ∨ n = 8 ∨ n = 9 →\n  is_happy n = false :=\nsorry\n\ntheorem performant_numbers_sorted (n: Nat) :\n  let result := performant_numbers n\n  ∀ i < result.length - 1,\n    result[i]! ≤ result[i+1]! :=\nsorry\n\ntheorem performant_numbers_bounded (n: Nat) :\n  ∀ x ∈ performant_numbers n, x ≤ n :=\nsorry\n\ntheorem performant_numbers_contains_happy (n: Nat) :\n  ∀ x ∈ [1, 7, 10, 13, 19, 23, 28, 31],\n    x ≤ n → x ∈ performant_numbers n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 7, 10]\n-/\n#guard_msgs in\n#eval performant_numbers 10\n\n/-\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49]\n-/\n#guard_msgs in\n#eval performant_numbers 50\n\n/-\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100]\n-/\n#guard_msgs in\n#eval performant_numbers 100"}
{"id": "fvapps_003426", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def looseChange (coins: List Nat) (amount: Nat) : Int :=\n  sorry\n\ndef listMin (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem looseChange_result_bound (coins: List Nat) (amount: Nat) :\n  coins.length > 0 → let result := looseChange coins amount\n  result ≥ -1 := by\nsorry\n\ntheorem looseChange_zero (coins: List Nat) :\n  coins.length > 0 → looseChange coins 0 = 0 := by\nsorry\n\ntheorem looseChange_small_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  amount > 0 →\n  amount < listMin coins →\n  looseChange coins amount = -1 := by\nsorry\n\ntheorem looseChange_bounded_by_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  looseChange coins amount ≠ -1 →\n  looseChange coins amount ≤ amount := by\nsorry\n\ntheorem looseChange_optimal (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  let result := looseChange coins amount\n  result ≠ -1 →\n  ∀ (c : Nat),\n  c ∈ coins →\n  ¬∃ (n : Nat), n > result ∧ n * c = amount := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval loose_change [1, 5, 10, 25] 37\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval loose_change [1, 3, 4] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval loose_change [25, 5, 10, 1, 21] 63"}
{"id": "fvapps_003429", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sieve (n : Nat) : List Nat :=\nsorry\n\ndef prime_primes (n : Nat) : Nat × Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem sieve_sorted (n : Nat) (h : n ≥ 2) :\n  let primes := sieve n\n  ∀ i h1 h2, primes.get ⟨i, h1⟩ < primes.get ⟨i+1, h2⟩ :=\nsorry\n\ntheorem prime_primes_nonneg (n : Nat) (h : n ≥ 2) :\n  let (count, total) := prime_primes n\n  count ≥ 0 ∧ total ≥ 0 :=\nsorry\n\ntheorem prime_primes_small_bound (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let (count, _) := prime_primes n\n  count ≤ n * n / 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003432", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_dd (n : Nat) : Bool :=\nsorry\n\ndef countDigit (n : Nat) (d : Nat) : Nat :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem dd_characterization (n : Nat) :\n  is_dd n = (∃ d : Nat, 1 ≤ d ∧ d ≤ 9 ∧ countDigit n d = d) :=\nsorry\n\ntheorem zero_not_counted (n : Nat) :\n  (∀ d : Nat, d ≠ 0 → countDigit n d ≠ d) →\n  is_dd n = false :=\nsorry\n\ntheorem count_digit_bounds (n d : Nat) :\n  countDigit n d ≤ (digits n).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 664444309\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 122\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 30313\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_dd 5023011"}
{"id": "fvapps_003438", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isArithmeticSequence (arr : List Int) : Bool :=\n  sorry\n\ndef sumOfRegularNumbers (arr : List Int) : Int :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem regular_numbers_properties {arr : List Int} (h : arr.length ≥ 3) :\n  let result := sumOfRegularNumbers arr\n  (result ≥ 0 ∨ (result < 0 ∧ ∃ x ∈ arr, x < 0)) ∧\n  (result ≠ 0 → ∃ i, i + 2 < arr.length ∧\n    isArithmeticSequence (arr.take 3))\n  :=\nsorry\n\ntheorem three_element_sequence {arr : List Int} (h : arr.length = 3) :\n  let d₁ := arr[0]! - arr[1]!\n  let d₂ := arr[1]! - arr[2]!\n  d₁ = d₂ → sumOfRegularNumbers arr = sum arr ∧\n  d₁ ≠ d₂ → sumOfRegularNumbers arr = 0 :=\nsorry\n\ntheorem non_overlapping_sequences {arr : List Int} (h : arr.length ≥ 4) :\n  let result := sumOfRegularNumbers arr\n  result > 0 →\n  ∃ i, i + 2 < arr.length ∧\n  (arr[i]! - arr[i+1]! = arr[i+1]! - arr[i+2]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 639\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]\n\n/-\ninfo: 1200\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [7, 2, 3, 2, -2, 400, 802]\n\n/-\ninfo: -13994\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [-1, 7000, 1, -6998, -13997]"}
{"id": "fvapps_003445", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingWeight (n: Nat) : Nat :=\nsorry\n\ndef bitLength (n: Nat) : Nat :=\nsorry\n\ndef isPowerOfTwo (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem hamming_weight_nonnegative_and_bounded (x: Nat) :\n  hammingWeight x ≥ 0 ∧ hammingWeight x ≤ bitLength x :=\nsorry\n\ntheorem hamming_weight_power_of_two (x: Nat) :\n  x > 0 → isPowerOfTwo x → hammingWeight x = 1 :=\nsorry\n\ntheorem hamming_weight_zero_and_nonzero (x: Nat) :\n  hammingWeight 0 = 0 ∧ (x > 0 → hammingWeight x > 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval hamming_weight 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_weight 10\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_weight 21\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2048"}
{"id": "fvapps_003446", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shuffleIt {α : Type} : List α → List (Nat × Nat) → List α\n  | xs, swaps => sorry\n\ndef swapAt {α : Type} (xs : List α) (i j : Nat) (h₁ : i < xs.length) (h₂ : j < xs.length) : List α :=\n  sorry", "vc-theorems": "theorem shuffleIt_preserves_length {α : Type} (xs : List α) (swaps : List (Nat × Nat))\n  (h : ∀ p ∈ swaps, p.1 < xs.length ∧ p.2 < xs.length) :\n  (shuffleIt xs swaps).length = xs.length :=\nsorry\n\ntheorem shuffleIt_preserves_elements {α : Type} [BEq α] (xs : List α) (swaps : List (Nat × Nat))\n  (h : ∀ p ∈ swaps, p.1 < xs.length ∧ p.2 < xs.length) :\n  ∀ x, x ∈ xs ↔ x ∈ shuffleIt xs swaps :=\nsorry\n\ntheorem shuffleIt_no_swaps {α : Type} (xs : List α) :\n  shuffleIt xs [] = xs :=\nsorry\n\ntheorem shuffleIt_single_swap {α : Type} (xs : List α) (i j : Nat)\n  (h₁ : i < xs.length) (h₂ : j < xs.length) :\n  shuffleIt xs [(i,j)] = swapAt xs i j h₁ h₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 2, 4, 5]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2]\n\n/-\ninfo: [1, 3, 2, 5, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4]\n\n/-\ninfo: [1, 3, 5, 2, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4] [2, 3]"}
{"id": "fvapps_003447", "vc-description": "/- Helper function to get nth char of string -/\n\n/- Type class for types that shouldn't be reversed -/", "vc-preamble": "def getNth (s : String) (n : Nat) : Char := s.data.get! n\n\nclass NonString (α : Type)", "vc-helpers": "", "vc-definitions": "def reverse_it {α : Type} (x : α) : α :=\nsorry", "vc-theorems": "theorem reverse_it_string_length {s : String} :\n  String.length (reverse_it s) = String.length s :=\nsorry\n\ntheorem reverse_it_string_reverses {s : String} {i : Nat} (h : i < String.length s) :\n  getNth (reverse_it s) i = getNth s (String.length s - 1 - i) :=\nsorry\n\ntheorem reverse_it_non_string_identity {α : Type} [NonString α] (x : α) :\n  reverse_it x = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'olleH'\n-/\n#guard_msgs in\n#eval reverse_it \"Hello\"\n\n/-\ninfo: 951413\n-/\n#guard_msgs in\n#eval reverse_it 314159\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval reverse_it [1, 2, 3]"}
{"id": "fvapps_003449", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef isBouncyStr (s : String) : Bool :=\nsorry\n\ndef bouncyRatio (n : Float) : Float :=\nsorry", "vc-theorems": "theorem bouncy_sequence_property {n : Nat} (h : n ≥ 100) (h2 : n ≤ 100000) :\n  isBouncyStr (toString n) = true →\n  ∃ i j : String.Pos, i < j ∧\n  ((toString n).get i < (toString n).get j) ∧\n  ∃ k l : String.Pos, k < l ∧\n  ((toString n).get k > (toString n).get l) :=\nsorry\n\ntheorem bouncy_ratio_validation_zero :\n  ¬ ∃ x : Float, x = bouncyRatio 0 :=\nsorry\n\ntheorem bouncy_ratio_validation_one :\n  ¬ ∃ x : Float, x = bouncyRatio 1 :=\nsorry\n\ntheorem bouncy_ratio_validation_negative (n : Float) :\n  n < 0 →\n  ¬ ∃ x : Float, x = bouncyRatio n :=\nsorry\n\ntheorem bouncy_ratio_validation_above_one (n : Float) :\n  n > 1 →\n  ¬ ∃ x : Float, x = bouncyRatio n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 538\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.5\n\n/-\ninfo: 21780\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.9\n\n/-\ninfo: 3088\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.75"}
{"id": "fvapps_003450", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef getFirstNPrimes (n : Nat) : List Nat :=\n  sorry\n\ndef numPrimorial (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem primorial_equals_product_of_first_n_primes (n : Nat)\n  (h : n ≥ 1 ∧ n ≤ 10) :\n  numPrimorial n = (getFirstNPrimes n).foldl (·*·) 1 :=\nsorry\n\ntheorem primorial_is_strictly_increasing {n : Nat}\n  (h1 : n ≥ 1 ∧ n ≤ 10) (h2 : n > 1) :\n  numPrimorial n > numPrimorial (n-1) :=\nsorry\n\ntheorem primorial_is_divisible_by_smaller_primorials {n : Nat}\n  (h1 : n ≥ 1 ∧ n ≤ 10) (h2 : n > 1) :\n  numPrimorial n % numPrimorial (n-1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval num_primorial 3\n\n/-\ninfo: 2310\n-/\n#guard_msgs in\n#eval num_primorial 5\n\n/-\ninfo: 9699690\n-/\n#guard_msgs in\n#eval num_primorial 8"}
{"id": "fvapps_003456", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def distribute (nodes : Nat) (workload : Nat) : List (List Nat) :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listMinimum (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem distribute_length {nodes workload : Nat}\n  (h : nodes ≤ workload ∨ workload = 0) :\n  (distribute nodes workload).length = nodes :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [[0, 1], [2, 3]]\n-/\n#guard_msgs in\n#eval distribute 2 4\n\n/-\ninfo: [[0], [1], [2]]\n-/\n#guard_msgs in\n#eval distribute 3 3\n\n/-\ninfo: [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n-/\n#guard_msgs in\n#eval distribute 4 10"}
{"id": "fvapps_003460", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (arr : List Int) : List Int :=\n  sorry\n\ndef list_max (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem solve_maintains_elements {arr : List Int} (h : arr ≠ []) :\n  let result := solve arr\n  result.length = arr.length ∧\n  ∀ x, (result.count x = arr.count x) :=\nsorry\n\ntheorem solve_alternates_high_low {arr : List Int} (h : arr.length ≥ 2) :\n  let result := solve arr\n  ∀ i, i + 1 < result.length → i % 2 = 0 →\n  (result.get ⟨i, sorry⟩) ≥ (result.get ⟨i+1, sorry⟩) :=\nsorry\n\ntheorem solve_first_element_is_max {arr : List Int} (h : arr ≠ []) :\n  let result := solve arr\n  ∀ i, i < result.length →\n  (result.get ⟨0, sorry⟩) ≥ (result.get ⟨i, sorry⟩) :=\nsorry\n\ntheorem solve_empty_and_single {arr : List Int} :\n  arr.length ≤ 1 → solve arr = arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [15, 11, 10, 7, 12]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [91, 75, 86, 14, 82]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [1, 6, 9, 4, 3, 7, 8, 2]"}
{"id": "fvapps_003461", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def summy (s : String) : Int :=\nsorry\n\ndef sum (l : List Int) : Int :=\nsorry\n\ndef stringToList (s : String) : List Int :=\nsorry", "vc-theorems": "theorem summy_matches_direct_sum (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \" \" (List.map toString l)) = sum l :=\nsorry\n\ntheorem summy_handles_whitespace (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \"   \" (List.map toString l)) = sum l :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval summy \"1 2 3\"\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval summy \"10 10\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval summy \"0 0\""}
{"id": "fvapps_003462", "vc-description": "", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def aa_percentage (seq : String) (residues : List Char := ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) : Nat :=\nsorry", "vc-theorems": "theorem default_residues_in_bounds (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  0 ≤ aa_percentage seq ∧ aa_percentage seq ≤ 100 :=\nsorry\n\ntheorem custom_residues_in_bounds (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  0 ≤ aa_percentage seq residues ∧ aa_percentage seq residues ≤ 100 :=\nsorry\n\ntheorem empty_residues_gives_zero (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq [] = 0 :=\nsorry\n\ntheorem residue_count_matches (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  aa_percentage seq residues =\n    ((sum_list (residues.map (λ r => seq.data.count r))) * 100 + seq.length / 2) / seq.length :=\nsorry\n\ntheorem default_residues_consistent (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq = aa_percentage seq ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V'] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval aa_percentage \"MSRSLLLRFLLFLLLLPPLP\" [\"M\"]\n\n/-\ninfo: 29\n-/\n#guard_msgs in\n#eval aa_percentage \"RLMADDFFGQTLMAAAAAAQERRR\" [\"A\"]\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval aa_percentage \"PLPPLPLLEELELRPFFMAAGGTPLAMMGG\""}
{"id": "fvapps_003465", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def seqR : String → Bool\n  | _ =>\nsorry\n\ndef seqB : String → Bool\n  | _ => sorry\n\ndef button_sequences (r : String) (b : String) : String :=\n  sorry", "vc-theorems": "theorem button_sequences_valid_chars (r b : String) (h : r.length > 0 ∧ b.length > 0) :\n  ∀ c, c ∈ (button_sequences r b).toList → c = 'R' ∨ c = 'B' :=\nsorry\n\ntheorem button_sequences_length (r b : String) (h : r.length > 0 ∧ b.length > 0) :\n  (button_sequences r b).length ≤ min r.length b.length :=\nsorry\n\ntheorem button_sequences_all_zeros_red (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  ∀ c, c ∈ (button_sequences s zeros).toList → c = 'R' :=\nsorry\n\ntheorem button_sequences_all_zeros_blue (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  ∀ c, c ∈ (button_sequences zeros s).toList → c = 'B' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'RBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10011010\" \"10110111\"\n\n/-\ninfo: 'RB'\n-/\n#guard_msgs in\n#eval button_sequences \"01001000\" \"01011100\"\n\n/-\ninfo: 'RBRBRBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10101010\" \"01010101\""}
{"id": "fvapps_003471", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\n  sorry\n\ndef swap (s : String) (n : Nat) : String :=\n  sorry\n\ndef swapcase (c : Char) : Char :=\n  sorry", "vc-theorems": "theorem swap_length_preserved (s : String) (n : Nat) :\n  (swap s n).length = s.length :=\nsorry\n\ntheorem swap_nonalpha_preserved (s : String) (n : Nat) (pos : String.Pos) :\n  ¬isAlpha (s.get pos) → (swap s n).get pos = s.get pos :=\nsorry\n\ntheorem swap_alpha_case (s : String) (n : Nat) (pos : String.Pos) :\n  isAlpha (s.get pos) →\n  (s.get pos).toLower = ((swap s n).get pos).toLower :=\nsorry\n\ntheorem swap_zero_identity (s : String) :\n  swap s 0 = s :=\nsorry\n\ntheorem swap_pattern_matches_binary (s : String) (n : Nat) (pos : String.Pos)\n    (binPattern : String) (idx : String.Pos) :\n  isAlpha (s.get pos) →\n  binPattern = (toString n).dropWhile (· = '0') →\n  (binPattern.get idx = '1' →\n    (swap s n).get pos = swapcase (s.get pos)) ∧\n  (binPattern.get idx = '0' →\n    (swap s n).get pos = s.get pos) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'heLLO wORLd!'\n-/\n#guard_msgs in\n#eval swap \"Hello world!\" 11\n\n/-\ninfo: 'GooD MorNIng'\n-/\n#guard_msgs in\n#eval swap \"gOOd MOrniNg\" 7864\n\n/-\ninfo: 'the lord of the rings'\n-/\n#guard_msgs in\n#eval swap \"the lord of the rings\" 0"}
{"id": "fvapps_003472", "vc-description": "/- Our variance function -/\n\n/- Our variance matches statistics.pvariance -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Words of same length have variance 0 -/\n\n/- Variance is always nonnegative -/\n\n/- Empty list raises error -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pvariance (xs : List String) : Float :=\nsorry\n\ndef variance (xs : List String) : Float :=\nsorry", "vc-theorems": "theorem variance_matches_pvariance (words : List String) (h : words ≠ []) :\n  variance words = pvariance words :=\nsorry\n\ntheorem same_length_zero_variance (words : List String) (h1 : words ≠ [])\n  (h2 : ∀ w ∈ words, w.length = 5) : variance words = 0 :=\nsorry\n\ntheorem variance_nonnegative (words : List String) (h : words.length ≥ 2) :\n  variance words ≥ 0 :=\nsorry\n\ntheorem empty_list_error :\n  variance [] = 0/0 :=\nsorry", "vc-postamble": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval variance [\"Hello\", \"world\"]\n\n/-\ninfo: 2.25\n-/\n#guard_msgs in\n#eval variance [\"Hi\", \"world\"]\n\n/-\ninfo: 7.5556\n-/\n#guard_msgs in\n#eval variance [\"Variance\", \"is\", \"not\", \"a\", \"good\", \"stimator\"]"}
{"id": "fvapps_003473", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose (n m : Nat) : Nat :=\n  sorry\n\ndef count_paths (n: Nat) (start_pos: Nat × Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_paths_one_by_one {n: Nat} (h: n = 1) :\n  count_paths n (0, 0) = 0 :=\nsorry\n\ntheorem count_paths_non_negative {n row col: Nat} (h1: row < n) (h2: col < n) (h3: n > 0) :\n  count_paths n (row, col) ≥ 0 :=\nsorry\n\ntheorem count_paths_only_vertical {n row col: Nat} (h1: col = n - 1) (h2: row > 0) (h3: row < n) (h4: n > 0) :\n  count_paths n (row, col) = 1 :=\nsorry\n\ntheorem count_paths_only_horizontal {n row col: Nat} (h1: row = 0) (h2: col < n - 1) (h3: n > 0) :\n  count_paths n (row, col) = 1 :=\nsorry\n\ntheorem count_paths_start_equals_target {n: Nat} (h: n ≥ 2) :\n  count_paths n (0, n-1) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_paths 1 (0, 0)\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_paths 2 (1, 0)\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_paths 3 (1, 0)\n\n/-\ninfo: 70\n-/\n#guard_msgs in\n#eval count_paths 5 (4, 0)"}
{"id": "fvapps_003476", "vc-description": "-- Result has length 4\n\n-- Elements follow x+y, x-y, x*y, x/y pattern for some x\n\n-- Elements are positive\n\n-- Sum equals input n\n\n-- If no solution, divmod has remainder", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + sum_list t\n\ndef nth : List Nat → Nat → Option Nat\n  | [], _ => none\n  | (h :: t), 0 => some h\n  | (h :: t), n+1 => nth t n", "vc-helpers": "", "vc-definitions": "def four_piles (n : Nat) (y : Nat) : Option (List Nat) :=\nsorry", "vc-theorems": "theorem four_piles_properties_solution (n y : Nat) (h1 : n > 0) (h2 : y > 0) (h3 : y ≤ 100) :\n  match four_piles n y with\n  | some result =>\n\n    result.length = 4 ∧\n\n    ∃ x : Nat,\n      (nth result 0 = some (x + y)) ∧\n      (nth result 1 = some (x - y)) ∧\n      (nth result 2 = some (x * y)) ∧\n      (nth result 3 = some (x / y)) ∧\n\n    (∀ i ∈ result, i > 0) ∧\n\n    sum_list result = n\n  | none =>\n\n    let prod := n * y\n    let denom := (y + 1) * (y + 1)\n    prod % denom ≠ 0 ∨ (prod / denom = y)\n  :=\nsorry\n\ntheorem four_piles_properties_positive (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => ∀ x ∈ result, x > 0\n  | none => True\n  :=\nsorry\n\ntheorem four_piles_properties_sum (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => sum_list result = n\n  | none => True\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [12, 6, 27, 3]\n-/\n#guard_msgs in\n#eval four_piles 48 3\n\n/-\ninfo: [20, 12, 64, 4]\n-/\n#guard_msgs in\n#eval four_piles 100 4\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval four_piles 25 4"}
{"id": "fvapps_003480", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mid_endian (n : Nat) : String :=\nsorry\n\ndef natToHexString (n : Nat) : String :=\nsorry\n\ndef splitInPairs (s : String) : List String :=\nsorry", "vc-theorems": "theorem mid_endian_idempotent_bytes (n : Nat) :\n  let result := mid_endian n\n  let pairs := splitInPairs result\n  String.join pairs = result :=\nsorry\n\ntheorem mid_endian_valid_hex (n : Nat) :\n  ∃ h, (mid_endian n).toNat? = some h :=\nsorry\n\ntheorem mid_endian_even_length (n : Nat) :\n  (mid_endian n).length % 2 = 0 :=\nsorry\n\ntheorem mid_endian_sufficient_length (n : Nat) :\n  (mid_endian n).length ≥ (natToHexString n).length :=\nsorry\n\ntheorem mid_endian_hex_chars (n : Nat) :\n  ∀ i : Fin (mid_endian n).length,\n    (mid_endian n).data.get i ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] :=\nsorry\n\ntheorem mid_endian_single_byte (n : Nat) (h : n ≤ 0xFF) :\n  mid_endian n = natToHexString n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '96987F'\n-/\n#guard_msgs in\n#eval mid_endian 9999999\n\n/-\ninfo: '00'\n-/\n#guard_msgs in\n#eval mid_endian 0\n\n/-\ninfo: '0B0A0C'\n-/\n#guard_msgs in\n#eval mid_endian 658188"}
{"id": "fvapps_003486", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def totient (n : Int) : Int :=\nsorry\n\ndef gcd (a b : Int) : Int :=\nsorry\n\ndef isPrime (n : Int) : Bool :=\nsorry\n\ndef isInt (n : Int) : Bool :=\nsorry\n\ndef countCoprimes (n : Int) : Int :=\nsorry", "vc-theorems": "theorem totient_matches_coprime_count (n : Int) (h : n > 0) :\n  totient n = countCoprimes n :=\nsorry\n\ntheorem totient_invalid_inputs (n : Int) (h : n ≤ 0) :\n  totient n = 0 :=\nsorry\n\ntheorem totient_multiplicative (n₁ n₂ : Int) (h₁ : gcd n₁ n₂ = 1) (h₂ : n₁ > 0) (h₃ : n₂ > 0) :\n  totient (n₁ * n₂) = totient n₁ * totient n₂ :=\nsorry\n\ntheorem totient_prime (p : Int) (h₁ : p > 1) (h₂ : isPrime p) :\n  totient p = p - 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003489", "vc-description": "", "vc-preamble": "def sumList (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def toBase (num base : Nat) : String :=\n  sorry\n\ndef sumItUp (nums : List (String × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem sum_it_up_equals_decimal_sum {nums : List (Nat × Nat)} :\n  ∀ pairs : List (String × Nat),\n  (∀ p : String × Nat, p ∈ pairs →\n    ∃ n ∈ nums, p.1 = toBase n.1 p.2) →\n  sumItUp pairs = sumList (nums.map Prod.fst) :=\nsorry\n\ntheorem sum_it_up_empty : sumItUp [] = 0 :=\nsorry\n\ntheorem sum_it_up_single {n : String} {b : Nat} :\n  b ≥ 2 → b ≤ 36 →\n  ∃ k : Nat, sumItUp [(n, b)] = k :=\nsorry\n\ntheorem base_conversion_roundtrip {n : Nat} {b : Nat} :\n  n ≤ 1000000 → b ≥ 2 → b ≤ 36 →\n  ∃ k : Nat, k = n ∧ String.toNat! (toBase n b) = k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 2], [\"10\", 8]]\n\n/-\ninfo: 2751\n-/\n#guard_msgs in\n#eval sum_it_up [[\"ABC\", 16], [\"11\", 2]]\n\n/-\ninfo: 4258\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 16], [\"7640\", 8], [\"1\", 9]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_it_up []"}
{"id": "fvapps_003503", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) (idx : Nat) : Int :=\nsorry\n\ndef has_matching_parens (s : String) : Bool :=\nsorry\n\ndef is_valid_idx (s : String) (idx : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_invalid_index {s : String} {idx : Nat} :\n  ¬(is_valid_idx s idx) → solve s idx = -1 :=\nsorry\n\ntheorem solve_unmatched_parens {s : String} {idx : Nat} :\n  ¬(has_matching_parens s) → solve s idx = -1 :=\nsorry\n\ntheorem solve_valid_result {s : String} {idx : Nat} :\n  (solve s idx ≠ -1) →\n  is_valid_idx s idx ∧\n  (∃ result : Nat, solve s idx = result ∧\n    idx < s.length ∧ result < s.length ∧\n    s.data[idx]! = '(' ∧\n    s.data[result]! = ')' ∧\n    has_matching_parens (String.mk (List.take (result + 1 - idx) (List.drop idx s.data)))) :=\nsorry\n\ntheorem solve_all_open_parens {s : String} :\n  (∀ c ∈ s.data, c = '(') →\n  ∀ i : Nat, i < s.length →\n  solve s i = -1 :=\nsorry\n\ntheorem solve_all_close_parens {s : String} :\n  (∀ c ∈ s.data, c = ')') →\n  ∀ i : Nat, i < s.length →\n  solve s i = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 0\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 1\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval solve \"(g(At)IO(f)(tM(qk)YF(n)Nr(E)))\" 11"}
{"id": "fvapps_003504", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_a_down_arrow_of (n : Nat) : String :=\nsorry\n\ndef String.lines (s : String) : List String :=\nsorry\n\ndef String.padLeft (n : Nat) (c : Char) (s : String) : String :=\nsorry\n\ndef charToNat (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem arrow_length (n : Nat) (h : 0 < n ∧ n ≤ 9) :\n  (get_a_down_arrow_of n).lines.length = n :=\nsorry\n\ntheorem arrow_leading_spaces (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let line := lines[i]!\n  (∃ rest : String, line = String.padLeft i ' ' rest) ∧\n  line.trim ≠ \"\" :=\nsorry\n\ntheorem arrow_decreasing_widths (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n - 1) :\n  let lines := (get_a_down_arrow_of n).lines\n  lines[i]!.length > lines[i+1]!.length :=\nsorry\n\ntheorem arrow_line_symmetry (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let stripped := lines[i]!.trim\n  let mid := stripped.length / 2\n  stripped.take mid = stripped.drop (mid+1) :=\nsorry\n\ntheorem arrow_sequential_digits (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let digits := lines[i]!.data.filter Char.isDigit\n  (∀ d ∈ digits, 0 < charToNat d ∧ charToNat d < 10) ∧\n  (digits.length > 1 →\n    ∀ j < digits.length/2 - 1,\n      charToNat digits[j+1]! - charToNat digits[j]! = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003515", "vc-description": "", "vc-preamble": "def CHARS_WITH_RINGS := \"abdegopqABBDOPQR\"\n\ndef POSSIBLE_OUTPUTS := [\"Not even a medal!\", \"Bronze!\", \"Silver!\", \"Gold!\"]", "vc-helpers": "", "vc-definitions": "def olympic_ring (s : String) : String :=\nsorry", "vc-theorems": "theorem output_in_possible_values (s : String) :\n  olympic_ring s ∈ POSSIBLE_OUTPUTS :=\nsorry\n\ntheorem empty_string_not_medal (s : String) :\n  (∀ c, c ∈ s.data → c ∉ CHARS_WITH_RINGS.data) →\n  olympic_ring s = \"Not even a medal!\" :=\nsorry\n\ntheorem no_ring_chars_not_medal (s : String) :\n  (∀ c, c ∈ s.data → c ∉ CHARS_WITH_RINGS.data) →\n  olympic_ring s = \"Not even a medal!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bronze!'\n-/\n#guard_msgs in\n#eval olympic_ring \"wHjMudLwtoPGocnJ\"\n\n/-\ninfo: 'Not even a medal!'\n-/\n#guard_msgs in\n#eval olympic_ring \"JKniLfLW\"\n\n/-\ninfo: 'Gold!'\n-/\n#guard_msgs in\n#eval olympic_ring \"IMBAWejlGRTDWetPS\""}
{"id": "fvapps_003526", "vc-description": "-- Helper function to check if character is uppercase\n\n-- Helper function to check if character is digit\n\n-- Helper function to check if string starts with 0 and uppercase letter\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encoder (s : String) : String :=\nsorry\n\ndef decoder (s : String) : String :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef startsWithZeroUpper (s : String) : Bool :=\nsorry", "vc-theorems": "theorem encoder_output_format (s : String) (h : s ≠ \"\") :\n  (∀ c, c ∈ s.toList → isDigit c ∨ isUpper c) ∧\n  startsWithZeroUpper (encoder s) :=\nsorry\n\ntheorem encoder_length_bounds (s : String) (h : s ≠ \"\") :\n  String.length (encoder s) ≤ 3 * String.length s ∧\n  String.length (encoder s) ≥ String.length s / 2 :=\nsorry\n\ntheorem encoder_decoder_inverse (s : String) (h : s ≠ \"\") :\n  decoder (encoder s) = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003534", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def average (l : List Int) : Int :=\n  sorry\n\ndef list_min (l : List Int) : Int :=\n  sorry\n\ndef list_max (l : List Int) : Int :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem average_in_range (l : List Int) (h : l ≠ []) :\n  let result := average l\n  let min_val := list_min l\n  let max_val := list_max l\n  min_val ≤ result ∧ result ≤ max_val := by\n  sorry\n\ntheorem average_close_to_mean (l : List Int) (h : l ≠ []) :\n  let result := average l\n  let mean := (list_sum l) / (List.length l)\n  (result - mean) < 1 ∧ (mean - result) < 1 := by\n  sorry\n\ntheorem average_shift (l : List Int) (shift : Int) (h : l ≠ []) :\n  average (List.map (· + shift) l) = average l + shift := by\n  sorry\n\ntheorem average_empty :\n  average [] = 0 ∧ False := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_003535", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_change (arr : List Int) : Nat :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem array_change_returns_nonnegative (arr : List Int) (h : arr.length ≥ 1) :\n  array_change arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval array_change [1, 1, 1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval array_change [-1000, 0, -2, 0]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval array_change [2, 1, 10, 1]"}
{"id": "fvapps_003542", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_perfect_square (n : Nat) : Bool :=\n  sorry\n\ndef square_sums_row (n : Nat) : Option (List Nat) :=\n  sorry", "vc-theorems": "theorem square_sums_row_length {n : Nat} {result : List Nat} :\n  square_sums_row n = some result → result.length = n :=\nsorry\n\ntheorem square_sums_row_elements {n : Nat} {result : List Nat} :\n  square_sums_row n = some result →\n  result = (List.map (λ x => x + 1) (List.range n)) :=\nsorry\n\ntheorem square_sums_row_adjacent_pairs {n : Nat} {result : List Nat} :\n  square_sums_row n = some result →\n  ∀ i, i < result.length - 1 →\n  is_perfect_square (result[i]! + result[i+1]!) = true :=\nsorry\n\ntheorem square_sums_row_impossible_cases :\n  (square_sums_row 2 = none) ∧\n  (square_sums_row 3 = none) ∧\n  (square_sums_row 5 = none) ∧\n  (square_sums_row 24 = none) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 24\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval len square_sums_row(15)\n\n/-\ninfo: list(range(1, 16))\n-/\n#guard_msgs in\n#eval sorted result"}
{"id": "fvapps_003545", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isInt (n : Nat) : Bool :=\nsorry\n\ndef isDiceList (l : List Nat) : Bool :=\nsorry\n\ndef isValidDiceDesc : String → Bool :=\nsorry\n\ndef extractSides : String → Option Nat :=\nsorry\n\ndef roll (desc : String) (verbose : Bool := false) : Bool ⊕ (List Nat × Int) :=\nsorry", "vc-theorems": "theorem valid_roll_structure {desc : String} {result : List Nat × Int}\n  (h : roll desc true = Sum.inr result) :\n  ∃ (dice : List Nat) (modifier : Int), result = (dice, modifier) ∧\n  ∀ d ∈ dice, isInt d :=\nsorry\n\ntheorem invalid_roll {desc : String} (h : ¬isValidDiceDesc desc) :\n  roll desc false = Sum.inl false :=\nsorry\n\ntheorem non_string_input {α : Type} {x : α} [ToString α] :\n  roll (toString x) false = Sum.inl false :=\nsorry\n\ntheorem roll_range_properties {desc : String} {result : List Nat × Int} {sides : Nat}\n  (h₁ : roll desc true = Sum.inr result)\n  (h₂ : extractSides desc = some sides) :\n  ∀ die ∈ result.1, 1 ≤ die ∧ die ≤ sides :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll {}\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"abc\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval len result1[\"dice\"]"}
{"id": "fvapps_003549", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sim (k n : Nat) (p : Float) : Float :=\n  sorry\n\ndef compute (k n m x : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sim_monotonic (k n : Nat)\n  (h1 : k ≥ 1) (h2 : n ≥ 2) :\n  sim k n 0 ≤ sim k n 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003555", "vc-description": "", "vc-preamble": "def LOWER : String :=\n  \"abcdefghijklmnopqrstuvwxyz\"", "vc-helpers": "", "vc-definitions": "def encode (message : String) (key : String) (shift : Int) : String :=\n  sorry\n\ndef decode (message : String) (key : String) (shift : Int) : String :=\n  sorry", "vc-theorems": "theorem encode_decode_roundtrip\n  {message key : String} {shift : Int}\n  (h1 : ∀ c ∈ message.data, c.toString ∈ LOWER.data.map toString)\n  (h2 : key.length > 0)\n  (h3 : ∀ c ∈ key.data, c.toString ∈ LOWER.data.map toString) :\n  decode (encode message key shift) key shift = message :=\nsorry\n\ntheorem non_alphabet_chars_unchanged\n  {message key : String} {shift : Int}\n  (h1 : key.length > 0)\n  (h2 : ∀ c ∈ key.data, c.toString ∈ LOWER.data.map toString) :\n  ∀ (i : Nat) (h3 : i < message.length),\n    (message.data.get ⟨i, h3⟩) ∉ LOWER.data →\n    (encode message key shift).data.get ⟨i, sorry⟩ = message.data.get ⟨i, h3⟩ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'jx'\n-/\n#guard_msgs in\n#eval encode \"on\" \"cryptogram\" 10\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode \"jx\" key shift\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"keyword\" 5\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"secret\" 7"}
{"id": "fvapps_003562", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def value_at (poly: List Int) (x: Float) : Float :=\nsorry\n\ndef aCb (a: Float) (b: Int) : Float :=\nsorry\n\ndef intToFloat (i: Int) : Float :=\nsorry", "vc-theorems": "theorem value_at_results_finite (poly: List Int) (x: Float) (h1: poly.length > 0)\n  (h2: -10 ≤ x ∧ x ≤ 10) : ∃ (y: Float), value_at poly x = y :=\nsorry\n\ntheorem aCb_matches_binomial (a b: Int) (h1: 0 ≤ a ∧ a ≤ 10) (h2: 0 ≤ b ∧ b ≤ 10)\n  (h3: b ≤ a) : ∃ (y: Float), aCb (intToFloat a) b = y :=\nsorry\n\ntheorem aCb_results_finite (a: Float) (b: Int) (h1: -10 ≤ a ∧ a ≤ 10)\n  (h2: 0 ≤ b ∧ b ≤ 5) : ∃ (y: Float), aCb a b = y :=\nsorry\n\ntheorem value_at_constant (c: Int) (h1: -10 ≤ c ∧ c ≤ 10) :\n  (value_at [c] 123 - intToFloat c) < 0.01 ∧ (intToFloat c - value_at [c] 123) < 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7] 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 2\n\n/-\ninfo: 4.24\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 0.6"}
{"id": "fvapps_003566", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def Nat.is_even (n : Nat) : Bool := n % 2 == 0", "vc-helpers": "", "vc-definitions": "def goldbach_partitions : Nat → List String :=\nsorry\n\ndef is_prime : Nat → Bool :=\nsorry", "vc-theorems": "theorem goldbach_odd_numbers_empty (n : Nat) :\n  n % 2 = 1 → goldbach_partitions n = [] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003568", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def word_mesh (words : List String) : String :=\nsorry\n\ndef isResult (s : String) : Bool :=\nsorry\n\ndef hasOverlap (s1 s2 : String) : Bool :=\nsorry\n\ndef isLowerAlpha (s : String) : Bool :=\nsorry", "vc-theorems": "theorem word_mesh_output_format\n  (words : List String)\n  (h1 : words.length ≥ 2)\n  (h2 : words.length ≤ 10)\n  (h3 : ∀ w ∈ words, w.length > 0) :\n  let result := word_mesh words\n  (result = \"failed to mesh\" ∨ isLowerAlpha result) :=\nsorry\n\ntheorem word_mesh_successful_overlap\n  (words : List String)\n  (h1 : words.length ≥ 2)\n  (h2 : words.length ≤ 5)\n  (h3 : ∀ w ∈ words, w.length > 0)\n  (h4 : ∀ i, i < words.length - 1 →\n    hasOverlap (words.get ⟨i, by sorry⟩) (words.get ⟨i+1, by sorry⟩)) :\n  let result := word_mesh words\n  result ≠ \"failed to mesh\" →\n  ∀ i, i < words.length - 1 →\n    hasOverlap (words.get ⟨i, by sorry⟩) (words.get ⟨i+1, by sorry⟩) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'lowringter'\n-/\n#guard_msgs in\n#eval word_mesh [\"allow\", \"lowering\", \"ringmaster\", \"terror\"]\n\n/-\ninfo: 'failed to mesh'\n-/\n#guard_msgs in\n#eval word_mesh [\"kingdom\", \"dominator\", \"notorious\", \"usual\", \"allegory\"]\n\n/-\ninfo: 'conumcal'\n-/\n#guard_msgs in\n#eval word_mesh [\"beacon\", \"condominium\", \"umbilical\", \"california\"]"}
{"id": "fvapps_003576", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getAllPrimeFactors (n : Int) : List Int :=\nsorry\n\ndef getUniquePrimeFactorsWithCount (n : Int) : List (List Int) :=\nsorry\n\ndef getUniquePrimeFactorsWithProducts (n : Int) : List Int :=\nsorry", "vc-theorems": "theorem prime_factors_product_equals_input {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  factors ≠ [] → factors.foldl (·*·) 1 = n :=\nsorry\n\ntheorem prime_factors_are_ordered {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  factors.length > 1 →\n  ∀ i : Fin (factors.length - 1), factors[i] ≤ factors[i.val + 1] :=\nsorry\n\ntheorem negative_inputs {n : Int} (h : n < 0) :\n  getAllPrimeFactors n = [] ∧\n  getUniquePrimeFactorsWithCount n = [[], []] ∧\n  getUniquePrimeFactorsWithProducts n = [] :=\nsorry\n\ntheorem count_matches_occurrences {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  factors ≠ [] →\n  ∀ (p c : Int),\n  List.zip uniqueWithCount[0]! uniqueWithCount[1]! |>.contains (p, c) →\n  (factors.filter (·= p)).length = c :=\nsorry\n\ntheorem products_match_prime_power {n : Int} (h : 0 ≤ n) :\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  let products := getUniquePrimeFactorsWithProducts n\n  uniqueWithCount[0]! ≠ [] →\n  products.length = uniqueWithCount[0]!.length ∧\n  ∀ (p c prod : Int),\n  List.zip (List.zip uniqueWithCount[0]! uniqueWithCount[1]!) products |>.contains ((p, c), prod) →\n  prod = p * c :=\nsorry\n\ntheorem edge_cases :\n  getAllPrimeFactors 0 = [] ∧\n  getUniquePrimeFactorsWithCount 0 = [[], []] ∧\n  getUniquePrimeFactorsWithProducts 0 = [] ∧\n  getAllPrimeFactors 1 = [1] ∧\n  getUniquePrimeFactorsWithCount 1 = [[1], [1]] ∧\n  getUniquePrimeFactorsWithProducts 1 = [1] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 2, 5, 5]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 0\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 1\n\n/-\ninfo: [[2, 5], [2, 2]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 100\n\n/-\ninfo: [[], []]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 0\n\n/-\ninfo: [[1], [1]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 1\n\n/-\ninfo: [4, 25]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 0\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 1"}
{"id": "fvapps_003577", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def name_file (fmt: String) (nbr: Int) (start: Int) : List String :=\n  sorry\n\ndef containsIndexNo (s: String) : Bool :=\n  sorry\n\ndef containsNumber (s: String) (n: Int) : Bool :=\n  sorry", "vc-theorems": "theorem name_file_length\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000) :\n  (name_file fmt nbr start).length = nbr := by\nsorry\n\ntheorem name_file_index_numbers\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000)\n  (h5: containsIndexNo fmt = true) :\n  ∀ (i: Nat), i < nbr →\n    containsNumber (List.get! (name_file fmt nbr start) i) (start + i) = true := by\nsorry\n\ntheorem name_file_no_index\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000)\n  (h5: containsIndexNo fmt = false) :\n  ∀ (x: String), x ∈ name_file fmt nbr start → x = fmt := by\nsorry\n\ntheorem name_file_invalid_number\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr ≤ 0) :\n  name_file fmt nbr start = [] := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_003578", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def execute (cmd : String) : String :=\n  sorry\n\ndef isValidOutput (result : String) : Bool :=\n  sorry", "vc-theorems": "theorem output_format_valid (cmd : String) :\n  isValidOutput (execute cmd) := by\n  sorry\n\ntheorem empty_input_yields_asterisk (cmd : String) :\n  cmd = \"\" → execute cmd = \"*\" := by\n  sorry\n\ntheorem rotation_only_yields_single_point (cmd : String)\n  (h : ∀ c ∈ cmd.data, c = 'R') :\n  execute cmd = \"*\" := by\n  sorry\n\ntheorem result_contains_origin (cmd : String) :\n  let result := execute cmd\n  result ≠ \"*\" →\n  ∃ line, line ∈ result.splitOn \"\\r\\n\" ∧ ('*' ∈ line.data) := by\n  sorry\n\ntheorem straight_line_is_continuous (cmd : String)\n  (h : ∀ c ∈ cmd.data, c = 'F') :\n  let result := execute cmd\n  (result.data.filter (· = '*')).length = cmd.length + 1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '*'\n-/\n#guard_msgs in\n#eval execute \"\"\n\n/-\ninfo: '******'\n-/\n#guard_msgs in\n#eval execute \"FFFFF\"\n\n/-\ninfo: '    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   '\n-/\n#guard_msgs in\n#eval execute \"LFFFFFRFFFRFFFRFFFFFFF\""}
{"id": "fvapps_003579", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_1D (x y : Nat) (size : Nat × Nat) : Nat :=\n  sorry\n\ndef to_2D (idx : Nat) (size : Nat × Nat) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem to_1D_to_2D_roundtrip (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let (x2, y2) := to_2D (to_1D x' y' size) size\n  x2 = x' ∧ y2 = y' :=\nsorry\n\ntheorem to_2D_to_1D_roundtrip (idx width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let idx' := idx % (width * height)\n  let (x, y) := to_2D idx' size\n  to_1D x y size = idx' :=\nsorry\n\ntheorem to_1D_bounds (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let idx := to_1D x' y' size\n  0 ≤ idx ∧ idx < width * height :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval to_1D 0 0 (3, 3)\n\n/-\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval to_2D 0 (3, 3)\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval to_1D 1 1 (3, 3)\n\n/-\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval to_2D 4 (3, 3)\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval to_1D 2 3 (4, 6)\n\n/-\ninfo: (2, 3)\n-/\n#guard_msgs in\n#eval to_2D 14 (4, 6)"}
{"id": "fvapps_003580", "vc-description": "", "vc-preamble": "def YES : String := \"In with a chance\"\n\ndef NO : String := \"Plenty more fish in the sea\"", "vc-helpers": "", "vc-definitions": "def validateNumber (phone : String) : String :=\nsorry", "vc-theorems": "theorem valid_number_format (phone : String) (h1 : String.length phone > 0) :\n  validateNumber phone = YES ∨ validateNumber phone = NO :=\nsorry\n\ntheorem valid_uk_mobile (phone : String) (h1 : String.startsWith phone \"+44\" ∨ String.startsWith phone \"0\")\n    (h2 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :=\nsorry\n\ntheorem invalid_number_wrong_prefix (phone : String)\n    (h1 : ¬String.startsWith phone \"+44\" ∧ ¬String.startsWith phone \"0\") :\n  validateNumber phone = NO :=\nsorry\n\ntheorem invalid_number_wrong_length (phone : String)\n    (h1 : String.length (String.replace phone \"[^0-9]\" \"\") ≠ 11) :\n  validateNumber phone = NO :=\nsorry\n\ntheorem validates_with_dashes (phone : String)\n    (h1 : String.contains phone '-')\n    (h2 : String.startsWith (String.replace phone \"-\" \"\") \"+44\" ∨\n          String.startsWith (String.replace phone \"-\" \"\") \"0\")\n    (h3 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"07454876120\"\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"0745--487-61-20\"\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"+447535514555\"\n\n/-\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"0754876120\"\n\n/-\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"+337535512555\""}
{"id": "fvapps_003595", "vc-description": "/- Helper function for pentagonal numbers -/\n\n/- Helper function for generalized pentagonal numbers -/", "vc-preamble": "def pen (n : Int) : Int := (3*n*n - n) / 2\n\ndef gen_pen (n : Int) : Int :=\n  if n >= 0 then (3*n*n - n) / 2 else (3*n*n + n) / 2", "vc-helpers": "", "vc-definitions": "def p_num (n : Int) : Bool :=\nsorry\n\ndef g_p_num (n : Int) : Bool :=\nsorry\n\ndef s_p_num (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem g_p_num_for_gen_pen (n : Int) : g_p_num (gen_pen n) = true :=\nsorry\n\ntheorem s_p_num_is_square_of_pentagonal_number {n : Int} (h : s_p_num n = true) :\n  ∃ k : Int,\n    k * k = n ∧\n    p_num k = true ∧\n    g_p_num n = true :=\nsorry\n\ntheorem non_square_not_s_p_num {n : Int} (h : ¬∃ k : Int, k * k = n) :\n  s_p_num n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 0\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 100\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 0\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 5\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 9801\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval s_p_num 100"}
{"id": "fvapps_003596", "vc-description": "", "vc-preamble": "def throw_points (r : Float) : Nat :=\n  if r < 5 then 10\n  else if r ≤ 10 then 5\n  else 0\n\ndef bonus_points (radiuses : List Float) : Nat :=\n  match radiuses with\n  | [] => 0\n  | xs => if (∀ r ∈ xs, r < 5) then 100 else 0", "vc-helpers": "", "vc-definitions": "def score_throws (radiuses : List Float) : Nat :=\nsorry", "vc-theorems": "theorem score_throws_empty :\n  score_throws [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval score_throws [1, 5, 11]\n\n/-\ninfo: 140\n-/\n#guard_msgs in\n#eval score_throws [1, 2, 3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval score_throws []"}
{"id": "fvapps_003598", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def moment_of_time_in_space (s : String) : List Bool :=\n  sorry\n\ndef sum_digits (s : String) : Nat :=\n  sorry\n\ndef count_non_digits (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem output_is_three_bools (s : String) :\n  let result := moment_of_time_in_space s\n  List.length result = 3 ∧\n  List.all result (fun x => x = true ∨ x = false) :=\nsorry\n\ntheorem exactly_one_true (s : String) :\n  let result := moment_of_time_in_space s\n  let count := List.foldl (fun acc b => acc + if b then 1 else 0) 0 result\n  count = 1 :=\nsorry\n\ntheorem time_space_comparison (s : String) :\n  let time := sum_digits s\n  let space := count_non_digits s\n  let result := moment_of_time_in_space s\n  (time < space → result = [true, false, false]) ∧\n  (time = space → result = [false, true, false]) ∧\n  (time > space → result = [false, false, true]) :=\nsorry\n\ntheorem permutation_invariant {s₁ s₂ : String} :\n  s₁.length = s₂.length →\n  (∀ c, s₁.find (· = c) = s₂.find (· = c)) →\n  moment_of_time_in_space s₁ = moment_of_time_in_space s₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [True, False, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"01:00 pm\"\n\n/-\ninfo: [False, True, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:02 pm\"\n\n/-\ninfo: [False, False, True]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:30 pm\""}
{"id": "fvapps_003604", "vc-description": "", "vc-preamble": "def iterateN (f : Nat → Nat) : Nat → Nat → Nat\n  | 0, x => x\n  | n+1, x => iterateN f n (f x)", "vc-helpers": "", "vc-definitions": "def find_the_ball (start : Nat) (swaps : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem find_the_ball_no_swaps (start : Nat) :\n  find_the_ball start [] = start :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_the_ball 5 []\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2)]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2), (2, 3)]"}
{"id": "fvapps_003607", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def spreadsheet (s : String) : String :=\nsorry\n\ndef is_valid_a1 (s : String) : Bool :=\nsorry\n\ndef is_valid_r1c1 (s : String) : Bool :=\nsorry", "vc-theorems": "theorem a1_conversion {s : String} (h : is_valid_a1 s = true) :\n  is_valid_r1c1 (spreadsheet s) = true ∧\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem r1c1_conversion {s : String} (h : is_valid_r1c1 s = true) :\n  is_valid_a1 (spreadsheet s) = true ∧\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem conversion_idempotent_a1 {s : String} (h : is_valid_a1 s = true) :\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem conversion_idempotent_r1c1 {s : String} (h : is_valid_r1c1 s = true) :\n  spreadsheet (spreadsheet s) = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'R1C1'\n-/\n#guard_msgs in\n#eval spreadsheet \"A1\"\n\n/-\ninfo: 'AA48'\n-/\n#guard_msgs in\n#eval spreadsheet \"R48C27\"\n\n/-\ninfo: 'R12C63'\n-/\n#guard_msgs in\n#eval spreadsheet \"BK12\""}
{"id": "fvapps_003619", "vc-description": "-- Simplified for demo\n\n-- Simplified for demo", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Real := Int\n\ndef does_fred_need_houseboat (x y : Int) : Int :=\n  sorry\n\ndef pi : Int := 3\n\ndef ceil (r : Int) : Int :=\n  sorry", "vc-theorems": "theorem does_fred_need_houseboat_nonnegative {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y ≥ 0 := by\n  sorry\n\ntheorem does_fred_need_houseboat_symmetric {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y = does_fred_need_houseboat (-x) y := by\n  sorry\n\ntheorem does_fred_need_houseboat_increases {x y cx cy : Int}\n  (h1 : y ≥ 0)\n  (h2 : x.natAbs > 0 ∨ y > 0)\n  (h3 : cx = x / 2)\n  (h4 : cy = y / 2) :\n  does_fred_need_houseboat x y ≥ does_fred_need_houseboat cx cy := by\n  sorry\n\ntheorem does_fred_need_houseboat_formula {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y = ceil (pi * ((x * x) + (y * y)) / 100) := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 1 1\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 25 0\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 10 10"}
{"id": "fvapps_003627", "vc-description": "", "vc-preamble": "def Elements := [\"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\"]\n\ndef Animals := [\"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\",\n               \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\"]\n\ndef String.splitToList (s : String) : List String :=\n  s.split (· = ' ')", "vc-helpers": "", "vc-definitions": "def chinese_zodiac (year : Int) : String :=\nsorry", "vc-theorems": "theorem cycle_12_years {y : Int} (h : y ≥ 1900 ∧ y ≤ 2100) :\n  (chinese_zodiac y).splitToList[1]! = (chinese_zodiac (y + 12)).splitToList[1]! :=\nsorry\n\ntheorem cycle_10_years {y : Int} (h : y ≥ 1900 ∧ y ≤ 2100) :\n  (chinese_zodiac y).splitToList[0]! = (chinese_zodiac (y + 10)).splitToList[0]! :=\nsorry\n\ntheorem valid_format {year : Int} (h : year ≥ 1900 ∧ year ≤ 2100) :\n  let result := chinese_zodiac year\n  let parts := result.splitToList\n  parts[0]! ∈ Elements ∧ parts[1]! ∈ Animals :=\nsorry\n\ntheorem deterministic {year : Int} (h : year ≥ 1900 ∧ year ≤ 2100) :\n  chinese_zodiac year = chinese_zodiac year :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Wood Snake'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1965\n\n/-\ninfo: 'Earth Tiger'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1998\n\n/-\ninfo: 'Fire Monkey'\n-/\n#guard_msgs in\n#eval chinese_zodiac 2016"}
{"id": "fvapps_003631", "vc-description": "/- Helper function to count occurrences of a substring -/\n\n/- Helper function to check if a string contains a substring -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def filter_words (s : String) : String :=\nsorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\nsorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem filter_words_output_is_string (s : String) :\n  filter_words s = filter_words s :=\nsorry\n\ntheorem filter_words_idempotent (s : String) :\n  filter_words (filter_words s) = filter_words s :=\nsorry\n\ntheorem filter_words_preserves_other_content (s : String) :\n  let banned_pattern := \"bad|mean|ugly|horrible|hideous\"\n  let remove_banned (str : String) := str.replace banned_pattern \"\"\n  remove_banned s = remove_banned (filter_words s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003633", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Float.toDegrees (x : Float) : Float :=\n  sorry\n\ndef Int.toFloat (x : Int) : Float :=\n  sorry\n\ndef missing_angle (h a o : Float) : Int :=\n  sorry", "vc-theorems": "theorem missing_angle_output_range (h a o : Float) :\n  h > 0 ∨ a > 0 ∨ o > 0 →\n  let angle := missing_angle h a o\n  0 ≤ angle ∧ angle ≤ 90 :=\nsorry\n\ntheorem missing_angle_with_missing_hyp (a o : Float) :\n  a > 0 ∧ o > 0 →\n  let angle := missing_angle 0 a o\n  (Int.toFloat angle - Float.toDegrees ((o/a).atan)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_with_missing_adj (h o : Float) :\n  h > 0 ∧ o > 0 →\n  let angle := missing_angle h 0 o\n  (Int.toFloat angle - Float.toDegrees ((o/h).asin)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_with_missing_opp (h a : Float) :\n  h > 0 ∧ a > 0 →\n  let angle := missing_angle h a 0\n  (Int.toFloat angle - Float.toDegrees ((a/h).acos)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_two_zeros (o : Float) :\n  o > 0 →\n  ¬∃angle, missing_angle 0 0 o = angle :=\nsorry\n\ntheorem missing_angle_invalid_triangle (h a : Float) :\n  h > 0 ∧ a > 0 →\n  a > h →\n  ¬∃angle, missing_angle h a 0 = angle :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 0 400 300\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 5 4 0\n\n/-\ninfo: 39\n-/\n#guard_msgs in\n#eval missing_angle 8 0 5"}
{"id": "fvapps_003635", "vc-description": "", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def build_square (blocks: List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem sum_16_if_buildable {blocks : List Nat} :\n  build_square blocks = true →\n  list_sum blocks ≥ 16 :=\nsorry\n\ntheorem input_unchanged {blocks : List Nat} :\n  build_square blocks = b →\n  blocks = blocks :=\nsorry\n\ntheorem invalid_pieces {blocks : List Nat} :\n  (∀ x ∈ blocks, x < 1 ∨ x > 4) →\n  build_square blocks = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [1, 1, 1, 1, 1, 1, 1, 2, 3, 4]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval build_square [1, 3, 2, 4, 3, 3, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [4, 2, 2, 1, 1, 1, 1, 3, 3, 3, 1]"}
{"id": "fvapps_003640", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palin (length pos : Nat) : Nat :=\nsorry\n\ndef is_palindrome (n : Nat) : Bool :=\nsorry\n\ndef num_length (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_digit_palindromes (pos : Nat) (h : 0 < pos ∧ pos < 10) :\n  let result := palin 1 pos\n  result = pos ∧ result < 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval palin 2 2\n\n/-\ninfo: 1441\n-/\n#guard_msgs in\n#eval palin 4 5\n\n/-\ninfo: 102201\n-/\n#guard_msgs in\n#eval palin 6 3"}
{"id": "fvapps_003649", "vc-description": "", "vc-preamble": "def REGION : String := \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef charAtPos (s : String) (pos : Nat) : Char := s.data[pos]!", "vc-helpers": "", "vc-definitions": "def encrypt (s : String) : String :=\nsorry\n\ndef decrypt (s : String) : String :=\nsorry\n\ndef isValidText (s : String) : Bool :=\nsorry", "vc-theorems": "theorem encryption_decryption_roundtrip (s : String) (h : isValidText s = true) :\n  decrypt (encrypt s) = s :=\nsorry\n\ntheorem encrypted_uses_valid_chars (s : String) (h : isValidText s = true) (h2 : s ≠ \"\") :\n  isValidText (encrypt s) = true :=\nsorry\n\ntheorem invalid_chars_raise_exception (s : String) (h : isValidText s = false) :\n  encrypt s = \"\" ∧ decrypt s = \"\" :=\nsorry\n\ntheorem empty_string :\n  encrypt \"\" = \"\" ∧ decrypt \"\" = \"\" :=\nsorry\n\ntheorem second_chars_different (s : String) (h : isValidText s = true) (h2 : s.length ≥ 2) :\n  encrypt s ≠ s :=\nsorry\n\ntheorem first_char_mirrored (s : String) (h : isValidText s = true) (h2 : s ≠ \"\") :\n  (charAtPos (encrypt s) 0) = (charAtPos REGION (REGION.length - 1)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: encrypted1\n-/\n#guard_msgs in\n#eval encrypt \"Business\"\n\n/-\ninfo: text1\n-/\n#guard_msgs in\n#eval decrypt encrypted1\n\n/-\ninfo: encrypted2\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\"\n\n/-\ninfo: text2\n-/\n#guard_msgs in\n#eval decrypt encrypted2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval decrypt \"\""}
{"id": "fvapps_003663", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unscramble_eggs (s : String) : String :=\nsorry\n\ndef containsEgg (s : String) : Bool :=\nsorry\n\ndef countSpaces (s : String) : Nat :=\nsorry", "vc-theorems": "theorem no_eggs_in_result (s : String) :\n  containsEgg (unscramble_eggs s) = false :=\nsorry\n\ntheorem preserves_space_count (s : String) :\n  countSpaces s = countSpaces (unscramble_eggs s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'code here'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"ceggodegge heggeregge\"\n\n/-\ninfo: 'FUN KATA'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"FeggUNegg KeggATeggA\"\n\n/-\ninfo: 'vegymite on toast'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"veggegeggyeggmeggitegge onegg teggoaseggtegg\""}
{"id": "fvapps_003677", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_it (s : String) (n : Nat) : String :=\nsorry\n\ndef isCharNSorted (words : List String) (n : Nat) : Bool :=\nsorry\n\ndef sameSets (s1 : List String) (s2 : List String) : Bool :=\nsorry\n\ndef wordsFromString (s : String) : List String :=\nsorry", "vc-theorems": "theorem sort_it_preserves_words (s : String) (n : Nat) :\n  n > 0 → sameSets (wordsFromString s) (wordsFromString (sort_it s n)) :=\nsorry\n\ntheorem sort_it_is_n_sorted (s : String) (n : Nat) (h : n > 0) :\n  isCharNSorted (wordsFromString (sort_it s n)) n :=\nsorry\n\ntheorem sort_it_first_char_is_normal_sort (s : String) :\n  sort_it s 1 = String.intercalate \", \" (wordsFromString s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003681", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def translateTableNum (s : String) : String :=\n  sorry\n\ndef t9_predict (words : List String) (seq : String) : List String :=\n  sorry", "vc-theorems": "theorem t9_predict_never_empty (words : List String) (seq : String) :\n  seq ≠ \"\" → ∃ result, t9_predict words seq = result ∧ result.length > 0 :=\nsorry\n\ntheorem t9_predict_fallback_on_no_matches (words : List String) (seq : String) :\n  seq ≠ \"\" →\n  (∀ w ∈ words, translateTableNum w.toLower ≠ seq) →\n  ∃ result, t9_predict words seq = [result] ∧ result.length = seq.length :=\nsorry\n\ntheorem t9_predict_all_matches_sequence (words : List String) (seq : String) :\n  seq ≠ \"\" →\n  ∀ w ∈ t9_predict words seq, translateTableNum w.toLower = seq :=\nsorry\n\ntheorem t9_predict_empty_dict (seq : String) :\n  seq ≠ \"\" →\n  ∃ result, t9_predict [] seq = [result] ∧ result.length = seq.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['hello']\n-/\n#guard_msgs in\n#eval t9_predict [\"hello\", \"world\"] \"43556\"\n\n/-\ninfo: ['good', 'home']\n-/\n#guard_msgs in\n#eval t9_predict [\"good\", \"home\", \"new\"] \"4663\"\n\n/-\ninfo: ['gdjjm']\n-/\n#guard_msgs in\n#eval t9_predict [] \"43556\""}
{"id": "fvapps_003683", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.toFloat (s : String) : Option Float :=\nsorry\n\ndef List.sort (l : List Float) (lt : Float → Float → Bool) : List Float := sorry\n\ndef search (budget : Float) (prices : List Float) : String :=\n  sorry", "vc-theorems": "theorem search_sorted (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  ∀ i, i < nums.length - 1 → nums[i]! ≤ nums[i+1]! :=\nsorry\n\ntheorem search_within_budget (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  ∀ x ∈ nums, x ≤ budget :=\nsorry\n\ntheorem search_includes_all_eligible (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let eligible := List.sort (prices.filter (· ≤ budget)) (·≤·)\n  let result := search budget prices\n  result = String.intercalate \",\" (eligible.map toString) :=\nsorry\n\ntheorem search_zero_budget (prices : List Float)\n  (h1 : ∀ x ∈ prices, x ≥ 0)\n  (h2 : prices ≠ []) :\n  let eligible := List.sort (prices.filter (·≤ 0)) (·≤·)\n  search 0 prices = String.intercalate \",\" (eligible.map toString) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1,2,2'\n-/\n#guard_msgs in\n#eval search 3 [6, 1, 2, 9, 2]\n\n/-\ninfo: '3,7,7,9,14'\n-/\n#guard_msgs in\n#eval search 14 [7, 3, 23, 9, 14, 20, 7]\n\n/-\ninfo: '0,1,2.7,5.5'\n-/\n#guard_msgs in\n#eval search 24 [2.7, 0, 100.9, 1, 5.5]"}
{"id": "fvapps_003688", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.findSubstr? (pattern : String) (s : String) : Option String.Pos :=\n  sorry\n\ndef gym_slang (s : String) : String :=\n  sorry", "vc-theorems": "theorem gym_slang_length (s : String) :\n  String.length (gym_slang s) ≤ String.length s :=\nsorry\n\ntheorem gym_slang_case_preserving_prob (s : String) :\n  (String.findSubstr? \"Probably\" s).isSome → (String.findSubstr? \"Prolly\" (gym_slang s)).isSome :=\nsorry\n\ntheorem gym_slang_case_preserving_prob_lower (s : String) :\n  (String.findSubstr? \"probably\" s).isSome → (String.findSubstr? \"prolly\" (gym_slang s)).isSome :=\nsorry\n\ntheorem gym_slang_all_transformations (s : String) :\n  let sLower := s.toLower\n  let resultLower := (gym_slang s).toLower\n  (Option.isSome (String.findSubstr? \"probably\" sLower) ↔ Option.isSome (String.findSubstr? \"prolly\" resultLower)) ∧\n  (Option.isSome (String.findSubstr? \"combination\" sLower) ↔ Option.isSome (String.findSubstr? \"combo\" resultLower)) :=\nsorry\n\ntheorem gym_slang_identity (s : String) :\n  (Option.isNone (String.findSubstr? \"probably\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"i am\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"instagram\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"do not\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"going to\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"combination\" s.toLower)) →\n  gym_slang s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003698", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : String :=\nsorry\n\ndef isUpper (s : String) : Bool :=\nsorry\n\ndef isLower (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_returns_either_upper_or_lower (s : String) :\n  (solve s = s.toUpper) ∨ (solve s = s.toLower) :=\nsorry\n\ntheorem solve_preserves_uppercase (s : String) :\n  isUpper s = true → solve s = s.toUpper :=\nsorry\n\ntheorem solve_preserves_lowercase (s : String) :\n  isLower s = true → solve s = s.toLower :=\nsorry\n\ntheorem solve_preserves_length (s : String) :\n  (solve s).length = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDe\"\n\n/-\ninfo: 'CODE'\n-/\n#guard_msgs in\n#eval solve \"CODe\"\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDE\""}
{"id": "fvapps_003700", "vc-description": "", "vc-preamble": "def sumMultiples (n : Nat) : Int :=\n  (List.range n).map Int.ofNat\n  |>.filter (fun x => x % 3 = 0 ∨ x % 5 = 0)\n  |>.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def solution (n : Int) : Int :=\nsorry", "vc-theorems": "theorem solution_nonnegative (n : Int) :\n  solution n ≥ 0 ∧ (n ≤ 0 → solution n = 0) :=\nsorry\n\ntheorem multiples_property {n : Nat} :\n  0 < n →\n  solution (Int.ofNat n) = sumMultiples n :=\nsorry\n\ntheorem result_smaller_than_input_squared {n : Int} :\n  n > 0 → solution n < n * n :=\nsorry\n\ntheorem negative_inputs :\n  ∀ n : Int, n < 0 → solution n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval solution 10\n\n/-\ninfo: 78\n-/\n#guard_msgs in\n#eval solution 20\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solution 0"}
{"id": "fvapps_003707", "vc-description": "/- For a sequence with one number removed, missing finds the removed number -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For a complete sequence with no gaps, missing returns -1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isDigit : String → Bool :=\n  sorry\n\ndef missing : String → Int :=\n  sorry\n\ndef isSequence : String → Bool :=\n  sorry", "vc-theorems": "theorem missing_finds_gap {start : Nat} (h : start ≥ 1 ∧ start ≤ 99) :\n  ∀ seq target,\n  (∃ curr, curr = start ∧\n    seq = String.join (List.map toString (List.range curr)) ∧\n    target = curr + 1 ∧\n    isSequence (seq.replace (toString target) \"\")) →\n  missing (seq.replace (toString target) \"\") = target :=\nsorry\n\ntheorem missing_complete_sequence {start : Nat} (h : start ≥ 1 ∧ start ≤ 999) :\n  ∀ seq,\n  (∃ curr, curr = start ∧\n    seq = String.join (List.map toString (List.range curr)) ∧\n    isSequence seq) →\n  missing seq = -1 :=\nsorry", "vc-postamble": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval missing \"123567\"\n\n/-\ninfo: 92\n-/\n#guard_msgs in\n#eval missing \"899091939495\"\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval missing \"9899101102\""}
{"id": "fvapps_003710", "vc-description": "", "vc-preamble": "def List.isPermutationOf (l1 l2 : List Int) : Prop :=\n  ∀ x, (l1.filter (· = x)).length = (l2.filter (· = x)).length", "vc-helpers": "", "vc-definitions": "def solve (arr : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem solve_output_length {arr : List Int} (h : arr ≠ []) :\n  (solve arr).length = arr.length :=\nsorry\n\ntheorem solve_contains_same_elements {arr : List Int} (h : arr ≠ []) :\n  (solve arr).isPermutationOf arr :=\nsorry\n\ntheorem solve_maintains_frequency_order {arr : List Int} (h : arr ≠ []) :\n  let freq := fun x => (arr.filter (· = x)).length\n  ∀ i, i + 1 < (solve arr).length →\n    let curr := (solve arr).get! i\n    let next := (solve arr).get! (i+1)\n    freq curr > freq next ∨\n    (freq curr = freq next ∧ curr ≤ next) :=\nsorry\n\ntheorem solve_idempotent {arr : List Int} (h : arr ≠ []) :\n  solve (solve arr) = solve arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [2, 3, 5, 3, 7, 9, 5, 3, 7]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [1, 2, 3, 0, 5, 0, 1, 6, 8, 8, 6, 9, 1]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [5, 9, 6, 9, 6, 5, 9, 9, 4, 4]"}
{"id": "fvapps_003712", "vc-description": "/- Helper function to check if expression uses given operators -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def operator_insertor (n : Int) : Option Int :=\nsorry\n\ndef expr_evaluates_to : Int → String → Prop :=\nsorry\n\ndef expr_uses_ops : List String → String → Prop :=\nsorry", "vc-theorems": "theorem operator_insertor_output_range (n : Int) :\n  match operator_insertor n with\n  | none => True\n  | some result => 0 ≤ result ∧ result ≤ 8\n  :=\nsorry\n\ntheorem operator_insertor_result_exists (n : Int) (result : Int) :\n  operator_insertor n = some result →\n  ∃ ops : List String,\n    (ops.length = result) ∧\n    (∀ op ∈ ops, op = \"+\" ∨ op = \"-\" ∨ op = \"\") ∧\n    (∃ expr : String, expr_evaluates_to n expr ∧ expr_uses_ops ops expr)\n  :=\nsorry\n\ntheorem operator_insertor_impossible_large (n : Int) :\n  n ≥ 10^10 → operator_insertor n = none :=\nsorry\n\ntheorem operator_insertor_impossible_small (n : Int) :\n  n ≤ -(10^10) → operator_insertor n = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Helper function to check if a string expression evaluates to a number -/\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval operator_insertor 11\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval operator_insertor 100\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval operator_insertor 160"}
{"id": "fvapps_003714", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def arr2bin (arr : List α) : String :=\nsorry\n\ndef sumList (l : List Int) : Int :=\nsorry\n\ndef toBinaryString (n : Int) : String :=\nsorry\n\ndef allBinary (s : String) : Bool :=\nsorry\n\ndef stringToNat (s : String) : Nat :=\nsorry\n\ndef isAllInts (arr : List α) : Bool :=\nsorry\n\ndef listToInts (arr : List α) : List Int :=\nsorry", "vc-theorems": "theorem arr2bin_all_ints {arr : List Int} :\n  arr2bin arr = toBinaryString (sumList arr) :=\nsorry\n\ntheorem arr2bin_empty :\n  arr2bin ([] : List α) = \"0\" :=\nsorry\n\ntheorem arr2bin_positive_ints {arr : List Nat} :\n  let result := arr2bin arr\n  allBinary result ∧\n  stringToNat result = arr.foldl (init := 0) (·+·) :=\nsorry\n\ntheorem arr2bin_mixed_types {α} {arr : List α} :\n  (¬isAllInts arr → arr2bin arr = \"\") ∧\n  (isAllInts arr → arr2bin arr = toBinaryString (sumList (listToInts arr))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '11'\n-/\n#guard_msgs in\n#eval arr2bin [1, 2]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval arr2bin [1, 2, \"a\"]\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval arr2bin []"}
{"id": "fvapps_003717", "vc-description": "", "vc-preamble": "def split (s : String) : List String := String.splitOn s \"\\n\"", "vc-helpers": "", "vc-definitions": "def countCarries (input : String) : String :=\nsorry\n\ndef carry_count (a b : Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_line_carries_correct\n  (a b : Nat)\n  (h1 : a ≤ 999999)\n  (h2 : b ≤ 999999) :\n  let result := countCarries s!\"{a} {b}\"\n  let expected :=\n    let carry := carry_count a b\n    if carry = 0 then \"No carry operation\"\n    else s!\"{carry} carry operations\"\n  result = expected :=\nsorry\n\ntheorem multiple_lines_carries_length\n  {n : Nat}\n  (pairs : List (Nat × Nat))\n  (h1 : ∀ p : Nat × Nat, p ∈ pairs → (Prod.fst p) ≤ 9999 ∧ (Prod.snd p) ≤ 9999)\n  (h2 : pairs.length > 0)\n  (h3 : pairs.length ≤ 10) :\n  let input := String.intercalate \"\\n\" (pairs.map (λ p => s!\"{Prod.fst p} {Prod.snd p}\"))\n  (split (countCarries input)).length = pairs.length :=\nsorry\n\ntheorem single_digit_carries_correct\n  (a b : Nat)\n  (h1 : a ≤ 9)\n  (h2 : b ≤ 9) :\n  countCarries s!\"{a} {b}\" =\n    if a + b > 9 then \"1 carry operations\"\n    else \"No carry operation\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval count_carries \"123 456\\n555 555\\n123 594\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval count_carries \"99 99\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval count_carries \"1 9\\n123456789 111111101\""}
{"id": "fvapps_003718", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mean_vs_median (l : List Int) : String :=\nsorry\n\ndef statistical_mean (l : List Int) : Float :=\nsorry\n\ndef statistical_median (l : List Int) : Float :=\nsorry", "vc-theorems": "theorem mean_vs_median_matches_statistics (l : List Int) (h : l ≠ []) :\n  let mean := statistical_mean l\n  let median := statistical_median l\n  mean_vs_median l = (if mean > median then \"mean\"\n                     else if median > mean then \"median\"\n                     else \"same\") :=\nsorry\n\ntheorem identical_numbers_return_same (l : List Int) (h1 : l ≠ [])\n  (h2 : ∀ x ∈ l, x = 1) :\n  mean_vs_median l = \"same\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'same'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 1, 1]\n\n/-\ninfo: 'mean'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 2, 37]\n\n/-\ninfo: 'median'\n-/\n#guard_msgs in\n#eval mean_vs_median [7, 14, -70]"}
{"id": "fvapps_003722", "vc-description": "/- Hamming distance is symmetric -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Hamming distance between a number and itself is zero -/\n\n/- Hamming distance satisfies the triangle inequality -/\n\n/- Hamming distance is always nonnegative -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hamming_distance : Int → Int → Nat :=\n  sorry", "vc-theorems": "theorem hamming_distance_symmetric (a b : Int) :\n  hamming_distance a b = hamming_distance b a := by\n  sorry\n\ntheorem hamming_distance_self_zero (a : Int) :\n  hamming_distance a a = 0 := by\n  sorry\n\ntheorem hamming_distance_triangle_inequality (a b c : Int) :\n  hamming_distance a c ≤ hamming_distance a b + hamming_distance b c := by\n  sorry\n\ntheorem hamming_distance_nonnegative (a b : Int) :\n  hamming_distance a b ≥ 0 := by\n  sorry", "vc-postamble": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 25 87\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 256 302\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 543 634"}
{"id": "fvapps_003727", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digSum (n : Nat) (p : Nat) : Nat :=\n  sorry\n\ndef digPow (n : Nat) (p : Nat) : Int :=\n  sorry", "vc-theorems": "theorem digPow_valid_result {n p : Nat} (h : digPow n p ≠ -1) :\n  digSum n p = (digPow n p).toNat * n ∧ digPow n p > 0 := by\n  sorry\n\ntheorem digPow_is_int (n p : Nat) :\n  ∃ k : Int, digPow n p = k := by\n  sorry\n\ntheorem digPow_power_one (n : Nat) :\n  digSum n 1 % n = 0 →\n  digPow n 1 = (digSum n 1) / n := by\n  sorry\n\ntheorem digPow_power_one_neg (n : Nat) :\n  digSum n 1 % n ≠ 0 →\n  digPow n 1 = -1 := by\n  sorry\n\ntheorem digPow_single_digit_power_one (n : Nat) :\n  n > 0 → n < 10 →\n  digPow n 1 = 1 := by\n  sorry\n\ntheorem digPow_large_power_is_int (n p : Nat) :\n  ∃ k : Int, digPow n p = k := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval dig_pow 89 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval dig_pow 92 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval dig_pow 695 2"}
{"id": "fvapps_003731", "vc-description": "", "vc-preamble": "def ValidResources := \"bwsog\"\n\ndef countChar (s : List Char) (c : Char) : Nat :=\n  s.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def build_or_buy (hand : String) : List String :=\nsorry", "vc-theorems": "theorem build_or_buy_returns_list (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  build_or_buy hand ≠ [] ∨ build_or_buy hand = [] := by\n  sorry\n\ntheorem build_or_buy_valid_items (hand : String) (result : List String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  result = build_or_buy hand →\n  result.all (· ∈ [\"road\", \"settlement\", \"city\", \"development\"]) := by\n  sorry\n\ntheorem can_build_road (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"road\" ∈ build_or_buy hand →\n  countChar hand.data 'b' ≥ 1 ∧ countChar hand.data 'w' ≥ 1 := by\n  sorry\n\ntheorem can_build_settlement (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"settlement\" ∈ build_or_buy hand →\n  countChar hand.data 'b' ≥ 1 ∧ countChar hand.data 'w' ≥ 1 ∧\n  countChar hand.data 's' ≥ 1 ∧ countChar hand.data 'g' ≥ 1 := by\n  sorry\n\ntheorem can_build_city (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"city\" ∈ build_or_buy hand →\n  countChar hand.data 'o' ≥ 3 ∧ countChar hand.data 'g' ≥ 2 := by\n  sorry\n\ntheorem can_build_development (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"development\" ∈ build_or_buy hand →\n  countChar hand.data 'o' ≥ 1 ∧ countChar hand.data 's' ≥ 1 ∧\n  countChar hand.data 'g' ≥ 1 := by\n  sorry\n\ntheorem empty_hand_empty_result :\n  build_or_buy \"\" = [] := by\n  sorry\n\ntheorem result_consistency (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  build_or_buy hand = build_or_buy hand := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['road']\n-/\n#guard_msgs in\n#eval build_or_buy \"bwoo\"\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval build_or_buy \"\"\n\n/-\ninfo: ['city']\n-/\n#guard_msgs in\n#eval build_or_buy \"ogogoogogo\""}
{"id": "fvapps_003733", "vc-description": "/- For a single digit input, the function hydrate returns a string with the\n    same number of glasses of water, and uses \"glass\" for 1 and \"glasses\" otherwise -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of single digit numbers, hydrate returns a string with the sum of\n    the numbers as glasses of water -/\n\n/- For any string containing only letters and spaces, hydrate returns \"0 glasses of water\" -/\n\n/- For an empty string, hydrate returns \"0 glasses of water\" -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hydrate (s : String) : String :=\nsorry", "vc-theorems": "theorem hydrate_single_digit {n : Nat} (h : n ≤ 9) :\n  hydrate s!\"{n} drinks\" =\n    s!\"{n} {if n = 1 then \"glass\" else \"glasses\"} of water\" :=\nsorry\n\ntheorem hydrate_multiple_digits {nums : List Nat} (h : ∀ n ∈ nums, n ≤ 9) :\n  let sum := nums.foldl (· + ·) 0\n  hydrate (String.intercalate \" \" (nums.map toString)) =\n    s!\"{sum} {if sum = 1 then \"glass\" else \"glasses\"} of water\" :=\nsorry\n\ntheorem hydrate_no_numbers {s : String}\n  (h : ∀ c ∈ s.data, c = ' ' ∨ ('a' ≤ c ∧ c ≤ 'z')) :\n  hydrate s = \"0 glasses of water\" :=\nsorry\n\ntheorem hydrate_empty : hydrate \"\" = \"0 glasses of water\" :=\nsorry", "vc-postamble": "/-\ninfo: '1 glass of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 beer\"\n\n/-\ninfo: '3 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"2 glasses of wine and 1 shot\"\n\n/-\ninfo: '10 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 shot, 5 beers, 2 shots, 1 glass of wine, 1 beer\""}
{"id": "fvapps_003734", "vc-description": "", "vc-preamble": "def get_lines (n : Nat) : List String :=\n  (pattern n).split (· = '\\n')", "vc-helpers": "", "vc-definitions": "def pattern (n : Nat) : String :=\nsorry", "vc-theorems": "theorem pattern_non_positive (n : Nat) (h : n = 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem pattern_first_line (n : Nat) (h : n > 0) :\n  (get_lines n)[0]! = String.join (List.map toString (List.range n)) :=\nsorry\n\ntheorem pattern_line_count (n : Nat) (h : n > 0) :\n  (get_lines n).length = n :=\nsorry\n\ntheorem pattern_line_length (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.length = n - i :=\nsorry\n\ntheorem pattern_line_starts_with_n (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.front.toString = toString n :=\nsorry\n\ntheorem pattern_descending_numbers (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  let nums := (get_lines n)[i]!.data.map (λ c => c.toString.toNat!);\n  nums == (List.range (n - i)).map (λ x => n - x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '4321\\n432\\n43\\n4'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/-\ninfo: '21\\n2'\n-/\n#guard_msgs in\n#eval pattern 2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"}
{"id": "fvapps_003737", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitsList (n : Nat) : List Nat :=\nsorry\n\ndef sumList (xs : List Nat) : Nat :=\nsorry\n\ndef check (n : Nat) (maxSum : Nat) : Bool :=\nsorry\n\ndef max_sumDig (nmax : Nat) (maxSum : Nat) : Nat × Nat × Nat :=\nsorry", "vc-theorems": "theorem check_type (n : Nat) (maxSum : Nat) : check n maxSum = true ∨ check n maxSum = false :=\nsorry\n\ntheorem check_max_sum (n : Nat) (maxSum : Nat)\n    (h1 : n ≥ 1000) (h2 : n < 10000) (h3 : maxSum ≤ 36) :\n  check n maxSum = true ↔\n    ∀ i, i + 4 ≤ (digitsList n).length →\n      sumList (List.drop i (List.take (i+4) (digitsList n))) ≤ maxSum :=\nsorry\n\ntheorem max_sumDig_constraints (nmax maxSum : Nat)\n    (h1 : nmax ≥ 2000) (h2 : nmax < 10000) (h3 : maxSum ≥ 3) (h4 : maxSum ≤ 36) :\n  let (count, closest, sum) := max_sumDig nmax maxSum\n  count ≥ 0 ∧\n  closest ≥ 1000 ∧\n  closest ≤ nmax ∧\n  check closest maxSum = true ∧\n  sum ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [11, 1110, 12555]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 3\n\n/-\ninfo: [21, 1120, 23665]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 4\n\n/-\ninfo: [85, 1200, 99986]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 7"}
{"id": "fvapps_003746", "vc-description": "", "vc-preamble": "def square_len (n : Nat) : Nat := toString (n * n) |>.length\n\ndef listSum : List Nat → Nat\n| [] => 0\n| x :: xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def square_digits (n : Nat) : Nat :=\nsorry\n\ndef digits_to_nat (digits : List Nat) : Nat :=\nsorry\n\ndef nat_to_digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem single_digit_square {d : Nat} (h : d ≤ 9) :\n  square_digits d = d * d :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9414\n-/\n#guard_msgs in\n#eval square_digits 3212\n\n/-\ninfo: 4114\n-/\n#guard_msgs in\n#eval square_digits 2112\n\n/-\ninfo: 811181\n-/\n#guard_msgs in\n#eval square_digits 9119"}
{"id": "fvapps_003747", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For element preservation, we can state that any element in the original list\n   exists in the result list and vice versa -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sel_reverse (arr : List α) (length : Nat) : List α :=\n  sorry", "vc-theorems": "theorem length_preservation {α : Type} (arr : List α) (length : Nat) :\n  List.length (sel_reverse arr length) = List.length arr :=\nsorry\n\ntheorem elem_preservation {α : Type} (arr : List α) (length : Nat) (a : α) :\n  (a ∈ sel_reverse arr length) ↔ (a ∈ arr) :=\nsorry\n\ntheorem zero_length {α : Type} (arr : List α) :\n  sel_reverse arr 0 = arr :=\nsorry\n\ntheorem chunk_reversal {α : Type} (arr : List α) (length : Nat) (h : length > 0) :\n  ∀ i, i < List.length arr →\n  (sel_reverse arr length).get? i =\n    arr.get? (i/length * length + (length - 1 - i%length)) :=\nsorry\n\ntheorem length_one {α : Type} (arr : List α) :\n  sel_reverse arr 1 = arr :=\nsorry\n\ntheorem full_length {α : Type} (arr : List α) (h : arr ≠ []) :\n  sel_reverse arr (List.length arr) = arr.reverse :=\nsorry", "vc-postamble": "/-\ninfo: [6, 4, 2, 12, 10, 8, 16, 14]\n-/\n#guard_msgs in\n#eval sel_reverse [2, 4, 6, 8, 10, 12, 14, 16] 3\n\n/-\ninfo: [2, 1, 4, 3, 6, 5]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 2\n\n/-\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 0"}
{"id": "fvapps_003753", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Pos2Nat (p : String.Pos) : Nat :=\nsorry\n\ndef Nat2Pos (n : Nat) : String.Pos :=\nsorry\n\ndef bracket_pairs (s : String) : Option (List (String.Pos × String.Pos)) :=\nsorry", "vc-theorems": "theorem bracket_pairs_valid_indices {s : String} {pairs : List (String.Pos × String.Pos)}\n    (h1 : bracket_pairs s = some pairs)\n    (open_pos close_pos : String.Pos)\n    (h2 : (open_pos, close_pos) ∈ pairs) :\n    s.get open_pos = '(' ∧\n    s.get close_pos = ')' ∧\n    Pos2Nat open_pos < Pos2Nat close_pos :=\nsorry\n\ntheorem no_brackets_empty_result {s : String} :\n  (∀ c, c ∈ s.data → c ≠ '(' ∧ c ≠ ')') →\n  bracket_pairs s = some [] :=\nsorry\n\ntheorem only_closing_brackets_false {s : String} :\n  (∀ c, c ∈ s.data → c = ')') →\n  s ≠ \"\" →\n  bracket_pairs s = none :=\nsorry\n\ntheorem only_opening_brackets_false {s : String} :\n  (∀ c, c ∈ s.data → c = '(') →\n  s ≠ \"\" →\n  bracket_pairs s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: {3: 8}\n-/\n#guard_msgs in\n#eval bracket_pairs \"len(list)\"\n\n/-\ninfo: {}\n-/\n#guard_msgs in\n#eval bracket_pairs \"string\"\n\n/-\ninfo: {0: 9, 2: 4, 6: 7}\n-/\n#guard_msgs in\n#eval bracket_pairs \"(a(b)c()d)\""}
{"id": "fvapps_003754", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sortString (s : String) : String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem sort_string_preserves_length (s : String) :\n  (sortString s).length = s.length :=\nsorry\n\ntheorem sort_string_preserves_non_alpha (s : String) (i : String.Pos) :\n  ¬(isAlpha (s.get i)) →\n  (sortString s).get i = s.get i :=\nsorry\n\ntheorem sort_string_sorts_alpha (s : String) :\n  let result := sortString s\n  let alphaChars := result.data.filter isAlpha\n  ∀ i j, i < j → j < alphaChars.length →\n    (alphaChars.get ⟨i, by sorry⟩).toLower ≤ (alphaChars.get ⟨j, by sorry⟩).toLower :=\nsorry\n\ntheorem sort_string_preserves_case_counts (s : String) :\n  let result := sortString s\n  (result.data.filter isUpper).length = (s.data.filter isUpper).length ∧\n  (result.data.filter isLower).length = (s.data.filter isLower).length :=\nsorry\n\ntheorem sort_string_idempotent (s : String) :\n  sortString (sortString s) = sortString s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval sort_string \"cba\"\n\n/-\ninfo: 'abC'\n-/\n#guard_msgs in\n#eval sort_string \"Cba\"\n\n/-\ninfo: 'a b c'\n-/\n#guard_msgs in\n#eval sort_string \"c b a\""}
{"id": "fvapps_003755", "vc-description": "", "vc-preamble": "def sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def uniq_c {α : Type u} (xs : List α) : List (α × Nat) :=\n  sorry", "vc-theorems": "theorem uniq_c_length_invariants {α : Type u} (xs : List α) :\n  let result := uniq_c xs\n  (∀ p ∈ result, (Prod.snd p) > 0) ∧\n  sum (result.map Prod.snd) = xs.length :=\nsorry\n\ntheorem uniq_c_groups_consecutive {α : Type u} [BEq α] (xs : List α) :\n  let result := uniq_c xs\n  let indices := List.range xs.length\n  ∀ (i j : Nat), i < xs.length → j < xs.length →\n    ∀ p ∈ result,\n      (i < j) →\n      (j - i < Prod.snd p) →\n      xs[i]? = some (Prod.fst p) →\n      xs[j]? = some (Prod.fst p) :=\nsorry\n\ntheorem uniq_c_single_element {α : Type u} [BEq α] (x : α) (n : Nat) :\n  uniq_c (List.replicate n x) = [(x, n)] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"b\", \"b\", \"c\", \"a\", \"b\", \"c\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval uniq_c [None, \"a\", \"a\"]"}
{"id": "fvapps_003769", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\n  sorry\n\ndef tidyNumber (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tidy_number_returns_boolean (n : Nat) :\n  tidyNumber n = true ∨ tidyNumber n = false :=\nsorry\n\ntheorem single_digit_numbers_tidy (n : Nat) :\n  n < 10 → tidyNumber n = true :=\nsorry\n\ntheorem tidy_implies_non_decreasing_digits {n : Nat} {ds : List Nat} :\n  tidyNumber n = true →\n  ds = digits n →\n  ∀ i j, i < j → j < ds.length → ds[i]! ≤ ds[j]! :=\nsorry\n\ntheorem non_decreasing_digits_iff_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n →\n  (∀ i j, i < j → j < ds.length → ds[i]! ≤ ds[j]!) ↔ tidyNumber n = true :=\nsorry\n\ntheorem decreasing_digits_not_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n →\n  ds.length ≥ 2 →\n  (∃ i j, i < j ∧ j < ds.length ∧ ds[i]! > ds[j]!) →\n  tidyNumber n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval tidyNumber 12\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 32\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 1024"}
{"id": "fvapps_003771", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def two_count (n : Nat) : Nat :=\nsorry\n\ndef calc_divisions (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem two_count_non_negative (n : Nat) (h : n > 0) :\n  two_count n ≥ 0 :=\nsorry\n\ntheorem two_count_matches_divisions (n : Nat) (h : n > 0) :\n  two_count n = calc_divisions n :=\nsorry\n\ntheorem two_count_odd (n : Nat) (h₁ : n > 0) (h₂ : n % 2 = 1) :\n  two_count n = 0 :=\nsorry\n\ntheorem two_count_power_of_two (n : Nat) (h₁ : n > 0) (h₂ : n.isPowerOfTwo) :\n  two_count n = Nat.log2 n :=\nsorry\n\ntheorem two_count_multiplication (n k : Nat) (h : n > 0) :\n  two_count (n * 2^k) = two_count n + k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval two_count 24\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval two_count 17280\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval two_count 256"}
{"id": "fvapps_003776", "vc-description": "", "vc-preamble": "def IsRepeatStart (s : String) (i : String.Pos) : Prop :=\n  i = ⟨0⟩ ∨ s.get (String.Pos.mk (i.1 - 1)) = s.get i\n\ndef IsRepeatEnd (s : String) (i : String.Pos) : Prop :=\n  i.1 < s.length - 1 → s.get i = s.get (String.Pos.mk (i.1 + 1))", "vc-helpers": "", "vc-definitions": "def reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :=\nsorry\n\ntheorem reverse_preserves_non_repeats (s : String) (i : String.Pos) :\n  ¬IsRepeatStart s i → ¬IsRepeatEnd s i →\n  (reverse s).get i = s.get i :=\nsorry\n\ntheorem reverse_swaps_case_on_repeats (s : String) (i : String.Pos) :\n  IsRepeatStart s i ∨ IsRepeatEnd s i →\n  (reverse s).get i ≠ s.get i :=\nsorry\n\ntheorem reverse_idempotent_no_repeats (s : String)\n  (h : ∀ i : String.Pos, i.1 < s.length → ¬IsRepeatStart s i ∧ ¬IsRepeatEnd s i) :\n  reverse s = s :=\nsorry\n\ntheorem reverse_preserves_non_letters (s : String) (i : String.Pos)\n  (h : ¬(s.get i).isAlpha) :\n  (reverse s).get i = s.get i :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'heLLo world'\n-/\n#guard_msgs in\n#eval reverse \"hello world\"\n\n/-\ninfo: 'www'\n-/\n#guard_msgs in\n#eval reverse \"WWW\"\n\n/-\ninfo: 'bOOKKEEper'\n-/\n#guard_msgs in\n#eval reverse \"bookkeeper\""}
{"id": "fvapps_003777", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_ints (xs : List Int) : Int :=\n  sorry\n\ndef range (n : Int) : List Int :=\n  sorry\n\ndef arithmetic_sequence_sum (a r n : Int) : Int :=\n  sorry", "vc-theorems": "theorem arithmetic_sequence_properties\n  (a r n : Int)\n  (h : n > 0) :\n  let sum := arithmetic_sequence_sum a r n\n  let manual_sum := sum_ints (range n |>.map (fun i => a + r * i))\n  (sum = manual_sum) ∧\n  (arithmetic_sequence_sum a r 1 = a) ∧\n  (n > 1 → sum = arithmetic_sequence_sum a r (n-1) + (a + (n-1)*r)) :=\nsorry\n\ntheorem sequence_symmetry\n  (a r n : Int)\n  (h : n > 0) :\n  let last := a + (n-1)*r\n  arithmetic_sequence_sum a r n = arithmetic_sequence_sum last (-r) n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 440\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 3 2 20\n\n/-\ninfo: 110\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 2 2 10\n\n/-\ninfo: -80\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 1 -2 10"}
{"id": "fvapps_003780", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_even_index (arr : List Int) : Nat :=\n  sorry\n\ndef sum_list (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem find_even_index_centered {n : Nat} :\n  let arr := List.replicate n 1 ++ [0] ++ List.replicate n 1\n  find_even_index arr = n\n  :=\nsorry\n\ntheorem find_even_index_single_element :\n  find_even_index [0] = 0 :=\nsorry\n\ntheorem find_even_index_single_nonzero :\n  find_even_index [1] = 0 :=\nsorry\n\ntheorem find_even_index_all_zeros :\n  find_even_index [0, 0, 0] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_even_index [1, 2, 3, 4, 3, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_even_index [1, 100, 50, -51, 1, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_even_index [20, 10, -80, 10, 10, 15, 35]"}
{"id": "fvapps_003781", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def discover_original_price (price : Float) (percentage : Float) : Float :=\nsorry\n\ndef abs (x : Float) : Float :=\nsorry", "vc-theorems": "theorem discover_original_price_geq_discounted (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  discover_original_price price percentage ≥ price :=\nsorry\n\ntheorem discover_original_price_positive (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  0 < discover_original_price price percentage :=\nsorry\n\ntheorem discover_original_price_accurate (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  let original := discover_original_price price percentage\n  let discounted := original * (1 - percentage/100)\n  Float.abs (discounted - price) ≤ 0.02 :=\nsorry\n\ntheorem discover_original_price_100_dollars (percentage : Float)\n  (h1 : 0 < percentage) (h2 : percentage < 100) :\n  let discounted := 100 * (1 - percentage/100)\n  Float.abs (discover_original_price discounted percentage - 100) < 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 75 25\n\n/-\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 25 75\n\n/-\ninfo: Decimal('421.00')\n-/\n#guard_msgs in\n#eval discover_original_price 373.85 11.2"}
{"id": "fvapps_003794", "vc-description": "-- conversion of digits to number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def strong_num (n : Nat) : String :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry\n\ndef sumDigitFactorials (n : Nat) : Nat :=\nsorry\n\ndef digitsOfNat (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem strong_num_outputs_valid_string (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" ∨ strong_num n = \"Not Strong !!\") :=\nsorry\n\ntheorem strong_num_correctness (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" ↔ sumDigitFactorials n = n) :=\nsorry\n\ntheorem single_digit_strong_nums (n : Nat) :\n  n ≤ 9 →\n  (strong_num n = \"STRONG!!!!\" ↔ (n = 1 ∨ n = 2)) :=\nsorry\n\ntheorem digit_composition_property (digits : List Nat) :\n  (∀ d ∈ digits, d ≤ 9) →\n  let n := sorry\n  (strong_num n = \"STRONG!!!!\" ↔ (sumDigitFactorials n = n)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 145\n\n/-\ninfo: 'Not Strong !!'\n-/\n#guard_msgs in\n#eval strong_num 123\n\n/-\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 40585"}
{"id": "fvapps_003799", "vc-description": "-- Result is non-negative (trivial in Lean since Nat is used)\n\n-- Number of 1 bits is preserved\n\n-- Helper function to count ones\n\n-- Power of 2 input results in power of 2 output\n\n-- Edge cases", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reverse_bits (n : Nat) : Nat :=\nsorry\n\ndef count_ones (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem reverse_bits_nonneg (n : Nat) :\n  reverse_bits n ≥ 0 :=\nsorry\n\ntheorem reverse_bits_preserves_ones (n : Nat) (h : n < 2^32) :\n  count_ones n = count_ones (reverse_bits n) :=\nsorry\n\ntheorem reverse_bits_preserves_power_of_two (n : Nat) (h : n < 2^32)\n  (h₁ : n ≠ 0) (h₂ : n &&& (n - 1) = 0) :\n  (reverse_bits n) &&& ((reverse_bits n) - 1) = 0 :=\nsorry\n\ntheorem reverse_bits_zero :\n  reverse_bits 0 = 0 :=\nsorry\n\ntheorem reverse_bits_one :\n  reverse_bits 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 267\n-/\n#guard_msgs in\n#eval reverse_bits 417\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval reverse_bits 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval reverse_bits 1024"}
{"id": "fvapps_003804", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef counting_triangles (sticks : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem triangle_count_properties {sticks : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 1000) :\n  let result := counting_triangles sticks\n  result ≥ 0 ∧ result ≤ choose sticks.length 3 :=\nsorry\n\ntheorem same_lengths_make_triangles {n : Nat} (h : n > 0) :\n  counting_triangles [n, n, n] = 1 :=\nsorry\n\ntheorem triangle_inequality {sticks : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 1000) :\n  ∃ a b c, (a ∈ sticks ∧ b ∈ sticks ∧ c ∈ sticks) ∧\n           (a + b > c → counting_triangles sticks > 0) :=\nsorry\n\ntheorem order_invariance {sticks sticksSorted : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 100)\n  (h3 : ∀ x, (x ∈ sticks ↔ x ∈ sticksSorted)) :\n  counting_triangles sticks = counting_triangles sticksSorted :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval counting_triangles [2, 3, 7, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [5, 6, 7, 8]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [2, 2, 2, 2]"}
{"id": "fvapps_003808", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def combine_strings : List String → String\n  | _ => sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem combine_strings_length (strings : List String) :\n  (combine_strings strings).length = List.foldl (· + ·) 0 (strings.map String.length) :=\nsorry\n\ntheorem combine_strings_freq (strings : List String) (s : String) (c : Char)\n  (h : s ∈ strings) :\n  (countChar (combine_strings strings) c) ≥\n  (countChar s c) :=\nsorry\n\ntheorem combine_strings_empty :\n  combine_strings [] = \"\" :=\nsorry\n\ntheorem combine_strings_singleton (s : String) :\n  combine_strings [s] = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\"\n\n/-\ninfo: 'a1b2c3'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\" \"123\"\n\n/-\ninfo: 'a1$b2%c3^d&'\n-/\n#guard_msgs in\n#eval combine_strings \"abcd\" \"123\" \"$%^&\""}
{"id": "fvapps_003809", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def paint_letterboxes (start: Nat) (finish: Nat) : List Nat :=\nsorry\n\ndef str_count_digits (n: Nat) : List Nat :=\nsorry\n\ndef toString (n: Nat) : String :=\nsorry\n\ndef sum_list (l: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem paint_letterboxes_range {start finish : Nat} (h: start ≤ finish) :\n  let result := paint_letterboxes start finish\n  List.length result = 10 ∧\n  (∀ x ∈ result, x ≥ 0) :=\nsorry\n\ntheorem paint_letterboxes_single_number (n: Nat) :\n  paint_letterboxes n n = str_count_digits n :=\nsorry\n\ntheorem paint_letterboxes_zero :\n  paint_letterboxes 0 0 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] :=\nsorry\n\ntheorem paint_letterboxes_non_negative {a b : Nat} :\n  ∀ x ∈ paint_letterboxes a b, x ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 9, 6, 3, 0, 1, 1, 1, 1, 1]\n-/\n#guard_msgs in\n#eval paint_letterboxes 125 132\n\n/-\ninfo: [2, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n-/\n#guard_msgs in\n#eval paint_letterboxes 1001 1001"}
{"id": "fvapps_003811", "vc-description": "-- Addition properties\n\n-- Multiplication properties\n\n-- Division properties\n\n-- Modulo properties\n\n-- Exponentiation properties\n\n-- Subtraction properties", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (a b : Int) : Int :=\nsorry\n\ndef multiply (a b : Int) : Int :=\nsorry\n\ndef divide (a b : Int) : Int :=\nsorry\n\ndef mod (a b : Int) : Int :=\nsorry\n\ndef exponent (a b : Int) : Int :=\nsorry\n\ndef subt (a b : Int) : Int :=\nsorry", "vc-theorems": "theorem add_commutative (a b : Int) : add a b = add b a :=\nsorry\n\ntheorem add_identity (a : Int) : add a 0 = a :=\nsorry\n\ntheorem add_associative (a b : Int) : add (add a b) 0 = add a (add b 0) :=\nsorry\n\ntheorem mult_commutative (a b : Int) : multiply a b = multiply b a :=\nsorry\n\ntheorem mult_identity (a : Int) : multiply a 1 = a :=\nsorry\n\ntheorem mult_zero (a : Int) : multiply a 0 = 0 :=\nsorry\n\ntheorem div_self {a : Int} (h : a ≠ 0) : divide a a = 1 :=\nsorry\n\ntheorem div_mult_cancel (a b : Int) (h : b ≠ 0) :\n  multiply (divide a b) b = a :=\nsorry\n\ntheorem mod_bounds (a b : Int) (h : b > 0) :\n  0 ≤ mod a b ∧ mod a b < b :=\nsorry\n\ntheorem mod_reconstruction (a b : Int) (h : b ≠ 0) :\n  a = multiply (divide a b) b + mod a b :=\nsorry\n\ntheorem exp_zero (a : Int) (h : a > 0) : exponent a 0 = 1 :=\nsorry\n\ntheorem exp_one (a : Int) : exponent a 1 = a :=\nsorry\n\ntheorem exp_growth (a b : Int) (h1 : a > 0) (h2 : b > 0) :\n  exponent a b ≥ a :=\nsorry\n\ntheorem subt_as_add (a b : Int) : subt a b = add a (-b) :=\nsorry\n\ntheorem subt_self (a : Int) : subt a a = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval add 1 2\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval add 5 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval add 0 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval multiply 2 3\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval multiply 5 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval divide 6 2\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval divide 5 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 7 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 10 3\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval exponent 2 3\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval exponent 3 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval subt 5 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval subt 10 7"}
{"id": "fvapps_003812", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (s : String) : Bool :=\n  sorry\n\ndef String.toFloat? (s : String) : Option Float :=\n  sorry", "vc-theorems": "theorem valid_float_strings (f : Float) :\n  isDigit (toString f) = true :=\nsorry\n\ntheorem arbitrary_text (s : String) :\n  match s.toFloat? with\n  | some _ => isDigit s = true\n  | none => isDigit s = false\n  :=\nsorry\n\ntheorem whitespace_padding (s : String) (f : Float) :\n  isDigit (s ++ toString f ++ s) = true :=\nsorry\n\ntheorem edge_cases :\n  isDigit \"\" = false ∧\n  isDigit \" \" = false ∧\n  isDigit \"-0\" = true ∧\n  isDigit \"+0\" = true ∧\n  isDigit \"-.1\" = true ∧\n  isDigit \"+.1\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"-234.4\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isDigit \"3 4\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"0.0\""}
{"id": "fvapps_003815", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def elections_winners (votes: List Nat) (k: Nat) : Nat :=\n  sorry\n\ndef list_maximum (l: List Nat) (h: l.length > 0) : Nat :=\n  sorry\n\ndef list_minimum (l: List Nat) (h: l.length > 0) : Nat :=\n  sorry", "vc-theorems": "theorem elections_winners_properties_result_bounds\n  (votes: List Nat) (k: Nat) (h: votes.length > 0) :\n  let result := elections_winners votes k\n  0 ≤ result ∧ result ≤ votes.length :=\nsorry\n\ntheorem elections_winners_k_zero_result\n  (votes: List Nat) (h: votes.length > 0) :\n  let result := elections_winners votes 0\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [2, 3, 5, 2] 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval elections_winners [1, 3, 3, 1, 1] 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [3, 1, 1, 3, 1] 2"}
{"id": "fvapps_003837", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def strLen (s : String) : Nat :=\n  sorry\n\ndef stringSuffix (s : String) : Nat :=\n  sorry\n\ndef isRepeatedChar (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem string_suffix_positive (s : String) :\n  stringSuffix s ≥ 0 :=\nsorry\n\ntheorem string_suffix_ge_len (s : String) :\n  stringSuffix s ≥ strLen s :=\nsorry\n\ntheorem string_suffix_le_square (s : String) :\n  stringSuffix s ≤ strLen s * strLen s :=\nsorry\n\ntheorem string_suffix_repeated_char (s : String) :\n  isRepeatedChar s → stringSuffix s = (strLen s * (strLen s + 1)) / 2 :=\nsorry\n\ntheorem string_suffix_empty :\n  stringSuffix \"\" = 0 :=\nsorry\n\ntheorem string_suffix_slice (s : String) (i : Nat) :\n  i < strLen s → stringSuffix (s.drop i) ≤ stringSuffix s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval string_suffix \"abc\"\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval string_suffix \"ababaa\"\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval string_suffix \"aaaa\""}
{"id": "fvapps_003845", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_num (arr : List Nat) : List Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef minimum (l : List Nat) (h : l.length > 0) : Nat :=\nsorry\n\ndef product (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem get_num_basic_properties {arr : List Nat} (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, 2 ≤ x ∧ x ≤ 20) :\n  let result := get_num arr\n  result.length = 4 ∧\n  result[0]! = product arr ∧\n  result[2]! = minimum arr h1 ∧\n  result[3]! = result[0]! / result[2]! :=\nsorry\n\ntheorem get_num_small_factors {arr : List Nat}\n  (h1 : 2 ≤ arr.length ∧ arr.length ≤ 3)\n  (h2 : ∀ x ∈ arr, 2 ≤ x ∧ x ≤ 7) :\n  let result := get_num arr\n  result[0]! > 0 ∧\n  result[1]! ≥ 0 ∧\n  result[2]! ≤ minimum arr (by exact Nat.zero_lt_of_lt h1.left) ∧\n  result[0]! % result[2]! = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [150, 11, 2, 75]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 5, 5]\n\n/-\ninfo: [378, 15, 2, 189]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 3, 3, 7]\n\n/-\ninfo: [23400, 71, 2, 11700]\n-/\n#guard_msgs in\n#eval get_num [2, 13, 2, 5, 2, 5, 3, 3]"}
{"id": "fvapps_003851", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_ones (n : Nat) : Nat :=\n  sorry\n\ndef max_pn (n : Nat) : Nat :=\n  sorry\n\ndef an_over (n : Nat) : List Float :=\n  sorry\n\ndef an_over_average (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_ones_bounds {n : Nat} (h : n > 0) :\n  count_ones n ≤ n ∧ count_ones n ≥ 0 := by\nsorry\n\ntheorem count_ones_nat {n : Nat} (h : n > 0) :\n  count_ones n ≥ 0 := by\nsorry\n\ntheorem max_pn_gt_one {n : Nat} (h : n > 0) :\n  max_pn n > 1 := by\nsorry\n\ntheorem max_pn_nat {n : Nat} (h : n > 0) :\n  max_pn n ≥ 0 := by\nsorry\n\ntheorem an_over_length {n : Nat} (h : n > 0) :\n  (an_over n).length = n := by\nsorry\n\ntheorem an_over_all_positive {n : Nat} (h : n > 0) :\n  ∀ x ∈ an_over n, x > 0 := by\nsorry\n\ntheorem an_over_average_positive {n : Nat} (h : n > 0) :\n  an_over_average n > 0 := by\nsorry\n\ntheorem an_over_average_nat {n : Nat} (h : n > 0) :\n  an_over_average n ≥ 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_ones 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_ones 5\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pn 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval an_over_average 1"}
{"id": "fvapps_003859", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def containsThree (n : Int) : Bool :=\n  sorry\n\ndef magicSum (nums : List Int) : Int :=\n  sorry\n\ndef sumList (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem magic_sum_filtering_contributing (nums : List Int) :\n  let contributing := nums.filter (fun x => x % 2 = 1 ∧ containsThree x)\n  contributing ≠ [] → magicSum nums = magicSum contributing := by\n  sorry\n\ntheorem magic_sum_filtering_non_contributing (nums : List Int) :\n  let non_contributing := nums.filter (fun x => x % 2 = 0 ∨ ¬containsThree x)\n  magicSum non_contributing = 0 := by\n  sorry\n\ntheorem magic_sum_order_invariant (nums : List Int) :\n  magicSum nums = magicSum nums.reverse := by\n  sorry\n\ntheorem magic_sum_duplicates (nums : List Int) :\n  magicSum (nums ++ nums) = 2 * magicSum nums := by\n  sorry\n\ntheorem magic_sum_empty :\n  magicSum [] = 0 := by\n  sorry\n\ntheorem magic_sum_valid_sum (nums : List Int) :\n  let valid := nums.filter (fun x => x % 2 = 1 ∧ containsThree x)\n  valid ≠ [] → magicSum nums = sumList valid := by\n  sorry\n\ntheorem magic_sum_all_invalid (nums : List Int) :\n  (∀ x ∈ nums, x % 2 = 0 ∨ ¬containsThree x) → magicSum nums = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval magic_sum [3]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 13]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 12, 5, 8, 30, 13]"}
{"id": "fvapps_003860", "vc-description": "-- Helper functions", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_happy_year (year : Nat) : Nat :=\nsorry\n\ndef number_to_digits (n : Nat) : List Nat :=\nsorry\n\ndef count_unique (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem next_happy_year_increases (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 8999) :\n  next_happy_year year > year :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1023\n-/\n#guard_msgs in\n#eval next_happy_year 1001\n\n/-\ninfo: 7801\n-/\n#guard_msgs in\n#eval next_happy_year 7712\n\n/-\ninfo: 9012\n-/\n#guard_msgs in\n#eval next_happy_year 8999"}
{"id": "fvapps_003875", "vc-description": "", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def firstNonConsecutive (arr : List Int) : Option Int :=\n  sorry", "vc-theorems": "theorem empty_or_single_returns_none (arr : List Int) :\n  arr.length ≤ 1 → firstNonConsecutive arr = none :=\nsorry\n\ntheorem consecutive_returns_none (arr : List Int) (h : arr.length ≥ 2) :\n  (∀ i j, i + 1 = j → arr[i]? = some x → arr[j]? = some y → y = x + 1) →\n  firstNonConsecutive arr = none :=\nsorry\n\ntheorem non_consecutive_returns_first_break (arr : List Int) (gap : Int)\n    (h1 : arr.length ≥ 3) (h2 : (abs gap) > 1) :\n  let pos := arr.length / 2\n  let val := arr[pos]?\n  match val with\n  | none => True\n  | some x =>\n    let next := arr[pos+1]?\n    match next with\n    | none => True\n    | some y => x + gap = y → firstNonConsecutive arr = some y\n  :=\nsorry\n\ntheorem result_in_input (arr : List Int) :\n  match firstNonConsecutive arr with\n  | none => True\n  | some x => x ∈ arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 6, 7, 8]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval first_non_consecutive [-3, -2, 0, 1]"}
{"id": "fvapps_003877", "vc-description": "", "vc-preamble": "def Position := String", "vc-helpers": "", "vc-definitions": "def Command := String\n\ndef tetris (commands : List Command) : Nat :=\n  sorry\n\ndef sumHeights (commands : List Command) : Nat :=\n  sorry", "vc-theorems": "theorem tetris_output_natural (commands : List Command) :\n  tetris commands ≥ 0 :=\nsorry\n\ntheorem tetris_height_limit (commands : List Command) (h : commands ≠ []) :\n  tetris commands < 30 :=\nsorry\n\ntheorem tetris_cleared_lines (commands : List Command) (h : commands ≠ []) :\n  tetris commands ≤ sumHeights commands :=\nsorry\n\ntheorem tetris_idempotent_empty_moves (commands : List Command) (h : commands ≠ []) :\n  let emptyMoves : List Command := [\"1L0\", \"1R0\"]\n  tetris commands = tetris (commands ++ emptyMoves) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval tetris [\"1R4\", \"2L3\", \"3L2\", \"4L1\", \"1L0\", \"2R1\", \"3R2\", \"4R3\", \"1L4\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval tetris [\"1L2\", \"4R2\", \"3L3\", \"3L1\", \"1L4\", \"1R4\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval tetris [\"4R4\", \"4L3\", \"4L2\", \"4L1\", \"4L0\", \"4R1\", \"4R2\", \"4R3\", \"3L4\"]"}
{"id": "fvapps_003884", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\n  sorry\n\ndef added_char (base modified : String) : Char :=\n  sorry", "vc-theorems": "theorem added_char_correct (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  added_char base modified = c :=\nsorry\n\ntheorem length_difference (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  modified.length = base.length + 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"hello\" \"checlclo\"\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"aabbcc\" \"aacccbbcc\"\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval added_char \"abcde\" \"2db2a2ec\""}
{"id": "fvapps_003887", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUpperCase (c : Char) : Bool :=\n  sorry\n\ndef toLetterIndex (c : Char) : Nat :=\n  sorry\n\ndef new_numeral_system (letter : Char) : List String :=\n  sorry", "vc-theorems": "theorem correct_format {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    s.length = 5 ∧ s.data.get ⟨1, sorry⟩ = ' ' ∧\n    s.data.get ⟨2, sorry⟩ = '+' ∧\n    s.data.get ⟨3, sorry⟩ = ' ' := by\n  sorry\n\ntheorem valid_letters {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    let first := s.data.get ⟨0, sorry⟩\n    let last := s.data.get ⟨4, sorry⟩\n    isUpperCase first ∧\n    isUpperCase last ∧\n    first ≤ letter ∧\n    last ≤ letter := by\n  sorry\n\ntheorem correct_sum {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    let first := s.data.get ⟨0, sorry⟩\n    let last := s.data.get ⟨4, sorry⟩\n    toLetterIndex first + toLetterIndex last = toLetterIndex letter := by\n  sorry\n\ntheorem left_side_sorted {letter : Char} :\n  let leftSide := (new_numeral_system letter).map (fun s => s.data.get ⟨0, sorry⟩)\n  ∀ i j, i < j → j < leftSide.length → leftSide[i]! ≤ leftSide[j]! := by\n  sorry\n\ntheorem middle_pair_equal {letter : Char} :\n  toLetterIndex letter % 2 = 0 →\n    let result := new_numeral_system letter\n    let midIdx := toLetterIndex letter / 2\n    let middle := result[midIdx]!\n    middle.data.get ⟨0, sorry⟩ = middle.data.get ⟨4, sorry⟩ := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_003888", "vc-description": "-- States that flipping a bit twice returns the original value\n\n-- States that only the target bit changes", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flip_bit (value : Int) (bit_index : Nat) : Int :=\nsorry\n\ndef band (x y : Int) : Int :=\nsorry\n\ndef shiftLeft (x : Int) (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem flip_bit_reversible\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 ≤ bit_index) (h2 : bit_index ≤ 32) :\n  flip_bit (flip_bit value bit_index) bit_index = value :=\nsorry\n\ntheorem flip_bit_changes_target_bit\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 ≤ bit_index) (h2 : bit_index ≤ 32) :\n  ∃ bit_mask : Int,\n    bit_mask = shiftLeft 1 (bit_index - 1) ∧\n    band value bit_mask ≠ band (flip_bit value bit_index) bit_mask ∧\n    band value (bit_mask - 1) = band (flip_bit value bit_index) (bit_mask - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 32768\n-/\n#guard_msgs in\n#eval flip_bit 0 16\n\n/-\ninfo: 1073741823\n-/\n#guard_msgs in\n#eval flip_bit 2147483647 31\n\n/-\ninfo: 255\n-/\n#guard_msgs in\n#eval flip_bit 127 8"}
{"id": "fvapps_003889", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isScientificNotation (s : String) : Bool :=\nsorry\n\ndef sumProd (s : String) : String :=\nsorry\n\ndef stringToFloat (s : String) : Float :=\nsorry", "vc-theorems": "theorem sumProd_format {nums : List Float}\n  (h1 : ∀ n ∈ nums, 0.1 ≤ n ∧ n ≤ 100)\n  (h2 : 2 ≤ nums.length ∧ nums.length ≤ 4) :\n  isScientificNotation (sumProd (\"+\".intercalate (nums.map toString))) :=\nsorry\n\ntheorem sumProd_multiply (x y : Nat)\n  (h1 : 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ y ∧ y ≤ 100) :\n  (stringToFloat (sumProd (s!\"{x}*{y}\"))) = Float.ofNat (x * y) :=\nsorry\n\ntheorem sumProd_add (x y : Nat)\n  (h1 : 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ y ∧ y ≤ 100) :\n  (stringToFloat (sumProd (s!\"{x}+{y}\"))) = Float.ofNat (x + y) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '2.60000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5*4+6\"\n\n/-\ninfo: '2.90000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5+4*6\"\n\n/-\ninfo: '3.58000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5.4*4.0+6.2+8.0\""}
{"id": "fvapps_003895", "vc-description": "", "vc-preamble": "def listSum (l : List Int) : Int :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def sumEvenNumbers (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_even_numbers_sums_evens (l : List Int) :\n  sumEvenNumbers l = listSum (l.filter (fun n => n % 2 = 0)) := by\n  sorry\n\ntheorem sum_even_numbers_is_even (l : List Int) :\n  sumEvenNumbers l % 2 = 0 := by\n  sorry\n\ntheorem sum_even_numbers_idempotent (l : List Int) :\n  let result := sumEvenNumbers l\n  result ≠ 0 → sumEvenNumbers [result] = result := by\n  sorry\n\ntheorem sum_even_numbers_empty :\n  sumEvenNumbers [] = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval sum_even_numbers [4, 3, 1, 2, 5, 10, 6, 7, 9, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_even_numbers []\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval sum_even_numbers [-16, -32, 20, 21, 41, 42]"}
{"id": "fvapps_003900", "vc-description": "-- Sum matches total multiples\n\n-- Components match exclusive counts\n\n-- Edge cases\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Output format properties", "vc-preamble": "def isMultipleOf3 (x : Nat) : Bool := x % 3 == 0\n\ndef isMultipleOf5 (x : Nat) : Bool := x % 5 == 0", "vc-helpers": "", "vc-definitions": "def solution (n : Nat) : Array Nat :=\nsorry", "vc-theorems": "theorem solution_output_format (n : Nat) (h : n > 0) :\n  (solution n).size = 3 ∧\n  ∀ i < 3, (solution n)[i]! ≥ 0 :=\nsorry\n\ntheorem solution_sum_matches_multiples (n : Nat) (h : n > 0) :\n  let result := solution n\n  let total := result[0]! + result[1]! + result[2]!\n  let multiples := (List.range n).filter (fun x => isMultipleOf3 x || isMultipleOf5 x)\n  total = multiples.length :=\nsorry\n\ntheorem solution_component_counts (n : Nat) (h : n > 0) :\n  let result := solution n\n  let only3 := (List.range n).filter (fun x => isMultipleOf3 x && !isMultipleOf5 x)\n  let only5 := (List.range n).filter (fun x => isMultipleOf5 x && !isMultipleOf3 x)\n  let both := (List.range n).filter (fun x => isMultipleOf3 x && isMultipleOf5 x)\n  result[0]! = only3.length ∧\n  result[1]! = only5.length ∧\n  result[2]! = both.length :=\nsorry\n\ntheorem solution_edge_cases :\n  solution 1 = #[0, 0, 0] ∧\n  solution 3 = #[0, 0, 0] ∧\n  solution 4 = #[1, 0, 0] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003909", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsUpper (c : Char) : Bool :=\nsorry\n\ndef IsLower (c : Char) : Bool :=\nsorry\n\ndef swapcase (c : Char) : Char :=\nsorry\n\ndef sc (s : String) : String :=\nsorry", "vc-theorems": "theorem sc_subset (s : String) :\n  ∀ (c : Char), c ∈ (sc s).data → c ∈ s.data :=\nsorry\n\ntheorem sc_length (s : String) :\n  (sc s).length ≤ s.length :=\nsorry\n\ntheorem sc_swapcase_pairs (s : String) :\n  ∀ (c : Char), c ∈ (sc s).data → swapcase c ∈ (sc s).data :=\nsorry\n\ntheorem sc_all_upper (s : String) :\n  (∀ (c : Char), c ∈ s.data → IsUpper c) → sc s = \"\" :=\nsorry\n\ntheorem sc_all_lower (s : String) :\n  (∀ (c : Char), c ∈ s.data → IsLower c) → sc s = \"\" :=\nsorry\n\ntheorem sc_empty :\n  sc \"\" = \"\" :=\nsorry\n\ntheorem sc_idempotent (s : String) :\n  sc (sc s) = sc s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Aa'\n-/\n#guard_msgs in\n#eval sc \"Aab\"\n\n/-\ninfo: 'AabB'\n-/\n#guard_msgs in\n#eval sc \"AabBc\"\n\n/-\ninfo: 'SONson'\n-/\n#guard_msgs in\n#eval sc \"SONson\""}
{"id": "fvapps_003910", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lcm_cardinality (n : Nat) : Nat :=\nsorry\n\ndef lcm (a b : Nat) : Nat :=\nsorry\n\ndef divisors (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem lcm_cardinality_positive (n : Nat) (h : n ≥ 1) :\n  lcm_cardinality n ≥ 1 :=\nsorry\n\ntheorem lcm_cardinality_upper_bound (n : Nat) (h : n ≥ 1) :\n  let divs := List.length (divisors n)\n  lcm_cardinality n ≤ 1 + (divs * (divs - 1)) / 2 :=\nsorry\n\ntheorem lcm_cardinality_monotonic_powers_two (i : Nat) (h : i > 0) :\n  lcm_cardinality (2^i) ≥ lcm_cardinality (2^(i-1)) :=\nsorry\n\ntheorem lcm_factors_bound (n : Nat) (h : n ≥ 1) :\n  ∀ (a b : Nat), a ∈ divisors n → b ∈ divisors n → lcm a b ≤ n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003912", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_weight (s : String) : Nat :=\n  sorry\n\ndef swapcase (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem get_weight_nonnegative (s : String) :\n  get_weight s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 254\n-/\n#guard_msgs in\n#eval get_weight \"Joe\"\n\n/-\ninfo: 1275\n-/\n#guard_msgs in\n#eval get_weight \"George Washington\"\n\n/-\ninfo: 214\n-/\n#guard_msgs in\n#eval get_weight \"R2D2\""}
{"id": "fvapps_003913", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def what_time_is_it (angle : Float) : String :=\nsorry\n\ndef str_to_hours_mins (s : String) : Nat × Nat :=\nsorry\n\ndef angle_to_total_mins (angle : Float) : Float :=\nsorry", "vc-theorems": "theorem time_format_valid {angle : Float} (h : 0 ≤ angle ∧ angle ≤ 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  result.length = 5 ∧\n  hours ≥ 1 ∧ hours ≤ 12 ∧\n  mins ≥ 0 ∧ mins ≤ 59 :=\nsorry\n\ntheorem time_calculation_consistent {angle : Float} (h : 0 ≤ angle ∧ angle ≤ 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  let expected_total_mins := angle / 360 * 12 * 60\n  let actual_total_mins := (hours % 12) * 60 + mins\n  (expected_total_mins - actual_total_mins.toFloat).abs < 2 :=\nsorry\n\ntheorem hour_boundaries_correct (angle : Nat) (h : angle < 360) :\n  let result := what_time_is_it angle.toFloat\n  let (hours, _) := str_to_hours_mins result\n  if angle < 30 then hours = 12\n  else hours = angle / 30 :=\nsorry\n\ntheorem specific_angles_correct :\n  (str_to_hours_mins (what_time_is_it 0)).1 = 12 ∧\n  (str_to_hours_mins (what_time_is_it 30)).1 = 1 ∧\n  (str_to_hours_mins (what_time_is_it 330)).1 = 11 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '12:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 0\n\n/-\ninfo: '03:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 90\n\n/-\ninfo: '01:30'\n-/\n#guard_msgs in\n#eval what_time_is_it 45"}
{"id": "fvapps_003917", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidHKPhoneNumber (s : String) : Bool :=\nsorry\n\ndef hasValidHKPhoneNumber (s : String) : Bool :=\nsorry\n\ndef isValidDigitStr (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_number_is_accepted {d1 d2 : String} :\n  isValidDigitStr d1 → isValidDigitStr d2 →\n  isValidHKPhoneNumber (d1 ++ \" \" ++ d2) ∧\n  hasValidHKPhoneNumber (d1 ++ \" \" ++ d2) :=\nsorry\n\ntheorem invalid_numbers_are_rejected {s : String} :\n  (∃ i, String.get? s i = some ' ') →\n  (∃ i n, String.get? s i = some n ∧ (n < '0' ∨ n > '9')) →\n  ¬isValidHKPhoneNumber s :=\nsorry\n\ntheorem has_valid_number_with_text {d1 d2 pre suf : String} :\n  isValidDigitStr d1 → isValidDigitStr d2 →\n  hasValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) ∧\n  ¬isValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"1234 5678\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"abcd efgh\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"836g 2986\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"Call 1234 5678 now\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"No number here\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"8365 2986 is my number\""}
{"id": "fvapps_003922", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\nsorry\n\ndef countOccurrences (c : Char) (s : String) : Nat :=\nsorry\n\ndef allCountsEqual (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_exists_char_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length ≥ 2) :\n  ∃ c : Char, c ∈ s.data ∧\n  allCountsEqual (s.replace (String.mk [c]) \"\") = true :=\nsorry\n\ntheorem solve_equal_counts_after_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length ≥ 2) :\n  ∃ c : Char, c ∈ s.data ∧\n  let s' := s.replace (String.mk [c]) \"\"\n  (∀ c₁ c₂, c₁ ∈ s'.data → c₂ ∈ s'.data →\n    countOccurrences c₁ s' = countOccurrences c₂ s') :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"aaaa\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbba\""}
{"id": "fvapps_003924", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_square (n : Int) : Bool :=\nsorry\n\ndef Int.sqrt (n : Int) : Int :=\nsorry", "vc-theorems": "theorem is_square_properties_1 {n : Int} :\n  is_square n = true → n ≥ 0 :=\nsorry\n\ntheorem is_square_properties_3 {n : Nat} :\n  is_square (n * n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003927", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bubblesortOnce (xs : List Int) : List Int :=\n  sorry\n\ndef isSorted (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem output_same_length {xs : List Int} (h : xs ≠ []) :\n  List.length (bubblesortOnce xs) = List.length xs :=\nsorry\n\ntheorem input_unchanged {xs : List Int} (h : xs ≠ []) :\n  let original := xs\n  bubblesortOnce xs = bubblesortOnce original :=\nsorry\n\ntheorem at_least_one_swap_if_unsorted {xs : List Int} (h : xs ≠ []) :\n  List.length xs > 1 →\n  ¬isSorted xs →\n  bubblesortOnce xs ≠ xs :=\nsorry\n\ntheorem moves_max_element_right {xs : List Int} (h : xs ≠ []) :\n  List.length xs > 1 →\n  let result := bubblesortOnce xs\n  ∀ y ∈ List.take (List.length result - 1) result,\n  y ≤ List.get! result (List.length result - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval bubblesort_once [9, 7, 5, 3, 1, 2, 4, 6, 8]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval bubblesort_once [6, 3, 4, 9, 1, 2, 7, 8, 5]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval bubblesort_once [2, 4, 1]"}
{"id": "fvapps_003931", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- 12 is smallest abundant number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDivisors (n : Int) : Int :=\n  sorry\n\ndef abundant (n : Int) : Option (List (List Int)) :=\n  sorry", "vc-theorems": "theorem abundant_output_structure\n  (h : Int)\n  (h_ge : h ≥ 12)\n  (h_le : h ≤ 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result) :\n  result.length = 2 ∧\n  ∀ sublist ∈ result, sublist.length = 1 ∧\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x ≥ 0 :=\nsorry\n\ntheorem abundant_properties\n  (h : Int)\n  (h_ge : h ≥ 12)\n  (h_le : h ≤ 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result)\n  (n : Int := (result.get! 0).get! 0)\n  (diff : Int := (result.get! 1).get! 0) :\n  n ≤ h ∧\n  n > 0 ∧\n  sumOfDivisors n > n ∧\n  sumOfDivisors n - n = diff :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003933", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_sorted_and_how (arr : List Int) : String :=\nsorry\n\ndef isSorted (arr : List Int) : Bool :=\nsorry\n\ndef isSortedDesc (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem sorted_properties (arr : List Int) (h : arr.length > 0) :\n  match is_sorted_and_how arr with\n  | \"yes, ascending\" => isSorted arr = true\n  | \"yes, descending\" => isSortedDesc arr = true\n  | _ => ¬(isSorted arr) ∧ ¬(isSortedDesc arr)\n  :=\nsorry\n\ntheorem result_is_valid (arr : List Int) (h : arr.length > 0) :\n  is_sorted_and_how arr = \"yes, ascending\" ∨\n  is_sorted_and_how arr = \"yes, descending\" ∨\n  is_sorted_and_how arr = \"no\"\n  :=\nsorry\n\ntheorem ascending_lists (arr : List Int) (h : arr.length > 0) (h2 : isSorted arr) :\n  is_sorted_and_how arr = \"yes, ascending\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'yes, ascending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [1, 2]\n\n/-\ninfo: 'yes, descending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [15, 7, 3, -8]\n\n/-\ninfo: 'no'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [4, 2, 30]"}
{"id": "fvapps_003934", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_digits (n : Int) : Int :=\n  sorry\n\ndef sum_of_digits_string (n : Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_digits_nonnegative (x : Int) :\n  sum_digits x ≥ 0 :=\nsorry\n\ntheorem sum_digits_symmetric (x : Int) :\n  sum_digits x = sum_digits (-x) :=\nsorry\n\ntheorem sum_digits_less_than_input (x : Int) (h : x.natAbs > 9) :\n  sum_digits x < x.natAbs :=\nsorry\n\ntheorem sum_digits_single_digit (x : Int)\n  (h : 0 ≤ x.natAbs ∧ x.natAbs ≤ 9) :\n  sum_digits x = x.natAbs :=\nsorry\n\ntheorem sum_digits_matches_string_sum (x : Int) :\n  x ≥ 0 → sum_digits x = sum_of_digits_string x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_digits 10\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval sum_digits 99\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_digits -32"}
{"id": "fvapps_003937", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mygcd (x y : Int) : Int :=\n  sorry\n\ndef abs (x : Int) : Int :=\n  sorry", "vc-theorems": "theorem gcd_positive_integers {x y : Int} (hx : x > 0) (hy : y > 0) :\n  let g := mygcd x y\n  g > 0 ∧ x % g = 0 ∧ y % g = 0 :=\nsorry\n\ntheorem gcd_identity {x : Int} :\n  mygcd x x = x :=\nsorry\n\ntheorem gcd_associative {x y : Int} (hx : x > 0) (hy : y > 0) :\n  mygcd (x * y) x = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mygcd 1 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval mygcd 60 12\n\n/-\ninfo: 334\n-/\n#guard_msgs in\n#eval mygcd 2672 5678"}
{"id": "fvapps_003941", "vc-description": "-- Result should be non-negative\n\n-- For 0 dimensions, result should be 0\n\n-- Result should be x*y for 1xN rectangles\n\n-- For a square, result should be sum of squares from 1 to side length", "vc-preamble": "def sum_squares (n : Nat) : Nat :=\n  Nat.rec 0 (fun k res => res + k*k) n", "vc-helpers": "", "vc-definitions": "def findSquares (x y : Nat) : Nat :=\nsorry", "vc-theorems": "theorem findSquares_nonneg (x y : Nat) :\n  findSquares x y ≥ 0 :=\nsorry\n\ntheorem findSquares_zero (x y : Nat) :\n  x = 0 ∨ y = 0 → findSquares x y = 0 :=\nsorry\n\ntheorem findSquares_stripe (x y : Nat) :\n  y = 1 → findSquares x y = x :=\nsorry\n\ntheorem findSquares_square (n : Nat) :\n  findSquares n n = sum_squares n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval findSquares 3 2\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval findSquares 4 3\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval findSquares 11 4"}
{"id": "fvapps_003942", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def group_check (s : String) : Bool :=\nsorry\n\ndef isOpening (c : Char) : Bool :=\nsorry\n\ndef isClosing (c : Char) : Bool :=\nsorry\n\ndef matching (o c : Char) : Bool :=\nsorry\n\ndef countOpening (s : String) : Nat :=\nsorry\n\ndef countClosing (s : String) : Nat :=\nsorry", "vc-theorems": "theorem empty_string_valid :\n  group_check \"\" = true :=\nsorry\n\ntheorem simple_pair_valid (o c : Char) :\n  isOpening o → matching o c →\n  group_check (String.mk [o, c]) = true :=\nsorry\n\ntheorem valid_brackets_equal_counts {s : String} :\n  group_check s = true →\n  countOpening s = countClosing s :=\nsorry\n\ntheorem only_opening_invalid {s : String} :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, isOpening c) →\n  group_check s = false :=\nsorry\n\ntheorem only_closing_invalid {s : String} :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, isClosing c) →\n  group_check s = false :=\nsorry\n\ntheorem nested_brackets_valid {opens : List Char} :\n  opens ≠ [] →\n  (∀ c ∈ opens, isOpening c) →\n  let closes := (opens.map (λ o => match o with\n    | '(' => ')'\n    | '{' => '}'\n    | '[' => ']'\n    | _ => ' ')).reverse\n  group_check (String.mk (opens ++ closes)) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"({})\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"[[]()]\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval group_check \"{(})\""}
{"id": "fvapps_003946", "vc-description": "", "vc-preamble": "def coprime (x y : Nat) : Prop :=\n  gcd x y = 1", "vc-helpers": "", "vc-definitions": "def gcd (x y : Nat) : Nat :=\n  sorry\n\ndef rat_at (n : Nat) : Nat × Nat :=\n  sorry\n\ndef index_of (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem rat_at_index_inverse (n : Nat) :\n  let (a, b) := rat_at n\n  index_of a b = n :=\nsorry\n\ntheorem base_cases :\n  rat_at 0 = (1, 1) ∧\n  index_of 1 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval rat_at 0\n\n/-\ninfo: (1, 3)\n-/\n#guard_msgs in\n#eval rat_at 3\n\n/-\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval rat_at 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval index_of 1 1"}
{"id": "fvapps_003956", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Int :=\n  sorry\n\ndef isBalanced (s : String) : Bool :=\n  sorry\n\ndef repeated_parens (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem solve_odd_length_returns_minus_one {s : String} :\n  (s.length % 2 = 1) → solve s = -1 :=\nsorry\n\ntheorem solve_valid_solution_bound {s : String} :\n  solve s ≥ 0 → solve s ≤ s.length :=\nsorry\n\ntheorem solve_empty_string :\n  solve \"\" = 0 :=\nsorry\n\ntheorem solve_single_paren_left :\n  solve \"(\" = -1 :=\nsorry\n\ntheorem solve_single_paren_right :\n  solve \")\" = -1 :=\nsorry\n\ntheorem solve_reversed_pair :\n  solve \")(\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \")(\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"(((())\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve \"(((\""}
{"id": "fvapps_003957", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def BLACK : Int := 1\n\ndef WHITE : Int := 0", "vc-helpers": "", "vc-definitions": "def ant (grid : List (List Int)) (col : Int) (row : Int) (steps : Int)\n  (direction : Int := 0) : List (List Int) :=\nsorry", "vc-theorems": "theorem ant_result_rectangular {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3)\n  (h6: grid.length > 0) (h7 : ∀ r ∈ grid, r.length = grid.head!.length) :\n  let result := ant grid col row steps dir\n  ∀ r ∈ result, r.length = result.head!.length :=\nsorry\n\ntheorem ant_result_valid_colors {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  ∀ r ∈ result, ∀ cell ∈ r, cell = BLACK ∨ cell = WHITE :=\nsorry\n\ntheorem ant_result_size {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  result.length ≥ grid.length ∧ result.head!.length ≥ grid.head!.length :=\nsorry\n\ntheorem ant_preserves_input {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  grid = grid :=\nsorry\n\ntheorem ant_zero_steps {grid : List (List Int)} {col row : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) :\n  ant grid col row 0 = grid :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003959", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For any non-empty repeater output, we can verify it consists of the original string repeated -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def repeater (s : String) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem repeater_length (s : String) (n : Nat) :\n  (repeater s n).length = s.length * n :=\nsorry\n\ntheorem repeater_eq_concat (s : String) (n : Nat) :\n  repeater s n = String.join (List.replicate n s) :=\nsorry\n\ntheorem repeater_validity (s : String) (n : Nat) (h : n > 0) :\n  ∀ k : Nat, k < n → String.isPrefixOf s (repeater s n) :=\nsorry\n\ntheorem repeater_zero (s : String) :\n  repeater s 0 = \"\" :=\nsorry\n\ntheorem repeater_one (s : String) :\n  repeater s 1 = s :=\nsorry", "vc-postamble": "/-\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval repeater \"a\" 5\n\n/-\ninfo: 'NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNa'\n-/\n#guard_msgs in\n#eval repeater \"Na\" 16\n\n/-\ninfo: 'Wub Wub Wub Wub Wub Wub '\n-/\n#guard_msgs in\n#eval repeater \"Wub \" 6"}
{"id": "fvapps_003962", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def sum : List Nat → Nat\n| [] => 0\n| (x::xs) => x + sum xs\n\ndef maxList : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => max x (maxList xs)\n\ndef zipWith (f : Nat → Nat → Nat) : List Nat → List Nat → List Nat\n| [], _ => []\n| _, [] => []\n| (x::xs), (y::ys) => f x y :: zipWith f xs ys\n\ndef pairwiseProduct (nums : List Nat) : Nat :=\n  let n := nums.length\n  let firstHalf := nums.take (n/2)\n  let secondHalf := (nums.drop (n/2)).reverse\n  sum (zipWith (fun x y => x * y) firstHalf secondHalf)", "vc-helpers": "", "vc-definitions": "def min_sum (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_sum_non_negative (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≥ 0 :=\nsorry\n\ntheorem min_sum_upper_bound (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≤ sum nums * maxList nums :=\nsorry\n\ntheorem min_sum_reverse_invariant (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums = min_sum nums.reverse :=\nsorry\n\ntheorem min_sum_permutation_invariant (nums₁ nums₂ : List Nat)\n  (h1 : nums₁.length ≥ 2)\n  (h2 : nums₁.length % 2 = 0)\n  (h3 : nums₁.length = nums₂.length)\n  (h4 : ∀ x, nums₁.count x = nums₂.count x) :\n  min_sum nums₁ = min_sum nums₂ :=\nsorry\n\ntheorem min_sum_minimality (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≤ pairwiseProduct nums :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003967", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime : Nat → Bool :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry\n\ndef factors_up_to (n : Nat) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem not_prime_if_less_than_2 (n : Nat) (h : n ≤ 1) : ¬(is_prime n = true) :=\nsorry\n\ntheorem prime_iff_no_factors (n : Nat) (h : n ≥ 2) :\n  is_prime n = true ↔ ¬(factors_up_to n (n/2) = true) :=\nsorry\n\ntheorem wilson_prime_property (n : Nat) (h1 : n ≥ 2) (h2 : n ≤ 20) :\n  is_prime n = true → (factorial (n-1) + 1) % n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 29\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_prime 143"}
{"id": "fvapps_003971", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.sumAscii (s : String) : Nat :=\nsorry\n\ndef highest_value (a b : String) : String :=\nsorry", "vc-theorems": "theorem highest_value_is_input (a b : String) :\n  let result := highest_value a b\n  result = a ∨ result = b :=\nsorry\n\ntheorem highest_value_maximizes_sum (a b : String) :\n  let result := highest_value a b\n  String.sumAscii result ≥ String.sumAscii (if result = a then b else a) :=\nsorry\n\ntheorem highest_value_equal_sums (a b : String) :\n  String.sumAscii a = String.sumAscii b →\n  highest_value a b = a :=\nsorry\n\ntheorem highest_value_identical (s : String) :\n  highest_value s s = s :=\nsorry\n\ntheorem highest_value_nonempty (a b : String) :\n  a.length > 0 →\n  b.length > 0 →\n  (highest_value a b).length > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'KkLlMmNnOoPp4567'\n-/\n#guard_msgs in\n#eval highest_value \"AaBbCcXxYyZz0189\" \"KkLlMmNnOoPp4567\"\n\n/-\ninfo: 'ABcd'\n-/\n#guard_msgs in\n#eval highest_value \"ABcd\" \"0123\"\n\n/-\ninfo: \"{}[]@~'#:;\"\n-/\n#guard_msgs in\n#eval highest_value \"!\"?$%^&*()\" \"{}[]@~\"#:;\""}
{"id": "fvapps_003974", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pairwise_pairs : List Int → Int → List (Int × Int)\n| xs, n =>\nsorry\n\ndef pairwise : List Int → Int → Int\n| xs, n =>\nsorry", "vc-theorems": "theorem pairwise_nonnegative {arr : List Int} {n : Int} :\n  pairwise arr n ≥ 0 := by\nsorry\n\ntheorem pairwise_less_than_triangular {arr : List Int} {n : Int} :\n  let max_triangular := (arr.length * (arr.length - 1)) / 2\n  pairwise arr n ≤ max_triangular := by\nsorry\n\ntheorem pairwise_indices_sum_correctly {arr : List Int} {n : Int} :\n  let used_indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.foldr (· + ·) 0 used_indices = pairwise arr n := by\nsorry\n\ntheorem pairwise_indices_unique {arr : List Int} {n : Int} :\n  let indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.Nodup indices := by\nsorry\n\ntheorem pairwise_empty_zero {n : Int} :\n  pairwise [] n = 0 := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_003975", "vc-description": "-- Helper function to check if a number's digits are all odd\n\n-- Helper function to check if a number is a perfect cube", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def odd_dig_cubic (a b : Int) : List Int :=\n  sorry\n\ndef hasAllOddDigits (n : Int) : Bool :=\n  sorry\n\ndef isPerfectCube (n : Int) : Bool :=\n  sorry", "vc-theorems": "theorem odd_dig_cubic_sorted (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ i, i + 1 < result.length → result[i]! ≤ result[i+1]! :=\nsorry\n\ntheorem odd_dig_cubic_all_cubes (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, isPerfectCube n :=\nsorry\n\ntheorem odd_dig_cubic_all_odd_digits (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, hasAllOddDigits n :=\nsorry\n\ntheorem odd_dig_cubic_in_range (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, min a b ≤ n ∧ n ≤ max a b :=\nsorry\n\ntheorem odd_dig_cubic_zero : odd_dig_cubic 0 0 = [] :=\nsorry\n\ntheorem odd_dig_cubic_one : odd_dig_cubic 1 1 = [1] :=\nsorry\n\ntheorem odd_dig_cubic_neg_one : odd_dig_cubic (-1) (-1) = [-1] :=\nsorry\n\ntheorem odd_dig_cubic_single_point (n : Int) :\n  let result := odd_dig_cubic n n\n  result ≠ [] → result.length = 1 ∧ result[0]! = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [-3375, -1331, -1, 1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 5000\n\n/-\ninfo: [1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic 0 5000\n\n/-\ninfo: [-3375, -1331]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 -2"}
{"id": "fvapps_003979", "vc-description": "/- Desimplifying a simplified number returns the original number -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- A simplified expression contains at most one sqrt -/\n\n/- A simplified expression with no sqrt is a single number -/\n\n/- A simplified expression with sqrt is in format \"a sqrt b\" or \"sqrt b\" -/\n\n/- Desimplifying returns a positive integer -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simplify (n : Nat) : String :=\nsorry\n\ndef desimplify (s : String) : Nat :=\nsorry\n\ndef containsSqrt (s : String) : Bool :=\nsorry\n\ndef countSqrt (s : String) : Nat :=\nsorry\n\ndef isNumeric (s : String) : Bool :=\nsorry\n\ndef splitByWhitespace (s : String) : List String :=\nsorry", "vc-theorems": "theorem simplify_desimplify_roundtrip (n : Nat) (h : n > 0) :\n  desimplify (simplify n) = n :=\nsorry\n\ntheorem simplify_sqrt_count (n : Nat) (h : n > 0) :\n  countSqrt (simplify n) ≤ 1 :=\nsorry\n\ntheorem simplify_no_sqrt (n : Nat) (h : n > 0) :\n  ¬containsSqrt (simplify n) → isNumeric (simplify n).trim :=\nsorry\n\ntheorem simplify_with_sqrt (n : Nat) (h : n > 0) :\n  let s := simplify n\n  let parts := splitByWhitespace s\n  containsSqrt s →\n    (parts.length = 2 ∧ parts.get! 0 = \"sqrt\" ∧ isNumeric (parts.get! 1)) ∨\n    (parts.length = 3 ∧ isNumeric (parts.get! 0) ∧ parts.get! 1 = \"sqrt\" ∧ isNumeric (parts.get! 2)) :=\nsorry\n\ntheorem desimplify_range (n : Nat) (h : n > 0) :\n  desimplify (simplify n) > 0 :=\nsorry", "vc-postamble": "/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval simplify 1\n\n/-\ninfo: '2 sqrt 2'\n-/\n#guard_msgs in\n#eval simplify 8\n\n/-\ninfo: '2 sqrt 5'\n-/\n#guard_msgs in\n#eval simplify 20\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval desimplify \"1\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 2\"\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 5\""}
{"id": "fvapps_003982", "vc-description": "", "vc-preamble": "def list_range_int (n : Nat) : List Int :=\n  (List.range n).map Int.ofNat", "vc-helpers": "", "vc-definitions": "def find_missing (seq : List Int) : Int :=\n  sorry\n\ndef is_arithmetic_seq (seq : List Int) : Bool :=\nsorry", "vc-theorems": "theorem find_missing_complete_sequence\n  (start step : Int)\n  (length : Nat)\n  (h1 : length ≥ 3)\n  (h2 : length ≤ 10)\n  (h3 : -100 ≤ start)\n  (h4 : start ≤ 100)\n  (h5 : 1 ≤ step)\n  (h6 : step ≤ 20) :\n  let full_seq := (list_range_int length).map (fun i => start + i * step)\n  let i := length / 2\n  let seq_with_missing := (full_seq.take i) ++ (full_seq.drop (i+1))\n  find_missing seq_with_missing = (full_seq.get! i) :=\nsorry\n\ntheorem find_missing_existing_arithmetic\n  {seq : List Int}\n  (h1 : seq.length ≥ 3)\n  (h2 : seq.length ≤ 20)\n  (h3 : is_arithmetic_seq seq = true) :\n  let diff := seq.get! 1 - seq.get! 0\n  ∃ i, i < seq.length - 1 ∧\n       seq.get! (i+1) - seq.get! i ≠ diff →\n       find_missing seq = seq.get! i + diff :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_missing [1, 2, 3, 4, 6, 7, 8, 9]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 5, 9, 11]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 4]"}
{"id": "fvapps_004001", "vc-description": "", "vc-preamble": "def isValidTriangle (a b c : Float) : Prop :=\n  (a + b > c) ∧ (b + c > a) ∧ (a + c > b)\n\ndef calculateArea (a b c : Float) : Float :=\n  let s := (a + b + c) / 2\n  Float.sqrt (s * (s - a) * (s - b) * (s - c))", "vc-helpers": "", "vc-definitions": "def equableTriangle (a b c : Float) : Bool :=\n  sorry\n\ndef isClose (x y : Float) (tol : Float) : Bool :=\n  sorry", "vc-theorems": "theorem equable_triangle_isosceles {x : Float} (h : x > 0)\n  (hvalid : isValidTriangle x x x) :\n  equableTriangle x x x = isClose (calculateArea x x x) (3 * x) 0.0001 := by\n  sorry\n\ntheorem equable_triangle_general {a b c : Float} (ha : a > 0) (hb : b > 0) (hc : c > 0)\n  (hvalid : isValidTriangle a b c) :\n  equableTriangle a b c = isClose (calculateArea a b c) (a + b + c) 0.0001 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 5 12 13\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval equable_triangle 2 3 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 6 25 29"}
{"id": "fvapps_004007", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_smallest (list : List Int) : List Int :=\n  sorry\n\ndef minimum (list : List Int) : Option Int :=\n  sorry\n\ndef list_eq (l1 l2 : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem remove_smallest_length (list : List Int) :\n  list = [] → remove_smallest list = [] ∧\n  list ≠ [] → List.length (remove_smallest list) = List.length list - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2, 3, 4, 5]\n-/\n#guard_msgs in\n#eval remove_smallest [1, 2, 3, 4, 5]\n\n/-\ninfo: [2, 2, 2, 1]\n-/\n#guard_msgs in\n#eval remove_smallest [2, 2, 1, 2, 1]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval remove_smallest []"}
{"id": "fvapps_004008", "vc-description": "-- Sum of complex numbers is equal to sum of separate numbers\n\n-- Sum of pure imaginary numbers has no real part\n\n-- Empty list sums to zero\n\n-- List of zeros sums to zero", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def complex_sum (arr : List String) : String :=\nsorry\n\ndef complex_str (real imag : Int) : String :=\nsorry\n\ndef real_part (s : String) : Int :=\nsorry\n\ndef imag_part (s : String) : Int :=\nsorry\n\ndef list_sum (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem complex_sum_equals_separate_sums {arr : List String} :\n  ∀ (real_sum imag_sum : Int),\n  complex_sum arr = complex_str real_sum imag_sum →\n  real_sum = list_sum (arr.map real_part) ∧\n  imag_sum = list_sum (arr.map imag_part) :=\nsorry\n\ntheorem pure_imaginary_sum {arr : List String} :\n  arr.all (λ s => s = \"i\") →\n  complex_sum arr = complex_str 0 arr.length :=\nsorry\n\ntheorem empty_list_sums_to_zero :\n  complex_sum [] = \"0\" :=\nsorry\n\ntheorem zeros_sum_to_zero {arr : List String} :\n  arr.all (λ s => s = \"0\") →\n  complex_sum arr = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5+2i'\n-/\n#guard_msgs in\n#eval complex_sum [\"2+3i\", \"3-i\"]\n\n/-\ninfo: '6i'\n-/\n#guard_msgs in\n#eval complex_sum [\"i\", \"2i\", \"3i\"]\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval complex_sum []"}
{"id": "fvapps_004010", "vc-description": "", "vc-preamble": "def sum_list_nat : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + sum_list_nat xs", "vc-helpers": "", "vc-definitions": "def bits_war (numbers : List Int) : String :=\nsorry\n\ndef bitsToCount (n : Int) : Nat :=\nsorry", "vc-theorems": "theorem bits_war_returns_valid_result (numbers : List Int) (h : numbers.length > 0) :\n  (bits_war numbers = \"odds win\") ∨\n  (bits_war numbers = \"evens win\") ∨\n  (bits_war numbers = \"tie\") :=\nsorry\n\ntheorem bits_war_all_zeros (numbers : List Int) :\n  (∀ n ∈ numbers, n = 0) →\n  bits_war numbers = \"tie\" :=\nsorry\n\ntheorem bits_war_all_positive (numbers : List Int) (h : numbers.length > 0) :\n  (∀ n ∈ numbers, n ≥ 0) →\n  let odd_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 1)).map bitsToCount)\n  let even_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 0)).map bitsToCount)\n  bits_war numbers = if odd_bits > even_bits then \"odds win\"\n                     else if even_bits > odd_bits then \"evens win\"\n                     else \"tie\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'odds win'\n-/\n#guard_msgs in\n#eval bits_war [1, 5, 12]\n\n/-\ninfo: 'evens win'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, 20]\n\n/-\ninfo: 'tie'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, -2, 6]"}
{"id": "fvapps_004011", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\n  sorry\n\ndef reverse_letter (s : String) : String :=\n  sorry", "vc-theorems": "theorem reverse_letter_only_letters (s : String) :\n  ∀ (c : Char), c ∈ (reverse_letter s).data → isAlpha c := by\n  sorry\n\ntheorem reverse_letter_length (s : String) :\n  (reverse_letter s).length = (s.toList.filter isAlpha).length := by\n  sorry\n\ntheorem reverse_letter_idempotent (s : String) :\n  reverse_letter (reverse_letter s) = String.mk (s.toList.filter isAlpha) := by\n  sorry\n\ntheorem reverse_letter_preserves_case (s : String) :\n  ∃ (perm : List Char → List Char),\n    (reverse_letter s).data.map Char.toLower =\n    (String.mk (s.toList.filter isAlpha)).data.map Char.toLower := by\n  sorry\n\ntheorem reverse_letter_empty_no_letters (s : String) :\n  (∀ c ∈ s.data, ¬isAlpha c) →\n  reverse_letter s = \"\" := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_004013", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef goldbach (n : Nat) : List (List Nat) :=\n  sorry", "vc-theorems": "theorem goldbach_valid_sums {n : Nat} (h : n ≥ 4) (h2 : n % 2 = 0) :\n  let result := goldbach n\n  (∀ x ∈ result, x.length = 2) ∧\n  (∀ x ∈ result, x[0]! + x[1]! = n) ∧\n  (∀ x ∈ result, x[0]! ≤ x[1]!) :=\nsorry\n\ntheorem goldbach_small_inputs {n : Nat} (h : n ≤ 3) :\n  goldbach n = [] :=\nsorry\n\ntheorem goldbach_four :\n  goldbach 4 = [[2, 2]] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [[3, 7], [5, 5]]\n-/\n#guard_msgs in\n#eval goldbach 10\n\n/-\ninfo: [[5, 47], [11, 41], [23, 29]]\n-/\n#guard_msgs in\n#eval goldbach 52\n\n/-\ninfo: [[5, 53], [11, 47], [17, 41], [29, 29]]\n-/\n#guard_msgs in\n#eval goldbach 58"}
{"id": "fvapps_004017", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (f: Nat → Nat) (n: Nat) : Nat :=\n  sorry\n\ndef squares_needed (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem squares_needed_zero :\n  squares_needed 0 = 0 :=\nsorry\n\ntheorem squares_needed_one :\n  squares_needed 1 = 1 :=\nsorry\n\ntheorem squares_needed_power_two :\n  squares_needed (2^10) = 11 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval squares_needed 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval squares_needed 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval squares_needed 4"}
{"id": "fvapps_004021", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_average (numbers : List Float) : Float :=\nsorry\n\ndef sum (l : List Float) : Float :=\nsorry\n\ndef minimum? (l : List Float) : Option Float :=\nsorry\n\ndef maximum? (l : List Float) : Option Float :=\nsorry\n\ndef sumInt (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem integer_list_average (numbers : List Int) :\n  find_average (numbers.map Float.ofInt) =\n    match numbers with\n    | [] => 0\n    | _  => Float.ofInt (sumInt numbers) / Float.ofInt numbers.length :=\nsorry\n\ntheorem empty_list_average :\n  find_average [] = 0 :=\nsorry\n\ntheorem average_between_min_max (numbers : List Float) (h : numbers ≠ []) :\n  match minimum? numbers, maximum? numbers with\n  | some min, some max => min ≤ find_average numbers ∧ find_average numbers ≤ max\n  | _, _ => True :=\nsorry\n\ntheorem average_times_length_equals_sum (numbers : List Float) :\n  match numbers with\n  | [] => find_average numbers = 0\n  | _  => find_average numbers * (Float.ofNat numbers.length) = sum numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_average [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_average [1.5, 2.5, 3.5]"}
{"id": "fvapps_004022", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome : (n : Int) → String ⊕ Bool :=\nsorry\n\ndef countOddDigits (n : Int) : Nat :=\nsorry", "vc-theorems": "theorem negative_numbers {n : Int} (h : n < 0) : palindrome n = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem different_digits_odd_count {n : Int} (h1 : n ≥ 100) (h2 : n ≤ 9999)\n  (h3 : countOddDigits n > 1) : palindrome n = Sum.inr false :=\nsorry\n\ntheorem non_integers_text (s : String) : palindrome 0 = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem non_integers_dec (d : Float) : palindrome 0 = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem single_digits {n : Int} (h1 : n ≥ 0) (h2 : n ≤ 9) :\n  palindrome n = Sum.inr false :=\nsorry\n\ntheorem repeated_digits {n : Int} (h1 : n ≥ 1) (h2 : n ≤ 9) :\n  palindrome (n * 11) = Sum.inr true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome 5\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome 1331\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome \"ololo\""}
{"id": "fvapps_004028", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sha256_cracker (h: String) (chars: String) : Option String :=\n  sorry\n\ndef sha256 (s: String) : String :=\n  sorry", "vc-theorems": "theorem found_string_matches_hash\n  {s h chars result: String} :\n  (h = sha256 s) →\n  (chars = s.toList.toString) →\n  (sha256_cracker h chars = some result) →\n  (sha256 result = h) ∧\n  (∀ c, c ∈ result.data → c ∈ chars.data) :=\nsorry\n\ntheorem invalid_chars_return_none\n  {s h invalid_chars chars: String} :\n  (h = sha256 s) →\n  (chars = (invalid_chars.toList.filter (fun c => !s.data.contains c)).toString) →\n  (chars ≠ \"\") →\n  sha256_cracker h chars = none :=\nsorry\n\ntheorem empty_chars_returns_none\n  {s h: String} :\n  (h = sha256 s) →\n  sha256_cracker h \"\" = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'GoOutside'\n-/\n#guard_msgs in\n#eval sha256_cracker \"b8c49d81cb795985c007d78379e98613a4dfc824381be472238dbd2f974e37ae\" \"deGioOstu\"\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval sha256_cracker \"5694d08a2e53ffcae0c3103e5ad6f6076abd960eb1f8a56577040bc1028f702b\" \"cdeo\""}
{"id": "fvapps_004029", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def difference_of_squares (n : Nat) : Nat :=\n  sorry\n\ndef sum_up_to (n : Nat) : Nat :=\n  sorry\n\ndef sum_squares_up_to (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem difference_non_negative {n : Nat} :\n  difference_of_squares n ≥ 0 :=\nsorry\n\ntheorem zero_and_one_cases :\n  difference_of_squares 0 = 0 ∧ difference_of_squares 1 = 0 :=\nsorry\n\ntheorem strictly_increasing {n : Nat} (h : n ≥ 2) :\n  difference_of_squares n > difference_of_squares (n-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 170\n-/\n#guard_msgs in\n#eval difference_of_squares 5\n\n/-\ninfo: 2640\n-/\n#guard_msgs in\n#eval difference_of_squares 10\n\n/-\ninfo: 25164150\n-/\n#guard_msgs in\n#eval difference_of_squares 100"}
{"id": "fvapps_004031", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n k : Nat) : List Nat :=\nsorry\n\ndef isStrictlyIncreasing (lst : List Nat) : Bool :=\nsorry\n\ndef checkSum (n : Nat) (lst : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_large_k (n k : Nat) (h1 : n > 0) (h2 : k > n) :\n  (solve n k).length = 0 :=\nsorry\n\ntheorem solve_k_equals_one (n : Nat) (h : n > 0) :\n  let result := solve n 1\n  result.length > 0 → result = [n] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval solve 12 3\n\n/-\ninfo: [3, 6, 9]\n-/\n#guard_msgs in\n#eval solve 18 3\n\n/-\ninfo: [2, 4, 6, 12]\n-/\n#guard_msgs in\n#eval solve 24 4"}
{"id": "fvapps_004037", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef String.reverse (s : String) : String :=\nsorry\n\ndef Nat.toString (n : Nat) : String :=\nsorry", "vc-theorems": "theorem pattern_invalid_n (n : Int) (h : n ≤ 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem pattern_valid_num_lines {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  lines.length = 2 * n - 1 :=\nsorry\n\ntheorem pattern_valid_sequence {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  ∀ i, i ≤ mid →\n    ∃ c, c ∈ String.toList (lines[i]!) ∧\n    c = ((i + 1).toString.toList[0]!) :=\nsorry\n\ntheorem pattern_reverse {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  (lines.take mid).reverse = lines.drop (mid + 1) :=\nsorry\n\ntheorem pattern_symmetric {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  ∀ line ∈ lines, line = line.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 3\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 4 2\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern -5 3"}
{"id": "fvapps_004045", "vc-description": "", "vc-preamble": "def isValidCharacter (c : String) : Bool :=\n  match c with\n  | \"warrior\" | \"knight\" | \"wanderer\" | \"thief\" | \"bandit\"\n  | \"hunter\" | \"sorcerer\" | \"pyromancer\" | \"cleric\" | \"deprived\" => true\n  | _ => false\n\ndef isValidBuild (b : List Nat) : Bool :=\n  b.length = 8 && b.all (fun x => x ≥ 1 && x ≤ 99)\n\ndef baseStats (c : String) : List Nat :=\n  match c with\n  | \"warrior\" => [11, 8, 12, 13, 13, 11, 9, 9]\n  | \"knight\" => [14, 10, 10, 11, 11, 10, 9, 11]\n  | \"wanderer\" => [10, 11, 10, 10, 14, 12, 11, 8]\n  | \"thief\" => [9, 11, 9, 9, 15, 10, 12, 11]\n  | \"bandit\" => [12, 8, 14, 14, 9, 11, 8, 10]\n  | \"hunter\" => [11, 9, 11, 12, 14, 11, 9, 9]\n  | \"sorcerer\" => [8, 15, 8, 9, 11, 8, 15, 8]\n  | \"pyromancer\" => [10, 12, 11, 12, 9, 12, 10, 8]\n  | \"cleric\" => [11, 11, 9, 12, 8, 11, 8, 14]\n  | \"deprived\" => [11, 11, 11, 11, 11, 11, 11, 11]\n  | _ => []", "vc-helpers": "", "vc-definitions": "def souls (character : String) (build : List Nat) : String :=\n  sorry", "vc-theorems": "theorem souls_returns_valid_string\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    result.startsWith s!\"Starting as a {c}\" ∧\n    (\"level\" ∈ result.splitOn \" \") ∧\n    (\"will require\" ∈ result.splitOn \" \") ∧\n    result.endsWith \"souls.\" :=\nsorry\n\ntheorem souls_returns_non_negative_souls\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    let soulsNeeded := result.splitOn \"require \" |>.get! 1 |>.splitOn \" souls\" |>.get! 0 |>.toNat!\n    soulsNeeded ≥ 0 :=\nsorry\n\ntheorem zero_change_requires_zero_souls\n    {c : String}\n    (hc : isValidCharacter c = true) :\n    let result := souls c (baseStats c)\n    result.endsWith \"will require 0 souls.\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Starting as a deprived, level 6 will require 0 souls.'\n-/\n#guard_msgs in\n#eval souls \"deprived\" [11, 11, 11, 11, 11, 11, 11, 11]\n\n/-\ninfo: 'Starting as a pyromancer, level 2 will require 673 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [10, 12, 11, 12, 9, 12, 11, 8]\n\n/-\ninfo: 'Starting as a pyromancer, level 12 will require 8348 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [16, 12, 11, 12, 9, 12, 13, 10]"}
{"id": "fvapps_004050", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def StringMatches (pattern str : String) : Bool :=\nsorry\n\ndef shorten_to_date (s : String) : String :=\nsorry", "vc-theorems": "theorem shorten_to_date_property (dateString : String) :\n  (dateString.contains ',' : Bool) ∧\n  (StringMatches \"[A-Za-z]+ [A-Za-z]+ \\\\d+, \\\\d+(?:am|pm)\" dateString) →\n  let result := shorten_to_date dateString\n  ¬(result.contains ',' : Bool) ∧\n  result = (dateString.splitOn \",\").get! 0 ∧\n  result.length < dateString.length :=\nsorry\n\ntheorem shorten_to_date_requires_comma (s : String) :\n  ¬((s.contains ',' : Bool) ∧ (s.splitOn \",\").length = 2) →\n  False :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Friday May 2'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Friday May 2, 7pm\"\n\n/-\ninfo: 'Tuesday January 29'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Tuesday January 29, 10pm\"\n\n/-\ninfo: 'Wed September 1'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Wed September 1, 3am\""}
{"id": "fvapps_004051", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def do_math (input : String) : Int :=\n  sorry\n\ndef make_alpha_num (nums : List Int) (letters : List String) : String :=\n  sorry", "vc-theorems": "theorem do_math_returns_int {nums : List Int} {letters : List String}\n  (h_nums_size : nums.length ≥ 2 ∧ nums.length ≤ 10)\n  (h_letters_size : letters.length ≥ 2 ∧ letters.length ≤ 10)\n  (h_nums_bound : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 1000)\n  (h_letters_single : ∀ l ∈ letters, l.length = 1)\n  : ∃ n : Int, do_math (make_alpha_num nums letters) = n :=\nsorry\n\ntheorem letter_position_invariant {letter : String}\n  (h_letter_single : letter.length = 1) :\n  do_math (\"123\" ++ letter ++ \" 456\" ++ letter) =\n  do_math (letter ++ \"123 \" ++ letter ++ \"456\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1414\n-/\n#guard_msgs in\n#eval do_math \"24z6 1z23 y369 89z 900b\"\n\n/-\ninfo: 1299\n-/\n#guard_msgs in\n#eval do_math \"24z6 1x23 y369 89a 900b\"\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval do_math \"10a 90x 14b 78u 45a 7b 34y\""}
{"id": "fvapps_004053", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solution (x : Float) : Float :=\nsorry\n\ndef floor (x : Float) : Float :=\nsorry\n\ndef ceil (x : Float) : Float :=\nsorry", "vc-theorems": "theorem solution_output_options (x : Float) :\n  let floorX := floor x\n  solution x = floorX ∨ solution x = floorX + 0.5 ∨ solution x = ceil x\n  :=\nsorry\n\ntheorem solution_within_half (x : Float) :\n  (solution x - x) ≤ 0.5 ∧ (x - solution x) ≤ 0.5\n  :=\nsorry\n\ntheorem solution_cases (x : Float) :\n  let floorX := floor x\n  (x - floorX < 0.25 → solution x = floorX) ∧\n  (x - floorX < 0.75 ∧ x - floorX ≥ 0.25 → solution x = floorX + 0.5) ∧\n  (x - floorX ≥ 0.75 → solution x = ceil x)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solution 4.2\n\n/-\ninfo: 4.5\n-/\n#guard_msgs in\n#eval solution 4.6\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solution 4.75"}
{"id": "fvapps_004064", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getParticipants (h : Nat) : Nat :=\n  sorry\n\ndef choose (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem handshakes_bounds (h : Nat) :\n  let n := getParticipants h\n  let possibleHandshakes := if n ≥ 2 then choose n 2 else 0\n  n ≥ 1 ∧ possibleHandshakes ≥ h :=\nsorry\n\ntheorem basic_cases :\n  getParticipants 0 = 1 ∧\n  getParticipants 1 = 2 ∧\n  getParticipants 6 = 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval get_participants 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_participants 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval get_participants 6"}
{"id": "fvapps_004067", "vc-description": "/- For any given value, the types function returns a string that should be consistent -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The types function is reflexive -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def types (x : α) : String :=\nsorry", "vc-theorems": "theorem types_matches_type_name {α : Type} (x : α) :\n  types x = types x :=\nsorry\n\ntheorem types_preserves_equality {α : Type} (x : α) :\n  types x = types x :=\nsorry", "vc-postamble": "/-\ninfo: 'int'\n-/\n#guard_msgs in\n#eval types 23\n\n/-\ninfo: 'float'\n-/\n#guard_msgs in\n#eval types 2.3\n\n/-\ninfo: 'str'\n-/\n#guard_msgs in\n#eval types \"Hello\"\n\n/-\ninfo: 'bool'\n-/\n#guard_msgs in\n#eval types True"}
{"id": "fvapps_004074", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Array.getSum (arr : Array Int) (n : Nat) : Int :=\n  sorry\n\ndef Array.getMean (arr : Array Int) (x y : Int) : Float :=\n  sorry", "vc-theorems": "theorem invalid_x_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 → x ≤ 0 → Array.getMean arr x y = -1 :=\nsorry\n\ntheorem invalid_y_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 → y ≤ 0 → Array.getMean arr x y = -1 :=\nsorry\n\ntheorem indices_larger_than_array {arr : Array Int} {x y : Int} :\n  x > arr.size ∨ y > arr.size →\n  Array.getMean arr x y = -1 :=\nsorry\n\ntheorem mean_properties {arr : Array Int} {x y : Int} :\n  arr.size ≥ 2 →\n  1 < x ∧ x ≤ arr.size →\n  1 < y ∧ y ≤ arr.size →\n  let firstMean := Float.ofInt (Array.getSum arr x.toNat) / Float.ofInt x;\n  let secondMean := Float.ofInt (Array.getSum (arr.extract (arr.size - y.toNat) arr.size) y.toNat) / Float.ofInt y;\n  let expected := (firstMean + secondMean) / 2;\n  (Array.getMean arr x y - expected).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004079", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_arrangements (n : Nat) : Nat :=\nsorry\n\ndef digit_sum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem deterministic (n : Nat) :\n  sum_arrangements n = sum_arrangements n := by\nsorry\n\ntheorem multiple_of_digit_sum (n : Nat) (h : n > 0) :\n  sum_arrangements n % digit_sum n = 0 := by\nsorry\n\ntheorem single_digit (n : Nat) (h : n > 0) (h₂ : n < 10) :\n  sum_arrangements n = n := by\nsorry\n\ntheorem positive_output (n : Nat) (h : n > 0) :\n  sum_arrangements n > 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 187\n-/\n#guard_msgs in\n#eval sum_arrangements 98\n\n/-\ninfo: 1332\n-/\n#guard_msgs in\n#eval sum_arrangements 123\n\n/-\ninfo: 99990\n-/\n#guard_msgs in\n#eval sum_arrangements 1185"}
{"id": "fvapps_004090", "vc-description": "", "vc-preamble": "def inRange (x: Int) (lower: Int) (upper: Int) : Prop :=\n  lower ≤ x ∧ x < upper", "vc-helpers": "", "vc-definitions": "def chessBishopDream (boardSize: List Int) (initPos: List Int) (initDir: List Int) (k: Nat) : List Int :=\n  sorry", "vc-theorems": "theorem bishop_within_boundaries\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, inRange (result[i]!) 0 (boardSize[i]!)) :=\nsorry\n\ntheorem bishop_periodic\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1) :\n  let period := (4 * boardSize[0]! * boardSize[1]!).toNat\n  chessBishopDream boardSize initPos initDir period =\n  chessBishopDream boardSize initPos initDir 0 :=\nsorry\n\ntheorem bishop_reflection\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, result[i]! ≤ boardSize[i]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [3, 7] [1, 2] [-1, 1] 13\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [1, 2] [0, 0] [1, 1] 6\n\n/-\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [2, 2] [1, 0] [1, 1] 12"}
{"id": "fvapps_004098", "vc-description": "/- Any string matching the pattern [A-Z][0-9] repeated 5 times, followed by\n    .-[A-Z]%[0-9].[0-9][0-9]. should return true -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any string not matching the pattern should return false -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def body_count (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_code_returns_true {code : String}\n  (h : ∃ (a₁ a₂ a₃ a₄ a₅ : Char) (n₁ n₂ n₃ n₄ n₅ : Nat) (last_letter : Char)\n        (last_num dec₁ dec₂ : Nat),\n    'A' ≤ a₁ ∧ a₁ ≤ 'Z' ∧\n    'A' ≤ a₂ ∧ a₂ ≤ 'Z' ∧\n    'A' ≤ a₃ ∧ a₃ ≤ 'Z' ∧\n    'A' ≤ a₄ ∧ a₄ ≤ 'Z' ∧\n    'A' ≤ a₅ ∧ a₅ ≤ 'Z' ∧\n    'A' ≤ last_letter ∧ last_letter ≤ 'Z' ∧\n    n₁ ≤ 9 ∧ n₂ ≤ 9 ∧ n₃ ≤ 9 ∧ n₄ ≤ 9 ∧ n₅ ≤ 9 ∧\n    last_num ≤ 9 ∧\n    dec₁ ≤ 9 ∧ dec₂ ≤ 9 ∧\n    code = String.mk [a₁, Char.ofNat (n₁ + 48),\n                     a₂, Char.ofNat (n₂ + 48),\n                     a₃, Char.ofNat (n₃ + 48),\n                     a₄, Char.ofNat (n₄ + 48),\n                     a₅, Char.ofNat (n₅ + 48),\n                     '.', '-', last_letter, '%',\n                     Char.ofNat (last_num + 48), '.',\n                     Char.ofNat (dec₁ + 48), Char.ofNat (dec₂ + 48), '.']) :\n  body_count code = true :=\nsorry\n\ntheorem invalid_code_returns_false {s : String}\n  (h : ¬∃ (a₁ a₂ a₃ a₄ a₅ : Char) (n₁ n₂ n₃ n₄ n₅ : Nat) (last_letter : Char)\n        (last_num dec₁ dec₂ : Nat),\n    'A' ≤ a₁ ∧ a₁ ≤ 'Z' ∧\n    'A' ≤ a₂ ∧ a₂ ≤ 'Z' ∧\n    'A' ≤ a₃ ∧ a₃ ≤ 'Z' ∧\n    'A' ≤ a₄ ∧ a₄ ≤ 'Z' ∧\n    'A' ≤ a₅ ∧ a₅ ≤ 'Z' ∧\n    'A' ≤ last_letter ∧ last_letter ≤ 'Z' ∧\n    n₁ ≤ 9 ∧ n₂ ≤ 9 ∧ n₃ ≤ 9 ∧ n₄ ≤ 9 ∧ n₅ ≤ 9 ∧\n    last_num ≤ 9 ∧\n    dec₁ ≤ 9 ∧ dec₂ ≤ 9 ∧\n    s = String.mk [a₁, Char.ofNat (n₁ + 48),\n                  a₂, Char.ofNat (n₂ + 48),\n                  a₃, Char.ofNat (n₃ + 48),\n                  a₄, Char.ofNat (n₄ + 48),\n                  a₅, Char.ofNat (n₅ + 48),\n                  '.', '-', last_letter, '%',\n                  Char.ofNat (last_num + 48), '.',\n                  Char.ofNat (dec₁ + 48), Char.ofNat (dec₂ + 48), '.']) :\n  body_count s = false :=\nsorry", "vc-postamble": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"A6C2E5Z9A4.-F%8.08.\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"PP P6A6T5F5S3.-Z%1.11.hgr\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval body_count \"b4A1D1I8B4.-E%8.76.\""}
{"id": "fvapps_004107", "vc-description": "", "vc-preamble": "def abs (n : Nat) : Nat :=\n  n", "vc-helpers": "", "vc-definitions": "def langtons_ant (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem langtons_ant_non_negative (n : Nat) :\n  langtons_ant n ≥ 0 :=\nsorry\n\ntheorem langtons_ant_first_moves (n : Nat) :\n  (n = 0 → langtons_ant n = 0) ∧\n  (n = 1 → langtons_ant n = 1) ∧\n  (n ≥ 2 → langtons_ant n ≤ n) :=\nsorry\n\ntheorem langtons_ant_periodic (n1 n2 : Nat) :\n  n1 ≥ 9977 → n2 ≥ 9977 →\n  (n1 - n2) % 104 = 0 →\n  (if langtons_ant n1 ≥ langtons_ant n2\n   then langtons_ant n1 - langtons_ant n2\n   else langtons_ant n2 - langtons_ant n1) =\n    12 * (if (n1 - 9977) / 104 ≥ (n2 - 9977) / 104\n          then (n1 - 9977) / 104 - (n2 - 9977) / 104\n          else (n2 - 9977) / 104 - (n1 - 9977) / 104) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval langtons_ant 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval langtons_ant 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval langtons_ant 2\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval langtons_ant 10\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval langtons_ant 100"}
{"id": "fvapps_004108", "vc-description": "", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def sort_number (l : List Int) : List Int :=\nsorry", "vc-theorems": "theorem sort_number_length {l : List Int} (h : l ≠ []) :\n  (sort_number l).length = l.length :=\nsorry\n\ntheorem sort_number_first {l : List Int} (h : l ≠ []) :\n  (sort_number l).head! = 1 :=\nsorry\n\ntheorem sort_number_deterministic {l : List Int} (h : l ≠ []) :\n  sort_number l = sort_number l :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval sort_number [1, 2, 3, 4, 5]\n\n/-\ninfo: [1, 2, 2]\n-/\n#guard_msgs in\n#eval sort_number [2, 2, 2]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval sort_number [42]"}
{"id": "fvapps_004110", "vc-description": "-- Result is subset of input\n\n-- Each result same length as input\n\n-- Each result has same letters\n\n-- Contains all valid anagrams", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def anagrams (word : String) (words : List String) : List String :=\nsorry\n\ndef sameLetters (word1 word2 : String) : Bool :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem anagram_properties (word : String) (words : List String) :\n  let result := anagrams word words\n\n  (∀ w ∈ result, w ∈ words) ∧\n\n  (∀ w ∈ result, String.length w = String.length word) ∧\n\n  (∀ w ∈ result, sameLetters w word) ∧\n\n  (∀ w ∈ words, sameLetters w word → w ∈ result) :=\nsorry\n\ntheorem empty_list (word : String) :\n  anagrams word [] = [] :=\nsorry\n\ntheorem same_word (word : String) :\n  anagrams word [word] = [word] :=\nsorry\n\ntheorem reversed_word (word : String) :\n  let reversed := reverseString word\n  anagrams word [reversed] = [reversed] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['aabb', 'bbaa']\n-/\n#guard_msgs in\n#eval anagrams \"abba\" [\"aabb\", \"abcd\", \"bbaa\", \"dada\"]\n\n/-\ninfo: ['carer', 'racer']\n-/\n#guard_msgs in\n#eval anagrams \"racer\" [\"crazer\", \"carer\", \"racar\", \"caers\", \"racer\"]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval anagrams \"laser\" [\"lazing\", \"lazy\", \"lacer\"]"}
{"id": "fvapps_004111", "vc-description": "", "vc-preamble": "def list_sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def mem_alloc (banks : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem mem_alloc_positive (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks > 0 :=\nsorry\n\ntheorem mem_alloc_preserves_input (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :=\nsorry\n\ntheorem mem_alloc_deterministic (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 70\n-/\n#guard_msgs in\n#eval mem_alloc [5, 1, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 600]\n\n/-\ninfo: 316\n-/\n#guard_msgs in\n#eval mem_alloc [53, 21, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 60]\n\n/-\ninfo: 826\n-/\n#guard_msgs in\n#eval mem_alloc [14, 21, 10, 0, 1, 7, 0, 14, 3, 12, 8, 10, 17, 12, 0, 19]"}
{"id": "fvapps_004115", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortest_time (speeds: List Int) : Int :=\n  sorry\n\ndef List.sorted (l: List Int) : List Int :=\n  sorry\n\ndef isPermutation (l1 l2: List Int) : Bool :=\n  sorry", "vc-theorems": "theorem shortest_time_positive (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  shortest_time speeds > 0 :=\nsorry\n\ntheorem shortest_time_min_bound (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds ≥ sorted[0]! + sorted[1]! + sorted[3]! :=\nsorry\n\ntheorem shortest_time_two_crossings (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds ≥ 2 * (sorted[0]! + sorted[1]!) :=\nsorry\n\ntheorem shortest_time_order_invariant (speeds1 speeds2: List Int)\n  (h1: speeds1.length = 4)\n  (h2: speeds2.length = 4)\n  (h3: ∀ x ∈ speeds1, x ≥ 1)\n  (h4: ∀ x ∈ speeds2, x ≥ 1)\n  (h5: isPermutation speeds1 speeds2) :\n  shortest_time speeds1 = shortest_time speeds2 :=\nsorry\n\ntheorem shortest_time_monotonic (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1)\n  (i: Nat)\n  (h3: i < speeds.length) :\n  let increased := speeds.set i (speeds[i]! + 1)\n  shortest_time increased ≥ shortest_time speeds :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval shortest_time [3, 4, 5, 6]\n\n/-\ninfo: 41\n-/\n#guard_msgs in\n#eval shortest_time [3, 7, 10, 18]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval shortest_time [5, 5, 6, 7]"}
{"id": "fvapps_004121", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hidden (n : Nat) : String :=\nsorry\n\ndef hidden_withInt (n : Int) : String :=\nsorry", "vc-theorems": "theorem hidden_length_matches_input {n : Nat} :\n  (toString n).length = (hidden n).length :=\nsorry\n\ntheorem hidden_rejects_negative (n : Int) :\n  n < 0 → hidden_withInt n = \"\" :=\nsorry\n\ntheorem hidden_valid_chars {n : Nat} {c : Char} :\n  c ∈ (hidden n).data → c ∈ ['o', 'b', 'l', 'i', 'e', 'a', 't', 'd', 'n', 'm'] :=\nsorry\n\ntheorem hidden_consistent_mapping {n₁ n₂ : Nat} {i : Nat} {pos1 : String.Pos} {pos2 : String.Pos} :\n  i < min (toString n₁).length (toString n₂).length →\n  (toString n₁).get pos1 = (toString n₂).get pos2 →\n  (hidden n₁).get pos1 = (hidden n₂).get pos2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'aid'\n-/\n#guard_msgs in\n#eval hidden 637\n\n/-\ninfo: 'dean'\n-/\n#guard_msgs in\n#eval hidden 7468\n\n/-\ninfo: 'email'\n-/\n#guard_msgs in\n#eval hidden 49632"}
{"id": "fvapps_004142", "vc-description": "/- Helper function to emulate sign behavior -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_negative_zero (x : Float) : Bool :=\nsorry\n\ndef getSign (x : Float) : Float :=\nsorry\n\ndef posInf : Float :=\nsorry\n\ndef negInf : Float :=\nsorry\n\ndef nanFloat : Float :=\nsorry", "vc-theorems": "theorem is_negative_zero_main (x : Float) :\n  is_negative_zero x = true ↔ (getSign x < 0 ∧ x = 0) :=\nsorry\n\ntheorem is_negative_zero_special_cases :\n  is_negative_zero posInf = false ∧\n  is_negative_zero negInf = false ∧\n  is_negative_zero nanFloat = false :=\nsorry\n\ntheorem is_negative_zero_integers (n : Int) :\n  is_negative_zero (Float.ofInt n) = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Constants for special float values -/\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_negative_zero -0.0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero 0.0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero -5.0"}
{"id": "fvapps_004143", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def indices (n d : Nat) : List (List (List Nat)) :=\nsorry\n\ndef sumIndices (idx : List (List Nat)) : Nat :=\nsorry\n\ndef starsAndBars (n k : Nat) : Nat :=\nsorry", "vc-theorems": "theorem indices_valid (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :\n  ∀ idx, idx ∈ indices n d →\n    idx.length = 1 ∧\n    idx.head!.length = n ∧\n    (∀ x, x ∈ idx.head! → x ≤ d) ∧\n    sumIndices idx = d :=\nsorry\n\ntheorem indices_unique (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :\n  ∀ i j, i ∈ indices n d → j ∈ indices n d → i ≠ j → i.head! ≠ j.head! :=\nsorry\n\ntheorem indices_zero (n : Nat) (h1: 0 < n) (h2: n ≤ 10) :\n  indices n 0 = [List.replicate 1 (List.replicate n 0)] :=\nsorry\n\ntheorem indices_singleton (d : Nat) (h: d ≤ 10) :\n  indices 1 d = [[[d]]] :=\nsorry\n\ntheorem indices_count (n d : Nat) (h1: 0 < n) (h2: n ≤ 5) (h3: d ≤ 5) :\n  (indices n d).length = starsAndBars n d :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len indices(3, 2)\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval len idx[0]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sum idx[0]"}
{"id": "fvapps_004152", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_unfairness (arr : List Int) (k : Nat) : Int :=\n  sorry\n\ndef listMax (xs : List Int) : Int :=\n  sorry\n\ndef listMin (xs : List Int) : Int :=\n  sorry\n\ndef sortList (xs : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem min_unfairness_non_negative {arr : List Int} {k : Nat}\n  (h : arr.length > 0) (h2 : k > 0) (h3 : k ≤ arr.length) :\n  min_unfairness arr k ≥ 0 :=\nsorry\n\ntheorem min_unfairness_k_one {arr : List Int}\n  (h : arr.length > 0) :\n  min_unfairness arr 1 = 0 :=\nsorry\n\ntheorem min_unfairness_max_difference {arr : List Int} {k : Nat}\n  (h1 : arr.length > 1) (h2 : k > 0) (h3 : k ≤ arr.length) :\n  min_unfairness arr k ≤ listMax arr - listMin arr :=\nsorry\n\ntheorem min_unfairness_sort_invariant {arr : List Int} {k : Nat}\n  (h1 : k > 1) (h2 : arr.length ≥ k) :\n  min_unfairness arr k = min_unfairness (sortList arr) k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval min_unfairness [30, 100, 1000, 150, 60, 250, 10, 120, 20] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_unfairness [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2] 10\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_unfairness [] 0"}
{"id": "fvapps_004153", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def NUMBER_WORDS : List String := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef uncollapse (s : String) : String :=\n  sorry\n\ndef isSubstring (pattern : String) (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem uncollapse_random_combinations (numbers : List String)\n  (h : numbers ≠ [] ∧ ∀ n ∈ numbers, n ∈ NUMBER_WORDS) :\n  uncollapse (String.join numbers) = String.join (List.intersperse \" \" numbers) :=\nsorry\n\ntheorem uncollapse_preserves_order (numbers : List String)\n  (h : numbers.length ≥ 2 ∧ ∀ n ∈ numbers, n ∈ NUMBER_WORDS) :\n  (uncollapse (String.join numbers)).split (. == ' ') = numbers :=\nsorry\n\ntheorem uncollapse_single_number (num : String)\n  (h : num ∈ NUMBER_WORDS) :\n  uncollapse num = num :=\nsorry\n\ntheorem uncollapse_invalid_input (s : String)\n  (h : ∀ word ∈ NUMBER_WORDS, isSubstring word s = false) :\n  uncollapse s = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'three'\n-/\n#guard_msgs in\n#eval uncollapse \"three\"\n\n/-\ninfo: 'eight six'\n-/\n#guard_msgs in\n#eval uncollapse \"eightsix\"\n\n/-\ninfo: 'five four seven'\n-/\n#guard_msgs in\n#eval uncollapse \"fivefourseven\""}
{"id": "fvapps_004157", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_in_middle (s : String) : Bool :=\nsorry\n\ndef containsSubstring (s₁ s₂ : String) : Bool :=\nsorry", "vc-theorems": "theorem empty_or_short_string (s : String) :\n  s.length ≤ 3 → is_in_middle s = false :=\nsorry\n\ntheorem without_abc (s : String) :\n  containsSubstring s \"abc\" = false → is_in_middle s = false :=\nsorry\n\ntheorem equal_padding (n : Nat) :\n  let s := String.mk (List.replicate n 'A') ++ \"abc\" ++ String.mk (List.replicate n 'A')\n  is_in_middle s = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_in_middle \"AAabcBB\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"AabcBBB\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"\""}
{"id": "fvapps_004165", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_higher (n : Nat) : Nat :=\n  sorry\n\ndef countOnes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem next_higher_preserves_bit_count (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  countOnes n = countOnes (next_higher n) :=\nsorry\n\ntheorem next_higher_is_higher (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  next_higher n > n :=\nsorry\n\ntheorem next_higher_power_two (i : Nat) (h : i < 8) :\n  next_higher (2^i) = 2^(i+1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 256\n-/\n#guard_msgs in\n#eval next_higher 128\n\n/-\ninfo: 191\n-/\n#guard_msgs in\n#eval next_higher 127\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval next_higher 1"}
{"id": "fvapps_004170", "vc-description": "", "vc-preamble": "def sumList (l : List Nat) : Nat :=\n  l.foldl (·+·) 0", "vc-helpers": "", "vc-definitions": "def minimum_steps (arr : List Nat) (n : Nat) : Option Nat :=\n  sorry\n\ndef List.sort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem minimum_steps_nonnegative (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result → result ≥ 0 :=\nsorry\n\ntheorem minimum_steps_less_than_length (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result → result < arr.length :=\nsorry\n\ntheorem minimum_steps_sum_sufficient (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result →\n  sumList (List.take (result + 1) (arr.sort)) ≥ n :=\nsorry\n\ntheorem minimum_steps_sum_necessary (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result →\n  result > 0 → sumList (List.take result (arr.sort)) < n :=\nsorry\n\ntheorem minimum_steps_sort_invariant (arr : List Nat) (n : Nat) :\n  minimum_steps (arr.sort) n = minimum_steps arr n :=\nsorry\n\ntheorem minimum_steps_single_element_target_le (x : Nat) (n : Nat) :\n  n ≤ x → minimum_steps [x] n = some 0 :=\nsorry\n\ntheorem minimum_steps_first_element_sufficient (x y z : Nat) :\n  minimum_steps [x, y, z] y = some 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [4, 6, 3] 7\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [10, 9, 9, 8] 17\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval minimum_steps [8, 9, 10, 4, 2] 23"}
{"id": "fvapps_004172", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\n  sorry\n\ndef eraseDuplicates (xs : List α) : List α :=\n  sorry\n\ndef sortList (xs : List α) : List α :=\n  sorry", "vc-theorems": "theorem solve_valid_string_properties (s : String) :\n  solve s →\n  (s.length : Nat) = (eraseDuplicates s.toList).length ∧\n  sortList (s.toList.map Char.toLower) = s.toList := by\n  sorry\n\ntheorem solve_invalid_chars (s : String) :\n  s.toList.all (λ c => ¬c.isLower) →\n  ¬(solve s) := by\n  sorry\n\ntheorem solve_duplicates (s : String) :\n  s.length > 0 →\n  ¬(solve (s ++ s)) := by\n  sorry\n\ntheorem solve_empty :\n  ¬(solve \"\") := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abc\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"dabc\""}
{"id": "fvapps_004175", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (α : Type) [ToString α] (x : α) : Bool :=\n  sorry\n\ndef reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem string_palindrome_property (s : String) :\n  is_palindrome String s = (s = reverse s) :=\nsorry\n\ntheorem integer_palindrome_property (n : Int) :\n  is_palindrome Int n = (toString n = reverse (toString n)) :=\nsorry\n\ntheorem palindrome_type_invariant (s : String) :\n  is_palindrome String s = is_palindrome String (toString s) :=\nsorry\n\ntheorem empty_string_is_palindrome :\n  is_palindrome String \"\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"anna\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"walter\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome 12321"}
{"id": "fvapps_004182", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isOdd (n : Nat) : Bool :=\n  sorry\n\ndef split_odd_and_even (n : Nat) : List Nat :=\n  sorry\n\ndef charToNat (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem split_returns_list (n : Nat) (h : n > 0) :\n  ∃ (l : List Nat), split_odd_and_even n = l\n  := by\nsorry\n\ntheorem digits_have_same_parity (n : Nat) (h : n > 0) :\n  ∀ x, x ∈ split_odd_and_even n →\n    let digits := (toString x).data\n    ∀ d, d ∈ digits →\n      ∀ h : 0 < digits.length,\n        isOdd (charToNat d) = isOdd (charToNat (digits[0]'h))\n  := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_004186", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef end_one (n : Nat) : Bool :=\n  sorry\n\ndef solve (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem is_prime_not_small (n : Nat) :\n  n ≤ 1 → is_prime n = false :=\nsorry\n\ntheorem is_prime_no_factors (n : Nat) :\n  is_prime n = true →\n  ∀ i : Nat, 2 ≤ i → i ≤ n^(1/2) → n % i ≠ 0 :=\nsorry\n\ntheorem prime_multiplication (n : Nat) :\n  2 < n → is_prime (2*n) = false :=\nsorry\n\ntheorem end_one_is_bool (n : Nat) :\n  end_one n = true ∨ end_one n = false :=\nsorry\n\ntheorem end_one_for_one :\n  end_one 1 = true :=\nsorry\n\ntheorem end_one_special_cases (n : Nat) :\n  (n = 1 ∨ n = 10) → end_one n = true :=\nsorry\n\ntheorem solve_bounded (a b : Nat) :\n  a ≤ b →\n  0 ≤ solve a b ∧ solve a b ≤ b - a :=\nsorry\n\ntheorem solve_wrong_order (a b : Nat) :\n  b < a → solve a b = 0 :=\nsorry\n\ntheorem solve_unit_range (n : Nat) :\n  solve n (n+1) = 0 ∨ solve n (n+1) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 1 25\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval solve 100 1000\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval solve 100 2000"}
{"id": "fvapps_004190", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (h : String) (m : String) (s : String) : String :=\nsorry\n\ndef isDigit (s : String) : Bool :=\nsorry\n\ndef toSeconds (s : String) : Option Nat :=\nsorry\n\ndef fromNat (n : Nat) : String :=\nsorry\n\ndef isValidTimeFormat (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_time_conversion\n  {h : Nat} {m : Nat} {s : Nat}\n  (h_bound : h ≤ 99)\n  (m_bound : m ≤ 59)\n  (s_bound : s ≤ 59) :\n  toSeconds (toString (fromNat h) (fromNat m) (fromNat s)) = some (h * 3600 + m * 60 + s) :=\nsorry\n\ntheorem invalid_format_returns_none\n  (s : String)\n  (h_invalid : ¬(isValidTimeFormat s)) :\n  toSeconds s = none :=\nsorry\n\ntheorem invalid_hours\n  (h m s : String)\n  (h_invalid : h.toNat? = some (Nat.succ 99)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem invalid_minutes\n  (h m s : String)\n  (m_invalid : m.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem invalid_seconds\n  (h m s : String)\n  (s_invalid : s.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem missing_components_none\n  (s : String)\n  (h_missing : ¬(isValidTimeFormat s)) :\n  toSeconds s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval to_seconds \"00:00:00\"\n\n/-\ninfo: 3723\n-/\n#guard_msgs in\n#eval to_seconds \"01:02:03\"\n\n/-\ninfo: 359999\n-/\n#guard_msgs in\n#eval to_seconds \"99:59:59\""}
{"id": "fvapps_004191", "vc-description": "", "vc-preamble": "def isSameChars (s₁ s₂ : String) : Prop :=\n  ∀ c : Char, (s₁.data.countP (· = c)) = (s₂.data.countP (· = c))", "vc-helpers": "", "vc-definitions": "def jumbledString (s : String) (n : Int) : String :=\nsorry", "vc-theorems": "theorem jumbledString_length_preserved (s : String) (n : Int) (h : s.length > 0) :\n  (jumbledString s n).length = s.length :=\nsorry\n\ntheorem jumbledString_same_chars (s : String) (n : Int) (h : s.length > 0) :\n  isSameChars s (jumbledString s n) :=\nsorry\n\ntheorem jumbledString_periodic (s : String) (n : Int) (h : s.length > 0) :\n  ∃ k : Nat, k > 0 ∧\n  jumbledString s n = jumbledString s (n % k) :=\nsorry\n\ntheorem jumbledString_empty_or_singleton (s : String) (n : Int) :\n  s.length ≤ 1 → jumbledString s n = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sc o!uhWw'\n-/\n#guard_msgs in\n#eval jumbled_string \"Such Wow!\" 1\n\n/-\ninfo: 'bexltept merae'\n-/\n#guard_msgs in\n#eval jumbled_string \"better example\" 2\n\n/-\ninfo: 'qtorieuwy'\n-/\n#guard_msgs in\n#eval jumbled_string \"qwertyuio\" 2"}
{"id": "fvapps_004196", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumGroups (arr : List Int) : Int :=\nsorry\n\ndef getNextArr (arr : List Int) : List Int :=\nsorry\n\ndef countAlternatingParity (arr : List Int) : Nat :=\nsorry", "vc-theorems": "theorem sum_groups_returns_positive :\n  ∀ (arr : List Int), arr ≠ [] → 0 < sumGroups arr :=\nsorry\n\ntheorem sum_groups_alternating_parity_bound :\n  ∀ (arr : List Int), arr ≠ [] →\n  sumGroups arr ≤ countAlternatingParity arr :=\nsorry\n\ntheorem sum_groups_monotonic_reduction :\n  ∀ (arr : List Int), arr ≠ [] →\n  ∀ (next : List Int), next = getNextArr arr →\n  next ≠ arr →\n  List.length next ≤ List.length arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 3, 3, 3, 9, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_groups [1, 1, 2, 2]"}
{"id": "fvapps_004204", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def has_subpattern (s : String) : Bool :=\n  sorry\n\ndef gcd (a b : Nat) : Nat :=\n  sorry\n\ndef reduce (f : Nat → Nat → Nat) (xs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_char_string_property (s : String) :\n  (s.length > 1 ∧ s.data.eraseDups.length = 1) → has_subpattern s\n  ∧\n  (s.length = 1) → ¬has_subpattern s :=\nsorry\n\ntheorem repeat_property (s : String) :\n  s.length ≥ 2 →\n  has_subpattern s →\n  has_subpattern (s ++ s) ∧ has_subpattern (s ++ s ++ s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004208", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countDivisors (n : Nat) : Nat :=\n  sorry\n\ndef divNum (a b : Nat) : Option Nat :=\n  sorry", "vc-theorems": "theorem divNum_invalid_range {a b : Nat} (h : a > b) :\n  divNum a b = none :=\nsorry\n\ntheorem divNum_result_in_range {a b : Nat} (h : a ≤ b) (result : Nat) :\n  divNum a b = some result → a ≤ result ∧ result ≤ b :=\nsorry\n\ntheorem divNum_max_divisors {a b result : Nat} (h : a ≤ b) :\n  divNum a b = some result →\n  ∀ x, a ≤ x ∧ x ≤ b → countDivisors x ≤ countDivisors result :=\nsorry\n\ntheorem divNum_equal_inputs (x : Nat) :\n  divNum x x = some x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval div_num 15 30\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval div_num 1 2\n\n/-\ninfo: 'Error'\n-/\n#guard_msgs in\n#eval div_num 159 4"}
{"id": "fvapps_004215", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def revamp (s : String) : String :=\nsorry\n\ndef sumChars (s : String) : Nat :=\nsorry\n\ndef sortString (s : String) : String :=\nsorry", "vc-theorems": "theorem output_has_same_word_count (s : String) :\n  (String.split (revamp s) (· = ' ')).length = (String.split s (· = ' ')).length :=\nsorry\n\ntheorem words_internally_sorted (s : String) :\n  let result := String.split (revamp s) (· = ' ')\n  ∀ word, word ∈ result →\n    word = sortString word :=\nsorry\n\ntheorem empty_string :\n  revamp \"\" = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004218", "vc-description": "-- Helper function to find maximum in list\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Helper function to find minimum in list", "vc-preamble": "def listMax : List Int → Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)\n\ndef listMin : List Int → Int\n  | [] => 0\n  | (x::xs) => min x (listMin xs)", "vc-helpers": "", "vc-definitions": "def consecutive (lst : List Int) : Int :=\nsorry", "vc-theorems": "theorem consecutive_empty : consecutive [] = 0 :=\nsorry\n\ntheorem consecutive_property {lst : List Int} (h : lst ≠ []) :\n  consecutive lst = listMax lst - listMin lst + 1 - lst.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004221", "vc-description": "/- For any string made up of valid keypad characters, the number of presses\n    should be at least the length of the string, and each character should\n    be present in one of the buttons -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The number of presses required should be the same regardless of case -/\n\n/- For strings containing only numbers and spaces, the number of presses\n    should be at least the length of the string -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BUTTONS : List String :=\nsorry\n\ndef presses (s : String) : Nat :=\nsorry", "vc-theorems": "theorem keypad_chars_valid (s : String) :\n  (∀ c ∈ s.data, ∃ button ∈ BUTTONS, c ∈ button.data) →\n  presses s ≥ s.length :=\nsorry\n\ntheorem case_insensitive (button : String) :\n  button ∈ BUTTONS →\n  presses button.toUpper = presses button.toLower :=\nsorry\n\ntheorem numeric_and_space_presses (s : String) :\n  (∀ c ∈ s.data, c ∈ [' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) →\n  presses s ≥ s.length :=\nsorry", "vc-postamble": "/-\ninfo: 9\n-/\n#guard_msgs in\n#eval presses \"LOL\"\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval presses \"HOW R U\"\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval presses \"WHERE DO U WANT 2 MEET L8R\""}
{"id": "fvapps_004222", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumin (n : Nat) : Nat :=\nsorry\n\ndef sumax (n : Nat) : Nat :=\nsorry\n\ndef sumsum (n : Nat) : Nat :=\nsorry\n\ndef sumOfMins (n : Nat) : Nat :=\nsorry\n\ndef sumOfMaxs (n : Nat) : Nat :=\nsorry\n\ndef sumOfSums (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem sumax_positive (n : Nat) (h : n > 0) :\n  sumax n > 0 :=\nsorry\n\ntheorem sumsum_equals_sumin_plus_sumax (n : Nat) :\n  sumsum n = sumin n + sumax n :=\nsorry\n\ntheorem sumin_positive (n : Nat) (h : n > 0) :\n  sumin n > 0 :=\nsorry\n\ntheorem sumin_le_sumax (n : Nat) :\n  sumin n ≤ sumax n :=\nsorry\n\ntheorem sumax_ge_sumin (n : Nat) :\n  sumax n ≥ sumin n :=\nsorry\n\ntheorem sumsum_positive (n : Nat) (h : n > 0) :\n  sumsum n > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 55\n-/\n#guard_msgs in\n#eval sumin 5\n\n/-\ninfo: 91\n-/\n#guard_msgs in\n#eval sumin 6\n\n/-\ninfo: 1240\n-/\n#guard_msgs in\n#eval sumin 15\n\n/-\ninfo: 161\n-/\n#guard_msgs in\n#eval sumax 6\n\n/-\ninfo: 61755\n-/\n#guard_msgs in\n#eval sumax 45\n\n/-\ninfo: 671650\n-/\n#guard_msgs in\n#eval sumax 100\n\n/-\ninfo: 252\n-/\n#guard_msgs in\n#eval sumsum 6\n\n/-\ninfo: 93150\n-/\n#guard_msgs in\n#eval sumsum 45\n\n/-\ninfo: 1010000\n-/\n#guard_msgs in\n#eval sumsum 100"}
{"id": "fvapps_004227", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def WEEKDAY : Nat → String :=\nsorry\n\ndef ERROR : String :=\nsorry\n\ndef whatday (n : Int) : String :=\nsorry", "vc-theorems": "theorem whatday_spec (n : Int) :\n  (1 ≤ n ∧ n ≤ 7 → ∃ (i : Nat), whatday n = WEEKDAY i) ∧\n  (¬(1 ≤ n ∧ n ≤ 7) → whatday n = ERROR) :=\nsorry\n\ntheorem valid_weekday (n : Int) (h : 1 ≤ n ∧ n ≤ 7) :\n  ∃ (i : Nat), whatday n = WEEKDAY i :=\nsorry\n\ntheorem invalid_weekday (n : Int) (h : ¬(1 ≤ n ∧ n ≤ 7)) :\n  whatday n = ERROR :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sunday'\n-/\n#guard_msgs in\n#eval whatday 1\n\n/-\ninfo: 'Saturday'\n-/\n#guard_msgs in\n#eval whatday 7\n\n/-\ninfo: ERROR\n-/\n#guard_msgs in\n#eval whatday 0"}
{"id": "fvapps_004235", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def splitString (s : String) (sep : String) : List String :=\nsorry\n\ndef containsString (s : String) (sub : String) : Bool :=\nsorry\n\ndef startsWithString (s : String) (pre : String) : Bool :=\nsorry\n\ndef simplify (n : Nat) : String :=\nsorry", "vc-theorems": "theorem simplify_zero :\n  simplify 0 = \"\" :=\nsorry\n\ntheorem simplify_format_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  terms.length > 0 :=\nsorry\n\ntheorem simplify_terms_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  ∀ t ∈ terms,\n    (containsString t \"*\" ∧\n     let parts := splitString t \"*\"\n     parts.length = 2 ∧\n     let digit := parts[0]!\n     let power := parts[1]!\n     startsWithString power \"10\" ∧\n     let digitNum := digit.toNat!\n     1 ≤ digitNum ∧ digitNum ≤ 9)\n    ∨\n    (¬containsString t \"*\" ∧\n     t.all Char.isDigit ∧\n     let termNum := t.toNat!\n     1 ≤ termNum ∧ termNum ≤ 9) :=\nsorry\n\ntheorem simplify_sums_to_input (n : Nat) :\n  let terms := splitString (simplify n) \"+\"\n  terms.foldl\n    (fun acc t =>\n      if containsString t \"*\" then\n        let parts := splitString t \"*\"\n        acc + parts[0]!.toNat! * parts[1]!.toNat!\n      else\n        acc + t.toNat!)\n    0\n  = n :=\nsorry\n\ntheorem simplify_no_leading_zeros (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  ∀ t ∈ terms, ¬startsWithString t \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5*10+6'\n-/\n#guard_msgs in\n#eval simplify 56\n\n/-\ninfo: '9*100+9*10+9'\n-/\n#guard_msgs in\n#eval simplify 999\n\n/-\ninfo: '1*10000+4'\n-/\n#guard_msgs in\n#eval simplify 10004"}
{"id": "fvapps_004242", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f (n : Int) : Int :=\n  sorry\n\ndef is_prime (n : Int) : Bool :=\n  sorry\n\ndef count_even_digits (n : Int) : Nat :=\n  sorry", "vc-theorems": "theorem f_result_is_prime (n : Int) (h : n ≥ 2) :\n  is_prime (f n) = true ∨ f n = 0 :=\nsorry\n\ntheorem f_result_less_than_input (n : Int) (h : n ≥ 2) :\n  f n ≤ n :=\nsorry\n\ntheorem f_result_has_max_even_digits (n : Int) (h : n ≥ 2) :\n  f n ≠ 0 →\n  ∀ i : Int, 2 ≤ i → i ≤ n → is_prime i = true →\n  count_even_digits i ≤ count_even_digits (f n) :=\nsorry\n\ntheorem f_result_largest_for_same_even_digits (n : Int) (h : n ≥ 2) :\n  f n ≠ 0 →\n  ∀ i : Int, f n < i → i ≤ n → is_prime i = true →\n  count_even_digits i = count_even_digits (f n) → False :=\nsorry\n\ntheorem f_small_inputs (n : Int) (h : n ≤ 1) :\n  f n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 887\n-/\n#guard_msgs in\n#eval f 1000\n\n/-\ninfo: 8887\n-/\n#guard_msgs in\n#eval f 10000\n\n/-\ninfo: 487\n-/\n#guard_msgs in\n#eval f 500"}
{"id": "fvapps_004251", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def HQ9 (s : String) : Option String :=\n  sorry\n\ndef contains (haystack needle : String) : Bool :=\n  sorry\n\ndef count (haystack needle : String) : Nat :=\n  sorry", "vc-theorems": "theorem hq9_invalid_none :\n  HQ9 \"\" = none ∧ HQ9 \" \" = none :=\nsorry\n\ntheorem h_returns_hello :\n  HQ9 \"H\" = some \"Hello World!\" :=\nsorry\n\ntheorem q_returns_q :\n  HQ9 \"Q\" = some \"Q\" :=\nsorry\n\ntheorem nine_returns_song (result : String) :\n  HQ9 \"9\" = some result →\n  contains result \"99 bottles of beer\" = true ∧\n  contains result \"1 bottle of beer\" = true ∧\n  contains (String.toLower result) \"no more bottles of beer\" = true ∧\n  count result \"of beer\" ≥ 190 ∧\n  count result \"\\n\" ≥ 99 :=\nsorry\n\ntheorem non_hq9_returns_none (s : String) :\n  s ≠ \"H\" → s ≠ \"Q\" → s ≠ \"9\" →\n  HQ9 s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval HQ9 \"X\"\n\n/-\ninfo: 'Hello World!'\n-/\n#guard_msgs in\n#eval HQ9 \"H\"\n\n/-\ninfo: 'Q'\n-/\n#guard_msgs in\n#eval HQ9 \"Q\""}
{"id": "fvapps_004270", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def share_price (invested : Float) (changes : List Float) : String :=\n  sorry\n\ndef parseFloat? (s : String) : Option Float :=\n  sorry", "vc-theorems": "theorem share_price_valid_format {invested : Float} {changes : List Float}\n  (h1 : invested > 0)\n  (h2 : ∀ c ∈ changes, c ≥ -99.99 ∧ c ≤ 1000) :\n  ∃ p d,\n    share_price invested changes = p ++ \".\" ++ d ∧\n    d.length = 2 ∧\n    (parseFloat? (share_price invested changes)).isSome ∧\n    ∃ x, parseFloat? (share_price invested changes) = some x ∧ x ≥ 0 :=\nsorry\n\ntheorem share_price_empty_changes {invested : Float}\n  (h : invested > 0) :\n  share_price invested [] = toString invested ++ \".\" ++ \"00\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '100.00'\n-/\n#guard_msgs in\n#eval share_price 100 []\n\n/-\ninfo: '75.00'\n-/\n#guard_msgs in\n#eval share_price 100 [-50, 50]\n\n/-\ninfo: '1113.64'\n-/\n#guard_msgs in\n#eval share_price 1000 [0, 2, 3, 6]"}
{"id": "fvapps_004275", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For valid rhythms, internal bars should sum to the correct total -/\n\n/- Invalid meter denominators result in invalid rhythms -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef validateRhythm (meter : List Nat) (score : String) : String :=\n  sorry", "vc-theorems": "theorem validate_rhythm_result_options (meter : List Nat) (score : String) :\n  let result := validateRhythm meter score;\n  result = \"Valid rhythm\" ∨ result = \"Valid rhythm with anacrusis\" ∨ result = \"Invalid rhythm\" :=\nsorry\n\ntheorem validate_rhythm_valid_bars_sum (meter : List Nat) (score : String)\n  (h1 : meter.length = 2) (h2 : meter[0]! > 0) (h3 : meter[1]! > 0)\n  (h4 : let result := validateRhythm meter score;\n        result = \"Valid rhythm\" ∨ result = \"Valid rhythm with anacrusis\") :\n  let bars := score.splitOn \"|\";\n  ∀ bar ∈ bars.tail.dropLast, bar ≠ \"\" →\n  ∃ barSum target : Nat,\n    barSum = target ∧ target = meter[0]! / meter[1]! :=\nsorry\n\ntheorem validate_rhythm_invalid_meter_denom (meter : List Nat)\n  (h1 : meter.length = 2)\n  (h2 : meter[1]! > 0)\n  (h3 : ¬(IsPowerOfTwo meter[1]!)) :\n  validateRhythm meter \"4|4\" = \"Invalid rhythm\" :=\nsorry", "vc-postamble": "/-\ninfo: 'Invalid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [4, 4] \"4444|8484842|888\"\n\n/-\ninfo: 'Valid rhythm with anacrusis'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 4] \"4|44|88\"\n\n/-\ninfo: 'Valid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 2] \"22|22|22\""}
{"id": "fvapps_004288", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\n  sorry\n\ndef sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef isPowerOfTen (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem solve_result_bounded (n : Nat) (h : n > 0) :\n  let result := solve n\n  result ≥ 0 ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 99\n-/\n#guard_msgs in\n#eval solve 100\n\n/-\ninfo: 48\n-/\n#guard_msgs in\n#eval solve 48\n\n/-\ninfo: 999\n-/\n#guard_msgs in\n#eval solve 1000"}
{"id": "fvapps_004289", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def permutation_average (n : Int) : Int :=\n  sorry\n\ndef permutation_average_str (s : String) : Int :=\n  sorry", "vc-theorems": "theorem permutation_average_returns_integer (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 999) :\n  ∃ i : Int, permutation_average n = i := by\n  sorry\n\ntheorem string_int_equivalent (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 999) :\n  permutation_average n = permutation_average_str (toString n) := by\n  sorry\n\ntheorem leading_zeros_valid (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 99) :\n  ∃ i : Int, permutation_average_str (\"0\" ++ toString n) = i := by\n  sorry\n\ntheorem result_within_bounds (n : Int)\n  (h : 10 ≤ n ∧ n ≤ 999) :\n  permutation_average n ≥ 0 ∧ permutation_average n ≤ n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval permutation_average 2\n\n/-\ninfo: 38\n-/\n#guard_msgs in\n#eval permutation_average 25\n\n/-\ninfo: 629\n-/\n#guard_msgs in\n#eval permutation_average 737"}
{"id": "fvapps_004306", "vc-description": "/- Each output is a valid list of strings where each string is a valid hex color -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Non-positive inputs return empty list -/\n\n/- Output length is constrained between 0 and min(n, 254) -/\n\n/- Values are monotonically increasing -/\n\n/- RGB components are equal for each color -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidHexColor (color : String) : Bool :=\nsorry\n\ndef shadesOfGrey (n : Int) : List String :=\nsorry", "vc-theorems": "theorem shadesOfGrey_outputs_valid_list (n : Int) :\n  ∀ x ∈ shadesOfGrey n, isValidHexColor x :=\nsorry\n\ntheorem nonpositive_input_returns_empty {n : Int} (h : n ≤ 0) :\n  shadesOfGrey n = [] :=\nsorry\n\ntheorem output_length_constraints (n : Int) :\n  List.length (shadesOfGrey n) = min (max 0 n) 254 :=\nsorry\n\ntheorem values_monotonic_increasing {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 254) :\n  let result := shadesOfGrey n\n  let values := result.map (fun color => (color.take 3).toNat!)\n  ∀ i j, i < j → j < values.length → values[i]! < values[j]! :=\nsorry\n\ntheorem rgb_components_equal {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 254) :\n  let result := shadesOfGrey n\n  ∀ color ∈ result,\n    color.get! ⟨1⟩ = color.get! ⟨3⟩ ∧\n    color.get! ⟨3⟩ = color.get! ⟨5⟩ :=\nsorry", "vc-postamble": "/-\ninfo: []\n-/\n#guard_msgs in\n#eval shades_of_grey -1\n\n/-\ninfo: ['#010101']\n-/\n#guard_msgs in\n#eval shades_of_grey 1\n\n/-\ninfo: ['#010101', '#020202', '#030303']\n-/\n#guard_msgs in\n#eval shades_of_grey 3"}
{"id": "fvapps_004308", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def distance (x y : Float) : Float :=\n  sorry\n\ndef angle (x y : Float) : Float :=\n  sorry\n\ndef get_score (x y : Float) : String :=\n  sorry\n\ndef ValidScores : List String :=\n  sorry", "vc-theorems": "theorem get_score_returns_valid : ∀ x y : Float, x ≥ -200 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 →\n  get_score x y ∈ ValidScores :=\nsorry\n\ntheorem same_distance_angle_same_score : ∀ x y x2 y2 : Float,\n  x ≥ -200 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 ∧\n  x2 ≥ -200 ∧ x2 ≤ 200 ∧ y2 ≥ -200 ∧ y2 ≤ 200 →\n  distance x y = distance x2 y2 ∧ angle x y = angle x2 y2 →\n  get_score x y = get_score x2 y2 :=\nsorry\n\ntheorem outside_board_is_X : ∀ x y : Float,\n  x > 170.1 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 →\n  get_score x y = \"X\" :=\nsorry\n\ntheorem bulls_eye_region : ∀ x y : Float,\n  x ≥ -6.35 ∧ x ≤ 6.35 ∧ y ≥ -6.35 ∧ y ≤ 6.35 ∧\n  distance x y ≤ 6.35 →\n  get_score x y = \"DB\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'X'\n-/\n#guard_msgs in\n#eval get_score -133.69 -147.38\n\n/-\ninfo: 'DB'\n-/\n#guard_msgs in\n#eval get_score 4.06 0.71\n\n/-\ninfo: 'T2'\n-/\n#guard_msgs in\n#eval get_score 55.53 -87.95"}
{"id": "fvapps_004310", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binary_zeros_count (c : Char) : Nat :=\n  sorry\n\ndef binary_ones_count (c : Char) : Nat :=\n  sorry\n\ndef more_zeros (s : String) : List Char :=\n  sorry", "vc-theorems": "theorem more_zeros_results_unique (s : String) :\n  let result := more_zeros s\n  (List.length result = List.length (List.eraseDups result)) ∧\n  (∀ c ∈ result, s.data.contains c) := by\n  sorry\n\ntheorem more_zeros_binary_property (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ result, binary_zeros_count c > binary_ones_count c := by\n  sorry\n\ntheorem more_zeros_inclusion_complete (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ s.data,\n    binary_zeros_count c > binary_ones_count c →\n    c ∉ result →\n    (s.data.filter (· = c)).length > 1 := by\n  sorry\n\ntheorem more_zeros_ascii_printable (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ result, 32 ≤ c.toNat ∧ c.toNat ≤ 127 := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_004317", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def play_if_enough (hand play : String) : Bool × String :=\n  sorry\n\ndef String.count (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem play_if_enough_success_length {hand play : String} :\n  let res := play_if_enough hand play\n  res.1 → res.2.length = hand.length - play.length :=\nsorry\n\ntheorem play_if_enough_success_subset {hand play : String} {c : Char} :\n  let res := play_if_enough hand play\n  res.1 → res.2.count c ≤ hand.count c :=\nsorry\n\ntheorem play_if_enough_failure_preserves {hand play : String} :\n  let res := play_if_enough hand play\n  ¬res.1 → res.2 = hand :=\nsorry\n\ntheorem play_if_enough_empty_succeeds {hand : String} :\n  (play_if_enough hand \"\").1 = true :=\nsorry\n\ntheorem play_if_enough_too_long_fails {hand play : String} :\n  play.length > hand.length →\n  ¬(play_if_enough hand play).1 :=\nsorry\n\ntheorem play_if_enough_impossible_preserves {hand : String} :\n  let impossible := String.mk (List.replicate (hand.length + 1) 'z')\n  let res := play_if_enough hand impossible\n  ¬res.1 ∧ res.2 = hand :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: (False, '')\n-/\n#guard_msgs in\n#eval play_if_enough \"\" \"bw\"\n\n/-\ninfo: (True, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"ooooogggssbbb\" \"ooogg\"\n\n/-\ninfo: (False, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"oogssbbb\" \"bwsg\""}
{"id": "fvapps_004318", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def string_color (s : String) : Option String :=\nsorry\n\ndef hexToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem string_color_short_strings {s : String} (h : s.length ≤ 1) :\n  string_color s = none :=\nsorry\n\ntheorem string_color_valid_ranges {s : String} (h : s.length ≥ 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    let r := hexToNat result\n    let g := hexToNat result\n    let b := hexToNat result\n    r ≤ 255 ∧ g ≤ 255 ∧ b ≤ 255 :=\nsorry\n\ntheorem string_color_longer_strings {s : String} (h : s.length ≥ 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    result.length = 6 ∧\n    (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']) :=\nsorry\n\ntheorem string_color_deterministic {s : String} :\n  string_color s = string_color s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"A\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"\"\n\n/-\ninfo: '79CAE5'\n-/\n#guard_msgs in\n#eval string_color \"Jack\""}
{"id": "fvapps_004320", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def penaltyShots (shots: Nat) (scores: List Nat) : Nat :=\nsorry\n\ndef abs (n: Int) : Nat :=\nsorry", "vc-theorems": "theorem penalty_shots_score_range {shots score1 score2: Nat}\n  (h1: score1 ≤ shots) (h2: score2 ≤ shots)\n  (h3: shots ≤ 20) (h4: score1 ≤ 20) (h5: score2 ≤ 20)\n  (h6: abs (Int.subNatNat score1 score2) ≤ (if shots > 4 then 2 else 5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ (if shots > 4 then 2 else 5 - shots + 1) :=\nsorry\n\ntheorem penalty_shots_sudden_death {shots score1 score2: Nat}\n  (h1: shots > 4) (h2: score1 ≤ shots) (h3: score2 ≤ shots)\n  (h4: abs (Int.subNatNat score1 score2) ≤ 2) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ 2 :=\nsorry\n\ntheorem penalty_shots_regular_rounds {shots score1 score2: Nat}\n  (h1: shots ≤ 4) (h2: score1 ≤ shots) (h3: score2 ≤ shots)\n  (h4: abs (Int.subNatNat score1 score2) ≤ (5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ (5 - shots + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval penaltyShots 2 [1, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 10 [10, 10]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 5 [5, 5]"}
{"id": "fvapps_004330", "vc-description": "", "vc-preamble": "def count_hashtags (s : String) : Nat :=\n  s.foldl (fun acc c => if c = '#' then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def clean_string (s : String) : String :=\nsorry", "vc-theorems": "theorem clean_string_idempotent (s : String) :\n  clean_string (clean_string s) = clean_string s :=\nsorry\n\ntheorem clean_string_no_hashtags (s : String) :\n  ¬(String.contains (clean_string s) '#') :=\nsorry\n\ntheorem clean_string_append {s₁ s₂ : String}\n  (h₁ : ¬(String.contains s₁ '#'))\n  (h₂ : ¬(String.contains s₂ '#')) :\n  clean_string (s₁ ++ s₂) = clean_string s₁ ++ clean_string s₂ :=\nsorry\n\ntheorem clean_string_length (s : String) :\n  String.length (clean_string s) ≤ String.length s - count_hashtags s :=\nsorry\n\ntheorem clean_string_empty :\n  clean_string \"\" = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ac'\n-/\n#guard_msgs in\n#eval clean_string \"abc#d##c\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval clean_string \"#######\"\n\n/-\ninfo: 'jf'\n-/\n#guard_msgs in\n#eval clean_string \"abjd####jfk#\""}
{"id": "fvapps_004331", "vc-description": "/- Decompose function's list result contains only numbers greater than 1 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Decompose function's remainder is non-negative -/\n\n/- The decomposition recomposes back to the original number -/\n\n/- Negative inputs return empty list and same number as remainder -/\n\n/- Small inputs (0,1) return empty list and same number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def decompose : Int → List Nat × Int :=\nsorry", "vc-theorems": "theorem decompose_result_gt_one (n : Int) :\n  let (result, _) := decompose n\n  ∀ k ∈ result, k > 1 :=\nsorry\n\ntheorem decompose_remainder_nonneg (n : Int) :\n  let (_, remainder) := decompose n\n  remainder ≥ 0 :=\nsorry\n\ntheorem decompose_recompose (n : Int) :\n  let (result, remainder) := decompose n\n  let recomposed := remainder + (List.foldl (fun acc (i, k) => acc + (i + 2)^k) 0\n    (List.zip (List.range result.length) result))\n  recomposed = n :=\nsorry\n\ntheorem decompose_negative (n : Int) :\n  n < 0 →\n  decompose n = ([], n) :=\nsorry\n\ntheorem decompose_small_inputs (n : Int) :\n  n = 0 ∨ n = 1 →\n  decompose n = ([], n) :=\nsorry", "vc-postamble": "/-\ninfo: [[], 3]\n-/\n#guard_msgs in\n#eval decompose 3\n\n/-\ninfo: [[4, 2], 1]\n-/\n#guard_msgs in\n#eval decompose 26\n\n/-\ninfo: [[], 0]\n-/\n#guard_msgs in\n#eval decompose 0"}
{"id": "fvapps_004332", "vc-description": "-- Property 1: Function should work for any valid positive integer string input\n\n-- Property 2: Powers of 2 should have n-1 consecutive zeros\n\n-- Property 3: Result should be same for equivalent decimal values", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_consec_zeros (n: String) : String :=\n  sorry\n\ndef toWord (n: Nat) : String :=\n  sorry", "vc-theorems": "theorem max_consec_zeros_valid_input {n: String} (h: ∃ (k: Nat), k > 0 ∧ k ≤ 10^6 ∧ n = toString k) :\n  let result := max_consec_zeros n\n  ∃ word, word ∈ [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n                  \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\"] ∧ result = word :=\nsorry\n\ntheorem powers_of_two_zeros {n: Nat} (h: n > 0 ∧ n ≤ 12) :\n  max_consec_zeros (toString (2^n)) = toWord (n-1) :=\nsorry\n\ntheorem equivalent_decimal_values {n: Nat} (h: n > 0 ∧ n ≤ 10000) :\n  max_consec_zeros (toString n) = max_consec_zeros (toString (n : Nat)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Two'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"9\"\n\n/-\ninfo: 'Three'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"550\"\n\n/-\ninfo: 'Eight'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"256\""}
{"id": "fvapps_004337", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def debug (s : String) : String :=\nsorry\n\ndef String.containsSubstr (s str : String) : Bool :=\nsorry\n\ndef String.countOccurrences (s str : String) : Nat :=\nsorry", "vc-theorems": "theorem debug_basic_properties (s : String) :\n  let result := debug s\n  (¬ result.containsSubstr \"bug\" ∨ result.containsSubstr \"bugs\") ∧\n  result.length ≤ s.length ∧\n  result = s.replace \"bug\" \"\" :=\nsorry\n\ntheorem debug_preserves_bugs (s : String) (h : ∀ c ∈ s.data, c = 'b' ∨ c = 'u' ∨ c = 'g' ∨ c = 's') :\n  (debug s).countOccurrences \"bugs\" = s.countOccurrences \"bugs\" :=\nsorry\n\ntheorem debug_idempotent (s : String) :\n  debug (debug s) = debug s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ooobuoobugsoo'\n-/\n#guard_msgs in\n#eval debug \"obugobugobuoobugsoo\"\n\n/-\ninfo: 'bugs gy'\n-/\n#guard_msgs in\n#eval debug \"bugs buggy\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval debug \"bugbugbugbug\""}
{"id": "fvapps_004340", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def are_similar (xs ys : List Int) : Bool :=\nsorry\n\ndef insertSort (xs : List Int) : List Int :=\nsorry", "vc-theorems": "theorem identical_lists_are_similar {xs : List Int} (h : xs ≠ []) :\n  are_similar xs xs :=\nsorry\n\ntheorem different_contents_not_similar {xs ys : List Int} :\n  insertSort xs ≠ insertSort ys →\n  ¬(are_similar xs ys) :=\nsorry\n\ntheorem single_swap_makes_similar {xs : List Int} (h : xs.length ≥ 2) :\n  let ys := xs.set 0 (xs.get! 1) |>.set 1 (xs.get! 0)\n  are_similar xs ys :=\nsorry\n\ntheorem multiple_swaps_not_similar {xs : List Int} (h : xs.length ≥ 3) :\n  let ys := xs.set 0 (xs.get! 1)\n            |>.set 1 (xs.get! 2)\n            |>.set 2 (xs.get! 0)\n  (List.length (List.filter (fun p => p.1 ≠ p.2) (List.zip xs ys))) > 2 →\n  ¬(are_similar xs ys) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [1, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [2, 1, 3]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 2] [2, 1, 1]"}
{"id": "fvapps_004354", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def perms (s : String) : Nat :=\nsorry\n\ndef listPerms (l : List α) : List (List α) :=\nsorry\n\ndef listToString (l : List Char) : String :=\nsorry\n\ndef numUnique (xs : List String) : Nat :=\nsorry", "vc-theorems": "theorem perms_matches_unique_perms_int {n : Nat} :\n  perms (toString n) = numUnique ((listPerms (toString n).data).map listToString) :=\nsorry\n\ntheorem perms_matches_unique_perms_str {s : String} :\n  perms s = numUnique ((listPerms s.data).map listToString) :=\nsorry\n\ntheorem perms_order_invariant {n : Nat} :\n  perms (toString n) = perms (toString n) :=\nsorry\n\ntheorem perms_positive_int {s : String} (h : s.length > 0) :\n  perms s > 0 :=\nsorry\n\ntheorem perms_single_char {c : Char} :\n  perms (String.mk [c]) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval perms 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval perms 25\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval perms \"abc\""}
{"id": "fvapps_004362", "vc-description": "--\") ∧\n\n--\") ∧", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def replace_dashes_as_one (s : String) : String :=\nsorry\n\ndef remove_dashes (s : String) : String :=\nsorry\n\ndef containsSubstring (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem no_consecutive_dashes\n  (s : String) :\n  ¬ (containsSubstring (replace_dashes_as_one s) \"\n  ¬ (containsSubstring (replace_dashes_as_one s) \"- -\") :=\nsorry\n\ntheorem preserves_non_dash_chars\n  (s : String) :\n  remove_dashes s = remove_dashes (replace_dashes_as_one s) :=\nsorry\n\ntheorem idempotent\n  (s : String) :\n  replace_dashes_as_one (replace_dashes_as_one s) = replace_dashes_as_one s :=\nsorry\n\ntheorem dash_only_strings\n  (s : String)\n  (h : ∀ c, String.contains s c → (c = '-' ∨ c = ' ')) :\n  (∀ c, String.contains (replace_dashes_as_one s) c → (c = '-' ∨ c = ' ')) ∧\n  ¬ (containsSubstring (replace_dashes_as_one s) \"\n  ¬ (containsSubstring (replace_dashes_as_one s) \"- -\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'we-are- code-warriors.-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"we-are- - - code----warriors.-\"\n\n/-\ninfo: 'a-b-c'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a---b- - -c\"\n\n/-\ninfo: 'a-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a------\""}
{"id": "fvapps_004366", "vc-description": "", "vc-preamble": "def bitLength (n : Nat) : Nat :=\n  if n = 0 then 0 else Nat.log2 n + 1", "vc-helpers": "", "vc-definitions": "def number_increasing (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem impossible_values_2 : number_increasing 2 = false :=\nsorry\n\ntheorem impossible_values_4 : number_increasing 4 = false :=\nsorry\n\ntheorem impossible_values_7 : number_increasing 7 = false :=\nsorry\n\ntheorem impossible_values_12 : number_increasing 12 = false :=\nsorry\n\ntheorem impossible_values_17 : number_increasing 17 = false :=\nsorry\n\ntheorem impossible_values_22 : number_increasing 22 = false :=\nsorry\n\ntheorem multiples_of_five (n : Nat) (h₁ : n > 1) (h₂ : n % 5 = 0) :\n  number_increasing n = false :=\nsorry\n\ntheorem start_point :\n  number_increasing 1 = true :=\nsorry\n\ntheorem multiples_of_three_reachable (n : Nat) (h₁ : n > 1)\n  (h₂ : n = 3^(bitLength (bitLength (n - 1)))) :\n  number_increasing n = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval number_increasing 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 6\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 18\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 32"}
{"id": "fvapps_004369", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (a b : String) : String :=\nsorry\n\ndef binary_to_int (s : String) : Nat :=\nsorry\n\ndef is_valid_binary (s : String) : Bool :=\nsorry", "vc-theorems": "theorem strips_leading_zeros (binary : String) :\n  let result := add binary \"0\"\n  (result.startsWith \"0\" → result = \"0\") ∧\n  binary_to_int result = binary_to_int binary :=\nsorry\n\ntheorem add_commutative (a b : String) :\n  add a b = add b a :=\nsorry\n\ntheorem matches_integer_addition (a b : String) :\n  let result := add a b\n  is_valid_binary result ∧\n  binary_to_int result = binary_to_int a + binary_to_int b :=\nsorry\n\ntheorem identity (binary : String) :\n  binary_to_int (add binary \"0\") = binary_to_int binary :=\nsorry\n\ntheorem empty_strings_zero :\n  add \"\" \"\" = \"0\" :=\nsorry\n\ntheorem empty_string_one :\n  add \"\" \"1\" = \"1\" ∧ add \"1\" \"\" = \"1\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1001'\n-/\n#guard_msgs in\n#eval add \"111\" \"10\"\n\n/-\ninfo: '10010'\n-/\n#guard_msgs in\n#eval add \"1101\" \"101\"\n\n/-\ninfo: '100100'\n-/\n#guard_msgs in\n#eval add \"1101\" \"10111\""}
{"id": "fvapps_004380", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gc_content (s : String) : Float :=\nsorry\n\ndef count (s : String) (c : String) : Nat :=\nsorry", "vc-theorems": "theorem gc_content_bounded (s : String) :\n  0.0 ≤ gc_content s ∧ gc_content s ≤ 100.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004388", "vc-description": "/- Theorem ensuring result is an integer bounded by board size -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Theorem for specific cases -/\n\n/- Empty board -/\n\n/- Single enemy -/\n\n/- Multiple enemies -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pac_man (size : Nat) (pacman : List Nat) (enemies : List (List Nat)) : Int :=\nsorry", "vc-theorems": "theorem pac_man_result_bounds\n  (size : Nat)\n  (px py : Nat)\n  (enemies : List (List Nat))\n  (h : size ≥ 2) :\n  let normalizedPx := px % size\n  let normalizedPy := py % size\n  let result := pac_man size [normalizedPx, normalizedPy] enemies\n  result ≥ -1 ∧ result ≤ size * size - 1 :=\nsorry\n\ntheorem pac_man_specific_cases :\n\n  pac_man 3 [0, 0] [] = 8 ∧\n\n  pac_man 4 [3, 0] [[1, 2]] = 3 ∧\n\n  pac_man 2 [0, 0] [[0, 1], [1, 0], [1, 1]] = 0 :=\nsorry", "vc-postamble": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval pac_man 4 [3, 0] [[1, 2]]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval pac_man 3 [0, 0] []\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval pac_man 8 [1, 1] [[5, 4]]"}
{"id": "fvapps_004391", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def splitOnSpace (s : String) : List String :=\n  s.split (fun c => c = ' ')", "vc-helpers": "", "vc-definitions": "def fizz_buzz_cuckoo_clock (time : String) : String :=\n  sorry", "vc-theorems": "theorem output_is_nonempty (time : String) :\n  time.length = 5 → (fizz_buzz_cuckoo_clock time).length > 0 :=\nsorry\n\ntheorem half_hour_single_cuckoo (hour : Nat) (h : hour ≤ 23) :\n  let time := (if hour < 10 then \"0\" else \"\") ++ toString hour ++ \":30\"\n  fizz_buzz_cuckoo_clock time = \"Cuckoo\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004399", "vc-description": "", "vc-preamble": "def length (s : String) : Nat := s.data.length", "vc-helpers": "", "vc-definitions": "def automorphic (n : Nat) : String :=\n  sorry\n\ndef endsWith (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem automorphic_returns_valid_string (n : Nat) :\n  automorphic n = \"Automorphic\" ∨ automorphic n = \"Not!!\" :=\nsorry\n\ntheorem automorphic_definition (n : Nat) :\n  automorphic n = \"Automorphic\" ↔ endsWith (ToString.toString (n * n)) (ToString.toString n) = true :=\nsorry\n\ntheorem automorphic_zero_property (n : Nat) :\n  n = 0 → automorphic n = \"Automorphic\" :=\nsorry\n\ntheorem automorphic_length_property (n : Nat) :\n  n > 0 →\n  automorphic n = \"Automorphic\" →\n  length (ToString.toString (n * n)) ≥ length (ToString.toString n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 6\n\n/-\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 25\n\n/-\ninfo: 'Not!!'\n-/\n#guard_msgs in\n#eval automorphic 53"}
{"id": "fvapps_004410", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\nsorry\n\ndef is_composite (n : Nat) : Bool :=\nsorry\n\ndef isDigitIn (d : Char) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_positive (n : Nat) :\n  solve n > 0 :=\nsorry\n\ntheorem solve_monotonic {n : Nat} (h : n > 0) :\n  solve n > solve (n-1) :=\nsorry\n\ntheorem solve_deterministic (n : Nat) :\n  solve n = solve n :=\nsorry\n\ntheorem solve_zero :\n  solve 0 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 2\n\n/-\ninfo: 44\n-/\n#guard_msgs in\n#eval solve 10"}
{"id": "fvapps_004411", "vc-description": "", "vc-preamble": "def isSorted (as : List Nat) : Prop :=\n  ∀ i j, i < j → j < as.length → as[i]! ≤ as[j]!", "vc-helpers": "", "vc-definitions": "def order (sentence : String) : String :=\n  sorry\n\ndef splitString (s : String) (sep : Char) : List String :=\n  sorry\n\ndef findNumber (s : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem order_preserves_empty_string :\n  order \"\" = \"\" :=\nsorry\n\ntheorem order_sorts_by_numbers {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers :=\nsorry\n\ntheorem order_preserves_words {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  let resultWords := splitString (order sentence) ' '\n  words.eraseDups = resultWords.eraseDups ∧\n  words.length = resultWords.length :=\nsorry\n\ntheorem order_all_properties {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  (sentence = \"\" → order sentence = \"\") ∧\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers ∧\n  words.eraseDups = resultWords.eraseDups ∧\n  words.length = resultWords.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval order \"is2 Thi1s T4est 3a\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval order \"4of Fo1r pe6ople g3ood th5e the2\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval order \"\""}
{"id": "fvapps_004421", "vc-description": "", "vc-preamble": "def LePair (p1 p2: String × (String ⊕ Int)) : Prop :=\n  p1.1 ≤ p2.1", "vc-helpers": "", "vc-definitions": "def convert_hash_to_array (d: List (String × (String ⊕ Int))) : List (String × (String ⊕ Int)) :=\n  sorry", "vc-theorems": "theorem convert_hash_output_is_sorted (d: List (String × (String ⊕ Int))) :\n  let result := convert_hash_to_array d\n  List.Pairwise LePair result ∧\n  (∀ x ∈ result, ∃ k v, x = (k, v)) ∧\n  result = d :=\nsorry\n\ntheorem convert_hash_empty_dict :\n  convert_hash_to_array [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\"}\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\", \"age\": 24, \"role\": \"Software Engineer\"}\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval convert_hash_to_array {}"}
{"id": "fvapps_004425", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef allDigits (s : String) : Bool :=\nsorry\n\ndef md5hash (s : String) : String :=\nsorry\n\ndef crack (hash : String) : String :=\nsorry", "vc-theorems": "theorem crack_roundtrip {num : Nat} (h : num ≤ 99999) :\n  let numStr := toString num\n  let paddedStr := if numStr.length < 5 then String.mk (List.replicate (5 - numStr.length) '0') ++ numStr else numStr\n  crack (md5hash paddedStr) = paddedStr :=\nsorry\n\ntheorem crack_invalid_hash (s : String)\n  (h1 : s = \"invalid_hash\" ∨ s = \"\") :\n  crack s = \"\" :=\nsorry\n\ntheorem crack_random_hash (hash : String)\n  (h1 : hash.length = 32) :\n  let result := crack hash\n  (result = \"\") ∨\n  (result.length = 5 ∧\n   allDigits result = true ∧\n   md5hash result = hash) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '12345'\n-/\n#guard_msgs in\n#eval crack \"827ccb0eea8a706c4c34a16891f84e7b\"\n\n/-\ninfo: '00078'\n-/\n#guard_msgs in\n#eval crack \"86aa400b65433b608a9db30070ec60cd\""}
{"id": "fvapps_004427", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def split (s : String) (sep : Char → Bool) : List String :=\nsorry\n\ndef trim (s : String) : String :=\nsorry\n\ndef to_freud (s : String) : String :=\nsorry", "vc-theorems": "theorem empty_string_returns_empty :\n  to_freud \"\" = \"\" :=\nsorry\n\ntheorem only_whitespace_returns_empty (s : String) :\n  trim s = \"\" → to_freud s = \"\" :=\nsorry\n\ntheorem non_empty_only_contains_sex (s : String) :\n  trim s ≠ \"\" →\n  List.all (split (to_freud s) (· = ' ')) (· = \"sex\") :=\nsorry\n\ntheorem preserves_word_count (s : String) :\n  trim s ≠ \"\" →\n  (split (to_freud s) (· = ' ')).length = (split (trim s) (· = ' ')).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'sex'\n-/\n#guard_msgs in\n#eval to_freud \"test\"\n\n/-\ninfo: 'sex sex sex sex'\n-/\n#guard_msgs in\n#eval to_freud \"This is a test\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval to_freud \"\""}
{"id": "fvapps_004428", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def alphabetized (s : String) : String :=\nsorry\n\ndef sorted_list (l : List Char) : List Char :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem alphabetized_is_sorted (s : String) :\n  let result := alphabetized s\n  result = String.mk (sorted_list (result.data)) :=\nsorry\n\ntheorem alphabetized_only_letters (s : String) :\n  let result := alphabetized s\n  ∀ c ∈ result.data, isAlpha c :=\nsorry\n\ntheorem alphabetized_preserves_count (s : String) :\n  let result := alphabetized s\n  let original_letters := s.data.filter isAlpha\n  result.length = original_letters.length ∧\n  sorted_list (result.data.map Char.toLower) = sorted_list (original_letters.map Char.toLower) :=\nsorry\n\ntheorem alphabetized_empty_string :\n  alphabetized \"\" = \"\" :=\nsorry\n\ntheorem alphabetized_no_letters (s : String) :\n  (∀ c ∈ s.data, ¬isAlpha c) →\n  alphabetized s = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval alphabetized \"\"\n\n/-\ninfo: 'BbeehHilloTy'\n-/\n#guard_msgs in\n#eval alphabetized \"The Holy Bible\"\n\n/-\ninfo: 'aaaaCcdddeLnooorstTWy'\n-/\n#guard_msgs in\n#eval alphabetized \"CodeWars can\"t Load Today\""}
{"id": "fvapps_004438", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_profit (prices : List Nat) : Int :=\nsorry\n\ndef maximum (l : List Nat) : Nat :=\nsorry\n\ndef minimum (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_profit_bounds {prices : List Nat} (h : prices.length ≥ 2) :\n  max_profit prices ≤ (maximum prices) - (minimum prices) :=\nsorry\n\ntheorem ascending_max_profit {prices : List Nat} (h : prices.length ≥ 2)\n  (ascending : ∀ (i : Nat), i + 1 < prices.length → prices[i]! ≤ prices[i + 1]!) :\n  max_profit prices = prices.getLast! - prices.head! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval max_profit [10, 7, 5, 8, 11, 9]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_profit [3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_profit [9, 9]"}
{"id": "fvapps_004439", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_tenth_digit (digits : List Nat) : Nat :=\nsorry\n\ndef calculate_last_digit (digits : List Nat) : Nat :=\nsorry\n\ndef check_valid_tr_number (n : String) : Bool :=\nsorry", "vc-theorems": "theorem invalid_length_returns_false (n : String) :\n  n.length ≠ 11 → check_valid_tr_number n = false :=\nsorry\n\ntheorem valid_number_is_accepted {digits : List Nat} (h1 : digits.length = 9)\n  (h2 : digits.head! ≠ 0) :\n  let tenth := calculate_tenth_digit digits\n  let full_digits := digits ++ [tenth]\n  let last := calculate_last_digit full_digits\n  check_valid_tr_number (toString (full_digits ++ [last])) = true :=\nsorry\n\ntheorem invalid_check_digits_returns_false {n : String} (h1 : n.length = 11) :\n  let digits := n.toList.map (·.toString.toNat!)\n  digits[9]! ≠ calculate_tenth_digit (digits.take 9) ∨\n  digits[10]! ≠ calculate_last_digit (digits.take 10) →\n  check_valid_tr_number n = false :=\nsorry\n\ntheorem invalid_type_returns_false (n : String) :\n  ¬(∀ c : Char, c ∈ n.data → c.isDigit) →\n  check_valid_tr_number n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 36637640050\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_valid_tr_number 12762438338\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 10167994524"}
{"id": "fvapps_004455", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sequence (n : Nat) : Nat :=\nsorry\n\ndef toBinaryString (n : Nat) : List Nat :=\nsorry\n\ndef fromBase3 (digits : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem sequence_nonnegative (n : Nat) :\n  sequence n ≥ 0 :=\nsorry\n\ntheorem sequence_monotonic {n : Nat} (h : n > 0) :\n  sequence n > sequence (n - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- Helper functions for binary/base-3 conversion -/\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sequence 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sequence 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sequence 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sequence 3\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval sequence 4\n\n/-\ninfo: 7329\n-/\n#guard_msgs in\n#eval sequence 334"}
{"id": "fvapps_004463", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef lines (s : String) : List String :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem pattern_negative_or_zero (n : Int) :\n  n ≤ 0 → pattern n = \"\" :=\nsorry\n\ntheorem pattern_num_lines (n : Int) :\n  n > 0 → (lines (pattern n)).length = 2*n - 1 :=\nsorry\n\ntheorem pattern_symmetric_lines (n : Int) (i : Nat) :\n  n > 0 → i < n-1 →\n  (lines (pattern n)).get ⟨i, sorry⟩ = (lines (pattern n)).get ⟨n.toNat * 2 - 2 - i, sorry⟩ :=\nsorry\n\ntheorem pattern_middle_line_palindrome (n : Int) :\n  n > 0 →\n  let middle := (lines (pattern n)).get ⟨(n-1).toNat, sorry⟩\n  middle = reverseString middle :=\nsorry\n\ntheorem pattern_middle_line_length (n : Int) :\n  n > 0 →\n  let middle := (lines (pattern n)).get ⟨(n-1).toNat, sorry⟩\n  middle.length = 2*n-1 :=\nsorry\n\ntheorem pattern_line_length (n : Int) (i : Nat) :\n  n > 0 → i < n →\n  let line := (lines (pattern n)).get ⟨i, sorry⟩\n  line.length = 2*(i+1)-1 + 2*(n.toNat-(i+1)) :=\nsorry\n\ntheorem pattern_line_palindrome (n : Int) (i : Nat) :\n  n > 0 → i < n →\n  let line := (lines (pattern n)).get ⟨i, sorry⟩\n  line.trim = reverseString (line.trim) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval pattern 1\n\n/-\ninfo: '  1  \\n 121 \\n12321\\n 121 \\n  1  '\n-/\n#guard_msgs in\n#eval pattern 3\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"}
{"id": "fvapps_004467", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def convert_temp (temp : Float) (from_scale : String) (to_scale : String) : Int :=\n  sorry\n\ndef round (x : Float) : Int :=\n  sorry\n\ndef int_to_float (n : Int) : Float :=\n  sorry", "vc-theorems": "theorem convert_temp_identity {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  convert_temp temp scale scale = round temp := by\n  sorry\n\ntheorem convert_temp_returns_int {temp : Float} {from_scale to_scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  ∃ n : Int, convert_temp temp from_scale to_scale = n := by\n  sorry\n\ntheorem convert_temp_kelvin_roundtrip {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) (h3 : scale ≠ \"K\") :\n  let kelvin := int_to_float (convert_temp temp scale \"K\")\n  let back := convert_temp kelvin \"K\" scale\n  (back - round temp) ≤ 2 ∧ (round temp - back) ≤ 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 212\n-/\n#guard_msgs in\n#eval convert_temp 100 \"C\" \"F\"\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval convert_temp 40 \"Re\" \"C\"\n\n/-\ninfo: 140\n-/\n#guard_msgs in\n#eval convert_temp 60 \"De\" \"F\"\n\n/-\ninfo: 33\n-/\n#guard_msgs in\n#eval convert_temp 373.15 \"K\" \"N\"\n\n/-\ninfo: 666\n-/\n#guard_msgs in\n#eval convert_temp 666 \"K\" \"K\""}
{"id": "fvapps_004481", "vc-description": "", "vc-preamble": "def min_of_list (arr : List Int) : Int :=\n  match arr with\n  | [] => 0\n  | x::xs => xs.foldl min x\n\ndef max_of_list (arr : List Int) : Int :=\n  match arr with\n  | [] => 0\n  | x::xs => xs.foldl max x", "vc-helpers": "", "vc-definitions": "def keep_order (arr : List Int) (val : Int) : Nat :=\nsorry", "vc-theorems": "theorem keep_order_bounds {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  0 ≤ idx ∧ idx ≤ arr.length :=\nsorry\n\ntheorem keep_order_before {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  ∀ i, i < idx → arr[i]! < val :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval keep_order [1, 1, 2, 2, 2] 2"}
{"id": "fvapps_004489", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Int) : Int :=\nsorry\n\ndef maximum? (l : List Int) : Option Int :=\nsorry\n\ndef filterWithIndex (l : List Int) (f : Nat → Int → Bool) : List Int :=\nsorry\n\ndef target_game (vals : List Int) : Int :=\nsorry", "vc-theorems": "theorem target_game_nonneg (vals : List Int)\n  (h : vals ≠ []) :\n  target_game vals ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval target_game [1, 2, 3, 4]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval target_game [5, 5, 5, 5, 5]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval target_game [5, -2, -9, -4]"}
{"id": "fvapps_004491", "vc-description": "", "vc-preamble": "inductive Category where\n  | fruit : Category\n  | meat : Category\n  | vegetable : Category\n  | other : Category\nderiving BEq, Repr\n\nstructure GroceryItem where\n  category : Category\n  name : String\nderiving Repr\n\ndef length4 (s : List α) : Prop := s.length = 4\n\ninductive isSorted : List String → Prop where\n  | nil : isSorted []\n  | single : (x : String) → isSorted [x]\n  | cons : (x y : String) → (rest : List String) →\n          x <= y → isSorted (y::rest) → isSorted (x::y::rest)", "vc-helpers": "", "vc-definitions": "def group_groceries (input : String) : String :=\n  sorry\n\ndef isValidCategoryName (name : String) : Bool :=\n  sorry", "vc-theorems": "theorem group_groceries_produces_four_lines (input : String) :\n  length4 ((group_groceries input).splitOn \"\\n\") :=\nsorry\n\ntheorem group_groceries_uses_expected_categories (input : String) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  lines[0]!.startsWith \"fruit:\" ∧\n  lines[1]!.startsWith \"meat:\" ∧\n  lines[2]!.startsWith \"other:\" ∧\n  lines[3]!.startsWith \"vegetable:\" :=\nsorry\n\ntheorem group_groceries_items_sorted (input : String) (i : Nat) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  let items := (lines[i]!.splitOn \":\")[1]!.splitOn \",\"\n  items.length > 0 → isSorted items :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,meat_chicken,drink_juice\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,fruit_apple,canned_sardines,drink_juice,fruit_orange\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_orange\""}
{"id": "fvapps_004496", "vc-description": "/- The kind function only outputs \"abundant\", \"deficient\", or \"perfect\" -/\n\n/- Properties of deficiently abundant amicable numbers output -/\n\n/- Symmetric property of amicable numbers -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDivs (n : Nat) : Nat :=\nsorry\n\ndef kind (n : Nat) (sum : Nat) : String :=\nsorry\n\ndef deficientlyAbundantAmicableNumbers (n1 n2 : Nat) : String :=\nsorry", "vc-theorems": "theorem kind_outputs {n : Nat} (h : n > 0) :\n  let sum := sumOfDivs n\n  let k := kind n sum\n  (k = \"abundant\" ∨ k = \"deficient\" ∨ k = \"perfect\") :=\nsorry\n\ntheorem deficientlyabundant_properties {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result := deficientlyAbundantAmicableNumbers n1 n2\n  let sum1 := sumOfDivs n1\n  let sum2 := sumOfDivs n2\n  let is_amicable := sum1 = n2 ∧ sum2 = n1 ∧ n1 ≠ n2\n  result.contains 'n' = !is_amicable :=\nsorry\n\ntheorem symmetric_property {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result1 := deficientlyAbundantAmicableNumbers n1 n2\n  let result2 := deficientlyAbundantAmicableNumbers n2 n1\n  result1.contains 'n' = result2.contains 'n' :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004497", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n-- Result length less than input length\n\n-- Result chars are sorted\n\n-- Result chars come from input", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\nsorry\n\ndef String.toCharArray (s : String) : Array Char :=\nsorry\n\ndef String.fromCharArray (arr : Array Char) : String :=\nsorry\n\ndef has_subpattern (s : String) : String :=\nsorry", "vc-theorems": "theorem output_is_substring (s : String) (h : s.length > 0) :\n  let result := has_subpattern s\n\n  result.length ≤ s.length ∧\n\n  (∀ i j, i < j → i < result.length → j < result.length →\n    result.toCharArray[i]! ≤ result.toCharArray[j]!) ∧\n\n  (∀ c, c ∈ result.toCharArray.toList → c ∈ s.toCharArray.toList) :=\nsorry\n\ntheorem output_pattern_reconstruction (s : String) (h : s.length > 0) :\n  let pattern := has_subpattern s\n  let counts_s := s.toCharArray.toList.map (fun c => (c, s.count c))\n  let counts_p := pattern.toCharArray.toList.map (fun c => (c, pattern.count c))\n  pattern.length > 0 →\n  ∃ ratio : Nat, ∀ (s_c p_c : Char) (s_count p_count : Nat),\n    (s_c, s_count) ∈ counts_s →\n    (p_c, p_count) ∈ counts_p →\n    s_count = p_count * ratio :=\nsorry\n\ntheorem idempotent (s : String) (h : s.length > 0) :\n  has_subpattern s = has_subpattern (has_subpattern s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004501", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isVowel (c : Char) : Bool :=\n  sorry\n\ndef find_vowel_substrings (s : String) : List String :=\n  sorry", "vc-theorems": "theorem find_vowel_substrings_valid_input {s : String}\n  (h : ∃ pre mid post : String,\n    (∀ c, c ∈ pre.data → !isVowel c) ∧\n    (∀ c, c ∈ mid.data → isVowel c) ∧\n    (∀ c, c ∈ post.data → !isVowel c) ∧\n    mid.length ≥ 2 ∧\n    s = pre ++ mid ++ post) :\n  ∃ result : List String,\n    find_vowel_substrings s = result ∧\n    result ≠ [\"-1\"] ∧\n    ∀ substr ∈ result,\n      substr.length ≥ 2 ∧\n      ∀ c, c ∈ substr.data → isVowel c :=\nsorry\n\ntheorem find_vowel_substrings_invalid_input {s : String}\n  (h : ∀ c, c ∈ s.data → !isVowel c) :\n  find_vowel_substrings s = [\"-1\"] :=\nsorry\n\ntheorem find_vowel_substrings_general {s : String} :\n  let result := find_vowel_substrings s\n  result = [\"-1\"] ∨\n  (∀ substr ∈ result,\n    substr.length ≥ 2 ∧\n    ∀ c, c ∈ substr.data → isVowel c) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004502", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Matrix := List (List Bool)\n\ndef solveMatrix (m n a b : Nat) : Option Matrix :=\n  sorry\n\ndef matrixToStr (m : Matrix) : String :=\n  sorry", "vc-theorems": "theorem solve_matrix_valid_2_2_1_1 :\n  ∃ (result : Matrix),\n    solveMatrix 2 2 1 1 = some result ∧\n    matrixToStr result = \"10\\n01\"\n  :=\nsorry\n\ntheorem solve_matrix_valid_2_2_2_2 :\n  ∃ (result : Matrix),\n    solveMatrix 2 2 2 2 = some result ∧\n    matrixToStr result = \"11\\n11\"\n  :=\nsorry\n\ntheorem solve_matrix_valid_3_6_2_1 :\n  ∃ (result : Matrix),\n    solveMatrix 3 6 2 1 = some result ∧\n    matrixToStr result = \"110000\\n001100\\n000011\"\n  :=\nsorry\n\ntheorem solve_matrix_impossible_2_2_2_1 :\n  solveMatrix 2 2 2 1 = none :=\nsorry\n\ntheorem solve_matrix_impossible_3_3_3_1 :\n  solveMatrix 3 3 3 1 = none :=\nsorry\n\ntheorem solve_matrix_impossible_greater_dimensions :\n  (∀ m n : Nat, m > 0 → n > 0 →\n    (∀ a b : Nat, (a > m ∨ b > n) →\n      solveMatrix m n a b = none)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result"}
{"id": "fvapps_004507", "vc-description": "", "vc-preamble": "def List.sumLength (l: List (List α)) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x.length + xs.sumLength", "vc-helpers": "", "vc-definitions": "def String.hasPattern (s pattern: String) : Prop :=\nsorry\n\ndef String.hasSuffix (s suffix: String) : Prop :=\nsorry\n\ndef nkotb_vs_homie (reqs: List (List String)) : List String :=\nsorry", "vc-theorems": "theorem response_count (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  : (nkotb_vs_homie reqs).length = (reqs.sumLength + 1) :=\nsorry\n\ntheorem responses_end_with_homie (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  (result := nkotb_vs_homie reqs)\n  (i: Fin result.length)\n  (h3: i.val < reqs.sumLength)\n  : (result.get ⟨i.val, i.isLt⟩).hasSuffix \"! Homie dont play that!\" :=\nsorry\n\ntheorem summary_contains_sections (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  (result := nkotb_vs_homie reqs)\n  (h3: reqs.sumLength < result.length)\n  : let summary := result.get ⟨reqs.sumLength, h3⟩\n    summary.hasPattern \"monitoring objections\" ∧\n    summary.hasPattern \"automation\" ∧\n    summary.hasPattern \"deployment pipeline\" ∧\n    summary.hasPattern \"cloud\" ∧\n    summary.hasPattern \"microservices\" :=\nsorry\n\ntheorem empty_categories_response\n  (empty_reqs: List (List String))\n  (h1: empty_reqs = [[], [], [], [], []])\n  : nkotb_vs_homie empty_reqs = [\"0 monitoring objections, 0 automation, 0 deployment pipeline, 0 cloud, and 0 microservices.\"] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval nkotb_vs_homie [[\"We need Monitoring now!\"], [\"We need Automation now!\"], [\"We need Deployment now!\"], [\"We need Cloud now!\"], [\"We need Microservices now!\"]]"}
{"id": "fvapps_004519", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def length_sup_u_k (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef comp (n : Nat) : Nat :=\n  sorry\n\ndef u1 : List Nat :=\n  sorry", "vc-theorems": "theorem length_sup_u_k_bounds (n k : Nat) (h : n > 0) :\n  0 ≤ length_sup_u_k n k ∧ length_sup_u_k n k ≤ n :=\nsorry\n\ntheorem comp_bounds (n : Nat) (h : n > 1) :\n  0 ≤ comp n ∧ comp n ≤ n - 1 :=\nsorry\n\ntheorem comp_deterministic (n : Nat) :\n  comp n = comp n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval length_sup_u_k 23 12\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval length_sup_u_k 50 10\n\n/-\ninfo: 304\n-/\n#guard_msgs in\n#eval length_sup_u_k 500 100\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval comp 23\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval comp 100\n\n/-\ninfo: 63\n-/\n#guard_msgs in\n#eval comp 200"}
{"id": "fvapps_004522", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxLen : Nat :=\nsorry\n\ndef sum_squares (n : Nat) : Nat :=\nsorry\n\ndef square_pi (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem square_pi_monotone {n₁ n₂ : Nat} (h : n₁ ≤ n₂) (h2 : n₂ ≤ maxLen) :\n  square_pi n₁ ≤ square_pi n₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval square_pi 1\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval square_pi 3\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval square_pi 5"}
{"id": "fvapps_004524", "vc-description": "-- Apps difficulty: introductory\n\n-- Assurance level: unguarded", "vc-preamble": "def add : Int → Int → Int := fun a b => a + b\n\ndef sub : Int → Int → Int := fun a b => a - b\n\ndef mul : Int → Int → Int := fun a b => a * b\n\ndef div : Int → Int → Int := fun a b => a / b\n\naxiom placeholder_identity (args : List Int) (h : args.length > 0) :\n  x args = args.head!\n\naxiom placeholder_binary_ops_forward (a b : Int) :\n  (add (x [a]) b) = add a b ∧\n  (sub (x [a]) b) = sub a b ∧\n  (mul (x [a]) b) = mul a b\n\naxiom placeholder_binary_ops_reverse (a b : Int) :\n  add b (x [a]) = add b a ∧\n  sub b (x [a]) = sub b a ∧\n  mul b (x [a]) = mul b a\n\naxiom placeholder_binary_ops_div (a b : Int) :\n  b ≠ 0 → div (x [a]) b = div a b\n\naxiom placeholder_binary_ops_div_reverse (a b : Int) :\n  a ≠ 0 → div b (x [a]) = div b a\n\naxiom placeholder_chaining (args : List Int) (h : args.length > 1) :\n  add (x [args.head!]) (x [args.tail.head!]) = add args.head! args.tail.head! ∧\n  mul (x [args.head!]) (x [args.tail.head!]) = mul args.head! args.tail.head! ∧\n  add (x [args.head!]) (mul 2 (x [args.tail.head!])) = add args.head! (mul 2 args.tail.head!)\n\naxiom placeholder_constant_folding (a : Int) :\n  add (add 2 3) (x [a]) = add 5 a ∧\n  add (mul 2 3) (x [a]) = add 6 a", "vc-helpers": "", "vc-definitions": "def x : List Int → Int :=\nsorry", "vc-theorems": "", "vc-postamble": ""}
{"id": "fvapps_004527", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def poly_derivative (p : List Int) : List Int :=\n  sorry\n\ndef scaleList (k : Int) (xs : List Int) : List Int :=\n  sorry\n\ndef zeroList (n : Nat) : List Int :=\n  sorry", "vc-theorems": "theorem derivative_length {p : List Int} (h : p ≠ []) :\n  (poly_derivative p).length = p.length - 1 :=\nsorry\n\ntheorem derivative_constant {p : List Int} (h : p.length = 1) :\n  poly_derivative p = [] :=\nsorry\n\ntheorem derivative_linear {p : List Int} (h : p.length ≥ 2) :\n  (poly_derivative p).get! 0 = p.get! 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2]\n\n/-\ninfo: [1, 6]\n-/\n#guard_msgs in\n#eval poly_derivative [9, 1, 3]\n\n/-\ninfo: [2, 6, 12]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2, 3, 4]"}
{"id": "fvapps_004529", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def GradeString : Type := String\nderiving Inhabited\n\ndef grade_val (v : GradeString) : Int :=\n  sorry\n\ndef sort_grades (grades : List GradeString) : List GradeString :=\n  sorry", "vc-theorems": "theorem sort_preserves_size (grades : List GradeString) :\n  List.length (sort_grades grades) = List.length grades :=\nsorry\n\ntheorem sort_preserves_elements (grades : List GradeString) (g : GradeString) :\n  g ∈ grades ↔ g ∈ sort_grades grades :=\nsorry\n\ntheorem sort_is_ordered (grades : List GradeString) :\n  ∀ i : Nat, i + 1 < List.length (sort_grades grades) →\n  grade_val (List.get! (sort_grades grades) i) ≤\n  grade_val (List.get! (sort_grades grades) (i + 1)) :=\nsorry\n\ntheorem empty_list_sort :\n  sort_grades [] = [] :=\nsorry\n\ntheorem sort_idempotent (grades : List GradeString) :\n  sort_grades (sort_grades grades) = sort_grades grades :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval sort_grades []\n\n/-\ninfo: ['VB', 'V0', 'V1', 'V3']\n-/\n#guard_msgs in\n#eval sort_grades [\"V1\", \"VB\", \"V3\", \"V0\"]\n\n/-\ninfo: ['V0+', 'V1', 'V2']\n-/\n#guard_msgs in\n#eval sort_grades [\"V0+\", \"V2\", \"V1\"]"}
{"id": "fvapps_004534", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitSum (n : Nat) : Nat :=\n  sorry\n\ndef countComfortablePairs (l r : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem window_size (start : Nat) (window : Nat)\n  (h1 : start ≥ 1) (h2 : start ≤ 100) (h3 : window ≥ 0) (h4 : window ≤ 10) :\n  let result := countComfortablePairs start (start + window)\n  result ≥ 0 ∧ result ≤ (window + 1) * window / 2 :=\nsorry\n\ntheorem single_number (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 1000) :\n  countComfortablePairs n n = 0 :=\nsorry\n\ntheorem pairs_symmetry (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 100) :\n  let allPairs := countComfortablePairs 1 n\n  allPairs ≥ 0 ∧ allPairs ≤ n * 2 :=\nsorry\n\ntheorem small_ranges :\n  countComfortablePairs 1 1 = 0 ∧\n  countComfortablePairs 1 2 ≥ 0 ∧\n  countComfortablePairs 9 10 ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 10 12\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 1 9\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 13 13"}
{"id": "fvapps_004535", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count (s : String) (pattern : String) : Nat :=\n  sorry\n\ndef SENTENCE : String :=\n  sorry\n\ndef SYLLABLE : String :=\n  sorry\n\ndef flesch_kincaid (text : String) : Float :=\n  sorry", "vc-theorems": "theorem flesch_kincaid_result_is_float (text : String) (h : text.length > 0) :\n  ∃ (f : Float), flesch_kincaid text = f :=\nsorry\n\ntheorem flesch_kincaid_count_properties (text : String)\n  (h₁ : text.length > 0)\n  (h₂ : count text SENTENCE = 1) :\n  let words := count text \" \" + 1\n  let sentences := count text SENTENCE\n  let syllables := count text SYLLABLE\n  words ≥ 1 ∧\n  sentences = 1 ∧\n  syllables ≥ 0 ∧\n  syllables ≤ text.length :=\nsorry\n\ntheorem syllable_counting_vowels_only (text : String)\n  (h₁ : text.length > 0)\n  (h₂ : ∀ c ∈ text.data, c ∈ ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']) :\n  let syllables := count text SYLLABLE\n  syllables ≥ 1 ∧ syllables ≤ text.length :=\nsorry\n\ntheorem flesch_kincaid_is_finite (words : List String)\n  (h : words.length > 0)\n  (h₂ : ∀ w ∈ words, w.length > 0)\n  (h₃ : ∀ w ∈ words, ∀ c ∈ w.data, c.isLower) :\n  let sentence := String.intercalate \" \" words ++ \".\"\n  ∃ (result : Float), flesch_kincaid sentence = result :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3.67\n-/\n#guard_msgs in\n#eval flesch_kincaid \"The turtle is leaving.\"\n\n/-\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Hi there.\"\n\n/-\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Go home.\""}
{"id": "fvapps_004553", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_num (n : Nat) : Nat :=\nsorry\n\ndef countDigits (n : Nat) : Nat :=\nsorry\n\ndef natToString (n : Nat) : String :=\nsorry", "vc-theorems": "theorem get_num_zero : get_num 0 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval get_num 123\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval get_num 6609\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval get_num 8888"}
{"id": "fvapps_004555", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_very_even_number (n : Nat) : Bool :=\nsorry\n\ndef digitSum (n : Nat) : Nat :=\nsorry\n\ndef singleDigitSum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem very_even_single_digit (n : Nat) :\n  n < 10 → is_very_even_number n = (n % 2 = 0) :=\nsorry\n\ntheorem very_even_digit_sum (n : Nat) :\n  is_very_even_number n = (singleDigitSum n % 2 = 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_very_even_number 88\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 222\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 841"}
{"id": "fvapps_004557", "vc-description": "", "vc-preamble": "def sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def spread {α β : Type u} (f : α → β) (args : List α) : β :=\n  sorry", "vc-theorems": "theorem spread_matches_direct_call {α β : Type u} (f : α → β) (x : α) :\n  spread f [x] = f x :=\nsorry\n\ntheorem spread_list_sum (nums : List Nat) :\n  spread (fun xs => sum xs) [nums] = sum nums :=\nsorry\n\ntheorem spread_concat_strings (strings : List String) :\n  spread (fun args => String.join args) [strings] = String.join strings :=\nsorry\n\ntheorem spread_empty_unit (f : Unit → Option α) :\n  spread f [] = f () :=\nsorry\n\ntheorem spread_single_identity :\n  spread (fun x:Nat => x) [42] = 42 :=\nsorry\n\ntheorem spread_too_many_args_fails :\n  ¬(∃ (res:Nat), spread (fun x:Nat => x) [1, 2] = res) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval spread lambda x, y: x + y [2, 3]\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval spread lambda x, y, z: x + y + z [\"a\", \"b\", \"c\"]\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval spread lambda: 42 []"}
{"id": "fvapps_004562", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def VALID_COLORS := [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]\n\nstructure Game where\n  solution : List String := []\n  tries : Nat := 0\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def Game.check (g : Game) (guess : List String) : List String :=\nsorry\n\ndef matches_result (code guess result : List String) : Bool :=\nsorry\n\ndef mastermind (g : Game) : Unit :=\nsorry", "vc-theorems": "theorem mastermind_always_solves {solution : List String}\n  (h1 : solution.length = 4)\n  (h2 : ∀ x ∈ solution, x ∈ VALID_COLORS) :\n  ∀ g : Game, g.solution = solution → g.tries ≤ 60 :=\nsorry\n\ntheorem matches_result_symmetric {code guess : List String}\n  (h1 : code.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ code, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result code guess (List.replicate 4 \"Black\") =\n  matches_result guess code (List.replicate 4 \"Black\") :=\nsorry\n\ntheorem matches_result_self {guess : List String}\n  (h1 : guess.length = 4)\n  (h2 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result guess guess (List.replicate 4 \"Black\") = true :=\nsorry\n\ntheorem game_check_invalid_inputs (g : Game) :\n  (∀ guess : List String, guess.length ≠ 4 → g.check guess = []) ∧\n  (∀ guess : List String, (∃ x ∈ guess, x ∉ VALID_COLORS) → g.check guess = []) ∧\n  (g.tries ≥ 60 → ∀ guess : List String, g.check guess = []) :=\nsorry\n\ntheorem check_result_length {solution guess : List String}\n  (h1 : solution.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ solution, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS)\n  (g : Game)\n  (h5 : g.solution = solution) :\n  let result := g.check guess\n  (result.length ≤ 4 ∧ ∀ x ∈ result, x = \"Black\" ∨ x = \"White\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004572", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime : Nat → Bool :=\nsorry\n\ndef reverse : Nat → Nat :=\nsorry\n\ndef backwards_prime : Nat → Nat → List Nat :=\nsorry", "vc-theorems": "theorem backwards_prime_empty_range :\n  backwards_prime 1 0 = [] ∧\n  backwards_prime 0 1 = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [13, 17, 31, 37, 71, 73, 79, 97]\n-/\n#guard_msgs in\n#eval backwards_prime 2 100\n\n/-\ninfo: [9923, 9931, 9941, 9967]\n-/\n#guard_msgs in\n#eval backwards_prime 9900 10000\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval backwards_prime 501 599"}
{"id": "fvapps_004573", "vc-description": "/- The function correctly encodes basic ASCII characters -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The function handles multiple characters correctly -/\n\n/- The length of output matches the number of separators plus one -/\n\n/- The output only contains printable ASCII characters -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def okkOokOo (s : String) : String :=\n  sorry", "vc-theorems": "theorem basic_ascii_encoding (input : String) :\n  okkOokOo \"Ok, Ook, Ooo!\" = \"H\" :=\nsorry\n\ntheorem multiple_char_encoding :\n  okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\" = \"He\" :=\nsorry\n\ntheorem length_matches_separators :\n  String.length (okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\") = 2 :=\nsorry\n\ntheorem output_is_printable_ascii (s : String) (c : Char) :\n  c ∈ (okkOokOo s).data →\n  32 ≤ c.toNat ∧ c.toNat ≤ 126 :=\nsorry", "vc-postamble": "/-\ninfo: 'H'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo!\"\n\n/-\ninfo: 'Hello'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo?  Okk, Ook, Ok?  Okk, Okk, Oo?  Okk, Okk, Oo?  Okk, Okkkk!\"\n\n/-\ninfo: 'World!'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ok, Okkk?  Okk, Okkkk?  Okkk, Ook, O?  Okk, Okk, Oo?  Okk, Ook, Oo?  Ook, Ooook!\""}
{"id": "fvapps_004576", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def new_avg (donations : List Int) (targetAvg : Int) : Option Int :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem new_avg_type_and_positive (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  r > 0 :=\nsorry\n\ntheorem new_avg_achieves_target (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  ((list_sum donations + r) / (donations.length + 1) - targetAvg).natAbs < 1 :=\nsorry\n\ntheorem new_avg_none_when_negative (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  (donations.length + 1) * targetAvg - list_sum donations ≤ 0 →\n  new_avg donations targetAvg = none :=\nsorry\n\ntheorem new_avg_positive_large_target (donations : List Int) (maxDonation : Int) :\n  donations ≠ [] →\n  (∀ d ∈ donations, d ≥ 0 ∧ d ≤ maxDonation) →\n  let targetAvg := maxDonation + 100\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  r > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 149\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 30\n\n/-\ninfo: 645\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 92"}
{"id": "fvapps_004577", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f : List (List Int) → List (List Int) :=\nsorry\n\ndef g : List (List Int) → List (List Int) :=\nsorry\n\ndef perform : String → String :=\nsorry", "vc-theorems": "theorem f_g_inverse {matrix : List (List Int)} (h1 : matrix.length > 0)\n  (h2 : ∀ row ∈ matrix, row.length > 0)\n  (h3 : ∀ row ∈ matrix, row.length = matrix.head!.length) :\n  f (g matrix) = matrix :=\nsorry\n\ntheorem perform_maintains_valid_colors (sequence : String) :\n  ∀ c, c.toString ∈ (perform sequence).data.map toString →\n  c = 'y' ∨ c = 'g' ∨ c = 'b' ∨ c = 'o' ∨ c = 'r' ∨ c = 'w' :=\nsorry\n\ntheorem perform_F_move :\n  perform \"F\" = \"yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww\" :=\nsorry\n\ntheorem perform_F2_move :\n  perform \"F2\" = \"yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww\" :=\nsorry\n\ntheorem perform_F_prime_move :\n  perform \"F'\" = \"yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\n\n/-\ninfo: 'yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww'\n-/\n#guard_msgs in\n#eval perform \"F2\"\n\n/-\ninfo: 'yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\""}
{"id": "fvapps_004587", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_ranks (ranks: List String) : List String :=\nsorry\n\ndef is_valid_version (s: String) : Bool :=\nsorry\n\ndef loose_version_le (v1 v2: String) : Bool :=\nsorry", "vc-theorems": "theorem sort_ranks_maintains_elements (ranks: List String)\n  (h: ∀ x ∈ ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  ∀ x, (x ∈ ranks ↔ x ∈ sorted) ∧\n  sorted.length = ranks.length :=\nsorry\n\ntheorem sort_ranks_ordering (ranks: List String)\n  (h1: ranks.length ≥ 2)\n  (h2: ∀ x ∈ ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  ∀ (i: Nat) (h: i + 1 < sorted.length),\n    loose_version_le (sorted[i]'(Nat.lt_of_lt_of_le (Nat.lt_succ_self i) (Nat.le_of_lt h)))\n                    (sorted[i+1]'h) :=\nsorry\n\ntheorem sort_ranks_idempotent (ranks: List String)\n  (h: ∀ x ∈ ranks, is_valid_version x) :\n  sort_ranks (sort_ranks ranks) = sort_ranks ranks :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_ranks [\"2\", \"1\", \"1.1\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_ranks [\"3.1\", \"1\", \"1.1\", \"2\", \"3\", \"1.2\", \"3.2\", \"1.2.1\", \"3.1.1\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_ranks [\"3\", \"2\", \"1\"]"}
{"id": "fvapps_004589", "vc-description": "-- Apps difficulty: introductory\n\n-- Assurance level: unguarded\n\n/-\ninfo: 'dcba\\nhgfe\\nlkji\\nponm'\n-/\n\n/-\ninfo: 'mnop\\nijkl\\nefgh\\nabcd'\n-/\n\n/-\ninfo: 'ba\\ndc'\n-/\n\n/-\ninfo: 'cd\\nab'\n-/", "vc-preamble": "def all_lines_reversed (orig result : List String) : Prop :=\n  ∀ i, i < orig.length → result.get! i = reverse_string (orig.get! i)\n\ndef line_lengths_preserved (orig result : List String) : Prop :=\n  ∀ i, i < orig.length → (orig.get! i).length = (result.get! i).length\n\naxiom vert_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper vert_mirror s) '\\n'\n  lines.length = result_lines.length ∧\n  all_lines_reversed lines result_lines ∧\n  line_lengths_preserved lines result_lines\n\naxiom hor_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper hor_mirror s) '\\n'\n  lines.length = result_lines.length ∧\n  result_lines = List.reverse lines\n\naxiom vert_mirror_involution (s : String) :\n  oper vert_mirror (oper vert_mirror s) = s\n\naxiom hor_mirror_involution (s : String) :\n  oper hor_mirror (oper hor_mirror s) = s\n\n#guard_msgs in\n#eval oper vert_mirror \"abcd\\nefgh\\nijkl\\nmnop\"\n\n#guard_msgs in\n#eval oper hor_mirror s1\n\n#guard_msgs in\n#eval oper vert_mirror \"ab\\ncd\"\n\n#guard_msgs in\n#eval oper hor_mirror s2", "vc-helpers": "", "vc-definitions": "def split (s : String) (c : Char) : List String :=\nsorry\n\ndef vert_mirror (s : String) : String :=\nsorry\n\ndef hor_mirror (s : String) : String :=\nsorry\n\ndef oper (f : String → String) (s : String) : String :=\nsorry\n\ndef reverse_string (s : String) : String :=\nsorry", "vc-theorems": "", "vc-postamble": ""}
{"id": "fvapps_004592", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def john (n : Nat) : List Nat :=\nsorry\n\ndef ann (n : Nat) : List Nat :=\nsorry\n\ndef sum_john (n : Nat) : Nat :=\nsorry\n\ndef sum_ann (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem sequences_start_correctly {n : Nat} (h : n > 0) :\n  (john n).get ⟨0, sorry⟩ = 0 ∧ (ann n).get ⟨0, sorry⟩ = 1 :=\nsorry\n\ntheorem sequence_lengths {n : Nat} (h : n > 0) :\n  (john n).length = n ∧ (ann n).length = n :=\nsorry\n\ntheorem sequences_nonnegative {n : Nat} (h : n > 0) :\n  (∀ x ∈ john n, x ≥ 0) ∧ (∀ x ∈ ann n, x ≥ 0) :=\nsorry\n\ntheorem sum_functions_match {n : Nat} (h : n > 0) :\n  sum_john n = ((john n).foldl (· + ·) 0) ∧\n  sum_ann n = ((ann n).foldl (· + ·) 0) :=\nsorry\n\ntheorem sequence_relationship {n : Nat} (h : n > 0) :\n  ∀ i : Nat, i < n → i > 0 →\n    ((john n).get ⟨i, sorry⟩ = i - (ann n).get ⟨(john n).get ⟨i-1, sorry⟩, sorry⟩) ∧\n    ((ann n).get ⟨i, sorry⟩ = i - (john n).get ⟨(ann n).get ⟨i-1, sorry⟩, sorry⟩) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]\n-/\n#guard_msgs in\n#eval john 11\n\n/-\ninfo: [1, 1, 2, 2, 3, 3]\n-/\n#guard_msgs in\n#eval ann 6\n\n/-\ninfo: 1720\n-/\n#guard_msgs in\n#eval sum_john 75\n\n/-\ninfo: 6930\n-/\n#guard_msgs in\n#eval sum_ann 150"}
{"id": "fvapps_004595", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_number_of_squares (n : Int) : Nat :=\n  sorry\n\ndef sum_squares (n : Nat) : Int :=\n  sorry\n\ndef next_square (n : Nat) : Int :=\n  sorry", "vc-theorems": "theorem known_sequence_values :\n  (get_number_of_squares 1 = 0) ∧\n  (get_number_of_squares 2 = 1) ∧\n  (get_number_of_squares 6 = 2) ∧\n  (get_number_of_squares 15 = 3) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_number_of_squares 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_number_of_squares 15\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval get_number_of_squares 100"}
{"id": "fvapps_004596", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def circularly_sorted (xs : List Int) : Bool :=\n  sorry\n\ndef isSorted (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem sorted_is_circular {xs : List Int} (h : xs.length > 0) :\n  isSorted xs → circularly_sorted xs = true :=\nsorry\n\ntheorem rotated_sorted_is_circular {xs : List Int} (h : xs.length > 0) (distinct : List.Nodup xs) :\n  ∀ i, i < xs.length → circularly_sorted (List.drop i xs ++ List.take i xs) = true :=\nsorry\n\ntheorem singleton_is_circular {x : Int} :\n  circularly_sorted [x] = true :=\nsorry\n\ntheorem empty_raises {xs : List Int} (h : xs.length = 0) :\n  circularly_sorted xs = false :=\nsorry\n\ntheorem unsorted_not_circular {xs : List Int} (h : xs.length > 1)\n  (not_sorted : ∀ i, i < xs.length → ¬(isSorted (List.drop i xs ++ List.take i xs))) :\n  circularly_sorted xs = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [2, 3, 4, 5, 0, 1]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [1, 2, 3, 4, 5]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circularly_sorted [4, 1, 2, 5]"}
{"id": "fvapps_004612", "vc-description": "-- Result is a natural number\n\n-- Result is bounded by factorial of total elements", "vc-preamble": "def factorial (n: Nat) : Nat :=\n  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def count_perms (matrix: List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem count_perms_single_element :\n  count_perms [[1]] = 1 := by\nsorry\n\ntheorem count_perms_dimensions_preserved {m n: Nat} (matrix: List (List Nat))\n  (h1: matrix.length = m)\n  (h2: ∀ row ∈ matrix, row.length = n) :\n  let result := count_perms matrix\n\n  0 < result ∧\n\n  result ≤ factorial (m * n) := by\nsorry\n\ntheorem count_perms_all_same {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_perms matrix = 1 := by\nsorry\n\ntheorem count_perms_all_different {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.map (fun i =>\n    List.map (fun j => i * n + j + 1) (List.range n)\n  ) (List.range m)\n  count_perms matrix = factorial (m * n) := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 360\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [3, 4, 5]]\n\n/-\ninfo: 1260\n-/\n#guard_msgs in\n#eval count_perms [[1, 1, 1], [2, 2, 3], [3, 3, 3]]\n\n/-\ninfo: 362880\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}
{"id": "fvapps_004618", "vc-description": "", "vc-preamble": "def dateCompare (d1 m1 y1 d2 m2 y2 : Int) : Bool :=\n  if y1 ≠ y2 then y1 > y2\n  else if m1 ≠ m2 then m1 > m2\n  else d1 > d2", "vc-helpers": "", "vc-definitions": "def days_until (date month year : Int) : Int :=\n  sorry\n\ndef isValidDate (date month year : Int) : Bool :=\n  sorry\n\ndef dateDiffDays (d1 m1 y1 d2 m2 y2 : Int) : Int :=\n  sorry", "vc-theorems": "theorem days_until_is_int {date month year : Int}\n  (h : isValidDate date month year = true) :\n  ∃ n : Int, days_until date month year = n :=\nsorry\n\ntheorem days_until_target_date {date month year : Int}\n  (h1 : date = 24)\n  (h2 : month = 3)\n  (h3 : year = 2437) :\n  days_until date month year = 0 :=\nsorry\n\ntheorem days_until_future_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare date month year 24 3 2437 = true) :\n  days_until date month year < 0 :=\nsorry\n\ntheorem days_until_past_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare 24 3 2437 date month year = true) :\n  days_until date month year > 0 :=\nsorry\n\ntheorem days_until_symmetry {date month year : Int}\n  (h : isValidDate date month year = true) :\n  days_until date month year = dateDiffDays year month date 2437 3 24 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval days_until 21 3 2437\n\n/-\ninfo: 365\n-/\n#guard_msgs in\n#eval days_until 24 3 2436\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval days_until 24 2 2437"}
{"id": "fvapps_004627", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binary_gcd (x y : Int) : Nat :=\n  sorry\n\ndef popCount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem binary_gcd_matches_gcd (x y : Int) :\n  binary_gcd x y = popCount (Int.gcd x y) :=\nsorry\n\ntheorem binary_gcd_symmetric_same (n : Int) :\n  binary_gcd n n = binary_gcd n (-n) :=\nsorry\n\ntheorem binary_gcd_symmetric_zero (n : Int) :\n  binary_gcd n 0 = binary_gcd 0 n :=\nsorry\n\ntheorem binary_gcd_positive_bounds (x y : Int) (hx : x > 0) (hy : y > 0) :\n  let result := binary_gcd x y\n  0 ≤ result ∧ result ≤ max x.natAbs.log2 y.natAbs.log2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval binary_gcd 300 45\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_gcd 0 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval binary_gcd -8 12"}
{"id": "fvapps_004636", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (n : Int) (d : Int) : String :=\nsorry\n\ndef toDecimal (n : Int) (d : Int) : Float :=\nsorry\n\ndef intToFloat (i : Int) : Float :=\nsorry\n\ndef stringToFloat (s : String) : Float :=\nsorry", "vc-theorems": "theorem sign_property (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  (n * d < 0 → s.startsWith \"-\") ∧\n  (n * d > 0 → ¬s.startsWith \"-\") :=\nsorry\n\ntheorem format_property (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  let parts := (s.dropWhile (·=='-')).splitOn \" \"\n  match parts with\n  | [p] =>\n    if p.any (·=='/') then\n      let nums := p.splitOn \"/\"\n      nums.length = 2 ∧\n      nums[0]!.all Char.isDigit ∧\n      nums[1]!.all Char.isDigit\n    else\n      p.all Char.isDigit\n  | [whole, frac] =>\n    whole.all Char.isDigit ∧\n    let fracParts := frac.splitOn \"/\"\n    fracParts.length = 2 ∧\n    fracParts[0]!.all Char.isDigit ∧\n    fracParts[1]!.all Char.isDigit ∧\n    fracParts[0]!.toNat! < fracParts[1]!.toNat!\n  | _ => False :=\nsorry\n\ntheorem decimal_conversion (n d : Int) (h : d ≠ 0) :\n  toDecimal n d = (intToFloat n / intToFloat d) :=\nsorry\n\ntheorem string_matches_value (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  let val :=\n    if s.any (·==' ') then\n      let parts := (s.dropWhile (·=='-')).splitOn \" \"\n      let whole := intToFloat parts[0]!.toInt!\n      let fracParts := (parts[1]!.splitOn \"/\")\n      let num := intToFloat fracParts[0]!.toInt!\n      let den := intToFloat fracParts[1]!.toInt!\n      whole + (num / den)\n    else if s.any (·=='/') then\n      let parts := (s.dropWhile (·=='-')).splitOn \"/\"\n      (intToFloat parts[0]!.toInt!) / (intToFloat parts[1]!.toInt!)\n    else\n      stringToFloat s\n  toDecimal n d = (if s.startsWith \"-\" then -val else val) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004638", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def html_end_tag_by_start_tag (start_tag: String) : String :=\n  sorry\n\ndef is_valid_tag_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_tag_first_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_attr_name_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_attr_value_char (c: Char) : Bool :=\n  sorry", "vc-theorems": "theorem html_end_tag_starts_with_close : ∀ (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).startsWith \"</\" = true :=\nsorry\n\ntheorem html_end_tag_ends_with_angle : ∀ (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).endsWith \">\" = true :=\nsorry\n\ntheorem html_end_tag_matches_start : ∀ (start_tag : String),\n  let start_name := (start_tag.drop 1).splitOn \" \" |>.head!.dropRight 1\n  let end_name := (html_end_tag_by_start_tag start_tag).drop 2 |>.dropRight 1\n  start_name = end_name :=\nsorry\n\ntheorem html_end_tag_no_attributes : ∀ (start_tag : String),\n  ¬(html_end_tag_by_start_tag start_tag).contains ' ' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '</i>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<i>\"\n\n/-\ninfo: '</button>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<button type=\"button\" disabled>\"\n\n/-\ninfo: '</div>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<div class=\"main\" id=\"content\" style=\"width:100px\">\""}
{"id": "fvapps_004644", "vc-description": "/- Helper function to convert strings to a list containing each character -/", "vc-preamble": "def stringToList (s : String) : List Char := s.data\n\ndef stringContains (s₁ s₂ : String) : Prop := ∃ pre post : String, s₁ = pre ++ s₂ ++ post", "vc-helpers": "", "vc-definitions": "def min_special_mult (numbers : List Int) : Int ⊕ String :=\nsorry\n\ndef parseAsInt (s : String) : Option Int :=\nsorry", "vc-theorems": "theorem valid_numbers_only (numbers : List Int)\n  (h : ∀ n ∈ numbers, n > 0)\n  : ∃ result, (min_special_mult numbers = Sum.inl result ∧ result > 0) :=\nsorry\n\ntheorem invalid_entries (valid_nums invalid_nums : List String)\n  (h1 : invalid_nums.length > 0)\n  (h2 : invalid_nums.length ≤ 5)\n  (h3 : ∀ n ∈ invalid_nums, ∃ c ∈ (stringToList n), c.isAlpha ∨ c ∈ ['&', '$', '#', '@'])\n  (h4 : ∀ n ∈ valid_nums, (parseAsInt n).isSome)\n  : let valid_int_nums := valid_nums.filterMap parseAsInt\n    ∃ result : String,\n    (min_special_mult valid_int_nums = Sum.inr result)\n    ∧ (stringContains result (toString invalid_nums.length))\n    ∧ (∀ inv ∈ invalid_nums, stringContains result inv) :=\nsorry\n\ntheorem lcm_properties (numbers : List Int)\n  (h1 : numbers.length ≥ 2)\n  (h2 : numbers.length ≤ 5)\n  (h3 : ∀ n ∈ numbers, n > 0)\n  : ∃ result, min_special_mult numbers = Sum.inl result\n      ∧ ∀ n ∈ numbers, result % n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 420\n-/\n#guard_msgs in\n#eval min_special_mult [2, 3, 4, 5, 6, 7]\n\n/-\ninfo: \"There are 2 invalid entries: ['a', '&']\"\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"a\", \"&\", \"12\"]\n\n/-\ninfo: 5520\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"-012\"]"}
{"id": "fvapps_004645", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (s : String) : Bool :=\n  sorry\n\ndef nato (s : String) : String :=\n  sorry", "vc-theorems": "theorem nato_output_format {s : String}\n  (h : s.all (fun c => c.isAlpha)) :\n  let result := nato s\n  let words := result.split (· = ' ')\n  (∀ w ∈ words, isAlpha w ∨ w.contains '-') ∧\n  words.length = s.length :=\nsorry\n\ntheorem nato_case_insensitive {s : String}\n  (h : s.all (fun c => 'A' ≤ c ∧ c ≤ 'Z')) :\n  nato s = nato s.toUpper :=\nsorry\n\ntheorem nato_valid_codes {s : String}\n  (h : s.all (fun c => 'A' ≤ c ∧ c ≤ 'Z')) :\n  let natoWords := [\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\",\n                   \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\",\n                   \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\",\n                   \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\",\n                   \"Uniform\", \"Victor\", \"Whiskey\", \"X-ray\",\n                   \"Yankee\", \"Zulu\"]\n  let result := nato s\n  ∀ w ∈ result.split (· = ' '), w ∈ natoWords :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bravo Alpha November Alpha November Alpha'\n-/\n#guard_msgs in\n#eval nato \"Banana\"\n\n/-\ninfo: 'Hotel India'\n-/\n#guard_msgs in\n#eval nato \"Hi\"\n\n/-\ninfo: 'Alpha Bravo Charlie'\n-/\n#guard_msgs in\n#eval nato \"ABC\""}
{"id": "fvapps_004650", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.choose (n k : Nat) : Nat :=\nsorry\n\ndef List.sort (l : List Nat) : List Nat :=\nsorry\n\ndef transform (arr : List Nat) (x : Nat) : Nat :=\nsorry", "vc-theorems": "theorem transform_single_element (n x : Nat) (h : x ≤ n) :\n  transform [n] x = (List.range (n - x + 1)).foldl (fun acc i => acc + Nat.choose (i + x) x) 0 :=\nsorry\n\ntheorem transform_shuffle (arr : List Nat) (x : Nat) (h : ∀ n ∈ arr, n ≥ x) :\n  transform arr x = transform (List.sort arr) x :=\nsorry\n\ntheorem transform_zero_x (arr : List Nat) :\n  transform arr 0 = List.foldl (fun acc n => acc + (n + 1)) 0 arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 384\n-/\n#guard_msgs in\n#eval transform [7, 4, 11, 6, 5] 3\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval transform [5, 6, 7] 2\n\n/-\ninfo: 462\n-/\n#guard_msgs in\n#eval transform [10] 5"}
{"id": "fvapps_004652", "vc-description": "-- Number of different squares is always positive and has an upper bound\n\n-- A matrix filled with same value has exactly 1 unique square\n\n-- Rotating a matrix preserves number of unique squares", "vc-preamble": "def Matrix := List (List Nat)", "vc-helpers": "", "vc-definitions": "def different_squares : Matrix → Nat :=\nsorry\n\ndef rotateMatrix (m : Matrix) : Matrix :=\nsorry\n\ndef isValidMatrix (m : Matrix) : Bool :=\nsorry\n\ndef isAllValue (m : Matrix) (v : Nat) : Bool :=\nsorry", "vc-theorems": "theorem different_squares_bounds (m : Matrix) :\n  isValidMatrix m →\n  1 ≤ different_squares m ∧\n  different_squares m ≤ (m.length - 1) * ((m.head!).length - 1) :=\nsorry\n\ntheorem same_value_matrix_one_square (m : Matrix) (v : Nat) :\n  isValidMatrix m →\n  isAllValue m v →\n  different_squares m = 1 :=\nsorry\n\ntheorem different_squares_rotation_invariant (m : Matrix) :\n  isValidMatrix m →\n  different_squares m = different_squares (rotateMatrix m) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval different_squares [[1, 2, 1], [2, 2, 2], [2, 2, 2], [1, 2, 3], [2, 2, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[1, 1], [1, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[9, 9, 9], [9, 9, 9], [9, 9, 9]]"}
{"id": "fvapps_004662", "vc-description": "/-\n  lineupStudentsLengthPreserved:\n  For any list of students, the length of the output list\n  equals the length of the input list\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  lineupStudentsSorted:\n  For any two adjacent elements in the result,\n  if they have equal length then they are reverse alphabetically sorted,\n  otherwise the first is longer than the second\n-/\n\n/-\n  lineupStudentsPreservesElements:\n  The output list contains exactly the same elements as the input\n-/\n\n/-\n  lineupStudentsSingleElement:\n  A single name returns a singleton list with that name\n-/\n\n/-\n  lineupStudentsEmpty:\n  An empty string input returns an empty list\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lineup_students (input : String) : List String :=\nsorry", "vc-theorems": "theorem lineupStudentsLengthPreserved (input : String) (names : List String) :\n  names = lineup_students input →\n  (lineup_students input).length = names.length :=\nsorry\n\ntheorem lineupStudentsSorted {result : List String} (i : Nat) (h : i + 1 < result.length) :\n  let a := result[i]!\n  let b := result[i+1]!\n  (a.length = b.length → a ≥ b) ∧\n  (a.length ≠ b.length → a.length > b.length) :=\nsorry\n\ntheorem lineupStudentsPreservesElements (input : String) (names : List String) :\n  names = lineup_students input →\n  ∀ x, (x ∈ names ↔ x ∈ lineup_students input) :=\nsorry\n\ntheorem lineupStudentsSingleElement (name : String) :\n  lineup_students name = [name] :=\nsorry\n\ntheorem lineupStudentsEmpty :\n  lineup_students \"\" = [] :=\nsorry", "vc-postamble": "/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval lineup_students \"Tadashi Takahiro Takao Takashi Takayuki Takehiko Takeo Takeshi Takeshi\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval lineup_students \"xxa xxb xxc xxd xa xb xc xd\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval lineup_students \"aaa bbb ccc\""}
{"id": "fvapps_004668", "vc-description": "/- Helper function to count numbers with ascending unique digits -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- Helper function to check if digits are ascending and unique -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sel_number (n : Nat) (d : Nat) : Nat :=\n  sorry\n\ndef hasAscendingUniqueDigits (n : Nat) : Bool :=\n  sorry\n\ndef countAscendingUnique (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sel_number_non_negative (n d : Nat) :\n  sel_number n d ≥ 0 :=\nsorry\n\ntheorem sel_number_under_twelve (n d : Nat) :\n  n < 12 → sel_number n d = 0 :=\nsorry\n\ntheorem sel_number_unique_bound (n : Nat) :\n  sel_number n 0 ≤ String.length (toString n) :=\nsorry\n\ntheorem sel_number_monotonic_d (n : Nat) :\n  ∀ d₁ d₂ : Nat, d₁ ≤ d₂ → d₂ < 10 → n ≥ 12 →\n    sel_number n d₁ ≤ sel_number n d₂ :=\nsorry\n\ntheorem sel_number_monotonic_n (d n₁ n₂ : Nat) :\n  n₁ ≤ n₂ → n₁ ≥ 12 → d < 10 →\n    sel_number n₁ d ≤ sel_number n₂ d :=\nsorry", "vc-postamble": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sel_number 20 2\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sel_number 0 1\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval sel_number 50 3"}
{"id": "fvapps_004669", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def sum_list : List Float → Float\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def resistor_parallel (r : List Float) : Float :=\nsorry", "vc-theorems": "theorem parallel_resistance_positive {r : List Float} (h : ∀ x ∈ r, x > 0) :\n  resistor_parallel r > 0 :=\nsorry\n\ntheorem single_resistor_identity {r : Float} (h : r > 0) :\n  resistor_parallel [r] = r :=\nsorry\n\ntheorem parallel_symmetric {r1 r2 : Float} (h1 : r1 > 0) (h2 : r2 > 0) :\n  resistor_parallel [r1, r2] = resistor_parallel [r2, r1] :=\nsorry\n\ntheorem inverse_sum_relationship {r : List Float} (h : ∀ x ∈ r, x > 0) :\n  1 / (resistor_parallel r) = sum_list (r.map (λ x => 1/x)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004680", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitsSum (n : Nat) : Nat :=\nsorry\n\ndef is_valid (n : Nat) : Bool :=\nsorry\n\ndef get_next (n : Nat) : Nat :=\nsorry\n\ndef get_series (count start : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem harshad_property {n : Nat} (h : n > 0) (valid : is_valid n = true) :\n  n % digitsSum n = 0 :=\nsorry\n\ntheorem get_next_properties {n : Nat} :\n  let next := get_next n\n  next > n ∧\n  is_valid next = true ∧\n  ∀ x, n < x → x < next → is_valid x = false :=\nsorry\n\ntheorem get_series_properties {count start : Nat} (h : count > 0) :\n  let series := get_series count start\n  List.length series = count ∧\n  (∀ i, i + 1 < List.length series →\n    series[i]'(by sorry) < series[i+1]'(by sorry)) ∧\n  (∀ x ∈ series, x > start) ∧\n  (∀ x ∈ series, is_valid x = true) :=\nsorry\n\ntheorem next_harshad_valid {n : Nat} :\n  is_valid (get_next n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004687", "vc-description": "", "vc-preamble": "def sumList (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sumList t\n\ndef zipWithIndex {α : Type} (l : List α) : List (Nat × α) :=\n  let rec aux (i : Nat) (xs : List α) : List (Nat × α) :=\n    match xs with\n    | [] => []\n    | h :: t => (i, h) :: aux (i+1) t\n  aux 0 l", "vc-helpers": "", "vc-definitions": "def knapsack (capacity : Nat) (items : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem knapsack_result_length_matches_input\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    (knapsack capacity items).length = items.length :=\nsorry\n\ntheorem knapsack_result_nonnegative\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    ∀ x ∈ knapsack capacity items, x ≥ 0 :=\nsorry\n\ntheorem knapsack_total_size_within_capacity\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    sumList sizes ≤ capacity :=\nsorry\n\ntheorem knapsack_optimal_ratio\n    (capacity : Nat) (items : List (Nat × Nat)) (i : Nat) :\n    i < items.length →\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    let total_size := sumList sizes\n    let ratio := items[i]!.2 / items[i]!.1\n    items[i]!.1 + total_size ≤ capacity →\n    ∀ j < items.length,\n      items[j]!.2 / items[j]!.1 = 0 ∨ items[j]!.2 / items[j]!.1 < ratio :=\nsorry\n\ntheorem knapsack_zero_capacity\n    (items : List (Nat × Nat)) :\n    knapsack 0 items = List.replicate items.length 0 :=\nsorry\n\ntheorem knapsack_empty_items\n    (capacity : Nat) :\n    knapsack capacity [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[6, 9], [5, 5]]\n\n/-\ninfo: [5, 0, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[2, 3], [3, 4], [4, 5]]\n\n/-\ninfo: [0, 0]\n-/\n#guard_msgs in\n#eval knapsack 5 [[10, 2], [12, 4]]"}
{"id": "fvapps_004693", "vc-description": "/- Map Roman numerals to their decimal values -/", "vc-preamble": "def romanValues : List (Char × Nat) :=\n  [('I', 1), ('V', 5), ('X', 10), ('L', 50), ('C', 100), ('D', 500), ('M', 1000)]", "vc-helpers": "", "vc-definitions": "def solution (n : Nat) : String :=\nsorry\n\ndef isSubstring (s₁ s₂ : String) : Bool :=\nsorry\n\ndef convertToNums (s : String) : List Nat :=\nsorry", "vc-theorems": "theorem monotonically_decreasing_values (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  let numericValues := convertToNums (solution n)\n  ∀ i j, i < j → j < numericValues.length →\n    (numericValues.get ⟨i, sorry⟩) ≥ (numericValues.get ⟨j, sorry⟩) :=\nsorry\n\ntheorem valid_roman_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ∀ c, String.contains (solution n) c → c ∈ ['M', 'D', 'C', 'L', 'X', 'V', 'I'] :=\nsorry\n\ntheorem length_constraints (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  (n ≤ 3 → (solution n).length ≤ 3) ∧\n  (n ≤ 8 → (solution n).length ≤ 4) ∧\n  (n ≤ 39 → (solution n).length ≤ 6) :=\nsorry\n\ntheorem no_four_consecutive_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ¬isSubstring \"IIII\" (solution n) ∧\n  ¬isSubstring \"XXXX\" (solution n) ∧\n  ¬isSubstring \"CCCC\" (solution n) ∧\n  ¬isSubstring \"MMMM\" (solution n) :=\nsorry\n\ntheorem valid_subtractive_pairs (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ¬isSubstring \"IL\" (solution n) ∧\n  ¬isSubstring \"IC\" (solution n) ∧\n  ¬isSubstring \"ID\" (solution n) ∧\n  ¬isSubstring \"IM\" (solution n) ∧\n  ¬isSubstring \"XD\" (solution n) ∧\n  ¬isSubstring \"XM\" (solution n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'I'\n-/\n#guard_msgs in\n#eval solution 1\n\n/-\ninfo: 'MCMXC'\n-/\n#guard_msgs in\n#eval solution 1990\n\n/-\ninfo: 'MMVIII'\n-/\n#guard_msgs in\n#eval solution 2008"}
{"id": "fvapps_004696", "vc-description": "/- For any number n and text, decoding after encoding returns original text -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The first word of encoded text equals the input number n as string -/\n\n/- Empty string cases -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encode (n : Nat) (s : String) : String :=\nsorry\n\ndef decode (s : String) : String :=\nsorry", "vc-theorems": "theorem encode_decode_roundtrip (n : Nat) (text : String) :\n  decode (encode n text) = text :=\nsorry\n\ntheorem encode_starts_with_n (n : Nat) (text : String) :\n  List.get! (String.splitOn (encode n text) \" \") 0 = toString n :=\nsorry\n\ntheorem empty_string_case1 : decode (encode 5 \"\") = \"\" :=\nsorry\n\ntheorem empty_string_case2 : encode 0 \"\" = \"0 \" :=\nsorry", "vc-postamble": "/-\ninfo: solution\n-/\n#guard_msgs in\n#eval encode 10 \"If you wish to make an apple pie from scratch, you must first invent the universe.\"\n\n/-\ninfo: quote\n-/\n#guard_msgs in\n#eval decode encode(10, quote)\n\n/-\ninfo: test2\n-/\n#guard_msgs in\n#eval decode encode(3, test2)\n\n/-\ninfo: test3\n-/\n#guard_msgs in\n#eval decode encode(5, test3)"}
{"id": "fvapps_004697", "vc-description": "", "vc-preamble": "def listSum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + listSum xs\n\ndef countChar (s: String) (c: Char) : Nat :=\n  s.toList.filter (· == c) |>.length", "vc-helpers": "", "vc-definitions": "def DIRS := [('←', (0,-1)), ('↑', (-1,0)), ('→', (0,1)), ('↓', (1,0)),\n            ('↖', (-1,-1)), ('↗', (-1,1)), ('↘', (1,1)), ('↙', (1,-1))]\n\ndef count_deaf_rats (town: List String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_output_range (town: List String)\n  (h1: town.length > 0)\n  (h2: listSum (town.map (fun row => countChar row 'P')) = 1)\n  : let total_rats := listSum (town.map (fun row =>\n      listSum ((DIRS.map Prod.fst).map (fun c => countChar row c))))\n    let result := count_deaf_rats town\n    0 ≤ result ∧ result ≤ total_rats :=\nsorry\n\ntheorem empty_town :\n  count_deaf_rats [\" P \"] = 0 :=\nsorry\n\ntheorem simple_case :\n  count_deaf_rats [\"P →\", \"← ←\"] = 2 :=\nsorry\n\ntheorem all_directions :\n  let dirChars := DIRS.map Prod.fst\n  let town := [\"P \" ++ String.mk dirChars]\n  let result := count_deaf_rats town\n  0 ≤ result ∧ result ≤ DIRS.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"↗ P     \", \"  ↘   ↖\", \"  ↑     \", \"↗       \"]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"    ↗    \", \"P ↓   ↖ ↑\", \"    ←   ↓\", \"  ↖ ↙   ↙\", \"↓ ↓ ↓    \"]"}
{"id": "fvapps_004708", "vc-description": "", "vc-preamble": "def Card := List (List (Option Nat))", "vc-helpers": "", "vc-definitions": "def CalledNumber := String\n\ndef bingo (card : Card) (numbers : List CalledNumber) : Bool :=\n  sorry\n\ndef cardNumberToString (n : Option Nat) : CalledNumber :=\n  sorry", "vc-theorems": "theorem bingo_returns_boolean (card : Card) (numbers : List CalledNumber) :\n  ∃ b : Bool, bingo card numbers = b :=\nsorry\n\ntheorem free_space_is_center (card : Card) :\n  card.get? 2 >>= (·.get? 2) = some none :=\nsorry\n\ntheorem empty_calls_no_bingo (card : Card) :\n  ¬(bingo card []) :=\nsorry\n\ntheorem all_numbers_called_is_bingo (card : Card) (numbers : List CalledNumber)\n  (h : ∀ (i j : Nat), i < card.length → j < (card.get! i).length →\n       (card.get! i).get! j ≠ none →\n       cardNumberToString ((card.get! i).get! j) ∈ numbers) :\n  bingo card numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\", \"O61\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\"]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"N31\", \"N33\", \"N37\", \"N39\"]"}
{"id": "fvapps_004713", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_divisors (n: Nat) : Nat :=\n  sorry\n\ndef equal_sigma1 (nmax: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sum_divisors_positive (n: Nat) (h: n ≥ 1) :\n  let result := sum_divisors n\n  result ≥ 1 ∧ result ≥ n :=\nsorry\n\ntheorem equal_sigma1_properties (nmax: Nat) (h: nmax ≥ 1) :\n  let result := equal_sigma1 nmax\n  result ≥ 0 ∧ (nmax < 528 → result = 0) :=\nsorry\n\ntheorem sum_divisors_multiplication_property (n: Nat) (h: n ≥ 1) :\n  ∀ k : Nat,\n  let divisors := (List.range n).filterMap (fun i =>\n    if n % (i+1) = 0 then some (i+1) else none)\n  k * k = n →\n  sum_divisors n ≤ 2 * n :=\nsorry\n\ntheorem equal_sigma1_symmetry (nmax: Nat) :\n  let result := equal_sigma1 nmax\n  ∀ n, n ≥ 528 → n ≤ nmax →\n  n = 528 ∨ n = 1561 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval equal_sigma1 100\n\n/-\ninfo: 1353\n-/\n#guard_msgs in\n#eval equal_sigma1 1000\n\n/-\ninfo: 4565\n-/\n#guard_msgs in\n#eval equal_sigma1 2000"}
{"id": "fvapps_004714", "vc-description": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def isVowel (c : Char) : Bool :=\n  c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'\n\ndef WORD_LIST : List String :=\n  [\"strength\", \"afterwards\", \"background\", \"photograph\", \"successful\", \"understand\"]", "vc-helpers": "", "vc-definitions": "def wanted_words (vowel_count : Nat) (consonant_count : Nat) (forbidden : List Char) : List String :=\n  sorry", "vc-theorems": "theorem result_are_strings (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f → w.length ≥ 0\n  :=\nsorry\n\ntheorem exact_vowel_count (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  (List.filter isVowel w.data).length = v\n  :=\nsorry\n\ntheorem exact_total_length (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  w.length = v + c\n  :=\nsorry\n\ntheorem no_forbidden_chars (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  ∀ (x : Char), x ∈ f → ¬(x ∈ w.data)\n  :=\nsorry", "vc-postamble": ""}
