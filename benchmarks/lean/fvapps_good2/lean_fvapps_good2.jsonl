{"id": "fvapps_000000", "vc-description": "/-\nPolycarp has $n$ different binary words. A word called binary if it contains only characters '0' and '1'. For example, these words are binary: \"0001\", \"11\", \"0\" and \"0011100\".\n\nPolycarp wants to offer his set of $n$ binary words to play a game \"words\". In this game, players name words and each next word (starting from the second) must start with the last character of the previous word. The first word can be any. For example, these sequence of words can be named during the game: \"0101\", \"1\", \"10\", \"00\", \"00001\".\n\nWord reversal is the operation of reversing the order of the characters. For example, the word \"0111\" after the reversal becomes \"1110\", the word \"11010\" after the reversal becomes \"01011\".\n\nProbably, Polycarp has such a set of words that there is no way to put them in the order correspondent to the game rules. In this situation, he wants to reverse some words from his set so that:  the final set of $n$ words still contains different words (i.e. all words are unique);  there is a way to put all words of the final set of words in the order so that the final sequence of $n$ words is consistent with the game rules. \n\nPolycarp wants to reverse minimal number of words. Please, help him.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains one integer $n$ ($1 \\le n \\le 2\\cdot10^5$) — the number of words in the Polycarp's set. Next $n$ lines contain these words. All of $n$ words aren't empty and contains only characters '0' and '1'. The sum of word lengths doesn't exceed $4\\cdot10^6$. All words are different.\n\nGuaranteed, that the sum of $n$ for all test cases in the input doesn't exceed $2\\cdot10^5$. Also, guaranteed that the sum of word lengths for all test cases in the input doesn't exceed $4\\cdot10^6$.\n\n-----Output-----\n\nPrint answer for all of $t$ test cases in the order they appear.\n\nIf there is no answer for the test case, print -1. Otherwise, the first line of the output should contain $k$ ($0 \\le k \\le n$) — the minimal number of words in the set which should be reversed. The second line of the output should contain $k$ distinct integers — the indexes of the words in the set which should be reversed. Words are numerated from $1$ to $n$ in the order they appear. If $k=0$ you can skip this line (or you can print an empty line). If there are many answers you can print any of them.\n\n-----Example-----\nInput\n4\n4\n0001\n1000\n0011\n0111\n3\n010\n101\n0\n2\n00000\n00001\n4\n01\n001\n0001\n00001\n\nOutput\n1\n3 \n-1\n0\n\n2\n1 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) (words : List String) : List Int :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_output_structure (n : Nat) (words : List String) :\n  let result := solve n words\n  (result = [-1] ∨\n   (result.length ≥ 1 ∧\n    ∀ x ∈ result, ∃ i : Int, x = i ∧\n    let count := result[0]!\n    result.length = count + 1 ∧\n    ∀ i ∈ result.tail, 1 ≤ i ∧ i ≤ n)) :=\nsorry\n\ntheorem solve_minimal_flips (n : Nat) (words : List String) :\n  let result := solve n words\n  result ≠ [-1] →\n  let zeros_to_ones := (words.filter (λ w => w.front = '0' ∧ w.back = '1')).length\n  let ones_to_zeros := (words.filter (λ w => w.front = '1' ∧ w.back = '0')).length\n  let min_flips := (abs (zeros_to_ones - ones_to_zeros)) / 2\n  result[0]! = min_flips :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 3]\n-/\n#guard_msgs in\n#eval solve 4 [\"0001\", \"1000\", \"0011\", \"0111\"]\n\n/--\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve 3 [\"010\", \"101\", \"0\"]\n\n/--\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 2 [\"00000\", \"00001\"]"}
{"id": "fvapps_000001", "vc-description": "/-\nMikhail walks on a Cartesian plane. He starts at the point $(0, 0)$, and in one move he can go to any of eight adjacent points. For example, if Mikhail is currently at the point $(0, 0)$, he can go to any of the following points in one move:   $(1, 0)$;  $(1, 1)$;  $(0, 1)$;  $(-1, 1)$;  $(-1, 0)$;  $(-1, -1)$;  $(0, -1)$;  $(1, -1)$. \n\nIf Mikhail goes from the point $(x1, y1)$ to the point $(x2, y2)$ in one move, and $x1 \\ne x2$ and $y1 \\ne y2$, then such a move is called a diagonal move.\n\nMikhail has $q$ queries. For the $i$-th query Mikhail's target is to go to the point $(n_i, m_i)$ from the point $(0, 0)$ in exactly $k_i$ moves. Among all possible movements he want to choose one with the maximum number of diagonal moves. Your task is to find the maximum number of diagonal moves or find that it is impossible to go from the point $(0, 0)$ to the point $(n_i, m_i)$ in $k_i$ moves.\n\nNote that Mikhail can visit any point any number of times (even the destination point!).\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 10^4$) — the number of queries.\n\nThen $q$ lines follow. The $i$-th of these $q$ lines contains three integers $n_i$, $m_i$ and $k_i$ ($1 \\le n_i, m_i, k_i \\le 10^{18}$) — $x$-coordinate of the destination point of the query, $y$-coordinate of the destination point of the query and the number of moves in the query, correspondingly.\n\n-----Output-----\n\nPrint $q$ integers. The $i$-th integer should be equal to -1 if Mikhail cannot go from the point $(0, 0)$ to the point $(n_i, m_i)$ in exactly $k_i$ moves described above. Otherwise the $i$-th integer should be equal to the the maximum number of diagonal moves among all possible movements.\n\n-----Example-----\nInput\n3\n2 2 3\n4 3 7\n10 1 9\n\nOutput\n1\n6\n-1\n\n-----Note-----\n\nOne of the possible answers to the first test case: $(0, 0) \\to (1, 0) \\to (1, 1) \\to (2, 2)$.\n\nOne of the possible answers to the second test case: $(0, 0) \\to (0, 1) \\to (1, 2) \\to (0, 3) \\to (1, 4) \\to (2, 3) \\to (3, 2) \\to (4, 3)$.\n\nIn the third test case Mikhail cannot reach the point $(10, 1)$ in 9 moves.\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def solve_max_diagonal_moves (n m k : Int) : Int :=\n  sorry", "vc-theorems": "theorem result_bound (n m k : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) (h3: 0 <= k ∧ k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  r = -1 ∨ r ≤ k :=\nsorry\n\ntheorem result_parity (n m k : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) (h3: 0 <= k ∧ k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  let max_dist := max (abs n) (abs m)\n  r ≠ -1 → (r % 2 = max_dist % 2 ∨ r % 2 = (max_dist - 1) % 2) :=\nsorry\n\ntheorem insufficient_moves (n : Int) (h: 1 <= n ∧ n <= 1000) :\n  let k := abs n - 1\n  solve_max_diagonal_moves n n k = -1 :=\nsorry\n\ntheorem symmetry (n m : Int) (h: -1000 <= n ∧ n <= 1000) (h2: -1000 <= m ∧ m <= 1000) :\n  let k := max (abs n) (abs m) * 2\n  let r1 := solve_max_diagonal_moves n m k\n  let r2 := solve_max_diagonal_moves (-n) m k\n  let r3 := solve_max_diagonal_moves n (-m) k\n  let r4 := solve_max_diagonal_moves (-n) (-m) k\n  r1 = r2 ∧ r2 = r3 ∧ r3 = r4 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 2 2 3\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 4 3 7\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 10 1 9"}
{"id": "fvapps_000003", "vc-description": "/-\nYou have $n$ barrels lined up in a row, numbered from left to right from one. Initially, the $i$-th barrel contains $a_i$ liters of water.\n\nYou can pour water from one barrel to another. In one act of pouring, you can choose two different barrels $x$ and $y$ (the $x$-th barrel shouldn't be empty) and pour any possible amount of water from barrel $x$ to barrel $y$ (possibly, all water). You may assume that barrels have infinite capacity, so you can pour any amount of water in each of them. \n\nCalculate the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $k$ times.\n\nSome examples:   if you have four barrels, each containing $5$ liters of water, and $k = 1$, you may pour $5$ liters from the second barrel into the fourth, so the amounts of water in the barrels are $[5, 0, 5, 10]$, and the difference between the maximum and the minimum is $10$;  if all barrels are empty, you can't make any operation, so the difference between the maximum and the minimum amount is still $0$. \n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k < n \\le 2 \\cdot 10^5$) — the number of barrels and the number of pourings you can make.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\le a_i \\le 10^{9}$), where $a_i$ is the initial amount of water the $i$-th barrel has.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, print the maximum possible difference between the maximum and the minimum amount of water in the barrels, if you can pour water at most $k$ times.\n\n-----Example-----\nInput\n2\n4 1\n5 5 5 5\n3 2\n0 0 0\n\nOutput\n10\n0\n-/\n\n/- Helper function to sum a list -/\n\n/- Helper function to get maximum of non-empty list -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- max_water_difference result is greater than or equal to max barrel -/\n\n/- max_water_difference result is less than or equal to sum of all barrels -/\n\n/- max_water_difference does not modify input list -/\n\n/- Helper function to sort list descending -/\n\n/- Helper function to take first n elements -/\n\n/- max_water_difference returns sum of k+1 largest values -/", "vc-preamble": "def listSum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + listSum xs\n\ndef listMaximum : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | x :: xs => if x > listMaximum xs then x else listMaximum xs\n\ndef takeFront : Nat → List Nat → List Nat\n  | 0, _ => []\n  | _, [] => []\n  | n+1, x :: xs => x :: takeFront n xs", "vc-helpers": "", "vc-definitions": "def max_water_difference (n : Nat) (k : Nat) (barrels : List Nat) : Nat :=\n  sorry\n\ndef sortDescending (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem max_water_diff_equals_k_plus_one_largest\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  max_water_difference n k barrels =\n    listSum (takeFront (k+1) (sortDescending barrels)) :=\nsorry\n\ntheorem max_water_diff_ge_max_barrel\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n)\n  (h₃ : barrels ≠ []) :\n  max_water_difference n k barrels ≥ listMaximum barrels :=\nsorry\n\ntheorem max_water_diff_le_total_sum\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  max_water_difference n k barrels ≤ listSum barrels :=\nsorry\n\ntheorem max_water_diff_preserves_input\n  {n k : Nat} {barrels : List Nat}\n  (h₁ : barrels.length = n)\n  (h₂ : k < n) :\n  let original := barrels\n  let _ := max_water_difference n k barrels\n  barrels = original :=\nsorry", "vc-postamble": "/--\ninfo: 10\n-/\n#guard_msgs in\n#eval max_water_difference 4 1 [5, 5, 5, 5]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_water_difference 3 2 [0, 0, 0]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval max_water_difference 5 2 [1, 2, 3, 4, 5]"}
{"id": "fvapps_000007", "vc-description": "/-\nThe only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) — the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of voters.\n\nThe next $n$ lines contains the description of voters. $i$-th line contains two integers $m_i$ and $p_i$ ($1 \\le p_i \\le 10^9, 0 \\le m_i < n$).\n\nIt is guaranteed that the sum of all $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case print one integer — the minimum number of coins you have to spend so that everyone votes for you.\n\n-----Example-----\nInput\n3\n3\n1 5\n2 10\n2 8\n7\n0 1\n3 1\n1 1\n6 1\n1 1\n4 1\n4 1\n6\n2 6\n2 3\n2 8\n2 7\n4 4\n5 5\n\nOutput\n8\n0\n7\n\n-----Note-----\n\nIn the first test case you have to buy vote of the third voter. Then the set of people voting for you will change as follows: ${3} \\rightarrow {1, 3} \\rightarrow {1, 2, 3}$.\n\nIn the second example you don't need to buy votes. The set of people voting for you will change as follows: ${1} \\rightarrow {1, 3, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 5, 6, 7} \\rightarrow {1, 2, 3, 4, 5, 6, 7}$.\n\nIn the third test case you have to buy votes of the second and the fifth voters. Then the set of people voting for you will change as follows: ${2, 5} \\rightarrow {1, 2, 3, 4, 5} \\rightarrow {1, 2, 3, 4, 5, 6}$.\n-/\n\n/- The heap maintains the min-heap property after insertions -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- The heap extracts elements in sorted order -/\n\n/- Single value insertion and extraction works correctly -/", "vc-preamble": "def Heap := List Int", "vc-helpers": "", "vc-definitions": "def ins (l : Heap) (x : Int) : Heap :=\nsorry\n\ndef pop (l : Heap) : Int × Heap :=\nsorry", "vc-theorems": "theorem heap_maintains_min_property {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  ∀ i, 2 ≤ i → i < h'.length →\n    match h'.get? i, h'.get? (i/2) with\n    | some vi, some vp => vi ≥ vp\n    | _, _ => True :=\nsorry\n\ntheorem heap_gives_sorted_output {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  let rec extract (h : Heap) (n : Nat) : List Int :=\n    match n with\n    | 0 => []\n    | n+1 => match pop h with\n      | (x, h') => x :: extract h' n\n  ∀ i j xi xj, i < j → j < (extract h' h'.length).length →\n    (extract h' h'.length).get? i = some xi →\n    (extract h' h'.length).get? j = some xj →\n    xi ≤ xj :=\nsorry\n\ntheorem heap_single_value (x : Int) :\n  let h := ins [] x\n  pop h = (x, []) :=\nsorry", "vc-postamble": "/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_election 3 [[1, 5], [2, 10], [2, 8]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_election 7 [[0, 1], [3, 1], [1, 1], [6, 1], [1, 1], [4, 1], [4, 1]]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_election 6 [[2, 6], [2, 3], [2, 8], [2, 7], [4, 4], [5, 5]]"}
{"id": "fvapps_000009", "vc-description": "/-\nAlice and Bob play a game. They have a binary string $s$ (a string such that each character in it is either $0$ or $1$). Alice moves first, then Bob, then Alice again, and so on.\n\nDuring their move, the player can choose any number (not less than one) of consecutive equal characters in $s$ and delete them.\n\nFor example, if the string is $10110$, there are $6$ possible moves (deleted characters are bold):  $\\textbf{1}0110 \\to 0110$;  $1\\textbf{0}110 \\to 1110$;  $10\\textbf{1}10 \\to 1010$;  $101\\textbf{1}0 \\to 1010$;  $10\\textbf{11}0 \\to 100$;  $1011\\textbf{0} \\to 1011$. \n\nAfter the characters are removed, the characters to the left and to the right of the removed block become adjacent. I. e. the following sequence of moves is valid: $10\\textbf{11}0 \\to 1\\textbf{00} \\to 1$.\n\nThe game ends when the string becomes empty, and the score of each player is the number of $1$-characters deleted by them.\n\nEach player wants to maximize their score. Calculate the resulting score of Alice.\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 500$) — the number of test cases.\n\nEach test case contains exactly one line containing a binary string $s$ ($1 \\le |s| \\le 100$).\n\n-----Output-----\n\nFor each test case, print one integer — the resulting score of Alice (the number of $1$-characters deleted by her).\n\n-----Example-----\nInput\n5\n01111001\n0000\n111111\n101010101\n011011110111\n\nOutput\n4\n0\n6\n3\n6\n\n-----Note-----\n\nQuestions about the optimal strategy will be ignored.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_alice_score (s : String) : Nat :=\n  sorry\n\ndef countOnes (s : String) : Nat :=\n  sorry\n\ndef sortByLengthDesc (ls : List String) : List String :=\n  sorry\n\ndef getAlternateSum (ls : List String) : Nat :=\n  sorry", "vc-theorems": "theorem result_not_exceed_input_length\n  (s : String) :\n  count_alice_score s ≤ s.length :=\nsorry\n\ntheorem result_nonnegative\n  (s : String) :\n  count_alice_score s ≥ 0 :=\nsorry\n\ntheorem empty_or_zeros_returns_zero\n  (s : String) :\n  (s.isEmpty ∨ s.all (· = '0')) → count_alice_score s = 0 :=\nsorry\n\ntheorem all_ones_full_score\n  (s : String) :\n  s.all (· = '1') →\n  s.length > 0 →\n  count_alice_score s = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_alice_score \"01111001\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_alice_score \"111111\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_alice_score \"101010101\""}
{"id": "fvapps_000011", "vc-description": "/-\nYou have a string $s$ — a sequence of commands for your toy robot. The robot is placed in some cell of a rectangular grid. He can perform four commands:  'W' — move one cell up;  'S' — move one cell down;  'A' — move one cell left;  'D' — move one cell right. \n\nLet $Grid(s)$ be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands $s$. For example, if $s = \\text{DSAWWAW}$ then $Grid(s)$ is the $4 \\times 3$ grid:  you can place the robot in the cell $(3, 2)$;  the robot performs the command 'D' and moves to $(3, 3)$;  the robot performs the command 'S' and moves to $(4, 3)$;  the robot performs the command 'A' and moves to $(4, 2)$;  the robot performs the command 'W' and moves to $(3, 2)$;  the robot performs the command 'W' and moves to $(2, 2)$;  the robot performs the command 'A' and moves to $(2, 1)$;  the robot performs the command 'W' and moves to $(1, 1)$.  [Image] \n\nYou have $4$ extra letters: one 'W', one 'A', one 'S', one 'D'. You'd like to insert at most one of these letters in any position of sequence $s$ to minimize the area of $Grid(s)$.\n\nWhat is the minimum area of $Grid(s)$ you can achieve?\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 1000$) — the number of queries.\n\nNext $T$ lines contain queries: one per line. This line contains single string $s$ ($1 \\le |s| \\le 2 \\cdot 10^5$, $s_i \\in \\{\\text{W}, \\text{A}, \\text{S}, \\text{D}\\}$) — the sequence of commands.\n\nIt's guaranteed that the total length of $s$ over all queries doesn't exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nPrint $T$ integers: one per query. For each query print the minimum area of $Grid(s)$ you can achieve.\n\n-----Example-----\nInput\n3\nDSAWWAW\nD\nWA\n\nOutput\n8\n2\n4\n\n-----Note-----\n\nIn the first query you have to get string $\\text{DSAWW}\\underline{D}\\text{AW}$.\n\nIn second and third queries you can not decrease the area of $Grid(s)$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_grid_area (s : String) : Nat :=\n  sorry\n\ndef min_width_height_from_path (s : String) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem min_grid_area_positive (s : String) :\n  min_grid_area s > 0 := by\n  sorry\n\ntheorem min_grid_area_nonempty (s : String) (h : s.length > 0) :\n  min_grid_area s ≥ 2 := by\n  sorry\n\ntheorem min_grid_area_empty :\n  min_grid_area \"\" = 1 := by\n  sorry\n\ntheorem min_grid_area_single_char (c : Char) (h : c = 'W' ∨ c = 'A' ∨ c = 'S' ∨ c = 'D') :\n  min_grid_area (String.mk [c]) = 2 := by\n  sorry\n\ntheorem min_grid_area_bounds (s : String) :\n  let (w, h) := min_width_height_from_path s\n  min_grid_area s ≥ min (w * h) 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval min_grid_area \"DSAWWAW\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_grid_area \"D\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_grid_area \"WA\""}
{"id": "fvapps_000019", "vc-description": "/-\nThe only difference between easy and hard versions is constraints.\n\nThe BerTV channel every day broadcasts one episode of one of the $k$ TV shows. You know the schedule for the next $n$ days: a sequence of integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the show, the episode of which will be shown in $i$-th day.\n\nThe subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.\n\nHow many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows $d$ ($1 \\le d \\le n$) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of $d$ consecutive days in which all episodes belong to the purchased shows.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10000$) — the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of each test case contains three integers $n, k$ and $d$ ($1 \\le n \\le 2\\cdot10^5$, $1 \\le k \\le 10^6$, $1 \\le d \\le n$). The second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the show that is broadcasted on the $i$-th day.\n\nIt is guaranteed that the sum of the values ​​of $n$ for all test cases in the input does not exceed $2\\cdot10^5$.\n\n-----Output-----\n\nPrint $t$ integers — the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for $d$ consecutive days. Please note that it is permissible that you will be able to watch more than $d$ days in a row.\n\n-----Example-----\nInput\n4\n5 2 2\n1 2 1 2 1\n9 3 3\n3 3 3 2 2 2 1 1 1\n4 10 4\n10 8 6 4\n16 9 8\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3\n\nOutput\n2\n1\n4\n5\n\n-----Note-----\n\nIn the first test case to have an opportunity to watch shows for two consecutive days, you need to buy a subscription on show $1$ and on show $2$. So the answer is two.\n\nIn the second test case, you can buy a subscription to any show because for each show you can find a segment of three consecutive days, consisting only of episodes of this show.\n\nIn the third test case in the unique segment of four days, you have four different shows, so you need to buy a subscription to all these four shows.\n\nIn the fourth test case, you can buy subscriptions to shows $3,5,7,8,9$, and you will be able to watch shows for the last eight days.\n-/", "vc-preamble": "def maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs\n\ndef listToFinset (l : List Nat) : List Nat :=\n  l.eraseDups", "vc-helpers": "", "vc-definitions": "def windowsOfSize (l : List Nat) (size : Nat) : List (List Nat) :=\n  sorry\n\ndef min_subscriptions (n k d : Nat) (shows : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_subscriptions_output_bounds\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x ∧ x ≤ 100) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min n (maximum shows)\n  let result := min_subscriptions n k d shows\n  1 ≤ result ∧ result ≤ (listToFinset shows).length :=\nsorry\n\ntheorem min_subscriptions_window_size_one\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  min_subscriptions n k 1 shows = 1 :=\nsorry\n\ntheorem min_subscriptions_window_size_equals_length\n  (shows : List Nat)\n  (k : Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x)\n  (h3 : 1 ≤ k) :\n  let n := shows.length\n  min_subscriptions n k n shows = (listToFinset shows).length :=\nsorry\n\ntheorem min_subscriptions_repeated_elements\n  (shows : List Nat)\n  (h1 : shows ≠ [])\n  (h2 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := n\n  min_subscriptions n k d shows = min_subscriptions (2*n) k d (shows ++ shows) :=\nsorry\n\ntheorem min_subscriptions_sliding_window\n  (shows : List Nat)\n  (window_size : Nat)\n  (h1 : shows.length ≥ 2)\n  (h2 : window_size ≥ 2)\n  (h3 : ∀ x ∈ shows, 1 ≤ x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min window_size n\n  let result := min_subscriptions n k d shows\n  let windows := windowsOfSize shows d\n  let min_unique := (windows.map (fun w => (listToFinset w).length)).foldl Nat.min n\n  result = min_unique :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subscriptions 5 2 2 [1, 2, 1, 2, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_subscriptions 9 3 3 [3, 3, 3, 2, 2, 2, 1, 1, 1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_subscriptions 4 10 4 [10, 8, 6, 4]"}
{"id": "fvapps_000022", "vc-description": "/-\nLet's define the following recurrence: $$a_{n+1} = a_{n} + minDigit(a_{n}) \\cdot maxDigit(a_{n}).$$\n\nHere $minDigit(x)$ and $maxDigit(x)$ are the minimal and maximal digits in the decimal representation of $x$ without leading zeroes. For examples refer to notes.\n\nYour task is calculate $a_{K}$ for given $a_{1}$ and $K$.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of independent test cases.\n\nEach test case consists of a single line containing two integers $a_{1}$ and $K$ ($1 \\le a_{1} \\le 10^{18}$, $1 \\le K \\le 10^{16}$) separated by a space.\n\n-----Output-----\n\nFor each test case print one integer $a_{K}$ on a separate line.\n\n-----Example-----\nInput\n8\n1 4\n487 1\n487 2\n487 3\n487 4\n487 5\n487 6\n487 7\n\nOutput\n42\n487\n519\n528\n544\n564\n588\n628\n\n-----Note-----\n\n$a_{1} = 487$ \n\n $a_{2} = a_{1} + minDigit(a_{1}) \\cdot maxDigit(a_{1}) = 487 + \\min (4, 8, 7) \\cdot \\max (4, 8, 7) = 487 + 4 \\cdot 8 = 519$ \n\n $a_{3} = a_{2} + minDigit(a_{2}) \\cdot maxDigit(a_{2}) = 519 + \\min (5, 1, 9) \\cdot \\max (5, 1, 9) = 519 + 1 \\cdot 9 = 528$ \n\n $a_{4} = a_{3} + minDigit(a_{3}) \\cdot maxDigit(a_{3}) = 528 + \\min (5, 2, 8) \\cdot \\max (5, 2, 8) = 528 + 2 \\cdot 8 = 544$ \n\n $a_{5} = a_{4} + minDigit(a_{4}) \\cdot maxDigit(a_{4}) = 544 + \\min (5, 4, 4) \\cdot \\max (5, 4, 4) = 544 + 4 \\cdot 5 = 564$ \n\n $a_{6} = a_{5} + minDigit(a_{5}) \\cdot maxDigit(a_{5}) = 564 + \\min (5, 6, 4) \\cdot \\max (5, 6, 4) = 564 + 4 \\cdot 6 = 588$ \n\n $a_{7} = a_{6} + minDigit(a_{6}) \\cdot maxDigit(a_{6}) = 588 + \\min (5, 8, 8) \\cdot \\max (5, 8, 8) = 588 + 5 \\cdot 8 = 628$\n-/\n\n-- Result is always non-negative\n\n-- k=1 returns original number\n\n-- k>1 implies result >= input", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_seq (a k : Nat) : Nat :=\n  sorry\n\ndef hasZeroDigit (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem calc_seq_basic_properties {a k : Nat} (ha : a > 0) (hk : k > 0) :\n  let result := calc_seq a k\n\n  result ≥ 0 ∧\n\n  calc_seq a 1 = a ∧\n\n  (k > 1 → result ≥ a) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 42\n-/\n#guard_msgs in\n#eval calc_seq 1 4\n\n/--\ninfo: 487\n-/\n#guard_msgs in\n#eval calc_seq 487 1\n\n/--\ninfo: 628\n-/\n#guard_msgs in\n#eval calc_seq 487 7"}
{"id": "fvapps_000030", "vc-description": "/-\nYou are given a string $s$ of even length $n$. String $s$ is binary, in other words, consists only of 0's and 1's.\n\nString $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse any substring of $s$. A substring of a string is a contiguous subsequence of that string.\n\nWhat is the minimum number of operations you need to make string $s$ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There are two types of alternating strings in general: 01010101... or 10101010...\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even) — the length of string $s$.\n\nThe second line of each test case contains a binary string $s$ of length $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print the minimum number of operations to make $s$ alternating.\n\n-----Example-----\nInput\n3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\n-----Note-----\n\nIn the first test case, string 10 is already alternating.\n\nIn the second test case, we can, for example, reverse the last two elements of $s$ and get: 0110 $\\rightarrow$ 0101.\n\nIn the third test case, we can, for example, make the following two operations:   11101000 $\\rightarrow$ 10101100;  10101100 $\\rightarrow$ 10101010.\n-/\n\n/- Main theorem combining several properties of solve_string_alternation:\n  1. Output is non-negative\n  2. Output is less than string length\n  3. Output relates to number of adjacent duplicates\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Perfectly alternating strings require no operations -/\n\n/- For strings of all same characters, result depends on length -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_string_alternation (n : Nat) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_string_alternation_properties (s : String) (n : Nat)\n  (h1 : s.length = n) (h2 : n > 0) (h3 : ∀c ∈ s.data, c = '0' ∨ c = '1') :\n  let result := solve_string_alternation n s\n  let adjacent_same := (List.zip s.data s.data.tail).filter (fun p => p.1 = p.2) |>.length\n  (result ≥ 0) ∧\n  (result < n) ∧\n  (result = (adjacent_same + adjacent_same % 2) / 2) :=\nsorry\n\ntheorem solve_string_alternation_perfect_alt (n : Nat) (h : n ≥ 2) :\n  let s := String.mk (List.map (fun i => if i % 2 = 0 then '0' else '1') (List.range n))\n  solve_string_alternation n s = 0 :=\nsorry\n\ntheorem solve_string_alternation_all_same (n : Nat) (h : n > 0) :\n  let s := String.mk (List.replicate n '0')\n  solve_string_alternation n s = ((n-1) + (n-1) % 2) / 2 :=\nsorry", "vc-postamble": "/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_string_alternation 2 \"10\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_string_alternation 4 \"0110\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_string_alternation 8 \"11101000\""}
{"id": "fvapps_000038", "vc-description": "/-\nTwo players decided to play one interesting card game.\n\nThere is a deck of $n$ cards, with values from $1$ to $n$. The values of cards are pairwise different (this means that no two different cards have equal values). At the beginning of the game, the deck is completely distributed between players such that each player has at least one card. \n\nThe game goes as follows: on each turn, each player chooses one of their cards (whichever they want) and puts on the table, so that the other player doesn't see which card they chose. After that, both cards are revealed, and the player, value of whose card was larger, takes both cards in his hand. Note that as all cards have different values, one of the cards will be strictly larger than the other one. Every card may be played any amount of times. The player loses if he doesn't have any cards.\n\nFor example, suppose that $n = 5$, the first player has cards with values $2$ and $3$, and the second player has cards with values $1$, $4$, $5$. Then one possible flow of the game is:\n\nThe first player chooses the card $3$. The second player chooses the card $1$. As $3>1$, the first player gets both cards. Now the first player has cards $1$, $2$, $3$, the second player has cards $4$, $5$.\n\nThe first player chooses the card $3$. The second player chooses the card $4$. As $3<4$, the second player gets both cards. Now the first player has cards $1$, $2$. The second player has cards $3$, $4$, $5$.\n\nThe first player chooses the card $1$. The second player chooses the card $3$. As $1<3$, the second player gets both cards. Now the first player has only the card $2$. The second player has cards $1$, $3$, $4$, $5$.\n\nThe first player chooses the card $2$. The second player chooses the card $4$. As $2<4$, the second player gets both cards. Now the first player is out of cards and loses. Therefore, the second player wins.\n\nWho will win if both players are playing optimally? It can be shown that one of the players has a winning strategy.\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains three integers $n$, $k_1$, $k_2$ ($2 \\le n \\le 100, 1 \\le k_1 \\le n - 1, 1 \\le k_2 \\le n - 1, k_1 + k_2 = n$) — the number of cards, number of cards owned by the first player and second player correspondingly.\n\nThe second line of each test case contains $k_1$ integers $a_1, \\dots, a_{k_1}$ ($1 \\le a_i \\le n$) — the values of cards of the first player.\n\nThe third line of each test case contains $k_2$ integers $b_1, \\dots, b_{k_2}$ ($1 \\le b_i \\le n$) — the values of cards of the second player.\n\nIt is guaranteed that the values of all cards are different.\n\n-----Output-----\n\nFor each test case, output \"YES\" in a separate line, if the first player wins. Otherwise, output \"NO\" in a separate line. You can print each letter in any case (upper or lower).\n\n-----Example-----\nInput\n2\n2 1 1\n2\n1\n5 2 3\n2 3\n1 4 5\n\nOutput\nYES\nNO\n\n-----Note-----\n\nIn the first test case of the example, there is only one possible move for every player: the first player will put $2$, the second player will put $1$. $2>1$, so the first player will get both cards and will win.\n\nIn the second test case of the example, it can be shown that it is the second player who has a winning strategy. One possible flow of the game is illustrated in the statement.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\n  sorry\n\ndef solve_card_game (n k1 k2 : Nat) (arr1 arr2 : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem card_game_returns_bool (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = true ∨\n  solve_card_game n k1 k2 arr1 arr2 = false :=\nsorry\n\ntheorem card_game_compares_maxes (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = (maximum arr1 > maximum arr2) :=\nsorry\n\ntheorem empty_lists_error (n : Nat) :\n  ∀ (arr1 arr2 : List Int),\n  arr1.length = 0 → arr2.length = 0 →\n  solve_card_game n 0 0 arr1 arr2 = default :=\nsorry\n\ntheorem equal_maxes_false (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : arr1.length > 0) (h2 : arr2.length > 0)\n  (h3 : maximum arr2 = maximum arr1) :\n  solve_card_game n arr1.length arr2.length arr1 arr2 = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 2 1 1 [2] [1]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve_card_game 5 2 3 [2, 3] [1, 4, 5]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 3 1 2 [3] [1, 2]"}
{"id": "fvapps_000043", "vc-description": "/-\nPetya is preparing for his birthday. He decided that there would be $n$ different dishes on the dinner table, numbered from $1$ to $n$. Since Petya doesn't like to cook, he wants to order these dishes in restaurants.\n\nUnfortunately, all dishes are prepared in different restaurants and therefore Petya needs to pick up his orders from $n$ different places. To speed up this process, he wants to order courier delivery at some restaurants. Thus, for each dish, there are two options for Petya how he can get it:  the dish will be delivered by a courier from the restaurant $i$, in this case the courier will arrive in $a_i$ minutes,  Petya goes to the restaurant $i$ on his own and picks up the dish, he will spend $b_i$ minutes on this. \n\nEach restaurant has its own couriers and they start delivering the order at the moment Petya leaves the house. In other words, all couriers work in parallel. Petya must visit all restaurants in which he has not chosen delivery, he does this consistently.\n\nFor example, if Petya wants to order $n = 4$ dishes and $a = [3, 7, 4, 5]$, and $b = [2, 1, 2, 4]$, then he can order delivery from the first and the fourth restaurant, and go to the second and third on your own. Then the courier of the first restaurant will bring the order in $3$ minutes, the courier of the fourth restaurant will bring the order in $5$ minutes, and Petya will pick up the remaining dishes in $1 + 2 = 3$ minutes. Thus, in $5$ minutes all the dishes will be at Petya's house.\n\nFind the minimum time after which all the dishes can be at Petya's home.\n\n-----Input-----\n\nThe first line contains one positive integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) — the number of test cases. Then $t$ test cases follow.\n\nEach test case begins with a line containing one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of dishes that Petya wants to order.\n\nThe second line of each test case contains $n$ integers $a_1 \\ldots a_n$ ($1 \\le a_i \\le 10^9$) — the time of courier delivery of the dish with the number $i$.\n\nThe third line of each test case contains $n$ integers $b_1 \\ldots b_n$ ($1 \\le b_i \\le 10^9$) — the time during which Petya will pick up the dish with the number $i$.\n\nThe sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case output one integer — the minimum time after which all dishes can be at Petya's home.\n\n-----Example-----\nInput\n4\n4\n3 7 4 5\n2 1 2 4\n4\n1 2 3 4\n3 3 3 3\n2\n1 2\n10 10\n2\n10 10\n1 2\n\nOutput\n5\n3\n2\n3\n-/", "vc-preamble": "def list_maximum (l : List Nat) : Nat :=\n  l.foldl Nat.max 0", "vc-helpers": "", "vc-definitions": "def solve_dishes (n : Nat) (a : List Nat) (b : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_dishes_leq_max_cook_time (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    solve_dishes n a b ≤ list_maximum a :=\nsorry\n\ntheorem solve_dishes_non_negative (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    solve_dishes n a b ≥ 0 :=\nsorry\n\ntheorem solve_dishes_valid_solution (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n ≥ 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : ∀ x ∈ a, x ≥ 1) (h5 : ∀ x ∈ b, x ≥ 1) :\n    let result := solve_dishes n a b\n    let remaining := result - (List.range n).foldl (λ acc i =>\n      if a[i]! > result then acc + b[i]! else acc) 0\n    remaining ≥ 0 :=\nsorry\n\ntheorem same_cook_and_wait_times (n : Nat) (times : List Nat)\n    (h1 : n ≥ 1) (h2 : times.length = n) (h3 : ∀ x ∈ times, x ≥ 1) :\n    solve_dishes n times times ≤ list_maximum times :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_dishes 4 [3, 7, 4, 5] [2, 1, 2, 4]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_dishes 4 [1, 2, 3, 4] [3, 3, 3, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dishes 2 [1, 2] [10, 10]"}
{"id": "fvapps_000046", "vc-description": "/-\nRecently, you found a bot to play \"Rock paper scissors\" with. Unfortunately, the bot uses quite a simple algorithm to play: he has a string $s = s_1 s_2 \\dots s_{n}$ of length $n$ where each letter is either R, S or P.\n\nWhile initializing, the bot is choosing a starting index $pos$ ($1 \\le pos \\le n$), and then it can play any number of rounds. In the first round, he chooses \"Rock\", \"Scissors\" or \"Paper\" based on the value of $s_{pos}$:   if $s_{pos}$ is equal to R the bot chooses \"Rock\";  if $s_{pos}$ is equal to S the bot chooses \"Scissors\";  if $s_{pos}$ is equal to P the bot chooses \"Paper\"; \n\nIn the second round, the bot's choice is based on the value of $s_{pos + 1}$. In the third round — on $s_{pos + 2}$ and so on. After $s_n$ the bot returns to $s_1$ and continues his game.\n\nYou plan to play $n$ rounds and you've already figured out the string $s$ but still don't know what is the starting index $pos$. But since the bot's tactic is so boring, you've decided to find $n$ choices to each round to maximize the average number of wins.\n\nIn other words, let's suggest your choices are $c_1 c_2 \\dots c_n$ and if the bot starts from index $pos$ then you'll win in $win(pos)$ rounds. Find $c_1 c_2 \\dots c_n$ such that $\\frac{win(1) + win(2) + \\dots + win(n)}{n}$ is maximum possible.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nNext $t$ lines contain test cases — one per line. The first and only line of each test case contains string $s = s_1 s_2 \\dots s_{n}$ ($1 \\le n \\le 2 \\cdot 10^5$; $s_i \\in \\{\\text{R}, \\text{S}, \\text{P}\\}$) — the string of the bot.\n\nIt's guaranteed that the total length of all strings in one test doesn't exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, print $n$ choices $c_1 c_2 \\dots c_n$ to maximize the average number of wins. Print them in the same manner as the string $s$.\n\nIf there are multiple optimal answers, print any of them.\n\n-----Example-----\nInput\n3\nRRRR\nRSP\nS\n\nOutput\nPPPP\nRSP\nR\n\n-----Note-----\n\nIn the first test case, the bot (wherever it starts) will always choose \"Rock\", so we can always choose \"Paper\". So, in any case, we will win all $n = 4$ rounds, so the average is also equal to $4$.\n\nIn the second test case:   if bot will start from $pos = 1$, then $(s_1, c_1)$ is draw, $(s_2, c_2)$ is draw and $(s_3, c_3)$ is draw, so $win(1) = 0$;  if bot will start from $pos = 2$, then $(s_2, c_1)$ is win, $(s_3, c_2)$ is win and $(s_1, c_3)$ is win, so $win(2) = 3$;  if bot will start from $pos = 3$, then $(s_3, c_1)$ is lose, $(s_1, c_2)$ is lose and $(s_2, c_3)$ is lose, so $win(3) = 0$;  The average is equal to $\\frac{0 + 3 + 0}{3} = 1$ and it can be proven that it's the maximum possible average.\n\nA picture from Wikipedia explaining \"Rock paper scissors\" game:  $\\beta$\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_rock_paper_scissors (s: String) : String :=\nsorry\n\ndef beats (move1 move2 : Char) : Bool :=\nsorry\n\ndef getMostFrequentMove (s : String) : Char :=\nsorry", "vc-theorems": "theorem length_preservation (s : String) :\n  s.length > 0 → (solve_rock_paper_scissors s).length = s.length :=\nsorry\n\ntheorem valid_moves (s : String) (i : String.Pos) :\n  s.length > 0 →\n  (solve_rock_paper_scissors s).get i = 'R' ∨\n  (solve_rock_paper_scissors s).get i = 'P' ∨\n  (solve_rock_paper_scissors s).get i = 'S' :=\nsorry\n\ntheorem uniform_response (s : String) :\n  s.length > 0 → ∀ i j : String.Pos,\n  (solve_rock_paper_scissors s).get i = (solve_rock_paper_scissors s).get j :=\nsorry\n\ntheorem beats_most_frequent (s : String) (h: s.length > 0):\n  let mostFrequent := getMostFrequentMove s\n  let firstChar := (solve_rock_paper_scissors s).front\n  beats firstChar mostFrequent :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: len(test_input)\n-/\n#guard_msgs in\n#eval len solve_rock_paper_scissors(test_input)"}
{"id": "fvapps_000053", "vc-description": "/-\nGildong recently learned how to find the longest increasing subsequence (LIS) in $O(n\\log{n})$ time for a sequence of length $n$. He wants to test himself if he can implement it correctly, but he couldn't find any online judges that would do it (even though there are actually many of them). So instead he's going to make a quiz for you about making permutations of $n$ distinct integers between $1$ and $n$, inclusive, to test his code with your output.\n\nThe quiz is as follows.\n\nGildong provides a string of length $n-1$, consisting of characters '<' and '>' only. The $i$-th (1-indexed) character is the comparison result between the $i$-th element and the $i+1$-st element of the sequence. If the $i$-th character of the string is '<', then the $i$-th element of the sequence is less than the $i+1$-st element. If the $i$-th character of the string is '>', then the $i$-th element of the sequence is greater than the $i+1$-st element.\n\nHe wants you to find two possible sequences (not necessarily distinct) consisting of $n$ distinct integers between $1$ and $n$, inclusive, each satisfying the comparison results, where the length of the LIS of the first sequence is minimum possible, and the length of the LIS of the second sequence is maximum possible.\n\n-----Input-----\n\nEach test contains one or more test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$).\n\nEach test case contains exactly one line, consisting of an integer and a string consisting of characters '<' and '>' only. The integer is $n$ ($2 \\le n \\le 2 \\cdot 10^5$), the length of the permutation you need to find. The string is the comparison results explained in the description. The length of the string is $n-1$.\n\nIt is guaranteed that the sum of all $n$ in all test cases doesn't exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, print two lines with $n$ integers each. The first line is the sequence with the minimum length of the LIS, and the second line is the sequence with the maximum length of the LIS. If there are multiple answers, print any one of them. Each sequence should contain all integers between $1$ and $n$, inclusive, and should satisfy the comparison results.\n\nIt can be shown that at least one answer always exists.\n\n-----Example-----\nInput\n3\n3 <<\n7 >><>><\n5 >>><\n\nOutput\n1 2 3\n1 2 3\n5 4 3 7 2 1 6\n4 3 1 7 5 2 6\n4 3 2 1 5\n5 4 2 1 3\n\n-----Note-----\n\nIn the first case, $1$ $2$ $3$ is the only possible answer.\n\nIn the second case, the shortest length of the LIS is $2$, and the longest length of the LIS is $3$. In the example of the maximum LIS sequence, $4$ '$3$' $1$ $7$ '$5$' $2$ '$6$' can be one of the possible LIS.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_sequence (n : Nat) (comp_str : String) : (List Nat × List Nat) :=\n  sorry\n\ndef verifySequenceMatchesComparisons (seq : List Nat) (comps : List Char) : Bool :=\n  sorry", "vc-theorems": "theorem sequence_length_matches_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  min_seq.length = n ∧ max_seq.length = n :=\nsorry\n\ntheorem sequences_follow_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  verifySequenceMatchesComparisons min_seq (comp_str.data) ∧\n  verifySequenceMatchesComparisons max_seq (comp_str.data) :=\nsorry\n\ntheorem sequences_use_consecutive_integers\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 →\n  ∀ k, k ≤ n → (k ∈ min_seq ↔ k ≤ n ∧ k > 0) ∧\n               (k ∈ max_seq ↔ k ≤ n ∧ k > 0) :=\nsorry\n\ntheorem single_value_edge_case\n  {n : Nat} :\n  n = 1 →\n  solve_sequence n \"\" = ([1], [1]) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set min3\n\n/--\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set max3"}
{"id": "fvapps_000059", "vc-description": "/-\nDark is going to attend Motarack's birthday. Dark decided that the gift he is going to give to Motarack is an array $a$ of $n$ non-negative integers.\n\nDark created that array $1000$ years ago, so some elements in that array disappeared. Dark knows that Motarack hates to see an array that has two adjacent elements with a high absolute difference between them. He doesn't have much time so he wants to choose an integer $k$ ($0 \\leq k \\leq 10^{9}$) and replaces all missing elements in the array $a$ with $k$.\n\nLet $m$ be the maximum absolute difference between all adjacent elements (i.e. the maximum value of $|a_i - a_{i+1}|$ for all $1 \\leq i \\leq n - 1$) in the array $a$ after Dark replaces all missing elements with $k$.\n\nDark should choose an integer $k$ so that $m$ is minimized. Can you help him?\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\leq t \\leq 10^4$)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains one integer $n$ ($2 \\leq n \\leq 10^{5}$) — the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-1 \\leq a_i \\leq 10 ^ {9}$). If $a_i = -1$, then the $i$-th integer is missing. It is guaranteed that at least one integer is missing in every test case.\n\nIt is guaranteed, that the sum of $n$ for all test cases does not exceed $4 \\cdot 10 ^ {5}$.\n\n-----Output-----\n\nPrint the answers for each test case in the following format:\n\nYou should print two integers, the minimum possible value of $m$ and an integer $k$ ($0 \\leq k \\leq 10^{9}$) that makes the maximum absolute difference between adjacent elements in the array $a$ equal to $m$.\n\nMake sure that after replacing all the missing elements with $k$, the maximum absolute difference between adjacent elements becomes $m$.\n\nIf there is more than one possible $k$, you can print any of them.\n\n-----Example-----\nInput\n7\n5\n-1 10 -1 12 -1\n5\n-1 40 35 -1 35\n6\n-1 -1 9 -1 3 -1\n2\n-1 -1\n2\n0 -1\n4\n1 -1 3 -1\n7\n1 -1 7 5 2 -1 5\n\nOutput\n1 11\n5 35\n3 6\n0 42\n0 0\n1 2\n3 4\n\n-----Note-----\n\nIn the first test case after replacing all missing elements with $11$ the array becomes $[11, 10, 11, 12, 11]$. The absolute difference between any adjacent elements is $1$. It is impossible to choose a value of $k$, such that the absolute difference between any adjacent element will be $\\leq 0$. So, the answer is $1$.\n\nIn the third test case after replacing all missing elements with $6$ the array becomes $[6, 6, 9, 6, 3, 6]$.  $|a_1 - a_2| = |6 - 6| = 0$;  $|a_2 - a_3| = |6 - 9| = 3$;  $|a_3 - a_4| = |9 - 6| = 3$;  $|a_4 - a_5| = |6 - 3| = 3$;  $|a_5 - a_6| = |3 - 6| = 3$. \n\nSo, the maximum difference between any adjacent elements is $3$.\n-/\n\n/- Properties for all-negative-ones case -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Main property about adjacent differences being bounded by result -/\n\n/- Property about the x value working for -1 positions -/\n\n/- Property about result types and non-negativity -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_differences (n : Nat) (arr : List Int) : Int × Int :=\nsorry", "vc-theorems": "theorem all_neg_ones_result {n : Nat} {arr : List Int}\n  (h : ∀ x ∈ arr, x = -1) :\n  solve_array_differences n arr = (0, 0) :=\nsorry\n\ntheorem adjacent_differences_bounded {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ∀ i < arr.length - 1,\n    arr[i]! ≠ -1 → arr[i+1]! ≠ -1 →\n    (arr[i]! - arr[i+1]!).natAbs ≤ ans :=\nsorry\n\ntheorem x_value_maintains_bound {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ∀ i < arr.length,\n    arr[i]! = -1 →\n    (i > 0 → arr[i-1]! ≠ -1 → (arr[i-1]! - x).natAbs ≤ ans) ∧\n    (i < arr.length - 1 → arr[i+1]! ≠ -1 → (x - arr[i+1]!).natAbs ≤ ans) :=\nsorry\n\ntheorem result_properties {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ans ≥ 0 :=\nsorry", "vc-postamble": "/--\ninfo: (1, 11)\n-/\n#guard_msgs in\n#eval solve_array_differences 5 [-1, 10, -1, 12, -1]\n\n/--\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval solve_array_differences 2 [-1, -1]\n\n/--\ninfo: (1, 2)\n-/\n#guard_msgs in\n#eval solve_array_differences 4 [1, -1, 3, -1]"}
{"id": "fvapps_000065", "vc-description": "/-\nKuroni has $n$ daughters. As gifts for them, he bought $n$ necklaces and $n$ bracelets:  the $i$-th necklace has a brightness $a_i$, where all the $a_i$ are pairwise distinct (i.e. all $a_i$ are different),  the $i$-th bracelet has a brightness $b_i$, where all the $b_i$ are pairwise distinct (i.e. all $b_i$ are different). \n\nKuroni wants to give exactly one necklace and exactly one bracelet to each of his daughters. To make sure that all of them look unique, the total brightnesses of the gifts given to each daughter should be pairwise distinct. Formally, if the $i$-th daughter receives a necklace with brightness $x_i$ and a bracelet with brightness $y_i$, then the sums $x_i + y_i$ should be pairwise distinct. Help Kuroni to distribute the gifts.\n\nFor example, if the brightnesses are $a = [1, 7, 5]$ and $b = [6, 1, 2]$, then we may distribute the gifts as follows:  Give the third necklace and the first bracelet to the first daughter, for a total brightness of $a_3 + b_1 = 11$. Give the first necklace and the third bracelet to the second daughter, for a total brightness of $a_1 + b_3 = 3$. Give the second necklace and the second bracelet to the third daughter, for a total brightness of $a_2 + b_2 = 8$. \n\nHere is an example of an invalid distribution:   Give the first necklace and the first bracelet to the first daughter, for a total brightness of $a_1 + b_1 = 7$. Give the second necklace and the second bracelet to the second daughter, for a total brightness of $a_2 + b_2 = 8$. Give the third necklace and the third bracelet to the third daughter, for a total brightness of $a_3 + b_3 = 7$. \n\nThis distribution is invalid, as the total brightnesses of the gifts received by the first and the third daughter are the same. Don't make them this upset!\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100$)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$)  — the number of daughters, necklaces and bracelets.\n\nThe second line of each test case contains $n$ distinct integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 1000$)  — the brightnesses of the necklaces.\n\nThe third line of each test case contains $n$ distinct integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 1000$)  — the brightnesses of the bracelets.\n\n-----Output-----\n\nFor each test case, print a line containing $n$ integers $x_1, x_2, \\dots, x_n$, representing that the $i$-th daughter receives a necklace with brightness $x_i$. In the next line print $n$ integers $y_1, y_2, \\dots, y_n$, representing that the $i$-th daughter receives a bracelet with brightness $y_i$.\n\nThe sums $x_1 + y_1, x_2 + y_2, \\dots, x_n + y_n$ should all be distinct. The numbers $x_1, \\dots, x_n$ should be equal to the numbers $a_1, \\dots, a_n$ in some order, and the numbers $y_1, \\dots, y_n$ should be equal to the numbers $b_1, \\dots, b_n$ in some order. \n\nIt can be shown that an answer always exists. If there are multiple possible answers, you may print any of them.\n\n-----Example-----\nInput\n2\n3\n1 8 5\n8 4 5\n3\n1 7 5\n6 1 2\n\nOutput\n1 8 5\n8 4 5\n5 1 7\n6 2 1\n\n-----Note-----\n\nIn the first test case, it is enough to give the $i$-th necklace and the $i$-th bracelet to the $i$-th daughter. The corresponding sums are $1 + 8 = 9$, $8 + 4 = 12$, and $5 + 5 = 10$.\n\nThe second test case is described in the statement.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sorted (l : List Int) : Bool :=\n  sorry\n\ndef solve_gift_distribution (n : Nat) (a b : List Int) : List Int × List Int :=\n  sorry\n\ndef List.sort (l : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem gift_distribution_output {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  (necklace.sorted = true) ∧ (bracelet.sorted = true) := by\n  sorry\n\ntheorem gift_distribution_nonempty {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace.length > 0 ∧ bracelet.length > 0 := by\n  sorry\n\ntheorem gift_distribution_preserves_elements {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace = a.sort ∧ bracelet = b.sort := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000066", "vc-description": "/-\nThis problem is different from the easy version. In this version Ujan makes at most $2n$ swaps. In addition, $k \\le 1000, n \\le 50$ and it is necessary to print swaps themselves. You can hack this problem if you solve it. But you can hack the previous problem only if you solve both problems.\n\nAfter struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first.\n\nUjan has two distinct strings $s$ and $t$ of length $n$ consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation at most $2n$ times: he takes two positions $i$ and $j$ ($1 \\le i,j \\le n$, the values $i$ and $j$ can be equal or different), and swaps the characters $s_i$ and $t_j$.\n\nUjan's goal is to make the strings $s$ and $t$ equal. He does not need to minimize the number of performed operations: any sequence of operations of length $2n$ or shorter is suitable.\n\n-----Input-----\n\nThe first line contains a single integer $k$ ($1 \\leq k \\leq 1000$), the number of test cases.\n\nFor each of the test cases, the first line contains a single integer $n$ ($2 \\leq n \\leq 50$), the length of the strings $s$ and $t$. \n\nEach of the next two lines contains the strings $s$ and $t$, each having length exactly $n$. The strings consist only of lowercase English letters. It is guaranteed that strings are different.\n\n-----Output-----\n\nFor each test case, output \"Yes\" if Ujan can make the two strings equal with at most $2n$ operations and \"No\" otherwise. You can print each letter in any case (upper or lower).\n\nIn the case of \"Yes\" print $m$ ($1 \\le m \\le 2n$) on the next line, where $m$ is the number of swap operations to make the strings equal. Then print $m$ lines, each line should contain two integers $i, j$ ($1 \\le i, j \\le n$) meaning that Ujan swaps $s_i$ and $t_j$ during the corresponding operation. You do not need to minimize the number of operations. Any sequence of length not more than $2n$ is suitable.\n\n-----Example-----\nInput\n4\n5\nsouse\nhouhe\n3\ncat\ndog\n2\naa\naz\n3\nabc\nbca\n\nOutput\nYes\n1\n1 4\nNo\nNo\nYes\n3\n1 2\n3 1\n2 3\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "inductive Even : Nat → Prop where\n  | zero : Even 0\n  | plus_two : (n : Nat) → Even n → Even (n + 2)", "vc-helpers": "", "vc-definitions": "def solve_string_swaps (n: Nat) (s t: String) : String × List (Nat × Nat) :=\n  sorry\n\ndef apply_swaps (s t: String) (swaps: List (Nat × Nat)) : String × String :=\n  sorry\n\ndef count_chars (s: String) : Char → Nat :=\n  sorry", "vc-theorems": "theorem identical_strings_always_possible\n  (n: Nat) (s: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s s\n  res.1 = \"Yes\" ∧ res.2.length ≤ 2 * n :=\nsorry\n\ntheorem valid_solution\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s t\n  res.1 = \"Yes\" →\n    (res.2.length ≤ 2 * n ∧\n     ∃ final_s final_t,\n       (apply_swaps s t res.2) = (final_s, final_t) ∧\n       final_s = final_t) ∧\n  res.1 = \"No\" →\n    res.2 = [] :=\nsorry\n\ntheorem character_count_invariant\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n ≤ 100) :\n  let res := solve_string_swaps n s t\n  let char_counts := count_chars (s ++ t)\n  res.1 = \"Yes\" ↔ ∀ c, Even (char_counts c) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000069", "vc-description": "/-\nWord $s$ of length $n$ is called $k$-complete if   $s$ is a palindrome, i.e. $s_i=s_{n+1-i}$ for all $1 \\le i \\le n$;  $s$ has a period of $k$, i.e. $s_i=s_{k+i}$ for all $1 \\le i \\le n-k$. \n\nFor example, \"abaaba\" is a $3$-complete word, while \"abccba\" is not.\n\nBob is given a word $s$ of length $n$ consisting of only lowercase Latin letters and an integer $k$, such that $n$ is divisible by $k$. He wants to convert $s$ to any $k$-complete word.\n\nTo do this Bob can choose some $i$ ($1 \\le i \\le n$) and replace the letter at position $i$ with some other lowercase Latin letter.\n\nSo now Bob wants to know the minimum number of letters he has to replace to convert $s$ to any $k$-complete word.\n\nNote that Bob can do zero changes if the word $s$ is already $k$-complete.\n\nYou are required to answer $t$ test cases independently.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t\\le 10^5$) — the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le k < n \\le 2 \\cdot 10^5$, $n$ is divisible by $k$).\n\nThe second line of each test case contains a word $s$ of length $n$.\n\nIt is guaranteed that word $s$ only contains lowercase Latin letters. And it is guaranteed that the sum of $n$ over all test cases will not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, output one integer, representing the minimum number of characters he has to replace to convert $s$ to any $k$-complete word.\n\n-----Example-----\nInput\n4\n6 2\nabaaba\n6 3\nabaaba\n36 9\nhippopotomonstrosesquippedaliophobia\n21 7\nwudixiaoxingxingheclp\n\nOutput\n2\n0\n23\n16\n\n-----Note-----\n\nIn the first test case, one optimal solution is aaaaaa.\n\nIn the second test case, the given word itself is $k$-complete.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_replacements (n k : Nat) (s : String) : Nat :=\n  sorry\n\ndef is_palindrome (s : String) : Bool :=\n  sorry\n\ndef max_char_count (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem min_replacements_nonneg (n k : Nat) (s : String) :\n  min_replacements n k s ≥ 0 :=\nsorry\n\ntheorem min_replacements_bounded (n k : Nat) (s : String) :\n  min_replacements n k s ≤ n :=\nsorry\n\ntheorem uniform_string_zero (n k : Nat) (s : String) :\n  s = String.mk (List.replicate n 'a') →\n  min_replacements n (min k n) s = 0 :=\nsorry\n\ntheorem min_replacements_type (n k : Nat) (s : String) :\n  min_replacements n k s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_replacements 6 2 \"abaaba\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_replacements 6 3 \"abaaba\"\n\n/--\ninfo: 23\n-/\n#guard_msgs in\n#eval min_replacements 36 9 \"hippopotomonstrosesquippedaliophobia\""}
{"id": "fvapps_000070", "vc-description": "/-\nYou're given an array $a$ of $n$ integers, such that $a_1 + a_2 + \\cdots + a_n = 0$.\n\nIn one operation, you can choose two different indices $i$ and $j$ ($1 \\le i, j \\le n$), decrement $a_i$ by one and increment $a_j$ by one. If $i < j$ this operation is free, otherwise it costs one coin.\n\nHow many coins do you have to spend in order to make all elements equal to $0$?\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 5000$). Description of the test cases follows.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 10^5$)  — the number of elements.\n\nThe next line contains $n$ integers $a_1, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$). It is given that $\\sum_{i=1}^n a_i = 0$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print the minimum number of coins we have to spend in order to make all elements equal to $0$.\n\n-----Example-----\nInput\n7\n4\n-3 5 -3 1\n2\n1 -1\n4\n-3 2 -3 4\n4\n-1 1 1 -1\n7\n-5 7 -6 -4 17 -13 4\n6\n-1000000000 -1000000000 -1000000000 1000000000 1000000000 1000000000\n1\n0\n\nOutput\n3\n0\n4\n1\n8\n3000000000\n0\n\n-----Note-----\n\nPossible strategy for the first test case:   Do $(i=2, j=3)$ three times (free), $a = [-3, 2, 0, 1]$.  Do $(i=2, j=1)$ two times (pay two coins), $a = [-1, 0, 0, 1]$.  Do $(i=4, j=1)$ one time (pay one coin), $a = [0, 0, 0, 0]$.\n-/", "vc-preamble": "def sum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def solve_array_zeroes (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_array_zeroes_nonnegative (n : Nat) (arr : List Int) :\n  solve_array_zeroes n arr ≥ 0 :=\nsorry\n\ntheorem solve_array_zeroes_all_positives (n : Nat) (arr : List Int) :\n  (List.all arr (fun x => x ≥ 0)) → solve_array_zeroes n arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 5, -3, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_array_zeroes 2 [1, -1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 2, -3, 4]"}
{"id": "fvapps_000090", "vc-description": "/-\nPermutation $p$ is a sequence of integers $p=[p_1, p_2, \\dots, p_n]$, consisting of $n$ distinct (unique) positive integers between $1$ and $n$, inclusive. For example, the following sequences are permutations: $[3, 4, 1, 2]$, $[1]$, $[1, 2]$. The following sequences are not permutations: $[0]$, $[1, 2, 1]$, $[2, 3]$, $[0, 1, 2]$.\n\nThe important key is in the locked box that you need to open. To open the box you need to enter secret code. Secret code is a permutation $p$ of length $n$. \n\nYou don't know this permutation, you only know the array $q$ of prefix maximums of this permutation. Formally:  $q_1=p_1$,  $q_2=\\max(p_1, p_2)$,  $q_3=\\max(p_1, p_2,p_3)$,  ...  $q_n=\\max(p_1, p_2,\\dots,p_n)$. \n\nYou want to construct any possible suitable permutation (i.e. any such permutation, that calculated $q$ for this permutation is equal to the given array).\n\n-----Input-----\n\nThe first line contains integer number $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of a test case contains one integer $n$ $(1 \\le n \\le 10^{5})$ — the number of elements in the secret code permutation $p$.\n\nThe second line of a test case contains $n$ integers $q_1, q_2, \\dots, q_n$ $(1 \\le q_i \\le n)$ — elements of the array $q$ for secret permutation. It is guaranteed that $q_i \\le q_{i+1}$ for all $i$ ($1 \\le i < n$).\n\nThe sum of all values $n$ over all the test cases in the input doesn't exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print:  If it's impossible to find such a permutation $p$, print \"-1\" (without quotes).  Otherwise, print $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$). If there are multiple possible answers, you can print any of them. \n\n-----Example-----\nInput\n4\n5\n1 3 4 5 5\n4\n1 1 3 4\n2\n2 2\n1\n1\n\nOutput\n1 3 4 5 2 \n-1\n2 1 \n1 \n\n-----Note-----\n\nIn the first test case of the example answer $[1,3,4,5,2]$ is the only possible answer:  $q_{1} = p_{1} = 1$;  $q_{2} = \\max(p_{1}, p_{2}) = 3$;  $q_{3} = \\max(p_{1}, p_{2}, p_{3}) = 4$;  $q_{4} = \\max(p_{1}, p_{2}, p_{3}, p_{4}) = 5$;  $q_{5} = \\max(p_{1}, p_{2}, p_{3}, p_{4}, p_{5}) = 5$. \n\nIt can be proved that there are no answers for the second test case of the example.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def intList (n : Nat) : List Int :=\nsorry\n\ndef isValidPermutation (n : Nat) (result : List Int) : Bool :=\nsorry\n\ndef satisfiesQConstraints (result : List Int) (q : List Int) : Bool :=\nsorry\n\ndef solvePermutationCode (n : Nat) (q : List Int) : List Int :=\nsorry", "vc-theorems": "theorem single_element_property (n : Nat) :\n  n > 0 → n ≤ 10 →\n  let q := [Int.ofNat n]\n  let result := solvePermutationCode 1 q\n  result = [Int.ofNat n] ∨ result = [-1] :=\nsorry\n\ntheorem strictly_increasing_property (n : Nat) :\n  n > 0 → n ≤ 10 →\n  let q := intList n\n  let result := solvePermutationCode n q\n  isValidPermutation n result = true ∧\n  satisfiesQConstraints result q = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 3, 4, 5, 2]\n-/\n#guard_msgs in\n#eval solve_permutation_code 5 [1, 3, 4, 5, 5]\n\n/--\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 4 [1, 1, 3, 4]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 1 [1]"}
{"id": "fvapps_000098", "vc-description": "/-\nLee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...\n\nThe string $s$ he found is a binary string of length $n$ (i. e. string consists only of 0-s and 1-s).\n\nIn one move he can choose two consecutive characters $s_i$ and $s_{i+1}$, and if $s_i$ is 1 and $s_{i + 1}$ is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.\n\nLee can make an arbitrary number of moves (possibly zero) and he'd like to make the string $s$ as clean as possible. He thinks for two different strings $x$ and $y$, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.\n\nNow you should answer $t$ test cases: for the $i$-th test case, print the cleanest possible string that Lee can get by doing some number of moves.\n\nSmall reminder: if we have two strings $x$ and $y$ of the same length then $x$ is lexicographically smaller than $y$ if there is a position $i$ such that $x_1 = y_1$, $x_2 = y_2$,..., $x_{i - 1} = y_{i - 1}$ and $x_i < y_i$.\n\n-----Input-----\n\nThe first line contains the integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. \n\nNext $2t$ lines contain test cases — one per two lines.\n\nThe first line of each test case contains the integer $n$ ($1 \\le n \\le 10^5$) — the length of the string $s$.\n\nThe second line contains the binary string $s$. The string $s$ is a string of length $n$ which consists only of zeroes and ones.\n\nIt's guaranteed that sum of $n$ over test cases doesn't exceed $10^5$.\n\n-----Output-----\n\nPrint $t$ answers — one per test case.\n\nThe answer to the $i$-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).\n\n-----Example-----\nInput\n5\n10\n0001111111\n4\n0101\n8\n11001101\n10\n1110000000\n1\n1\n\nOutput\n0001111111\n001\n01\n0\n1\n\n-----Note-----\n\nIn the first test case, Lee can't perform any moves.\n\nIn the second test case, Lee should erase $s_2$.\n\nIn the third test case, Lee can make moves, for example, in the following order: 11001101 $\\rightarrow$ 1100101 $\\rightarrow$ 110101 $\\rightarrow$ 10101 $\\rightarrow$ 1101 $\\rightarrow$ 101 $\\rightarrow$ 01.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def clean_binary_string (n : Nat) (s : String) : String :=\nsorry\n\ndef string_of_zeros (n : Nat) : String :=\nsorry\n\ndef string_of_ones (n : Nat) : String :=\nsorry", "vc-theorems": "theorem clean_preserves_all_zeros (n : Nat) :\n  clean_binary_string n (string_of_zeros n) = string_of_zeros n :=\nsorry\n\ntheorem clean_preserves_all_ones (n : Nat) :\n  clean_binary_string n (string_of_ones n) = string_of_ones n :=\nsorry\n\ntheorem clean_preserves_monotonic_transitions (n : Nat) (s : String) :\n  s = \"0001\" ∨ s = \"0011\" ∨ s = \"0111\" → clean_binary_string n s = s :=\nsorry\n\ntheorem clean_shortens_alternating (n : Nat) :\n  clean_binary_string 4 \"0101\" = \"001\" :=\nsorry\n\ntheorem clean_shortens_complex_pattern (n : Nat) :\n  clean_binary_string 8 \"11001101\" = \"01\" :=\nsorry\n\ntheorem clean_reduces_to_minimal (n : Nat) :\n  clean_binary_string 6 \"100110\" = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '0001111111'\n-/\n#guard_msgs in\n#eval clean_binary_string 10 \"0001111111\"\n\n/--\ninfo: '001'\n-/\n#guard_msgs in\n#eval clean_binary_string 4 \"0101\"\n\n/--\ninfo: '01'\n-/\n#guard_msgs in\n#eval clean_binary_string 8 \"11001101\""}
{"id": "fvapps_000102", "vc-description": "/-\nAshish and Vivek play a game on a matrix consisting of $n$ rows and $m$ columns, where they take turns claiming cells. Unclaimed cells are represented by $0$, while claimed cells are represented by $1$. The initial state of the matrix is given. There can be some claimed cells in the initial state.\n\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\n\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\n\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\n\n-----Input-----\n\nThe first line consists of a single integer $t$ $(1 \\le t \\le 50)$ — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case consists of two space-separated integers $n$, $m$ $(1 \\le n, m \\le 50)$ — the number of rows and columns in the matrix.\n\nThe following $n$ lines consist of $m$ integers each, the $j$-th integer on the $i$-th line denoting $a_{i,j}$ $(a_{i,j} \\in \\{0, 1\\})$.\n\n-----Output-----\n\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\n\n-----Example-----\nInput\n4\n2 2\n0 0\n0 0\n2 2\n0 0\n0 1\n2 3\n1 0 1\n1 1 0\n3 3\n1 0 0\n0 0 0\n1 0 0\n\nOutput\nVivek\nAshish\nVivek\nAshish\n\n-----Note-----\n\nFor the first case: One possible scenario could be: Ashish claims cell $(1, 1)$, Vivek then claims cell $(2, 2)$. Ashish can neither claim cell $(1, 2)$, nor cell $(2, 1)$ as cells $(1, 1)$ and $(2, 2)$ are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \n\nFor the second case: Ashish claims cell $(1, 1)$, the only cell that can be claimed in the first move. After that Vivek has no moves left.\n\nFor the third case: Ashish cannot make a move, so Vivek wins.\n\nFor the fourth case: If Ashish claims cell $(2, 3)$, Vivek will have no moves left.\n-/", "vc-preamble": "def countEmptyRows (grid : List (List Nat)) : Nat :=\n  (grid.filter (fun row => row.all (fun x => x = 0))).length\n\ndef countEmptyCols (n m : Nat) (grid : List (List Nat)) : Nat :=\n  let isEmptyCol (j : Nat) := (List.range n).all (fun i =>\n    match grid.get? i with\n    | none => true\n    | some row => match row.get? j with\n      | none => true\n      | some x => x = 0)\n  (List.range m).filter isEmptyCol |>.length", "vc-helpers": "", "vc-definitions": "def solve_game (n m : Nat) (grid : List (List Nat)) : String :=\n  sorry", "vc-theorems": "theorem solve_game_returns_valid_winner (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : ∀ row ∈ grid, row.length = m)\n  (h5 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  solve_game n m grid = \"Ashish\" ∨ solve_game n m grid = \"Vivek\" :=\nsorry\n\ntheorem winner_depends_on_empty_lines (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : ∀ row ∈ grid, row.length = m)\n  (h5 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨ x = 1) :\n  let empty_rows := countEmptyRows grid\n  let empty_cols := countEmptyCols n m grid\n  let min_empty := min empty_rows empty_cols\n  solve_game n m grid = \"Ashish\" ↔ min_empty % 2 = 1 :=\nsorry\n\ntheorem all_zeros_grid (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 0)\n  solve_game n m grid = (if min n m % 2 = 1 then \"Ashish\" else \"Vivek\") :=\nsorry\n\ntheorem no_empty_lines (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 1)\n  solve_game n m grid = \"Vivek\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 0]]\n\n/--\ninfo: 'Ashish'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 1]]\n\n/--\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 3 [[1, 0, 1], [1, 1, 0]]"}
{"id": "fvapps_000104", "vc-description": "/-\n— Hey folks, how do you like this problem?\n\n— That'll do it. \n\nBThero is a powerful magician. He has got $n$ piles of candies, the $i$-th pile initially contains $a_i$ candies. BThero can cast a copy-paste spell as follows:   He chooses two piles $(i, j)$ such that $1 \\le i, j \\le n$ and $i \\ne j$.  All candies from pile $i$ are copied into pile $j$. Formally, the operation $a_j := a_j + a_i$ is performed. \n\nBThero can cast this spell any number of times he wants to — but unfortunately, if some pile contains strictly more than $k$ candies, he loses his magic power. What is the maximum number of times BThero can cast the spell without losing his power?\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 500$) — the number of test cases.\n\nEach test case consists of two lines:   the first line contains two integers $n$ and $k$ ($2 \\le n \\le 1000$, $2 \\le k \\le 10^4$);  the second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le k$). \n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $1000$, and the sum of $k$ over all test cases does not exceed $10^4$.\n\n-----Output-----\n\nFor each test case, print one integer — the maximum number of times BThero can cast the spell without losing his magic power.\n\n-----Example-----\nInput\n3\n2 2\n1 1\n3 5\n1 2 3\n3 7\n3 2 2\n\nOutput\n1\n5\n4\n\n-----Note-----\n\nIn the first test case we get either $a = [1, 2]$ or $a = [2, 1]$ after casting the spell for the first time, and it is impossible to cast it again.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_magic_candies (n : Nat) (k : Nat) (candies : List Nat) : Nat :=\n  sorry\n\ndef list_minimum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_magic_candies_minimum_case\n  (k : Nat)\n  (h1 : k ≥ 1) (h2 : k ≤ 1000) :\n  solve_magic_candies 2 k [1, 1] = k - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_magic_candies 2 2 [1, 1]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 5 [1, 2, 3]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 7 [3, 2, 2]"}
{"id": "fvapps_000107", "vc-description": "/-\nYou have a bag of size $n$. Also you have $m$ boxes. The size of $i$-th box is $a_i$, where each $a_i$ is an integer non-negative power of two.\n\nYou can divide boxes into two parts of equal size. Your goal is to fill the bag completely.\n\nFor example, if $n = 10$ and $a = [1, 1, 32]$ then you have to divide the box of size $32$ into two parts of size $16$, and then divide the box of size $16$. So you can fill the bag with boxes of size $1$, $1$ and $8$.\n\nCalculate the minimum number of divisions required to fill the bag of size $n$.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1 \\le n \\le 10^{18}, 1 \\le m \\le 10^5$) — the size of bag and the number of boxes, respectively.\n\nThe second line of each test case contains $m$ integers $a_1, a_2, \\dots , a_m$ ($1 \\le a_i \\le 10^9$) — the sizes of boxes. It is guaranteed that each $a_i$ is a power of two.\n\nIt is also guaranteed that sum of all $m$ over all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case print one integer — the minimum number of divisions required to fill the bag of size $n$ (or $-1$, if it is impossible).\n\n-----Example-----\nInput\n3\n10 3\n1 32 1\n23 4\n16 1 4 1\n20 5\n2 1 16 1 8\n\nOutput\n2\n-1\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef sum (xs : List Nat) : Nat :=\n  sorry\n\ndef min_divisions (n : Nat) (boxes : List Nat) : Int :=\n  sorry", "vc-theorems": "theorem min_divisions_properties (n : Nat) (boxes : List Nat)\n  (h1 : n ≥ 1) (h2 : ∀ x ∈ boxes, isPowerOfTwo x = true) :\n  let result := min_divisions n boxes;\n  (result ≠ -1 →\n    (result ≥ 0 ∧\n     sum boxes ≥ n)) ∧\n  (sum boxes < n →\n    result = -1) := by\n  sorry\n\ntheorem min_divisions_with_sum (boxes : List Nat)\n  (h : ∀ x ∈ boxes, isPowerOfTwo x = true) :\n  let n := sum boxes;\n  let result := min_divisions n boxes;\n  result = 0 ∨ result = -1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_divisions *test1\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_divisions *test2\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_divisions *test3"}
{"id": "fvapps_000108", "vc-description": "/-\nOn February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $k$ ($k \\ge 3$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.\n\nMountains are described by a sequence of heights $a_1, a_2, \\dots, a_n$ in order from left to right ($k \\le n$). It is guaranteed that neighboring heights are not equal to each other (that is, $a_i \\ne a_{i+1}$ for all $i$ from $1$ to $n-1$).\n\nPeaks of mountains on the segment $[l,r]$ (from $l$ to $r$) are called indexes $i$ such that $l < i < r$, $a_{i - 1} < a_i$ and $a_i > a_{i + 1}$. It is worth noting that the boundary indexes $l$ and $r$ for the segment are not peaks. For example, if $n=8$ and $a=[3,1,4,1,5,9,2,6]$, then the segment $[1,8]$ has only two peaks (with indexes $3$ and $6$), and there are no peaks on the segment $[3, 6]$.\n\nTo break the door, Nastya throws it to a segment $[l,l+k-1]$ of consecutive mountains of length $k$ ($1 \\le l \\le n-k+1$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $p+1$, where $p$ is the number of peaks on the segment $[l,l+k-1]$.\n\nNastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $[l, l+k-1]$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $l$ is minimal.\n\nFormally, you need to choose a segment of mountains $[l, l+k-1]$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $l$.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\leq t \\leq 10^4$)  — the number of test cases. Then the descriptions of the test cases follow.\n\nThe first line of each test case contains two integers $n$ and $k$ ($3 \\leq k \\leq n \\leq 2 \\cdot 10^5$)  — the number of mountains and the length of the door.\n\nThe second line of the input data set contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\leq a_i \\leq 10 ^ 9$, $a_i \\neq a_{i + 1}$)  — the heights of mountains.\n\nIt is guaranteed that the sum of $n$ over all the test cases will not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, output two integers $t$ and $l$  — the maximum number of parts that the door can split into, and the left border of the segment of length $k$ that the door should be reset to.\n\n-----Example-----\nInput\n5\n8 6\n1 2 4 1 2 4 1 2\n5 3\n3 2 3 2 1\n10 4\n4 3 4 3 2 3 2 1 0 1\n15 7\n3 7 4 8 2 3 4 5 21 2 3 4 2 1 3\n7 5\n1 2 3 4 5 6 1\n\nOutput\n3 2\n2 2\n2 1\n3 1\n2 3\n\n-----Note-----\n\nIn the first example, you need to select a segment of mountains from $2$ to $7$. In this segment, the indexes $3$ and $6$ are peaks, so the answer is $3$ (only $2$ peaks, so the door will break into $3$ parts). It is not difficult to notice that the mountain segments $[1, 6]$ and $[3, 8]$ are not suitable since they only have a $1$ peak (for the first segment, the $6$ index is not a peak, and for the second segment, the $3$ index is not a peak).\n\nIn the second example, you need to select a segment of mountains from $2$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts).\n\nIn the third example, you need to select a segment of mountains from $1$ to $4$. In this segment, the index $3$ is a peak, so the answer is $2$ (only $1$ peak, so the door will break into $2$ parts). You can see that on the segments $[2, 5]$, $[4, 7]$ and $[5, 8]$ the number of peaks is also $1$, but these segments have a left border greater than the segment $[1, 4]$, so they are not the correct answer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_peaks (window : List Nat) : Nat :=\n  sorry\n\ndef solve_door_peaks (n k : Nat) (arr : List Nat) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem peaks_atleast_one {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (peaks, _) := solve_door_peaks n k arr\n  peaks ≥ 1 :=\nsorry\n\ntheorem position_in_range {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (_, pos) := solve_door_peaks n k arr\n  1 ≤ pos ∧ pos ≤ n - k + 1 :=\nsorry\n\ntheorem peaks_match_window {n k : Nat} {arr : List Nat}\n  (h1 : n ≥ 3)\n  (h2 : k ≥ 3)\n  (h3 : k ≤ n)\n  (h4 : arr.length = n) :\n  let (peaks, pos) := solve_door_peaks n k arr\n  let window := arr.take k\n  count_peaks window = peaks - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 8 6 [1, 2, 4, 1, 2, 4, 1, 2]\n\n/--\ninfo: (2, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 5 3 [3, 2, 3, 2, 1]\n\n/--\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_door_peaks 10 4 [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]"}
{"id": "fvapps_000115", "vc-description": "/-\nAll techniques in the ninja world consist of hand seals. At the moment Naruto is learning a new technique, which consists of $n\\cdot m$ different seals, denoted by distinct numbers. All of them were written in an $n\\times m$ table.\n\nThe table is lost now. Naruto managed to remember elements of each row from left to right, and elements of each column from top to bottom, but he doesn't remember the order of rows and columns. Please restore the table consistent with this data so that Naruto will be able to learn the new technique.\n\n-----Input-----\n\nThe first line of the input contains the only integer $t$ ($1\\leq t\\leq 100\\,000$) denoting the number of test cases. Their descriptions follow.\n\nThe first line of each test case description consists of two space-separated integers $n$ and $m$ ($1 \\leq n, m \\leq 500$) standing for the number of rows and columns in the table, respectively. All hand seals are encoded by the positive integers from $1$ to $n\\cdot m$.\n\nThe following $n$ lines contain $m$ space separated integers each, denoting elements of an arbitrary row in the table left to right.\n\nThe following $m$ lines contain $n$ space separated integers each, denoting elements of an arbitrary column in the table top to bottom.\n\nSum of $nm$ over all test cases does not exceed $250\\,000$. It is guaranteed that each row occurs in the input exactly once, as well as each column. It is also guaranteed that each number from $1$ to $nm$ occurs exactly once in all rows, as well as in all columns. Finally, it is guaranteed that a table consistent with the input exists.\n\n-----Output-----\n\nFor each test case, output $n$ lines with $m$ space-separated integers each, denoting the restored table. One can show that the answer is always unique.\n\n-----Example-----\nInput\n2\n2 3\n6 5 4\n1 2 3\n1 6\n2 5\n3 4\n3 1\n2\n3\n1\n3 1 2\n\nOutput\n1 2 3 \n6 5 4 \n3 \n1 \n2 \n\n-----Note-----\n\nConsider the first test case. The matrix is $2 \\times 3$. You are given the rows and columns in arbitrary order.\n\nOne of the rows is $[6, 5, 4]$. One of the rows is $[1, 2, 3]$.\n\nOne of the columns is $[1, 6]$. One of the columns is $[2, 5]$. One of the columns is $[3, 4]$.\n\nYou are to reconstruct the matrix. The answer is given in the output.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_naruto_seals (n m : Nat) (rows cols : List (List Nat)) : List (List Nat) :=\nsorry\n\ndef is_valid_matrix (result : List (List Nat)) (n m : Nat) (rows cols : List (List Nat)) : Bool :=\nsorry\n\ndef makeMatrix (n m : Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem dimensions_check (n m : Nat) (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  List.length result = n ∧ ∀ row ∈ result, List.length row = m :=\nsorry\n\ntheorem permutations_check (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 5) (h3 : 0 < m) (h4 : m ≤ 5) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  is_valid_matrix result n m matrix matrix = true :=\nsorry\n\ntheorem single_cell_check :\n  solve_naruto_seals 1 1 [[1]] [[1]] = [[1]] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000116", "vc-description": "/-\nThere are $n$ programmers that you want to split into several non-empty teams. The skill of the $i$-th programmer is $a_i$. You want to assemble the maximum number of teams from them. There is a restriction for each team: the number of programmers in the team multiplied by the minimum skill among all programmers in the team must be at least $x$.\n\nEach programmer should belong to at most one team. Some programmers may be left without a team.\n\nCalculate the maximum number of teams that you can assemble.\n\n-----Input-----\n\nThe first line contains the integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $x$ ($1 \\le n \\le 10^5; 1 \\le x \\le 10^9$) — the number of programmers and the restriction of team skill respectively.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the skill of the $i$-th programmer.\n\nThe sum of $n$ over all inputs does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case print one integer — the maximum number of teams that you can assemble. \n\n-----Example-----\nInput\n3\n5 10\n7 11 2 9 5\n4 8\n2 4 2 3\n4 11\n1 3 3 7\n\nOutput\n2\n1\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_teams (n: Nat) (x: Nat) (skills: List Nat) : Nat :=\n  sorry\n\ndef list_sort (l: List Nat) : List Nat :=\n  sorry\n\ndef list_sum (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_teams_bounds\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: ∀ s ∈ skills, s ≥ 1 ∧ s ≤ 100) :\n  let result := max_teams n x skills\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_teams_sort_invariant\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h: skills.length = n) :\n  max_teams n x skills = max_teams n x (list_sort skills) :=\nsorry\n\ntheorem max_teams_impossible_target\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: x > (list_sum skills) * n) :\n  max_teams n x skills = 0 :=\nsorry\n\ntheorem max_teams_min_requirement\n  (n: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: ∀ s ∈ skills, s ≥ 1) :\n  max_teams n 1 skills = (List.filter (λ s => s ≥ 1) skills).length :=\nsorry\n\ntheorem max_teams_empty\n  (x: Nat) :\n  max_teams 0 x [] = 0 :=\nsorry\n\ntheorem max_teams_uniform_skills\n  (n: Nat) (skill: Nat)\n  (h1: skill ≥ 1)\n  (h2: skill ≤ 100) :\n  max_teams n skill (List.replicate n skill) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_teams 5 10 [7, 11, 2, 9, 5]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_teams 4 8 [2, 4, 2, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_teams 4 11 [1, 3, 3, 7]"}
{"id": "fvapps_000119", "vc-description": "/-\nReminder: the median of the array $[a_1, a_2, \\dots, a_{2k+1}]$ of odd number of elements is defined as follows: let $[b_1, b_2, \\dots, b_{2k+1}]$ be the elements of the array in the sorted order. Then median of this array is equal to $b_{k+1}$.\n\nThere are $2n$ students, the $i$-th student has skill level $a_i$. It's not guaranteed that all skill levels are distinct.\n\nLet's define skill level of a class as the median of skill levels of students of the class.\n\nAs a principal of the school, you would like to assign each student to one of the $2$ classes such that each class has odd number of students (not divisible by $2$). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.\n\nWhat is the minimum possible absolute difference you can achieve?\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of students halved.\n\nThe second line of each test case contains $2n$ integers $a_1, a_2, \\dots, a_{2 n}$ ($1 \\le a_i \\le 10^9$) — skill levels of students.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.\n\n-----Example-----\nInput\n3\n1\n1 1\n3\n6 5 4 1 2 3\n5\n13 4 20 13 2 5 8 3 17 16\n\nOutput\n0\n1\n5\n\n-----Note-----\n\nIn the first test, there is only one way to partition students — one in each class. The absolute difference of the skill levels will be $|1 - 1| = 0$.\n\nIn the second test, one of the possible partitions is to make the first class of students with skill levels $[6, 4, 2]$, so that the skill level of the first class will be $4$, and second with $[5, 1, 3]$, so that the skill level of the second class will be $3$. Absolute difference will be $|4 - 3| = 1$.\n\nNote that you can't assign like $[2, 3]$, $[6, 5, 4, 1]$ or $[]$, $[6, 5, 4, 1, 2, 3]$ because classes have even number of students.\n\n$[2]$, $[1, 3, 4]$ is also not possible because students with skills $5$ and $6$ aren't assigned to a class.\n\nIn the third test you can assign the students in the following way: $[3, 4, 13, 13, 20], [2, 5, 8, 16, 17]$ or $[3, 8, 17], [2, 4, 5, 13, 13, 16, 20]$. Both divisions give minimal possible absolute difference.\n-/", "vc-preamble": "def abs (x: Nat) (y: Nat) : Nat :=\nif x ≥ y then x - y else y - x", "vc-helpers": "", "vc-definitions": "def solve_min_skill_diff (n: Nat) (arr: List Nat) : Nat :=\nsorry\n\ndef list_max (xs: List Nat) : Nat :=\nsorry\n\ndef list_min (xs: List Nat) : Nat :=\nsorry\n\ndef list_sort (xs: List Nat) : List Nat :=\nsorry\n\ndef list_differences (xs: List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_skill_diff_properties {n: Nat} {arr: List Nat} (h1: n < arr.length) (h2: 1 ≤ n) (h3: arr.length ≥ 2)\n(h4: ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 1000) :\n  let result := solve_min_skill_diff n arr\n  result ≥ 0 ∧ result ≤ list_max arr - list_min arr :=\nsorry\n\ntheorem identical_values_property {arr: List Nat} (h1: arr.length ≥ 2)\n(h2: ∀ x ∈ arr, x = 1) :\n  let n := arr.length / 2\n  solve_min_skill_diff n arr = 0 :=\nsorry\n\ntheorem sorted_sequence_property {n: Nat} {arr: List Nat}\n(h1: n < arr.length) (h2: 1 ≤ n) (h3: 2 ≤ arr.length) (h4: arr.length ≤ 20)\n(h5: ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100) :\n  let result := solve_min_skill_diff n arr\n  let sorted := list_sort arr\n  let diffs := list_differences sorted\n  result ∈ diffs :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 1 [1, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 3 [6, 5, 4, 1, 2, 3]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 5 [13, 4, 20, 13, 2, 5, 8, 3, 17, 16]"}
{"id": "fvapps_000120", "vc-description": "/-\nThere are several cards arranged in a row, and each card has an associated number of points The points are given in the integer array cardPoints.\nIn one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\nYour score is the sum of the points of the cards you have taken.\nGiven the integer array cardPoints and the integer k, return the maximum score you can obtain.\n\nExample 1:\nInput: cardPoints = [1,2,3,4,5,6,1], k = 3\nOutput: 12\nExplanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.\n\nExample 2:\nInput: cardPoints = [2,2,2], k = 2\nOutput: 4\nExplanation: Regardless of which two cards you take, your score will always be 4.\n\nExample 3:\nInput: cardPoints = [9,7,7,9,7,7,9], k = 7\nOutput: 55\nExplanation: You have to take all the cards. Your score is the sum of points of all cards.\n\nExample 4:\nInput: cardPoints = [1,1000,1], k = 1\nOutput: 1\nExplanation: You cannot take the card in the middle. Your best score is 1. \n\nExample 5:\nInput: cardPoints = [1,79,80,1,1,1,200,1], k = 3\nOutput: 202\n\nConstraints:\n\n1 <= cardPoints.length <= 10^5\n1 <= cardPoints[i] <= 10^4\n1 <= k <= cardPoints.length\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Int) : Int :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry\n\ndef take (n : Nat) (l : List Int) : List Int :=\n  sorry\n\ndef drop (n : Nat) (l : List Int) : List Int :=\n  sorry\n\ndef map (f : Int → Int) (l : List Int) : List Int :=\n  sorry\n\ndef maxScore (cards : List Int) (k : Nat) : Int :=\n  sorry", "vc-theorems": "", "vc-postamble": ""}
{"id": "fvapps_000123", "vc-description": "/-\nYour task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n\nExample1:\n\na = 2\nb = [3]\n\nResult: 8\n\nExample2:\n\na = 2\nb = [1,0]\n\nResult: 1024\n\nCredits:Special thanks to @Stomach_ache for adding this problem and creating all test cases.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def super_pow (base : Int) (exponent_digits : List Int) : Int :=\n  sorry\n\ndef pow_mod (base exp m : Int) : Int :=\n  sorry", "vc-theorems": "theorem super_pow_range (base : Int) (exp_digits : List Int)\n  (h1 : base > 0)\n  (h2 : exp_digits.length > 0)\n  (h3 : exp_digits.length ≤ 10)\n  (h4 : ∀ d ∈ exp_digits, 0 ≤ d ∧ d ≤ 9) :\n  let result := super_pow base exp_digits\n  0 ≤ result ∧ result < 1337 :=\nsorry\n\ntheorem super_pow_small_exp (base : Int) (exp_digit : Int)\n  (h1 : base > 0)\n  (h2 : 0 ≤ exp_digit)\n  (h3 : exp_digit < 5) :\n  super_pow base [exp_digit] = pow_mod base exp_digit 1337 :=\nsorry\n\ntheorem super_pow_zero (base : Int)\n  (h : base > 0) :\n  super_pow base [0] = 1 :=\nsorry\n\ntheorem super_pow_one (base : Int) (exp_digits : List Int)\n  (h1 : exp_digits.length > 0)\n  (h2 : exp_digits.length ≤ 5)\n  (h3 : ∀ d ∈ exp_digits, 0 ≤ d ∧ d ≤ 9) :\n  super_pow 1 exp_digits = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval super_pow 2 [3]\n\n/--\ninfo: 1024\n-/\n#guard_msgs in\n#eval super_pow 2 [1, 0]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval super_pow 3 [2]"}
{"id": "fvapps_000125", "vc-description": "/-\nThere is a group of G members, and a list of various crimes they could commit.\nThe ith crime generates a profit[i] and requires group[i] members to participate in it.\nIf a member participates in one crime, that member can't participate in another crime.\nLet's call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of members participating in that subset of crimes is at most G.\nHow many schemes can be chosen?  Since the answer may be very large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: G = 5, P = 3, group = [2,2], profit = [2,3]\nOutput: 2\nExplanation: \nTo make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\nExample 2:\nInput: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]\nOutput: 7\nExplanation: \nTo make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n\nNote:\n\n1 <= G <= 100\n0 <= P <= 100\n1 <= group[i] <= 100\n0 <= profit[i] <= 100\n1 <= group.length = profit.length <= 100\n-/\n\n-- Empty list cases\n\n-- Scaling property\n\n-- Basic properties", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def profitable_schemes (G : Nat) (P : Nat) (group : List Nat) (profit : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem profitable_schemes_non_negative (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit ≥ 0 :=\nsorry\n\ntheorem profitable_schemes_mod_bound (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit < MOD :=\nsorry\n\ntheorem profitable_schemes_empty_zero_profit (G : Nat) :\n  profitable_schemes G 0 [] [] = 1 :=\nsorry\n\ntheorem profitable_schemes_empty_positive_profit (G P : Nat) :\n  P > 0 → profitable_schemes G P [] [] = 0 :=\nsorry\n\ntheorem profitable_schemes_scaling (G P : Nat) (group profit : List Nat) :\n  group ≠ [] →\n  profit.length = group.length →\n  profitable_schemes G P group profit =\n  profitable_schemes G (2 * P) group (List.map (fun p => 2 * p) profit) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval profitable_schemes 5 3 [2, 2] [2, 3]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval profitable_schemes 10 5 [2, 3, 5] [6, 7, 8]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval profitable_schemes 1 1 [1] [1]"}
{"id": "fvapps_000126", "vc-description": "/-\nImplement a basic calculator to evaluate a simple expression string.\n\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\n\nExample 1:\n\nInput: \"1 + 1\"\nOutput: 2\n\nExample 2:\n\nInput: \" 2-1 + 2 \"\nOutput: 3\n\nExample 3:\n\nInput: \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\nNote:\n\n       You may assume that the given expression is always valid.\n       Do not use the eval built-in library function.\n-/", "vc-preamble": "def makeParens (n : Nat) : String :=\n  match n with\n  | 0 => \"\"\n  | n+1 => \"(\" ++ makeParens n", "vc-helpers": "", "vc-definitions": "def calculate (s : String) : Int :=\nsorry", "vc-theorems": "theorem single_number {n : Int} (h : -1000 ≤ n ∧ n ≤ 1000) :\n  calculate s!\"{n}\" = n :=\nsorry\n\ntheorem addition {a b : Int} (h : -100 ≤ a ∧ a ≤ 100 ∧ -100 ≤ b ∧ b ≤ 100) :\n  calculate s!\"{a}+{b}\" = a + b :=\nsorry\n\ntheorem nested_parentheses {n : Int} (h : -50 ≤ n ∧ n ≤ 50) :\n  calculate s!\"{makeParens n.toNat}1{makeParens n.toNat}\" = 1 :=\nsorry\n\ntheorem parentheses_operations {a b : Int} (h : -50 ≤ a ∧ a ≤ 50 ∧ -50 ≤ b ∧ b ≤ 50) :\n  calculate s!\"({a})+({b})\" = a + b ∧\n  calculate s!\"({a})-({b})\" = a - b :=\nsorry\n\ntheorem whitespace_invariance (spaces : String) (h : ∀ c ∈ spaces.data, c = ' ') :\n  calculate \"1+2\" = calculate s!\"{spaces}1{spaces}+{spaces}2{spaces}\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval calculate \"\"1 + 1\"\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval calculate \"\" 2-1 + 2 \"\"\n\n/--\ninfo: 23\n-/\n#guard_msgs in\n#eval calculate \"\"(1+(4+5+2)-3)+(6+8)\"\""}
{"id": "fvapps_000128", "vc-description": "/-\nA program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k. There can be multiple ways to restore the array.\nReturn the number of possible array that can be printed as a string s using the mentioned program.\nThe number of ways could be very large so return it modulo 10^9 + 7\n\nExample 1:\nInput: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]\n\nExample 2:\nInput: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n\nExample 3:\nInput: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]\n\nExample 4:\nInput: s = \"2020\", k = 30\nOutput: 1\nExplanation: The only possible array is [20,20]. [2020] is invalid because 2020 > 30. [2,020] is ivalid because 020 contains leading zeros.\n\nExample 5:\nInput: s = \"1234567890\", k = 90\nOutput: 34\n\nConstraints:\n\n1 <= s.length <= 10^5.\ns consists of only digits and doesn't contain leading zeros.\n1 <= k <= 10^9.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.repeat (s : String) (n : Nat) : String :=\n  sorry\n\ndef number_of_arrays (s : String) (k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_digit_valid {d : Char} {k : Nat}\n  (h1 : d ∈ ['1', '2', '3', '4', '5', '6', '7', '8', '9'])\n  (h2 : k > 0)\n  : number_of_arrays (String.mk [d]) k = if (d.toNat - 48) ≤ k then 1 else 0 :=\nsorry\n\ntheorem single_zero_invalid {k : Nat} (h : k > 0)\n  : number_of_arrays \"0\" k = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10000\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval number_of_arrays \"1317\" 2000"}
{"id": "fvapps_000131", "vc-description": "/-\nYou are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.\nA string is said to be balanced if each of its characters appears n/4 times where n is the length of the string.\nReturn the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.\nReturn 0 if the string is already balanced.\n\nExample 1:\nInput: s = \"QWER\"\nOutput: 0\nExplanation: s is already balanced.\nExample 2:\nInput: s = \"QQWE\"\nOutput: 1\nExplanation: We need to replace a 'Q' to 'R', so that \"RQWE\" (or \"QRWE\") is balanced.\n\nExample 3:\nInput: s = \"QQQW\"\nOutput: 2\nExplanation: We can replace the first \"QQ\" to \"ER\". \n\nExample 4:\nInput: s = \"QQQQ\"\nOutput: 3\nExplanation: We can replace the last 3 'Q' to make s = \"QWER\".\n\nConstraints:\n\n1 <= s.length <= 10^5\ns.length is a multiple of 4\ns contains only 'Q', 'W', 'E' and 'R'.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def balanced_string (s : String) : Int :=\nsorry\n\ndef has_equal_quarters (s : String) : Bool :=\nsorry\n\ndef count_char (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem invalid_length_returns_negative {s : String} :\n  (s.length % 4 ≠ 0) → balanced_string s = -1 :=\nsorry\n\ntheorem result_within_bounds {s : String} :\n  balanced_string s ≠ -1 →\n  0 ≤ balanced_string s ∧ balanced_string s ≤ s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval balanced_string \"QWER\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval balanced_string \"QQWE\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval balanced_string \"QQQW\""}
{"id": "fvapps_000137", "vc-description": "/-\nWe are given an array A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\",\"vyz\"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] <= A[1] <= A[2] ... <= A[A.length - 1]).\nReturn the minimum possible value of D.length.\n\nExample 1:\nInput: [\"ca\",\"bb\",\"ac\"]\nOutput: 1\nExplanation: \nAfter deleting the first column, A = [\"a\", \"b\", \"c\"].\nNow A is in lexicographic order (ie. A[0] <= A[1] <= A[2]).\nWe require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.\n\nExample 2:\nInput: [\"xc\",\"yb\",\"za\"]\nOutput: 0\nExplanation: \nA is already in lexicographic order, so we don't need to delete anything.\nNote that the rows of A are not necessarily in lexicographic order:\nie. it is NOT necessarily true that (A[0][0] <= A[0][1] <= ...)\n\nExample 3:\nInput: [\"zyx\",\"wvu\",\"tsr\"]\nOutput: 3\nExplanation: \nWe have to delete every column.\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100\n-/\n\n/- Output is bounded between 0 and string length -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Already sorted columns need 0 deletions -/\n\n/- Reverse sorted columns need at most string length deletions -/\n\n/- Identical strings need 0 deletions -/\n\n-- imagine this is the input with sorted columns\n\n-- imagine this is input with reverse sorted columns", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minDeletionSize (A : List (List Char)) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (A : List (List Char)) (h : A.all (λ s => s.length = A.head!.length)) :\n  let result := minDeletionSize A\n  0 ≤ result ∧ result ≤ A.head!.length :=\nsorry\n\ntheorem sorted_columns_zero_deletions (A : List (List Char)) (h : A.all (λ s => s.length = A.head!.length)) :\n  let sorted_columns := A\n  minDeletionSize sorted_columns = 0 :=\nsorry\n\ntheorem reverse_sorted_most_deletions (A : List (List Char)) (h₁ : A ≠ []) (h₂ : A.all (λ s => s.length = A.head!.length)) :\n  let reverse_sorted := A\n  minDeletionSize reverse_sorted ≤ A.head!.length :=\nsorry\n\ntheorem identical_strings_zero_deletions (A : List (List Char)) (s : List Char)\n    (h₁ : A ≠ []) (h₂ : A.all (λ str => str = s)) :\n  minDeletionSize A = 0 :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_deletion_size [\"ca\", \"bb\", \"ac\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_deletion_size [\"xc\", \"yb\", \"za\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_deletion_size [\"zyx\", \"wvu\", \"tsr\"]"}
{"id": "fvapps_000139", "vc-description": "/-\nThe i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)\n\nExample 1:\nInput: people = [1,2], limit = 3\nOutput: 1\nExplanation: 1 boat (1, 2)\n\nExample 2:\nInput: people = [3,2,2,1], limit = 3\nOutput: 3\nExplanation: 3 boats (1, 2), (2) and (3)\n\nExample 3:\nInput: people = [3,5,3,4], limit = 5\nOutput: 4\nExplanation: 4 boats (3), (3), (4), (5)\nNote:\n\n1 <= people.length <= 50000\n1 <= people[i] <= limit <= 30000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numRescueBoats (people : List Nat) (limit : Nat) : Nat :=\n  sorry\n\ndef listMax (l : List Nat) : Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry\n\ndef listSort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem rescue_boats_minimum (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit ≥ (people.length + 1) / 2 := by\n  sorry\n\ntheorem rescue_boats_maximum (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit ≤ people.length := by\n  sorry\n\ntheorem rescue_boats_deterministic (people : List Nat) (h : people ≠ []) :\n  let limit := listMax people\n  numRescueBoats people limit = numRescueBoats people limit := by\n  sorry\n\ntheorem single_person_per_boat (weights : List Nat) (h : weights ≠ []) :\n  let min_limit := listMin weights\n  numRescueBoats weights min_limit = weights.length := by\n  sorry\n\ntheorem sorted_same_result (people : List Nat) (limit : Nat)\n    (h1 : people.length ≥ 2) (h2 : ∀ x ∈ people, x ≤ 100) (h3 : limit ≤ 100) :\n  numRescueBoats people limit = numRescueBoats (listSort people) limit := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval numRescueBoats [1, 2] 3\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 2, 2, 1] 3\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 5, 3, 4] 5"}
{"id": "fvapps_000141", "vc-description": "/-\nIn a row of trees, the i-th tree produces fruit with type tree[i].\nYou start at any tree of your choice, then repeatedly perform the following steps:\n\nAdd one piece of fruit from this tree to your baskets.  If you cannot, stop.\nMove to the next tree to the right of the current tree.  If there is no tree to the right, stop.\n\nNote that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.\nYou have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.\nWhat is the total amount of fruit you can collect with this procedure?\n\nExample 1:\nInput: [1,2,1]\nOutput: 3\nExplanation: We can collect [1,2,1].\n\nExample 2:\nInput: [0,1,2,2]\nOutput: 3\nExplanation: We can collect [1,2,2].\nIf we started at the first tree, we would only collect [0, 1].\n\nExample 3:\nInput: [1,2,3,2,2]\nOutput: 4\nExplanation: We can collect [2,3,2,2].\nIf we started at the first tree, we would only collect [1, 2].\n\nExample 4:\nInput: [3,3,3,1,2,1,1,2,3,3,4]\nOutput: 5\nExplanation: We can collect [1,2,1,1,2].\nIf we started at the first tree or the eighth tree, we would only collect 4 fruits.\n\nNote:\n\n1 <= tree.length <= 40000\n0 <= tree[i] < tree.length\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_fruit (tree : List Nat) : Nat :=\nsorry\n\ndef maxSubseqLengthWithTwoTypes (tree : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem total_fruit_bounds {tree : List Nat} (h : tree ≠ []) :\n  1 ≤ total_fruit tree ∧ total_fruit tree ≤ tree.length :=\nsorry\n\ntheorem total_fruit_min_length {tree : List Nat} (h : tree.length ≥ 3) :\n  total_fruit tree ≥ 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 1]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [0, 1, 2, 2]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 3, 2, 2]"}
{"id": "fvapps_000148", "vc-description": "/-\nGiven an array A, partition it into two (contiguous) subarrays left and right so that:\n\nEvery element in left is less than or equal to every element in right.\nleft and right are non-empty.\nleft has the smallest possible size.\n\nReturn the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.\n\nExample 1:\nInput: [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\nExample 2:\nInput: [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\nNote:\n\n2 <= A.length <= 30000\n0 <= A[i] <= 10^6\nIt is guaranteed there is at least one way to partition A as described.\n-/", "vc-preamble": "def List.maximum' : List Int → Int\n  | [] => 0 \n  | [x] => x\n  | (x::xs) => max x (List.maximum' xs)\n\ndef List.Sorted : List Int → Prop := List.Pairwise (· ≤ ·)\n\ndef partitioned_at (p : Nat) (nums : List Int) : Prop :=\n  let left := (nums.take p)\n  let right := (nums.drop p)\n  let left_max := List.maximum' left\n  (∀ x ∈ left, x ≤ left_max) ∧\n  (∀ x ∈ right, x ≥ left_max)", "vc-helpers": "", "vc-definitions": "def partition_disjoint (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem partition_point_valid : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  1 ≤ res ∧ res ≤ nums.length :=\nsorry\n\ntheorem partition_left_properties : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let left_max := List.maximum' left\n  ∀ x ∈ left, x ≤ left_max :=\nsorry\n\ntheorem partition_right_properties : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  ∀ x ∈ right, x ≥ left_max :=\nsorry\n\ntheorem sorted_list_partitions_at_one : ∀ nums, nums.length ≥ 2 →\n  List.Sorted nums →\n  partition_disjoint nums = 1 :=\nsorry\n\ntheorem no_smaller_elements_after_partition : ∀ nums, nums.length ≥ 2 →\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  ¬∃ x ∈ right, x < left_max :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [5, 0, 3, 8, 6]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval partition_disjoint [1, 1, 1, 0, 6, 12]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [3, 1, 2, 4, 5]"}
{"id": "fvapps_000149", "vc-description": "/-\nA password is considered strong if below conditions are all met:\n\n It has at least 6 characters and at most 20 characters. \n It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. \n It must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met). \n\nWrite a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.\n\nInsertion, deletion or replace of any one character are all considered as one change.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef hasThreeRepeated (s : String) : Bool :=\n  sorry\n\ndef strongPasswordChecker (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem output_non_negative (s : String) :\n  strongPasswordChecker s ≥ 0 :=\nsorry\n\ntheorem valid_password_needs_no_changes (s : String) :\n  (s.length ≥ 6 ∧ s.length ≤ 20 ∧\n   s.any isLower ∧\n   s.any isUpper ∧\n   s.any isDigit ∧\n   ¬hasThreeRepeated s) →\n  strongPasswordChecker s = 0 :=\nsorry\n\ntheorem short_password_minimum_changes (s : String) :\n  s.length < 6 →\n  strongPasswordChecker s ≥ 6 - s.length :=\nsorry\n\ntheorem long_password_minimum_changes (s : String) :\n  s.length > 20 →\n  strongPasswordChecker s ≥ s.length - 20 :=\nsorry\n\ntheorem missing_categories_minimum_changes (s : String) :\n  let missing := (if s.any isLower then 0 else 1) +\n                 (if s.any isUpper then 0 else 1) +\n                 (if s.any isDigit then 0 else 1)\n  strongPasswordChecker s ≥ missing :=\nsorry\n\ntheorem repeated_chars_minimum_changes (s : String) :\n  (∀ c : Char, c ∈ s.data → c = 'a') →\n  s.length ≥ 3 →\n  strongPasswordChecker s ≥ s.length / 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"a\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"aA1\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"1337C0d3\""}
{"id": "fvapps_000150", "vc-description": "/-\nIn universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\nGiven the integer array position and the integer m. Return the required force.\n\nExample 1:\n\nInput: position = [1,2,3,4,7], m = 3\nOutput: 3\nExplanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\nExample 2:\nInput: position = [5,4,3,2,1,1000000000], m = 2\nOutput: 999999999\nExplanation: We can use baskets 1 and 1000000000.\n\nConstraints:\n\nn == position.length\n2 <= n <= 10^5\n1 <= position[i] <= 10^9\nAll integers in position are distinct.\n2 <= m <= position.length\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_distance (positions : List Nat) (m : Nat) : Nat :=\n  sorry\n\ndef can_place_balls (distance : Nat) (sorted_pos : List Nat) (m : Nat) : Bool :=\nsorry", "vc-theorems": "theorem max_distance_bounds {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  result ≥ 0 ∧\n  result ≤ (positions[positions.length-1]! - positions[0]!) :=\nsorry\n\ntheorem max_distance_placement {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  can_place_balls result positions m = true :=\nsorry\n\ntheorem max_distance_maximal {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length)\n  (h4 : ∀ x ∈ positions, x ≥ 1 ∧ x ≤ 1000000000) :\n  let result := max_distance positions m\n  result < (positions[positions.length-1]! - positions[0]!) →\n  can_place_balls (result + 1) positions m = false :=\nsorry\n\ntheorem max_distance_input_preservation {positions : List Nat} {m : Nat}\n  (h1 : positions.length ≥ 2)\n  (h2 : m ≥ 2)\n  (h3 : m ≤ positions.length) :\n  positions = positions :=\nsorry\n\ntheorem max_distance_edge_cases :\n  max_distance [1, 1000000000] 2 = 999999999 ∧\n  max_distance [1,2,3] 3 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 7] 3\n\n/--\ninfo: 999999999\n-/\n#guard_msgs in\n#eval max_distance [5, 4, 3, 2, 1, 1000000000] 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 5, 6] 4"}
{"id": "fvapps_000154", "vc-description": "/-\nGiven two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may return any of them.\n(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)\n\nExample 1:\nInput: str1 = \"abac\", str2 = \"cab\"\nOutput: \"cabac\"\nExplanation: \nstr1 = \"abac\" is a subsequence of \"cabac\" because we can delete the first \"c\".\nstr2 = \"cab\" is a subsequence of \"cabac\" because we can delete the last \"ac\".\nThe answer provided is the shortest such string that satisfies these properties.\n\nNote:\n\n1 <= str1.length, str2.length <= 1000\nstr1 and str2 consist of lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubsequence (s₁ s₂ : String) : Bool :=\nsorry\n\ndef shortestCommonSupersequence (s₁ s₂ : String) : String :=\nsorry", "vc-theorems": "theorem scs_contains_both_strings (s₁ s₂ : String) :\n  let result := shortestCommonSupersequence s₁ s₂\n  isSubsequence s₁ result = true ∧ isSubsequence s₂ result = true :=\nsorry\n\ntheorem scs_same_string (s : String) :\n  shortestCommonSupersequence s s = s :=\nsorry\n\ntheorem scs_length_bounds (s₁ s₂ : String) :\n  let result := shortestCommonSupersequence s₁ s₂\n  result.length ≥ max s₁.length s₂.length ∧\n  result.length ≤ s₁.length + s₂.length :=\nsorry\n\ntheorem scs_empty_string (s : String) :\n  shortestCommonSupersequence \"\" s = s ∧\n  shortestCommonSupersequence s \"\" = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'cabac'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"abac\" \"cab\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval len shortest_common_supersequence(\"abc\", \"def\")\n\n/--\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"aaaaa\" \"aa\""}
{"id": "fvapps_000161", "vc-description": "/-\nGiven a string num representing the digits of a very large integer and an integer k.\nYou are allowed to swap any two adjacent digits of the integer at most k times.\nReturn the minimum integer you can obtain also as a string.\n\nExample 1:\n\nInput: num = \"4321\", k = 4\nOutput: \"1342\"\nExplanation: The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n\nExample 2:\nInput: num = \"100\", k = 1\nOutput: \"010\"\nExplanation: It's ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n\nExample 3:\nInput: num = \"36789\", k = 1000\nOutput: \"36789\"\nExplanation: We can keep the number without any swaps.\n\nExample 4:\nInput: num = \"22\", k = 22\nOutput: \"22\"\n\nExample 5:\nInput: num = \"9438957234785635408\", k = 23\nOutput: \"0345989723478563548\"\n\nConstraints:\n\n1 <= num.length <= 30000\nnum contains digits only and doesn't have leading zeros.\n1 <= k <= 10^9\n-/", "vc-preamble": "def stringToList (s : String) : List Char := s.data\n\ndef listToString (l : List Char) : String := String.mk l\n\ndef charListOrdered (l₁ l₂ : List Char) : Bool :=\n  match l₁, l₂ with\n  | [], [] => true\n  | x::xs, y::ys => if x.val < y.val then true\n                    else if x.val = y.val then charListOrdered xs ys\n                    else false\n  | _, _ => false\n\ndef countChar (c : Char) (s : String) : Nat :=\n  s.data.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def minInteger (num : String) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem minInteger_length (num : String) (k : Nat) :\n  (minInteger num k).length = num.length :=\nsorry\n\ntheorem minInteger_leq_input (num : String) (k : Nat) :\n  minInteger num k ≤ num :=\nsorry\n\ntheorem minInteger_zero_k (num : String) :\n  minInteger num 0 = num :=\nsorry\n\ntheorem minInteger_monotonic (num : String) (k₁ k₂ : Nat) :\n  k₁ ≤ k₂ → minInteger num k₂ ≤ minInteger num k₁ :=\nsorry\n\ntheorem minInteger_char_count (num : String) (k : Nat) (c : Char) :\n  countChar c (minInteger num k) = countChar c num :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '1342'\n-/\n#guard_msgs in\n#eval minInteger \"4321\" 4\n\n/--\ninfo: '010'\n-/\n#guard_msgs in\n#eval minInteger \"100\" 1\n\n/--\ninfo: '36789'\n-/\n#guard_msgs in\n#eval minInteger \"36789\" 1000"}
{"id": "fvapps_000163", "vc-description": "/-\nGiven 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).\nFlip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\n\nExample 1:\n\nInput: a = 2, b = 6, c = 5\nOutput: 3\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)\nExample 2:\nInput: a = 4, b = 2, c = 7\nOutput: 1\n\nExample 3:\nInput: a = 1, b = 2, c = 3\nOutput: 0\n\nConstraints:\n\n1 <= a <= 10^9\n1 <= b <= 10^9\n1 <= c <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_flips (a b c : Nat) : Nat :=\nsorry\n\ndef count_ones (n : Nat) : Nat :=\nsorry\n\ndef bitwise_or (a b : Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_flips_non_negative (a b c : Nat) :\n  min_flips a b c ≥ 0 :=\nsorry\n\ntheorem min_flips_identity_left (c : Nat) :\n  min_flips c 0 c = 0 :=\nsorry\n\ntheorem min_flips_identity_right (c : Nat) :\n  min_flips 0 c c = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_flips 2 6 5\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_flips 4 2 7\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_flips 1 2 3"}
{"id": "fvapps_000167", "vc-description": "/-\nGiven an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nA subarray is a contiguous subsequence of the array.\nReturn the length of the shortest subarray to remove.\n\nExample 1:\nInput: arr = [1,2,3,10,4,2,3,5]\nOutput: 3\nExplanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4].\nExample 2:\nInput: arr = [5,4,3,2,1]\nOutput: 4\nExplanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].\n\nExample 3:\nInput: arr = [1,2,3]\nOutput: 0\nExplanation: The array is already non-decreasing. We do not need to remove any elements.\n\nExample 4:\nInput: arr = [1]\nOutput: 0\n\nConstraints:\n\n1 <= arr.length <= 10^5\n0 <= arr[i] <= 10^9\n-/\n\n-- Output is between 0 and length of array\n\n-- There exists some subarray of length result that when removed makes array non-decreasing\n\n-- Cannot remove fewer elements to make array non-decreasing\n\n-- Sorted array returns 0\n\n-- Small arrays", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_length_of_shortest_subarray (arr : List Int) : Nat :=\n  sorry\n\ndef isNonDecreasing (l : List Int) : Bool :=\n  sorry\n\ndef removeSubarray (arr : List Int) (start : Nat) (len : Nat) : List Int :=\n  sorry", "vc-theorems": "theorem output_bounds (arr : List Int) :\n  let result := find_length_of_shortest_subarray arr\n  0 ≤ result ∧ result ≤ arr.length :=\nsorry\n\ntheorem valid_removal_exists (arr : List Int) (h : arr ≠ []) :\n  let result := find_length_of_shortest_subarray arr\n  ∃ i : Nat, i + result ≤ arr.length ∧\n    isNonDecreasing (removeSubarray arr i result) :=\nsorry\n\ntheorem cannot_remove_fewer (arr : List Int) (h : arr ≠ []) :\n  let result := find_length_of_shortest_subarray arr\n  result = 0 → isNonDecreasing arr\n  ∧\n  result > 0 → ∀ i : Nat, i + (result - 1) ≤ arr.length →\n    ¬isNonDecreasing (removeSubarray arr i (result - 1)) :=\nsorry\n\ntheorem sorted_returns_zero (arr : List Int) (h : arr ≠ []) :\n  isNonDecreasing arr → find_length_of_shortest_subarray arr = 0 :=\nsorry\n\ntheorem small_arrays (arr : List Int) :\n  arr.length ≤ 1 → find_length_of_shortest_subarray arr = 0\n  ∧\n  (arr.length = 2 →\n    find_length_of_shortest_subarray arr =\n      if arr.get! 0 ≤ arr.get! 1 then 0 else 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3, 10, 4, 2, 3, 5]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [5, 4, 3, 2, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3]"}
{"id": "fvapps_000169", "vc-description": "/-\nYou are given an integer num. You will apply the following steps exactly two times:\n\nPick a digit x (0 <= x <= 9).\nPick another digit y (0 <= y <= 9). The digit y can be equal to x.\nReplace all the occurrences of x in the decimal representation of num by y.\nThe new integer cannot have any leading zeros, also the new integer cannot be 0.\n\nLet a and b be the results of applying the operations to num the first and second times, respectively.\nReturn the max difference between a and b.\n\nExample 1:\nInput: num = 555\nOutput: 888\nExplanation: The first time pick x = 5 and y = 9 and store the new integer in a.\nThe second time pick x = 5 and y = 1 and store the new integer in b.\nWe have now a = 999 and b = 111 and max difference = 888\n\nExample 2:\nInput: num = 9\nOutput: 8\nExplanation: The first time pick x = 9 and y = 9 and store the new integer in a.\nThe second time pick x = 9 and y = 1 and store the new integer in b.\nWe have now a = 9 and b = 1 and max difference = 8\n\nExample 3:\nInput: num = 123456\nOutput: 820000\n\nExample 4:\nInput: num = 10000\nOutput: 80000\n\nExample 5:\nInput: num = 9288\nOutput: 8700\n\nConstraints:\n\n1 <= num <= 10^8\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxDiff (n : Nat) : Nat :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem maxDiff_single_digit (n : Nat) (h : n < 10) : maxDiff n = 8 :=\nsorry\n\ntheorem maxDiff_properties (n : Nat) :\n  n ≥ 10 →\n  maxDiff n ≥ 0 ∧\n  maxDiff n ≤ 999999 :=\nsorry\n\ntheorem maxDiff_nonnegative (n : Nat) : maxDiff n ≥ 0 :=\nsorry", "vc-postamble": "-- Helper function to get number of digits\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 888\n-/\n#guard_msgs in\n#eval maxDiff 555\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval maxDiff 9\n\n/--\ninfo: 820000\n-/\n#guard_msgs in\n#eval maxDiff 123456"}
{"id": "fvapps_000170", "vc-description": "/-\nGiven an array of integers arr of even length n and an integer k.\nWe want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.\nReturn True If you can find a way to do that or False otherwise.\n\nExample 1:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: Pairs are (1,9),(2,8),(3,7),(4,6) and (5,10).\n\nExample 2:\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: Pairs are (1,6),(2,5) and(3,4).\n\nExample 3:\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.\n\nExample 4:\nInput: arr = [-10,10], k = 2\nOutput: true\n\nExample 5:\nInput: arr = [-1,1,-2,2,-3,3,-4,4], k = 3\nOutput: true\n\nConstraints:\n\narr.length == n\n1 <= n <= 10^5\nn is even.\n-10^9 <= arr[i] <= 10^9\n1 <= k <= 10^5\n-/", "vc-preamble": "def Even (n : Nat) : Prop := ∃ k, n = 2 * k\n\ndef countOdds (xs : List Int) : Nat :=\n  xs.foldl (fun acc x => if x % 2 = 1 then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def can_arrange (arr : List Int) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem can_arrange_result_type (arr : List Int) (k : Nat) :\n  can_arrange arr k = true ∨ can_arrange arr k = false :=\nsorry\n\ntheorem can_arrange_even_length {arr : List Int} {k : Nat} :\n  can_arrange arr k = true → List.length arr % 2 = 0 :=\nsorry\n\ntheorem can_arrange_k_one {arr : List Int} :\n  can_arrange arr 1 = true ↔ List.length arr % 2 = 0 :=\nsorry\n\ntheorem can_arrange_k_two {arr : List Int} :\n  can_arrange arr 2 = true →\n  Even (countOdds arr) :=\nsorry\n\ntheorem can_arrange_empty {k : Nat} :\n  can_arrange [] k = true :=\nsorry\n\ntheorem can_arrange_singleton {x : Int} {k : Nat} :\n  can_arrange [x] k = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 10, 6, 7, 8, 9] 5\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 6] 10\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [-1, 1, -2, 2, -3, 3, -4, 4] 3"}
{"id": "fvapps_000173", "vc-description": "/-\nGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n\nBelow is one possible representation of s1 = \"great\":\n\n    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n\nTo scramble the string, we may choose any non-leaf node and swap its two children.\n\nFor example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\n\n    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n\nWe say that \"rgeat\" is a scrambled string of \"great\".\n\nSimilarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\n\n    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n\nWe say that \"rgtae\" is a scrambled string of \"great\".\n\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\n\nExample 1:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\n\nExample 2:\n\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- We'll use substring operations instead of direct char manipulation -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isScramble (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem equal_strings_are_scramble (s : String) :\n  isScramble s s = true :=\nsorry\n\ntheorem different_lengths_not_scramble (s : String) :\n  isScramble s (s ++ \"a\") = false :=\nsorry\n\ntheorem different_chars_not_scramble (s : String) (h : s.length > 0) :\n  ∀ (s2 : String), s.length = s2.length → (∃ c, s.contains c ≠ s2.contains c) →\n  isScramble s s2 = false :=\nsorry\n\ntheorem length_two_strings_scramble (s1 s2 : String) :\n  s1.length = 2 → s2.length = 2 → (∀ c, s1.contains c = s2.contains c) →\n  isScramble s1 s2 = true :=\nsorry\n\ntheorem scramble_symmetric (s1 s2 : String) :\n  isScramble s1 s2 = isScramble s2 s1 :=\nsorry\n\ntheorem empty_strings_are_scramble :\n  isScramble \"\" \"\" = true :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"great\" \"rgeat\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_scramble \"abcde\" \"caebd\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"a\" \"a\""}
{"id": "fvapps_000177", "vc-description": "/-\nA car travels from a starting position to a destination which is target miles east of the starting position.\nAlong the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.\nThe car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.\nWhen the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\nWhat is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\n\nExample 1:\nInput: target = 1, startFuel = 1, stations = []\nOutput: 0\nExplanation: We can reach the target without refueling.\n\nExample 2:\nInput: target = 100, startFuel = 1, stations = [[10,100]]\nOutput: -1\nExplanation: We can't reach the target (or even the first gas station).\n\nExample 3:\nInput: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\nOutput: 2\nExplanation: \nWe start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\nNote:\n\n1 <= target, startFuel, stations[i][1] <= 10^9\n0 <= stations.length <= 500\n0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target\n-/", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def min_refuel_stops (target : Nat) (start_fuel : Nat) (stations : List (Nat × Nat)) : Int :=\n  sorry", "vc-theorems": "theorem min_refuel_stops_result_valid (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result ≥ -1 :=\nsorry\n\ntheorem min_refuel_stops_sufficient_start_fuel (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  start_fuel ≥ target →\n  min_refuel_stops target start_fuel stations = 0 :=\nsorry\n\ntheorem min_refuel_stops_impossible (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let total_fuel := start_fuel + list_sum (stations.map Prod.snd)\n  total_fuel < target →\n  min_refuel_stops target start_fuel stations = -1 :=\nsorry\n\ntheorem min_refuel_stops_stations_ordered (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  stations.length > 0 →\n  ∀ i : Nat, i < stations.length - 1 →\n  (stations.get! i).1 ≤ (stations.get! (i+1)).1 :=\nsorry\n\ntheorem min_refuel_stops_bound (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat × Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result ≠ -1 →\n  result ≤ stations.length :=\nsorry\n\ntheorem min_refuel_stops_empty_stations_sufficient (start_fuel target : Nat) :\n  target ≤ start_fuel →\n  min_refuel_stops target start_fuel [] = 0 :=\nsorry\n\ntheorem min_refuel_stops_empty_stations_insufficient (start_fuel target : Nat) :\n  start_fuel < target →\n  min_refuel_stops target start_fuel [] = -1 :=\nsorry\n\ntheorem min_refuel_stops_zero_start_fuel (target : Nat) (stations : List (Nat × Nat)) :\n  min_refuel_stops target 0 stations = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_refuel_stops 1 1 []\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 1 [[10, 100]]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 10 [[10, 60], [20, 30], [30, 30], [60, 40]]"}
{"id": "fvapps_000184", "vc-description": "/-\nYou are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.\n\nExample 1:\n\nInput: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.\nExample 2:\nInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n\nExample 3:\nInput: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1.\n\nExample 4:\nInput: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8\nOutput: 9\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait, the wheel rotates. Current profit is 4 * $3 - 1 * $8 = $4.\n2. 10 customers arrive, 4 board and 12 wait, the wheel rotates. Current profit is 8 * $3 - 2 * $8 = $8.\n3. 6 customers arrive, 4 board and 14 wait, the wheel rotates. Current profit is 12 * $3 - 3 * $8 = $12.\n4. 4 customers arrive, 4 board and 14 wait, the wheel rotates. Current profit is 16 * $3 - 4 * $8 = $16.\n5. 7 customers arrive, 4 board and 17 wait, the wheel rotates. Current profit is 20 * $3 - 5 * $8 = $20.\n6. 4 board and 13 wait, the wheel rotates. Current profit is 24 * $3 - 6 * $8 = $24.\n7. 4 board and 9 wait, the wheel rotates. Current profit is 28 * $3 - 7 * $8 = $28.\n8. 4 board and 5 wait, the wheel rotates. Current profit is 32 * $3 - 8 * $8 = $32.\n9. 4 board and 1 waits, the wheel rotates. Current profit is 36 * $3 - 9 * $8 = $36.\n10. 1 board and 0 wait, the wheel rotates. Current profit is 37 * $3 - 10 * $8 = $31.\nThe highest profit was $36 after rotating the wheel 9 times.\n\nConstraints:\n\nn == customers.length\n1 <= n <= 105\n0 <= customers[i] <= 50\n1 <= boardingCost, runningCost <= 100\n-/", "vc-preamble": "def list_sum (xs: List Nat) : Nat :=\nxs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def min_operations_max_profit (customers: List Nat) (boarding_cost: Nat) (running_cost: Nat) : Int :=\nsorry", "vc-theorems": "theorem min_operations_result_valid\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x ≤ 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    result = -1 ∨ result > 0 :=\nsorry\n\ntheorem min_operations_max_rotations\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x ≤ 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    let total := list_sum customers\n    let max_rotations := total / 4 + (if total % 4 = 0 then 0 else 1)\n    result = -1 ∨ result ≤ max_rotations + total :=\nsorry\n\ntheorem high_running_cost_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: customers.length ≤ 10)\n  (h3: boarding_cost > 0)\n  (h4: boarding_cost ≤ 10)\n  (h5: ∀ x ∈ customers, x ≤ 10)\n  : min_operations_max_profit customers boarding_cost 1000 = -1 :=\nsorry\n\ntheorem high_profit_scenario_profitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost ≥ 100)\n  (h3: ∀ x ∈ customers, x ≥ 100 ∧ x ≤ 1000)\n  : min_operations_max_profit customers boarding_cost 1 > 0 :=\nsorry\n\ntheorem no_customers_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: ∀ x ∈ customers, x = 0)\n  : min_operations_max_profit customers boarding_cost running_cost = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_operations_max_profit [8, 3] 5 6\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_operations_max_profit [10, 9, 6] 6 4\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_operations_max_profit [3, 4, 0, 5, 1] 1 92"}
{"id": "fvapps_000187", "vc-description": "/-\nGiven an array of digits, you can write numbers using each digits[i] as many times as we want.  For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.\nReturn the number of positive integers that can be generated that are less than or equal to a given integer n.\n\nExample 1:\nInput: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\nOutput: 20\nExplanation: \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\nExample 2:\nInput: digits = [\"1\",\"4\",\"9\"], n = 1000000000\nOutput: 29523\nExplanation: \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\nExample 3:\nInput: digits = [\"7\"], n = 8\nOutput: 1\n\nConstraints:\n\n1 <= digits.length <= 9\ndigits[i].length == 1\ndigits[i] is a digit from '1' to '9'.\nAll the values in digits are unique.\n1 <= n <= 109\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "def countValidDigits (digits : List String) (n : Nat) : Nat :=\n  (digits.filter (fun d => d.toNat?.getD 0 ≤ n)).length", "vc-helpers": "", "vc-definitions": "def atMostNGivenDigitSet (digits : List String) (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_nonnegative {digits : List String} {n : Nat} :\n  0 ≤ atMostNGivenDigitSet digits n :=\nsorry\n\ntheorem result_within_max_possible {digits : List String} {n : Nat} :\n  let max_len := toString n |>.length\n  atMostNGivenDigitSet digits n ≤ (digits.length ^ max_len) :=\nsorry\n\ntheorem single_digit_result {digits : List String} {n : Nat} :\n  n < 10 →\n  atMostNGivenDigitSet digits n = countValidDigits digits n :=\nsorry\n\ntheorem empty_digit_list_fails (n : Nat) :\n  atMostNGivenDigitSet [] n = 0 :=\nsorry\n\ntheorem single_digit_basic_cases_1 :\n  atMostNGivenDigitSet [\"1\"] 1 = 1 :=\nsorry\n\ntheorem single_digit_basic_cases_2 :\n  atMostNGivenDigitSet [\"9\"] 10 = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000189", "vc-description": "/-\nGiven an array arr.  You can choose a set of integers and remove all the occurrences of these integers in the array.\nReturn the minimum size of the set so that at least half of the integers of the array are removed.\n\nExample 1:\nInput: arr = [3,3,3,3,5,5,5,2,2,7]\nOutput: 2\nExplanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).\nPossible sets of size 2 are {3,5},{3,2},{5,2}.\nChoosing set {2,7} is not possible as it will make the new array [3,3,3,3,5,5,5] which has size greater than half of the size of the old array.\n\nExample 2:\nInput: arr = [7,7,7,7,7,7]\nOutput: 1\nExplanation: The only possible set you can choose is {7}. This will make the new array empty.\n\nExample 3:\nInput: arr = [1,9]\nOutput: 1\n\nExample 4:\nInput: arr = [1000,1000,3,7]\nOutput: 1\n\nExample 5:\nInput: arr = [1,2,3,4,5,6,7,8,9,10]\nOutput: 5\n\nConstraints:\n\n1 <= arr.length <= 10^5\narr.length is even.\n1 <= arr[i] <= 10^5\n-/", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + sum t\n\ndef listRange (n : Nat) : List Int :=\n  (List.range n).map Int.ofNat", "vc-helpers": "", "vc-definitions": "def min_set_size (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem min_set_size_positive (arr : List Int) (h : arr ≠ []) :\n  min_set_size arr > 0 :=\nsorry\n\ntheorem min_set_size_upper_bound (arr : List Int) (h : arr ≠ []) :\n  min_set_size arr ≤ arr.length :=\nsorry\n\ntheorem min_set_size_removes_half (arr : List Int) (h : arr ≠ []) :\n  let countMap := arr.map (fun x => (arr.filter (· = x)).length)\n  let removed := countMap.take (min_set_size arr)\n  sum removed ≥ arr.length / 2 :=\nsorry\n\ntheorem min_set_size_all_same (arr : List Int) (h : arr ≠ []) :\n  (∀ i j, i < arr.length → j < arr.length → arr[i]! = arr[j]!) →\n  min_set_size arr = 1 :=\nsorry\n\ntheorem min_set_size_all_unique (n : Nat) :\n  min_set_size (listRange n) = (n + 1) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_set_size [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_set_size [7, 7, 7, 7, 7, 7]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval min_set_size [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"}
{"id": "fvapps_000191", "vc-description": "/-\nGiven an array of integers A, find the number of triples of indices (i, j, k) such that:\n\n0 <= i < A.length\n0 <= j < A.length\n0 <= k < A.length\nA[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.\n\nExample 1:\nInput: [2,1,3]\nOutput: 12\nExplanation: We could choose the following i, j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0, j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 & 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) : 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0, k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\nNote:\n\n1 <= A.length <= 1000\n0 <= A[i] < 2^16\n-/\n\n-- Basic properties\n\n-- For prime numbers\n\n-- For prime powers\n\n-- For products\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def is_prime (n : Int) : Prop :=\n  n > 1 ∧ ∀ k, 2 ≤ k → k < n → ¬(n % k = 0)", "vc-helpers": "", "vc-definitions": "def sum_of_prime_factors (n : Int) : Int :=\n  sorry\n\ndef pow (base exp : Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_prime_factors_positive {n : Int} (h : n ≥ 2) :\n  sum_of_prime_factors n > 0 ∧ sum_of_prime_factors n ≤ n :=\nsorry\n\ntheorem sum_prime_factors_nonpositive {n : Int} (h : n ≤ 1) :\n  sum_of_prime_factors n = 0 :=\nsorry\n\ntheorem sum_prime_factors_of_prime {n : Int} (h : is_prime n) :\n  sum_of_prime_factors n = n :=\nsorry\n\ntheorem sum_prime_factors_of_prime_power {p k : Int}\n  (hp : is_prime p) (hk : k > 0) :\n  sum_of_prime_factors (pow p k) = p :=\nsorry\n\ntheorem sum_prime_factors_of_product {a b : Int} (ha : a ≥ 2) (hb : b ≥ 2) :\n  sum_of_prime_factors (a * b) ≤ sum_of_prime_factors a + sum_of_prime_factors b :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000192", "vc-description": "/-\nGiven a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.\nHere, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 <= i < A.length, and C[i+A.length] = C[i] when i >= 0.)\nAlso, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i <= k1, k2 <= j with k1 % A.length = k2 % A.length.)\n\nExample 1:\nInput: [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3\n\nExample 2:\nInput: [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10\n\nExample 3:\nInput: [3,-1,2,-1]\nOutput: 4\nExplanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4\n\nExample 4:\nInput: [3,-2,2,-3]\nOutput: 3\nExplanation: Subarray [3] and [3,-2,2] both have maximum sum 3\n\nExample 5:\nInput: [-2,-3,-1]\nOutput: -1\nExplanation: Subarray [-1] has maximum sum -1\n\nNote: \n\n-30000 <= A[i] <= 30000\n1 <= A.length <= 30000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSubarraySumCircular (nums : List Int) : Int :=\nsorry\n\ndef isEmpty (nums : List Int) : Bool :=\nsorry\n\ndef maxElem (nums : List Int) : Int :=\nsorry\n\ndef sumList (nums : List Int) : Int :=\nsorry\n\ndef isAllPositive (nums : List Int) : Bool :=\nsorry\n\ndef isAllNegative (nums : List Int) : Bool :=\nsorry\n\ndef rotate (nums : List Int) (i : Nat) : List Int :=\nsorry", "vc-theorems": "theorem single_element (nums : List Int) (h : nums.length = 1) (first : Int) :\n  nums = [first] → maxSubarraySumCircular nums = first :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, 3, -2, 1]\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [5, -3, 5]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, -3, -1]"}
{"id": "fvapps_000195", "vc-description": "/-\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nYour algorithm should run in O(n) complexity.\n\nExample:\n\nInput: [100, 4, 200, 1, 3, 2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_consecutive (nums : List Int) : Nat :=\nsorry\n\ndef removeDuplicates (nums : List Int) : List Int :=\nsorry\n\ndef sortList (nums : List Int) : List Int :=\nsorry", "vc-theorems": "theorem output_nonnegative (nums : List Int) :\n  longest_consecutive nums ≥ 0 :=\nsorry\n\ntheorem same_as_deduplicated (nums : List Int) :\n  longest_consecutive nums = longest_consecutive (removeDuplicates nums) :=\nsorry\n\ntheorem sorted_same_as_unsorted (nums : List Int) :\n  nums ≠ [] → longest_consecutive nums = longest_consecutive (sortList nums) :=\nsorry\n\ntheorem output_leq_input_len (nums : List Int) :\n  longest_consecutive nums ≤ nums.length :=\nsorry\n\ntheorem empty_list_zero (nums : List Int) :\n  nums = [] → longest_consecutive nums = 0 :=\nsorry\n\ntheorem single_element_one (nums : List Int) (x : Int) :\n  nums = [x] → longest_consecutive nums = 1 :=\nsorry\n\ntheorem reversed_same (nums : List Int) :\n  nums ≠ [] → longest_consecutive nums = longest_consecutive nums.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_consecutive [100, 4, 200, 1, 3, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval longest_consecutive [1, 2, 0, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_consecutive []"}
{"id": "fvapps_000209", "vc-description": "/-\nImplement pow(x, n), which calculates x raised to the power n (xn).\n\nExample 1:\n\nInput: 2.00000, 10\nOutput: 1024.00000\n\nExample 2:\n\nInput: 2.10000, 3\nOutput: 9.26100\n\nExample 3:\n\nInput: 2.00000, -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\nNote:\n\n       -100.0 < x < 100.0\n       n is a 32-bit signed integer, within the range [−231, 231 − 1]\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def myPow (x : Float) (n : Int) : Float :=\n  sorry\n\ndef isClose (a b : Float) (relTol absTol : Float := 0.0) : Bool :=\n  sorry", "vc-theorems": "theorem myPow_matches_mathPow {x : Float} {n : Int}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10)\n  (n_range : -5 ≤ n ∧ n ≤ 5) :\n  isClose (myPow x n) (Float.pow x (Float.ofInt n)) (relTol := 1e-5) (absTol := 1e-5) :=\nsorry\n\ntheorem myPow_zero_exponent {x : Float}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10) :\n  myPow x 0 = 1.0 :=\nsorry\n\ntheorem myPow_inverse_property {x : Float} {n : Int}\n  (x_range : 0.1 ≤ x ∧ x ≤ 10)\n  (n_range : 1 ≤ n ∧ n ≤ 2) :\n  isClose ((myPow x n) * (myPow x (-n))) 1.0 (relTol := 1e-5) (absTol := 1e-5) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000211", "vc-description": "/-\nGiven an array nums of positive integers. Your task is to select some subset of nums, multiply each element by an integer and add all these numbers. The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand.\nReturn True if the array is good otherwise return False.\n\nExample 1:\nInput: nums = [12,5,7,23]\nOutput: true\nExplanation: Pick numbers 5 and 7.\n5*3 + 7*(-2) = 1\n\nExample 2:\nInput: nums = [29,6,10]\nOutput: true\nExplanation: Pick numbers 29, 6 and 10.\n29*1 + 6*(-3) + 10*(-1) = 1\n\nExample 3:\nInput: nums = [3,6]\nOutput: false\n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isGoodArray (nums : List Nat) : Bool :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef listGcd (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem good_array_gcd {nums : List Nat} (h : nums ≠ []) :\n  isGoodArray nums = true ↔ listGcd nums = 1\n  :=\nsorry\n\ntheorem multiples_not_good {n : Nat} (h : n ≥ 2) :\n  isGoodArray [n, 2*n, 3*n, 4*n] = false\n  :=\nsorry\n\ntheorem scale_makes_not_good {nums : List Nat} (h : nums ≠ []) :\n  isGoodArray (nums.map (· * 2)) = false\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[12, 5, 7, 23]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[29, 6, 10]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval isGoodArray #[3, 6]"}
{"id": "fvapps_000213", "vc-description": "/-\nWe have an array A of non-negative integers.\nFor every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].\nReturn the number of possible results.  (Results that occur more than once are only counted once in the final answer.)\n\nExample 1:\nInput: [0]\nOutput: 1\nExplanation: \nThere is only one possible result: 0.\n\nExample 2:\nInput: [1,1,2]\nOutput: 3\nExplanation: \nThe possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values, so the answer is 3.\n\nExample 3:\nInput: [1,2,4]\nOutput: 6\nExplanation: \nThe possible results are 1, 2, 3, 4, 6, and 7.\n\nNote:\n\n1 <= A.length <= 50000\n0 <= A[i] <= 10^9\n-/", "vc-preamble": "def countUnique (l: List Nat) : Nat :=\n  (List.foldl (fun acc x => if acc.contains x then acc else x::acc) [] l).length", "vc-helpers": "", "vc-definitions": "def subarrayBitwiseORs (nums: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_is_nonnegative {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≥ 0 :=\nsorry\n\ntheorem result_upper_bound {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≤ (nums.length * (nums.length + 1)) / 2 :=\nsorry\n\ntheorem single_element_subarray {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≥ countUnique nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [0]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 1, 2]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 2, 4]"}
{"id": "fvapps_000217", "vc-description": "/-\nGiven a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)\nReturn any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is \"\".)\n\nExample 1:\nInput: \"banana\"\nOutput: \"ana\"\n\nExample 2:\nInput: \"abcd\"\nOutput: \"\"\n\nNote:\n\n2 <= S.length <= 10^5\nS consists of lowercase English letters.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_dup_substring (s : String) : String :=\nsorry\n\ndef isSubstringOf (sub str : String) : Bool :=\nsorry\n\ndef countOccurrences (needle haystack : String) (start : Nat) : Nat :=\nsorry\n\ndef hasLongerDuplicate (s : String) (len : Nat) : Bool :=\nsorry", "vc-theorems": "theorem longest_dup_occurs_twice {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  if result.length > 0 then\n    countOccurrences result s 0 ≥ 2\n  else True :=\nsorry\n\ntheorem no_longer_duplicate_exists {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  ∀ len, len > result.length →\n  hasLongerDuplicate s len = false :=\nsorry\n\ntheorem longest_dup_is_substring {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  isSubstringOf result s = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000222", "vc-description": "/-\nGiven an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.\nReturn the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].\n\nExample 1:\nInput: [1,17,8]\nOutput: 2\nExplanation: \n[1,8,17] and [17,8,1] are the valid permutations.\n\nExample 2:\nInput: [2,2,2]\nOutput: 1\n\nNote:\n\n1 <= A.length <= 12\n0 <= A[i] <= 1e9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n: Nat) : Nat :=\nsorry\n\ndef numSquarefulPerms (A: List Nat) : Nat :=\nsorry\n\ndef factorial (n: Nat) : Nat :=\nsorry", "vc-theorems": "def isPerfectSquare (n: Nat) : Bool :=\n  match n with\n  | 0 => true\n  | n + 1 =>\n    let sq := sqrt n\n    sq * sq = n\n\ntheorem output_bounds\n  (A: List Nat)\n  (h1: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :\n  let result := numSquarefulPerms A\n  0 ≤ result ∧ result ≤ factorial A.length :=\nsorry\n\ntheorem valid_permutations\n  (A: List Nat)\n  (h1: A.length ≥ 2)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)\n  (h3: numSquarefulPerms A > 0) :\n  ∃ i, i < A.length - 1 ∧ isPerfectSquare (A[i]! + A[i+1]!) :=\nsorry\n\ntheorem identical_elements\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)\n  (x: Nat)\n  (h3: x = A[0]!) :\n  numSquarefulPerms (List.replicate A.length x) = 0 ∨\n  numSquarefulPerms (List.replicate A.length x) = 1 :=\nsorry\n\ntheorem sorting_invariance\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :\n  numSquarefulPerms A = numSquarefulPerms (List.reverse A) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 17, 8]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval numSquarefulPerms [2, 2, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 1]"}
{"id": "fvapps_000223", "vc-description": "/-\nGiven an array A of 0s and 1s, we may change up to K values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s. \n\nExample 1:\nInput: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2\nOutput: 6\nExplanation: \n[1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\nExample 2:\nInput: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3\nOutput: 10\nExplanation: \n[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1.  The longest subarray is underlined.\n\nNote:\n\n1 <= A.length <= 20000\n0 <= K <= A.length\nA[i] is 0 or 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestOnes (A : List Nat) (K : Nat) : Nat :=\nsorry\n\ndef isConsecutiveOnes (A : List Nat) (n : Nat) : Prop :=\nsorry\n\ndef maxConsecutiveOnes (A : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem longestOnes_upper_bound (A : List Nat) (K : Nat) :\n  longestOnes A K ≤ A.length :=\nsorry\n\ntheorem longestOnes_min_bound (A : List Nat) (K : Nat) (n : Nat) :\n  isConsecutiveOnes A n → n ≤ longestOnes A K :=\nsorry\n\ntheorem longestOnes_zero_k (A : List Nat) :\n  longestOnes A 0 = maxConsecutiveOnes A :=\nsorry\n\ntheorem longestOnes_large_k (A : List Nat) (K : Nat) :\n  K ≥ A.length → longestOnes A K = A.length :=\nsorry\n\ntheorem longestOnes_single_zero (K : Nat) :\n  longestOnes [0] K = min 1 K :=\nsorry\n\ntheorem longestOnes_single_one (K : Nat) :\n  longestOnes [1] K = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0] 2\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval longestOnes [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1] 3\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 1] 2"}
{"id": "fvapps_000224", "vc-description": "/-\nGiven a string s and an integer k.\nReturn the maximum number of vowel letters in any substring of s with length k.\nVowel letters in English are (a, e, i, o, u).\n\nExample 1:\nInput: s = \"abciiidef\", k = 3\nOutput: 3\nExplanation: The substring \"iii\" contains 3 vowel letters.\n\nExample 2:\nInput: s = \"aeiou\", k = 2\nOutput: 2\nExplanation: Any substring of length 2 contains 2 vowels.\n\nExample 3:\nInput: s = \"leetcode\", k = 3\nOutput: 2\nExplanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.\n\nExample 4:\nInput: s = \"rhythms\", k = 4\nOutput: 0\nExplanation: We can see that s doesn't have any vowel letters.\n\nExample 5:\nInput: s = \"tryhard\", k = 4\nOutput: 1\n\nConstraints:\n\n1 <= s.length <= 10^5\ns consists of lowercase English letters.\n1 <= k <= s.length\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_vowels (s : String) (k : Nat) : Nat :=\nsorry\n\ndef count_vowels (s : String) : Nat :=\nsorry\n\ndef is_vowel (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem max_vowels_monotonic {s : String} {k : Nat}\n  (h1 : k < String.length s) :\n  max_vowels s k ≤ max_vowels s (k + 1) :=\nsorry\n\ntheorem max_vowels_empty {k : Nat}\n  (h1 : k > 0) :\n  max_vowels \"\" k = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_vowels \"abciiidef\" 3\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_vowels \"leetcode\" 3\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_vowels \"rhythms\" 4"}
{"id": "fvapps_000230", "vc-description": "/-\nGiven a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid.\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\n\nGiven a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.\n\nExample 1:\nInput: \"())\"\nOutput: 1\n\nExample 2:\nInput: \"(((\"\nOutput: 3\n\nExample 3:\nInput: \"()\"\nOutput: 0\n\nExample 4:\nInput: \"()))((\"\nOutput: 4\n\nNote:\n\nS.length <= 1000\nS only consists of '(' and ')' characters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_parens_to_add (s : String) : Nat :=\nsorry\n\ndef is_balanced (s : String) : Bool :=\nsorry\n\ndef count_char (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem empty_string : min_parens_to_add \"\" = 0 :=\nsorry\n\ntheorem unmatched_open (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n '(')) = n :=\nsorry\n\ntheorem unmatched_close (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n ')')) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_parens_to_add \"())\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_parens_to_add \"(((\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_parens_to_add \"()\""}
{"id": "fvapps_000236", "vc-description": "/-\nGiven a string, sort it in decreasing order based on the frequency of characters.\n\nExample 1:\n\nInput:\n\"tree\"\n\nOutput:\n\"eert\"\n\nExplanation:\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\n\nExample 2:\n\nInput:\n\"cccaaa\"\n\nOutput:\n\"cccaaa\"\n\nExplanation:\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\n\nExample 3:\n\nInput:\n\"Aabb\"\n\nOutput:\n\"bbAa\"\n\nExplanation:\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def frequency_sort (s : String) : String :=\n  sorry\n\ndef countOccurrences (c : Char) (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem frequency_sort_maintains_length (s : String) :\n  (frequency_sort s).length = s.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000242", "vc-description": "/-\nIn English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.\n\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\n\nYou need to output the sentence after the replacement.\n\nExample 1:\n\nInput: dict = [\"cat\", \"bat\", \"rat\"]\nsentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n\nNote:\n\nThe input will only have lower-case letters.\n 1 \n 1 \n 1 \n 1\n-/", "vc-preamble": "def splitIntoWords (s : String) : List String := s.split (· == ' ')\n\ndef wordCount (s : String) : Nat := (splitIntoWords s).length", "vc-helpers": "", "vc-definitions": "def replace_words (dict : List String) (sentence : String) : String :=\nsorry", "vc-theorems": "theorem replace_words_output_length_matches_input\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  wordCount (replace_words dict sentence) = words.length :=\nsorry\n\ntheorem replace_words_output_words_valid\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  ∀ (i : Nat) (h : i < words.length),\n    result[i]! = words[i]! ∨ result[i]! ∈ dict :=\nsorry\n\ntheorem replace_words_replacement_preserves_prefix\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  ∀ (i : Nat) (h : i < words.length),\n    result[i]! ∈ dict → words[i]!.startsWith result[i]! :=\nsorry\n\ntheorem empty_dict_preserves_input\n  (dict : List String) (word : String) (h_dict : dict = []) :\n  replace_words dict word = word :=\nsorry\n\ntheorem replace_words_idempotent\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (h_dict : dict.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let once := replace_words dict sentence\n  let twice := replace_words dict once\n  once = twice :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'the cat was rat by the bat'\n-/\n#guard_msgs in\n#eval replace_words [\"cat\", \"bat\", \"rat\"] \"the cattle was rattled by the battery\"\n\n/--\ninfo: 'a a a'\n-/\n#guard_msgs in\n#eval replace_words [\"a\", \"aa\", \"aaa\"] \"aa aaa aaaa\""}
{"id": "fvapps_000243", "vc-description": "/-\nGiven an array of integers arr and an integer target.\nYou have to find two non-overlapping sub-arrays of arr each with sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.\nReturn the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.\n\nExample 1:\nInput: arr = [3,2,2,4,3], target = 3\nOutput: 2\nExplanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n\nExample 2:\nInput: arr = [7,3,4,7], target = 7\nOutput: 2\nExplanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n\nExample 3:\nInput: arr = [4,3,2,6,2,3,4], target = 6\nOutput: -1\nExplanation: We have only one sub-array of sum = 6.\n\nExample 4:\nInput: arr = [5,5,4,4,5], target = 3\nOutput: -1\nExplanation: We cannot find a sub-array of sum = 3.\n\nExample 5:\nInput: arr = [3,1,1,1,5,1,2,1], target = 3\nOutput: 3\nExplanation: Note that sub-arrays [1,2] and [2,1] cannot be an answer because they overlap.\n\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= arr[i] <= 1000\n1 <= target <= 10^8\n-/", "vc-preamble": "def sumOfSubarray (arr : List Int) (i j : Nat) : Int :=\n  (arr.take j).drop i |>.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def minSumOfLengths (arr : List Int) (target : Int) : Int :=\n  sorry", "vc-theorems": "theorem edge_cases_return_negative_one (target : Int) :\n  minSumOfLengths [] target = -1 ∧\n  minSumOfLengths [1] (2 : Int) = -1 ∧\n  minSumOfLengths [0] (0 : Int) = -1 :=\nsorry\n\ntheorem valid_result_bounds {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ target ∧ target ≤ 1000)\n  (h3 : arr ≠ [])\n  (h4 : minSumOfLengths arr target ≠ -1) :\n  2 ≤ minSumOfLengths arr target ∧ minSumOfLengths arr target ≤ arr.length :=\nsorry\n\ntheorem negative_result_implies_no_valid_subarrays {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 0 ≤ x ∧ x ≤ 10)\n  (h2 : 0 ≤ target ∧ target ≤ 20)\n  (h3 : ¬∃ i j, 0 ≤ i ∧ i < j ∧ j ≤ arr.length ∧\n       sumOfSubarray arr i j = target) :\n  minSumOfLengths arr target = -1 :=\nsorry\n\ntheorem negative_one_implies_no_non_overlapping_subarrays {arr : List Int} {target : Int}\n  (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10)\n  (h2 : 1 ≤ target ∧ target ≤ 20)\n  (h3 : arr.length ≥ 4)\n  (h4 : minSumOfLengths arr target = -1) :\n  ¬∃ i j k l,\n    0 ≤ i ∧ i < j ∧ j ≤ k ∧ k < l ∧ l ≤ arr.length ∧\n    sumOfSubarray arr i j = target ∧\n    sumOfSubarray arr k l = target :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [3, 2, 2, 4, 3] 3\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [7, 3, 4, 7] 7\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [4, 3, 2, 6, 2, 3, 4] 6"}
{"id": "fvapps_000244", "vc-description": "/-\nGiven a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.\n\nExample 1:\n\nInput: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:\n\nExample 2:\n\nInput: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:\n\nExample 3:\n\nInput: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 500\n1 <= n <= 500\ngrid consists only of lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.rectangular (grid : List (List α)) : Bool :=\n  sorry\n\ndef contains_cycle (grid : List (List Char)) : Bool :=\n  sorry", "vc-theorems": "theorem contains_cycle_empty_raises : ∀ (grid : List (List Char)),\n  grid = [] ∨ grid.head?.map (λ row => row = []) = some true →\n  contains_cycle grid = false :=\nsorry\n\ntheorem contains_cycle_returns_bool : ∀ (grid : List (List Char)),\n  grid ≠ [] →\n  grid.head?.map (λ row => row ≠ []) = some true →\n  grid.rectangular = true →\n  (contains_cycle grid = true ∨ contains_cycle grid = false) :=\nsorry\n\ntheorem contains_cycle_all_same_char : ∀ (c : Char) (n : Nat),\n  n > 0 →\n  let grid := List.replicate n (List.replicate n c);\n  contains_cycle grid = (n > 1) :=\nsorry\n\ntheorem contains_cycle_checkerboard : ∀ (n : Nat),\n  n ≥ 2 →\n  let grid := List.map (λ i => List.map (λ j => if (i+j)%2 = 0 then 'a' else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = false :=\nsorry\n\ntheorem contains_cycle_border : ∀ (n : Nat),\n  n ≥ 3 →\n  let grid := List.map (λ i => List.map (λ j =>\n    if i = 0 ∨ i = n-1 ∨ j = 0 ∨ j = n-1\n    then 'a'\n    else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"a\", \"a\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"a\", \"a\", \"a\"]]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"c\", \"c\", \"c\", \"a\"], [\"c\", \"d\", \"c\", \"c\"], [\"c\", \"c\", \"e\", \"c\"], [\"f\", \"c\", \"c\", \"c\"]]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"b\", \"b\"], [\"b\", \"z\", \"b\"], [\"b\", \"b\", \"a\"]]"}
{"id": "fvapps_000249", "vc-description": "/-\nYou have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. \n\nFor each move, you could choose any m (1 ≤ m ≤ n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  \n\nGiven an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n\nExample1\n\nInput: [1,0,5]\n\nOutput: 3\n\nExplanation: \n1st move:    1     0     1     1     4\n2nd move:    1     2     1     3    \n3rd move:    2     1     2     2     2   \n\nExample2\n\nInput: [0,3,0]\n\nOutput: 2\n\nExplanation: \n1st move:    0     1     2     0    \n2nd move:    1     2 --> 0    =>    1     1     1     \n\nExample3\n\nInput: [0,2,0]\n\nOutput: -1\n\nExplanation: \nIt's impossible to make all the three washing machines have the same number of dresses. \n\nNote:\n\nThe range of n is [1, 10000].\nThe range of dresses number in a super washing machine is [0, 1e5].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Nat) : Nat :=\nsorry\n\ndef listMax (l : List Nat) : Nat :=\nsorry\n\ndef findMinMoves (machines : List Nat) : Int :=\nsorry", "vc-theorems": "theorem find_min_moves_non_negative\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  findMinMoves machines ≥ 0 :=\nsorry\n\ntheorem find_min_moves_preserves_sum\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  sum machines = machines.length * (sum machines / machines.length) :=\nsorry\n\ntheorem find_min_moves_lower_bound\n  {machines : List Nat}\n  (h : findMinMoves machines ≠ -1) :\n  findMinMoves machines ≥\n    max (listMax machines - sum machines / machines.length) 0 :=\nsorry\n\ntheorem find_min_moves_negative_one\n  {machines : List Nat}\n  (h : findMinMoves machines = -1) :\n  sum machines % machines.length ≠ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_moves [1, 0, 5]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_moves [0, 3, 0]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_moves [0, 2, 0]"}
{"id": "fvapps_000254", "vc-description": "/-\nGiven an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\nIt is guaranteed that there will be an answer.\n\nExample 1:\nInput: nums = [1,2,5,9], threshold = 6\nOutput: 5\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \n\nExample 2:\nInput: nums = [2,3,5,7,11], threshold = 11\nOutput: 3\n\nExample 3:\nInput: nums = [19], threshold = 5\nOutput: 4\n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n1 <= nums[i] <= 10^6\nnums.length <= threshold <= 10^6\n-/", "vc-preamble": "def ceil_div (a b : Nat) : Nat :=\n  (a + b - 1) / b\n\ndef list_max (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | (x::xs) => List.foldl max x xs", "vc-helpers": "", "vc-definitions": "def find_smallest_divisor (nums : List Nat) (threshold : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_element_case {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length = 1)\n  (h2 : threshold > 0)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000000)\n  (h4 : threshold ≤ 1000000) :\n  find_smallest_divisor nums threshold = ceil_div nums[0] threshold :=\nsorry\n\ntheorem result_bounded {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length > 0)\n  (h2 : nums.length ≤ 10)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100)\n  (h4 : 1 ≤ threshold ∧ threshold ≤ 100) :\n  1 ≤ find_smallest_divisor nums threshold ∧\n  find_smallest_divisor nums threshold ≤ list_max nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_smallest_divisor [1, 2, 5, 9] 6\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_smallest_divisor [2, 3, 5, 7, 11] 11\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_smallest_divisor [19] 5"}
{"id": "fvapps_000255", "vc-description": "/-\nA sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. \n\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\n\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\n\nExamples:\n\nInput: [1,7,4,9,2,5]\nOutput: 6\nThe entire sequence is a wiggle sequence.\n\nInput: [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n\nInput: [1,2,3,4,5,6,7,8,9]\nOutput: 2\n\nFollow up:\nCan you do it in O(n) time?\n\nCredits:Special thanks to @agave and @StefanPochmann for adding this problem and creating all test cases.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def wiggleMaxLength (arr : List Int) : Nat :=\nsorry\n\ndef isSorted (l : List Int) : Bool :=\nsorry", "vc-theorems": "theorem wiggle_length_bounds (arr : List Int) :\n  0 ≤ wiggleMaxLength arr ∧ wiggleMaxLength arr ≤ arr.length :=\nsorry\n\ntheorem monotonic_increasing_bound (arr : List Int) :\n  arr.length > 1 → isSorted arr = true → wiggleMaxLength arr ≤ 2 :=\nsorry\n\ntheorem small_array_property (arr : List Int) :\n  arr.length < 2 → wiggleMaxLength arr = arr.length :=\nsorry\n\ntheorem monotonic_decreasing_bound (arr : List Int) :\n  arr.length > 1 → isSorted (List.reverse arr) = true → wiggleMaxLength arr ≤ 2 :=\nsorry\n\ntheorem shift_invariance (arr : List Int) (k : Int) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (· + k)) :=\nsorry\n\ntheorem scale_invariance (arr : List Int) (k : Int) (h : k ≠ 0) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (· * k)) :=\nsorry\n\ntheorem reverse_invariance (arr : List Int) :\n  wiggleMaxLength arr = wiggleMaxLength (List.reverse arr) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 7, 4, 9, 2, 5]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"id": "fvapps_000256", "vc-description": "/-\nFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nExample 1:\n\nInput: [3,2,1,5,6,4] and k = 2\nOutput: 5\n\nExample 2:\n\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\nOutput: 4\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ array's length.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_kth_largest (nums : List Int) (k : Nat) : Int :=\n  sorry\n\ndef max_list (l : List Int) : Int :=\n  sorry\n\ndef min_list (l : List Int) : Int :=\n  sorry\n\ndef sort_desc (l : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem find_kth_largest_element_membership\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (find_kth_largest nums k) ∈ nums :=\nsorry\n\ntheorem find_kth_largest_lower_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (nums.filter (fun x => x ≥ find_kth_largest nums k)).length ≥ k :=\nsorry\n\ntheorem find_kth_largest_upper_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k ≤ nums.length) :\n  (nums.filter (fun x => x > find_kth_largest nums k)).length < k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 1, 5, 6, 4] 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 3, 1, 2, 4, 5, 5, 6] 4\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [2, 1, 3, 4, 5, 6] 2"}
{"id": "fvapps_000257", "vc-description": "/-\nGiven an equation, represented by words on left side and the result on right side.\nYou need to check if the equation is solvable under the following rules:\n\nEach character is decoded as one digit (0 - 9).\nEvery pair of different characters they must map to different digits.\nEach words[i] and result are decoded as one number without leading zeros.\nSum of numbers on left side (words) will equal to the number on right side (result). \n\nReturn True if the equation is solvable otherwise return False.\n\nExample 1:\nInput: words = [\"SEND\",\"MORE\"], result = \"MONEY\"\nOutput: true\nExplanation: Map 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'\nSuch that: \"SEND\" + \"MORE\" = \"MONEY\" ,  9567 + 1085 = 10652\nExample 2:\nInput: words = [\"SIX\",\"SEVEN\",\"SEVEN\"], result = \"TWENTY\"\nOutput: true\nExplanation: Map 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4\nSuch that: \"SIX\" + \"SEVEN\" + \"SEVEN\" = \"TWENTY\" ,  650 + 68782 + 68782 = 138214\nExample 3:\nInput: words = [\"THIS\",\"IS\",\"TOO\"], result = \"FUNNY\"\nOutput: true\n\nExample 4:\nInput: words = [\"LEET\",\"CODE\"], result = \"POINT\"\nOutput: false\n\nConstraints:\n\n2 <= words.length <= 5\n1 <= words[i].length, result.length <= 7\nwords[i], result contains only upper case English letters.\nNumber of different characters used on the expression is at most 10.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Solution := String\n\ndef isSolvable (words : List String) (result : String) : Bool :=\n  sorry\n\ndef isAlpha (s : String) : Bool :=\n  sorry\n\ndef isUpper (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem valid_solution_constraints {words : List String} {result : String}\n  (h1 : ∀ w ∈ words, isAlpha w ∧ isUpper w)\n  (h2 : isAlpha result ∧ isUpper result)\n  (h3 : words.length > 0)\n  (h4 : ∀ w ∈ words, w.length > 0)\n  (h5 : result.length ≥ words.foldr (fun w acc => max w.length acc) 0) :\n  ∃ solution : Bool, isSolvable words result = solution :=\nsorry\n\ntheorem known_valid_cases_work\n  (h1 : isSolvable [\"SEND\", \"MORE\"] \"MONEY\" = true)\n  (h2 : isSolvable [\"SIX\", \"SEVEN\", \"SEVEN\"] \"TWENTY\" = true) :\n  ∀ words result,\n    (words = [\"SEND\", \"MORE\"] ∧ result = \"MONEY\") ∨\n    (words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ result = \"TWENTY\") →\n    isSolvable words result = true :=\nsorry\n\ntheorem modified_valid_case_exists_solution\n  {words result : String}\n  (h1 : words.length > 0)\n  (h2 : result.length > 0)\n  (h3 : ∃ (orig_words : List String) (orig_result : String),\n        ((orig_words = [\"SEND\", \"MORE\"] ∧ orig_result = \"MONEY\") ∨\n         (orig_words = [\"SIX\", \"SEVEN\", \"SEVEN\"] ∧ orig_result = \"TWENTY\")) ∧\n        words.length = orig_result.length) :\n  ∃ solution : Bool, isSolvable [words] result = solution :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000258", "vc-description": "/-\nGiven an array nums and an integer target.\nReturn the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.\n\nExample 1:\nInput: nums = [1,1,1,1,1], target = 2\nOutput: 2\nExplanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).\n\nExample 2:\nInput: nums = [-1,3,5,1,4,2,-9], target = 6\nOutput: 2\nExplanation: There are 3 subarrays with sum equal to 6.\n([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.\nExample 3:\nInput: nums = [-2,6,6,3,5,4,1,2,8], target = 10\nOutput: 3\n\nExample 4:\nInput: nums = [0,0,0], target = 0\nOutput: 3\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n0 <= target <= 10^6\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_non_overlapping (nums: List Int) (target: Int) : Nat :=\n  sorry\n\ndef abs (n: Int) : Nat :=\n  sorry\n\ndef sum_list (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_non_overlapping_non_negative (nums: List Int) (target: Int) :\n  max_non_overlapping nums target ≥ 0 :=\nsorry\n\ntheorem max_non_overlapping_bounded_by_length (nums: List Int) (target: Int) :\n  max_non_overlapping nums target ≤ nums.length :=\nsorry\n\ntheorem max_non_overlapping_empty_list (target: Int) :\n  max_non_overlapping [] target = 0 :=\nsorry\n\ntheorem max_non_overlapping_all_zeros (n: Nat) :\n  max_non_overlapping (List.replicate n 0) 0 = n :=\nsorry\n\ntheorem max_non_overlapping_self_consistent (nums: List Int) (target: Int) :\n  max_non_overlapping nums target = max_non_overlapping nums target :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [1, 1, 1, 1, 1] 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [-1, 3, 5, 1, 4, 2, -9] 6\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_non_overlapping [0, 0, 0] 0"}
{"id": "fvapps_000259", "vc-description": "/-\nYou are given a string s, a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same.\nReturn the number of good splits you can make in s.\n\nExample 1:\nInput: s = \"aacaba\"\nOutput: 2\nExplanation: There are 5 ways to split \"aacaba\" and 2 of them are good. \n(\"a\", \"acaba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aa\", \"caba\") Left string and right string contains 1 and 3 different letters respectively.\n(\"aac\", \"aba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aaca\", \"ba\") Left string and right string contains 2 and 2 different letters respectively (good split).\n(\"aacab\", \"a\") Left string and right string contains 3 and 1 different letters respectively.\n\nExample 2:\nInput: s = \"abcd\"\nOutput: 1\nExplanation: Split the string as follows (\"ab\", \"cd\").\n\nExample 3:\nInput: s = \"aaaaa\"\nOutput: 4\nExplanation: All possible splits are good.\nExample 4:\nInput: s = \"acbadbaada\"\nOutput: 2\n\nConstraints:\n\ns contains only lowercase English letters.\n1 <= s.length <= 10^5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_good_splits (s : String) : Nat :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry\n\ndef uniqueChars (s : String) : Bool :=\nsorry", "vc-theorems": "theorem num_good_splits_bounds (s : String) (h : s.length > 0) :\n  num_good_splits s ≤ s.length - 1 ∧ num_good_splits s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval num_good_splits \"aacaba\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval num_good_splits \"abcd\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval num_good_splits \"aaaaa\""}
{"id": "fvapps_000263", "vc-description": "/-\nA happy string is a string that:\n\nconsists only of letters of the set ['a', 'b', 'c'].\ns[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).\n\nFor example, strings \"abc\", \"ac\", \"b\" and \"abcbabcbcb\" are all happy strings and strings \"aa\", \"baa\" and \"ababbc\" are not happy strings.\nGiven two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.\nReturn the kth string of this list or return an empty string if there are less than k happy strings of length n.\n\nExample 1:\nInput: n = 1, k = 3\nOutput: \"c\"\nExplanation: The list [\"a\", \"b\", \"c\"] contains all happy strings of length 1. The third string is \"c\".\n\nExample 2:\nInput: n = 1, k = 4\nOutput: \"\"\nExplanation: There are only 3 happy strings of length 1.\n\nExample 3:\nInput: n = 3, k = 9\nOutput: \"cab\"\nExplanation: There are 12 different happy string of length 3 [\"aba\", \"abc\", \"aca\", \"acb\", \"bab\", \"bac\", \"bca\", \"bcb\", \"cab\", \"cac\", \"cba\", \"cbc\"]. You will find the 9th string = \"cab\"\n\nExample 4:\nInput: n = 2, k = 7\nOutput: \"\"\n\nExample 5:\nInput: n = 10, k = 100\nOutput: \"abacbabacb\"\n\nConstraints:\n\n1 <= n <= 10\n1 <= k <= 100\n-/\n\n-- Length property\n\n-- Character set property\n\n-- Adjacent character property\n\n-- Empty string property", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_happy_string (n k : Nat) : String :=\n  sorry\n\ndef all_chars_abc (s : String) : Bool :=\n  sorry\n\ndef no_adjacent_same (s : String) : Bool :=\n  sorry\n\ndef starts_with_a (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem happy_string_properties (n k : Nat)\n  (h1 : 0 < n) (h2 : n ≤ 10) (h3 : 0 < k) (h4 : k ≤ 1000) :\n  let s := get_happy_string n k\n  let max_possible := 3 * 2^(n-1)\n\n  (s.length = n ∨ s.length = 0) ∧\n\n  all_chars_abc s ∧\n\n  (s.length > 1 → no_adjacent_same s) ∧\n\n  ((k > max_possible → s.length = 0) ∧\n   (k ≤ max_possible → s.length = n)) :=\nsorry\n\ntheorem n1_special_case (k : Nat)\n  (h1 : 0 < k) (h2 : k ≤ 10) :\n  let s := get_happy_string 1 k\n  (k ≤ 3 → (s = \"a\" ∨ s = \"b\" ∨ s = \"c\")) ∧\n  (k > 3 → s = \"\") :=\nsorry\n\ntheorem k1_special_case (n : Nat)\n  (h1 : 0 < n) (h2 : n ≤ 5) :\n  let s := get_happy_string n 1\n  s.length = n ∧\n  starts_with_a s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'c'\n-/\n#guard_msgs in\n#eval get_happy_string 1 3\n\n/--\ninfo: 'cab'\n-/\n#guard_msgs in\n#eval get_happy_string 3 9\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval get_happy_string 1 4"}
{"id": "fvapps_000270", "vc-description": "/-\nThere is a room with n bulbs, numbered from 1 to n, arranged in a row from left to right. Initially, all the bulbs are turned off.\nAt moment k (for k from 0 to n - 1), we turn on the light[k] bulb. A bulb change color to blue only if it is on and all the previous bulbs (to the left) are turned on too.\nReturn the number of moments in which all turned on bulbs are blue.\n\nExample 1:\n\nInput: light = [2,1,3,5,4]\nOutput: 3\nExplanation: All bulbs turned on, are blue at the moment 1, 2 and 4.\n\nExample 2:\nInput: light = [3,2,4,1,5]\nOutput: 2\nExplanation: All bulbs turned on, are blue at the moment 3, and 4 (index-0).\n\nExample 3:\nInput: light = [4,1,2,3]\nOutput: 1\nExplanation: All bulbs turned on, are blue at the moment 3 (index-0).\nBulb 4th changes to blue at the moment 3.\n\nExample 4:\nInput: light = [2,1,4,3,6,5]\nOutput: 3\n\nExample 5:\nInput: light = [1,2,3,4,5,6]\nOutput: 6\n\nConstraints:\n\nn == light.length\n1 <= n <= 5 * 10^4\nlight is a permutation of  [1, 2, ..., n]\n-/\n\n-- proof that nodupes ≠ []", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_times_all_blue (lights : List Nat) : Nat :=\n  sorry\n\ndef remove_duplicates (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (lights : List Nat) (h : lights ≠ []) :\n  let valid := lights.filter (fun x => x ≤ lights.length)\n  let nodupes := remove_duplicates valid\n  0 ≤ num_times_all_blue nodupes ∧ num_times_all_blue nodupes ≤ nodupes.length :=\nsorry\n\ntheorem permutation_correctness {n : Nat} (lights : List Nat)\n  (h1 : lights.length = n)\n  (h2 : ∀ x, x ∈ lights → x ≤ n)\n  (h3 : ∀ x, x ∈ lights → (lights.filter (· = x)).length = 1) :\n  num_times_all_blue lights =\n    (List.range lights.length).foldl\n      (fun acc i =>\n        let rightmost := (lights.take (i+1)).foldl Nat.max 0\n        if i+1 = rightmost then acc + 1 else acc)\n      0 :=\nsorry\n\ntheorem invariants (lights : List Nat) (h : lights ≠ []) :\n  let valid := lights.filter (fun x => x ≤ lights.length)\n  let nodupes := remove_duplicates valid\n  let h2 := sorry\n  (nodupes.getLast h2 = nodupes.length → num_times_all_blue nodupes ≥ 1) ∧\n  num_times_all_blue nodupes ≤ nodupes.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval num_times_all_blue [2, 1, 3, 5, 4]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval num_times_all_blue [3, 2, 4, 1, 5]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval num_times_all_blue [4, 1, 2, 3]"}
{"id": "fvapps_000275", "vc-description": "/-\nGiven a m x n matrix mat and an integer threshold. Return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.\n\nExample 1:\n\nInput: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4\nOutput: 2\nExplanation: The maximum side length of square with sum less than 4 is 2 as shown.\n\nExample 2:\nInput: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1\nOutput: 0\n\nExample 3:\nInput: mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6\nOutput: 3\n\nExample 4:\nInput: mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184\nOutput: 2\n\nConstraints:\n\n1 <= m, n <= 300\nm == mat.length\nn == mat[i].length\n0 <= mat[i][j] <= 10000\n0 <= threshold <= 10^5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSideLength (mat: List (List Int)) (threshold: Int) : Int :=\n  sorry\n\ndef minElem (list: List Int) : Int :=\n  sorry\n\ndef sumList (list: List Int) : Int :=\n  sorry\n\ndef listSum (list: List Int) : Int :=\n  sorry\n\ndef floorSqrt (n: Int) : Int :=\n  sorry", "vc-theorems": "theorem maxSideLength_bounds {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length) :\n  let result := maxSideLength mat threshold\n  0 ≤ result ∧ result ≤ min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_low_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : threshold < minElem (mat.map minElem)) :\n  maxSideLength mat threshold = 0 :=\nsorry\n\ntheorem maxSideLength_high_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : threshold ≥ listSum (mat.map sumList)) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_zero_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : ∀ row ∈ mat, ∀ x ∈ row, x = 0)\n  (h3 : threshold ≥ 0) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :=\nsorry\n\ntheorem maxSideLength_ones_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : ∀ row ∈ mat, row.length = mat[0]!.length)\n  (h2 : ∀ row ∈ mat, ∀ x ∈ row, x = 1) :\n  maxSideLength mat threshold ≤ floorSqrt threshold :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2]] 4\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSideLength [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]] 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]] 6"}
{"id": "fvapps_000276", "vc-description": "/-\nGiven an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. \n\nExample 1:\n\nInput:\nnums = [1,3,1]\nk = 1\nOutput: 0 \nExplanation:\nHere are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\nNote:\n\n2 .\n0 .\n1 .\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\nsorry\n\ndef minimum (l : List Int) : Int :=\nsorry\n\ndef smallest_distance_pair : List Int → Nat → Int :=\nsorry", "vc-theorems": "theorem smallest_distance_pair_properties {nums : List Int} {k : Nat}\n    (h1 : nums.length ≥ 2)\n    (h2 : k ≥ 1)\n    (h3 : k ≤ (nums.length * (nums.length - 1)) / 2)\n    (h4 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :\n    let result := smallest_distance_pair nums k;\n    result ≥ 0 ∧\n    result ≤ maximum nums - minimum nums :=\nsorry\n\ntheorem identical_elements {n : List Int} (h : n.length ≥ 2) :\n  smallest_distance_pair (List.replicate n.length (n.get! 0)) 1 = 0 :=\nsorry\n\ntheorem sorted_input_equivalence {nums : List Int} (h : nums.length ≥ 2) :\n  smallest_distance_pair nums 1 = smallest_distance_pair (nums.reverse.reverse) 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 1, 3] 1\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 3, 1] 1\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 6, 1] 3"}
{"id": "fvapps_000286", "vc-description": "/-\nGiven a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.\n\nHowever, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. \n\nYou need to return the least number of intervals the CPU will take to finish all the given tasks.\n\nExample 1:\n\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B.\n\nNote:\n\nThe number of tasks is in the range [1, 10000].\nThe integer n is in the range [0, 100].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def least_interval (tasks : List Char) (n : Nat) : Nat :=\n  sorry\n\ndef countFrequencies (tasks : List Char) : List Nat :=\n  sorry\n\ndef maxFrequency (tasks : List Char) : Nat :=\n  sorry\n\ndef maxFrequencyCount (tasks : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem least_interval_zero_cooldown (tasks : List Char) (h : tasks ≠ []) :\n  least_interval tasks 0 = tasks.length :=\nsorry\n\ntheorem least_interval_basic_properties (tasks : List Char) (n : Nat) (h : tasks ≠ []) :\n  let result := least_interval tasks n\n  let max_freq := maxFrequency tasks\n  let max_freq_count := maxFrequencyCount tasks\n  let min_possible := (max_freq - 1) * (n + 1) + max_freq_count\n  result ≥ tasks.length ∧ result ≥ min_possible :=\nsorry\n\ntheorem least_interval_upper_bound (tasks : List Char) (n : Nat) (h : tasks ≠ []) :\n  least_interval tasks n ≤ tasks.length * (n + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"] 2\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\"] 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"B\", \"C\", \"D\"] 0"}
{"id": "fvapps_000294", "vc-description": "/-\nWe write the integers of A and B (in the order they are given) on two separate horizontal lines.\nNow, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:\n\nA[i] == B[j];\nThe line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.\nReturn the maximum number of connecting lines we can draw in this way.\n\nExample 1:\n\nInput: A = [1,4,2], B = [1,2,4]\nOutput: 2\nExplanation: We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.\n\nExample 2:\nInput: A = [2,5,1,2,5], B = [10,5,2,1,5,2]\nOutput: 3\n\nExample 3:\nInput: A = [1,3,7,1,7,5], B = [1,9,2,5,1]\nOutput: 2\n\nNote:\n\n1 <= A.length <= 500\n1 <= B.length <= 500\n1 <= A[i], B[i] <= 2000\n-/", "vc-preamble": "def List.min_length (a b : List α) : Nat :=\n  min a.length b.length\n\ndef List.everyOther : List α → List α\n  | [] => []\n  | [x] => [x]\n  | x :: _ :: xs => x :: everyOther xs", "vc-helpers": "", "vc-definitions": "def max_uncrossed_lines (a b : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_uncrossed_lines_nonnegative (a b : List Nat) :\n  max_uncrossed_lines a b ≥ 0 :=\nsorry\n\ntheorem max_uncrossed_lines_upper_bound (a b : List Nat) :\n  max_uncrossed_lines a b ≤ min a.length b.length :=\nsorry\n\ntheorem max_uncrossed_lines_empty (a b : List Nat) :\n  a = [] ∨ b = [] → max_uncrossed_lines a b = 0 :=\nsorry\n\ntheorem max_uncrossed_lines_identical (a : List Nat) :\n  max_uncrossed_lines a a = a.length :=\nsorry\n\ntheorem max_uncrossed_lines_reverse (a b : List Nat) :\n  max_uncrossed_lines a b = max_uncrossed_lines a.reverse b.reverse :=\nsorry\n\ntheorem max_uncrossed_lines_edge_cases :\n  max_uncrossed_lines [] [] = 0 ∧\n  max_uncrossed_lines [1] [] = 0 ∧\n  max_uncrossed_lines [] [1] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 4, 2] [1, 2, 4]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [2, 5, 1, 2, 5] [10, 5, 2, 1, 5, 2]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 3, 7, 1, 7, 5] [1, 9, 2, 5, 1]"}
{"id": "fvapps_000296", "vc-description": "/-\nGiven an integer array arr, you should partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\nReturn the largest sum of the given array after partitioning.\n\nExample 1:\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n\nExample 2:\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n\nExample 3:\nInput: arr = [1], k = 1\nOutput: 1\n\nConstraints:\n\n1 <= arr.length <= 500\n0 <= arr[i] <= 109\n1 <= k <= arr.length\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_sum_after_partitioning (arr : List Int) (k : Nat) : Int :=\nsorry\n\ndef sum (l : List Int) : Int :=\nsorry\n\ndef max (l : List Int) : Int :=\nsorry\n\ndef len (l : List Int) : Nat :=\nsorry", "vc-theorems": "theorem result_bounds {arr : List Int} {k : Nat}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0)\n  (h3 : k > 0)\n  (h4 : k ≤ 100) :\n  sum arr ≤ max_sum_after_partitioning arr k ∧\n  max_sum_after_partitioning arr k ≤ len arr * max arr :=\nsorry\n\ntheorem k_equals_one {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0) :\n  max_sum_after_partitioning arr 1 = sum arr :=\nsorry\n\ntheorem k_equals_length {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0) :\n  max_sum_after_partitioning arr arr.length = len arr * max arr :=\nsorry\n\ntheorem single_element {arr : List Int} {k : Nat}\n  (h1 : arr.length = 1)\n  (h2 : k > 0) :\n  max_sum_after_partitioning arr k = arr[0] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 84\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 15, 7, 9, 2, 5, 10] 3\n\n/--\ninfo: 83\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 4, 1, 5, 7, 3, 6, 1, 9, 9, 3] 4\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1] 1"}
{"id": "fvapps_000301", "vc-description": "/-\nGiven an array A of integers, return the length of the longest arithmetic subsequence in A.\nRecall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).\n\nExample 1:\nInput: A = [3,6,9,12]\nOutput: 4\nExplanation: \nThe whole array is an arithmetic sequence with steps of length = 3.\n\nExample 2:\nInput: A = [9,4,7,2,10]\nOutput: 3\nExplanation: \nThe longest arithmetic subsequence is [4,7,10].\n\nExample 3:\nInput: A = [20,1,15,3,10,5,8]\nOutput: 4\nExplanation: \nThe longest arithmetic subsequence is [20,15,10,5].\n\nConstraints:\n\n2 <= A.length <= 1000\n0 <= A[i] <= 500\n-/", "vc-preamble": "def countMaxOccurrences (arr : List Int) : Nat :=\n  let counts := arr.map (λ x => arr.count x)\n  counts.foldl Nat.max 0", "vc-helpers": "", "vc-definitions": "def longestArithSeqLength (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem min_length_at_least_two {arr : List Int} (h : arr.length ≥ 1) :\n  longestArithSeqLength arr ≥ 2 :=\nsorry\n\ntheorem dupes_counted_properly {arr : List Int} (h : arr.length ≥ 2) :\n  longestArithSeqLength arr ≥ countMaxOccurrences arr :=\nsorry\n\ntheorem arithmetic_sequence_preserved {arr : List Int} (h₁ : arr.length ≥ 3) (h₂ : arr.length ≤ 10) :\n  let diff := arr[1]! - arr[0]!\n  let arithSeq := (List.range arr.length).map (λ i => arr[0]! + diff * (Int.ofNat i))\n  longestArithSeqLength arithSeq = arithSeq.length :=\nsorry\n\ntheorem reverse_same_result {arr : List Int} (h : arr.length ≥ 2) :\n  longestArithSeqLength arr = longestArithSeqLength arr.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [3, 6, 9, 12]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval longestArithSeqLength [9, 4, 7, 2, 10]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [20, 1, 15, 3, 10, 5, 8]"}
{"id": "fvapps_000302", "vc-description": "/-\nGiven a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.\n\n(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x .)\n\nExample 1:\n\nInput: N = 10\nOutput: 9\n\nExample 2:\n\nInput: N = 1234\nOutput: 1234\n\nExample 3:\n\nInput: N = 332\nOutput: 299\n\nNote:\nN is an integer in the range [0, 10^9].\n-/\n\n/- Function that returns the largest number not exceeding n whose digits are monotone increasing -/\n\n/- Helper function to compare Options -/\n\n/- For any number n, its monotone increasing digits result will have digits in non-decreasing order\n    and will not exceed the original number n -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- For any number n, its monotone increasing digits result is maximal - incrementing any digit\n    would either make it exceed n or break the monotone increasing property -/\n\n/- Single digit numbers remain unchanged when applying monotone increasing digits -/\n\n/- Numbers that are already monotone increasing remain unchanged -/", "vc-preamble": "def optionLE (a b : Option Nat) : Prop :=\n  match a, b with\n  | some x, some y => x ≤ y\n  | none, _ => True\n  | _, none => False", "vc-helpers": "", "vc-definitions": "def getDigits (n : Nat) : List Nat :=\nsorry\n\ndef monotoneIncreasingDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_is_monotone_increasing (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  (∀ i j : Nat, i < j → j < digits.length → optionLE (digits[i]?) (digits[j]?)) ∧\n  result ≤ n :=\nsorry\n\ntheorem largest_possible_result (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  ∀ i : Nat, i < digits.length →\n    let digit := digits[i]?\n    match digit with\n    | none => True\n    | some d => d = 9 ∨\n      (let incrementedDigits := digits.set i (d + 1)\n       let incrementedNum := incrementedDigits.foldl (fun acc d => acc * 10 + d) 0\n       incrementedNum > n ∨\n       ¬(∀ j k : Nat, j < k → k < incrementedDigits.length →\n           optionLE (incrementedDigits[j]?) (incrementedDigits[k]?))) :=\nsorry\n\ntheorem single_digit_unchanged (n : Nat) :\n  n < 10 → monotoneIncreasingDigits n = n :=\nsorry\n\ntheorem already_monotone_unchanged (n : Nat) :\n  let digits := getDigits n\n  (∀ i j : Nat, i < j → j < digits.length → optionLE (digits[i]?) (digits[j]?)) →\n  monotoneIncreasingDigits n = n :=\nsorry", "vc-postamble": "/--\ninfo: 9\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 10\n\n/--\ninfo: 1234\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 1234\n\n/--\ninfo: 299\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 332"}
{"id": "fvapps_000304", "vc-description": "/-\nReturn the length of the shortest, non-empty, contiguous subarray of A with sum at least K.\nIf there is no non-empty subarray with sum at least K, return -1.\n\nExample 1:\nInput: A = [1], K = 1\nOutput: 1\n\nExample 2:\nInput: A = [1,2], K = 4\nOutput: -1\n\nExample 3:\nInput: A = [2,-1,2], K = 3\nOutput: 3\n\nNote:\n\n1 <= A.length <= 50000\n-10 ^ 5 <= A[i] <= 10 ^ 5\n1 <= K <= 10 ^ 9\n-/", "vc-preamble": "def sumList (l : List Int) : Int :=\n  l.foldl (· + ·) 0\n\ndef toNat (i : Int) : Nat :=\n  if i ≤ 0 then 0 else i.natAbs", "vc-helpers": "", "vc-definitions": "def shortestSubarray (arr : List Int) (k : Int) : Int :=\n  sorry", "vc-theorems": "theorem impossible_cases (k : Int) :\n  shortestSubarray [] k = -1 ∧\n  shortestSubarray [0] k = -1 ∧\n  shortestSubarray [0,0] k = -1 :=\nsorry\n\ntheorem positive_only (arr : List Int) (k : Int) (h1 : ∀ x ∈ arr, 0 < x) (h2 : 0 < k) :\n  let result := shortestSubarray arr k\n  if result = -1 then\n    ∀ start len : Nat, start + len ≤ arr.length →\n      sumList ((arr.take (start + len)).drop start) < k\n  else\n    (∃ start : Nat, start + (toNat result) ≤ arr.length ∧\n      sumList ((arr.take (start + (toNat result))).drop start) ≥ k) ∧\n    (∀ len : Nat, len < (toNat result) → ∀ start : Nat, start + len ≤ arr.length →\n      sumList ((arr.take (start + len)).drop start) < k) :=\nsorry\n\ntheorem result_bounds (arr : List Int) (k : Int) (h1 : 0 < k) (h2 : ¬arr.isEmpty) :\n  let result := shortestSubarray arr k\n  if result = -1 then True\n  else 1 ≤ result ∧ result ≤ arr.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval shortestSubarray [1] 1\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval shortestSubarray [1, 2] 4\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval shortestSubarray [2, -1, 2] 3"}
{"id": "fvapps_000310", "vc-description": "/-\nThere is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:\n\nYou will pick any pizza slice.\nYour friend Alice will pick next slice in anti clockwise direction of your pick. \nYour friend Bob will pick next slice in clockwise direction of your pick.\nRepeat until there are no more slices of pizzas.\n\nSizes of Pizza slices is represented by circular array slices in clockwise direction.\nReturn the maximum possible sum of slice sizes which you can have.\n\nExample 1:\n\nInput: slices = [1,2,3,4,5,6]\nOutput: 10\nExplanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\nExample 2:\n\nInput: slices = [8,9,8,6,1,1]\nOutput: 16\nOutput: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\nExample 3:\nInput: slices = [4,1,2,5,8,3,1,9,7]\nOutput: 21\n\nExample 4:\nInput: slices = [3,1,2]\nOutput: 3\n\nConstraints:\n\n1 <= slices.length <= 500\nslices.length % 3 == 0\n1 <= slices[i] <= 1000\n-/", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def maxSizeSlices (slices: List Nat) : Nat :=\nsorry\n\ndef maxList : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (maxList xs)\n\ndef sortList : List Nat → List Nat :=\nsorry", "vc-theorems": "theorem max_size_bounds {slices : List Nat}\n  (h1: slices.length ≥ 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  let result := maxSizeSlices slices\n  result > 0 ∧\n  result ≤ sumList slices ∧\n  result ≥ maxList slices :=\nsorry\n\ntheorem max_size_elements {slices : List Nat}\n  (h1: slices.length ≥ 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  let n := slices.length\n  maxSizeSlices slices ≤ sumList (List.take (n/3) (sortList slices)) :=\nsorry\n\ntheorem min_case_three {slices : List Nat}\n  (h1: slices.length = 3)\n  (h2: ∀ x ∈ slices, x ≥ 1 ∧ x ≤ 100) :\n  maxSizeSlices slices = maxList slices :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSizeSlices [1, 2, 3, 4, 5, 6]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval maxSizeSlices [8, 9, 8, 6, 1, 1]\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval maxSizeSlices [4, 1, 2, 5, 8, 3, 1, 9, 7]"}
{"id": "fvapps_000312", "vc-description": "/-\nYour task is to form an integer array nums from an initial array of zeros arr that is the same size as nums.\nReturn the minimum number of function calls to make nums from arr.\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\nExample 1:\nInput: nums = [1,5]\nOutput: 5\nExplanation: Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\nDouble all the elements: [0, 1] -> [0, 2] -> [0, 4] (2 operations).\nIncrement by 1 (both elements)  [0, 4] -> [1, 4] -> [1, 5] (2 operations).\nTotal of operations: 1 + 2 + 2 = 5.\n\nExample 2:\nInput: nums = [2,2]\nOutput: 3\nExplanation: Increment by 1 (both elements) [0, 0] -> [0, 1] -> [1, 1] (2 operations).\nDouble all the elements: [1, 1] -> [2, 2] (1 operation).\nTotal of operations: 2 + 1 = 3.\n\nExample 3:\nInput: nums = [4,2,5]\nOutput: 6\nExplanation: (initial)[0,0,0] -> [1,0,0] -> [1,0,1] -> [2,0,2] -> [2,1,2] -> [4,2,4] -> [4,2,5](nums).\n\nExample 4:\nInput: nums = [3,2,2,4]\nOutput: 7\n\nExample 5:\nInput: nums = [2,4,8,16]\nOutput: 8\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^9\n-/", "vc-preamble": "def maxList : List Nat → Nat\n  | [] => 0\n  | (x::xs) => max x (maxList xs)", "vc-helpers": "", "vc-definitions": "def minOperations (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem minOperations_nonnegative (nums : List Nat) :\n  minOperations nums ≥ 0 :=\nsorry\n\ntheorem minOperations_at_least_nonzero_count (nums : List Nat) :\n  minOperations nums ≥ (nums.filter (λ x => x > 0)).length :=\nsorry\n\ntheorem minOperations_at_least_max_bits (nums : List Nat) :\n  nums.length > 0 → nums ≠ [] →\n  minOperations nums ≥ (String.length (toString (maxList nums))).pred :=\nsorry\n\ntheorem minOperations_all_zeros (nums : List Nat) :\n  (∀ x ∈ nums, x = 0) → minOperations nums = 0 :=\nsorry\n\ntheorem minOperations_nonzero_lower_bound (nums : List Nat) :\n  (∀ x ∈ nums, x > 0) → minOperations nums ≥ nums.length :=\nsorry\n\ntheorem minOperations_powers_two_bound (nums : List Nat) (max : Nat) :\n  nums.length > 0 →\n  (∀ x ∈ nums, ∃ n, x = 2^n) →\n  max = maxList nums →\n  minOperations nums ≤ (String.length (toString max)) + nums.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval minOperations [1, 5]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval minOperations [2, 2]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval minOperations [4, 2, 5]"}
{"id": "fvapps_000313", "vc-description": "/-\nGiven two strings: s1 and s2 with the same size, check if some permutation of string s1 can break some permutation of string s2 or vice-versa (in other words s2 can break s1).\nA string x can break string y (both of size n) if x[i] >= y[i] (in alphabetical order) for all i between 0 and n-1.\n\nExample 1:\nInput: s1 = \"abc\", s2 = \"xya\"\nOutput: true\nExplanation: \"ayx\" is a permutation of s2=\"xya\" which can break to string \"abc\" which is a permutation of s1=\"abc\".\n\nExample 2:\nInput: s1 = \"abe\", s2 = \"acd\"\nOutput: false \nExplanation: All permutations for s1=\"abe\" are: \"abe\", \"aeb\", \"bae\", \"bea\", \"eab\" and \"eba\" and all permutation for s2=\"acd\" are: \"acd\", \"adc\", \"cad\", \"cda\", \"dac\" and \"dca\". However, there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n\nExample 3:\nInput: s1 = \"leetcodee\", s2 = \"interview\"\nOutput: true\n\nConstraints:\n\ns1.length == n\ns2.length == n\n1 <= n <= 10^5\nAll strings consist of lowercase English letters.\n-/\n\n/- If two strings are compared with checkIfCanBreak, they must have same length -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A string can always break itself -/\n\n/- The break relationship is symmetric -/\n\n/- A sorted string can always break its unsorted version -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkIfCanBreak (s1 s2 : String) : Bool :=\n  sorry", "vc-theorems": "theorem check_if_can_break_same_length (s1 s2 : String) :\n  checkIfCanBreak s1 s2 → String.length s1 = String.length s2 :=\nsorry\n\ntheorem check_if_can_break_reflexive (s : String) :\n  checkIfCanBreak s s = true :=\nsorry\n\ntheorem check_if_can_break_symmetric (s1 s2 : String) :\n  checkIfCanBreak s1 s2 = checkIfCanBreak s2 s1 :=\nsorry\n\ntheorem sorted_string_breaks_unsorted (s sorted : String)\n  (h : ∀ i j : String.Pos, i < j → sorted.get i ≤ sorted.get j)\n  (h2 : sorted.length = s.length)\n  (h3 : ∀ c, c ∈ sorted.data ↔ c ∈ s.data) :\n  checkIfCanBreak sorted s = true :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"abc\" \"xya\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_if_can_break \"abe\" \"acd\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"leetcodee\" \"interview\""}
{"id": "fvapps_000314", "vc-description": "/-\nGiven a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\n\nExample 1:\n\nInput: nums = [1,3], n = 6\nOutput: 1 \nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n\nExample 2:\n\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\n\nExample 3:\n\nInput: nums = [1,2,2], n = 5\nOutput: 0\n-/\n\n-- Define sorted property\n\n-- All results are natural numbers and input list remains sorted\n\n-- Empty list produces positive result\n\n-- Result is non-negative for small n\n\n-- Specific cases", "vc-preamble": "def isSorted (as : List Nat) : Prop :=\n  ∀ i j, i < j → j < as.length → as[i]! ≤ as[j]!", "vc-helpers": "", "vc-definitions": "def min_patches (nums : List Nat) (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_patches_basic_properties {nums : List Nat} {n : Nat}\n  (h : isSorted nums) :\n  let result := min_patches nums n\n  Nat.zero ≤ result ∧ isSorted nums := by\n  sorry\n\ntheorem min_patches_empty_list {n : Nat} :\n  let result := min_patches [] n\n  0 < result := by\n  sorry\n\ntheorem min_patches_small_n {nums : List Nat} (n : Nat)\n  (h₁ : isSorted nums)\n  (h₂ : nums ≠ [])\n  (h₃ : ∀ x ∈ nums, n < x) :\n  0 ≤ min_patches nums n := by\n  sorry\n\ntheorem min_patches_minimal_cases_1 :\n  min_patches [1] 1 = 0 := by\n  sorry\n\ntheorem min_patches_minimal_cases_2 :\n  min_patches [2] 1 = 1 := by\n  sorry\n\ntheorem min_patches_minimal_cases_3 :\n  min_patches [1,2] 2 = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_patches [1, 3] 6\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_patches [1, 5, 10] 20\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_patches [1, 2, 2] 5"}
{"id": "fvapps_000316", "vc-description": "/-\nGiven an N x N grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized and return the distance.\nThe distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.\nIf no land or water exists in the grid, return -1.\n\nExample 1:\n\nInput: [[1,0,1],[0,0,0],[1,0,1]]\nOutput: 2\nExplanation: \nThe cell (1, 1) is as far as possible from all the land with distance 2.\n\nExample 2:\n\nInput: [[1,0,0],[0,0,0],[0,0,0]]\nOutput: 4\nExplanation: \nThe cell (2, 2) is as far as possible from all the land with distance 4.\n\nNote:\n\n1 <= grid.length == grid[0].length <= 100\ngrid[i][j] is 0 or 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxDistance (grid : List (List Int)) : Int :=\n  sorry\n\ndef rotateGrid (grid : List (List Int)) : List (List Int) :=\n  sorry", "vc-theorems": "theorem maxDistance_bounds (grid : List (List Int)) :\n  let result := maxDistance grid\n  result ≥ -1 ∧ (result ≠ -1 → result ≤ 2 * grid.length) :=\nsorry\n\ntheorem maxDistance_all_water (grid : List (List Int)) :\n  (∀ row ∈ grid, ∀ cell ∈ row, cell = 0) →\n  maxDistance grid = -1 :=\nsorry\n\ntheorem maxDistance_all_land (grid : List (List Int)) :\n  (∀ row ∈ grid, ∀ cell ∈ row, cell = 1) →\n  maxDistance grid = -1 :=\nsorry\n\ntheorem maxDistance_rotation {grid : List (List Int)} :\n  maxDistance grid = maxDistance (rotateGrid grid) :=\nsorry\n\ntheorem maxDistance_edge_cases :\n  maxDistance [[1]] = -1 ∧\n  maxDistance [[0]] = -1 ∧\n  maxDistance [[1,0],[0,0]] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval maxDistance [[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}
{"id": "fvapps_000319", "vc-description": "/-\nGiven a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such\nthat i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n\nNote: n will be less than 15,000.\n\nExample 1:\n\nInput: [1, 2, 3, 4]\n\nOutput: False\n\nExplanation: There is no 132 pattern in the sequence.\n\nExample 2:\n\nInput: [3, 1, 4, 2]\n\nOutput: True\n\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\n\nExample 3:\n\nInput: [-1, 3, 2, 0]\n\nOutput: True\n\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find132pattern (nums : List Int) : Bool :=\n  sorry\n\ndef has_132_pattern_brute_force (nums : List Int) : Bool :=\n  sorry\n\ndef isSorted (nums : List Int) (cmp : Int → Int → Bool) : Bool :=\n  sorry", "vc-theorems": "theorem find132pattern_matches_bruteforce {nums : List Int} :\n  find132pattern nums = has_132_pattern_brute_force nums :=\nsorry\n\ntheorem short_sequences_return_false {nums : List Int} :\n  List.length nums ≤ 2 → find132pattern nums = false :=\nsorry\n\ntheorem monotonic_increasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x ≤ y) → find132pattern nums = false :=\nsorry\n\ntheorem monotonic_decreasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x ≥ y) → find132pattern nums = false :=\nsorry\n\ntheorem same_elements_no_pattern {nums : List Int} {x : Int} :\n  nums.length ≥ 3 → nums = List.replicate nums.length x → find132pattern nums = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval find132pattern [1, 2, 3, 4]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [3, 1, 4, 2]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [-1, 3, 2, 0]"}
{"id": "fvapps_000321", "vc-description": "/-\nValidate if a given string is numeric.\n\nSome examples:\n\"0\" => true\n\" 0.1 \" => true\n\"abc\" => false\n\"1 a\" => false\n\"2e10\" => true\n\nNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.\n\nUpdate (2015-02-10):\nThe signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def isWhitespace (c : Char) : Bool := c = ' ' || c = '\\t' || c = '\\n' || c = '\\r'", "vc-helpers": "", "vc-definitions": "def is_numeric (s : String) : Bool :=\nsorry\n\ndef isInteger (s : String) : Bool :=\nsorry\n\ndef isDecimal (s : String) : Bool :=\nsorry", "vc-theorems": "theorem integer_pattern (s : String)\n  (h : isInteger s) :\n  is_numeric s = true :=\nsorry\n\ntheorem decimal_pattern (s : String)\n  (h : isDecimal s) :\n  is_numeric s = true :=\nsorry\n\ntheorem invalid_chars (s : String)\n  (h₁ : s.length > 0)\n  (h₂ : ∀ c ∈ s.data, c ∈ ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n                           'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n                           'x', 'y', 'z', 'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I',\n                           'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n                           'U', 'V', 'W', 'X', 'Y', 'Z', '!', '@', '#', '$', '%',\n                           '^', '&', '*', '(', ')', '_', '{', '}', '[', ']', ';',\n                           ':', '<', '>', '?'])\n  (h₃ : ∀ c ∈ s.data, c ≠ 'e' ∧ c ≠ 'E') :\n  is_numeric s = false :=\nsorry\n\ntheorem whitespace_handling (s : String) (ws : String)\n  (h₁ : ∀ c ∈ ws.data, isWhitespace c)\n  (h₂ : isInteger s ∨ isDecimal s)\n  (h₃ : s.trim ≠ \"\") :\n  is_numeric (ws ++ s ++ ws) = is_numeric s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000323", "vc-description": "/-\nGiven a string, your task is to count how many palindromic substrings in this string.\n\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. \n\nExample 1:\n\nInput: \"abc\"\nOutput: 3\nExplanation: Three palindromic strings: \"a\", \"b\", \"c\".\n\nExample 2:\n\nInput: \"aaa\"\nOutput: 6\nExplanation: Six palindromic strings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\nNote:\n\nThe input string length won't exceed 1000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_palindromic_substrings (s: String) : Nat :=\n  sorry\n\ndef is_palindrome (s : String) : Bool :=\n  sorry\n\ndef string_reverse (s : String) : String :=\n  sorry\n\ndef string_repeat (c : Char) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem minimum_palindromes (s : String) (h : s.length > 0) :\n  count_palindromic_substrings s ≥ s.length :=\nsorry\n\ntheorem empty_string :\n  count_palindromic_substrings \"\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"abc\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"aaa\"\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"racecar\""}
{"id": "fvapps_000331", "vc-description": "/-\nGiven an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\nCorner Cases:\n\n       Did you consider the case where path = \"/../\"?\n       In this case, you should return \"/\".\n       Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\n       In this case, you should ignore redundant slashes and return \"/home/foo\".\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simplify_path (s : String) : String :=\nsorry\n\ndef is_valid_path_segment (s : String) : Bool :=\nsorry\n\ndef splitString (s : String) (c : Char) : List String :=\nsorry", "vc-theorems": "theorem dot_references_resolve\n  {segments : List String}\n  (valid_segs : ∀ s ∈ segments, s = \".\" ∨ s = \"..\" ∨ is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let result := simplify_path path\n  result.startsWith \"/\" ∧ \".\" ∉ splitString result '/'\n  :=\nsorry\n\ntheorem redundant_slashes\n  (slashes : String)\n  (h : ∀ c ∈ slashes.toList, c = '/') :\n  simplify_path slashes = \"/\"\n  :=\nsorry\n\ntheorem idempotent\n  {segments : List String}\n  (valid_segs : ∀ s ∈ segments, is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let once := simplify_path path\n  simplify_path once = once\n  :=\nsorry\n\ntheorem root_path :\n  simplify_path \"/\" = \"/\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '/home'\n-/\n#guard_msgs in\n#eval simplify_path \"/home/\"\n\n/--\ninfo: '/c'\n-/\n#guard_msgs in\n#eval simplify_path \"/a/./b/../../c/\"\n\n/--\ninfo: '/home/foo'\n-/\n#guard_msgs in\n#eval simplify_path \"/home//foo/\""}
{"id": "fvapps_000338", "vc-description": "/-\nGiven two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\n\nExample 1:\n\nInput:s1 = \"ab\" s2 = \"eidbaooo\"\nOutput:True\nExplanation: s2 contains one permutation of s1 (\"ba\").\n\nExample 2:\n\nInput:s1= \"ab\" s2 = \"eidboaoo\"\nOutput: False\n\nNote:\n\nThe input strings only contain lower case letters.\nThe length of both given strings is in range [1, 10,000].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def contains_permutation (s1 s2 : String) : Bool :=\n  sorry\n\ndef IsPermutation (s1 s2 : String) : Prop :=\n  sorry", "vc-theorems": "theorem contains_permutation_empty_string {s : String} :\n  contains_permutation \"\" s = true :=\nsorry\n\ntheorem contains_permutation_shorter_string {s1 s2 : String} :\n  s2.length < s1.length → contains_permutation s1 s2 = false :=\nsorry\n\ntheorem contains_permutation_self {s : String} :\n  contains_permutation s s = true :=\nsorry\n\ntheorem contains_permutation_concat {s : String} :\n  contains_permutation s (s ++ s) = true :=\nsorry\n\ntheorem contains_permutation_permutation_invariant {s1 s2 s1_perm : String} :\n  IsPermutation s1 s1_perm →\n  contains_permutation s1 s2 = contains_permutation s1_perm s2 :=\nsorry\n\ntheorem contains_permutation_single_char {c : Char} {s : String} :\n  contains_permutation (String.mk [c]) s = String.contains s c :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidbaooo\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidboaoo\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"hello\" \"ooolleoabceh\""}
{"id": "fvapps_000339", "vc-description": "/-\nGiven an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.\nNote that the subarray needs to be non-empty after deleting one element.\n\nExample 1:\nInput: arr = [1,-2,0,3]\nOutput: 4\nExplanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.\nExample 2:\nInput: arr = [1,-2,-2,3]\nOutput: 3\nExplanation: We just choose [3] and it's the maximum sum.\n\nExample 3:\nInput: arr = [-1,-1,-1,-1]\nOutput: -1\nExplanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\nConstraints:\n\n1 <= arr.length <= 10^5\n-10^4 <= arr[i] <= 10^4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_sum_with_deletion (arr : List Int) : Int :=\n  sorry\n\ndef list_maximum (arr : List Int) : Int :=\n  sorry\n\ndef list_sum (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem positive_scaling {arr : List Int} {scale : Int}\n  (h : arr ≠ []) (hs : scale > 0) :\n  maximum_sum_with_deletion (List.map (· * scale) arr) =\n  maximum_sum_with_deletion arr * scale :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, 0, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, -2, 3]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [-1, -1, -1, -1]"}
{"id": "fvapps_000356", "vc-description": "/-\nLet's define a function countUniqueChars(s) that returns the number of unique characters on s, for example if s = \"LEETCODE\" then \"L\", \"T\",\"C\",\"O\",\"D\" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.\n\nOn this problem given a string s we need to return the sum of countUniqueChars(t) where t is a substring of s. Notice that some substrings can be repeated so on this case you have to count the repeated ones too.\nSince the answer can be very large, return the answer modulo 10 ^ 9 + 7.\n\nExample 1:\nInput: s = \"ABC\"\nOutput: 10\nExplanation: All possible substrings are: \"A\",\"B\",\"C\",\"AB\",\"BC\" and \"ABC\".\nEvey substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\nExample 2:\nInput: s = \"ABA\"\nOutput: 8\nExplanation: The same as example 1, except countUniqueChars(\"ABA\") = 1.\n\nExample 3:\nInput: s = \"LEETCODE\"\nOutput: 92\n\nConstraints:\n\n0 <= s.length <= 10^4\ns contain upper-case English letters only.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unique_letter_string (s : String) : Nat :=\nsorry\n\ndef string_reverse (s : String) : String :=\nsorry\n\ndef string_append_char (s : String) (c : Char) : String :=\nsorry", "vc-theorems": "theorem unique_letter_string_positive (s : String) (h : s.length > 0) :\n  unique_letter_string s > 0 :=\nsorry\n\ntheorem unique_letter_string_reverse_invariant (s : String) (h : s.length > 0) :\n  unique_letter_string s = unique_letter_string (string_reverse s) :=\nsorry\n\ntheorem unique_letter_string_monotone (s : String) (h : s.length > 0)\n  (h1 : 0 < s.length) :\n  unique_letter_string (string_append_char s (s.get 0)) > unique_letter_string s :=\nsorry\n\ntheorem unique_letter_string_bounded (s : String) (h : s.length > 0) :\n  unique_letter_string s < 1000000007 :=\nsorry\n\ntheorem unique_letter_string_single_char (s : String) (h : s.length = 1) :\n  unique_letter_string s = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABC\"\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABA\"\n\n/--\ninfo: 92\n-/\n#guard_msgs in\n#eval unique_letter_string \"LEETCODE\""}
{"id": "fvapps_000362", "vc-description": "/-\nWe have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.\nWe start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.\nExample:\nInput: \nroutes = [[1, 2, 7], [3, 6, 7]]\nS = 1\nT = 6\nOutput: 2\nExplanation: \nThe best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\nConstraints:\n\n1 <= routes.length <= 500.\n1 <= routes[i].length <= 10^5.\n0 <= routes[i][j] < 10 ^ 6.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numBusesToDestination (routes: List (List Nat)) (source: Nat) (target: Nat) : Int :=\n  sorry\n\ndef findMaxInList (l: List Nat) : Nat :=\n  sorry\n\ndef findMaxInRoutes (routes: List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem impossible_path_property\n  (routes: List (List Nat))\n  (h: routes ≠ [])\n  (h2: ∀ r ∈ routes, r ≠ []) :\n  let maxStop := findMaxInRoutes routes\n  numBusesToDestination routes 0 (maxStop + 1) = -1 :=\nsorry\n\ntheorem result_range_property\n  (routes: List (List Nat))\n  (h: routes ≠ [])\n  (h2: ∀ r ∈ routes, r ≠ [])\n  (start: Nat)\n  (route: List Nat)\n  (routeEnd: Nat)\n  (h3: route ∈ routes)\n  (h4: routeEnd ∈ route) :\n  numBusesToDestination routes start routeEnd ≥ -1 :=\nsorry\n\ntheorem empty_routes_property\n  (routes: List (List Nat))\n  (h: routes = [] ∨ routes = [[]]) :\n  numBusesToDestination routes 1 2 = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 7], [3, 6, 7]] 1 6\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 3], [3, 4, 5]] 1 5\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2], [2, 3], [3, 4]] 1 4"}
{"id": "fvapps_000364", "vc-description": "/-\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\n\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n\nExample 1:\n\nInput: [2,4,1], k = 2\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\nExample 2:\n\nInput: [3,2,6,5,0,3], k = 2\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n-/", "vc-preamble": "def lastElem (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => lastElem xs", "vc-helpers": "", "vc-definitions": "def max_profit (k : Nat) (prices : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_price_zero_profit (k : Nat) (p : Nat) :\n  max_profit k [p] = 0 := sorry\n\nprivate def pairwise_profits (prices : List Nat) : Nat :=\n  sorry\n\nprivate def isSorted (l : List Nat) : Prop :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_profit 2 [2, 4, 1]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval max_profit 2 [3, 2, 6, 5, 0, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_profit 1 [1, 2, 3, 4]"}
{"id": "fvapps_000366", "vc-description": "/-\nGiven an unsorted array, find the maximum difference between the successive elements in its sorted form.\n\nReturn 0 if the array contains less than 2 elements.\n\nExample 1:\n\nInput: [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either\n             (3,6) or (6,9) has the maximum difference 3.\n\nExample 2:\n\nInput: [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n\nNote:\n\n       You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.\n       Try to solve it in linear time/space.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_gap (nums : List Nat) : Nat :=\n  sorry\n\ndef Permutation (l1 l2 : List α) : Prop :=\n  sorry\n\ndef sort (l : List α) (lt : α → α → Bool) : List α :=\n  sorry", "vc-theorems": "theorem maximum_gap_empty_or_singleton {nums : List Nat} :\n  nums.length ≤ 1 → maximum_gap nums = 0 :=\nsorry\n\ntheorem maximum_gap_nonnegative {nums : List Nat} :\n  maximum_gap nums ≥ 0 :=\nsorry\n\ntheorem maximum_gap_bounded {nums : List Nat} :\n  nums.length > 0 →\n  maximum_gap nums ≤ List.foldl Nat.max 0 nums - List.foldl Nat.min 0 nums :=\nsorry\n\ntheorem maximum_gap_is_max_consecutive_diff {nums : List Nat} (h : nums.length > 1) :\n  let sorted := sort nums (fun x y => x < y)\n  let gaps := List.zipWith (fun x y => y - x) sorted (List.drop 1 sorted)\n  maximum_gap nums = List.foldl Nat.max 0 gaps :=\nsorry\n\ntheorem maximum_gap_permutation_invariant {nums₁ nums₂ : List Nat} :\n  nums₁.length > 1 →\n  Permutation nums₁ nums₂ →\n  maximum_gap nums₁ = maximum_gap nums₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [3, 6, 9, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval maximum_gap [10]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [1, 2, 2, 5, 7, 10]"}
{"id": "fvapps_000370", "vc-description": "/-\nYou are given two sorted arrays of distinct integers nums1 and nums2.\nA valid path is defined as follows:\n\nChoose array nums1 or nums2 to traverse (from index-0).\nTraverse the current array from left to right.\nIf you are reading any value that is present in nums1 and nums2 you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nScore is defined as the sum of uniques values in a valid path.\nReturn the maximum score you can obtain of all possible valid paths.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\n\nInput: nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\nOutput: 30\nExplanation: Valid paths:\n[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],  (starting from nums1)\n[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]    (starting from nums2)\nThe maximum is obtained with the path in green [2,4,6,8,10].\n\nExample 2:\nInput: nums1 = [1,3,5,7,9], nums2 = [3,5,100]\nOutput: 109\nExplanation: Maximum sum is obtained with the path [1,3,5,100].\n\nExample 3:\nInput: nums1 = [1,2,3,4,5], nums2 = [6,7,8,9,10]\nOutput: 40\nExplanation: There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path [6,7,8,9,10].\n\nExample 4:\nInput: nums1 = [1,4,5,8,9,11,19], nums2 = [2,3,4,11,12]\nOutput: 61\n\nConstraints:\n\n1 <= nums1.length <= 10^5\n1 <= nums2.length <= 10^5\n1 <= nums1[i], nums2[i] <= 10^7\nnums1 and nums2 are strictly increasing.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSum (nums1 : List Nat) (nums2 : List Nat) : Nat :=\n  sorry\n\ndef hasCommonElements (l1 l2 : List Nat) : List Nat :=\n  sorry\n\ndef sumUniqueElements (l1 l2 : List Nat) : Nat :=\n  sorry\n\ndef sumCommonElements (l1 l2 : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxsum_positive (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  maxSum nums1 nums2 ≥ 0 :=\nsorry\n\ntheorem maxsum_under_modulo (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  maxSum nums1 nums2 < 10^9 + 7 :=\nsorry\n\ntheorem maxsum_lower_bound (nums1 nums2 : List Nat)\n  (h1 : ∀ x ∈ nums1, 1 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, 1 ≤ x ∧ x ≤ 1000)\n  (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let common := sumCommonElements nums1 nums2\n  let unique1 := sumUniqueElements nums1 nums2\n  let unique2 := sumUniqueElements nums2 nums1\n  maxSum nums1 nums2 ≥ min (unique1 + common) (unique2 + common) % (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval maxSum [2, 4, 5, 8, 10] [4, 6, 8, 9]\n\n/--\ninfo: 109\n-/\n#guard_msgs in\n#eval maxSum [1, 3, 5, 7, 9] [3, 5, 100]\n\n/--\ninfo: 40\n-/\n#guard_msgs in\n#eval maxSum [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]"}
{"id": "fvapps_000372", "vc-description": "/-\nGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.\n\nExample: \n\nInput: s = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\n\nFollow up:\n\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_subarray_len (target : Nat) (nums : List Nat) : Nat :=\nsorry\n\ndef sum_list (l : List Nat) : Nat :=\nsorry\n\ndef slice (l : List Nat) (start : Nat) (len : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_subarray_len_empty {target : Nat} :\n  min_subarray_len target [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subarray_len 7 [2, 3, 1, 2, 4, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 5 []\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 10 [1, 1, 1]"}
{"id": "fvapps_000374", "vc-description": "/-\n(This problem is the same as Minimize Malware Spread, with the differences bolded.)\nIn a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.\nSome nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will remove one node from the initial list, completely removing it and any connections from this node to any other node.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\nExample 2:\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\n\nExample 3:\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\n\nNote:\n\n1 < graph.length = graph[0].length <= 300\n0 <= graph[i][j] == graph[j][i] <= 1\ngraph[i][i] = 1\n1 <= initial.length < graph.length\n0 <= initial[i] < graph.length\n-/\n\n/- Helper function to get spread after removing a node -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_malware_spread (graph : List (List Int)) (initial : List Int) : Int :=\nsorry\n\ndef get_spread (graph : List (List Int)) (initial : List Int) (removed : Int) : Int :=\nsorry", "vc-theorems": "theorem result_in_initial {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  initial.contains result = true :=\nsorry\n\ntheorem smallest_among_equal_spreads {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  ∀ node : Int,\n    node ∈ initial →\n    node < result →\n    get_spread graph initial node ≥ get_spread graph initial result :=\nsorry\n\ntheorem valid_graph_properties {graph : List (List Int)} :\n  let n := graph.length\n  graph.length > 0 →\n  (∀ row ∈ graph, row.length = n) →\n  (∀ (i j : Nat), i < n → j < n →\n    (graph.get! i).get! j = (graph.get! i).get! j) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 0], [0, 0, 1]] [0, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 1], [0, 1, 1]] [0, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]] [0, 1]"}
{"id": "fvapps_000379", "vc-description": "/-\nIn a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)\nReturn true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.\nExample :\nInput: \n[1,2,3,4,5,6,7,8]\nOutput: true\nExplanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.\n\nNote:\n\nThe length of A will be in the range [1, 30].\nA[i] will be in the range of [0, 10000].\n-/", "vc-preamble": "def sum_list (l : List Int) : Int :=\nl.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def split_array_same_average (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem split_array_verification {arr : List Int}\n  (h : split_array_same_average arr = true)\n  (h1 : arr.length ≥ 2)\n  (h2 : ∀ x ∈ arr, x ≥ 0 ∧ x ≤ 100) :\n  ∃ (subset1 subset2 : List Int),\n    subset1 ≠ [] ∧\n    subset2 ≠ [] ∧\n    (∀ x, x ∈ subset1 ∨ x ∈ subset2 ↔ x ∈ arr) ∧\n    (sum_list subset1) * subset2.length = (sum_list subset2) * subset1.length :=\nsorry\n\ntheorem single_element_false {x : Int} (h : x ≥ 1 ∧ x ≤ 10) :\n  split_array_same_average [x] = false :=\nsorry\n\ntheorem identical_elements_splittable {x : Int} {n : Nat}\n  (h : n ≥ 2) :\n  split_array_same_average (List.replicate n x) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3, 4, 5, 6, 7, 8]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [3, 1, 2]"}
{"id": "fvapps_000381", "vc-description": "/-\nDefine S = [s,n] as the string S which consists of n connected strings s. For example, [\"abc\", 3] =\"abcabcabc\". \nOn the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc”  can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.\nYou are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.\n\nExample:\n\nInput:\ns1=\"acb\", n1=4\ns2=\"ab\", n2=2\n\nReturn:\n2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getMaxRepetitions (s1: String) (n1: Nat) (s2: String) (n2: Nat) : Nat :=\n  sorry\n\ndef is_subsequence (s1 s2: String) : Bool :=\n  sorry", "vc-theorems": "theorem result_non_negative (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 ≥ 0 :=\nsorry\n\ntheorem result_positive_implies_common_chars (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 > 0 → ∃ c, c ∈ s2.data ∧ c ∈ s1.data :=\nsorry\n\ntheorem monotonic_in_n1 (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 (n1 + 1) s2 n2 ≥ getMaxRepetitions s1 n1 s2 n2 :=\nsorry\n\ntheorem monotonic_in_s1_length (s1: String) (n1: Nat) (s2: String) (n2: Nat)\n  (h1: s1.length > 0) (h2: s2.length > 0) :\n  getMaxRepetitions (s1 ++ s1) n1 s2 n2 ≥ getMaxRepetitions s1 n1 s2 n2 :=\nsorry\n\ntheorem same_string_division (s: String) :\n  getMaxRepetitions s 3 s 2 = 3 / 2 :=\nsorry\n\ntheorem impossible_match (s1: String) (n1: Nat) :\n  (∀ c, c ∈ s1.data → c ≠ 'c') →\n  getMaxRepetitions s1 n1 \"c\" 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"acb\" 4 \"ab\" 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"aaa\" 3 \"aa\" 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"baba\" 2 \"ba\" 1"}
{"id": "fvapps_000382", "vc-description": "/-\nGiven a binary string s (a string consisting only of '0's and '1's), we can split s into 3 non-empty strings s1, s2, s3 (s1+ s2+ s3 = s).\nReturn the number of ways s can be split such that the number of characters '1' is the same in s1, s2, and s3.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: s = \"10101\"\nOutput: 4\nExplanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n\"1|010|1\"\n\"1|01|01\"\n\"10|10|1\"\n\"10|1|01\"\n\nExample 2:\nInput: s = \"1001\"\nOutput: 0\n\nExample 3:\nInput: s = \"0000\"\nOutput: 3\nExplanation: There are three ways to split s in 3 parts.\n\"0|0|00\"\n\"0|00|0\"\n\"00|0|0\"\n\nExample 4:\nInput: s = \"100100010100110\"\nOutput: 12\n\nConstraints:\n\n3 <= s.length <= 10^5\ns[i] is '0' or '1'.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef count_char (s : String) (c : Char) : Nat :=\n  sorry\n\ndef numWays (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem numWays_non_negative (s : String) :\n  numWays s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval numWays \"10101\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval numWays \"1001\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval numWays \"0000\""}
{"id": "fvapps_000383", "vc-description": "/-\nWrite a program to find the n-th ugly number.\nUgly numbers are positive integers which are divisible by a or b or c.\n\nExample 1:\nInput: n = 3, a = 2, b = 3, c = 5\nOutput: 4\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\nExample 2:\nInput: n = 4, a = 2, b = 3, c = 4\nOutput: 6\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\n\nExample 3:\nInput: n = 5, a = 2, b = 11, c = 13\nOutput: 10\nExplanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10.\n\nExample 4:\nInput: n = 1000000000, a = 2, b = 217983653, c = 336916467\nOutput: 1999999984\n\nConstraints:\n\n1 <= n, a, b, c <= 10^9\n1 <= a * b * c <= 10^18\nIt's guaranteed that the result will be in range [1, 2 * 10^9]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nth_ugly_number (n a b c : Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef count_divisible (num a b c : Nat) : Nat :=\nsorry", "vc-theorems": "theorem ugly_number_divisible (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  let result := find_nth_ugly_number n a b c\n  result % a = 0 ∨ result % b = 0 ∨ result % c = 0 :=\nsorry\n\ntheorem ugly_number_positive (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c > 0 :=\nsorry\n\ntheorem ugly_number_min_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c ≥ min a (min b c) :=\nsorry\n\ntheorem ugly_number_max_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c ≤ n * min a (min b c) :=\nsorry\n\ntheorem ugly_number_equal_divisors (a : Nat) (h : a > 0) :\n  find_nth_ugly_number 1 a a a = a :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 3 2 3 5\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 4 2 3 4\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 5 2 11 13"}
{"id": "fvapps_000384", "vc-description": "/-\nGiven a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n\nYou may assume the array's length is at most 10,000.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_to_equal (nums : List Int) : Nat :=\n  sorry\n\ndef abs (x : Int) : Nat :=\n  sorry\n\ndef sort (nums : List Int) : List Int :=\n  sorry\n\ndef median (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (nums : List Int) :\n  0 ≤ min_moves_to_equal nums :=\nsorry\n\ntheorem min_moves_equal_median (nums : List Int) (h : nums ≠ []) :\n  min_moves_to_equal nums = nums.foldl (fun acc x => acc + abs (x - median nums)) 0 :=\nsorry\n\ntheorem identical_nums_zero_moves (n : Int) (nums : List Int) (h : ∀ x ∈ nums, x = n) :\n  min_moves_to_equal nums = 0 :=\nsorry\n\ntheorem order_invariant (nums : List Int) :\n  min_moves_to_equal nums = min_moves_to_equal (sort nums) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 2, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 1, 1]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 10, 2, 9]"}
{"id": "fvapps_000386", "vc-description": "/-\nGiven a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.\nReturn the length of N.  If there is no such N, return -1.\n\nExample 1:\nInput: 1\nOutput: 1\nExplanation: The smallest answer is N = 1, which has length 1.\nExample 2:\nInput: 2\nOutput: -1\nExplanation: There is no such positive integer N divisible by 2.\nExample 3:\nInput: 3\nOutput: 3\nExplanation: The smallest answer is N = 111, which has length 3.\n\nNote:\n\n1 <= K <= 10^5\n-/\n\n/- For any natural number k, smallest_repunit_div_by_k(k) is either -1 or between 1 and k inclusive -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Certain numbers like 2,4,5,6,8,10 should return -1 as no repunit divides them -/\n\n/- If the result is not -1, then the repunit number of that length should be divisible by k -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def smallest_repunit_div_by_k (k : Nat) : Int :=\nsorry", "vc-theorems": "theorem output_range (k : Nat) :\n  let result := smallest_repunit_div_by_k k\n  result = -1 ∨ (1 ≤ result ∧ result ≤ k) :=\nsorry\n\ntheorem invalid_inputs :\n  smallest_repunit_div_by_k 2 = -1 ∧\n  smallest_repunit_div_by_k 4 = -1 ∧\n  smallest_repunit_div_by_k 5 = -1 ∧\n  smallest_repunit_div_by_k 6 = -1 ∧\n  smallest_repunit_div_by_k 8 = -1 ∧\n  smallest_repunit_div_by_k 10 = -1 :=\nsorry\n\ntheorem result_divisibility (k : Nat) (result : Int) :\n  smallest_repunit_div_by_k k = result →\n  result ≠ -1 →\n  ∃ repunit : Nat, repunit % k = 0 :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 1\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 3"}
{"id": "fvapps_000389", "vc-description": "/-\nA message containing letters from A-Z is being encoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\nGiven a non-empty string containing only digits, determine the total number of ways to decode it.\n\nExample 1:\n\nInput: \"12\"\nOutput: 2\nExplanation: It could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nExample 2:\n\nInput: \"226\"\nOutput: 3\nExplanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_encoding (s : String) : Bool :=\n  sorry\n\ndef count_decodings (s : String) : Nat :=\n  sorry\n\ndef num_decodings (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_strings (s : String) :\n  is_valid_encoding s → num_decodings s = count_decodings s :=\nsorry\n\ntheorem invalid_strings (s : String) :\n  ¬is_valid_encoding s → num_decodings s = 0 :=\nsorry\n\ntheorem empty_string :\n  num_decodings \"\" = 0 :=\nsorry\n\ntheorem starting_zero (s : String) :\n  s.length > 0 → s.front = '0' → num_decodings s = 0 :=\nsorry\n\ntheorem short_valid_numbers (s : String) :\n  is_valid_encoding s → s.length ≤ 6 → num_decodings s = count_decodings s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval num_decodings \"12\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval num_decodings \"226\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval num_decodings \"06\""}
{"id": "fvapps_000390", "vc-description": "/-\nGiven n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n\nExample:\n\nInput: [2,1,5,6,2,3]\nOutput: 10\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest_rectangle_area (heights : List Nat) : Nat :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listModify (l : List Nat) (i : Nat) (f : Nat → Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem largest_rectangle_area_non_negative (heights : List Nat) :\n  0 ≤ largest_rectangle_area heights :=\nsorry\n\ntheorem largest_rectangle_area_upper_bound (heights : List Nat) :\n  heights ≠ [] →\n  largest_rectangle_area heights ≤ (List.length heights) * (listMaximum heights) :=\nsorry\n\ntheorem largest_rectangle_area_at_least_max_height (heights : List Nat) :\n  heights ≠ [] →\n  largest_rectangle_area heights ≥ listMaximum heights :=\nsorry\n\ntheorem largest_rectangle_area_empty (heights : List Nat) :\n  heights = [] →\n  largest_rectangle_area heights = 0 :=\nsorry\n\ntheorem largest_rectangle_area_tall_column (heights : List Nat) :\n  heights ≠ [] →\n  let tall_height := (listMaximum heights) + 1\n  let new_heights := heights ++ [tall_height]\n  largest_rectangle_area new_heights ≥ tall_height :=\nsorry\n\ntheorem largest_rectangle_area_monotonic (heights : List Nat) (i : Nat) :\n  i < List.length heights →\n  let increased := listModify heights i (· + 1)\n  largest_rectangle_area increased ≥ largest_rectangle_area heights :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 5, 6, 2, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_rectangle_area []"}
{"id": "fvapps_000391", "vc-description": "/-\nGiven an array nums of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.\n\nExample 1:\nInput: nums = [3,6,5,1,8]\nOutput: 18\nExplanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\nExample 2:\nInput: nums = [4]\nOutput: 0\nExplanation: Since 4 is not divisible by 3, do not pick any number.\n\nExample 3:\nInput: nums = [1,2,3,4,4]\nOutput: 12\nExplanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n\nConstraints:\n\n1 <= nums.length <= 4 * 10^4\n1 <= nums[i] <= 10^4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSumDivThree (nums: List Nat) : Nat :=\n  sorry\n\ndef sum (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxSumDivThree_divisible_by_3 (nums: List Nat) :\n  maxSumDivThree nums % 3 = 0 :=\nsorry\n\ntheorem maxSumDivThree_bounded (nums: List Nat) :\n  maxSumDivThree nums ≤ sum nums :=\nsorry\n\ntheorem maxSumDivThree_nonnegative (nums: List Nat) :\n  maxSumDivThree nums ≥ 0 :=\nsorry\n\ntheorem maxSumDivThree_all_divisible (nums: List Nat)\n  (h: ∀ n ∈ nums, n % 3 = 0) :\n  maxSumDivThree nums = sum nums :=\nsorry\n\ntheorem maxSumDivThree_none_divisible (nums: List Nat)\n  (h1: nums ≠ [])\n  (h2: ∀ n ∈ nums, n % 3 ≠ 0) :\n  maxSumDivThree nums ≤ sum nums ∧\n  maxSumDivThree nums % 3 = 0 :=\nsorry\n\ntheorem maxSumDivThree_monotonic (nums: List Nat) :\n  maxSumDivThree nums ≤ maxSumDivThree (nums ++ [3]) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval maxSumDivThree [3, 6, 5, 1, 8]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSumDivThree [4]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval maxSumDivThree [1, 2, 3, 4, 4]"}
{"id": "fvapps_000394", "vc-description": "/-\nWe partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?\nNote that our partition must use every number in A, and that scores are not necessarily integers.\nExample:\nInput: \nA = [9,1,2,3,9]\nK = 3\nOutput: 20\nExplanation: \nThe best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned A into [9, 1], [2], [3, 9], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\nNote: \n\n1 <= A.length <= 100.\n1 <= A[i] <= 10000.\n1 <= K <= A.length.\nAnswers within 10^-6 of the correct answer will be accepted as correct.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def listMin (xs : List Int) : Float :=\n  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl min h t)\n\ndef listMax (xs : List Int) : Float :=\n  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl max h t)\n\ndef listSum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => h + listSum t", "vc-helpers": "", "vc-definitions": "def array_stats (numbers: List Int) : Float × Float × Float × Float :=\n  sorry\n\ndef sorted (xs : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem array_stats_empty :\n  array_stats [] = (0, 0, 0, 0) :=\nsorry\n\ntheorem array_stats_mean (numbers: List Int) (h: numbers ≠ []) :\n  let (mean, _, _, _) := array_stats numbers\n  (mean - Float.ofInt (listSum numbers) / Float.ofInt numbers.length).abs < 1e-10 :=\nsorry\n\ntheorem array_stats_minmax (numbers: List Int) (h: numbers ≠ []) :\n  let (_, _, min_val, max_val) := array_stats numbers\n  min_val = listMin numbers ∧\n  max_val = listMax numbers :=\nsorry\n\ntheorem array_stats_ordering (numbers: List Int) (h: numbers ≠ []) :\n  let (mean, median, min_val, max_val) := array_stats numbers\n  min_val ≤ median ∧ median ≤ max_val ∧\n  min_val ≤ mean ∧ mean ≤ max_val :=\nsorry\n\ntheorem array_stats_median_even (numbers: List Int) (h: numbers ≠ [])\n  (h2: numbers.length % 2 = 0) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt ((List.get! s ((numbers.length)/2 - 1)) + (List.get! s (numbers.length/2)))/2).abs < 1e-10 :=\nsorry\n\ntheorem array_stats_median_odd (numbers: List Int) (h: numbers ≠ [])\n  (h2: numbers.length % 2 = 1) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt (List.get! s (numbers.length/2))).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000398", "vc-description": "/-\nGiven an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\nIn case of a tie, return the minimum such integer.\nNotice that the answer is not neccesarilly a number from arr.\n\nExample 1:\nInput: arr = [4,9,3], target = 10\nOutput: 3\nExplanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.\n\nExample 2:\nInput: arr = [2,3,5], target = 10\nOutput: 5\n\nExample 3:\nInput: arr = [60864,25176,27249,21296,20204], target = 56803\nOutput: 11361\n\nConstraints:\n\n1 <= arr.length <= 10^4\n1 <= arr[i], target <= 10^5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_best_value (arr : List Nat) (target : Nat) : Nat :=\n  sorry\n\ndef sum_capped_vals (arr : List Nat) (cap : Nat) : Nat :=\n  sorry\n\ndef list_maximum (arr : List Nat) (h : arr ≠ []) : Nat :=\n  sorry\n\ndef abs (n : Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_best_value_bounds {arr : List Nat} {target : Nat} (h : arr ≠ []) :\n  let result := find_best_value arr target\n  0 ≤ result ∧ result ≤ list_maximum arr h :=\nsorry\n\ntheorem find_best_value_minimizes {arr : List Nat} {target : Nat} (h : arr ≠ []) :\n  let result := find_best_value arr target\n  let curr_diff := abs (sum_capped_vals arr result - target)\n  let less := max 0 (result - 1)\n  let more := min (list_maximum arr h) (result + 1)\n  curr_diff ≤ abs (sum_capped_vals arr less - target) ∧\n  curr_diff ≤ abs (sum_capped_vals arr more - target) :=\nsorry\n\ntheorem find_best_value_target_one {arr : List Nat} (h : arr ≠ []) :\n  let result := find_best_value arr 1\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_best_value [4, 9, 3] 10\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_best_value [2, 3, 5] 10\n\n/--\ninfo: 11361\n-/\n#guard_msgs in\n#eval find_best_value [60864, 25176, 27249, 21296, 20204] 56803"}
{"id": "fvapps_000400", "vc-description": "/-\nThe power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps:\n\nif x is even then x = x / 2\nif x is odd then x = 3 * x + 1\n\nFor example, the power of x = 3 is 7 because 3 needs 7 steps to become 1 (3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1).\nGiven three integers lo, hi and k. The task is to sort all integers in the interval [lo, hi] by the power value in ascending order, if two or more integers have the same power value sort them by ascending order.\nReturn the k-th integer in the range [lo, hi] sorted by the power value.\nNotice that for any integer x (lo <= x <= hi) it is guaranteed that x will transform into 1 using these steps and that the power of x is will fit in 32 bit signed integer.\n\nExample 1:\nInput: lo = 12, hi = 15, k = 2\nOutput: 13\nExplanation: The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)\nThe power of 13 is 9\nThe power of 14 is 17\nThe power of 15 is 17\nThe interval sorted by the power value [12,13,14,15]. For k = 2 answer is the second element which is 13.\nNotice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.\n\nExample 2:\nInput: lo = 1, hi = 1, k = 1\nOutput: 1\n\nExample 3:\nInput: lo = 7, hi = 11, k = 4\nOutput: 7\nExplanation: The power array corresponding to the interval [7, 8, 9, 10, 11] is [16, 3, 19, 6, 14].\nThe interval sorted by power is [8, 10, 11, 7, 9].\nThe fourth number in the sorted array is 7.\n\nExample 4:\nInput: lo = 10, hi = 20, k = 5\nOutput: 13\n\nExample 5:\nInput: lo = 1, hi = 1000, k = 777\nOutput: 570\n\nConstraints:\n\n1 <= lo <= hi <= 1000\n1 <= k <= hi - lo + 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_power (x : Int) : Int :=\n  sorry\n\ndef getKth (lo hi k : Int) : Int :=\n  sorry", "vc-theorems": "theorem get_power_always_terminates (x : Int)\n  (h : x ≥ 1) :\n  get_power x ≥ 0 :=\nsorry\n\ntheorem getKth_input_validation (lo hi k : Int)\n  (h1 : lo ≥ 1)\n  (h2 : hi ≥ 1)\n  (h3 : lo ≤ hi)\n  (h4 : k ≥ 1)\n  (h5 : k ≤ hi - lo + 1) :\n  lo ≤ getKth lo hi k ∧ getKth lo hi k ≤ hi :=\nsorry\n\ntheorem getKth_sorting_property (lo hi : Int)\n  (h1 : lo ≥ 1)\n  (h2 : hi ≥ 1)\n  (h3 : lo ≤ hi)\n  (k1 k2 : Int)\n  (h4 : k1 ≥ 1)\n  (h5 : k2 ≥ 1)\n  (h6 : k1 ≤ hi - lo + 1)\n  (h7 : k2 ≤ hi - lo + 1)\n  (h8 : k1 < k2) :\n  get_power (getKth lo hi k1) < get_power (getKth lo hi k2) ∨\n  (get_power (getKth lo hi k1) = get_power (getKth lo hi k2) ∧\n   getKth lo hi k1 ≤ getKth lo hi k2) :=\nsorry\n\ntheorem getKth_single_element (x : Int)\n  (h : x ≥ 1) :\n  getKth x x 1 = x :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval getKth 12 15 2\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval getKth 7 11 4\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval getKth 1 1 1"}
{"id": "fvapps_000402", "vc-description": "/-\nYou have d dice, and each die has f faces numbered 1, 2, ..., f.\nReturn the number of possible ways (out of fd total ways) modulo 10^9 + 7 to roll the dice so the sum of the face up numbers equals target.\n\nExample 1:\nInput: d = 1, f = 6, target = 3\nOutput: 1\nExplanation: \nYou throw one die with 6 faces.  There is only one way to get a sum of 3.\n\nExample 2:\nInput: d = 2, f = 6, target = 7\nOutput: 6\nExplanation: \nYou throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:\n1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n\nExample 3:\nInput: d = 2, f = 5, target = 10\nOutput: 1\nExplanation: \nYou throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.\n\nExample 4:\nInput: d = 1, f = 2, target = 3\nOutput: 0\nExplanation: \nYou throw one die with 2 faces.  There is no way to get a sum of 3.\n\nExample 5:\nInput: d = 30, f = 30, target = 500\nOutput: 222616187\nExplanation: \nThe answer must be returned modulo 10^9 + 7.\n\nConstraints:\n\n1 <= d, f <= 30\n1 <= target <= 1000\n-/", "vc-preamble": "def M := 1000000007", "vc-helpers": "", "vc-definitions": "def numRollsToTarget (d f t : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem impossible_target (d f t : Nat) :\n  (t < d ∨ t > d*f) → numRollsToTarget d f t = 0 :=\nsorry\n\ntheorem single_die_possible (f t : Nat) :\n  1 ≤ t ∧ t ≤ f → numRollsToTarget 1 f t = 1 :=\nsorry\n\ntheorem single_die_impossible (f t : Nat) :\n  (t < 1 ∨ t > f) → numRollsToTarget 1 f t = 0 :=\nsorry\n\ntheorem above_max_target (d f : Nat) :\n  numRollsToTarget d f (d*f+1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 1 6 3\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 6 7\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 5 10"}
{"id": "fvapps_000403", "vc-description": "/-\nGiven a palindromic string palindrome, replace exactly one character by any lowercase English letter so that the string becomes the lexicographically smallest possible string that isn't a palindrome.\nAfter doing so, return the final string.  If there is no way to do so, return the empty string.\n\nExample 1:\nInput: palindrome = \"abccba\"\nOutput: \"aaccba\"\n\nExample 2:\nInput: palindrome = \"a\"\nOutput: \"\"\n\nConstraints:\n\n1 <= palindrome.length <= 1000\npalindrome consists of only lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def break_palindrome (s : String) : String :=\nsorry\n\ndef is_palindrome (s : String) : Bool :=\nsorry\n\ndef strRepeat (c : Char) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem single_char_palindrome (n : Nat) (h : n = 1) :\n  break_palindrome (strRepeat 'a' n) = \"\" :=\nsorry\n\ntheorem all_a_string_breaks_to_b (s : String) (h₁ : s.length ≥ 2) (h₂ : ∀ c ∈ s.data, c = 'a') :\n  break_palindrome s = (s.dropRight 1).push 'b' :=\nsorry\n\ntheorem break_gives_different_string (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  break_palindrome s ≠ s :=\nsorry\n\ntheorem break_gives_non_palindrome (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  is_palindrome (break_palindrome s) = false :=\nsorry\n\ntheorem break_preserves_length (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :\n  (break_palindrome s).length = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'aaccba'\n-/\n#guard_msgs in\n#eval break_palindrome \"abccba\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval break_palindrome \"a\"\n\n/--\ninfo: 'ab'\n-/\n#guard_msgs in\n#eval break_palindrome \"aa\""}
{"id": "fvapps_000404", "vc-description": "/-\nGiven an integer array arr of distinct integers and an integer k.\nA game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0 and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\nReturn the integer which will win the game.\nIt is guaranteed that there will be a winner of the game.\n\nExample 1:\nInput: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n\nExample 2:\nInput: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.\n\nExample 3:\nInput: arr = [1,9,8,2,3,7,6,4,5], k = 7\nOutput: 9\n\nExample 4:\nInput: arr = [1,11,22,33,44,55,66,77,88,99], k = 1000000000\nOutput: 99\n\nConstraints:\n\n2 <= arr.length <= 10^5\n1 <= arr[i] <= 10^6\narr contains distinct integers.\n1 <= k <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_winner (arr : List Int) (k : Int) : Int :=\n  sorry\n\ndef List.maximum (l : List Int) : Int :=\n  sorry\n\ndef List.maximum' (l : List Int) (h : l ≠ []) : Int :=\n  sorry\n\ndef List.findIndex (l : List Int) (p : Int → Bool) : Nat :=\n  sorry\n\ndef List.sorted (l : List Int) (r : Int → Int → Bool) : Prop :=\n  sorry", "vc-theorems": "theorem winner_exists_in_array (arr : List Int) (h : arr ≠ []) :\n  ∀ k, k > 0 → get_winner arr k ∈ arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval get_winner [2, 1, 3, 5, 4, 6, 7] 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval get_winner [3, 2, 1] 10\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval get_winner [1, 9, 8, 2, 3, 7, 6, 4, 5] 7"}
{"id": "fvapps_000406", "vc-description": "/-\nA game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nMouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.\nDuring each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\nThen, the game can end in 3 ways:\n\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\nIf ever the Mouse reaches the Hole, the Mouse wins.\nIf ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.\n\nExample 1:\nInput: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\nExplanation:\n4---3---1\n|   |\n2---5\n \\ /\n  0\n\nNote:\n\n3 <= graph.length <= 50\nIt is guaranteed that graph[1] is non-empty.\nIt is guaranteed that graph[2] contains a non-zero element.\n-/\n\n/- For a valid graph input, the output is either 0, 1 or 2 -/\n\n/- The cat-mouse game output range theorem only applies to valid graphs -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A graph is valid if:\n1. It is non-empty\n2. Each node's neighbors are valid indices into the graph -/", "vc-preamble": "def IsValidGraph (graph : List (List Nat)) : Prop :=\n  graph ≠ [] ∧\n  ∀ neighbors ∈ graph, ∀ x ∈ neighbors, x < graph.length", "vc-helpers": "", "vc-definitions": "def CatMouseGame (graph : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem cat_mouse_game_output_range (graph : List (List Nat)) :\n  CatMouseGame graph = 0 ∨ CatMouseGame graph = 1 ∨ CatMouseGame graph = 2 :=\nsorry\n\ntheorem cat_mouse_game_output_range_valid (graph : List (List Nat)) :\n  IsValidGraph graph →\n  CatMouseGame graph = 0 ∨ CatMouseGame graph = 1 ∨ CatMouseGame graph = 2 :=\nsorry", "vc-postamble": "/--\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3], [], []]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval cat_mouse_game [[1, 3], [0], [3], [0, 2]]"}
{"id": "fvapps_000407", "vc-description": "/-\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nExample 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\n\nExample 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findMedianSortedArrays (nums1 : List Int) (nums2 : List Int) : Float :=\n  sorry\n\ndef getMedian (l : List Int) : Float :=\n  sorry\n\ndef mergeSorted (l1 l2 : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem findMedianSortedArrays_correct (nums1 nums2 : List Int)\n  (h : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = getMedian (mergeSorted nums1 nums2) := by\n  sorry\n\ntheorem findMedianSortedArrays_symmetric (nums1 nums2 : List Int)\n  (h : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = findMedianSortedArrays nums2 nums1 := by\n  sorry\n\ntheorem findMedianSortedArrays_bounded (nums1 nums2 : List Int)\n  (h1 : ∀ x ∈ nums1, -1000 ≤ x ∧ x ≤ 1000)\n  (h2 : ∀ x ∈ nums2, -1000 ≤ x ∧ x ≤ 1000)\n  (h3 : ¬(nums1.length = 0 ∧ nums2.length = 0)) :\n  -1000 ≤ findMedianSortedArrays nums1 nums2 ∧\n  findMedianSortedArrays nums1 nums2 ≤ 1000 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 3] #[2]\n\n/--\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 2] #[3, 4]\n\n/--\ninfo: 3.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1] #[2, 3, 4, 5]"}
{"id": "fvapps_000410", "vc-description": "/-\nGiven the string s, return the size of the longest substring containing each vowel an even number of times. That is, 'a', 'e', 'i', 'o', and 'u' must appear an even number of times.\n\nExample 1:\nInput: s = \"eleetminicoworoep\"\nOutput: 13\nExplanation: The longest substring is \"leetminicowor\" which contains two each of the vowels: e, i and o and zero of the vowels: a and u.\n\nExample 2:\nInput: s = \"leetcodeisgreat\"\nOutput: 5\nExplanation: The longest substring is \"leetc\" which contains two e's.\n\nExample 3:\nInput: s = \"bcbcbc\"\nOutput: 6\nExplanation: In this case, the given string \"bcbcbc\" is the longest because all vowels: a, e, i, o and u appear zero times.\n\nConstraints:\n\n1 <= s.length <= 5 x 10^5\ns contains only lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countVowels (s : String) : List Char → Bool :=\n  sorry\n\ndef verifySubstringVowels (s : String) (start length : Nat) : Bool :=\n  sorry\n\ndef findLongestEvenVowelSubstring (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_is_valid_length (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  0 ≤ result ∧ result ≤ s.length :=\nsorry\n\ntheorem result_has_even_vowels (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  result > 0 →\n  ∃ i : Nat, i + result ≤ s.length ∧ verifySubstringVowels s i result :=\nsorry\n\ntheorem no_longer_valid_substring_exists (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  ∀ length : Nat, result < length → length ≤ s.length →\n  ∀ i : Nat, i + length ≤ s.length →\n  ¬(verifySubstringVowels s i length) :=\nsorry\n\ntheorem edge_cases_empty :\n  findLongestEvenVowelSubstring \"\" = 0 :=\nsorry\n\ntheorem edge_cases_single_nonvowel (c : Char) (h : c ∉ ['a', 'e', 'i', 'o', 'u']) :\n  findLongestEvenVowelSubstring (String.mk [c]) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"eleetminicoworoep\"\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"leetcodeisgreat\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"bcbcbc\""}
{"id": "fvapps_000412", "vc-description": "/-\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample 1:\n\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: \"cbbd\"\nOutput: \"bb\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isPalindrome (s : String) : Bool :=\nsorry\n\ndef find_longest_palindrome (s : String) : String :=\nsorry\n\ndef String.isSubstringOf (sub str : String) : Bool :=\nsorry\n\ndef String.substring (str : String) (start len : Nat) : String :=\nsorry", "vc-theorems": "theorem find_longest_palindrome_is_substring (s : String) :\n  (find_longest_palindrome s).isSubstringOf s = true :=\nsorry\n\ntheorem find_longest_palindrome_is_palindrome (s : String) :\n  (find_longest_palindrome s).isPalindrome = true :=\nsorry\n\ntheorem find_longest_palindrome_length (s : String) :\n  (find_longest_palindrome s).length ≥ min 1 s.length :=\nsorry\n\ntheorem find_longest_palindrome_maximal (s : String) (start len : Nat) :\n  let substr := String.substring s start len\n  substr.isPalindrome = true → (find_longest_palindrome s).length ≥ substr.length :=\nsorry\n\ntheorem nonempty_input_nonempty_output (s : String) (h : s.length > 0) :\n  (find_longest_palindrome s).length > 0 :=\nsorry\n\ntheorem palindrome_input_returns_itself (s : String) (h : s.isPalindrome = true) :\n  find_longest_palindrome s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"cbbd\"\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"a\""}
{"id": "fvapps_000413", "vc-description": "/-\nGiven an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\n\nExample 1:\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].\nExample 2:\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n\nExample 3:\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n\nConstraints:\n\n1 <= arr.length <= 10^5\n-10^4 <= arr[i], difference <= 10^4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_arithmetic_subsequence (arr: List Int) (diff: Int) : Nat :=\n  sorry\n\ndef countOccurrences (xs : List Int) (x : Int) : Nat :=\n  sorry\n\ndef maxOccurrences (xs : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem las_length_bounded {arr: List Int} {diff: Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr diff ≤ arr.length :=\nsorry\n\ntheorem las_non_negative {arr: List Int} {diff: Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr diff ≥ 0 :=\nsorry\n\ntheorem las_zero_diff {arr: List Int} :\n  arr ≠ [] → longest_arithmetic_subsequence arr 0 = maxOccurrences arr :=\nsorry\n\ntheorem las_reverse_symmetry {arr: List Int} {diff: Int} :\n  arr ≠ [] → diff > 0 →\n    longest_arithmetic_subsequence arr diff =\n    longest_arithmetic_subsequence arr.reverse (-diff) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 2, 3, 4] 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 3, 5, 7] 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 5, 7, 8, 5, 3, 4, 2, 1] -2"}
{"id": "fvapps_000416", "vc-description": "/-\nStarting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.\nReturn true if and only if we can do this in a way such that the resulting number is a power of 2.\n\nExample 1:\nInput: 1\nOutput: true\n\nExample 2:\nInput: 10\nOutput: false\n\nExample 3:\nInput: 16\nOutput: true\n\nExample 4:\nInput: 24\nOutput: false\n\nExample 5:\nInput: 46\nOutput: true\n\nNote:\n\n1 <= N <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reordered_power_of_2 (n : Nat) : Bool :=\nsorry\n\ndef get_powers_of_2 (max_digits : Nat) : List Nat :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef sorted_digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem power_2_permutations_property {n : Nat} (h : reordered_power_of_2 n = true) :\n  ∃ p, (p = 2^(Nat.log2 p)) ∧ sorted_digits n = sorted_digits p :=\nsorry\n\ntheorem single_digit_property {n : Nat} (h : List.length (digits n) = 1) :\n  reordered_power_of_2 n = (n = 1 ∨ n = 2 ∨ n = 4 ∨ n = 8) :=\nsorry\n\ntheorem leading_zeros_property {n : Nat} (h : n < 10) :\n  reordered_power_of_2 n = reordered_power_of_2 (10 * n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 1\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval reordered_power_of_2 10\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 16"}
{"id": "fvapps_000421", "vc-description": "/-\nGiven an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.\nSince the answer may be large, return the answer modulo 10^9 + 7.\n\nExample 1:\nInput: [3,1,2,4]\nOutput: 17\nExplanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.\n\nNote:\n\n1 <= A.length <= 30000\n1 <= A[i] <= 30000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_subarray_mins (nums : List Nat) : Nat :=\n  sorry\n\ndef list_min (l : List Nat) : Nat :=\n  sorry\n\ndef list_max (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sum_subarray_mins_non_negative (nums : List Nat) :\n  sum_subarray_mins nums ≥ 0 :=\nsorry\n\ntheorem sum_subarray_mins_modulo_bound (nums : List Nat) :\n  sum_subarray_mins nums < 10^9 + 7 :=\nsorry\n\ntheorem sum_subarray_mins_singleton (n : Nat) :\n  sum_subarray_mins [n] = n :=\nsorry\n\ntheorem sum_subarray_mins_min_bound {nums : List Nat} (h : nums.length ≥ 2) :\n  sum_subarray_mins nums ≥ list_min nums :=\nsorry\n\ntheorem sum_subarray_mins_append_larger {nums : List Nat} (h : nums.length ≥ 2) :\n  let max := list_max nums\n  sum_subarray_mins (nums ++ [max + 1]) % (10^9 + 7) ≥ sum_subarray_mins nums % (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 17\n-/\n#guard_msgs in\n#eval sum_subarray_mins [3, 1, 2, 4]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_subarray_mins [1]\n\n/--\ninfo: 444\n-/\n#guard_msgs in\n#eval sum_subarray_mins [11, 81, 94, 43, 3]"}
{"id": "fvapps_000431", "vc-description": "/-\nGiven a positive integer N, how many ways can we write it as a sum of consecutive positive integers?\nExample 1:\nInput: 5\nOutput: 2\nExplanation: 5 = 5 = 2 + 3\nExample 2:\nInput: 9\nOutput: 3\nExplanation: 9 = 9 = 4 + 5 = 2 + 3 + 4\nExample 3:\nInput: 15\nOutput: 4\nExplanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\nNote: 1 <= N <= 10 ^ 9.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def consecutive_numbers_sum (n : Nat) : Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\ndef isSquare (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem result_always_positive (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n ≥ 1 :=\nsorry\n\ntheorem result_less_than_input (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n ≤ n :=\nsorry\n\ntheorem known_edge_cases :\n  consecutive_numbers_sum 1 = 1 ∧\n  consecutive_numbers_sum 2 = 1 ∧\n  consecutive_numbers_sum 3 = 2 ∧\n  consecutive_numbers_sum 4 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 5\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 9\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 15"}
{"id": "fvapps_000439", "vc-description": "/-\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).\n\nFind the minimum element.\n\nYou may assume no duplicate exists in the array.\n\nExample 1:\n\nInput: [3,4,5,1,2] \nOutput: 1\n\nExample 2:\n\nInput: [4,5,6,7,0,1,2]\nOutput: 0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findMin (arr : List Int) : Int :=\n  sorry\n\ndef rotateList (xs : List Int) (n : Nat) : List Int :=\n  sorry\n\ndef listMin (xs : List Int) : Int :=\n  sorry", "vc-theorems": "theorem findMin_singleton (n : Int) :\n  findMin [n] = n :=\nsorry\n\ntheorem findMin_pair (a b : Int) :\n  findMin [a, b] = min a b :=\nsorry\n\ntheorem findMin_triple (a b c : Int) :\n  findMin [a, b, c] = min (min a b) c :=\nsorry\n\ntheorem findMin_rotated_sorted_unique {nums : List Int} (h1 : nums.length ≥ 4)\n    (h2 : List.Pairwise (· ≠ ·) nums) (h3 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :\n  findMin (rotateList nums (nums.length / 2)) = listMin nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [3, 4, 5, 1, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval findMin [4, 5, 6, 7, 0, 1, 2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [1, 2, 3, 4, 5]"}
{"id": "fvapps_000440", "vc-description": "/-\nA character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\n\nThis is how the UTF-8 encoding would work:\n\n   Char. number range  |        UTF-8 octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\n\nNote:\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\nExample 1:\n\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\n\nReturn true.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\nExample 2:\n\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\n\nReturn false.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isContinuationByte (x : Nat) : Bool :=\n  sorry\n\ndef countRequiredBytes (firstByte : Nat) : Int :=\n  sorry\n\ndef validUtf8 (data : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem valid_utf8_property (data : List Nat) (h : ∀ x ∈ data, x ≤ 255) :\n  validUtf8 data = true →\n  ∃ i : Nat,\n    i < data.length ∧\n    let required := countRequiredBytes (data.get ⟨i, sorry⟩)\n    required ≥ 0 ∧\n    i + required < data.length ∧\n    ∀ j, i + 1 ≤ j ∧ j ≤ i + required →\n      isContinuationByte (data.get ⟨j, sorry⟩) = true :=\nsorry\n\ntheorem valid_utf8_property_contra (data : List Nat) (h : ∀ x ∈ data, x ≤ 255) :\n  validUtf8 data = false →\n  ∃ i : Nat,\n    i < data.length ∧\n    (countRequiredBytes (data.get ⟨i, sorry⟩) < 0 ∨\n     i + countRequiredBytes (data.get ⟨i, sorry⟩) ≥ data.length ∨\n     ∃ j, i + 1 ≤ j ∧ j ≤ i + countRequiredBytes (data.get ⟨i, sorry⟩) ∧\n       isContinuationByte (data.get ⟨j, sorry⟩) = false) :=\nsorry\n\ntheorem ascii_always_valid (data : List Nat) (h : ∀ x ∈ data, x ≤ 127) :\n  validUtf8 data = true :=\nsorry\n\ntheorem continuation_bytes_invalid (data : List Nat) (h1 : data ≠ [])\n    (h2 : ∀ x ∈ data, x ≥ 128 ∧ x ≤ 191) :\n  validUtf8 data = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [197, 130, 1]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval valid_utf8 [235, 140, 4]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [240, 162, 138, 147]"}
{"id": "fvapps_000442", "vc-description": "/-\nYou want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the i-th job, you have to finish all the jobs j where 0 <= j < i).\nYou have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done in that day.\nGiven an array of integers jobDifficulty and an integer d. The difficulty of the i-th job is jobDifficulty[i].\nReturn the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.\n\nExample 1:\n\nInput: jobDifficulty = [6,5,4,3,2,1], d = 2\nOutput: 7\nExplanation: First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\nExample 2:\nInput: jobDifficulty = [9,9,9], d = 4\nOutput: -1\nExplanation: If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\nExample 3:\nInput: jobDifficulty = [1,1,1], d = 3\nOutput: 3\nExplanation: The schedule is one job per day. total difficulty will be 3.\n\nExample 4:\nInput: jobDifficulty = [7,1,7,1,7,1], d = 3\nOutput: 15\n\nExample 5:\nInput: jobDifficulty = [11,111,22,222,33,333,44,444], d = 6\nOutput: 843\n\nConstraints:\n\n1 <= jobDifficulty.length <= 300\n0 <= jobDifficulty[i] <= 1000\n1 <= d <= 10\n-/", "vc-preamble": "def list_maximum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| [x] => x\n| x::xs => max x (list_maximum xs)\n\ndef list_sum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def min_difficulty (difficulties: List Nat) (days: Nat) : Int :=\nsorry\n\ndef list_sort (l: List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_difficulty_invalid_days {difficulties : List Nat} {days : Nat} :\n  days > difficulties.length → min_difficulty difficulties days = -1\n  :=\nsorry\n\ntheorem min_difficulty_lb_max {difficulties : List Nat} {days : Nat} :\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties days ≥ list_maximum difficulties\n  :=\nsorry\n\ntheorem min_difficulty_lb_sum_min {difficulties : List Nat} {days : Nat} :\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties days ≥ list_sum (List.take days (list_sort difficulties))\n  :=\nsorry\n\ntheorem min_difficulty_single_day {difficulties : List Nat} :\n  difficulties.length > 0 →\n  min_difficulty difficulties 1 = list_maximum difficulties\n  :=\nsorry\n\ntheorem min_difficulty_monotonic {difficulties : List Nat} {days : Nat} :\n  days > 1 →\n  days ≤ difficulties.length →\n  min_difficulty difficulties days ≥ 0 →\n  min_difficulty difficulties (days-1) ≥ 0 →\n  min_difficulty difficulties days ≥ min_difficulty difficulties (days-1)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_difficulty [6, 5, 4, 3, 2, 1] 2\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_difficulty [9, 9, 9] 4\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difficulty [1, 1, 1] 3"}
{"id": "fvapps_000444", "vc-description": "/-\nGiven a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\n\nExample 1:\n\nInput: 2736\nOutput: 7236\nExplanation: Swap the number 2 and the number 7.\n\nExample 2:\n\nInput: 9973\nOutput: 9973\nExplanation: No swap.\n\nNote:\n\nThe given number is in the range [0, 108]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum_swap (n : Nat) : Nat :=\nsorry\n\ndef countDigit (d n : Nat) : Nat :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem maximum_swap_result_ge (n : Nat) :\n  maximum_swap n ≥ n :=\nsorry\n\ntheorem maximum_swap_edge_cases :\n  maximum_swap 0 = 0 ∧\n  maximum_swap 1 = 1 ∧\n  maximum_swap 10 = 10 ∧\n  maximum_swap 99 = 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7236\n-/\n#guard_msgs in\n#eval maximum_swap 2736\n\n/--\ninfo: 9973\n-/\n#guard_msgs in\n#eval maximum_swap 9973\n\n/--\ninfo: 9913\n-/\n#guard_msgs in\n#eval maximum_swap 1993"}
{"id": "fvapps_000445", "vc-description": "/-\nThere is a strange printer with the following two special requirements:\n\nOn each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\nOnce the printer has used a color for the above operation, the same color cannot be used again.\n\nYou are given a m x n matrix targetGrid, where targetGrid[row][col] is the color in the position (row, col) of the grid.\nReturn true if it is possible to print the matrix targetGrid, otherwise, return false.\n\nExample 1:\n\nInput: targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\nOutput: true\n\nExample 2:\n\nInput: targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\nOutput: true\n\nExample 3:\nInput: targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\nOutput: false\nExplanation: It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\nExample 4:\nInput: targetGrid = [[1,1,1],[3,1,3]]\nOutput: false\n\nConstraints:\n\nm == targetGrid.length\nn == targetGrid[i].length\n1 <= m, n <= 60\n1 <= targetGrid[row][col] <= 60\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef isPrintable (grid: Grid) : Bool :=\n  sorry", "vc-theorems": "def isValidGrid (grid: Grid) : Bool :=\n  match grid with\n  | [] => false\n  | row::rows =>\n    match row with\n    | [] => false\n    | _::_ =>\n      let width := row.length\n      rows.all (λ r => r.length = width)\n\ntheorem grid_validity {grid: Grid} (h: isValidGrid grid) :\n  ∃ (row: List Nat) (rows: List (List Nat)), grid = row::rows :=\nsorry\n\ntheorem printable_returns_bool (grid: Grid) :\n  isPrintable grid = true ∨ isPrintable grid = false :=\nsorry\n\ntheorem single_color_printable {grid: Grid} (h1: isValidGrid grid)\n  (h2: ∀ (i j: Nat) (hi: i < grid.length) (hj: j < (grid.get ⟨i, hi⟩).length),\n    (grid.get ⟨i, hi⟩).get ⟨j, hj⟩ = 1) :\n  isPrintable grid = true :=\nsorry\n\ntheorem symmetric_grid_printable_rotation {grid: Grid} {n: Nat}\n  (h1: isValidGrid grid)\n  (h2: grid.length = n)\n  (h3: ∀ (i: Nat) (hi: i < grid.length),\n    (grid.get ⟨i, hi⟩).length = n) :\n  isPrintable grid = isPrintable (List.map List.reverse grid).reverse :=\nsorry\n\ntheorem known_cases :\n  (isPrintable [[1,1], [1,1]] = true) ∧\n  (isPrintable [[1]] = true) ∧\n  (isPrintable [[1,2], [2,1]] = false) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 1, 3, 3], [1, 1, 3, 4], [5, 5, 1, 4]]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval isPrintable [[1, 2, 1], [2, 1, 2], [1, 2, 1]]"}
{"id": "fvapps_000452", "vc-description": "/-\nYou are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.\n\nReturn the number of servers that communicate with any other server.\n\nExample 1:\n\nInput: grid = [[1,0],[0,1]]\nOutput: 0\nExplanation: No servers can communicate with others.\nExample 2:\n\nInput: grid = [[1,0],[1,1]]\nOutput: 3\nExplanation: All three servers can communicate with at least one other server.\n\nExample 3:\n\nInput: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\nOutput: 4\nExplanation: The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 250\n1 <= n <= 250\ngrid[i][j] == 0 or 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countServers (grid : List (List Nat)) : Nat :=\nsorry\n\ndef is_valid_grid (grid : List (List Nat)) : Bool :=\nsorry\n\ndef count_ones (grid : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem countServers_non_negative (grid : List (List Nat)) :\n  is_valid_grid grid → countServers grid ≥ 0 :=\nsorry\n\ntheorem countServers_upper_bound (grid : List (List Nat)) :\n  is_valid_grid grid → countServers grid ≤ count_ones grid :=\nsorry\n\ntheorem single_server_result (grid : List (List Nat)) :\n  is_valid_grid grid → count_ones grid = 1 → countServers grid = 0 :=\nsorry\n\ntheorem empty_grid_zero {m n : Nat} (grid : List (List Nat)) :\n  m > 0 → n > 0 →\n  grid = List.replicate m (List.replicate n 0) →\n  countServers grid = 0 :=\nsorry\n\ntheorem full_grid_count {n : Nat} (grid : List (List Nat)) :\n  n ≥ 2 →\n  grid = List.replicate n (List.replicate n 1) →\n  countServers grid = n * n :=\nsorry\n\ntheorem diagonal_only_zero {n : Nat} (grid : List (List Nat)) :\n  n ≥ 2 →\n  grid = List.map\n    (fun i => List.map (fun j => if i = j then 1 else 0) (List.range n))\n    (List.range n) →\n  countServers grid = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [0, 1]]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [1, 1]]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval countServers [[1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1]]"}
{"id": "fvapps_000453", "vc-description": "/-\nYou are given an integer array nums. The value of this array is defined as the sum of |nums[i]-nums[i+1]| for all 0 <= i < nums.length-1.\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\nFind maximum possible value of the final array.\n\nExample 1:\nInput: nums = [2,3,1,5,4]\nOutput: 10\nExplanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.\n\nExample 2:\nInput: nums = [2,4,9,24,2,1,10]\nOutput: 68\n\nConstraints:\n\n1 <= nums.length <= 3*10^4\n-10^5 <= nums[i] <= 10^5\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef diffSum (nums : List Int) : Int :=\n  match nums with\n  | [] => 0\n  | [_] => 0\n  | x :: xs => List.foldl (fun acc (pair : Int × Int) => acc + abs (pair.1 - pair.2)) 0 (List.zip (x::xs) xs)", "vc-helpers": "", "vc-definitions": "def maxValueAfterReverse (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem maxValueAfterReverse_nonnegative (nums : List Int) :\n  maxValueAfterReverse nums ≥ 0 :=\nsorry\n\ntheorem maxValueAfterReverse_geq_base (nums : List Int) :\n  maxValueAfterReverse nums ≥ diffSum nums :=\nsorry\n\ntheorem maxValueAfterReverse_small_lists {nums : List Int} (h : nums.length ≤ 2) :\n  match nums with\n  | [] => maxValueAfterReverse nums = 0\n  | [_] => maxValueAfterReverse nums = 0\n  | [x, y] => maxValueAfterReverse nums = abs (x - y)\n  | _ => True\n  :=\nsorry\n\ntheorem maxValueAfterReverse_monotonic_defined (nums : List Int) (h : nums.length ≥ 3) :\n  ∃ (n n' : Int), maxValueAfterReverse nums = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 3, 1, 5, 4]\n\n/--\ninfo: 68\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 4, 9, 24, 2, 1, 10]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [1, 2, 3, 4, 5]"}
{"id": "fvapps_000465", "vc-description": "/-\nGiven the array nums consisting of n positive integers. You computed the sum of all non-empty continous subarrays from the array and then sort them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.\nReturn the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.\n\nExample 1:\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 5\nOutput: 13 \nExplanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n\nExample 2:\nInput: nums = [1,2,3,4], n = 4, left = 3, right = 4\nOutput: 6\nExplanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n\nExample 3:\nInput: nums = [1,2,3,4], n = 4, left = 1, right = 10\nOutput: 50\n\nConstraints:\n\n1 <= nums.length <= 10^3\nnums.length == n\n1 <= nums[i] <= 100\n1 <= left <= right <= n * (n + 1) / 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def range_sum (nums : List Nat) (n : Nat) (left right : Nat) : Nat :=\n  sorry\n\ndef partialSums (nums : List Nat) (n : Nat) : List Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem range_sum_output_properties {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 1000)\n  (h4 : left ≥ 1 ∧ right ≥ 1)\n  (h5 : left ≤ 20 ∧ right ≤ 20) :\n  let result := range_sum nums n left right\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem range_sum_monotonic {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : left < right)\n  (h4 : right ≤ n) :\n  range_sum nums n left (right-1) ≤ range_sum nums n left right :=\nsorry\n\ntheorem range_sum_single_element {nums : List Nat} {n k : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : k ≤ n)\n  (h4 : k > 0) :\n  let pSums := partialSums nums n\n  ∀ h : k - 1 < pSums.length,\n  range_sum nums n k k = pSums.get ⟨k-1, h⟩ :=\nsorry\n\ntheorem range_sum_full_range {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 100) :\n  range_sum nums n 1 (n * (n+1) / 2) > 0 :=\nsorry\n\ntheorem range_sum_first_element {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty) :\n  range_sum nums n 1 1 = listMin nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 5\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 3 4\n\n/--\ninfo: 50\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 10"}
{"id": "fvapps_000474", "vc-description": "/-\nFind the smallest prime palindrome greater than or equal to N.\nRecall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1. \nFor example, 2,3,5,7,11 and 13 are primes.\nRecall that a number is a palindrome if it reads the same from left to right as it does from right to left. \nFor example, 12321 is a palindrome.\n\nExample 1:\nInput: 6\nOutput: 7\n\nExample 2:\nInput: 8\nOutput: 11\n\nExample 3:\nInput: 13\nOutput: 101\n\nNote:\n\n1 <= N <= 10^8\nThe answer is guaranteed to exist and be less than 2 * 10^8.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def primePalindrome (n : Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem primePalindrome_geq_input\n  (n : Nat)\n  (h1 : n ≥ 2)\n  (h2 : n ≤ 19990) :\n  primePalindrome n ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval primePalindrome 6\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval primePalindrome 8\n\n/--\ninfo: 101\n-/\n#guard_msgs in\n#eval primePalindrome 13"}
{"id": "fvapps_000476", "vc-description": "/-\nGiven a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.\n\nExample 1:\nInput: S = \"0110\", N = 3\nOutput: true\n\nExample 2:\nInput: S = \"0110\", N = 4\nOutput: false\n\nNote:\n\n1 <= S.length <= 1000\n1 <= N <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin (n : Nat) : String :=\nsorry\n\ndef query_string (s : String) (n : Nat) : Bool :=\nsorry\n\ndef containsSubstring (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem query_string_with_all_prefixes (n : Nat) (h : 0 < n ∧ n ≤ 20) :\n  let binary_nums := String.join (List.map bin (List.range n))\n  query_string binary_nums n = true\n  :=\nsorry\n\ntheorem query_string_correct (s : String) (n : Nat) (h : 0 < n ∧ n ≤ 20) :\n  query_string s n = true ↔\n    ∀ i : Nat, 1 ≤ i ∧ i ≤ n → containsSubstring s (bin i)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"0110\" 3\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval query_string \"0110\" 4\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"11011\" 2"}
{"id": "fvapps_000477", "vc-description": "/-\nGiven a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\n\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n\nExample:\n\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ n2.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def kth_smallest_in_sorted_matrix (matrix : List (List Int)) (k : Nat) : Int :=\nsorry\n\ndef is_sorted (row : List Int) : Bool :=\nsorry\n\ndef is_matrix_sorted (matrix : List (List Int)) : Bool :=\nsorry", "vc-theorems": "theorem empty_rows_handled_raises\n  (matrix : List (List Int))\n  (h1 : matrix = [] ∨ ¬∃row ∈ matrix, row ≠ []) :\n  ∀k, k ≠ 0 → kth_smallest_in_sorted_matrix matrix k = default :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15]] 8\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 2], [3, 4]] 3\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15], [], []] 8"}
{"id": "fvapps_000478", "vc-description": "/-\nGiven an array A of integers, a ramp is a tuple (i, j) for which i < j and A[i] <= A[j].  The width of such a ramp is j - i.\nFind the maximum width of a ramp in A.  If one doesn't exist, return 0.\n\nExample 1:\nInput: [6,0,8,2,1,5]\nOutput: 4\nExplanation: \nThe maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.\n\nExample 2:\nInput: [9,8,1,0,1,9,4,0,4,1]\nOutput: 7\nExplanation: \nThe maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.\n\nNote:\n\n2 <= A.length <= 50000\n0 <= A[i] <= 50000\n-/", "vc-preamble": "def isSorted (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)\n\ndef isStrictlyDecreasing (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x > y && isStrictlyDecreasing (y::rest)\n\ndef hasNoDups (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | x::xs => !(xs.contains x) && hasNoDups xs", "vc-helpers": "", "vc-definitions": "def max_width_ramp (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem max_width_ramp_non_negative (nums : List Int) :\n  max_width_ramp nums ≥ 0 :=\nsorry\n\ntheorem max_width_ramp_upper_bound (nums : List Int) :\n  max_width_ramp nums ≤ max 0 (nums.length - 1) :=\nsorry\n\ntheorem max_width_ramp_small_lists (nums : List Int) :\n  nums.length ≤ 1 → max_width_ramp nums = 0 :=\nsorry\n\ntheorem max_width_ramp_valid_ramp_exists (nums : List Int) (h : max_width_ramp nums > 0) :\n  ∃ i j, ∃ (hi : i < nums.length) (hj : j < nums.length),\n         i < j ∧ j - i ≥ max_width_ramp nums ∧\n         (nums.get ⟨i, hi⟩) ≤ (nums.get ⟨j, hj⟩) :=\nsorry\n\ntheorem max_width_ramp_monotonic_increasing (nums : List Int) :\n  nums.length > 1 →\n  isSorted nums = true →\n  max_width_ramp nums = nums.length - 1 :=\nsorry\n\ntheorem max_width_ramp_strictly_decreasing (nums : List Int) :\n  nums.length > 0 →\n  isStrictlyDecreasing nums = true →\n  hasNoDups nums = true →\n  max_width_ramp nums = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval max_width_ramp [6, 0, 8, 2, 1, 5]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval max_width_ramp [9, 8, 1, 0, 1, 9, 4, 0, 4, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_width_ramp [1, 0]"}
{"id": "fvapps_000481", "vc-description": "/-\nGiven two integers A and B, return any string S such that:\n\nS has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters;\nThe substring 'aaa' does not occur in S;\nThe substring 'bbb' does not occur in S.\n\nExample 1:\nInput: A = 1, B = 2\nOutput: \"abb\"\nExplanation: \"abb\", \"bab\" and \"bba\" are all correct answers.\n\nExample 2:\nInput: A = 4, B = 1\nOutput: \"aabaa\"\n\nNote:\n\n0 <= A <= 100\n0 <= B <= 100\nIt is guaranteed such an S exists for the given A and B.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def strWithout3a3b (a b : Nat) : String :=\n  sorry\n\ndef count_char (s : String) (c : Char) : Nat :=\n  sorry\n\ndef contains_substring (s main : String) : Bool :=\n  sorry", "vc-theorems": "def is_valid_string (s : String) (a_count b_count : Nat) : Prop :=\n  count_char s 'a' = a_count ∧\n  count_char s 'b' = b_count ∧\n  ¬contains_substring \"aaa\" s ∧\n  ¬contains_substring \"bbb\" s\n\ntheorem equal_counts {n : Nat} (h : n > 0) :\n  let s := strWithout3a3b n n\n  is_valid_string s n n ∧ s.length = 2 * n\n  :=\nsorry\n\ntheorem double_a_count {n : Nat} :\n  let s := strWithout3a3b (2 * n) n\n  is_valid_string s (2 * n) n ∧ s.length = 3 * n\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000483", "vc-description": "/-\nReturn the largest possible k such that there exists a_1, a_2, ..., a_k such that:\n\nEach a_i is a non-empty string;\nTheir concatenation a_1 + a_2 + ... + a_k is equal to text;\nFor all 1 <= i <= k,  a_i = a_{k+1 - i}.\n\nExample 1:\nInput: text = \"ghiabcdefhelloadamhelloabcdefghi\"\nOutput: 7\nExplanation: We can split the string on \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)\".\n\nExample 2:\nInput: text = \"merchant\"\nOutput: 1\nExplanation: We can split the string on \"(merchant)\".\n\nExample 3:\nInput: text = \"antaprezatepzapreanta\"\nOutput: 11\nExplanation: We can split the string on \"(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)\".\n\nExample 4:\nInput: text = \"aaa\"\nOutput: 3\nExplanation: We can split the string on \"(a)(a)(a)\".\n\nConstraints:\n\ntext consists only of lowercase English characters.\n1 <= text.length <= 1000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestDecomposition (s : String) : Nat :=\n  sorry\n\ndef isReversed (s : String) : Bool :=\n  sorry\n\ndef allCharsSame (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem decomposition_length {s : String} (h : s ≠ \"\") :\n  1 ≤ longestDecomposition s ∧ longestDecomposition s ≤ s.length :=\nsorry\n\ntheorem concatenated_decomposition {s : String} (h : s ≠ \"\") :\n  longestDecomposition (s ++ s) ≥ 2 * longestDecomposition s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval longestDecomposition \"ghiabcdefhelloadamhelloabcdefghi\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval longestDecomposition \"merchant\"\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval longestDecomposition \"antaprezatepzapreanta\""}
{"id": "fvapps_000484", "vc-description": "/-\nWe have a collection of rocks, each rock has a positive integer weight.\nEach turn, we choose any two rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\n\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\n\nAt the end, there is at most 1 stone left.  Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.)\n\nExample 1:\nInput: [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.\n\nNote:\n\n1 <= stones.length <= 30\n1 <= stones[i] <= 100\n-/", "vc-preamble": "def sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def lastStoneWeightII (stones : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem lastStoneWeight_nonNegative (stones : List Nat) :\n  lastStoneWeightII stones ≥ 0 :=\nsorry\n\ntheorem lastStoneWeight_upperBound (stones : List Nat) :\n  lastStoneWeightII stones ≤ sum stones :=\nsorry\n\ntheorem lastStoneWeight_identical_pairs (stones : List Nat) :\n  stones.length = 2 → stones[0]! = stones[1]! → lastStoneWeightII stones = 0 :=\nsorry\n\ntheorem lastStoneWeight_single_stone (stones : List Nat) (x : Nat) :\n  stones = [x] → lastStoneWeightII stones = x :=\nsorry\n\ntheorem lastStoneWeight_identical_values (stones : List Nat) (x : Nat) :\n  (∀ i, i < stones.length → stones[i]! = x) → lastStoneWeightII stones ≤ x :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 7, 4, 1, 8, 1]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval lastStoneWeightII [1, 1, 1]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 2]"}
{"id": "fvapps_000485", "vc-description": "/-\nGiven an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.\nReturn the least number of moves to make every value in A unique.\n\nExample 1:\nInput: [1,2,2]\nOutput: 1\nExplanation:  After 1 move, the array could be [1, 2, 3].\n\nExample 2:\nInput: [3,2,1,2,1,7]\nOutput: 6\nExplanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].\nIt can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n\nNote:\n\n0 <= A.length <= 40000\n0 <= A[i] < 40000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_increment_for_unique (nums : List Int) : Nat :=\n  sorry\n\ndef sorted (l : List Int) : List Int :=\n  sorry\n\ndef makeUnique (nums : List Int) : List Int :=\n  sorry\n\ndef sumList (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_increment_nonneg (nums : List Int) :\n  min_increment_for_unique nums ≥ 0 :=\nsorry\n\ntheorem min_increment_empty (nums : List Int) :\n  nums = [] → min_increment_for_unique nums = 0 :=\nsorry\n\ntheorem min_increment_single (nums : List Int) (x : Int) :\n  nums = [x] → min_increment_for_unique nums = 0 :=\nsorry\n\ntheorem min_increment_sort_invariant (nums : List Int) :\n  min_increment_for_unique nums = min_increment_for_unique (sorted nums) :=\nsorry\n\ntheorem min_increment_makes_unique (nums : List Int) :\n  let result := sorted nums\n  let incremented := makeUnique result\n  min_increment_for_unique nums = (sumList incremented - sumList result) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_increment_for_unique [1, 2, 2]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval min_increment_for_unique [3, 2, 1, 2, 1, 7]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_increment_for_unique []"}
{"id": "fvapps_000490", "vc-description": "/-\nGiven a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n\nExample 1:\n\nInput: \"aacecaaa\"\nOutput: \"aaacecaaa\"\n\nExample 2:\n\nInput: \"abcd\"\nOutput: \"dcbabcd\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortest_palindrome (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef stringReverse (s : String) : String :=\nsorry", "vc-theorems": "theorem shortest_palindrome_contains_original (s : String) :\n  (shortest_palindrome s).endsWith s :=\nsorry\n\ntheorem shortest_palindrome_is_palindrome (s : String) :\n  isPalindrome (shortest_palindrome s) = true :=\nsorry\n\ntheorem shortest_palindrome_minimal_length (s : String) :\n  (shortest_palindrome s).length ≤ 2 * s.length :=\nsorry\n\ntheorem shortest_palindrome_empty_single_char (s : String) :\n  s = \"\" ∨ s.length = 1 → shortest_palindrome s = s :=\nsorry\n\ntheorem shortest_palindrome_starts_with_reversed_suffix (s : String) :\n  s ≠ \"\" →\n  let result := shortest_palindrome s\n  let suffixLen := result.length - s.length\n  suffixLen > 0 →\n  (result.take suffixLen) = stringReverse (s.takeRight suffixLen) :=\nsorry\n\ntheorem shortest_palindrome_single_char_string (s : String) (c : Char) :\n  s.all (· = c) → shortest_palindrome s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'aaacecaaa'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"aacecaaa\"\n\n/--\ninfo: 'dcbabcd'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"abcd\"\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"a\""}
{"id": "fvapps_000494", "vc-description": "/-\nGiven a string s of '(' , ')' and lowercase English characters. \nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\nFormally, a parentheses string is valid if and only if:\n\nIt is the empty string, contains only lowercase characters, or\nIt can be written as AB (A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\n\nExample 1:\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n\nExample 2:\nInput: s = \"a)b(c)d\"\nOutput: \"ab(c)d\"\n\nExample 3:\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n\nExample 4:\nInput: s = \"(a(b(c)d)\"\nOutput: \"a(b(c)d)\"\n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is one of  '(' , ')' and lowercase English letters.\n-/\n\n-- Result has balanced parentheses\n\n-- Result is a subsequence of input\n\n-- Strings without parens are unchanged\n\n-- Empty string case\n\n-- Only open brackets become empty\n\n-- Only close brackets become empty\n\n-- All chars in result are valid", "vc-preamble": "inductive CharIn (s : String) where\n  | mk (c : Char) (h : s.data.contains c) : CharIn s", "vc-helpers": "", "vc-definitions": "def validParens (s : String) : Bool :=\nsorry\n\ndef isSubsequence (s1 s2 : String) : Bool :=\nsorry\n\ndef minRemoveToMakeValid (s : String) : String :=\nsorry", "vc-theorems": "theorem result_contains_valid_chars (s : String) :\n  ∀ c, (minRemoveToMakeValid s).data.contains c →\n    c = '(' ∨ c = ')' ∨ c = 'a' ∨ c = 'b' ∨ c = 'c' :=\nsorry\n\ntheorem result_has_balanced_parens (s : String) :\n  validParens (minRemoveToMakeValid s) :=\nsorry\n\ntheorem result_is_subsequence (s : String) :\n  isSubsequence (minRemoveToMakeValid s) s :=\nsorry\n\ntheorem no_parens_unchanged (s : String) :\n  (∀ c, s.data.contains c → c ≠ '(' ∧ c ≠ ')') →\n  minRemoveToMakeValid s = s :=\nsorry\n\ntheorem empty_string :\n  minRemoveToMakeValid \"\" = \"\" :=\nsorry\n\ntheorem only_open_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n '(')) = \"\" :=\nsorry\n\ntheorem only_close_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n ')')) = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'lee(t(c)o)de'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"lee(t(c)o)de)\"\n\n/--\ninfo: 'ab(c)d'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"a)b(c)d\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"))((\""}
{"id": "fvapps_000504", "vc-description": "/-\nWitua is a little student from the University of Lviv. He enjoys studying math. Witua knows a lot of famous mathematicians like Eratosthenes, Pythagoras, Fermat, Diophantus, Furko, Gauss and so on. However, his favorite one is Euler. The only thing Witua likes more than Euler is Euler’s totient function φ. He is exploring the nature of this function. One of the steps of his work is finding φ(i)/i for all 2≤i≤N. He doesn’t need to know every such value, but Witua wonders for what value i, is φ(i)/i the maximum he can get? Help little student to find such i that φ(i)/i is maximum among all the  2≤i≤N.\n\n-----Input-----\nThe first line contains single integer T - the number of test cases. Each of the next T lines contains a single integer N. \n\n-----Output-----\nFor every test case output i such that φ(i)/i is maximum among all i (2≤i≤N) in a separate line.\n\n-----Constrains-----\nT (1≤T≤500 )\n\nN(2≤N≤10^18)\n\n-----Example-----\nInput:\n3\n2\n3\n4\n\nOutput:\n2\n3\n3\n\nExplanationφ(2)/2=1/2\nφ(3)/3=2/3\nφ(4)/4=2/4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef modular_pow (base exponent modulus : Nat) : Nat :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry\n\ndef find_max_totient_ratio (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_totient_ratio_small_values :\n  find_max_totient_ratio 2 = 2 ∧\n  find_max_totient_ratio 4 = 3 ∧\n  find_max_totient_ratio 10 = 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 3\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 4"}
{"id": "fvapps_000505", "vc-description": "/-\nAlmir had a small sequence $A_1, A_2, \\ldots, A_N$. He decided to make $K$ copies of this sequence and concatenate them, forming a sequence $X_1, X_2, \\ldots, X_{NK}$; for each valid $i$ and $j$ ($0 \\le j < K$), $X_{j \\cdot N + i} = A_i$.\nFor example, if $A = (1, 2, 3)$ and $K = 4$, the final sequence is $X = (1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)$.\nA pair $(i, j)$, where $1 \\le i < j \\le N$, is an inversion if $X_i > X_j$. Find the number of inversions in the final sequence $X$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of inversions in the sequence $X$.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 100$\n- $1 \\le K \\le 10^6$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n2\n3 3\n2 1 3\n4 100\n99 2 1000 24\n\n-----Example Output-----\n12\n30000\n-/", "vc-preamble": "def sorted (xs : List Nat) : Prop :=\n  ∀ i j, i < j → i < xs.length → j < xs.length →\n    xs[i]! ≤ xs[j]!", "vc-helpers": "", "vc-definitions": "def count_inversions (arr : List Nat) (n : Nat) (m : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_inversions_non_negative (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m ≥ 0 :=\nsorry\n\ntheorem count_inversions_sorted_zero (arr : List Nat) (n : Nat) (m : Nat) :\n  sorted arr → count_inversions arr n m = 0 :=\nsorry\n\ntheorem count_inversions_scale_invariant (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m = count_inversions (List.map (· * 2) arr) n m :=\nsorry\n\ntheorem count_inversions_monotone (arr : List Nat) (n : Nat) (m1 m2 : Nat) :\n  m1 ≤ m2 → count_inversions arr n m1 ≤ count_inversions arr n m2 :=\nsorry\n\ntheorem count_inversions_single_element (n m : Nat) (a : Nat) :\n  count_inversions [a] n m = 0 :=\nsorry\n\ntheorem count_inversions_same_elements (n m a : Nat) :\n  count_inversions [a,a,a] n m = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval count_inversions [2, 1, 3] 3 3\n\n/--\ninfo: 30000\n-/\n#guard_msgs in\n#eval count_inversions [99, 2, 1000, 24] 4 100"}
{"id": "fvapps_000513", "vc-description": "/-\nGiven an Array of length  $N$  containing elements $Ai$ ( i = 1 to n ) . You have to handle $Q$ queries on this array . Each Query is of two types k=(1 or 2). \nType 1:- $k$ $l$ $r$ in which you have to tell whether the product of numbers in range l to r results in a perfect square or not. if product of numbers in range $l$ to$r$ is a perfect square then simply output YES else output NO.\nType 2:- $k$ $i$ $val$ Multiply the value present at index $i$ with $val$.\nNote#1: 1 based indexing in each query.\nNote#2: Values of prime factors of all numbers $val$ and $Ai$ is between 2 to 100 only.\n\n-----Input:-----\n- First line will contain $N$, denoting the size of the array. Then the next line follow. \n- N integers  $Ai - An$.\n- Third line will contain $Q$, denoting the number of queries. Then the next $Q$ lines follow -description of each query. \n- Each query consists of either type 1 or type 2 and each query gives you three elements either\n-{$k$ $l$ $r$} or {$k$ $i$ $val$}\n\n-----Output:-----\nFor each  Query of Type 1 Output either \"YES\" or \"NO\" Without Quotes.\n\n-----Constraints-----\n- $1 \\leq N \\leq 20000$\n- $1 \\leq Q \\leq 20000$\n- $2 \\leq Ai \\leq 1000000$\n- $1 \\leq i ,l,r \\leq N$\n- $1 \\leq val \\leq 1000000$\n- $1 \\leq l \\leq r$\n\n-----Subtasks-----\nSubtask 1 :-40 points \n- Values of prime factors of all numbers $val$ and $Ai$ is between 2 to 40 only.\nSubtask 2 :- 60 points\n- Original Constraints \n\n-----Sample Input:-----\n4\n2 2 3 4\n4\n1 1 2\n1 3 4\n2 3 3\n1 1 4\n\n-----Sample Output:-----\nYES\nNO\nYES\n\n-----EXPLANATION:-----\n-Query 1 :- product of numbers in range 1 to 2=2 * 2=4 (perfect square so YES)\n-Query 2:- product of numbers in range 3 to 4 = 3 * 4 = 12 (not perfect square so NO)\n-Query 3:- multiply number at index3 with 3 so number at index 3= 3*3 = 9 .\n-Query 4:- product of numbers in range 1 to 4 = 2 * 2 * 9 * 4 = 144 (perfect square so YES)\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def perfect_square_range_query (arr : List Nat) (queries : List (Nat × Nat × Nat)) : List String :=\nsorry\n\ndef is_perfect_square (n : Nat) : Bool :=\nsorry\n\ndef product_range (arr : List Nat) (s e : Nat) : Nat :=\nsorry", "vc-theorems": "theorem query_response_format\n  (arr : List Nat) (queries : List (Nat × Nat × Nat)) :\n  let result := perfect_square_range_query arr queries\n  let type_1_count := (queries.filter (fun q => q.fst = 1)).length\n  result.length = type_1_count ∧\n  result.all (fun r => r = \"YES\" ∨ r = \"NO\") :=\nsorry\n\ntheorem array_update_consistency\n  (arr : List Nat) (queries : List (Nat × Nat × Nat)) (i : Nat) (h : i < queries.length) :\n  let result := perfect_square_range_query arr queries\n  let q := queries[i]'h\n  (q.fst = 1 →\n    let product := product_range arr (q.2.1 - 1) (q.2.2)\n    (result[i]? = some \"YES\") = is_perfect_square product) :=\nsorry\n\ntheorem single_element_range\n  (arr : List Nat) (i : Nat) (h : i < arr.length) :\n  let queries := List.range arr.length |>.map (fun i => (1, i+1, i+1))\n  let result := perfect_square_range_query arr queries\n  result[i]? = some (if is_perfect_square (arr[i]'h) then \"YES\" else \"NO\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000520", "vc-description": "/-\nVasya's older brother, Petya, attends an algorithm course in his school. Today he learned about matchings in graphs. Formally, a set of edges in a graph is called a matching if no pair of distinct edges in the set shares a common endpoint.\nPetya instantly came up with an inverse concept, an antimatching. In an antimatching, any pair of distinct edges should have a common endpoint.\nPetya knows that finding a largest matching in a graph is a somewhat formidable task. He wonders if finding the largest antimatching is any easier. Help him find the number of edges in a largest antimatching in a given graph.\n\n-----Input:-----\nThe first line contains T$T$, number of test cases per file.\nThe first line of each test case contains two integers n$n$ and m−$m-$ the number of vertices and edges of the graph respectively (1≤n≤104$1 \\leq n \\leq 10^4$, 0≤m≤104$0 \\leq m \\leq 10^4$).\nThe next m$m$ lines describe the edges. The i$i$-th of these lines contains two integers ui$u_i$ and vi−$v_i-$ the indices of endpoints of the i$i$-th edge (1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$, ui≠vi$u_i \\neq v_i$).\nIt is guaranteed that the graph does not contain self-loops nor multiple edges. It is not guaranteed that the graph is connected.\n\n-----Output:-----\nPrint a single number per test case −$-$ the maximum size of an antichain in the graph.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤n≤104$1 \\leq n \\leq 10^4$\n- 0≤m≤104$0 \\leq m \\leq 10^4$\n- 1≤ui,vi≤n$1 \\leq u_i, v_i \\leq n$\n- ui≠vi$u_i \\neq v_i$\n\n-----Sample Input:-----\n3\n3 3\n1 2\n1 3\n2 3\n4 2\n1 2\n3 4\n5 0\n\n-----Sample Output:-----\n3\n1\n0\n\n-----EXPLANATION:-----\nIn the first sample all three edges form an antimatching.\nIn the second sample at most one of the two edges can be included in an antimatching since they do not share common endpoints.\nIn the third sample there are no edges, hence the answer is 0$0$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_antimatching (n m : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef vertex_degree (v : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem antimatching_nonnegative (n m : Nat) (edges : List (Nat × Nat)) :\n  solve_antimatching n m edges ≥ 0 :=\nsorry\n\ntheorem antimatching_empty_graph (n : Nat) :\n  solve_antimatching n 0 [] = 0 :=\nsorry\n\ntheorem antimatching_single_vertex :\n  solve_antimatching 1 0 [] = 0 :=\nsorry\n\ntheorem antimatching_single_edge :\n  solve_antimatching 2 1 [(1,2)] = 1 :=\nsorry\n\ntheorem antimatching_triangle :\n  solve_antimatching 3 3 [(1,2), (2,3), (1,3)] = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_antimatching 3 3 [(1, 2), (1, 3), (2, 3)]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_antimatching 4 2 [(1, 2), (3, 4)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_antimatching 5 0 []"}
{"id": "fvapps_000526", "vc-description": "/-\nChef has a sequence of positive integers $A_1, A_2, \\ldots, A_N$. He wants to choose some elements of this sequence (possibly none or all of them) and compute their MEX, i.e. the smallest positive integer which does not occur among the chosen elements. For example, the MEX of $[1, 2, 4]$ is $3$.\nHelp Chef find the largest number of elements of the sequence $A$ which he can choose such that their MEX is equal to $M$, or determine that it is impossible.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum number of elements Chef can choose, or $-1$ if he cannot choose elements in such a way that their MEX is $M$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $2 \\le M \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n1\n3 3\n1 2 4\n\n-----Example Output-----\n3\n\n-----Explanation-----\nExample case 1: The MEX of whole array is 3. Hence, we can choose all the elements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_subset_with_mex (n m : Nat) (arr : List Nat) : Int :=\n  sorry\n\ndef mex (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_largest_subset_result_valid (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  result ≤ n :=\nsorry\n\ntheorem find_largest_subset_result_cases (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  (result = -1 ∨ result = n ∨ result = n - (List.count m arr)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 3 [1, 2, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 4 2 [1, 3, 4, 5]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 5 [1, 2, 3]"}
{"id": "fvapps_000532", "vc-description": "/-\nMotu and Patlu are playing with a Magical Ball. Patlu find some interesting pattern in the motion of the ball that ball always bounce back from the ground after travelling a linear distance whose value is some power of $2$. Patlu gave Motu total distance $D$ travelled by the ball and ask him to calculate the minimum number of bounces that the ball makes before coming to rest.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, single integers $D$.\n- Note : Power of $2$ must be a non-negative integer. \n\n-----Output:-----\nFor each testcase, output in a single line answer, the minimum number of bounces the ball makes before coming to rest.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1$ $\\leq$ $M$< $10$^18\n\n-----Sample Input:-----\n1\n13 \n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_ball_bounces (n: Nat) : Nat :=\nsorry\n\ndef isPowerOfTwo (n: Nat) : Bool :=\nsorry\n\ndef allOnesInBinary (n: Nat) : Bool :=\nsorry\n\ndef countOnesInBinary (n: Nat) : Nat :=\nsorry", "vc-theorems": "theorem non_negative_result (distance : Nat) :\n  count_ball_bounces distance ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 13\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 7\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ball_bounces 16"}
{"id": "fvapps_000540", "vc-description": "/-\nSherlock Holmes has decided to start a new academy to some of the young lads. He has conducted several tests and finally selected N equally brilliant\n\nstudents.Now he don't know whether to train all the N students or not. Now since Holmes was in a confusion, Watson came up with an idea. He wanted to\n\ntest the obedience of the students. So during the camp, the students were given some Swiss Chocolates as gifts each time when they passed a level.Now some of them have\n\nfinished eating all the chocolates, some of them had some remaining. Now to test their team chemistry and IQ skills, Watson told the lads to arrange themselves in such \na way that,  number of chocolates of the ith kid should be equal to the sum of   (i-1)th kid and (i-2)th kid. Now they have arranged themselves in an order.\nNow Sherlock announced that he will select the students who have formed the line according to this order. But since there can be many such small groups among the\n\nentire N kids, he will select a sequence of kids such that the length of the sequence is maximized, meanwhile satisfying the above condition \n\n-----Input-----\nFirst line is an integer T which denotes the total number of test cases. Each of the next T lines contains an integer N which denotes, N students. The next \nline contains N spaced integers.where it denotes the order in which the kids arranged themselves. \n\n-----Output-----\nEach line contains an integer which denotes the maximum number of students among the N students who have arranged themselves according the rule said by Watson.It is guaranteed that Holmes will select atleast 1 or 2 students\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10^5\n- 1 ≤ Each of next N integers ≤ 10^9\n\n-----Subtasks-----\nSubtask #1 : (20 points)\n- 1 ≤ T ≤ 10\n- 1 ≤ N≤ 100\n- 1 ≤ Each element≤ 10^3\n\nSubtask 2 : (80 points) \n\n- 1 ≤ T ≤ 10\n- 1 ≤ N≤ 100000\n- 1 ≤ Each element≤ 10^9\n\n-----Example-----\nInput:\n2\n5\n2 3 5 1 2\n3\n1 2 3\n\nOutput:\n3\n3\n\n-----Explanation-----\nExample case 1. Here the first kid has 2 chocolates, second has 3 chocolates, third kid has 5 chocolates, which is the sum of first kid's total chocolates \nand second kid's chocolate. Forth student has only 1 chocolate where he did not follow the rule. So the maximum number of kids who arranged themselves in the order was \n3. That is students at index 1 to index 3.\n-/", "vc-preamble": "def count_fibonacci_sequence (arr : List Int) : Nat :=\n  let rec helper (i : Nat) (curr_max curr_fib : Nat) : Nat :=\n    if i ≥ arr.length then curr_max\n    else match arr.get? i, arr.get? (i-1), arr.get? (i-2) with\n    | some x, some y, some z =>\n      if x = y + z then\n        helper (i+1) (max curr_max (curr_fib + 1)) (curr_fib + 1)\n      else\n        helper (i+1) curr_max 2\n    | _, _, _ => curr_max\n  termination_by arr.length - i\n  helper 2 2 2", "vc-helpers": "", "vc-definitions": "def find_max_sequence_length (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_sequence_length_empty :\n  find_max_sequence_length 0 [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 5 [2, 3, 5, 1, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 3 [1, 2, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_sequence_length 2 [1, 2]"}
{"id": "fvapps_000541", "vc-description": "/-\nA robot is initially at $(0,0)$ on the cartesian plane. It can move in 4 directions - up, down, left, right denoted by letter u, d, l, r respectively. More formally:\n- if the position of robot is $(x,y)$ then u makes it $(x,y+1)$\n- if the position of robot is $(x,y)$ then l makes it $(x-1,y)$\n- if the position of robot is $(x,y)$ then d makes it $(x,y-1)$\n- if the position of robot is $(x,y)$ then r makes it $(x+1,y)$\nThe robot is performing a counter-clockwise spiral movement such that his movement can be represented by the following sequence of moves -\nulddrruuulllddddrrrruuuuu… and so on.\nA single move takes 1 sec. You have to find out the position of the robot on the cartesian plane at $t$ second.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $t$.\n\n-----Output:-----\nFor each test case, print two space-separated integers, $(x,y)$ — the position of the robot.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq t \\leq 10^{18}$\n\n-----Sample Input:-----\n5\n1\n2\n3\n50\n12233443\n\n-----Sample Output:-----\n0 1\n-1 1\n-1 0\n2 4\n-1749 812\n-/", "vc-preamble": "def manhattan_distance (x y : Int) : Nat :=\n  Int.natAbs x + Int.natAbs y", "vc-helpers": "", "vc-definitions": "def find_robot_position (t : Nat) : Int × Int :=\n  sorry", "vc-theorems": "theorem coordinates_are_integers (t : Nat) (h : t > 0) :\n  let (x, y) := find_robot_position t\n  True :=\nsorry\n\ntheorem position_uniqueness (t : Nat) (h : t > 0) :\n  find_robot_position t = find_robot_position t :=\nsorry\n\ntheorem first_position_is_up :\n  find_robot_position 1 = (0, 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (0, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 1\n\n/--\ninfo: (-1, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 2\n\n/--\ninfo: (2, 4)\n-/\n#guard_msgs in\n#eval find_robot_position 50"}
{"id": "fvapps_000555", "vc-description": "/-\nAyu loves distinct letter sequences ,a distinct letter sequence is defined by a sequence of small case english alphabets such that no character appears more then once.\nBut however there are two phrases that she doesn't like these phrases are \"kar\" and \"shi\" and she is given a sequence of distinct characters and she wonders how many such sequences she can form using all the characters such that these phrases don't occur.\nHelp her finding the number of such sequences.\nNew Year Gift - It is guaranteed that for sequences of length greater then 6 letters k,a,r,s,h,i will be present(we thought of being generous, thank us later :)).\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each line consists of a string $S$ (3<=s.length<=18) of distinct characters.\n\n-----Output:-----\nPrint the number of sequences that can be formed by permuting all the characters such that phrases \"kar\" and \"shi\" don't occur.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $3 \\leq S.length \\leq 18$\n\n-----Sample Input:-----\n2\nkarp\nabcd\n\n-----Sample Output:-----\n22\n24\n-/", "vc-preamble": "def factorial (n : Nat) : Nat :=\n  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n\n\ndef containsChar (s : String) (c : Char) : Bool :=\n  s.data.contains c", "vc-helpers": "", "vc-definitions": "def count_distinct_sequences (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem count_distinct_basic_properties (s : String) :\n  let result := count_distinct_sequences s\n  result ≤ factorial s.length ∧\n  0 < result ∧\n  result = result\n  :=\nsorry\n\ntheorem count_distinct_special_substring (s : String) :\n  let result := count_distinct_sequences s\n  ((containsChar s 'k' ∧ containsChar s 'a' ∧ containsChar s 'r') ∨\n   (containsChar s 's' ∧ containsChar s 'h' ∧ containsChar s 'i')) →\n  result < factorial s.length\n  :=\nsorry\n\ntheorem count_distinct_karshi_all_letters (s : String) :\n  let result := count_distinct_sequences s\n  (containsChar s 'k' ∧ containsChar s 'a' ∧ containsChar s 'r' ∧\n   containsChar s 's' ∧ containsChar s 'h' ∧ containsChar s 'i') →\n  result < factorial s.length - factorial (s.length - 2)\n  :=\nsorry\n\ntheorem count_distinct_exact_karshi (s : String) :\n  s.length = 6 →\n  (s.data.toArray.qsort (· < ·) = \"karshi\".data.toArray.qsort (· < ·)) →\n  count_distinct_sequences s = factorial 6 - 2 * factorial 4\n  :=\nsorry\n\ntheorem count_distinct_length_properties (s : String) :\n  let result := count_distinct_sequences s\n  (s.length ≤ 2 → result = factorial s.length) ∧\n  (s.length > 6 ∧ containsChar s 'k' ∧ containsChar s 'a' ∧\n   containsChar s 'r' ∧ containsChar s 's' ∧ containsChar s 'h' ∧\n   containsChar s 'i' →\n    result = factorial s.length - 2 * factorial (s.length - 2) + factorial (s.length - 4))\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 22\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"karp\"\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"abcd\""}
{"id": "fvapps_000556", "vc-description": "/-\nThe chef has a recipe he wishes to use for his guests,\nbut the recipe will make far more food than he can serve to the guests.\nThe chef therefore would like to make a reduced version of the recipe which has the same ratios of ingredients, but makes less food.\nThe chef, however, does not like fractions.\nThe original recipe contains only whole numbers of ingredients,\nand the chef wants the reduced recipe to only contain whole numbers of ingredients as well.\nHelp the chef determine how much of each ingredient to use in order to make as little food as possible.\n\n-----Input-----\nInput will begin with an integer T, the number of test cases.\nEach test case consists of a single line.\nThe line begins with a positive integer N, the number of ingredients.\nN integers follow, each indicating the quantity of a particular ingredient that is used.\n\n-----Output-----\nFor each test case, output exactly N space-separated integers on a line,\ngiving the quantity of each ingredient that the chef should use in order to make as little food as possible.\n\n-----Sample Input-----\n3\n2 4 4\n3 2 3 4\n4 3 15 9 6\n\n-----Sample Output-----\n1 1\n2 3 4\n1 5 3 2\n\n-----Constraints-----\nT≤100\n\n2≤N≤50\n\nAll ingredient quantities are between 1 and 1000, inclusive.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reduce_recipe (ingredients : List Nat) : List Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef gcdl (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem reduce_recipe_proportions (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  let result := reduce_recipe ingredients\n  ∀ i j, i < ingredients.length → j < ingredients.length →\n    ingredients[i]! * result[j]! = ingredients[j]! * result[i]! :=\nsorry\n\ntheorem reduce_recipe_gcd (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  gcdl (reduce_recipe ingredients) = 1 :=\nsorry\n\ntheorem gcd_divides (a b : Nat) (h₁ : a > 0) (h₂ : b > 0) :\n  let g := gcd a b\n  g ∣ a ∧ g ∣ b :=\nsorry\n\ntheorem gcd_commutative (a b : Nat) (h₁ : a > 0) (h₂ : b > 0) :\n  gcd a b = gcd b a :=\nsorry\n\ntheorem reduce_recipe_nat (ingredients : List Nat)\n  (h : ∀ x ∈ ingredients, x > 0) :\n  ∀ x, x ∈ reduce_recipe ingredients → x > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval reduce_recipe [4, 4]\n\n/--\ninfo: [2, 3, 4]\n-/\n#guard_msgs in\n#eval reduce_recipe [2, 3, 4]\n\n/--\ninfo: [1, 5, 3, 2]\n-/\n#guard_msgs in\n#eval reduce_recipe [3, 15, 9, 6]"}
{"id": "fvapps_000559", "vc-description": "/-\nFind out the maximum sub-array of non negative numbers from an array. \n\nThe sub-array should be continuous. That is, a sub-array created by choosing the second and fourth element and skipping the third element is invalid.\n\nMaximum sub-array is defined in terms of the sum of the elements in the sub-array. Sub-array A is greater than sub-array B if sum(A) > sum(B).\n\nNOTE 1 :If there is a tie, then compare with segment's length and return segment which has maximum length \n\nNOTE 2: If there is still a tie, then return the segment with minimum starting index.\n\n-----Input-----\n\nThe first line contains the number of test cases. Each test cases contains an integer N. next line consists of N integers, the elements of the array.\n\n-----Output-----\n\nPrint out the maximum sub-array as stated above.\n\n-----Constraints-----\n-  1  ≤  T  ≤  100 \n-  1  ≤  N  ≤  105 \n-  1  ≤  Ai  ≤  105 \n\n-----Example-----\nInput:\n\n1\n6\n1 2 5 -7 2 3\n\nOutput:\n\n1 2 5\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_subarray (arr : List Int) : List Int :=\nsorry\n\ndef sum_list (l : List Int) : Int :=\nsorry\n\ndef all_subarrays_bounded_by_negatives (arr : List Int) : List (List Int) :=\nsorry", "vc-theorems": "theorem all_positive_returns_full_array {arr : List Int}\n  (h : ∀ x ∈ arr, x ≥ 0) (nonempty : arr ≠ []) :\n  find_max_subarray arr = arr :=\nsorry\n\ntheorem sum_is_maximal {arr : List Int} (nonempty : arr ≠ []) :\n  let result := find_max_subarray arr\n  let result_sum := sum_list result\n  ∀ subarray ∈ all_subarrays_bounded_by_negatives arr,\n    sum_list subarray ≤ result_sum :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000567", "vc-description": "/-\nLet's call a sequence good if the sum of all its elements is $0$.\nYou have a sequence of integers $A_1, A_2, \\ldots, A_N$. You may perform any number of operations on this sequence (including zero). In one operation, you should choose a valid index $i$ and decrease $A_i$ by $i$. Can you make the sequence good using these operations?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"YES\" if it is possible to make the given sequence good or \"NO\" if it is impossible.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10$\n- $|A_i| \\le 100$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (10 points): $N = 1$\nSubtask #2 (30 points): $N \\le 2$\nSubtask #3 (60 points): original constraints\n\n-----Example Input-----\n2\n1\n-1\n2\n1 2\n\n-----Example Output-----\nNO\nYES\n\n-----Explanation-----\nExample case 2: We can perform two operations ― subtract $1$ from $A_1$ and $2$ from $A_2$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_make_sequence_good (n : Nat) (sequence : List Int) : String :=\nsorry\n\ndef sum_nonnegative (l : List Int) : Int :=\nsorry\n\ndef sum_negative (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem sequence_result_is_yes_or_no (n : Nat) (sequence : List Int) :\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" ∨ result = \"NO\" :=\nsorry\n\ntheorem yes_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"YES\" →\n  sum_nonnegative sequence ≥ Int.natAbs (sum_negative sequence) :=\nsorry\n\ntheorem no_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"NO\" →\n  sum_nonnegative sequence < Int.natAbs (sum_negative sequence) :=\nsorry\n\ntheorem single_element_sequence (x : Int) :\n  can_make_sequence_good 1 [x] = (if x ≥ 0 then \"YES\" else \"NO\") :=\nsorry\n\ntheorem sequence_length_valid (sequence : List Int) :\n  let n := sequence.length\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" ∨ result = \"NO\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 1 [-1]\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 2 [1, 2]\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 3 [1, -2, 3]"}
{"id": "fvapps_000569", "vc-description": "/-\nYou are an evil sorcerer at a round table with $N$ sorcerers (including yourself). You can cast $M$ spells which have distinct powers $p_1, p_2, \\ldots, p_M$.\nYou may perform the following operation any number of times (possibly zero):\n- Assign a living sorcerer to each positive integer cyclically to your left starting from yourself ― the closest living sorcerer to your left is assigned to $1$, the next living sorcerer to the left is assigned to $2$ and so on. Note that each living sorcerer (including yourself) is assigned to an infinite number of integers.\n- Choose a spell $j$ (possibly a spell you have chosen before) and kill the living sorcerer assigned to $p_j$. You may not cast a spell to kill yourself. \n\nWhat is the maximum number of sorcerers you can kill using zero or more operations?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $M$ space-separated integers $p_1, p_2, \\ldots, p_M$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum number of sorcerers you can kill.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^9$\n- $1 \\le M \\le 3 \\cdot 10^5$\n- $1 \\le p_i \\le 10^9$ for each valid $i$\n- $p_1, p_2, \\ldots, p_N$ are pairwise distinct\n- the sum of $M$ over all test cases does not exceed $3 \\cdot 10^5$\n\n-----Example Input-----\n5\n4 1\n5\n6 2\n2 4\n1 4\n7 16 8 29\n1000000000 1\n998244353\n1 1\n20201220\n\n-----Example Output-----\n3\n4\n0\n1755647\n0\n\n-----Explanation-----\nExample case 1: The initial state is shown in the figure from the statement. We can first use spell $1$ and kill the $5$-th sorcerer to our left, i.e. sorcerer $2$. Now there are $3$ living sorcerers and the state is as shown in the following figure:\n\nWe can use spell $1$ again and kill the current $5$-th living sorcerer to our left, i.e. sorcerer $4$. Now there are $2$ living sorcerers and the state is:\n\nFinally, we can use spell $1$ again and kill the only other living sorcerer, i.e. sorcerer $3$. Now, none of the other sorcerers are alive. As we cannot cast a spell to kill ourselves, we cannot improve the answer any further.\nExample case 2: We can perform $4$ operations using the spell $p_1 = 2$ each time. We can also instead use $p_2 = 4$ in the first two operations and $p_1 = 2$ in the last two operations. Note that there may be multiple valid sequences of operations that lead to the best answer.\nExample case 3: We cannot perform any operations using any of the given spells, so we are unable to kill any sorcerers.\nExample case 4: We can perform $1,755,647$ operations, each of them using the spell $p_1 = 998,244,353$.\n-/\n\n-- Result is non-negative\n\n-- Result is less than or equal to n\n\n-- GCD divides both numbers\n\n-- GCD is positive\n\n-- GCD is largest such number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_evil_sorcerer (n : Nat) (p : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_evil_sorcerer_properties {n : Nat} {p : List Nat}\n  (n_pos : n > 0) (p_pos : ∀ x ∈ p, x > 0) :\n  let result := solve_evil_sorcerer n p\n\n  result ≥ 0 ∧\n\n  result ≤ n := by\n  sorry\n\ntheorem gcd_properties {a b : Nat} (a_pos : a > 0) (b_pos : b > 0) :\n  let g := gcd a b\n\n  (a % g = 0 ∧ b % g = 0) ∧\n\n  g > 0 ∧\n\n  ∀ i, g < i → i ≤ min a b → ¬(a % i = 0 ∧ b % i = 0) := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 4 [5]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 6 [2, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 1 [20201220]"}
{"id": "fvapps_000572", "vc-description": "/-\nVasya has ordered a pizza delivery. The pizza can be considered a perfect circle. There were $n$ premade cuts in the pizza when it was delivered. Each cut is a straight segment connecting the center of the pizza with its boundary.\nLet $O$ be the center of the pizza, $P_i$ be the endpoint of the $i$-th cut lying on the boundary, and $R$ be the point of the boundary straight to the right of $O$. Then the counterclockwise-measured angle $\\angle ROP_i$ is equal to $a_i$ degrees, where $a_i$ is an integer between $0$ and $359$. Note that angles between $0$ and $180$ angles correspond to $P_i$ in the top half of the pizza, while angles between $180$ and $360$ angles correspond to the bottom half.\nVasya may cut his pizza a few more times, and the new cuts still have to be straight segments starting at the center. He wants to make the pizza separated into several equal slices, with each slice being a circular sector with no cuts inside of it. How many new cuts Vasya will have to make?\n\n-----Input:-----\nThe first line of input contains $T$ , i.e number of test cases per file.\nThe first line of each test case contains a single integer $n-$  the numbers of premade cuts ($2 \\leq n \\leq 360$).\nThe second lines contains $n$ integers $a_1, \\ldots, a_n-$ angles of the cuts $1, \\ldots, n$ respectively ($0 \\leq a_1 < \\ldots, a_{n - 1} < 360$).\n\n-----Output:-----\nPrint a single integer$-$ the smallest number of additional cuts Vasya has to make so that the pizza is divided into several equal slices.\n\n-----Constraints-----\n- $1  \\leq T  \\leq 36$\n- $2 \\leq n \\leq 360$\n- $0 \\leq a_1 < \\ldots, a_{n - 1} < 360$\n\n-----Sample Input:-----\n3\n4 \n0 90 180 270\n2\n90 210\n2\n0 1\n\n-----Sample Output:-----\n0\n1\n358\n\n-----EXPLANATION:-----\nIn the first sample the pizza is already cut into four equal slices.\nIn the second sample the pizza will be cut into three equal slices after making one extra cut at $330$ degrees.\nIn the third sample Vasya will have to cut his pizza into $360$ pieces of $1$ degree angle each.\n-/\n\n-- GCD theorems\n\n-- Pizza cuts theorems", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def gcd (a b : Int) : Int :=\n  sorry\n\ndef minPizzaCuts (n : Nat) (angles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_positive {a b : Int} (h : a ≠ 0 ∨ b ≠ 0) :\n  gcd (abs a) (abs b) > 0 :=\nsorry\n\ntheorem gcd_divides {a b : Int} :\n  let d := gcd (abs a) (abs b)\n  (a ≠ 0 → abs a % d = 0) ∧\n  (b ≠ 0 → abs b % d = 0) :=\nsorry\n\ntheorem minPizzaCuts_nonnegative {n : Nat} {angles : List Nat} :\n  minPizzaCuts n angles ≥ 0 :=\nsorry\n\ntheorem minPizzaCuts_upper_bound {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles + n ≤ 360 :=\nsorry\n\ntheorem minPizzaCuts_rotation_invariant {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles =\n  minPizzaCuts n (List.map (fun x => (x + 45) % 360) angles) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_pizza_cuts 4 [0, 90, 180, 270]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [90, 210]\n\n/--\ninfo: 358\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [0, 1]"}
{"id": "fvapps_000581", "vc-description": "/-\nRoman has no idea, why this problem is called Stone. He also has no idea on how to solve the followong problem: given array of N integers A and a number K. During a turn the maximal value over all Ai is chosen, let's call it MAX. Then Ai = \nMAX - Ai is done for every 1 <= i <= N. Help Roman to find out how will the array look like after K turns.\n\n-----Input-----\nThe numbers N and K are given in the first line of an input. Then N integers are given in the second line which denote the array A. \n\n-----Output-----\nOutput N numbers on a single line. It should be the array A after K turns.\n\n-----Constraints-----\n\n- 1 <= N <= 105\n- 0 <= K <= 109\n- Ai does not exceed 2 * 109 by it's absolute value.\n\n-----Example-----\nInput:\n4 1\n5 -1 7 0\n\nOutput:\n2 8 0 7\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_stone_array (n k : Nat) (A : List Int) : List Int :=\n  sorry\n\ndef list_maximum (l : List Int) : Int :=\n  sorry\n\ndef list_minimum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem stone_array_output_length {n k : Nat} {A : List Int} :\n  List.length (solve_stone_array n k A) = List.length A :=\nsorry\n\ntheorem stone_array_zero_k {n : Nat} {A : List Int} :\n  solve_stone_array n 0 A = A :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000582", "vc-description": "/-\nChef just got a box of chocolates as his birthday gift. The box contains $N$ chocolates in a row (numbered $1$ through $N$), where $N$ is even. For each valid $i$, the $i$-th chocolate has a sweetness value $W_i$.\nChef wants to eat all the chocolates in the first half of the box and leave all chocolates in the second half uneaten. Since he does not like chocolates that are too sweet, he will be unhappy if at least one of the chocolates he eats has the maximum sweetness among all the chocolates in the box.\nA right cyclic shift by $k$ chocolates ($0 \\le k < N$) consists of moving the last $k$ chocolates in the row to the beginning in the same order and moving each of the remaining $N-k$ chocolates $k$ places to the right. Before eating the first half of the chocolates, Chef wants to perform some right cyclic shift in such a way that he will not be unhappy after eating them. Find the number of ways to do this, i.e. the number of valid integers $k$ such that if Chef performs the right cyclic shift by $k$ chocolates and then eats the first half of the chocolates in the box, he does not become unhappy.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $W_1, W_2, \\ldots, W_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of shifts for which Chef does not become unhappy.\n\n-----Constraints-----\n- $1 \\le T \\le 5$\n- $1 \\le N \\le 10^5$\n- $N$ is even\n- $1 \\le W_i \\le 10^5$ for each valid $i$\n\n-----Example Input-----\n2\n6\n1 1 2 1 1 1\n6\n1 1 2 1 1 2\n\n-----Example Output-----\n3\n0\n\n-----Explanation-----\nExample case 1: The three valid right shifts and the contents of the box for these shifts are:\n- shift by $k = 1$: $(1, 1, 1, 2, 1, 1)$\n- shift by $k = 2$: $(1, 1, 1, 1, 2, 1)$\n- shift by $k = 3$: $(1, 1, 1, 1, 1, 2)$\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_valid_shifts (n : Nat) (nums : List Nat) : Nat :=\nsorry\n\ndef verify_shift (arr : List Nat) (shift_pos : Nat) : Bool :=\nsorry", "vc-theorems": "theorem result_bounds (n : Nat) (nums : List Nat)\n  (h1 : 2 ≤ n) (h2 : n ≤ 20) (h3 : nums.length = n) :\n  0 ≤ count_valid_shifts n nums ∧ count_valid_shifts n nums ≤ n :=\nsorry\n\ntheorem all_same_gives_zero (n : Nat)\n  (h1 : 2 ≤ n) (h2 : n ≤ 20) :\n  count_valid_shifts n (List.replicate n 1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 2]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_valid_shifts 4 [1, 2, 1, 1]"}
{"id": "fvapps_000604", "vc-description": "/-\nGiven n words w[1..n], which originate from the same stem (e.g. grace, graceful, disgraceful, gracefully), we are interested in the original stem. To simplify the problem, we define the stem as the longest consecutive substring that occurs in all the n words. If there are ties, we will choose the smallest one in the alphabetical (lexicographic) order.\n\n-----Input-----\nThe first line contains an integer T denoting the total number of test cases.\nIn each test cases, the first line contains an integer n denoting the number of words. In the second line, n words w[1..n] consisting of lower case characters are given as a single space-spearated list.\n\n-----Output-----\nFor each test case, output the stem in a new line.\n\n-----Constraints-----\n- 1 <= T <= 10\n- 1 <= n <= 10\n- 1 <= |w[i]| <= 20\n\n-----Example-----\nInput:\n1\n4\ngrace graceful disgraceful gracefully\nOutput:\ngrace\n\n-----Explanation-----\nThe stem is grace.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isInfixOf (sub str : String) : Bool :=\nsorry\n\ndef substr (s : String) (i len : Nat) : String :=\nsorry\n\ndef find_stem (words : List String) : String :=\nsorry", "vc-theorems": "theorem stem_exists_in_all_words (words : List String) :\n  let stem := find_stem words\n  ∀ word ∈ words, isInfixOf stem word :=\nsorry\n\ntheorem stem_is_substring_of_first_word (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  isInfixOf stem (words.get ⟨0, h⟩) :=\nsorry\n\ntheorem stem_length_consistency (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  let first := words.get ⟨0, h⟩\n  ∀ i j, i < j → j ≤ first.length →\n    let substring := substr first i (j-i)\n    (∀ word ∈ words, isInfixOf substring word) →\n    substring.length ≤ stem.length ∨\n    (substring.length = stem.length ∧ stem ≤ substring) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'grace'\n-/\n#guard_msgs in\n#eval find_stem [\"grace\", \"graceful\", \"disgraceful\", \"gracefully\"]\n\n/--\ninfo: 'cat'\n-/\n#guard_msgs in\n#eval find_stem [\"cat\", \"catch\", \"cathedral\"]\n\n/--\ninfo: 'python'\n-/\n#guard_msgs in\n#eval find_stem [\"python\", \"pythonic\", \"pythoness\"]"}
{"id": "fvapps_000606", "vc-description": "/-\nGiven the list of numbers, you are to sort them in non decreasing order.\n\n-----Input-----\nt – the number of numbers in list, then t lines follow [t <= 10^6]. \n\nEach line contains one integer: N [0 <= N <= 10^6]\n\n-----Output-----\nOutput given numbers in non decreasing order.\n\n-----Example-----\nInput:\n5\n5\n3\n6\n7\n1\n\nOutput:\n1\n3\n5\n6\n7\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_numbers (nums : List Int) : List String :=\n  sorry\n\ndef isSorted (l : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem sort_numbers_ascending (nums : List Int) :\n  let result := sort_numbers nums;\n  result.length = nums.length ∧\n  isSorted (result.map String.toInt!) := by\n  sorry\n\ntheorem sort_numbers_idempotent_list (nums : List Int) :\n  sort_numbers nums = sort_numbers nums := by\n  sorry\n\ntheorem sort_numbers_bounds (nums : List Int) (h : nums ≠ []) :\n  let result := sort_numbers nums\n  let vals := result.map String.toInt!\n  vals.head! ≤ vals.getLast! ∧\n  ∀ x ∈ vals, vals.head! ≤ x ∧ x ≤ vals.getLast! := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000607", "vc-description": "/-\nOnce, a genius guy Cristo visited NASA where he met many scientists. A young intern Mark at NASA asked Cristo to observe the strange behaviour of two\n\nindependent particles (say Alpha and Beta) moving in the free space.Cristo was astonished to see the movement of Alpha and Beta. However, he formulated a procedure\n\nto evaluate the distance covered by the particles in given time.\nThe procedure calculates the distance covered by Alpha and Beta for a given time. Mark, however struggles\n\nto evaluate the procedure manually and asks you to help him. \nCristo's Procedure :- \nalpha = 0\nbeta = 0\nProcedure CristoSutra( Ti ) :\nif Ti <= 0 :\nalpha = alpha + 1 \nelse if Ti == 1 :\n\tbeta = beta + 1\nelse :\nCristoSutra(Ti-1)\n\t         CristoSutra(Ti-2)\n\t         CristoSutra(Ti-3)\nend procedure\nNote: Print the answer by taking mod from 109+7 .\n\n-----Constraints:-----\n- 1<=T<=105\n- 1<=Ti<=105\n\n-----Input Format:-----\nFirst line consists an integer t, number of Test cases.For each test case, there is an integer denoting time Ti.\n\n-----Output Format:-----\nFor each test case, a single output line contains two space seperated numbers ,distance covered by alpha and beta in the given time.\n\n-----Subtasks:-----\nSubtask 1 (30 points)\n- 1<=T<=10\n- 1<=Ti<=1000\nSubtask 2 (70 points)\noriginal contraints\nSample Input:\n2\n1\n2\nSample Output:\n0 1\n2 1\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def cristo_sutra (input : List Nat) : List String :=\nsorry\n\ndef parseResults (strs : List String) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem cristo_sutra_length (input : List Nat) :\n  input.length > 0 → (cristo_sutra input).length = input.length :=\nsorry\n\ntheorem cristo_sutra_base_cases :\n  cristo_sutra [1] = [\"0 1\"] ∧\n  cristo_sutra [2] = [\"2 1\"] ∧\n  cristo_sutra [3] = [\"3 2\"] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000608", "vc-description": "/-\nShaun is very much interested in Subarrays. Shaun wants to count the number of subarrays in his chosen array with sum being a multiple of $10^9$. Since, Shaun is interested in huge numbers.He chose his array such that it contains only $10^8$ and $9*10^8$ as its elements.\nHelp shaun to count the number of required subarrays.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains one integer $N$,size of array $A$. \n- Second line of each testcase contains $N$ space separated array elements\n\n-----Output:-----\nFor each testcase, output in a single line number of subarrays with sum being multiple of $10^9$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $A[i]$=$10^8$ , $9*10^8$\n\n-----Sample Input:-----\n2\n3\n100000000 900000000 100000000\n1\n900000000\n\n-----Sample Output:-----\n2\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry\n\ndef count_valid_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_subarrays_singleton (x : Nat) :\n  solve_subarrays 1 [x] = 0 :=\nsorry\n\ntheorem solve_subarrays_alternating_nonneg (n : Nat) :\n  let arr := List.replicate (2*n) 100000000 ++ List.replicate (2*n) 900000000\n  solve_subarrays (4*n) arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_subarrays 3 [100000000, 900000000, 100000000]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 1 [900000000]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 2 [100000000, 100000000]"}
{"id": "fvapps_000610", "vc-description": "/-\nChef and his best friend Aleksa are into mathematical games these days. Today, they have some ( ≥ 0 ) black cells represented as B, and a white cell represented as W, lying randomly in a straight line.\nThey have decided to play with these cells. In a move, a player chooses some ( > 0 ) black cells lying on any one side of the white cell and remove them. It should be noted that a player is not allowed to choose black cells from both side of the given white cell. Both the players alternate their moves, and play optimally. The player who is unable to move in his respective turn will lose the game.\nAleksa, being a girl, has a habit of playing first. But Chef is fairly smart himself, and will not play the game if he is going to lose it. Therefore, he wants to know the winner beforehand. Can you tell him who is going to win the game for the given configuration of cells?\n\n-----Input-----\nFirst line of input contains a single integer T denoting the number of test cases. First and the only line of each test case contains a string S consisting of the characters 'B' and 'W', denoting black and white cells, respectively.\n\n-----Output-----\nFor each test case, output \"Chef\" if chef wins the game for the given configuration. Else print \"Aleksa\". (quotes for clarity only).\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ |S| ≤ 10000\n- S contains exactly 1 white cell.\n\n-----Scoring-----\n-  Subtask 1:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10 : ( 30 pts )\n-  Subtask 2:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 100 : ( 30 pts )\n-  Subtask 3:  1 ≤ T ≤ 10, 1 ≤ |S| ≤ 10000 : ( 40 pts )\n\n-----Example-----\nInput\n3\nW\nBW\nBWBB\n\nOutput\nChef\nAleksa\nAleksa\n\n----- Explanation-----\n-  Test 1 : Aleksa cannot make a move in her first turn as there is no black cell in the given configuration.\n-  Test 2 : Aleksa can remove 1 black cell lying on the left of white cell in her turn. But then, Chef cannot make a move in his turn as there will be no black cells left.\n-  Test 3 : Figure out yourself.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gameWinner (config : String) : String :=\nsorry\n\ndef countBlacksBeforeWhite (s : String) : Nat :=\nsorry\n\ndef countBlacksAfterWhite (s : String) : Nat :=\nsorry", "vc-theorems": "theorem gameWinner_returns_valid_player (config : String) :\n  (gameWinner config = \"Chef\" ∨ gameWinner config = \"Aleksa\") :=\nsorry\n\ntheorem chef_wins_equal_blacks (config : String)\n  (h : countBlacksBeforeWhite config = countBlacksAfterWhite config) :\n  gameWinner config = \"Chef\" :=\nsorry\n\ntheorem aleksa_wins_unequal_blacks (config : String)\n  (h : countBlacksBeforeWhite config ≠ countBlacksAfterWhite config) :\n  gameWinner config = \"Aleksa\" :=\nsorry\n\ntheorem chef_wins_single_white (config : String)\n  (h : config = \"W\") :\n  gameWinner config = \"Chef\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Chef'\n-/\n#guard_msgs in\n#eval game_winner \"W\"\n\n/--\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BW\"\n\n/--\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BWBB\""}
{"id": "fvapps_000614", "vc-description": "/-\nWell known investigative reporter Kim \"Sherlock'' Bumjun needs your help! Today, his mission is to sabotage the operations of the evil JSA. If the JSA is allowed to succeed, they will use the combined power of the WQS binary search and the UFDS to take over the world!\nBut Kim doesn't know where the base is located. He knows that the base is on the highest peak of the Himalayan Mountains. He also knows the heights of each of the $N$ mountains. Can you help Kim find the height of the mountain where the base is located? \n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow.    \n- The first line in each testcase contains one integer, $N$.    \n- The following $N$ lines of each test case each contain one integer: the height of a new mountain.\n\n-----Output:-----\nFor each testcase, output one line with one integer: the height of the tallest mountain for that test case.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 100000$\n- $0 \\leq$ height of each mountain $\\leq 10^9$\n\n-----Subtasks:-----\n- 100 points: No additional constraints.\n\n-----Sample Input:-----\n1\n5\n4\n7\n6\n3\n1\n\n-----Sample Output:-----\n7\n-/", "vc-preamble": "def list_max (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl Nat.max h t\n\ndef list_min (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl Nat.min h t", "vc-helpers": "", "vc-definitions": "def find_tallest_mountain (n : Nat) (heights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_tallest_in_list {n : Nat} {heights : List Nat} (h : heights ≠ []) :\n  find_tallest_mountain n heights ∈ heights\n  :=\nsorry\n\ntheorem length_preserved {n : Nat} {heights : List Nat} :\n  heights.length = n →\n  heights.length = n\n  :=\nsorry\n\ntheorem single_mountain_height {height : Nat} :\n  find_tallest_mountain 1 [height] = height\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_tallest_mountain 5 [4, 7, 6, 3, 1]\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval find_tallest_mountain 3 [10, 20, 30]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_tallest_mountain 1 [5]"}
{"id": "fvapps_000617", "vc-description": "/-\nIn this problem you are given a sequence of $N$ positive integers $S[1],S[2],\\dots,S[N]$. In addition you are given an integer $T$, and your aim  is to find the number of quadruples $(i,j,k,l)$, such that $1 \\le i < j < k < l \\le N$, and $S[i] + S[j] + S[k] + S[l] = T$.  That is, the number of ways of picking four numbers from the sequence summing up to $T$.\n\n-----Constraints:-----\nFor all test cases,\n- $1 \\le N \\le 5000$\n- $1 \\le T \\le 10^6$\n- $1 \\le S[i] \\le 10^9$, for all $i$.\nSubtask $1:10\\%$\nIt is guaranteed that $N \\le 50$.\nSubtask $2:50\\%$\nIt is guaranteed that $N \\le 300$.\nSubtask $3:40\\%$\nNo additional guarantees.\n\n-----Input Format:-----\nThere is only one line of input with $N+2$ space separated integers. The first two integers are $N$ and $T$. The next $N$ integers are $S[1],S[2],\\dots,S[N]$.\n\n-----Output Format:-----\nA single integer which is the number of valid quadruples.\n\n-----Sample Input 1:-----\n6 20 3 1 1 2 5 10\n\n-----Sample Output 1:-----\n1\n\n-----Explanation 1:-----\nThe quadruple $(1,4,5,6)$ is valid  because $S[1]+S[4]+S[5]+S[6]=3+2+5+10=20$. You can check that no other quadruple is valid and hence the answer is $1$.\n\n-----Sample Input 2:-----\n6 13 1 2 3 4 5 4 \n\n-----Sample Output 2:-----\n3\n\n-----Explanation 2:-----\nYou can verify that the only quadruples that are valid are $(2,3,4,6),(1,3,4,5)$  and $(1,3,5,6)$. Thus, the answer is $3$.\n\n-----Note:-----\nAs the answer might be large, please use 64 bit integers (long long int in\nC/C++ and long in Java) instead of 32 bit int.\n-/", "vc-preamble": "def listMax : List Int → Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)\n\ndef listSum : List Int → Int\n  | [] => 0\n  | (x::xs) => x + listSum xs", "vc-helpers": "", "vc-definitions": "def count_quadruples (n : Nat) (target : Int) (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem count_quadruples_returns_natural\n  (nums : List Int) (target : Int) (h : nums.length ≥ 4) :\n  count_quadruples nums.length target nums ≥ 0 :=\nsorry\n\ntheorem count_quadruples_binary_for_four\n  (nums : List Int) (target : Int) (h : nums.length = 4) :\n  count_quadruples nums.length target nums = 0 ∨\n  count_quadruples nums.length target nums = 1 :=\nsorry\n\ntheorem insufficient_elements_gives_zero\n  (nums : List Int) (target : Int) (h : nums.length < 4) :\n  count_quadruples nums.length target nums = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_quadruples 6 20 [3, 1, 1, 2, 5, 10]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_quadruples 6 13 [1, 2, 3, 4, 5, 4]"}
{"id": "fvapps_000618", "vc-description": "/-\nA balanced parenthesis string is defined as follows:\n- The empty string is balanced\n- If P is balanced, (P) is also \n- If P and Q are balanced, PQ is also balanced\nYou are given two even integers n$n$ and k$k$. Find any balanced paranthesis string of length n$n$ that doesn't contain a balanced substring of length k$k$, or claim that no such string exists.\n\n-----Input-----\n- First line will contain T$T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line containing n$n$ and k$k$.\n\n-----Output-----\nFor every testcase, print on a new line, any balanced paranthesis string of length n$n$ that doesn't contain a balanced substring of length k$k$. If there doesn't exist any such string, print −1$-1$ instead.\n\n-----Constraints-----\n- 1≤T≤50000$1 \\leq T \\leq 50000$\n- 2≤k≤n≤105$2 \\leq k \\leq n \\leq 10^5$\n- Sum of n$n$ over all testcases doesn't exceed 105$10^5$.\n- n$n$ and k$k$ are both even integers.\n\n-----Example Input-----\n2\n4 2\n8 6\n\n-----Example Output-----\n-1\n(())(())\n\n-----Explanation-----\nIn the first testcase, the only balanced strings of length 4$4$ are (()) and ()(), both of which contain () as a substring.\nIn the second testcase, (())(()) is a balanced string that doesn't contain any balanced substring of length 6$6$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_parens (s : String) : Bool :=\nsorry\n\ndef max_nested_depth (s : String) : Nat :=\nsorry\n\ndef solve_balanced_parens (n : Nat) (k : Nat) : String :=\nsorry", "vc-theorems": "theorem balanced_parens_properties (n k : Nat) (h1 : n > 0) (h2 : k > 0) (h3 : n ≤ 100) (h4 : k ≤ 100) :\n  let result := solve_balanced_parens n k\n  if result = \"-1\" then\n    k = 2 ∨ k = 4 ∨ n % 2 ≠ 0 ∨ n = k\n  else\n    result.length = n ∧\n    (∀ c, c ∈ result.data → c = '(' ∨ c = ')') ∧\n    is_valid_parens result :=\nsorry\n\ntheorem odd_k_cases (n : Nat) (h1 : n > 1) (h2 : n ≤ 100) (h3 : n % 2 = 0) :\n  let k := 3\n  let result := solve_balanced_parens n k\n  if result ≠ \"-1\" then\n    result = String.mk (List.replicate (n/2) '(' ++ List.replicate (n/2) ')') else True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '-1'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 4 2\n\n/--\ninfo: '(())(())'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 8 6"}
{"id": "fvapps_000623", "vc-description": "/-\nChef is the leader of Chef's Earth Defense Organization, and his mission is to counter aliens which are threatening the earth. According to information gathered by the organization, there are $N$ alien spaceships (numbered $1$ through $N$) planning to invade the earth. The $i$-th spaceship will appear on the radar at time $C_i$. Each spaceship needs $D$ time to reach earth once it appears on the radar. \nChef's organization owns a huge laser cannon which can destroy one spaceship in one shot. However, once the cannon is used once it needs some amount of cool-down time in order to be used again (first shot doesn't require cool-down time before it is used). This cool-down time, however, is configurable. It has to be set before the first shot, and cannot be changed after that. If Chef sets a lower cool-down time, that would increase the energy consumed by the cannon, and vice-versa - the higher the cool-down time, the lower the energy consumed.\nThis might be a long battle, and Chef wants to use as little energy as possible. So Chef wants to maximize the cool-down time while still being able to destroy all spaceships before any of them arrive on earth. In particular, the $i$-th spaceship should be shot between the times $C_i$ and $C_i + D$ (both end points inclusive).\n\n-----Input:-----\n- The first line of input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two integers $N$ and $D$. \n- The second line contains $N$ space-separated integers $C_1, C_2, \\ldots, C_N$.\n\n-----Output:-----\nFor each test case, print a single line containing one real number― the maximum cool-down time possible. Your answer will be considered correct if the absolute or relative error of the answer does not exceed $10^{-6}$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq N \\leq 10^5$\n- $1 \\leq C_i \\leq 10^9$ for each valid $i$\n- $1 \\leq D \\leq 10^9$\n- The sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points): \n- $N \\le 1,000$\n- the sum of $N$ over all test cases does not exceed $10,000$\nSubtask #2 (50 points): Original constraints\n\n-----Sample Input:-----\n2\n3 2\n3 2 3\n2 1\n5 6\n\n-----Sample Output:-----\n1.5000000000\n2.0000000000\n-/\n\n-- Result should be non-negative\n\n-- Cooldown should not exceed max time window plus delay\n\n-- Monotonicity with respect to delay\n\n-- Known values\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def list_maximum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.max x\n\ndef list_minimum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.min x", "vc-helpers": "", "vc-definitions": "def solve_spaceship_cooldown (n d : Nat) (arrivals : List Nat) : Float :=\n  sorry", "vc-theorems": "theorem spaceship_cooldown_nonnegative\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≥ 0 :=\nsorry\n\ntheorem spaceship_cooldown_upper_bound\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≤\n    ((list_maximum arrivals) - (list_minimum arrivals)).toFloat + d.toFloat :=\nsorry\n\ntheorem spaceship_cooldown_monotone_delay\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length ≥ 2)\n  : solve_spaceship_cooldown n d arrivals ≤ solve_spaceship_cooldown n (d + 1) arrivals :=\nsorry\n\ntheorem spaceship_cooldown_known_value1 :\n  solve_spaceship_cooldown 3 2 [3, 2, 3] = 1.5 :=\nsorry\n\ntheorem spaceship_cooldown_known_value2 :\n  solve_spaceship_cooldown 2 1 [5, 6] = 2.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000624", "vc-description": "/-\nTed$Ted$ loves prime numbers. One day he is playing a game called legendary$legendary$ with his girlfriend Robin$Robin$. Ted$Ted$ writes a number N$N$ on a table and the number is in the form of :\nN = P1A1 *  P2A2 * ……….. * PnAn\nTed$Ted$ asks Robin$Robin$ to find the sum of all the numbers which are less than or equal to N$N$ and also contains all the primes whose minimum power in the number is given by an array B$B$.  \nAs Robin$Robin$ is bad with maths she asks your help to answer this question.\n\n-----Input:-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.  \n- The first line of each test case contains a single integer n$n$, represents a number of distinct prime numbers.\n- The second line of each test case contains n$n$ space separated distinct prime numbers which represents an array P$P$.\n- The third line of each test case contains n$n$ space separated integers which represents an array A$A$.\n- The fourth line of each test case contains n$n$ space separated integers which represents an array B$B$ \n\n-----Output:-----\nFor each test case, output the Answer Modulo 109 + 7 in a single line.\n\n-----Constraints-----\n- 1≤T≤3$1 \\leq T \\leq 3$\n- 1≤n≤105$1 \\leq n \\leq 10^5$\n- 2≤Pi≤106$2 \\leq P_{i} \\leq 10^6$\n- 1≤Ai≤109$1 \\leq A_{i} \\leq 10^9$\n- 0≤Bi≤Ai$0 \\leq B_{i} \\leq Ai$\n\n-----Sample Input:-----\n1\n3\n2 3 5\n2 1 2\n1 1 1\n\n-----Sample Output:-----\n540\n\n-----EXPLANATION:-----\n22 * 31 * 52= 300 which is N over here. \nThe four numbers less than or equal to 300 are 30, 60, 150 and 300.\n\n30 = 21 * 31 * 51 , 60 =  22 * 31 * 51, 150 =  21 * 31 * 52 and 300 =  22 * 31 * 52. \nIn the 4 numbers, the minimum powers for 2, 3 and 5 are 1, 1 and 1 or more than them in every case.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_legendary_prime_game (n: Nat) (p a b: List Nat) : Nat :=\nsorry\n\ndef is_prime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem single_prime_result_bounds (n: Nat) (h: n > 0) (h2: n ≤ 5):\n  let p := List.replicate n 2\n  let a := List.replicate n 1\n  let b := List.replicate n 1\n  let result := solve_legendary_prime_game n p a b\n  result > 0 ∧ result < (10^9 + 7) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 540\n-/\n#guard_msgs in\n#eval solve_legendary_prime_game 3 [2, 3, 5] [2, 1, 2] [1, 1, 1]"}
{"id": "fvapps_000627", "vc-description": "/-\nGiven a string $s$.\nYou can perform the following operation on given string any number of time.\nDelete two successive elements of the string if they are same.\nAfter performing the above operation you have to return the least possible length of the string.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, a string $s$. \n\n-----Output:-----\nFor each testcase, output in a single line answer- minimum length of string possible after performing given operations.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq length of string \\leq 10^5$\n$s$ contains only lowercase letters.\n\n-----Sample Input:-----\n3\nabccd\nabbac\naaaa\n\n-----Sample Output:-----\n3\n1\n0\n\n-----EXPLANATION:-----\n- In first case, $\"abd\"$ will be final string.\n- in second case, $\"c\"$ will be final string\n-/\n\n-- Result is non-negative\n\n-- Result is at most input length\n\n-- Single character sequence reduces to at most 1\n\n-- Palindrome property", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_string_length (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem min_string_length_non_negative (s : String) (h : s.length > 0) :\n  min_string_length s ≥ 0 :=\nsorry\n\ntheorem min_string_length_upper_bound (s : String) (h : s.length > 0) :\n  min_string_length s ≤ s.length :=\nsorry\n\ntheorem min_string_length_same_char (s : String) (h : s.length > 0)\n  (h' : ∀ (i j : String.Pos), s.get i = s.get j) :\n  min_string_length s ≤ 1 :=\nsorry\n\ntheorem min_string_length_palindrome (s : String) (h : s.length > 0) :\n  min_string_length s = min_string_length (reverseString s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_string_length \"abccd\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_string_length \"abbac\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_string_length \"aaaa\""}
{"id": "fvapps_000629", "vc-description": "/-\nChef is going to organize a hill jumping competition and he is going to be one of the judges in it. In this competition there are N hills in a row, and the initial height of i-th hill is Ai. Participants are required to demonstrate their jumping skills by doing what the judges tell them.\nJudges will give each participant a card which has two numbers, i and k, which means that the participant should start at the i-th hill and jump k times, where one jump should be from the current hill to the nearest hill to the right which is strictly higher (in height) than the current one. If there is no such hill or its distance (i.e. difference between their indices)  is more than 100 then the participant should remain in his current hill.\nPlease help Chef by creating a program to use it during the competitions. It should read the initial heights of the hill and should support two kinds of operations:\nType 1: Given a two numbers: i and k, your program should output the index of the hill the participant is expected to finish if he starts from the i-th hill (as explained above).\nType 2: Given three numbers: L, R, X, the heights of all the hills between L and R, both end points inclusive, should be increased by X (if X is negative then their height is decreased).\n\n-----Input-----\n- First line contains two integers N and Q, denoting the number of hills and number of operations respectively.\n- Second line contains N space-separated integers A1, A2, ..., AN denoting the initial heights of the hills.\n- Each of the next Q lines describes an operation. If the first integer is equal to 1, it means that the operation is of Type 1, and it will be followed by two integers i and k. Otherwise the first number will be equal to 2, and it means that the operation is of Type 2, and so it will be followed by three integers L, R and X.\n\n-----Output-----\nFor each operation of Type 1, output the index of the hill in which the participant will finish.\n\n-----Constraints-----\n- 1 ≤ N, Q ≤ 100,000\n- 1 ≤ Ai ≤ 1,000,000\n- 1 ≤ L ≤ R ≤ N\n- -1,000,000 ≤ X ≤ 1,000,000\n- 1 ≤ i, k ≤ N\n\n-----Subtasks-----\n- Subtask 1 (20 points) : 1 ≤ N, Q ≤ 1,000 \n- Subtask 2 (80 points) : Original constraints\n\n-----Example-----\nInput:\n5 3\n1 2 3 4 5\n1 1 2\n2 3 4 -1\n1 1 2\n\nOutput:\n3\n4\n\n-----Explanation-----\nThe initial heights are (1, 2, 3, 4, 5). The first operation is of Type 1 and starts from Hill 1 and wants to jump twice. The first jump will be to Hill 2, and the second jump will be to Hill 3. Hence the output for this is 3.\nThe second operation changes the heights to (1, 2, 2, 3, 5).\nThe last operation starts from Hill 1. The first jump is to Hill 2. But the next jump will skip Hill 3 (because it's height is not strictly greater than the current hill's height), and will go to Hill 4. Hence the output is 4.\n-/", "vc-preamble": "def is_valid_operation (op : List Nat) : Bool :=\nmatch op with\n| h::t =>\n  if h = 1 then t.length = 2 && List.head! t ≥ 1 && List.get! t 1 ≥ 1\n  else if h = 2 then t.length = 3 && List.head! t ≥ 1 && List.get! t 1 ≥ List.head! t\n  else false\n| [] => false", "vc-helpers": "", "vc-definitions": "def hill_jumping_competition (n : Nat) (heights : List Nat) (operations : List (List Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem hill_jumping_result_length (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  (hill_jumping_competition n heights operations).length =\n    (List.filter (fun op => List.head! op = 1) operations).length :=\nsorry\n\ntheorem hill_jumping_bounds (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  List.all (hill_jumping_competition n heights operations) (fun x => x ≥ 1 ∧ x ≤ n) :=\nsorry\n\ntheorem hill_jumping_preserves_heights (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation →\n  let original := heights\n  let _ := hill_jumping_competition n heights operations\n  heights = original :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 5 [1, 2, 3, 4, 5] [[1, 1, 2], [2, 3, 4, -1], [1, 1, 2]]\n\n/--\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 3 [1, 3, 2] [[1, 1, 1], [2, 1, 2, 1], [1, 1, 1]]"}
{"id": "fvapps_000630", "vc-description": "/-\nMandarin chinese\n, Russian and Vietnamese as well.\nYou are given a grid with $n$ rows and $m$ columns. Each cell of this grid can either be empty or it contains one particle. It can never contain more than one particle. Let's denote the cell in the $i$-th row and $j$-th column by $(i, j)$, with the top left corner being $(0, 0)$. From a cell $(i, j)$, a particle could move in one of the following four directions:\n- to the left, i.e. to the cell $(i, j - 1)$\n- to the right, i.e. to the cell $(i, j + 1)$\n- up, i.e. to the cell $(i - 1, j)$\n- down, i.e. to the cell $(i + 1, j)$\nIt is not possible for a particle to move to a cell that already contains a particle or to a cell that does not exist (leave the grid).\nIt is possible to apply a force in each of these directions. When a force is applied in a given direction, all particles will simultaneously start moving in this direction as long as it is still possible for them to move.\nYou are given a sequence of forces. Each subsequent force is applied only after all particles have stopped moving. Determine which cells of the grid contain particles after all forces from this sequence are applied in the given order.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $n$ and $m$.\n- $n$ lines describing the initial grid follow. For each $i$ ($1 \\le i \\le n$), the $i$-th of these lines contains a binary string with length $m$ describing the $i$-th row of the grid. For each $j$ ($1 \\le j \\le m$), if the $j$-th character of this string is '1', then the cell $(i, j)$ contains a particle, and if it is '0', then the cell $(i, j)$ is empty.\n- The last line contains a single string $S$ describing the sequence of applied forces. Each character of this string corresponds to applying a force in some direction; forces applied in the directions left, right, up, down correspond to characters 'L', 'R', 'U', 'D' respectively.\n\n-----Output-----\nFor each test case, print $n$ lines each containing a binary string of length $m$, describing the resulting grid (after all the forces are applied) in the same format as the input grid.\n\n-----Constraints-----\n- $1 \\le T \\le 200$\n- $1 \\le n, m \\le 100$\n- $1 \\le |S| \\le 2 \\cdot 10^4$\n\n-----Subtasks-----\nSubtaks #1 (30 points):\n- $1 \\le T \\le 10$\n- $1 \\le n, m \\le 10$\n- $1 \\le |S| \\le 100$\nSubtask #2 (70 points): Original constraints\n\n-----Example Input-----\n3\n4 4\n1010\n0010\n1001\n0100\nLRDU\n4 3\n000\n010\n001\n101\nLRL\n3 2\n01\n10\n00\nD\n\n-----Example Output-----\n0011\n0011\n0001\n0001\n000\n100\n100\n110\n00\n00\n11\n\n-----Explanation-----\nExample case 1: The initial grid is:\n1010\n0010\n1001\n0100\n\nAfter applying the first force (in the direction \"L\", i.e. to the left), the grid is:\n1100\n1000\n1100\n1000\n\nAfter applying the second force (in the direction \"R\"), the grid is:\n0011\n0001\n0011\n0001\n\nAfter applying the third force (in the direction \"D\"), the grid is:\n0001\n0001\n0011\n0011\n\nAfter applying the fourth force (in the direction \"U\"), the final grid is:\n0011\n0011\n0001\n0001\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidGrid (grid : List (List Char)) : Bool :=\n  sorry\n\ndef countOnes (grid : List (List Char)) : Nat :=\n  sorry\n\ndef isGravityConsistent (grid : List (List Char)) (force : Char) : Bool :=\n  sorry\n\ndef solveParticleGrid (n m : Nat) (grid : List (List Char)) (forces : List Char) : List (List Char) :=\n  sorry", "vc-theorems": "theorem grid_dimensions {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  List.length result = n ∧\n  ∀ row ∈ result, List.length row = m :=\nsorry\n\ntheorem grid_valid_chars {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  ∀ row ∈ result, ∀ c ∈ row, c = '0' ∨ c = '1' :=\nsorry\n\ntheorem preserved_ones_count {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  countOnes grid = countOnes result :=\nsorry\n\ntheorem final_gravity_consistent {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid)\n  (h2 : forces ≠ []) :\n  let result := solveParticleGrid n m grid forces\n  let lastForce := List.getLast forces h2\n  isGravityConsistent result lastForce :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000634", "vc-description": "/-\nYou have a laser with P amount of energy in it. You are playing a game where you have to use the laser to destroy some crystals, each with some health of their own. Initially, you have 0 points.\nEach crystal has an associated health. The health of the ith crystal is given by health[i]. You can perform one of the two actions:\n- \nAt the cost of health[i] energy, you can destroy the ith crystal and gain 1 point. You can only perform this action if your laser has atleast health[i] energy in it.\n- \nAt the cost of 1 point, you can destroy the ith crystal and refuel the laser's energy by an amount equal to health[i]. This action can only be performed if you have atleast one point.\nNote: Each crystal can only be destroyed once.\nDetermine the maximum number of points you can obtain by destroying any number of crystals and performing either action as you wish.\n\n-----Input:-----\n- First line will contain n, number of crystals. \n- Second line will contain space separated integers, health of each crystal.\n- Third line will contain an integer P, initial energy of the laser.\n\n-----Output:-----\nPrint the largest number of points we can have after destroying any number of crystals.\n\n-----Constraints-----\n- health.length <= 1000\n- 0 <= health[i] < 10000\n- 0 <= P < 10000\n\n-----Subtasks-----\n- 40 points : 1 <= health.length <= 100\n- 60 points : health.length > 100\n\n-----Sample Input 1:-----\n1\n200\n100\n\n-----Sample Output 1:-----\n0\n\n-----Explanation:-----\nThe laser initially has only 100 energy. Since the only crystal requires 200 energy to destroy, we cannot perform any action here, and the game ends. The number of points is zero.\n\n-----Sample Input 2:-----\n2\n100 200\n150\n\n-----Sample Output 2:-----\n1\n\n-----Explanation:-----\nThe laser has 150 energy. We can consume 100 energy and destroy the first crystal and gain 1 point. The remaining energy is 50, which is not enough to destroy the other crystal. We end the game here as we have the maximum possible points attainable.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def game (n : Nat) (health : List Nat) (laser_energy : Nat) : Nat :=\n  sorry\n\ndef listMin (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem game_result_non_negative (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy ≥ 0 :=\nsorry\n\ntheorem game_result_bounded (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy ≤ n :=\nsorry\n\ntheorem game_empty_list (laser_energy : Nat) :\n  game 0 [] laser_energy = 0 :=\nsorry\n\ntheorem game_zero_energy (n : Nat) (health : List Nat) (h : health ≠ []) :\n  game n health 0 = 0 :=\nsorry\n\ntheorem game_energy_threshold (n : Nat) (health : List Nat) (laser_energy : Nat)\n  (h1 : health ≠ []) (h2 : laser_energy < listMin health) :\n  game n health laser_energy = 0 :=\nsorry\n\ntheorem game_sufficient_energy (n : Nat) (health : List Nat) (h : health ≠ []) :\n  game n health (2 * listSum health) = n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000643", "vc-description": "/-\nKabir wants to impress Tara by showing her his problem solving skills. He has decided to give the correct answer to the next question which will be asked by his Algorithms teacher.\nThe question asked is:\nFind the sum of alternate consecutive d$d$ odd numbers from the range L$L$ to R$R$ inclusive.\nif d$d$ is 3 and L$L$ is 10 and R$R$ is 34, then the odd numbers between 10 and 34 are 11,13,15,17,19,21,23,25,27,29,31,33$11,13,15,17,19,21,23,25,27,29,31,33$, and the d$d$ alternate odd numbers are 11,13,15,23,25,27$11,13,15,23,25,27$.\nYou are a friend of Kabir, help him solve the question.\nNote:$Note:$ Number of odd number between L$L$ and R$R$ (both inclusive) is a multiple of d$d$.\n\n-----Input:-----\n- First line will contain T$T$, number of test cases.  \n- First line of each test case contains one integer d$d$ . \n- Second line of each test case contains two space separated integer L$L$ and R$R$.\n\n-----Output:-----\nFor each test case, print the sum modulo 1000000007.\n\n-----Constraints:-----\n- 1≤T≤106$1 \\leq T \\leq 10^6$\n- 1≤d≤103$1 \\leq d \\leq 10^3$\n- 1≤L<R≤106$1 \\leq L < R \\leq 10^6$\n\n-----Sample Input:-----\n1\n3 \n\n10 33\n\n-----Sample Output:-----\n114\n\n-----EXPLANATION:-----\nSum of alternate odd numbers i.e, 11,13,15,23,25,27 is 114\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MODULO := 1000000007\n\ndef sum_odds_in_range (l r : Nat) : Nat :=\n  sorry\n\ndef solve_alternate_odd_sum (d l r : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_non_negative (d l r : Nat) :\n  solve_alternate_odd_sum d l r ≥ 0 :=\nsorry\n\ntheorem same_start_end_even (d l : Nat) :\n  l % 2 = 0 →\n  solve_alternate_odd_sum d l l = 0 :=\nsorry\n\ntheorem empty_range (d : Nat) :\n  ∀ l r : Nat, r < l →\n  solve_alternate_odd_sum d l r = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 114\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 10 33\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 2 1 7\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 1 9"}
{"id": "fvapps_000652", "vc-description": "/-\nChef is going to start playing Fantasy Football League (FFL) this season. In FFL, each team consists of exactly $15$ players: $2$ goalkeepers, $5$ defenders, $5$ midfielders and $3$ forwards. Chef has already bought $13$ players; he is only missing one defender and one forward.\nThere are $N$ available players (numbered $1$ through $N$). For each valid $i$, the $i$-th player is either a defender or a forward and has a price $P_i$. The sum of prices of all players in a team must not exceed $100$ dollars and the players Chef bought already cost him $S$ dollars.\nCan you help Chef determine if he can complete the team by buying one defender and one forward in such a way that he does not exceed the total price limit?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $S$.\n- The second line contains $N$ space-separated integers $P_1, P_2, \\ldots, P_N$.\n- The last line contains $N$ space-separated integers. For each valid $i$, the $i$-th of these integers is $0$ if the $i$-th player is a defender or $1$ if the $i$-th player is a forward.\n\n-----Output-----\nFor each test case, print a single line containing the string \"yes\" if it is possible to build a complete team or \"no\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 100$\n- $13 \\le S \\le 100$\n- $1 \\le P_i \\le 100$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n2\n4 90\n3 8 6 5\n0 1 1 0\n4 90\n5 7 6 5\n0 1 1 0\n\n-----Example Output-----\nyes\nno\n\n-----Explanation-----\nExample case 1: If Chef buys the $1$-st and $3$-rd player, the total price of his team is $90 + 9 = 99$, which is perfectly fine. There is no other valid way to pick two players.\nExample case 2: Chef cannot buy two players in such a way that all conditions are satisfied.\n-/", "vc-preamble": "def min_list (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| h::t => List.foldl min h t", "vc-helpers": "", "vc-definitions": "def can_complete_team (N : Nat) (S : Nat) (prices : List Nat) (positions : List Nat) : String :=\nsorry", "vc-theorems": "theorem empty_lists :\n  can_complete_team 0 0 [] [] = \"no\" :=\nsorry\n\ntheorem all_defenders_or_forwards_only (p₁ p₂ p₃ : Nat) :\n  can_complete_team 3 50 [p₁, p₂, p₃] [0, 0, 0] = \"no\" ∧\n  can_complete_team 3 50 [p₁, p₂, p₃] [1, 1, 1] = \"no\" :=\nsorry\n\ntheorem valid_input_result {N S : Nat} {prices positions : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : positions.length = N)\n  (h₅ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₆ : ∀ p ∈ positions, p = 0 ∨ p = 1)\n  (h₇ : positions.get! 0 = 0)\n  (h₈ : positions.get! 1 = 1) :\n  can_complete_team N S prices positions = \"yes\" ∨\n  can_complete_team N S prices positions = \"no\" :=\nsorry\n\ntheorem valid_input_cost {N S : Nat} {prices positions : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : positions.length = N)\n  (h₅ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₆ : ∀ p ∈ positions, p = 0 ∨ p = 1)\n  (h₇ : positions.get! 0 = 0)\n  (h₈ : positions.get! 1 = 1) :\n  let min_defender := min_list (List.filterMap (λ i => if positions.get! i = 0 then some (prices.get! i) else none) (List.range N))\n  let min_forward := min_list (List.filterMap (λ i => if positions.get! i = 1 then some (prices.get! i) else none) (List.range N))\n  100 - S ≥ min_defender + min_forward ↔ can_complete_team N S prices positions = \"yes\" :=\nsorry\n\ntheorem team_costs {N S : Nat} {prices : List Nat}\n  (h₁ : N ≥ 2)\n  (h₂ : S < 100)\n  (h₃ : prices.length = N)\n  (h₄ : ∀ p ∈ prices, p ≥ 1 ∧ p ≤ 100)\n  (h₅ : can_complete_team N S prices (List.map (λ i => i % 2) (List.range N)) = \"yes\") :\n  100 - S ≥ min_list (List.filterMap (λ i => if i % 2 = 0 then some (prices.get! i) else none) (List.range N)) +\n           min_list (List.filterMap (λ i => if i % 2 = 1 then some (prices.get! i) else none) (List.range N)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'yes'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [3, 8, 6, 5] [0, 1, 1, 0]\n\n/--\ninfo: 'no'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [5, 7, 6, 5] [0, 1, 1, 0]"}
{"id": "fvapps_000669", "vc-description": "/-\nYou are given a string s of length 8 consisting solely of '0's and '1's. Assume that the characters of the string are written in a circular fashion. You need to find the number of 0-1 or 1-0 transitions that one has to make while making a single traversal over the string. ie. start from any character and go circularly until you get back to the same character, and find the number of transitions that you made. The string is said to be said to be uniform if there are at most two such transitions. Otherwise, it is called non-uniform.\nGiven the string s, tell whether the string is uniform or not.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe only line of input contains the string s.\n\n-----Output-----\nFor each test case, output \"uniform\" if the given string is uniform and \"non-uniform\" otherwise.\n\n-----Constraints-----\n- 1 ≤ T ≤ 256\n- Length of s is 8\n\n-----Example-----\nInput\n4\n00000000\n10101010\n10000001\n10010011\n\nOutput\nuniform\nnon-uniform\nuniform\nnon-uniform\n\n-----Explanation-----\nThe number of transitions are 0, 8, 2 and 4 for the respective cases. So, the first and third one are uniform while the second and fourth one are non-uniform.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUniform (s : String) : String :=\n  sorry\n\ndef countTransitions (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry\n\ndef swapBits (s : String) : String :=\n  sorry", "vc-theorems": "theorem uniform_string_result_valid {s : String} (h : s.length > 0) :\n  isUniform s = \"uniform\" ∨ isUniform s = \"non-uniform\" :=\nsorry\n\ntheorem all_same_chars_uniform {s : String} (h₁ : s.length > 0)\n  (h₂ : ∀ (i j : String.Pos), s.get i = s.get j) :\n  isUniform s = \"uniform\" :=\nsorry\n\ntheorem transitions_gt_two_nonuniform {s : String} (h₁ : s.length > 0)\n  (h₂ : countTransitions s > 2) :\n  isUniform s = \"non-uniform\" :=\nsorry\n\ntheorem transitions_leq_two_uniform {s : String} (h₁ : s.length > 0)\n  (h₂ : countTransitions s ≤ 2) :\n  isUniform s = \"uniform\" :=\nsorry\n\ntheorem uniform_reverse_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (reverseString s) :=\nsorry\n\ntheorem uniform_swap_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (swapBits s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"00000000\"\n\n/--\ninfo: 'non-uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10101010\"\n\n/--\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10000001\""}
{"id": "fvapps_000674", "vc-description": "/-\nWrite a program to find the factorial value of any number entered by the user.\n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then T lines follow, each line contains an integer N. \n\n-----Output-----\nFor each test case, display the factorial of the given number N in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 0 ≤ N ≤ 20\n\n-----Example-----\nInput\n3 \n3 \n4\n5\n\nOutput\n\n6\n24\n120\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def factorial (n : Nat) : Nat :=\n  sorry\n\ndef calculate_factorials (nums : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem empty_list_factorial :\n  calculate_factorials [] = [] :=\nsorry\n\ntheorem factorial_zero :\n  calculate_factorials [0] = [1] :=\nsorry\n\ntheorem factorial_one :\n  calculate_factorials [1] = [1] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000678", "vc-description": "/-\nIn Programmers Army Land, people have started preparation as sports day is scheduled next week.\nYou are given a task to form 1 team of $k$ consecutive players, from a list of sports player whose powers are given to you.\nYou want your team to win this championship, so you have to chose your $k$ team players optimally i.e. there must not be any other $k$ consecutive team players who have their total power greater than your team members total power.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$. $T$ denoting the number of test cases. The description of $T$ test cases is as follows.\n- The next line of the input contains 2 space separated integers $N$ and $K$. $N$ denotes the total number of players and $K$ denotes the number of players allowed in a team.\n- The next line of the input contains $N$ space-separated integers $A1, A2, A3...An$ where $ith$ number denotes power of $ith$ player.\nNote: power of players can also be negative\n\n-----Output:-----\n- For each test-case print the total power that your selected team have(each test case output must be printed on a new line).\n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N,K \\leq 10^5$\n- $-10^7 \\leq A1, A2, A3...An \\leq 10^7$\n\n-----Sample Input:-----\n1\n5 3\n1 2 3 4 5\n\n-----Sample Output:-----\n12\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_consecutive_power (arr : List Int) (k : Nat) : Int :=\nsorry\n\ndef sum_sublist (l : List Int) (i : Nat) (len : Nat) : Int :=\nsorry\n\ndef list_sum (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem find_max_consecutive_power_is_k_consecutive\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length) :\n  ∃ i, i + k ≤ arr.length ∧\n    find_max_consecutive_power arr k = sum_sublist arr i k :=\nsorry\n\ntheorem find_max_consecutive_power_is_maximum\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length) :\n  ∀ i, i + k ≤ arr.length →\n    sum_sublist arr i k ≤ find_max_consecutive_power arr k :=\nsorry\n\ntheorem find_max_consecutive_power_equals_sum_when_k_equals_length\n  {arr : List Int} :\n  find_max_consecutive_power arr arr.length = list_sum arr :=\nsorry\n\ntheorem find_max_consecutive_power_nonnegative\n  {arr : List Int} {k : Nat} (h : k ≤ arr.length)\n  (h_nonneg : ∀ x ∈ arr, 0 ≤ x) :\n  0 ≤ find_max_consecutive_power arr k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, 2, 3, 4, 5] 3\n\n/--\ninfo: -3\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [-1, -2, -3, -4, -5] 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, -2, 3, -4, 5] 3"}
{"id": "fvapps_000679", "vc-description": "/-\nFor years you have been working hard in Santa's factory to manufacture gifts for kids in substandard work environments with no pay. You have finally managed to escape the factory and now you seek revenge. You are planning a heist with the Grinch to steal all the gifts which are locked in a safe. Since you have worked in the factory for so many years, you know how to crack the safe.\nThe passcode for the safe is an integer. This passcode keeps changing everyday, but you know a way to crack it. You will be given two numbers  A  and  B .\nPasscode is the number of  X  such that 0 ≤ X < B and\ngcd(A,B) = gcd(A+X,B).\nNote : gcd(A,B) is the greatest common divisor of A & B.\n\n-----Input-----\nThe first line contains the single integer T (1 ≤ T ≤ 50) — the number of test cases.\nNext T lines contain test cases per line. Each line contains two integers  A  &  B \n( 1 ≤ A < B ≤ 1010 )\n\n-----Output-----\nPrint T integers, one for each Test case. For each test case print the appropriate passcode for that day.\n\n-----Sample Input-----\n3\n4 9\n5 10\n42 9999999967\n\n-----Output-----\n6\n1\n9999999966\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def phi (n : Nat) : Nat :=\n  sorry\n\ndef solve_passcode (a m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem phi_positive (n : Nat) (h : n > 0) : phi n > 0 :=\nsorry\n\ntheorem phi_upper_bound (n : Nat) : phi n ≤ n :=\nsorry\n\ntheorem phi_one : phi 1 = 1 :=\nsorry\n\ntheorem solve_passcode_positive (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m > 0 :=\nsorry\n\ntheorem solve_passcode_upper_bound (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m ≤ m :=\nsorry\n\ntheorem solve_passcode_one (a : Nat) (h : a > 0) :\n  solve_passcode a 1 = 1 :=\nsorry\n\ntheorem solve_passcode_coprime (a m : Nat) (h₁ : a > 0) (h₂ : m > 0)\n  (h₃ : Nat.gcd a m = 1) :\n  solve_passcode a m = phi m :=\nsorry\n\ntheorem solve_passcode_gcd (a m : Nat) (h₁ : a > 0) (h₂ : m > 0) :\n  solve_passcode a m = phi (m / Nat.gcd a m) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_passcode 4 9\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_passcode 5 10\n\n/--\ninfo: 9999999966\n-/\n#guard_msgs in\n#eval solve_passcode 42 9999999967"}
{"id": "fvapps_000681", "vc-description": "/-\nNow-a-days, Manish is becoming  famous for bank robbery in the country because of his cleverness, he never robs own his own.He has four workers A , B, C, and D , all working under him.All of the four take some amount for that. There are total N banks in the country and Manish wants to rob all the banks with minimum\n\namount spent on workers.Only one worker is allowed to rob the ith bank but following a condition that if one worker robs ith bank, then he can't rob (i+1) th bank.\n\nSo ,Manish wants you to calculate minimum amount that he has to spend on all workers to rob all N banks.\n\n-----Input Format-----\nFirst line consists number of test cases T.For each test case,\n\nfirst line consists an integer N, number of banks in the country\n\nand the next N line consists 4 integers amount taken by A,B,C and D respectively to rob ith bank.\n\n-----Output format-----\nFor each test case ,output an integer, minimum amount paid  by Manish in separate line .\n\n-----Constraint-----\n- 1<=T<=1000\n- 1<=N<=100000\n- 1<=amount<=100000\n\n-----Subtasks-----\nSubtask-1 (10 points)\n- 1<=T<=5\n- 1<=N<=10\n- 1<=amount<=10\nSubtask-1 (30 points)\n- 1<=T<=100\n- 1<=N<=1000\n- 1<=amount<=1000\nSubtask-1 (60 points)\nOriginal Constraints \nSample Input\n1\n3\n4 7 2 9\n5 6 4 7\n2 6 4 3\n\nSample Output\n10\n-/\n\n-- arbitrary large value", "vc-preamble": "def listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => List.foldl min h t\n\ndef findMinValidPath (costs : List (List Nat)) : Nat :=\n  let range4 := [0, 1, 2, 3]\n  let maxVal := 10000\n  let bank1 := costs.head!\n  let bank2 := costs.get! 1\n  listMin (List.map (fun w1 =>\n    listMin (List.map (fun w2 =>\n      if w1 ≠ w2 then bank1[w1]! + bank2[w2]! else maxVal\n    ) range4)\n  ) range4)", "vc-helpers": "", "vc-definitions": "def minRobberyCost (n : Nat) (costs : List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem single_bank_result (costs : List (List Nat))\n  (h1 : costs.length = 1)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 1 costs = listMin (costs.head!) := by\nsorry\n\ntheorem two_banks_positive (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs > 0 := by\nsorry\n\ntheorem two_banks_lower_bound (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs ≥ listMin (costs.head!) + listMin (costs.get! 1) := by\nsorry\n\ntheorem two_banks_min_path (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : ∀ lst ∈ costs, lst.length = 4)\n  (h3 : ∀ lst ∈ costs, ∀ x ∈ lst, x > 0) :\n  minRobberyCost 2 costs = findMinValidPath costs := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 3 [[4, 7, 2, 9], [5, 6, 4, 7], [2, 6, 4, 3]]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_robbery_cost 2 [[1, 2, 3, 4], [5, 6, 7, 8]]\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 1 [[10, 20, 30, 40]]"}
{"id": "fvapps_000682", "vc-description": "/-\nYou are given a sequence of N$N$ powers of an integer k$k$; let's denote the i$i$-th of these powers by kAi$k^{A_i}$. You should partition this sequence into two non-empty contiguous subsequences; each element of the original sequence should appear in exactly one of these subsequences. In addition, the product of (the sum of elements of the left subsequence) and (the sum of elements of the right subsequence) should be maximum possible.\nFind the smallest position at which you should split this sequence in such a way that this product is maximized.\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and k$k$.\n- The second line contains N$N$ space-separated integers A1,A2,…,AN$A_1, A_2, \\dots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the size of the left subsequence. If there is more than one possible answer, print the smallest possible one.\n\n-----Constraints-----\n- 1≤T≤10$1 \\le T \\le 10$\n- 2≤N≤105$2 \\le N \\le 10^5$\n- 2≤k≤109$2 \\le k \\le 10^9$\n- 0≤Ai≤105$0 \\le A_i \\le 10^5$ for each valid i$i$\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- 2≤N≤1,000$2 \\le N \\le 1,000$\n- 0≤Ai≤1,000$0 \\le A_i \\le 1,000$ for each valid i$i$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n1\n5 2\n1 1 3 3 5\n\n-----Example Output-----\n4\n\n-----Explanation-----\nExample case 1: The actual sequence of powers is [21,21,23,23,25]=[2,2,8,8,32]$[2^1, 2^1, 2^3, 2^3, 2^5] = [2, 2, 8, 8, 32]$. The maximum product is 20⋅32=640$20 \\cdot 32 = 640$. In the optimal solution, the sequence is partitioned into [2,2,8,8]$[2, 2, 8, 8]$ and [32]$[32]$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_optimal_split (N k : Nat) (powers : List Nat) : Nat :=\nsorry\n\ndef calc_product (values : List Nat) (split : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_optimal_split_properties1 {N k : Nat} {powers : List Nat} (h1: N ≥ 2) (h2: k ≥ 1)\n    (h3: powers.length = N) (h4: ∀ x ∈ powers, x ≤ 10) :\n    let result := find_optimal_split N k powers\n    1 ≤ result ∧ result ≤ N-1 :=\nsorry\n\ntheorem find_optimal_split_properties2 {N k : Nat} {powers : List Nat} (h1: N ≥ 2) (h2: k ≥ 1)\n    (h3: powers.length = N) (h4: ∀ x ∈ powers, x ≤ 10) :\n    let values := powers.map (fun p => k^p)\n    let result := find_optimal_split N k powers\n    let optimal_product := calc_product values result\n    ∀ i, 1 ≤ i → i < N → calc_product values i ≤ optimal_product :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_optimal_split 5 2 [1, 1, 3, 3, 5]"}
{"id": "fvapps_000685", "vc-description": "/-\nEugene has to do his homework. But today, he is feeling very lazy and wants to you do his homework. His homework has the following given maths problem.\nYou are given three integers: A, N, M. You write the number A appended to itself N times in a row. Let's call the resulting big number X. For example, if A = 120, N = 3, then X will be 120120120. Find out the value of X modulo M.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follow.\nEach test case is described in one line containing three integers: A, N and M as described in the problem statement.\n\n-----Output-----\nFor each test case, output a single line containing an integer denoting the value of X modulo M.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 0 ≤ A ≤ 109\n- 1 ≤ N ≤ 1012\n- 2 ≤ M ≤ 109\n\n-----Subtasks-----\nSubtask #1 (15 points):\n- 0 ≤ A ≤ 100\n- 1 ≤ N ≤ 105\n\nSubtask #2 (25 points):\n- 1 ≤ N ≤ 109\n\nSubtask #3 (60 points):\n- Original constraints\n\n-----Example-----\nInput:\n2\n12 2 17\n523 3 11\n\nOutput:\n5\n6\n\n-----Explanation-----\nExample 1: As A = 12, N = 2, X = 1212, 1212 modulo 17 = 5\nExample 2. As A = 523, N = 3, X = 523523523, 523523523 modulo 11 = 6\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveEugeneHomework (a n m : Nat) : Nat :=\n  sorry\n\ndef repeatedNum (a n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_eugene_homework_range (a n m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^9)\n  (hn : 1 ≤ n ∧ n ≤ 100)\n  (hm : 2 ≤ m ∧ m ≤ 10^9) :\n  let result := solveEugeneHomework a n m\n  0 ≤ result ∧ result < m :=\nsorry\n\ntheorem solve_eugene_homework_correct (a n m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^9)\n  (hn : 1 ≤ n ∧ n ≤ 100)\n  (hm : 2 ≤ m ∧ m ≤ 10^9) :\n  solveEugeneHomework a n m = repeatedNum a n % m :=\nsorry\n\ntheorem modulo_one_is_zero (a n : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^6)\n  (hn : 1 ≤ n ∧ n ≤ 100) :\n  solveEugeneHomework a n 1 = 0 :=\nsorry\n\ntheorem single_repeat (a m : Nat)\n  (ha : 1 ≤ a ∧ a ≤ 10^6)\n  (hm : 2 ≤ m ∧ m ≤ 10^6) :\n  solveEugeneHomework a 1 m = a % m :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_eugene_homework 12 2 17\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_eugene_homework 523 3 11\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_eugene_homework 1000 3 7"}
{"id": "fvapps_000687", "vc-description": "/-\nChef has $N$ small boxes arranged on a line from $1$ to $N$. For each valid $i$, the weight of the $i$-th box is $W_i$. Chef wants to bring them to his home, which is at the position $0$. He can hold any number of boxes at the same time; however, the total weight of the boxes he's holding must not exceed K at any time, and he can only pick the ith box if all the boxes between Chef's home and the ith box have been either moved or picked up in this trip.\nTherefore, Chef will pick up boxes and carry them home in one or more round trips. Find the smallest number of round trips he needs or determine that he cannot bring all boxes home.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $W_1, W_2, \\ldots, W_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the smallest number of round trips or $-1$ if it is impossible for Chef to bring all boxes home.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N, K \\le 10^3$\n- $1 \\le W_i \\le 10^3$ for each valid $i$\n\n-----Example Input-----\n4\n1 1 \n2\n2 4\n1 1\n3 6\n3 4 2\n3 6\n3 4 3\n\n-----Example Output-----\n-1\n1\n2\n3\n\n-----Explanation-----\nExample case 1: Since the weight of the box higher than $K$, Chef can not carry that box home in any number of the round trip.\nExample case 2: Since the sum of weights of both boxes is less than $K$, Chef can carry them home in one round trip.\nExample case 3: In the first round trip, Chef can only pick up the box at position $1$. In the second round trip, he can pick up both remaining boxes at positions $2$ and $3$.\nExample case 4: Chef can only carry one box at a time, so three round trips are required.\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef list_maximum : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (list_maximum xs)", "vc-helpers": "", "vc-definitions": "def min_trips (n : Nat) (k : Nat) (weights : List Nat) : Int :=\nsorry", "vc-theorems": "theorem min_trips_basic_properties\n  (weights : List Nat) (k : Nat) (n : Nat) (h1 : n = weights.length) :\n  let result := min_trips n k weights\n  ((∃ w ∈ weights, w > k) → result = -1) ∧\n  ((∀ w ∈ weights, w ≤ k) →\n    result > 0 ∧\n    result ≤ n ∧\n    result * k ≥ list_sum weights) :=\nsorry\n\ntheorem min_trips_monotonic\n  (weights : List Nat) (n : Nat) (h1 : n = weights.length) :\n  let k₁ := list_maximum weights\n  let k₂ := k₁ + 1\n  min_trips n k₁ weights ≥ min_trips n k₂ weights :=\nsorry\n\ntheorem min_trips_zero_weights\n  (k : Nat) (weights : List Nat) (n : Nat) (h1 : n = weights.length)\n  (h2 : ∀ w ∈ weights, w = 0) :\n  let result := min_trips n k weights\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_trips 1 1 [2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_trips 2 4 [1, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_trips 3 6 [3, 4, 2]"}
{"id": "fvapps_000690", "vc-description": "/-\n$Gogi$, $Tapu$ and $Sonu$ are the elite members of $Tapu$ $Sena$. $Gogi$ is always stoned and asks absurd questions, But this time he asked a question which seems to be very serious and interesting. $Tapu$ wants to solve this question to impress $Sonu$. He  gave an array of length N to $Tapu$, $Tapu$ can perform the following operations exactly once:\n- Remove any subarray from the given array given the resulting array formed after the removal is non-empty.    \n- Reverse the whole array.\nRemember you can’t shuffle the elements of the array.\nTapu needs to find out the maximum possible GCD of all the numbers in the array after applying the given operations exactly once. Tapu is very weak at programming, he wants you to solve this problem so that he can impress $Sonu$.\n\n-----Input:-----\n- The first line contains $T$, the number of test cases.\n- For each test case\n-FIrst line contains $N$.\n- Last line contains $N$ numbers of the array. \n\n-----Output:-----\nA single integer in a new line, maximum possible GCD. \n\n-----Constraints-----\n- $1 \\leq T \\leq 10^2$\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq a[i] \\leq 10^9$\n\nSummation of N for all testcases is less than $10^6$ \n\n-----Sample Input 1:-----\n1\n1\n2\n\n-----Sample Output 1:-----\n2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef find_max_gcd (arr : List Nat) : Nat :=\n  sorry\n\ndef gcd_of_list (numbers : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_returns_valid : ∀ (n : Nat) (arr : List Nat),\n  arr ≠ [] → solve n arr = arr.head! ∨ solve n arr = arr.getLast! :=\nsorry\n\ntheorem solve_optimality : ∀ (n : Nat) (arr : List Nat),\n  arr ≠ [] →\n  (arr.length = 1 → solve n arr = arr.head!) ∧\n  (arr.length > 1 → solve n arr ≥ arr.head! ∧ solve n arr ≥ arr.getLast!) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 1 [2]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 3 [6, 9, 3]\n\n/--\ninfo: 36\n-/\n#guard_msgs in\n#eval solve 4 [12, 18, 24, 36]"}
{"id": "fvapps_000693", "vc-description": "/-\nChef got into a fight with the evil Dr Doof. Dr Doof has decided to destroy all even numbers from the universe using his Evil-Destroy-inator. Chef has $N$ integers with him. To stop Doof, Chef has to find an odd number which is an integer multiple of all $N$ numbers that he has with him. Find if it is possible for Chef to prevent Dr Doof from destroying the even numbers.\nFormally, given $N$ positive integers, find if there exists an odd number which is an integer multiple of all the given $N$ numbers. If yes, print \"YES\", otherwise \"NO\". You can print any letter in any case.\n\n-----Input-----\n- First line contains $T$, number of testcases. Each testcase consists of $2$ lines.\n- The first line of each test case consists of a positive integer $N$, denoting the number of positive integers Chef has.\n- The second line of each test case contains $N$ space separated integers $A_i$ each denoting an integer that Chef has with him.\n\n-----Output-----\nFor every test case, if there exists such an odd number, print \"YES\" on a separate line, otherwise \"NO\". The judge is case insensitive. That means, your code can print any letter in any case ( \"Yes\", \"yes\" or \"YES\" are all accepted).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N \\leq 10^3$\n- $1 \\leq A_i \\leq 10^3$\n\n-----Sample Input-----\n2\n5\n1 2 5 4 3\n1\n7\n\n-----Sample Output-----\nNO\nYES\n\n-----Explanation-----\nFor test $1$: There exists no odd number.\nFor test $2$: The possible odd numbers can be $7$, $21$, $49$, $315$, …\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def isEven (x : Int) : Bool :=\n  x % 2 == 0", "vc-helpers": "", "vc-definitions": "def can_find_odd_multiple (n : Nat) (arr : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem all_even_no_odd_multiple {n : Nat} {arr : List Int} :\n  (∀ x ∈ arr, isEven x = true) →\n  can_find_odd_multiple n arr = false :=\nsorry\n\ntheorem single_number_case (x : Int) :\n  can_find_odd_multiple 1 [x] = (!isEven x) :=\nsorry\n\ntheorem gcd_property {n : Nat} {arr : List Int} :\n  n = arr.length →\n  can_find_odd_multiple n arr = true ∨ can_find_odd_multiple n arr = false :=\nsorry\n\ntheorem parity_preservation {n : Nat} {arr : List Int} :\n  can_find_odd_multiple n arr = can_find_odd_multiple n arr :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000694", "vc-description": "/-\nChef has a sequence of $N$ integers, $A_1, A_2, ... , A_N$. He likes this sequence if it contains a  subsequence of $M$ integers, $B_1, B_2, ... , B_M$ within it.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\nYou will be given a sequence of $N$ integers, $A_1, A_2, ..., A_N$ followed by another sequence of $M$ integers, $B_1, B_2, ..., B_M$. Given these, you have to tell whether Chef likes the sequence of $N$ integers($A_1, A_2, ..., A_N$) or not. \nFormally, output \"Yes\" if\n$\\exists idx_1, idx_2, ..., idx_M | 1 \\le idx_1 < idx_2 < ... < idx_M \\le N$ and $A_{idx_i} = B_i \\forall i, 1 \\le i \\le M$\nOtherwise output \"No\". Note that the quotes are for clarity.\n\n-----Input-----\nThe first line contains a single integer, $T$.\n$T$ test cases follow where each test case contains four lines:\n- The first line of a test case contains a single integer $N$\n- The second line of the test case contains $N$ space separated integers, $A_1, A_2, ..., A_N$\n- The third line of the test case contains a single integer $M$.\n- The fourth line contains $M$ space separated integers, $B_1, B_2, ..., B_M$\nSymbols have usual meanings as described in the statement.\n\n-----Output-----\nFor each test case, output a single line containing the output. Output is \"Yes\" if Chef likes the sequence $A$. Output is \"No\" if Chef dislikes the sequence $A$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 10^3$\n- $1 \\le M \\le 10^3$\n- $1 \\le A_i, B_i \\le 10^9$\n\n-----Sample Input-----\n3\n6\n1 2 3 4 5 6\n3\n2 3 4\n6\n22 5 6 33 1 4\n2\n4 15\n4\n1 3 4 2\n2\n1 2\n\n-----Sample Output-----\nYes\nNo\nYes\n\n-----Explanation:-----\nIn sample test case $1$, the sequence $1,2,3,4,5,6$ contains the subsequence $2, 3, 4$. The subsequence is present at indices $1, 2, 3$ of the original sequence.\nHence, $1,2,3,4,5,6$ is a sequence which Chef likes it. Therefore, we output \"Yes\".\nIn sample test case $2$, the subsequence $4, 15$ is not present in sequence $22, 5, 6, 33, 1, 4$. Hence, we output \"No\".\nIn sample test case $3$, the sequence $1, 3, 4, 2$ contains the subsequence $1, 2$. The subsequence is present at indices $0, 3$. Therefore, we output \"Yes\".\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.index {α} [BEq α] (xs : List α) (x : α) : Nat :=\n  sorry\n\ndef check_subsequence (s1 : String) (s2 : String) : String :=\n  sorry", "vc-theorems": "theorem sequence_is_subsequence_of_itself (seq : List Nat) (h : seq.length > 0) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  check_subsequence (toString seq) (toString seq) = \"Yes\" :=\nsorry\n\ntheorem invalid_element_not_subsequence (seq : List Nat) (invalid : Nat) (h1 : seq.length > 0) :\n  (∀ x ∈ seq, x > 0 ∧ x ≤ 100) →\n  invalid > 100 ∧ invalid ≤ 200 →\n  check_subsequence (toString seq) (toString invalid) = \"No\" :=\nsorry\n\ntheorem first_element_is_subsequence (seq : List Nat) (h : seq.length > 1) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  check_subsequence (toString seq) (toString (seq.get! 0)) = \"Yes\" :=\nsorry\n\ntheorem consecutive_elements_subsequence (seq : List Nat) (start : Nat)\n  (h1 : seq.length ≥ 3) (h2 : start < seq.length - 1) :\n  ∀ x ∈ seq, x > 0 ∧ x ≤ 100 →\n  let subseq := (seq.drop start).take 2\n  ∀ i < subseq.length - 1,\n    seq.index (subseq[i]!) < seq.index (subseq[i+1]!) →\n  check_subsequence (toString seq) (toString subseq) = \"Yes\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 2 3 4 5 6\" \"2 3 4\"\n\n/--\ninfo: 'No'\n-/\n#guard_msgs in\n#eval check_subsequence \"22 5 6 33 1 4\" \"4 15\"\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 3 4 2\" \"1 2\""}
{"id": "fvapps_000696", "vc-description": "/-\nRecently Rocky had participated in coding competition and he is sharing one of the problem with you which he was unable to solve. Help Rocky in solving the problem.\nSuppose the alphabets are arranged in a row starting with index 0$0$ from AtoZ$A to Z$.\nIf in a coded language  A=27$A=27$ and AND=65$AND=65$.\nHelp Rocky to find a suitable formula for finding all the value for given test cases?\n(All alphabets are in Upper case only).\n\n-----Input:-----\nFirst line of the input contains  string s$s$.\n\n-----Output:-----\nOutput the possible integer values of the given string s$s$ according to the question . \n\n-----Constraints-----\n- 1≤s≤100$1 \\leq s \\leq 100$\n\n-----Sample Input:-----\nA\n\nAND   \n\n-----Sample Output:-----\n27\n\n65\n-/", "vc-preamble": "def string_reverse (s : String) : String :=\n  ⟨s.data.reverse⟩", "vc-helpers": "", "vc-definitions": "def calculate_string_weight (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem length_weight_relationship {s : String}\n  (h : ∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  s.length ≤ calculate_string_weight s ∧ calculate_string_weight s ≤ 27 * s.length :=\nsorry\n\ntheorem invariant_under_reversal {s : String}\n  (h : ∀ c ∈ s.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  calculate_string_weight s = calculate_string_weight (string_reverse s) :=\nsorry\n\ntheorem weight_additive {s1 s2 : String}\n  (h1 : ∀ c ∈ s1.data, 'A' ≤ c ∧ c ≤ 'Z')\n  (h2 : ∀ c ∈ s2.data, 'A' ≤ c ∧ c ≤ 'Z') :\n  calculate_string_weight (s1 ++ s2) = calculate_string_weight s1 + calculate_string_weight s2 :=\nsorry\n\ntheorem a_highest_weight :\n  calculate_string_weight \"A\" > calculate_string_weight \"Z\" :=\nsorry\n\ntheorem a_weight_27 :\n  calculate_string_weight \"A\" = 27 :=\nsorry\n\ntheorem z_weight_2 :\n  calculate_string_weight \"Z\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 27\n-/\n#guard_msgs in\n#eval calculate_string_weight \"A\"\n\n/--\ninfo: 65\n-/\n#guard_msgs in\n#eval calculate_string_weight \"AND\""}
{"id": "fvapps_000697", "vc-description": "/-\nChef has created a special dividing machine that supports the below given operations on an array of positive integers.\nThere are two operations that Chef implemented on the machine.\nType 0 Operation\n\nUpdate(L,R):\n\tfor i = L to R:\n\t\ta[i] = a[i] / LeastPrimeDivisor(a[i])\n\nType 1 Operation\n\nGet(L,R):\n\tresult = 1\n\tfor i = L to R:\n\t\tresult = max(result, LeastPrimeDivisor(a[i]))\n\treturn result;\n\nThe function LeastPrimeDivisor(x) finds the smallest prime divisor of a number. If the number does not have any prime divisors, then it returns 1.\nChef has provided you an array of size N, on which you have to apply M operations using the special machine. Each operation will be one of the above given two types. Your task is to implement the special dividing machine operations designed by Chef. Chef finds this task quite easy using his machine, do you too?\n\n-----Input-----\n\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \nThe first line of each test case contains two space-separated integers N, M, denoting the size of array A and the number of queries correspondingly.\n\nThe second line of each test case contains N space-separated integers A1, A2, ..., AN denoting the initial array for dividing machine.\nEach of following M lines contain three space-separated integers  type, L, R - the type of operation (0 - Update operation, 1 - Get operation), and the arguments of function, respectively\n\n-----Output-----\nFor each test case, output answer of each query of type 1 (Get query) separated by space. Each test case from the same file should start from the new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ Ai ≤ 106\n- 1 ≤ L ≤ R ≤ N\n- 0 ≤ type ≤ 1\n-  Sum of M over all test cases in a single test file does not exceed 106\n\n-----Subtasks-----\nSubtask #1: (10 points) \n- 1 ≤ N, M ≤ 103\n\nSubtask #2: (25 points)\n- 1 ≤ N, M ≤ 105\n-  Ai is a prime number. \n\nSubtask #3: (65 points)\n- 1 ≤ N, M ≤ 105\n\n-----Example-----\nInput:\n2\n6 7\n2 5 8 10 3 44\n1 2 6\n0 2 3\n1 2 6\n0 4 6\n1 1 6\n0 1 6\n1 4 6\n2 2\n1 3\n0 2 2\n1 1 2\nOutput:\n5 3 5 11\n1\n\n-----Explanation-----\nExample case 1.The states of array A after each Update-operation:\nA: = [2 1 4 10 3 44]\nA: = [2 1 4 5 1 22]\nA: = [1 1 2 1 1 11]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def leastPrimeDivisors (n : Nat) : List Nat :=\n  sorry\n\ndef dividing_machine (n m : Nat) (arr : List Nat) (ops : List (List Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem least_prime_divisors_are_prime (n : Nat) :\n  (∀ p ∈ leastPrimeDivisors n, p > 1) ∧\n  (∀ p ∈ leastPrimeDivisors n, ∀ i : Nat, 2 ≤ i ∧ i * i ≤ p → p % i ≠ 0) :=\nsorry\n\ntheorem dividing_machine_valid_result {n m : Nat} {arr : List Nat} {ops : List (List Nat)}\n  (h_ops : ∀ op ∈ ops, op.length = 3 ∧\n          (op.get! 0 < 2 ∧ 1 ≤ op.get! 1 ∧ op.get! 1 ≤ op.get! 2 ∧ op.get! 2 ≤ n)) :\n  (dividing_machine n m arr ops).length = (ops.filter (fun op => op.get! 0 = 1)).length ∧\n  ∀ x ∈ dividing_machine n m arr ops, x ≥ 1 :=\nsorry\n\ntheorem single_number_valid {x : Nat} (h : x ≥ 1) :\n  let result := dividing_machine 1 1 [x] [[1,1,1]]\n  result.length = 1 ∧ result.get! 0 ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [5, 3, 5, 11]\n-/\n#guard_msgs in\n#eval dividing_machine 6 7 [2, 5, 8, 10, 3, 44] [[1, 2, 6], [0, 2, 3], [1, 2, 6], [0, 4, 6], [1, 1, 6], [0, 1, 6], [1, 4, 6]]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval dividing_machine 2 2 [1, 3] [[0, 2, 2], [1, 1, 2]]"}
{"id": "fvapps_000702", "vc-description": "/-\nDo you know that The Chef has a special interest in palindromes? Yes he does! Almost all of the dishes in his restaurant is named by a palindrome strings. The problem is that a name of a dish should not be too long, so The Chef has only limited choices when naming a new dish.\n\nFor the given positive integer N, your task is to calculate the number of palindrome strings of length not exceeding N, that contain only lowercase letters of English alphabet (letters from 'a' to 'z', inclusive). Recall that a palindrome is a string that reads the same left to right as right to left (as in \"radar\").\n\nFor example:\n\n- For N = 1, we have 26 different palindromes of length not exceeding N:\n\"a\", \"b\", ..., \"z\".\n- For N = 2 we have 52 different palindromes of length not exceeding N:\n\"a\", \"b\", ..., \"z\",\n\"aa\", \"bb\", ..., \"zz\".\n- For N = 3 we have 728 different palindromes of length not exceeding N:\n\"a\", \"b\", ..., \"z\",\n\"aa\", \"bb\", ..., \"zz\",\n\"aaa\", \"aba\", ..., \"aza\",\n\"bab\", \"bbb\", ..., \"bzb\",\n...,\n\"zaz\", \"zbz\", ..., \"zzz\".\n\nSince the answer can be quite large you should output it modulo 1000000007 (109 + 7). Yes, we know, most of you already hate this modulo, but there is nothing we can do with it :)\n\n-----Input-----\n\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. The only line of each test case contains a single integer N.\n\n-----Output-----\n\nFor each test case, output a single line containing the answer for the corresponding test case.\n\n-----Constrains-----\n\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 109\n\n-----Example-----\nInput:\n5\n1\n2\n3\n4\n100\n\nOutput:\n26\n52\n728\n1404\n508533804\n\n-----Explanation-----\n\nThe first three examples are explained in the problem statement above.\n-/\n\n/- Helper function for calculating palindrome count -/\n\n/- Calculated palindromes are non-negative integers less than modulus -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Binary exponentiation results are within valid modulo range -/\n\n/- Binary exponentiation of anything to power 0 equals 1 -/\n\n/- Binary exponentiation of x to power 1 equals x mod p -/\n\n/- Known values for small inputs -/\n\n/- Results differ between consecutive odd and even inputs -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin_expo (x n p : Nat) : Nat :=\n  sorry\n\ndef calculate_palindromes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem palindrome_count_bounds (n : Nat) (h : 0 < n) :\n  let result := calculate_palindromes n\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem bin_expo_bounds (x n p : Nat) :\n  let result := bin_expo x n p\n  0 ≤ result ∧ result < p :=\nsorry\n\ntheorem bin_expo_zero (x p : Nat) :\n  bin_expo x 0 p = 1 :=\nsorry\n\ntheorem bin_expo_one (x p : Nat) :\n  bin_expo x 1 p = x % p :=\nsorry\n\ntheorem small_n_cases :\n  calculate_palindromes 1 = 26 ∧\n  calculate_palindromes 2 = 52 ∧\n  calculate_palindromes 3 = 728 :=\nsorry\n\ntheorem palindrome_parity (n : Nat) (h : 0 < n) :\n  n % 2 = 1 → calculate_palindromes n ≠ calculate_palindromes (n + 1) :=\nsorry", "vc-postamble": "/--\ninfo: 26\n-/\n#guard_msgs in\n#eval calculate_palindromes 1\n\n/--\ninfo: 52\n-/\n#guard_msgs in\n#eval calculate_palindromes 2\n\n/--\ninfo: 728\n-/\n#guard_msgs in\n#eval calculate_palindromes 3"}
{"id": "fvapps_000705", "vc-description": "/-\nPetya is preparing a problem for a local contest in his school. The problem is to find a longest increasing subsequence in a given permutation. A permutation of size n$n$ is a sequence of n$n$ numbers a1,…,an$a_1, \\ldots, a_n$ such that every number from 1$1$ to n$n$ occurs in the sequence exactly once. An increasing subsequence of length k$k$ of the sequence a1,…,an$a_1, \\ldots, a_n$ is a sequence of indices i1,…,ik$i_1, \\ldots, i_k$ such that 1≤i1<…<ik≤n$1 \\leq i_1 < \\ldots < i_k \\leq n$ and ai1<…<aik$a_{i_1} < \\ldots < a_{i_k}$. A longest increasing subsequence is an increasing subsequences with the largest length. Note that in general there may be several longest increasing subsequences.\nPetya had some tests prepared, but then lost the input part for some of them. He now has a test for a certain value of n$n$, and a sequence i1,…,ik$i_1, \\ldots, i_k$ that is supposed to be a longest increasing subsequence. Petya now has to reconstruct a permutation of size n$n$ with this sequence being an answer. Petya doesn't want to take any risks, so he additionally wants this sequence to be the only longest increasing subsequence, that is, all other increasing subsequences have to have strictly smaller length. Help Petya determine if this is possible, and if so, construct any such permutation.\n\n-----Input:-----\nThe first line contains an integer T$T$, denoting number of test cases.\nThe first line of every test case contains two integers n$n$ and k−$k-$  the size of the permutation and the length of the longest increasing subsequence (1≤k≤n≤105$1 \\leq k \\leq n \\leq 10^5$).\nThe second line contains k$k$ integers i1,…,ik−$i_1, \\ldots, i_k-$ the longest increasing subsequence (1≤i1<…<ik≤n$1 \\leq i_1 < \\ldots < i_k \\leq n$).\n\n-----Output:-----\nIf there is no permutation with the sequence i1,…,ik$i_1, \\ldots, i_k$ being the only longest increasing subsequence, print NO . Otherwise, print YES on the first line, followed by n$n$ numbers describing any suitable permutation on the second line.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤k≤n≤105$1 \\leq k \\leq n \\leq 10^5$ \n- 1≤i1<…<ik≤n$1 \\leq i_1 < \\ldots < i_k \\leq n$ \n\n-----Sample Input:-----\n2\n3 2\n1 2\n2 1\n1\n\n-----Sample Output:-----\nYES\n2 3 1\nNO\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_permutation (n : Nat) (k : Nat) (indices : List Nat) : (String × List Nat) :=\n  sorry\n\ndef is_valid_permutation (perm : List Nat) : Bool :=\n  sorry\n\ndef check_indices_descending (perm indices : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem basic_case_1 :\n  solve_permutation 1 1 [1] = (\"YES\", [1]) :=\nsorry\n\ntheorem basic_case_2 :\n  solve_permutation 2 1 [1] = (\"NO\", []) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000707", "vc-description": "/-\nToday, Chef decided to cook some delicious meals from the ingredients in his kitchen. There are $N$ ingredients, represented by strings $S_1, S_2, \\ldots, S_N$. Chef took all the ingredients, put them into a cauldron and mixed them up.\nIn the cauldron, the letters of the strings representing the ingredients completely mixed, so each letter appears in the cauldron as many times as it appeared in all the strings in total; now, any number of times, Chef can take one letter out of the cauldron (if this letter appears in the cauldron multiple times, it can be taken out that many times) and use it in a meal. A complete meal is the string \"codechef\". Help Chef find the maximum number of complete meals he can make!\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains a single string $S_i$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the maximum number of complete meals Chef can create.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 100$\n- $|S_1| + |S_2| + \\ldots + |S_N| \\le 1,000$\n- each string contains only lowercase English letters\n\n-----Example Input-----\n3\n6\ncplusplus\noscar\ndeck\nfee\nhat\nnear\n5\ncode\nhacker\nchef\nchaby\ndumbofe\n5\ncodechef\nchefcode\nfehcedoc\ncceeohfd\ncodechef\n\n-----Example Output-----\n1\n2\n5\n\n-----Explanation-----\nExample case 1: After mixing, the cauldron contains the letter 'c' 3 times, the letter 'e' 4 times, and each of the letters 'o', 'd', 'h' and 'f' once. Clearly, this is only enough for one \"codechef\" meal.\nExample case 2: After mixing, the cauldron contains the letter 'c' 4 times, 'o' 2 times, 'd' 2 times, 'e' 4 times, 'h' 3 times and 'f' 2 times, which is enough to make 2 meals.\n-/", "vc-preamble": "def count_char (c : Char) (s : List Char) : Nat :=\n  (s.filter (fun x => x = c)).length\n\ndef sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def max_meals (ingredients : List (List Char)) : Nat :=\n  sorry", "vc-theorems": "theorem max_meals_non_negative (ingredients : List (List Char)) :\n  max_meals ingredients ≥ 0 := by\nsorry\n\ntheorem max_meals_bounded_by_c (ingredients : List (List Char)) :\n  max_meals ingredients ≤ (sum_list (ingredients.map (count_char 'c'))) / 2 := by\nsorry\n\ntheorem max_meals_bounded_by_o (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'o')) := by\nsorry\n\ntheorem max_meals_bounded_by_d (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'd')) := by\nsorry\n\ntheorem max_meals_bounded_by_e (ingredients : List (List Char)) :\n  max_meals ingredients ≤ (sum_list (ingredients.map (count_char 'e'))) / 2 := by\nsorry\n\ntheorem max_meals_bounded_by_h (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'h')) := by\nsorry\n\ntheorem max_meals_bounded_by_f (ingredients : List (List Char)) :\n  max_meals ingredients ≤ sum_list (ingredients.map (count_char 'f')) := by\nsorry\n\ntheorem max_meals_empty_list :\n  max_meals [] = 0 := by\nsorry\n\ntheorem max_meals_doubles (ingredients : List (List Char)) :\n  ingredients ≠ [] →\n  max_meals (ingredients.map (fun s => s ++ s)) ≥ max_meals ingredients := by\nsorry\n\ntheorem max_meals_with_invalid_chars (ingredients : List (List Char)) :\n  max_meals ingredients ≥ 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_meals [\"cplusplus\", \"oscar\", \"deck\", \"fee\", \"hat\", \"near\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_meals [\"code\", \"hacker\", \"chef\", \"chaby\", \"dumbofe\"]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval max_meals [\"codechef\", \"chefcode\", \"fehcedoc\", \"cceeohfd\", \"codechef\"]"}
{"id": "fvapps_000710", "vc-description": "/-\nYou are given a matrix of integers $A$ with $N$ rows (numbered $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Each element of this matrix is either $0$ or $1$.\nA move consists of the following steps:\n- Choose two different rows $r_1$ and $r_2$ or two different columns $c_1$ and $c_2$.\n- Apply the bitwise OR operation with the second row/column on the first row/column. Formally, if you chose two rows, this means you should change $A_{r_1, k}$ to $A_{r_1, k} \\lor A_{r_2, k}$ for each $1 \\le k \\le M$; if you chose two columns, then you should change $A_{k, c_1}$ to $A_{k, c_1} \\lor A_{k, c_2}$ for each $1 \\le k \\le N$.\nFor each element of the matrix, compute the minimum number of moves required to make it equal to $1$ or determine that it is impossible. Note that these answers are independent, i.e. we are starting with the initial matrix for each of them.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains $M$ integers $A_{i, 1}, A_{i, 2}, \\dots, A_{i, M}$ NOT separated by spaces.\n\n-----Output-----\nFor each test case, print $N$ lines. For each valid $i$, the $i$-th of these lines should contain $M$ space-separated integers; for each valid $j$, the $j$-th of these integers should be the minimum number of moves required to make $A_{i, j}$ equal to $1$, or $-1$ if it is impossible.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N, M \\le 1,000$\n- $A_{i, j} \\in \\{0, 1\\}$ for each valid $i, j$\n- the sum of $N \\cdot M$ for all test cases does not exceed $1,000,000$\n\n-----Example Input-----\n1\n3 3\n010\n000\n001\n\n-----Example Output-----\n1 0 1\n2 1 1\n1 1 0\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Matrix := List (List Int)", "vc-helpers": "", "vc-definitions": "def StrMatrix := List String\n\ndef solve_matrix_moves (n m : Nat) (matrix : StrMatrix) : Matrix :=\n  sorry\n\ndef replicate_zeros (n : Nat) (m : Nat) : List String :=\n  sorry\n\ndef create_matrix_with_one (n m : Nat) : StrMatrix :=\n  sorry", "vc-theorems": "theorem matrix_dimensions {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  result.length = n ∧\n  ∀ (row : List Int), List.elem row result → row.length = m :=\nsorry\n\ntheorem matrix_all_zeros {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  ∀ (row : List Int), List.elem row result →\n  ∀ (x : Int), List.elem x row → x = -1 :=\nsorry\n\ntheorem single_one {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let i := n / 2\n  let j := m / 2\n  let matrix := create_matrix_with_one n m\n  let result := solve_matrix_moves n m matrix\n  (List.get! result i |>.get! j) = 0 ∧\n  (∀ k, k < m → k ≠ j → (List.get! result i |>.get! k) = 1) ∧\n  (∀ k, k < n → k ≠ i → (List.get! result k |>.get! j) = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000713", "vc-description": "/-\nAlice and Bob are walking on an infinite straight street. Initially, both are at the position $X=0$ and they start walking in the direction of increasing $X$. After $N$ seconds, they stop. Let's denote Alice's speed and Bob's speed during the $i$-th of these seconds by $A_i$ and $B_i$ respectively.\nSometimes, Alice and Bob walk together, i.e. with the same speed side by side. Let's define the weird distance as the total distance they walk this way. Find this weird distance.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n- The third line contains $N$ space-separated integers $B_1, B_2, \\ldots, B_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the total weird distance. It can be proved that this distance is an integer.\n\n-----Constraints-----\n- $1 \\le T \\le 20$\n- $1 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^5$ for each valid $i$\n- $1 \\le B_i \\le 10^5$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (30 points): $1 \\le N \\le 1,000$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n3\n4\n1 3 3 4\n1 2 4 4\n2\n2 3\n3 2\n2\n3 3\n3 3\n\n-----Example Output-----\n5\n0\n6\n\n-----Explanation-----\nExample case 1:\n- Alice and Bob walk side by side during the first second, from $X=0$ to $X=1$.\n- Then, Alice starts walking faster than Bob, so they do not walk side by side during second $2$. At the end of second $2$, Alice is at $X=4$, while Bob is at $X=3$.\n- During the next second, they again do not walk side by side, but Bob walks faster, so they both end up at $X=7$.\n- During the last second, they both walk side by side and the distance they walk is $4$.\n- Alice and Bob walk side by side during the $1$-st and $4$-th second and the total weird distance they travel is $1+4=5$.\nExample case 2:\n- First, Alice walks with speed $2$ and Bob walks with speed $3$, so they do not walk side by side. Alice ends up at $X=2$, while Bob ends up at $X=3$ at the end of the $1$-st second.\n- Then, Alice walks with speed $3$ and Bob walks with speed $2$, so they do not walk side by side either.\n- Although Alice and Bob both end up at $X=5$ at the end of the $2$-nd second, the weird distance is $0$.\nExample case 3: We can see that Alice and Bob always walk together, so the weird distance is $3+3=6$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.padRight (default : α) (n : Nat) (xs : List α) : List α :=\n  sorry\n\ndef find_weird_distance (n : Nat) (alice_speeds : List Nat) (bob_speeds : List Nat) : Nat :=\n  sorry\n\ndef running_sum_equal (alice_speeds bob_speeds : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem identical_speeds_sum_to_length\n  (n : Nat)\n  (h1 : n > 0)\n  (h2 : n ≤ 100) :\n  find_weird_distance n (List.replicate n 1) (List.replicate n 1) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_weird_distance 4 [1, 3, 3, 4] [1, 2, 4, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [2, 3] [3, 2]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [3, 3] [3, 3]"}
{"id": "fvapps_000714", "vc-description": "/-\nGiven a string consisting of only lowercase English alphabets, your task is to find the smallest palindromic substring.\nIn case there are multiple palindromic substrings of the same length present, print the lexicographically smallest substring. \nFormally, a substring is a contiguous sequence of characters within a string. So in a string \"abcdef\", \"abc\" is a substring whereas \"adf\" is not a substring.\nA palindrome is a word, phrase, or sequence that reads the same backwards as forwards, e.g. madam or mom.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains of two lines of input, two integers.\n- First, we have a single integer $N$ which signifies the length of the substring.\n- Next, we have a string of length $N$ that only has lowercase English alphabets.\n\n-----Output:-----\nFor each testcase, output in a single line the shortest palindromic substring.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $2 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n2\n2\nzy\n1\ncd\n\n-----Sample Output:-----\ny\nc\n\n-----EXPLANATION:-----\nThere are only two possibilities. \"z\" and \"y\". Since both of them have the same length. We print the lexicographically smaller substring which is y.\n-/", "vc-preamble": "def lexMin (s: String) : String :=\n  s.data.foldl (fun acc c => if c < acc.get! 0 then String.mk [c] else acc) (String.mk [s.get! 0])", "vc-helpers": "", "vc-definitions": "def find_smallest_palindrome (len: Nat) (s: String) : String :=\nsorry", "vc-theorems": "theorem find_smallest_palindrome_result_length\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  (find_smallest_palindrome len s).length = 1 :=\nsorry\n\ntheorem find_smallest_palindrome_in_original\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  s.contains ((find_smallest_palindrome len s).get! 0) = true :=\nsorry\n\ntheorem find_smallest_palindrome_lexmin\n  (len: Nat) (s: String) (h₁: len > 0) (h₂: s.length > 0) :\n  find_smallest_palindrome len s = lexMin s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'y'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 2 \"zy\"\n\n/--\ninfo: 'c'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 1 \"cd\"\n\n/--\ninfo: 'm'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 3 \"mom\""}
{"id": "fvapps_000718", "vc-description": "/-\nRodriguez is a happy and content farmer. He has got a square field of side length $x$. Miguel, his son has himself grown into a man and his father wants to gift him something out of which he can make a living. So he gift's his son a square piece of land cut out from a corner of his field of side length $ y (y < x) $ leaving him with a L-shaped land.\nBut in Spanish tradition, it is considered inauspicious to own something which is prime in number. This worries Rodriguez as he doesn't want his left out area to be a prime number leading to bad luck. Find whether the spilt will be in terms with the tradition leaving Rodriguez happy.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains two integers $x, y$. \n\n-----Output:-----\nPrint YES if Rodriguez will be happy. Otherwise print NO.\n\n-----Constraints-----\n- $1 \\leq T \\leq 5$\n- $1 \\leq y < x \\leq 100000000000$\n\n-----Sample Input:-----\n2\n7 5\n6 5\n\n-----Sample Output:-----\nYES\nNO\n\n-----EXPLANATION:-----\nIn case 1 :\nLeft out area is 24, which is not prime.\nIn case 2:\nLeft out area is 11, which is prime.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef check_land_split (x y : Nat) : String :=\n  sorry", "vc-theorems": "theorem is_prime_properties (n : Nat) (h : n ≤ 1000) :\n  (n < 2 → is_prime n = false) ∧\n  (is_prime n = true → n ≥ 2) ∧\n  (is_prime n = true → ∀ i : Nat, 2 ≤ i → i ≤ 100 → ¬(n % i = 0)) :=\nsorry\n\ntheorem check_land_split_properties (x y : Nat) (h₁ : x ≤ 100) (h₂ : y ≤ 100) (h₃ : y ≤ x) :\n  (check_land_split x y = \"YES\" ∨ check_land_split x y = \"NO\") ∧\n  (check_land_split x y = \"NO\" ↔ is_prime (x*x - y*y)) :=\nsorry\n\ntheorem check_land_split_equal_sides (x : Nat) (h : x ≤ 100) :\n  check_land_split x x = \"YES\" :=\nsorry\n\ntheorem check_land_split_zero_inner (x : Nat) (h : x ≤ 100) :\n  check_land_split x 0 = \"NO\" ↔ is_prime (x*x) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 7 5\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval check_land_split 6 5\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 10 8"}
{"id": "fvapps_000719", "vc-description": "/-\nCalculate the power of an army of numbers from 1 to $N$, both included.\n\n-----Input:-----\n- First line will contain a single integer $N$.\n\n-----Output:-----\nFor each testcase, output in a single line containing the answer.\n\n-----Constraints-----\n- $1 \\leq N \\leq 5000$\n\n-----Sample Input:-----\n24\n\n-----Sample Output:-----\n5\n-/\n\n/- The army power is always at least 1 for positive inputs -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The army power is monotonic increasing -/\n\n/- Known base cases for the army power function -/\n\n/- The army power is bounded above by n -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_army_power (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem army_power_always_positive (n : Nat) (h : n ≥ 1) :\n  calc_army_power n ≥ 1 :=\nsorry\n\ntheorem army_power_monotonic (n : Nat) (h : n > 1) :\n  calc_army_power n ≥ calc_army_power (n-1) :=\nsorry\n\ntheorem army_power_base_cases :\n  (calc_army_power 1 = 1) ∧ (calc_army_power 4 = 2) :=\nsorry\n\ntheorem army_power_bounded (n : Nat) (h : n ≥ 1) :\n  calc_army_power n ≤ n :=\nsorry", "vc-postamble": "/--\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_army_power 24\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_army_power 1\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_army_power 4"}
{"id": "fvapps_000722", "vc-description": "/-\nGiven a positive integer K > 2, with prime\nfactorization:\n\nK = p1^a1 * p2^a2 ... * pn^an\n\nCompute the following:\n\nS = a1*p1 + a2*p2 ... + an*pn.\n\n-----Input-----\nA list of <100 integers, one on each line,\nall less than $2*10^{18}$.\n\n-----Output-----\nFor each integer compute the super factor\nsum and output it on a single line.\n\n-----Example-----\nInput:\n6\n7\nOutput:\n5\n7\n-/", "vc-preamble": "def list_product : List Nat → Nat\n  | [] => 1\n  | x :: xs => x * list_product xs\n\ndef list_sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def compute_super_factor_sum (n : Nat) : Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem compute_super_factor_sum_positive (n : Nat) (h : n ≥ 2) :\n  compute_super_factor_sum n > 0 :=\nsorry\n\ntheorem compute_super_factor_sum_primes (n : Nat) (h1 : n ≥ 2) (h2 : is_prime n = true) :\n  compute_super_factor_sum n = n :=\nsorry\n\ntheorem compute_super_factor_sum_multiplicative (a b : Nat) (h1 : a ≥ 1) (h2 : b ≥ 1) :\n  compute_super_factor_sum (a * b) ≥ min (compute_super_factor_sum a) (compute_super_factor_sum b) :=\nsorry\n\ntheorem compute_super_factor_sum_product_relation (factors : List Nat)\n  (h1 : ∀ x ∈ factors, x ≥ 2) (h2 : factors.length > 0) :\n  compute_super_factor_sum (list_product factors) ≥\n  list_sum (List.map compute_super_factor_sum (List.filter (fun x => x > 1) factors)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 6\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 7\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 12"}
{"id": "fvapps_000726", "vc-description": "/-\nYou want to build a temple for snakes. The temple will be built on a mountain range, which can be thought of as n blocks, where height of i-th block is given by hi. The temple will be made on a consecutive section of the blocks and its height should start from 1 and increase by exactly 1 each time till some height and then decrease by exactly 1 each time to height 1, \ni.e. a consecutive section of 1, 2, 3, .. x-1, x, x-1, x-2, .., 1 can correspond to a temple. Also, heights of all the blocks other than of the temple should have zero height, so that the temple is visible to people who view it from the left side or right side.\nYou want to construct a temple. For that, you can reduce the heights of some of the blocks. In a single operation, you can reduce the height of a block by 1 unit. Find out minimum number of operations required to build a temple.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains an integer n.\nThe next line contains n integers, where the i-th integer denotes hi\n\n-----Output-----\nFor each test case, output a new line with an integer corresponding to the answer of that testcase.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ n ≤ 105\n- 1 ≤ hi ≤ 109\n\n-----Example-----\nInput\n3\n3\n1 2 1\n4\n1 1 2 1\n5\n1 2 6 2 1\n\nOutput\n0\n1\n3\n\n-----Explanation-----\nExample 1. The entire mountain range is already a temple. So, there is no need to make any operation.\nExample 2. If you reduce the height of the first block to 0. You get 0 1 2 1. The blocks 1, 2, 1 form a temple. So, the answer is 1.\nExample 3. One possible temple can be 1 2 3 2 1. It requires 3 operations to build. This is the minimum amount you have to spend in order to build a temple.\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t", "vc-helpers": "", "vc-definitions": "def min_temple_operations (n : Nat) (heights : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_temple_operations_nonnegative (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  min_temple_operations n heights ≥ 0 :=\nsorry\n\ntheorem min_temple_operations_preserves_input (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  heights = heights :=\nsorry\n\ntheorem min_temple_operations_bounded_by_sum (n : Nat) (heights : List Nat) :\n  heights.length = n →\n  min_temple_operations n heights ≤ list_sum heights :=\nsorry\n\ntheorem min_temple_operations_perfect (heights : List Nat) :\n  heights = [1,2,3,2,1] →\n  min_temple_operations 5 heights = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_temple_operations 3 [1, 2, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_temple_operations 4 [1, 1, 2, 1]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_temple_operations 5 [1, 2, 6, 2, 1]"}
{"id": "fvapps_000727", "vc-description": "/-\nGiven a complete binary tree with the height of H, we index the nodes respectively top-down and left-right from 1. The i-th node stores a positive integer Vi. Define Pi as follows: Pi=Vi if the i-th node is a leaf, otherwise Pi=max(Vi*PL, Vi*PR), where L and R are the indices of the left and right children of i, respectively. Your task is to caculate the value of P1.\n\n-----Input-----\nThere are several test cases (fifteen at most), each formed as follows:\n\n- The first line contains a positive integer H (H ≤ 15).\n- The second line contains 2H-1 positive integers (each having a value of 109 at most), the i-th integer shows the value of Vi.\nThe input is ended with H = 0.\n\n-----Output-----\nFor each test case, output on a line an integer which is the respective value of P1 found, by modulo of 1,000,000,007.\n\n-----Example-----\nInput:\n2\n1 2 3\n3\n3 1 5 2 6 4 7\n0\n\nOutput:\n3\n105\n\nExplanation:\n\nThe second test case is constructed as follows:\n\n3\n/ \\\n/   \\\n1     5\n/ \\   / \\\n2   6 4   7\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minArraySize (height : Nat) : Nat := (2 ^ height) - 1\n\ndef calcMaxProduct (height : Nat) (values : List Nat) : Nat :=\nsorry\n\ndef treeProduct (values : List Nat) (height : Nat) : Nat :=\nsorry", "vc-theorems": "theorem calc_max_product_zero_height (values : List Nat) :\n  calcMaxProduct 0 values = 0 := by\n  sorry\n\ntheorem calc_max_product_bounds {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length ≥ minArraySize height) :\n  0 ≤ calcMaxProduct height values ∧ calcMaxProduct height values < 1000000007 := by\n  sorry\n\ntheorem tree_product_monotonic {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length ≥ minArraySize height)\n  (h3 : ∀ x ∈ values, x > 0) :\n  let scaledValues := values.map (· * 2)\n  treeProduct scaledValues height > treeProduct values height := by\n  sorry\n\ntheorem min_array_size_valid (height : Nat) :\n  minArraySize height = 2^height - 1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_product 2 #[1, 2, 3]\n\n/--\ninfo: 105\n-/\n#guard_msgs in\n#eval calc_max_product 3 #[3, 1, 5, 2, 6, 4, 7]"}
{"id": "fvapps_000729", "vc-description": "/-\n\tChef has a cubic die with 6 faces kept on an infinite plane. Each face has a distinct integer in the range [1,6] written on it, but the exact arrangement of the numbers on the faces of the die is unknown to Chef. Curiosity gets the better of Chef and he wants to find out o(1), o(2), ..., o(6), where o(i) is the number written opposite to the number i.\n\n\tChef performs the following N-1 steps to learn the exact arrangement of the numbers on the die. In the i-th step, Chef pushes the die in some direction (there are 4 possible directions), and the die rolls 90o in this direction. The picture below demonstrates a die and the result that it produced after rolling in each of the 4 directions respectively. For this die, we have o(1)=4, o(2)=5, o(3)=6, o(4)=1, o(5)=2, o(6)=3.\n\n\tChef records N numbers A1, A2, ..., AN, where Ai is the number written on the top of the die before the i-th step. However, the information on the direction in which he pushes the die each time are lost. Can you help him determine the arrangement of 1-6? You need to output o(1), o(2), ..., o(6). If there are multiple solutions, output any one of them.\n\n-----\n\tInput-----\n- The first line of input contains a single integer T, the number of test cases.\n- Each test case consists of two lines.\n- The first line contains an integer N, and the second line contains N space-separated integers A1, A2, ..., AN.\n\n-----\n\tOutput-----\n\n\tFor each test case, output one line. If a possible solution exists, then output 6 space-separated integers o(1), o(2), ..., o(6); otherwise, output -1.\n\n-----\n\tConstraints-----\n\n- 1 ≤ T, N ≤ 500\n- 1 ≤ Ai ≤ 6\n\n\tSubtask #1 (17 points):\n\n- N ≤ 2\n\n\tSubtask #2 (83 points):\n\n- original constraints\n\n-----\n\tExample-----\nInput:\n4\n9\n1 3 4 6 1 3 4 6 1\n10\n1 2 1 3 1 4 1 5 1 6\n6\n1 2 3 4 5 6\n4\n1 3 3 1\n\nOutput:\n2 1 6 5 4 3\n-1\n4 5 6 1 2 3\n-1\n\n-----\n\tExplanation-----\nExample case 1: See below.\n\nExample case 2: You can prove that there's no solution.\nExample case 3: The solution is not unique. 3 5 1 6 2 4 is another valid solution.\n-/\n\n/- If solveDie returns [0], it indicates no valid configuration exists.\n    Otherwise, returns a valid die configuration that works with the input sequence. -/\n\n/- If there are adjacent equal numbers in the input sequence,\n    no valid die configuration exists -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveDie (n : Nat) (nums : List Nat) : List Nat :=\n  sorry\n\ndef isValidConfig (config : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem die_configuration_theorem (n : Nat) (nums : List Nat) :\n  let result := solveDie n nums\n  result = [0] ∨ isValidConfig result ∧\n    ∀ i : Nat, i + 1 < n →\n      nums[i]! ≠ nums[i+1]! ∧\n      nums[i+1]! ≠ result[nums[i]! - 1]! :=\nsorry\n\ntheorem adjacent_same_numbers_theorem (n : Nat) (nums : List Nat) :\n  (∃ i : Nat, i + 1 < n ∧ nums[i]! = nums[i+1]!) →\n  solveDie n nums = [0] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000732", "vc-description": "/-\nThere are n villages in a Chefland. Some of the villages have electricity facilities, other doesn't. You can consider the villages arranged in line in the order 1 to n from left to right. i-th of village can be considered at xi coordinates.\n\nChef decided that electricity should be provided to all the villages. So, he decides to buy some amount of electric wires to connect the villeges without electricity to some villages with electricity. As Chef does not want to spend too much amount of money on wires, can you find out minimum amount of length of wire Chef should buy.\n\n-----Input-----\nFirst line of the input contains an integer T denoting the number of test cases. T test cases follow.\nFirst line of each test case contains an integer n denoting number of villages in Chefland.\nSecond line will contain a string of length n containing '0' or '1's only. If i-th character of the string is '1', then it denotes that i-th village has electricity.\nNext line contains n space separated integers denoting the x coordinates of the villages in the order from village 1 to n\n\n-----Output-----\nFor each test case, output a single line containing a integer corresponding to the minimum length of wire Chef needs to buy.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- It is guaranteed that there will be at least one village which will have electricity.\n- 1 ≤ x1 <  x2 <  ... < xn ≤ 109\n\n-----Subtasks-----\nSubtask #1 : 30 points\n- 1 ≤ N ≤ 1000\n\nSubtask #2 : 70 points\n- 1 ≤ N ≤ 105\n\n-----Example-----\nInput\n2\n2\n01\n1 2\n3\n100\n1 5 6\nOutput:\n1\n5\n\n-----Explanation-----\nIn the first example, first village does not have electricity. If we put a wire between village 1 and 2 of length 1, then both the villages will have electricity.\n\nIn the second example,\nWe can a draw a wire from first village to third village, passing through second village. Its total length will be 5. Now all the villages will have electricity. This is the minimum length of wire you will require.\n-/\n\n/- Basic properties -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Sorting property -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_min_wire_length (n : Nat) (has_electricity : String) (coordinates : List Nat) : Nat :=\n  sorry\n\ndef isSorted (l : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem min_wire_length_non_negative (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : ∃ i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates ≥ 0 :=\nsorry\n\ntheorem min_wire_length_bounded (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : ∃ i < n, has_electricity.data.get! i = '1')\n  (h5 : coordinates.length ≥ 1) :\n  solve_min_wire_length n has_electricity coordinates ≤ (coordinates.getLast! - coordinates.head!) :=\nsorry\n\ntheorem min_wire_length_all_electrified (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : ∀ i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates = 0 :=\nsorry\n\ntheorem min_wire_length_requires_sorted (n : Nat) (has_electricity : String) (coordinates unsorted : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : unsorted.length = n)\n  (h5 : coordinates ≠ unsorted)\n  (h6 : coordinates ≠ []) :\n  solve_min_wire_length n has_electricity coordinates ≠\n  solve_min_wire_length n has_electricity unsorted :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_wire_length 2 \"01\" [1, 2]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_wire_length 3 \"100\" [1, 5, 6]"}
{"id": "fvapps_000735", "vc-description": "/-\nChef has a number N, Cheffina challenges the chef to check the divisibility of all the permutation of N by 2. If any of the permutations is divisible by 2 then print 1 else print 0.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n19\n385\n\n-----Sample Output:-----\n0\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\n  sorry\n\ndef check_divisible_permutations (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem check_divisible_permutations_valid_output (n : Nat) :\n  n > 0 → check_divisible_permutations n = 0 ∨ check_divisible_permutations n = 1 :=\nsorry\n\ntheorem check_divisible_permutations_single_digits :\n  check_divisible_permutations 1 = 0 ∧ check_divisible_permutations 2 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval check_divisible_permutations 19\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 385\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 246"}
{"id": "fvapps_000736", "vc-description": "/-\nAkshay is interested in mathematics, one day he came across a problem of modulus operator.He has  a list of M integers say arr[M] and has to find all integers K such that :\n- K > 1\n- arr[1]%K = arr[2]%K = arr[3]%K = … = arr[M]%K where '%' is a modulus operator.\nHelp Akshay to find all such K's.\n\n-----Input:-----\n- First line of input contains an integer M. Then M lines follow each containing one integer of the list. Input data is such that at least one integer K will always exist.\n\n-----Output:-----\n- Output all possible integers K separated by space in increasing order.\n\n-----Constraints-----\n- 2<= M <=100\n- 1< value of each integer <109\n- All integers will be distinct\n\n-----Sample Input:-----\n3\n38\n6\n34\n\n-----Sample Output:-----\n2 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.minimum (l : List Nat) : Nat :=\n  sorry\n\ndef List.sort (l: List Nat) : List Nat :=\n  sorry\n\ndef find_common_divisors (nums: List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem find_common_divisors_contains_prime_factors {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 1 ∧ n ≤ 100) :\n  ∀ i: Nat, 2 ≤ i ∧ i ≤ List.minimum nums →\n  (∀ n ∈ nums, n % i = 0) →\n  (∀ j, 2 ≤ j ∧ j < i → i % j ≠ 0) →\n  i ∈ find_common_divisors nums :=\nsorry\n\ntheorem find_common_divisors_sorted {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  find_common_divisors nums = List.sort (find_common_divisors nums) :=\nsorry\n\ntheorem find_common_divisors_greater_than_one {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  ∀ x ∈ find_common_divisors nums, x > 1 :=\nsorry\n\ntheorem find_common_divisors_bounded_by_min {nums: List Nat}\n  (h1: nums.length ≥ 2)\n  (h2: ∀ n ∈ nums, n ≥ 2 ∧ n ≤ 1000) :\n  ∀ x ∈ find_common_divisors nums, x ≤ List.minimum nums :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval find_common_divisors [38, 6, 34]\n\n/--\ninfo: [2, 3, 6]\n-/\n#guard_msgs in\n#eval find_common_divisors [12, 18, 24]\n\n/--\ninfo: [5]\n-/\n#guard_msgs in\n#eval find_common_divisors [10, 15, 20]"}
{"id": "fvapps_000737", "vc-description": "/-\nFarmer Feb has three fields with potatoes planted in them. He harvested x potatoes from the first field, y potatoes from the second field and is yet to harvest potatoes from the third field. Feb is very superstitious and believes that if the sum of potatoes he harvests from the three fields is a prime number (http://en.wikipedia.org/wiki/Prime_number), he'll make a huge profit. Please help him by calculating for him the minimum number of potatoes that if harvested from the third field will make the sum of potatoes prime. At least one potato should be harvested from the third field.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. Each of the next T lines contain 2 integers separated by single space: x and y.\n\n-----Output-----\nFor each test case, output a single line containing the answer.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ x ≤ 1000\n- 1 ≤ y ≤ 1000\n\n-----Example-----\nInput:\n2\n1 3\n4 3\n\nOutput:\n1\n4\n\n-----Explanation-----\n\nIn example case 1: the farmer harvested a potato from the first field and 3 potatoes from the second field. The sum is 4. If he is able to harvest a potato from the third field, that will make the sum 5, which is prime. Hence the answer is 1(he needs one more potato to make the sum of harvested potatoes prime.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef find_min_potatoes (x y : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_min_potatoes_returns_prime_sum\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x ≤ 1000) (h4 : y ≤ 1000) :\n  let result := find_min_potatoes x y\n  result ≥ 0 ∧ isPrime (x + y + result) = true := by\n  sorry\n\ntheorem find_min_potatoes_with_equal_inputs\n  (x : Nat) (h1 : x > 0) (h2 : x ≤ 1000) :\n  let result := find_min_potatoes x x\n  isPrime (2*x + result) = true := by\n  sorry\n\ntheorem find_min_potatoes_reasonable_bounds\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x ≤ 100) (h4 : y ≤ 100) :\n  find_min_potatoes x y ≤ x + y := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 3\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_potatoes 4 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 1"}
{"id": "fvapps_000740", "vc-description": "/-\nTara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:\nGiven N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ … An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.\nYou are friends with Kabir, help him to solve the problem for Tara.\n\n-----Input:-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. \n- First line of each test case contains N$N$, the number of elements in the sequence.\n- Second line contains N space separated elements A1$A_1$,A2$A_2$ … An$A_n$.\n\n-----Output:-----\n- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.\n\n-----Constraints-----\n- 1≤T≤10$1 \\leq T \\leq 10$\n- 1≤N≤105$1 \\leq N \\leq 10^5$\n- 2≤A[i]≤105$2 \\leq A[i] \\leq 10^5$\n\n-----Sample Input:-----\n1\n7\n\n3 2 15 6 8 5 10\n\n-----Sample Output:-----\n5\n\n-----EXPLANATION:-----\nThe largest prime factors of numbers are:\n3 2  5  3  2  5  5 , of which 5 is most frequent.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\nsorry\n\ndef find_max_prime_factor (nums : List Nat) : Nat :=\nsorry\n\ndef get_prime_factors_count (nums : List Nat) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem result_is_prime_factor\n  (nums : List Nat)\n  (h1 : ∀ x ∈ nums, x ≥ 2 ∧ x ≤ 10000)\n  (h2 : nums.length > 0) :\n  let result := find_max_prime_factor nums\n  let factors := get_prime_factors_count nums\n  ∃ freq, (result, freq) ∈ factors :=\nsorry\n\ntheorem all_same_prime\n  (nums : List Nat)\n  (h : ∀ x ∈ nums, x = 2)\n  (h2 : nums.length > 0) :\n  find_max_prime_factor nums = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 2, 15, 6, 8, 5, 10]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_prime_factor [4, 8, 12, 15]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 5, 7, 11]"}
{"id": "fvapps_000744", "vc-description": "/-\nYou are given two binary strings $S$ and $P$, each with length $N$. A binary string contains only characters '0' and '1'. For each valid $i$, let's denote the $i$-th character of $S$ by $S_i$.\nYou have to convert the string $S$ into $P$ using zero or more operations. In one operation, you should choose two indices $i$ and $j$ ($1 \\leq i < j \\leq N$) such that $S_i$ is '1' and $S_j$ is '0', and swap $S_i$ with $S_j$.\nDetermine if it is possible to convert $S$ into $P$ by performing some operations.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains a single string $S$.\n- The third line contains a single string $P$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Yes\" if it is possible to convert $S$ into $P$ or \"No\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $S$ and $P$ contain only characters '0' and '1'\n- the sum of $N$ over all test cases does not exceed $10^5$\n\n-----Subtasks-----\nSubtask #1 (20 points):\n- $N \\leq 14$\n- the sum of $N$ over all test cases does not exceed $100$\nSubtask #2 (30 points): the sum of $N$ over all test cases does not exceed $1,000$\nSubtask #3 (50 points): original constraints\n\n-----Example Input-----\n3\n2\n00\n00\n3\n101\n010\n4\n0110\n0011\n\n-----Example Output-----\nYes\nNo\nYes\n\n-----Explanation-----\nExample case 1: The strings are already equal.\nExample case 2: It can be showed that it is impossible to convert $S$ into $P$.\nExample case 3: You can swap $S_2$ with $S_4$. The strings will then be equal.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_convert_binary_strings (s p : String) : String :=\nsorry\n\ndef count_ones (s : String) : Nat :=\nsorry\n\ndef has_adjacent_ones (s : String) : Bool :=\nsorry", "vc-theorems": "theorem same_string_convertible (s : String)\n  (h : s ≠ \"\") :\n  can_convert_binary_strings s s = \"Yes\" :=\nsorry\n\ntheorem conversion_preserves_ones (s p : String)\n  (h1 : s ≠ \"\") (h2 : p ≠ \"\")\n  (h3 : s.length = p.length) :\n  (can_convert_binary_strings s p = \"Yes\") ↔ (count_ones s = count_ones p) :=\nsorry\n\ntheorem cannot_convert_ones_to_zeros (s p : String)\n  (h1 : s ≠ \"\")\n  (h2 : s.length = p.length)\n  (h3 : has_adjacent_ones s = true)\n  (h4 : p = s.replace \"11\" \"00\") :\n  can_convert_binary_strings s p = \"No\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"00\" \"00\"\n\n/--\ninfo: 'No'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"101\" \"010\"\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"0110\" \"0011\""}
{"id": "fvapps_000747", "vc-description": "/-\nChef has an array of N natural numbers. Cheffina challenges the chef to choose the two numbers from the array and following the condition as the area of the rectangle formed from the two numbers is maximum. Cheffina also asks the chef to choose two numbers different from the previous two to form the rectangle with a minimum area.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$.\n- N space-separated natural numbers. \n\n-----Output:-----\nFor each test case, output in one line answers maximum and minimum area of a rectangle.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $4 \\leq N \\leq 10^5$\n- $1 \\leq arr[i] \\leq 10^6$\n\n-----Sample Input:-----\n1\n5\n4 2 1 5 3\n\n-----Sample Output:-----\n20 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_rectangle_areas (n : Nat) (numbers : List Nat) : Nat × Nat :=\nsorry\n\ndef maximumTwoProduct (l : List Nat) : Nat :=\nsorry\n\ndef minimumTwoProduct (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_rectangle_areas_ordering\n  (numbers : List Nat)\n  (h : numbers.length ≥ 2) :\n  let (max_area, min_area) := find_rectangle_areas numbers.length numbers\n  max_area ≥ min_area :=\nsorry\n\ntheorem find_rectangle_areas_minimal\n  (numbers : List Nat)\n  (h : numbers = [1, 1]) :\n  find_rectangle_areas 2 numbers = (1, 1) :=\nsorry\n\ntheorem find_rectangle_areas_preserves_input\n  (numbers : List Nat)\n  (h : numbers.length ≥ 2) :\n  let original := numbers\n  let _ := find_rectangle_areas numbers.length numbers\n  numbers = original :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (20, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 5 [4, 2, 1, 5, 3]\n\n/--\ninfo: (12, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 4 [1, 2, 3, 4]\n\n/--\ninfo: (30, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 6 [5, 4, 3, 2, 1, 6]"}
{"id": "fvapps_000749", "vc-description": "/-\nThe MEX of a set of integers is defined as the smallest non-negative integer that does not belong to this set. For example, $\\mathrm{MEX}(\\{0,2,3\\}) = 1$ and $\\mathrm{MEX}(\\{1,3\\}) = 0$.\nChef has a tree with $N$ nodes (numbered $1$ through $N$). The tree is rooted at node $1$. Chef wants to assign a non-negative integer to each node in such a way that each integer between $0$ and $N-1$ (inclusive) is assigned to exactly one node.\nFor each node $u$, consider the integers assigned to the nodes in the subtree of $u$ (including $u$); let $a_u$ denote the MEX of these integers. Chef wants $a_1 + a_2 + \\ldots + a_N$ to be as large as possible. Find the maximum possible value of this sum.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N-1$ space-separated integers $p_1, p_2, \\ldots, p_{N-1}$. For each valid $i$, the node $p_i$ is the parent of the node $i+1$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum sum of subtree MEX-s which can be obtained if you assign the weights optimally.\n\n-----Constraints-----\n- $1 \\le T \\le 5$\n- $2 \\le N \\le 10^5$\n- $1 \\le p_i < i$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n2\n3\n1 1\n5\n1 1 2 2\n\n-----Example Output-----\n4\n9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_mex (n : Nat) (parents : List Nat) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tree_mex_positive (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents → solve_tree_mex n parents > 0 :=\nsorry\n\ntheorem tree_mex_ge_nodes (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents → solve_tree_mex n parents ≥ n :=\nsorry\n\ntheorem tree_mex_monotonic (n : Nat) (parents : List Nat) :\n  n > 2 →\n  is_valid_tree n parents →\n  solve_tree_mex n parents > solve_tree_mex (n-1) (parents.take (n-2)) :=\nsorry\n\ntheorem line_tree_formula (n : Nat) :\n  n ≥ 2 →\n  solve_tree_mex n (List.map (fun i => i) (List.range (n-1))) = n * (n+1) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_mex 3 [1, 1]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_tree_mex 5 [1, 1, 2, 2]"}
{"id": "fvapps_000766", "vc-description": "/-\nThe chef was not happy with the binary number system, so he designed a new machine which is having 6 different states, i.e. in binary there is a total of 2 states as 0 and 1. Now, the chef is confused about how to correlate this machine to get an interaction with Integer numbers, when N(Integer number) is provided to the system, what will be the Nth number that system will return(in Integer form), help the chef to design this system.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer given by the system.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n2\n3\n5\n\n-----Sample Output:-----\n7\n37\n\n-----EXPLANATION:-----\nInitial numbers for system = [1, 6, 7, 36, 37, 42, 43, 216, …..\nFor 1) 3rd Number for the system will be 7.\nFor 2) 5th Number for the system will be 37.\n-/\n\n/- The function always returns positive integers -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The first 5 elements follow a specific pattern -/\n\n/- For odd positions after 3, each number is previous number plus 1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nth_number (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_nth_number_positive (n : Nat) (h : n > 0) :\n  find_nth_number n > 0 :=\nsorry\n\ntheorem sequence_initial_pattern :\n  find_nth_number 1 = 1 ∧\n  find_nth_number 2 = 6 ∧\n  find_nth_number 3 = 7 ∧\n  find_nth_number 4 = 36 ∧\n  find_nth_number 5 = 37 :=\nsorry\n\ntheorem odd_index_increment (n : Nat) (h1 : n > 3) (h2 : n % 2 = 1) :\n  find_nth_number n = find_nth_number (n-1) + 1 :=\nsorry", "vc-postamble": "/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_nth_number 3\n\n/--\ninfo: 37\n-/\n#guard_msgs in\n#eval find_nth_number 5\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_nth_number 1"}
{"id": "fvapps_000771", "vc-description": "/-\nChef's dog Snuffles has so many things to play with! This time around, Snuffles has an array A containing N integers: A1, A2, ..., AN.\nBad news: Snuffles only loves to play with an array in which all the elements are equal.\nGood news: We have a mover of size D. ! \nA mover of size D is a tool which helps to change arrays. Chef can pick two existing elements Ai and Aj from the array, such that i + D = j and subtract 1 from one of these elements (the element should have its value at least 1), and add 1 to the other element. In effect, a single operation of the mover, moves a value of 1 from one of the elements to the other.\nChef wants to find the minimum number of times she needs to use the mover of size D to make all the elements of the array A equal. Help her find this out.\n\n-----Input-----\n- The first line of the input contains an integer T, denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two integers N and D, denoting the number of elements in the array and the size of the mover. \n- The second line of each testcase contains N space-separated integers: A1, A2, ..., AN, denoting the initial elements of the array. \n\n-----Output-----\n- For each test case, output a single line containing the minimum number of uses or -1 if it is impossible to do what Snuffles wants.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ N ≤ 105\n- 1 ≤ D < N\n- 1 ≤ Ai ≤ 109\n\n-----Subtasks-----\n- Subtask 1 (30 points) : N ≤  103\n- Subtask 2 (70 points) : Original constraints\n\n-----Example-----\nInput:\n3\n5 2\n1 4 5 2 3\n3 1\n1 4 1\n4 2\n3 4 3 5\n\nOutput:\n3\n2\n-1\n\n-----Explanation-----\nTestcase 1:\nHere is a possible sequence of usages of the mover:\n- Move 1 from A3 to A1\n- Move 1 from A3 to A1\n- Move 1 from A2 to A4\nAt the end, the array becomes (3, 3, 3, 3, 3), which Snuffles likes. And you cannot achieve this in fewer moves. Hence the answer is 3.\nTestcase 2:\nHere is a possible sequence of usages of the mover:\n- Move 1 from A2 to A1\n- Move 1 from A2 to A3\nAt the end, the array becomes (2, 2, 2), which Snuffles likes. And you cannot achieve this in fewer moves. Hence the answer is 2.\nTestcase 3:\nIt is impossible to make all the elements equal. Hence the answer is -1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_snuffles_array (n d : Nat) (arr : List Int) : Int :=\n  sorry\n\ndef verify_solution (n d: Nat) (arr : List Int) : Bool :=\n  sorry\n\ndef list_sum (xs : List Int) : Int :=\n  sorry", "vc-theorems": "theorem snuffles_array_properties {n d : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : d > 0)\n  (h3 : d ≤ n)\n  (h4 : arr.length = n) :\n  let result := solve_snuffles_array n d arr\n  (result ≥ 0 → verify_solution n d arr = true) ∧\n  (result = -1 →\n    (∃ i : Nat, i < d ∧\n      let group := (List.range arr.length).filter (fun j => j % d = i)\n      let group_sum := list_sum (group.map (fun j => arr.get! j))\n      let group_avg := group_sum / group.length\n      group_avg ≠ (list_sum arr / arr.length))) :=\nsorry\n\ntheorem all_equal_array_zero {n : Nat} {x : Int}\n  (h1 : n > 0) :\n  solve_snuffles_array n 1 (List.replicate n x) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_snuffles_array 5 2 [1, 4, 5, 2, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_snuffles_array 3 1 [1, 4, 1]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_snuffles_array 4 2 [3, 4, 3, 5]"}
{"id": "fvapps_000772", "vc-description": "/-\nDustin, is the head of an Intelligence agency. He wants to send a secret message S$S$ to his colleague.The message is a single word consisting of only lowercase english letters but he decides to encrypt the message for security reasons. He makes a string M$M$ of length N$N$, such that after deleting a substring of non-zero length from M$M$, the remaining string is S$S$.\nCalculate the number of all such possible strings he can form.\n\n-----Input:-----\n- First line will contain T$T$, number of testcases. Then the testcases follow.\n- For each testcase the there is a single line which contains an integer, N$N$ and then a string S$S$.\n\n-----Output:-----\nFor each testcase, output the number of possible strings modulo 109+7$10^9+7$.\n\n-----Constraints-----\n- 1≤T≤50$1 \\leq T \\leq 50$\n- 1≤N≤1018$1 \\leq N \\leq 10^{18}$\n- 1≤|S|≤105$1 \\leq |S| \\leq 10^5$\n- S$S$ can contain only lowercase English letters.\n\n-----Sample Input:-----\n2\n\n3 a\n\n3 ab     \n\n-----Sample Output:-----\n1326\n\n76\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def count_possible_strings (n : Nat) (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem count_possible_strings_short_input (n : Nat) (s : String) :\n  n ≤ s.length → count_possible_strings n s = 0 :=\nsorry\n\ntheorem count_possible_strings_long_input (n : Nat) (s : String) :\n  n > s.length → count_possible_strings n s > 0 :=\nsorry\n\ntheorem count_possible_strings_monotone_in_string_length (s : String) :\n  let n := s.length + 2\n  count_possible_strings n s > count_possible_strings n (s.append \"a\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1326\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"a\"\n\n/--\ninfo: 76\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"ab\""}
{"id": "fvapps_000777", "vc-description": "/-\nChef is a very experienced and well-known cook. He has participated in many cooking competitions in the past — so many that he does not even remember them all.\nOne of these competitions lasted for a certain number of days. The first day of the competition was day $S$ of the week (i.e. Monday, Tuesday etc.) and the last day was day $E$ of the week. Chef remembers that the duration of the competition (the number of days between the first and last day, inclusive) was between $L$ days and $R$ days inclusive. Is it possible to uniquely determine the exact duration of the competition? If so, what is this duration?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains two space-separated strings $S$ and $E$, followed by a space and two space-separated integers $L$ and $R$.\n\n-----Output-----\nFor each test case, print a single line containing:\n- the string \"impossible\" if there is no duration consistent with all given information\n- the string \"many\" if there is more than one possible duration\n- one integer — the duration of the competition, if its duration is unique\n\n-----Constraints-----\n- $1 \\le T \\le 10,000$\n- $1 \\le L \\le R \\le 100$\n- $S$ is one of the strings \"saturday\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\" or \"friday\"\n- $E$ is one of the strings \"saturday\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\" or \"friday\"\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n3\nsaturday sunday 2 4\nmonday wednesday 1 20\nsaturday sunday 3 5\n\n-----Example Output-----\n2\nmany\nimpossible\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DAYS : List String := [\"saturday\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n\ndef indexOfDay (day: String) : Nat :=\nsorry\n\ndef solveCompetitionDuration (startDay endDay: String) (l r: Nat) : String ⊕ Nat :=\nsorry", "vc-theorems": "theorem competition_duration_impossible {startDay endDay: String} {l r: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"impossible\") :\n  ∀ x, l ≤ x → x ≤ r →\n    x % 7 ≠ ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :=\nsorry\n\ntheorem competition_duration_many {startDay endDay: String} {l r: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"many\") :\n  ∃ x y, l ≤ x ∧ x < y ∧ y ≤ r ∧\n    x % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) ∧\n    y % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :=\nsorry\n\ntheorem competition_duration_specific {startDay endDay: String} {l r n: Nat}\n  (h1: l ≤ r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inr n) :\n  l ≤ n ∧ n ≤ r ∧\n  n % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) ∧\n  (∀ x, l ≤ x → x < n → x % 7 ≠ n % 7) ∧\n  n + 7 > r :=\nsorry\n\ntheorem same_day_property {day: String}\n  (h: day ∈ DAYS) :\n  solveCompetitionDuration day day 1 20 = Sum.inr 7 ∨\n  solveCompetitionDuration day day 1 20 = Sum.inl \"many\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 2 4\n\n/--\ninfo: 'many'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"monday\" \"wednesday\" 1 20\n\n/--\ninfo: 'impossible'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 3 5"}
{"id": "fvapps_000780", "vc-description": "/-\nChef has provided with a sequence of integers of length $N$ arranged in an unsorted fashion.\nThe elements of the sequence are ordered as ${A1,A2,A3.....A'N}$\nThe task of the chef is to identify the highest and lowest value among the given sequence. It is assured that the sequence given contains the highest and the lowest value always\nPlease help chef in finding the desired value.\n\n-----Input:-----\n- First line will contain $N$, number of elements in the sequence.  \n- Next line contains  $N$ integers of the sequence  . \n\n-----Output:-----\nPrint the HIGHEST and  LOWEST value of the sequence respectively.\n\n-----Constraints-----\n- $1 \\leq N \\leq 100$\n- $2 \\leq  {A1,A2,A3.....A'N}  \\leq 10^4$\n\n-----Sample Input:-----\n5\n3 2 7 9 4\n\n-----Sample Output:-----\n9 2\n\n-----EXPLANATION:-----\nThis list is :\n[3,2,7,9,4]  so the highest value is 9 and lowest is 2 respectively.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_min (n : Nat) (seq : String) : Int × Int :=\nsorry\n\ndef maximum : List Int → Int :=\nsorry\n\ndef minimum : List Int → Int :=\nsorry", "vc-theorems": "theorem find_max_min_permutation_invariant {nums1 nums2 : List Int} (n : Nat)\n  (seq1 seq2 : String)\n  (h1 : n = nums1.length)\n  (h2 : n = nums2.length)\n  (h3 : seq1 = String.intercalate \" \" (List.map toString nums1))\n  (h4 : seq2 = String.intercalate \" \" (List.map toString nums2))\n  (h5 : nums2.isPerm nums1) :\n  find_max_min n seq1 = find_max_min n seq2 :=\nsorry\n\ntheorem find_max_min_single_element (n : Nat) (x : Int) (seq : String)\n  (h1 : n = 1)\n  (h2 : seq = toString x) :\n  find_max_min n seq = (x, x) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (9, 2)\n-/\n#guard_msgs in\n#eval find_max_min 5 \"3 2 7 9 4\"\n\n/--\ninfo: (10, 5)\n-/\n#guard_msgs in\n#eval find_max_min 3 \"10 5 8\"\n\n/--\ninfo: (1000, 250)\n-/\n#guard_msgs in\n#eval find_max_min 4 \"1000 250 750 500\""}
{"id": "fvapps_000804", "vc-description": "/-\nCorruption is on the rise in the country of Freedonia, Gru's home. Gru wants to end this for good and for that he needs the help of his beloved minions.\nThis corruption network can be represented in the form of a tree having N$N$ nodes and N−1$N-1$ edges. The nodes are numbered from 1$1$ to N$N$, and the tree is rooted at node 1$1$. These nodes represent the corrupt officials and each corrupt official works under some other corrupt official except the Boss who is represented by node 1$1$.\nGru believes in divide and conquer and thinks that this network needs to be divided into as many sub-networks as possible.\nHe commands the minions to kill some of the corrupt officials in order to break the network into maximum sub-networks. But as you know, these corrupt officials are very sharp, and hence these assassinations need to be done very smartly and silently, without leaving any traces.  To achieve this Gru devises a strategy, in which he designs an operation, and that operation can be applied by the minions any number of times (even 0). \nIn one operation the minions can select any one leaf node official [that is an official who does not have any other official beneath him] in the graph and kill him along with all his ancestors$ancestors$ officials till the root$root$ of the tree in which the operation is applied (this is done to wipe all traces of the operation). This deleted all those nodes from the graph, and also, while doing so, all the associated edges/connections$edges/connections$ of the leaf node and its ancestors are also destroyed. Hence after applying this operation on any tree, it breaks into some connected components which are also trees, which are the new sub-networks.\nNow the minions are a bit lazy and will do the task someday, but they need to submit a report to Gru containing the number of the maximum$maximum$ connected$connected$ components$components$ that they could achieve by applying the operation any number of times. To do this, the minions require your help. So help the minions by finding out the maximum$maximum$ no.$no.$ of$of$ connected$connected$ components$components$ that can be achieved.\nNote: After each operation, the topmost node (node with the lowest level. It can be proved that there will always be a unique node with the lowest level in each tree) of each of the remaining trees becomes the root of that particular tree (that is, after the first operation it can be visualized that the graph converts into a forest of rooted trees)\n\n-----Input:-----\n- First line will contain N$N$, number of nodes in the tree. \n- Next N−1$N-1$ lines contains 2 integers U$U$, V$V$ denoting the endpoints of the ith$i^{th}$ edge.\n\n-----Output:-----\n- Print the maximum number of connected components you can obtain after doing the operation any number of times.\n\n-----Constraints-----\n- 1≤N≤106$1 \\leq N \\leq 10^6$\n- 1≤U,V≤N$1 \\leq U,V \\leq N$\n\n-----Sample Input:-----\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\nWe have 4 leaf nodes in this tree: 4 5 6 7. Suppose we delete node 5, then along with it we also delete node 2 and node 1. so after the deletion we are left with 2 trees, one consisting of only node 4 as the root node of that particular tree, and the other consisting of node 3,6,7 with node 3 as the root node. This can also be achieved by deleting any of the other leaf nodes and it can be proved that we cannot obtain more than 2 connected components in this example.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_components (n: Nat) (edges: List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_tree (n: Nat) (edges: List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem line_graph_components {n: Nat} (h: n ≥ 2) :\n  let edges := List.range (n-1) |>.map (λi => (i+1, i+2))\n  find_max_components n edges = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 7 [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_components 3 [(1, 2), (2, 3)]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 4 [(1, 2), (1, 3), (1, 4)]"}
{"id": "fvapps_000812", "vc-description": "/-\nChef has a sequence $A_1, A_2, \\ldots, A_N$. This sequence has exactly $2^N$ subsequences. Chef considers a subsequence of $A$ interesting if its size is exactly $K$ and the sum of all its elements is minimum possible, i.e. there is no subsequence with size $K$ which has a smaller sum.\nHelp Chef find the number of interesting subsequences of the sequence $A$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of interesting subsequences.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le K \\le N \\le 50$\n- $1 \\le A_i \\le 100$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (30 points): $1 \\le N \\le 20$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n1\n4 2\n1 2 3 4\n\n-----Example Output-----\n1\n\n-----Explanation-----\nExample case 1: There are six subsequences with length $2$: $(1, 2)$, $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$ and $(3, 4)$. The minimum sum is $3$ and the only subsequence with this sum is $(1, 2)$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_interesting_subsequences (n k : Nat) (a : List Nat) : Nat :=\n  sorry\n\ndef isSorted (l : List Nat) : Bool :=\n  sorry\n\ndef sortList (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem count_interesting_subsequences_properties (n k : Nat) (a : List Nat)\n    (h1 : n > 0) (h2 : k > 0) (h3 : List.length a > 0) :\n    k ≤ List.length a →\n    0 ≤ count_interesting_subsequences n k a :=\nsorry\n\ntheorem sorted_input_equivalence (a : List Nat)\n    (h1 : List.length a ≥ 2) :\n    let k := List.length a / 2\n    count_interesting_subsequences (List.length a) k (sortList a) =\n    count_interesting_subsequences (List.length a) k a :=\nsorry\n\ntheorem kth_element_boundary (a : List Nat)\n    (h1 : List.length a ≥ 2) (h2 : List.length a ≤ 10) :\n    let k := List.length a / 2\n    let sorted := sortList a\n    k > 0 →\n    k ≤ List.length a →\n    ∃ x, List.elem x a ∧ x = List.get! sorted (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 4 2 [1, 2, 3, 4]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 3 2 [2, 2, 2]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 5 3 [1, 1, 2, 2, 3]"}
{"id": "fvapps_000823", "vc-description": "/-\nLittle kids, Jack and Evan like playing their favorite game Glass-and-Stone. Today they want to play something new and came across Twitter on their father's laptop.\n\nThey saw it for the first time but were already getting bored to see a bunch of sentences having at most 140 characters each. The only thing they liked to play with it is, closing and opening tweets.\n\nThere are N tweets on the page and each tweet can be opened by clicking on it, to see some statistics related to that tweet. Initially all the tweets are closed. Clicking on an open tweet closes it and clicking on a closed tweet opens it. There is also a button to close all the open tweets. Given a sequence of K clicks by Jack, Evan has to guess the total number of open tweets just after each click. Please help Evan in this game.\n\n-----Input-----\nFirst line contains two integers N K, the number of tweets (numbered 1 to N) and the number of clicks respectively (1 ≤ N, K ≤ 1000). Each of the following K lines has one of the following.\n\n- CLICK X , where X is the tweet number (1 ≤ X ≤ N)\n- CLOSEALL\n\n-----Output-----\nOutput K lines, where the ith line should contain the number of open tweets just after the ith click.\n\n-----Example-----\nInput:\n3 6\nCLICK 1\nCLICK 2\nCLICK 3\nCLICK 2\nCLOSEALL\nCLICK 1\n\nOutput:\n1\n2\n3\n2\n0\n1\n\nExplanation:\n\nLet open[x] = 1 if the xth tweet is open and 0 if its closed.\n\nInitially open[1..3] = { 0 , 0 , 0 }. Here is the state of open[1..3] after each click and corresponding count of open tweets.\n\nCLICK 1 : { 1, 0, 0 }, open count = 1\n\nCLICK 2 : { 1, 1, 0 }, open count = 2\n\nCLICK 3 : { 1, 1, 1 }, open count = 3\n\nCLICK 2 : { 1, 0, 1 }, open count = 2\n\nCLOSEALL : { 0, 0, 0 }, open count = 0\n\nCLICK 1 : { 1, 0, 0 }, open count = 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tweet_clicks (n : Nat) (clicks : List String) : List Nat :=\nsorry\n\ndef is_valid_click_command (n : Nat) (s : String) : Bool :=\nsorry\n\ndef get_tweet_count (prev : Nat) (cmd : String) : Nat :=\nsorry", "vc-theorems": "theorem output_length_matches_input {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  (solve_tweet_clicks n clicks).length = clicks.length :=\nsorry\n\ntheorem counts_are_nonnegative {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  ∀ x ∈ solve_tweet_clicks n clicks, 0 ≤ x ∧ x ≤ n :=\nsorry\n\ntheorem closeall_resets_to_zero {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n ≤ 100) (h3 : clicks.length > 0) :\n  ∀ (i : Nat) (h : i < clicks.length),\n  clicks.get ⟨i, h⟩ = \"CLOSEALL\" →\n  (solve_tweet_clicks n clicks).get ⟨i, by rw [output_length_matches_input h1 h2 h3]; exact h⟩ = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [1, 2, 3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 3 [\"CLICK 1\", \"CLICK 2\", \"CLICK 3\", \"CLICK 2\", \"CLOSEALL\", \"CLICK 1\"]\n\n/--\ninfo: [1, 2, 0]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 2 [\"CLICK 1\", \"CLICK 2\", \"CLOSEALL\"]\n\n/--\ninfo: [1, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 4 [\"CLICK 1\", \"CLICK 1\", \"CLICK 2\"]"}
{"id": "fvapps_000827", "vc-description": "/-\nCoach Moony wants the best team to represent their college in ICPC. He has $N$ students standing in a circle with certain rating $X_i$ on a competitive coding platform. It is an established fact that any coder with more rating on the platform is a better coder.      \nMoony  wants to send his best $3$ coders based upon their rating. But all coders only want to have their friends in their team and every coder is friends with four other coders, adjacent two on left side in the circle, and adjacent two on right. So Moony comes up with a solution that team with maximum cumulative rating of all three members in a team shall be representing their college.\nYou need to give the cumulative score of the team that will be representing the college.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. \n- First line of each test case contains a single integer $N$.\n- Second  line of each test case takes $N$ integers, denoting rating of $ith$ coder.\n\n-----Output:-----\nFor each testcase, output a single integer denoting cumulative rating  of the team.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $7 \\leq N \\leq 10^5$ \n- $0 \\leq X_i \\leq 10^9$\n\n-----Sample Input:-----\n1\n\n7\n\n10 40 30 30 20 0 0  \n\n-----Sample Output:-----\n100\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef take_last (n : Nat) (l : List Nat) : List Nat :=\n  let rev := l.reverse\n  (rev.take n).reverse", "vc-helpers": "", "vc-definitions": "def find_max_team_score (n : Nat) (ratings : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_max_team_score_upper_bound\n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≤ list_sum (take_last 3 ratings) :=\nsorry\n\ntheorem find_max_team_score_lower_bound\n  (ratings : List Nat) (h : ratings.length ≥ 3) :\n  find_max_team_score ratings.length ratings ≥ list_sum (ratings.take 3) :=\nsorry\n\ntheorem find_max_team_score_three_elements\n  (ratings : List Nat) (h : ratings.length = 3) :\n  find_max_team_score ratings.length ratings = list_sum ratings :=\nsorry\n\ntheorem find_max_team_score_consecutive\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) (hi : i + 2 < ratings.length) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i]! + ratings[i+1]! + ratings[i+2]! :=\nsorry\n\ntheorem find_max_team_score_wrapping\n  (ratings : List Nat) (h : ratings.length ≥ 3) (i : Nat) :\n  find_max_team_score ratings.length ratings ≥\n    ratings[i % ratings.length]! +\n    ratings[(i + 1) % ratings.length]! +\n    ratings[(i + 2) % ratings.length]! :=\nsorry\n\ntheorem find_max_team_score_all_equal\n  (n : Nat) (h : n ≥ 3) :\n  find_max_team_score n (List.replicate n 1) = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [10, 40, 30, 30, 20, 0, 0]\n\n/--\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [50, 20, 30, 10, 40, 15, 25]\n\n/--\ninfo: 60\n-/\n#guard_msgs in\n#eval find_max_team_score 3 [10, 20, 30]"}
{"id": "fvapps_000829", "vc-description": "/-\nChef has a sequence of positive integers $A_1, A_2, \\ldots, A_N$. He wants to split this sequence into two non-empty (not necessarily contiguous) subsequences $B$ and $C$ such that $\\mathrm{GCD}\\,(B) + \\mathrm{GCD}\\,(C)$ is maximum possible. Help him find this maximum value.\nNote: The greatest common divisor (GCD) of a sequence of positive integers is the largest positive integer that divides each element of this sequence. For example, the GCD of the sequence $(8, 12)$ is $4$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the maximum value of $\\mathrm{GCD}\\,(B) + \\mathrm{GCD}\\,(C)$.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $2 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (20 points): $2 \\le N \\le 20$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n1              \n4                    \n4 4 7 6                    \n\n-----Example Output-----\n9\n\n-----Explanation-----\nExample case 1: For example, the sequence $A$ can be divided into subsequences $B = (4, 4, 6)$ and $C = (7)$.\n-/", "vc-preamble": "def list_max : List Nat → Nat\n| [] => 0\n| (x::xs) => max x (list_max xs)\n\ndef list_min : List Nat → Nat\n| [] => 0\n| (x::xs) => min x (list_min xs)", "vc-helpers": "", "vc-definitions": "def gcd : Nat → Nat → Nat\n| a, b =>\nsorry\n\ndef max_gcd_sum : List Nat → Nat\n| xs =>\nsorry", "vc-theorems": "theorem matches_reference (nums : List Nat) (h : ∀ x ∈ nums, x > 0) :\n  ∃ result, max_gcd_sum nums = result := by\n  sorry\n\ntheorem output_larger_than_input (nums : List Nat) (h : ∀ x ∈ nums, x > 0) :\n  max_gcd_sum nums ≥ list_max nums ∧ max_gcd_sum nums ≥ list_min nums := by\n  sorry\n\ntheorem duplicate_handling (nums : List Nat) (dupes : List Nat)\n  (h : ∀ x ∈ nums, x > 0) (h2 : ∀ x ∈ dupes, x ∈ nums) :\n  max_gcd_sum nums = max_gcd_sum (nums ++ dupes) := by\n  sorry\n\ntheorem single_element (x : Nat) (h : x > 0) :\n  max_gcd_sum [x] = 2 * x := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval max_gcd_sum [4, 4, 7, 6]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gcd_sum [2, 2, 2]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval max_gcd_sum [3, 6, 9, 12]"}
{"id": "fvapps_000835", "vc-description": "/-\nProblem description.\nDominic Toretto has taken his crew to compete in this years' Race Wars, a crew-on-crew tournament in which each member of one crew competes with a member of the other crew in a quarter mile drag race. Each win counts as one point for the winning crew. Draws and loses are awarded zero points. In the end the crew with more points is declared the winner of that round and can advance while the losing crew is knocked out. One member can compete in only one race per round and all crews have the same number of members.\nDom and his crew have a reputation of being the best and naturally everyone expects them to win this year as well.\nHowever, during the tournament he spots a new crew of racers who are participating for the first time in this event. People expect them to be a dark horse so naturally Dom wants to keep an eye on their performance.\nBeing the experienced racer that he is, Dom has figured out the time in which each racer of the opposing crew completes his quarter mile race.\n\nHe also knows his own crew inside out and can estimate with absolute certainty, the time it would take each of his members to complete the race. Dominic is the reigning champion and thus has an advantage that he can select the order of the matches i.e.: he can select which member of his crew will go up against which member of the opposition. Given this data he wants to figure out the number of races he will win should his crew come face to face with their newest rivals.\n\nUnfortunately he is a racer and not a problem solver so he comes to you for help.\n\nGiven the time each member of the two crews take to complete the race you have to figure out a way to arrange the matches so that Dominic can win maximum points possible for him.\n\n-----Input-----\n\nThe first line of input is the T, the number of test cases.\n\nEach test case starts with a single number N, the number of racers on each crew.\n\nThis is followed by two lines, each having N space separated integers containing the time taken by each member of Dominic's crew and the rival crew respectively.\n\n-----Output-----\nOutput a single integer. The maximum number of points that Dominic can get.\n\n-----Constraints-----\n1<=T<=100\n1<=N<=100\nTime taken by each member will be between 1 and 500\n\n-----Example-----\nInput:\n\n1\n3\n5 4 1\n5 4 1\n\nOutput:\n2\n\n-----Explanation-----\nIf Dom selects Racer 1 of his team to go against Racer 2 of the other team, Racer 2 of his team against Racer 3 of the other team and Racer 3 of his team against Racer 1 of the other team then he ends up with two wins and a loss which gives him 2 points. ...\n-/", "vc-preamble": "def isDescending (l : List Nat) : Prop :=\n  ∀ i j, i < l.length → j < l.length → i < j →\n    match l.get? i, l.get? j with\n    | some x, some y => x ≥ y\n    | _, _ => True", "vc-helpers": "", "vc-definitions": "def max_race_wins (n : Nat) (my_times : List Nat) (opp_times: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem max_race_wins_result_bounds {n : Nat} {my_times opp_times : List Nat}\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : ∀ x ∈ my_times, 1 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ x ∈ opp_times, 1 ≤ x ∧ x ≤ 1000) :\n  let result := max_race_wins n my_times opp_times\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_race_wins_length {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : n > 0)\n  (h2 : my_times_out.length = n)\n  (h3 : opp_times_out.length = n)\n  (h4 : max_race_wins n my_times opp_times > 0) : True :=\nsorry\n\ntheorem max_race_wins_sorted {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : max_race_wins n my_times opp_times > 0)\n  (h2 : isDescending my_times_out)\n  (h3 : isDescending opp_times_out) : True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 3 [5, 4, 1] [5, 4, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_race_wins 2 [3, 1] [2, 2]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 4 [5, 4, 3, 2] [6, 5, 4, 1]"}
{"id": "fvapps_000838", "vc-description": "/-\nMinion Chef likes to eat bananas a lot. There are N piles of bananas in front of Chef; for each i (1 ≤ i ≤ N), the i-th pile contains Ai bananas.\nChef's mother wants her to eat the bananas and be healthy. She has gone to the office right now and will come back in H hours. Chef would like to make sure that she can finish eating all bananas by that time.\nSuppose Chef has an eating speed of K bananas per hour. Each hour, she will choose some pile of bananas. If this pile contains at least K bananas, then she will eat K bananas from it. Otherwise, she will simply eat the whole pile (and won't eat any more bananas during this hour).\nChef likes to eat slowly, but still wants to finish eating all the bananas on time. Therefore, she would like to choose the minimum K such that she is able to eat all the bananas in H hours. Help Chef find that value of K.\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers N and H denoting the number of piles and the number of hours after which Chef's mom will come home.\n- The second line contains N space-separated integers A1, A2, ..., AN.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the minimum possible value of K.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- N ≤ H ≤ 109\n- 1 ≤ Ai ≤ 109 for each valid i\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- 1 ≤ N ≤ 100\n- Ai ≤ 103 for each valid i\n\nSubtask #2 (70 points): original constraints\n\n-----Example-----\nInput:\n\n3\n3 3\n1 2 3\n3 4\n1 2 3\n4 5\n4 3 2 7\n\nOutput:\n\n3\n2\n4\n\n-----Explanation-----\nExample case 1: With a speed of K = 3 bananas per hour, Chef can finish eating all the bananas in 3 hours. It's the minimum possible speed with which she can eat all the bananas in 3 hours. With a speed of 2 bananas per hour, she would take at least 4 hours and with a speed of 1 banana per hour, she would take at least 6 hours.\n-/", "vc-preamble": "def list_maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef nat_ceil_div (a b : Nat) : Nat :=\n  (a + b - 1) / b", "vc-helpers": "", "vc-definitions": "def min_banana_speed (pile_count : Nat) (hours : Nat) (piles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem edge_cases_singleton_one :\n  min_banana_speed 1 1 [1] = 1 :=\nsorry\n\ntheorem edge_cases_singleton_hundred :\n  min_banana_speed 1 1 [100] = 100 :=\nsorry\n\ntheorem edge_cases_two_ones :\n  min_banana_speed 2 2 [1, 1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_banana_speed 3 3 [1, 2, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_banana_speed 3 4 [1, 2, 3]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_banana_speed 4 5 [4, 3, 2, 7]"}
{"id": "fvapps_000842", "vc-description": "/-\nThese days, chef is very much interested in Mathematics. He has started attending Recitations too! His hunger for problems is increasing day by day!\nToday, chef was a given a crumpled maths problem, which he is stuck with . He needs your help to do it\nHere's what his teacher said: \"Find sum of all numbers till N, do not include numbers which are powers of K from K, K2, K3... which are less than or equal to N\"\nEasy, right? Can you solve it?\n\n-----INPUT-----\nThe first line of the input contains an integer T, denoting the number of test cases. The description of T test cases follows. The first line of each test contains two integers N and K, as per the above given problem specification.\n\n-----OUTPUT-----\nFor each test case, output a single line printing the sum of the each test case, in format Case #T: S, where T is the Tth test case running and S is sum of corresponding test case.\n\n-----CONSTRAINTS-----\n\n10 < T < 50\n\n10 < N < 104\n\n0 < K < 100\n\n-----EXAMPLE-----\nInput:\n\n2\n\n10 3\n\n20 2\n\nOutput:\n\nCase #1: 43\n\nCase #2: 180\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def pow (x: Int) (n: Nat) : Int :=\n  match n with\n  | 0 => 1\n  | n + 1 => x * pow x n", "vc-helpers": "", "vc-definitions": "def calculate_special_sum (n: Int) (k: Int) : Int :=\n  sorry\n\ndef solve_case (n: Int) (k: Int) : String :=\n  sorry", "vc-theorems": "theorem calculate_special_sum_nonnegative\n  (n: Int) (k: Int)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  calculate_special_sum n k ≥ 0 :=\nsorry\n\ntheorem calculate_special_sum_upper_bound\n  (n: Int) (k: Int) (power: Nat)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100)\n  (hp: pow k power ≤ n) :\n  calculate_special_sum n k ≤ (n * (n+1))/2 :=\nsorry\n\ntheorem calculate_special_sum_negative_input\n  (n: Int) (k: Int)\n  (hn: n < 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  calculate_special_sum n k = 0 :=\nsorry\n\ntheorem solve_case_format\n  (n: Int) (k: Int)\n  (hn: n ≥ 0) (hk: k ≥ 2) (hk2: k ≤ 100) :\n  solve_case n k = \"Case #1: \" ++ toString (calculate_special_sum n k) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000844", "vc-description": "/-\n\"It does not matter how slowly you go as long as you do not stop.\" - Confucius\nYou are given an array $A_1, A_2, \\ldots, A_N$ and an integer $K$. For each subarray $S = [A_l, A_{l+1}, \\ldots, A_r]$ ($1 \\le l \\le r \\le N$):\n- Let's define an array $B$ as $S$ concatenated with itself $m$ times, where $m$ is the smallest integer such that $m(r-l+1) \\ge K$.\n- Next, let's sort $B$ and define $X = B_K$, i.e. as a $K$-th smallest element of $B$. Note that $|B| \\ge K$.\n- Then, let's define $F$ as the number of occurrences of $X$ in $S$.\n- The subarray $S$ is beautiful if $F$ occurs in $S$ at least once.\nFind the number of beautiful subarrays of $A$. Two subarrays $A_l, A_{l+1}, \\ldots, A_r$ and $A_p, A_{p+1}, \\ldots, A_q$ are different if $l \\neq p$ or $r \\neq q$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$. \n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer - the number of beautiful subarrays.\n\n-----Constraints-----\n- $1 \\le T \\le 5$\n- $1 \\le N \\le 2,000$\n- $1 \\le K \\le 10^9$\n- $1 \\le A_i \\le 2000$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le N \\le 200$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n1\n3 3\n1 2 3\n\n-----Example Output-----\n3\n\n-----Explanation-----\nExample case 1: There are six subarrays of $A$: $[1]$, $[2]$, $[3]$, $[1, 2]$, $[2, 3]$, $[1, 2, 3]$. The corresponding arrays $B$ are $[1, 1, 1]$, $[2, 2, 2]$, $[3, 3, 3]$, $[1, 2, 1, 2]$, $[2, 3, 2, 3]$, $[1, 2, 3]$.\nThree of the subarrays are beautiful: $[1]$, $[1, 2]$ and $[1, 2, 3]$. For these subarrays, $X$ is $1$, $2$ and $3$ respectively (for example, for $S = [1, 2]$, $B = [1, 2, 1, 2]$ is sorted to $[1, 1, 2, 2]$ and $X = 2$ is the $3$-rd element). Then, $F = 1$ for each of these subarrays, and each of these subarrays contains $1$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_beautiful_subarrays (n k : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef is_valid_array (arr : List Nat) (n : Nat) : Bool :=\n  sorry\n\ndef list_sorted (arr : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem array_bounds (n k : Nat) (arr : List Nat) :\n  1 ≤ n ∧ n ≤ 100 ∧\n  1 ≤ k ∧ k ≤ 100 ∧\n  arr.length = n ∧\n  (∀ x ∈ arr, 1 ≤ x ∧ x ≤ 2000) →\n  0 ≤ count_beautiful_subarrays n k arr :=\nsorry\n\ntheorem single_element_arrays (n k : Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 →\n  n ≤ count_beautiful_subarrays n k (List.replicate n 1) :=\nsorry\n\ntheorem sorted_vs_unsorted (n k : Nat) (arr : List Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 ∧\n  is_valid_array arr n →\n  count_beautiful_subarrays n k (list_sorted arr) = count_beautiful_subarrays n k arr :=\nsorry\n\ntheorem minimal_case (k : Nat) :\n  1 ≤ k ∧ k ≤ 10 →\n  count_beautiful_subarrays 1 k [1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 3 3 [1, 2, 3]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 1 1 [1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 2 2 [2, 1]"}
{"id": "fvapps_000847", "vc-description": "/-\nYou are given a grid with $R$ rows (numbered $1$ through $R$) and $C$ columns (numbered $1$ through $C$). Initially, each cell of this grid is either empty, contains an ant or an anteater. Each ant is moving in a fixed direction: up, down, left or right. The anteaters do not move.\nThe movement of ants happens in discrete steps. For example, when an ant is in the cell in the $i$-th row and $j$-th column at some point in time (in some step) and it is moving down, then in the next step, it enters the cell in the $(i+1)$-th row and $j$-th column. Two ants meet each other when they enter the same cell at the same point in time (in the same step). When ants meet, they do not interact in any way and keep moving in their fixed directions.\nIf an ant reaches an anteater, that anteater eats the ant, so the ant completely disappears. If an ant attempts to leave the grid, it also disappears. When two ants enter a cell containing an anteater at the same time, they are eaten before they could meet.\nCalculate the total number of pairs of ants that meet each other.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $R$ and $C$.\n- Each of the following $R$ lines contains a single string with length $C$. For each valid $i, j$, the $j$-th character in the $i$-th string is:\n- '#' if the cell in the $i$-th row and $j$-th column of the grid contains an anteater\n- 'U', 'D', 'L' or 'R' if this cell contains an ant moving up, down, left or right respectively\n- '-' if this cell is empty\n\n-----Output-----\nFor each test case, print a single line containing one integer — the number of pairs of ants that meet.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le R, C \\le 50$\n- each string contains only characters 'U', 'D', 'L', 'R', '#' and '-'\n\n-----Example Input-----\n10\n3 3\nR--\n---\n--U\n1 4\nR--R\n2 2\n--\n--\n1 4\nR--L\n1 4\n-R-L\n1 4\n-R#L\n3 3\nR-D\n-#-\nR-U\n3 3\nR-D\n---\nR#U\n3 3\n-D-\nR-L\n-U-\n1 7\nRLLLLLL\n\n-----Example Output-----\n1\n0\n0\n0\n1\n0\n3\n2\n6\n3\n-/", "vc-preamble": "def is_direction (c : Char) : Bool :=\n  c = 'U' || c = 'D' || c = 'L' || c = 'R'", "vc-helpers": "", "vc-definitions": "def solve_ant_grid (R C : Nat) (grid : List String) : Nat :=\n  sorry\n\ndef make_empty_string (n : Nat) (c : Char) : String :=\n  sorry\n\ndef count_directions (grid : List String) : Nat :=\n  sorry", "vc-theorems": "theorem solve_ant_grid_output_props (R C : Nat) (grid : List String)\n  (h : R > 0 ∧ C > 0) :\n  let result := solve_ant_grid R C grid;\n  result ≥ 0 :=\nsorry\n\ntheorem empty_grid_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : ∀ (row : String), row ∈ grid → ∀ (c : Char), c ∈ row.data → (c = '-' ∨ c = '#')) :\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem single_ant_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : count_directions grid ≤ 1) :\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem all_empty_grid_zero (R C : Nat) (h : R > 0 ∧ C > 0) :\n  let empty_row := make_empty_string C '-';\n  let grid := List.replicate R empty_row;\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem all_walls_grid_zero (R C : Nat) (h : R > 0 ∧ C > 0) :\n  let wall_row := make_empty_string C '#';\n  let grid := List.replicate R wall_row;\n  solve_ant_grid R C grid = 0 :=\nsorry\n\ntheorem single_ant_top_left_zero (R C : Nat) (ant : Char)\n  (h1 : R > 0 ∧ C > 0)\n  (h2 : is_direction ant) :\n  let first_row := (String.push (make_empty_string (C-1) '-') ant);\n  let empty_row := make_empty_string C '-';\n  let rest_rows := List.replicate (R-1) empty_row;\n  let grid := first_row :: rest_rows;\n  solve_ant_grid R C grid = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"R--\", \"---\", \"--U\"]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 1 4 [\"-R-L\"]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"-D-\", \"R-L\", \"-U-\"]"}
{"id": "fvapps_000855", "vc-description": "/-\nTracy loves Donuts. She purchased a lots of Donuts for her birthday party. She learnt to calculate the area of the circle a few days back and she is fascinated to know the area of the donuts as well !! Help her finding the area of the Donuts…..\n\n-----Input:-----\n- First line will contain, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, where in you have to provide the RADIUS of the Donuts. \n\n-----Output:-----\nFor each testcase, output in a single line answer is the AREA of the Donut.\n\n-----Constraints-----\n1 <= Radius <= 20.\n\n-----Sample Input:-----\n2\n5 \n12\n\n-----Sample Output:-----\n78.5\n\n452.16\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Float.ofString? (s: String) : Option Float :=\nsorry\n\ndef calculate_donut_areas (radii : List Int) : List String :=\nsorry", "vc-theorems": "def Float.ofString! (s: String) : Float := (Float.ofString? s).get!\n\ntheorem calculate_donut_areas_length_match (radii : List Int) :\n  (calculate_donut_areas radii).length = radii.length :=\nsorry\n\ntheorem calculate_donut_areas_decimal_format (radii : List Int) (result : String) :\n  result ∈ calculate_donut_areas radii →\n  (∃ n d : String, result = n ++ \".\" ++ d ∧ d.length = 2) :=\nsorry\n\ntheorem calculate_donut_areas_accuracy (radius : Int) :\n  let area := calculate_donut_areas [radius]\n  let expected := (Float.ofInt (radius * radius)) * 3.14\n  let actual := Float.ofString! area.head!\n  (actual - expected).abs < 0.01 :=\nsorry\n\ntheorem calculate_donut_areas_negative_valid (radii : List Int)\n  (h : ∀ r ∈ radii, r < 0) :\n  (calculate_donut_areas radii).length = radii.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000864", "vc-description": "/-\nChef is a brilliant university student that does not attend lectures because he believes that they are boring and coding is life! However, his university follows certain rules and regulations, and a student may only take an exam for a course if he has attended at least 75% of lectures for this course.\nSince you are Chef's best friend, you want to help him reach the attendance he needs to take exams. Unfortunately, Chef is still focused on his code and refuses to attend more lectures, so the only option is to have some of his friends mark him as present by proxy. This trick is well-known in the university, but only few have the talent to pull it off.\nIn a certain course, there is exactly one lesson per day over the course of $D$ days (numbered $1$ through $D$). You are given a string $S$ with length $D$ describing the lessons Chef attended — for each valid $i$, the $i$-th character of this string is either 'A' if Chef was absent on day $i$ or 'P' if Chef was actually present on day $i$.\nFor each day $d$ when Chef is absent, one of Chef's friends can mark him as present by proxy on this day only if he was present (if he was really present, not just marked as present) on at least one of the previous two days, i.e. days $d-1$ and $d-2$, and on at least one of the following two days, i.e. days $d+1$ and $d+2$. However, it is impossible to mark him as present by proxy on the first two days and the last two days.\nFind the minimum number of times Chef has to be marked as present by proxy so that his attendance becomes at least 75% ($0.75$). Chef's attendance is number of days when he was marked as present, either by proxy or by actually being present, divided by $D$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $D$.\n- The second line contains a single string $S$ with length $D$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the minimum number of times Chef needs to be marked as present by proxy, or $-1$ if it is impossible to make Chef achieve 75% attendance.\n\n-----Constraints-----\n- $1 \\le T \\le 200$\n- $1 \\le D \\le 1,000$\n- $S$ contains only characters 'A' and 'P'\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n1\n9\nPAAPPAPPP\n\n-----Example Output-----\n1\n\n-----Explanation-----\nExample case 1: With a proxy on the third day, the attendance string is \"PAPPPAPPP\". Now, Chef's attendance is at least 75%, so the minimum number of times Chef needs to be marked as present by proxy is $1$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_proxy_attendance (D : Nat) (S : String) : Int :=\n  sorry\n\ndef countP (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_range {D : Nat} {S : String} (h : D ≥ 5) (h2 : D ≤ 100) (h3 : S.length = D) :\n  let result := solve_proxy_attendance D S\n  result = -1 ∨ result ≥ 0 :=\nsorry\n\ntheorem all_present {D : Nat} (h : D ≥ 5) (h2 : D ≤ 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'P')) = 0 :=\nsorry\n\ntheorem too_many_absences {D : Nat} (h : D ≥ 5) (h2 : D ≤ 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'A')) = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 9 \"PAAPPAPPP\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 5 \"PAAAA\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 8 \"PPPPPPPP\""}
{"id": "fvapps_000867", "vc-description": "/-\nThere are $N$ cells numbered 1,2,….., N, and every cell has some positive value. you will be given an array $A_1$,$A_2$,…,$A_N$ where $A_i$ is the value of $ith$ cell and an integer $K$.\nThere is a monkey who wants to reach the $right$ side of the last ($Nth$) cell, initially, the monkey was left side of the first ($1st$) cell. \nIn the first step, he can jump into any cell numbered 1,2,….., K.Once he jumped into any cell $i$ next he can only jump to the cell $j$ such that-\n- j>i\n- j-i <= K  \n- A[i]%2 == A[j]%2\nYou have to find out what is the minimum number of steps required to reach the right side of the cell or In case it's not possible to reach the right side of the cell your answer should be $-1$.NOTE: As soon as monkey reach any cell whose distance from the last cell is less than K, then in the last step, he will jump out to the right side of the ($Nth$) cell.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $A_1$,$A_2$,…,$A_N$\n\n-----Output:-----\nFor each test case, output in a single line minimum steps or $-1$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 2*10^5$\n- $1 \\leq K \\leq N$\n- $0 \\leq A_i \\leq 10^6$\n- $\\text{the sum of N over all test cases does not exceed $5*10^{5}$}$\n\n-----Sample Input:-----\n1\n2 2\n3 4\n\n-----Sample Output:-----\n2 \n\n-----EXPLANATION:-----\nin the first step, you can jump into any cell 1 or 2 and then in the second step you will jump \nout to the right side of 2nd cell\nremember we don't want to reach $Nth$ cell we want to reach the right side of the nth cell.\n-/", "vc-preamble": "def list_max : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (list_max xs)\n\ndef iterate_steps (i j steps : Nat) : Nat × Nat :=\n  match steps with\n  | 0 => (i, j)\n  | n+1 =>\n    let (cur_i, cur_j) := iterate_steps i j n\n    if cur_i ≤ cur_j then\n      (cur_i + cur_j, cur_j)\n    else\n      (cur_i, cur_j + cur_i)", "vc-helpers": "", "vc-definitions": "def find_min_steps (i j : Nat) (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_min_steps_nonnegative {i j : Nat} {nums : List Nat} :\n  find_min_steps i j nums ≥ 0 :=\nsorry\n\ntheorem find_min_steps_monotonic {i j target : Nat} (hi : i > 1) (hj : j > 1) :\n  find_min_steps i j [target] ≤ find_min_steps (i-1) (j-1) [target] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 1 2 [5]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_steps 2 2 [3, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_steps 1 1 [3, 4, 5]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 2 1 [5]"}
{"id": "fvapps_000878", "vc-description": "/-\nKabir likes Tara's smile and wants to look at her smile. They are sitting in the class and you are friends with Kabir. You have to place a mirror (point size)  in the front wall of the class so that Kabir can have a glimpse of Tara's smile.\nConsider the front wall as x-axis . You are given the  coordinates of position of Kabir (x1,y1)$(x1,y1)$ and Tara  (x2,y2)$(x2,y2)$. Find the position where the mirror should be placed. \n\n-----Input:-----\n- First line will contain T$T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains two integers x1,y1$x1, y1$.\n- Second line of each testcase contains two integers x2,y2$x2, y2$. \n\n-----Output:-----\nFor each testcase, print the x-coordinate of the mirror. Absolute error of 10−2$10^{−2}$ is allowed.\n\n-----Constraints:-----\n- 1≤T≤1000$1 \\leq T \\leq 1000$\n- 1≤x1,y1,x2,y2≤105$1 \\leq x1,y1,x2,y2 \\leq 10^5 $\n\n-----Sample Input:-----\n1\n1 1\n\n4 4\n\n-----Sample Output:-----\n1.60\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n-- Not vertical\n\n-- Avoid division by zero", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Float) : Float :=\nsorry\n\ndef IsFinite (x : Float) : Prop := sorry\n\ndef find_mirror_position (x1 y1 x2 y2 : Float) : Float :=\n  sorry", "vc-theorems": "theorem valid_mirror_position_basic_properties\n  (x1 y1 x2 y2 : Float)\n  (h1 : abs (x2 - x1) > 1e-6)\n  (h2 : abs (y2 + y1) > 1e-6)\n  : IsFinite (find_mirror_position x1 y1 x2 y2) := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_000879", "vc-description": "/-\nThe most dangerous cyborg Jenish is finally entrapped on a narrow bridge over a valley. The bridge is $N$ meters long. For convenience, position $i$ represents a portion of bridge between whose left border is at distance $i-1$ meters from left end and right border is at distance $i$ meters from left end. \nThere are $N$ batteries placed at positions $1,2...N$. The $i^{th}$ one has energy $a[i]$.\nThere are two tanks of strength $X$ at positions $0$ and $N+1$. Initially Jenish has $0$ energy.\nFrom now at any second $t$ starting from $1$, \nfirst, Jenish can select any battery placed at position $i$ such that $(t \\leq i \\leq N-t+1)$ and add $a[i]$ to his energy (every battery can be used atmost once).\nThen both the tanks move one meter towards each other. If there are still any batteries present at positions where the tanks are heading, the battery gets destroyed. \nAt any moment if Jenish's total energy is greater than or equal to $X$, he destroys both the tanks and he escapes the cops. If by the end of $\\lfloor \\frac {(n+1)}{2}\\rfloor^{th}$ second, he can't destroy the tanks, he himself gets destroyed. Find out if he can escape.\n\n-----Input:-----\n- The first line consists of a single integer $T$, the number of test cases.\n- The first line of each test case contains two space separated integers which represents $N$ and $X$ for that test case respectively.\n- The second line of each test case contains $N$ space separated integers, $i^{th}$ of which represents $a[i]$.\n\n-----Output:-----\nFor each test case, print in a single line, $YES$ if Jenish can escape or $NO$ if he gets destroyed.\n\n-----Constraints:-----\n- $1 \\leq  X \\leq 10^9$\n- $0 \\leq a[i] \\leq 10^6$\n- $ 1 \\leq N \\leq 10^5$\n- $\\Sigma$ $N$ over all the test cases does not exceed $10^5$\n\n-----Sample Input:-----\n3\n4 8\n5 1 4 2\n3 4\n3 1 2\n2 7\n5 5\n\n-----Sample Output:-----\nYES\nYES\nNO\n\n-----Explanation-----\nFor test $1$, in the 1st second, first Jenish will select battery at index $1$ and then the tanks from either side will move one meter closer, thus destroying the battery at index $4$.Then, in the next second, Jenish will select battery at index $3$.Then,tanks will move one meter closer again to destroy the remaining battery at index $2$.But now, Jenish has a total energy of $9$ units which is more than enough to destroy the tanks.\nFor test $2$, Jenish can use batteries at index $1$ and $2$ to get a total energy of $4$ units.\nFor test $3$, Jenish can use batteries at index $1$ or $2$ and get a maximum of $5$ units of energy which is less than required.\n-/", "vc-preamble": "def max : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (max xs)", "vc-helpers": "", "vc-definitions": "def sum : List Nat → Nat\n| [] => 0\n| (x::xs) => x + sum xs\n\ndef can_cyborg_escape (n : Nat) (target : Nat) (powers : List Nat) : Bool :=\nsorry\n\ndef reverse : List Nat → List Nat :=\nsorry", "vc-theorems": "theorem target_less_than_max_always_possible\n  (powers : List Nat) (target : Nat) (h1 : powers ≠ []) :\n  target ≤ max powers → can_cyborg_escape (powers.length) target powers = true := by\nsorry\n\ntheorem target_greater_than_sum_impossible\n  (powers : List Nat) (extra : Nat) (h1 : powers ≠ []) :\n  let target := sum powers + extra + 1\n  can_cyborg_escape (powers.length) target powers = false := by\nsorry\n\ntheorem symmetric_input\n  (powers : List Nat) (h1 : powers ≠ []) :\n  let target := sum powers / 2\n  can_cyborg_escape (powers.length) target powers =\n    can_cyborg_escape (powers.length) target (reverse powers) := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 4 8 [5, 1, 4, 2]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 3 4 [3, 1, 2]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval can_cyborg_escape 2 7 [5, 5]"}
{"id": "fvapps_000882", "vc-description": "/-\nThe annual snake festival is upon us, and all the snakes of the kingdom have gathered to participate in the procession. Chef has been tasked with reporting on the procession, and for this he decides to first keep track of all the snakes. When he sees a snake first, it'll be its Head, and hence he will mark a 'H'. The snakes are long, and when he sees the snake finally slither away, he'll mark a 'T' to denote its tail. In the time in between, when the snake is moving past him, or the time between one snake and the next snake, he marks with '.'s.\nBecause the snakes come in a procession, and one by one, a valid report would be something like \"..H..T...HTH....T.\", or \"...\", or \"HT\", whereas \"T...H..H.T\", \"H..T..H\", \"H..H..T..T\" would be invalid reports (See explanations at the bottom).\nFormally, a snake is represented by a 'H' followed by some (possibly zero) '.'s, and then a 'T'. A valid report is one such that it begins with a (possibly zero length) string of '.'s, and then some (possibly zero) snakes between which there can be some '.'s, and then finally ends with some (possibly zero) '.'s.\n\nChef had binged on the festival food and had been very drowsy. So his report might be invalid. You need to help him find out if his report is valid or not.\n\n-----Input-----\n- The first line contains a single integer, R, which denotes the number of reports to be checked. The description of each report follows after this.\n- The first line of each report contains a single integer, L, the length of that report.\n- The second line of each report contains a string of length L. The string contains only the characters '.', 'H', and 'T'.\n\n-----Output-----\n- For each report, output the string \"Valid\" or \"Invalid\" in a new line, depending on whether it was a valid report or not.\n\n-----Constraints-----\n- 1 ≤ R ≤ 500\n- 1 ≤ length of each report ≤ 500\n\n-----Example-----\nInput:\n6\n18\n..H..T...HTH....T.\n3\n...\n10\nH..H..T..T\n2\nHT\n11\n.T...H..H.T\n7\nH..T..H\n\nOutput:\nValid\nValid\nInvalid\nValid\nInvalid\nInvalid\n\n-----Explanation-----\n\"H..H..T..T\" is invalid because the second snake starts before the first snake ends, which is not allowed.\n\".T...H..H.T\" is invalid because it has a 'T' before a 'H'. A tail can come only after its head.\n\"H..T..H\" is invalid because the last 'H' does not have a corresponding 'T'.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_valid_snake_procession (report : String) : String :=\nsorry\n\ndef is_valid_segment (s₁ s₂ : Char) : Bool :=\nsorry", "vc-theorems": "theorem valid_snake_formations (report : String) :\n  (∀ i j : String.Pos, j.1 = i.1 + 1 →\n    (report.get i = '.' ∨ (report.get i = 'H' ∧ report.get j = 'T'))) →\n  check_valid_snake_procession report = \"Valid\" :=\nsorry\n\ntheorem balanced_counts_if_valid (report : String) :\n  check_valid_snake_procession report = \"Valid\" →\n  let h_count := report.toList.filter (· = 'H') |>.length\n  let t_count := report.toList.filter (· = 'T') |>.length\n  h_count = t_count :=\nsorry\n\ntheorem running_count_bounds_if_valid (report : String) (n : Nat) :\n  check_valid_snake_procession report = \"Valid\" →\n  n ≤ report.length →\n  let h_count := (report.take n).toList.filter (· = 'H') |>.length\n  let t_count := (report.take n).toList.filter (· = 'T') |>.length\n  let count := h_count - t_count\n  count ≥ 0 ∧ count ≤ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"..H..T...HTH....T.\"\n\n/--\ninfo: 'Invalid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"H..H..T..T\"\n\n/--\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"HT\""}
{"id": "fvapps_000887", "vc-description": "/-\nk kids seem to have visited your home for the festival. It seems like the kids\nhad all been fighting with each other, so you decided to keep them as far as\npossible from each other. You had placed n chairs on the positive number line,\neach at position x i , 1 ≤ i ≤ n. You can make the kids sit in any of the chairs.\nNow you want to know the largest possible minimum distance between each kid.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains two lines. First line contains two space separated integers n and k. Second line contains n space separated values, x1, x2, x3, … ,xn.\n\n-----Output:-----\nFor each test case print the largest possible minimum distance.\n\n-----Sample Input:-----\n1\n\n2 2\n\n1 2    \n\n-----Sample Output:-----\n1  \n\n-----Constraints-----\n- $2 \\leq n \\leq 100000$\n- $0 \\leq xi \\leq 10^9$\n- $k \\leq n $\n-/\n\n-- Helper functions for max/min\n\n-- Non-negative result\n\n-- Evenly spaced points\n\n-- Result bounded by max distance\n\n-- Special case for k=2\n\n-- Sorting invariance\n\n-- Evenly spaced integers\n\n-- simplified for theorem statement", "vc-preamble": "def listMax (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => List.foldl max h t\n\ndef listMin (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | (h::t) => List.foldl min h t\n\ndef listToSorted (xs : List Int) : List Int :=\n  match xs with\n  | [] => []\n  | (h::t) => h :: t\n\ndef generateRange (n : Nat) : List Int :=\n  List.map Int.ofNat (List.range n)", "vc-helpers": "", "vc-definitions": "def find_max_min_distance (n k : Nat) (x : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_min_distance_nonneg\n    {n k : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n)\n    (h4 : x.length = n)\n    (h5 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x ≥ 0 :=\nsorry\n\ntheorem find_max_min_distance_bounded\n    {n k : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n)\n    (h4 : x.length = n)\n    (h5 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x ≤ listMax x - listMin x :=\nsorry\n\ntheorem find_max_min_distance_k2\n    {n : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : x.length = n)\n    (h3 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x ≤ listMax x - listMin x :=\nsorry\n\ntheorem find_max_min_distance_sort_invariant\n    {n : Nat} {x : List Int}\n    (h1 : n ≥ 2)\n    (h2 : x.length = n)\n    (h3 : ∀ i ∈ x, i ≥ 1 ∧ i ≤ 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x = find_max_min_distance n 2 (listToSorted x) :=\nsorry\n\ntheorem find_max_min_distance_evenly_spaced\n    {n k : Nat}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 2)\n    (h3 : k ≤ n) :\n    find_max_min_distance n k (generateRange n) = (n-1) / (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_min_distance 2 2 [1, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 5 3 [1, 2, 8, 4, 9]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 4 2 [1, 2, 3, 4]"}
{"id": "fvapps_000888", "vc-description": "/-\nSalmon runs a fish delivery company in Fish City. Fish City has $N$ vertical roads numbered $1, 2, ..., N$ from left to right, each spaced 1 unit apart; similarly, there are $M$ horizontal roads numbered $1, 2, ..., M$ from bottom to top, each spaced 1 unit apart. We will denote the intersection between the $x$-th vertical road and the $y$-th horizontal road as $(x, y)$. \nSalmon has to make $K$ deliveries, with the $i$-th delivery starting at $(x_i, y_i)$ and ending at $(x'_i, y'_i)$. He can also travel every road with speed $0.5$ (meaning it would take him $2$ units of time to travel $1$ unit of distance). However, Salmon can bribe the mayor of Fish City and make the mayor change exactly one horizontal road to a highway, meaning the speed on that road would increase to $1$.\nHe wants to choose a road to be a highway such that the sum of durations of all the deliveries is minimum possible. Help him find this minimum sum!\nNote that each delivery starts exactly at $(x_i, y_i)$ and ends at $(x'_i, y'_i)$, i.e., we don't count the time taken to travel from $(x'_{i-1}, y'_{i-1})$ to $(x_i, y_i)$ in our answer.\n\n-----Input:-----\nThe first line contains 3 integers, $N$, $M$ and $K$ ($1 \\le N, M, K \\le 10^5$).\nThe next $K$ lines describe deliveries. Each line contains 4 space-separated integers $x_i$, $y_i$, $x'_i$, $y'_i$ ($1 \\le x_i, x'_i \\le N$, $1 \\le y_i, y'_i \\le M$), describing the $i$-th delivery.\n\n-----Output:-----\nPrint one integer -- the minimum sum of durations possible.\n\n-----Subtasks-----\n- Subtask 1 [17 points]: $y_i = y_{i-1}$ for all $i>0$. \n- Subtask 2 [34 points]: $K \\le 10$.\n- Subtask 3 [49 points]: No additional constraints.\n\n-----Sample Input 1:-----\n5 4 3\n2 3 4 1\n1 4 5 2\n3 3 5 3\n\n-----Sample Output 1:-----\n16\n\n-----Explanation:-----\n\nSalmon can turn the 3rd horizontal road into a highway.\n- For the first delivery, we can go 2 units to the right taking 2 units of time, and 2 units down taking 4 units of time. The time taken is $2 + 4 = 6$.\n- For the second delivery, we can go 1 unit down taking 2 units of time, 4 units right taking 4 units of time, and 1 unit down taking 2 units of time. The time taken is $2 + 4 + 2 = 8$.\n- For the third delivery, we can go 2 units right taking 2 units of time.\nTherefore, the total time taken is $6 + 8 + 2 = 16$.\n\n-----Sample Input 2:-----\n10 2 3\n1 2 10 2\n2 1 9 1\n4 1 7 1\n\n-----Sample Output 2:-----\n23\n\n-----Explanation:-----\n\nSalmon can turn the 1st horizontal road into a highway.\n- For the first delivery, we can go 1 unit down taking 2 units of time, 9 units right taking 9 units of time, and 1 unit up taking 2 units of time. The time taken is $2 + 9 + 2 = 13$.\n- For the second delivery, we can go 7 units right taking 7 units of time.\n- For the third delivery, we can go 3 units to the right taking 3 units of time.\nTherefore, the total time taken is $13 + 7 + 3 = 23$.\n-/", "vc-preamble": "def fst_minus (a b : Nat) : Nat :=\n  if a ≥ b then a - b else b - a", "vc-helpers": "", "vc-definitions": "def abs (n : Nat) : Nat :=\nsorry\n\ndef list_sum (l : List Nat) : Nat :=\nsorry\n\ndef min_delivery_time (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem min_delivery_time_non_negative (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) :\n  min_delivery_time n m k deliveries ≥ 0 :=\nsorry\n\ntheorem min_delivery_time_same_point (n : Nat) :\n  let m := n\n  let deliveries := [(1,1,1,1)]\n  min_delivery_time n m 1 deliveries = 0 :=\nsorry\n\ntheorem min_delivery_time_bounded (n m k : Nat) (deliveries : List (Nat × Nat × Nat × Nat)) :\n  min_delivery_time n m k deliveries ≤\n    list_sum (deliveries.map (fun (d: Nat × Nat × Nat × Nat) =>\n      let (x1, y1, x2, y2) := d\n      2 * (fst_minus x1 x2 + fst_minus y1 y2))) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_delivery_time 5 4 3 [[2, 3, 4, 1], [1, 4, 5, 2], [3, 3, 5, 3]]\n\n/--\ninfo: 23\n-/\n#guard_msgs in\n#eval min_delivery_time 10 2 3 [[1, 2, 10, 2], [2, 1, 9, 1], [4, 1, 7, 1]]"}
{"id": "fvapps_000891", "vc-description": "/-\nYou are given an array of N integers a1, a2, ..., aN and an integer K. Find the number of such unordered pairs {i, j} that \n\n- i ≠ j\n- |ai + aj - K| is minimal possible\n\nOutput  the minimal possible value of |ai + aj - K| (where i ≠ j) and the number of such pairs for the given array and the integer K.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case consists of two space separated integers - N and K respectively.\n\nThe second line contains N single space separated integers - a1, a2, ..., aN respectively.\n\n-----Output-----\nFor each test case, output a single line containing two single space separated integers - the minimal possible value of |ai + aj - K| and the number of unordered pairs {i, j} for which this minimal difference is reached.\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 50\n- 1 ≤ ai, K ≤ 109\n- N = 2 - 31 point.\n- 2 ≤ N ≤ 1000 - 69 points.\n\n-----Example-----\nInput:\n1   \n4 9\n4 4 2 6\n\nOutput:\n1 4\n\n-----Explanation:-----\nThe minimal possible absolute difference of 1 can be obtained by taking the pairs of a1 and a2, a1 and a4, a2 and a4, a3 and a4.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_min_pairs (n : Nat) (k : Int) (arr : List Int) : Int × Nat :=\n  sorry\n\ndef count_pairs_with_diff (arr : List Int) (k : Int) (min_diff : Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_min_pairs_nonneg_diff (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  min_diff ≥ 0 := by\n  sorry\n\ntheorem solve_min_pairs_positive_count (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (_, count) := solve_min_pairs n k arr\n  count > 0 := by\n  sorry\n\ntheorem solve_min_pairs_count_accurate (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, count) := solve_min_pairs n k arr\n  count_pairs_with_diff arr k min_diff = count := by\n  sorry\n\ntheorem solve_min_pairs_minimal (n : Nat) (k : Int) (arr : List Int)\n  (h1: n ≥ 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  ∀ i j, 0 ≤ i ∧ i < n ∧ j > i ∧ j < n →\n    let diff := arr[i]! + arr[j]! - k\n    if diff ≥ 0 then diff ≥ min_diff else -diff ≥ min_diff := by\n  sorry\n\ntheorem solve_min_pairs_permutation_invariant (n : Nat) (k : Int) (arr1 arr2 : List Int)\n  (h1: n ≥ 2) (h2: arr1.length = n) (h3: arr2.length = n)\n  (h4: arr2.Perm arr1) :\n  solve_min_pairs n k arr1 = solve_min_pairs n k arr2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: (1, 4)\n-/\n#guard_msgs in\n#eval solve_min_pairs 4 9 [4, 4, 2, 6]\n\n/--\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_min_pairs 2 10 [3, 5]\n\n/--\ninfo: (4, 3)\n-/\n#guard_msgs in\n#eval solve_min_pairs 3 12 [4, 4, 4]"}
{"id": "fvapps_000902", "vc-description": "/-\nBeing a crewmate in the Among Us game, you will have to solve a task to win against the imposter. \nThe task : You are given a certain number of bulbs(Say n) which are initially in OFF position. \nThe bulbs are numbered from 1 to n. There will be n current fluctuations in such a way that in the 1st fluctuation all bulbs are toggled, in the 2nd fluctuation every 2nd bulb is toggled, in the 3rd fluctuation every 3rd bulb is toggled and so on.\nYour job as a crewmate is to find the number of bulbs which are ON at the end of n fluctuations. But, the imposter has a special power which alerts it when a bulb with a number divisible by 3 is kept ON at the end of n fluctuations. \nSo, you will have to switch off the bulbs with numbers divisible by 3 and give the final result to complete the task and win the game.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, an integer $n$. \n\n-----Output:-----\n- For each testcase, output a single integer - the number of bulbs that will remain ON after $n$ fluctuations.\n\n-----Constraints :-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq n \\leq 10^9$\n\n-----Sample Input:-----\n2\n2\n20\n\n-----Sample Output:-----\n1\n\n3\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_bulb_fluctuations (n: Nat) : Nat :=\n  sorry\n\ndef sqrt (n: Nat) : Nat :=\n  sorry\n\ndef countSquaresNotDiv3 (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_non_negative (n: Nat) :\n  solve_bulb_fluctuations n ≥ 0 :=\nsorry\n\ntheorem output_less_than_input (n: Nat) :\n  solve_bulb_fluctuations n ≤ n :=\nsorry\n\ntheorem matches_edge_cases_0 :\n  solve_bulb_fluctuations 0 = 0 :=\nsorry\n\ntheorem matches_edge_cases_1 :\n  solve_bulb_fluctuations 1 = 1 :=\nsorry\n\ntheorem matches_edge_cases_2 :\n  solve_bulb_fluctuations 2 = 1 :=\nsorry\n\ntheorem matches_edge_cases_3 :\n  solve_bulb_fluctuations 3 = 1 :=\nsorry\n\ntheorem matches_edge_cases_9 :\n  solve_bulb_fluctuations 9 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 20\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 100"}
{"id": "fvapps_000904", "vc-description": "/-\nConsider the following $4 \\times 4$ pattern:\n1  2  4  7\n3  5  8 11\n6  9 12 14\n10 13 15 16\n\nYou are given an integer $N$. Print the $N \\times N$ pattern of the same kind (containing integers $1$ through $N^2$).\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single integer $N$.\n\n-----Output-----\nFor each test case, print $N$ lines; each of them should contain $N$ space-separated integers.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le N \\le 100$\n\n-----Subtasks-----\nSubtask #1 (100 points): Original constraints\n\n-----Example Input-----\n1\n4\n\n-----Example Output-----\n1 2 4 7\n3 5 8 11\n6 9 12 14\n10 13 15 16\n\n-----Explanation-----\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_pattern (n : Nat) : List (List Nat) :=\n  sorry\n\ndef sumRange (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem triangle_numbers (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  ∀ i, i < n → (pattern.get! i).get! 0 = sumRange 1 (i+2) :=\nsorry\n\ntheorem pattern_differences (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  ∀ i j, i < n → j + 1 < (pattern.get! i).length →\n    let row := pattern.get! i\n    let diff := row.get! (j+1) - row.get! j\n    if j + i + 1 < n\n      then diff = j + i + 1\n      else diff = 2*n - (j + i + 1) - 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000923", "vc-description": "/-\nIIST is thinking of acquiring some land nearby to build its new state of the art labs. The land it has chosen incidentaly has some abandoned college buildings which IIST wants to use. The administration decide the value of the building based on the amount of work that has to be done to get it in shape (lower amount of work, higher value). The security experts want to tear down some of the buildings and use the bricks to build a boundary wall. \n\nThe director has chosen you to write a program which determines the buildings which needs to be demolished to maximise the value while fulfilling the above criterion. \n\nInput Format: \n\nThe first line contains the number of test cases, T.\n\nThe next T cases contains information about hypothetical plots.\n\nEach test case starts with a single integer n, 2 ≤ n ≤ 15, the number of abandoned buildings in the plot. The buildings are identified by consecutive integers 1 to n. Each of the subsequent lines contains 4 integers x_i , y_i , v_i , l_i that describe a single building. (x_i, y_i) is the position of the building in the plane, v_i is its value, and l_i is the length of boundary wall that can be built using the bricks from the building. v_i and l_i are between 0 and 10,000.\n\nOutput Format:\n\nFor each test case, compute a subset of the buildings such that, using the bricks from the buildings from that subset, the remaining buildings can be enclosed in a single boundary. Find the subset with a minimum value. If more than one such minimum-value subset exists, choose one with the smallest number of buildings. \n\nDisplay, as shown below, the identity of each building to be demolished, and the length of the excess boundary (accurate to two fractional digits).\n\nSample Input:  \n\n2\n\n6\n\n0 0 8 3\n\n1 4 3 2\n\n2 1 7 1\n\n4 1 2 3\n\n3 5 4 6\n\n2 3 9 8\n\n3\n\n3 0 10 2\n\n5 5 20 25\n\n7 -3 30 32\n\nSample Output: \n\n2 4 5\n\n3.16\n\n2\n\n15.00\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Building := Int × Int × Int × Int\n\ndef av (buildings : List Building) : Int :=\n  sorry\n\ndef val (buildings : List Building) : Int :=\n  sorry\n\ndef diff (l1 l2 : List Building) : List Building :=\n  sorry", "vc-theorems": "theorem av_nonnegative (buildings : List Building) :\n  av buildings ≥ 0 :=\nsorry\n\ntheorem val_nonnegative (buildings : List Building) :\n  val buildings ≥ 0 :=\nsorry\n\ntheorem av_sum_fourth (buildings : List Building) :\n  av buildings = buildings.foldl (λ acc b => acc + b.2.2.2) 0 :=\nsorry\n\ntheorem val_sum_third (buildings : List Building) :\n  val buildings = buildings.foldl (λ acc b => acc + b.2.2.1) 0 :=\nsorry\n\ntheorem diff_properties (l1 l2 : List Building) :\n  ∀ x ∈ diff l1 l2, x ∈ l1 ∧ x ∉ l2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000928", "vc-description": "/-\nYou are given a convex polygon $P$ with vertices $P_0, P_1, \\ldots, P_{n-1}$, each having integer coordinates. On each edge $P_{i} P_{(i+1) \\% n}$ of the polygon, choose a point $R_i$ uniformly at random. What is the expected area of the convex hull of these $n$ chosen points $R_0, R_1, \\ldots R_{n-1}$ ?\n\n-----Note-----\n- Consider the area of the convex hull as zero if it contains less than 3 vertices.\n- All the points $R_i$ are chosen independently of each other.\n- Your answer is considered correct if and only if its absolute or relative error doesn't exceed $10^{-6}$.\n\n-----Input-----\n- The first line contains $n$, the number of vertices in the convex polygon.\n- The next $n$ lines contain the coordinates of the vertices of the polygon in anti-clockwise order. \n\n-----Output-----\nFor each testcase, print the expected area of the convex hull of the $n$ randomly chosen points.\n\n-----Constraints-----\n- $3 \\leq n \\leq 10^5$\n- The absolute values of all the coordinates $\\leq 10^7$.\n- All the points in the input are distinct.\n- The described polygon $P$ is convex and the vertices of the polygon are given in anti-clockwise order. Also, no three vertices of the polygon are collinear.\n\n-----Example Input-----\n3\n0 0\n1 0\n0 1\n\n-----Example Output-----\n0.1250000000\n-/\n\n/- Helper function to get the minimum value from a list -/\n\n/- Helper function to get the maximum value from a list -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def list_max (xs : List Float) : Float :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl max x\n\ndef list_min (xs : List Float) : Float :=\n  match xs with\n  | [] => 0\n  | x::xs => xs.foldl min x", "vc-helpers": "", "vc-definitions": "def Point := Float × Float\n\ndef calc_expected_area (n: Nat) (vertices: List Point) : Float :=\n  sorry", "vc-theorems": "theorem area_is_non_negative {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  calc_expected_area n vertices ≥ 0 :=\nsorry\n\ntheorem area_smaller_than_bounding_box {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  let xs := vertices.map (·.1)\n  let ys := vertices.map (·.2)\n  calc_expected_area n vertices ≤ (list_max xs - list_min xs) * (list_max ys - list_min ys) + 1e-10 :=\nsorry\n\ntheorem area_invariant_under_translation {n: Nat} {vertices: List Point}\n  {dx dy: Float} :\n  vertices.length = n → n ≥ 3 →\n  let translated := vertices.map (fun (x, y) => (x + dx, y + dy))\n  (calc_expected_area n vertices - calc_expected_area n translated).abs < 1e-10 :=\nsorry\n\ntheorem area_scales_quadratically {n: Nat} {vertices: List Point} :\n  vertices.length = n → n ≥ 3 →\n  let scaled := vertices.map (fun (x, y) => (2*x, 2*y))\n  (calc_expected_area n scaled - 4 * calc_expected_area n vertices).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000939", "vc-description": "/-\nYou are given a rooted tree on N vertices. The nodes are numbered from 1 to N, and Node 1 is the root. Each node u has an associated value attached to it: Au.\nFor each vertex v, we consider the path going upwards from v to the root. Suppose that path is v1, v2, .., vk, where v1 = v and vk = 1. The cost of any node on this path is equal to the minimum value among all the nodes to its left in the path sequence, including itself. That is, cost(vi) = min1 <= j <= i{Avj}. And the cost of the path is the sum of costs of all the nodes in it.\nFor every node in the tree, find the cost of the path from that node to the root.\n\n-----Input-----\n- The first line of the input contains a single integer, N, denoting the number of nodes in the tree.\n- The next line contains N-1 integers, the i-th of which denotes the parent of node i+1.\n- The next line contains N integers, the i-th of which denotes Ai.\n\n-----Output-----\nOutput a single line containing N integers, the i-th of which should be the cost of the path from node i to the root.\n\n-----Constraints-----\n- 1 ≤ N ≤ 100,000\n- -1,000,000,000 ≤ Av ≤ 1,000,000,000\n\n-----Subtasks-----\n- Subtask #1 (30 points): 1 ≤ N ≤ 2000\n- Subtask #2 (70 points): Original constraints.\n\n-----Example-----\nInput:\n8\n1 1 1 1 5 8 6\n1 2 3 4 5 15 70 10\n\nOutput: \n1 3 4 5 6 21 96 26\n\n-----Explanation-----\nFor example, take a look at the path from vertex 7: The path is 7 -> 8 -> 6 -> 5 -> 1.\nCost(7) has no choice but to be A7. So Cost(7) = 70.\nCost(8) will be minimum of A7 and A8, which turns out to be A8. So Cost(8) = 10.\nCost(6) = minimum {A7, A8, A6} = minimum {70, 10, 15} = 10.\nCost(5) = minimum {70, 10, 15, 5} = 5.\nCost(1) = minimum {70, 10, 15, 5, 1} = 1. \nSo, the cost of the path from 7 to the root is 70 + 10 + 10 + 5 + 1 = 96.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_path_costs (n: Nat) (parents: List Nat) (values: List Nat) : List Nat :=\n  sorry\n\ndef is_valid_tree (n: Nat) (parents: List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem output_length_matches_input\n  (n: Nat) (values: List Nat) (parents: List Nat) :\n  (n > 0) →\n  (n > values.length → True) →\n  (parents = List.replicate (n-1) 1) →\n  (calculate_path_costs n parents (values.take n)).length = n :=\nsorry\n\ntheorem path_costs_increase_with_depth\n  (n: Nat) (parent_nodes: List Nat) (values: List Nat) :\n  (n ≥ 2) →\n  (parent_nodes.length = n-1) →\n  (values.length ≥ n) →\n  (is_valid_tree n parent_nodes = true) →\n  ∀ i, i ≥ 1 → i < n →\n    let result := calculate_path_costs n parent_nodes (values.take n)\n    result.length = n →\n    (i-1) < parent_nodes.length →\n    parent_nodes[i-1]! - 1 < result.length →\n    result[i]! ≥ result[parent_nodes[i-1]! - 1]! :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000943", "vc-description": "/-\n-----\nHALLOWEEN EVE\n-----\n\nIn some other world, today is Halloween Eve.There are N trees planted in Mr. Smith’s\ngarden. The height of the i-th tree (1≤i≤N) is h i meters.\nHe decides to choose K trees from these trees and decorate them with electric lights.\nTo make the scenery more beautiful, the heights of the decorated trees should be as\nclose to each other as possible.\n\nMore specifically, let the height of the tallest decorated tree be hmax meters, and the\nheight of the shortest decorated tree be hmin meters.\nThe smaller the value hmax−hmin is, the better. What is the minimum possible value of\nhmax−hmin?\n\n-----Constraints-----\n\n\t    2≤K< N ≤105 \n\n1≤hi≤109\n\nhi is an integer\n\n-----Input Format-----\n\nInput is given from Standard Input in the following format:\n\nN K \n\nh1 \n\nh2 \n\n: \n\nhN\n\n-----Output-----\n\nPrint the minimum possible value of hmax−hmin.\n\n-----Example Text Case-----\nInput:\n\n5 3\n10\n15\n11\n14\n12\n\nOutput:\n\n2\n\nExplanation\n\nIf we decorate the first, third and fifth trees, hmax=12,hmin=10 so hmax−hmin=2. This is\noptimal.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.maximum (l : List Int) : Int :=\nsorry\n\ndef List.minimum (l : List Int) : Int :=\nsorry\n\ndef List.sort (l : List Int) : List Int :=\nsorry\n\ndef find_min_height_diff (n : Nat) (k : Nat) (heights : List Int) : Int :=\nsorry", "vc-theorems": "theorem find_min_height_diff_single_window {n : Nat} {heights : List Int}\n  (h1 : heights.length > 0)\n  (h2 : heights.length = n)\n  : find_min_height_diff n 1 heights = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_height_diff 5 3 [10, 15, 11, 14, 12]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_height_diff 4 2 [4, 2, 1, 3]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval find_min_height_diff 6 4 [5, 10, 15, 20, 25, 30]"}
{"id": "fvapps_000944", "vc-description": "/-\nYou are given an $array$ of size $N$ and an integer $K$ ( $N > 1 , K > 0$ ).\nEach element in the array can be incremented by $K$ or decremented by $K$ $at$ $most$ $once$.\nSo there will be  $3^n$ possible combinations of final array. (As there are 3 options for every element).\n\nOut of these combinations, you have to select a combination, in which the $absolute$ difference between the largest and the smallest element is $maximum$.\nYou have to print the $maximum$ $absolute$ $difference$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a two lines of input\n- First line contains two integers $N, K$. \n- Second line contains $N$ space separated integers.\n\n-----Output:-----\nFor each testcase, output the maximum absolute difference that can be achieved on a new line.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $2 \\leq N \\leq 1000$\n- $1 \\leq K , arr[i]  \\leq 10000$\n$NOTE$:  Large  input files, Use of fastio is recommended.\n\n-----Sample Input:-----\n2\n\n4 3\n\n4 2 5 1\n\n3 5\n\n2 5 3\n\n-----Sample Output:-----\n10\n\n13\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_diff (N : Nat) (K : Nat) (arr : List Int) : Int :=\nsorry\n\ndef list_max (arr : List Int) : Int :=\nsorry\n\ndef list_min (arr : List Int) : Int :=\nsorry\n\ndef list_sort (arr : List Int) : List Int :=\nsorry", "vc-theorems": "theorem find_max_diff_non_negative (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr ≥ 0 :=\nsorry\n\ntheorem find_max_diff_reverse_invariant (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr = find_max_diff N K arr.reverse :=\nsorry\n\ntheorem find_max_diff_single_element (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length = 1) :\n  find_max_diff N K arr = 2 * K :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_diff 4 3 [4, 2, 5, 1]\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval find_max_diff 3 5 [2, 5, 3]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_diff 2 2 [1, 3]"}
{"id": "fvapps_000952", "vc-description": "/-\nChef is very fond of horses. He enjoys watching them race. As expected, he has a stable full of horses. He, along with his friends, goes to his stable during the weekends to watch a few of these horses race. Chef wants his friends to enjoy the race and so he wants the race to be close. This can happen only if the horses are comparable on their skill i.e. the difference in their skills is less.\nThere are N horses in the stable. The skill of the horse i is represented by an integer S[i]. The Chef needs to pick 2 horses for the race such that the difference in their skills is minimum. This way, he would be able to host a very interesting race. Your task is to help him do this and report the minimum difference that is possible between 2 horses in the race.\n\n-----Input:-----\nFirst line of the input file contains a single integer T, the number of test cases.\n\nEvery test case starts with a line containing the integer N.\n\nThe next line contains N space separated integers where the i-th integer is S[i].\n\n-----Output:-----\nFor each test case, output a single line containing the minimum difference that is possible.\n\n-----Constraints:-----\n1 ≤ T ≤ 10\n2 ≤ N ≤ 5000\n1 ≤ S[i] ≤ 1000000000\n\n-----Example:-----Input:\n1\n5\n4 9 1 32 13\n\nOutput:\n3\n\nExplanation: The minimum difference can be achieved if we pick horses with skills 1 and 4 for the race.\n-/\n\n-- Result is non-negative\n\n-- Result is at most the range of skills\n\n-- Result is at most any adjacent difference in sorted elements\n\n-- Result is invariant under list reordering\n\n-- n must match list length", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_horse_skill_diff (n : Nat) (skills : List Nat) : Nat :=\nsorry\n\ndef list_max (l : List Nat) : Nat :=\nsorry\n\ndef list_min (l : List Nat) : Nat :=\nsorry\n\ndef list_sort (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem min_horse_skill_diff_nonneg {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) :\n  min_horse_skill_diff n skills ≥ 0 :=\nsorry\n\ntheorem min_horse_skill_diff_le_range {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) :\n  min_horse_skill_diff n skills ≤ list_max skills - list_min skills :=\nsorry\n\ntheorem min_horse_skill_diff_le_adjacent {n : Nat} {skills : List Nat} {i : Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2) (h3 : i < skills.length - 1) :\n  min_horse_skill_diff n skills ≤\n    (list_sort skills).get! (i+1) - (list_sort skills).get! i :=\nsorry\n\ntheorem min_horse_skill_diff_order_inv {n : Nat} {skills shuffled : List Nat}\n  (h : skills.length = n) (h2 : skills.length ≥ 2)\n  (h3 : list_sort skills = list_sort shuffled) :\n  min_horse_skill_diff n skills = min_horse_skill_diff n shuffled :=\nsorry\n\ntheorem min_horse_skill_diff_invalid {n : Nat} {skills : List Nat}\n  (h : skills.length ≠ n) :\n  min_horse_skill_diff n skills = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 5 [4, 9, 1, 32, 13]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 3 [4, 5, 6]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 4 [1, 10, 100, 1000]"}
{"id": "fvapps_000956", "vc-description": "/-\nThis problem is about sequences of positive integers $a_1,a_2,...,a_N$. A subsequence of a sequence is anything obtained by dropping some of the elements. For example, $3,7,11,3$ is a subsequence of $6,3,11,5,7,4,3,11,5,3$ , but $3,3,7$ is not a subsequence of $6,3,11,5,7,4,3,11,5,3$ .\nA fully dividing sequence is a sequence $a_1,a_2,...,a_N$ where $a_i$ divides $a_j$ whenever $i < j$. For example, $3,15,60,720$ is a fully dividing sequence.\nGiven a sequence of integers your aim is to find the length of the longest fully dividing subsequence of this sequence.\nConsider the sequence $2,3,7,8,14,39,145,76,320$\nIt has a fully dividing sequence of length $3$, namely $2,8,320$, but none of length $4$ or greater.\nConsider the sequence $2,11,16,12,36,60,71,17,29,144,288,129,432,993$.\nIt has two fully dividing subsequences of length $5$,\n- $2,11,16,12,36,60,71,17,29,144,288,129,432,993$ and\n- $2,11,16,12,36,60,71,17,29,144,288,129,432,993$\nand none of length $6$ or greater.\n\n-----Input:-----\nThe first line of input contains a single positive integer $N$ indicating the length of the input sequence. Lines $2,...,N+1$ contain one integer each. The integer on line $i+1$ is $a_i$.\n\n-----Output:-----\nYour output should consist of a single integer indicating the length of the longest fully dividing subsequence of the input sequence.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 10000$\n- $1 \\leq a_i \\leq 1000000000$\n\n-----Sample input 1:-----\n9\n2 \n3 \n7 \n8 \n14 \n39 \n145 \n76 \n320\n\n-----Sample output 1:-----\n3\n\n-----Sample input 2:-----\n14\n2\n11 \n16 \n12 \n36 \n60 \n71 \n17 \n29 \n144 \n288 \n129 \n432 \n993\n\n-----Sample output 2:-----\n5\n-/", "vc-preamble": "def powers_of_two : List Nat :=\n  let rec mk_powers : Nat → List Nat\n    | 0 => []\n    | n+1 => if (2^n ≤ 1000) then (2^n)::(mk_powers n) else mk_powers n\n  mk_powers 10", "vc-helpers": "", "vc-definitions": "def find_longest_dividing_subsequence (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem length_bounds {nums: List Nat}\n  (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n  (h2: nums.length > 0) :\n  1 ≤ find_longest_dividing_subsequence nums ∧\n  find_longest_dividing_subsequence nums ≤ nums.length :=\nsorry\n\ntheorem powers_of_two_sequence :\n  find_longest_dividing_subsequence powers_of_two = powers_of_two.length :=\nsorry\n\ntheorem sorted_divisible_sequence {nums: List Nat}\n  (h1: ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n  (h2: nums.length ≥ 2)\n  (h3: ∀ (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val → (nums.get j) % (nums.get i) = 0)\n  (h4: ∀ (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val → nums.get i ≤ nums.get j) :\n  find_longest_dividing_subsequence nums = nums.length :=\nsorry\n\ntheorem edge_case_singleton :\n  find_longest_dividing_subsequence [1] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 3, 7, 8, 14, 39, 145, 76, 320]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 11, 16, 12, 36, 60, 71, 17, 29, 144, 288, 129, 432, 993]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [1, 2, 4, 8]"}
{"id": "fvapps_000963", "vc-description": "/-\nJanuary and February are usually very cold in ChefLand. The temperature may reach -20 and even -30 degrees Celsius. Because of that, many people seal up windows in their houses.\nSergey also lives in ChefLand. He wants to seal the window in his house. The window has the shape of a   simple convex polygon with N vertices.\nFor the sealing, there are M kinds of sticky stripes, which are sold in the shops. The stripe of the ith type has the length of Li millimeters and the cost of Ci rubles.\nThe sealing process consists in picking the stripe and sticking it on the border of the window. The stripe can't be cut (it is made of very lasting material) and can only be put straight, without foldings. It is not necessary to put the strip strictly on the window border, it can possibly extend outside the border side of window too (by any possible amount). The window is considered sealed up if every point on its' border is covered with at least one stripe.\nNow Sergey is curious about the stripes he needs to buy. He wonders about the cheapest cost, at which he can seal his window. Please help him.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N denoting the number of number of vertices in the polygon denoting Sergey's window.\nEach of the following N lines contains a pair of space-separated integer numbers Xi Yi, denoting the coordinates of the ith points.\nThe following line contains a single integer M denoting the number of types of sticky stripe which is sold in the shop.\nEach of the following M lines contains a pair of space-separated integers Li Ci denoting the length and the cost of the sticky stripe of the ith type respectively.\n\n-----Output-----\nFor each test case, output a single line containing the minimum cost of sealing up the window.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- The coordinates of the window are given either in clockwise or in a counter-clockwise order.\n- No three or more vertices lie on the same line (i.e. are collinear).\n- 0 ≤ Xi, Yi ≤ 106\n- 1 ≤ Li, Ci ≤ 106\n\n-----Subtasks-----\n- Subtask #1 (17 points): 3 ≤ N ≤ 10,  M = 1\n- Subtask #2 (24 points): 3 ≤ N ≤ 42, M ≤ 2\n- Subtask #3 (59 points): 3 ≤ N ≤ 2000, 1 ≤ M ≤ 10\n\n-----Example-----\nInput:1\n4\n0 0\n1000 0\n1000 2000\n0 2000\n2\n1000 10\n2000 15\n\nOutput:50\n\n-----Explanation-----\nExample case 1. In this case, Sergey's window is a rectangle with the side lengths of 1000 and 2000. There are two types of the sticky stripes in the shop - the one of the length 1000 with the cost of 10 rubles and with the length of 2000 and the cost of 15 rubles. The optimal solution would be to buy 2 stripes of the first type 2 stripes of the second type. The cost will be 2 × 15 + 2 × 10 = 50 rubles.\n-/\n\n/- Signature for the main function -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidPolygon (vertices: List (Int × Int)) : Bool :=\nsorry\n\ndef calculateMinCost (vertices: List (Int × Int)) (stripes: List (Float × Int)) : Nat :=\nsorry", "vc-theorems": "theorem min_cost_positive (vertices: List (Int × Int)) (stripes: List (Float × Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  calculateMinCost vertices stripes > 0 :=\nsorry\n\ntheorem min_cost_integer (vertices: List (Int × Int)) (stripes: List (Float × Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  ∃ n: Nat, calculateMinCost vertices stripes = n :=\nsorry\n\ntheorem empty_stripes_error (vertices: List (Int × Int))\n  (h1: isValidPolygon vertices = true) :\n  ∀ result, calculateMinCost vertices [] ≠ result :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 50\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (1000, 0), (1000, 2000), (0, 2000)] [(1000, 10), (2000, 15)]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (4, 0), (2, 3)] [(5, 2)]"}
{"id": "fvapps_000967", "vc-description": "/-\nThe game of billiards involves two players knocking 3 balls around\non a green baize table. Well, there is more to it, but for our\npurposes this is sufficient.\nThe game consists of several rounds and in each round both players\nobtain a score, based on how well they played. Once all the rounds\nhave been played, the total score of each player is determined by\nadding up the scores in all the rounds and the player with the higher\ntotal score is declared the winner.\nThe Siruseri Sports Club organises an annual billiards game where\nthe top two players of Siruseri play against each other. The Manager\nof Siruseri Sports Club decided to add his own twist to the game by\nchanging the rules for determining the winner. In his version, at the\nend of each round, the cumulative score for each player is calculated, and the leader and her current lead are found. Once\nall the rounds are over the player who had the maximum lead at the\nend of any round in the game is declared the winner.\n\nConsider the following score sheet for a game with 5 rounds:\nRoundPlayer 1Player 2114082289134390110411210658890\n\nThe total scores of both players, the leader and the lead after\neach round for this game is given below:RoundPlayer 1Player 2LeaderLead114082Player 1582229216Player 1133319326Player 274431432Player 215519522Player 23\nNote that the above table contains the cumulative scores.\nThe winner of this game is Player 1 as he had the maximum lead (58\nat the end of round 1) during the game.\nYour task is to help the Manager find the winner and the winning\nlead. You may assume that the scores will be such that there will\nalways be a single winner.  That is, there are no ties.\nInput\nThe first line of the input will contain a single integer N (N\n≤ 10000) indicating the number of rounds in the game.  Lines\n2,3,...,N+1 describe the scores of the two players in the N rounds.\nLine i+1 contains two integer Si and Ti, the scores of the Player 1\nand 2 respectively, in round i.  You may assume that 1 ≤ Si ≤\n1000 and 1 ≤ Ti ≤ 1000.  \nOutput\nYour output must consist of a single line containing two integers\nW and L, where W is 1 or 2 and indicates the winner and L is the\nmaximum lead attained by the winner.\nExample\nInput:\n5\n140 82\n89 134\n90 110\n112 106\n88 90\n\nOutput:\n1 58\n-/", "vc-preamble": "def get_max_leads (rounds : List (Nat × Nat)) : Nat × Nat :=\n  rounds.foldl (fun acc r =>\n    let p1Total := acc.1 + r.1\n    let p2Total := acc.2 + r.2\n    if p1Total > p2Total\n    then (p1Total - p2Total, acc.2)\n    else (acc.1, p2Total - p1Total)\n  ) (0, 0)", "vc-helpers": "", "vc-definitions": "def find_winner_and_max_lead (rounds : List (Nat × Nat)) : Nat × Nat :=\nsorry", "vc-theorems": "theorem winner_is_valid (rounds : List (Nat × Nat)) :\n  let (winner, _) := find_winner_and_max_lead rounds\n  winner = 1 ∨ winner = 2 :=\nsorry\n\ntheorem max_lead_nonnegative (rounds : List (Nat × Nat)) :\n  let (_, maxLead) := find_winner_and_max_lead rounds\n  maxLead ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (1, 58)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(140, 82), (89, 134), (90, 110), (112, 106), (88, 90)]\n\n/--\ninfo: (1, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(10, 5), (20, 15), (30, 25)]\n\n/--\ninfo: (2, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(5, 10), (15, 20), (25, 30)]"}
{"id": "fvapps_000973", "vc-description": "/-\nIn the world of DragonBool there are fierce warriors called Soints. Also there are even fiercer warriors called Sofloats – the mortal enemies of Soints.\n\nThe power of each warrior is determined by the amount of chakra he possesses which is some positive integer. Warriors with zero level of chakra are dead warriors :) When the fight between Soint with power CI and Sofloat with power CF occurs the warrior with lower power will die and the winner will lose the amount of chakra that his enemy have possessed before the fight. So three cases are possible:\n\n- CI > CF. Then Sofloat will die while the new power of Soint will be CI – CF.\n- CI < CF. Then Soint will die while the new power of Sofloat will be CF – CI.\n- CI = CF. In this special case both warriors die.\n\nEach warrior (Soint or Sofloat) has his level of skills which is denoted by some positive integer. The fight between two warriors can occur only when these warriors are Soint and Sofloat of the same level. In particual, friendly fights are not allowed, i.e., a Soint cannot fight with another Soint and the same holds for Sofloats.\n\nLets follow the following convention to denote the warriors. A Soint of level L and power C will be denoted as (I, C, L), while Sofloat of level L and power C will be denoted as (F, C, L). Consider some examples. If A = (I, 50, 1) fights with B = (F, 20, 1), B dies and A becomes (I, 30, 1). On the other hand, (I, 50, 1) cannot fight with (F, 20, 2) as they have different levels.\n\nThere is a battle between Soints and Sofloats. There are N Soints and M Sofloats in all. The battle will consist of series of fights. As was mentioned above in each fight one Soint and one Sofloat of the same level take part and after the fight the warrior with lower power will die (or both will die if they have the same power). The battle proceeds as long as there exists at least one pair of warriors who can fight. The distribution of warriors by levels satisfies the following condition: for every Soint of level L there exists at least one Sofloat of the same level L and vice-versa. So if for some level L we have at least one warrior of this level then there is at least one Soint of level L and at least one Sofloat of level L.\n\nThere is a powerful wizard, whose name is SoChef, on the side of Soints. He can increase the amount of chakra of each Soint by any number. SoChef wants the army of Soints to win this battle. But increasing amount of chakra of any Soint by one costs him a lot of his magic power. Hence he wants to minimize the total amount of additional chakra he should give to Soints in order for them to win. Note, however, that the win here means that all Sofloats should be dead irregardless of whether any Soint is alive. Also note that the battle can proceed by different scenarios and the SoChef need to distribute additional chakra among the Soints in such a way that they will win for any possible battle scenario. Help SoChef and find the minimal amount of additional chakra he should give to Soints in order for them to win.\n\n-----Input-----\n\nThe first line of the input contains an integer T, the number of test cases. T test cases follow. The first line of each test case contains two space separated integers N and M. Here N is the number of Soints  participating in the battle and M is the number of Sofloats  for the same. Each of the next N lines contains two space separated integers  Ci and  Li, the amount of chakra and level of i-th Soint correspondingly. The next M lines describe power and level of Sofloats participating in the battle in the same format.\n\n-----Output-----\n\nFor each test case output a single integer on a single line, the minimum amount of chakra SoChef should give to Soints in order for them to win the battle.\n\n-----Constraints-----\nEach integer in the input file is positive and does not exceed 100. That is1 ≤ T ≤ 100\n1 ≤ N ≤ 100\n1 ≤ M ≤ 100\n1 ≤ Ci ≤ 100\n1 ≤ Li ≤ 100\n\nFor every Soint of level L there exists at least one Sofloat of the same level L and vice-versa.\nIt is guaranteed that each official test file will satisfy all these constraints. You DON'T need to verify them in your program.\n\n-----Example-----\nInput:\n2\n2 3\n10 1\n20 2\n5 2\n5 2\n18 1\n5 5\n73 87\n69 13\n36 36\n77 46\n43 93\n49 46\n74 93\n78 87\n99 13\n59 36\n\nOutput:\n8\n89\n\n-----Explanation-----\nCase 1.\nThe warriors are I1 = (I, 10, 1), I2 = (I, 20, 2), F1 = (F, 5, 2), F2 = (F, 5, 2), F3 = (F, 18, 1). Without the SoChef help the battle can proceed as follows.\n\n- I2 fights with F1, F1 dies, I2 becomes (I, 15, 2).\n- I2 fights with F2, F2 dies, I2 becomes (I, 10, 2).\n- I1 fights with F3, I1 dies, F3 becomes (F, 8, 1).\n\nSo if SoChef will give 8 additional units of chakra to I1 the Soints will win the battle and even one Soint (I2) will left alive. Hence the answer is 8.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_chakra_needed (n m : Nat) (soint_powers soint_levels sofloat_powers sofloat_levels : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_chakra_cases :\n  (min_chakra_needed 1 1 [10] [1] [5] [1] = 0) ∧\n  (min_chakra_needed 2 2 [10, 20] [1, 2] [5, 15] [1, 2] = 0) ∧\n  (min_chakra_needed 2 3 [10, 20] [1, 2] [5, 5, 18] [2, 2, 1] = 8) ∧\n  (min_chakra_needed 2 2 [10, 10] [1, 1] [20, 20] [1, 1] = 20) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000976", "vc-description": "/-\nGiven an array A1,A2...AN, you have to print the size of the largest contiguous subarray such that \nGCD of all integers in that subarray is 1.\n\nFormally,\nFor a subarray Ai,Ai+1...Aj where 1 ≤ i < j ≤ N to be valid: GCD(Ai,Ai+1...Aj) should be 1. You have to print the size of the largest valid subarray.\nIf no valid subarray exists, output -1.\nNote:A single element is not considered as a subarray according to the definition of this problem.\n\n-----Input-----\nFirst line contains T, the number of testcases. Each testcase consists of N in one line followed by N integers in the next line.\n\n-----Output-----\nFor each testcase, print the required answer in one line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ N ≤ 105\n- 1 ≤ Ai ≤ 105\n\n-----Example-----\nInput:\n2\n2\n7 2\n3\n2 2 4\n\nOutput:\n2\n-1\n\n-----Explanation-----\nExample case 1.GCD(2,7)=1. So the subarray [A1,A2] is valid.\nExample case 2.No subarray satisfies.\nNote: Use scanf/print instead of cin/cout. Large input files.\n-/", "vc-preamble": "def List.firstElem (l : List Nat) (h : l.length > 0) : Nat :=\n  match l with\n  | [] => by contradiction\n  | x::_ => x", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef find_largest_gcd_1_subarray (arr : List Nat) : Int :=\n  sorry\n\ndef reduce_gcd (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_one_returns_full_length {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 1)\n    (h3 : reduce_gcd arr = 1) :\n  find_largest_gcd_1_subarray arr = arr.length :=\nsorry\n\ntheorem non_gcd_one_returns_negative {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 1)\n    (h3 : reduce_gcd arr > 1) :\n  find_largest_gcd_1_subarray arr = -1 :=\nsorry\n\ntheorem return_bounds {arr : List Nat} (h1 : arr.length ≥ 2) (h2 : ∀ x ∈ arr, x ≥ 2) :\n  find_largest_gcd_1_subarray arr = -1 ∨\n  (1 ≤ find_largest_gcd_1_subarray arr ∧ find_largest_gcd_1_subarray arr ≤ arr.length) :=\nsorry\n\ntheorem same_elements_no_gcd_one {arr : List Nat} (h1 : arr.length ≥ 2)\n    (h2 : ∀ x ∈ arr, ∀ y ∈ arr, x = y) :\n  ∀ x ∈ arr, x ≠ 1 → find_largest_gcd_1_subarray arr = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [7, 2]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [2, 2, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [6, 10, 15, 25]"}
{"id": "fvapps_000977", "vc-description": "/-\nYou are given an array A consisting of N integers. A group of disjoint subarrays in it will be a collection of subarrays of the array. Formally a group of subarrays consisting of K subarrays can be denoted by 2 * K indices, [i1, j1], [i2, j2] , ..., [iK, jK], such that i1 ≤ j1 < i2 ≤ j2 < ... < iK ≤ jK.\n\nFor example, in array A = {5, 6, 7}. A group of subarrays could be the subarrays denoted by indices [1, 1], [2, 3]. The subarray corresponding to indices [1, 1] will be {5}. The subarray corresponding to indices [2, 3] will be {6, 7}. So, we have i1 = 1, j1 = 1, i2 = 2, j2 = 3 and K = 2. You can check that the indices satisfy the property i1 ≤ j1 < i2 ≤ j2.\n\nNote that the group of subarrays [1, 2] and [2, 3] won't be disjoint, as it does not satisfy the property j1 < i2. In other words, the index 2 is common in two subarrays, which should not happen.\n\nLet M denote the maximum value of K in a group of K disjoint subarrays of array A, such that there are not two elements (not indices) common in those subarrays. This means, that if the group contained subarrays [A[i1], A[j1], [A[i2], A[j2]] , ..., A[[iK, jK]], then there should not be an element which is present in more than one subarrays.\n\nYou have to find maximum number of group of disjoint subarrays that number of subarrays in those groups are equal to M. As the answer could be large, output it modulo 109 + 7.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFirst line of the each test case contains a single integer N denoting number of elements in array A.\nSecond line of each test case contains N space separated integers denoting the elements of the array A\n\n-----Output-----\nFor each test case, output a single line corresponding to maximum number of group of disjoint subarrays of array A.\n\n-----Constraints-----\n- 1 ≤ T, N ≤ 105\n- 1 ≤ Ai ≤ n\n- Sum of N over all the test cases in a single file won't exceed 105\n\n-----Subtasks-----\nSubtask #1 (30 points)\n\n- 1 ≤ T, N ≤ 103\n- 1 ≤ Ai ≤ n\n- Sum of N over all the test cases in a single file won't exceed 103\n\nSubtask #2 (70 points)\n- original constraints\n\n-----Example-----\nInput\n3\n2\n3 4\n3\n1 2 2\n5\n1 1 2 2 2\n\nOutput:\n1\n3\n18\n\n-----Explanation-----\nExample case 1. M will be equal to 2. The subarrays will be {[1, 1], [2, 2]}.\nExample case 2. M will be equal to 3. The subarrays will be {[1, 1], [2, 2]}, {[1, 1], [3, 3]} and {[1, 1], [2, 3]}. Note that {[2, 2], [3, 3]} won't be a non-intersecting subarray as A[2] = 2 and A[3] = 2. So, 2 is common in both these subarrays.\n-/", "vc-preamble": "def triangular_num (n : Nat) : Nat :=\nn * (n + 1) / 2", "vc-helpers": "", "vc-definitions": "def solve_disjoint_subarrays (n : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_disjoint_subarrays_output_bounds {n : Nat} {arr : List Nat}\n  (hn : n > 0)\n  (harr_size : arr.length = n)\n  (harr_bounds : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 1000) :\n  let result := solve_disjoint_subarrays n arr\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem solve_disjoint_subarrays_singleton {arr : List Nat}\n  (hsingle : arr.length = 1)\n  (hbound : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10) :\n  solve_disjoint_subarrays 1 arr = 1 :=\nsorry\n\ntheorem solve_disjoint_subarrays_all_equal {n : Nat} {arr : List Nat}\n  (hn : n > 1)\n  (harr_size : arr.length = n)\n  (harr_bounds : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10)\n  (hall_equal : ∀ x ∈ arr, x = arr.head!) :\n  solve_disjoint_subarrays n arr = (triangular_num n) * (triangular_num n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 2 [3, 4]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 3 [1, 2, 2]\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 5 [1, 1, 2, 2, 2]"}
{"id": "fvapps_000979", "vc-description": "/-\nAnmol gained a lot of weight last semester. So this semester, he decided to run everyday. There is a very long straight road starting at his hostel. There are N poles on the road - P1, P2, P3,..., PN on the road. All the poles lie on the same side of his hostel. The distance between Pi and his hostel is Di.\nFor 1 ≤ i, j ≤ N, i < j implies Di < Dj\nEveryday, Anmol chooses a pole Pi to start running from. He keeps on running until he reaches Pi+K. Whenever he reaches a pole (other than the starting pole), he records the distance traveled since the last pole.\n\nYou are given the distances recorded by him today. Your task is to find the number of distinct values of i such that i + K ≤ N and if he starts at Pi and end at Pi+K, he would end up having exactly the same record of distances (in the same order).\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases.\n- The first line of each test case contains two space separated integers N and K.\n- The next line contains N space separated integers D1, D2,..., DN.\n- The next line contains K space separated integers representing the distances recorded by Anmol in the same order.\n.\n\n-----Output-----\n- For each test case, output a single line containing the answer for that test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ N ≤ 5 x 104\n- 1 ≤ K < N\n- 1 ≤ Di ≤ 106\n\n-----Subtasks-----\n\n-----Subtask #1 (20 points)-----\n- 1 ≤ N ≤ 1000\n\n-----Subtask #2 (80 points)-----\n- Original constraints\n\n-----Example-----\nInput:\n3\n5 1\n1 5 10 12 14\n5\n5 2\n5 8 13 16 21\n3 5\n5 3\n2 6 8 11 16\n2 3 5\n\nOutput:\n1\n2\n1\n\n-----Explanation-----\nExample case 1. If he runs from P2 to P3, he will record (5)\nExample case 2. He can start at P1 or P3\nExample case 3. He can start at P2\n-/\n\n/- The output is a natural number between 0 and n-k -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- A pattern matches against itself at least once -/\n\n/- Basic cases work correctly -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_running_patterns (n : Nat) (k : Nat) (distances : List Nat) (recorded : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_running_patterns_bounds (n k : Nat) (distances recorded : List Nat)\n    (hn : n ≥ 2) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)\n    (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j)\n    (hrec : recorded.length = k) :\n    let result := solve_running_patterns n k distances recorded\n    0 ≤ result ∧ result ≤ n - k :=\nsorry\n\ntheorem solve_running_patterns_self_match (n k : Nat) (distances : List Nat)\n    (hn : n ≥ 3) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)\n    (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j) :\n    let diffs := List.zipWith (fun x y => x - y) (distances.drop 1) distances\n    let pattern := List.take k diffs\n    solve_running_patterns n k distances pattern ≥ 1 :=\nsorry\n\ntheorem solve_running_patterns_basic_cases :\n    solve_running_patterns 2 1 [1,2] [1] = 1 ∧\n    solve_running_patterns 3 1 [1,2,3] [1] = 2 :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 1 [1, 5, 10, 12, 14] [5]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 2 [5, 8, 13, 16, 21] [3, 5]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 3 [2, 6, 8, 11, 16] [2, 3, 5]"}
{"id": "fvapps_000980", "vc-description": "/-\nChef is a really nice and respectful person, in sharp contrast to his little brother, who is a very nasty and disrespectful person. Chef always sends messages to his friends in all small letters, whereas the little brother sends messages in all capital letters.\nYou just received a message given by a string s. You don't know whether this message is sent by Chef or his brother. Also, the communication channel through which you received the message is erroneous and hence can flip a letter from uppercase to lowercase or vice versa. However, you know that this channel can make at most K such flips.\nDetermine whether the message could have been sent only by Chef, only by the little brother, by both or by none.\n\n-----Input-----\n\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers N and K denoting the length of the string s and the maximum number of flips that the erroneous channel can make.\n- The second line contains a single string s denoting the message you received.\n\n-----Output-----\nFor each test case, output a single line containing one string — \"chef\", \"brother\", \"both\" or \"none\".\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 100\n- 0 ≤ K ≤ N\n- s consists only of (lowercase and uppercase) English letters\n\n-----Example-----\nInput\n\n4\n5 1\nfrauD\n5 1\nFRAUD\n4 4\nLife\n10 4\nsTRAWBerry\n\nOutput\n\nchef\nbrother\nboth\nnone\n\n-----Explanation-----\nExample case 1: Only one flip is possible. So it is possible that Chef sent \"fraud\" and the channel flipped the last character to get \"frauD\". However, it is not possible for the brother to have sent \"FRAUD\", because then it would need 4 flips. Hence the answer is \"chef\".\nExample case 2: Only one flip is possible. So it is possible that the brother sent \"FRAUD\" and the channel didn't flip anything. However, it is not possible for Chef to have sent \"fraud\", because then it would need 5 flips. Hence the answer is \"brother\".\nExample case 3: Four flips are allowed. It is possible that Chef sent \"life\" and the channel flipped the first character to get \"Life\". It is also possible that the brother sent \"LIFE\" and the channel flipped the last three characters to get \"Life\". Hence the answer is \"both\".\nExample case 4: Four flips are allowed. It is not possible that Chef sent \"strawberry\", because it would need five flips to get \"sTRAWBerry\". It is also not possible that the brother sent \"STRAWBERRY\", because that would also need five flips. Hence the answer is \"none\".\n-/", "vc-preamble": "inductive MessageType where\n  | chef\n  | brother\n  | both\n  | none\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def isUpper (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry\n\ndef countUpper (s : String) : Nat :=\nsorry\n\ndef countLower (s : String) : Nat :=\nsorry\n\ndef classify_message (N : Nat) (K : Nat) (s : String) : MessageType :=\nsorry", "vc-theorems": "theorem classify_message_properties {N K : Nat} {s : String} :\n  let upper := countUpper s\n  let lower := countLower s\n  match classify_message N K s with\n  | MessageType.chef => lower > K ∧ upper ≤ K\n  | MessageType.brother => upper > K ∧ lower ≤ K\n  | MessageType.both => upper ≤ K ∧ lower ≤ K\n  | MessageType.none => upper > K ∧ lower > K\n  :=\nsorry\n\ntheorem all_upper {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'A')) = MessageType.brother :=\nsorry\n\ntheorem all_lower {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'a')) = MessageType.chef :=\nsorry\n\ntheorem empty_k_large {N : Nat} (h : N > 1) {s : String} :\n  classify_message N 0 s = MessageType.none :=\nsorry\n\ntheorem empty_k_small {N : Nat} (h : N = 1) {s : String} :\n  classify_message N 0 s ≠ MessageType.none :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'chef'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"frauD\"\n\n/--\ninfo: 'brother'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"FRAUD\"\n\n/--\ninfo: 'both'\n-/\n#guard_msgs in\n#eval classify_message 4 4 \"Life\""}
{"id": "fvapps_000981", "vc-description": "/-\nAlice likes prime numbers. According to Alice, only those strings are nice whose sum of character values at a prime position is prime. She has a string $S$. Now, she has to count the number of nice strings which come before string $S$( including $S$) in the dictionary and are of the same length as $S$. \nStrings are zero-indexed from left to right.\nTo find the character value she uses the mapping {'a': 0, 'b':1, 'c':2 ……. 'y': 24, 'z':25} .\nFor example, for string $abcde$ Characters at prime positions are $'c'$ and $'d'$. c + d = 2 + 3 = 5. Since, 5 is a prime number, the string is $nice$.\nSince there could be many nice strings print the answer modulo $10^{9}+7$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, the string $S$. \n\n-----Output:-----\nFor each testcase, output in a single line number of nice strings modulo $10^{9}+7$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $2 \\leq |S| \\leq 10^2$\nString $S$ contains only lowercase letters.\n\n-----Sample Input:-----\n1\nabc\n\n-----Sample Output:-----\n10\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_nice (s: List Char) : Bool :=\n  sorry\n\ndef count_nice_strings (s: List Char) : Nat :=\n  sorry", "vc-theorems": "theorem count_nice_strings_non_negative (s: List Char) :\n  count_nice_strings s ≥ 0 :=\nsorry\n\ntheorem count_nice_strings_upper_bound (s: List Char) :\n  count_nice_strings s ≤ (s.length * (s.length + 1)) / 2 :=\nsorry\n\ntheorem empty_string_has_zero_nice (s: List Char) :\n  s.length = 0 → count_nice_strings s = 0 :=\nsorry\n\ntheorem is_nice_min_length (s: List Char) :\n  is_nice s → s.length ≥ 2 :=\nsorry\n\ntheorem small_strings_not_nice (s: List Char) :\n  s.length ≤ 1 → ¬(is_nice s) :=\nsorry\n\ntheorem nice_string_conditions (s: List Char) (i: Nat) :\n  is_nice s →\n  (∀ i, i < s.length → s.get! 0 = s.get! i) ∨\n  (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) > Char.toNat (s.get! (i-1))) ∨\n  (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) < Char.toNat (s.get! (i-1))) :=\nsorry\n\ntheorem nice_string_has_nice_count (s: List Char) :\n  s.length ≥ 2 →\n  is_nice s →\n  count_nice_strings s ≥ 1 :=\nsorry\n\ntheorem count_matches_actual_nice (s: List Char) :\n  count_nice_strings s =\n    (List.foldl (fun acc i =>\n      acc + List.foldl (fun inner_acc j =>\n        if is_nice (List.take (j + 1) (List.drop i s))\n        then inner_acc + 1\n        else inner_acc)\n      0 (List.range (s.length - i)))\n    0 (List.range s.length)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"aaa\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abc\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abbc\""}
{"id": "fvapps_000994", "vc-description": "/-\nYou are given a tree rooted at node $1$ with $N$ vertices. The $i$$th$ vertex initially has value $A_i (1 \\leq i \\leq N)$. You are also given $Q$ queries. \nIn each query you are given a vertex $V$.  Let $S = \\{ S_1 , S_2 , ... S_x \\} $ denote the set of vertices such that $S_i$ is in the subtree of $V$, distance between $S_i$ and $V$ is even and $S_i \\neq V$ for all $i$. For all $S_i$ , add $A$$S_i$ to $A_V$ and change the value of $A$$S_i$ to zero.\nFind the values of all the vertices after all queries are performed. \nNote-The distance between two vertices is defined as the number of edges\ntraversed on the shortest path from one vertex to the other.\n\n-----Input:-----\n- The first line contains an integer $T$ denoting the number of test cases.\n- The first line of each test case contain two integers $N$ and $Q$.\n- The second line contains $N$ space separated integers, $A_1, A_2, ..., A_n$ denoting the initial values of the vertices.\n- The next $N-1$ lines contain two integers $u$ and $v$ denoting an edge between $u$and $v$.\n- The next $Q$ lines contain a single integer which is the query.\n\n-----Output:-----\n- Print a single line containing $N$ integers for each test case which is the final values of the vertices.\n\n-----Constraints:-----\n- $1\\leq T \\leq 10$\n- $1 \\leq N \\leq 200000$\n- $1 \\leq Q \\leq 200000$\n- $0 \\leq A_i \\leq 10^9$\n- The sum of $N$ over all test cases does not exceed $200000$.\n- The sum of $Q$ over all test cases does not exceed $200000$.\n\n-----Sample Input-----\n1\n4 3\n6 2 7 3\n1 2\n2 3\n3 4\n3\n2\n1\n\n-----Sample Output-----\n13 5 0 0\n\n-----Explanation-----\nNode $3$ has no child in its subtree which is at  an even distance so there is no change in the values. Values of nodes after $1st$ query: $6, 2, 7, 3$.\nNode $4$ is at an even distance in the subtree of node $2$ so $A_4$ gets added to $A_2$ and $A_4$ becomes 0. Values of nodes after $2nd$ query: $6, 5, 7, 0$.\nNode $3$ is at an even distance in the subtree of node $1$ so $A_3$ gets added to $A_1$ and $A_3$ becomes 0. Values of nodes after $3rd$ query: $13, 5, 0, 0$.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def countChanges (arr : List Nat) : Nat :=\n  let indices := List.range (arr.length - 1)\n  indices.foldl (fun acc i =>\n    if h : i < arr.length ∧ i + 1 < arr.length then\n      if arr[i]'h.left ≠ arr[i+1]'h.right then\n        acc + 1\n      else acc\n    else acc) 0", "vc-helpers": "", "vc-definitions": "def find_sequence (arr : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem find_sequence_non_negative (arr : List Nat) :\n  ∀ x ∈ find_sequence arr, x ≥ 0 :=\nsorry\n\ntheorem find_sequence_trailing_zero (arr : List Nat) :\n  arr.length > 0 → arr.getLast! = 0 →\n  (find_sequence arr).getLast! = 0 :=\nsorry\n\ntheorem find_sequence_run_lengths (arr : List Nat) (pos : Nat) (h : pos < arr.length) :\n  let val := arr[pos]'h\n  let run_length := (find_sequence arr).get! pos\n  ∃ actual_count : Nat,\n    (∀ i, pos ≤ i ∧ i < pos + actual_count →\n      ∃ h' : i < arr.length, arr[i]'h' = val) ∧\n    (val = 0 ∧ pos + actual_count = arr.length → run_length = 0) ∧\n    (¬(val = 0 ∧ pos + actual_count = arr.length) → run_length = actual_count) :=\nsorry\n\ntheorem find_sequence_length (arr : List Nat) :\n  arr.length > 0 →\n  (find_sequence arr).length = 1 + countChanges arr :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_000997", "vc-description": "/-\nChef has some numbers. His girlfriend Chefina feels good when chef gives her a particular pattern number also called as Armstrong number.\nArmstrong number is a number whose sum of its all individual digit raise to the power of the number of digit in that number is equal to that number itself\neg.. 153 = 1^3 + 5^3 + 3^3 (153 is an Armstrong number)\n1634 = 1^4 + 6^4 + 3^4 + 4^4 (1634 is an Armstrong number)\nAs a love guru of chef you have to help chef to find Armstrong numbers Among the numbers which chef has initially so that Chefina feels good\n\n-----Input:-----\nFirst line will contain a positive Integer $T$ which is the number of testcases\nNext $T$ lines follows an Integer $N$.\n\n-----Output:-----\nFor Every n You have to print \"FEELS GOOD\" without qoutes if it is an armstrong number otherwise Print \"FEELS BAD\" without quotes\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $2 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n3\n153\n11\n1634\n\n-----Sample Output:-----\nFEELS GOOD\nFEELS BAD\nFEELS GOOD\n\n-----EXPLANATION:-----\nFor test case 1 --> 153 = 1^3 + 5^3 + 3^3 (153 is an armstrong number)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def power (x y : Nat) : Nat :=\n  sorry\n\ndef order (x : Nat) : Nat :=\n  sorry\n\ndef is_armstrong (x : Nat) : String :=\n  sorry\n\ndef check_numbers (numbers : List Nat) : List String :=\n  sorry", "vc-theorems": "theorem power_properties (x : Nat) (y : Nat) :\n  (y = 0 → power x y = 1) ∧\n  (y = 1 → power x y = x) ∧\n  (y = 2 → power x y = x * x) :=\nsorry\n\ntheorem order_properties (x : Nat) :\n  (x = 0 → order x = 0) ∧\n  (0 < x ∧ x < 10 → order x = 1) ∧\n  (10 ≤ x ∧ x < 100 → order x = 2) :=\nsorry\n\ntheorem is_armstrong_properties (x : Nat) :\n  (x < 10 → is_armstrong x = \"FEELS GOOD\") ∧\n  (is_armstrong x = \"FEELS GOOD\" ∨ is_armstrong x = \"FEELS BAD\") :=\nsorry\n\ntheorem check_numbers_properties (numbers : List Nat) :\n  (numbers = [] → check_numbers numbers = []) ∧\n  (List.length (check_numbers numbers) = List.length numbers) ∧\n  (∀ x ∈ check_numbers numbers, x = \"FEELS GOOD\" ∨ x = \"FEELS BAD\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: ['FEELS GOOD', 'FEELS BAD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [153, 11, 1634]\n\n/--\ninfo: ['FEELS GOOD', 'FEELS GOOD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [370, 371, 407]\n\n/--\ninfo: ['FEELS BAD', 'FEELS BAD', 'FEELS BAD']\n-/\n#guard_msgs in\n#eval check_numbers [123, 555, 999]"}
{"id": "fvapps_001000", "vc-description": "/-\nChef taught his brother Chefu about right angled triangle and its properties. Chefu says that he has understood everything about right angled triangles. Chef wants to check learning of his brother by asking the following question \"Can you find a right angled triangle whose length of hypotenuse  is H and its area is S?\"\nChefu is confused how to solve it. I hope you are not. Please solve this by finding a right angled triangle with hypotenuse H and area S. If it not possible to do so, then output -1.\n\n-----Input-----\nThe first line of the input contains a single integer T denoting the number of test-cases. T test cases follow.\nFor each test case, there will be a single line containing two space separated integers H and S.\n\n-----Output-----\nOutput the answer for each test-case in a single line. If it is not possible to find such a triangle, output -1. Otherwise print 3 real numbers corresponding to the lengths of the sides of the triangle sorted in non-decreasing order. Please note that the length of the triangle sides should not differ by more than 0.01 in absolute value from the correct lengths.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ H ≤ 106\n- 1 ≤ S ≤ 1012\n\n-----Example-----\nInput:4\n5 6\n6 10\n258303 89837245228\n616153 77878145466\nOutput:3.00000 4.00000 5.00000\n-1\n-1\n285168.817674 546189.769984 616153.000000\n-/\n\n-- Positive sides\n\n-- Height matches\n\n-- Area matches\n\n-- Ordered sides\n\n-- Simplified String validation since we lack string manipulation operations\n\n-- Triangle inequality", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_triangle (h : Int) (s : Int) : Int × Int × Int :=\n  sorry\n\ndef format_output (triangle : Int × Int × Int) : String :=\n  sorry", "vc-theorems": "theorem find_triangle_valid_output {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000000) (s_bound : s ≤ 1000000) :\n  let (a, b, c) := find_triangle h s\n  if a ≠ -1 then\n    a > 0 ∧ b > 0 ∧ c > 0 ∧\n    c = h ∧\n    a * b / 2 = s ∧\n    a ≤ b\n  else True :=\nsorry\n\ntheorem format_output_valid {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000000) (s_bound : s ≤ 1000000) :\n  let result := format_output (find_triangle h s)\n  if result ≠ \"-1\" then\n\n    result.length > 0\n  else True :=\nsorry\n\ntheorem triangle_inequality {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h ≤ 1000) (s_bound : s ≤ 1000) :\n  let (a, b, c) := find_triangle h s\n  if a ≠ -1 then\n    a + b > c ∧ b + c > a ∧ a + c > b\n  else True :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '3.000000 4.000000 5.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(5, 6)\n\n/--\ninfo: '-1'\n-/\n#guard_msgs in\n#eval format_output find_triangle(6, 10)\n\n/--\ninfo: '285168.817674 546189.769984 616153.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(616153, 77878145466)"}
{"id": "fvapps_001007", "vc-description": "/-\nTwo's company, three's a crowd!\nIt's been one year since Chef met his brother. Last year, his younger brother came to visit him during this time of the year. This year, the Chef is planning to go visit his brother. Chef's brother has planned to throw a \"Welcome Party\" for him. He wants to invite people from his neighbourhood (i.e. from the street where he lives). There are N houses on the street in a single line (not considering the brother's house). He wants the party to be fun and he will not like to invite people who might spoil the mood of the party. If people are invited from three consecutive houses on the street, they might create trouble. As they say, three's a crowd! He doesn't want to ruin the Chef's Welcome Party and so he will not want to send invites to any three consecutive houses. He wants you to tell him how many ways are there for him to go wrong. Note that he can play safe by not inviting anyone to avoid a crowd.\n\n-----Input:-----\nFirst line of the input contains a single integer T, the number of test cases.\n\nEach test case contains a line containing a single integer N described above.\n\n-----Output:-----\nFor each test case output a single integer denoting the number of ways the brother can go wrong with planning the party.\n\nThe answer can get quite large. So output the total number of ways modulo 109+7.\n\n-----Constraints:-----\n1<=T<=10000\n1<=N<=1015\n\n-----Example:-----Input:\n2\n3\n4\n\nOutput:\n1\n3\n\nExplanation:\nCase 1: The only way he can go wrong is by inviting all the houses.\nCase 2: First way of getting wrong is by inviting houses (1,2,3). Second way to get wrong is by inviting houses (2,3,4). Third way of going wrong is by inviting all 4 houses i.e. (1,2,3,4).\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_crowds (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_crowds_nonnegative (n : Nat) :\n  solve_crowds n ≥ 0 ∧ solve_crowds n < MOD :=\nsorry\n\ntheorem solve_crowds_small_n (n : Nat) (h : n ≤ 2) :\n  solve_crowds n = 0 :=\nsorry\n\ntheorem solve_crowds_upper_bound (n : Nat) (h : n ≥ 3) :\n  solve_crowds n < 2^n :=\nsorry\n\ntheorem solve_crowds_known_values_3 :\n  solve_crowds 3 = 1 :=\nsorry\n\ntheorem solve_crowds_known_values_4 :\n  solve_crowds 4 = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_crowds 3\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_crowds 4\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_crowds 2"}
{"id": "fvapps_001014", "vc-description": "/-\nYou are given Name of chef's friend and using chef's new method of calculating value of string , chef have to find the value of all the names. Since chef is busy , he asked you to do the work from him .\nThe method is a function $f(x)$ as follows - \n- \n$f(x)$ = $1$ , if $x$ is a consonent\n- \n$f(x)$ = $0$ , if $x$ is a vowel \nYour task is to apply the above function on all the characters in the string $S$ and convert the obtained binary string in decimal number N. Since the number N can be very large, compute it modulo $10^9+7$ .\nInput:\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each test line contains one String $S$ composed of lowercase English alphabet letters. \n\n-----Output:-----\nFor each case, print a single line containing one integer $N$ modulo  $10^9+7$ .\n\n-----Constraints-----\n- $1 \\leq T \\leq 50$\n- $1 \\leq |S| \\leq 10^5$\n\n-----Sample Input:-----\n1\ncodechef\n\n-----Sample Output:-----\n173\n\n-----EXPLANATION:-----\nThe string \"codechef\" will be converted to 10101101 ,using the chef's method function . Which is equal to 173.\n-/", "vc-preamble": "def MOD := 1000000007\n\ndef isVowel (c : Char) : Bool :=\n  match c.toLower with\n  | 'a' | 'e' | 'i' | 'o' | 'u' => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def solveBinaryNames (name : String) : Nat :=\n  sorry", "vc-theorems": "theorem binary_names_result_range\n  (name : String)\n  (h : ∃ c ∈ name.data, c.isAlpha) :\n  0 ≤ solveBinaryNames name ∧ solveBinaryNames name < MOD :=\nsorry\n\ntheorem only_letters_matter\n  (name : String)\n  (h : ∃ c ∈ name.data, c.isAlpha) :\n  solveBinaryNames name = solveBinaryNames (String.mk (name.data.filter Char.isAlpha)) :=\nsorry\n\ntheorem all_vowels_zero\n  (name : String)\n  (h₁ : name.length > 0)\n  (h₂ : ∀ c ∈ name.data, isVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :=\nsorry\n\ntheorem all_consonants_one\n  (name : String)\n  (h₁ : name.length > 0)\n  (h₂ : ∀ c ∈ name.data, c.isAlpha ∧ ¬isVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 173\n-/\n#guard_msgs in\n#eval solve_binary_names \"codechef\""}
{"id": "fvapps_001018", "vc-description": "/-\n-----\nARRAY AND DISTINCT ELEMENTS\n-----\n\nChef is multitalented but he mistakenly took part in 2 contest which will take place\nat the same time. So while chef is busy at one cooking contest, he wants you to\ntake part in coding contest. Chef wants u to solve this program for him.\n\nYou have been given an array of size n. You have to calculate a subarray of size k\nwith maximum sum having distinct elements same as original array.\n\n-----Input Format-----\n\nFirst line contains no. of test cases. Second line contains n and k. Third line\ncontains array of n integers.\n\n-----Output-----\n\nPrint maximum possible sum as stated in question\n\n-----Example Text Case-----\nInput:\n\n1\n10 6\n8 8 3 5 3 8 5 7 7 7\n\nOutput:\n37\n-/", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0\n\ndef allEqual (l : List Nat) : Prop :=\n  ∀ x y, x ∈ l → y ∈ l → x = y\n\ndef uniqueCount (l : List Nat) : Nat :=\n  (l.eraseDups).length", "vc-helpers": "", "vc-definitions": "def find_max_distinct_subarray_sum (n k : Nat) (arr : List Nat) : Int :=\n  sorry", "vc-theorems": "theorem max_distinct_subarray_sum_within_bounds\n  {n k : Nat} {arr : List Nat} (h1 : k ≤ n) (h2 : n = arr.length)\n  (h3 : ∀ x, x ∈ arr → 1 ≤ x ∧ x ≤ 100) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 ∨\n  result ≤ (List.range (n - k + 1)).foldl (fun acc i =>\n    max acc (sum ((arr.take (i + k)).drop i))) 0 :=\nsorry\n\ntheorem identical_elements_sum_first_k\n  {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n) (h2 : n = arr.length)\n  (h3 : allEqual arr) (h4 : ∀ x, x ∈ arr → x > 0) :\n  find_max_distinct_subarray_sum n k arr = sum (arr.take k) :=\nsorry\n\ntheorem distinct_count_consistent\n  {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n) (h2 : n = arr.length) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 ∨\n  ∀ i, i + k ≤ n →\n    sum ((arr.take (i + k)).drop i) = result →\n    uniqueCount ((arr.take (i + k)).drop i) = uniqueCount arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 37\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 10 6 [8, 8, 3, 5, 3, 8, 5, 7, 7, 7]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 5 3 [1, 2, 1, 2, 3]\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 4 2 [5, 5, 5, 5]"}
{"id": "fvapps_001019", "vc-description": "/-\nLira is now very keen on compiler development. :) \nShe knows that one of the most important components of a compiler, is its parser.\nA parser is, in simple terms, a software component that processes text, and checks it's semantic correctness, or, if you prefer, if the text is properly built.\nAs an example, in declaring and initializing an integer, in C/C++, you can't do something like:\nint = x ;4\nas the semantics of such statement is incorrect, as we all know that the datatype must precede an identifier and only afterwards should come the equal sign and the initialization value, so, the corrected statement should be:\nint x = 4;\nToday, Lira is concerned with an abstract instruction which is composed of the characters \"<\" and \">\" , which she will use on the design of her language, L++ :D.\nShe is using it as an abstraction for generating XML code Tags in an easier fashion and she understood that, for an expression to be valid, a \"<\" symbol must always have a corresponding \">\" character somewhere (not necessary immediately) after it. Moreover, each \">\" symbol should correspond to exactly one \"<\" symbol.\nSo, for instance, the instructions:\n<<>> \n<> \n<><> \nare all valid. While:\n>> \n><>< \nare not.\nGiven some expressions which represent some instructions to be analyzed by Lira's compiler, you should tell the length of the longest prefix of each of these expressions that is valid, or 0 if there's no such a prefix.\n\n-----Input-----\nInput will consist of an integer T denoting the number of test cases to follow.\nThen, T strings follow, each on a single line, representing a possible expression in L++.\n\n-----Output-----\nFor each expression you should output the length of the longest prefix that is valid or 0 if there's no such a prefix. \n\n-----Constraints-----\n- 1 ≤ T ≤ 500\n- 1 ≤ The length of a single expression ≤ 106\n- The total size all the input expressions is no more than 5*106\n\n-----Example-----\nInput:\n3\n<<>>\n><\n<>>>\nOutput:\n4\n0\n2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestValidPrefix (s : String) : Nat :=\n  sorry\n\ndef isValid (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_non_negative (s : String) :\n  longestValidPrefix s ≥ 0 :=\nsorry\n\ntheorem result_not_exceed_length (s : String) :\n  longestValidPrefix s ≤ String.length s :=\nsorry\n\ntheorem result_is_even (s : String) :\n  longestValidPrefix s % 2 = 0 :=\nsorry\n\ntheorem next_char_makes_invalid (s : String) :\n  longestValidPrefix s < String.length s →\n  let withNext := s.take (longestValidPrefix s + 1)\n  ¬isValid withNext :=\nsorry\n\ntheorem perfect_pairs_full_length (n : Nat) :\n  let s := String.mk (List.append (List.replicate n '<') (List.replicate n '>'))\n  longestValidPrefix s = 2 * n :=\nsorry\n\ntheorem empty_string_zero :\n  longestValidPrefix \"\" = 0 :=\nsorry\n\ntheorem single_right_zero :\n  longestValidPrefix \">\" = 0 :=\nsorry\n\ntheorem single_left_zero :\n  longestValidPrefix \"<\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<<>>\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"><\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<>>>\""}
{"id": "fvapps_001029", "vc-description": "/-\nChef is playing with an expression which consists of integer operands and the following binary\nBitwise operators -  AND, OR and XOR. He is trying to figure out that what could be the Maximum possible answer of the expression, given that he can perform the operation in any order i.e not necessarily follow the rule of Precedence of operators while evaluating the expression.\nAfter some time of consistent work Chef starts feeling exhausted and wants you to automate this process for him. Can you help him out?\nThe expression has Bitwise operators in symbol format:\n- &  stands for AND \n- |   stands for OR\n- ^   stands for XOR\nNOTE : It is guaranteed that the expression will always be valid, also each OPERATOR will always be preceded and succeeded by an OPERAND.\n\n-----Input:-----\n- The first line of input contains a single integer $T$ denoting the number of test cases.\n- The only line of input for each test case is a $string$ which is the Chef's expression to evaluate.\n\n-----Output:-----\nFor each test case print a single integer i.e the maximum possible value of Chef's expression.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$.\n- The number of OPERATORS in the expression will be atleast 1 and atmost 10.\n- Each OPERAND may range from 0 to $10^9$.\n\n-----Subtasks-----\n- 10 points : The number of OPERATORS in the expression will be atmost 5.\n- 20 points : The number of OPERATORS in the expression will be atmost 8.\n- 70 points : Original constraints.\n\n-----Sample Input:-----\n2\n3^40|10^2\n\n92^95|56&2&3\n\n-----Sample Output:-----\n43\n\n95\n\n-----EXPLANATION:-----CASE 2 :\n- If we first compute (56 & 2), the expression becomes 92^95|0&3, since (56 & 2) yields $0$.\n- Now on computing (95 | 0), the expression becomes 92^95&3.\n- Further on computing (95 & 3), the expression becomes 92^3.\n- Finally (92 ^ 3) yields 95, which is the maximum value of the expression.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def value (a b : Nat) (op : String) : Nat :=\n  sorry\n\ndef solve_expression (expr : String) : Nat :=\n  sorry", "vc-theorems": "theorem value_commutativity {a b : Nat} {op : String} (h : op = \"&\" ∨ op = \"|\") :\n  value a b op = value b a op := by\n  sorry\n\ntheorem value_nonnegativity {a b : Nat} {op : String} (h : op = \"&\" ∨ op = \"|\" ∨ op = \"^\") :\n  value a b op ≥ 0 := by\n  sorry\n\ntheorem solve_expr_type {expr : String} :\n  ∃ (n : Nat), solve_expression expr = n := by\n  sorry\n\ntheorem solve_expr_nonneg {expr : String} :\n  solve_expression expr ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 43\n-/\n#guard_msgs in\n#eval solve_expression \"3^40|10^2\"\n\n/--\ninfo: 95\n-/\n#guard_msgs in\n#eval solve_expression \"92^95|56&2&3\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_expression \"1&2|3\""}
{"id": "fvapps_001031", "vc-description": "/-\nWrite a program to find the remainder when an integer A is divided by an integer B.\n\n-----Input-----\n\nThe first line contains an integer T, the total number of test cases. Then T lines follow, each line contains two Integers A and B. \n\n-----Output-----\nFor each test case, find the remainder when A is divided by  B, and display it in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ A,B ≤ 10000\n\n-----Example-----\nInput\n3 \n1 2\n100 200\n40 15\n\nOutput\n1\n100\n10\n-/\n\n/- For any list of test cases, the length of results matches the input length -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Each remainder in the result is correctly computed -/\n\n/- All remainders are non-negative and less than their divisors -/\n\n/- Division by one always yields zero remainder -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_remainders (cases : List String) : List Nat :=\nsorry", "vc-theorems": "theorem find_remainders_length (cases : List String) :\n  (find_remainders cases).length = cases.length :=\nsorry\n\ntheorem find_remainders_correct (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 →\n  find_remainders [test_case] = [a % b] :=\nsorry\n\ntheorem find_remainders_bounds (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 →\n  let r := (find_remainders [test_case]).head!\n  0 ≤ r ∧ r < b :=\nsorry\n\ntheorem find_remainders_div_by_one (a : Nat) (h : a > 0) :\n  find_remainders [s!\"{a} 1\"] = [0] :=\nsorry", "vc-postamble": "/--\ninfo: [1, 100, 10]\n-/\n#guard_msgs in\n#eval find_remainders [\"1 2\", \"100 200\", \"40 15\"]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_remainders [\"7 3\"]\n\n/--\ninfo: [0, 3]\n-/\n#guard_msgs in\n#eval find_remainders [\"10 2\", \"15 4\"]"}
{"id": "fvapps_001032", "vc-description": "/-\nChefland is a grid with N$N$ rows and M$M$ columns. Each cell of this grid is either empty or contains a house. The distance between a pair of houses is the Manhattan distance between the cells containing them.\nFor each d$d$ between 1$1$ and N+M−2$N+M-2$ inclusive, Chef wants to calculate the number of unordered pairs of distinct houses with distance equal to d$d$. Please help him!\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and M$M$.\n- N$N$ lines follow. For each i$i$ (1≤i≤N$1 \\le i \\le N$), the i$i$-th of these lines contains a binary string with length M$M$; for each j$j$ (1≤j≤M$1 \\le j \\le M$), the j$j$-th character of this string is '1' if the cell in the i$i$-th row and j$j$-th column contains a house or '0' if it is empty.\n\n-----Output-----\nFor each test case, print a single line containing N+M−2$N+M-2$ space-separated integers. For each valid i$i$, the i$i$-th integer should denote the number of pairs with distance i$i$.\n\n-----Constraints-----\n- 1≤T≤3$1 \\le T \\le 3$\n- 2≤N,M≤300$2 \\le N, M \\le 300$\n\n-----Subtasks-----\nSubtask #1 (50 points): N,M≤50$N, M \\le 50$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n1\n3 4\n0011\n0000\n0100\n\n-----Example Output-----\n1 0 1 1 0\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | (x::xs) => x + sum_list xs\n\ndef list_get (xs : List Nat) (i : Nat) : Option Nat :=\n  match xs, i with\n  | [], _ => none\n  | (x::_), 0 => some x\n  | (_::xs), n+1 => list_get xs n", "vc-helpers": "", "vc-definitions": "def make_grid (n m : Nat) (house_coords : List (Nat × Nat)) : List String :=\nsorry\n\ndef solve_house_distances (n m : Nat) (grid : List String) : List Nat :=\nsorry", "vc-theorems": "theorem house_distances_properties\n  (n m : Nat) (coords : List (Nat × Nat))\n  (h_n : n > 0) (h_m : m > 0)\n  (h_coords : coords.length ≥ 2)\n  (h_valid : ∀ (p : Nat × Nat), p ∈ coords → p.1 < n ∧ p.2 < m)\n  (h_unique : ∀ (p q : Nat × Nat), p ∈ coords → q ∈ coords → p = q ∨ p ≠ q) :\n  let result := solve_house_distances n m (make_grid n m coords);\n  let num_pairs := (coords.length * (coords.length - 1)) / 2;\n  result.length = n + m - 2 ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  sum_list result = num_pairs ∧\n  (sum_list result > 0 →\n   ∀ i x, i < result.length → list_get result i = some x → x > 0 → i + 1 ≥ 1) :=\nsorry\n\ntheorem minimal_case\n  (n m : Nat)\n  (h_n : n ≥ 2) (h_m : m ≥ 2) :\n  let corner_houses := [(0,0), (n-1,m-1)];\n  let result := solve_house_distances n m (make_grid n m corner_houses);\n  list_get result (n+m-3) = some 1 ∧\n  sum_list result = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001034", "vc-description": "/-\nChef has a strip of length $N$ units and he wants to tile it using $4$ kind of tiles\n\n-A Red tile of $2$ unit length\n\n-A Red tile of $1$ unit length\n\n-A Blue tile of $2$ unit length\n\n-A Blue tile of $1$ unit length   \nChef is having an infinite supply of each of these tiles. He wants to find out the number of ways in which he can tile the strip. Help him find this number.\nSince this number can be large, output your answer modulo 1000000007 ($10^9 + 7$).\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, an integer $N$. \n\n-----Output:-----\nFor each testcase, output in a single line your answer modulo 1000000007.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq N \\leq 10^{18}$\n\n-----Sample Input:-----\n1\n2\n\n-----Sample Output:-----\n6\n\n-----EXPLANATION:-----\n\nIt can be seen that for a strip of length $2$, there are $6$ possible configurations.     \n$NOTE : $ 2 tiles of 1 unit length are different from 1 tile of 2 unit length.\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_tile_count (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_non_negative_and_bounded (n : Nat) :\n  let result := solve_tile_count n\n  0 ≤ result ∧ result < MOD := by\n  sorry\n\ntheorem modulo_consistency (n : Nat) :\n  solve_tile_count n = solve_tile_count n % MOD := by\n  sorry\n\ntheorem base_cases_correct :\n  solve_tile_count 0 = 1 ∧\n  solve_tile_count 1 = 2 ∧\n  solve_tile_count 2 = 6 ∧\n  solve_tile_count 3 = 16 ∧\n  solve_tile_count 4 = 42 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_tile_count 2\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_tile_count 3\n\n/--\ninfo: 42\n-/\n#guard_msgs in\n#eval solve_tile_count 4"}
{"id": "fvapps_001038", "vc-description": "/-\nBob just learned about bitwise operators. Since Alice is an expert, she decided to play a game, she will give a number $x$ to Bob and will ask some questions:\nThere will be 4 different kinds of queries:-\n- \nAlice gives an integer $i$ and Bob has to report the status of the $i^{th}$ bit in $x$, the answer is $\"ON\"$ if it is on else $\"OFF\"$.\n- \nAlice gives an integer $i$ and Bob has to turn on the $i^{th}$ bit in $x$.\n- \nAlice gives an integer $i$ and Bob has to turn off the $i^{th}$ bit in $x$.\n- \nAlice gives two integers $p$ and $q$ and in the binary representation of $x$ Bob has to swap the $p^{th}$ and the $q^{th}$ bits.\nThe value of $x$ changes after any update operation.\npositions $i$, $p$, and $q$ are always counted from the right or from the least significant bit.\nIf anyone of $i$, $p$, or $q$ is greater than the number of bits in the binary representation of $x$, consider $0$ at that position.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- the first line of each test case contains two space-separated integers $x, Q$.\n- $2Q$ lines follow.\n- first line is an integer, the query type.\n- for each query of type 1 to 3, there will be the integer $i$\n- for the query of type 4, there will be two space-separated integers, the integers $p, q$\n\n-----Output:-----\nFor the queries of the first kind, print $\"ON\"$ or $\"OFF\"$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq x \\leq 10^9$\n- $1 \\leq Q \\leq 10^3$\n- $1 \\leq i,p,q \\leq 30$\n\n-----Sample Input-----\n1\n2 2\n2 \n1\n1 \n1\n\n-----Sample Output:-----\nON\n\n-----EXPLANATION:-----\nthe binary representation of 2 is 10\nfor query 1, we just have to update x to 11 (or 3 in decimal).\nfor the next query, x is now 3 or 11 in binary so the answer is ON.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def process_bit_queries (x : Nat) (queries : List (List Nat)) : List String :=\nsorry\n\ndef countOnes (n : Nat) : Nat :=\nsorry\n\ndef drop {α} (n : Nat) (xs : List α) : List α :=\nsorry", "vc-theorems": "theorem binary_conversion_preserves_number (x : Nat) (h : x < 2^64) (pos : Nat)\n(h2 : pos > 0 ∧ pos < 64) :\n  process_bit_queries x [[1, pos]] =\n    [if x &&& (1 <<< (pos - 1)) ≠ 0 then \"ON\" else \"OFF\"] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001055", "vc-description": "/-\nThe garden has a tree with too many leaves on it and gardner wants to cut the unwanted leaves. This is a rooted tree, where a node $v$ is called parent of another node $u$, if there exists a directed edge from $v$ to $u$. Leaf node is a node with no outgoing edges.\nGardner cuts the tree in a peculiar way:\n- For each parent node(which has a valid leaf node attached to it), he cuts $x$ leaf nodes, such that $x$ is a multiple of 3.\nExample : If a parent node has 7 leaf nodes, 6 leaf nodes will be cut and 1 will be left.\n- If a parent has all its leaf nodes cut, only then the parent node itself becomes a new leaf node. If new leaf nodes are created, Gardner repeats step 1 until he can cut no more leaf nodes.\nAfter completing all operations, gardner wants to know the minimum number of nodes left on the tree.\n\nIt is guaranteed that the given input is a rooted tree.\nThe root of the tree is vertex 1.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains an integer $n$, the number of vertices in the tree. \n- Second line of each testcase contains array $A$ of size $n-1$, where $A_{i}(1≤i≤n-1)$, is the index of the parent of the $(i+1)^{th}$ vertex. \n\n-----Output:-----\nFor each testcase, output single integer, the number of nodes finally left on the tree.  \n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $2 \\leq n \\leq 10^5$ \n- $1 \\leq A_i \\leq i$\n\n-----Sample Input:-----\n1\n\n13\n\n1 1 1 1 1 4 3 4 4 3 4 3 \n\n-----Sample Output:-----\n4\n\n-----EXPLANATION:-----\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_trimming (n : Nat) (parents : List Nat) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tree_trimming_bounds {n : Nat} {parents : List Nat}\n  (h1 : n ≥ 2) (h2 : is_valid_tree n parents = true) :\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem small_tree_optimum {n : Nat} {parents : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 3) (h3 : is_valid_tree n parents = true) :\n  solve_tree_trimming n parents = n :=\nsorry\n\ntheorem line_tree_bounds {n : Nat}\n  (h : n ≥ 2) :\n  let parents := List.range (n-1)\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem star_tree_bounds {n : Nat}\n  (h : n ≥ 2) :\n  let parents := List.replicate (n-1) 1\n  let result := solve_tree_trimming n parents\n  1 ≤ result ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_trimming 13 [1, 1, 1, 1, 1, 4, 3, 4, 4, 3, 4, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_trimming 3 [1, 1]"}
{"id": "fvapps_001064", "vc-description": "/-\nChef and Roma are playing a game. Rules of the game are quite simple.\nInitially there are N piles of stones on the table.\nIn each turn, a player can choose one pile and remove it from the table.\nEach player want to maximize the total number of stones removed by him.\nChef takes the first turn. \n\nPlease tell Chef the maximum number of stones he can remove assuming that both players play optimally.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N denoting the number of piles.\nThe second line contains N space separated integers A1, A2, ..., AN denoting the number of stones in each pile.\n\n-----Output-----\nFor each test case, output a single line containg the maximum number of stones that Chef can remove.\n\n-----Constraints-----\n- 1 ≤ Ai ≤ 109\n- Subtask 1 (35 points): T = 10, 1 ≤ N ≤ 1000\n- Subtask 2 (65 points): T = 10, 1 ≤ N ≤ 105 \n\n-----Example-----\nInput:\n2\n3\n1 2 3\n3\n1 2 1\n\nOutput:\n4\n3\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef alternating_elements : List Nat → List Nat\n  | [] => []\n  | [x] => [x]\n  | x::_::xs => x :: alternating_elements xs", "vc-helpers": "", "vc-definitions": "def max_stones_removed (n : Nat) (piles : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_stones_removed_identity (n : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n piles = max_stones_removed n piles :=\nsorry\n\ntheorem max_stones_removed_n_independent (n₁ n₂ : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n₁ piles = max_stones_removed n₂ piles :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 1]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval max_stones_removed 4 [4, 3, 2, 1]"}
{"id": "fvapps_001066", "vc-description": "/-\nAfter failing to clear his school mathematics examination, infinitepro decided to prepare very hard for his upcoming re-exam, starting with the topic he is weakest at ― computational geometry.\nBeing an artist, infinitepro has C$C$ pencils (numbered 1$1$ through C$C$); each of them draws with one of C$C$ distinct colours. He draws N$N$ lines (numbered 1$1$ through N$N$) in a 2D Cartesian coordinate system; for each valid i$i$, the i$i$-th line is drawn with the ci$c_i$-th pencil and it is described by the equation y=ai⋅x+bi$y = a_i \\cdot x + b_i$.\nNow, infinitepro calls a triangle truly-geometric if each of its sides is part of some line he drew and all three sides have the same colour. He wants to count these triangles, but there are too many of them! After a lot of consideration, he decided to erase a subset of the N$N$ lines he drew. He wants to do it with his eraser, which has length K$K$.\nWhenever erasing a line with a colour i$i$, the length of the eraser decreases by Vi$V_i$. In other words, when the eraser has length k$k$ and we use it to erase a line with a colour i$i$, the length of the eraser decreases to k−Vi$k-V_i$; if k<Vi$k < V_i$, it is impossible to erase such a line.\nSince infinitepro has to study for the re-exam, he wants to minimise the number of truly-geometric triangles. Can you help him find the minimum possible number of truly-geometric triangles which can be obtained by erasing a subset of the N$N$ lines in an optimal way? He promised a grand treat for you if he passes the examination!\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of the input contains three space-separated integers N$N$, C$C$ and K$K$.\n- N$N$ lines follow. For each i$i$ (1≤i≤N$1 \\le i \\le N$), the i$i$-th of these lines contains three space-separated integers ai$a_i$, bi$b_i$ and ci$c_i$.\n- The last line contains C$C$ space-separated integers V1,V2,…,VC$V_1, V_2, \\ldots, V_C$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the smallest possible number of truly-geometric triangles after erasing lines.\n\n-----Constraints-----\n- 1≤T≤10$1 \\le T \\le 10$\n- 1≤C≤N≤3,000$1 \\le C \\le N \\le 3,000$\n- 0≤K≤3,000$0 \\le K \\le 3,000$\n- 0≤ai,bi≤109$0 \\le a_i, b_i \\le 10^9$ for each valid i$i$\n- 1≤ci≤C$1 \\le c_i \\le C$ for each valid i$i$\n- 0≤Vi≤K$0 \\le V_i \\le K$ for each valid i$i$\n- no two lines coincide, regardless of their colours\n- no three lines are concurrent\n\n-----Subtasks-----\nSubtask #1 (10 points):\n- N≤10$N \\le 10$\n- K≤100$K \\le 100$\nSubtask 2 (15 points):\n- V1=V2=…=VC$V_1 = V_2 = \\ldots = V_C$\n- no two lines are parallel\nSubtask #3 (25 points): no two lines are parallel\nSubtask #4 (50 points): original constraints\n\n-----Example Input-----\n2\n7 2 13\n1 10 1\n1 14 2\n6 4 1\n2 2 1\n0 12 2\n2 11 2\n0 6 1\n8 10\n6 1 20\n1 5 1\n2 11 1\n4 0 1\n6 8 1\n0 11 1\n3 3 1\n9\n\n-----Example Output-----\n2\n4\n\n-----Explanation-----\nExample case 1: We can remove exactly one line. Initially, we have 5$5$ truly geometric triangles (see the image below; red is colour 1$1$ and green is colour 2$2$).\n- Removing any line with colour 2$2$ brings the total number of truly-geometric triangles down to 4+0=4$4+0=4$.\n- Removing any line with colour 1$1$ brings the total number of truly-geometric triangles down to 1+1=2$1+1=2$.\nThus, the smallest number of truly-geometric triangles we can obtain is 2$2$.\n\nExample case 2: We can remove at most 2$2$ lines and removing any 2$2$ lines gives us a total of 4$4$ truly-geometric triangles.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def nc3 (n : Nat) : Nat :=\n  sorry\n\ndef solve (n : Nat) (c : Nat) (k : Nat) (lines : List (List Nat)) (v : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem nc3_nonnegative (n : Nat) :\n  nc3 n ≥ 0 :=\nsorry\n\ntheorem nc3_zero_for_small_n (n : Nat) :\n  n < 3 → nc3 n = 0 :=\nsorry\n\ntheorem nc3_formula (n : Nat) :\n  nc3 n = n * (n-1) * (n-2) / 6 :=\nsorry\n\ntheorem solve_nonnegative (n c k : Nat) (lines : List (List Nat)) (v : List Nat) :\n  solve n c k lines v ≥ 0 :=\nsorry\n\ntheorem solve_bounded_by_combinations\n  (n c k : Nat) (lines : List (List Nat)) (v : List Nat)\n  (validLines := List.filter (fun line => line.get! 2 ≤ c) lines) :\n  solve n c k lines v ≤ nc3 validLines.length :=\nsorry\n\ntheorem solve_empty :\n  solve 0 1 1 [] [1] = 0 :=\nsorry\n\ntheorem solve_minimal :\n  solve 1 1 1 [[0,0,1]] [1] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 7 2 13 [[1, 10, 1], [1, 14, 2], [6, 4, 1], [2, 2, 1], [0, 12, 2], [2, 11, 2], [0, 6, 1]] [8, 10]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 6 1 20 [[1, 5, 1], [2, 11, 1], [4, 0, 1], [6, 8, 1], [0, 11, 1], [3, 3, 1]] [9]"}
{"id": "fvapps_001069", "vc-description": "/-\nChef Ada is preparing $N$ dishes (numbered $1$ through $N$). For each valid $i$, it takes $C_i$ minutes to prepare the $i$-th dish. The dishes can be prepared in any order.\nAda has a kitchen with two identical burners. For each valid $i$, to prepare the $i$-th dish, she puts it on one of the burners and after $C_i$ minutes, removes it from this burner; the dish may not be removed from the burner before those $C_i$ minutes pass, because otherwise it cools down and gets spoiled. Any two dishes may be prepared simultaneously, however, no two dishes may be on the same burner at the same time. Ada may remove a dish from a burner and put another dish on the same burner at the same time.\nWhat is the minimum time needed to prepare all dishes, i.e. reach the state where all dishes are prepared?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $C_1, C_2, \\ldots, C_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the minimum number of minutes needed to prepare all dishes.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 4$\n- $1 \\le C_i \\le 5$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (1 points): $C_1 = C_2 = \\ldots = C_N$\nSubtask #2 (99 points): original constraints\n\n-----Example Input-----\n3\n3\n2 2 2\n3\n1 2 3\n4\n2 3 4 5\n\n-----Example Output-----\n4\n3\n7\n\n-----Explanation-----\nExample case 1: Place the first two dishes on the burners, wait for two minutes, remove both dishes and prepare the last one on one burner.\nExample case 2: Place the first and third dish on the burners. When the first dish is prepared, remove it and put the second dish on the same burner.\nExample case 3: Place the third and fourth dish on the burners. When the third dish is prepared, remove it and put the second dish on the same burner. Similarly, replace the fourth dish (when it is prepared) by the first dish on the other burner.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_cooking_time (n: Nat) (times: List Nat) : Nat :=\n  sorry\n\ndef list_maximum (l: List Nat) : Nat :=\n  sorry\n\ndef list_sorted_take (l: List Nat) (n: Nat) : List Nat :=\n  sorry\n\ndef list_sum (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_cooking_time_lower_bound_half_sum {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times ≥ (list_sum usedTimes) / 2 := by\n  sorry\n\ntheorem min_cooking_time_lower_bound_max {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  min_cooking_time n times ≥ list_maximum (times.take n) := by\n  sorry\n\ntheorem min_cooking_time_upper_bound_sum {n: Nat} {times: List Nat}\n  (h1: 1 ≤ n) (h2: n ≤ 100) (h3: times.length ≥ 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times ≤ list_sum usedTimes := by\n  sorry\n\ntheorem min_cooking_time_equal_times {n: Nat} (h1: 1 ≤ n) (h2: n ≤ 100) :\n  let times := List.replicate n 10\n  min_cooking_time n times = ((n + 1) / 2) * 10 := by\n  sorry\n\ntheorem min_cooking_time_single_item {times: List Nat} (h: times.length ≥ 1) :\n  min_cooking_time 1 times = list_maximum times := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [2, 2, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [1, 2, 3]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_cooking_time 4 [2, 3, 4, 5]"}
{"id": "fvapps_001071", "vc-description": "/-\nPolo, the Penguin, likes numbers. He says that the goodness of a number is itself multiplied by the number of digits in it's decimal representation. For example, the goodness of the integer 474 is 474*3 = 1422.\nHelp him to count the sum of goodness of all integers from L to R, inclusive. Since the answer can be too large, output it modulo 1,000,000,007 (10^9+7).\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. The only line of each test case contains the pair of integers L and R, separated by a single space.\n\n-----Output-----\nFor each test case, output a single line containing the answer to the corresponding test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1,000\n- 1 ≤ L ≤ R ≤ 1,000,000,000 (10^9)\n\n-----Example-----\nInput:\n1\n9 12\n\nOutput:\n75\n\n-----Explanation-----\nExample case 1. The answer is 9*1 + 10*2 + 11*2 + 12*2 = 75.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_goodness_sum (a b : Nat) : Nat :=\n  sorry\n\ndef MOD := 1000000007\n\ndef num_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem monotonic_increasing (n : Nat) (h : 1 < n) (h2 : n ≤ 10000) :\n  calculate_goodness_sum 1 (n-1) ≤ calculate_goodness_sum 1 n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 75\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 9 12\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 1 5\n\n/--\ninfo: 66\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 10 12"}
{"id": "fvapps_001078", "vc-description": "/-\nYou are given a tree with $N$ vertices (numbered $1$ through $N$) and a sequence of integers $A_1, A_2, \\ldots, A_N$. You may choose an arbitrary permutation $p_1, p_2, \\ldots, p_N$ of the integers $1$ through $N$. Then, for each vertex $i$, you should assign the value $A_{p_i}$ to this vertex.\nThe profit of a path between two vertices $u$ and $v$ is the sum of the values assigned to the vertices on that path (including $u$ and $v$).\nLet's consider only (undirected) paths that start at a leaf and end at a different leaf. Calculate the maximum possible value of the sum of profits of all such paths. Since this value could be very large, compute it modulo $10^9 + 7$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n- Each of the following $N−1$ lines contains two space-separated integers $u$ and $v$ denoting that vertices $u$ and $v$ are connected by an edge.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the maximum sum of profits, modulo $10^9 + 7$.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 300,000$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $5 \\cdot 10^5$\n\n-----Example Input-----\n2\n4\n1 2 3 4\n1 2\n2 3\n2 4\n5\n1 2 3 4 5\n1 2\n2 3\n3 4\n4 5\n\n-----Example Output-----\n24\n15\n\n-----Explanation-----\nExample case 1: $(1, 4, 2, 3)$ is one of the possible permutations that give the optimal answer. Then, the profits of paths between pairs of vertices $(1, 3)$, $(1, 4)$ and $(3, 4)$ are $7$, $8$ and $9$ respectively.\nExample case 2: Here, any permutation could be chosen.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_path_profits (n: Nat) (values: List Nat) (edges: List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_valid_tree (n: Nat) (edges: List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem single_node_case (n: Nat) (values: List Nat) :\n  n = 1 → solve_max_path_profits n values [] = 0 := by\n  sorry\n\ntheorem valid_inputs_result_properties (n: Nat) (values: List Nat) (edges: List (Nat × Nat)) :\n  n ≥ 2 →\n  values.length ≥ n →\n  is_valid_tree n edges = true →\n  let result := solve_max_path_profits n values edges\n  (result ≥ 0 ∧ result ≤ 10^9 + 7) := by\n  sorry\n\ntheorem line_graph_properties (n: Nat) (values: List Nat) :\n  n ≥ 2 →\n  values.length ≥ n →\n  let edges := List.range (n-1) |>.map (fun i => (i+1, i+2))\n  let result := solve_max_path_profits n values edges\n  result ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval solve_max_path_profits 4 [1, 2, 3, 4] [(1, 2), (2, 3), (2, 4)]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval solve_max_path_profits 5 [1, 2, 3, 4, 5] [(1, 2), (2, 3), (3, 4), (4, 5)]"}
{"id": "fvapps_001081", "vc-description": "/-\nChef is playing a game which contains a binary string. \nHe can perform one operation only:\n- Toggle the i_th bit of the string (0 to 1 or 1 to 0)\nBy performing operations on the string (can be zero times), you have to convert the string with no adjacent bit being the same.\nCan you help chef ?\n\n-----Input:-----\n- First line will contain $T$, number of test cases. Then the test cases follow. \n- First line of each test case, contains the size of the  string $N$\n- Seond line contains a single line of input, the binary string. \n\n-----Output:-----\nFor each testcase, output in a single line answer - the minimum operations.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $2 \\leq |S| \\leq 10^3$\n\n-----Sample Input:-----\n1\n4\n1011\n\n-----Sample Output:-----\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_operations_to_alternating (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef is_alternating (s : String) : Bool :=\n  sorry\n\ndef make_alternating_01 (n : Nat) : String :=\n  sorry\n\ndef make_alternating_10 (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem uniform_string_flips (n : Nat) (c : Char) :\n  let s := String.mk (List.replicate n c)\n  let ops := min_operations_to_alternating n s\n  ops = n/2 ∨ ops = (n+1)/2 :=\nsorry\n\ntheorem length_result_bounded (n : Nat) (s : String) :\n  s.length = n →\n  let ops := min_operations_to_alternating n s\n  0 ≤ ops ∧ ops ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1011\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1111\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 6 \"101010\""}
{"id": "fvapps_001085", "vc-description": "/-\nRavi is very good student in mathematics and he also like Even numbers very much .\n\nOn the other hand his friend Jhon like Odd numbers . Both of them are preparing for IIT JEE Advance .One day they are solving a  question together the question was Find the sum of first $n$ terms of the given series  $1^2+2.2^2+3^2+2.4^2+5^2+2.6^2+...........$\nIf the sum is odd then Jhon will be happy and will solve 2 more questions,and Ravi will not attempt more questions. If sum is even Ravi will  be happy and will solve 2 more questions and Jhon will not attempt more questions. \nSo Your task is to decide who will solve more questions.\n\n-----Input:-----\n- First line will contain $n$, number of terms  in the given series.\n\n-----Output:-----\nOutput single line \"Ravi\" if he solve more questions or \"Jhon\" if he solve more questions.\n\n-----Constraints-----\n- $1 \\leq n \\leq 100$\n\n-----Sample Input:-----\n2\n\n3   \n\n-----Sample Output:-----\nJhon       \nRavi       \n\n-----EXPLANATION:-----\nIn the first test cases  sum of 2 terms is 9 (according to the given series) which is an odd number   so Jhon will solve 2 more questions and Ravi will not attempt more questions.\nIn second test case sum of 3 terms is 18 (according to the given series) which is an  even number according to the given series  so Ravi will solve 3 more questions and Jhon will not attempt more questions.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def seriesSumSolver (n : Nat) : String :=\nsorry\n\ndef squaredSum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem series_sum_solver_returns_valid_name (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 1000000) :\n    seriesSumSolver n = \"Ravi\" ∨ seriesSumSolver n = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_alternates (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 10000) :\n    (seriesSumSolver n = \"Ravi\" ↔ squaredSum n % 2 = 0) :=\nsorry\n\ntheorem series_sum_solver_consistent (n : Nat)\n    (h : 1 ≤ n ∧ n ≤ 1000000) :\n    seriesSumSolver n = seriesSumSolver n :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_1 :\n    seriesSumSolver 1 = \"Ravi\" ∨ seriesSumSolver 1 = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_2 :\n    seriesSumSolver 2 = \"Ravi\" ∨ seriesSumSolver 2 = \"Jhon\" :=\nsorry\n\ntheorem series_sum_solver_works_on_edge_cases_3 :\n    seriesSumSolver 1000000 = \"Ravi\" ∨ seriesSumSolver 1000000 = \"Jhon\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Jhon'\n-/\n#guard_msgs in\n#eval series_sum_solver 2\n\n/--\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 3\n\n/--\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 4"}
{"id": "fvapps_001090", "vc-description": "/-\nNitika was once reading a history book and wanted to analyze it. So she asked her brother to create a list of names of the various famous personalities in the book. Her brother gave Nitika the list. Nitika was furious when she saw the list. The names of the people were not properly formatted. She doesn't like this and would like to properly format it.\nA name can have at most three parts: first name, middle name and last name. It will have at least one part. The last name is always present. The rules of formatting a name are very simple:\n\n- Only the first letter of each part of the name should be capital.\n- All the parts of the name except the last part should be represented by only two characters. The first character should be the first letter of the part and should be capitalized. The second character should be \".\".\n\nLet us look at some examples of formatting according to these rules:\n- gandhi -> Gandhi\n\n- mahatma gandhI -> M. Gandhi \n- Mohndas KaramChand ganDhi -> M. K. Gandhi \n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases.\nThe only line of each test case contains the space separated parts of the name.\n\n-----Output-----\nFor each case, output the properly formatted name.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 2 ≤ Length of each part of the name ≤ 10\n- Each part of the name contains the letters from lower and upper case English alphabets (i.e. from 'a' to 'z', or 'A' to 'Z')\n\n-----Subtasks-----\nSubtask #1 (40 points)\n- There is exactly one part in the name.\n\nSubtask #2 (60 points)\n- Original constraints.\n\n-----Example-----\nInput:\n3\ngandhi\nmahatma gandhI\nMohndas KaramChand gandhi\n\nOutput:\nGandhi \nM. Gandhi \nM. K. Gandhi \n\n-----Explanation-----\nThe examples are already explained in the problem statement.\n-/\n\n-- Result is a string\n\n-- Last part is capitalized original\n\n-- Other parts are initials\n\n-- Result is a string\n\n-- Parts lengths match\n\n-- Initials format\n\n-- Last name is starts with uppercase", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidNamePart (s: String) : Bool :=\n  sorry\n\ndef formatName (input: List String) : String :=\n  sorry\n\ndef formatNameStr (input: String) : String :=\n  sorry", "vc-theorems": "theorem format_name_list_properties {parts: List String}\n  (h: ∃ p ∈ parts, isValidNamePart p = true) :\n  let result := formatName parts\n  let resultParts := result.split (· = ' ')\n\n  result.length ≥ 0 ∧\n\n  resultParts.getLast! = (parts.getLast!).capitalize ∧\n\n  (parts.length > 1 →\n    ∀ i < parts.length - 1,\n    resultParts[i]! = s!\"{(parts[i]!).get 0}.\") :=\nsorry\n\ntheorem format_name_string_properties {input: String}\n  (h: ∃ c ∈ input.data, c.isAlpha) :\n  let validParts := (input.split (· = ' ')).filter isValidNamePart\n  let result := formatNameStr input\n  let resultParts := result.split (· = ' ')\n  (validParts.length > 0) →\n\n  result.length ≥ 0 ∧\n\n  resultParts.length = validParts.length ∧\n\n  (validParts.length > 1 →\n    ∀ i < validParts.length - 1,\n    (resultParts[i]!).endsWith \".\" ∧\n    (resultParts[i]!).length = 2) ∧\n\n  (resultParts.getLast!).get 0 ≥ 'A' ∧\n  (resultParts.getLast!).get 0 ≤ 'Z' :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"gandhi\"\n\n/--\ninfo: 'M. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"mahatma gandhI\"\n\n/--\ninfo: 'M. K. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"Mohndas KaramChand gandhi\""}
{"id": "fvapps_001094", "vc-description": "/-\nChef has an array of N natural numbers most of them are repeated. Cheffina challenges chef to find all numbers(in ascending order) whose frequency is strictly more than K.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, two integers $N, K$.\n- N space-separated natural numbers.\n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N, K \\leq 10^5$\n- $1 \\leq arr[i] \\leq 10^5$\n\n-----Sample Input:-----\n1\n5 1\n5 2 1 2 5\n\n-----Sample Output:-----\n2 5\n-/\n\n-- Result contains only numbers appearing more than k times\n\n-- All numbers appearing more than k times are in result\n\n-- Result is sorted\n\n-- All result elements exist in input array", "vc-preamble": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def find_frequent_numbers (n : Nat) (k : Nat) (arr : List Nat) : List Nat :=\n  sorry\n\ndef count {α} [BEq α] (as : List α) (a : α) : Nat :=\n  sorry\n\ndef uniqueSort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem frequent_numbers_properties\n  (n : Nat) (k : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k ≤ 19)\n  (h3 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  let result := find_frequent_numbers n k arr\n\n  ∀ num ∈ result, count arr num > k\n\n  ∧ ∀ num ∈ arr, count arr num > k → num ∈ result\n\n  ∧ isSorted result\n\n  ∧ ∀ num ∈ result, num ∈ arr :=\nsorry\n\ntheorem k_zero_returns_unique\n  (n : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  find_frequent_numbers n 0 arr = uniqueSort arr :=\nsorry\n\ntheorem large_k_returns_empty\n  (n : Nat) (k extra : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k = n + extra)\n  (h3 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 20) :\n  find_frequent_numbers n k arr = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: [2, 5]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 5 1 [5, 2, 1, 2, 5]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 6 2 [1, 1, 1, 2, 2, 3]\n\n/--\ninfo: [1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 4 0 [4, 2, 3, 1]"}
{"id": "fvapps_001100", "vc-description": "/-\nVishal Wants to buy 2 gifts for his best friend whose name is Annabelle(her age is 20), So they both went for shopping in a store. But Annabelle gave, Vishal a condition that she will accept this gifts only when the total price of the gifts is the same as her age times 100.\nThe store contains, a list of items whose prices are also displayed, Now Vishal is asking for your help to buy gifts, as he wants to impress Annabelle this time.\nNote: Vishal cannot buy the same item more than once.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$. $T$ denoting the number of test cases. The description of $T$ test cases is as follows.\n- The next line of the input contains a single integer $N$. $N$ denotes the total number of items in store.\n- The next line of the input contains $N$ space-separated integers $A1, A2, A3...An$ where $ith$ number denotes the price of $ith$ element.\n\n-----Output:-----\n- For each test-case print \"Accepted\"(without quotes) if the gifts are accepted by Annabelle, else print \"Rejected\"(without quotes)\n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq A1, A2, A3...An \\leq 10^7$\n\n-----Sample Input:-----\n1\n5\n10 2 1000 50 1000\n\n-----Sample Output:-----\nAccepted\n\n-----Explanation:-----\n- As the given list of items have 2 items whose price sum up to the age times 100 of Annabelle i.e. 1000+1000 = (20 *100)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_gift_pair (n : Nat) (prices : List Nat) : String :=\nsorry\n\ndef process_test_cases (numCases : Nat) (cases : List (Nat × List Nat)) : List String :=\nsorry\n\ndef permutation (xs : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem find_gift_pair_order_independence (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n (permutation prices) :=\nsorry\n\ntheorem find_gift_pair_result (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = \"Accepted\" ∨ find_gift_pair n prices = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_deterministic (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n prices :=\nsorry\n\ntheorem process_test_cases_preserves_result (n : Nat) (prices : List Nat) :\n  let test_cases := [(n, prices)]\n  let results := process_test_cases 1 test_cases\n  results.length = 1 ∧\n  results[0]! = find_gift_pair n prices :=\nsorry\n\ntheorem find_gift_pair_empty : find_gift_pair 0 [] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_single : find_gift_pair 1 [1000] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_too_small : find_gift_pair 3 [1, 1, 1] = \"Rejected\" :=\nsorry\n\ntheorem find_gift_pair_too_large : find_gift_pair 3 [2001, 2001, 2001] = \"Rejected\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 5 [10, 2, 1000, 50, 1000]\n\n/--\ninfo: 'Rejected'\n-/\n#guard_msgs in\n#eval find_gift_pair 3 [500, 500, 500]\n\n/--\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 4 [1000, 1000, 50, 60]"}
{"id": "fvapps_001106", "vc-description": "/-\nDevu loves to play with binary strings a lot. One day he borrowed a binary string s of size n from his friend Churu. Before starting to play with it, he wants to make sure that string does not contain more than  k consecutive equal characters. For achieving that, only kind of operation he is allowed to perform is to flip any ith character of the string. \n\nAs Devu is always in hurry to meet his girlfriend, he wants you to help him in finding out the minimum number of operations he will need. Also he wants you to print one of the possible modified string too.\n\n-----Input-----\n- First line of input contains an integer T denoting the number of test cases. \n- For each test case, there are two lines. \n- First line contains two space separated integers n, k as defined in the problem. \n- Next line contains string s of size n.\n\n-----Output-----\n- For each test case, print two lines.\n- First line should contain an integer corresponding to minimum number of operations Devu needs.\n- In second line, print one of the possible modified strings.\n\n-----Constraints-----\nSubtask #1: 20 points\n- 1 ≤ T ≤ 100, 1 ≤ n ≤ 20, 1 ≤ k ≤ n\n\nSubtask #2: 35 points\n- 1 ≤ T ≤ 102, 1 ≤ n ≤ 103, 1 ≤ k ≤ n\n\nSubtask #3: 45 points\n- 1 ≤ T ≤ 105, 1 ≤ n ≤ 105, 1 ≤ k ≤ n\n- Sum of n over all the test cases is ≤ 106 \n\n-----Example-----\nInput:\n3\n2 1\n11\n2 2\n11\n4 1\n1001\n\nOutput:\n1\n10\n0\n11\n2\n1010\n\n-----Explanation-----\nExample case 1: As 1 is occurring twice consecutively, we can convert 11 to 10 in a single operation.\nExample case 2: You don't need to modify the string as it does not have more than 2 equal consecutive character.\nExample case 3: As 0 is occurring twice consecutively, we can convert 1001 to 1010 in a two operations (Flip third and fourth character).\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n-- Output type properties", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_binary_flips (n k : Nat) (s : String) : Nat × String :=\nsorry\n\ndef is_alternating (s : String) : Bool :=\nsorry\n\ndef check_consecutive (s : String) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem binary_flips_basic_properties {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 0) (h3 : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (flips, result) := solve_binary_flips n k s\n\n  flips ≥ 0 ∧\n  result.length = n ∧\n  (∀ c ∈ result.data, c = '0' ∨ c = '1') :=\nsorry\n\ntheorem k_one_alternating {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) := solve_binary_flips n 1 s\n  is_alternating result = true :=\nsorry\n\ntheorem k_gt_one_consecutive {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 1) (h3 : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) := solve_binary_flips n k s\n  check_consecutive result k = true :=\nsorry\n\ntheorem k_equals_n_no_flips {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (flips, result) := solve_binary_flips n n s\n  flips = 0 ∧ result = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001111", "vc-description": "/-\nChef had an interesting dream last night. He dreamed of a new revolutionary chicken recipe. When he woke up today he tried very hard to reconstruct the ingredient list. But, he could only remember certain ingredients. To simplify the problem, the ingredient list can be represented by a string of lowercase characters 'a' - 'z'.\nChef can recall some characters of the ingredient list, all the others, he has forgotten. However, he is quite sure that the ingredient list was a palindrome.\nYou are given the ingredient list Chef dreamed last night. The forgotten characters are represented by a question mark ('?'). Count the number of ways Chef can replace the forgotten characters with characters 'a' - 'z' in such a way that resulting ingredient list is a palindrome.\n\n-----Input-----\nThe first line of input contains a single integer T, the number of test cases. T lines follow, each containing a single non-empty string - the ingredient list as recalled by Chef. Whatever letters he couldn't recall are represented by a '?'.\n\n-----Output-----\nFor each test case, output a single line containing the number of valid ways the ingredient list could be completed. Since the answers can be very large, output each answer modulo 10,000,009.\n\n-----Example-----\nInput:\n5\n?\n??\nab?\na?c\naba\n\nOutput:\n26\n26\n1\n0\n1\n\n-----Constraints-----\n\n1 ≤ T ≤ 20\n\n1 ≤ sum of length of all input strings ≤ 1,000,000\n\nEach input string contains only lowercase roman letters ('a' - 'z') or question marks.\n-/", "vc-preamble": "def mkPos (s : String) (i : Nat) (h : i < s.length) : String.Pos := ⟨i⟩", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : String) : Bool :=\nsorry\n\ndef countPalindromeCompletions (s : String) : Nat :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem countPalindromeCompletions_nonnegative (s : String) :\n  countPalindromeCompletions s ≥ 0 :=\nsorry\n\ntheorem countPalindromeCompletions_impossible_case (s : String) (i : Nat)\n  (h1 : i < s.length / 2)\n  (h2 : i < s.length)\n  (h3 : s.length - 1 - i < s.length)\n  (h4 : s.get (mkPos s i h2) ≠ '?' ∧ s.get (mkPos s (s.length - 1 - i) h3) ≠ '?')\n  (h5 : s.get (mkPos s i h2) ≠ s.get (mkPos s (s.length - 1 - i) h3)) :\n  countPalindromeCompletions s = 0 :=\nsorry\n\ntheorem countPalindromeCompletions_bounded (s : String) :\n  countPalindromeCompletions s ≤ 10000009 :=\nsorry\n\ntheorem countPalindromeCompletions_all_question_marks (s : String) (h : ∀ c ∈ s.data, c = '?') :\n  countPalindromeCompletions s = (26 ^ ((s.length + 1) / 2)) % 10000009 :=\nsorry\n\ntheorem countPalindromeCompletions_no_question_marks (s : String) (h : '?' ∉ s.data) :\n  countPalindromeCompletions s = if isPalindrome s then 1 else 0 :=\nsorry\n\ntheorem countPalindromeCompletions_deterministic (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions s :=\nsorry\n\ntheorem countPalindromeCompletions_symmetry (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions (reverseString s) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"?\"\n\n/--\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"??\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"aba\""}
{"id": "fvapps_001112", "vc-description": "/-\nIn the 2-D world of Flatland, the Circles were having their sports day and wanted to end it with a nice formation. So, they called upon Mr. Sphere from Spaceland for help. Mr Sphere decides to arrange the Circles in square formations. He starts with $N$ Circles and forms the largest possible square using these Circles. He then takes the remaining Circles and repeats the procedure. A square of side $S$ requires $S^2$ Circles to create.\nFind the number of squares he will be able to form at the end of the process.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow.\n- Each testcase contains of a single integer $N$.\n\n-----Output:-----\nFor each testcase, output a single integer denoting the number of squares.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq N \\leq 1000$\n\n-----Sample Input:-----\n2\n\n85\n\n114          \n\n-----Sample Output:-----\n2\n\n4\n\n-----EXPLANATION:-----\nTest case 1 : Mr Sphere forms a square of side 9 using 81 Circles and then forms a square of side 2 using the remaining 4.\n-/\n\n/- Every positive number can be decomposed into a sum of squares,\n    and the count of squares is positive and not larger than the input number -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The decomposition count equals 1 for perfect squares -/\n\n/- Basic results for small numbers -/\n\n/- The sum of squares used in decomposition equals the input number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_squares (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_squares_basic_properties (n : Nat) (h : n > 0) :\n  let result := count_squares n\n  0 < result ∧ result ≤ n :=\nsorry\n\ntheorem count_squares_perfect (n : Nat) (h : n > 0) :\n  count_squares (n * n) = 1 :=\nsorry\n\ntheorem count_squares_small_numbers :\n  count_squares 1 = 1 ∧\n  count_squares 2 = 2 ∧\n  count_squares 3 = 3 :=\nsorry\n\ntheorem count_squares_sum_property (n : Nat) (h : n > 0) :\n  ∃ (squares : List Nat),\n    squares.length ≤ count_squares n ∧\n    (∀ x ∈ squares, ∃ k, x = k * k) ∧\n    (squares.foldl (· + ·) 0 = n) :=\nsorry", "vc-postamble": "/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 85\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_squares 114\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 10"}
{"id": "fvapps_001118", "vc-description": "/-\nWrite a program, which takes an integer N and if the number is less than 10 then display \"Thanks for helping Chef!\" otherwise print \"-1\".\n\n-----Input-----\n\nThe first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, output the given string or -1 depending on conditions, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- -20 ≤ N ≤ 20\n\n-----Example-----\nInput\n3 \n1\n12\n-5\nOutput\nThanks for helping Chef!\n-1\nThanks for helping Chef!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_helper_thanks (n : Int) : String :=\nsorry\n\ndef solve_multiple_cases (nums : List Int) : List String :=\nsorry", "vc-theorems": "theorem solve_helper_thanks_result_valid (n : Int) :\n  (solve_helper_thanks n = \"-1\") ∨\n  (solve_helper_thanks n = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_length (nums : List Int) :\n  (solve_multiple_cases nums).length = nums.length :=\nsorry\n\ntheorem solve_helper_thanks_condition (n : Int) :\n  (n < 10) = (solve_helper_thanks n = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_valid_results (nums : List Int) :\n  ∀ x ∈ solve_multiple_cases nums,\n    (x = \"-1\") ∨ (x = \"Thanks for helping Chef!\") :=\nsorry\n\ntheorem solve_multiple_cases_condition (nums : List Int) :\n  ∀ (i : Nat), i < nums.length →\n    ((nums[i]! < 10) =\n     ((solve_multiple_cases nums)[i]! = \"Thanks for helping Chef!\")) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: test1_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [1, 12, -5]\n\n/--\ninfo: test2_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [-20, 0, 20]\n\n/--\ninfo: test3_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [9, 10]"}
{"id": "fvapps_001120", "vc-description": "/-\nRecently, chef Ciel often hears about lucky numbers.\n\nEverybody knows that lucky numbers are positive integers\nwhose decimal representation contains only the lucky digits 4 and 7.\nFor example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nCiel decides to make Ciel numbers.\nAs you know, Ciel likes the digit 8 very much.\nAnd then, Ciel likes the digits 5 and 3.\nSo Ciel defines Ciel numbers as the positive integers k such that d(k, 8) ≥ d(k, 5) ≥ d(k, 3) and d(k, i) = 0 for all i = 0, 1, 2, 4, 6, 7, 9,\nwhere d(k, i) denotes the number of the digit i in the decimal representation of the integer k.\nFor example, the first few Ciel numbers are 8, 58, 85, 88, 358, 385, 538, 583, 588, 835, 853, 858, 885, 888, ....\n\nCiel's restaurant has N menus.\nAnd Ciel want to know how many menus have Ciel numbers as their price.\nYour task is to find it.\n\n-----Input-----\n\nThe first line contains an integer N.\nThen N lines follow.\nEach line has the name Si of the menu and its price Pi separated by a single space.\n\n-----Output-----\n\nPrint the number of menus whose prices are one of Ciel numbers.\n\n-----Constraints-----\n\n1 ≤ N ≤ 1000\n\n1 ≤ |Si| ≤ 100, where |Si| denotes the length of Si\n\nEach letter of Si is either an alphabetical letter or a digit or a single quotation mark or a space.\n\n1 ≤ Pi < 1000000 (106)\nPi contains no leading zeros.\n\n-----Sample Input-----\n6\nmilk 58\nCiel's Drink 80\nThe curry 2nd edition 888888\nrice omelet 85855\nunagi 1\nThe first    and last letters can be a space    358\n\n-----Sample Output-----\n3\n\n-----Output details-----\n\n58 and 888888 and 358 are Ciel numbers.\n80 and 85855 and 1 are not Ciel numbers.\n\n-----Notes-----\n\nDifferent operating systems have different ways of representing a newline; do not assume one particular way will be used.\n-/", "vc-preamble": "def count_char (s : String) (c : Char) : Nat :=\n  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def count_ciel_number_prices (menu_items : List String) : Nat :=\n  sorry", "vc-theorems": "theorem count_result_bounded (menu_items : List String) :\n  0 ≤ count_ciel_number_prices menu_items ∧\n  count_ciel_number_prices menu_items ≤ menu_items.length :=\nsorry\n\ntheorem count_result_bounded_with_format\n  (menu_items : List String)\n  (h : ∀ item ∈ menu_items, ∃ words price, item = words ++ \" \" ++ price ∧ price.all (λ c => '0' ≤ c ∧ c ≤ '9')) :\n  0 ≤ count_ciel_number_prices menu_items ∧\n  count_ciel_number_prices menu_items ≤ menu_items.length :=\nsorry\n\ntheorem count_ciel_numbers_positive\n  (menu_items : List String)\n  (h : ∃ item ∈ menu_items,\n    let price := (item.split (· = ' ')).getLast!\n    price.all (λ c => c = '8' ∨ c = '5' ∨ c = '3') ∧\n    count_char price '8' ≥ count_char price '5' ∧\n    count_char price '5' ≥ count_char price '3') :\n  count_ciel_number_prices menu_items > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"milk 58\", \"Ciel\"s Drink 80\", \"The curry 2nd edition 888888\", \"rice omelet 85855\", \"unagi 1\", \"The first and last letters can be a space 358\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"menu 8\", \"special 853\", \"dessert 123\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"item 44\", \"item2 77\"]"}
{"id": "fvapps_001128", "vc-description": "/-\nLittle Elephant is playing a game with arrays. He is given an array A0, A1, ..., AN−1 of N integers. And then Q queries are given, each containing an integer K. He has to tell how many subarrays satisfy the condition: the function foo returns K when it is applied to the subarray.\n\nIn this problem, a subarray is defined as a sequence of continuous elements Ai, Ai+1, ..., Aj  where 0 ≤ i ≤ j ≤ N−1. The function foo, when applied to an array, returns the minimum of all the elements in the array.\n\nFor example, foo returns 5 when it is applied to the array [7, 5, 10, 7, 5, 8]. Please note that the subarrays Ai, Ai+1, ..., Aj and Ak, Ak+1, ..., Al are different if and only if i ≠ k or j ≠ l in this problem.\n\n-----Input-----\nThe first line of input contains N, denoting the size of the array. The next line contains N space separated integers A0, A1, ..., AN−1, denoting the array. Then the next line contains Q, denoting the number of queries. Each query consists of one integer per line, denoting K.\n\n-----Output-----\nFor each query, print the required number of subarrays.\n\n-----Constraints-----\n- 1 ≤ N ≤ 50\n- 1 ≤ Ai ≤ 1000000 (106)\n- 1 ≤ Q ≤ 10\n- 1 ≤ K ≤ 1000000 (106)\n\n-----Example-----\nInput:\n5\n4 1 2 3 4\n4\n3\n4\n6\n1\n\nOutput:\n2\n2\n0\n8\n\n-----Explanation-----\nQuery 1. Only the two subarrays [3, 4] and [3] satisfy.\nQuery 2. Again only the two subarrays [4] and [4] satisfy. Please note that these subarrays (A0 and A4) are considered different.\nQuery 3. No subarray satisfies.\nQuery 4. The eight subarrays [4, 1], [4, 1, 2], [4, 1, 2, 3], [4, 1, 2, 3, 4], [1], [1, 2], [1, 2, 3] and [1, 2, 3, 4] satisfy.\n-/\n\n-- Result should never be negative\n\n-- If k is less than min(arr), result should be 0\n\n-- If k equals min(arr), result should be at least length of array\n\n-- Single element array returns 1 if element equals k, 0 otherwise\n\n-- For array of identical elements, result is n*(n+1)/2\n\n-- For any k, result with k should be >= result with k+1", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_subarrays_with_min (arr : List Int) (k : Int) : Nat :=\n  sorry\n\ndef list_min (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem count_subarrays_nonneg {arr : List Int} {k : Int}\n  (h1 : arr ≠ []) :\n  count_subarrays_with_min arr k ≥ 0 :=\nsorry\n\ntheorem count_subarrays_less_than_min {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : k < list_min arr) :\n  count_subarrays_with_min arr k = 0 :=\nsorry\n\ntheorem count_subarrays_equals_min {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : k = list_min arr) :\n  count_subarrays_with_min arr k ≥ arr.length :=\nsorry\n\ntheorem count_subarrays_single_elem {arr : List Int} {k : Int}\n  (h1 : arr.length = 1) :\n  count_subarrays_with_min arr k = if arr.head! = k then 1 else 0 :=\nsorry\n\ntheorem count_subarrays_identical_elems {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : ∀ x ∈ arr, x = k) :\n  count_subarrays_with_min arr k = (arr.length * (arr.length + 1)) / 2 :=\nsorry\n\ntheorem count_subarrays_monotonic {arr : List Int} {k : Int}\n  (h1 : arr ≠ [])\n  (h2 : ∀ x ∈ arr, x > 0) :\n  count_subarrays_with_min arr k ≥ count_subarrays_with_min arr (k+1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [2, 2] 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [3] 3"}
{"id": "fvapps_001133", "vc-description": "/-\nChef has the string s of length n consisted of digits 4 and 7.\nThe string s is called balanced\nif there exits such integer x (1 ≤ x ≤ n) that the number of digits 4 in substring s[1; x) is equal to the number of digits 7 in substring s(x; n],\nwhere s[1; x) is the substring from the 1st digit to (x-1)th digit of s, and s(x; n] is the substring from the (x+1)th digit to nth digit of s.\nFor example, s = 747474 is a balanced string, because s[1; 4) = 747 has one 4 and s(4; 6] = 74 has one 7.\nNote that x can be 1 or n and s[1; 1) and s(n; n] denote an empty string.\n\nIn one turn Chef can choose any pair of consecutive digits and swap them.\nFind for Chef the total number of different balanced string that can be obtained from string s using any (even 0) number of turns.\nPrint the result modulo 1000000007.\n\n-----Input-----\n\nThe first line of the input contains one integer T, the number of test cases.\nThen T lines follow, each of which contains string s for the corresponding test.\n\n-----Output-----\nT lines, each of which contains single integer - the answer for the corresponding test modulo 109+7.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ n ≤ 5000\n\n-----Example-----\nInput:\n2\n47\n4477\n\nOutput:\n1\n4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveBalancedDigits (s : String) : Nat :=\n  sorry\n\ndef makeBalancedString (m n : Nat) : String :=\n  sorry", "vc-theorems": "theorem equal_fours_and_sevens {n : Nat} (h : n > 0) (h2 : n ≤ 50) :\n  let s := makeBalancedString n n\n  let result := solveBalancedDigits s\n  result ≥ 1 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem arbitrary_fours_and_sevens {m n : Nat}\n  (h1 : m > 0) (h2 : m ≤ 50) (h3 : n > 0) (h4 : n ≤ 50) :\n  let s := makeBalancedString m n\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem valid_string_bounds {s : String}\n  (h : s.length > 0) (h2 : s.length ≤ 50)\n  (h3 : ∀ c ∈ s.data, c = '4' ∨ c = '7') :\n  let result := solveBalancedDigits s\n  result ≥ 0 ∧ result < 10^9 + 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"47\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"4477\""}
{"id": "fvapps_001136", "vc-description": "/-\nOliver and Nova are true lovers. Inspite of knowing that Nova will die Oliver married her at the lake where they met. But they had a conflict about even and odd numbers. Nova likes the odd numbers and Oliver prefers even. One day they went to a fair where Oliver bought some square shaped marshmallows and Nova bought some round shaped. Then they decided to play a game. They will pick a natural number N . Nova will sum up the odd numbers from 1 to N and and she will notedown LCM of R(R is defined in the picture) and the sum she calculated before. And Oliver will sum up the even numbers from 1 to N and and he will notedown LCM of S(S is defined in the picture) and the sum he calculated before. You must use the ceil value of R and S.\n\nNow  whose LCM is strictly greater than the other will win.If both of their LCM is equal Nova will win because Oliver is afraid of Nova.\n$N.B.$ define the value of pi with $acos(-1)$.\n$N.B.$ Sum of all odd number and sum of all even number will not exceed 10^18. \n\n-----Input:-----\nThe first line contains an integer $T$  — the number of test cases in the input. Next, T test cases are given, one per line.\nEach test case is a positive integer $N$  . \n\n-----Output:-----\nPrint T answers to the test cases.\nIn each test cases,\nIf Oliver wins the game, print \"Nova's gonna kill me\" (without quotes) .\nIf Nova wins the game, print \"YESS(sunglass emo)\" (without quotes) .\n\n-----Constraints-----\n- $1 \\leq T \\leq 2000$\n- $1 \\leq N \\leq 1845271$\n\n-----Sample Input:-----\n1\n111\n\n-----Sample Output:-----\nYESS(sunglass emo)\n-/\n\n-- Properties relating to lcm and gcd with same inputs\n\n-- Properties with 1\n\n-- Commutativity properties\n\n-- Solution validation\n\n-- Deterministic output", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lcm (a b : Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef solve_lovers_lcm (n : Nat) : String :=\nsorry", "vc-theorems": "theorem lcm_self (n : Nat) : lcm n n = n :=\nsorry\n\ntheorem gcd_self (n : Nat) (h : n > 0) : gcd n n = n :=\nsorry\n\ntheorem lcm_one (n : Nat) (h : n > 0) : lcm n 1 = n :=\nsorry\n\ntheorem gcd_one (n : Nat) (h : n > 0) : gcd n 1 = 1 :=\nsorry\n\ntheorem lcm_comm (a b : Nat) : lcm a b = lcm b a :=\nsorry\n\ntheorem gcd_comm (a b : Nat) : gcd a b = gcd b a :=\nsorry\n\ntheorem solve_lovers_valid_output (n : Nat) (h : n > 0) :\n  solve_lovers_lcm n = \"Nova's gonna kill me\" ∨\n  solve_lovers_lcm n = \"YESS(sunglass emo)\" :=\nsorry\n\ntheorem solve_lovers_deterministic (n : Nat) :\n  solve_lovers_lcm n = solve_lovers_lcm n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 111\n\n/--\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 10\n\n/--\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 100"}
{"id": "fvapps_001140", "vc-description": "/-\nYou are given a positive integer $N$. Consider the sequence $S = (1, 2, \\ldots, N)$. You should choose two elements of this sequence and swap them.\nA swap is nice if there is an integer $M$ ($1 \\le M < N$) such that the sum of the first $M$ elements of the resulting sequence is equal to the sum of its last $N-M$ elements. Find the number of nice swaps.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single integer $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of nice swaps.\n\n-----Constraints-----\n- $1 \\le T \\le 10^6$\n- $1 \\le N \\le 10^9$\n\n-----Subtasks-----\nSubtask #1 (10 points):\n- $T \\le 10$\n- $N \\le 10^3$\nSubtask #2 (30 points):\n- $T \\le 10$\n- $N \\le 10^6$\nSubtask #3 (60 points): original constraints\n\n-----Example Input-----\n5\n1\n2\n3\n4\n7\n\n-----Example Output-----\n0\n0\n2\n2\n3\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def canSplitEvenly (n : Nat) : Bool :=\n  sorry\n\ndef countPossibleSwaps (n : Nat) : Nat :=\n  sorry\n\ndef solveSwaps (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_swaps_returns_valid_count (n : Nat) (h : n > 0) :\n  let result := solveSwaps n\n  result ≥ 0 ∧ result ≤ countPossibleSwaps n ∧\n  (¬canSplitEvenly n → result = 0) :=\nsorry\n\ntheorem solve_swaps_small_sequences (n : Nat) (h1 : n > 0) (h2 : n ≤ 2) :\n  solveSwaps n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 1\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_swaps 7"}
{"id": "fvapps_001142", "vc-description": "/-\nChef has a natural number N. Cheffina challenges chef to check whether the given number is divisible by the sum of its digits or not. If the given number is divisible then print \"Yes\" else \"No\".\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n16\n27\n\n-----Sample Output:-----\nNo\nYes\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitSum (n : Nat) : Nat :=\n  sorry\n\ndef isDivisibleByDigitSum (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem isDivisibleByDigitSum_spec (n : Nat) (h : n > 0) :\n  let ds := digitSum n\n  isDivisibleByDigitSum n = \"Yes\" ↔ n % ds = 0\n  :=\nsorry\n\ntheorem isDivisibleByDigitSum_returns_valid_result (n : Nat) (h : n > 0) :\n  isDivisibleByDigitSum n = \"Yes\" ∨ isDivisibleByDigitSum n = \"No\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'No'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 16\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 27\n\n/--\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 45"}
{"id": "fvapps_001155", "vc-description": "/-\nChefland has all the cities on a straight line. There are $N$ cities in Chefland numbered $1$ to $N$. City $i$ is located at coordinate $x_i$ on the x-axis. Guru wants to travel from city $A$ to city $B$. He starts at time t=0. He has following choices to travel.\n- He can walk $1$ metre in $P$ secs.\n- There is a train that travels from city $C$ to city $D$ which travels $1$ metre in $Q$ secs which starts at time t=$Y$ secs. Guru can take the train only at city $C$ and leave the train only at city $D$.\nCan you help Guru find the minimum time he will need to travel from city $A$ to $B$. Note that you cannot board the train after time t =$Y$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains eight space separated integers $N, A, B, C, D, P, Q, Y $. \n- Second line of each testcase contains $N$ space-separated integers with the $i$-th integer representing $x_i$.\n\n-----Output:-----\nFor each testcase, output in a single line containing the minimum travel time.\n\n-----Constraints-----\n- $1 \\leq T \\leq 300$\n- $2 \\leq N \\leq 300$\n- $-1000 \\leq x_i \\leq 1000$\n- $0 \\leq Y \\leq 100000$\n- $1 \\leq A,B,C,D \\leq n $\n- $A \\neq B$\n- $C \\neq D$\n- $1 \\leq P, Q \\leq 100$\n- $x_i < x_j$  if $i < j$\n\n-----Sample Input:-----\n1\n4 1 3 2 4 3 2 4\n1 2 3 4\n\n-----Sample Output:-----\n6\n\n-----EXPLANATION:-----\nGuru can walk directly in 6 secs.\nIf Guru takes train, then he will need  atleast 11 secs.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Int) : Int :=\nsorry\n\ndef min_travel_time (n a b c d p q y : Nat) (cities : List Int) : Nat :=\nsorry", "vc-theorems": "theorem min_travel_time_non_negative (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities ≥ 0 :=\nsorry\n\ntheorem min_travel_time_upper_bound (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities ≤ (abs (cities[b-1] - cities[a-1])) * p :=\nsorry\n\ntheorem min_travel_time_identical_cities (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n ≥ 4) (h2 : n ≤ 100)\n  (h3 : p ≥ 1) (h4 : p ≤ 100)\n  (h5 : q ≥ 1) (h6 : q ≤ 100)\n  (h7 : y ≤ 100000)\n  (h8 : cities.length ≥ 4) (h9 : cities.length ≤ 100)\n  (h10 : ∀ x ∈ cities, -100000 ≤ x ∧ x ≤ 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4)\n  (h15 : cities[a-1] = cities[b-1]) :\n  min_travel_time n a b c d p q y cities = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 3 2 4 3 2 4 [1, 2, 3, 4]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 4 2 3 2 1 10 [0, 1, 2, 3]"}
{"id": "fvapps_001157", "vc-description": "/-\nChef loves saving money and he trusts none other bank than State Bank of Chefland. Unsurprisingly, the employees like giving a hard time to their customers. But instead of asking them to stand them in long queues, they have weird way of accepting money.\nChef did his homework and found that the bank only accepts the money in coins such that the sum of the denomination with any previously deposited coin OR itself can't be obtained by summing any two coins OR double of any coin deposited before. Considering it all, he decided to start with $1$ Chefland rupee and he would keep choosing smallest possible denominations upto $N$ coins. Since chef is busy with his cooking, can you find out the $N$ denomination of coins chef would have to take to the bank? Also find the total sum of money of those $N$ coins.\n\n-----Input:-----\n- First line has a single integer $T$ i.e. number of testcases.\n- $T$ lines followed, would have a single integer $N$ i.e. the number of coins the chef is taking.\n\n-----Output:-----\n- Output for $i$-th testcase ($1 ≤ i ≤ T$) would have 2 lines.\n- First line would contain $N$ integers i.e. the denomination of coins chef would deposit to the bank.\n- Second line would contain a single integer i.e. the sum of all the coins chef would deposit.\n\n-----Constraints:-----\n- $1 ≤ T ≤ 700$\n- $1 ≤ N ≤ 700$\n\n-----Subtasks:-----\n- $20$ points: $1 ≤ T, N ≤ 80$\n- $70$ points: $1 ≤ T, N ≤ 500$\n- $10$ points: $1 ≤ T, N ≤ 700$ \n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n1\n1\n1 2\n3\n1 2 4\n7\n1 2 4 8\n15\n\n-----Explanation:-----\nFor testcase 1: First coin is stated to be 1, hence for $N$ = 1, 1 is the answer.\nFor testcase 2: Since chef chooses the lowest possible denomination for each $i$-th coin upto $N$ coins, second coin would be 2. Only sum possible with N = 1 would be 1+1 = 2. For N = 2, $\\{1+2,  2+2\\}$ $\\neq$ $2$.\nFor testcase 3: With first two coins being 1 and 2, next coin couldn't be 3 because 3+1 = 2+2, but $\\{4+1,  4+2,  4+4\\}$ $\\neq$ $\\{1+1,  1+2,  2+2\\}$\n-/", "vc-preamble": "def list_is_sorted {α: Type} (l: List α) (less_eq : α → α → Prop) : Prop :=\n  ∀ i j (h1 : i < j) (h2 : j < l.length), less_eq (l.get ⟨i, Nat.lt_trans h1 h2⟩) (l.get ⟨j, h2⟩)\n\ndef list_sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def get_coins_and_sum (n: Nat) : List Nat × Nat :=\n  sorry", "vc-theorems": "theorem coins_length_matches_input {n: Nat} (h: 1 ≤ n ∧ n ≤ 17):\n  (get_coins_and_sum n).fst.length = n :=\nsorry\n\ntheorem coins_are_positive {n: Nat} (h: 1 ≤ n ∧ n ≤ 17):\n  ∀ x ∈ (get_coins_and_sum n).fst, 0 < x :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"}
{"id": "fvapps_001162", "vc-description": "/-\nMark loves eating chocolates and also likes to be fit. Given the calorie count for every chocolate he eats, find what he has to do to burn the calories. \nThe name of the chocolates along with its calorie count are given as follows:\nCalories per one whole bar:\nDairy milk (D)\n238\nTwix (T)\n244\nMilky Bar (M)\n138\nBounty (B)\n279\nCrunchie (C)\n186\nThe exercises preferred by him and the calories burnt are as follows:\nCalories burnt per km:\nRunning\n50\nCycling\n5\nWalking\n0.5\nFind the number of kilometers he has to run, cycle or walk to burn all of the calories. \nPriority given to the exercises is as follows: \nRunning > Cycling > Walking\n\n-----Input:-----\n- It is a one line string consisting of the names(initial letter) of all the chocolates he has eaten.\n\n-----Output:-----\nPrint three lines. First line representing how much he ran(in km), second line representing how much he cycled(in km), third line representing how much he walked(in km).\n\n-----Constraints-----\n- 1 <= length of input string <= 10. \n\n-----Sample Input:-----\nDDTM\n\n-----Sample Output:-----\n17\n1\n6\n\n-----EXPLANATION:-----\nCalorie intake = 238 + 238 + 244 + 138 = 858\n( 17km x 50 ) + ( 1km x 5 ) + ( 6km x 0.5 ) = 858.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUpper (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef isSpace (c : Char) : Bool :=\nsorry\n\ndef count_elements (s : String) : Nat × Nat × Nat :=\nsorry", "vc-theorems": "theorem count_elements_totals (s : String) :\n  let (uppers, digits, spaces) := count_elements s\n  let total := uppers + digits + spaces\n  total ≤ s.length :=\nsorry\n\ntheorem empty_string :\n  count_elements \"\" = (0, 0, 0) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001167", "vc-description": "/-\nChef is solving mathematics problems. He is preparing for Engineering Entrance exam. He's stuck in a problem.\n$f(n)=1^n*2^{n-1}*3^{n-2} * \\ldots * n^{1} $ \nHelp Chef to find the value of $f(n)$.Since this number could be very large, compute it modulo $1000000007$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input,  $N$. \n\n-----Output:-----\nFor each testcase, output in a single line the value of $f(n)$ mod $1000000007$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Subtasks-----\nSubtask 1(24 points) : \n- $1 \\leq T \\leq 5000$\n- $1 \\leq N \\leq 5000$\nSubtask 2(51 points) : original constraints\n\n-----Sample Input:-----\n1\n3\n\n-----Sample Output:-----\n12\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef solve_f_n (n : Nat) : Nat :=\n  sorry\n\ndef direct_calc (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem base_cases :\n  solve_f_n 1 = 1 ∧\n  solve_f_n 2 = 2 ∧\n  solve_f_n 3 = 12 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_f_n 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_f_n 1\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_f_n 2"}
{"id": "fvapps_001179", "vc-description": "/-\nChef played an interesting game yesterday. This game is played with two variables $X$ and $Y$; initially, $X = Y = 0$. Chef may make an arbitrary number of moves (including zero). In each move, he must perform the following process:\n- Choose any positive integer $P$ such that $P \\cdot P > Y$.\n- Change $X$ to $P$.\n- Add $P \\cdot P$ to $Y$.\nUnfortunately, Chef has a bad memory and he has forgotten the moves he made. He only remembers the value of $X$ after the game finished; let's denote it by $X_f$. Can you tell him the maximum possible number of moves he could have made in the game?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single integer $X_f$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the maximum number of moves Chef could have made.\n\n-----Constraints-----\n- $1 \\le T \\le 10^5$\n- $1 \\le X_f \\le 10^9$\n\n-----Example Input-----\n3\n3\n8\n9\n\n-----Example Output-----\n3\n5\n6\n\n-----Explanation-----\nExample case 2: One possible sequence of values of $X$ is $0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 5 \\rightarrow 8$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_max_moves (n : Nat) : Nat :=\n  sorry\n\ndef isqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem calc_max_moves_non_negative (x : Nat) :\n  calc_max_moves x ≥ 0 :=\nsorry\n\ntheorem calc_max_moves_monotonic (x : Nat) :\n  x > 0 → calc_max_moves x ≥ calc_max_moves (x-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_moves 3\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_max_moves 8\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval calc_max_moves 9"}
{"id": "fvapps_001180", "vc-description": "/-\nThe EEE classes are so boring that the students play games rather than paying attention during the lectures. Harsha and Dubey are playing one such game.\n\nThe game involves counting the number of anagramic pairs of a given string (you can read about anagrams from here). Right now Harsha is winning. Write a program to help Dubey count this number quickly and win the game!\n\n-----Input-----\nThe first line has an integer T which is the number of strings. Next T lines each contain a strings. Each string consists of lowercase english alphabets only.\n\n-----Output-----\nFor each string, print the answer in a newline.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ length of each string ≤ 100\n\n-----Example-----\nInput:\n3\nrama\nabba\nabcd\nOutput:\n2\n4\n0\n\n-----Explanation-----\nrama has the following substrings:\n\n- r\n- ra\n- ram\n- rama\n- a\n- am\n- ama\n- m\n- ma\n- a\nOut of these, {5,10} and {6,9} are anagramic pairs.\n\nHence the answer is 2.\n\nSimilarly for other strings as well.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_anagram_pairs (s : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem find_anagram_pairs_nonneg (s : String) :\n  find_anagram_pairs s ≥ 0 :=\nsorry\n\ntheorem find_anagram_pairs_empty_or_single (s : String) :\n  s.length ≤ 1 → find_anagram_pairs s = 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001191", "vc-description": "/-\nThere are players standing in a row each player has a digit written on their T-Shirt (multiple players can have the same number written on their T-Shirt).   \nYou have to select a group of players, note that players in this group should be standing in $\\textbf{consecutive fashion}$. For example second player of chosen group next to first player of chosen group, third player next to second and similarly last player next to second last player of chosen group. Basically You've to choose a contiguous group of players.\nAfter choosing a group, players can be paired if they have the same T-Shirt number (one player can be present in at most one pair), finally the chosen group is called “good” if at most one player is left unmatched. Your task is to find the size of the maximum “good” group.\nFormally, you are given a string $S=s_{1}s_{2}s_{3}...s_{i}...s_{n}$ where $s_{i}$ can be any digit character between $'0'$ and $'9'$ and $s_{i}$ denotes the number written on the T-Shirt of $i^{th}$ player. Find a value $length$ such that there exist pair of indices $(i,j)$ which denotes $S[i...j]$ is a “good” group where $i\\geq1$ and $j\\leq S.length$ and $i\\leq j$ and $(j-i+1)=length$ and there exist no other pair $(i’,j’)$ such that $(j’-i’+1)>length$ and $S[i'...j']$ is a \"good\" group.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- $i^{th}$ testcase consist of a single line of input, a string $S$. \n\n-----Output:-----\nFor each testcase, output in a single line maximum possible size of a \"good\" group.\n\n-----Constraints-----\n$\\textbf{Subtask 1} (20 points)$\n- $1 \\leq T \\leq 10$\n- $S.length \\leq 10^{3}$\n$\\textbf{Subtask 2} (80 points)$\n- $1 \\leq T \\leq 10$\n- $S.length \\leq 10^{5}$\n\n-----Sample Input:-----\n1\n\n123343\n\n-----Sample Output:-----\n3\n\n-----EXPLANATION:-----\n1$\\textbf{$\\underline{2 3 3}$}$43\nUnderlined group is a “good” group because the second player(number 2 on T-Shirt) is the only player who is left unmatched and third and fourth player can form a pair, no other group has length greater than 3 that are “good”. However note that we have other “good” group also 12$\\textbf{$\\underline{334}$}$3 but length is 3 which is same as our answer.\n\n-----Sample Input:-----\n1\n\n95665\n\n-----Sample Output:-----\n5\n\n-----EXPLANATION:-----\n$\\textbf{$\\underline{95665}$}$ is “good” group because first player is the only player who is left unmatched second and fifth player can form pair and third and fourth player also form pair.\n\n-----Sample Input:-----\n2\n\n2323\n\n1234567\n\n-----Sample Output:-----\n4\n\n1\n\n-----EXPLANATION:-----\nFor first test case\n$\\textbf{$\\underline{2323}$}$ is a “good” group because there are no players who are left unmatched first and third player form pair and second and fourth player form pair.\n\nFor second test\n\nOnly length one \"good\" group is possible.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_good_group (s : String) : Nat :=\n  sorry\n\ndef is_good_group (s : String) : Bool :=\n  sorry\n\ndef substring (s : String) (start len : Nat) : String :=\n  sorry\n\ndef get_char (s : String) (i : Nat) : Char :=\n  sorry", "vc-theorems": "theorem find_max_good_result_bounds {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  1 ≤ res ∧ res ≤ s.length :=\nsorry\n\ntheorem exists_valid_substring {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  ∃ start : Nat, start + res ≤ s.length ∧\n    is_good_group (substring s start res) :=\nsorry\n\ntheorem no_longer_good_groups {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  ∀ len : Nat, len > res → len ≤ s.length →\n    ∀ i : Nat, i + len ≤ s.length →\n      ¬is_good_group (substring s i len) :=\nsorry\n\ntheorem same_digit_max_length {s : String} (h : s.length > 0)\n  (h_same : ∀ i j : Nat, i < s.length → j < s.length →\n            get_char s i = get_char s j) :\n  find_max_good_group s = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_good_group \"123343\"\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_good_group \"95665\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_good_group \"2323\""}
{"id": "fvapps_001195", "vc-description": "/-\nChef likes to play with big numbers. Today, he has a big positive integer N. He can select any two digits from this number (the digits can be same but their positions should be different) and orders them in any one of the two possible ways. For each of these ways, he creates a two digit number from it (might contain leading zeros). Then, he will pick a character corresponding to the ASCII value equal to this number, i.e. the number 65 corresponds to 'A', 66 to 'B' and so on till 90 for 'Z'. Chef is only interested in finding which of the characters in the range 'A' to 'Z' can possibly be picked this way. \n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases.\nThe first line of the input contains an integer N. \n\n-----Output-----\nFor each test case, output a string containing characters Chef can pick in sorted order If the resulting size of string is zero, you should output a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10100000\n\n-----Subtasks-----\n- Subtask #1 (40 points) N ≤ 1010\n- Subtask #2 (60 points) Original Constraints\n\n-----Example-----\nInput:\n4\n65\n566\n11\n1623455078\n\nOutput:\nA\nAB\n\nACDFGHIJKLNPQRSTUVW\n\n-----Explanation-----\nExample case 1. Chef can pick digits 6 and 5 and create integers 56 and 65. The integer 65 corresponds to 'A'.\nExample case 2. Chef can pick digits 6 and 5 and create 'A' as it equals 65. He can pick 6 and 6 (they are picked from position 2 and position 3, respectively) to create 'B' too. Hence answer is \"AB\".\nExample case 3. It's not possible to create any character from 'A' to 'Z'. Hence, we just print a new line.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_possible_ascii_chars (s: String) : String :=\n  sorry\n\ndef hasDuplicates (s: List α) : Bool :=\n  sorry", "vc-theorems": "theorem output_is_uppercase_ascii (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    result.all (fun c => 65 ≤ c.toNat ∧ c.toNat ≤ 90) ∧\n    ¬hasDuplicates result.data :=\nsorry\n\ntheorem chars_derive_from_input (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    let input_chars := input.data\n    ∀ c ∈ result.data, ∃ d ∈ input_chars, d.toNat = (c.toNat / 10) + '0'.toNat :=\nsorry\n\ntheorem small_digits_give_empty (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '4'))\n    (h_size: input.length > 0) :\n    find_possible_ascii_chars input = \"\" :=\nsorry\n\ntheorem duplicates_are_removed (input: String)\n    (h: input.all (fun c => '0' ≤ c ∧ c ≤ '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    ¬hasDuplicates result.data :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'A'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"65\"\n\n/--\ninfo: 'AB'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"566\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"11\""}
{"id": "fvapps_001210", "vc-description": "/-\nPeople in Karunanagar are infected with Coronavirus. To understand the spread of disease and help contain it as early as possible, Chef wants to analyze the situation in the town. Therefore, he does the following:\n- Chef represents the population of Karunanagar as a binary string of length $N$ standing in a line numbered from $1$ to $N$ from left to right, where an infected person is represented as $1$ and an uninfected person as $0$.\n- Every day, an infected person in this binary string can infect an adjacent (the immediate left and right) uninfected person.\n- Therefore, if before Day 1, the population is $00100$, then at the end of Day 1, it becomes $01110$ and at the end of Day 2, it becomes $11111$.\nBut people of Karunanagar are smart and they know that if they 'socially isolate' themselves as early as possible, they reduce the chances of the virus spreading. Therefore on $i$-th day, person numbered $P_i$ isolates himself from person numbered $P_i - 1$, thus cannot affect each other. This continues in the town for $D$ days.\nGiven the population binary string before Day 1, Chef wants to calculate the total number of infected people in Karunanagar at the end of the day $D$. Since Chef has gone to wash his hands now, can you help do the calculation for him?\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the test cases follow. \n- The first line of each test case contains a single integer $N$ denoting the length of the binary string.\n- The next line contains a binary string of length $N$ denoting the population before the first day, with $1$ for an infected person and $0$ for uninfected.\n- The next line contains a single integer $D$ - the number of days people isolate themselves.\n- The next line contains $P$ - a list of $D$ distinct space-separated integers where each $P_{i}$ denotes that at the start of $i^{th}$ day, person $P_{i}$ isolated him/herself from the person numbered $P_i-1$.\n\n-----Output:-----\nFor each test case, print a single integer denoting the total number of people who are infected after the end of $D^{th}$ day.\n\n-----Constraints-----\n- $1 \\leq T \\leq 200$\n- $2 \\leq N \\leq 10^{4}$\n- $1 \\leq D < N$\n- $2 \\leq P_{i} \\leq N$ for $1 \\le i \\le D$\n\n-----Subtasks-----\nSubtask #1(30 points): $1 \\leq T \\leq 100$, $2 \\leq N \\leq 2000$\nSubtask #2(70 points): Original Constraints\n\n-----Sample Input:-----\n2\n9\n000010000\n3\n2 5 8\n5\n00001\n1\n5\n\n-----Sample Output:-----\n6\n1\n\n-----EXPLANATION:-----\nFor the purpose of this explanation, a social distance can be denoted with a '$|$'.\nFor the first testcase:\n- \nBefore Day $1$, the population is: $0|00010000$\n- \nBefore Day $2$, the population is: $0|001|11000$\n- \nBefore Day $3$, the population is: $0|011|111|00$\n- \nTherefore, after Day $3$, the population will be: $0|111|111|00$\nSo, there are $6$ infected persons.\nFor the second testcase:\nBefore Day $1$, the population is: $0000|1$\nTherefore, there is one infected person.\n-/", "vc-preamble": "def countOnes (s : String) : Nat :=\n  s.data.filter (· = '1') |>.length", "vc-helpers": "", "vc-definitions": "def solve_virus_spread (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_virus_spread_type (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le 0 (solve_virus_spread N init_pop D isolations) ∧\n  Nat.le (solve_virus_spread N init_pop D isolations) N :=\nsorry\n\ntheorem solve_virus_spread_no_infected (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  (∀ c, c ∈ init_pop.data → c ≠ '1') →\n  solve_virus_spread N init_pop D isolations = 0 :=\nsorry\n\ntheorem solve_virus_spread_no_isolation (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  D = 0 →\n  solve_virus_spread N init_pop D isolations = countOnes init_pop :=\nsorry\n\ntheorem solve_virus_spread_monotonic (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le (countOnes init_pop) (solve_virus_spread N init_pop D isolations) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_virus_spread 9 \"000010000\" 3 [2, 5, 8]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_virus_spread 5 \"00001\" 1 [5]"}
{"id": "fvapps_001215", "vc-description": "/-\nChef Zidane likes the number 9. He has a number N, and he wants to turn it into a multiple of 9. He cannot add or remove digits, and he can only change one digit at a time. The only allowed operation is to increment or decrement a digit by one, and doing this takes exactly one second. Note that he cannot increase a digit 9 or decrease a digit 0, and the resulting number must not contain any leading zeroes unless N has a single digit.\n\nChef Zidane wants to know the minimum amount of time (in seconds) needed to accomplish this. Please help him, before his kitchen gets overwhelmed with mist!\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nEach test case consists of one line containing a single positive integer N.\n\n-----Output-----\nFor each test case, output a single line containing the answer.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ N ≤ 10105\n- N will not contain leading zeroes.\n- Each test file is at most 3Mb in size.\n\n-----Example-----\nInput:4\n1989\n86236\n90210\n99999999999999999999999999999999999999988\n\nOutput:0\n2\n3\n2\n\n-----Explanation-----\nExample case 1. 1989 is already divisible by 9, so no operations are needed to be performed.\nExample case 2. 86236 can be turned into a multiple of 9 by incrementing the first and third digit (from the left), to get 96336. This takes 2 seconds.\nExample case 3. 90210 can be turned into a multiple of 9 by decrementing the third digit twice and the fourth digit once, to get 90000. This takes 3 seconds.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_time_for_multiple_of_nine (n : Nat) : Nat :=\n  sorry\n\ndef digit_sum (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_within_bounds (n : Nat) (h : n > 0) :\n  let result := min_time_for_multiple_of_nine n\n  result ≥ 0 ∧ result ≤ 8 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 1989\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 86236\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 90210"}
{"id": "fvapps_001221", "vc-description": "/-\nMohit's girlfriend is playing a game with Nicky. The description of the game is as follows:\n- Initially on a table Player 1 will put N gem-stones.\n- Players will play alternatively, turn by turn.\n- At each move a player can take at most M gem-stones (at least 1 gem-stone must be taken) from the available gem-stones on the table.(Each gem-stone has same cost.)\n- Each players gem-stone are gathered in player's side.\n- The player that empties the table purchases food from it (using all his gem-stones; one gem-stone can buy one unit of food), and the other one puts all his gem-stones back on to the table. Again the game continues with the \"loser\" player starting.\n- The game continues until all the gem-stones are used to buy food.\n- The main objective of the game is to consume maximum units of food.\n\n\tMohit's girlfriend is weak in mathematics and prediction so she asks help from Mohit, in return she shall kiss Mohit. Mohit task is to predict the maximum units of food her girlfriend can eat, if, she starts first. Being the best friend of Mohit, help him in predicting the answer.\n\n-----Input-----\n- Single line contains two space separated integers N and M.\n\n-----Output-----\n- The maximum units of food Mohit's girlfriend can eat.\n\n-----Constraints and Subtasks-----\n- 1 <= M <= N <= 100\nSubtask 1: 10 points\n- 1 <= M <= N <= 5\nSubtask 2: 20 points\n- 1 <= M <= N <= 10\nSubtask 3: 30 points\n- 1 <= M <= N <= 50\nSubtask 3: 40 points\n- Original Constraints.\n\n-----Example-----\nInput:\n4 2\n\nOutput:\n2\n-/\n\n/- The result of solve_gem_game is never negative -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- When m=1, result follows pattern based on n being even/odd -/\n\n/- For m > (n+1)/2, result equals m -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_gem_game (n m : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_gem_game_nonneg (n m : Nat) :\n  solve_gem_game n m ≥ 0 :=\nsorry\n\ntheorem solve_gem_game_m_one (n : Nat) :\n  solve_gem_game n 1 = if n % 2 = 0 then n/2 else n/2 + 1 :=\nsorry\n\ntheorem solve_gem_game_large_m (n m : Nat) (h : m > (n+1)/2) :\n  solve_gem_game n m = m :=\nsorry", "vc-postamble": "/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_gem_game 4 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_gem_game 6 3\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_gem_game 10 1"}
{"id": "fvapps_001222", "vc-description": "/-\nThe Head Chef is receiving a lot of orders for cooking the best of the problems lately. For this, he organized an hiring event to hire some talented Chefs. He gave the following problem to test the skills of the participating Chefs. Can you solve this problem and be eligible for getting hired by Head Chef.\n\nA non-negative number n is said to be magical if it satisfies the following property. Let S denote the multi-set of numbers corresponding to the non-empty subsequences of the digits of the number n in decimal representation. Please note that the numbers in the set S can have leading zeros. Let us take an element s of the multi-set S, prod(s) denotes the product of all the digits of number s in decimal representation. \nThe number n will be called magical if sum of prod(s) for all elements s in S, is even. \n\nFor example, consider a number 246, its all possible non-empty subsequence will be S = {2, 4, 6, 24, 46, 26, 246}. Products of digits of these subsequences will be {prod(2) = 2, prod(4) = 4, prod(6) = 6, prod(24) = 8, prod(46) = 24, prod(26) = 12, prod(246) = 48, i.e. {2, 4, 6, 8, 24, 12, 48}. Sum of all of these is 104, which is even. Hence 246 is a magical number.\n\nPlease note that multi-set S can contain repeated elements, e.g. if number is 55, then S = {5, 5, 55}. Products of digits of these subsequences will be {prod(5) = 5, prod(5) = 5, prod(55) = 25}, i.e. {5, 5, 25}. Sum of all of these is 35 which is odd. Hence 55 is not a \nmagical number.\n\nConsider a number 204, then S = {2, 0, 4, 20, 04, 24, 204}. Products of digits of these subsequences will be {2, 0, 4, 0, 0, 8, 0}. Sum of all these elements will be 14 which is even. So 204 is a magical number.\n\nThe task was to simply find the Kth magical number.\n\n-----Input-----\n- First line of the input contains an integer T denoting the number of test cases.\n- Each of the next T lines contains a single integer K.\n\n-----Output-----\nFor each test case, print a single integer corresponding to the Kth magical number.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ K ≤ 1012.\n\n-----Subtasks-----\nSubtask #1 : (20 points)\n- 1 ≤ T ≤ 100\n- 1 ≤ K ≤ 104.\n\nSubtask 2 : (80 points) Original Constraints\n\n-----Example-----\nInput:\n2\n2\n5\n\nOutput:\n2\n8\n\n-----Explanation-----\nExample case 1.\n2 is the 2nd magical number, since it satisfies the property of the magical number. The first magical number will be of course 0.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def base5 (n : Nat) : List Nat :=\nsorry\n\ndef seq (n : Nat) : Nat :=\nsorry\n\ndef get_kth_magical_number (k : Nat) : Nat :=\nsorry\n\ndef digitList (n : Nat) : List Nat :=\nsorry\n\ndef isEvenDigit (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem base5_zero :\n  base5 0 = [] :=\nsorry\n\ntheorem base5_digits_bounded (n : Nat) :\n  ∀ d ∈ base5 n, 0 ≤ d ∧ d ≤ 4 :=\nsorry\n\ntheorem magical_increasing (k : Nat) :\n  k > 1 →\n  get_kth_magical_number (k-1) < get_kth_magical_number k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval get_kth_magical_number 2\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval get_kth_magical_number 5\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval get_kth_magical_number 1"}
{"id": "fvapps_001230", "vc-description": "/-\nThere is a haunted town called HauntedLand. The structure of HauntedLand can be thought of as a grid of size n * m. There is a house in each cell of the grid. Some people have fled from their houses because they were haunted. '.' represents a haunted house whereas '*' represents a house in which people are living.\n\nOne day, Devu, the famous perfumer came to town with a perfume whose smell can hypnotize people. Devu can put the perfume in at most one of the houses. This takes Devu one second. Then, the perfume spreads from one house (need not be inhabited by people) to all its adjacent houses in one second, and the cycle continues. Two houses are said to be a adjacent to each other, if they share a corner or an edge, i.e., each house (except those on the boundaries) will have 8 adjacent houses.\n\nYou want to save people from Devu's dark perfumery by sending them a message to flee from the town. So, you need to estimate the minimum amount of time Devu needs to hypnotize all the people? Note that if there are no houses inhabited by people, Devu doesn't need to put perfume in any cell.\n\n-----Input-----\nThe first line of input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFirst line of each test case contains two space separated integers n, m denoting the dimensions of the town.\nFor each of next n lines, each line has m characters (without any space) denoting a row of houses of the town.\n\n-----Output-----\nFor each test case, output a single integer corresponding to the answer of the problem.\n\n-----Constraints-----\n- 1 ≤ T ≤ 20\nSubtask #1: (40 points) \n\n- 1 ≤ n, m ≤ 100Subtask #2: (60 points) \n\n- 1 ≤ n, m ≤ 1000\n\n-----Example-----\nInput:\n2\n2 2\n*...\n3 4\n.*..***..*..\n\nOutput:\n1\n2\n\n-----Explanation-----\nIn the first example, it will take Devu one second for putting the perfume at the only house. So, the answer is 1.\n\nIn the second example, He will first put the perfume at the * at cell (1, 1) (assuming 0-based indexing).\n\nNow, it will take Devu 1 secs to put perfume. In the next second, the perfume will spread to all of its adjacent cells, thus making each house haunted.\nSo, the answer is 2.\n-/", "vc-preamble": "def countStars (s : String) : Nat :=\n  s.toList.filter (· = '*') |>.length\n\ndef listSum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def Grid := List String\n\ndef isValidGrid (grid : Grid) : Bool :=\n  sorry\n\ndef solveHauntedLand (grid : Grid) : Nat :=\n  sorry", "vc-theorems": "theorem solve_haunted_land_output_valid (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid ≥ 0 :=\nsorry\n\ntheorem empty_grid_returns_zero (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : ∀ (row : String), List.contains grid row → ¬ row.contains '*') :\n  solveHauntedLand grid = 0 :=\nsorry\n\ntheorem single_house_returns_one (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : listSum (grid.map countStars) = 1) :\n  solveHauntedLand grid = 1 :=\nsorry\n\ntheorem result_bounded_by_dimensions (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid ≤ max grid.length (grid.head?.map String.length |>.getD 0) :=\nsorry\n\ntheorem inhabited_houses_positive_time (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : ∃ (row : String), List.contains grid row ∧ row.contains '*') :\n  solveHauntedLand grid ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"*.\", \"..\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_haunted_land [\".*..\", \"***.\", \".*..\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"...\", \"...\"]"}
{"id": "fvapps_001233", "vc-description": "/-\nChef Tobby is trying to run a code given to him by Bhuvan for an experiment they want to include in the manuscript to be submitted to a conference. The deadline to submit the manuscript is within a couple of hours and Chef Tobby needs to finish the experiments before then.\nThe code given by Bhuvan is the following which runs given an array of N integers and another integer K :\nvoid recurse ( array a, int n )\n{\n\t// n = size of array\n\tdefine array b currently empty\n\tconsider all 2^n subsets of a[]\n\t{\n\t\tx = bitwise OR of elements in the subsets\n\t\tadd x into \"b\" if it is not present yet\n\t}\n\tif (sizeof( b ) == 1 << k)\n\t{\n\t\tprintf(“Won”);\n\t\treturn;\n\t}\n\trecurse ( b, sizeof( b ) );\n}\n\nChef Tobby tried to run an experiment with only one integer in the array with value 2 and K = 3. To his horror, he found out that the algorithm is resulting in an infinite loop. He is livid with the possibility that the algorithm can lead to infinite loops for certain cases. On closer inspection he determines that it might be possible to insert additional elements in the initial array to subvert the problem. Since time is very less, Chef Tobby would like to insert the minimum number of elements.\nChef Tobby has to finish writing the paper, so he asks his graduate student Leamas to fix it. Leamas has no idea how to fix the problem so he asks you for help.\n\n-----Input section-----\nThe first line contains T, the number of test cases.\nEach test case consists of 2 lines. The first line contains 2 integers N and K, denoting the number of elements in the array and parameter mentioned in problem statement.\nNext line contains N space separated integers, denoting the elements of the array.\n\n-----Output section-----\nOutput the minimum number of elements that need to be inserted so that inifinite loop can be avoided.\n\n-----Input constraints-----\n1 ≤ T ≤ 10\n1 ≤ Sum of N over all test cases ≤ 105\n1 ≤ K ≤ 20\n0 ≤ A[i] ≤ 2K-1, where A[i] denotes the ith element of the array.\n\n-----Sample Input - 1-----\n1\n2 2\n3 1\n\n-----Sample Output - 1-----\n1\n\n-----Explanation - 1-----\nYou can win the game by inserting the element 2 into the array.\n\n-----Sample Input - 2-----\n1\n7 3\n3 7 5 4 6 2 1\n\n-----Sample Output - 2-----\n0\n\n-----Explanation - 2-----\nThe initial array will result will terminate in the first step of algorithm only. Thus there is no need to insert any new element.\n-/", "vc-preamble": "def permutation (l1 l2 : List Nat) : Prop :=\n  l1.length = l2.length ∧ ∀ x, x ∈ l1 ↔ x ∈ l2", "vc-helpers": "", "vc-definitions": "def min_elements_needed (N K : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_elements_non_negative (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr ≥ 0 :=\nsorry\n\ntheorem min_elements_upper_bound (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr ≤ K :=\nsorry\n\ntheorem min_elements_complete_powers (N K : Nat) (arr : List Nat) :\n  (∀ i : Nat, i < K → (2^i) ∈ arr) →\n  min_elements_needed N K arr = 0 :=\nsorry\n\ntheorem min_elements_empty (K : Nat) :\n  min_elements_needed 0 K [] = K :=\nsorry\n\ntheorem min_elements_singleton_min (K : Nat) :\n  min_elements_needed 1 K [1] = K - 1 :=\nsorry\n\ntheorem min_elements_singleton_max (K : Nat) :\n  min_elements_needed 1 K [2^K] = K :=\nsorry\n\ntheorem min_elements_perm_invariant (N K : Nat) (arr₁ arr₂ : List Nat) :\n  permutation arr₁ arr₂ →\n  min_elements_needed N K arr₁ = min_elements_needed N K arr₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_elements_needed 2 2 [3, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_elements_needed 7 3 [3, 7, 5, 4, 6, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_elements_needed 1 3 [2]"}
{"id": "fvapps_001243", "vc-description": "/-\nYou are given a string $s$. And you have a function $f(x)$ defined as:\nf(x) = 1, if $x$ is a vowel\nf(x) = 0, if $x$ is a constant\n\nYour task is to apply the above function on all the characters in the string s and convert \nthe obtained binary string in decimal number $M$.\nSince the number $M$ can be very large, compute it modulo $10^9+7$. \n\n-----Input:-----\n- The first line of the input contains a single integer $T$ i.e the no. of test cases. \n- Each test line contains one String $s$ composed of lowercase English alphabet letters. \n\n-----Output:-----\nFor each case, print a single line containing one integer $M$ modulo $10^9 + 7$.\n\n-----Constraints-----\n- $1 ≤ T ≤ 50$\n- $|s|≤10^5$\n\n-----Subtasks-----\n- 20 points : $|s|≤30$\n- 80 points : $ \\text{original constraints}$\n\n-----Sample Input:-----\n1\nhello\n\n-----Sample Output:-----\n9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binaryStringToDecimal (s : String) : Nat :=\nsorry\n\ndef isVowel (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem result_in_valid_range (s : String) (h : s.length > 0) :\n  binaryStringToDecimal s < 10^9 + 7 ∧ binaryStringToDecimal s ≥ 0 :=\nsorry\n\ntheorem all_vowels_max_value (s : String) (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, isVowel c) :\n  binaryStringToDecimal s = (2^s.length - 1) % (10^9 + 7) :=\nsorry\n\ntheorem all_consonants_zero (s : String) (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, ¬isVowel c) :\n  binaryStringToDecimal s = 0 :=\nsorry\n\ntheorem same_vowel_positions_equal (s1 s2 : String)\n  (h1 : s1.length > 0)\n  (h2 : s1.length = s2.length)\n  (h3 : ∀ (i : String.Pos), isVowel (s1.get i) = isVowel (s2.get i)) :\n  binaryStringToDecimal s1 = binaryStringToDecimal s2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"hello\"\n\n/--\ninfo: 31\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"aeiou\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"xyz\""}
{"id": "fvapps_001249", "vc-description": "/-\nChef and his friend Miron were getting bored and decided to play a game. \nMiron thinks of a sequence of  N  integers (A1, A2, …., AN) and gives Chef a matrix B, where Bi,j = |Ai - Aj|. He further tells Chef that A1 = 0. The game is for Chef to guess the sequence that Miron thought of. \nBut Miron is an adversarial player. Every time Chef tries to guess the sequence, he makes a change to the matrix. He makes such a change Q times. Each time, he replaces an entry in some row and the corresponding column with a new one leaving Chef to guess the sequence after each change. \nChef needs a friend to help him against such an adversarial player. Can you be that friend and help Chef find a suitable sequence A for the initial matrix B and also after each change Miron makes? \nNote that if several answers exist, then print the lexicographically smallest answer. Further, the numbers in the sequence can be negative.\n\n-----Input-----\n\nThe first line contains two space-separated integers N, Q. Each of the N subsequent lines contains N space-separated integers, denoting the matrix B.\n\nQ queries follow. Each query has two lines. The first line of each query contains an integer p, denoting the number of row and column that is changed. The second line of each query contains N space-separated integers F1, F2, F3, ... FN, denoting the new values to the corresponding cells of the matrix (you should make the following assignments Bi,p = Bp,i = Fi for all valid i). \n\n-----Output-----\nPrint Q + 1 lines which contain N space-separated integers, Miron's initial array and Miron's array after each query.\n\n-----Constraints-----\n- 3 ≤ N ≤  1000 \n- 1 ≤ Q ≤  1000 \n- 0 ≤ Bi,j ≤  5000 \n- 1 ≤ p ≤  n \n- 0 ≤ Fi ≤  5000 \n- it's guaranteed there's always an answer\n\n-----Example-----\nInput:\n3 2\n0 1 2\n1 0 1\n2 1 0\n1\n0 4 3\n2\n4 0 7\nOutput:\n0 -1 -2\n0 -4 -3\n0 -4 3\n\n-----Explanation-----\nExample case 1. Initially, sequence {0, 1, 2} is also suitable, but {0, -1, -2} is lexicografically smaller.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_symmetric_zero_diag (B : List (List Nat)) : List (List Nat) :=\nsorry\n\ndef solve (N: Nat) (Q: Nat) (B: List (List Nat)) (queries: List (Nat × List Nat)) : List (List Nat) :=\nsorry\n\ndef get_A (B: List (List Int)) : List Int :=\nsorry\n\ndef update_B (B: List (List Nat)) (p: Nat) (R: List Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem solve_shape_correct {N Q: Nat} {B: List (List Nat)} {queries: List (Nat × List Nat)}\n  (h1: N = 3)\n  (h2: List.length B = N)\n  (h3: ∀ row ∈ B, List.length row = N)\n  (h4: List.length queries ≥ 1)\n  (h5: List.length queries ≤ 3)\n  : let result := solve N Q B queries\n    List.length result = List.length queries + 1 ∧\n    ∀ row ∈ result, List.length row = N :=\nsorry\n\ntheorem distances_preserved {A: List Int} {N: Nat}\n  (h1: List.length A = N)\n  (h2: N = 3)\n  : let B := List.map (λ i => List.map (λ j => Int.natAbs (A.get ⟨i, by sorry⟩ - A.get ⟨j, by sorry⟩)) (List.range N)) (List.range N)\n    let reconstructed := get_A (B.map (List.map Int.ofNat))\n    ∀ (i j : Fin reconstructed.length),\n    Int.natAbs (reconstructed.get i - reconstructed.get j) = (B.get ⟨i.val, by sorry⟩).get ⟨j.val, by sorry⟩ :=\nsorry\n\ntheorem update_B_symmetric {N p: Nat} {R: List Nat}\n  (h1: N ≥ 2)\n  (h2: N ≤ 5)\n  (h3: p < N)\n  (h4: List.length R ≥ N)\n  : let B := List.replicate N (List.replicate N 0)\n    let updated := update_B B p (List.take N R)\n    ∀ (i j : Fin N),\n    (updated.get ⟨i.val, by sorry⟩).get ⟨j.val, by sorry⟩ =\n    (updated.get ⟨j.val, by sorry⟩).get ⟨i.val, by sorry⟩ :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001250", "vc-description": "/-\n\"Say my Name\".\nTodd Alquist is being taught the process of cooking methamphetamine, but to see whether he's really capable of learning it, Walt gives him a problem to solve. Since he can't solve it, he asks you for help.\nYou are given a tree with $N$ vertices (numbered $1$ through $N$), rooted at the vertex $1$. There is an integer written at each vertex; for each valid $i$, the value of vertex $i$ is $A$$i$.There also exists a special integer $K$. \nChoose any leaf node, denoted by $X$, and go down a simple path from $root$ to $X$.\nLet $S$ denote the set of all nodes lying on the simple path from $root$ to $X$.\nFor all $ i $ $\\epsilon $ $ S $, choose an integer $D$ $\\epsilon$ $[2^{A[i]-1},2^{A[i]})$.\n\nInformally, for every node $i$ lying on the simple path from $root$ to $X$, you have to choose an integer $D$ such that  $2^{A[i]-1}\\leq D < 2^{A[i]}$.  \nYou now have to perform one of the two following operations :   \n- Bitwise XOR of all chosen integers.  \n- Bitwise AND of all chosen integers.   \nYou have to determine whether you can choose the values in such a way that after performing one of the given operations you can get an integer equal to $K$.  \n- Note : A leaf is a node of the tree without any child nodes.\nDetermine if it is possible to obtain the value $K$ by performing the given operations.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains two space separated integers $N, K$ denoting the number of nodes and the value of the special integer .\n- $N-1$ lines follow , each line contains two space separated integers $u,v$ denoting an edge between $u$ and $v$. \n- A single line follows containing $N$ space separated integers denoting the value of nodes.\n\n-----Output:-----\nFor each testcase, output in a single line \"YES\"(without quotes) or \"NO\"(without quotes).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10000$\n- $2 \\leq N \\leq 5*10^5$\n- $1 \\leq K \\leq 10^{18}$\n- $1 \\leq u,v \\leq N$\n- $ 1\\leq A[i] \\leq 64$\n- Sum of $N$ over all test cases does not exceed 1e6.\n\n-----Sample Input:-----\n1\n6 85\n1 2\n2 3\n2 4\n4 5\n3 6\n3 5 4 7 1 9\n\n-----Sample Output:-----\nYES\n\n-----EXPLANATION:-----\nThere are two leaf nodes, 5 and 6\nconsidering path from root to 5\nwe have nodes\n1->2->4->5\nwe can select the values\n5,26,75,1 and perform operation 1 that is XOR of all numbers to get 85\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_obtain_k (n : Nat) (k : Nat) (edges : List (Nat × Nat)) (values : List Nat) : String :=\nsorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem can_obtain_k_returns_valid_output (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  (can_obtain_k n k edges values = \"YES\") ∨ (can_obtain_k n k edges values = \"NO\") :=\nsorry\n\ntheorem can_obtain_k_identical_values_consistent (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (h1 : is_valid_tree n edges = true) :\n  let values := List.replicate n 1\n  can_obtain_k n k edges values = can_obtain_k n k edges values :=\nsorry\n\ntheorem can_obtain_k_valid_edges (n : Nat) (k : Nat) (edges : List (Nat × Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  edges.length = n - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 6 85 [(1, 2), (2, 3), (2, 4), (4, 5), (3, 6)] [3, 5, 4, 7, 1, 9]\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 3 4 [(1, 2), (1, 3)] [2, 3, 1]\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_obtain_k 4 100 [(1, 2), (2, 3), (2, 4)] [3, 4, 2, 5]"}
{"id": "fvapps_001252", "vc-description": "/-\nIn Byteland there are N cities, numbered 1 through N. Some pairs of cities are connected by bi-directional roads in such a way that starting from any one city you can visit all other cities either directly or indirectly.\n\nChef is currently at city A and wants to visit all other cities in Byteland. Chef can only move according to following rule. \n\nIf Chef is at city A then he continues to move from city A to city B, city B to city C (provided A is directly connected to B, B is directly connected to C) and so on unless there are no more cities leading from current city.\n\nIf so he jumps back to previous city and repeat the same tour with other cities leading from it which are not visited. Chef repeat this step unless all cities are not visited.\n\nHelp Chef to count number of ways in which he can visit all other cities . As this number can be large print it modulo 109+7\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N denoting the number of cities in Byteland.\n-  Next N-1 lines contain two space-separated integers u and v denoting there is bi-directional road between city numbered u and v. \n-  Next line contains a single integer A denoting the city number where Chef is present.\n\n-----Output-----\n- For each test case, output a single line containing number of ways in which Chef can visit all cities modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105\n- 1 ≤ A ≤ N\n\n-----Subtasks-----\nSubtask #1 : (10 points) \n- 1 ≤ N ≤ 5\nSubtask #2 : (30 points) \n- 1 ≤ N ≤ 100\nSubtask #3 : (60 points) \n- 1 ≤ N ≤ 105\n\n-----Example-----\nInput:\n2\n3\n1 2\n1 3\n1\n5\n1 2\n1 3\n2 4\n2 5\n1\n\nOutput:\n2\n4\n\n-----Explanation-----\nExample case 1. Chef can visit cities in two ways according to the problem: 1-2-3 and 1-3-2\nExample case 1. Chef can visit cities in four ways according to the problem:\n\n1-2-4-5-3\n1-2-5-4-3\n1-3-2-4-5\n1-3-2-5-4\n-/\n\n-- Helper definition for valid graphs", "vc-preamble": "def is_valid_graph (n: Nat) (roads: List (Nat × Nat)) : Prop :=\n  ∀ (u v: Nat), (u,v) ∈ roads →\n    (1 ≤ u ∧ u ≤ n) ∧\n    (1 ≤ v ∧ v ≤ n) ∧\n    (u ≠ v) ∧\n    (∀ (u' v': Nat), (u',v') ∈ roads → (u',v') = (u,v) ∨ (u',v') ≠ (u,v))", "vc-helpers": "", "vc-definitions": "def solve_city_paths (n: Nat) (roads: List (Nat × Nat)) (start: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_city_paths_single_node :\n  solve_city_paths 1 [] 1 = 1 :=\nsorry\n\ntheorem solve_city_paths_two_nodes :\n  solve_city_paths 2 [(1,2)] 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_city_paths 3 [(1, 2), (1, 3)] 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_city_paths 5 [(1, 2), (1, 3), (2, 4), (2, 5)] 1"}
{"id": "fvapps_001260", "vc-description": "/-\nIt is an interesting exercise to write a program to print out all permutations of $1, 2, …, n$. However, since there are $6227020800$ permutations of $1, 2, …, 13$, it is unlikely that we would ever run this program on an input of size more than $10$.\nHowever, here is another interesting problem whose solution can also be used to generate permutations. We can order the permutations of $1, 2, …, n$ under the lexicographic (or dictionary) order. Here are the permutations of $1,2,3$ in lexicographic order:\n123132213231312321123132213231312321 1 \\, 2 \\, 3 \\quad    1 \\, 3 \\, 2 \\quad     2 \\, 1 \\, 3 \\quad     2 \\, 3 \\, 1 \\quad     3 \\, 1 \\, 2 \\quad     3 \\, 2 \\, 1 \nThe problem we have is the following: given a permutation of $1,2, …, n$, generate the next permutation in lexicographic order. For example, for $2 3 1 4$ the answer is $2 3 4 1$.\n\n-----Input:-----\nThe first line of the input contains two integers, $N$ and $K$. This is followed by $K$ lines, each of which contains one permutation of $1, 2,…,N$.\n\n-----Output:-----\nThe output should consist of $K$ lines. Line $i$ should contain the lexicographically next permutation correponding to the permutation on line $i+1$ in the input.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 1000$.\n- $1 \\leq K \\leq 10$.\n\n-----Sample input-----\n3 2\n3 1 2\n2 3 1\n\n-----Sample output-----\n3 2 1\n3 1 2\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def nextPermutation (arr : List Int) : List Int :=\nsorry\n\ndef solve (n k : Nat) (perms : List (List Int)) : List (List Int) :=\nsorry\n\ndef isPermutation (arr1 arr2 : List Int) : Bool :=\nsorry\n\ndef isSortedDesc (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem next_permutation_preserves_elements (arr : List Int) :\n  isPermutation arr (nextPermutation arr) = true :=\nsorry\n\ntheorem next_permutation_idempotent_at_max {arr : List Int}\n  (h : isSortedDesc arr) :\n  nextPermutation arr = arr :=\nsorry\n\ntheorem next_permutation_lexicographically_larger {arr : List Int} :\n  nextPermutation arr ≥ arr ∨ isSortedDesc arr :=\nsorry\n\ntheorem solve_returns_correct_length (n k : Nat) (perms : List (List Int)) :\n  (solve n k perms).length = perms.length :=\nsorry\n\ntheorem solve_preserves_permutations (n k : Nat) (perms : List (List Int)) :\n  ∀ i, i < perms.length →\n    isPermutation (perms.get ⟨i, sorry⟩) ((solve n k perms).get ⟨i, sorry⟩) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001262", "vc-description": "/-\nYou are given a string S constisting of uppercase Latin letters. Is it possible to reorder the characters in this string to get a string with prefix \"LTIME\" and suffix \"EMITL\"?\nWe remind you that a prefix of a string is any substring which contains its first character, while a suffix of a string is substring containing its last character.\n\n-----Input-----\nThe first line contains a single integer T, denoting the number of testcases. The descriptions of T test cases follow.\nThe first and only line of the test case description has one non-empty string S consisting of uppercase Latin letters only.\n\n-----Output-----\nFor each testcase output a single line containing the string \"YES\" (without quotes) if it's possible to reorder the characters to get the required prefix and suffix, or \"NO\" (without quotes) otherwise.\n\n-----Constraints-----\n- Subtask 1 (23 points) : 1 ≤ T ≤ 100, 1 ≤ |S| ≤ 9\n- Subtask 2 (77 points) : 1 ≤ T ≤ 1000, 1 ≤ |S| ≤ 100\n\n-----Example-----\nInput:3\nLTIMEAZAZAITLME\nLLLTTTIIIMMMEEEAHA\nLTIMEM\n\nOutput:YES\nYES\nNO\n\n-----Explanation-----\nTest case 1: we can permute the last 5 letters and get LTIMEAZAZAEMITL\nTest case 2: we have 3 copies of each of the letters 'L', 'T', 'I', 'M', 'E' so we can leave 5 of them in the beginning and move 5 of them to the end.\nTest case 3: we have only one letter 'L' so we can't make necessary prefix and suffix at the same time.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isString : (s : String) → Bool :=\nsorry\n\ndef canReorderString : (s : String) → String :=\nsorry\n\ndef countChar (c : Char) (s : String) : Nat :=\nsorry\n\ndef isValidLifetime (s : String) : Bool :=\nsorry", "vc-theorems": "theorem canReorderString_valid_output (s : String) :\n  (canReorderString s = \"YES\") ∨ (canReorderString s = \"NO\") :=\nsorry\n\ntheorem canReorderString_matches_validity (s : String) :\n  canReorderString s = (if isValidLifetime s then \"YES\" else \"NO\") :=\nsorry\n\ntheorem exactly_nine_chars (s : String) (h : s.length = 9) :\n  countChar 'L' s ≥ 2 →\n  countChar 'T' s ≥ 2 →\n  countChar 'I' s ≥ 2 →\n  countChar 'M' s ≥ 2 →\n  countChar 'E' s ≥ 1 →\n  canReorderString s = \"YES\" :=\nsorry\n\ntheorem more_than_nine_chars (s : String) (h : s.length > 9) :\n  countChar 'L' s ≥ 2 →\n  countChar 'T' s ≥ 2 →\n  countChar 'I' s ≥ 2 →\n  countChar 'M' s ≥ 2 →\n  countChar 'E' s ≥ 2 →\n  canReorderString s = \"YES\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEAZAZAITLME\"\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LLLTTTIIIMMMEEEAHA\"\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEM\""}
{"id": "fvapps_001263", "vc-description": "/-\nAs we all know, F.C. Barcelona is the best soccer team of our era! Their entangling and mesmerizing game style usually translates into very high ball possession, consecutive counter-attack plays and goals. Lots of goals, thanks to the natural talent of their attacker and best player in history, Lionel Andres Messi.\nHowever, at the most prestigious tournament of individual teams, the UEFA Champions League, there are no guarantees and believe it or not, Barcelona is in trouble.... They are tied versus Chelsea, which is a very defending team that usually relies on counter-strike to catch opposing teams off guard and we are in the last minute of the match. So Messi decided to settle things down for good and now he is conducting the ball on his teams' midfield and he will start a lethal counter-attack :D\nAfter dribbling the 2 strikers from Chelsea, he now finds himself near the center of the field and he won't be able to dribble the entire team on his own, so he will need to pass the ball to one of his teammates, run forward and receive the ball once again to score the final goal.\nExactly K players are with him on his counter-attack and the coach, Tito Villanova knows that this counter-attack will end in a goal only if after exactly N passes are performed between the players, Messi ends up with the ball.\n(Note that the ball only needs to end with Messi after exactly N passes are performed between all the K+1 players, i.e. Messi can receive the ball several times during the N passes. See the 2nd test case explanation for further clarification. ) \nHowever, he realized that there are many scenarios possible for this, so he asked you, his assistant coach, to tell him in how many ways can Messi score the important victory goal. So help him!!\n\n-----Input-----\nInput will contain a number T denoting the number of test cases.\nThen T test cases follow, each one consisting of two space-sparated integers N and K.\n\n-----Output-----\nFor each test case, output a single integer, the number of ways the winning play might happen modulo 1000000007 (109+7).\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 100\n- 2 ≤ N ≤ 1000\n- 1 ≤ K ≤ 10\n\n-----Example-----\nInput:\n2\n2 4\n4 2\n\nOutput:\n4\n6\n\n-----Explanation-----\nIn the first test case, say four players with Messi are Xavi, Busquets, Iniesta and Jordi Alba. Then the ways of the winning play to happen when exactly  2 passes are to be performed are:\n1) Messi - Xavi - Messi\n2) Messi - Busquets - Messi\n3) Messi - Iniesta - Messi\n4) Messi - Alba - Messi\n\nIn the second test case, also say that two players with Messi are Xavi and Iniesta. There are 6 ways for the winning play to happen when exactly 4 passes are performed. All the examples of such winning play are:\n1) Messi - Xavi - Messi - Iniesta - Messi\n2) Messi - Xavi - Iniesta - Xavi - Messi\n3) Messi - Xavi - Messi - Xavi - Messi\n4) Messi - Iniesta - Messi - Iniesta - Messi\n5) Messi - Iniesta - Messi - Xavi - Messi\n6) Messi - Iniesta - Xavi - Iniesta - Messi\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_messi_passing (n_passes: Nat) (k_teammates: Nat) : Nat :=\nsorry", "vc-theorems": "theorem two_passes_equals_teammates {k: Nat} (h: k ≤ 1000) (h2: k ≥ 1) :\n  solve_messi_passing 2 k = k :=\nsorry\n\ntheorem result_bounded_by_power {n k: Nat} (h1: n ≥ 2) (h2: n ≤ 1000)\n    (h3: k ≥ 1) (h4: k ≤ 1000) :\n  solve_messi_passing n k ≤ k^(n-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_messi_passing 2 4\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 4 2\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 3 3"}
{"id": "fvapps_001267", "vc-description": "/-\nYou are given two positive integers $N$ and $K$, where $K \\le N$. Find a sequence $A_1, A_2, \\ldots, A_N$ such that:\n- for each valid $i$, $A_i$ is either $i$ or $-i$\n- there are exactly $K$ values of $i$ such that $1 \\le i \\le N$ and $A_1 + A_2 + \\ldots + A_i > 0$\nIf there are multiple solutions, you may print any one of them. It can be proved that at least one solution always exists.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains two space-separated integers $N$ and $K$.\n\n-----Output-----\nFor each test case, print a single line containing $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le K \\le N \\le 1,000$\n\n-----Subtasks-----\nSubtask #1 (10 points): $N \\le 10$\nSubtask #2 (90 points): original constraints\n\n-----Example Input-----\n1\n3 3\n\n-----Example Output-----\n1 2 3\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.size {α} : List α → Nat\n  | [] => 0\n  | _::xs => 1 + xs.size\n\ndef sequence_generator (n k : Nat) : List Int :=\n  sorry\n\ndef count_positive_prefixes (seq : List Int) : Nat :=\n  sorry\n\ndef sumList (xs : List Int) : Int :=\n  sorry\n\ndef Int.abs (i : Int) : Nat :=\n  sorry", "vc-theorems": "theorem sequence_length (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n  (sequence_generator n k).size = n :=\nsorry\n\ntheorem sequence_elements (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) (h3 : i < n) :\n  let seq := sequence_generator n k\n  ∀ i : Nat, i < n → Int.abs (seq.get ⟨i, sorry⟩) = i + 1 :=\nsorry\n\ntheorem positive_prefix_count (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n  count_positive_prefixes (sequence_generator n k) ≤ min k n :=\nsorry\n\ntheorem all_positive_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n n\n  (∀ i : Nat, i < n → seq.get ⟨i, sorry⟩ > 0) ∧\n  seq = List.map (Int.ofNat ∘ Nat.succ) (List.range n) :=\nsorry\n\ntheorem all_negative_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n 0\n  (∀ i : Nat, i < n → seq.get ⟨i, sorry⟩ < 0) ∧\n  seq = List.map (fun i => -Int.ofNat (i + 1)) (List.range n) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval sequence_generator 3 3"}
{"id": "fvapps_001268", "vc-description": "/-\nThe Little Elephant from the Zoo of Lviv has an array A that consists of N positive integers. Let A[i] be the i-th number in this array (i = 1, 2, ..., N).\n\nFind the minimal number x > 1 such that x is a divisor of all integers from array A. More formally, this x should satisfy the following relations:\n\nA[1] mod x = 0, A[2] mod x = 0, ..., A[N] mod x = 0,\n\nwhere mod stands for the modulo operation. For example,  8 mod 3 = 2,  2 mod 2 = 0, 100 mod 5 = 0 and so on. If such number does not exist, output -1.\n\n-----Input-----\n\nThe first line of the input contains a single integer T, the number of test cases. T test cases follow. The first line of each test case contains a single integer N, the size of the array A for the corresponding test case. The second line contains N space separated integers A[1], A[2], ..., A[N].\n\n-----Output-----\n\nFor each test case output a single line containing the answer for the corresponding test case.\n\n-----Constraints-----\n1 ≤ T ≤ 100000\n\n1 ≤ N ≤ 100000\n\nThe sum of values of N in each test file does not exceed 100000\n\n1 ≤ A[i] ≤ 100000\n\n-----Example-----\nInput:\n2\n3\n2 4 8\n3\n4 7 5\n\nOutput:\n2\n-1\n\n-----Explanation-----\nCase 1. Clearly 2 is a divisor of each of the numbers 2, 4 and 8. Since 2 is the least number greater than 1 then it is the answer.\n\nCase 2. Let's perform check for several first values of x.\n\nx4 mod x7 mod x5 mod x20113112403154206415740584759475\n\nAs we see each number up to 9 does not divide all of the numbers in the array. Clearly all larger numbers also will fail to do this. So there is no such number x > 1 and the answer is -1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_divisor (nums: List Nat) : Int :=\n  sorry\n\ndef is_divides_all (d: Nat) (nums: List Nat) : Bool :=\n  sorry\n\ndef gcd (a b: Nat) : Nat :=\n  sorry\n\ndef list_gcd (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_divides_all_numbers (nums: List Nat) :\n  let result := find_min_divisor nums\n  result ≠ -1 → is_divides_all result.toNat nums = true := by\n  sorry\n\ntheorem negative_one_means_no_common_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 → list_gcd nums = 1 := by\n  sorry\n\ntheorem result_is_minimal_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result ≠ -1 →\n  ∀ d: Nat, 2 ≤ d → d < result.toNat →\n  is_divides_all d nums = false := by\n  sorry\n\ntheorem result_is_valid_number (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 ∨ result ≥ 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [2, 4, 8]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_divisor [4, 7, 5]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [12, 18, 24]"}
{"id": "fvapps_001277", "vc-description": "/-\nSnackdown 2019 is coming! There are two rounds (round A and round B) after the qualification round. From both of them, teams can qualify to the pre-elimination round. According to the rules, in each of these two rounds, teams are sorted in descending order by their score and each team with a score greater or equal to the score of the team at the $K=1500$-th place advances to the pre-elimination round (this means it is possible to have more than $K$ qualified teams from each round in the case of one or more ties after the $K$-th place).\nToday, the organizers ask you to count the number of teams which would qualify for the pre-elimination round from round A for a given value of $K$ (possibly different from $1500$). They provided the scores of all teams to you; you should ensure that all teams scoring at least as many points as the $K$-th team qualify.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $S_1, S_2, \\dots, S_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the number of qualified teams.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le K \\le N \\le 10^5$\n- $1 \\le S_i \\le 10^9$ for each valid $i$\n- the sum of $N$ for all test cases does not exceed $10^6$\n\n-----Example Input-----\n2\n5 1\n3 5 2 4 5\n6 4\n6 5 4 3 2 1\n\n-----Example Output-----\n2\n4\n-/", "vc-preamble": "def list_max (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs\n\ndef list_unique (l : List Int) : Prop :=\n  ∀ (i j : Fin l.length), i.val ≠ j.val → l[i] ≠ l[j]", "vc-helpers": "", "vc-definitions": "def count_qualified_teams (n : Nat) (k : Nat) (scores : List Int) : Nat :=\nsorry", "vc-theorems": "theorem count_qualified_teams_bounds (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k ≤ scores.length)\n    (h3 : scores.length = n) :\n    k ≤ count_qualified_teams n k scores ∧ count_qualified_teams n k scores ≤ n :=\nsorry\n\ntheorem count_qualified_teams_deterministic (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k ≤ scores.length)\n    (h3 : scores.length = n) :\n    count_qualified_teams n k scores = count_qualified_teams n k scores :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 5 1 [3, 5, 2, 4, 5]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_qualified_teams 6 4 [6, 5, 4, 3, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 4 2 [10, 10, 8, 8]"}
{"id": "fvapps_001282", "vc-description": "/-\nChef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nChef has a positive integer N. He can apply any of the following operations as many times as he want in any order:\n\n-  Add 1 to the number N.\n\n-  Take some digit of N and replace it by any non-zero digit.\n\n-  Add any non-zero leading digit to N.\n\nFind the minimum number of operations that is needed for changing N to the lucky number.\n\n-----Input-----\nThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a positive integer N without leading zeros. \n\n-----Output-----\nFor each T test cases print one integer, the minimum number of operations that is needed for changing N to the lucky number.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ N < 10100000\n\n-----Example-----\nInput:\n3\n25\n46\n99\n\nOutput:\n2\n1\n2\n-/\n\n/- Basic properties about operation counting -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Helper function to count non-lucky digits -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calcMinOpsLuckyNum (n : String) : Nat :=\n  sorry\n\ndef countNonLuckyDigits (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem result_is_nonnegative (n : String) :\n  calcMinOpsLuckyNum n ≥ 0 :=\nsorry\n\ntheorem max_ops_is_length (n : String) :\n  calcMinOpsLuckyNum n ≤ n.length :=\nsorry\n\ntheorem ops_equals_non_lucky_digits (n : String) :\n  calcMinOpsLuckyNum n = countNonLuckyDigits n :=\nsorry", "vc-postamble": "/--\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"25\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"46\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"99\""}
{"id": "fvapps_001290", "vc-description": "/-\nA printer – who still uses moveable type – is preparing to print a set of pages for a book. These pages are to be numbered, as usual. The printer needs to know how many instances of each decimal digit will be required to set up the page numbers in the section of the book to be printed.\n\nFor example, if pages 10, 11, 12, 13, 14 and 15 are to be printed, computing the number of digits is relatively simple: just look at the page numbers that will appear, and count the number of times each digit appears. The digit 0 appears only once, the digit 1 appears 7 times, the digits 2, 3, 4 and 5 each appear once, and 6, 7, 8 and 9 don’t appear at all.\n\nYour task in this problem is to provide the printer with the appropriate counts of the digits. You will be given the numbers of the two pages that identify the section of the book to be printed. You may safely assume that all pages in that section are to be numbered, that no leading zeroes will be printed, that page numbers are positive, and that no page will have more than three digits in its page number.\n\n-----Input-----\n\nThere will be multiple cases to consider. The input for each case has two integers, A and B, each of which is guaranteed to be positive. These identify the pages to be printed. That is, each integer P between A and B, including A and B, is to be printed. A single zero will follow the input for the last case.\n\n-----Output-----\n\nFor each input case, display the case number (1, 2, …) and the number of occurrences of each decimal digit 0 through 9 in the specified range of page numbers. Display your results in the format shown in the examples below.\n\n-----Example-----\nInput:\n\n10 15\n912 912\n900 999\n0\n\nOutput:\n\nCase 1: 0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0\nCase 2: 0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1\nCase 3: 0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120\n-/", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs\n\ndef isSorted : List String → Bool\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)", "vc-helpers": "", "vc-definitions": "def countDigits (a b : Nat) : String :=\nsorry", "vc-theorems": "theorem countDigits_format_valid {a b : Nat} (h : a ≤ b) (n : Nat) (h1 : n < 10^4) :\n  let result := countDigits a b\n  let pairs := (result.split (· = ' '))\n  pairs.length = 10 ∧\n  (∀ p ∈ pairs, ∃ d c, (p.split (· = ':')) = [d, c] ∧\n     d ∈ [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] ∧\n     (∀ ch ∈ c.data, ch.isDigit)) ∧\n  isSorted (pairs.map (fun p => ((p.split (· = ':')).get! 0))) :=\nsorry\n\ntheorem countDigits_count_valid {a b : Nat} (h : a ≤ b) :\n  let result := countDigits a b\n  let counts := ((result.split (· = ' ')).map\n    (fun p => String.toNat! ((p.split (· = ':')).get! 1)))\n  let digitCount := (List.range (b - a + 1)).map\n    (fun i => (toString (i + a)).length)\n  sumList counts = sumList digitCount :=\nsorry\n\ntheorem countDigits_single_num_valid (n : Nat) :\n  let result := countDigits n n\n  let counts := ((result.split (· = ' ')).map\n    (fun p => String.toNat! ((p.split (· = ':')).get! 1)))\n  ∀ d : Nat, d < 10 →\n    (counts.get! d) = ((toString n).data.filter\n      (fun c => c = (toString d).data.get! 0)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0'\n-/\n#guard_msgs in\n#eval count_digits 10 15\n\n/--\ninfo: '0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1'\n-/\n#guard_msgs in\n#eval count_digits 912 912\n\n/--\ninfo: '0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120'\n-/\n#guard_msgs in\n#eval count_digits 900 999"}
{"id": "fvapps_001291", "vc-description": "/-\nThe $String$ Family gave birth to a new $Tripartite$ $trio$ $sisters$ and named them $Hema$, $Rekha$ and $Sushma$. Hema and Rekha are very fond of parties whereas Sushma hates them. One day Hema and Rekha asked their parents to buy them candies to distribute to people in their birthday party. (Remember Hema, Rekha and Sushma were born on the same day). But Sushma was uninterested in the party and only wanted candies for herself.\nYou will be given a list $P$ of possible number of candidates coming to the party. Were $P[i]$ denotes the count of people coming in the i th possibility. In each case every person should get maximum possible equal number of candies  such that after distributing the candies, there are always $R$ candies remaining for Sushma. You have to calculate the minimum number of candies required to buy so that, in any possible situation of the given array, each person coming to party gets equal number of candies (at least 1 and maximum possible out of total) and there are always $R$ candies remaining for Sushma.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each test case contain  $N$, number of possible count of people coming to party\n- Next line contain $N$ spaced integers denoting the count of people \n- Next line contain $R$ the number of candies always remaining after maximum equal distribution\n\n-----Output:-----\nFor each testcase, output in a single line answer, the minimum number of candies required to buy.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq P[i] \\leq 41$\n- $0 \\leq R < min(P[i])$\n\n-----Sample Input:-----\n1\n2\n2 3\n1\n\n-----Sample Output:-----\n7\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_candies_for_party (people_counts: List Nat) (remainder: Nat) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry", "vc-theorems": "def lcm (a b : Nat) : Nat := Nat.div (a * b) (gcd a b)\n\ntheorem remainder_divides_result (people_counts: List Nat) (remainder: Nat) (count: Nat)\n  (h: count ∈ people_counts) (h2: count > 0) :\n  count ∣ (min_candies_for_party people_counts remainder - remainder) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 3] 1\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 4, 6] 1\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [5] 2"}
{"id": "fvapps_001293", "vc-description": "/-\nVasya learned about integer subtraction in school. He is still not very good at it, so he is only able to subtract any single digit number from any other number (which is not necessarily single digit).\nFor practice, Vasya chose a positive integer n$n$ and wrote it on the first line in his notepad. After that, on the second line he wrote the result of subtraction of the first digit of n$n$ from itself. For example, if n=968$n = 968$, then the second line would contain 968−9=959$968 - 9 = 959$, while with n=5$n = 5$ the second number would be 5−5=0$5 - 5 = 0$. If the second number was still positive, then Vasya would write the result of the same operation on the following line, and so on. For example, if n=91$n = 91$, then the sequence of numbers Vasya would write starts as follows: 91,82,74,67,61,55,50,…$91, 82, 74, 67, 61, 55, 50, \\ldots$. One can see that any such sequence eventually terminates with the number 0$0$.\nSince then, Vasya lost his notepad. However, he remembered the total number k$k$ of integers he wrote down (including the first number n$n$ and the final number 0$0$). What was the largest possible value of n$n$ Vasya could have started with?\n\n-----Input:-----\nThe first line contains T$T$ , number of test cases per file.\nThe only line in each testcase contains a single integer k−$k-$ the total number of integers in Vasya's notepad (2≤k≤1012$2 \\leq k \\leq 10^{12}$).\n\n-----Output:-----\nPrint a single integer−$-$ the largest possible value of the starting number n$n$. It is guaranteed that at least one such number n$n$ exists, and the largest possible value is finite.\n\n-----Constraints-----\n- 1≤T≤34$1 \\leq  T \\leq 34 $\n- 2≤k≤1012$2 \\leq k \\leq 10^{12}$\n\n-----Sample Input-----\n3\n2\n3\n100\n\n-----Sample Output:-----\n9\n10\n170\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_n (k : Nat) : Nat :=\n  sorry\n\ndef count_steps_to_zero (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_largest_n_returns_valid (k : Nat) (h : k > 0) (h2 : k ≤ 1000) :\n  find_largest_n k ≥ 0 :=\nsorry\n\ntheorem find_largest_n_edge_cases :\n  find_largest_n 1 = 0 ∧\n  find_largest_n 2 = 9 ∧\n  find_largest_n 3 = 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval find_largest_n 2\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval find_largest_n 3\n\n/--\ninfo: 170\n-/\n#guard_msgs in\n#eval find_largest_n 100"}
{"id": "fvapps_001298", "vc-description": "/-\nAt the legendary times of Nonsenso wars in ISM Dhanbad, there was a neck to neck competition between Barney Stinson and Sheldon Cooper. They both were on level 19. After trying too hard both of them could not decipher the nonsense, so they decided to play alongside. Sheldon Cooper had to pass a message to Barney Stinson. So he decided to convert each letter of the sentence to their corresponding to their ASCII codes. When Barney received the message he could not get anything. Now you have to design a code which converts the encrypted message to readable format.\n\n-----Input-----\nThe input will consist of the first line containing the number of test cases ‘n’ followed by n lines of test cases.\n\n-----Output-----\n\nFor each input print the decoded line.\n\n-----Example-----\nInput:\n2\n721011081081113287111114108100\n871011089911110910132116111327311010010597\n\nOutput:\nHello World\nWelcome to India\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encodeAscii (s : String) : String :=\n  sorry\n\ndef decodeAsciiMessage (s : String) : String :=\n  sorry", "vc-theorems": "theorem decode_matches_input {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    decodeAsciiMessage (encodeAscii s) = s :=\nsorry\n\ntheorem decoded_chars_in_ascii_range {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    ∀ c ∈ (decodeAsciiMessage (encodeAscii s)).data,\n      32 ≤ c.toNat ∧ c.toNat ≤ 126 :=\nsorry\n\ntheorem encoded_is_numeric {s : String}\n    (h1 : s ≠ \"\")\n    (h2 : ∀ c ∈ s.data, 32 ≤ c.toNat ∧ c.toNat ≤ 126) :\n    ∀ c ∈ (encodeAscii s).data, c.isDigit :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"721011081081113287111114108100\"\n\n/--\ninfo: 'Welcome to India'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"871011089911110910132116111327311010010597\""}
{"id": "fvapps_001302", "vc-description": "/-\nChef has a number N, Cheffina challenges the chef to check the divisibility of all the permutation of N by 3. If any of the permutations is divisible by 3 then print 1 else print 0.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n18\n308\n\n-----Sample Output:-----\n1\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_permutation_divisible_by_3 (n : Nat) : Nat :=\nsorry\n\ndef sum_digits (n : Nat) : Nat :=\nsorry\n\ndef get_digits (n : Nat) : List Nat :=\nsorry\n\ndef sort_digits (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem check_permutation_returns_binary (n : Nat) :\n  check_permutation_divisible_by_3 n = 0 ∨ check_permutation_divisible_by_3 n = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 18\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 308\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 123"}
{"id": "fvapps_001318", "vc-description": "/-\nMaster Shifu is training Po to become The Dragon Warrior and as a final assignment he must obtain maximum deliciousness from dumplings. There are  $N$ plates of dumplings in front of him with deliciousness $A_1, A_2, \\ldots, A_N$, Po can choose any number of continuous plates of  dumplings. The total deliciousness is the sum of deliciousness of all the  chosen dumplings.\nWhat is the minimum number of plates he must choose so that total deliciousness is maximum possible?\nNote: Po must choose atleast one plate.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output:-----\nFor each test case, print a single line containing one integer.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le N \\le 2 \\cdot 10^5$\n- $0 \\le A_i \\le 10^9$\n\n-----Sample Input:-----\n2\n4\n1 2 3 4\n5\n3 2 0 3 0\n\n-----Sample Output:-----\n4\n4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_plates_max_deliciousness (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef countLeadingZeros (arr : List Nat) : Nat :=\nsorry\n\ndef countTrailingZeros (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_plates_result_bounds {n : Nat} {arr : List Nat}\n  (h : arr.length = n) (h2 : n > 0) :\n  let result := min_plates_max_deliciousness n arr\n  1 ≤ result ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 4 [1, 2, 3, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 5 [3, 2, 0, 3, 0]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 3 [0, 0, 0]"}
{"id": "fvapps_001319", "vc-description": "/-\nSebi lives in Chefland where the government is extremely corrupt that usually makes fool out of public by announcing eye catching but non-sustainable schemes. Recently there was a move to increase tourism in the country that was highly lauded. Sebi wants to examine whether the move has some potential or is a hogwash as usual.\nThe Chefland is a city with very old road infrastructure. The city has N tourist places. All the places are reachable from each other. The corrupt administrators of the city constructed as few roads as possible just ensuring that all the places are reachable from each other, and those too have now gone old with potholes every here and there. Upon this, there is a toll tax for each road too, which you have to pay once for using that road. Once you pay the tax for a road, you can visit it again as many times as possible.\nThe tourists coming to Chefland usually want to see all the N nice places. They usually have visit in their own vehicle and stay for few days. Also, they are usually not very rich, they want to pay as less toll tax as possible. For promoting tourism, the government offered their citizens a scheme. It was announced that citizens can choose any two places and the government will build a high class road between those two places and that too without any toll tax. Note that citizens may choose to have a high class road between two cities which already have an old road between them.\nSebi is very sceptical of the claims of the announcement. So, he wants to understand the expected toll tax a tourist has to pay to tour the entire city considering that the citizens of Chefland vote for the two cities for constructing high road uniformly randomly. Can you please him in finding this?\n\n-----Input-----\nThere is a single test case per test file.\nThe first line of the input contains an integer N denoting the number of tourist spots in Chefland.\nEach of the he next N - 1 lines contains three space separated integers u, v, c, denoting that there is a road between tourist spot u and v which has a toll tax of c Rs.\n\n-----Output-----\nOutput a single line containing the expected toll tax a tourist has to pay for visiting all the N spots after the construction of new road. Your answer will be considered correct if it has an absolute error less than or equal to 1e-2.\n\n-----Constraints-----\n- 2 ≤ N ≤ 105\n- 1 ≤ u, v ≤ N\n- 0 ≤ c ≤ 106\n\n-----Example-----\nInput:\n3\n1 2 3\n1 3 2\n\nOutput:\n2.333333\n\n-----Explanation-----\nAssume that the citizens construct the high class road between city 1 and 2. A tourist can visit all the places by just paying a toll tax of 2 Rs.\nIf the high class road is constructed between city 1 and 3. All the places then can be visited by just paying a toll tax of 3 Rs.\nIf the cities 2 and 3 are connected by the high class road. All the places can be visited by paying a toll tax of 2Rs. \nHence expected Rs. that a tourist has to pay in toll tax will be (2 + 3 + 2) / 3 = 7 / 3 = 2.333333\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tourist_spots (n : Nat) (roads : List String) : Float :=\nsorry\n\ndef isValidRoad : String → Bool :=\nsorry", "vc-theorems": "theorem solve_tourist_spots_output_is_float (n : Nat) (roads : List String)\n    (h : n ≥ 2) (h2 : roads.length > 0) :\n  ∃ (f : Float), solve_tourist_spots n roads = f :=\nsorry\n\ntheorem solve_tourist_spots_total_weight\n    {n : Nat} {roads : List String} {weights : List Float}\n    (h : n ≥ 2)\n    (h2 : roads.length > 0)\n    (h3 : weights = roads.map (fun r => sorry)) :\n  solve_tourist_spots n roads ≤ weights.foldl (. + .) 0.0 :=\nsorry\n\ntheorem solve_tourist_spots_invalid_input\n    {n : Nat} {roads : List String}\n    (h : n ≥ 2)\n    (h2 : ∃ r ∈ roads, ¬ isValidRoad r) :\n  solve_tourist_spots n roads = 0.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001328", "vc-description": "/-\n-----General Statement:-----\nGiven the actual high and low temperatures for the day and the normal high and low temperatures for that day, calculate the average difference from normal.\n\n-----Input:-----\nThe first line of the data set for this problem is an integer that represents the number of data sets that follow. Each data set is on a separate line and consists of today’s high, today’s low, normal high, and normal low – in that order.\n\n-----Output:-----\nIf the average difference is negative, do not output the negative sign (-).\nOutput the amount of deviation from normal, followed by the words\nDEGREE(S) ABOVE NORMAL, or by the words\nDEGREE(S) BELOW NORMAL.\nRound to 1 decimal place. A trailing zero is required if the average is an integer.\nThe output is to be formatted exactly like that for the sample output given below.\n\n-----Assumptions:-----\nTemperatures are in the range –15..100 degrees.\nThe average temperature difference will not be zero.\n\n-----Discussion:-----\nDetermine the average of the difference of the high temperatures and the difference of the low temperatures.\n\n-----Sample Input:-----\n3\n75 45 78 40\n50 32 45 30\n56 48 62 45\n\n-----Sample Output:-----\n1.0 DEGREE(S) ABOVE NORMAL\n3.5 DEGREE(S) ABOVE NORMAL\n1.5 DEGREE(S) BELOW NORMAL\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_temp_difference (today_high today_low normal_high normal_low : Int) : String :=\nsorry\n\ndef String.contains? (s : String) (substr : String) : Bool :=\nsorry\n\ndef String.toFloat (s : String) : Float :=\nsorry\n\ndef Int.toFloat (i : Int) : Float :=\nsorry", "vc-theorems": "theorem temp_diff_result_format (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  ∃ (diff : String) (dir : String),\n    result = diff ++ \" DEGREE(S) \" ++ dir ++ \" NORMAL\" ∧\n    (dir = \"ABOVE\" ∨ dir = \"BELOW\") :=\nsorry\n\ntheorem temp_diff_nonnegative (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let parts := result.splitOn \" DEGREE(S) \"\n  let diff := parts[0]!\n  String.toFloat diff ≥ 0 :=\nsorry\n\ntheorem temp_diff_direction (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high ≥ today_low) (h2 : normal_high ≥ normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let avg_today : Float := (today_high.toFloat + today_low.toFloat) / 2\n  let avg_normal : Float := (normal_high.toFloat + normal_low.toFloat) / 2\n  (avg_today > avg_normal → result.contains? \"ABOVE\") ∧\n  (avg_today ≤ avg_normal → result.contains? \"BELOW\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001334", "vc-description": "/-\nOn each of the following $N$ days (numbered $1$ through $N$), Chef is planning to cook either pizza or broccoli. He wrote down a string $A$ with length $N$, where for each valid $i$, if the character $A_i$ is '1', then he will cook pizza on the $i$-th day, while if $A_i$ is '0', he will cook broccoli on this day.\nChefu, his son, loves pizza but hates broccoli ― just like most kids. He wants to select a substring of $A$ with length $K$ and change each character '0' in this substring to '1'. Afterwards, let's define pizza time as the maximum number of consecutive days where Chef will cook pizza. Find the maximum pizza time Chefu can achieve.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$. \n- The second line contains a string $A$ with length $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum pizza time.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le K \\le N \\le 10^5$\n- $A$ contains only characters '0' and '1'\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- $N \\le 10^3$\n- the sum of $N$ over all test cases does not exceed $10^4$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n2\n13 2\n0101110000101\n6 3\n100001\n\n-----Example Output-----\n5\n4\n\n-----Explanation-----\nExample case 1: Chefu can choose the substring $A[2, 3]$ = \"10\", and change the third character of $A$ to '1'. Then, the pizza time is $5$ days: from day $2$ to day $6$.\nExample case 2: Chefu can choose the substring $A[2, 4]$ = \"000\". Then, the pizza time is $4$ days: from day $1$ to day $4$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_pizza_time (n : Nat) (k : Nat) (s : String) : Nat :=\n  sorry\n\ndef count_ones (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem max_pizza_time_bounds (n k: Nat) (s: String) :\n  n > 0 → s.length = n →\n  let result := max_pizza_time n k s\n  0 ≤ result ∧ result ≤ n :=\nsorry\n\ntheorem max_pizza_time_upper_bound (n k: Nat) (s: String) :\n  n > 0 → s.length = n →\n  max_pizza_time n k s ≤ n :=\nsorry\n\ntheorem max_pizza_time_all_ones (n: Nat) :\n  n > 0 →\n  let s := String.mk (List.replicate n '1')\n  max_pizza_time n 0 s = n :=\nsorry\n\ntheorem max_pizza_time_all_zeros (n: Nat) :\n  n > 0 →\n  let s := String.mk (List.replicate n '0')\n  let k := n / 2\n  max_pizza_time n k s = k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pizza_time 13 2 \"0101110000101\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval max_pizza_time 6 3 \"100001\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval max_pizza_time 5 2 \"10001\""}
{"id": "fvapps_001344", "vc-description": "/-\nRam and Shyam are sitting next to each other, hoping to cheat on an exam. However, the examination board has prepared $p$ different sets of questions (numbered $0$ through $p-1$), which will be distributed to the students in the following way:\n- The students are assigned roll numbers — pairwise distinct positive integers.\n- If a student's roll number is $r$, this student gets the $((r-1)\\%p)$-th set of questions.\nObviously, Ram and Shyam can cheat only if they get the same set of questions.\nYou are given the roll numbers of Ram and Shyam: $A$ and $B$ respectively. Find the number of values of $p$ for which they can cheat, or determine that there is an infinite number of such values.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains two space-separated integers $A$ and $B$.\n\n-----Output-----\nFor each test case, print a single line — the number of values of $p$ for which Ram and Shyam can cheat, or $-1$ if there is an infinite number of such values.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le A, B \\le 10^8$\n\n-----Example Input-----\n1\n2 6\n\n-----Example Output-----\n3\n\n-----Explanation-----\nExample case 1: They can cheat for $p = 1$, $p = 2$ or $p = 4$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_cheat_possibilities (a b : Nat) : Int :=\n  sorry\n\ndef countDivisors (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem same_numbers_returns_negative_one\n  {x : Nat} (h : x > 0) (h2 : x ≤ 1000) :\n  solve_cheat_possibilities x x = -1 :=\nsorry\n\ntheorem result_is_symmetric\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a ≤ 1000) (h4 : b ≤ 1000) :\n  solve_cheat_possibilities a b = solve_cheat_possibilities b a :=\nsorry\n\ntheorem result_is_nonnegative_for_different\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a ≤ 1000) (h4 : b ≤ 1000) (h5 : a ≠ b) :\n  solve_cheat_possibilities a b ≥ 0 :=\nsorry\n\ntheorem perfect_squares_have_odd_factors\n  {n : Nat} (h1 : n > 0) (h2 : n ≤ 100) :\n  solve_cheat_possibilities 0 (n * n) % 2 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 2 6\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 5 5\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 10 14"}
{"id": "fvapps_001355", "vc-description": "/-\nA sophomore Computer Science student is frustrated with boring college lectures. Professor X agreed to give him some questions; if the student answers all questions correctly, then minimum attendance criteria will not apply to him.\nProfessor X chooses a sequence $A_1, A_2, \\ldots, A_N$ and asks $Q$ queries. In each query, the student is given an integer $P$; he has to construct a sequence $B_1, B_2, \\ldots, B_N$, where $P \\oplus A_i = B_i$ for each valid $i$ ($\\oplus$ denotes bitwise XOR), and then he has to find the number of elements of this sequence which have an even number of $1$-s in the binary representation and the number of elements with an odd number of $1$-s in the binary representation. Help him answer the queries.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $Q$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n- $Q$ lines follow. Each of these lines contains a single integer $P$ describing a query.\n\n-----Output-----\nFor each query, print a single line containing two space-separated integers ― the number of elements with an even number of $1$-s and the number of elements with an odd number of $1$-s in the binary representation.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N, Q \\le 10^5$\n- $ T \\cdot (N+Q) \\leq 4 \\cdot 10^6 $\n- $1 \\le A_i \\le 10^8$ for each valid $i$\n- $1 \\le P \\le 10^5$\nThe input/output is quite large, please use fast reading and writing methods.\n\n-----Subtasks-----\nSubtask #1 (30 points): $N, Q \\le 1,000$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n1\n6 1\n4 2 15 9 8 8\n3\n\n-----Example Output-----\n2 4\n\n-----Explanation-----\nExample case 1: The elements of the sequence $B$ are $P \\oplus 4 = 7$, $P \\oplus 2 = 1$, $P \\oplus 15 = 12$, $P \\oplus 9 = 10$, $P \\oplus 8 = 11$ and $P \\oplus 8 = 11$. The elements which have an even number of $1$-s in the binary representation are $12$ and $10$, while the elements with an odd number of $1$-s are $7$, $1$, $11$ and $11$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_xor_parity (n m : Nat) (arr queries : List Nat) : List String :=\n  sorry\n\ndef popCount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_xor_parity_output_format {n m : Nat} {arr queries : List Nat}\n    (h1 : arr.length > 0) (h2 : queries.length > 0)\n    (h3 : arr.length = n) (h4 : queries.length = m) :\n    let result := solve_xor_parity n m arr queries\n    result.length = queries.length ∧\n    ∀ r ∈ result,\n      ∃ evens odds : Nat,\n        r = toString evens ++ \" \" ++ toString odds ∧\n        evens + odds = arr.length :=\nsorry\n\ntheorem solve_xor_parity_idempotent {n : Nat} {arr : List Nat} {query : Nat}\n    (h : arr.length > 0) (h2 : arr.length = n) :\n    solve_xor_parity n 1 arr [query] = solve_xor_parity n 1 arr [query] :=\nsorry\n\ntheorem solve_xor_parity_singleton {x query : Nat} :\n    let result := solve_xor_parity 1 1 [x] [query]\n    let r := result[0]!\n    let evens := (r.splitOn \" \")[0]!.toNat!\n    let odds := (r.splitOn \" \")[1]!.toNat!\n    evens + odds = 1 ∧\n    (if (popCount (x.xor query)) % 2 = 0\n     then evens = 1 ∧ odds = 0\n     else evens = 0 ∧ odds = 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: ['2 4']\n-/\n#guard_msgs in\n#eval solve_xor_parity 6 1 [4, 2, 15, 9, 8, 8] [3]\n\n/--\ninfo: ['0 2']\n-/\n#guard_msgs in\n#eval solve_xor_parity 2 1 [1, 2] [3]\n\n/--\ninfo: ['0 1']\n-/\n#guard_msgs in\n#eval solve_xor_parity 1 1 [5] [7]"}
{"id": "fvapps_001358", "vc-description": "/-\nChef solved so many hard questions, now he wants to solve some easy problems for refreshment. Chef asks Cheffina for the new question. Cheffina challanges the chef to print the total number of 1's in the binary representation of N(natural number).\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $1 \\leq N \\leq 10^6$\n\n-----Sample Input:-----\n2\n2\n5\n\n-----Sample Output:-----\n1\n2\n\n-----EXPLANATION:-----\nFor 1) Binary representation of 2 is 10. i.e. only one 1 present in it.\nFor 2) Binary representation of 5 is 101, i.e. two 1's present in it.\n-/", "vc-preamble": "def count_bits : Nat → Nat :=\n  fun n => if n = 0 then 0 else (n % 2) + count_bits (n / 2)\ndecreasing_by all_goals simp_wf; omega", "vc-helpers": "", "vc-definitions": "def count_ones_in_binary (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_ones_nonnegative_basic {x : Nat} (h : x ≥ 0) :\n  count_ones_in_binary x ≥ 0 :=\n  sorry\n\ntheorem count_ones_negative_has_ones {x : Nat} (h : x < 0) :\n  count_ones_in_binary x > 0 :=\n  sorry\n\ntheorem count_ones_power_of_two {x : Nat} (h1 : x > 0) (h2 : x % 2 = 0) :\n  count_ones_in_binary x = 1 :=\n  sorry\n\ntheorem count_ones_equals_bit_count {x : Nat} (h : x ≥ 0) :\n  count_ones_in_binary x = count_bits x :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]"}
{"id": "fvapps_001360", "vc-description": "/-\nMotu and Patlu are racing against each other on a circular track of radius $R$. Initially they are at the same point on the track and will run in same direction .The coach ordered them to run $X$ rounds of the circular field. Patlu wants to know how many times they will meet after the race starts and  before any of them finishes $X$ rounds. But he is busy in warm up so he wants you to calculate this. You are given speed of both Motu and Patlu ($A$ and $B$). \n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, four integers $X, R, A, B$. \n\n-----Output:-----\nFor each testcase, output in a single line answer the number of times whey will meet before any of them completes $X$ rounds.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq R \\leq 10^9$\n- $1 \\leq X \\leq 10^9$\n- $1 \\leq A \\leq 10^9$\n- $1 \\leq B \\leq 10^9$\n- Speed of both are different\n\n-----Sample Input:-----\n2\n3 10 2 5\n2 20 5 10\n\n-----Sample Output:-----\n1\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_race_encounters (x : Int) (r speed1 speed2 : Float) : Int :=\n  sorry\n\ndef abs (x : Float) : Float :=\n  sorry", "vc-theorems": "theorem race_encounters_non_negative\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 ≥ -1 :=\nsorry\n\ntheorem race_encounters_less_than_laps\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 < x :=\nsorry\n\ntheorem race_encounters_speed_symmetry\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r speed2 speed1 :=\nsorry\n\ntheorem race_encounters_speed_scaling\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r (2 * speed1) (2 * speed2) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 3 10 2 5\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_race_encounters 2 20 5 10\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 4 15 3 6"}
{"id": "fvapps_001361", "vc-description": "/-\nChef changed the password of his laptop a few days ago, but he can't remember it today. Luckily, he wrote the encrypted password on a piece of paper, along with the rules for decryption.\nThe encrypted password is a string S consists of ASCII printable characters except space (ASCII 33 - 126, in decimal notation, the same below). Read here for more details: ASCII printable characters.\nEach rule contains a pair of characters ci, pi, denoting that every character ci appears in the encrypted password should be replaced with pi. Notice that it is not allowed to do multiple replacements on a single position, see example case 1 for clarification.\nAfter all the character replacements, the string is guaranteed to be a positive decimal number. The shortest notation of this number is the real password. To get the shortest notation, we should delete all the unnecessary leading and trailing zeros. If the number contains only non-zero fractional part, the integral part should be omitted (the shortest notation of \"0.5\" is \".5\"). If the number contains zero fractional part, the decimal point should be omitted as well (the shortest notation of \"5.00\" is \"5\").\nPlease help Chef to find the real password.\n\n-----Input-----\nThe first line of the input contains an interger T denoting the number of test cases.\nThe description of T test cases follows.\nThe first line of each test case contains a single interger N, denoting the number of rules.\nEach of the next N lines contains two space-separated characters ci and pi,\ndenoting a rule.\nThe next line contains a string S, denoting the encrypted password.\n\n-----Output-----\nFor each test case, output a single line containing the real password.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 0 ≤ N ≤ 94\n- All characters in S and ci may be any ASCII printable character except space. (ASCII 33 - 126)\n- All ci in a single test case are distinct.\n- pi is a digit (\"0\" - \"9\") or a decimal point \".\" (ASCII 46).\n- The total length of S in a single input file will not exceed 106.\n\n-----Example-----\nInput:\n4\n2\n5 3\n3 1\n5\n0\n01800.00\n0\n0.00100\n3\nx 0\nd 3\n# .\n0xd21#dd098x\n\nOutput:\n3\n1800\n.001\n321.33098\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def decryptPassword (rules : List (Char × Char)) (encrypted : String) : String :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry\n\ndef replaceChar (s : String) (oldChar newChar : Char) : String :=\n  sorry", "vc-theorems": "theorem zero_rules_preserve_number {num : Nat} (h : num ≤ 1000000) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  stringToNat decrypted = num\n  :=\nsorry\n\ntheorem zero_rules_no_leading_zeros {num : Nat} (h : num ≤ 1000000) (h2 : num ≠ 0) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  ¬(decrypted.get 0 = '0')\n  :=\nsorry\n\ntheorem zero_rules_single_zero :\n  decryptPassword [] \"0\" = \"0\"\n  :=\nsorry\n\ntheorem simple_substitutions_preserve_number\n  {rules : List (Char × Char)}\n  {num : Nat}\n  (h1 : num ≤ 1000000)\n  (h2 : ∀ r1 r2, r1 ∈ rules → r2 ∈ rules → r1.1 = r2.1 → r1 = r2)\n  (h3 : ∀ r, r ∈ rules → r.1 ∈ \"abcdefghijklmnopqrstuvwxyz\".data)\n  (h4 : ∀ r, r ∈ rules → r.2 ∈ \"0123456789\".data)\n  (h5 : rules.length ≤ 5) :\n  let numStr := toString num\n  let encrypted := rules.foldl (fun acc r => replaceChar acc r.2 r.1) numStr\n  let decrypted := decryptPassword rules encrypted\n  stringToNat decrypted = num\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '3'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"5\", \"3\"), (\"3\", \"1\")] \"5\"\n\n/--\ninfo: '1800'\n-/\n#guard_msgs in\n#eval decrypt_password [] \"01800.00\"\n\n/--\ninfo: '321.33098'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"x\", \"0\"), (\"d\", \"3\"), (\"#\", \".\")] \"0xd21#dd098x\""}
{"id": "fvapps_001363", "vc-description": "/-\nThe auditorium of Stanford University is made up of L*R matrix (assume each coordinate has a chair). On the occasion of an event Chef was called as a chief guest. The auditorium was filled with males (M) and females (F), occupying one chair each. Our Chef is very curious guy, so he asks the gatekeeper some queries. The queries were as follows: Is there any K*K sub-matrix in the auditorium which contains all Males or Females.\n\n-----Input-----\n- The first line contains three space-separated integers L, R  and Q describing the dimension of the auditorium and the number of questions Chef will ask.\n- Each of next L lines contains R characters (M or F).\n- Next Q lines contains K and a character (M or F).\n\n-----Output-----\n- For each query output \"yes\" (without quotes) if there exist any K*K sub-matrix in the auditorium which contains all Males (if he asks about Male) or Females (if he asks about Female), otherwise output \"no\" (without quotes).\n\n-----Constraints and Subtasks-----\n- 1 <= L, R, K <= 1000\n- 1 <= Q <= 1e6\nSubtask 1: 30 points\n- 1 <= L, R, Q <= 200\nSubtask 2: 70 points\n- Original Contraints\n\n-----Example-----\nInput:\n4 3 3\nMMF\nMMM\nFFM\nFFM\n2 F\n3 M\n1 M\n\nOutput:\nyes\nno\nyes\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Matrix := List String\n\ndef Query := Nat × Char", "vc-helpers": "", "vc-definitions": "def Result := String\n\ndef check_matrix_exists (L R : Nat) (matrix : Matrix) (queries : List Query) : List Result :=\n  sorry\n\ndef all_same_matrix (c : Char) (L R : Nat) : Matrix :=\n  sorry", "vc-theorems": "theorem check_matrix_exists_results_match_queries\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  List.length results = List.length queries :=\nsorry\n\ntheorem check_matrix_exists_valid_results\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  ∀ r ∈ results, r = \"yes\" ∨ r = \"no\" :=\nsorry\n\ntheorem check_matrix_exists_size_constraint\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  ∀ (q : Query) (r : Result),\n    (q, r) ∈ List.zip queries results →\n    q.1 > min L R → r = \"no\" :=\nsorry\n\ntheorem check_matrix_exists_all_same_char\n  (matrix : Matrix) (queries : List Query) (L R : Nat) (c : Char) :\n  let all_same := all_same_matrix c L R\n  let results := check_matrix_exists L R all_same queries\n  ∀ (q : Query) (r : Result),\n    (q, r) ∈ List.zip queries results →\n    (q.2 = c → r = \"yes\" ↔ q.1 ≤ min L R) ∧\n    (q.2 ≠ c → r = \"no\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001364", "vc-description": "/-\nGiven a string s. Can you make it a palindrome by deleting exactly one character? Note that size of the string after deletion would be one less than it was before. \n\n-----Input-----\nFirst line of the input contains a single integer T denoting number of test cases.\nFor each test case, you are given a single line containing string  s. \n\n-----Output-----\nFor each test case, print YES or NO depending on the answer of the problem. \n\n-----Constraints-----\nSubtask 1, 35 points \n-  1 ≤ T ≤ 100\n- 2 ≤  size of string s ≤ 1000\n-  String s contains lowercase English alphabets (ie. from 'a' to 'z').\n\nSubtask 2, 65 points \n- 2 ≤  size of string s ≤ 10^5\n-  Sum of size of string s over all the input test cases won't exceed 10^6\n-  String s contains lowercase English alphabets (ie. from 'a' to 'z').\n\n-----Example-----\nInput:\n4\naaa\nabc\nabdbca\nabba\n\nOutput:\nYES\nNO\nYES\nYES\n\n-----Explanation-----\nExample case 1. Delete any one 'a', resulting string is \"aa\" which is a palindrome.\nExample case 2. It is not possible to delete exactly one character and having a palindrome.\nExample case 3. Delete 'c', resulting string is \"abdba\" which is a palindrome. \nExample case 4. Delete 'b', resulting string is \"aba\" which is a palindrome.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_make_palindrome (s : String) : Bool :=\nsorry\n\ndef process_test_case (s : String) : String :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem palindrome_stays_true {s : String} :\n  s = reverse s → can_make_palindrome s = true :=\nsorry\n\ntheorem single_char_is_palindrome {s : String} :\n  s.length = 1 → can_make_palindrome s = true :=\nsorry\n\ntheorem reverse_preserves_palindrome {s : String} :\n  can_make_palindrome s = can_make_palindrome (reverse s) :=\nsorry\n\ntheorem process_returns_yes_no {s : String}\n  (h : s.length > 0) :\n  process_test_case s = \"YES\" ∨ process_test_case s = \"NO\" :=\nsorry\n\ntheorem process_matches_can_make {s : String} :\n  (process_test_case s = \"YES\") = can_make_palindrome s :=\nsorry\n\ntheorem basic_palindrome_cases :\n  can_make_palindrome \"a\" ∧\n  can_make_palindrome \"aa\" ∧\n  can_make_palindrome \"aba\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"aaa\"\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval process_test_case \"abc\"\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"abdbca\""}
{"id": "fvapps_001368", "vc-description": "/-\nMr. Wilson was planning to record his new Progressive Rock music album called \"Digits. Cannot. Separate\". Xenny and PowerShell, popular pseudo-number-theoreticists from the Land of Lazarus were called by him to devise a strategy to ensure the success of this new album. Xenny and Powershell took their Piano Lessons and arrived at the Studio in different Trains.\nMr. Wilson, creative as usual, had created one single, long music track S. The track consisted of N musical notes. The beauty of each musical note was represented by a decimal digit from 0 to 9.\nMr. Wilson told them that he wanted to create multiple musical tracks out of this long song. Since Xenny and Powershell were more into the number theory part of music, they didn’t know much about their real workings. Mr. Wilson told them that a separator could be placed between 2 digits. After placing separators, the digits between 2 separators would be the constituents of this new track and the number formed by joining them together would represent the Quality Value of that track. He also wanted them to make sure that no number formed had greater than M digits.\nMr. Wilson had Y separators with him. He wanted Xenny and PowerShell to use at least X of those separators, otherwise he would have to ask them to Drive Home.\nXenny and PowerShell knew straight away that they had to put place separators in such a way that the Greatest Common Divisor (GCD) of all the Quality Values would eventually determine the success of this new album. Hence, they had to find a strategy to maximize the GCD.\nIf you find the maximum GCD of all Quality Values that can be obtained after placing the separators, Xenny and PowerShell shall present you with a Porcupine Tree.\nNote:\n- \nYou can read about GCD here.\n\n- \nGreatest Common Divisor of 0 and 0 is defined as 0.\n\n-----Input-----\nThe first line of input consists of a single integer T - the number of testcases.\nEach test case is of the following format:\nFirst line contains a single integer N - the length of the long musical track.\nSecond line contains the string of digits S.\nThird line contains 3 space-separated integers - M, X and Y - the maximum number of digits in a number, the minimum number of separators to be used and the maximum number of separators to be used.\n\n-----Output-----\nFor each testcase, output a single integer on a new line - the maximum GCD possible after placing the separators.\n\n-----Constraints-----\nSubtask 1: 20 points\n\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 18\n- 1 ≤ M ≤ 2\n- 1 ≤ X ≤ Y ≤ (N - 1)\n\nSubtask 2: 80 points\n\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 300\n- 1 ≤ M ≤ 10\n- 1 ≤ X ≤ Y ≤ (N - 1)\n\nFor both Subtask 1 and Subtask 2:\n\n- 1 ≤ X ≤ Y ≤ (N - 1)\n- M*(Y+1) ≥ N\n- S may contain leading 0s.\n\n-----Example-----Input:\n2\n3\n474\n2 1 1\n34\n6311861109697810998905373107116111\n10 4 25\n\nOutput:\n2\n1\n\n-----Explanation-----\nTest case 1. \nSince only 1 separator can be placed, we can only have 2 possibilities:\n\na. 4 | 74\n\nThe GCD in this case is 2.\n\nb. 47 | 4\n\nThe GCD in this case is 1.\n\nHence, the maximum GCD is 2.\nTest case 2.\n\nOne of the optimal partitions is:\n63|118|61|109|69|78|109|98|90|53|73|107|116|111\nBonus: Decode the above partition to unlock a hidden treasure.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n-- max of all valid partition numbers\n\n-- equal to integer value of s or 0", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef solve_max_gcd (s : String) (m x y : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_properties (a b : Int) (h : b ≠ 0) :\n  let g := gcd a.natAbs b.natAbs\n  g > 0 ∧ a.natAbs % g = 0 ∧ b.natAbs % g = 0 :=\nsorry\n\ntheorem solve_max_gcd_basic_properties\n  (s : String) (m x y : Nat)\n  (h1 : s.length > 0)\n  (h2 : s.length ≤ 10)\n  (h3 : m ≤ 5)\n  (h4 : m > 0)\n  (h5 : x ≤ 3)\n  (h6 : y ≤ 3)\n  (h7 : x ≤ y) :\n  let result := solve_max_gcd s m x y\n  result ≥ 0 ∧\n  result ≤ (sorry)\n  :=\nsorry\n\ntheorem solve_max_gcd_partition_bounds\n  (s : String)\n  (h1 : s.length > 0)\n  (h2 : s.length ≤ 5) :\n  let m := s.length\n  let full_partition := solve_max_gcd s m 0 m\n  let single_partition := solve_max_gcd s m 0 0\n  full_partition ≥ 0 ∧\n  (single_partition = sorry ∨ single_partition = 0)\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001371", "vc-description": "/-\nThe Little Elephant from the Zoo of Lviv currently is on the military mission. There are N enemy buildings placed in a row and numbered from left to right strating from 0. Each building i (except the first and the last) has exactly two adjacent buildings with indices i-1 and i+1. The first and the last buildings have just a single adjacent building.\n\nSome of the buildings contain bombs. When bomb explodes in some building it destroys it and all adjacent to it buildings.\n\nYou are given the string S of length N, where Si is 1 if the i-th building contains bomb, 0 otherwise. Find for the Little Elephant the number of buildings that will not be destroyed after all bombs explode. Please note that all bombs explode simultaneously.\n\n-----Input-----\nThe first line contains single integer T - the number of test cases. T test cases follow. The first line of each test case contains the single integer N - the number of buildings. The next line contains the string S of length N consisted only of digits 0 and 1.\n\n-----Output-----\nIn T lines print T inetgers - the answers for the corresponding test cases.\n\n-----Constraints-----\n\n1 <= T <= 100\n\n1 <= N <= 1000\n\n-----Example-----\nInput:\n3\n3\n010\n5\n10001\n7\n0000000\n\nOutput:\n0\n1\n7\n-/\n\n-- Function signature we're reasoning about\n\n-- Properties from hypothesis test\n\n-- Helper definition for checking if building at index i is safe\n\n-- Edge cases", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.replicate (s : String) (n : Nat) : String :=\nsorry\n\ndef count_safe_buildings (s : String) : Nat :=\nsorry\n\ndef isSafeBuilding (s : String) (i : Nat) : Bool :=\nsorry", "vc-theorems": "theorem count_safe_buildings_equals_safe_spots (s : String) :\n  count_safe_buildings s =\n    (List.range s.length).foldl (fun acc i =>\n      if isSafeBuilding s i then acc + 1 else acc) 0 :=\nsorry\n\ntheorem count_safe_buildings_nonnegative (s : String) :\n  count_safe_buildings s ≥ 0 :=\nsorry\n\ntheorem count_safe_buildings_bounded (s : String) :\n  count_safe_buildings s ≤ s.length :=\nsorry\n\ntheorem all_zeros_returns_length (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"0\" n) = n :=\nsorry\n\ntheorem all_ones_returns_zero (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"1\" n) = 0 :=\nsorry\n\ntheorem empty_string_returns_zero :\n  count_safe_buildings \"\" = 0 :=\nsorry\n\ntheorem single_zero_returns_one :\n  count_safe_buildings \"0\" = 1 :=\nsorry\n\ntheorem single_one_returns_zero :\n  count_safe_buildings \"1\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_safe_buildings \"010\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_safe_buildings \"10001\"\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval count_safe_buildings \"0000000\""}
{"id": "fvapps_001378", "vc-description": "/-\nMonisha likes to paint. She has painted $N$ paintings (numbered $1$ through $N$) and wants to choose some subset of these paintings for an exhibition. For each valid $i$, the $i$-th painting has beauty $b_i$ and the probability that it will be displayed at the exhibition is $p_i$. Each painting is chosen or excluded from the exhibition independently randomly.\nThe beauty of the resulting exhibition is the bitwise XOR of the beauties of all displayed paintings. If no paintings are displayed, the XOR is $0$.\nMonisha wants to find out how beautiful her exhibition is going to be. Help her compute the expected value of the beauty of the exhibition.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $b_1, b_2, \\ldots, b_N$.\n- The third line contains $N$ space-separated real numbers $p_1, p_2, \\ldots, p_N$. Each of these numbers is given with at most five digits after the decimal point.\n\n-----Output-----\nFor each test case, print a single line containing one real number — the expected beauty of the exhibition. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n\n-----Constraints-----\n- $1 \\le N \\le 10^5$\n- $0 \\le b_i \\le 10^9$ for each valid $i$\n- $0 \\le p_i \\le 1$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $4 \\cdot 10^5$\n\n-----Example Input-----\n2\n3\n5 6 2\n1.0 0.0 0.5\n4\n2 2 2 2\n0.5 0.5 0.5 0.5\n\n-----Example Output-----\n6.000000000000000\n1.000000000000000\n\n-----Explanation-----\nExample case 1: The first painting must be displayed at the exhibition, the second one must be excluded. If the third painting is displayed (with probability $0.5$), the beauty is $5 \\oplus 2 = 7$; if it is excluded (with probability $0.5$), the beauty is $5$. The expected beauty is $0.5 \\cdot 5 + 0.5 \\cdot 7 = 6$.\nExample case 2: If there is an odd number of paintings at the exhibition, the beauty is $2$; this has a probability of $0.5$. If there is an even number of paintings, the beauty is $0$ (with probability $0.5$), so the expected beauty is $0.5 \\cdot 0 + 0.5 \\cdot 2 = 1$.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def maxList (l : List Nat) : Float :=\n  Float.ofNat (l.foldl max 0)\n\ndef listXor (l : List Nat) : Float :=\n  Float.ofNat (l.foldl Nat.xor 0)", "vc-helpers": "", "vc-definitions": "def calculate_expected_beauty (n : Nat) (beauties : List Nat) (probs : List Float) : Float :=\n  sorry", "vc-theorems": "theorem expected_beauty_bounds {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (h3 : ∀ p ∈ probs, 0 ≤ p ∧ p ≤ 1)\n    (h4 : beauties.length > 0)\n    : 0 ≤ calculate_expected_beauty n beauties probs ∧\n      calculate_expected_beauty n beauties probs ≤ maxList beauties :=\nsorry\n\ntheorem probabilities_zero_one {n : Nat} {beauties : List Nat}\n    (h1 : beauties.length = n)\n    : calculate_expected_beauty n beauties (List.replicate n 0) = 0 ∧\n      calculate_expected_beauty n beauties (List.replicate n 1) =\n        listXor beauties :=\nsorry\n\ntheorem symmetry {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (σ : List.Perm beauties (beauties.take n))\n    (τ : List.Perm probs (probs.take n))\n    : calculate_expected_beauty n beauties probs =\n      calculate_expected_beauty n (beauties.take n) (probs.take n) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001384", "vc-description": "/-\nIndraneel's student has given him data from two sets of experiments that the student has performed. Indraneel wants to establish a correlation between the two sets of data. Each data set is a sequence of $N$ numbers. The two data sets do not match number for number, but Indraneel believes that this is because data has been shifted due to inexact tuning of the equipment.\nFor example, consider the following two sequences:\n$ $\n3  8   4  23  9  11  28\n2  3  22  26  8  16  12\n\n$ $\nIndraneel observes that if we consider the subsequences $3,4,23,9$ and $2,3,22,8$ and examine their successive differences we get $1,19,-14$. He considers these two subsequences to be \"identical\". He would like to find the longest such pair of subsequences so that the successive differences are identical. Your task is to help him do this.\n\n-----Input:-----\nThe first line of the input will contain a single integer $N$ indicating the number of data points in each of Indraneel's student's data sets. This is followed by two lines, each containing $N$ integers.\n\n-----Output:-----\nThe output consists of three lines. The first line of output contains a single integer indicating the length of the longest pair of subsequences (one from each sequence) that has identical successive differences. This is followed by two lines each containing the corresponding subsequences. If there is more than one answer, it suffices to print one.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 150$.\n- $0 \\leq$ Each data point $\\leq 1000$\n\n-----Sample Input-----\n7\n3 8 4 23 9 11 28  \n2 3 22 26 8 16 12 \n\n-----Sample Output-----\n4\n3 4 23 9\n2 3 22 8\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def Point := Int × Int\n\ndef Rectangle := List Point", "vc-helpers": "", "vc-definitions": "def calculate_rectangle_characteristics (points : Rectangle) : Float × Float × Float × Float × Float :=\n  sorry", "vc-theorems": "def length (points : Rectangle) : Float :=\n  let (l, _, _, _, _) := calculate_rectangle_characteristics points\n  l\n\ndef width (points : Rectangle) : Float :=\n  let (_, w, _, _, _) := calculate_rectangle_characteristics points\n  w\n\ndef area (points : Rectangle) : Float :=\n  let (_, _, a, _, _) := calculate_rectangle_characteristics points\n  a\n\ndef perimeter (points : Rectangle) : Float :=\n  let (_, _, _, p, _) := calculate_rectangle_characteristics points\n  p\n\ndef diagonal (points : Rectangle) : Float :=\n  let (_, _, _, _, d) := calculate_rectangle_characteristics points\n  d\n\ntheorem length_positive (points : Rectangle) :\n  length points > 0 :=\nsorry\n\ntheorem width_positive (points : Rectangle) :\n  width points > 0 :=\nsorry\n\ntheorem area_is_length_times_width (points : Rectangle) :\n  area points = length points * width points :=\nsorry\n\ntheorem perimeter_formula (points : Rectangle) :\n  perimeter points = 2 * (length points + width points) :=\nsorry\n\ntheorem diagonal_formula (points : Rectangle) :\n  diagonal points = Float.sqrt (length points * length points + width points * width points) :=\nsorry\n\ntheorem diagonal_larger_than_sides (points : Rectangle) :\n  diagonal points > length points ∧ diagonal points > width points :=\nsorry\n\ntheorem measurements_match_points (points : Rectangle) (h : points.length = 4) :\n  ∃ x1 x2 y1 y2 : Int,\n    (x2 > x1 ∧ y2 > y1) ∧\n    points = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)] ∧\n    length points = Float.ofInt (x2 - x1) ∧\n    width points = Float.ofInt (y2 - y1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001385", "vc-description": "/-\nHarrenhal is the largest castle in the Seven Kingdoms and is the seat of House Whent in the Riverlands, on the north shore of the Gods Eye lake. Since the War of Conquest, however, it has become a dark and ruinous place.\n(c) A Wiki of Ice and Fire\n\nNow Harrenhal is too dangerous since it's a nice place for bandits to hide, or even for rebels to start planning overthrowing of the king. So, the current Lord of the Seven Kingdoms has decided, that it's time to completely ruin the castle. For that puposes, he's planning to send some military troops.\nIn this problem we assume, that Harrenhal can be described as a string H, which consists only of symbols 'a' and 'b'. Harrenhal is completely ruined if and only if the length of H is equal to zero.\nSo, how to make H empty? Send a military troop! When a military troop of the king reach the castle, they delete some palindromic subsequence S of H. For example, let H = 'abbabaab'. Then the current military troop can choose S = 'ababa'(Let's make symbols of S bold in H: 'abbabaab'). After deleting S, H will be equal to 'bab'. Military troops are free to choose any possible palindromic subsequence of H.\nYour task is pretty simple: determine the minimal number of military troops, that the Lord of the Seven Kingdoms has to send in order to ruin Harrenhal.\n\n-----Note-----\n\nMaybe, some of you aren't familiar with definitions from the statement. Here're some articles that could help you to understand the problem correctly:\n\n- Subsequence: http://en.wikipedia.org/wiki/Subsequence\n- Palindrome: http://en.wikipedia.org/wiki/Palindrome\n\n-----Input-----\nThe first line of the input contains an integer T, denoting the number of test cases.\nThe next T lines contain a string H each, denoting the string, that describes the current state of Harrenhal for the corresponding test cases.\nIt's guaranteed, that each H consists only of symbols 'a' and 'b'.\n\n-----Output-----\nThe output should contain exactly T lines. i'th line of the output should contain the only integer: the minimal number of military troops, that the Lord of the Seven Kingdoms has to send in order to ruin Harrenhal for the corresponding test cases.\n\n-----Constraints-----\n- 1 ≤ |H| ≤ 100000, for each H.\n- Subtask 1(30 points): each H in the input is a palindrome, 1 ≤ T ≤ 6;\n- Subtask 2(70 points): 1 ≤ T ≤ 9.\n\n-----Example-----\nInput:\n1\nabbabaab\n\nOutput:\n2\n\n-----Explanation-----\nThere're multiple ways to ruin Harrenhal in the example test. Let's consider one of them.\nThe first troop can delete S = 'ababa'('abbabaab'). After that, H = 'bab'.\nThe second troop can delete S = 'bab'('bab'). After that, H is empty and that's it.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_troops_to_ruin (s: String) : Nat :=\nsorry\n\ndef isPalindrome (s: String) : Bool :=\nsorry", "vc-theorems": "theorem min_troops_bounds (s: String) :\n  let result := find_min_troops_to_ruin s\n  0 ≤ result ∧ result ≤ 2 :=\nsorry\n\ntheorem empty_string_troops (s: String) :\n  s = \"\" → find_min_troops_to_ruin s = 0 :=\nsorry\n\ntheorem palindrome_troops (s: String) :\n  s ≠ \"\" ∧ isPalindrome s → find_min_troops_to_ruin s = 1 :=\nsorry\n\ntheorem non_palindrome_troops (s: String) :\n  s ≠ \"\" ∧ ¬isPalindrome s → find_min_troops_to_ruin s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abbabaab\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abba\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"ab\""}
{"id": "fvapps_001402", "vc-description": "/-\nChef has a sequence $A_1, A_2, \\ldots, A_N$; each element of this sequence is either $0$ or $1$. Appy gave him a string $S$ with length $Q$ describing a sequence of queries. There are two types of queries:\n- '!': right-shift the sequence $A$, i.e. replace $A$ by another sequence $B_1, B_2, \\ldots, B_N$ satisfying $B_{i+1} = A_i$ for each valid $i$ and $B_1 = A_N$\n- '?': find the length of the longest contiguous subsequence of $A$ with length $\\le K$ such that each element of this subsequence is equal to $1$\nAnswer all queries of the second type.\n\n-----Input-----\n- The first line of the input contains three space-separated integers $N$, $Q$ and $K$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n- The third line contains a string with length $Q$ describing queries. Each character of this string is either '?', denoting a query of the second type, or '!', denoting a query of the first type.\n\n-----Output-----\nFor each query of the second type, print a single line containing one integer — the length of the longest required subsequence.\n\n-----Constraints-----\n- $1 \\le K \\le N \\le 10^5$\n- $1 \\le Q \\le 3 \\cdot 10^5$\n- $0 \\le A_i \\le 1$ for each valid $i$\n- $S$ contains only characters '?' and '!'\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- $1 \\le N \\le 10^3$\n- $1 \\le Q \\le 3 \\cdot 10^3$\nSubtask #2 (70 points): original constraints \n\n-----Example Input-----\n5 5 3\n1 1 0 1 1\n?!?!?    \n\n-----Example Output-----\n2\n3\n3\n\n-----Explanation-----\n- In the first query, there are two longest contiguous subsequences containing only $1$-s: $A_1, A_2$ and $A_4, A_5$. Each has length $2$.\n- After the second query, the sequence $A$ is $[1, 1, 1, 0, 1]$.\n- In the third query, the longest contiguous subsequence containing only $1$-s is $A_1, A_2, A_3$.\n- After the fourth query, $A = [1, 1, 1, 1, 0]$.\n- In the fifth query, the longest contiguous subsequence containing only $1$-s is $A_1, A_2, A_3, A_4$ with length $4$. However, we only want subsequences with lengths $\\le K$. One of the longest such subsequences is $A_2, A_3, A_4$, with length $3$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest_contiguous_subsequence (N Q K : Nat) (A : List Nat) (S : String) : List Nat :=\nsorry\n\ndef count_max_consecutive_ones (A : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_length_matches_question_marks {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  (longest_contiguous_subsequence N Q K A S).length =\n    (S.data.filter (. = '?')).length :=\nsorry\n\ntheorem results_bounded_by_k {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x ≤ K :=\nsorry\n\ntheorem results_non_negative {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x ≤ 1) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x ≥ 0 :=\nsorry\n\ntheorem zero_array_gives_zero_result {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : ∀ x ∈ A, x = 0) :\n  ∀ x ∈ (longest_contiguous_subsequence N Q K A S), x = 0 :=\nsorry\n\ntheorem single_question_mark_result {N K : Nat} {A : List Nat}\n  (h1 : N > 0) (h2 : K > 0)\n  (h3 : ∀ x ∈ A, x ≤ 1)\n  (h4 : (longest_contiguous_subsequence N 1 K A \"?\").length > 0) :\n  (longest_contiguous_subsequence N 1 K A \"?\")[0]! = min (count_max_consecutive_ones A) K :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [2, 3, 3]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 5 5 3 [1, 1, 0, 1, 1] \"?!?!?\"\n\n/--\ninfo: [1, 1, 1]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 3 3 2 [1, 0, 1] \"???\"\n\n/--\ninfo: [4, 4]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 4 2 4 [1, 1, 1, 1] \"??\""}
{"id": "fvapps_001413", "vc-description": "/-\nYou visit a doctor on a date given in the format $yyyy:mm:dd$. Your doctor suggests you to take pills every alternate day starting from that day. You being a forgetful person are pretty sure won’t be able to remember the last day you took the medicine and would end up in taking  the medicines on wrong days. \nSo you come up with the idea of taking medicine on the dates whose day is odd or even depending on whether $dd$ is odd or even. Calculate the number of pills you took on right time before messing up for the first time.\n\n-----Note:-----\nEvery year that is exactly divisible by four is a leap year, except for years that are exactly divisible by 100; the centurial years that are exactly divisible by 400 are still leap years. For example, the year 1900 is not a leap year; the year 2000 is a leap year.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, in the format $yyyy:mm:dd$\n\n-----Output:-----\nFor each testcase, output in a single line the required answer.\n\n-----Constraints-----\n- $ 1 \\leq T \\leq 1000 $\n- $ 1900 \\leq yyyy \\leq 2038 $\n- $yyyy:mm:dd$ is a valid date\n\n-----Sample Input:-----\n1\n2019:03:31\n\n-----Sample Output:-----\n1\n\n-----EXPLANATION:-----\nYou can take pill on the right day only on 31st March. Next you will take it on 1st April which is not on the alternate day.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLeapYear (year : Int) : Bool :=\n  sorry\n\ndef isValidDate (year month day : Int) : Bool :=\n  sorry\n\ndef countCorrectPills (dateStr : String) : Int :=\n  sorry", "vc-theorems": "theorem valid_date_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  1 ≤ month ∧ month ≤ 12 →\n  1 ≤ day ∧ day ≤ 31 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry\n\ntheorem leap_year_feb29_count (year : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  isLeapYear year →\n  let result := countCorrectPills s!\"{year}:02:29\"\n  result ≥ 1 :=\nsorry\n\ntheorem thirty_day_months_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  (month = 4 ∨ month = 6 ∨ month = 9 ∨ month = 11) →\n  1 ≤ day ∧ day ≤ 30 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry\n\ntheorem thirtyone_day_months_count (year month day : Int) :\n  1 ≤ year ∧ year ≤ 9999 →\n  (month = 1 ∨ month = 3 ∨ month = 5 ∨ month = 7 ∨ month = 8 ∨ month = 10 ∨ month = 12) →\n  1 ≤ day ∧ day ≤ 31 →\n  isValidDate year month day →\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2019:03:31\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2020:02:28\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2000:12:31\""}
{"id": "fvapps_001417", "vc-description": "/-\nMs. E.T. came from planet Hex. She has 8 fingers in each hand which makes her count in hexadecimal way. When she meets you, she tells you that she came from 7E light years from the planet Earth. You see she means that it is 126 light years far away and she is telling you the numbers in hexadecimal. Now, you are in trouble to understand what those numbers really mean. Therefore, you have to convert the hexadecimal numbers to decimals.\n\nInput:\n\nFirst line of code contain T test cases.\n\nevery line of text case contain a Hex-value \n\nOutput:\n\nEvery line of output contain a decimal conversion of given nunmber\n\nSample Input:\n\n3\n\nA\n\n1A23\n\n2C2A\n\nSample Output:\n\n10\n\n6691\n\n11306\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.toHexString (n: Nat) : String :=\n  sorry\n\ndef String.trimLeftZeros (s: String) : String :=\n  sorry\n\ndef hexToDecimal (l: List String) : List Nat :=\n  sorry", "vc-theorems": "theorem hex_to_decimal_length (l: List String) :\n  l.length = (hexToDecimal l).length := by\n  sorry\n\ntheorem hex_to_decimal_non_negative (l: List String) (i: Nat) (h: i < (hexToDecimal l).length) :\n  (hexToDecimal l).get ⟨i, h⟩ ≥ 0 := by\n  sorry\n\ntheorem hex_to_decimal_roundtrip (l: List String) :\n  let converted := hexToDecimal l\n  let back_to_hex := converted.map Nat.toHexString\n  let normalized := l.map String.trimLeftZeros\n  back_to_hex = normalized := by\n  sorry\n\ntheorem hex_to_decimal_increasing (l: List String) (i: Nat) (h₁: i < l.length) (h₂: i < (hexToDecimal l).length) :\n  let num := l.get ⟨i, h₁⟩\n  num.length > 1 →\n  (hexToDecimal l).get ⟨i, h₂⟩ > 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [10]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\"]\n\n/--\ninfo: [6691]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"1A23\"]\n\n/--\ninfo: [10, 6691, 11306]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\", \"1A23\", \"2C2A\"]"}
{"id": "fvapps_001419", "vc-description": "/-\nIn Chefland, there is a monthly robots competition. In the competition, a grid table of N rows and M columns will be used to place robots. A cell at row i and column j in the table is called cell (i, j). To join this competition, each player will bring two robots to compete and each robot will be placed at a cell in the grid table. Both robots will move at the same time from one cell to another until they meet at the same cell in the table. Of course they can not move outside the table. Each robot has a movable range. If a robot has movable range K, then in a single move, it can move from cell (x, y) to cell (i, j) provided (|i-x| + |j-y| <= K). However, there are some cells in the table that the robots can not stand at, and because of that, they can not move to these cells. The two robots with the minimum number of moves to be at the same cell will win the competition.\n\nChef plans to join the competition and has two robots with the movable range K1 and K2, respectively. Chef does not know which cells in the table will be used to placed his 2 robots, but he knows that there are 2 cells (1, 1) and (1, M) that robots always can stand at. Therefore, he assumes that the first robot is at cell (1, 1) and the other is at cell (1, M). Chef wants you to help him to find the minimum number of moves that his two robots needed to be at the same cell and promises to give you a gift if he wins the competition. \n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n-  The first line of each test case contains 4 space-separated integers N M K1 K2 denoting the number of rows and columns in the table and the movable ranges of the first and second robot of Chef.\n-  The next N lines, each line contains M space-separated numbers either 0 or 1 denoting whether the robots can move to this cell or not (0 means robots can move to this cell, 1 otherwise). It makes sure that values in cell (1, 1) and cell (1, M) are 0.\n\n-----Output-----\nFor each test case, output a single line containing the minimum number of moves that Chef’s 2 robots needed to be at the same cell. If they can not be at the same cell, print -1.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N, M ≤ 100\n- 0 ≤ K1, K2 ≤ 10\n\n----- Subtasks -----\nSubtask #1 : (25 points) \n-  K1 = K2 = 1 \n\nSubtask # 2 : (75 points) \nOriginal Constraints\n\n-----Example-----\nInput:\n2\n4 4 1 1\n0 1 1 0\n0 1 1 0\n0 1 1 0\n0 0 0 0\n4 4 1 1\n0 1 1 0\n0 1 1 0\n0 1 1 0\n1 0 0 1\n\nOutput:\n5\n-1\n\n-----Explanation-----\nExample case 1. Robot 1 can move (1, 1) -> (2, 1) -> (3, 1) -> (4, 1) -> (4, 2) -> (4, 3), and robot 2 can move (1, 4) -> (2, 4) -> (3, 4) -> (4, 4) -> (4, 3) -> (4, 3), they meet at cell (4, 3) after 5 moves.\nExample case 2. Because the movable range of both robots is 1, robot 1 can not move from (3, 1) to (4, 2), and robot 2 can not move from (3, 4) to (4, 3. Hence, they can not meet each other.\n-/\n\n/- Any valid result should be either -1 or non-negative -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Trivial 1x1 grid case should return 0 -/\n\n/- Any valid result should not exceed grid dimensions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_robots_meeting (n m k1 k2 : Nat) (grid : Array (Array Nat)) : Int :=\n  sorry", "vc-theorems": "theorem result_valid_range {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 ∨ result ≥ 0 := by\n  sorry\n\ntheorem trivial_case :\n  let grid := #[#[0]]\n  solve_robots_meeting 1 1 1 1 grid = 0 := by\n  sorry\n\ntheorem result_bounds {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 ∨ result ≤ n * m := by\n  sorry", "vc-postamble": "/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]"}
{"id": "fvapps_001422", "vc-description": "/-\nStuart is obsessed to numbers. He like all type of numbers in fact he is having a great collection of numbers in his room. His collection includes N different large numbers. But today he is searching for a number which is having maximum frequency of digit X. Numbers are large so he can’t do the task on his own. Help him to find a number having maximum frequency of digit X.\n\n-----Input-----\nFirst Line contains number of test cases T. First Line of each test case contains N. Next line contains N space separated integers A1,A2,A3,....,AN. Where Ai integer indicates ith number in Stuart's room. Next Line contains digit X.\n\n-----Output-----\nOutput the number which is having maximum frequency of digit X. If two or more numbers are having same maximum frequency then output the first occurred number among them in A1,A2,A3,....,AN\n\n-----Constraints-----\n- 1 ≤ T ≤ 30\n- 1 ≤ N ≤ 100\n- 1 ≤ Ai ≤ 10200\n- 0 ≤ X ≤ 9\n\n-----Example-----\nInput:\n2\n5\n345 1323 165 98 456\n3\n5\n335 876 98 1323 349\n3\n\nOutput:\n1323\n335\n\n-----Explanation-----\nExample case 1. 1323 number is having maximum occurrence of digit 3.\nExample case 2. 335 & 1323 are having maximum occurrence of digit 3 so output must be first occurred number in the array i.e. 335.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countDigit (n : Nat) (d : Nat) : Nat :=\nsorry\n\ndef find_max_digit_frequency (nums : List Nat) (target : Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_digit_freq_in_list (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) :\n  find_max_digit_frequency nums target ∈ nums :=\nsorry\n\ntheorem max_digit_freq_is_max (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) :\n  ∀ n ∈ nums, countDigit (find_max_digit_frequency nums target) target ≥\n              countDigit n target :=\nsorry\n\ntheorem no_target_returns_first (nums : List Nat) (target : Nat)\n  (h : nums ≠ [])\n  (h2 : ∀ n ∈ nums, countDigit n target = 0) :\n  find_max_digit_frequency nums target = nums.head! :=\nsorry\n\ntheorem same_freq_returns_first (nums : List Nat) (target : Nat)\n  (h : nums ≠ []) (n : Nat) (hn : n ∈ nums) :\n  countDigit n target = countDigit (find_max_digit_frequency nums target) target →\n  n = find_max_digit_frequency nums target ∨\n  nums.findIdx (. = n) > nums.findIdx (. = find_max_digit_frequency nums target) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '1323'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"345\", \"1323\", \"165\", \"98\", \"456\"] \"3\"\n\n/--\ninfo: '335'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"335\", \"876\", \"98\", \"1323\", \"349\"] \"3\""}
{"id": "fvapps_001423", "vc-description": "/-\nAbhiram needs to search for an antidote. He comes to know that clue for finding the antidote is carefully hidden by KrishnaMurthy in the form of a puzzle.\n\nThe puzzle consists of a string S and a keywordK. Abhiram needs to find the string of position of anagrams R of the keyword in the string which is the clue. \nThe antidote is found in the box numbered R. Help him find his clue R.\nAnagram: A word or phrase that is made by arranging the letters of another word or phrase in a different order. Eg: 'elvis' and 'lives' are both anagrams of each other.\nNote: Consider, Tac and act are not anagrams(case sensitive).\n\n-----Input:-----\nThe first line contains a string S of length land the second line contains a keyword K.\n\n-----Output:-----\n\nOutput contains a line\"The antidote is found in R.\" Where R= string of positions of anagrams.(the position of the first word in the string is 1).\n\n-----Constraints:-----\n1<=l<=500\n\n1<=k<=50\n\n-----Example:-----\nInput:\ncat is the act of tac\ncat\n\nOutput:\nThe antidote is found in 46.\n-/\n\n/- Helper function that converts a string to a sorted char array for anagram comparison -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def stringToSortedArray (s : String) : Array Char :=\n  (s.data.toArray).qsort (· ≤ ·)", "vc-helpers": "", "vc-definitions": "def find_anagram_positions (haystack : String) (needle : String) : String :=\n  sorry", "vc-theorems": "theorem output_format {s : String} :\n  let result := find_anagram_positions s \"test\"\n  result.startsWith \"The antidote is found in\" ∧\n  result.endsWith \".\" :=\nsorry\n\ntheorem identical_word_not_counted {word : String} :\n  word ≠ \"\" →\n  find_anagram_positions word word = \"The antidote is found in .\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001424", "vc-description": "/-\nChef has decided to retire and settle near a peaceful beach. He had always been interested in literature & linguistics. Now when he has leisure time, he plans to read a lot of novels and understand structure of languages. Today he has decided to learn a difficult language called Smeagolese. Smeagolese is an exotic  language whose alphabet is lowercase and uppercase roman letters. Also every word on this alphabet is a meaningful word in Smeagolese. Chef, we all know is a fierce learner - he has given himself a tough exercise. He has taken a word and wants to determine all possible anagrams of the word which mean something in Smeagolese.  Can you help him ?\n\n-----Input-----\nInput begins with a single integer T, denoting the number of test cases. After that T lines follow each containing a single string S - the word chef has chosen. You can assume that 1 <= T <= 500 and 1 <= |S| <= 500. You can also assume that no character repeats more than 10 times in the string. \n\n-----Output-----\nOutput one line per test case - the number of different words that are anagrams of the word that chef has chosen. As answer can get huge, print it modulo 10^9 + 7\n\n-----Example-----\nInput:\n4\nab\naa\naA\nAAbaz\n\nOutput:\n2\n1\n2\n60\nDescription:\nIn first case \"ab\" & \"ba\" are two different words. In third case, note that A & a are different alphabets and hence \"Aa\" & \"aA\" are different words.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_anagrams (s : String) : Nat :=\nsorry\n\ndef manual_count_anagrams (s : String) : Nat :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem count_anagrams_positive (s : String) (h : s.length > 0) :\n  count_anagrams s ≥ 0 ∧ count_anagrams s < 10^9 + 7 :=\nsorry\n\ntheorem count_anagrams_letter_order_invariant (s : String) (h : s.length > 0) :\n  count_anagrams s = count_anagrams s :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"ab\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_anagrams \"aa\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"aA\"\n\n/--\ninfo: 60\n-/\n#guard_msgs in\n#eval count_anagrams \"AAbaz\""}
{"id": "fvapps_001429", "vc-description": "/-\nA binary string is called a self-destructing string if it can reduced to an empty string by performing the following operation some number of times (possibly zero): Choose a valid integer $i$ such that the $i$-th character of the current string is different from the $i+1$-th character, and remove these two characters from the string.\nYou are given a binary string $s$. Your task is to convert $s$ to a self-destructing string. To do that, you may perform the following operation any number of times (possibly zero): Choose an integer $i$ ($1 \\le i \\le |s|-1$) such that the $i$-th character of $s$ is different from the $i+1$-th character, and invert one of these characters (inverting a character means changing '0' to '1' or '1' to '0', e.g. the string \"01\" can be changed to \"00\").\nFind the smallest number of operations required to convert $s$ to a self-destructing string or determine that it is impossible.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single string $s$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the smallest required number of operations or $-1$ if it is impossible to convert $s$ to a self-destructing string.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le |s| \\le 10^6$\n- $s$ contains only characters '0' and '1'\n- the sum of $|s|$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n3\n001101\n1101\n110\n\n-----Example Output-----\n0\n1\n-1\n\n-----Explanation-----\nExample case 1: We already have a self-destructing string because \"001101\" can be converted to \"0101\", to \"01\" and finally to an empty string.\nExample case 2: We can choose $i=3$ (since $s_3 \\neq s_4$) and then invert $s_4$ to obtain \"1100\", which is a self-destructing string.\nExample case 3: It can be shown that \"110\" cannot be converted to a self-destructing string.\n-/\n\n/- If the input string length is odd, min_ops_for_self_destruct returns -1 -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- If the input string contains only 0s or only 1s, min_ops_for_self_destruct returns -1 -/\n\n/- If min_ops_for_self_destruct returns a non-negative result, it is bounded by half the string length -/\n\n/- For balanced strings with equal counts of 0s and 1s and even length, min_ops_for_self_destruct returns 0 -/\n\n/- The result equals half the absolute difference between counts of 0s and 1s when not -1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_ops_for_self_destruct (s : String) : Int :=\n  sorry", "vc-theorems": "theorem odd_length_returns_negative (s : String) :\n  String.length s % 2 = 1 → min_ops_for_self_destruct s = -1 := by\n  sorry\n\ntheorem all_ones_or_zeroes_returns_negative (s : String) :\n  (∀c ∈ s.data, c = '0') ∨ (∀c ∈ s.data, c = '1') →\n  min_ops_for_self_destruct s = -1 := by\n  sorry\n\ntheorem result_bounds (s : String) :\n  min_ops_for_self_destruct s ≠ -1 →\n  0 ≤ min_ops_for_self_destruct s ∧ min_ops_for_self_destruct s ≤ String.length s / 2 := by\n  sorry\n\ntheorem balanced_strings_need_zero_ops (s : String) :\n  String.length s % 2 = 0 →\n  (s.data.filter (· = '0')).length = (s.data.filter (· = '1')).length →\n  min_ops_for_self_destruct s = 0 := by\n  sorry\n\ntheorem operations_count (s : String) :\n  min_ops_for_self_destruct s ≠ -1 →\n  min_ops_for_self_destruct s =\n    (Int.natAbs ((s.data.filter (· = '0')).length - (s.data.filter (· = '1')).length)) / 2 := by\n  sorry", "vc-postamble": "/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"001101\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"1101\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"110\""}
{"id": "fvapps_001437", "vc-description": "/-\n$Harshad$ $Mehta$ is planning  a new scam with the stocks he is given a stock of  integer price S and a number K . $harshad$ has got the power to change the number $S$ at most $K$ times\nIn order to raise the price of stock and now cash it for his benefits\nFind the largest price at which $harshad$ can sell the stock in order to maximize his profit \n\n-----Input:-----\n- First line will contain $S$ and  $K$ , the price of the stock and the number K \n\n-----Output:-----\nPrint the largest profit  he can make in a single line.\n\n-----Constraints-----\n- S can take value upto 10^18\nNOTE: use 64 int number to fit range\n- K can take value from [0.. 9]\n\n-----Sample Input:-----\n4483 2\n\n-----Sample Output:-----\n9983\n\n-----EXPLANATION:-----\nFirst two digits of the number are changed to get the required number.\n-/\n\n-- Result should be greater than or equal to input\n\n-- Result should have same number of digits as input\n\n-- Result changes should not exceed k\n\n-- k=0 means unchanged\n\n-- With enough k, all digits become 9", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numDigits (n : Nat) : Nat :=\n  sorry\n\ndef maximizeStockPrice (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maximize_stock_price_properties (n k : Nat) (h1 : n ≤ 999999) (h2 : k ≤ 10) :\n  let result := maximizeStockPrice n k;\n\n  result ≥ n\n\n  ∧ numDigits result = numDigits n\n\n  ∧ ∃ changes, changes ≤ k\n\n  ∧ (k = 0 → result = n) :=\nsorry\n\ntheorem maximize_stock_price_saturated (n k : Nat) (h1 : k ≥ numDigits n) :\n  let result := maximizeStockPrice n k;\n\n  result = n :=\nsorry\n\ntheorem maximize_stock_price_edge_cases :\n  maximizeStockPrice 0 0 = 0\n  ∧ maximizeStockPrice 1 1 = 9\n  ∧ maximizeStockPrice 9 1 = 9\n  ∧ maximizeStockPrice 99 1 = 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 9983\n-/\n#guard_msgs in\n#eval maximize_stock_price 4483 2\n\n/--\ninfo: 9234\n-/\n#guard_msgs in\n#eval maximize_stock_price 1234 1\n\n/--\ninfo: 9999\n-/\n#guard_msgs in\n#eval maximize_stock_price 9999 4"}
{"id": "fvapps_001440", "vc-description": "/-\nDevu is a disastrous oracle: his predictions about various events of your life are horrifying. Instead of providing good luck, he \"blesses\" you with bad luck. The secret behind his wickedness is a hidden omen which is a string of length m. On your visit to him, you can ask a lot of questions about your future, each of which should be a string of length m. In total you asked him n such questions, denoted by strings s1, s2, ... , sn of length m each. Each of the question strings is composed of the characters 'a' and 'b' only.\n\nAmount of bad luck this visit will bring you is equal to the length of longest common subsequence (LCS) of all the question strings and the hidden omen string. Of course, as the omen string is hidden, you are wondering what could be the least value of bad luck you can get.\n\nCan you find out what could be the least bad luck you can get? Find it fast, before Devu tells you any bad omens.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFirst line of each test case contains a single integer n denoting number of strings.\nFor each of next n lines, the ith line contains the string si.\n\n-----Output-----\nFor each test case, output a single integer corresponding to the answer of the problem. \n\n-----Constraints-----\n- All the strings (including the hidden omen) contain the characters 'a' and 'b' only.\n\nSubtask #1: (40 points) \n\n- 1 ≤ T, n, m ≤ 14\n\nSubtask #2: (60 points) \n\n- 1 ≤ T, n, m ≤ 100\n\n-----Example-----\nInput:3\n2\nab\nba\n2\naa\nbb\n3\naabb\nabab\nbaab\n\nOutput:1\n0\n2\n\n-----Explanation-----\nIn the first example, the minimum value of LCS of all the strings is 1, the string by oracle can be one of these {aa, ab, ba, bb}. \n\nIn the second example, whatever string oracle has does not matter, LCS will always be zero.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_bad_luck (strings : List String) : Nat :=\nsorry\n\ndef countChar (c : Char) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem find_min_bad_luck_non_negative (strings : List String) :\n  find_min_bad_luck strings ≥ 0 :=\nsorry\n\ntheorem find_min_bad_luck_leq_min_len (strings : List String) :\n  strings ≠ [] → find_min_bad_luck strings ≤ List.foldr (fun s acc => min s.length acc) (strings[0]!.length) strings.tail :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"ab\", \"ba\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aa\", \"bb\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aabb\", \"abab\", \"baab\"]"}
{"id": "fvapps_001443", "vc-description": "/-\nChef has a nice complete binary tree in his garden. Complete means that each node has exactly two sons, so the tree is infinite. Yesterday he had enumerated the nodes of the tree in such a way: \n- Let's call the nodes' level a number of nodes that occur on the way to this node from the root, including this node. This way, only the root has the level equal to 1, while only its two sons has the level equal to 2.\n- Then, let's take all the nodes with the odd level and enumerate them with consecutive odd numbers, starting from the smallest levels and the leftmost nodes, going to the rightmost nodes and the highest levels.\n- Then, let's take all the nodes with the even level and enumerate them with consecutive even numbers, starting from the smallest levels and the leftmost nodes, going to the rightmost nodes and the highest levels.\n- For the better understanding there is an example: \n1\n/           \\\n2                   4\n/   \\                /       \\\n3       5           7        9\n/ \\      /  \\          /  \\       /  \\\n6  8 10 12      14 16   18 20 \n\nHere you can see the visualization of the process. For example, in odd levels, the root was enumerated first, then, there were enumerated roots' left sons' sons and roots' right sons' sons.\nYou are given the string of symbols, let's call it S. Each symbol is either l or r. Naturally, this sequence denotes some path from the root, where l means going to the left son and r means going to the right son.\nPlease, help Chef to determine the number of the last node in this path.\n\n-----Input-----\nThe first line contains single integer T number of test cases.\nEach of next T lines contain a string S consisting only of the symbols l and r.\n\n-----Output-----\nPer each line output the number of the last node in the path, described by S, modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ |T| ≤ 5\n- 1 ≤ |S| ≤ 10^5\n- Remember that the tree is infinite, so each path described by appropriate S is a correct one.\n\n-----Example-----\nInput:\n4\nlrl\nrll\nr\nlllr\nOutput:\n10\n14\n4\n13\n\n-----Explanation-----\nSee the example in the statement for better understanding the samples.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_path_number : String → Nat :=\n  sorry\n\ndef MOD : Nat := 1000000007\n\ndef mkString (c : String) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem find_path_number_positive (s : String) :\n  find_path_number s > 0 := by\nsorry\n\ntheorem find_path_number_within_bounds (s : String) :\n  find_path_number s < MOD := by\nsorry\n\ntheorem find_path_number_empty :\n  find_path_number \"\" = 1 := by\nsorry\n\ntheorem find_path_number_single_char :\n  find_path_number \"l\" = 2 ∧ find_path_number \"r\" = 4 := by\nsorry\n\ntheorem find_path_number_concat_bounds (s : String) :\n  find_path_number (s ++ s) < MOD := by\nsorry\n\ntheorem find_path_number_lr_distinct (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  find_path_number (mkString \"l\" n) ≠\n  find_path_number (mkString \"r\" n) := by\nsorry\n\ntheorem find_path_number_modulo (s : String) :\n  find_path_number s = find_path_number s % MOD := by\nsorry\n\ntheorem find_path_number_concat_distinct (s1 s2 : String)\n  (h1 : s1 ≠ \"\") (h2 : s2 ≠ \"\") :\n  find_path_number (s1 ++ s2) ≠ find_path_number s1 ∧\n  find_path_number (s1 ++ s2) ≠ find_path_number s2 := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval find_path_number \"lrl\"\n\n/--\ninfo: 14\n-/\n#guard_msgs in\n#eval find_path_number \"rll\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_path_number \"r\""}
{"id": "fvapps_001450", "vc-description": "/-\nTo make Yalalovichik even more satisfied and happy, Jafar decided to invent Yalalovichik strings. A string is called a Yalalovichik string if the set of all of its distinct non-empty substrings is equal to the set of all of its distinct non-empty subsequences. \nYou are given a string S$S$. You need to find the number of its distinct non-empty substrings which are Yalalovichik strings.\nNote: A string A$A$ is called a subsequence of a string B$B$ if A$A$ can be formed by erasing some characters (possibly none) from B$B$. A string A$A$ is called a substring of a string B$B$ if it can be formed by erasing some characters (possibly none) from the beginning of B$B$ and some (possibly none) from the end of B$B$. Two substrings or subsequences are considered different if they are different strings.\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains a single integer N=|S|$N = |S|$.\n- The second line contains the string S$S$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the number of distinct Yalalovichik substrings of S$S$.\n\n-----Constraints-----\n- 1≤T≤100$1 \\le T \\le 100$\n- 1≤N≤106$1 \\le N \\le 10^6$\n- the sum of N$N$ over all test cases does not exceed 2⋅106$2 \\cdot 10^6$\n- S$S$ contains only lowercase English letters\n\n-----Example Input-----\n1\n3\nxxx\n\n-----Example Output-----\n3\n\n-----Explanation-----\nExample case 1: The distinct Yalalovichik substrings are \"x\", \"xx\" and \"xxx\".\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_yalalovichik_substrings (s: String) : Nat :=\n  sorry\n\ndef longest_run (s: String) : Nat :=\n  sorry", "vc-theorems": "theorem count_always_nonnegative (s: String) (h: s.length > 0):\n  count_yalalovichik_substrings s ≥ 0 :=\nsorry\n\ntheorem single_char_count (c: Char):\n  count_yalalovichik_substrings (String.singleton c) = 1 :=\nsorry\n\ntheorem repeated_single_char (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"a\")\n  count_yalalovichik_substrings s = n :=\nsorry\n\ntheorem alternating_chars (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"ab\")\n  count_yalalovichik_substrings s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"xxx\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aa\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aaa\""}
{"id": "fvapps_001451", "vc-description": "/-\nZonal Computing Olympiad 2012, 26 Nov 2011\n\nA sequence of opening and closing brackets is well-bracketed if we can pair up each opening bracket with a matching closing bracket in the usual sense.  For instance, the sequences (), (()) and ()(()) are well-bracketed, while (, ()), (()(), and )(  are not well-bracketed.\n\nThe nesting depth of a well-bracketed sequence tells us the maximum number of levels of inner matched brackets enclosed within outer matched brackets.  For instance, the nesting depth of () and ()()() is 1, the nesting depth of (()) and ()(()) is 2, the nesting depth of ((())) is 3, and so on.  \n\nGiven a well-bracketed sequence, we are interested in computing the following: \n-  The nesting depth, and the first position where it occurs–this will be the position of the first opening bracket at this nesting depth, where the positions are numbered starting with 1.\n-  The maximum number of symbols between any pair of matched  brackets, including both the outer brackets, and the first position where this occurs–that is, the position of the first opening bracket of this segment\n\nFor instance, the nesting depth of ()(())()(()())(()()) is 2 and the first position where this occurs is 4.  The opening bracket at position 10 is also at nesting depth 2 but we have to report the first position where this occurs, which is 4.\n\nIn this sequence, the maximum number of symbols between a pair of matched bracket is 6, starting at position 9. There is another such sequence of length 6 starting at position 15, but this is not the first such position.\n\n-----Input format-----\nThe input consists of two lines. The first line is a single integer N, the length of the bracket sequence. Positions in the sequence are numbered 1,2,…,N. The second line is a sequence of N space-separated integers that encode the bracket expression as follows: 1 denotes an opening bracket ( and 2 denotes a closing bracket ).  Nothing other than 1 or 2 appears in the second line of input and the corresponding expression is guaranteed to be well-bracketed.\n\n-----Output format-----\nYour program should print 4 space-separated integers in a line, denoting the four quantities asked for in the following order: nesting depth, first position that achieves the nesting depth, length of the maximum sequence between matching brackets and the first position where such a maximum length sequence occurs.  \n\n-----Testdata-----\n\nYou may assume that 2 ≤ N ≤ 105.  In 30% of the test cases, 2 ≤ N ≤ 103.\n\n- Subtask 1 (30 marks)\n- Subtask 2 (70 marks)\n\n-----Sample Input-----\n20\n1 2 1 1 2 2 1 2 1 1 2 1 2 2 1 1 2 1 2 2\n\n-----Sample Output-----\n2 4 6 9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_valid_bracket_sequence (n : Nat) : List Nat :=\n  sorry\n\ndef analyze_brackets (n : Nat) (brackets : List Nat) : Nat × Nat × Nat × Nat :=\n  sorry", "vc-theorems": "theorem minimal_valid_case :\n  analyze_brackets 2 [1,2] = (1,1,2,1) :=\nsorry\n\ntheorem nested_depth_increases :\n  (analyze_brackets 4 [1,1,2,2]).1 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (2, 4, 6, 9)\n-/\n#guard_msgs in\n#eval analyze_brackets 20 [1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2]\n\n/--\ninfo: (1, 1, 2, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 2 [1, 2]\n\n/--\ninfo: (2, 2, 6, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 8 [1, 1, 2, 1, 2, 2, 1, 2]"}
{"id": "fvapps_001452", "vc-description": "/-\nCherry has a binary matrix $A$ consisting of $N$ rows and $M$ columns. The rows are numbered from $1$ to $N$, columns are numbered from $1$ to $M$. Element at row $i$ ($1$ ≤ $i$ ≤ $N$) and column $j$ ($1$ ≤ $j$ ≤ $M$) is denoted as $A_{ij}$. All elements of $A$ are either $0$ or $1$.\nHe performs $Q$ queries on matrix. Each query is provided by four integers $x_{1}$, $y_{1}$, $x_{2}$, $y_{2}$ which define the rectangle, where ($x_{1}$, $y_{1}$) stands for the coordinates of the top left cell of the rectangle, while ($x_{2}$, $y_{2}$) stands for the coordinates of the bottom right cell. You need to flip all the bits i.e. ($0$ to $1$, $1$ to $0$) that are located fully inside the query rectangle.\nFinally, print the matrix after performing all the queries.\nNote: $x_{1}$ represents the row number while $y_{1}$ represents the column number.\n\n-----Input:-----\n- The first line of the input contains two integers $N$ and $M$ — the number of rows and the number of columns in the matrix.\n- Each of the next $N$ lines contains a string of length $M$, where the $j^{th}$ character of $i^{th}$ line denotes the value of $A_{i,j}$. \n- Next line contains an integer $Q$ — the number of queries.\n- Then follow $Q$ lines with queries descriptions. Each of them contains four space-seperated integers $x_{1}$, $y_{1}$, $x_{2}$, $y_{2}$ — coordinates of the up left and bottom right cells of the query rectangle.\n\n-----Output:-----\nPrint the matrix, in the form of $N$ strings, after performing all the queries.\n\n-----Constraints-----\n- $1 \\leq N,M \\leq 1000$\n- $0 \\leq  A_{ij}  \\leq 1$\n- $1 \\leq Q \\leq 10^6$\n- $1 \\leq x_{1} \\leq x_{2} \\leq N$\n- $1 \\leq y_{1} \\leq y_{2} \\leq M$\n\n-----Sample Input:-----\n2 2\n00\n00\n3\n1 1 1 1\n2 2 2 2\n1 1 2 2 \n\n-----Sample Output:-----\n01\n10\n\n-----Explanation:-----\nExample case 1:\nAfter processing the 1st query 1 1 1 1, matrix becomes:\n[1000][1000]\\begin{bmatrix} 10 \\\\ 00  \\end{bmatrix}\nAfter processing the 2nd query 2 2 2 2, the matrix becomes:\n[1001][1001]\\begin{bmatrix} 10 \\\\ 01  \\end{bmatrix}\nAfter processing the 3rd query 1 1 2 2, matrix becomes:\n[0110][0110]\\begin{bmatrix} 01 \\\\ 10  \\end{bmatrix}\nWe need to output the matrix after processing all queries.\n-/\n\n/- Helper for String operations -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def make_zero_matrix (n m : Nat) : List String :=\n  List.replicate n (String.mk (List.replicate m '0'))\n\ndef make_one_matrix (n m : Nat) : List String :=\n  List.replicate n (String.mk (List.replicate m '1'))", "vc-helpers": "", "vc-definitions": "def String.replicate (n : Nat) (c : Char) : String :=\n  sorry\n\ndef List.modifyNth {α : Type} (idx : Nat) (f : α → α) (xs : List α) : List α :=\n  sorry\n\ndef process_matrix_queries (n m : Nat) (matrix : List String) (queries : List (List Nat)) : List String :=\n  sorry", "vc-theorems": "theorem empty_queries_preserves_matrix (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 10) (h4 : m ≤ 10)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [] = matrix :=\nsorry\n\ntheorem single_element_query_sets_one (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 5) (h4 : m ≤ 5)\n    (h5 : matrix = make_zero_matrix n m)\n    (i j : Nat) (h6 : i ≤ n) (h7 : j ≤ m) :\n    process_matrix_queries n m matrix [[i, j, i, j]] =\n    List.modifyNth (i - 1)\n      (fun s => s.take (j - 1) ++ \"1\" ++ s.drop j)\n      matrix :=\nsorry\n\ntheorem full_matrix_query_sets_all_ones (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n ≤ 5) (h4 : m ≤ 5)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [[1, 1, n, m]] =\n    make_one_matrix n m :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001456", "vc-description": "/-\nChef loves to play with iron (Fe) and magnets (Ma). He took a row of $N$ cells (numbered $1$ through $N$) and placed some objects in some of these cells. You are given a string $S$ with length $N$ describing them; for each valid $i$, the $i$-th character of $S$ is one of the following:\n- 'I' if the $i$-th cell contains a piece of iron\n- 'M' if the $i$-th cell contains a magnet\n- '_' if the $i$-th cell is empty\n- ':' if the $i$-th cell contains a conducting sheet\n- 'X' if the $i$-th cell is blocked\nIf there is a magnet in a cell $i$ and iron in a cell $j$, the attraction power between these cells is $P_{i,j} = K+1 - |j-i| - S_{i,j}$, where $S_{i,j}$ is the number of cells containing sheets between cells $i$ and $j$. This magnet can only attract this iron if $P_{i, j} > 0$ and there are no blocked cells between the cells $i$ and $j$.\nChef wants to choose some magnets (possibly none) and to each of these magnets, assign a piece of iron which this magnet should attract. Each piece of iron may only be attracted by at most one magnet and only if the attraction power between them is positive and there are no blocked cells between them. Find the maximum number of magnets Chef can choose.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains a single string $S$ with length $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum number of magnets that can attract iron.\n\n-----Constraints-----\n- $1 \\le T \\le 2,000$\n- $1 \\le N \\le 10^5$\n- $0 \\le K \\le 10^5$\n- $S$ contains only characters 'I', 'M', '_', ':' and 'X'\n- the sum of $N$ over all test cases does not exceed $5 \\cdot 10^6$\n\n-----Subtasks-----\nSubtask #1 (30 points): there are no sheets, i.e. $S$ does not contain the character ':'\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n2\n4 5\nI::M\n9 10\nMIM_XII:M\n\n-----Example Output-----\n1\n2\n\n-----Explanation-----\nExample case 1: The attraction power between the only magnet and the only piece of iron is $5+1-3-2 = 1$. Note that it decreases with distance and the number of sheets.\nExample case 2:\nThe magnets in cells $1$ and $3$ can attract the piece of iron in cell $2$, since the attraction power is $10$ in both cases. They cannot attract iron in cells $6$ or $7$ because there is a wall between them.\nThe magnet in cell $9$ can attract the pieces of iron in cells $7$ and $6$; the attraction power is $8$ and $7$ respectively.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_magnet_attract (n k : Nat) (s : String) : Nat :=\nsorry\n\ndef countChar (s : String) (c : Char) : Nat :=\nsorry\n\ndef String.atN (s : String) (n : Nat) : Char :=\nsorry\n\ndef countAdjacentPairs (n : Nat) (s : String) : Nat :=\nsorry", "vc-theorems": "theorem max_magnet_blocked_by_x {n k : Nat} {s : String} :\n  (∀ i j, 0 ≤ i → i < n → 0 ≤ j → j < n →\n    s.atN i = 'M' → s.atN j = 'I' →\n    ∃ x, min i j ≤ x ∧ x ≤ max i j ∧ s.atN x = 'X') →\n  max_magnet_attract n k s = 0 :=\nsorry\n\ntheorem max_magnet_distance_zero {n : Nat} {s : String} :\n  max_magnet_attract n 0 s ≤ countAdjacentPairs n s :=\nsorry\n\ntheorem max_magnet_output_nonNeg {n k : Nat} {s : String} :\n  max_magnet_attract n k s ≥ 0 :=\nsorry\n\ntheorem max_magnet_output_bounded {n k : Nat} {s : String} :\n  max_magnet_attract n k s ≤ min (countChar s 'M') (countChar s 'I') :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_magnet_attract 4 5 \"I::M\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 9 10 \"MIM_XII:M\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 5 3 \"MI:IM\""}
{"id": "fvapps_001458", "vc-description": "/-\nIshank lives in a country in which there are N$N$ cities and N−1$N-1$ roads. All the cities are connected via these roads. Each city has been assigned a unique number from 1 to N$N$. The country can be assumed as a tree, with nodes representing the cities and edges representing the roads. The tree is rooted at 1.Every Time, when a traveler through a road, he will either gain some amount or has to pay some amount.\nAbhineet is a traveler and wishes to travel to various cities in this country. There's a law in the country for travelers, according to which, when a traveler moves from the city A$A$ to city B$B$, where city A$A$ and B$B$ are connected by a road then the traveler is either paid or has to pay the amount of money equal to profit or loss respectively. When he moves from A$A$ to B$B$, he hires a special kind of vehicle which can reverse its direction at most once. Reversing the direction means earlier the vehicle is going towards the root, then away from the root or vice versa. Abhineet is analyzing his trip and therefore gave Q$Q$ queries to his friend, Ishank, a great coder. In every query, he gives two cities A$A$ and B$B$. Ishank has to calculate the maximum amount he can gain (if he cannot gain, then the minimum amount he will lose) if he goes from the city A$A$ to city B$B$.\n\n-----Input:-----\n-The first line of the input contains a two space-separated integers N and Q.\n-The next N-1 line contains 3 space-separated integers Xi and Yi and Zi denoting that cities Xi and Yi are connected by a road which gives profit Zi (Negative Zi represents loss).\n-The next Q contains 2 space-separated integers A and B denoting two cities.\n\n-----Output:-----\nPrint a single line corresponding to each query — the maximum amount he can gain (if he cannot gain, then the minimum amount he will lose with negative sign) if he goes from city A to city B.\n\n-----Constraints-----\n- 2≤N≤105$2 \\leq N \\leq 10^5$\n- 1≤Q≤105$1 \\leq Q \\leq 10^5$\n- 1≤Xi,Yi,A,B≤N$1 \\leq Xi, Yi, A, B \\leq N$\n- abs(Zi)≤109$ abs(Zi) \\leq 10^9$\n\n-----Sample Input:-----\n9 5\n1 2 8\n1 3 -9\n2 4 1\n2 5 -6\n3 6 7\n3 7 6\n6 8 3\n6 9 4\n1 2\n2 7\n4 3\n3 2\n8 9\n\n-----Sample Output:-----\n10\n5\n0\n-1\n21\n\n-----EXPLANATION:-----\nIn the first query, he goes from 1 to 2, 2 to 4, takes a turn and go to 2. Therefore profit=8+1+1=10.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_profit_path (n : Nat) (edges : List (Nat × Nat × Int)) (queries : List (Nat × Nat)) : List Int :=\nsorry\n\ndef isConnectedTree (edges : List (Nat × Nat × Int)) : Prop :=\nsorry\n\ndef isValidPath (edges : List (Nat × Nat × Int)) (start finish : Nat) (path : List Nat) : Prop :=\nsorry", "vc-theorems": "theorem singleton_tree_zero (u v : Nat)\n  (h : u = 1 ∧ v = 1) :\n  solve_max_profit_path 1 [] [(u, v)] = [0] :=\nsorry\n\ntheorem line_graph_max_profit (edges : List (Nat × Nat × Int))\n  (h_edges : edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) :\n  solve_max_profit_path 4 edges [(1, 4)] = [3] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001469", "vc-description": "/-\nZombies zombies everywhere!! \nIn a parallel world of zombies, there are N zombies. There are infinite number of unused cars, each of same model only differentiated by the their colors. The cars are of K colors.\n\nA zombie parent can give birth to any number of zombie-children (possibly zero), i.e. each zombie will have its parent except the head zombie which was born in the winters by combination of ice and fire.\n\nNow, zombies are having great difficulties to commute to their offices without cars, so they decided to use the cars available. Every zombie will need only one car. Head zombie called a meeting regarding this, in which he will allow each zombie to select a car for him.\n\nOut of all the cars, the head zombie chose one of cars for him. Now, he called his children to choose the cars for them. After that they called their children and so on till each of the zombie had a car. Head zombie knew that it won't be a good idea to allow children to have cars of same color as that of parent, as they might mistakenly use that. So, he enforced this rule during the selection of cars.\n\nProfessor James Moriarty is a criminal mastermind and has trapped Watson again in the zombie world. Sherlock somehow manages to go there and met the head zombie. Head zombie told Sherlock that they will let Watson free if and only if Sherlock manages to tell him the maximum number of ways in which the cars can be selected by N Zombies among all possible hierarchies. A hierarchy represents parent-child relationships among the N zombies. Since the answer may be large, output the answer modulo 109 + 7. Sherlock can not compute big numbers, so he confides you to solve this for him.\n\n-----Input-----\nThe first line consists of a single integer T, the number of test-cases.\n\nEach test case consists of two space-separated integers N and K, denoting number of zombies and the possible number of colors of the cars respectively.\n\n-----Output-----\nFor each test-case, output a single line denoting the answer of the problem.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 10^9\n- 1 ≤ K ≤ 10^9\n\n-----Subtasks-----\nSubtask #1 : (10 points)\n- 1 ≤ T ≤ 20\n- 1 ≤ N, K ≤ 10\n\nSubtask 2 : (20 points) \n\n- 1 ≤ T ≤ 10\n- 1 ≤ N, K ≤ 10000\n\nSubtask 3 : (70 points) \n\n- 1 ≤ T ≤ 100\n- 1 ≤ N, K ≤ 10^9\n\n-----Example-----\nInput\n2\n2 2\n3 3\nOutput:\n2\n12\n\n-----Explanation\nIn the first sample test case, there are 2 zombies. Let us name them Z1 and Z2. Let one hierarchy be one in which Z1 is parent of Z2. There are 2 colors, suppose red and blue. If Z1 takes red, then Z2 should take a blue. If Z1 takes blue, then Z2 should take red. \nNote that one other possible hierarchy could be one in which Z2 is a parent of Z1. In that hierarchy also, number of possible ways of assigning cars is 2.\nSo there maximum number of possible ways is 2.\n\nIn the second example, we have 3 Zombies say Z1, Z2, Z3 and cars of 3 colors, suppose red, blue and green.\nA hierarchy to maximize the number of possibilities is Z1 is the parent of Z2, Z2 is the parent of Z3.\nZombie Z1 can choose one of red, blue or green cars. Z2 can choose one of the remaining two colors (as its car's color can not be same as its parent car.). Z3 can also choose his car in two colors, (one of them could be color same as Z1, and other being the color which is not same as cars of both Z1 and Z2.). This way, there can be 12 different ways of selecting the cars.\n\n-----\nIn the first sample test case, there are 2 zombies. Let us name them Z1 and Z2. Let one hierarchy be one in which Z1 is parent of Z2. There are 2 colors, suppose red and blue. If Z1 takes red, then Z2 should take a blue. If Z1 takes blue, then Z2 should take red. \n\nNote that one other possible hierarchy could be one in which Z2 is a parent of Z1. In that hierarchy also, number of possible ways of assigning cars is 2.\n\nSo there maximum number of possible ways is 2.\n\nIn the second example, we have 3 Zombies say Z1, Z2, Z3 and cars of 3 colors, suppose red, blue and green.\n\nA hierarchy to maximize the number of possibilities is Z1 is the parent of Z2, Z2 is the parent of Z3.\n\nZombie Z1 can choose one of red, blue or green cars. Z2 can choose one of the remaining two colors (as its car's color can not be same as its parent car.). Z3 can also choose his car in two colors, (one of them could be color same as Z1, and other being the color which is not same as cars of both Z1 and Z2.). This way, there can be 12 different ways of selecting the cars.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def MOD : Nat := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_zombie_cars (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_zombie_cars_output_range (n k : Nat) :\n  n ≥ 1 → k ≥ 1 → solve_zombie_cars n k < MOD :=\nsorry\n\ntheorem solve_zombie_cars_k_one (n k : Nat) :\n  n ≥ 1 → k = 1 → solve_zombie_cars n k = if n = 1 then 1 else 0 :=\nsorry\n\ntheorem solve_zombie_cars_formula (n k : Nat) :\n  n ≥ 1 → k ≥ 1 →\n  solve_zombie_cars n k = (k * (k-1)^(n-1)) % MOD :=\nsorry\n\ntheorem solve_zombie_cars_known_values :\n  solve_zombie_cars 2 2 = 2 ∧\n  solve_zombie_cars 3 3 = 12 ∧\n  solve_zombie_cars 4 3 = 24 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001476", "vc-description": "/-\nBobby has decided to hunt some Parrots. There are n horizontal branch of trees aligned parallel to each other. Branches are numbered 1 to n from top to bottom. On each branch there are some parrots sitting next to each other. Supposed there are a[i]$a[i]$ parrots sitting on the i−th$ i-th$ branch.  \nSometimes Bobby shots one of the parrot and the parrot dies (suppose that this parrots sat at the i−th$i-th$ branch). Consequently all the parrots on the i−th$i-th$ branch to the left of the dead parrot get scared and jump up on the branch number i − 1$i - 1$, if there exists no upper branch they fly away. Also all the parrots to the right of the dead parrot jump down on branch number i + 1$i + 1$, if there exists no such branch they fly away.  \nBobby has shot m parrots. You're given the initial number of parrots on each branch, tell him how many parrots are sitting on each branch after the shots.  \n\n-----Input:-----\nThe first line of the input contains an integer N$N$. The next line contains a list of space-separated integers a1, a2, …, an.\nThe third line contains an integer M$M$. Each of the next M$M$ lines contains two integers x[i]$x[i]$ and y[i]$y[i]$. The integers mean that for the i-th time Bobby shoot the y[i]-th (from left) parrot on the x[i]-th branch. It's guaranteed there will be at least y[i] parrot on the x[i]-th branch at that moment.   \n\n-----Output:-----\nOn the i−th$i-th$ line of the output print the number of parrots on the i−th$i-th$ branch.\n\n-----Constraints-----\n- 1≤N≤100$1 \\leq N \\leq 100$\n- 0≤a[i]≤100$0 \\leq a[i] \\leq 100$\n- 0≤M≤100$0 \\leq M \\leq 100$\n- 1≤x[i]≤n$1 \\leq x[i] \\leq n$, 1≤y[i]$1 \\leq y[i] $\n\n-----Sample Input:-----\n5\n\n10 10 10 10 10\n\n5\n\n2 5\n\n3 13\n\n2 12\n\n1 13\n\n4 6   \n3\n\n2 4 1\n\n1\n\n2 2   \n\n-----Sample Output:-----\n0\n\n12\n\n5\n\n0\n\n16   \n3\n\n0\n\n3\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def is_valid_shot (n : Nat) (shot : Nat × Nat) : Bool :=\n  1 ≤ shot.1 ∧ shot.1 ≤ n ∧ shot.2 ≥ 1", "vc-helpers": "", "vc-definitions": "def solve_parrot_hunt (n : Nat) (init_parrots : List Nat) (num_shots : Nat) (shots : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_parrot_hunt_no_shots_preserves_input\n  (n : Nat) (init_parrots : List Nat) (h : init_parrots.length = n) :\n  solve_parrot_hunt n init_parrots 0 [] = init_parrots :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001477", "vc-description": "/-\nAs you know America’s Presidential Elections are about to take place and the most popular leader of the Republican party Donald Trump is famous for throwing allegations against anyone he meets.\n\nHe goes to a rally and meets n people which he wants to offend. For each person i he can choose an integer between 1 to max[i].\n\nHe wants to decide in how many ways he can offend all these persons (N) given the condition that all numbers chosen by him for each person are distinct.\nSo he needs your help to find out the number of ways in which he can do that. If no solution is possible print 0\n\n-----Input-----\nThe first line of the input contains an integer T (1<=T<=100) denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case contains a single integer N denoting the number of people Trump wants to offend. The second line contains N space-separated integers maxnumber[0], maxnumber[1], ..., maxnumber[n-1] denoting the maxnumber that trump can choose for each person. \n\n-----Output-----\nFor each test case, output a single line containing the number of ways Trump can assign numbers to the people, modulo 1,000,000,007. If it's impossible to assign distinct integers to the people, print 0\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 50\n- 1 ≤ Maxnumber[i] ≤ 3000\n\n-----Example-----\nInput:\n3\n1\n4\n2\n10 5\n4\n2 3 1 3\n\nOutput:\n4\n45\n0\n\n-----Explanation-----\nIn case 1, He can choose any number from 1 to 4\n\nIn case 2,Out of the total 50 combination he can not take (1,1) ,(2,2) , (3,3) ,(4,4) or (5,5).\n-/", "vc-preamble": "def natLeBool (a b : Nat) : Bool :=\n  if a ≤ b then true else false", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef calculate_offense_ways (n : Nat) (numbers : List Nat) : Nat :=\nsorry\n\ndef isSorted (l : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem result_range {n : Nat} {numbers : List Nat} :\n  let result := calculate_offense_ways n numbers\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem single_number {x : Nat} :\n  x > 0 →\n  calculate_offense_ways 1 [x] = x :=\nsorry\n\ntheorem impossible_combinations_zero :\n  calculate_offense_ways 2 [1, 1] = 0 ∧\n  calculate_offense_ways 3 [2, 2, 2] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval calculate_offense_ways 1 [4]\n\n/--\ninfo: 45\n-/\n#guard_msgs in\n#eval calculate_offense_ways 2 [10, 5]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_offense_ways 4 [2, 3, 1, 3]"}
{"id": "fvapps_001480", "vc-description": "/-\nThere are $N$ villages numbered $1$ to $N$. The villages are connected through bi-directional paths in between them. The whole network is in the form of a tree. \nEach village has only $1$ fighter but they help each other in times of crisis by sending their fighter to the village in danger through paths along the villages. Defeating a fighter will mean conquering his village. In particular, If village $X$ is under attack, all villages having a path to $X$ will send their fighters for help. \nNaruto wants to conquer all the villages. But he cannot take on so many fighters at the same time so he plans to use  a secret technique with which he can destroy  any $1$ village (along with paths connected to it) in the blink of an eye.  However, it can be used only once. He realized that if he destroys any village, say $X$, the maximum number of fighters he has to fight at once reduces to $W$. He wants $W$ to be as small as possible. Help him find the optimal $X$.\nIn case of multiple answers, choose the smallest value of $X$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First Line contains $N$.\n- Next $N - 1$ lines contain $U, V$, denoting a path between village $U$ and $V$. \n\n-----Output:-----\n- For each Test case, print in a new line, optimal $X$ and corresponding value of $W$.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $3 \\leq N \\leq 10^5$\n- $1 \\leq U, V \\leq N$ \n- $U != V$ \n\n-----Sample Input:-----\n2\n5\n1 2\n1 3\n2 4\n3 5\n3\n1 2\n2 3\n\n-----Sample Output:-----\n1 2\n2 1\n\n-----EXPLANATION:-----\nSample 1:  By destroying village $1$,  The fighters Naruto will be fighting at the same time will be from villages $[2, 4]$ and $[3, 5]$.  For this $W$ = $2$. No other choice can give lesser $W$. Hence $1$ is optimal choice.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry\n\ndef findOptimalAttack (n : Nat) (edges : List (Nat × Nat)) : Nat × Nat :=\n  sorry\n\ndef getAdjList (n : Nat) (edges : List (Nat × Nat)) : List (List Nat) :=\n  sorry\n\ndef componentSize (adj : List (List Nat)) (start visited : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_optimal_attack_output_bounds {n : Nat} {edges : List (Nat × Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges\n  1 ≤ attack_node ∧ attack_node ≤ n ∧\n  1 ≤ max_subgraph ∧ max_subgraph ≤ n-1 :=\nsorry\n\ntheorem breaking_point_subgraph_sizes {n : Nat} {edges : List (Nat × Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges;\n  let adj := getAdjList n edges;\n  ∀ node neighbors, neighbors = (adj.get? (attack_node-1)).getD [] →\n  node ∈ neighbors →\n  componentSize adj [node] [attack_node] ≤ max_subgraph :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001482", "vc-description": "/-\nPrime numbers are arranged in a ordered list U$U$, in increasing order. Let S$S$ be a sublist of U$U$ with a unique property that for every element A$A$ belonging to list S$S$, if i$i$ denotes the index of A$A$ in list U$U$, than i$i$ also belongs to list U$U$.\nGiven N$N$, find sum of first N$N$ elements of list S$S$, assuming 1-based indexing.\nAs the sum can be very large, print the sum modulo 109+7$10^{9}+7$.\n\n-----Input:-----\n-The first line of the input contains a single integer T$T$ denoting the number of test cases.\n-Only line of each test case has an integer N$N$ .\n\n-----Output:-----\nFor each test case, print a single integer denoting the sum of first N$N$ elements of set S$S$ modulo 109+7$10^{9}+7$.\n\n-----Constraints-----\n- 1≤T≤10000$1 \\leq T \\leq 10000$\n- 1≤N≤1000$1 \\leq N \\leq 1000$\n\n-----Subtasks-----\n- \n20 points : \n- \n1≤T≤10000$1 \\leq T \\leq 10000$\n- \n1≤N≤10$1 \\leq N \\leq 10$\n- \n20 points :\n- \n1≤T≤100$1 \\leq T \\leq 100$\n- \n1≤N≤100$1 \\leq N \\leq 100$\n- \n60 points : Original Constraints\n\n-----Sample Input:-----\n2\n\n1\n2\n\n-----Sample Output:-----\n3\n8\n\n-----EXPLANATION:-----\nExample case 1: \nFirst few elements of set S$S$ are  {3,5,11…}  , so sum is 3.\nExample case 2: \nSum is 3+5=8.\n-/\n\n/- Output is always within valid mod range -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Function is deterministic for same input -/\n\n/- First values are monotonically increasing -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD : Nat := 10^9 + 7\n\ndef solve_prime_sum (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_prime_sum_output_range (n: Nat) :\n  solve_prime_sum n < MOD :=\nsorry\n\ntheorem solve_prime_sum_deterministic (n: Nat) :\n  solve_prime_sum n = solve_prime_sum n :=\nsorry\n\ntheorem solve_prime_sum_monotone_init :\n  solve_prime_sum 1 < solve_prime_sum 2 :=\nsorry", "vc-postamble": "/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_prime_sum 1\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_prime_sum 2\n\n/--\ninfo: 19\n-/\n#guard_msgs in\n#eval solve_prime_sum 3"}
{"id": "fvapps_001483", "vc-description": "/-\nTwo integers A and B are the inputs. Write a program to find GCD and LCM of A and B.\n\n-----Input-----\n\nThe first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer A and B. \n\n-----Output-----\nDisplay the GCD and LCM of A and B separated by space respectively. The answer for each test case must be displayed in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ A,B ≤ 1000000\n\n-----Example-----\nInput\n3 \n120 140\n10213 312\n10 30\n\nOutput\n\n20 840\n1 3186456\n10 30\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef lcm (a b : Nat) : Nat :=\n  sorry\n\ndef find_gcd_lcm_pairs (pairs : List (Nat × Nat)) : List (Nat × Nat) :=\n  sorry", "vc-theorems": "theorem gcd_divides {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let g := gcd x y\n  x % g = 0 ∧ y % g = 0 :=\nsorry\n\ntheorem lcm_dividedby {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let l := lcm x y\n  l % x = 0 ∧ l % y = 0 :=\nsorry\n\ntheorem gcd_lcm_product {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y * lcm x y = x * y :=\nsorry\n\ntheorem gcd_upper_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y ≤ min x y :=\nsorry\n\ntheorem lcm_lower_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  lcm x y ≥ max x y :=\nsorry\n\ntheorem same_number_gcd_lcm {n : Nat} (h : n > 0) :\n  gcd n n = n ∧ lcm n n = n :=\nsorry\n\ntheorem find_gcd_lcm_pairs_preserves_length {pairs : List (Nat × Nat)} :\n  pairs.length = (find_gcd_lcm_pairs pairs).length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001484", "vc-description": "/-\nSoma is a fashionable girl. She absolutely loves shiny stones that she can put on as jewellery accessories. She has been collecting stones since her childhood - now she has become really good with identifying which ones are fake and which ones are not.  Her King requested for her help in mining precious stones, so she has told him which all stones are jewels and which are not. Given her description, your task is  to count the number of jewel stones. \n\nMore formally, you're given a string J composed of latin characters where each character is a jewel. You're also given a string S composed of latin characters where each character is a mined stone. You have to find out how many characters of S are in J as well. \n\n-----Input-----\n\nFirst line contains an integer T denoting the number of test cases. Then follow T test cases. Each test case consists of two lines, each of which contains a string composed of English lower case and upper characters. First of these is the jewel string J and the second one is stone string S. \nYou can assume that  1 <= T <= 100, 1 <= |J|, |S| <= 100\n\n-----Output-----\nOutput for each test case, a single integer, the number of jewels mined. \n\n-----Example-----\nInput:\n4\nabc\nabcdef\naA\nabAZ\naaa\na\nwhat\nnone\n\nOutput:\n3\n2\n1\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_jewels (jewels stones : String) : Nat :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem count_jewels_properties_non_negative (jewels stones : String) :\n  count_jewels jewels stones ≥ 0 :=\nsorry\n\ntheorem count_jewels_bounded_by_stones (jewels stones : String) :\n  count_jewels jewels stones ≤ stones.length :=\nsorry\n\ntheorem count_jewels_empty_jewels (stones : String) :\n  count_jewels \"\" stones = 0 :=\nsorry\n\ntheorem count_jewels_empty_stones (jewels : String) :\n  count_jewels jewels \"\" = 0 :=\nsorry\n\ntheorem count_jewels_duplicates (jewels stones : String) :\n  count_jewels (jewels ++ jewels) stones = count_jewels jewels stones :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_jewels \"abc\" \"abcdef\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_jewels \"aA\" \"abAZ\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_jewels \"what\" \"none\""}
{"id": "fvapps_001495", "vc-description": "/-\nThe Fibonacci sequence is defined as F(n) = F(n-1) + F(n-2). You have developed two sequences of numbers. The first sequence that uses the bitwise XOR operation instead of the addition method is called the Xoronacci number. It is described as follows:\nX(n) = X(n-1) XOR X(n-2)\nThe second sequence that uses the bitwise XNOR operation instead of the addition method is called the XNoronacci number. It is described as follows:\nE(n) = E(n-1) XNOR E(n-2)\nThe first and second numbers of the sequence are as follows:\nX(1) = E(1) = a\nX(2) = E(2) = b\nYour task is to determine the value of max(X(n),E(n)), where n is the n th term of the Xoronacci and XNoronacci sequence.\n\n-----Input:-----\nThe first line consists of a single integer T denoting the number of test cases.\nThe first and the only line of each test case consists of three space separated integers a, b and n.\n\n-----Output:-----\nFor each test case print a single integer max(X(n),E(n)).\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $2 \\leq a,b,n \\leq 1000000000000$\n\n-----Sample Input:-----\n1\n3 4 2 \n\n-----Sample Output:-----\n4\n\n-----EXPLANATION:-----\nXoronacci Sequence : 3 4 7 …….\nXNoronacci Sequence : 3 4 0 …….\nHere n = 2. Hence max(X(2),E(2)) = 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_sequence (a b n : Nat) : Nat :=\nsorry\n\ndef bitXor (a b : Nat) : Nat :=\nsorry\n\ndef bitNot (a : Nat) : Nat :=\nsorry\n\ndef bitLength (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_sequence_nonnegative (a b n : Nat) :\n  n > 0 → n ≤ 3 → solve_sequence a b n ≥ 0 :=\nsorry\n\ntheorem solve_sequence_first (a b : Nat) :\n  solve_sequence a b 1 = a :=\nsorry\n\ntheorem solve_sequence_second (a b : Nat) :\n  solve_sequence a b 2 = b :=\nsorry\n\ntheorem solve_sequence_symmetric (a b : Nat) :\n  solve_sequence a b 3 = solve_sequence b a 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 2\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 3\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_sequence 10 12 2"}
{"id": "fvapps_001500", "vc-description": "/-\nChef is interested to solve series problems. Chef wants to solve a series problem but he can't \nsolve it till now.Can you help Chef to solve the series problem?\n- In series problem, the series goes as follows 1,9,31,73,141 . . . . . . . . \nYour task is to find the Nth term of series. For larger value of $N$ answer becomes very large, So your output should be performed $N$th term modulo 1000000007 ($10^9+7$ ).\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single integer $N$. \n\n-----Output:-----\nFor each testcase,  output in a single line answer i.e. The $N$th term of series modulo 1000000007.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^9$\n\n-----Sample Input:-----\n2\n\n8\n\n10\n\n-----Sample Output:-----\n561\n\n1081\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_series (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_series_increases (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  solve_series (n+1) > solve_series n :=\nsorry\n\ntheorem solve_series_one :\n  solve_series 1 = 1 :=\nsorry\n\ntheorem solve_series_large_bound (n : Nat) (h : n = 1000000) :\n  solve_series n < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 561\n-/\n#guard_msgs in\n#eval solve_series 8\n\n/--\ninfo: 1081\n-/\n#guard_msgs in\n#eval solve_series 10\n\n/--\ninfo: 31\n-/\n#guard_msgs in\n#eval solve_series 3"}
{"id": "fvapps_001503", "vc-description": "/-\nAnas is playing an amazing game on a grid with $N$ rows and $M$ columns. The rows are numbered $1$ through $N$ from top to bottom and the columns are numbered $1$ through $M$ from left to right.\nAnas wants to destroy this grid. To do that, he wants to send two heroes from the top left cell to the bottom right cell:\n- The first hero visits cells in row-major order: $(1,1) \\rightarrow (1,2) \\rightarrow \\ldots \\rightarrow (1,M) \\rightarrow (2,1) \\rightarrow (2,2) \\rightarrow \\ldots \\rightarrow (2,M) \\rightarrow \\ldots \\rightarrow (N,M)$.\n- The second hero visits cells in column-major order: $(1,1) \\rightarrow (2,1) \\rightarrow \\ldots \\rightarrow (N,1) \\rightarrow (1,2) \\rightarrow (2,2) \\rightarrow \\ldots \\rightarrow (N,2) \\rightarrow \\ldots \\rightarrow (N,M)$.\nWe know that each hero destroys the first cell he visits, rests in the next $K$ cells he visits without destroying them, then destroys the next cell he visits, rests in the next $K$ cells, destroys the next cell, and so on until he reaches (and rests in or destroys) the last cell he visits.\nAnas does not know the value of $K$. Therefore, for each value of $K$ between $0$ and $N \\cdot M - 1$ inclusive, he wants to calculate the number of cells that will be destroyed by at least one hero. Can you help him?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains two space-separated integers $N$ and $M$.\n\n-----Output-----\nFor each test case, print a single line containing $N \\cdot M$ space-separated integers as described above.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $2 \\le N, M \\le 1,000$\n- the sum of $N \\cdot M$ over all test cases does not exceed $2 \\cdot 10^6$\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- $2 \\le N, M \\le 50$\n- the sum of $N \\cdot M$ over all test cases does not exceed $5,000$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n1\n2 3\n\n-----Example Output-----\n6 4 3 3 2 1\n\n-----Explanation-----\nExample case 1:\n- $K = 0$: All cells will be destroyed by the heroes.\n- $K = 1$: The first hero will destroy the cells $[(1,1), (1,3), (2,2)]$, while the second one will destroy the cells $[(1,1), (1,2), (1,3)]$.\n- $K = 2$: The first hero will destroy the cells $[(1,1), (2,1)]$, while the second one will destroy the cells $[(1,1), (2,2)]$.\n- $K = 3$: The first hero will destroy the cells $[(1,1), (2,2)]$, while the second one will destroy the cells $[(1,1), (1,3)]$.\n- $K = 4$: The first hero will destroy the cells $[(1,1), (2,3)]$ and the second one will also destroy the cells $[(1,1), (2,3)]$.\n- $K = 5$ : The first hero will destroy the cell $(1,1)$ and the second one will also destroy the cell $(1,1)$.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n m : Nat) : List Nat :=\nsorry\n\ndef cell_advance_hero1 (row col n m k : Nat) : (Nat × Nat) :=\nsorry\n\ndef cell_advance_hero2 (row col n m k : Nat) : (Nat × Nat) :=\nsorry\n\ndef find_destroyed_cells (advance : Nat → Nat → Nat → Nat → Nat → (Nat × Nat)) (n m k : Nat) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem solve_output_range {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.length result = n * m ∧\n  ∀ x, x ∈ result → 1 ≤ x ∧ x ≤ n * m * 2 := by\n  sorry\n\ntheorem solve_first_last {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.head! result ≥ List.getLast! result ∧\n  List.getLast! result ≥ 1 := by\n  sorry\n\ntheorem cell_advance_hero1_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero1 row col n m k;\n  1 ≤ result.2 ∧ result.2 ≤ m := by\n  sorry\n\ntheorem cell_advance_hero2_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero2 row col n m k;\n  1 ≤ result.1 ∧ result.1 ≤ n := by\n  sorry\n\ntheorem destroyed_cells_bounds {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (∀ p ∈ cells1, 1 ≤ p.1 ∧ p.1 ≤ n ∧ 1 ≤ p.2 ∧ p.2 ≤ m) ∧\n  (∀ p ∈ cells2, 1 ≤ p.1 ∧ p.1 ≤ n ∧ 1 ≤ p.2 ∧ p.2 ≤ m) := by\n  sorry\n\ntheorem destroyed_cells_start {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (1, 1) ∈ cells1 ∧ (1, 1) ∈ cells2 := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_001504", "vc-description": "/-\nScheme? - Too loudly said. Just a new idea. Now Chef is expanding his business. He wants to make some new restaurants in the big city of Lviv. To make his business competitive he should interest customers. Now he knows how. But don't tell anyone -  it is a secret plan. Chef knows four national Ukrainian dishes - salo, borsch, varenyky and galushky. It is too few, of course, but enough for the beginning. Every day in his restaurant will be a dish of the day among these four ones. And dishes of the consecutive days must be different. To make the scheme more refined the dish of the first day and the dish of the last day must be different too. Now he wants his assistant to make schedule for some period. Chef suspects that there is more than one possible schedule. Hence he wants his assistant to prepare all possible plans so that he can choose the best one among them. He asks you for help. At first tell him how many such schedules exist. Since the answer can be large output it modulo 109 + 7, that is, you need to output the remainder of division of the actual answer by 109 + 7.\n\n-----Input-----\n\nThe first line of the input contains an integer T, the number of test cases. Each of the following T lines contains a single integer N denoting the number of days for which the schedule should be made.\n\n-----Output-----\n\nFor each test case output a single integer in a separate line, the answer for the corresponding test case.\n\n-----Constraints-----1 ≤ T ≤ 100\n2 ≤ N ≤ 109\n\n-----Example-----\nInput:\n3\n2\n3\n5\n\nOutput:\n12\n24\n240\n\n-----Explanation-----\nCase 1. For N = 2 days we have the following 12 schedules:\nFirst day Second day  salo   borsch    salo   varenyky    salo   galushky    borsch   salo    borsch   varenyky    borsch   galushky    varenyky   salo    varenyky   borsch    varenyky   galushky    galushky   salo    galushky   borsch    galushky   varenyky  \n\nCase 2. For N = 3 we have the following 24 schedules:\nFirst daySecond dayThird day  salo   borsch   varenyky    salo   borsch   galushky    salo   varenyky   borsch    salo   varenyky   galushky    salo   galushky   borsch    salo   galushky   varenyky    borsch   salo   varenyky    borsch   salo   galushky    borsch   varenyky   salo    borsch   varenyky   galushky    borsch   galushky   salo    borsch   galushky   varenyky    varenyky   salo   borsch    varenyky   salo   galushky    varenyky   borsch   salo    varenyky   borsch   galushky    varenyky   galushky   salo    varenyky   galushky   borsch    galushky   salo   borsch    galushky   salo   varenyky    galushky   borsch   salo    galushky   borsch   varenyky    galushky   varenyky   salo    galushky   varenyky   borsch  \n\nCase 3. Don't be afraid. This time we will not provide you with a table of 240 schedules. The only thing we want to mention here is that apart from the previous two cases schedules for other values of N can have equal dishes (and even must have for N > 4). For example the schedule (salo, borsch, salo, borsch) is a correct schedule for N = 4 while the schedule (varenyky, salo, galushky, verynky, salo) is a correct schedule for N = 5.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef calculate_possible_schedules (n : Nat) : Nat :=\n  sorry\n\ndef pow (base n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem calculate_possible_schedules_mod_bounds (n : Nat) :\n  0 ≤ calculate_possible_schedules n ∧ calculate_possible_schedules n < MOD :=\nsorry\n\ntheorem calculate_possible_schedules_odd_even_match (n : Nat) :\n  calculate_possible_schedules n =\n    if n % 2 = 0\n    then ((pow 3 n) + 3) % MOD\n    else ((pow 3 n) - 3) % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 2\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 3\n\n/--\ninfo: 240\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 5"}
{"id": "fvapps_001507", "vc-description": "/-\n\"I'm a fan of anything that tries to replace actual human contact.\" - Sheldon.\nAfter years of hard work, Sheldon was finally able to develop a formula which would diminish the real human contact.  \nHe found k$k$ integers n1,n2...nk$n_1,n_2...n_k$ . Also he found that if he could minimize the value of m$m$ such that  ∑ki=1$\\sum_{i=1}^k$n$n$i$i$C$C$m$m$i$i$ is even, where m$m$ = ∑ki=1$\\sum_{i=1}^k$mi$m_i$, he would finish the real human contact.  \nSince Sheldon is busy choosing between PS-4 and XBOX-ONE, he want you to help him to calculate the minimum value of m$m$. \n\n-----Input:-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The \ndescription of T$T$ test cases follows.\n- The first line of each test case contains a single integer k$k$.\n- Next line contains k space separated integers n1,n2...nk$n_1,n_2...n_k$ .\n\n-----Output:-----\nFor each test case output the minimum value of m for which ∑ki=1$\\sum_{i=1}^k$n$n$i$i$C$C$m$m$i$i$ is even, where  m$m$=m1$m_1$+m2$m_2$+. . . mk$m_k$   and  0$0$ <= mi$m_i$<= ni$n_i$ .  If no such answer exists print -1.\n\n-----Constraints-----\n- 1≤T≤1000$1 \\leq T \\leq 1000$\n- 1≤k≤1000$1 \\leq k \\leq 1000$\n- 1≤ni≤10$1 \\leq n_i \\leq 10$18$18$\n\n-----Sample Input:-----\n1\n1\n5\n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\n5$5$C$C$2$2$ = 10 which is even and m is minimum.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_m (n : Nat) (nums : List Nat) : Int :=\nsorry\n\ndef hasAllOnes (n : Nat) : Bool :=\nsorry\n\ndef hasPowerOfTwo (n : Int) (pos : Nat) : Bool :=\nsorry", "vc-theorems": "theorem all_ones_returns_negative_one (nums : List Nat) :\n  (∃ n ∈ nums, hasAllOnes n = true) →\n  find_min_m 1 nums = -1 :=\nsorry\n\ntheorem result_nonnegative_when_valid (nums : List Nat) :\n  (¬∃ n ∈ nums, hasAllOnes n = true) →\n  find_min_m 1 nums ≥ 0 :=\nsorry\n\ntheorem result_is_power_of_two_sum (nums : List Nat) (i : Nat) :\n  let result := find_min_m 1 nums\n  result ≠ -1 →\n  hasPowerOfTwo result i = true →\n  ∃ k, result = 2^k :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_m 1 [5]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_m 1 [7]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_m 1 [10]"}
{"id": "fvapps_001513", "vc-description": "/-\nDio Brando has set  a goal for himself of becoming the richest and the most powerful being on earth.To achieve his goals he will do anything using either manipulation,seduction or plain violence.\nOnly one guy stands between his goal of conquering earth ,named Jotaro Kujo aka JoJo .Now Dio has a stand (visual manifestation of life energy  i.e, special power )  “Za Warudo” ,which can stop time itself but needs to chant few words to activate the time stopping ability of the stand.There is a code hidden inside the words and if you can decipher the code then Dio loses his power.\nIn order to stop Dio ,Jotaro asks your help to decipher the code since he can’t do so while fighting Dio at the same time.\nYou will be given a string as input and you have to find the shortest substring which contains all the characters of itself and then make a number based on the alphabetical ordering of the characters.\nFor example : “bbbacdaddb”\nshortest substring will be “bacd” and based on the alphabetical ordering\nthe answer is 2134\n\n-----NOTE:-----\nA substring is a contiguous subsegment of a string. For example, \"acab\" is a substring of \"abacaba\" (it starts in position 3 and ends in position 6), but \"aa\" or \"d\" aren't substrings of this string. So the substring of the string s from position l to position r is\n\nS[l;r]=SlSl+1…Sr.\n\n-----Input :-----\nThe first line contains $T$,number of test cases.\nThe second line contains a string $S$.\n\n-----Output:-----\nFor each test cases ,output the number you can get from the shortest string \n\n-----Constraints:-----\n$1 \\leq t \\leq 100$\n$1 \\leq |S| \\leq 10^6$\n\n-----Test Cases:-----\n\n-----Sample Input:-----\n6\n\nabcdfgh\n\nurdrdrav\n\njojojojoj\n\nbbbbaaa\n\ncddfsccs\n\ntttttttttttt   \n\n-----Sample Output:-----\n1234678\n\n2118418418122\n\n1015\n\n21\n\n46193\n\n20\n\n-----Explanation:-----\nTest case 1: abcdfgh is the shortest substring containing all char of itself and the number is 1234678\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubstring (sub : String) (orig : String) : Bool :=\nsorry\n\ndef hasAllChars (sub : String) (orig : String) : Bool :=\nsorry\n\ndef substr (s : String) (i j : Nat) : String :=\nsorry\n\ndef findSubString (s : String) : String :=\nsorry", "vc-theorems": "theorem find_sub_string_is_substring\n  (s : String) (h : s.length > 0) :\n  isSubstring (findSubString s) s :=\nsorry\n\ntheorem find_sub_string_has_all_chars\n  (s : String) (h : s.length > 0) :\n  hasAllChars (findSubString s) s :=\nsorry\n\ntheorem find_sub_string_is_minimal\n  (s : String) (h : s.length > 0)\n  (i j : Nat) (h1 : i < s.length) (h2 : j ≤ s.length) (h3 : i < j) :\n  let sub := substr s i j\n  let result := findSubString s\n  sub.length < result.length → ¬(hasAllChars sub s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001534", "vc-description": "/-\nMaster Oogway has forseen that a panda named Po will be the dragon warrior, and the master of Chi. But he did not tell anyone about the spell that would make him the master of Chi, and has left Po confused. Now Po has to defeat Kai, who is the super villian, the strongest of them all. Po needs to master Chi, and he finds a spell which unlocks his powerful Chi. But the spell is rather strange. It asks Po to calculate the factorial of a number! Po is very good at mathematics, and thinks that this is very easy. So he leaves the spell, thinking it's a hoax. But little does he know that this can give him the ultimate power of Chi. Help Po by solving the spell and proving that it's not a hoax.\n\n-----Input-----\nFirst line of input contains an integer T denoting the number of test cases.\nThe next T lines contain an integer N.\n\n-----Output-----\nFor each test case, print a single line containing the solution to the spell which is equal to factorial of N, i.e. N!. Since the output could be large, output it modulo 1589540031(Grand Master Oogway's current age).\n\n-----Constraints-----\n- 1 ≤ T ≤ 100000\n- 1 ≤ N ≤ 100000\n\n-----Example-----\nInput:\n4\n1\n2\n3\n4\n\nOutput:\n1\n2\n6\n24\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def modInv (a n : Nat) : Nat :=\n  sorry\n\ndef solve_factorial_spell (input : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_factorial_spell_output_length\n  (input : List Nat)\n  : List.length (solve_factorial_spell input) = List.length input :=\nsorry\n\ntheorem solve_factorial_spell_modulo_bounds\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length (solve_factorial_spell input))\n  : (List.get! (solve_factorial_spell input) i) < 1589540031 :=\nsorry\n\ntheorem solve_factorial_spell_zero_case\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length input)\n  (h2 : List.get! input i = 0)\n  : List.get! (solve_factorial_spell input) i = 1 :=\nsorry\n\ntheorem solve_factorial_spell_consecutive_ratio\n  (input : List Nat)\n  (i : Nat)\n  (h1 : i + 1 < List.length input)\n  (h2 : List.get! input (i + 1) = List.get! input i + 1)\n  (h3 : List.get! input i > 0)\n  : (List.get! (solve_factorial_spell input) (i + 1) *\n     (modInv (List.get! (solve_factorial_spell input) i) 1589540031)) % 1589540031 =\n    List.get! input (i + 1) :=\nsorry\n\ntheorem solve_factorial_spell_input_bound\n  (input : List Nat)\n  (h : ∃ i, i < List.length input ∧ List.get! input i > 100000)\n  : solve_factorial_spell input = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_factorial_spell [1, 2, 3, 4]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_factorial_spell [5]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_factorial_spell [6, 7]"}
{"id": "fvapps_001538", "vc-description": "/-\nNobody outside the cooking community knows that Chef is a big fan of Chefgram™ — a social network where chefs and cooks upload their secret kitchen photos.\nRecently Chef clicked a beautiful photo, which is represented using 10 pixels in a single row. Respecting Chefgram™'s boolean roots, every pixel is either white or black.\n\nChefgram™ has N filters. Every filter is a string containing 10 symbols. Every symbol is either '+' or '-'.\n\n- A '+' at the ith position in a filter means that if Chef applies this filter to his photo, the ith pixel will be inverted: it becomes black if it was originally white, and vice versa. \n- A '-' at the ith position in a filter string means that if Chef applies this filter to his photo, the ith pixel will remain unchanged.\n\nChef can apply as many filters as he wants from a list. He can pick any subset of filters and consequently apply them to a photo.\n\nFor example:\n\n- Imagine that Chef has a photo \"bbwwbbwwbb\" (where 'b' stands for black and 'w' stands for white).\n- He applies filters \"++--++--++\", \"-+-+-+-+-+\".\n- Applying the first filter will transform his picture to \"wwwwwwwwww\". \n- Applying the second filter on the transformed picture will give Chef the picture \"wbwbwbwbwb\".\n\nEven if Chefgram™ has two or more identical filters, they are still considered different!\n\nChef is extremely interested in knowing how many different subsets of all the Chefgram™ filters can he apply to transform his photo into 10 black pixels?\n\n-----Input-----\n- The first line of input contains a single integer T — the number of test cases.\n- First line of each test case contains a string S. Each symbol is either 'b' or 'w'. This is Chef's photo.\n- Second line of each test case contains a single integer N — the number of Chefgram™ filters.\n- Each of the next N lines contains a single string Fi, each symbol of which is either '+' or '-'. This string is the ith Chefgram™ filter.\n\n-----Output-----\n- For each test case, output a single line containing a single integer — answer to Chef's question modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- |S| = 10\n- 1 ≤ N ≤ 10^5\n- |Fi| = 10\n\n-----Subtasks-----\n- Subtask 1: T ≤ 5; N ≤ 20; Points: 20\n- Subtask 2: T ≤ 5; N ≤ 10^3; Points: 30\n- Subtask 3: T ≤ 5; N ≤ 10^5; Points: 50\n\n-----Example-----\nInput:\n3\nwwwwwwwwww\n3\n+-+-+-+-+-\n----------\n+---------\nwbwbwbwbwb\n3\n+-+-+-+-+-\n+-+-------\n----+-+-+-\nbbbbbbbbbb\n2\n----------\n----------\n\nOutput:\n0\n2\n4\n\n-----Explanation-----\nExample case 1. There is no filter or combination of filters transforming the picture to whole black. \nExample case 2. Chef can either apply the first filter (and invert all whites) or apply the second and third filters in any order.\nExample case 3. Picture is already fully black, and we have two different identity filters. Chef can either apply the empty subset of filters, the first filter only, the second filter only, or both.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_filter_pattern : String → Bool :=\nsorry\n\ndef valid_photo_pattern : String → Bool :=\nsorry\n\ndef process_chefgram_filters : String → List String → Nat :=\nsorry", "vc-theorems": "theorem size_threshold_consistency\n  (n : Nat)\n  (h1 : n ∈ [1000, 1024, 1048]) :\n  let photo := String.mk (List.replicate 10 'w')\n  let filter := \"+-+-+-+-+-\"\n  let filters := List.replicate n filter\n  let result := process_chefgram_filters photo filters\n  0 ≤ result ∧ result < 10^9 + 7 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wwwwwwwwww\" [\"+-+-+-+-+-\", \"----------\", \"+---------\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wbwbwbwbwb\" [\"+-+-+-+-+-\", \"+-+-------\", \"----+-+-+-\"]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"bbbbbbbbbb\" [\"----------\", \"----------\"]"}
{"id": "fvapps_001550", "vc-description": "/-\nWrite a function that accepts a square matrix (`N x N` 2D array) and returns the determinant of the matrix.\n\nHow to take the determinant of a matrix -- it is simplest to start with the smallest cases:\n\nA 1x1 matrix `|a|` has determinant `a`.\n\nA 2x2 matrix `[ [a, b], [c, d] ]` or\n```\n|a  b|\n|c  d|\n```\nhas determinant: `a*d - b*c`.\n\nThe determinant of an `n x n` sized matrix is calculated by reducing the problem to the calculation of the determinants of `n` matrices of`n-1 x n-1` size.\n\nFor the 3x3 case, `[ [a, b, c], [d, e, f], [g, h, i] ]` or\n```\n|a b c|  \n|d e f|  \n|g h i|  \n```\nthe determinant is: `a * det(a_minor) - b * det(b_minor) + c * det(c_minor)` where `det(a_minor)` refers to taking the determinant of the 2x2 matrix created by crossing out the row and column in which the element a occurs:\n```\n|- - -|\n|- e f|\n|- h i|  \n```\nNote the alternation of signs. \n\nThe determinant of larger matrices are calculated analogously, e.g. if M is a 4x4 matrix with first row `[a, b, c, d]`, then:\n\n`det(M) = a * det(a_minor) - b * det(b_minor) + c * det(c_minor) - d * det(d_minor)`\n-/", "vc-preamble": "def Matrix (α : Type u) (n : Nat) := Array (Array α)", "vc-helpers": "", "vc-definitions": "def standardDeterminant {n : Nat} (M : Matrix Int n) : Int :=\nsorry\n\ndef identityMatrix (n : Nat) : Matrix Int n :=\nsorry\n\ndef zeroMatrix (n : Nat) : Matrix Int n :=\nsorry\n\ndef scaleMatrix {n : Nat} (c : Int) (M : Matrix Int n) : Matrix Int n :=\nsorry\n\ndef determinant {n : Nat} (M : Matrix Int n) : Int :=\nsorry", "vc-theorems": "theorem determinant_matches_standard_implementation {n : Nat} (M : Matrix Int n) :\n  determinant M = standardDeterminant M :=\nsorry\n\ntheorem determinant_identity {n : Nat} :\n  determinant (identityMatrix n) = 1 :=\nsorry\n\ntheorem determinant_zero {n : Nat} :\n  determinant (zeroMatrix n) = 0 :=\nsorry\n\ntheorem determinant_scaling {n : Nat} (M : Matrix Int n) (c : Int) :\n  determinant (scaleMatrix c M) = c^n * determinant M :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval determinant #[[5]]\n\n/--\ninfo: -2\n-/\n#guard_msgs in\n#eval determinant #[[1, 2], [3, 4]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval determinant #[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}
{"id": "fvapps_001554", "vc-description": "/-\nWe are given a certain number ```n``` and we do the product partitions of it.\n```[59, 3, 2, 2, 2]``` is a product partition of ```1416``` because:\n```\n59 * 3 * 2 * 2 * 2 = 1416\n```\nWe form a score, ```sc``` for each partition in the following way:\n- if ```d1, d2, ...., dk``` are the prime factors of ```n```, and ```f1, f2, ...., fk```, the corresponding frequencies for each factor, we calculate:\n\nSuposse that we have that ```n = 1416``` \nThe product partitions of this number with a corresponding special score are as follows:\n```\nProduct Partition           Score(sc)\n[59, 3, 2, 2, 2]             350    # equals to: (59^1 + 3^1 + 2^3) * 5\n[177, 2, 2, 2]               740    # equals to: (177^1 + 2^3) * 4\n[118, 3, 2, 2]               500\n[59, 6, 2, 2]                276\n[354, 2, 2]                 1074\n[59, 4, 3, 2]                272\n[236, 3, 2]                  723\n[177, 4, 2]                  549\n[118, 6, 2]                  378\n[59, 12, 2]                  219\n[708, 2]                    1420  <---- maximum value\n[118, 4, 3]                  375\n[59, 8, 3]                   210\n[472, 3]                     950\n[59, 6, 4]                   207\n[354, 4]                     716\n[236, 6]                     484\n[177, 8]                     370\n[118, 12]                    260\n[59, 24]                     166  <---- minimum value\n```\nSo we need a function that may give us the product partition with maximum or minimum score.\n\nThe function ```find_spec_prod_part()``` will receive two arguments:\n\n- an integer ```n, n > 0```\n- a command as a string, one of the following ones: ```'max' or 'min'```\n\nThe function should output a list with two elements: the found product partition (as a list sorted in descendin order) with its corresponding score.\n```\nfind_spec_prod_part(n, com) ---> [prod_partition, score]\n```\nLet'see some cases:\n```python\nfind_spec_prod_part(1416, 'max') == [[708, 2], 1420]\n\nfind_spec_prod_part(1416, 'min') == [[59, 24], 166]\n```\n\nThe function should reject prime numbers:\n```python\nfind_spec_prod_part(10007 , 'max') == \"It is a prime number\"\n```\nEnjoy it!\n\nHint: In this kata, optimization is one of the purposes or tags. The algorithm to produce the product partition is a key factor in terms of speed. Your code will be tested for an ```n``` value up to ```500000```.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def primeFactors (n : Nat) : List Nat :=\n  sorry\n\ndef find_spec_prod_part (n : Nat) (mode : String) : String ⊕ (List Nat × Nat) :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem prime_find_spec_prod_part (n : Nat) (h : n ≥ 2) :\n  is_prime n = true →\n  find_spec_prod_part n \"max\" = Sum.inl \"It is a prime number\" ∧\n  find_spec_prod_part n \"min\" = Sum.inl \"It is a prime number\" :=\nsorry\n\ntheorem partition_product_equals_input (n : Nat) (h1 : n ≥ 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (max_parts, _), Sum.inr (min_parts, _) =>\n    (max_parts.foldl Nat.mul 1 = n) ∧\n    (min_parts.foldl Nat.mul 1 = n)\n  | _, _ => False\n  :=\nsorry\n\ntheorem min_max_relationship (n : Nat) (h1 : n ≥ 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (_, max_score), Sum.inr (_, min_score) => max_score ≥ min_score\n  | _, _ => False\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001556", "vc-description": "/-\n# Connect Four\n\nTake a look at wiki description of Connect Four game:\n\n[Wiki Connect Four](https://en.wikipedia.org/wiki/Connect_Four)\n\nThe grid is 6 row by 7 columns, those being named from A to G.\n\nYou will receive a list of strings showing the order of the pieces which dropped in columns:\n\n```python\n  pieces_position_list = [\"A_Red\",\n                          \"B_Yellow\",\n                          \"A_Red\",\n                          \"B_Yellow\",\n                          \"A_Red\",\n                          \"B_Yellow\",\n                          \"G_Red\",\n                          \"B_Yellow\"]\n```\n\nThe list may contain up to 42 moves and shows the order the players are playing.\n\nThe first player who connects four items of the same color is the winner.\n\nYou should return \"Yellow\", \"Red\" or \"Draw\" accordingly.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def who_is_winner (moves : List String) : String :=\n  sorry\n\ndef columnHeight (moves : List String) (col : String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_result_states (moves : List String) :\n  let result := who_is_winner moves\n  result = \"Red\" ∨ result = \"Yellow\" ∨ result = \"Draw\" := by\n  sorry\n\ntheorem column_height_bound (moves : List String) (col : String) :\n  columnHeight moves col ≤ 6 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"G_Red\", \"B_Yellow\"]\n\n/--\ninfo: 'Red'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Yellow\", \"B_Red\", \"B_Yellow\", \"C_Red\", \"G_Yellow\", \"C_Red\", \"C_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"F_Yellow\", \"E_Red\", \"D_Yellow\"]\n\n/--\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"C_Yellow\", \"E_Red\", \"G_Yellow\", \"B_Red\", \"D_Yellow\", \"B_Red\", \"B_Yellow\", \"G_Red\", \"C_Yellow\", \"C_Red\", \"D_Yellow\", \"F_Red\", \"E_Yellow\", \"A_Red\", \"A_Yellow\", \"G_Red\", \"A_Yellow\", \"F_Red\", \"F_Yellow\", \"D_Red\", \"B_Yellow\", \"E_Red\", \"D_Yellow\", \"A_Red\", \"G_Yellow\", \"D_Red\", \"D_Yellow\", \"C_Red\"]"}
{"id": "fvapps_001558", "vc-description": "/-\nIn this kata we want to convert a string into an integer. The strings simply represent the numbers in words.\n\nExamples:\n\n* \"one\" => 1\n* \"twenty\" => 20\n* \"two hundred forty-six\" => 246\n* \"seven hundred eighty-three thousand nine hundred and nineteen\" => 783919\n\nAdditional Notes:\n\n* The minimum number is \"zero\" (inclusively)\n* The maximum number, which must be supported is 1 million (inclusively)\n* The \"and\" in e.g. \"one hundred and twenty-four\" is optional, in some cases it's present and in others it's not\n* All tested numbers are valid, you don't need to validate them\n-/\n\n-- Main theorems based on property tests", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def parse_int (s : String) : Nat :=\n  sorry\n\ndef normalize_text (s : String) : String :=\n  sorry\n\ndef int_to_english (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem parse_int_inverse (n : Nat) (h : n ≤ 999) :\n  parse_int (int_to_english n) = n :=\nsorry\n\ntheorem parse_int_specific_example :\n  parse_int \"one hundred twenty three\" = 123 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval parse_int \"zero\"\n\n/--\ninfo: 123\n-/\n#guard_msgs in\n#eval parse_int \"one hundred twenty-three\"\n\n/--\ninfo: 200003\n-/\n#guard_msgs in\n#eval parse_int \"two hundred thousand three\""}
{"id": "fvapps_001561", "vc-description": "/-\nMy little sister came back home from school with the following task:\ngiven a squared sheet of paper she has to cut it in pieces\nwhich, when assembled, give squares the sides of which form\nan increasing sequence of numbers.\nAt the beginning it was lot of fun but little by little we were tired of seeing the pile of torn paper.\nSo we decided to write a program that could help us and protects trees.\n\n## Task\n\nGiven a positive integral number n, return a **strictly increasing** sequence (list/array/string depending on the language) of numbers, so that the sum of the squares is equal to n².\n\nIf there are multiple solutions (and there will be), return as far as possible the result with the largest possible values:\n\n## Examples\n\n`decompose(11)` must return `[1,2,4,10]`. Note that there are actually two ways to decompose 11²,\n11² = 121 = 1 + 4 + 16 + 100 = 1² + 2² + 4² + 10² but don't return `[2,6,9]`, since 9 is smaller than 10.\n\nFor `decompose(50)` don't return `[1, 1, 4, 9, 49]` but `[1, 3, 5, 8, 49]` since `[1, 1, 4, 9, 49]`\ndoesn't form a strictly increasing sequence.\n\n## Note\nNeither `[n]` nor `[1,1,1,…,1]` are valid solutions. If no valid solution exists, return `nil`, `null`, `Nothing`, `None` (depending on the language) or `\"[]\"` (C) ,`{}` (C++), `[]` (Swift, Go).\n\nThe function \"decompose\" will take a positive integer n \nand return the decomposition of N = n² as:\n\n- [x1 ... xk]\nor\n- \"x1 ... xk\"\nor\n- Just [x1 ... xk]\nor\n- Some [x1 ... xk]\nor\n- {x1 ... xk}\nor\n- \"[x1,x2, ... ,xk]\"\n\ndepending on the language (see \"Sample tests\")\n\n# Note for Bash\n```\ndecompose 50 returns \"1,3,5,8,49\"\ndecompose 4  returns \"Nothing\"\n```\n# Hint\n\nVery often `xk` will be `n-1`.\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h::t) => h + list_sum t\n\ndef list_sorted : List Nat → Bool\n  | [] => true\n  | [_] => true\n  | (a::b::rest) => a ≤ b && list_sorted (b::rest)\n\ndef list_all (l : List Nat) (p : Nat → Bool) : Bool :=\n  List.all l p\n\ndef square (n : Nat) : Nat := n * n", "vc-helpers": "", "vc-definitions": "def decompose (n : Nat) : Option (List Nat) :=\nsorry", "vc-theorems": "theorem decompose_valid (n : Nat) (result : List Nat) :\n  decompose n = some result →\n  (list_sum (List.map square result) = n * n) ∧\n  list_sorted result = true ∧\n  list_all result (λ x => x > 0) = true ∧\n  list_all result (λ x => x < n) = true :=\nsorry\n\ntheorem decompose_2_impossible :\n  decompose 2 = none :=\nsorry\n\ntheorem decompose_3_impossible :\n  decompose 3 = none :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 2, 4, 10]\n-/\n#guard_msgs in\n#eval decompose 11\n\n/--\ninfo: [1, 3, 5, 8, 49]\n-/\n#guard_msgs in\n#eval decompose 50\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval decompose 4"}
{"id": "fvapps_001566", "vc-description": "/-\nThe number ```89``` is the first positive integer that has a particular, curious property:\n\nThe square of ```89``` is ```7921```; ```89² = 7921```\n\nThe reverse of ```7921``` is ```1297```, and ```1297``` is a prime number.\n\nThe cube of ```89``` is ```704969```; ```89³ = 704969```\n\nThe reverse of ```704969``` is ```969407```, and ```969407``` is a prime number.\n\nThe first four terms of this sequence having this special property are:\n```\nn-th term      term value\n    1               89 \n    2              271\n    3              325\n    4              328\n```\n\nCreate a function ```sq_cub_rev_prime()```, that receives the ordinal number of the sequence and outputs its correspoding value.\n\nUse the above table to show how the function should work:\n```python \nsq_cub_rev_prime(1) == 89 \nsq_cub_rev_prime(2) == 271\nsq_cub_rev_prime(3) == 325\nsq_cub_rev_prime(4) == 328\n```\nYour code will be tested up to the 250th term\n\nThis is not a registered sequence of OESIS, so if you are one of the first ten people that solve this kata, you may have the privilege to register the sequence at https://oeis.org, with your name. If you do so, please, mention in your biography that you are a Codewarrior.\n\nMemoize your results to pass the tests.\n\nEnjoy it!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Int) : Bool :=\nsorry\n\ndef reverse_num (n : Int) : Int :=\nsorry\n\ndef sq_cub_rev_prime (n : Int) : Int :=\nsorry", "vc-theorems": "theorem is_prime_basic_cases :\n  ¬is_prime 1 ∧ is_prime 2 ∧ ¬is_prime 4 ∧ is_prime 5 :=\nsorry\n\ntheorem is_prime_nonpositive (n : Int) :\n  n ≤ 0 → ¬is_prime n :=\nsorry\n\ntheorem is_prime_no_small_divisors {n : Int} (h1 : 2 ≤ n) (h2 : n ≤ 1000) :\n  is_prime n → ∀ i : Int, 2 ≤ i ∧ i * i ≤ n → ¬(i ∣ n) :=\nsorry\n\ntheorem sq_cub_rev_prime_properties (n : Int) (h : 1 ≤ n ∧ n ≤ 39) :\n  sq_cub_rev_prime n > 0 ∧\n  sq_cub_rev_prime n = sq_cub_rev_prime n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 89\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 1\n\n/--\ninfo: 271\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 2\n\n/--\ninfo: 325\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 3"}
{"id": "fvapps_001567", "vc-description": "/-\nA chess board is normally played with 16 pawns and 16 other pieces, for this kata a variant will be played with only the pawns.  All other pieces will not be on the board.  \nFor information on how pawns move, refer [here](http://www.chesscorner.com/tutorial/basic/pawn/pawn.htm)\n\nWrite a function that can turn a list of pawn moves into a visual representation of the resulting board.  \nA chess move will be represented by a string,\n```\n\"c3\"\n```\nThis move represents a pawn moving to `c3`.  If it was white to move, the move would represent a pawn from `c2` moving to `c3`.  If it was black to move, a pawn would move from `c4` to `c3`, because black moves in the other direction.  \nThe first move in the list and every other move will be for white's pieces.\n\nThe letter represents the column, while the number represents the row of the square where the piece is moving  \n\nCaptures are represented differently from normal moves:\n\n```\n\"bxc3\"\n```\nrepresents a pawn on the column represented by 'b' (the second column) capturing a pawn on `c3`.\n\nFor the sake of this kata a chess board will be represented by a list like this one:  \n```\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n```\nHere is an example of the board with the squares labeled:\n```\n[[\"a8\",\"b8\",\"c8\",\"d8\",\"e8\",\"f8\",\"g8\",\"h8\"],\n [\"a7\",\"b7\",\"c7\",\"d7\",\"e7\",\"f7\",\"g7\",\"h7\"],\n [\"a6\",\"b6\",\"c6\",\"d6\",\"e6\",\"f6\",\"g6\",\"h6\"],\n [\"a5\",\"b5\",\"c5\",\"d5\",\"e5\",\"f5\",\"g5\",\"h5\"],\n [\"a4\",\"b4\",\"c4\",\"d4\",\"e4\",\"f4\",\"g4\",\"h4\"],\n [\"a3\",\"b3\",\"c3\",\"d3\",\"e3\",\"f3\",\"g3\",\"h3\"],\n [\"a2\",\"b2\",\"c2\",\"d2\",\"e2\",\"f2\",\"g2\",\"h2\"],\n [\"a1\",\"b1\",\"c1\",\"d1\",\"e1\",\"f1\",\"g1\",\"h1\"]]\n```\nWhite pawns are represented by capital `'P'` while black pawns are lowercase `'p'`.  \n\nA few examples\n```\nIf the list/array of moves is: [\"c3\"]\n>>>\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\"P\",\".\",\".\",\".\",\".\",\".\"],\n [\"P\",\"P\",\".\",\"P\",\"P\",\"P\",\"P\",\"P\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n```\nadd a few more moves,\n```\nIf the list/array of moves is: [\"d4\", \"d5\", \"f3\", \"c6\", \"f4\"]\n>>>\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"p\",\"p\",\".\",\".\",\"p\",\"p\",\"p\",\"p\"],\n [\".\",\".\",\"p\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\"P\",\".\",\"P\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"P\",\"P\",\"P\",\".\",\"P\",\".\",\"P\",\"P\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n```\nnow to add a capture...\n```\nIf the list/array of moves is: [\"d4\", \"d5\", \"f3\", \"c6\", \"f4\", \"c5\", \"dxc5\"]\n>>>\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"p\",\"p\",\".\",\".\",\"p\",\"p\",\"p\",\"p\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\"P\",\"p\",\".\",\".\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\"P\",\".\",\".\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n [\"P\",\"P\",\"P\",\".\",\"P\",\".\",\"P\",\"P\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n```\nIf an invalid move (a move is added that no pawn could perform, a capture where there is no piece, a move to a square where there is already a piece, etc.) is found in the list of moves, return '(move) is invalid'.\n```python\nIf the list/array of moves is: [\"e6\"]\n>>>\n\"e6 is invalid\"\n```\n\n```python\nIf the list/array of moves is: [\"e4\", \"d5\", \"exf5\"]\n>>>\n\"exf5 is invalid\"\n```\nThe list passed to `pawn_move_tracker / PawnMoveTracker.movePawns` will always be a list of strings in the form (regex pattern): `[a-h][1-8]` or `[a-h]x[a-h][1-8]`.  \n\nNotes:\n\n* In the case of a capture, the first lowercase letter will always be adjacent to the second in the alphabet, a move like `axc5` will never be passed.\n* A pawn can move two spaces on its first move\n* There are no cases with the 'en-passant' rule.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "def countChar (c : Char) (l : List Char) : Nat :=\n  l.foldl (fun acc x => if x = c then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def pawnMoveTracker (moves : List String) : List (List Char) :=\nsorry", "vc-theorems": "theorem empty_moves_initial_position (moves : List String) :\n  moves = [] →\n  let board := pawnMoveTracker moves\n  (board.length = 8 ∧\n   (∀ row ∈ board, row.length = 8) ∧\n   (∀ i, i < 8 → (board.get! 1).get! i = 'p') ∧\n   (∀ i, i < 8 → (board.get! 6).get! i = 'P')) :=\nsorry\n\ntheorem valid_moves_invariants (moves : List String) :\n  let board := pawnMoveTracker moves\n  (board.length = 8 ∧\n   (∀ row ∈ board, row.length = 8) ∧\n   let whitePawns := (board.foldl (fun acc row => acc + countChar 'P' row) 0)\n   let blackPawns := (board.foldl (fun acc row => acc + countChar 'p' row) 0)\n   0 ≤ whitePawns ∧ whitePawns ≤ 8 ∧\n   0 ≤ blackPawns ∧ blackPawns ≤ 8) :=\nsorry\n\ntheorem valid_first_white_move (file : Char) (rank : Char) :\n  file ∈ ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] →\n  rank = '4' →\n  let move := String.mk [file, rank]\n  let board := pawnMoveTracker [move]\n  ((board.get! 6).get! (file.toNat - 'a'.toNat) = '.' ∧\n   (board.get! 4).get! (file.toNat - 'a'.toNat) = 'P') :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001568", "vc-description": "/-\nConsider the following array:\n\n```\n[1, 12, 123, 1234, 12345, 123456, 1234567, 12345678, 123456789, 12345678910, 1234567891011...]\n```\n\nIf we join these blocks of numbers, we come up with an infinite sequence which starts with `112123123412345123456...`. The list is infinite.\n\nYou will be given an number (`n`) and your task will be to return the element at that index in the sequence, where `1 ≤ n ≤ 10^18`. Assume the indexes start with `1`, not `0`.  For example:\n\n```\nsolve(1) = 1, because the first character in the sequence is 1. There is no index 0. \nsolve(2) = 1, because the second character is also 1.\nsolve(3) = 2, because the third character is 2.\n```\n\nMore examples in the test cases. Good luck!\n-/\n\n/- For any natural number n, solve returns a single digit (0-9) -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- solve is idempotent: calling it twice gives same result as once -/\n\n/- solve returns single digit for boundary values -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_returns_single_digit (n : Nat) :\n  solve n ≤ 9 :=\nsorry\n\ntheorem solve_idempotent (n : Nat) :\n  solve n = solve (solve n) :=\nsorry\n\ntheorem solve_boundaries_single_digit :\n  solve 1 ≤ 9 ∧\n  solve (10^9) ≤ 9 ∧\n  solve (10^18) ≤ 9 :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 100\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 55\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 123456\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 999999999999999999\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1000000000000000000"}
{"id": "fvapps_001569", "vc-description": "/-\n### Background\n\nI was reading a [book](http://www.amazon.co.uk/Things-Make-Do-Fourth-Dimension/dp/1846147646/) recently, \"Things to Make and Do in the Fourth Dimension\" by comedian and mathematician Matt Parker, and in the first chapter of the book Matt talks about problems he likes to solve in his head to take his mind off the fact that he is in his dentist's chair, we've all been there!\n\nThe problem he talks about relates to polydivisible numbers, and I thought a kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)\n\n### Polydivisib... huh what?\n\nSo what are they?\n\nA polydivisible number is divisible in an unusual way. The first digit is cleanly divisible by `1`, the first two digits are cleanly divisible by `2`, the first three by `3` and so on.\n\nThe interesting thing about polydivisiblity is that it relates to the underlying number, but not the base it is written in, so if aliens came to Earth and used base `23` (`11` fingers on one hand and `12` on the other), no matter what squiggles they use to write numbers, they would find the same numbers polydivisible!\n\n### Polydivisibilty Example:\n\nLet's do a worked example to clear up any questions ...\n\nStarting wih the number `1,232` in base `10` then:\n\n```\n 1232\n 1    /1 = 1    Yay!\n 12   /2 = 6    Yay!\n 123  /3 = 41   Yay!\n 1232 /4 = 308  Yay!\n```\n\nThus `1,232` is a polydivisible number in base `4` and above.\n\nHowever starting wih the number `123,220` and using base `10` then:\n\n```\n 123220\n 1      /1 = 1            Yay!\n 12     /2 = 6            Yay!\n 123    /3 = 41           Yay!\n 1232   /4 = 308          Yay!\n 12322  /5 = 2464.4       Oh no, that's not a round number!\n 123220 /6 = 220536.333r  Oh no, that's not a round number!\n```\n\nThus `123,220` is not a polydivisible base 10 number, but what about in another base?\n\nAgain starting wih the number `123,220` and using base `6` then:\n\n```\n base 6   base 10\n 1      = 1       -> 1     /1 = 1     Yay!\n 12     = 8       -> 8     /2 = 4     Yay!\n 123    = 51      -> 51    /3 = 17    Yay!\n 1232   = 308     -> 308   /4 = 77    Yay!\n 12322  = 1850    -> 1850  /5 = 370   Yay!\n 123220 = 11100   -> 11100 /6 = 1850  Yay!\n```\n\nThus `123,220` is a polydivisible base `6` number (and a polydivisible base `10` number when converted to `11100` in base `10`).\n\n### Kata\n\nIn this kata you must implement two methods: `is_polydivisible(n, b)` and `get_polydivisible(n, b)`.\n\nThe first `is_polydivisible(n, b)` will return `True` if `n` is polydivisible in base `b` or `False` if not.\n\nThe second `get_polydivisible(n, b)` will return the `n`th polydivisible number using base `b`, the first polydivisible number is of course always `0`.\n\nYou can assume that all inputs are valid.\n\n```if:haskell\nAll necessary arithmetic can be done in `Int` range.\n```\n\n### Kata Examples:\n\n```python\n    is_polydivisible(\"1232\", 10)   # => True\n    is_polydivisible(\"123220\", 10) # => False\n    is_polydivisible(\"123220\", 6)  # => True\n    get_polydivisible(22, 10)      # => \"32\"\n    get_polydivisible(22, 16)      # => \"1A\"\n    get_polydivisible(42, 16)      # => \"42\"\n```\n\n#### A Note on Bases\n\nThe maximum base used is base `62`, and uses characters in the following order `[0-9][A-Z][a-z]` to denote its digits, base `n` will use the first `n` characters of this sequence.\n```if-not:haskell\nA constant CHARS has been declared with this sequence for you.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CHARS := ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n\ndef int_to_base_n (num : Nat) (base : Nat) : String :=\nsorry\n\ndef is_polydivisible (s : String) (base : Nat) : Bool :=\nsorry", "vc-theorems": "theorem single_digit_polydivisible {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length) :\n  ∀ (digit : Char), digit ∈ CHARS.take base → is_polydivisible digit.toString base :=\nsorry\n\ntheorem base_conversion_result_bool {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length)\n  (decimal_num : Nat) :\n  let base_n := int_to_base_n decimal_num base\n  ∃ (b : Bool), is_polydivisible base_n base = b :=\nsorry\n\ntheorem zero_polydivisible {base : Nat} (h1 : base ≥ 2) (h2 : base ≤ CHARS.length) :\n  is_polydivisible \"0\" base = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123\" 10\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_polydivisible \"1234\" 10\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123220\" 6"}
{"id": "fvapps_001574", "vc-description": "/-\nGiven two numbers: 'left' and 'right' (1 <= 'left' <= 'right' <= 200000000000000)\nreturn sum of all '1' occurencies in binary representations of numbers between 'left' and 'right' (including both)\n\n``` \nExample:\ncountOnes 4 7 should return 8, because:\n4(dec) = 100(bin), which adds 1 to the result.\n5(dec) = 101(bin), which adds 2 to the result.\n6(dec) = 110(bin), which adds 2 to the result.\n7(dec) = 111(bin), which adds 3 to the result.\nSo finally result equals 8.\n```\nWARNING: Segment may contain billion elements, to pass this kata, your solution cannot iterate through all numbers in the segment!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countOnes (a b : Nat) : Nat :=\nsorry\n\ndef toBinary (n : Nat) : List Nat :=\nsorry\n\ndef countBinaryOnes (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem countOnes_non_negative\n  (a b : Nat)\n  (h1 : 0 < a) (h2 : a ≤ 10^6)\n  (h3 : 0 < b) (h4 : b ≤ 10^6) :\n  0 ≤ countOnes a b :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval countOnes 4 7\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval countOnes 5 5\n\n/--\ninfo: 14846928141\n-/\n#guard_msgs in\n#eval countOnes 1 1000000000"}
{"id": "fvapps_001575", "vc-description": "/-\nCreate a function that takes a Number as its argument and returns a Chinese numeral string. You don't need to validate the input argument, it will always be a Number in the range `[-99999.999, 99999.999]`, rounded to 8 decimal places.\n\nSimplified Chinese numerals have characters representing each number from 0 to 9 and additional numbers representing larger numbers like 10, 100, 1000, and 10000. \n\n```\n0 líng 零\n1 yī 一\n2 èr 二\n3 sān 三\n4 sì 四\n5 wǔ 五\n6 liù 六\n7 qī 七\n8 bā 八\n9 jiǔ 九\n10 shí 十\n100 bǎi 百\n1000 qiān 千\n10000 wàn 万\n```\n\nMultiple-digit numbers are constructed by first the digit value (1 to 9) and then the place multiplier (such as 10, 100, 1000), starting with the most significant digit. A special case is made for 10 - 19 where the leading digit value (yī 一) is dropped. Note that this special case is only made for the actual values 10 - 19, not any larger values.\n\n```\n10 十\n11 十一\n18 十八\n21 二十一\n110 一百一十\n123 一百二十三\n24681 二万四千六百八十一\n```\n\nTrailing zeros are omitted, but interior zeros are grouped together and indicated by a single 零 character without giving the place multiplier.\n\n```\n10 十\n20 二十\n104 一百零四\n1004 一千零四\n10004 一万零四\n10000 一万\n```\n\nDecimal numbers are constructed by first writing the whole number part, and then inserting a point (diǎn 点), followed by the decimal portion. The decimal portion is expressed using only the digits 0 to 9, without any positional characters and without grouping zeros.\n\n```\n0.1 零点一\n123.45 一百二十三点四五\n```\n\nNegative numbers are the same as other numbers, but add a 负 (fù) before the number.\n\nFor more information, please see http://en.wikipedia.org/wiki/Chinese_numerals.\n-/", "vc-preamble": "def DIGS : List String := [\"零\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"]\n\ndef POWS : List String := [\"\", \"十\", \"百\", \"千\", \"万\"]\n\ndef NEG : String := \"负\"", "vc-helpers": "", "vc-definitions": "def to_chinese_numeral (n : Int) : String :=\nsorry", "vc-theorems": "theorem sign_property {n : Int} :\n  n < 0 → (to_chinese_numeral n).startsWith NEG ∧\n  n ≥ 0 → ¬(to_chinese_numeral n).startsWith NEG :=\nsorry\n\ntheorem char_validation {n : Int} :\n  ∀ c : Char, c ∈ (to_chinese_numeral n).data →\n    c ∈ (NEG.data ++ (String.join DIGS).data ++ (String.join POWS).data) :=\nsorry\n\ntheorem single_digit {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 9) :\n  to_chinese_numeral n = DIGS[n.toNat - 1]! :=\nsorry\n\ntheorem teen_numbers {n : Int} (h1 : 10 ≤ n) (h2 : n ≤ 19) :\n  (to_chinese_numeral n).startsWith \"十\" ∧\n  (n > 10 → ∃ c : Char, c ∈ (String.join DIGS).data ∧\n    (to_chinese_numeral n).data[1]? = some c) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '一百二十三点四五'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 123.45\n\n/--\ninfo: '负一千零四'\n-/\n#guard_msgs in\n#eval to_chinese_numeral -1004\n\n/--\ninfo: '一万零四点零零五'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 10004.005"}
{"id": "fvapps_001576", "vc-description": "/-\nLet's define `increasing` numbers as the numbers whose digits, read from left to right, are never less than the previous ones: 234559 is an example of increasing number.\n\nConversely, `decreasing` numbers have all the digits read from left to right so that no digits is bigger than the previous one: 97732 is an example of decreasing number.\n\nYou do not need to be the next Gauss to figure that all numbers with 1 or 2 digits are either increasing or decreasing: 00, 01, 02, ..., 98, 99 are all belonging to one of this categories (if not both, like 22 or 55): 101 is indeed the first number which does NOT fall into either of the categories. Same goes for all the numbers up to 109, while 110 is again a decreasing number.\n\nNow your task is rather easy to declare (a bit less to perform): you have to build a function to return the total occurrences of all the increasing or decreasing numbers *below* 10 raised to the xth power (x will always be >= 0).\n\nTo give you a starting point, there are a grand total of increasing and decreasing numbers as shown in the table:\n\n|Total  | Below\n|---------------\n|1      | 1\n|10     | 10\n|100    | 100\n|475    | 1000\n|1675   | 10000\n|4954   | 100000\n|12952  | 1000000\n\nThis means that your function will have to behave like this:\n```python\ntotal_inc_dec(0)==1\ntotal_inc_dec(1)==10\ntotal_inc_dec(2)==100\ntotal_inc_dec(3)==475\ntotal_inc_dec(4)==1675\ntotal_inc_dec(5)==4954\ntotal_inc_dec(6)==12952\n```\n\n**Tips:** efficiency and trying to figure out how it works are essential: with a brute force approach, some tests with larger numbers may take more than the total computing power currently on Earth to be finished in the short allotted time.\n\nTo make it even clearer, the increasing or decreasing numbers between in the range 101-200 are: [110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 122, 123, 124, 125, 126, 127, 128, 129, 133, 134, 135, 136, 137, 138, 139, 144, 145, 146, 147, 148, 149, 155, 156, 157, 158, 159, 166, 167, 168, 169, 177, 178, 179, 188, 189, 199, 200], that is 47 of them. In the following range, 201-300, there are 41 of them and so on, getting rarer and rarer.\n\n**Trivia:** just for the sake of your own curiosity, a number which is neither decreasing of increasing is called a `bouncy` number, like, say, 3848 or 37294; also, usually 0 is not considered being increasing, decreasing or bouncy, but it will be for the purpose of this kata\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_inc_dec (n : Int) : Nat :=\n  sorry\n\ndef xCy (n m : Int) : Int :=\n  sorry", "vc-theorems": "theorem total_inc_dec_non_negative (x : Int) :\n  x ≥ 0 → total_inc_dec x ≥ 1 :=\nsorry\n\ntheorem total_inc_dec_negative (x : Int) :\n  x < 0 → total_inc_dec x = 0 :=\nsorry\n\ntheorem total_inc_dec_monotonic (x : Int) :\n  x > 0 → total_inc_dec x > total_inc_dec (x-1) :=\nsorry\n\ntheorem xCy_non_negative (x y : Int) :\n  y ≤ x → xCy x y ≥ 0 :=\nsorry\n\ntheorem xCy_int_valued (x y : Int) :\n  y ≤ x → ∃ n : Int, xCy x y = n :=\nsorry\n\ntheorem xCy_symmetry (x y : Int) :\n  y ≤ x ∧ y > 0 → xCy x y = xCy x (x-y) :=\nsorry\n\ntheorem xCy_invalid (x y : Int) :\n  y > x → xCy x y = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval total_inc_dec 0\n\n/--\ninfo: 475\n-/\n#guard_msgs in\n#eval total_inc_dec 3\n\n/--\ninfo: 4954\n-/\n#guard_msgs in\n#eval total_inc_dec 5"}
{"id": "fvapps_001577", "vc-description": "/-\n# Task\n You are given a string `s`. Every letter in `s` appears once. \n\n Consider all strings formed by rearranging the letters in `s`. After ordering these strings in dictionary order, return the middle term. (If the sequence has a even length `n`, define its middle term to be the `(n/2)`th term.)\n\n# Example\n\n For `s = \"abc\"`, the result should be `\"bac\"`.\n```\nThe permutations in order are:\n\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"\nSo, The middle term is \"bac\".```\n\n# Input/Output\n\n - `[input]` string `s`\n\n  unique letters (`2 <= length <= 26`)\n\n - `[output]` a string\n\n  middle permutation.\n-/", "vc-preamble": "def char_list_eq (l1 l2 : List Char) : Prop :=\n  ∀ c : Char, c ∈ l1 ↔ c ∈ l2", "vc-helpers": "", "vc-definitions": "def middle_permutation (s : String) : String :=\nsorry", "vc-theorems": "theorem middle_permutation_symmetric (s : String) :\n  middle_permutation s = middle_permutation s := by\nsorry\n\ntheorem middle_permutation_length (s : String) :\n  (middle_permutation s).length = s.length := by\nsorry\n\ntheorem middle_permutation_chars (s : String) :\n  char_list_eq s.data (middle_permutation s).data := by\nsorry\n\ntheorem middle_permutation_valid (s : String) :\n  ∃ perm : List Char, middle_permutation s = String.mk perm ∧\n    ∃ (π : List Char → List Char),\n      perm = π s.data ∧\n      (∀ (l : List Char), (π l).length = l.length) ∧\n      (∀ (l : List Char), char_list_eq (π l) l) := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'bac'\n-/\n#guard_msgs in\n#eval middle_permutation \"abc\"\n\n/--\ninfo: 'bdca'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcd\"\n\n/--\ninfo: 'cbxda'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcdx\""}
{"id": "fvapps_001580", "vc-description": "/-\n# Longest Palindromic Substring (Linear)\n\nA palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g.,\n'madam' or 'racecar'. Even the letter 'x' is considered a palindrome. \n\nFor this Kata, you are given a string ```s```. Write a function that returns the longest _contiguous_ palindromic substring in ```s``` (it could be the entire string). In the event that there are multiple longest palindromic substrings, return the first to occur.\n\nI'm not trying to trick you here:\n- You can assume that all inputs are valid strings.\n- Only the letters a-z will be used, all lowercase (your solution should, in theory, extend to more than just the letters a-z though). \n\n**NOTE:** Quadratic asymptotic complexity _(O(N^2))_ or above will __NOT__ work here.\n\n-----\n\n## Examples\n\n### Basic Tests\n\n```\nInput: \"babad\"\nOutput: \"bab\"\n(Note: \"bab\" occurs before \"aba\")\n```\n```\nInput: \"abababa\"\nOutput: \"abababa\"\n```\n```\nInput: \"cbbd\"\nOutput: \"bb\"\n```\n\n### Edge Cases\n\n```\nInput: \"ab\"\nOutput: \"a\"\n```\n```\nInput: \"\"\nOutput: \"\"\n```\n-----\n\n## Testing\n\nAlong with the example tests given:\n\n - There are **500** tests using strings of length in range [1 - 1,000]\n - There are **50** tests using strings of length in range [1,000 - 10,000]\n - There are **5** tests using strings of length in range [10,000 - 100,000]\n\nAll test cases can be passed within 10 seconds, but non-linear solutions will time out every time. _Linear performance is essential_. \n\n## Good Luck!\n\n-----\n\nThis problem was inspired by [this](https://leetcode.com/problems/longest-palindromic-substring/) challenge on LeetCode. Except this is the performance version :^)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : String) : Bool :=\n  sorry\n\ndef isSubstring (sub str : String) : Bool :=\n  sorry\n\ndef longest_palindrome (s : String) : String :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry\n\ndef substring (s : String) (i j : Nat) : String :=\n  sorry", "vc-theorems": "theorem output_is_palindrome {s : String} :\n  let result := longest_palindrome s\n  result = \"\" ∨ (result = reverseString result ∧ isSubstring result s)\n  := by\nsorry\n\ntheorem output_is_maximum_length {s : String} :\n  let result := longest_palindrome s\n  ∀ (i j : Nat), i ≤ s.length → j ≤ s.length →\n    let substr := substring s i j\n    substr = reverseString substr →\n    substr.length ≤ result.length\n  := by\nsorry\n\ntheorem empty_and_single_char_inputs {s : String} :\n  (s = \"\" → longest_palindrome s = \"\") ∧\n  (s.length = 1 → longest_palindrome s = s)\n  := by\nsorry\n\ntheorem palindrome_input_returns_itself {s : String} :\n  s ≠ \"\" →\n  s = reverseString s →\n  longest_palindrome s = s\n  := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'bab'\n-/\n#guard_msgs in\n#eval longest_palindrome \"babad\"\n\n/--\ninfo: 'abababa'\n-/\n#guard_msgs in\n#eval longest_palindrome \"abababa\"\n\n/--\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval longest_palindrome \"cbbd\""}
{"id": "fvapps_001584", "vc-description": "/-\n## Task\n\nGiven a positive integer, `n`, return the number of possible ways such that `k` positive integers multiply to `n`. Order matters.\n\n**Examples**\n```\nn = 24\nk = 2\n(1, 24), (2, 12), (3, 8), (4, 6), (6, 4), (8, 3), (12, 2), (24, 1) -> 8\n\nn = 100\nk = 1\n100 -> 1\n\nn = 20\nk = 3\n(1, 1, 20), (1, 2, 10), (1, 4, 5), (1, 5, 4), (1, 10, 2), (1, 20, 1),\n(2, 1, 10), (2, 2, 5), (2, 5, 2), (2, 10, 1), (4, 1, 5), (4, 5, 1),\n(5, 1, 4), (5, 2, 2), (5, 4, 1), (10, 1, 2), (10, 2, 1), (20, 1, 1) -> 18\n```\n**Constraints**\n`1 <= n <= 500_000_000`\nand `1 <= k <= 1000`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multiply (n k: Nat) : Nat :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem multiply_positive (n k: Nat)\n  (h1: n > 0) (h2: k > 0) : multiply n k > 0 :=\nsorry\n\ntheorem multiply_one (k: Nat)\n  (h: k > 0) : multiply 1 k = 1 :=\nsorry\n\ntheorem multiply_k1_is_one (n: Nat)\n  (h: n > 0) : multiply n 1 = 1 :=\nsorry\n\ntheorem multiply_monotone_k (n k: Nat)\n  (h1: n > 0) (h2: k > 1) :\n  multiply n k ≥ multiply n (k-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval multiply 24 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval multiply 100 1\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval multiply 20 3"}
{"id": "fvapps_001585", "vc-description": "/-\nYou are given 2 numbers is `n` and `k`. You need to find the number of integers between 1 and n (inclusive) that contains exactly `k` non-zero digit.\n\nExample1 \n\n`\nalmost_everywhere_zero(100, 1) return 19`\n\nby following condition we have 19 numbers that have k = 1 digits( not count zero ) \n` [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100]`\n\nExample2  \n\n`\nalmost_everywhere_zero(11, 2) return 1`\n\nwe have only `11` that has 2 digits(ten not count because zero is not count) \n` 11`\n\nconstrains\n\n`1≤n<pow(10,100)`\n\n`1≤k≤100`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def almost_everywhere_zero (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef comb (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef num_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem aez_valid_inputs (n : Nat) (k : Nat) :\n  let result := almost_everywhere_zero n k\n  result ≥ 0 :=\nsorry\n\ntheorem aez_zero_k (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 0 = 1 :=\nsorry\n\ntheorem aez_k_greater_than_digits (n : Nat) (k : Nat) (h1 : n > 0) (h2 : k > num_digits n) :\n  almost_everywhere_zero n k = 0 :=\nsorry\n\ntheorem comb_properties (n k : Nat) :\n  let result := comb n k\n  (k > n → result = 0) ∧\n  ((k = 0 ∨ k = n) → result ≤ 1) ∧\n  (k ≤ n → comb n k = comb n (n-k)) :=\nsorry\n\ntheorem aez_single_nonzero (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 1 ≥ num_digits n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 19\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 100 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 11 2\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 20 2"}
{"id": "fvapps_001587", "vc-description": "/-\nThe task is simply stated. Given an integer n (3 < n < 10^(9)), find the length of the smallest list of [*perfect squares*](https://en.wikipedia.org/wiki/Square_number) which add up to n. Come up with the best algorithm you can; you'll need it!\n\nExamples:\n\nsum_of_squares(17) = 2  17 = 16 + 1 (4 and 1 are perfect squares).\nsum_of_squares(15) = 4  15 = 9 + 4 + 1 + 1. There is no way to represent 15 as the sum of three perfect squares.\nsum_of_squares(16) = 1  16 itself is a perfect square.\n\nTime constraints:\n\n5 easy (sample) test cases: n < 20\n\n5 harder test cases: 1000 < n < 15000\n\n5 maximally hard test cases: 5 * 1e8 < n < 1e9\n\n```if:java\n300 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:c#\n350 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:python\n15 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:ruby\n25  random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:javascript\n100 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:crystal\n250 random maximally hard test cases: 1e8 < n < 1e9\n```\n```if:cpp\nRandom maximally hard test cases: 1e8 < n < 1e9\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_of_squares (n : Nat) : Nat :=\nsorry\n\ndef one_square (n : Nat) : Bool :=\nsorry\n\ndef two_squares (n : Nat) : Bool :=\nsorry\n\ndef three_squares (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem sum_of_squares_range (n : Nat) (h : n ≥ 1) :\n  1 ≤ sum_of_squares n ∧ sum_of_squares n ≤ 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_squares 15\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 16\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval sum_of_squares 17\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 999887641\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_squares 999950886"}
{"id": "fvapps_001588", "vc-description": "/-\nThis is a very simply formulated task. Let's call an integer number `N` 'green' if `N²` ends with all of the digits of `N`. Some examples:\n\n`5` is green, because `5² = 25` and `25` ends with `5`.\n\n`11` is not green, because `11² = 121` and `121` does not end with `11`.\n\n`376` is green, because `376² = 141376` and `141376` ends with `376`.\n\nYour task is to write a function `green` that returns `n`th green number, starting with `1` - `green (1) == 1`\n\n---\n\n## Data range\n\n```if:haskell\n`n <= 4000` for Haskell\n```\n```if:java\n`n <= 5000` for Java\n```\n```if:python\n`n <= 5000` for Python\n```\n```if:javascript\n`n <= 3000` for JavaScript\n\nReturn values should be `String`s, and should be exact. A BigNum library is recommended.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def green (n : Nat) : Nat :=\n  sorry\n\ndef first_5_green_numbers (n : Nat) (h : n > 0 ∧ n ≤ 5) :\n  green n = match n with\n    | 1 => 1\n    | 2 => 5\n    | 3 => 6\n    | 4 => 25\n    | 5 => 76\n    | _ => 0 :=\n  sorry\n\ndef green_number_positive (n : Nat) (h : n > 0) :\n  green n > 0 :=\n  sorry\n\ndef green_numbers_ordered (n : Nat) (h : n > 1) :\n  green n > green (n-1) :=\n  sorry\n\ndef green_numbers_unique (n m : Nat) (h1 : n > 0) (h2 : m > 0) (h3 : n ≠ m) :\n  green n ≠ green m :=\n  sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval green 1\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval green 2\n\n/--\ninfo: 76\n-/\n#guard_msgs in\n#eval green 5"}
{"id": "fvapps_001589", "vc-description": "/-\nCreate a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:\n\n```\n12 ==> 21\n513 ==> 531\n2017 ==> 2071\n```\n\nIf the digits can't be rearranged to form a bigger number, return `-1` (or `nil` in Swift):\n\n```\n9 ==> -1\n111 ==> -1\n531 ==> -1\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\nsorry\n\ndef digits_sorted (n : Nat) : List Nat :=\nsorry\n\ndef digits_sorted_desc (n : Nat) : List Nat :=\nsorry\n\ndef next_bigger (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem next_bigger_larger (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 → result > n :=\nsorry\n\ntheorem next_bigger_same_digits (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 →\n  ∀ (r : Nat), result = r → (digits_sorted n = digits_sorted r) :=\nsorry\n\ntheorem next_bigger_minimal (n : Nat) :\n  let result := next_bigger n\n  result ≠ -1 →\n  ∀ x, n < x → x < result → digits_sorted x ≠ digits_sorted n :=\nsorry\n\ntheorem next_bigger_none_exists (n : Nat) :\n  next_bigger n = -1 ↔ digits n = digits_sorted_desc n :=\nsorry\n\ntheorem next_bigger_single_digit (n : Nat) :\n  n < 10 → next_bigger n = -1 :=\nsorry\n\ntheorem next_bigger_output_type (n : Nat) :\n  ∃ i : Int, next_bigger n = i :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval next_bigger 12\n\n/--\ninfo: 531\n-/\n#guard_msgs in\n#eval next_bigger 513\n\n/--\ninfo: 2071\n-/\n#guard_msgs in\n#eval next_bigger 2017\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval next_bigger 9876543210"}
{"id": "fvapps_001592", "vc-description": "/-\nWe want to generate all the numbers of three digits where:\n\n- the sum of their digits is equal to 10.\n\n- their digits are in increasing order (the numbers may have two or more equal contiguous digits)\n\nThe numbers that fulfill the two above constraints are: ```118, 127, 136, 145, 226, 235, 244, 334```\n\nMake a function that receives two arguments:\n\n- the sum of digits value \n\n- the desired number of digits for the numbers\n\nThe function should output an array with three values: \\[1,2,3\\]\n\n1 - the total number of possible numbers\n\n2 - the minimum number\n\n3 - the maximum number\n\nThe example given above should be:\n\n```python\nfind_all(10, 3) == [8, 118, 334]\n```\n\nIf we have only one possible number as a solution, it should output a result like the one below:\n\n```python\nfind_all(27, 3) == [1, 999, 999]\n```\n\nIf there are no possible numbers, the function should output the empty array.\n\n```python\nfind_all(84, 4) == []\n```\n\nThe number of solutions climbs up when the number of digits increases.\n\n```python\nfind_all(35, 6) == [123, 116999, 566666]\n```\n\nFeatures of the random tests:\n\n* Number of tests: `112`\n* Sum of digits value between `20` and `65`\n* Amount of digits between `2` and `17`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumDigits (n : Nat) : Nat :=\nsorry\n\ndef isAscending (n : Nat) : Bool :=\nsorry\n\ndef numDigits (n : Nat) : Nat :=\nsorry\n\ndef find_all (sumDig digs : Nat) : Option (Nat × Nat × Nat) :=\nsorry", "vc-theorems": "theorem empty_for_impossible_sums (sumDig digs : Nat) :\n  (sumDig > 9 * digs ∨ sumDig < digs) → find_all sumDig digs = none :=\nsorry\n\ntheorem valid_output_format {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (count, first, last) := res\n  count > 0 ∧\n  numDigits first = digs ∧\n  numDigits last = digs ∧\n  first ≤ last :=\nsorry\n\ntheorem solutions_have_correct_sum {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (_, first, last) := res\n  sumDigits first = sumDig ∧\n  sumDigits last = sumDig :=\nsorry\n\ntheorem solutions_are_ascending {sumDig digs : Nat} (res : Nat × Nat × Nat) :\n  find_all sumDig digs = some res →\n  let (_, first, last) := res\n  isAscending first ∧\n  isAscending last :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: [8, 118, 334]\n-/\n#guard_msgs in\n#eval find_all 10 3\n\n/--\ninfo: [1, 999, 999]\n-/\n#guard_msgs in\n#eval find_all 27 3\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval find_all 84 4"}
{"id": "fvapps_001593", "vc-description": "/-\nA format for expressing an ordered list of integers is to use a comma separated list of either\n\n* individual integers\n* or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. The range includes all integers in the interval including both endpoints.  It is not considered a range unless it spans at least 3 numbers. For example \"12,13,15-17\"\n\nComplete the solution  so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format. \n\n**Example:**\n\n```python\nsolution([-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20])\n# returns \"-6,-3-1,3-5,7-11,14,15,17-20\"\n```\n\n```C#\nRangeExtraction.Extract(new[] {-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20});\n# returns \"-6,-3-1,3-5,7-11,14,15,17-20\"\n```\n\n*Courtesy of rosettacode.org*\n-/", "vc-preamble": "inductive ValidPart : Type where\n  | empty : ValidPart\n  | single (n : Int) : ValidPart\n  | range (s e : Int) (h : s < e) : ValidPart", "vc-helpers": "", "vc-definitions": "def solution (xs : List Int) : String :=\nsorry\n\ndef parseAsInt (s : String) : Option Int :=\nsorry\n\ndef isValidPart (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solution_empty_list : solution [] = \"\" := by\nsorry\n\ntheorem solution_valid_parts (xs : List Int) :\n  ∀ p ∈ (solution xs).splitOn \",\", isValidPart p = true := by\nsorry\n\ntheorem solution_nonempty_input (xs : List Int) (h : xs ≠ []) :\n  solution xs ≠ \"\" := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '-6,-3-1,3-5,7-11,14,15,17-20'\n-/\n#guard_msgs in\n#eval solution [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\n\n/--\ninfo: '-3--1,2,10,15,16,18-20'\n-/\n#guard_msgs in\n#eval solution [-3, -2, -1, 2, 10, 15, 16, 18, 19, 20]\n\n/--\ninfo: '1-5'\n-/\n#guard_msgs in\n#eval solution [1, 2, 3, 4, 5]"}
{"id": "fvapps_001607", "vc-description": "/-\nWrite a function that takes a positive integer and returns the next smaller positive integer containing the same digits.\n\nFor example:\n\n```python\nnext_smaller(21) == 12\nnext_smaller(531) == 513\nnext_smaller(2071) == 2017\n```\n\nReturn -1 (for `Haskell`: return `Nothing`, for `Rust`: return `None`), when there is no smaller number that contains the same digits. Also return -1 when the next smaller number with the same digits would require the leading digit to be zero.\n\n```python \nnext_smaller(9) == -1\nnext_smaller(135) == -1\nnext_smaller(1027) == -1  # 0721 is out since we don't write numbers with leading zeros\n```\n```ruby \nnext_smaller(9) == -1\nnext_smaller(135) == -1\nnext_smaller(1027) == -1  # 0721 is out since we don't write numbers with leading zeros\n```\n\n * some tests will include very large numbers.\n * test data only employs positive integers.\n\n*The function you write for this challenge is the inverse of this kata: \"[Next bigger number with the same digits](http://www.codewars.com/kata/next-bigger-number-with-the-same-digits).\"*\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_smaller (n : Nat) : Int :=\nsorry\n\ndef has_same_digits (n m : Nat) : Bool :=\nsorry", "vc-theorems": "theorem next_smaller_result_positive (n : Nat) (h: n ≥ 10) :\n  next_smaller n = -1 ∨ next_smaller n > 0 :=\nsorry\n\ntheorem single_digit_returns_negative_one (n : Nat) (h: n < 10) :\n  next_smaller n = -1 :=\nsorry\n\ntheorem zero_returns_negative_one :\n  next_smaller 0 = -1 :=\nsorry\n\ntheorem result_preserves_number_of_digits (n : Nat) (h: n ≥ 10) :\n  next_smaller n ≠ -1 →\n  (String.length (toString (next_smaller n).natAbs) = String.length (toString n)) ∧\n  next_smaller n < n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval next_smaller 21\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval next_smaller 1027\n\n/--\ninfo: 123456789\n-/\n#guard_msgs in\n#eval next_smaller 123456798"}
{"id": "fvapps_001608", "vc-description": "/-\nAlice has a hand of cards, given as an array of integers.\nNow she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.\nReturn true if and only if she can.\n\nExample 1:\nInput: hand = [1,2,3,6,2,3,4,7,8], W = 3\nOutput: true\nExplanation: Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].\nExample 2:\nInput: hand = [1,2,3,4,5], W = 4\nOutput: false\nExplanation: Alice's hand can't be rearranged into groups of 4.\n\nConstraints:\n\n1 <= hand.length <= 10000\n0 <= hand[i] <= 10^9\n1 <= W <= hand.length\n\nNote: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isNStraightHand (hand : List Int) (w : Int) : Bool :=\n  sorry\n\ndef isConsecutive (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem div_by_w_necessary {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w ≤ 10000) (hh : List.length hand > 0) :\n  isNStraightHand hand w → List.length hand % w = 0 :=\nsorry\n\ntheorem w_one_always_true {hand : List Int} (hh : List.length hand > 0) :\n  isNStraightHand hand 1 = true :=\nsorry\n\ntheorem monotonic_w {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w < List.length hand) (hh : List.length hand > 0) :\n  isNStraightHand hand w → ¬isNStraightHand hand (w + 1) :=\nsorry\n\ntheorem consecutive_numbers_possible {hand : List Int}\n  (hh : List.length hand > 0)\n  (h_len : List.length hand ≥ 2)\n  (h_consec : isConsecutive hand)\n  (h_div : List.length hand % 3 = 0) :\n  isNStraightHand hand 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 6, 2, 3, 4, 7, 8] 3\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 4, 5] 4\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 1, 2, 2, 3, 3] 3"}
{"id": "fvapps_001611", "vc-description": "/-\nper nextum in unam tum XI conscribementis fac sic\n\n    vestibulo perlegementum da varo.\n\n    morde varo.\n\n    seqis cumula varum.\n\ncis\n\nper nextum in unam tum XI conscribementis fac sic\n\n    seqis decumulamenta da varo.\n\n    varum privamentum fodementum da aresulto.\n\n    varum tum III elevamentum tum V multiplicamentum da bresulto.\n\n    aresultum tum bresultum addementum da resulto.\n\n    si CD tum resultum non praestantiam fac sic\n\n        dictum sic f(%d) = %.2f cis tum varum tum resultum egresso describe.\n\n        novumversum egresso scribe.\n\n    cis\n\n    si CD tum resultum praestantiam fac sic\n\n        dictum sic f(%d) = MAGNA NIMIS! cis tum varum egresso describe.\n\n        novumversum egresso scribe.        \n\n    cis\n\ncis\n\n-----Input-----\n\nThe input consists of several integers, one per line. Each integer is between -50 and 50, inclusive.\n\n-----Output-----\n\nAs described in the problem statement.\n\n-----Example-----\nInput\n0\n1\n-2\n-3\n-4\n-5\n-6\n-7\n-8\n-9\n10\n\nOutput\nf(10) = MAGNA NIMIS!\nf(-9) = -3642.00\nf(-8) = -2557.17\nf(-7) = -1712.35\nf(-6) = -1077.55\nf(-5) = -622.76\nf(-4) = -318.00\nf(-3) = -133.27\nf(-2) = -38.59\nf(1) = 6.00\nf(0) = 0.00\n-/", "vc-preamble": "structure FormatResult where\n  isStartF : Bool\n  containsAssign : Bool\n\ndef checkFormat (s : String) : FormatResult :=\n  { isStartF := s.data.head? = some 'f',\n    containsAssign := s.data.contains '=' }", "vc-helpers": "", "vc-definitions": "def calculateSequences : List Int → List String :=\nsorry\n\ndef extractValue (s : String) : String :=\nsorry\n\ndef extractNumber (s : String) : Int :=\nsorry", "vc-theorems": "theorem list_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let fmt := checkFormat x\n    fmt.isStartF ∧ fmt.containsAssign :=\nsorry\n\ntheorem value_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n ≥ 5 ∨ n ≤ -51 → val = \"MAGNA NIMIS!\") ∧\n    (n ≤ 3 → val.data.contains '.') :=\nsorry\n\ntheorem order_matches_reversed {inputs : List Int} :\n  let result := calculateSequences inputs\n  let nums := result.map extractNumber\n  nums = inputs.reverse :=\nsorry\n\ntheorem known_values {inputs : List Int} (h : inputs.length > 0) :\n  let result := calculateSequences inputs\n  ∀ x ∈ result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n = 0 → val = \"0.00\") ∧\n    (n = 1 → val = \"6.00\") ∧\n    (n = -1 → val = \"-4.00\") :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval calculate_sequences [0, 1, -2, -3, -4, -5, -6, -7, -8, -9, 10]"}
{"id": "fvapps_001621", "vc-description": "/-\nLaxman, a great Mathematician and Thinker, gives Sugreev an integer, $N$, and asks him to make an array $A$ of length $N$, such that  $\\sum A$i$^3 = X^2$, to prove the purity of the bond of his friendship with Ram. Sugreev is facing difficulty in forming the array. So, help Sugreev to form this array.\n\n-----Note:-----\n- $A$i must be an integer between $1$ to $10^3$ (both inclusive), where $A$i denotes the $i$$th$ element of the array, $A$.\n- $X$ must be an integer (Any Integer).\n- If there are multiple solutions, satisfying the condition, you can print any \"one\" solution.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then, the testcases follow. \n- Each testcase contains a single line of input, integer $N$. \n\n-----Output:-----\nFor each testcase, output in a single line, array $A$ of $N$ integers, where each element is between $1$ to $1000$ (both inclusive), satisfying the equation $\\sum A$i$^3 = X^2$, where $X$ is \"any\" integer.\n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N \\leq 10^3$\n\n-----Sample Input:-----\n2\n1\n6\n\n-----Sample Output:-----\n4\n5 10 5 10 5 5\n-/\n\n-- Cube sum matches formula\n\n-- Perfect squares are identified correctly\n\n-- Product of perfect squares is perfect square\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_cube_sum (n : Nat) : Nat :=\nsorry\n\ndef is_perfect_square (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem cube_sum_matches_formula (n : Nat) :\n  calculate_cube_sum n = ((n * (n + 1)) / 2) ^ 2 :=\nsorry\n\ntheorem perfect_square_properties (n : Nat) (h : n > 1) :\n  (is_perfect_square (n * n) = true) ∧\n  (is_perfect_square (n * n + 1) = false) ∧\n  (is_perfect_square (n * n - 1) = false) :=\nsorry\n\ntheorem perfect_square_product (n : Nat) :\n  is_perfect_square n = true → is_perfect_square (n * n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001622", "vc-description": "/-\nAnna Hazare is a well known social activist in India.\n\nOn 5th April, 2011 he started \"Lokpal Bill movement\".\n\nChef is very excited about this movement. He is thinking of contributing to it. He gathers his cook-herd and starts thinking about how our community can contribute to this.\n\nAll of them are excited about this too, but no one could come up with any idea. Cooks were slightly disappointed with this and went to consult their friends.\n\nOne of the geekiest friend gave them the idea of spreading knowledge through Facebook. But we do not want to spam people's wall. So our cook came up with the idea of dividing Facebook users into small friend groups and then identify the most popular friend in each group and post on his / her wall. They started dividing users into groups of friends and identifying the most popular amongst them.\n\nThe notoriety of a friend is defined as the averaged distance from all the other friends in his / her group. This measure considers the friend himself, and the trivial distance of '0' that he / she has with himself / herself.\n\nThe most popular friend in a group is the friend whose notoriety is least among all the friends in the group. \n\nDistance between X and Y is defined as follows:\n\nMinimum number of profiles that X needs to visit for reaching Y's profile(Including Y's profile). X can open only those profiles which are in the friend list of the current opened profile. For Example:\n\n- Suppose A is friend of B.\n\n- B has two friends C and D.\n\n- E is a friend of D.\n\nNow, the distance between A and B is 1, A and C is 2, C and E is 3. \n\nSo, one of our smart cooks took the responsibility of identifying the most popular friend in each group and others will go to persuade them for posting.  This cheeky fellow knows that he can release his burden by giving this task as a long contest problem.\n\nNow, he is asking you to write a program to identify the most popular friend among all the friends in each group. Also, our smart cook wants to know the average distance of everyone from the most popular friend.\n\n-----Input-----\n\nFriends in a group are labelled with numbers to hide their Facebook identity. The first line of input contains the number of groups in which users are divided. First line of each group contains the number of friends that belong to that group. ith line of each group contains the space separated friend list of 'i'. You are assured that each friend's profile can be accessed by the profile of every other friend by following some sequence of profile visits.\n\n-----Output-----\nYour output contains the most popular friend name label along with the average distance (space separated) from all other friends (including himself / herself) in six digits of precision. There might be multiple most popular friend, in that case output the friend labelled with least number. \n\n-----Note:-----\n\nEach person in a group have atleast one friend and he/she cannot be in his/her own friend list. \n\nNumber of friends in a group cannot be more than 100.\n\nThere are atmost 100 groups.\n\n-----Example-----\nInput:\n1\n6\n3\n5\n1 4\n3 5 6\n2 4 6\n4 5\n\nOutput:\n4 1.166667\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def Graph := List (List Nat)", "vc-helpers": "", "vc-definitions": "def is_valid_graph (g : Graph) : Bool :=\nsorry\n\ndef find_most_popular_friend (friend_lists : List String) : Nat × Float :=\nsorry", "vc-theorems": "theorem most_popular_friend_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  1 ≤ popular ∧ popular ≤ friend_lists.length :=\nsorry\n\ntheorem notoriety_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  0 ≤ notoriety ∧ notoriety ≤ Float.ofNat friend_lists.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001628", "vc-description": "/-\nChef has a rectangular matrix A of nxm integers. Rows are numbered by integers from 1 to n from top to bottom, columns - from 1 to m from left to right. Ai, j denotes the j-th integer of the i-th row.\nChef wants you to guess his matrix. To guess integers, you can ask Chef questions of next type: \"How many integers from submatrix iL, iR, jL, jR are grater than or equal to x and less than or equal to y?\". By submatrix iL, iR, jL, jR we mean all elements Ai, j for all iL ≤ i ≤ iR and jL ≤ j ≤ jR. \nAlso Chef can answer not more than C questions of next type: \"What is the sum of integers from submatrix iL, iR, jL, jR?\"\nAs soon as you think you know the Chefs matrix, you can stop asking questions and tell to the Chef your variant of the matrix. Please see \"Scoring\" part to understand how your solution will be evaluated. \n\n-----Input-----\nThe first line of the input contains three space-separated integers n, m and C denoting the sizes of the matrix and the maximum number of the second-type questions. After that the judge will answer your questions and evaluate the resuts. Read more about that in the \"Interaction with the judge\" part of the statement. \n\n-----Interaction with the judge-----\nTo ask a first-type question you should print to the standard output one line containing seven space-separated integers 1 iL iR jL jR x y. To ask a second-type question you should print one line containing five space-separated integers 2 iL iR jL jR. After that you should read from the standard input one integer - answer to the question. To end the game you should print 3 and starting from next line print n lines, each of them contains m space-separated integers - your variant of the matrix A. After that your program must stop. Remember to flush the output after every line you print.\n\n-----Constraints-----\n- 1 ≤ n, m ≤ 2.5 * 105\n- 1 ≤ n * m ≤ 2.5 * 105\n- 103 ≤ C ≤ 104\n- 1 ≤ Ai, j ≤ 50\n- 1 ≤ iL ≤ iR ≤ n\n- 1 ≤ jL ≤ jR ≤ m\n- 1 ≤ x ≤ y ≤ 50\n- 0 ≤ number of asked questions ≤ 5 * 105\n- 1 ≤ Bi, j ≤ 50\n- 1 ≤ a1, a2, a3 ≤ 10\n\n----- Scoring -----\nLet B will be the matrix you output and diff = ∑ |Ai, j - Bi, j| for all 1 ≤ i ≤ n, 1 ≤ j ≤ m. The number of questions you asked is questions. The number of integers, you correctly guessed is correct(i. e. the number of elements i, j such that Ai, j = Bi, j). \nThe score for each test case will be: score = a1 * questions +  a2 * diff +  a3 * (n * m - correct).\nYour goal is to minimize this score.\nYour total score for the problem will be the sum of scores on all the test cases.\n\n-----Example-----\nInput:\n3 3 10\n4\n0\n3\n1\n6\n\nOutput:\n1 1 2 1 2 1 3\n1 3 3 1 3 1 1\n1 3 3 1 3 2 2\n1 1 2 3 3 1 1\n2 3 3 1 3\n3\n2 2 1\n2 2 1\n2 2 2\n\n-----Explanation-----\n\n[1, 2, 3]\nA = [3, 2, 1]\n[2, 2, 2]\n\nFor this test case a1 = 1, a2 = 1 and a3 = 1.\nThe score for this test case will be 1 * 5 + 1 * 4 + 1 * (9 - 6) = 12.\n\n----- Test data generation -----\nThere will be four types of the test files.\n- Type #1: n = 10,  m = 25000\n- Type #2: n = 100,  m = 2500\n- Type #3: n = 250,  m = 1000\n- Type #4: n = 500,  m = 500\nThere will be 5 test files of each type. During the contest, you will be shown the score for only one test file of each type.\nAll elements of matrix A are randomly chosen.\nFor each test case C is randomly chosen from interval [103 .. 104].\nFor each test case values a1, a2 and a3 are manually chosen.\n-/\n\n/- Query function is consistent for matrices with small values (1-25) -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Query function is consistent for matrices with large values (26-50) -/\n\n/- Result matrix has correct dimensions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_matrix_guessing (n m K : Nat) (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem solve_matrix_query_consistency_small {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  1 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 25 :=\nsorry\n\ntheorem solve_matrix_query_consistency_large {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  ∀ i j, i < n → j < m →\n  26 ≤ ((result.get! i).get! j) ∧ ((result.get! i).get! j) ≤ 50 :=\nsorry\n\ntheorem basic_dimensions {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat → Nat → Nat → Nat → Nat → Nat → Nat → Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  result.length = n ∧ ∀ row ∈ result, row.length = m :=\nsorry", "vc-postamble": "/--\ninfo: n\n-/\n#guard_msgs in\n#eval len solve_matrix_guessing(n, m, c, mock_query_func)\n\n/--\ninfo: m\n-/\n#guard_msgs in\n#eval len result[0]"}
{"id": "fvapps_001633", "vc-description": "/-\nYour task is the exact same as for the easy version. But this time, the marmots subtract the village's population P from their random number before responding to Heidi's request.\n\nAlso, there are now villages with as few as a single inhabitant, meaning that $1 \\leq P \\leq 1000$.\n\nCan you help Heidi find out whether a village follows a Poisson or a uniform distribution?\n\n-----Input-----\n\nSame as for the easy and medium versions. But remember that now 1 ≤ P ≤ 1000 and that the marmots may provide positive as well as negative integers.\n\n-----Output-----\n\nOutput one line per village, in the same order as provided in the input. The village's line shall state poisson if the village's distribution is of the Poisson type, and uniform if the answers came from a uniform distribution.\n-/", "vc-preamble": "def isValidDistribution (s : String) : Bool :=\n  s = \"uniform\" || s = \"poisson\"", "vc-helpers": "", "vc-definitions": "def identify_distribution (samples : List Int) : String :=\n  sorry", "vc-theorems": "theorem identify_distribution_valid (samples : List Int)\n  (h : samples.length ≥ 2) :\n  isValidDistribution (identify_distribution samples) :=\nsorry\n\ntheorem identify_distribution_deterministic (samples : List Int) :\n  identify_distribution samples = identify_distribution samples :=\nsorry\n\ntheorem identify_distribution_uniform (samples : List Int) :\n  samples.length ≥ 2 → identify_distribution samples = \"uniform\" :=\nsorry\n\ntheorem identify_distribution_poisson (samples : List Int) :\n  samples.length ≥ 2 → identify_distribution samples = \"poisson\" :=\nsorry\n\ntheorem identify_distribution_scale_invariant (samples : List Int)\n  (scale : Int) (h : scale ≠ 0) :\n  identify_distribution samples =\n  identify_distribution (samples.map (· * scale)) :=\nsorry\n\ntheorem identify_distribution_order_invariant (samples₁ samples₂ : List Int)\n  (h : samples₁.length = samples₂.length)\n  (h2 : ∀ x, x ∈ samples₁ ↔ x ∈ samples₂) :\n  identify_distribution samples₁ = identify_distribution samples₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [1, 2, 3, 2, 1]\n\n/--\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [10, 8, 9, 8, 12]\n\n/--\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [-5, -4, -3, -4, -5]"}
{"id": "fvapps_001634", "vc-description": "/-\nOnce you complete this kata, there is a [15x15 Version](http://www.codewars.com/kata/15x15-nonogram-solver) that you can try.\nAnd once you complete that, you can do the [Multisize Version](https://www.codewars.com/kata/5a5519858803853691000069) which goes up to 50x50.\n\n# Description\n\nFor this kata, you will be making a Nonogram solver. :)\n\nIf you don't know what Nonograms are, you can [look at some instructions](https://www.puzzle-nonograms.com/faq.php) and also [try out some Nonograms here.](https://www.puzzle-nonograms.com/)\n\nFor this kata, you will only have to solve 5x5 Nonograms. :)\n\n# Instructions\n\nYou need to complete the Nonogram class and the solve method:\n```python\nclass Nonogram:\n\n    def __init__(self, clues):\n        pass\n\n    def solve(self):\n        pass\n```\n\nYou will be given the clues and you should return the solved puzzle. All the puzzles will be solveable so you will not need to worry about that.\n\n```if:python\nThe clues will be a tuple of the horizontal clues, then the vertical clues, which will contain the individual clues. For example, for the Nonogram:\n```\n\n```if:java\nThe clues will be a three dimensional array of the horizontal clues, then the vertical clues, which will contain the individual clues. For example, for the Nonogram:\n```\n\n```\n    |   |   | 1 |   |   |\n    | 1 |   | 1 |   |   |\n    | 1 | 4 | 1 | 3 | 1 |\n-------------------------\n  1 |   |   |   |   |   |\n-------------------------\n  2 |   |   |   |   |   |\n-------------------------\n  3 |   |   |   |   |   |\n-------------------------\n2 1 |   |   |   |   |   |\n-------------------------\n  4 |   |   |   |   |   |\n-------------------------\n```\nThe clues are on the top and the left of the puzzle, so in this case:\n```if:python\nThe horizontal clues are: `((1, 1), (4,), (1, 1, 1), (3,), (1,))`, and the vertical clues are: `((1,), (2,), (3,), (2, 1), (4,))`. The horizontal clues are given from left to right. If there is more than one clue for the same column, the upper clue is given first. The vertical clues are given from top to bottom. If there is more than one clue for the same row, the leftmost clue is given first.\n\nTherefore, the clue given to the `__init__` method would be `(((1, 1), (4,), (1, 1, 1), (3,), (1,)), ((1,), (2,), (3,), (2, 1), (4,)))`. You are given the horizontal clues first then the vertical clues second.\n\n```\n\n```if:java\nThe horizontal clues are: `{{1, 1}, {4}, {1, 1, 1}, {3}, {1}}`, and the vertical clues are: `{{1}, {2}, {3}, {2, 1}, {4}}`. The horizontal clues are given from left to right. If there is more than one clue for the same column, the upper clue is given first. The vertical clues are given from top to bottom. If there is more than one clue for the same row, the leftmost clue is given first.\n\nTherefore, the clue given to the `solve` method would be `{{{1, 1}, {4}, {1, 1, 1}, {3}, {1}},\n                    {{1}, {2}, {3}, {2, 1}, {4}}}`. You are given the horizontal clues first then the vertical clues second.\n\n```\n\n```if:python\nYou should return a tuple of the rows as your answer. In this case, the solved Nonogram looks like:\n\n```\n```if:java\nYou should return a two-dimensional array as your answer. In this case, the solved Nonogram looks like:\n\n```\n\n```\n    |   |   | 1 |   |   |\n    | 1 |   | 1 |   |   |\n    | 1 | 4 | 1 | 3 | 1 |\n-------------------------\n  1 |   |   | # |   |   |\n-------------------------\n  2 | # | # |   |   |   |\n-------------------------\n  3 |   | # | # | # |   |\n-------------------------\n2 1 | # | # |   | # |   |\n-------------------------\n  4 |   | # | # | # | # |\n-------------------------\n```\n\n```if:python\nIn the tuple, you should use 0 for a unfilled square and 1 for a filled square. Therefore, in this case, you should return:\n~~~\n((0, 0, 1, 0, 0),\n (1, 1, 0, 0, 0),\n (0, 1, 1, 1, 0),\n (1, 1, 0, 1, 0),\n (0, 1, 1, 1, 1))\n~~~\n\n```\n\n```if:java\nIn the two-dimensional array, you should use 0 for a unfilled square and 1 for a filled square. Therefore, in this case, you should return:\n~~~\n{{0, 0, 1, 0, 0},\n {1, 1, 0, 0, 0},\n {0, 1, 1, 1, 0},\n {1, 1, 0, 1, 0},\n {0, 1, 1, 1, 1}}\n~~~\n\n```\nGood Luck!!\n\nIf there is anything that is unclear or confusing, just let me know :)\n-/", "vc-preamble": "def minimum (lst : List Int) : Option Int := lst.foldl (fun min x => match min with\n  | none => some x\n  | some m => if x < m then some x else some m) none\n\ndef maximum (lst : List Int) : Option Int := lst.foldl (fun max x => match max with\n  | none => some x\n  | some m => if x > m then some x else some m) none", "vc-helpers": "", "vc-definitions": "def find_min_index (lst : List Int) : Int :=\nsorry\n\ndef find_max_index (lst : List Int) : Int :=\nsorry\n\ndef find_second_max (lst : List Int) : Option Int :=\nsorry", "vc-theorems": "theorem min_index_empty (lst : List Int) :\n  lst = [] → find_min_index lst = -1 :=\nsorry\n\ntheorem min_index_valid (lst : List Int) (result : Int) :\n  result = find_min_index lst →\n  result ≠ -1 →\n  (∃ min : Int, minimum lst = some min ∧\n   0 ≤ result ∧ result < lst.length ∧\n   lst.get ⟨result.toNat, sorry⟩ = min ∧\n   lst.count min = 1) :=\nsorry\n\ntheorem min_index_duplicate (lst : List Int) :\n  find_min_index lst = -1 →\n  lst ≠ [] →\n  (∃ min : Int, minimum lst = some min ∧ lst.count min > 1) :=\nsorry\n\ntheorem max_index_empty (lst : List Int) :\n  lst = [] → find_max_index lst = -1 :=\nsorry\n\ntheorem max_index_valid (lst : List Int) (result : Int) :\n  result = find_max_index lst →\n  result ≠ -1 →\n  (∃ max : Int, maximum lst = some max ∧\n   0 ≤ result ∧ result < lst.length ∧\n   lst.get ⟨result.toNat, sorry⟩ = max ∧\n   lst.count max = 1) :=\nsorry\n\ntheorem max_index_duplicate (lst : List Int) :\n  find_max_index lst = -1 →\n  lst ≠ [] →\n  (∃ max : Int, maximum lst = some max ∧ lst.count max > 1) :=\nsorry\n\ntheorem second_max_short (lst : List Int) :\n  lst.length < 2 → find_second_max lst = none :=\nsorry\n\ntheorem second_max_valid (lst : List Int) (result : Int) :\n  find_second_max lst = some result →\n  (∃ max : Int, maximum lst = some max ∧\n   result < max ∧\n   (∀ x, x ∈ lst → ¬(result < x ∧ x < max)) ∧\n   result ∈ lst) :=\nsorry\n\ntheorem second_max_none (lst : List Int) :\n  find_second_max lst = none →\n  lst.length ≥ 2 →\n  (∃ x : Int, ∀ y ∈ lst, y = x) :=\nsorry\n\ntheorem results_from_input (lst : List Int) :\n  let min_idx := find_min_index lst\n  let max_idx := find_max_index lst\n  let second := find_second_max lst\n  (min_idx ≠ -1 → (∃ x, lst.get ⟨min_idx.toNat, sorry⟩ = x ∧ x ∈ lst)) ∧\n  (max_idx ≠ -1 → (∃ x, lst.get ⟨max_idx.toNat, sorry⟩ = x ∧ x ∈ lst)) ∧\n  (second.isSome → (Option.get! second) ∈ lst) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_second_max [4, 1, 2, 3, 5]\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval find_second_max [1, 1, 1, 1, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_second_max [1, 2, 3, 3]"}
{"id": "fvapps_001639", "vc-description": "/-\nGiven a Sudoku data structure with size `NxN, N > 0 and √N == integer`, write a method to validate if it has been filled out correctly.\n\nThe data structure is a multi-dimensional Array, i.e:\n```\n[\n  [7,8,4,  1,5,9,  3,2,6],\n  [5,3,9,  6,7,2,  8,4,1],\n  [6,1,2,  4,3,8,  7,5,9],\n\n  [9,2,8,  7,1,5,  4,6,3],\n  [3,5,7,  8,4,6,  1,9,2],\n  [4,6,1,  9,2,3,  5,8,7],\n\n  [8,7,6,  3,9,4,  2,1,5],\n  [2,4,3,  5,6,1,  9,7,8],\n  [1,9,5,  2,8,7,  6,3,4]\n]\n```\n\n**Rules for validation**\n\n- Data structure dimension: `NxN` where `N > 0` and `√N == integer`\n- Rows may only contain integers: `1..N (N included)`\n- Columns may only contain integers: `1..N (N included)`\n- *'Little squares'* (`3x3` in example above) may also only contain integers: `1..N (N included)`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPerfectSquare (n : Nat) : Bool :=\n  sorry\n\ndef generateValidBoard (size : Nat) : List (List Nat) :=\n  sorry\n\ndef validateSudoku (board : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem invalid_size_board {n : Nat} :\n  n > 0 → ¬(isPerfectSquare n) →\n  validateSudoku (List.replicate n (List.replicate n 1)) = false :=\nsorry\n\ntheorem valid_size_board {n : Nat} :\n  n > 0 → n ≤ 3 →\n  validateSudoku (generateValidBoard (n * n)) = true :=\nsorry\n\ntheorem duplicate_in_row {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 0 ∧ (board.head!).length > 1\n    then board.set 0 ((board.get! 0).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry\n\ntheorem duplicate_in_column {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 1\n    then board.set 1 ((board.get! 1).set 0 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry\n\ntheorem duplicate_in_square {n : Nat} (board : List (List Nat)) :\n  n > 0 → n ≤ 3 →\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 ∧ board.length > 1\n    then board.set 1 ((board.get! 1).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku [[7, 8, 4, 1, 5, 9, 3, 2, 6], [5, 3, 9, 6, 7, 2, 8, 4, 1], [6, 1, 2, 4, 3, 8, 7, 5, 9], [9, 2, 8, 7, 1, 5, 4, 6, 3], [3, 5, 7, 8, 4, 6, 1, 9, 2], [4, 6, 1, 9, 2, 3, 5, 8, 7], [8, 7, 6, 3, 9, 4, 2, 1, 5], [2, 4, 3, 5, 6, 1, 9, 7, 8], [1, 9, 5, 2, 8, 7, 6, 3, 4]]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval validate_sudoku invalid_board\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku valid_small"}
{"id": "fvapps_001646", "vc-description": "/-\nGiven an array of positive or negative integers \n\n I= [i1,..,in]\n\nyou have to produce a sorted array P of the form \n\n[ [p, sum of all ij of I for which p is a prime factor (p positive) of ij] ...]\n\nP will be sorted by increasing order of the prime numbers.\nThe final result has to be given as a string in Java, C#, C, C++ and as an array of arrays in other languages.\n\nExample:\n\n```python\nI = [12, 15] # result = [[2, 12], [3, 27], [5, 15]]\n```\n\n[2, 3, 5] is the list of all prime factors of the elements of I, hence the result.\n\n**Notes:**\n- It can happen that a sum is 0 if some numbers are negative!\n\nExample: I = [15, 30, -45]\n5 divides 15, 30 and (-45) so 5 appears in the result, the sum of the numbers for which 5 is a factor is 0 so we have [5, 0] in the result amongst others. \n\n- In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n-/", "vc-preamble": "def listSum (lst : List Int) : Int := lst.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def isPrime (n : Int) : Bool :=\nsorry\n\ndef primeFactor (n: Int) : List Int :=\nsorry\n\ndef sumForList (lst : List Int) : List (Int × Int) :=\nsorry", "vc-theorems": "theorem results_are_prime_factors {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  ∀ pt, pt ∈ sumForList lst →\n    isPrime pt.1 = true ∧\n    ∃ x, x ∈ lst ∧ x % pt.1 = 0 :=\nsorry\n\ntheorem sums_are_correct {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  ∀ pt, pt ∈ sumForList lst →\n    pt.2 = listSum (lst.filter (fun x => x % pt.1 = 0)) :=\nsorry\n\ntheorem factors_ordered {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  List.Pairwise (· ≤ ·) (List.map Prod.fst (sumForList lst)) :=\nsorry\n\ntheorem all_prime_factors_included {lst : List Int} (h : ∀ x, x ∈ lst → x ≠ 0) :\n  (∀ p, p ∈ List.map Prod.fst (sumForList lst) →\n    (∃ x, x ∈ lst ∧ x % p = 0 ∧ isPrime p = true)) ∧\n  (∀ x, x ∈ lst → ∀ p, p ∈ primeFactor x →\n    p ∈ List.map Prod.fst (sumForList lst)) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [[2, 12], [3, 27], [5, 15]]\n-/\n#guard_msgs in\n#eval sum_for_list [12, 15]\n\n/--\ninfo: [[2, 30], [3, 0], [5, 0]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 30, -45]\n\n/--\ninfo: [[2, 54], [3, 135], [5, 90], [7, 21]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 21, 24, 30, 45]"}
{"id": "fvapps_001653", "vc-description": "/-\nKate constantly finds herself in some kind of a maze. Help her to find a way out!.\n\nFor a given maze and Kate's position find if there is a way out. Your function should return True or False.\n\nEach maze is defined as a list of strings, where each char stays for a single maze \"cell\". ' ' (space) can be stepped on, '#' means wall and 'k' stays for Kate's starting position. Note that the maze may not always be square or even rectangular.\n\nKate can move left, up, right or down only.\n\nThere should be only one Kate in a maze. In any other case you have to throw an exception.\n\nExample input\n=============\n```\n['# ##',\n '# k#',\n '####']\n```\n\nExample output\n==============\nTrue\n\nExample input\n=============\n```\n['####'.\n '# k#',\n '####']\n```\n\nExample output\n==============\nFalse\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidMaze (maze : List String) : Bool :=\nsorry\n\ndef hasExit (maze : List String) : Bool :=\nsorry\n\ndef isKateAt (maze : List String) (i j : Nat) : Bool :=\nsorry", "vc-theorems": "theorem maze_properties (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1) :\n  hasExit maze = true ∨ hasExit maze = false :=\nsorry\n\ntheorem invalid_maze_no_kate (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 0) :\n  ∃ e, hasExit maze = e → False :=\nsorry\n\ntheorem edge_escape (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1)\n  (h3 : ∃ (i j : Nat),\n    (i = 0 ∨ i = maze.length - 1 ∨ j = 0 ∨ j = (maze.get! 0).length - 1) ∧\n    isKateAt maze i j = true) :\n  hasExit maze = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval has_exit [\"# ##\", \"# k#\", \"####\"]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval has_exit [\"####\", \"# k#\", \"####\"]"}
{"id": "fvapps_001659", "vc-description": "/-\n## Task\n\nYou are at position [0, 0] in maze NxN and you can **only** move in one of the four cardinal directions (i.e. North, East, South, West).  Return `true` if you can reach position [N-1, N-1] or `false` otherwise.\n\nEmpty positions are marked `.`. Walls are marked `W`. Start and exit positions are empty in all test cases.\n\n## Path Finder Series:\n-       [#1: can you reach the exit?](https://www.codewars.com/kata/5765870e190b1472ec0022a2)\n-       [#2: shortest path](https://www.codewars.com/kata/57658bfa28ed87ecfa00058a)\n-       [#3: the Alpinist](https://www.codewars.com/kata/576986639772456f6f00030c)\n-       [#4: where are you?](https://www.codewars.com/kata/5a0573c446d8435b8e00009f)\n-       [#5: there's someone here](https://www.codewars.com/kata/5a05969cba2a14e541000129)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def path_finder (maze : String) : Bool :=\nsorry\n\ndef stringReplicate (n : Nat) (s : String) : String :=\nsorry\n\ndef stringJoin (l : List String) (sep : String) : String :=\nsorry\n\ndef makeList (n : Nat) (c : Char) : List Char :=\nsorry\n\ndef listToString (l : List Char) : String :=\nsorry\n\ndef make_maze (cells : List Char) : String :=\nsorry", "vc-theorems": "theorem empty_maze_always_solvable (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let row := stringReplicate n \".\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = true :=\nsorry\n\ntheorem border_wall_maze_unsolvable (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let row := stringReplicate n \"W\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = false :=\nsorry\n\ntheorem random_valid_maze_returns_bool (cells : List Char)\n  (h1 : cells.length ≥ 4) (h2 : cells.length ≤ 100)\n  (h3 : ∀ c ∈ cells, c = '.' ∨ c = 'W')\n  (h4 : ∃ n : Nat, n * n = cells.length)\n  (h5 : cells ≠ [] → cells[0] = '.')\n  (h6 : cells ≠ [] → cells[cells.length - 1] = '.') :\n  (path_finder (make_maze cells)) = true ∨ (path_finder (make_maze cells)) = false :=\nsorry\n\ntheorem single_path_solvable :\n  path_finder \"..W\\nW.W\\n...\" = true :=\nsorry\n\ntheorem path_to_self_exists (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let cells := makeList (n*n) '.'\n  path_finder (make_maze cells) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval path_finder \"\\n\".join([\".W.\", \".W.\", \"...\"])\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder maze2"}
{"id": "fvapps_001663", "vc-description": "/-\nTo almost all of us solving sets of linear equations is quite obviously the most exciting bit of linear algebra. Benny does not agree though and wants to write a quick program to solve his homework problems for him. Unfortunately Benny's lack of interest in linear algebra means he has no real clue on how to go about this. Fortunately, you can help him!\n\nWrite a method ```solve``` that accepts a list of linear equations that your method will have to solve. The output should be a map (a `Map` object in JavaScript) with a value for each variable in the equations. If the system does not have a unique solution (has infinitely many solutions or is unsolvable), return ```null``` (`None` in python).\n\nFor example :  \n\n\"2x + 4y + 6z = 18\"  \n\"3y + 3z = 6\"  \n\"x + 2y = z - 3\"\n\nshould result in a map :  \n\nx = 2  \ny = -1  \nz = 3  \n\nPossible input equations have the following rules:  \n-   Only the plus and minus operators are used on both the left and right hand side of the equation.  \n-   Both sides of the equation can have variables; One variable can appear in multiple terms, on both sides.\n-   Variable names are strings of arbitrary length.  \n-   All coefficients are integers and generally fall within the range of -150 to 150, with a few ranging from -1000 to 1000. Free terms are integers in range -20000 to 20000.  \n-   Equations do not necessarily have variables.  \n-   Equations have exactly one operator (+ or -) between terms.  \n\nComparisons are performed with accuracy of `1e-6`.\n\n**Note on numerical stability:**\n\nThere are many possible ways to solve a system of linear equations. One group of such algorithms is based on reduction and elimination methods. If you are going to use any of these, remember that such algorithms are in general *numerically unstable*, i.e. division operations repeated over and over introduce inaccuracies which accumulate from row to row. As a result it might occur that some value which is expected to be zero is actually larger, for example, `2.5e-10`. Such inaccuracies tend to be bigger in large equation systems, and random tests check systems of up to 26 equations. If it happens that small tests pass for you, and large tests fail, it probably means that you did not account for inaccuracies correctly.\nAlso note that tests do not depend on any reference solution, so the way how test cases are generated _is numrically stable_ - the only source of inaccuracies is your solution, and you need to account for it.\n\n```if:python\n___Note for python users:___\n\n`numpy` module has been disabled, so that the task matches the one of the other languages. There is an anti-cheat measure about that, so you won't be able to import some other modules too (either way, you shouldn't need any module to solve this kata...)\n```\n-/", "vc-preamble": "def Term := String\n\ndef Equation := String\n\ndef Solution := List (String × Int)", "vc-helpers": "", "vc-definitions": "def solve_equations : List Equation → Option Solution :=\n  sorry\n\ndef equation_vars : Equation → List String :=\n  sorry\n\ndef solution_vars : Solution → List String :=\n  sorry\n\ndef verify_solution (equations : List Equation) (solution : Option Solution) : Bool :=\nsorry", "vc-theorems": "theorem solution_variables_match_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  ∀ v, (∃ eq ∈ equations, v ∈ equation_vars eq) ↔ v ∈ solution_vars s :=\nsorry\n\ntheorem underdetermined_system_no_solution :\n  solve_equations [\"x + y = 1\"] = none :=\nsorry\n\ntheorem solution_satisfies_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  verify_solution equations (some s) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_equations [\"2x + 4y + 6z = 18\", \"3y + 3z = 6\", \"x + 2y = z - 3\"]\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval solve_equations [\"x + y = 2\", \"x + y = 3\"]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_equations [\"x = 1\"]"}
{"id": "fvapps_001664", "vc-description": "/-\nGiven two different positions on a chess board, find the least number of moves it would take a knight to get from one to the other.\nThe positions will be passed as two arguments in algebraic notation.\nFor example, `knight(\"a3\", \"b5\")` should return 1.\n\nThe knight is not allowed to move off the board.\nThe board is 8x8.\n\nFor information on knight moves, see https://en.wikipedia.org/wiki/Knight_%28chess%29\n\nFor information on algebraic notation, see\nhttps://en.wikipedia.org/wiki/Algebraic_notation_%28chess%29\n\n(Warning: many of the tests were generated randomly. If any do not work, the test cases will return the input, output, and expected output; please post them.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Nat) : Nat :=\n  sorry\n\ndef isValidPos (pos : String) : Bool :=\n  sorry\n\ndef knight (s e : String) : Nat :=\n  sorry", "vc-theorems": "theorem knight_valid_range {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e) :\n  let m := knight s e\n  0 ≤ m ∧ m ≤ 6 :=\nsorry\n\ntheorem knight_same_position {p : String}\n  (h : isValidPos p) :\n  knight p p = 0 :=\nsorry\n\ntheorem knight_diagonal_adjacent {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e)\n  (h3 : abs ((s.get! ⟨0⟩).toNat - (e.get! ⟨0⟩).toNat) = 1)\n  (h4 : abs ((s.get! ⟨1⟩).toNat - (e.get! ⟨1⟩).toNat) = 1) :\n  knight s e = 2 :=\nsorry\n\ntheorem knight_symmetric {p t : String}\n  (h1 : isValidPos p) (h2 : isValidPos t) :\n  knight p t = knight t p :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval knight \"a3\" \"b5\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval knight \"a1\" \"c5\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval knight \"d5\" \"d5\""}
{"id": "fvapps_001667", "vc-description": "/-\n> \"7777...*8?!??!*\", exclaimed Bob, \"I missed it again!  Argh!\"  Every time there's an interesting number coming up, he notices and then promptly forgets.  Who *doesn't* like catching those one-off interesting mileage numbers?\n\nLet's make it so Bob **never** misses another interesting number.  We've hacked into his car's computer, and we have a box hooked up that reads mileage numbers.  We've got a box glued to his dash that lights up yellow or green depending on whether it receives a `1` or a `2` (respectively).\n\nIt's up to you, intrepid warrior, to glue the parts together.  Write the function that parses the mileage number input, and returns a `2` if the number is \"interesting\" (see below), a `1` if an interesting number occurs within the next two miles, or a `0` if the number is not interesting.\n\n**Note:** In Haskell, we use `No`, `Almost` and `Yes` instead of `0`, `1` and `2`.\n\n## \"Interesting\" Numbers\n\nInteresting numbers are 3-or-more digit numbers that meet one or more of the following criteria:\n\n```if-not:ruby,python\n* Any digit followed by all zeros: `100`, `90000`\n* Every digit is the same number: `1111`\n* The digits are sequential, incementing†: `1234`\n* The digits are sequential, decrementing‡: `4321`\n* The digits are a palindrome: `1221` or `73837`\n* The digits match one of the values in the `awesomePhrases` array\n```\n```if:ruby,python\n* Any digit followed by all zeros: `100`, `90000`\n* Every digit is the same number: `1111`\n* The digits are sequential, incementing†: `1234`\n* The digits are sequential, decrementing‡: `4321`\n* The digits are a palindrome: `1221` or `73837`\n* The digits match one of the values in the `awesome_phrases` array\n```\n\n> † For incrementing sequences, `0` should come after `9`, and not before  `1`, as in `7890`.\n> ‡ For decrementing sequences, `0` should come after `1`, and not before  `9`, as in `3210`.\n\nSo, you should expect these inputs and outputs:\n\n```python\n# \"boring\" numbers\nis_interesting(3, [1337, 256])    # 0\nis_interesting(3236, [1337, 256]) # 0\n\n# progress as we near an \"interesting\" number\nis_interesting(11207, []) # 0\nis_interesting(11208, []) # 0\nis_interesting(11209, []) # 1\nis_interesting(11210, []) # 1\nis_interesting(11211, []) # 2\n\n# nearing a provided \"awesome phrase\"\nis_interesting(1335, [1337, 256]) # 1\nis_interesting(1336, [1337, 256]) # 1\nis_interesting(1337, [1337, 256]) # 2\n```\n\n## Error Checking\n\n* A number is only interesting if it is greater than `99`!\n* Input will *always* be an integer greater than `0`, and less than `1,000,000,000`. \n* The `awesomePhrases` array will always be provided, and will always be an array, but may be empty.  (Not *everyone* thinks numbers spell funny words...)\n* You should only ever output `0`, `1`, or `2`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_interesting (number : Nat) (awesome_phrases : Array Nat) : Nat :=\n  sorry\n\ndef isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef isRoundNumber (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem is_interesting_result_valid (n : Nat) (phrases : Array Nat) :\n  let result := is_interesting n phrases\n  result = 0 ∨ result = 1 ∨ result = 2 :=\nsorry\n\ntheorem small_numbers_boring (n : Nat) (h : n < 98) :\n  is_interesting n #[] = 0 :=\nsorry\n\ntheorem awesome_phrases_direct_match (n : Nat) (phrases : Array Nat)\n  (h1 : n ≥ 100) (h2 : phrases.contains n = true) :\n  is_interesting n phrases = 2 :=\nsorry\n\ntheorem awesome_phrases_nearby_match (n : Nat) (phrases : Array Nat)\n  (h1 : n ≥ 98) (h2 : phrases.contains (n + 1) = true ∨ phrases.contains (n + 2) = true) :\n  is_interesting n phrases ≥ 1 :=\nsorry\n\ntheorem palindrome_direct_match (n : Nat) (h1 : n ≥ 100)\n  (h2 : isPalindrome n = true) :\n  is_interesting n #[] = 2 :=\nsorry\n\ntheorem palindrome_nearby_match (n : Nat) (h1 : n ≥ 98)\n  (h2 : isPalindrome (n + 1) = true ∨ isPalindrome (n + 2) = true)\n  (h3 : n + 1 ≥ 100 ∨ n + 2 ≥ 100) :\n  is_interesting n #[] ≥ 1 :=\nsorry\n\ntheorem incrementing_sequences (n : Nat)\n  (h : n = 123 ∨ n = 234 ∨ n = 345 ∨ n = 456 ∨ n = 567 ∨ n = 678 ∨ n = 789 ∨ n = 890) :\n  is_interesting n #[] = 2 :=\nsorry\n\ntheorem decrementing_sequences (n : Nat)\n  (h : n = 987 ∨ n = 876 ∨ n = 765 ∨ n = 654 ∨ n = 543 ∨ n = 432 ∨ n = 321) :\n  is_interesting n #[] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval is_interesting 3 #[1337, 256]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval is_interesting 1336 #[1337, 256]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval is_interesting 1000 #[1337, 256]"}
{"id": "fvapps_001674", "vc-description": "/-\n# Background\n\nThe famous Collatz Sequence is generated with the following rules:\n\n* Start with a positive integer `a[0] = n`.\n* If `a[i]` is even, `a[i+1] = a[i] / 2`.\n* Otherwise, `a[i+1] = a[i] * 3 + 1`.\n\nHowever, for the purpose of this Kata, I give a **slightly modified definition**:\n\n* If `a[i]` is even, `a[i+1] = a[i] / 2`. This step is a step-down, or `D`.\n* Otherwise, `a[i+1] = (a[i] * 3 + 1) / 2`. This step is a step-up, or `U`.\n\nAlso, for any starting number, the sequence is generated indefinitely, not ending at 1.\n\n# Problem Description\n\nFor any given starting number, we can record the types of steps(`D` or `U`) from it.\nFor example, if we start with the number 11, the Collatz steps look like this:\n```\na[0] = 11\na[1] = (11 * 3 + 1) / 2 = 17 -> U\na[2] = (17 * 3 + 1) / 2 = 26 -> U\na[3] = 26 / 2 = 13           -> D\na[4] = (13 * 3 + 1) / 2 = 20 -> U\na[5] = 20 / 2 = 10           -> D\na[6] = 10 / 2 = 5            -> D\na[7] = (5 * 3 + 1) / 2 = 8   -> U\na[8] = 8 / 2 = 4             -> D\na[9] = 4 / 2 = 2             -> D\na[10] = 2 / 2 = 1            -> D\na[11] = (1 * 3 + 1) / 2 = 2  -> U\na[12] = 2 / 2 = 1            -> D\n...\n```\n\n```\n11 -> 17 -> 26 -> 13 -> 20 -> 10 -> 5 -> 8 -> 4 -> 2 -> 1 -> 2 -> 1 -> ...\n   U     U     D     U     D     D    U    D    D    D    U    D\n```\n\nBased on the steps shown above, the first four Collatz steps of 11 is `UUDU`.\nAlso, 107 is the smallest number over 100 whose Collatz steps start with `UUDU`, and\n1003 is the smallest number over 1000 with the property.\n\nA special example is the number 1, which can generate any number of `UD`.\n\nFind the smallest integer exceeding or equal to `n` whose Collatz steps start with the given string `steps`.\n\n# Constraints\n\n`1 <= n <= 10 ** 9`\n\n`n` is always a valid integer.\n\n`1 <= length(steps) <= 25`\n\nThe string `steps` will entirely consist of `U`s and `D`s.\n\n# Examples\n\n```python\ncollatz_steps(1, 'UUDU') == 11\ncollatz_steps(100, 'UUDU') == 107\ncollatz_steps(1000, 'UUDU') == 1003\n\ncollatz_steps(1, 'UD') == 1\ncollatz_steps(1, 'UDUD') == 1\ncollatz_steps(1, 'UDUDUD') == 1\n```\n\n# Hint\n\nIf you are completely lost, start by answering the following question:\n\n* After applying the given steps (e.g. `UUDU`) to an initial number `x`,\n  what fraction do you get?\n\nAfter that, you might want to study about [modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse).\n\n# Acknowledgement\n\nThis problem was inspired by [Project Euler #277: A Modified Collatz sequence](https://projecteuler.net/problem=277).\n\nIf you enjoyed this Kata, please also have a look at [my other Katas](https://www.codewars.com/users/Bubbler/authored)!\n-/\n\n/- Base case properties -/\n\n/- Main invariant properties for any input -/\n\n/- Minimal result property -/\n\n/- Helper lemma to relate get_steps to collatz_steps -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def collatz_steps (n : Nat) (s : String) : Nat :=\n  sorry\n\ndef get_steps (n : Nat) (len : Nat) : String :=\n  sorry", "vc-theorems": "theorem collatz_steps_D : collatz_steps 1 \"D\" = 2 :=\nsorry\n\ntheorem collatz_steps_U : collatz_steps 1 \"U\" = 1 :=\nsorry\n\ntheorem collatz_steps_geq_input {n : Nat} {s : String} (h : n > 0) :\n  collatz_steps n s ≥ n :=\nsorry\n\ntheorem collatz_steps_minimal {n : Nat} {s : String} (h : n > 0) (h2 : collatz_steps n s > 1) :\n  ∀ m, m < collatz_steps n s → ¬(get_steps m (String.length s)).startsWith s :=\nsorry\n\ntheorem get_steps_matches {n : Nat} {s : String} (h : n > 0) :\n  (get_steps (collatz_steps n s) (String.length s)).startsWith s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001680", "vc-description": "/-\nA factorial (of a large number) will usually contain some trailing zeros.\nYour job is to make a function that calculates the number of trailing zeros, in any given base.\n\nFactorial is defined like this:\n```n! = 1 * 2 * 3 * 4 * ... * n-2 * n-1 * n```\n\nHere's two examples to get you started:\n\n```python\ntrailing_zeros(15, 10) == 3\n#15! = 1307674368000, which has 3 zeros at the end\n\ntrailing_zeros(7, 2) == 4\n#7! = 5030 = 0b1001110110000, which has 4 zeros at the end\n```\n\nYour code should be able to handle some very large numbers, so write some smart code.\n\nNote: ```num``` will be a non-negative integer, ```base``` will be an integer larger or equal to two.\n\nHINT: Should you not make any headway after trying a long time, you should try [this kata](https://www.codewars.com/kata/number-of-trailing-zeros-of-n) first.\n-/", "vc-preamble": "structure PrimeFactor where\n  prime : Nat\n  power : Nat", "vc-helpers": "", "vc-definitions": "def isqrt (n : Nat) : Nat :=\nsorry\n\ndef isPrime (p : Nat) : Bool :=\nsorry\n\ndef factorize (n : Nat) : List PrimeFactor :=\nsorry", "vc-theorems": "theorem isqrt_upper_bound (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  r * r ≤ n :=\nsorry\n\ntheorem isqrt_next_exceeds (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  (r + 1) * (r + 1) > n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval trailing_zeros 15 10\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval trailing_zeros 7 2\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval trailing_zeros 30 10"}
{"id": "fvapps_001681", "vc-description": "/-\nThe `mystery` function is defined over the non-negative integers. The more common name of this function is concealed in order to not tempt you to search the Web for help in solving this kata, which most definitely would be a very dishonorable thing to do.\n\nAssume `n` has `m` bits. Then `mystery(n)` is the number whose binary representation is the entry in the table `T(m)` at index position `n`, where `T(m)` is defined recursively as follows:\n\n```\nT(1) = [0, 1]\n```\n\n`T(m + 1)` is obtained by taking two copies of `T(m)`, reversing the second copy, prepending each entry of the first copy with `0` and each entry of the reversed copy with `1`, and then concatenating the two. For example:\n\n```\nT(2) = [ 00, 01, 11, 10 ]\n```\n\nand\n\n```\nT(3) = [ 000, 001, 011, 010, 110, 111, 101, 100 ]\n```\n\n`mystery(6)` is the entry in `T(3)` at index position 6 (with indexing starting at `0`), i.e., `101` interpreted as a binary number. So, `mystery(6)` returns `5`.\n\nYour mission is to implement the function `mystery`, where the argument may have up to 63 bits. Note that `T(63)` is far too large to compute and store, so you'll have to find an alternative way of implementing `mystery`. You are also asked to implement `mystery_inv` ( or `mysteryInv` ), the inverse of `mystery`. Finally, you are asked to implement a function `name_of_mystery` ( or `nameOfMystery` ), which shall return the name that `mystery` is more commonly known as. After passing all tests you are free to learn more about this function on Wikipedia or another place.\n\nHint: If you don't know the name of `mystery`, remember there is information in passing as well as failing a test.\n-/", "vc-preamble": "def name_of_mystery : String :=\n  \"Gray code\"", "vc-helpers": "", "vc-definitions": "def mystery (n : Nat) : Nat :=\n  sorry\n\ndef mystery_inv (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem mystery_inverse : ∀ n : Nat, n < 2^32 →\n  mystery (mystery_inv n) = n ∧ mystery_inv (mystery n) = n :=\nsorry\n\ntheorem mystery_preserves_non_negative : ∀ n : Nat,\n  mystery n ≥ 0 ∧ mystery_inv n ≥ 0 :=\nsorry\n\ntheorem mystery_bit_length : ∀ n : Nat, n < 2^16 →\n  n.log2 - (mystery n).log2 ≤ 1 ∧\n  n.log2 - (mystery_inv n).log2 ≤ 1 :=\nsorry\n\ntheorem mystery_name_is_gray_code :\n  name_of_mystery = \"Gray code\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval mystery 6\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval mystery_inv 5\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval mystery mystery_inv(10)\n\n/--\ninfo: 'Gray code'\n-/\n#guard_msgs in\n#eval name_of_mystery"}
{"id": "fvapps_001693", "vc-description": "/-\nAbove: An overhead view of the house in one of the tests. The green outline indicates the path taken by K\nA mouse named K has found a new home on Ash Tree Lane. K wants to know the size of the interior of the house (which consists of just one room). K is able to measure precise distances in any direction he runs. But K is wary of open spaces and will only run alongside walls, as mice tend to do. In this house the walls always connect at right angles.\nK's plan is to run alongside the walls, traversing the entire perimeter of the room, starting and ending at K's mousehole. K memorizes the path as an alternating sequence of distance traveled and directional turn. Your task is to write a function that will find the area of the house interior when given K's path.\nInput\n\nYour function will receive a string as an argument. The string will consist of turns (`L` or `R`, for `left` and `right`, respectively) and positive integers, in an alternating sequence. `L`/`R` represents the turn direction made by K, and the integers mark the number of distance units to move forward.\n\nOutput\n\nYour function should return an integer representing the area of the house, based on K's path. If K's path is not a valid path, return `null` or `None`.\n\nInvalid Paths\n\nA path is invalid if it meets any of the following criteria:\n- the path intersects/overlaps itself (with the exception of the mousehole when completing the loop); see examples of path fragments below\n- the path doesn't complete the loop back to the mousehole\n- the mousehole is located along the straight path of a wall (K's mousehole must be located at a convex/concave corner position to be valid)\n\nInvalidating overlap path fragment examples\n\n- Example A: Perpendicular intersection `...5L2L3L4...`\n- Example B: Point of overlap `...2L2R3R2R3L2...`\n- Example C: Parallel overlap `...4L2R2R3R4R1L2...`\n\nTest Example\n\nThe circled K and green arrow indicate the starting position and direction as given in the example test below\n\n```python\nmouse_path('4R2L1R5R9R4R4L3') # 49\n```\n\nAdditional Details\n\n- K's path will always consist of fewer than `500` turns\n- The area of the house (when valid) will always be less than `2**32`\n- Full Test Suite: `12` fixed tests and `150` random tests\n- Use Python 3+ for the Python translation\n- For JavaScript, most built-in prototypes are frozen, except `Array` and `Function`\n- All inputs will be of valid type and pattern (that is, it will alternate between distance moved and directional turn)\n- NOTE: the random test generator may, on very rare occasions, throw an error (around 0.01% of the time, based on my observation); if you get an error pointing to the random test function, try running your solution again.\n- This kata was inspired by [Kafka](https://en.wikipedia.org/wiki/A_Little_Fable) and [Danielewski](https://en.wikipedia.org/wiki/House_of_Leaves)\n\nIf you enjoyed this kata, be sure to check out my other katas\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mouse_path (s : String) : Option Nat :=\nsorry\n\ndef check_corner (orientations : List Char) : Bool :=\nsorry\n\ndef check_intersect (rectas : List ((Int × Int) × (Int × Int))) : Bool :=\nsorry\n\ndef calc_area (points : List (Int × Int)) : Nat :=\nsorry\n\ndef add_point (direction : Char) (distance : Nat) (points : List (Int × Int)) : List (Int × Int) :=\nsorry", "vc-theorems": "theorem mouse_path_returns_none_or_natural (s : String) :\n  match mouse_path s with\n  | none => True\n  | some n => n ≥ 0\n  :=\nsorry\n\ntheorem check_corner_single_orientation {o : Char} (orientations : List Char) :\n  (∀ x ∈ orientations, x = o) → check_corner orientations = false :=\nsorry\n\ntheorem check_intersect_symmetry (rectas : List ((Int × Int) × (Int × Int))) :\n  check_intersect rectas = check_intersect rectas.reverse :=\nsorry\n\ntheorem calc_area_nonnegative (points : List (Int × Int)) :\n  calc_area points ≥ 0 :=\nsorry\n\ntheorem add_point_preserves_coordinate (direction : Char) (distance : Nat) (points : List (Int × Int)) :\n  let newPoints := add_point direction distance [(0,0)]\n  (direction = 'N' ∨ direction = 'S') →\n    (newPoints.get! 0).1 = (newPoints.get! 1).1 ∧\n  (direction = 'E' ∨ direction = 'O') →\n    (newPoints.get! 0).2 = (newPoints.get! 1).2\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 49\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5R9R4R4L3\"\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5\"\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"2R2R2L2L\""}
{"id": "fvapps_001694", "vc-description": "/-\nIn this kata you must determine the lowest floor in a building from which you cannot drop an egg without it breaking. You may assume that all eggs are the same; if one egg breaks when dropped from floor `n`, all eggs will. If an egg survives a drop from some floor, it will survive a drop from any floor below too. \n\nYou are given `num_eggs` eggs and are allowed to make a maximum of `num_drops` drops. If an egg does not break when dropped, it may be reused. You may assume that it is feasible to determine the floor with the given number of eggs and drops.\n\nExample 1: \nYou are given 1 egg and 10 drops. You start by dropping the egg from the first floor (floor numbering starts at 1). If it breaks, the answer is 1. If it does not break, you drop it from the second floor. If it breaks, the answer is 2. Otherwise you continue in the same manner until you reach a floor where the egg breaks. You may assume that you will reach that floor before you have exhausted your drops (i.e., in this example, the egg will break when dropped from floor 10 or lower).\n\nExample 2: You are given 2 eggs and 10 drops. The highest floor for which this problem has a solution is floor 55, so you may assume that the answer is floor 55 or a lower floor. You will have to determine how the number 55 is derived and generalize it for any number of eggs and drops.\n\nTo solve this problem, you need to write a function `solve` that takes an argument `emulator` and returns the lowest floor from which an egg will break if dropped. The `emulator` object has the following properties and method which you may invoke:\n\n  1. `emulator.eggs` returns the number of eggs you have left. You may use this property to detemine the number of eggs you are given initially.\n  2. `emulator.drops` returns the the number of drops you have left. You may use this property to detemine the number of drops you are given initially.\n  3. `emulator.drop(n)` returns `True` if an egg dropped from floor `n` breaks and `False` if it does not break. The number of times that you may invoke this method is limited to the number of drops you were given. If invoked after no drops are left, it will throw an exception. Same happens if you invoke this method after all your eggs are broken. \n\nYou are not allowed to access any other method or state attribute of the `emulator` object, even if you can. This is considered cheating and is a very dishonorable thing to do! Note that `emulator.__dict__` has been disabled. \n\nNote: [This kata](http://www.codewars.com/kata/faberge-easter-eggs-crush-test) is similar although not the same.\n-/", "vc-preamble": "def TestEmulator := Nat × Nat × Nat", "vc-helpers": "", "vc-definitions": "def height (n m : Nat) : Nat :=\nsorry\n\ndef solve (e : TestEmulator) : Nat :=\nsorry", "vc-theorems": "theorem height_nonnegative (n m : Nat) :\n  height n m ≥ 0 :=\nsorry\n\ntheorem height_when_n_geq_m (n m : Nat) :\n  n ≥ m → height n m = 2^m - 1 :=\nsorry\n\ntheorem solve_bounded_by_break_floor (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  solve (eggs, drops, break_floor) ≤ break_floor :=\nsorry\n\ntheorem solve_positive (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  solve (eggs, drops, break_floor) > 0 :=\nsorry\n\ntheorem solve_respects_constraints (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 0 →\n  let e := (eggs, drops, break_floor)\n  solve e ≤ eggs ∧ solve e ≤ drops :=\nsorry\n\ntheorem emulator_below_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 0 → break_floor > 1 →\n  solve (eggs, drops - 1, break_floor - 1) = 0 :=\nsorry\n\ntheorem emulator_at_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 → drops > 1 → break_floor > 0 →\n  solve (eggs - 1, drops - 2, break_floor) > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve TestEmulator(1, 10, 5)\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval solve TestEmulator(2, 10, 20)\n\n/--\ninfo: 55\n-/\n#guard_msgs in\n#eval solve TestEmulator(3, 14, 55)"}
{"id": "fvapps_001696", "vc-description": "/-\n#SKRZAT\n\nGeek Challenge [SKRZAT] is an old, old game from Poland that uses a game console with two buttons plus a joy stick. As is true to its name, the game communicates in binary, so that one button represents a zero and the other a one. Even more true to its name, the game chooses to communicate so that the base of the number system is minus two, not plus two, so we'll call this representation \"Weird Binary\". Thus the bit positions label the powers of minus two, as seen in the following five-bit tables:\n\n    | ------------------------------------------------------------------------- |\n    |  Bits  |  Value  |  Bits  |  Value  |  Bits  |  Value  |  Bits  |  Value  |\n    | ------ | ------- | ------ | ------- | ------ | ------- | ------ | ------- |\n    | 00000  |    0    | 01000  |    -8   | 10000  |    16   | 11000  |    8    |\n    | 00001  |    1    | 01001  |    -7   | 10001  |    17   | 11001  |    9    |\n    | 00010  |   -2    | 01010  |   -10   | 10010  |    14   | 11010  |    6    |\n    | 00011  |   -1    | 01011  |    -9   | 10011  |    15   | 11011  |    7    |\n    | 00100  |    4    | 01100  |    -4   | 10100  |    20   | 11100  |    12   |\n    | 00101  |    5    | 01101  |    -3   | 10101  |    21   | 11101  |    13   |\n    | 00110  |    2    | 01110  |    -6   | 10110  |    18   | 11110  |    10   |\n    | 00111  |    3    | 01111  |    -5   | 10111  |    19   | 11111  |    11   |\n    | ------------------------------------------------------------------------- |\n\n    | ------------------------------------------------------------------------- |\n    |  Bits  |  Value  |  Bits  |  Value  |  Bits  |  Value  |  Bits  |  Value  |\n    | ------ | ------- | ------ | ------- | ------ | ------- | ------ | ------- |\n    | 01010  |   -10   | 00010  |    -2   | 11010  |    6    | 10010  |    14   |\n    | 01011  |    -9   | 00011  |    -1   | 11011  |    7    | 10011  |    15   |\n    | 01000  |    -8   | 00000  |    0    | 11000  |    8    | 10000  |    16   |\n    | 01001  |    -7   | 00001  |    1    | 11001  |    9    | 10001  |    17   |\n    | 01110  |    -6   | 00110  |    2    | 11110  |    10   | 10110  |    18   |\n    | 01111  |    -5   | 00111  |    3    | 11111  |    11   | 10111  |    19   |\n    | 01100  |    -4   | 00100  |    4    | 11100  |    12   | 10100  |    20   |\n    | 01101  |    -3   | 00101  |    5    | 11101  |    13   | 10101  |    21   |\n    | ------------------------------------------------------------------------- |\n\nNumbers are presented on the screen in Weird Binary, and then numbers are accepted in response from the console as a stream of zeroes and ones, terminated by a five-second pause.  You are writing a computer program to support the novice geek in playing the game by translating numbers between decimal and Weird Binary.\n\n#Input\n\nThe `skrzat` function will either convert into Weird Binary or out of Weird Binary: The first parameter will be either the letter `\"b\"`, which indicates that the second parameter is written in Weird Binary and needs to be converted to decimal; the letter `\"d\"` indicates that the second parameter is a decimal and needs to be converted to Weird Binary.  The second parameter will be in the range to fit within a 15-bit Weird Binary number, which represents the decimal number range -10922 to 21845, inclusive.\n\n#Output\n\nFor each conversion problem, return the type of problem, its input string, and the converted result in the format shown below, replicating even the spacing exactly as shown. Leading zeroes are not allowed.\n\nreturn format: `'From {binary || decimal}: {non-converted value} is {converted value}'`\n\n#Sample Input\n\n    skrzat('b', '1001101')\n    skrzat('b', '0111111')\n    skrzat('b', '101001000100001')\n    skrzat('b', '010010001000010')\n    skrzat('b', '100110100110100')\n    skrzat('d', -137)\n    skrzat('d', 137)\n    skrzat('d', 8191)\n    skrzat('d', -10000)\n    skrzat('d', 21000)\n\n#Sample Output\n\n    'From binary: 1001101 is 61'\n    'From binary: 0111111 is -21'\n    'From binary: 101001000100001 is 19937'\n    'From binary: 010010001000010 is -7106'\n    'From binary: 100110100110100 is 15604'\n    'From decimal: -137 is 10001011'\n    'From decimal: 137 is 110011001'\n    'From decimal: 8191 is 110000000000011'\n    'From decimal: -10000 is 10100100110000'\n    'From decimal: 21000 is 101011000011000'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def b (n : Int) : String :=\nsorry\n\ndef d (s : String) : Int :=\nsorry\n\ndef skrzat (mode : String) (input : Int ⊕ String) : String :=\nsorry\n\ndef is_valid_binary (s : String) : Bool :=\nsorry", "vc-theorems": "theorem bidirectional_conversion : ∀ (n : Int),\n  let bin := b n; d bin = n :=\nsorry\n\ntheorem binary_valid : ∀ (n : Int),\n  is_valid_binary (b n) = true :=\nsorry\n\ntheorem skrzat_binary_format : ∀ (binary : String),\n  is_valid_binary binary = true →\n  ∃ n : Int, skrzat \"b\" (Sum.inr binary) = s!\"From binary: {binary} is {n}\" :=\nsorry\n\ntheorem skrzat_decimal_format : ∀ (decimal : Int),\n  ∃ binary : String,\n    skrzat \"d\" (Sum.inl decimal) = s!\"From decimal: {decimal} is {binary}\" ∧\n    is_valid_binary binary = true :=\nsorry\n\ntheorem skrzat_invalid_base : ∀ (input : Int ⊕ String),\n  skrzat \"x\" input ≠ skrzat \"d\" input ∧ skrzat \"x\" input ≠ skrzat \"b\" input :=\nsorry\n\ntheorem positive_conversion : ∀ (n : Int),\n  n ≥ 0 →\n  let bin := b n\n  ¬bin.startsWith \"-\" ∧ d bin = n :=\nsorry\n\ntheorem zero_negative_conversion : ∀ (n : Int),\n  n ≤ 0 →\n  let bin := b n\n  d bin = n :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'From binary: 1001101 is 61'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"1001101\"\n\n/--\ninfo: 'From binary: 0111111 is -21'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"0111111\"\n\n/--\ninfo: 'From binary: 101001000100001 is 19937'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"101001000100001\"\n\n/--\ninfo: 'From decimal: -137 is 10001011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" -137\n\n/--\ninfo: 'From decimal: 137 is 110011001'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 137\n\n/--\ninfo: 'From decimal: 8191 is 110000000000011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 8191"}
{"id": "fvapps_001699", "vc-description": "/-\nThe professional Russian, Dmitri, from the popular youtube channel FPSRussia has hired you to help him move his arms cache between locations without detection by the authorities.  Your job is to write a Shortest Path First (SPF) algorithm that will provide a route with the shortest possible travel time between waypoints, which will minimize the chances of detection.  One exception is that you can't travel through the same waypoint twice.  Once you've been seen there is a higher chance of detection if you travel through that waypoint a second time.\n\nYour function shortestPath will take three inputs, a topology/map of the environment, along with a starting point, and an ending point.  The topology will be a dictionary with the keys being the different waypoints.  The values of each entry will be another dictionary with the keys being the adjacent waypoints, and the values being the time it takes to travel to that waypoint.\n\nTake the following topology as an example:\n\n     topology = {'a' : {'b': 10, 'c': 20},\n                 'b' : {'a': 10, 'c': 20},\n                 'c' : {'a': 10, 'b': 20} }\n\nIn this example, waypoint 'a' has two adjacent waypoints, 'b' and 'c'.  And the time it takes to travel from 'a' to 'b' is 10 minutes, and from 'a' to 'c' is 20 minutes.  It's important to note that the time between these waypoints is one way travel time and can be different in opposite directions.  This is highlighted in the example above where a->c takes 20 minutes, but c->a takes 10 minutes.\n\nThe starting and ending points will passed to your function as single character strings such as 'a' or 'b', which will match a key in your topology.\n\nThe return value should be in the form of a list of lists of waypoints that make up the shortest travel time.  If there multiple paths that have equal travel time, then you should choose the path with the least number of waypoints.  If there are still multiple paths with equal travel time and number of waypoints, then you should return a list of lists with the multiple options. For multiple solutions, the list of paths should be sorted in lexicographic (alphabetical) order. If there is only one shortest path, you should still return a list of that list.\n\nHere are a few examples:\n    #Topology\n    #      b--d--g   \n    #     /   |   \\  \n    #    /    |    \\ \n    #   a-----e     h\n    #    \\     \\   / \n    #     \\     \\ /  \n    #      c-----f  \n    topology = {'a' : {'b': 10, 'c': 20, 'e':20},\n                'b' : {'a': 10, 'd': 20},\n                'c' : {'a': 10, 'f': 20},\n                'd' : {'b': 10, 'e': 20, 'g': 20},\n                'e' : {'a': 10, 'd': 20, 'f': 20},                      \n                'f' : {'c': 10, 'e': 20, 'h': 20},\n                'g' : {'d': 10, 'h': 20},\n                'h' : {'g': 10, 'f': 20},\n    }\n\n    Two solutions with a time of 40:\n    shortestPath(topology, 'a', 'f') == [['a', 'c', 'f'], ['a', 'e', 'f']] \n\n    One solution with a time of 20:\n    shortestPath(topology, 'a', 'e') == [['a', 'e']]\n-/", "vc-preamble": "def List.noDuplicates (path : List Char) : Prop :=\n  ∀ (x : Char), (List.count x path) ≤ 1\n\ndef List.isSorted (xs : List (List Char)) : Prop :=\n  ∀ i j (h1 : i < j) (h2 : j < xs.length), (xs.get ⟨i, Nat.lt_trans h1 h2⟩) ≤ (xs.get ⟨j, h2⟩)\n\ndef Topology := Char → Char → Option Nat", "vc-helpers": "", "vc-definitions": "def shortestPath (G : Topology) (s e : Char) : List (List Char) :=\nsorry", "vc-theorems": "theorem shortestPath_valid_paths {G : Topology} {s e : Char}\n  (path : List Char) (h : path ∈ shortestPath G s e) :\n    path.head? = some s ∧\n    path.getLast? = some e ∧\n    path.noDuplicates :=\nsorry\n\ntheorem shortestPath_equal_length {G : Topology} {s e : Char}\n  (p1 p2 : List Char) (h1 : p1 ∈ shortestPath G s e) (h2 : p2 ∈ shortestPath G s e) :\n    p1.length = p2.length :=\nsorry\n\ntheorem shortestPath_sorted {G : Topology} {s e : Char} :\n  (shortestPath G s e).isSorted :=\nsorry\n\ntheorem shortestPath_connected {G : Topology} {s e : Char}\n  (path : List Char) (h : path ∈ shortestPath G s e) :\n  ∀ i, i < path.length - 1 →\n    ∃ h : i < path.length, ∃ h' : i + 1 < path.length,\n      (G (path.get ⟨i, h⟩) (path.get ⟨i+1, h'⟩)).isSome :=\nsorry\n\ntheorem shortestPath_disconnected {G : Topology} {s e : Char}\n  (h_disconnected : ∀ c, (G s c).isNone) :\n  shortestPath G s e = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [['a', 'c', 'f'], ['a', 'e', 'f']]\n-/\n#guard_msgs in\n#eval shortestPath {\"a\": {\"b\": 10, \"c\": 20, \"e\": 20}, \"b\": {\"a\": 10, \"d\": 20}, \"c\": {\"a\": 10, \"f\": 20}, \"d\": {\"b\": 10, \"e\": 20, \"g\": 20}, \"e\": {\"a\": 10, \"d\": 20, \"f\": 20}, \"f\": {\"c\": 10, \"e\": 20, \"h\": 20}, \"g\": {\"d\": 10, \"h\": 20}, \"h\": {\"g\": 10, \"f\": 20}} \"a\" \"f\"\n\n/--\ninfo: [['a', 'e']]\n-/\n#guard_msgs in\n#eval shortestPath topology1 \"a\" \"e\"\n\n/--\ninfo: [['a', 'c']]\n-/\n#guard_msgs in\n#eval shortestPath {\"a\": {\"b\": 10, \"c\": 20}, \"b\": {\"a\": 10, \"c\": 20}, \"c\": {\"a\": 10, \"b\": 20}} \"a\" \"c\""}
{"id": "fvapps_001700", "vc-description": "/-\n## Task\n\nYou are at position `[0, 0]` in maze NxN and you can **only** move in one of the four cardinal directions (i.e. North, East, South, West). Return the minimal number of steps to exit position `[N-1, N-1]` *if* it is possible to reach the exit from the starting position.  Otherwise, return `false` in **JavaScript**/**Python** and `-1` in **C++**/**C#**/**Java**.\n\nEmpty positions are marked `.`.  Walls are marked `W`.  Start and exit positions are guaranteed to be empty in all test cases.\n\n## Path Finder Series:\n\n-       [#1: can you reach the exit?](https://www.codewars.com/kata/5765870e190b1472ec0022a2)\n-       [#2: shortest path](https://www.codewars.com/kata/57658bfa28ed87ecfa00058a)\n-       [#3: the Alpinist](https://www.codewars.com/kata/576986639772456f6f00030c)\n-       [#4: where are you?](https://www.codewars.com/kata/5a0573c446d8435b8e00009f)\n-       [#5: there's someone here](https://www.codewars.com/kata/5a05969cba2a14e541000129)\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Any valid path length must be non-negative -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pathFinder (maze : String) : Option Nat :=\nsorry", "vc-theorems": "theorem path_finder_result_exists (maze : String) :\n  ∃ (result : Option Nat), pathFinder maze = result := by\nsorry\n\ntheorem path_finder_empty_path :\n  pathFinder \"...\\n...\\n...\" ≠ none := by\nsorry\n\ntheorem path_finder_blocked_two_by_two :\n  pathFinder \"W.\\n.W\" = none := by\nsorry\n\ntheorem path_finder_all_blocked_except_ends :\n  pathFinder \".WW\\nWWW\\nWW.\" = none := by\nsorry\n\ntheorem path_finder_positive_length (maze : String) (n : Nat) :\n  pathFinder maze = some n → n > 0 := by\nsorry", "vc-postamble": "/--\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    ...\".replace(\"    \", \"\")\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    .W.\".replace(\"    \", \"\")\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \"...\\n    ...\\n    ...\".replace(\"    \", \"\")"}
{"id": "fvapps_001703", "vc-description": "/-\n### Sudoku Background\n\nSudoku is a game played on a 9x9 grid. The goal of the game is to fill all cells of the grid with digits from 1 to 9, so that each column, each row, and each of the nine 3x3 sub-grids (also known as blocks) contain all of the digits from 1 to 9. \n(More info at: http://en.wikipedia.org/wiki/Sudoku)\n\n### Sudoku Solution Validator\n\nWrite a function `validSolution`/`ValidateSolution`/`valid_solution()` that accepts a 2D array representing a Sudoku board, and returns true if it is a valid solution, or false otherwise. The cells of the sudoku board may also contain 0's, which will represent empty cells. Boards containing one or more zeroes are considered to be invalid solutions.\n\nThe board is always 9 cells by 9 cells, and every cell only contains integers from 0 to 9.\n\n### Examples\n\n```\nvalidSolution([\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9]\n]); // => true\n```\n\n```\nvalidSolution([\n  [5, 3, 4, 6, 7, 8, 9, 1, 2], \n  [6, 7, 2, 1, 9, 0, 3, 4, 8],\n  [1, 0, 0, 3, 4, 2, 5, 6, 0],\n  [8, 5, 9, 7, 6, 1, 0, 2, 0],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 0, 1, 5, 3, 7, 2, 1, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 0, 0, 4, 8, 1, 1, 7, 9]\n]); // => false\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_solution (board : List (List Nat)) : Bool :=\nsorry\n\ndef check_unique_1_to_9 (arr : List Nat) : Bool :=\nsorry\n\ndef get_box_elements (board : List (List Nat)) (box_i box_j : Nat) : List Nat :=\nsorry\n\ndef get_column (board : List (List Nat)) (j : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem valid_grid_properties (board : List (List Nat)) :\n  (∀ row ∈ board, check_unique_1_to_9 row) ∧\n  (∀ j, 0 ≤ j ∧ j < 9 → check_unique_1_to_9 (get_column board j)) ∧\n  (∀ i j, 0 ≤ i ∧ i < 3 ∧ 0 ≤ j ∧ j < 3 →\n    check_unique_1_to_9 (get_box_elements board (3*i) (3*j)))\n  → valid_solution board :=\nsorry\n\ntheorem invalid_numbers (board : List (List Nat)) :\n  (∃ row ∈ board, ∃ x ∈ row, x < 1 ∨ x > 9) →\n  ¬ valid_solution board :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 8], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]"}
{"id": "fvapps_001704", "vc-description": "/-\n# Task\n\n Your task is to create a `Funnel` data structure. It consists of three basic methods: `fill()`, `drip()` and `toString()/to_s/__str__`. Its maximum capacity is 15 data.\n\n Data should be arranged in an inverted triangle, like this:\n ```\n \\1 2 3 4 5/\n  \\7 8 9 0/\n   \\4 5 6/\n    \\2 3/\n     \\1/\n ```\n The string method should return a multi-line string to display current funnel data arrangement:\n   ```python\n funnel = Funnel()\n print(funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      \\ /\n```\n\n The method `fill()` should accept one or more arguments to fill in the funnel:\n\n  ```python\n funnel = Funnel()\n funnel.fill(1)\n print (funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      \\1/\n funnel.fill(2)\n print (funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\2  /\n      \\1/\n funnel.fill(3)\n print (funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\2 3/\n      \\1/\n funnel.fill(4,5)\n print (funnel)\n  \\         /\n   \\       /\n    \\4 5  /\n     \\2 3/\n      \\1/\n funnel.fill(6,7,8,9)\n print(funnel)\n  \\         /\n   \\7 8 9  /\n    \\4 5 6/\n     \\2 3/\n      \\1/\n ```\n  In each row, `fill()` always fill data from left to right.\n\n The method `drip()` should drip the bottom value out of funnel and returns this value:\n   ```python\n (continue the example above)\n v = funnel.drip()\n print(v)\n 1\n print(funnel)\n  \\         /\n   \\  8 9  /\n    \\7 5 6/\n     \\4 3/\n      \\2/\n ```\n\nAs you can see, the bottom 1 was dripping out. The number above it will fill it's place. The rules to fill are: Select one of the two numbers above it, which bear the \"weight\" of relatively large. In other words, there are more numbers on this number. Is this a bit hard to understand? Please see the following:\n\n```\n In the example above, before the execution of drip(), funnel is:\n  \\         /\n   \\7 8 9  /\n    \\4 5 6/\n     \\2 3/\n      \\1/\n ```\n * After drip(), 1 will be dripped out. \n * We should choose a number between 2 and 3 to fill the place of 1.\n * 2 has 5 numbers on it(4,5,7,8,9). 3 has 4 numbers on it(5,6,8,9)\n * So we choose 2 to fill the place of 1\n * And now, the place of 2 is empty. \n * We also need choose a number between 4 and 5 to fill the place of 2.\n * 4 has 2 numbers on it(7,8). 5 has 2 numbers on it too(8,9)\n * There are same \"weight\" on 4 and 5, \n * In this case, we choose the number on the left\n * So we choose 4 to fill the place of 2\n * And then choose 7 to fill the place of 4\n\nLet us continue to `drip()`:\n\n   ```python\n funnel.drip()\n print(funnel)\n  \\         /\n   \\    9  /\n    \\7 8 6/\n     \\5 3/\n      \\4/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\7 9 6/\n     \\8 3/\n      \\5/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\  9 6/\n     \\7 3/\n      \\8/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\    6/\n     \\7 9/\n      \\3/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\7 6/\n      \\9/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\  6/\n      \\7/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      \\6/\n\n funnel.drip()\n print(funnel)\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      \\ /\n ```\n\n When the funnel is empty, drip() will return `null/nil/None`\n\n Another edge case is: When funnel is full, fill() will not change the funnel.\n\n A bit complex...\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_single_digit_addition (n : Nat) : Nat :=\nsorry\n\ndef compute_running_sum : Nat → Nat\n  | x => if x < 10 then x\n         else compute_running_sum (solve_single_digit_addition x)\ntermination_by x => x\ndecreasing_by all_goals simp_wf; sorry", "vc-theorems": "theorem result_is_single_digit (n : Nat) :\n  solve_single_digit_addition n ≤ 9 :=\nsorry\n\ntheorem result_equals_sum_of_digits (n : Nat) :\n  let result := solve_single_digit_addition n\n  let digit_sum := solve_single_digit_addition result\n  result = digit_sum :=\nsorry\n\ntheorem idempotent (n : Nat) :\n  let first_result := solve_single_digit_addition n\n  let second_result := solve_single_digit_addition first_result\n  first_result = second_result :=\nsorry\n\ntheorem equals_recursive_digit_sum (n : Nat) :\n  solve_single_digit_addition n = compute_running_sum n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001709", "vc-description": "/-\nWrite a function which makes a list of strings representing all of the ways you can balance `n` pairs of parentheses\n\n### Examples\n\n```python\nbalanced_parens(0) => [\"\"]\nbalanced_parens(1) => [\"()\"]\nbalanced_parens(2) => [\"()()\",\"(())\"]\nbalanced_parens(3) => [\"()()()\",\"(())()\",\"()(())\",\"(()())\",\"((()))\"]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isBalanced (s : String) : Bool :=\nsorry\n\ndef balancedParens (n : Nat) : List String :=\nsorry\n\ndef catalan (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem balanced_parens_output_is_balanced (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, isBalanced s = true :=\nsorry\n\ntheorem balanced_parens_length (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, s.length = 2 * n :=\nsorry\n\ntheorem balanced_parens_unique (n : Nat) (h : n ≤ 5) :\n  (balancedParens n).Nodup :=\nsorry\n\ntheorem balanced_parens_only_parens (n : Nat) (h : n ≤ 5) :\n  ∀ s ∈ balancedParens n, ∀ c ∈ s.toList, c = '(' ∨ c = ')' :=\nsorry\n\ntheorem balanced_parens_catalan (n : Nat) (h : n ≤ 5) :\n  (balancedParens n).length = catalan n :=\nsorry\n\ntheorem balanced_parens_non_negative (n : Int) :\n  n ≥ 0 → ∃ (l : List String), l = balancedParens n.toNat :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: ['']\n-/\n#guard_msgs in\n#eval balanced_parens 0\n\n/--\ninfo: ['()']\n-/\n#guard_msgs in\n#eval balanced_parens 1\n\n/--\ninfo: ['(())', '()()']\n-/\n#guard_msgs in\n#eval balanced_parens 2\n\n/--\ninfo: ['((()))', '(()())', '(())()', '()(())', '()()()']\n-/\n#guard_msgs in\n#eval balanced_parens 3"}
{"id": "fvapps_001713", "vc-description": "/-\nA famous casino is suddenly faced with a sharp decline of their revenues. They decide to offer Texas hold'em also online. Can you help them by writing an algorithm that can rank poker hands? \n\nTask:\n\nCreate a poker hand that has a constructor that accepts a string containing 5 cards:\n\n```python\nhand = PokerHand(\"KS 2H 5C JD TD\")\n```\n\nThe characteristics of the string of cards are:\n\nA space is used as card seperator\nEach card consists of two characters\nThe first character is the value of the card, valid characters are:\n`2, 3, 4, 5, 6, 7, 8, 9, T(en), J(ack), Q(ueen), K(ing), A(ce)`\nThe second character represents the suit, valid characters are: \n`S(pades), H(earts), D(iamonds), C(lubs)`\n\nThe poker hands must be sortable by rank, the highest rank first:\n\n```python\nhands = []\nhands.append(PokerHand(\"KS 2H 5C JD TD\"))\nhands.append(PokerHand(\"2C 3C AC 4C 5C\"))\nhands.sort() (or sorted(hands))\n```\n\nApply the Texas Hold'em rules for ranking the cards. \nThere is no ranking for the suits.\nAn ace can either rank high or rank low in a straight or straight flush. Example of a straight with a low ace:\n`\"5C 4D 3C 2S AS\"`\n\nNote:  there are around 25000 random tests, so keep an eye on performances.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "def VALID_VALUES := ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n\ndef VALID_SUITS := ['S', 'H', 'D', 'C']\n\nstructure Card where\n  value : Char\n  suit : Char\n  deriving Repr\n\nstructure Hand where\n  cards : List Card\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def Hand.maxCount (h : Hand) : Nat :=\nsorry\n\ndef Hand.maxCard (h : Hand) : Char :=\nsorry\n\ndef Hand.remaining (h : Hand) : List Char :=\nsorry\n\ndef Hand.isFlush (h : Hand) : Bool :=\nsorry\n\ndef Hand.isStraight (h : Hand) : Bool :=\nsorry\n\ndef Hand.gt (h1 h2 : Hand) : Bool :=\nsorry", "vc-theorems": "theorem hand_initialization (cards : List Card) (h : Hand) :\n  cards.length = 5 ∧\n  ∀ c ∈ cards, c.value ∈ VALID_VALUES ∧ c.suit ∈ VALID_SUITS :=\nsorry\n\ntheorem hand_properties (h : Hand) :\n  1 ≤ h.maxCount ∧ h.maxCount ≤ 4 ∧\n  h.maxCard ∈ VALID_VALUES ∧\n  ∀ r ∈ h.remaining, r ∈ VALID_VALUES :=\nsorry\n\ntheorem hand_comparison_reflexive (h : Hand) :\n  ¬(Hand.gt h h) :=\nsorry\n\ntheorem hand_comparison_antisymmetric (h1 h2 : Hand) :\n  Hand.gt h1 h2 → ¬(Hand.gt h2 h1) :=\nsorry\n\ntheorem hand_comparison_transitive (h1 h2 : Hand) :\n  h1 = h2 → ¬(Hand.gt h1 h2) ∧ ¬(Hand.gt h2 h1) :=\nsorry\n\ntheorem straight_flush_beats_others (h : Hand) :\n  ¬(h.isStraight ∧ h.isFlush) →\n  Hand.gt (Hand.mk [\n    {value := 'A', suit := 'S'},\n    {value := 'K', suit := 'S'},\n    {value := 'Q', suit := 'S'},\n    {value := 'J', suit := 'S'},\n    {value := 'T', suit := 'S'}\n  ]) h :=\nsorry\n\ntheorem flush_consistency (h : Hand) :\n  h.isFlush → List.length (List.map Card.suit h.cards) = 5 ∧\n  ∀ (c1 c2 : Card), c1 ∈ h.cards → c2 ∈ h.cards → c1.suit = c2.suit :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001716", "vc-description": "/-\nLet's say you have a bunch of points, and you want to round them all up and calculate the area of the smallest polygon containing all of the points (nevermind why, you just want a challenge). What you're looking for is the area of the *convex hull* of these points. Here is an example, delimited in blue :\n\n## Your task\n\nImplement a function that will compute the area covered by the convex hull that can be formed from an array of points, the area being rounded to two decimal places. The points are given as `(x,y)`, like in an orthonormal coordinates system.\n\n```python\npoints = [(0, 0), (0, 3), (4, 0)]\nconvex_hull_area(points) == 6.00\n```\n\n*Note* : In Python, the scipy module has a [ready made solution](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.ConvexHull.html) for this. Of course, if you use it here, you are lame.\n\n*P. S.* : If you enjoy this kata, you may also like this one, which asks you to compute a convex hull, without finding its area.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Point := Float × Float\n\ndef convex_hull_area (points : List Point) : Float :=\n  sorry\n\ndef is_internal_point (p : Point) (points : List Point) : Prop :=\n  sorry", "vc-theorems": "theorem convex_hull_area_non_negative (points : List Point) :\n  convex_hull_area points ≥ 0 :=\nsorry\n\ntheorem convex_hull_area_less_than_three_points (points : List Point) :\n  points.length < 3 → convex_hull_area points = 0 :=\nsorry\n\ntheorem convex_hull_area_permutation_invariant {points perm : List Point} :\n  points.length > 0 →\n  points.Perm perm →\n  convex_hull_area points = convex_hull_area perm :=\nsorry\n\ntheorem convex_hull_area_internal_points {points : List Point} {p : Point} :\n  points.length ≥ 3 →\n  is_internal_point p points →\n  convex_hull_area (p::points) = convex_hull_area points :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0)]\n\n/--\ninfo: 4.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 2), (2, 2), (2, 0)]\n\n/--\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0), (1, 1), (2, 1)]"}
{"id": "fvapps_001718", "vc-description": "/-\nThis kata explores writing an AI for a two player, turn based game called *NIM*.\n\nThe Board\n--------------\n\nThe board starts out with several piles of straw.  Each pile has a random number of straws.\n\n```\nPile 0: ||||\n\nPile 1: ||\n\nPile 2: |||||\n\nPile 3: |\n\nPile 4: ||||||\n\n...or more concisely: [4,2,5,1,6]\n```\n\nThe Rules\n--------------\n\n- The players take turns picking a pile, and removing any number of straws from the pile they pick\n- A player must pick at least one straw\n- If a player picks the last straw, she wins!\n\nThe Task\n------------\n\nIn this kata, you have to write an AI to play the straw picking game.\n\nYou have to encode an AI in a function `choose_move` (or `chooseMove`, or `choose-move`) that takes a board, represented as a list of positive integers, and returns\n\n```python\n(pile_index, number_of_straws)\n```\n\nWhich refers to an index of a pile on the board, and some none-zero number of straws to draw from that pile.\n\nThe test suite is written so that your AI is expected to play 50 games and win every game it plays.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose_move (gameState : List Nat) : Nat × Nat :=\n  sorry\n\ndef nimSum (xs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem choose_move_valid {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  pileIdx < gameState.length ∧\n  0 < straws ∧\n  straws ≤ gameState[pileIdx]! :=\nsorry\n\ntheorem winning_move_reduces_nim_sum {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  let initialNimSum := nimSum gameState\n  let newState := gameState.set pileIdx (gameState[pileIdx]! - straws)\n  let newNimSum := nimSum newState\n  initialNimSum > 0 → newNimSum < initialNimSum :=\nsorry\n\ntheorem modify_nonempty_pile {gameState : List Nat} (h : gameState ≠ []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  gameState[pileIdx]! > 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001719", "vc-description": "/-\nAs [breadcrumb menùs](https://en.wikipedia.org/wiki/Breadcrumb_%28navigation%29) are quite popular today, I won't digress much on explaining them, leaving the wiki link to do all the dirty work in my place.\n\nWhat might not be so trivial is instead to get a decent breadcrumb from your current url. For this kata, your purpose is to create a function that takes a url, strips the first part (labelling it always `HOME`) and then builds it making each element but the last a `` element linking to the relevant path; last has to be a `` element getting the `active` `class`.\n\nAll elements need to be turned to uppercase and separated by a separator, given as the second parameter of the function; the last element can terminate in some common extension like `.html`, `.htm`, `.php` or `.asp`; if the name of the last element is `index`.something, you treat it as if it wasn't there, sending users automatically to the upper level folder.\n\nA few examples can be more helpful than thousands of words of explanation, so here you have them:\n```python\ngenerate_bc(\"mysite.com/pictures/holidays.html\", \" : \") == 'HOME : PICTURES : HOLIDAYS'\ngenerate_bc(\"www.codewars.com/users/GiacomoSorbi\", \" / \") == 'HOME / USERS / GIACOMOSORBI'\ngenerate_bc(\"www.microsoft.com/docs/index.htm\", \" * \") == 'HOME * DOCS'\n```\nSeems easy enough?\n\nWell, probably not so much, but we have one last extra rule: if one element (other than the root/home) is longer than 30 characters, you have to shorten it, acronymizing it (i.e.: taking just the initials of every word); url will be always given in the format `this-is-an-element-of-the-url` and you should ignore words in this array while acronymizing: `[\"the\",\"of\",\"in\",\"from\",\"by\",\"with\",\"and\", \"or\", \"for\", \"to\", \"at\", \"a\"]`; a url composed of more words separated by `-` and equal or less than 30 characters long needs to be just uppercased with hyphens replaced by spaces.\n\nIgnore anchors (`www.url.com#lameAnchorExample`) and parameters (`www.url.com?codewars=rocks&pippi=rocksToo`) when present.\n\nExamples:\n```python\ngenerate_bc(\"mysite.com/very-long-url-to-make-a-silly-yet-meaningful-example/example.htm\", \" > \") == 'HOME > VLUMSYME > EXAMPLE'\ngenerate_bc(\"www.very-long-site_name-to-make-a-silly-yet-meaningful-example.com/users/giacomo-sorbi\", \" + \") == 'HOME + USERS + GIACOMO SORBI'\n```\n\nYou will always be provided **valid url** to webpages **in common formats**, so you probably shouldn't bother validating them.\n\nIf you like to test yourself with actual work/interview related kata, please also consider this one about building [a string filter for Angular.js](http://www.codewars.com/kata/number-shortening-filter).\n\n_Special thanks to [the colleague](http://www.codewars.com/users/jury89) that, seeing my code and commenting that I worked on that as if it was I was on CodeWars, made me realize that it could be indeed a good idea for a kata_ :)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_bc (url : String) (separator : String) : String :=\n  sorry\n\ndef containsStr (s : String) (sub : String) : Bool :=\n  sorry\n\ndef findStr (s : String) (sub : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem generate_bc_structure (paths : List String) (separator : String)\n  (h1 : paths.length ≥ 1) (h2 : paths.length ≤ 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url separator;\n  (result.startsWith \"<a href=\\\"/\\\">HOME</a>\" ∨\n   result.startsWith \"<span class=\\\"active\\\">HOME</span>\") ∧\n  result.endsWith \"</span>\" ∧\n  (containsStr result \"<span class=\\\"active\\\">\") ∧\n  ((result.split (· == separator.get! 0)).length ≥ 1) :=\nsorry\n\ntheorem generate_bc_protocol_stripping (url : String)\n  (h : containsStr url \"http://\" ∨ containsStr url \"https://\") :\n  let result := generate_bc url \"/\";\n  ¬containsStr result \"http://\" ∧\n  ¬containsStr result \"https://\" :=\nsorry\n\ntheorem generate_bc_long_segments (path : String)\n  (h : path.length > 30) :\n  let url := \"mysite.com/\" ++ path\n  let result := generate_bc url \" > \"\n  let spans := result.split (· == '>')\n  let lastSpan := spans[spans.length - 1]'(by sorry)\n  let content := (lastSpan.split (· == '>')).getLast!;\n  content.length < path.length :=\nsorry\n\ntheorem generate_bc_href_validity (paths : List String)\n  (h1 : paths.length ≥ 2) (h2 : paths.length ≤ 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url \" : \"\n  let segments := (result.split (· == ':')).dropLast;\n  ∀ s ∈ segments,\n    s.startsWith \"<a href=\\\"/\\\"\" ∧\n    s.endsWith \"</a>\" ∧\n    (findStr s \"\\\">\").isSome :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/pictures/holidays.html\" \" : \"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval generate_bc \"www.microsoft.com/docs/index.htm\" \" * \"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/very-long-url-to-make-a-silly-yet-meaningful-example/example.htm\" \" > \""}
{"id": "fvapps_001722", "vc-description": "/-\nIf you like cryptography and playing cards, have also a look at the kata [Card-Chameleon, a Cipher with Playing cards](http://www.codewars.com/kata/card-chameleon-a-cipher-with-playing-cards).\n\nAs a secret agent, you need a method to transmit a message to another secret agent. But an encrypted text written on a notebook will be suspicious if you get caught. A simple deck of playing cards, however, is everything but suspicious...\n\nWith a deck of 52 playing cards, there are `52!` different possible permutations to order it. And `52!` is equal to `80658175170943878571660636856403766975289505440883277824000000000000`. That's a number with [68 digits](https://www.wolframalpha.com/input/?i=52!)!\n\nThere are so many different possible permutations, we can affirm that if you shuffle the cards well and put them back together to form a deck, you are the first one in history to get this particular order. The number of possible permutations in a deck of cards is higher than the estimated number of atoms in planet Earth (which is a number with about [50 digits](https://www.wolframalpha.com/input/?i=number+of+atoms+in+earth)).\n\nWith a way to associate a permutation of the cards to a sequence of characters, we can hide a message in the deck by ordering it correctly.\n\n---\n\n# Correspondence between message and permutation\n\n## Message\n\nTo compose our message, we will use an alphabet containing 27 characters: the space and the letters from A to Z. We give them the following values:\n\n`\" \" = 0, A = 1, B = 2, ..., Z = 26`\n\nWe now have a [numeral system](https://en.wikipedia.org/wiki/Numeral_system) with a base equal to 27. We can compute a numeric value corresponding to any message:\n\n`\"A \" = 27`\n`\"AA\" = 28`\n`\"AB\" = 29`\n`\"ABC\" = 786`\netc.\n\n## Permutation\n\nNow we need a way to attribute a unique number to each of the possible [permutations](https://en.wikipedia.org/wiki/Permutation) of our deck of playing cards.\n\nThere are few methods to [enumerate permutations](https://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations) and [assign a number](https://en.wikipedia.org/wiki/Permutation#Numbering_permutations) to each of them, we will use the [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order). With three cards, A, B, and C, as an example, it gives:\n\n`ABC = 0`\n`ACB = 1`\n`BAC = 2`\n`BCA = 3`\n`CAB = 4`\n`CBA = 5`\n\nSo the first arrangement is ABC, and the last one is CBA. With our 52 playing cards – ranks sorted from the Ace to the King, and suits in alphabetical order (Clubs, Diamonds, Hearts, Spades) – the first arrangement (number `0`) is:\n\nand the last one (number `52! - 1`) is:\n\nTo transmit a message, we will compute the permutation for which the unique number is the numeric value of the message.\n\n---\n\n# Your task\n\nWrite two functions:\n\n* ```python\nencode(message)\n```\n```if:java\nWhich takes a message as argument and returns a deck of playing cards ordered to hide the message (or `null` if the message contains invalid characters or has a numeric value greater than or equal to `52!`).\n```\n```if:python\nWhich takes a String containing a message, and returns an array of Strings representing a deck of playing cards ordered to hide the message (or `None` if the message contains invalid characters or has a numeric value greater than or equal to `52!`).\n```\n```if:elixir\nWhich takes a string containing a message, and returns a list of strings representing a deck of playing cards ordered to hide the message (or `nil` if the message contains invalid characters or has a numeric value greater than or equal to `52!`).\n```\n\n* ```python\ndecode(deck)\n```\n```if:java\nWhich takes a deck of playing cards as argument and returns the message hidden inside (or `null` if the deck contains invalid cards, more than one time a single card, or doesn't contain 52 cards).\n```\n```if:python\nWhich takes an array of Strings representing a deck of playing cards, and returns the message that is hidden inside (or `None` if the deck contains invalid cards, more than one time a single card, or doesn't contain 52 cards).\n```\n```if:elixir\nWhich takes a list of strings representing a deck of playing cards, and returns the message that is hidden inside (or `nil` if the deck contains invalid cards, more than one time a single card, or doesn't contain 52 cards).\n```\n\nEach card name, in a deck, is written with a two characters String: the rank followed by the suit. So the first arrangement of the deck is represented like:\n\n`AC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC` for the Clubs  \n`AD 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD` for the Diamonds  \n`AH 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH` for the Hearts  \n`AS 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS` for the Spades\n\nFor your convenience, a preloaded method allows you to easily print a deck to the output:\n\n```python\nprintDeck(deck, unicode)\n```\n\nThe first argument is the deck to print, the second one is a boolean value allowing you to choose between simple text or Unicode display. (For Unicode, you need to have a font, on your system, that contains the playing cards Unicode characters.)\n\n---\n\n# Examples\n\n## Encoding\n\n```python\nplayingCards.encode(\"ATTACK TONIGHT ON CODEWARS\")\n```\n\nshould return an array of 52 Strings containing:\n\n```python\n[\n    \"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\n    \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"JD\", \"9D\", \"7S\", \"9S\", \"QD\", \"5S\", \"TH\",\n    \"7D\", \"TS\", \"QS\", \"2H\", \"JS\", \"6H\", \"3S\", \"6S\", \"TD\", \"8S\", \"2S\", \"8H\", \"7H\",\n    \"4S\", \"4H\", \"3H\", \"5H\", \"AS\", \"KH\", \"QH\", \"9H\", \"KD\", \"KS\", \"JH\", \"8D\", \"AH\"\n]\n```\n\n## Decoding\n\n```python\nplayingCards.decode([\n    \"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\n    \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"7D\", \"8D\", \"9D\", \"TD\", \"JD\", \"QD\", \"KD\",\n    \"AH\", \"2H\", \"3H\", \"4H\", \"8H\", \"9S\", \"3S\", \"2S\", \"8S\", \"TS\", \"QS\", \"9H\", \"7H\",\n    \"KH\", \"AS\", \"JH\", \"4S\", \"KS\", \"JS\", \"5S\", \"TH\", \"7S\", \"6S\", \"5H\", \"QH\", \"6H\"\n])\n```\n\nshould return a String containing:\n\n```python\n\"ATTACK APPROVED\"\n```\n\n---\n\n# Further readings\n\n## Logarithm\n\nWith the logarithm function, we can know how many digits, in a numeral system of a certain base, are needed to represent a number. For example, `log base 2 of 52! = 225.58`, so we can store 225 bits of information in a deck of cards (and 226 bits are needed to represent the value of `52!`). Also, `log base 27 of 52! = 47.44`, so we can store [47](https://www.wolframalpha.com/input/?i=log+base+27+of+52!) characters of our alphabet in a deck of cards (and some message with 48 characters, but not all of them).\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "structure PlayingCards where\n  cards : List String\n  chars : List Char\n  encode : String → Option (List String)\n  decode : List String → Option String", "vc-helpers": "", "vc-definitions": "def validCharSet : String → Bool :=\nsorry\n\ndef isValidMessage (s : String) : Bool :=\nsorry\n\ndef isValidCard (s : String) : Bool :=\nsorry\n\ndef isValidDeck (d : List String) : Bool :=\nsorry\n\ndef defaultPlayingCards : PlayingCards :=\nsorry", "vc-theorems": "theorem encode_decode_roundtrip\n  {pc : PlayingCards} {msg : String} (h : isValidMessage msg) :\n  match (pc.encode msg) with\n  | none => True\n  | some encoded =>\n    (pc.decode encoded = some msg) ∧\n    (encoded.length = 52) ∧\n    (encoded.eraseDups = encoded) ∧\n    (∀ c, c ∈ encoded → c ∈ pc.cards)\n  :=\nsorry\n\ntheorem decode_encode_roundtrip\n  {pc : PlayingCards} {deck : List String} (h : isValidDeck deck) :\n  match (pc.decode deck) with\n  | none => True\n  | some decoded => pc.encode decoded = some deck\n  :=\nsorry\n\ntheorem invalid_message_returns_none\n  {pc : PlayingCards} {msg : String} :\n  (¬ msg.all (fun c => c ∈ pc.chars)) →\n  pc.encode msg = none\n  :=\nsorry\n\ntheorem invalid_deck_returns_none\n  {pc : PlayingCards} {deck : List String} :\n  (deck.length ≠ 52 ∨ deck.eraseDups.length ≠ 52) →\n  pc.decode deck = none\n  :=\nsorry\n\ntheorem empty_message_valid\n  (pc : PlayingCards) :\n  pc.encode \"\" ≠ none ∧\n  pc.decode (Option.get! (pc.encode \"\")) = some \"\"\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001723", "vc-description": "/-\nAlice, Samantha, and Patricia are relaxing on the porch, when Alice suddenly says: _\"I'm thinking of two numbers, both greater than or equal to 2. I shall tell Samantha the sum of the two numbers and Patricia the product of the two numbers.\"_ \n\nShe takes Samantha aside and whispers in her ear the sum so that Patricia cannot hear it. Then she takes Patricia aside and whispers in her ear the product so that Samantha cannot hear it.\n\nAfter a moment of reflection, Samantha says:\n\n **Statement 1:** _\"Patricia cannot know what the two numbers are.\"_\n\nAfter which Patricia says:\n\n **Statement 2:**  _\"In that case, I do know what the two numbers are.\"_\n\nTo which Samantha replies:\n\n **Statement 3:**  _\"Then I too know what the two numbers are.\"_\n\nYour first task is to write a function `statement1(s)` that takes an `int` argument `s` and returns `True` if and only if Samantha could have made statement 1 if given the number `s`. You may assume that `s` is the sum of two numbers both greater than or equal to 2.  \n\nYour second task is to write a function `statement2(p)` that takes an `int` argument `p` and returns `True` if and only if Patricia, when given the number `p`, could have made statement 2 after hearing Samantha make statement 1. You may assume that `p` is the product of two numbers both greater than or equal to 2 and that Patricia would not have been able to determine the two numbers by looking at `p` alone.\n\nYour third task is to write a function `statement3(s)` that takes an `int` argument `s` and returns `True` if and only if Samantha, when given the number `s`, could have made statement 3 after hearing Patricia make statement 2.\n\nFinally, it is to you to figure out what two numbers Alice was thinking of. Since there are multiple solutions, you must write a function `is_solution(a, b)` that returns `True` if and only if `a` and `b` could have been two numbers that Alice was thinking of.\n\nHint: To get you started, think of what Samantha's first statement implies. Samantha knows that Patricia was not given the product of two primes. That means that the sum that Samantha was given cannot be written as the sum of two primes. Goldbach's conjecture stipulates that every even number greater than 3 can be written as the sum of two primes. Although Goldbach's conjecture has not yet been proven, you may assume that it has been verified for all numbers involved in the test cases here. So we know that the sum that Samantha was given must be odd. The only way to write an odd number as the sum of two primes is when one of the primes is 2, the only even prime. This means that the number given to Samantha is not the sum of 2 and a prime.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef statement1 (s : Nat) : Bool :=\n  sorry\n\ndef statement2 (p : Nat) : Bool :=\n  sorry\n\ndef statement3 (s : Nat) : Bool :=\n  sorry\n\ndef is_solution (a b : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem small_numbers_not_prime {n : Nat} (h : n ≤ 1) :\n  is_prime n = false :=\nsorry\n\ntheorem prime_divisibility {n : Nat} (h₁ : n ≥ 2) (h₂ : n ≤ 1000) :\n  is_prime n = true → ∀ i : Nat, 2 ≤ i ∧ i ≤ n^(1/2) → n % i ≠ 0 :=\nsorry\n\ntheorem statement1_even {s : Nat} (h : s % 2 = 0) :\n  statement1 s = false :=\nsorry\n\ntheorem statement1_prime_diff {s : Nat} (h : is_prime (s - 2)) :\n  statement1 s = false :=\nsorry\n\ntheorem statement2_type {p : Nat} (h₁ : p ≥ 4) (h₂ : p ≤ 100) :\n  statement2 p = true ∨ statement2 p = false :=\nsorry\n\ntheorem statement2_composite {p : Nat} (h₁ : p ≥ 4) (h₂ : p ≤ 100) :\n  statement2 p = true → ∃ i : Nat, 2 ≤ i ∧ i ≤ p^(1/2) ∧ p % i = 0 :=\nsorry\n\ntheorem statement3_type {s : Nat} (h₁ : s ≥ 4) (h₂ : s ≤ 100) :\n  statement3 s = true ∨ statement3 s = false :=\nsorry\n\ntheorem statement3_small {s : Nat} (h : s ≤ 3) :\n  statement3 s = false :=\nsorry\n\ntheorem is_solution_type {a b : Nat} (h₁ : a ≥ 2) (h₂ : a ≤ 50) (h₃ : b ≥ 2) (h₄ : b ≤ 50) :\n  is_solution a b = true ∨ is_solution a b = false :=\nsorry\n\ntheorem is_solution_constraints {a b : Nat} (h₁ : (a + b) % 2 = 0 ∨ is_prime (a * b)) :\n  is_solution a b = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval statement1 6\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval statement2 15\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_solution 5 4"}
{"id": "fvapps_001727", "vc-description": "/-\nGiven a 2D array and a number of generations, compute n timesteps of [Conway's Game of Life](http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life).\n\nThe rules of the game are:\n\n1. Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.\n2. Any live cell with more than three live neighbours dies, as if by overcrowding.\n3. Any live cell with two or three live neighbours lives on to the next generation.\n4. Any dead cell with exactly three live neighbours becomes a live cell.\n\nEach cell's neighborhood is the 8 cells immediately around it (i.e. [Moore Neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood)). The universe is infinite in both the x and y dimensions and all cells are initially dead - except for those specified in the arguments. The return value should be a 2d array cropped around all of the living cells. (If there are no living cells, then return `[[]]`.)\n\nFor illustration purposes, 0 and 1 will be represented as `░░` and `▓▓` blocks respectively (PHP, **C**: plain black and white squares). You can take advantage of the `htmlize` function to get a text representation of the universe, e.g.:\n\n```python\nprint(htmlize(cells))\n````\n\n~~~if:c\nIn **C**, the initial dimensions of the GoL universe is passed into your function *by reference* via the pointers `rowptr` and `colptr`.  When expanding/contracting the GoL universe, please keep track of the dimensions of the modified grid through these two variables.\n~~~\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def trim : List (List Nat) → List (List Nat) :=\nsorry\n\ndef next_gen : List (List Nat) → List (List Nat) :=\nsorry\n\ndef get_generation : List (List Nat) → Nat → List (List Nat) :=\nsorry", "vc-theorems": "theorem static_block_pattern :\n  next_gen [[1,1], [1,1]] = [[1,1], [1,1]] :=\nsorry\n\ntheorem empty_grid_static :\n  next_gen [[]] = [[]] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001730", "vc-description": "/-\nOn fictional islands of Matunga archipelage several different tribes use fictional currency - tung. One tung is a very small amount, so all payments are made with coins of different values. For example, one tribe use coins of 7 and 9 tungs, another - 6, 10 and 11 tungs. Every tribe has at least 2 different coins.\nAlso every tribe has a shop with remarkable feature: if you find an item N tungs worth, you always can find an item priced N+1 tungs in the same shop.\nYour goal is to write the function min_price(coins) which finds out the minimum price of item which can be in sale in Matunga tribe shop, knowing the values of coins used there.\n\nFunction should return -1 if result is not accessible (i.e. coins of these values can't cover natural row from N to infinity without gaps).\n\nFor example, some tribe has coins of 3 and 5 tungs. They can't sell items of 4 or 7 tungs, because 4 and 7 can't be represented as a sum of 3's and 5's. But starting from 8 tungs you can do it with every sum: 8 is 5+3, 9 is 3+3+3, 10 is 5+5, 11 is 5+3+3 and so on. So the answer for this set of coins is 8.\n-/\n\n-- First coin must be minimum of input list\n\n-- Result must be either -1 or >= first coin\n\n-- Input list should not be modified after operation\n\n-- Two coprime numbers should always have a solution", "vc-preamble": "def min_int (a b : Int) : Int := if a ≤ b then a else b\n\ndef list_minimum (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x :: xs => match xs with\n    | [] => x\n    | y :: ys => min_int x (list_minimum xs)", "vc-helpers": "", "vc-definitions": "def min_price (coins : List Int) : Int :=\nsorry", "vc-theorems": "theorem min_price_first_coin_min {coins : List Int} (h : coins.length ≥ 2) :\n  coins ≠ [] → coins.head! = list_minimum coins :=\nsorry\n\ntheorem min_price_result_bounds {coins : List Int} (h : coins.length ≥ 2) :\n  let result := min_price coins\n  result ≠ -1 → result ≥ coins.head! :=\nsorry\n\ntheorem min_price_preserves_input {coins : List Int} (h : coins.length ≥ 2) :\n  let original := coins\n  let _ := min_price coins\n  coins = original :=\nsorry\n\ntheorem coprime_has_solution {coins : List Int} (h : coins.length ≥ 2) :\n  Nat.gcd (coins.head!.toNat) (coins.get! 1).toNat = 1 →\n  min_price coins ≠ -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval min_price [3, 5]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval min_price [4, 6]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_price [2, 3]"}
{"id": "fvapps_001731", "vc-description": "/-\nCreate a function that finds the largest palindromic number made from the product of **at least 2** of the given arguments.\n\n### Notes\n\n* Only non-negative numbers will be given in the argument\n* You don't need to use all the digits of the products\n* Single digit numbers are considered palindromes\n* Optimization is needed: dealing with ones and zeros in a smart way will help a lot\n\n## Examples\n\n```\n[937, 113] --> 81518\n```\nAs `937 * 113 = 105881` and the largest palindromic number that can be arranged from the digits of result is: `81518`\n\nAnother one:\n\n```\n[57, 62, 23] --> 82128\n\n             product     palindrome\n57 * 62      = 3534   -->  353\n57 * 23      = 1311   -->  131\n62 * 23      = 1426   -->  6\n57 * 62 * 23 = 81282  -->  82128\n```\n\nOne more:\n```\n[15, 125, 8] --> 8\n\n             product     palindrome\n15 * 125     = 1875   -->  8\n15 * 8       = 120    -->  2\n125 * 8      = 1000   -->  1\n15 * 125 * 8 = 15000  -->  5\n```\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest_palindrom_from (n : Nat) : Nat :=\nsorry\n\ndef numeric_palindrome (arr : List Nat) : Nat :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem largest_palindrom_from_is_palindrome (n : Nat)\n  (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :\n  let result := toString (largest_palindrom_from n)\n  result = reverseString result :=\nsorry\n\ntheorem largest_palindrom_from_uses_input_digits (n : Nat)\n  (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :\n  let result := toString (largest_palindrom_from n)\n  ∀ d : Char, d ∈ result.data → d ∈ (toString n).data :=\nsorry\n\ntheorem numeric_palindrome_is_palindrome (nums : List Nat)\n  (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)\n  (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :=\nsorry\n\ntheorem numeric_palindrome_bound (nums : List Nat)\n  (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)\n  (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :\n  numeric_palindrome nums ≤ nums.foldr (·*·) 1 :=\nsorry\n\ntheorem numeric_palindrome_with_ones (nums : List Nat)\n  (h1 : nums.length ≥ 3) (h2 : nums.length ≤ 6)\n  (h3 : ∀ i, i < nums.length - 1 → nums.get ⟨i, sorry⟩ = 1)\n  (h4 : nums.getLast? = some 2) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001732", "vc-description": "/-\nThere is a secret string which is unknown to you. Given a collection of random triplets from the string, recover the original string. \n\nA triplet here is defined as a sequence of three letters such that each letter occurs somewhere before the next in the given string. \"whi\" is a triplet for the string \"whatisup\".\n\nAs a simplification, you may assume that no letter occurs more than once in the secret string.\n\nYou can assume nothing about the triplets given to you other than that they are valid triplets and that they contain sufficient information to deduce the original string. In particular, this means that the secret string will never contain letters that do not occur in one of the triplets given to you.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def recoverSecret (triplets : List (List Char)) : String :=\nsorry\n\ndef isConsistentWithTriplets (result : String) (triplets : List (List Char)) : Bool :=\nsorry\n\ndef containsAllChars (result : String) (triplets : List (List Char)) : Bool :=\nsorry", "vc-theorems": "theorem recoverSecret_produces_string (triplets : List (List Char)) :\n  String.length (recoverSecret triplets) > 0 :=\nsorry\n\ntheorem recoverSecret_contains_all_chars (triplets : List (List Char)) :\n  containsAllChars (recoverSecret triplets) triplets = true :=\nsorry\n\ntheorem recoverSecret_consistent_with_triplets (triplets : List (List Char)) :\n  isConsistentWithTriplets (recoverSecret triplets) triplets = true :=\nsorry\n\ntheorem recoverSecret_basic_case :\n  recoverSecret [['a', 'b', 'c'], ['a', 'c', 'd']] = \"abcd\" :=\nsorry\n\ntheorem recoverSecret_complex_case :\n  recoverSecret [\n    ['t','u','p'],\n    ['w','h','i'],\n    ['t','s','u'],\n    ['a','t','s'],\n    ['h','a','p'],\n    ['t','i','s'],\n    ['w','h','s']\n  ] = \"whatisup\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'whatisup'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"t\", \"u\", \"p\"], [\"w\", \"h\", \"i\"], [\"t\", \"s\", \"u\"], [\"a\", \"t\", \"s\"], [\"h\", \"a\", \"p\"], [\"t\", \"i\", \"s\"], [\"w\", \"h\", \"s\"]]\n\n/--\ninfo: 'abcd'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"a\", \"b\", \"c\"], [\"a\", \"c\", \"d\"]]\n\n/--\ninfo: 'great'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"g\", \"r\", \"t\"], [\"e\", \"a\", \"t\"]]"}
{"id": "fvapps_001735", "vc-description": "/-\nGiven an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n. The fractions can be in any order.\n\nExample 1:\nInput: n = 2\nOutput: [\"1/2\"]\nExplanation: \"1/2\" is the only unique fraction with a denominator less-than-or-equal-to 2.\nExample 2:\nInput: n = 3\nOutput: [\"1/2\",\"1/3\",\"2/3\"]\n\nExample 3:\nInput: n = 4\nOutput: [\"1/2\",\"1/3\",\"1/4\",\"2/3\",\"3/4\"]\nExplanation: \"2/4\" is not a simplified fraction because it can be simplified to \"1/2\".\nExample 4:\nInput: n = 1\nOutput: []\n\nConstraints:\n\n1 <= n <= 100\n-/", "vc-preamble": "structure Fraction where\n  num : Nat\n  denom : Nat", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\nsorry\n\ndef simplifiedFractions (n : Nat) : List String :=\nsorry\n\ndef stringToFraction (s : String) : Fraction :=\nsorry", "vc-theorems": "theorem fractions_are_valid {n : Nat} (h : n > 0) :\n  ∀ frac, frac ∈ simplifiedFractions n →\n    let f := stringToFraction frac\n    0 < f.num ∧ f.num < f.denom ∧ f.denom ≤ n ∧ gcd f.num f.denom = 1 :=\nsorry\n\ntheorem fractions_are_unique {n : Nat} (h : n > 0) :\n  ∀ x y, x ∈ simplifiedFractions n → y ∈ simplifiedFractions n →\n    x = y → stringToFraction x = stringToFraction y :=\nsorry\n\ntheorem all_simplified_fractions_included {n : Nat} (h : n > 0) :\n  ∀ i j : Nat, 1 ≤ i → i < j → j ≤ n → gcd i j = 1 →\n    ∃ frac, frac ∈ simplifiedFractions n ∧ stringToFraction frac = ⟨i, j⟩ :=\nsorry\n\ntheorem empty_for_n_less_than_2 :\n  simplifiedFractions 1 = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: ['1/2']\n-/\n#guard_msgs in\n#eval simplifiedFractions 2\n\n/--\ninfo: ['1/2', '1/3', '2/3']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(3)\n\n/--\ninfo: ['1/2', '1/3', '1/4', '2/3', '3/4']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(4)"}
{"id": "fvapps_001743", "vc-description": "/-\nLeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period.\nYou are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.\nAccess times are given in the 24-hour time format \"HH:MM\", such as \"23:51\" and \"09:49\".\nReturn a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.\nNotice that \"10:00\" - \"11:00\" is considered to be within a one-hour period, while \"22:51\" - \"23:52\" is not considered to be within a one-hour period.\n\nExample 1:\nInput: keyName = [\"daniel\",\"daniel\",\"daniel\",\"luis\",\"luis\",\"luis\",\"luis\"], keyTime = [\"10:00\",\"10:40\",\"11:00\",\"09:00\",\"11:00\",\"13:00\",\"15:00\"]\nOutput: [\"daniel\"]\nExplanation: \"daniel\" used the keycard 3 times in a one-hour period (\"10:00\",\"10:40\", \"11:00\").\n\nExample 2:\nInput: keyName = [\"alice\",\"alice\",\"alice\",\"bob\",\"bob\",\"bob\",\"bob\"], keyTime = [\"12:01\",\"12:00\",\"18:00\",\"21:00\",\"21:20\",\"21:30\",\"23:00\"]\nOutput: [\"bob\"]\nExplanation: \"bob\" used the keycard 3 times in a one-hour period (\"21:00\",\"21:20\", \"21:30\").\n\nExample 3:\nInput: keyName = [\"john\",\"john\",\"john\"], keyTime = [\"23:58\",\"23:59\",\"00:01\"]\nOutput: []\n\nExample 4:\nInput: keyName = [\"leslie\",\"leslie\",\"leslie\",\"clare\",\"clare\",\"clare\",\"clare\"], keyTime = [\"13:00\",\"13:20\",\"14:00\",\"18:00\",\"18:51\",\"19:30\",\"19:49\"]\nOutput: [\"clare\",\"leslie\"]\n\nConstraints:\n\n1 <= keyName.length, keyTime.length <= 105\nkeyName.length == keyTime.length\nkeyTime are in the format \"HH:MM\".\n[keyName[i], keyTime[i]] is unique.\n1 <= keyName[i].length <= 10\nkeyName[i] contains only lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Time := String\nderiving Inhabited\n\ndef alertNames (names : List String) (times : List Time) : List String :=\n  sorry\n\ndef parseTime (t : Time) : Nat :=\n  sorry", "vc-theorems": "theorem alertNames_output_ordered (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ i j, i < j → j < result.length → result[i]! ≤ result[j]! := by\nsorry\n\ntheorem alertNames_subset_of_input (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ x ∈ result, x ∈ names := by\nsorry\n\ntheorem alertNames_unique (names : List String) (times : List Time) :\n  let result := alertNames names times\n  List.Nodup result := by\nsorry\n\ntheorem alertNames_violation_exists (names : List String) (times : List Time) :\n  let result := alertNames names times\n  ∀ name ∈ result,\n    let personTimes := (List.zip names times).filterMap\n      (fun p => if p.1 = name then some (parseTime p.2) else none)\n    List.length personTimes ≥ 3 ∧\n    ∃ t0 t1 t2,\n      t0 ∈ personTimes ∧\n      t1 ∈ personTimes ∧\n      t2 ∈ personTimes ∧\n      t0 < t1 ∧ t1 < t2 ∧\n      t2 - t0 ≤ 100 := by\nsorry\n\ntheorem alertNames_short_inputs (names : List String) (times : List Time) :\n  List.length names ≤ 2 → alertNames names times = [] := by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: ['daniel']\n-/\n#guard_msgs in\n#eval alert_names [\"daniel\", \"daniel\", \"daniel\", \"luis\", \"luis\", \"luis\", \"luis\"] [\"10:00\", \"10:40\", \"11:00\", \"09:00\", \"11:00\", \"13:00\", \"15:00\"]\n\n/--\ninfo: ['bob']\n-/\n#guard_msgs in\n#eval alert_names [\"alice\", \"alice\", \"alice\", \"bob\", \"bob\", \"bob\", \"bob\"] [\"12:01\", \"12:00\", \"18:00\", \"21:00\", \"21:20\", \"21:30\", \"23:00\"]\n\n/--\ninfo: ['clare', 'leslie']\n-/\n#guard_msgs in\n#eval alert_names [\"leslie\", \"leslie\", \"leslie\", \"clare\", \"clare\", \"clare\", \"clare\"] [\"13:00\", \"13:20\", \"14:00\", \"18:00\", \"18:51\", \"19:30\", \"19:49\"]"}
{"id": "fvapps_001744", "vc-description": "/-\nOn an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).\n\nNow rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nYou start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\n\nExample 1:\n\nInput: [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\nExample 2:\n\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\nOutput: 16\nExplanation:\n 0  1  2  3  4\n24 23 22 21  5\n12 13 14 15 16\n11 17 18 19 20\n10  9  8  7  6\n\nThe final route is marked in bold.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\nNote:\n\n       2 <= N <= 50.\n       grid[i][j] is a permutation of [0, ..., N*N - 1].\n-/", "vc-preamble": "def Matrix (α : Type) := List (List α)", "vc-helpers": "", "vc-definitions": "def swim_time (grid : Matrix Nat) : Nat :=\nsorry\n\ndef can_reach (t : Nat) (grid : Matrix Nat) (i j : Nat) (visited : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem swim_time_non_negative (grid : Matrix Nat) :\n  swim_time grid ≥ 0 :=\nsorry\n\ntheorem swim_time_bounds {grid : Matrix Nat} (h : grid.length > 0) :\n  swim_time grid ≥ (grid.head!.head!) ∧\n  swim_time grid ≥ (grid.getLast!.getLast!) ∧\n  swim_time grid ≤ grid.length * grid.length :=\nsorry\n\ntheorem swim_time_monotonic {grid grid2 : Matrix Nat} {i j : Nat}\n  (h1 : i < grid.length)\n  (h2 : j < grid.length)\n  (h3 : ∀ x y, x ≠ i ∨ y ≠ j →\n    (grid.get! x).get! y = (grid2.get! x).get! y)\n  (h4 : (grid2.get! i).get! j = (grid.get! i).get! j + 1) :\n  swim_time grid2 ≥ swim_time grid :=\nsorry\n\ntheorem swim_time_path_exists (grid : Matrix Nat) :\n  can_reach (swim_time grid) grid 0 0 [] = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 2], [1, 3]]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval swim_time [[0, 1, 2, 3, 4], [24, 23, 22, 21, 5], [12, 13, 14, 15, 16], [11, 17, 18, 19, 20], [10, 9, 8, 7, 6]]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 1], [2, 3]]"}
{"id": "fvapps_001751", "vc-description": "/-\nGiven an unsorted array of integers, find the number of longest increasing subsequence.\n\nExample 1:\n\nInput: [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].\n\nExample 2:\n\nInput: [2,2,2,2,2]\nOutput: 5\nExplanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.\n\nNote:\nLength of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.\n-/", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! < l[j]!", "vc-helpers": "", "vc-definitions": "def find_number_of_lis (nums : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem number_of_lis_properties (nums : List Int) :\n  let result := find_number_of_lis nums\n  result ≥ 0 ∧\n  (nums = [] → result = 0)\n:= by\nsorry\n\ntheorem constant_list_property {n : Nat} (x : Int) :\n  find_number_of_lis (List.replicate n x) = n\n:= by\nsorry\n\ntheorem strictly_increasing_property (nums : List Int) (h : nums ≠ []) :\n  isSorted nums →\n  find_number_of_lis nums = 1\n:= by\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 3, 5, 4, 7]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_number_of_lis [2, 2, 2, 2, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 2, 4, 3, 5, 4, 7, 2]"}
{"id": "fvapps_001764", "vc-description": "/-\nA Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\n\nThe board is a 3 x 3 array, and consists of characters \" \", \"X\", and \"O\".  The \" \" character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n       Players take turns placing characters into empty squares (\" \").\n       The first player always places \"X\" characters, while the second player always places \"O\" characters.\n       \"X\" and \"O\" characters are always placed into empty squares, never filled ones.\n       The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.\n       The game also ends if all squares are non-empty.\n       No more moves can be played if the game is over.\n\nExample 1:\nInput: board = [\"O  \", \"   \", \"   \"]\nOutput: false\nExplanation: The first player always plays \"X\".\n\nExample 2:\nInput: board = [\"XOX\", \" X \", \"   \"]\nOutput: false\nExplanation: Players take turns making moves.\n\nExample 3:\nInput: board = [\"XXX\", \"   \", \"OOO\"]\nOutput: false\n\nExample 4:\nInput: board = [\"XOX\", \"O O\", \"XOX\"]\nOutput: true\n\nNote:\n\n       board is a length-3 array of strings, where each string board[i] has length 3.\n       Each board[i][j] is a character in the set {\" \", \"X\", \"O\"}.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validTicTacToe (board : List String) : Bool :=\nsorry\n\ndef hasWin (board : List String) (player : Char) : Bool :=\nsorry\n\ndef countChar (board : List String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem board_dimensions {board : List String} (h : validTicTacToe board) :\n  board.length = 3 ∧\n  (∀ row ∈ board, row.length = 3) ∧\n  (∀ row ∈ board, ∀ c ∈ row.data, c = 'X' ∨ c = 'O' ∨ c = ' ') :=\nsorry\n\ntheorem count_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  o_count ≤ x_count ∧ x_count - o_count ≤ 1 :=\nsorry\n\ntheorem winner_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  let x_wins := hasWin board 'X'\n  let o_wins := hasWin board 'O'\n  ¬(x_wins ∧ o_wins) ∧\n  ¬(x_wins ∧ x_count ≤ o_count) ∧\n  ¬(o_wins ∧ x_count ≠ o_count) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"O  \", \"   \", \"   \"]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \" X \", \"   \"]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \"O O\", \"XOX\"]"}
{"id": "fvapps_001766", "vc-description": "/-\nGiven an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from the vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. \nThe edges of the undirected tree are given in the array edges, where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi.\nReturn the probability that after t seconds the frog is on the vertex target.\n\nExample 1:\n\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n\nExample 2:\n\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. \n\nExample 3:\nInput: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6\nOutput: 0.16666666666666666\n\nConstraints:\n\n1 <= n <= 100\nedges.length == n-1\nedges[i].length == 2\n1 <= edges[i][0], edges[i][1] <= n\n1 <= t <= 50\n1 <= target <= n\nAnswers within 10^-5 of the actual value will be accepted as correct.\n-/\n\n/- Function that computes probability of frog being at target vertex after t steps -/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (List Nat)) : Bool :=\nsorry\n\ndef frogPosition (n : Nat) (edges : List (List Nat)) (t : Nat) (target : Nat) : Float :=\nsorry", "vc-theorems": "theorem frog_position_probability (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob := frogPosition n edges t target\n  0 ≤ prob ∧ prob ≤ 1 ∧ 1 ≤ target ∧ target ≤ n :=\nsorry\n\ntheorem frog_position_deterministic (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob1 := frogPosition n edges t target\n  let prob2 := frogPosition n edges t target\n  prob1 = prob2 :=\nsorry\n\ntheorem frog_position_impossible_start (n : Nat) (edges : List (List Nat))\n    (target : Nat)\n    (h1 : isValidTree n edges = true)\n    (h2 : target ≠ 1) :\n  frogPosition n edges 0 target = 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001780", "vc-description": "/-\nIn an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\nIn one move the snake can:\n\nMove one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\n\nRotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).\n\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return -1.\n\nExample 1:\n\nInput: grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n               [0,0,0,0,1,1],\n               [0,0,1,0,1,0],\n               [0,1,1,0,0,0],\n               [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n\nExample 2:\nInput: grid = [[0,0,1,1,1,1],\n               [0,0,0,0,1,1],\n               [1,1,0,0,0,1],\n               [1,1,1,0,0,1],\n               [1,1,1,0,0,1],\n               [1,1,1,0,0,0]]\nOutput: 9\n\nConstraints:\n\n2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells.\n-/\n\n/- For any non-empty n×n grid with all zeros, there exists a valid path to reach bottom right -/\n\n-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- For any n×n grid that is blocked except start position, no valid path exists -/\n\n/- For minimal 3×3 grid of all zeros, there exists a valid path -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minimum_moves (grid : Array (Array Nat)) : Int :=\nsorry", "vc-theorems": "theorem min_moves_empty_grid_reaches {n : Nat} (h : n ≥ 3) :\n  let grid := Array.mk (List.replicate n (Array.mk (List.replicate n (0:Nat))))\n  minimum_moves grid > 0 :=\nsorry\n\ntheorem min_moves_blocked_grid_unreachable {n : Nat} (h : n ≥ 3) :\n  let blockedGrid := Array.mk (List.replicate n (Array.mk (List.replicate n (1:Nat))))\n  let grid := blockedGrid.set! 0 (blockedGrid[0]!.set! 0 0) |>.set! 0 (blockedGrid[0]!.set! 1 0)\n  minimum_moves grid = -1 :=\nsorry\n\ntheorem min_moves_minimal_grid_reaches :\n  let grid := Array.mk [Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)]]\n  minimum_moves grid > 0 :=\nsorry", "vc-postamble": "/--\ninfo: 11\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0]]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0]]"}
{"id": "fvapps_001783", "vc-description": "/-\nGiven a m * n matrix of ones and zeros, return how many square submatrices have all ones.\n\nExample 1:\nInput: matrix =\n[\n  [0,1,1,1],\n  [1,1,1,1],\n  [0,1,1,1]\n]\nOutput: 15\nExplanation: \nThere are 10 squares of side 1.\nThere are 4 squares of side 2.\nThere is  1 square of side 3.\nTotal number of squares = 10 + 4 + 1 = 15.\n\nExample 2:\nInput: matrix = \n[\n  [1,0,1],\n  [1,1,0],\n  [1,1,0]\n]\nOutput: 7\nExplanation: \nThere are 6 squares of side 1.  \nThere is 1 square of side 2. \nTotal number of squares = 6 + 1 = 7.\n\nConstraints:\n\n1 <= arr.length <= 300\n1 <= arr[0].length <= 300\n0 <= arr[i][j] <= 1\n-/\n\n-- simplified expected result for type checking", "vc-preamble": "def listSum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => h + listSum t", "vc-helpers": "", "vc-definitions": "def Matrix (α : Type) := List (List α)\n\ndef count_squares (matrix : Matrix Int) : Nat :=\n  sorry", "vc-theorems": "theorem all_ones_matrix_squares {m n : Nat} (h1 : m > 0) (h2 : n > 0) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_squares matrix = m * n\n  :=\nsorry\n\ntheorem binary_matrix_bounds (matrix : Matrix Int)\n  (h1 : matrix ≠ []) :\n  let result := count_squares matrix\n  let m := matrix.length\n  let n := (List.head! matrix).length\n  result ≥ 0 ∧\n  result ≤ m * n * (min m n)\n  :=\nsorry\n\ntheorem square_all_ones {n : Nat} (h : n > 0) :\n  let matrix := List.replicate n (List.replicate n 1)\n  count_squares matrix = n * (n + 1) * (2 * n + 1) / 6\n  :=\nsorry\n\ntheorem empty_and_edge_cases :\n  count_squares [[0]] = 0 ∧\n  count_squares [[1]] = 1 ∧\n  count_squares [[0, 0], [0, 0]] = 0\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval count_squares [[0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval count_squares [[1, 0, 1], [1, 1, 0], [1, 1, 0]]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval count_squares [[1, 1], [1, 1]]"}
{"id": "fvapps_001784", "vc-description": "/-\nOn an infinite number line (x-axis), we drop given squares in the order they are given.\nThe i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].\nThe square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares.  We wait for each square to stick before dropping the next.\nThe squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square).  Squares dropped adjacent to each other will not stick together prematurely.\n\nReturn a list ans of heights.  Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].\n\nExample 1:\n\nInput: [[1, 2], [2, 3], [6, 1]]\nOutput: [2, 5, 5]\nExplanation:\n\nAfter the first drop of positions[0] = [1, 2]:\n_aa\n_aa\n-------\nThe maximum height of any square is 2.\n\nAfter the second drop of positions[1] = [2, 3]:\n__aaa\n__aaa\n__aaa\n_aa__\n_aa__\n--------------\nThe maximum height of any square is 5.  \nThe larger square stays on top of the smaller square despite where its center\nof gravity is, because squares are infinitely sticky on their bottom edge.\n\nAfter the third drop of positions[1] = [6, 1]:\n__aaa\n__aaa\n__aaa\n_aa\n_aa___a\n--------------\nThe maximum height of any square is still 5.\n\nThus, we return an answer of [2, 5, 5].\n\nExample 2:\n\nInput: [[100, 100], [200, 100]]\nOutput: [100, 100]\nExplanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.\n\nNote:\n1 .\n1 .\n1 .\n-/\n\n/- Result length should match input length -/\n\n/- Heights are monotonically non-decreasing -/\n\n/- Each height is at least as tall as corresponding square -/\n\n/- Maximum height is bounded by sum of all side lengths -/\n\n/- Results are non-negative integers -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def fallingSquares (positions: List (List Int)) : List Int :=\n  sorry", "vc-theorems": "variable (positions : List (List Int))\nvariable (result : List Int := fallingSquares positions)\n\ntheorem result_length :\n  result.length = positions.length := \nsorry\n\ntheorem heights_monotonic {i : Nat} (h : i + 1 < result.length) :\n  match result[i]?, result[i+1]? with\n  | some x, some y => x ≥ 0 ∧ y ≥ x\n  | _, _ => False\n  := \nsorry\n\ntheorem heights_geq_sides :\n  ∀ (i : Nat) (h : i < positions.length),\n  match positions[i]?, result[i]? with\n  | some pos, some height =>\n    match pos.get? 1 with\n    | some side => height ≥ side\n    | none => True\n  | _, _ => True \n  := \nsorry\n\ntheorem max_height_bound (sides : List Int) :\n  (∀ i < positions.length,\n    match positions[i]?, sides.get? i with\n    | some pos, some side => pos.get? 1 = some side\n    | _, _ => False) →\n  result.length > 0 →\n  ∀ h ∈ result, h ≤ sides.foldl (·+·) 0 := \nsorry\n\ntheorem results_nonneg :\n  ∀ x ∈ result, x ≥ 0 := \nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Heights are monotonically non-decreasing -/\n\ntheorem heights_monotonic {i : Nat} (h : i + 1 < result.length) :\n  match result[i]?, result[i+1]? with\n  | some x, some y => x ≥ 0 ∧ y ≥ x\n  | _, _ => False\n  := sorry\n\n/- Each height is at least as tall as corresponding square -/\n\ntheorem heights_geq_sides : \n  ∀ (i : Nat) (h : i < positions.length), \n  match positions[i]?, result[i]? with\n  | some pos, some height => \n    match pos.get? 1 with\n    | some side => height ≥ side\n    | none => True\n  | _, _ => True\n  := sorry\n\n/- Maximum height is bounded by sum of all side lengths -/\n\ntheorem max_height_bound (sides : List Int) :\n  (∀ i < positions.length, \n    match positions[i]?, sides.get? i with \n    | some pos, some side => pos.get? 1 = some side\n    | _, _ => False) →\n  result.length > 0 →\n  ∀ h ∈ result, h ≤ sides.foldl (·+·) 0 := sorry\n\n/- Results are non-negative integers -/\n\ntheorem results_nonneg : \n  ∀ x ∈ result, x ≥ 0 := sorry\n\n/--\ninfo: [2, 5, 5]\n-/\n#guard_msgs in\n#eval fallingSquares [[1, 2], [2, 3], [6, 1]]\n\n/--\ninfo: [100, 100]\n-/\n#guard_msgs in\n#eval fallingSquares [[100, 100], [200, 100]]\n\n/--\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval fallingSquares [[1, 2], [3, 1]]"}
{"id": "fvapps_001786", "vc-description": "/-\nGiven an array of integers arr, sort the array by performing a series of pancake flips.\nIn one pancake flip we do the following steps:\n\nChoose an integer k where 1 <= k <= arr.length.\nReverse the sub-array arr[1...k].\n\nFor example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\nReturn the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\n\nExample 1:\nInput: arr = [3,2,4,1]\nOutput: [4,2,4,3]\nExplanation: \nWe perform 4 pancake flips, with k values 4, 2, 4, and 3.\nStarting state: arr = [3, 2, 4, 1]\nAfter 1st flip (k = 4): arr = [1, 4, 2, 3]\nAfter 2nd flip (k = 2): arr = [4, 1, 2, 3]\nAfter 3rd flip (k = 4): arr = [3, 2, 1, 4]\nAfter 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.\nNotice that we return an array of the chosen k values of the pancake flips.\n\nExample 2:\nInput: arr = [1,2,3]\nOutput: []\nExplanation: The input is already sorted, so there is no need to flip anything.\nNote that other answers, such as [3, 3], would also be accepted.\n\nConstraints:\n\n1 <= arr.length <= 100\n1 <= arr[i] <= arr.length\nAll integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).\n-/", "vc-preamble": "def List.sorted : List Nat → Bool\n| [] => true\n| [_] => true\n| x :: y :: xs => x ≤ y ∧ sorted (y :: xs)\n\ndef applyFlips : List Nat → List Nat → List Nat\n| xs, [] => xs\n| xs, k::ks => applyFlips ((xs.take k).reverse ++ xs.drop k) ks", "vc-helpers": "", "vc-definitions": "def pancakeSort : List Nat → List Nat\n| xs =>\nsorry", "vc-theorems": "theorem pancakeSort_produces_valid_flips (arr : List Nat) :\n  ∀ k ∈ pancakeSort arr, 1 ≤ k ∧ k ≤ arr.length :=\nsorry\n\ntheorem pancakeSort_sorts (arr : List Nat) :\n  (applyFlips arr (pancakeSort arr)).sorted :=\nsorry\n\ntheorem pancakeSort_on_sorted_is_empty (arr : List Nat) :\n  arr.sorted → pancakeSort arr = [] :=\nsorry\n\ntheorem pancakeSort_reverses_reversed (arr : List Nat) :\n  arr = arr.reverse →\n  (applyFlips arr (pancakeSort arr)).sorted :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval len pancake_sort(arr2)"}
{"id": "fvapps_001792", "vc-description": "/-\nFor some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that:\nFor every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].\nGiven N, return any beautiful array A.  (It is guaranteed that one exists.)\n\nExample 1:\nInput: 4\nOutput: [2,1,4,3]\n\nExample 2:\nInput: 5\nOutput: [3,1,2,5,4]\n\nNote:\n\n1 <= N <= 1000\n-/\n\n-- Length is correct\n\n-- Is permutation of 1..n\n\n-- Beautiful property holds", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def beautiful_array (n : Nat) : List Nat :=\n  sorry\n\ndef is_permutation (arr : List Nat) (n : Nat) : Bool :=\n  sorry\n\ndef check_beautiful_property (arr : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem beautiful_array_correct (n : Nat) :\n  let arr := beautiful_array n\n  n > 0 → (\n\n    arr.length = n ∧\n\n    is_permutation arr n = true ∧\n\n    check_beautiful_property arr = true\n  ) :=\nsorry\n\ntheorem beautiful_array_small_cases :\n  ∀ n : Nat, n ≤ 5 → n > 0 →\n    let arr := beautiful_array n\n    arr.length = n ∧\n    is_permutation arr n = true ∧\n    check_beautiful_property arr = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 4\n\n/--\ninfo: [1, 5, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 5\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval beautiful_array 1"}
{"id": "fvapps_001797", "vc-description": "/-\nGiven a directed, acyclic graph of N nodes.  Find all possible paths from node 0 to node N-1, and return them in any order.\n\nThe graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.\n\nExample:\nInput: [[1,2], [3], [3], []] \nOutput: [[0,1,3],[0,2,3]] \nExplanation: The graph looks like this:\n0--->1\n|    |\nv    v\n2--->3\nThere are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\nNote:\n\n       The number of nodes in the graph will be in the range [2, 15].\n       You can print different paths in any order, but you should keep the order of nodes inside one path.\n-/", "vc-preamble": "def Graph := List (List Nat)", "vc-helpers": "", "vc-definitions": "def find_all_paths (g: Graph) : List (List Nat) :=\nsorry\n\ndef is_valid_dag (g: Graph) : Bool :=\nsorry\n\ndef verify_paths (g: Graph) (paths: List (List Nat)) : Bool :=\nsorry", "vc-theorems": "theorem paths_start_end_valid (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths, p.head? = some 0 ∧\n               p.getLast? = some (g.length - 1) :=\nsorry\n\ntheorem paths_follow_edges (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths, ∀ i < p.length - 1,\n    (p.get! (i+1)) ∈ (g.get! (p.get! i)) :=\nsorry\n\ntheorem paths_are_unique (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p₁ ∈ paths, ∀ p₂ ∈ paths, p₁ = p₂ ∨ p₁ ≠ p₂ :=\nsorry\n\ntheorem linear_graph_single_path (n: Nat) (h: n ≥ 2) :\n  let g : Graph := List.map (fun i => if i < n-1 then [i+1] else []) (List.range n)\n  let paths := find_all_paths g\n  paths.length = 1 ∧ paths.head? = some (List.range n) :=\nsorry\n\ntheorem complete_dag_valid_paths (n: Nat) (h: n ≥ 3) :\n  let g : Graph := List.map (fun i => List.filter (fun j => j > i ∧ j < n) (List.range n)) (List.range n)\n  let paths := find_all_paths g\n  verify_paths g paths = true :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: sorted(expected1)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph1)\n\n/--\ninfo: sorted(expected3)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph3)"}
{"id": "fvapps_001801", "vc-description": "/-\nOn the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\n\nGiven row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).\n\nExamples:\nInput: N = 1, K = 1\nOutput: 0\n\nInput: N = 2, K = 1\nOutput: 0\n\nInput: N = 2, K = 2\nOutput: 1\n\nInput: N = 4, K = 5\nOutput: 1\n\nExplanation:\nrow 1: 0\nrow 2: 01\nrow 3: 0110\nrow 4: 01101001\n\nNote:\n\n       N will be an integer in the range [1, 30].\n       K will be an integer in the range [1, 2^(N-1)].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def kthSymbol (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef countOnes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem first_row_is_zero (k : Nat) (h : k > 0) :\n  kthSymbol 1 k = 0 :=\nsorry\n\ntheorem output_is_binary (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = 0 ∨ kthSymbol n k = 1 :=\nsorry\n\ntheorem first_position_zero (n : Nat) (h : n > 1) :\n  kthSymbol n 1 = 0 :=\nsorry\n\ntheorem kth_symbol_property (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = if n > 1 then countOnes (k-1) % 2 else 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 1 1\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 2 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval kth_symbol 4 5"}
{"id": "fvapps_001816", "vc-description": "/-\nYou are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. \n\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\n\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n\nExample 1:\n\nGiven nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\n\nReturn: [1,2],[1,4],[1,6]\n\nThe first 3 pairs are returned from the sequence:\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\nExample 2:\n\nGiven nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\n\nReturn: [1,1],[1,1]\n\nThe first 2 pairs are returned from the sequence:\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\nExample 3:\n\nGiven nums1 = [1,2], nums2 = [3],  k = 3 \n\nReturn: [1,3],[2,3]\n\nAll possible pairs are returned from the sequence:\n[1,3],[2,3]\n\nCredits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases.\n-/\n\n-- Apps difficulty: interview\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSorted (l : List Int) : Bool :=\n  sorry\n\ndef k_smallest_pairs (nums1 nums2 : List Int) (k : Nat) : List (Int × Int) :=\n  sorry", "vc-theorems": "theorem k_smallest_pairs_size (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result ≤ k ∧ List.length result ≤ List.length nums1 * List.length nums2 :=\nsorry\n\ntheorem k_smallest_pairs_elements (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  ∀ pair ∈ result, (List.elem pair.1 nums1 ∧ List.elem pair.2 nums2) :=\nsorry\n\ntheorem k_smallest_pairs_ordered (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  ∀ i, i + 1 < result.length →\n    (result.get! i).1 + (result.get! i).2 ≤ (result.get! (i+1)).1 + (result.get! (i+1)).2 :=\nsorry\n\ntheorem k_smallest_pairs_min_sum (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  result ≠ [] →\n    (result.get! 0).1 + (result.get! 0).2 = nums1.get! 0 + nums2.get! 0 :=\nsorry\n\ntheorem k_smallest_pairs_all_combinations (nums1 nums2 : List Int)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :\n  let k := List.length nums1 * List.length nums2\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result = k ∧\n  ∀ x ∈ nums1, ∀ y ∈ nums2, ∃ pair ∈ result, pair = (x, y) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001819", "vc-description": "/-\nIn a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)\nNow, we may change 0s to 1s so as to connect the two islands together to form 1 island.\nReturn the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)\n\nExample 1:\nInput: A = [[0,1],[1,0]]\nOutput: 1\nExample 2:\nInput: A = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\nExample 3:\nInput: A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n\nConstraints:\n\n2 <= A.length == A[0].length <= 100\nA[i][j] == 0 or A[i][j] == 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef shortest_bridge (grid: Grid) : Nat :=\n  sorry\n\ndef is_valid_grid (grid: Grid) : Bool :=\n  sorry\n\ndef has_two_islands (grid: Grid) : Bool :=\n  sorry", "vc-theorems": "theorem shortest_bridge_non_negative\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid ≥ 0 :=\nsorry\n\ntheorem shortest_bridge_less_than_dimensions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid < grid.length * (grid.head!).length :=\nsorry\n\ntheorem shortest_bridge_assumptions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  0 ≤ shortest_bridge grid ∧ shortest_bridge grid < grid.length * (grid.head!).length :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1], [1, 0]]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1, 0], [0, 0, 0], [0, 0, 1]]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]"}
{"id": "fvapps_001832", "vc-description": "/-\nGiven an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.\n\nExample 1:\nInput: [3,2,1]\nOutput: [3,1,2]\nExplanation: Swapping 2 and 1.\n\nExample 2:\nInput: [1,1,5]\nOutput: [1,1,5]\nExplanation: This is already the smallest permutation.\n\nExample 3:\nInput: [1,9,4,6,7]\nOutput: [1,7,4,6,9]\nExplanation: Swapping 9 and 7.\n\nExample 4:\nInput: [3,1,1,3]\nOutput: [1,3,1,3]\nExplanation: Swapping 1 and 3.\n\nNote:\n\n1 <= A.length <= 10000\n1 <= A[i] <= 10000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def prev_perm_opt1 (arr : List Int) : List Int :=\nsorry\n\ndef list_sortFn : List Int → List Int :=\nsorry", "vc-theorems": "theorem prev_perm_length_preserved {arr : List Int} (h : arr ≠ []) :\n  (prev_perm_opt1 arr).length = arr.length :=\nsorry\n\ntheorem prev_perm_same_elements {arr : List Int} (h : arr ≠ []) :\n  list_sortFn (prev_perm_opt1 arr) = list_sortFn arr :=\nsorry\n\ntheorem prev_perm_sorted_unchanged {arr : List Int} (h : arr ≠ []) :\n  arr = list_sortFn arr → prev_perm_opt1 arr = arr :=\nsorry\n\ntheorem prev_perm_lexicographically_smaller {arr : List Int} (h : arr ≠ []) :\n  prev_perm_opt1 arr ≤ arr :=\nsorry\n\ntheorem prev_perm_idempotent {arr : List Int} (h : arr ≠ []) :\n  prev_perm_opt1 (prev_perm_opt1 arr) ≤ prev_perm_opt1 arr :=\nsorry\n\ntheorem prev_perm_singleton_unchanged {arr : List Int} (h : arr.length = 1) :\n  prev_perm_opt1 arr = arr :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 2, 1]\n\n/--\ninfo: [1, 7, 4, 6, 9]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [1, 9, 4, 6, 7]\n\n/--\ninfo: [1, 3, 1, 3]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 1, 1, 3]"}
{"id": "fvapps_001861", "vc-description": "/-\nGiven the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).\nReturn the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.\n\nExample 1:\nInput: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]]\nOutput: [0,1,4] \nExplanation: \nPerson with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. \nPerson with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. \nOther lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].\n\nExample 2:\nInput: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]]\nOutput: [0,1] \nExplanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1].\n\nExample 3:\nInput: favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]]\nOutput: [0,1,2,3]\n\nConstraints:\n\n1 <= favoriteCompanies.length <= 100\n1 <= favoriteCompanies[i].length <= 500\n1 <= favoriteCompanies[i][j].length <= 20\nAll strings in favoriteCompanies[i] are distinct.\nAll lists of favorite companies are distinct, that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j].\nAll strings consist of lowercase English letters only.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.isSubsetOf (l1 l2 : List α) [BEq α] : Bool :=\n  sorry\n\ndef people_indexes (favorite_companies : List (List String)) : List Nat :=\n  sorry", "vc-theorems": "theorem people_indexes_valid_indices\n  (favorite_companies : List (List String)) :\n  let result := people_indexes favorite_companies\n  ∀ i ∈ result, i < favorite_companies.length :=\nsorry\n\ntheorem people_indexes_empty :\n  people_indexes [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [0, 1, 4]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"google\", \"microsoft\"], [\"google\", \"facebook\"], [\"google\"], [\"amazon\"]]\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"leetcode\", \"amazon\"], [\"facebook\", \"google\"]]\n\n/--\ninfo: [0, 1, 2, 3]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\"], [\"google\"], [\"facebook\"], [\"amazon\"]]"}
{"id": "fvapps_001879", "vc-description": "/-\nFind the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate\n\nHere, for letters we ignore case.  For example, \"P\" on the licensePlate still matches \"p\" on the word.\n\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\n\nThe license plate might have the same letter occurring multiple times.  For example, given a licensePlate of \"PP\", the word \"pair\" does not complete the licensePlate, but the word \"supper\" does.\n\nExample 1:\n\nInput: licensePlate = \"1s3 PSt\", words = [\"step\", \"steps\", \"stripe\", \"stepple\"]\nOutput: \"steps\"\nExplanation: The smallest length word that contains the letters \"S\", \"P\", \"S\", and \"T\".\nNote that the answer is not \"step\", because the letter \"s\" must occur in the word twice.\nAlso note that we ignored case for the purposes of comparing whether a letter exists in the word.\n\nExample 2:\n\nInput: licensePlate = \"1s3 456\", words = [\"looks\", \"pest\", \"stew\", \"show\"]\nOutput: \"pest\"\nExplanation: There are 3 smallest length words that contains the letters \"s\".\nWe return the one that occurred first.\n\nNote:\n\nlicensePlate will be a string with length in range [1, 7].\nlicensePlate will contain digits, spaces, or letters (uppercase or lowercase).\nwords will have a length in the range [10, 1000].\nEvery words[i] will consist of lowercase letters, and have length in range [1, 15].\n-/\n\n-- Helper functions", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortestCompletingWord (licensePlate : String) (words : List String) : Option String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef containsAllLetters (word : String) (plate : String) : Bool :=\nsorry", "vc-theorems": "theorem shortest_completing_word_in_wordlist (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∃ w ∈ words, w.toLower = result.toLower :=\nsorry\n\ntheorem completes_license_plate (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∀ c ∈ plate.toList, isAlpha c → c.toLower ∈ result.toLower.toList :=\nsorry\n\ntheorem is_shortest_valid_word (plate : String) (words : List String) :\n  ∀ result, shortestCompletingWord plate words = some result →\n  ∀ w ∈ words, containsAllLetters w plate → result.length ≤ w.length :=\nsorry\n\ntheorem case_insensitive (plate : String) (words : List String) :\n  shortestCompletingWord plate.toLower words = shortestCompletingWord plate.toUpper words :=\nsorry\n\ntheorem ignore_non_alpha (words : List String) :\n  shortestCompletingWord \"A1B2C3\" words = shortestCompletingWord \"ABC\" words :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'steps'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 PSt\" [\"step\", \"steps\", \"stripe\", \"stepple\"]\n\n/--\ninfo: 'pest'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 456\" [\"looks\", \"pest\", \"stew\", \"show\"]\n\n/--\ninfo: 'supper'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"PP\" [\"pair\", \"supper\"]"}
{"id": "fvapps_001880", "vc-description": "/-\nIn LeetCode Store, there are some kinds of items to sell. Each item has a price.\n\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\nThe job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.\n\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\n\nYou could use any of special offers as many times as you want.\n\nExample 1:\n\nInput: [2,5], [[3,0,5],[1,2,10]], [3,2]\nOutput: 14\nExplanation: \nThere are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\nExample 2:\n\nInput: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]\nOutput: 11\nExplanation: \nThe price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\nNote:\n\nThere are at most 6 kinds of items, 100 special offers.\nFor each item, you need to buy at most 6 of them.\nYou are not allowed to buy more items than you want, even if that would lower the overall price.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shoppingOffers (price : List Int) (special : List (List Int)) (needs : List Int) : Int :=\n  sorry\n\ndef isValidInput (price : List Int) (special : List (List Int)) (needs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem shoppingOffers_result_nonnegative\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 10)\n  (h_special : ∀ s ∈ special, ∀ x ∈ s, 0 ≤ x ∧ x ≤ 10)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 10)\n  (h_valid : isValidInput price special needs) :\n  0 ≤ shoppingOffers price special needs :=\nsorry\n\ntheorem shoppingOffers_not_exceed_list_price\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 10)\n  (h_special : ∀ s ∈ special, ∀ x ∈ s, 0 ≤ x ∧ x ≤ 10)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 10)\n  (h_valid : isValidInput price special needs) :\n  shoppingOffers price special needs ≤ (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :=\nsorry\n\ntheorem shoppingOffers_no_special_equals_list_price\n  (price : List Int) (needs : List Int)\n  (h_price : ∀ p ∈ price, 1 ≤ p ∧ p ≤ 5)\n  (h_needs : ∀ n ∈ needs, 0 ≤ n ∧ n ≤ 5)\n  (h_valid : isValidInput price [] needs) :\n  shoppingOffers price [] needs = (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 14\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 5] [[3, 0, 5], [1, 2, 10]] [3, 2]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 3, 4] [[1, 1, 0, 4], [2, 2, 1, 9]] [1, 2, 1]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval shoppingOffers [1, 1, 1] [[1, 1, 0, 3], [2, 2, 1, 5]] [1, 1, 1]"}
{"id": "fvapps_001887", "vc-description": "/-\nGiven an integer n, find the closest integer (not including itself), which is a palindrome. \n\nThe 'closest' is defined as absolute difference minimized between two integers.\n\nExample 1:\n\nInput: \"123\"\nOutput: \"121\"\n\nNote:\n\nThe input n is a positive integer represented by string, whose length will not exceed 18.\nIf there is a tie, return the smaller one as answer.\n-/\n\n-- Basic type constraints\n\n-- Result should be numeric\n\n-- Result differs from input\n\n-- Result length within ±1 of input length\n\n-- Result is palindromic\n\n-- Result doesn't start with '0'\n\n-- Result is closest palindrome (minimality)", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_closest_palindrome (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef allCharsNumeric (s : String) : Bool :=\nsorry\n\ndef toNat (s : String) : Nat :=\nsorry\n\ndef toString! (n : Nat) : String :=\nsorry", "vc-theorems": "theorem find_closest_palindrome_outputs_nonempty {n : String}\n  (h : isPalindrome n = false)\n  : String.length (find_closest_palindrome n) > 0 :=\nsorry\n\ntheorem find_closest_palindrome_is_numeric {n : String}\n  (h : isPalindrome n = false)\n  : allCharsNumeric (find_closest_palindrome n) = true :=\nsorry\n\ntheorem find_closest_palindrome_different {n : String}\n  (h : isPalindrome n = false)\n  : find_closest_palindrome n ≠ n :=\nsorry\n\ntheorem find_closest_palindrome_length {n : String}\n  (h : isPalindrome n = false)\n  : (String.length (find_closest_palindrome n)).sub (String.length n) ≤ 1 ∧\n    (String.length n).sub (String.length (find_closest_palindrome n)) ≤ 1 :=\nsorry\n\ntheorem find_closest_palindrome_is_palindrome {n : String}\n  (h : isPalindrome n = false)\n  : isPalindrome (find_closest_palindrome n) = true :=\nsorry\n\ntheorem find_closest_palindrome_no_leading_zero {n : String}\n  (h : isPalindrome n = false)\n  : String.get! (find_closest_palindrome n) 0 ≠ '0' :=\nsorry\n\ntheorem find_closest_palindrome_is_minimal {n : String}\n  (h : isPalindrome n = false)\n  (h2 : String.length n ≥ 1)\n  : let result := find_closest_palindrome n\n    let diff := (toNat result).sub (toNat n)\n    ∀ k : Nat,\n      k ≠ toNat n →\n      isPalindrome (toString! k) = true →\n      (k.sub (toNat n)).min ((toNat n).sub k) ≥ diff :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '121'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"123\"\n\n/--\ninfo: '999'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"1000\"\n\n/--\ninfo: '1001'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"999\""}
{"id": "fvapps_001888", "vc-description": "/-\nGiven a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\nExample:\n\nInput: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\nOutput: 4\n-/", "vc-preamble": "def isValid (matrix : List (List String)) : Prop :=\n  match matrix with\n  | [] => True\n  | h::t => ∀ row ∈ t, row.length = h.length", "vc-helpers": "", "vc-definitions": "def maximalSquare (matrix : List (List String)) : Nat :=\n  sorry", "vc-theorems": "theorem maximal_square_is_perfect_square (matrix : List (List String)) :\n  ∃ n : Nat, maximalSquare matrix = n * n :=\nsorry\n\ntheorem maximal_square_bounded (matrix : List (List String)) :\n  match matrix with\n  | [] => maximalSquare matrix = 0\n  | h::t =>\n    let result := maximalSquare matrix\n    let maxDim := min matrix.length h.length\n    0 ≤ result ∧ result ≤ maxDim * maxDim :=\nsorry\n\ntheorem maximal_square_all_zeros (matrix : List (List String))\n  (h₁ : matrix.length > 0)\n  (h₂ : ∀ (i : Nat) (j : Nat), i < matrix.length →\n        j < matrix.head!.length →\n        (matrix.get! i).get! j = \"0\") :\n  maximalSquare matrix = 0 :=\nsorry\n\ntheorem maximal_square_all_ones (matrix : List (List String))\n  (h₁ : matrix.length > 0)\n  (h₂ : ∀ (i : Nat) (j : Nat), i < matrix.length →\n        j < matrix.head!.length →\n        (matrix.get! i).get! j = \"1\") :\n  maximalSquare matrix = (min matrix.length matrix.head!.length) *\n                        (min matrix.length matrix.head!.length) :=\nsorry\n\ntheorem maximal_square_padding (matrix : List (List String))\n  (h : matrix.length > 0) :\n  let padRow := fun (row : List String) => \"0\" :: (row ++ [\"0\"])\n  let paddedMatrix := (List.replicate (matrix.head!.length + 2) \"0\") ::\n                      (matrix.map padRow) ++\n                      [List.replicate (matrix.head!.length + 2) \"0\"]\n  maximalSquare matrix = maximalSquare paddedMatrix :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"0\", \"1\", \"0\", \"0\"], [\"1\", \"0\", \"1\", \"1\", \"1\"], [\"1\", \"1\", \"1\", \"1\", \"1\"], [\"1\", \"0\", \"0\", \"1\", \"0\"]]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"1\"], [\"1\", \"1\"]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval maximal_square [[\"0\"]]"}
{"id": "fvapps_001889", "vc-description": "/-\nS and T are strings composed of lowercase letters. In S, no letter occurs more than once.\n\nS was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.\n\nReturn any permutation of T (as a string) that satisfies this property.\n\nExample :\nInput: \nS = \"cba\"\nT = \"abcd\"\nOutput: \"cbad\"\nExplanation: \n\"a\", \"b\", \"c\" appear in S, so the order of \"a\", \"b\", \"c\" should be \"c\", \"b\", and \"a\". \nSince \"d\" does not appear in S, it can be at any position in T. \"dcba\", \"cdba\", \"cbda\" are also valid outputs.\n\nNote:\n\n       S has length at most 26, and no character is repeated in S.\n       T has length at most 200.\n       S and T consist of lowercase letters only.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sort (l : List α) (f : α → α → Bool) : List α :=\n  sorry\n\ndef custom_sort_string (s t : String) : String :=\n  sorry", "vc-theorems": "theorem length_preserved {s t : String} (h : s.length > 0) :\n  (custom_sort_string s t).length = t.length :=\nsorry\n\ntheorem chars_preserved {s t : String} (h : s.length > 0) :\n  List.sort (custom_sort_string s t).data (· ≤ ·) = List.sort t.data (· ≤ ·) :=\nsorry\n\ntheorem single_char_pattern {s t : String} (h1 : s.length = 1) (h2 : t.length > 0) :\n  s.get 0 ∈ t.data →\n  (custom_sort_string s t).startsWith (String.mk (List.replicate (t.data.count (s.get 0)) (s.get 0))) :=\nsorry\n\ntheorem idempotent {s t : String} (h : s.length > 0) :\n  custom_sort_string s (custom_sort_string s t) = custom_sort_string s t :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 'kqeep'\n-/\n#guard_msgs in\n#eval custom_sort_string \"kqep\" \"pekeq\"\n\n/--\ninfo: 'zyxw'\n-/\n#guard_msgs in\n#eval custom_sort_string \"abc\" \"zyxw\""}
{"id": "fvapps_001894", "vc-description": "/-\nGiven a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.\nReturn the number of closed islands.\n\nExample 1:\n\nInput: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\nOutput: 2\nExplanation: \nIslands in gray are closed because they are completely surrounded by water (group of 1s).\nExample 2:\n\nInput: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]\nOutput: 1\n\nExample 3:\nInput: grid = [[1,1,1,1,1,1,1],\n               [1,0,0,0,0,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,1,0,1,0,1],\n               [1,0,1,1,1,0,1],\n               [1,0,0,0,0,0,1],\n               [1,1,1,1,1,1,1]]\nOutput: 2\n\nConstraints:\n\n1 <= grid.length, grid[0].length <= 100\n0 <= grid[i][j] <=1\n-/", "vc-preamble": "def listSum (l: List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def Grid := List (List Nat)\n\ndef closed_island (grid : Grid) : Nat :=\n  sorry", "vc-theorems": "theorem closed_island_non_negative (grid: Grid) :\n  closed_island grid ≥ 0 :=\nsorry\n\ntheorem closed_island_less_than_zeros (grid: Grid) :\n  let countZeros (row: List Nat) := List.length (List.filter (λ x => x = 0) row)\n  closed_island grid ≤ listSum (List.map countZeros grid) :=\nsorry\n\ntheorem closed_island_small_grid (grid: Grid) (h1: grid.length < 3 ∨ (List.head! grid).length < 3) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_all_ones (grid: Grid)\n  (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_all_zeros (grid: Grid)\n  (h: ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 0) :\n  closed_island grid = 0 :=\nsorry\n\ntheorem closed_island_simple_case_3x3 (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  closed_island grid = 1 :=\nsorry\n\ntheorem closed_island_simple_case_4x4 (grid: Grid)\n  (h1: grid = [[1,1,1,1], [1,0,0,1], [1,0,0,1], [1,1,1,1]]) :\n  closed_island grid = 1 :=\nsorry\n\ntheorem closed_island_mutates_to_ones (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  let _ := closed_island grid\n  ∀ row, List.elem row grid → ∀ x, List.elem x row → x = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0]]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval closed_island [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]"}
{"id": "fvapps_001896", "vc-description": "/-\nGiven an array arr of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.\n24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.\nReturn the latest 24-hour time in \"HH:MM\" format.  If no valid time can be made, return an empty string.\n\nExample 1:\nInput: A = [1,2,3,4]\nOutput: \"23:41\"\nExplanation: The valid 24-hour times are \"12:34\", \"12:43\", \"13:24\", \"13:42\", \"14:23\", \"14:32\", \"21:34\", \"21:43\", \"23:14\", and \"23:41\". Of these times, \"23:41\" is the latest.\n\nExample 2:\nInput: A = [5,5,5,5]\nOutput: \"\"\nExplanation: There are no valid 24-hour times as \"55:55\" is not valid.\n\nExample 3:\nInput: A = [0,0,0,0]\nOutput: \"00:00\"\n\nExample 4:\nInput: A = [0,0,1,0]\nOutput: \"10:00\"\n\nConstraints:\n\narr.length == 4\n0 <= arr[i] <= 9\n-/", "vc-preamble": "def is_valid_time (hours mins: Nat) : Prop :=\n  hours < 24 ∧ mins < 60", "vc-helpers": "", "vc-definitions": "def find_latest_time (digits: List Nat) : String :=\n  sorry\n\ndef is_valid_time_str (s: String) : Bool :=\n  sorry\n\ndef time_to_minutes (time: String) : Nat :=\n  sorry", "vc-theorems": "theorem find_latest_time_gives_valid_result {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d ≤ 9) :\n  is_valid_time_str (find_latest_time digits) = true :=\nsorry\n\ntheorem find_latest_time_invalid_when_all_large {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: (∀ d ∈ digits, d ≥ 6) ∨ (∀ d ∈ digits, d > 2)) :\n  find_latest_time digits = \"\" :=\nsorry\n\ntheorem find_latest_time_zeros {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d = 0) :\n  find_latest_time digits = \"00:00\" :=\nsorry\n\ntheorem find_latest_time_is_maximum {digits: List Nat} {result: String}\n  (h1: digits.length = 4)\n  (h2: ∀ d ∈ digits, d ≤ 9)\n  (h3: result = find_latest_time digits)\n  (h4: result ≠ \"\") :\n  ∀ (h1 h2 m1 m2: Nat),\n  h1 ∈ digits → h2 ∈ digits → m1 ∈ digits → m2 ∈ digits →\n  is_valid_time (h1 * 10 + h2) (m1 * 10 + m2) →\n  time_to_minutes result ≥ (h1 * 10 + h2) * 60 + (m1 * 10 + m2) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: '23:41'\n-/\n#guard_msgs in\n#eval find_latest_time [1, 2, 3, 4]\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval find_latest_time [5, 5, 5, 5]\n\n/--\ninfo: '00:00'\n-/\n#guard_msgs in\n#eval find_latest_time [0, 0, 0, 0]"}
{"id": "fvapps_001898", "vc-description": "/-\nWe have an array of integers, nums, and an array of requests where requests[i] = [starti, endi]. The ith request asks for the sum of nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]. Both starti and endi are 0-indexed.\nReturn the maximum total sum of all requests among all permutations of nums.\nSince the answer may be too large, return it modulo 109 + 7.\n\nExample 1:\nInput: nums = [1,2,3,4,5], requests = [[1,3],[0,1]]\nOutput: 19\nExplanation: One permutation of nums is [2,1,3,4,5] with the following result: \nrequests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\nrequests[1] -> nums[0] + nums[1] = 2 + 1 = 3\nTotal sum: 8 + 3 = 11.\nA permutation with a higher total sum is [3,5,4,2,1] with the following result:\nrequests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\nrequests[1] -> nums[0] + nums[1] = 3 + 5  = 8\nTotal sum: 11 + 8 = 19, which is the best that you can do.\n\nExample 2:\nInput: nums = [1,2,3,4,5,6], requests = [[0,1]]\nOutput: 11\nExplanation: A permutation with the max total sum is [6,5,4,3,2,1] with request sums [11].\nExample 3:\nInput: nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]\nOutput: 47\nExplanation: A permutation with the max total sum is [4,10,5,3,2,1] with request sums [19,18,10].\n\nConstraints:\n\nn == nums.length\n1 <= n <= 105\n0 <= nums[i] <= 105\n1 <= requests.length <= 105\nrequests[i].length == 2\n0 <= starti <= endi < n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef maxSumRangeQuery (nums : List Nat) (requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ndef listSortDescending (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem maxSumRangeQuery_bounded\n  (nums : List Nat)\n  (requests : List (Nat × Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : ∀ r ∈ requests, r.1 ≤ r.2 ∧ r.2 < nums.length) :\n  0 ≤ maxSumRangeQuery nums requests ∧ maxSumRangeQuery nums requests < MOD :=\nsorry\n\ntheorem maxSumRangeQuery_deterministic\n  (nums : List Nat)\n  (requests : List (Nat × Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : ∀ r ∈ requests, r.1 ≤ r.2 ∧ r.2 < nums.length) :\n  maxSumRangeQuery nums requests = maxSumRangeQuery nums requests :=\nsorry\n\ntheorem maxSumRangeQuery_single_request\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  let requests := [(0, nums.length - 1)]\n  maxSumRangeQuery nums requests = (listSum nums) % MOD :=\nsorry\n\ntheorem maxSumRangeQuery_overlapping_bounds\n  (nums : List Nat)\n  (h1 : nums.length > 1) :\n  let requests := [(0, nums.length / 2), (nums.length / 4, nums.length - 1)]\n  let sorted_prefix := (listSortDescending nums).take nums.length\n  maxSumRangeQuery nums requests ≤ (listSum sorted_prefix) * 2 % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/--\ninfo: 19\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5] [[1, 3], [0, 1]]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 6] [[0, 1]]\n\n/--\ninfo: 47\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 10] [[0, 2], [1, 3], [1, 1]]"}
{"id": "fvapps_001902", "vc-description": "/-\nGiven 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :\n\np[0] = start\np[i] and p[i+1] differ by only one bit in their binary representation.\np[0] and p[2^n -1] must also differ by only one bit in their binary representation.\n\nExample 1:\nInput: n = 2, start = 3\nOutput: [3,2,0,1]\nExplanation: The binary representation of the permutation is (11,10,00,01). \nAll the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]\n\nExample 2:\nInput: n = 3, start = 2\nOutput: [2,6,7,5,4,0,1,3]\nExplanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).\n\nConstraints:\n\n1 <= n <= 16\n0 <= start < 2 ^ n\n-/", "vc-preamble": "def listContains (l : List Nat) (n : Nat) : Prop :=\n  n ∈ l", "vc-helpers": "", "vc-definitions": "def countOnes (n : Nat) : Nat :=\n  sorry\n\ndef circularPermutation (n : Nat) (start : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem circularPermutation_length (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).length = 2^n :=\nsorry\n\ntheorem circularPermutation_starts_with_start (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).head! = start :=\nsorry\n\ntheorem circularPermutation_contains_all_numbers (n : Nat) (start : Nat)\n  (h : start < 2^n) (k : Nat) (hk : k < 2^n):\n  listContains (circularPermutation n start) k :=\nsorry\n\ntheorem circularPermutation_adjacent_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) (i : Nat) (h2 : i < (circularPermutation n start).length - 1) :\n  countOnes ((circularPermutation n start)[i]! ^^^ (circularPermutation n start)[i+1]!) = 1 :=\nsorry\n\ntheorem circularPermutation_first_last_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  countOnes ((circularPermutation n start).head! ^^^ (circularPermutation n start).getLast!) = 1 :=\nsorry\n\ntheorem circularPermutation_invalid_start (n : Nat) (start : Nat)\n  (h : start ≥ 2^n) :\n  circularPermutation n start = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/--\ninfo: [3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 2 3\n\n/--\ninfo: [2, 6, 7, 5, 4, 0, 1, 3]\n-/\n#guard_msgs in\n#eval circular_permutation 3 2\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 1 0"}
{"id": "fvapps_001920", "vc-description": "/-\nToad Rash has a binary string $s$. A binary string consists only of zeros and ones.\n\nLet $n$ be the length of $s$.\n\nRash needs to find the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\nFind this number of pairs for Rash.\n\n-----Input-----\n\nThe first line contains the string $s$ ($1 \\leq |s| \\leq 300\\,000$), consisting of zeros and ones.\n\n-----Output-----\n\nOutput one integer: the number of such pairs of integers $l$, $r$ that $1 \\leq l \\leq r \\leq n$ and there is at least one pair of integers $x$, $k$ such that $1 \\leq x, k \\leq n$, $l \\leq x < x + 2k \\leq r$, and $s_x = s_{x+k} = s_{x+2k}$.\n\n-----Examples-----\nInput\n010101\n\nOutput\n3\n\nInput\n11001100\n\nOutput\n0\n\n-----Note-----\n\nIn the first example, there are three $l$, $r$ pairs we need to count: $1$, $6$; $2$, $6$; and $1$, $5$.\n\nIn the second example, there are no values $x$, $k$ for the initial string, so the answer is $0$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_valid_pairs (s : String) : Nat :=\n  sorry\n\ndef complement (s : String) : String :=\nsorry", "vc-theorems": "theorem count_valid_pairs_bounds {s : String} (h : s.length ≥ 3) (h2 : s.length ≤ 8) :\n  let n := s.length\n  0 ≤ count_valid_pairs s ∧ count_valid_pairs s ≤ (n-1)*(n-2)/2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"010101\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_pairs \"11001100\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"0000\""}
{"id": "fvapps_001923", "vc-description": "/-\nA schoolboy named Vasya loves reading books on programming and mathematics. He has recently read an encyclopedia article that described the method of median smoothing (or median filter) and its many applications in science and engineering. Vasya liked the idea of the method very much, and he decided to try it in practice.\n\nApplying the simplest variant of median smoothing to the sequence of numbers a_1, a_2, ..., a_{n} will result a new sequence b_1, b_2, ..., b_{n} obtained by the following algorithm:  b_1 = a_1, b_{n} = a_{n}, that is, the first and the last number of the new sequence match the corresponding numbers of the original sequence.  For i = 2, ..., n - 1 value b_{i} is equal to the median of three values a_{i} - 1, a_{i} and a_{i} + 1. \n\nThe median of a set of three numbers is the number that goes on the second place, when these three numbers are written in the non-decreasing order. For example, the median of the set 5, 1, 2 is number 2, and the median of set 1, 0, 1 is equal to 1.\n\nIn order to make the task easier, Vasya decided to apply the method to sequences consisting of zeros and ones only.\n\nHaving made the procedure once, Vasya looked at the resulting sequence and thought: what if I apply the algorithm to it once again, and then apply it to the next result, and so on? Vasya tried a couple of examples and found out that after some number of median smoothing algorithm applications the sequence can stop changing. We say that the sequence is stable, if it does not change when the median smoothing is applied to it.\n\nNow Vasya wonders, whether the sequence always eventually becomes stable. He asks you to write a program that, given a sequence of zeros and ones, will determine whether it ever becomes stable. Moreover, if it ever becomes stable, then you should determine what will it look like and how many times one needs to apply the median smoothing algorithm to initial sequence in order to obtain a stable one.\n\n-----Input-----\n\nThe first input line of the input contains a single integer n (3 ≤ n ≤ 500 000) — the length of the initial sequence.\n\nThe next line contains n integers a_1, a_2, ..., a_{n} (a_{i} = 0 or a_{i} = 1), giving the initial sequence itself.\n\n-----Output-----\n\nIf the sequence will never become stable, print a single number  - 1.\n\nOtherwise, first print a single integer — the minimum number of times one needs to apply the median smoothing algorithm to the initial sequence before it becomes is stable. In the second line print n numbers separated by a space  — the resulting sequence itself.\n\n-----Examples-----\nInput\n4\n0 0 1 1\n\nOutput\n0\n0 0 1 1\n\nInput\n5\n0 1 0 1 0\n\nOutput\n2\n0 0 0 0 0\n\n-----Note-----\n\nIn the second sample the stabilization occurs in two steps: $01010 \\rightarrow 00100 \\rightarrow 00000$, and the sequence 00000 is obviously stable.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def abs (n : Nat) (m : Nat) : Nat :=\n  if n ≥ m then n - m else m - n", "vc-helpers": "", "vc-definitions": "def solve_median_smoothing (n : Nat) (seq : List Nat) : Nat × Option (List Nat) :=\n  sorry\n\ndef is_sorted_window (arr : List Nat) (i : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem median_smoothing_properties\n  (n : Nat) (seq : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : ∀ x ∈ seq, x ≤ 1)\n  (steps : Nat) (result : Option (List Nat)) :\n  let (steps', result') := solve_median_smoothing n seq\n  match result' with\n  | none => steps' < 0\n  | some res =>\n    steps' ≥ 0 ∧\n    res.length = n ∧\n    (∀ i, 0 < i → i < res.length - 1 → is_sorted_window res i) ∧\n    (seq.length > 0 → res.length > 0 → List.head! res = List.head! seq) ∧\n    (seq.length > 0 → res.length > 0 → List.getLast res (by sorry) = List.getLast seq (by sorry))\n  :=\nsorry\n\ntheorem constant_sequence_property\n  (n : Nat) (seq : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : ∀ x ∈ seq, x = 0) :\n  let (steps, result) := solve_median_smoothing n seq\n  steps = 0 ∧ result = some seq :=\nsorry\n\ntheorem alternating_sequence_property\n  (n : Nat)\n  (h : n ≥ 3) :\n  let seq := List.map (fun i => i % 2) (List.range n)\n  let (steps, result) := solve_median_smoothing n seq\n  steps ≥ 0 ∧\n  match result with\n  | none => False\n  | some res =>\n    ∀ i, i + 1 < res.length →\n    abs (List.get! res i) (List.get! res (i+1)) ≤ 1\n  :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001924", "vc-description": "/-\nFor a vector $\\vec{v} = (x, y)$, define $|v| = \\sqrt{x^2 + y^2}$.\n\nAllen had a bit too much to drink at the bar, which is at the origin. There are $n$ vectors $\\vec{v_1}, \\vec{v_2}, \\cdots, \\vec{v_n}$. Allen will make $n$ moves. As Allen's sense of direction is impaired, during the $i$-th move he will either move in the direction $\\vec{v_i}$ or $-\\vec{v_i}$. In other words, if his position is currently $p = (x, y)$, he will either move to $p + \\vec{v_i}$ or $p - \\vec{v_i}$.\n\nAllen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $p$ satisfies $|p| \\le 1.5 \\cdot 10^6$ so that he can stay safe.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of moves.\n\nEach of the following lines contains two space-separated integers $x_i$ and $y_i$, meaning that $\\vec{v_i} = (x_i, y_i)$. We have that $|v_i| \\le 10^6$ for all $i$.\n\n-----Output-----\n\nOutput a single line containing $n$ integers $c_1, c_2, \\cdots, c_n$, each of which is either $1$ or $-1$. Your solution is correct if the value of $p = \\sum_{i = 1}^n c_i \\vec{v_i}$, satisfies $|p| \\le 1.5 \\cdot 10^6$.\n\nIt can be shown that a solution always exists under the given constraints.\n\n-----Examples-----\nInput\n3\n999999 0\n0 999999\n999999 0\n\nOutput\n1 1 -1 \n\nInput\n1\n-824590 246031\n\nOutput\n1 \n\nInput\n8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n\nOutput\n1 1 1 1 1 1 1 -1\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_path (n : Nat) (vectors : List (Int × Int)) : List Int :=\n  sorry\n\ndef compute_final_position (vectors : List (Int × Int)) (path : List Int) : Int × Int :=\n  sorry\n\ndef verify_path_length (x : Int) (y : Int) : Bool :=\n  sorry", "vc-theorems": "theorem find_path_correct_length {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  n = vectors.length → path.length = n :=\nsorry\n\ntheorem find_path_valid_elements {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  n = vectors.length → ∀ x ∈ path, x = 1 ∨ x = -1 :=\nsorry\n\ntheorem find_path_bounded_result {n : Nat} {vectors : List (Int × Int)} :\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  n = vectors.length →\n  verify_path_length final_pos.1 final_pos.2 = true :=\nsorry\n\ntheorem single_vector_axis_bounded {n : Nat} :\n  n > 0 → n ≤ 50 →\n  let vectors := List.replicate n (1000000, 0)\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  verify_path_length final_pos.1 final_pos.2 = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001940", "vc-description": "/-\nVasya and Petya are playing a simple game. Vasya thought of number x between 1 and n, and Petya tries to guess the number.\n\nPetya can ask questions like: \"Is the unknown number divisible by number y?\".\n\nThe game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.\n\nUnfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers y_{i}, he should ask the questions about.\n\n-----Input-----\n\nA single line contains number n (1 ≤ n ≤ 10^3).\n\n-----Output-----\n\nPrint the length of the sequence of questions k (0 ≤ k ≤ n), followed by k numbers — the questions y_{i} (1 ≤ y_{i} ≤ n).\n\nIf there are several correct sequences of questions of the minimum length, you are allowed to print any of them.\n\n-----Examples-----\nInput\n4\n\nOutput\n3\n2 4 3 \n\nInput\n6\n\nOutput\n4\n2 4 3 5 \n\n-----Note-----\n\nThe sequence from the answer to the first sample test is actually correct.\n\nIf the unknown number is not divisible by one of the sequence numbers, it is equal to 1.\n\nIf the unknown number is divisible by 4, it is 4.\n\nIf the unknown number is divisible by 3, then the unknown number is 3.\n\nOtherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_min_questions (n : Nat) : List Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry\n\ndef isPrimePower (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem find_min_questions_output_type (n : Nat) :\n  ∀ x ∈ find_min_questions n, x ≤ n := by\n  sorry\n\ntheorem find_min_questions_ordering (n : Nat) :\n  ∀ (l : List Nat), l = find_min_questions n →\n    ∀ i, i + 1 < l.length →\n      l.get! i > l.get! (i + 1) →\n      isPrime (l.get! (i + 1)) := by\n  sorry\n\ntheorem find_min_questions_empty_for_one :\n  find_min_questions 1 = [] := by\n  sorry\n\ntheorem find_min_questions_nonempty_for_gt_one (n : Nat) :\n  n > 1 →\n  (find_min_questions n).length > 0 ∧\n  ∀ x ∈ find_min_questions n, x ≥ 2 := by\n  sorry\n\ntheorem find_min_questions_prime_powers (n : Nat) :\n  ∀ x ∈ find_min_questions n, isPrimePower x := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval len find_min_questions(4)\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval len find_min_questions(6)\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_min_questions(1)"}
{"id": "fvapps_001943", "vc-description": "/-\nReading books is one of Sasha's passions. Once while he was reading one book, he became acquainted with an unusual character. The character told about himself like that: \"Many are my names in many countries. Mithrandir among the Elves, Tharkûn to the Dwarves, Olórin I was in my youth in the West that is forgotten, in the South Incánus, in the North Gandalf; to the East I go not.\"\n\nAnd at that moment Sasha thought, how would that character be called in the East? In the East all names are palindromes. A string is a palindrome if it reads the same backward as forward. For example, such strings as \"kazak\", \"oo\" and \"r\" are palindromes, but strings \"abb\" and \"ij\" are not. \n\nSasha believed that the hero would be named after one of the gods of the East. As long as there couldn't be two equal names, so in the East people did the following: they wrote the original name as a string on a piece of paper, then cut the paper minimum number of times $k$, so they got $k+1$ pieces of paper with substrings of the initial string, and then unite those pieces together to get a new string. Pieces couldn't be turned over, they could be shuffled.\n\nIn this way, it's possible to achive a string abcdefg from the string f|de|abc|g using $3$ cuts (by swapping papers with substrings f and abc). The string cbadefg can't be received using the same cuts.\n\nMore formally, Sasha wants for the given palindrome $s$ find such minimum $k$, that you can cut this string into $k + 1$ parts, and then unite them in such a way that the final string will be a palindrome and it won't be equal to the initial string $s$. It there is no answer, then print \"Impossible\" (without quotes).\n\n-----Input-----\n\nThe first line contains one string $s$ ($1 \\le |s| \\le 5\\,000$) — the initial name, which consists only of lowercase Latin letters. It is guaranteed that $s$ is a palindrome.\n\n-----Output-----\n\nPrint one integer $k$ — the minimum number of cuts needed to get a new name, or \"Impossible\" (without quotes).\n\n-----Examples-----\nInput\nnolon\n\nOutput\n2\n\nInput\notto\n\nOutput\n1\n\nInput\nqqqq\n\nOutput\nImpossible\n\nInput\nkinnikkinnik\n\nOutput\n1\n\n-----Note-----\n\nIn the first example, you can cut the string in those positions: no|l|on, and then unite them as follows on|l|no. It can be shown that there is no solution with one cut.\n\nIn the second example, you can cut the string right in the middle, and swap peaces, so you get toot.\n\nIn the third example, you can't make a string, that won't be equal to the initial one.\n\nIn the fourth example, you can cut the suffix nik and add it to the beginning, so you get nikkinnikkin.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (s : String) : Bool :=\n  sorry\n\ndef solve_palindrome_cuts (s : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem solve_result_in_valid_range\n  (s : String)\n  (h : s.length > 0) :\n  let result := solve_palindrome_cuts s\n  result = none ∨ result = some 1 ∨ result = some 2 :=\nsorry\n\ntheorem palindrome_gives_impossible\n  (s : String)\n  (h : is_palindrome s = true) :\n  solve_palindrome_cuts s = none :=\nsorry\n\ntheorem result_one_implies_palindrome_rotation\n  (s : String)\n  (h : solve_palindrome_cuts s = some 1) :\n  ∃ i : Nat, i ≤ s.length ∧\n    is_palindrome (s.drop i ++ s.take i) = true :=\nsorry\n\ntheorem result_preserves_length\n  (s : String)\n  (h : s.length > 0) :\n  (solve_palindrome_cuts s).isSome → s.length > 0 :=\nsorry\n\ntheorem repeated_char_impossible\n  (c : Char)\n  (n : Nat)\n  (h : n > 0) :\n  solve_palindrome_cuts (String.mk (List.replicate n c)) = none :=\nsorry\n\ntheorem short_strings_impossible\n  (s : String)\n  (h : s.length ≤ 2) :\n  solve_palindrome_cuts s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"nolon\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"otto\"\n\n/--\ninfo: 'Impossible'\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"qqqq\""}
{"id": "fvapps_001944", "vc-description": "/-\nYou are given integer $n$. You have to arrange numbers from $1$ to $2n$, using each of them exactly once, on the circle, so that the following condition would be satisfied:\n\nFor every $n$ consecutive numbers on the circle write their sum on the blackboard. Then any two of written on the blackboard $2n$ numbers differ not more than by $1$.\n\nFor example, choose $n = 3$. On the left you can see an example of a valid arrangement: $1 + 4 + 5 = 10$, $4 + 5 + 2 = 11$, $5 + 2 + 3 = 10$, $2 + 3 + 6 = 11$, $3 + 6 + 1 = 10$, $6 + 1 + 4 = 11$, any two numbers differ by at most $1$. On the right you can see an invalid arrangement: for example, $5 + 1 + 6 = 12$, and $3 + 2 + 4 = 9$, $9$ and $12$ differ more than by $1$.\n\n [Image] \n\n-----Input-----\n\nThe first and the only line contain one integer $n$ ($1 \\le n \\le 10^5$).\n\n-----Output-----\n\nIf there is no solution, output \"NO\" in the first line. \n\nIf there is a solution, output \"YES\" in the first line. In the second line output $2n$ numbers — numbers from $1$ to $2n$ in the order they will stay in the circle. Each number should appear only once. If there are several solutions, you can output any of them.\n\n-----Examples-----\nInput\n3\n\nOutput\nYES\n1 4 5 2 3 6 \nInput\n4\n\nOutput\nNO\n\n-----Note-----\n\nExample from the statement is shown for the first example. \n\nIt can be proved that there is no solution in the second example.\n-/\n\n-- Parse result into nums\n\n-- Parse result into nums", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_circle_arrangement (n : Nat) : String :=\n  sorry\n\ndef validate_arrangement (n : Nat) (result : String) : Bool :=\n  sorry", "vc-theorems": "theorem solve_returns_string {n : Nat} :\n  ∃ s : String, solve_circle_arrangement n = s\n  :=\nsorry\n\ntheorem solve_starts_with_yes_or_is_no {n : Nat} :\n  let result := solve_circle_arrangement n\n  result.startsWith \"YES\\n\" ∨ result = \"NO\"\n  :=\nsorry\n\ntheorem result_validates {n : Nat} :\n  validate_arrangement n (solve_circle_arrangement n) = true\n  :=\nsorry\n\ntheorem validates_checks_length {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n\n    nums.length = 2 * n\n  :=\nsorry\n\ntheorem validates_checks_unique_nums {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n\n    nums = List.range (2 * n)\n  :=\nsorry\n\ntheorem validates_checks_consecutive_sums {n : Nat} {result : String} :\n  result ≠ \"NO\" → validate_arrangement n result = true →\n  ∃ nums : List Nat,\n    let doubled := nums ++ nums\n    ∃ sums : List Nat,\n      ∃ maxSum minSum : Nat,\n        maxSum - minSum ≤ 1\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 'YES\\n2 3 6 1 4 5'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 3\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 4\n\n/--\ninfo: 'YES\\n2 1'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 1"}
{"id": "fvapps_001957", "vc-description": "/-\nDoubly linked list is one of the fundamental data structures. A doubly linked list is a sequence of elements, each containing information about the previous and the next elements of the list. In this problem all lists have linear structure. I.e. each element except the first has exactly one previous element, each element except the last has exactly one next element. The list is not closed in a cycle.\n\nIn this problem you are given n memory cells forming one or more doubly linked lists. Each cell contains information about element from some list. Memory cells are numbered from 1 to n.\n\nFor each cell i you are given two values:   l_{i} — cell containing previous element for the element in the cell i;  r_{i} — cell containing next element for the element in the cell i. \n\nIf cell i contains information about the element which has no previous element then l_{i} = 0. Similarly, if cell i contains information about the element which has no next element then r_{i} = 0. [Image] Three lists are shown on the picture. \n\nFor example, for the picture above the values of l and r are the following: l_1 = 4, r_1 = 7; l_2 = 5, r_2 = 0; l_3 = 0, r_3 = 0; l_4 = 6, r_4 = 1; l_5 = 0, r_5 = 2; l_6 = 0, r_6 = 4; l_7 = 1, r_7 = 0.\n\nYour task is to unite all given lists in a single list, joining them to each other in any order. In particular, if the input data already contains a single list, then there is no need to perform any actions. Print the resulting list in the form of values l_{i}, r_{i}.\n\nAny other action, other than joining the beginning of one list to the end of another, can not be performed.\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of memory cells where the doubly linked lists are located.\n\nEach of the following n lines contains two integers l_{i}, r_{i} (0 ≤ l_{i}, r_{i} ≤ n) — the cells of the previous and the next element of list for cell i. Value l_{i} = 0 if element in cell i has no previous element in its list. Value r_{i} = 0 if element in cell i has no next element in its list.\n\nIt is guaranteed that the input contains the correct description of a single or more doubly linked lists. All lists have linear structure: each element of list except the first has exactly one previous element; each element of list except the last has exactly one next element. Each memory cell contains information about one element from some list, each element of each list written in one of n given cells.\n\n-----Output-----\n\nPrint n lines, the i-th line must contain two integers l_{i} and r_{i} — the cells of the previous and the next element of list for cell i after all lists from the input are united in a single list. If there are many solutions print any of them.\n\n-----Example-----\nInput\n7\n4 7\n5 0\n0 0\n6 1\n0 2\n0 4\n1 0\n\nOutput\n4 7\n5 6\n0 5\n6 1\n3 2\n2 4\n1 0\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unite_linked_lists (n : Nat) (arr : List (List Nat)) : List (List Nat) :=\n  sorry\n\ndef is_valid_linked_list (n : Nat) (arr : List (List Nat)) : Bool :=\n  sorry\n\ndef count_lists (n : Nat) (arr : List (List Nat)) : Nat :=\n  sorry\n\ndef is_connected (n : Nat) (arr : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem unite_linked_lists_preserves_size {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    List.length (unite_linked_lists n arr) = List.length arr :=\nsorry\n\ntheorem unite_linked_lists_maintains_validity {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    is_valid_linked_list n (unite_linked_lists n arr) :=\nsorry\n\ntheorem unite_linked_lists_creates_connection {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    is_connected n (unite_linked_lists n arr) :=\nsorry\n\ntheorem unite_linked_lists_reduces_count {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr ≥ 2) :\n    count_lists n (unite_linked_lists n arr) = 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001959", "vc-description": "/-\nHooray! Berl II, the king of Berland is making a knight tournament. The king has already sent the message to all knights in the kingdom and they in turn agreed to participate in this grand event.\n\nAs for you, you're just a simple peasant. There's no surprise that you slept in this morning and were late for the tournament (it was a weekend, after all). Now you are really curious about the results of the tournament. This time the tournament in Berland went as follows:  There are n knights participating in the tournament. Each knight was assigned his unique number — an integer from 1 to n.  The tournament consisted of m fights, in the i-th fight the knights that were still in the game with numbers at least l_{i} and at most r_{i} have fought for the right to continue taking part in the tournament.  After the i-th fight among all participants of the fight only one knight won — the knight number x_{i}, he continued participating in the tournament. Other knights left the tournament.  The winner of the last (the m-th) fight (the knight number x_{m}) became the winner of the tournament. \n\nYou fished out all the information about the fights from your friends. Now for each knight you want to know the name of the knight he was conquered by. We think that the knight number b was conquered by the knight number a, if there was a fight with both of these knights present and the winner was the knight number a.\n\nWrite the code that calculates for each knight, the name of the knight that beat him.\n\n-----Input-----\n\nThe first line contains two integers n, m (2 ≤ n ≤ 3·10^5; 1 ≤ m ≤ 3·10^5) — the number of knights and the number of fights. Each of the following m lines contains three integers l_{i}, r_{i}, x_{i} (1 ≤ l_{i} < r_{i} ≤ n; l_{i} ≤ x_{i} ≤ r_{i}) — the description of the i-th fight.\n\nIt is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.\n\n-----Output-----\n\nPrint n integers. If the i-th knight lost, then the i-th number should equal the number of the knight that beat the knight number i. If the i-th knight is the winner, then the i-th number must equal 0.\n\n-----Examples-----\nInput\n4 3\n1 2 1\n1 3 3\n1 4 4\n\nOutput\n3 1 4 0 \nInput\n8 4\n3 5 4\n3 7 6\n2 8 8\n1 8 1\n\nOutput\n0 8 4 6 4 8 6 1 \n\n-----Note-----\n\nConsider the first test case. Knights 1 and 2 fought the first fight and knight 1 won. Knights 1 and 3 fought the second fight and knight 3 won. The last fight was between knights 3 and 4, knight 4 won.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_winning_knights (n : Nat) (m : Nat) (fights : List (Nat × Nat × Nat)) : List Nat :=\nsorry\n\ndef is_valid_result (n : Nat) (fights : List (Nat × Nat × Nat)) (result : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem find_winning_knights_valid_output (n m : Nat) (fights : List (Nat × Nat × Nat))\n  (h1 : 1 ≤ n) (h2 : n ≤ 100) (h3 : 1 ≤ m) (h4 : m ≤ 100)\n  (h5 : ∀ (f : Nat × Nat × Nat), f ∈ fights →\n    let (l,r,x) := f\n    1 ≤ l ∧ l ≤ x ∧ x ≤ r ∧ r ≤ n) :\n  let result := find_winning_knights n m fights\n  result.length = n ∧\n  (∀ x ∈ result, 0 ≤ x ∧ x ≤ n) ∧\n  is_valid_result n fights result :=\nsorry\n\ntheorem single_fight_winner_pattern (n : Nat) (h : 2 ≤ n) (h2 : n ≤ 10) :\n  let fights := [(1, n, 1)]\n  let result := find_winning_knights n 1 fights\n  result.length = n ∧\n  result.head? = some 0 ∧\n  (∀ x ∈ result.tail, x = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001968", "vc-description": "/-\nAndrew and Eugene are playing a game. Initially, Andrew has string s, consisting of digits. Eugene sends Andrew multiple queries of type \"d_{i} → t_{i}\", that means \"replace all digits d_{i} in string s with substrings equal to t_{i}\". For example, if s = 123123, then query \"2 → 00\" transforms s to 10031003, and query \"3 → \" (\"replace 3 by an empty string\") transforms it to s = 1212. After all the queries Eugene asks Andrew to find the remainder after division of number with decimal representation equal to s by 1000000007 (10^9 + 7). When you represent s as a decimal number, please ignore the leading zeroes; also if s is an empty string, then it's assumed that the number equals to zero.\n\nAndrew got tired of processing Eugene's requests manually and he asked you to write a program for that. Help him!\n\n-----Input-----\n\nThe first line contains string s (1 ≤ |s| ≤ 10^5), consisting of digits — the string before processing all the requests.\n\nThe second line contains a single integer n (0 ≤ n ≤ 10^5) — the number of queries.\n\nThe next n lines contain the descriptions of the queries. The i-th query is described by string \"d_{i}->t_{i}\", where d_{i} is exactly one digit (from 0 to 9), t_{i} is a string consisting of digits (t_{i} can be an empty string). The sum of lengths of t_{i} for all queries doesn't exceed 10^5. The queries are written in the order in which they need to be performed.\n\n-----Output-----\n\nPrint a single integer — remainder of division of the resulting number by 1000000007 (10^9 + 7).\n\n-----Examples-----\nInput\n123123\n1\n2->00\n\nOutput\n10031003\n\nInput\n123123\n1\n3->\n\nOutput\n1212\n\nInput\n222\n2\n2->0\n0->7\n\nOutput\n777\n\nInput\n1000000008\n0\n\nOutput\n1\n\n-----Note-----\n\nNote that the leading zeroes are not removed from string s after the replacement (you can see it in the third sample).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 10^9 + 7\n\ndef process_queries (s : String) (queries : List (Char × String)) : Nat :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem process_queries_mod (s : String) (queries : List (Char × String)) :\n  0 ≤ process_queries s queries ∧ process_queries s queries < MOD :=\nsorry\n\ntheorem process_queries_empty (s : String) :\n  process_queries s [] = (stringToNat s % MOD) :=\nsorry\n\ntheorem process_queries_replacement (s : String) (d r : Char) :\n  s.length > 0 →\n  s.contains d →\n  process_queries s [(d,r.toString)] ≠ stringToNat s % MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 10031003\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"2\", \"00\"]]\n\n/--\ninfo: 1212\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"3\", \"\"]]\n\n/--\ninfo: 777\n-/\n#guard_msgs in\n#eval process_queries \"222\" [[\"2\", \"0\"], [\"0\", \"7\"]]"}
{"id": "fvapps_001979", "vc-description": "/-\nThe Fair Nut is going to travel to the Tree Country, in which there are $n$ cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city $u$ and go by a simple path to city $v$. He hasn't determined the path, so it's time to do it. Note that chosen path can consist of only one vertex.\n\nA filling station is located in every city. Because of strange law, Nut can buy only $w_i$ liters of gasoline in the $i$-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can't choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last.\n\nHe also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\leq n \\leq 3 \\cdot 10^5$) — the number of cities.\n\nThe second line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\leq w_{i} \\leq 10^9$) — the maximum amounts of liters of gasoline that Nut can buy in cities.\n\nEach of the next $n - 1$ lines describes road and contains three integers $u$, $v$, $c$ ($1 \\leq u, v \\leq n$, $1 \\leq c \\leq 10^9$, $u \\ne v$), where $u$ and $v$ — cities that are connected by this road and $c$ — its length.\n\nIt is guaranteed that graph of road connectivity is a tree.\n\n-----Output-----\n\nPrint one number — the maximum amount of gasoline that he can have at the end of the path.\n\n-----Examples-----\nInput\n3\n1 3 3\n1 2 2\n1 3 2\n\nOutput\n3\n\nInput\n5\n6 3 2 5 0\n1 2 10\n2 3 3\n2 4 1\n1 5 1\n\nOutput\n7\n\n-----Note-----\n\nThe optimal way in the first example is $2 \\to 1 \\to 3$.  [Image] \n\nThe optimal way in the second example is $2 \\to 4$.  [Image]\n-/\n\n/- Helper function to get maximum of a list -/\n\n/- Main solve function signature -/\n\n/- Result of solve is always a natural number -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- Result is at least the maximum weight in the input weights -/\n\n/- For singleton input, result equals the single weight -/\n\n/- Properties for small cases (n ≤ 3) -/", "vc-preamble": "def list_max (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| (x::xs) => List.foldl Nat.max x xs", "vc-helpers": "", "vc-definitions": "def make_tree_edges (n : Nat) (edge_weights : List Nat) : List (Nat × Nat × Nat) :=\nsorry\n\ndef solve (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem solve_produces_nat (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) :\n  solve n weights roads ≥ 0 :=\nsorry\n\ntheorem solve_at_least_max_weight (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat))\n  (h : weights ≠ []) :\n  solve n weights roads ≥ list_max weights :=\nsorry\n\ntheorem solve_singleton (w : Nat) :\n  solve 1 [w] [] = w :=\nsorry\n\ntheorem solve_small_cases (n : Nat) (weights : List Nat) (h₁ : n ≤ 3) (h₂ : weights.length = n)\n  (h₃ : weights ≠ []) :\n  let roads := List.map (fun i => (i + 1, i + 2, 1)) (List.range (n-1))\n  solve n weights roads ≥ list_max weights :=\nsorry", "vc-postamble": "/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve 3 [1, 3, 3] [[1, 2, 2], [1, 3, 2]]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve 5 [6, 3, 2, 5, 0] [[1, 2, 10], [2, 3, 3], [2, 4, 1], [1, 5, 1]]\n\n/--\ninfo: 42\n-/\n#guard_msgs in\n#eval solve 1 [42] []"}
{"id": "fvapps_001980", "vc-description": "/-\nYou are given an array $a$ of $n$ integers.\n\nYou want to make all elements of $a$ equal to zero by doing the following operation exactly three times:  Select a segment, for each number in this segment we can add a multiple of $len$ to it, where $len$ is the length of this segment (added integers can be different). \n\nIt can be proven that it is always possible to make all elements of $a$ equal to zero.\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 100\\,000$): the number of elements of the array.\n\nThe second line contains $n$ elements of an array $a$ separated by spaces: $a_1, a_2, \\dots, a_n$ ($-10^9 \\le a_i \\le 10^9$).\n\n-----Output-----\n\nThe output should contain six lines representing three operations.\n\nFor each operation, print two lines:\n\n  The first line contains two integers $l$, $r$ ($1 \\le l \\le r \\le n$): the bounds of the selected segment.\n\n  The second line contains $r-l+1$ integers $b_l, b_{l+1}, \\dots, b_r$ ($-10^{18} \\le b_i \\le 10^{18}$): the numbers to add to $a_l, a_{l+1}, \\ldots, a_r$, respectively; $b_i$ should be divisible by $r - l + 1$. \n\n-----Example-----\nInput\n4\n1 3 2 4\n\nOutput\n1 1 \n-1\n3 4\n4 2\n2 4\n-3 -6 -6\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_operations (n : Nat) (arr : List Int) : List (Nat × Nat × List Int) :=\nsorry\n\ndef verify_operations (n : Nat) (arr : List Int) (ops : List (Nat × Nat × List Int)) : Bool :=\nsorry\n\ndef valid_operation (n : Nat) (op : Nat × Nat × List Int) : Bool :=\nsorry", "vc-theorems": "theorem solve_array_operations_properties\n  (n : Nat) (arr : List Int) (h : 0 < n) (h2 : n ≤ 100) :\n  let ops := solve_array_operations n arr\n  List.length ops = 3 ∧\n  (∀ op ∈ ops, valid_operation n op) ∧\n  verify_operations n arr ops :=\nsorry\n\ntheorem solve_array_single_element\n  (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let arr := [1]\n  let ops := solve_array_operations 1 arr\n  List.length ops = 3 ∧\n  ops[0]! = (1, 1, [0]) ∧\n  ops[1]! = (1, 1, [0]) ∧\n  ops[2]! = (1, 1, [-1]) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_001981", "vc-description": "/-\nKaren has just arrived at school, and she has a math test today! [Image] \n\nThe test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n\nThere are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n\nNote that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n\nThe teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n\nKaren has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n\nSince this number can be quite large, output only the non-negative remainder after dividing it by 10^9 + 7.\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 ≤ n ≤ 200000), the number of numbers written on the first row.\n\nThe next line contains n integers. Specifically, the i-th one among these is a_{i} (1 ≤ a_{i} ≤ 10^9), the i-th number on the first row.\n\n-----Output-----\n\nOutput a single integer on a line by itself, the number on the final row after performing the process above.\n\nSince this number can be quite large, print only the non-negative remainder after dividing it by 10^9 + 7.\n\n-----Examples-----\nInput\n5\n3 6 9 12 15\n\nOutput\n36\n\nInput\n4\n3 7 5 2\n\nOutput\n1000000006\n\n-----Note-----\n\nIn the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is still 36, so this is the correct output.\n\nIn the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n\nKaren performs the operations as follows: [Image] \n\nThe non-negative remainder after dividing the final number by 10^9 + 7 is 10^9 + 6, so this is the correct output.\n-/", "vc-preamble": "def MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_alternative_math (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_range (nums : List Nat) (h : nums ≠ []) :\n  solve_alternative_math nums < MOD :=\nsorry\n\ntheorem solve_single_elem (n : Nat) :\n  solve_alternative_math [n] = n % MOD :=\nsorry\n\ntheorem solve_deterministic (nums : List Nat) (h : nums.length ≥ 2) :\n  solve_alternative_math nums = solve_alternative_math nums :=\nsorry\n\ntheorem solve_odd_length {nums : List Nat} (h1 : nums.length ≥ 3) (h2 : nums.length % 2 = 1) :\n  solve_alternative_math nums < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 36\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 6, 9, 12, 15]\n\n/--\ninfo: 1000000006\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 7, 5, 2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_alternative_math [1]"}
{"id": "fvapps_001984", "vc-description": "/-\nBike loves looking for the second maximum element in the sequence. The second maximum element in the sequence of distinct numbers x_1, x_2, ..., x_{k} (k > 1) is such maximum element x_{j}, that the following inequality holds: $x_{j} \\neq \\operatorname{max}_{i = 1}^{k} x_{i}$.\n\nThe lucky number of the sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence.\n\nYou've got a sequence of distinct positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l} + 1, ..., s_{r} as s[l..r] (1 ≤ l < r ≤ n). Your task is to find the maximum number among all lucky numbers of sequences s[l..r].\n\nNote that as all numbers in sequence s are distinct, all the given definitions make sence.\n\n-----Input-----\n\nThe first line contains integer n (1 < n ≤ 10^5). The second line contains n distinct integers s_1, s_2, ..., s_{n} (1 ≤ s_{i} ≤ 10^9).\n\n-----Output-----\n\nPrint a single integer — the maximum lucky number among all lucky numbers of sequences s[l..r].\n\n-----Examples-----\nInput\n5\n5 2 1 4 3\n\nOutput\n7\n\nInput\n5\n9 8 3 5 7\n\nOutput\n15\n\n-----Note-----\n\nFor the first sample you can choose s[4..5] = {4, 3} and its lucky number is (4 xor 3) = 7. You can also choose s[1..2].\n\nFor the second sample you must choose s[2..5] = {8, 3, 5, 7}.\n-/", "vc-preamble": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j (h1 : i < l.length) (h2 : j < l.length) (_ : i < j), l[i]'h1 ≤ l[j]'h2", "vc-helpers": "", "vc-definitions": "def find_max_lucky_number (nums : List Nat) : Nat := \n  sorry", "vc-theorems": "theorem result_non_negative\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  find_max_lucky_number nums ≥ 0 := \nsorry\n\ntheorem result_bounded_by_max_xor\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  ∀ max_xor : Nat,\n  (∀ i j (h1 : i < nums.length) (h2 : j < nums.length) (_ : i < j),\n    (nums[i]'h1) ^^^ (nums[j]'h2) ≤ max_xor) →\n  find_max_lucky_number nums ≤ max_xor := \nsorry\n\ntheorem single_element_zero\n  (x : Nat) :\n  find_max_lucky_number [x] = 0 := \nsorry\n\ntheorem reverse_invariant_unique\n  (nums : List Nat)\n  (h1 : nums.length ≥ 2)\n  (h2 : ∀ i j (h1 : i < nums.length) (h2 : j < nums.length) (_ : i ≠ j), nums[i]'h1 ≠ nums[j]'h2) :\n  find_max_lucky_number nums = find_max_lucky_number nums.reverse := \nsorry\n\ntheorem sorted_sequence_maintains_xor_pair\n  (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (sorted : List Nat)\n  (h_sorted : isSorted sorted) :\n  let result := find_max_lucky_number sorted\n  ∃ i j, i < sorted.length ∧ j < sorted.length ∧ i < j ∧\n    ((h1 : i < sorted.length) → (h2 : j < sorted.length) → \n    result = (sorted[i]'h1) ^^^ (sorted[j]'h2)) := \nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_max_lucky_number [5, 2, 1, 4, 3]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval find_max_lucky_number [9, 8, 3, 5, 7]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_lucky_number [11, 10, 8]"}
{"id": "fvapps_001985", "vc-description": "/-\nYou've got array A, consisting of n integers and a positive integer k. Array A is indexed by integers from 1 to n.\n\nYou need to permute the array elements so that value $\\sum_{i = 1}^{n - k}|A [ i ] - A [ i + k ]|$ became minimal possible. In particular, it is allowed not to change order of elements at all.\n\n-----Input-----\n\nThe first line contains two integers n, k (2 ≤ n ≤ 3·10^5, 1 ≤ k ≤ min(5000, n - 1)). \n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 10^9 ≤ A[i] ≤ 10^9), separate by spaces — elements of the array A.\n\n-----Output-----\n\nPrint the minimum possible value of the sum described in the statement.\n\n-----Examples-----\nInput\n3 2\n1 2 4\n\nOutput\n1\n\nInput\n5 2\n3 -5 3 -5 3\n\nOutput\n0\n\nInput\n6 3\n4 3 4 3 2 5\n\nOutput\n3\n\n-----Note-----\n\nIn the first test one of the optimal permutations is 1 4 2. \n\nIn the second test the initial order is optimal. \n\nIn the third test one of the optimal permutations is 2 3 4 4 3 5.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (l : List Int) : Int :=\n  sorry\n\ndef minimum (l : List Int) : Int :=\n  sorry\n\ndef min_difference_sum (n k : Nat) (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_difference_sum_non_negative\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k ≤ n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr ≥ 0 :=\nsorry\n\ntheorem min_difference_sum_upper_bound\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k ≤ n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr ≤ (maximum arr - minimum arr) * k :=\nsorry\n\ntheorem min_difference_sum_k_equals_n\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr = 0 :=\nsorry\n\ntheorem min_difference_sum_k_equals_one\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = 1)\n  (h3 : n > 1) :\n  min_difference_sum n k arr = maximum arr - minimum arr :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_difference_sum 3 2 [1, 2, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_difference_sum 5 2 [3, -5, 3, -5, 3]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difference_sum 6 3 [4, 3, 4, 3, 2, 5]"}
{"id": "fvapps_001990", "vc-description": "/-\nMaxim always goes to the supermarket on Sundays. Today the supermarket has a special offer of discount systems.\n\nThere are m types of discounts. We assume that the discounts are indexed from 1 to m. To use the discount number i, the customer takes a special basket, where he puts exactly q_{i} items he buys. Under the terms of the discount system, in addition to the items in the cart the customer can receive at most two items from the supermarket for free. The number of the \"free items\" (0, 1 or 2) to give is selected by the customer. The only condition imposed on the selected \"free items\" is as follows: each of them mustn't be more expensive than the cheapest item out of the q_{i} items in the cart.\n\nMaxim now needs to buy n items in the shop. Count the minimum sum of money that Maxim needs to buy them, if he use the discount system optimally well.\n\nPlease assume that the supermarket has enough carts for any actions. Maxim can use the same discount multiple times. Of course, Maxim can buy items without any discounts.\n\n-----Input-----\n\nThe first line contains integer m (1 ≤ m ≤ 10^5) — the number of discount types. The second line contains m integers: q_1, q_2, ..., q_{m} (1 ≤ q_{i} ≤ 10^5). \n\nThe third line contains integer n (1 ≤ n ≤ 10^5) — the number of items Maxim needs. The fourth line contains n integers: a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^4) — the items' prices.\n\nThe numbers in the lines are separated by single spaces.\n\n-----Output-----\n\nIn a single line print a single integer — the answer to the problem.\n\n-----Examples-----\nInput\n1\n2\n4\n50 50 100 100\n\nOutput\n200\n\nInput\n2\n2 3\n5\n50 50 50 50 50\n\nOutput\n150\n\nInput\n1\n1\n7\n1 1 1 1 1 1 1\n\nOutput\n3\n\n-----Note-----\n\nIn the first sample Maxim needs to buy two items that cost 100 and get a discount for two free items that cost 50. In that case, Maxim is going to pay 200.\n\nIn the second sample the best strategy for Maxim is to buy 3 items and get 2 items for free using the discount. In that case, Maxim is going to pay 150.\n-/", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef list_take (n : Nat) (l : List Nat) : List Nat :=\n  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take n t\n\ndef list_replicate (n : Nat) (v : Nat) : List Nat :=\n  match n with\n  | 0 => []\n  | n+1 => v :: list_replicate n v", "vc-helpers": "", "vc-definitions": "def solve_discount_shopping (n_discounts : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) : Nat :=\n  sorry\n\ndef list_sort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  0 ≤ solve_discount_shopping n_discounts discount_values n_items item_values :=\nsorry\n\ntheorem discount_shopping_upper_bound\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  solve_discount_shopping n_discounts discount_values n_items item_values ≤ list_sum item_values :=\nsorry\n\ntheorem discount_shopping_min_items\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  let sorted_items := list_sort item_values\n  let min_disc := match discount_values with\n                  | [] => n_items\n                  | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values ≥ min_items_sum :=\nsorry\n\ntheorem identical_items_result\n  (n_discounts : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h2 : 1 ≤ n_items ∧ n_items ≤ 5)\n  (h3 : 1 ≤ item_value ∧ item_value ≤ 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values := list_replicate n_items item_value\n  let result := solve_discount_shopping n_discounts discount_values n_items item_values\n  result % item_value = 0 ∧ result ≤ item_value * n_items :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 200\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [2] 4 [50, 50, 100, 100]\n\n/--\ninfo: 150\n-/\n#guard_msgs in\n#eval solve_discount_shopping 2 [2, 3] 5 [50, 50, 50, 50, 50]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [1] 7 [1, 1, 1, 1, 1, 1, 1]"}
{"id": "fvapps_001992", "vc-description": "/-\nSlime and his $n$ friends are at a party. Slime has designed a game for his friends to play.\n\nAt the beginning of the game, the $i$-th player has $a_i$ biscuits. At each second, Slime will choose a biscuit randomly uniformly among all $a_1 + a_2 + \\ldots + a_n$ biscuits, and the owner of this biscuit will give it to a random uniform player among $n-1$ players except himself. The game stops when one person will have all the biscuits.\n\nAs the host of the party, Slime wants to know the expected value of the time that the game will last, to hold the next activity on time.\n\nFor convenience, as the answer can be represented as a rational number $\\frac{p}{q}$ for coprime $p$ and $q$, you need to find the value of $(p \\cdot q^{-1})\\mod 998\\,244\\,353$. You can prove that $q\\mod 998\\,244\\,353 \\neq 0$.\n\n-----Input-----\n\nThe first line contains one integer $n\\ (2\\le n\\le 100\\,000)$: the number of people playing the game.\n\nThe second line contains $n$ non-negative integers $a_1,a_2,\\dots,a_n\\ (1\\le a_1+a_2+\\dots+a_n\\le 300\\,000)$, where $a_i$ represents the number of biscuits the $i$-th person own at the beginning.\n\n-----Output-----\n\nPrint one integer: the expected value of the time that the game will last, modulo $998\\,244\\,353$.\n\n-----Examples-----\nInput\n2\n1 1\n\nOutput\n1\n\nInput\n2\n1 2\n\nOutput\n3\n\nInput\n5\n0 0 0 0 35\n\nOutput\n0\n\nInput\n5\n8 4 2 0 1\n\nOutput\n801604029\n\n-----Note-----\n\nFor the first example, in the first second, the probability that player $1$ will give the player $2$ a biscuit is $\\frac{1}{2}$, and the probability that player $2$ will give the player $1$ a biscuit is $\\frac{1}{2}$. But anyway, the game will stop after exactly $1$ second because only one player will occupy all biscuits after $1$ second, so the answer is $1$.\n-/", "vc-preamble": "def MOD : Nat := 998244353", "vc-helpers": "", "vc-definitions": "def solve_biscuit_game (n : Nat) (biscuits : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_range (n : Nat) (biscuits : List Nat) :\n  n > 0 → 0 ≤ solve_biscuit_game n biscuits ∧ solve_biscuit_game n biscuits < MOD :=\nsorry\n\ntheorem zero_biscuits (n : Nat) (len : Nat) :\n  n > 0 → solve_biscuit_game n (List.replicate len 0) = 0 :=\nsorry\n\ntheorem equal_distribution (n : Nat) (biscuits : List Nat) :\n  n > 0 → biscuits ≠ [] →\n  0 ≤ solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) ∧\n  solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) < MOD :=\nsorry\n\ntheorem single_player (n : Nat) (biscuits : List Nat) :\n  n = 1 → biscuits ≠ [] → solve_biscuit_game n biscuits = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 1]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_biscuit_game 5 [0, 0, 0, 0, 35]"}
{"id": "fvapps_002001", "vc-description": "/-\nSereja has a bracket sequence s_1, s_2, ..., s_{n}, or, in other words, a string s of length n, consisting of characters \"(\" and \")\".\n\nSereja needs to answer m queries, each of them is described by two integers l_{i}, r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence s_{l}_{i}, s_{l}_{i} + 1, ..., s_{r}_{i}. Help Sereja answer all queries.\n\nYou can find the definitions for a subsequence and a correct bracket sequence in the notes.\n\n-----Input-----\n\nThe first line contains a sequence of characters s_1, s_2, ..., s_{n} (1 ≤ n ≤ 10^6) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 ≤ m ≤ 10^5) — the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers l_{i}, r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n) — the description of the i-th query.\n\n-----Output-----\n\nPrint the answer to each question on a single line. Print the answers in the order they go in the input.\n\n-----Examples-----\nInput\n())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n\nOutput\n0\n0\n2\n10\n4\n6\n6\n\n-----Note-----\n\nA subsequence of length |x| of string s = s_1s_2... s_{|}s| (where |s| is the length of string s) is string x = s_{k}_1s_{k}_2... s_{k}_{|}x| (1 ≤ k_1 < k_2 < ... < k_{|}x| ≤ |s|).\n\nA correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters \"1\" and \"+\" between the characters of the string. For example, bracket sequences \"()()\", \"(())\" are correct (the resulting expressions \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.\n\nFor the third query required sequence will be «()».\n\nFor the fourth query required sequence will be «()(())(())».\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "structure SegTree where\n  size : Nat\n  answer : Array Nat\n  opened : Array Nat\n  closed : Array Nat\nderiving Inhabited", "vc-helpers": "", "vc-definitions": "def next_pow_2 (n: Nat) : Nat :=\nsorry\n\ndef SegTree.build (self : SegTree) (s : String) : SegTree :=\nsorry\n\ndef solve_brackets (s: String) (queries: List (Nat × Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem next_pow_2_properties (n: Nat) (h: n ≥ 1) :\n  let result := next_pow_2 n\n  result ≥ n ∧\n  result &&& (result - 1) = 0 ∧\n  (result / 2 < n ∨ n = 1) :=\nsorry\n\ntheorem segtree_build_properties (s : String) (h: s.length > 0) :\n  let tree := SegTree.build (SegTree.mk s.length #[] #[] #[]) s\n  tree.answer.size = 2 * tree.size ∧\n  tree.opened.size = 2 * tree.size ∧\n  tree.closed.size = 2 * tree.size ∧\n  ∀ i < s.length,\n    let idx := tree.size + i\n    (tree.opened.get! idx = 0 ∨ tree.opened.get! idx = 1) ∧\n    (tree.closed.get! idx = 0 ∨ tree.closed.get! idx = 1) ∧\n    tree.opened.get! idx + tree.closed.get! idx ≤ 1 :=\nsorry\n\ntheorem solve_brackets_properties (s: String) (queries: List (Nat × Nat))\n  (h₁: s.length > 0)\n  (h₂: ∀ q, q ∈ queries →\n    q.1 > 0 ∧ q.2 > 0 ∧ q.1 ≤ q.2 ∧ q.2 ≤ s.length) :\n  let results := solve_brackets s queries\n  (∀ r, r ∈ results → r ≥ 0) ∧\n  (∀ r, r ∈ results → r % 2 = 0) ∧\n  (∀ q r, q ∈ queries → r ∈ results →\n    r ≤ 2 * (q.2 - q.1 + 1) ∧\n    (r > 0 → q.2 - q.1 ≥ 1)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002008", "vc-description": "/-\nAs you know, majority of students and teachers of Summer Informatics School live in Berland for the most part of the year. Since corruption there is quite widespread, the following story is not uncommon.\n\nElections are coming. You know the number of voters and the number of parties — $n$ and $m$ respectively. For each voter you know the party he is going to vote for. However, he can easily change his vote given a certain amount of money. In particular, if you give $i$-th voter $c_i$ bytecoins you can ask him to vote for any other party you choose.\n\nThe United Party of Berland has decided to perform a statistical study — you need to calculate the minimum number of bytecoins the Party needs to spend to ensure its victory. In order for a party to win the elections, it needs to receive strictly more votes than any other party.\n\n-----Input-----\n\nThe first line of input contains two integers $n$ and $m$ ($1 \\le n, m \\le 3000$) — the number of voters and the number of parties respectively.\n\nEach of the following $n$ lines contains two integers $p_i$ and $c_i$ ($1 \\le p_i \\le m$, $1 \\le c_i \\le 10^9$) — the index of this voter's preferred party and the number of bytecoins needed for him to reconsider his decision.\n\nThe United Party of Berland has the index $1$.\n\n-----Output-----\n\nPrint a single number — the minimum number of bytecoins needed for The United Party of Berland to win the elections.\n\n-----Examples-----\nInput\n1 2\n1 100\n\nOutput\n0\n\nInput\n5 5\n2 100\n3 200\n4 300\n5 400\n5 900\n\nOutput\n500\n\nInput\n5 5\n2 100\n3 200\n4 300\n5 800\n5 900\n\nOutput\n600\n\n-----Note-----\n\nIn the first sample, The United Party wins the elections even without buying extra votes.\n\nIn the second sample, The United Party can buy the votes of the first and the fourth voter. This way The Party gets two votes, while parties $3$, $4$ and $5$ get one vote and party number $2$ gets no votes.\n\nIn the third sample, The United Party can buy the votes of the first three voters and win, getting three votes against two votes of the fifth party.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_min_bytecoins (n : Nat) (m : Nat) (votes : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  sorry\n\ndef count_votes_for_party (votes : List (Nat × Nat)) (party : Nat) : Nat :=\n  sorry\n\ndef max_list (l : List Nat) : Nat :=\n  sorry\n\ndef increase_first_vote_cost (votes : List (Nat × Nat)) : List (Nat × Nat) :=\n  sorry", "vc-theorems": "theorem calculate_min_bytecoins_non_negative (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000) :\n  calculate_min_bytecoins n m votes ≥ 0 :=\nsorry\n\ntheorem calculate_min_bytecoins_upper_bound (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000) :\n  calculate_min_bytecoins n m votes ≤ list_sum (votes.map (λ v => v.2)) :=\nsorry\n\ntheorem calculate_min_bytecoins_party1_winning (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000)\n  (party1_votes := count_votes_for_party votes 1)\n  (other_parties_max := max_list (List.range m |>.map (λ i => count_votes_for_party votes (i + 2))))\n  (h_winning : party1_votes > other_parties_max) :\n  calculate_min_bytecoins n m votes = 0 :=\nsorry\n\ntheorem calculate_min_bytecoins_monotone (n m : Nat) (votes : List (Nat × Nat))\n  (hn : n > 0) (hm : m ≥ 2)\n  (hvotes : ∀ v ∈ votes, v.1 ≥ 1 ∧ v.1 ≤ m ∧ v.2 ≤ 1000)\n  (increased_votes := increase_first_vote_cost votes) :\n  calculate_min_bytecoins n m increased_votes ≥ calculate_min_bytecoins n m votes :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 1 2 [[1, 100]]\n\n/--\ninfo: 500\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 400], [5, 900]]\n\n/--\ninfo: 600\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 800], [5, 900]]"}
{"id": "fvapps_002012", "vc-description": "/-\nAndrewid the Android is a galaxy-famous detective. He is now chasing a criminal hiding on the planet Oxa-5, the planet almost fully covered with water.\n\nThe only dry land there is an archipelago of n narrow islands located in a row. For more comfort let's represent them as non-intersecting segments on a straight line: island i has coordinates [l_{i}, r_{i}], besides, r_{i} < l_{i} + 1 for 1 ≤ i ≤ n - 1.\n\nTo reach the goal, Andrewid needs to place a bridge between each pair of adjacent islands. A bridge of length a can be placed between the i-th and the (i + 1)-th islads, if there are such coordinates of x and y, that l_{i} ≤ x ≤ r_{i}, l_{i} + 1 ≤ y ≤ r_{i} + 1 and y - x = a. \n\nThe detective was supplied with m bridges, each bridge can be used at most once. Help him determine whether the bridges he got are enough to connect each pair of adjacent islands.\n\n-----Input-----\n\nThe first line contains integers n (2 ≤ n ≤ 2·10^5) and m (1 ≤ m ≤ 2·10^5) — the number of islands and bridges.\n\nNext n lines each contain two integers l_{i} and r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ 10^18) — the coordinates of the island endpoints.\n\nThe last line contains m integer numbers a_1, a_2, ..., a_{m} (1 ≤ a_{i} ≤ 10^18) — the lengths of the bridges that Andrewid got.\n\n-----Output-----\n\nIf it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b_1, b_2, ..., b_{n} - 1, which mean that between islands i and i + 1 there must be used a bridge number b_{i}. \n\nIf there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.\n\n-----Examples-----\nInput\n4 4\n1 4\n7 8\n9 10\n12 14\n4 5 3 8\n\nOutput\nYes\n2 3 1 \n\nInput\n2 2\n11 14\n17 18\n2 9\n\nOutput\nNo\n\nInput\n2 1\n1 1\n1000000000000000000 1000000000000000000\n999999999999999999\n\nOutput\nYes\n1 \n\n-----Note-----\n\nIn the first sample test you can, for example, place the second bridge between points 3 and 8, place the third bridge between points 7 and 10 and place the first bridge between points 10 and 14.\n\nIn the second sample test the first bridge is too short and the second bridge is too long, so the solution doesn't exist.\n-/\n\n-- Simplified gaps for type checking", "vc-preamble": "structure BridgeProblemInputs where\n  n : Nat\n  m : Nat\n  islands : List (List Int)\n  bridges : List Int", "vc-helpers": "", "vc-definitions": "def solve_bridge_problem (n m : Nat) (islands : List (List Int)) (bridges : List Int) : String :=\nsorry\n\ndef verify_bridge_placement (bridges : List Int) (gaps : List (Int × Int)) (result : String) : Bool :=\nsorry\n\ndef string_to_nat_array (s : String) : List Nat :=\nsorry", "vc-theorems": "def get_indices (result : String) : List Nat :=\n  if result = \"No\" then []\n  else string_to_nat_array (result.splitOn \"\\n\").head!\n\ntheorem result_format_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  (result = \"No\") ∨\n  (∃ nums : List Nat, result = s!\"Yes\\n{nums}\" ∧ nums.length = n - 1) :=\nsorry\n\ntheorem bridge_placement_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let gaps := List.range (n-1) |>.map (λ i => (1, 1))\n  verify_bridge_placement bridges gaps result = true :=\nsorry\n\ntheorem bridge_indices_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let indices := get_indices result\n  result = \"No\" ∨\n  (∀ i ∈ indices, 1 ≤ i ∧ i ≤ m) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 'Yes\\n2 3 1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 4 4 [[1, 4], [7, 8], [9, 10], [12, 14]] [4, 5, 3, 8]\n\n/--\ninfo: 'No'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 2 [[11, 14], [17, 18]] [2, 9]\n\n/--\ninfo: 'Yes\\n1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 1 [[1, 1], [1000000000000000000, 1000000000000000000]] [999999999999999999]"}
{"id": "fvapps_002014", "vc-description": "/-\nSherlock has a new girlfriend (so unlike him!). Valentine's day is coming and he wants to gift her some jewelry.\n\nHe bought n pieces of jewelry. The i-th piece has price equal to i + 1, that is, the prices of the jewelry are 2, 3, 4, ... n + 1.\n\nWatson gave Sherlock a challenge to color these jewelry pieces such that two pieces don't have the same color if the price of one piece is a prime divisor of the price of the other piece. Also, Watson asked him to minimize the number of different colors used.\n\nHelp Sherlock complete this trivial task.\n\n-----Input-----\n\nThe only line contains single integer n (1 ≤ n ≤ 100000) — the number of jewelry pieces.\n\n-----Output-----\n\nThe first line of output should contain a single integer k, the minimum number of colors that can be used to color the pieces of jewelry with the given constraints.\n\nThe next line should consist of n space-separated integers (between 1 and k) that specify the color of each piece in the order of increasing price.\n\nIf there are multiple ways to color the pieces using k colors, you can output any of them.\n\n-----Examples-----\nInput\n3\n\nOutput\n2\n1 1 2 \nInput\n4\n\nOutput\n2\n2 1 1 2\n\n-----Note-----\n\nIn the first input, the colors for first, second and third pieces of jewelry having respective prices 2, 3 and 4 are 1, 1 and 2 respectively.\n\nIn this case, as 2 is a prime divisor of 4, colors of jewelry having prices 2 and 4 must be distinct.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef color_jewelry (n : Nat) : Nat × List Nat :=\n  sorry", "vc-theorems": "theorem k_bounds (n : Nat) (h : n ≥ 1) :\n  let (k, colors) := color_jewelry n\n  k = 1 ∨ k = 2 :=\nsorry\n\ntheorem large_n_coloring (n : Nat) (h1 : n > 2) :\n  let (k, colors) := color_jewelry n\n  k = 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002015", "vc-description": "/-\nFox Ciel is playing a card game with her friend Fox Jiro. There are n piles of cards on the table. And there is a positive integer on each card.\n\nThe players take turns and Ciel takes the first turn. In Ciel's turn she takes a card from the top of any non-empty pile, and in Jiro's turn he takes a card from the bottom of any non-empty pile. Each player wants to maximize the total sum of the cards he took. The game ends when all piles become empty.\n\nSuppose Ciel and Jiro play optimally, what is the score of the game?\n\n-----Input-----\n\nThe first line contain an integer n (1 ≤ n ≤ 100). Each of the next n lines contains a description of the pile: the first integer in the line is s_{i} (1 ≤ s_{i} ≤ 100) — the number of cards in the i-th pile; then follow s_{i} positive integers c_1, c_2, ..., c_{k}, ..., c_{s}_{i} (1 ≤ c_{k} ≤ 1000) — the sequence of the numbers on the cards listed from top of the current pile to bottom of the pile.\n\n-----Output-----\n\nPrint two integers: the sum of Ciel's cards and the sum of Jiro's cards if they play optimally.\n\n-----Examples-----\nInput\n2\n1 100\n2 1 10\n\nOutput\n101 10\n\nInput\n1\n9 2 8 6 5 9 4 7 1 3\n\nOutput\n30 15\n\nInput\n3\n3 1 3 2\n3 5 4 6\n2 8 7\n\nOutput\n18 18\n\nInput\n3\n3 1000 1000 1000\n6 1000 1000 1000 1000 1000 1000\n5 1000 1000 1000 1000 1000\n\nOutput\n7000 7000\n\n-----Note-----\n\nIn the first example, Ciel will take the cards with number 100 and 1, Jiro will take the card with number 10.\n\nIn the second example, Ciel will take cards with numbers 2, 8, 6, 5, 9 and Jiro will take cards with numbers 4, 7, 1, 3.\n-/", "vc-preamble": "def Card := Nat\n\ndef Pile := List Card", "vc-helpers": "", "vc-definitions": "def Game := List (Nat × Pile)\n\ndef listSum (l : List Nat) : Nat :=\n  sorry\n\ndef solve_card_game (g : Game) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem solve_card_game_returns_tuple (g : Game) :\n  let (a, b) := solve_card_game g\n  a ≥ 0 ∧ b ≥ 0 :=\nsorry\n\ntheorem sum_scores_equals_input (g : Game) :\n  let (a, b) := solve_card_game g\n  let total := g.map (fun p => listSum p.2) |> listSum\n  a + b = total :=\nsorry\n\ntheorem first_pile_split_correctly (g : Game) (h : g ≠ []) :\n  let first := g.head h\n  let k := first.1 / 2 + 1\n  let first_sum := listSum first.2\n  let rest_sum := g.tail.map (fun p => listSum p.2) |> listSum\n  let (a, b) := solve_card_game g\n  a + b = first_sum + rest_sum :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: (101, 10)\n-/\n#guard_msgs in\n#eval solve_card_game [[1, 100], [2, 1, 10]]\n\n/--\ninfo: (30, 15)\n-/\n#guard_msgs in\n#eval solve_card_game [[9, 2, 8, 6, 5, 9, 4, 7, 1, 3]]\n\n/--\ninfo: (18, 18)\n-/\n#guard_msgs in\n#eval solve_card_game [[3, 1, 3, 2], [3, 5, 4, 6], [2, 8, 7]]"}
{"id": "fvapps_002018", "vc-description": "/-\n10^{10^{10}} participants, including Takahashi, competed in two programming contests.\nIn each contest, all participants had distinct ranks from first through 10^{10^{10}}-th.\nThe score of a participant is the product of his/her ranks in the two contests.\nProcess the following Q queries:\n - In the i-th query, you are given two positive integers A_i and B_i. Assuming that Takahashi was ranked A_i-th in the first contest and B_i-th in the second contest, find the maximum possible number of participants whose scores are smaller than Takahashi's.\n\n-----Constraints-----\n - 1 \\leq Q \\leq 100\n - 1\\leq A_i,B_i\\leq 10^9(1\\leq i\\leq Q)\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nQ\nA_1 B_1\n:\nA_Q B_Q\n\n-----Output-----\nFor each query, print the maximum possible number of participants whose scores are smaller than Takahashi's.\n\n-----Sample Input-----\n8\n1 4\n10 5\n3 3\n4 11\n8 9\n22 40\n8 36\n314159265 358979323\n\n-----Sample Output-----\n1\n12\n4\n11\n14\n57\n31\n671644785\n\nLet us denote a participant who was ranked x-th in the first contest and y-th in the second contest as (x,y).\nIn the first query, (2,1) is a possible candidate of a participant whose score is smaller than Takahashi's. There are never two or more participants whose scores are smaller than Takahashi's, so we should print 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (points : List (Nat × Nat)) : List Nat :=\nsorry\n\ndef sqrt (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_output_length {points : List (Nat × Nat)} :\n  points.length = (solve points).length :=\nsorry\n\ntheorem solve_output_bound {points : List (Nat × Nat)} (i : Fin points.length) :\n  let (a, b) := points.get i\n  let sqrt_ab := sqrt (a * b)\n  ∃ j : Fin (solve points).length, (solve points).get j ≤ 2 * sqrt_ab :=\nsorry\n\ntheorem solve_output_nonneg {points : List (Nat × Nat)} (i : Fin (solve points).length) :\n  0 ≤ (solve points).get i :=\nsorry\n\ntheorem solve_one_input :\n  solve [(1, 1)] = [0] :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve [(1, 4)]\n\n/--\ninfo: [12, 4]\n-/\n#guard_msgs in\n#eval solve [(10, 5), (3, 3)]\n\n/--\ninfo: [0, 0, 1, 1, 2]\n-/\n#guard_msgs in\n#eval solve [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]"}
{"id": "fvapps_002019", "vc-description": "/-\nRecently, Duff has been practicing weight lifting. As a hard practice, Malek gave her a task. He gave her a sequence of weights. Weight of i-th of them is 2^{w}_{i} pounds. In each step, Duff can lift some of the remaining weights and throw them away. She does this until there's no more weight left. Malek asked her to minimize the number of steps. [Image] \n\nDuff is a competitive programming fan. That's why in each step, she can only lift and throw away a sequence of weights 2^{a}_1, ..., 2^{a}_{k} if and only if there exists a non-negative integer x such that 2^{a}_1 + 2^{a}_2 + ... + 2^{a}_{k} = 2^{x}, i. e. the sum of those numbers is a power of two.\n\nDuff is a competitive programming fan, but not a programmer. That's why she asked for your help. Help her minimize the number of steps. \n\n-----Input-----\n\nThe first line of input contains integer n (1 ≤ n ≤ 10^6), the number of weights.\n\nThe second line contains n integers w_1, ..., w_{n} separated by spaces (0 ≤ w_{i} ≤ 10^6 for each 1 ≤ i ≤ n), the powers of two forming the weights values.\n\n-----Output-----\n\nPrint the minimum number of steps in a single line.\n\n-----Examples-----\nInput\n5\n1 1 2 3 3\n\nOutput\n2\n\nInput\n4\n0 1 2 3\n\nOutput\n4\n\n-----Note-----\n\nIn the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.\n\nIn the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two.\n-/", "vc-preamble": "def count_odd_frequencies (weights : List Nat) : Nat :=\n  let freqs := weights.foldl (fun acc x =>\n    match acc.find? (fun p => p.1 = x) with\n    | some p => acc.erase p ++ [(p.1, p.2 + 1)]\n    | none => acc ++ [(x, 1)]\n    ) []\n  (freqs.filter (fun p => p.2 % 2 = 1)).length", "vc-helpers": "", "vc-definitions": "def min_steps_to_lift (n : Nat) (weights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_steps_nonneg (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≥ 0 :=\nsorry\n\ntheorem min_steps_upper_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≤ n :=\nsorry\n\ntheorem min_steps_odd_freq_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≥ count_odd_frequencies weights :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_steps_to_lift 5 [1, 1, 2, 3, 3]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_steps_to_lift 4 [0, 1, 2, 3]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval min_steps_to_lift 13 [92, 194, 580495, 0, 10855, 41704, 13, 96429, 33, 213, 0, 92, 140599]"}
{"id": "fvapps_002020", "vc-description": "/-\nLesha plays the recently published new version of the legendary game hacknet. In this version character skill mechanism was introduced. Now, each player character has exactly n skills. Each skill is represented by a non-negative integer a_{i} — the current skill level. All skills have the same maximum level A.\n\nAlong with the skills, global ranking of all players was added. Players are ranked according to the so-called Force. The Force of a player is the sum of the following values:  The number of skills that a character has perfected (i.e., such that a_{i} = A), multiplied by coefficient c_{f}. The minimum skill level among all skills (min a_{i}), multiplied by coefficient c_{m}. \n\nNow Lesha has m hacknetian currency units, which he is willing to spend. Each currency unit can increase the current level of any skill by 1 (if it's not equal to A yet). Help him spend his money in order to achieve the maximum possible value of the Force.\n\n-----Input-----\n\nThe first line of the input contains five space-separated integers n, A, c_{f}, c_{m} and m (1 ≤ n ≤ 100 000, 1 ≤ A ≤ 10^9, 0 ≤ c_{f}, c_{m} ≤ 1000, 0 ≤ m ≤ 10^15).\n\nThe second line contains exactly n integers a_{i} (0 ≤ a_{i} ≤ A), separated by spaces, — the current levels of skills.\n\n-----Output-----\n\nOn the first line print the maximum value of the Force that the character can achieve using no more than m currency units.\n\nOn the second line print n integers a'_{i} (a_{i} ≤ a'_{i} ≤ A), skill levels which one must achieve in order to reach the specified value of the Force, while using no more than m currency units. Numbers should be separated by spaces.\n\n-----Examples-----\nInput\n3 5 10 1 5\n1 3 1\n\nOutput\n12\n2 5 2 \n\nInput\n3 5 10 1 339\n1 3 1\n\nOutput\n35\n5 5 5 \n\n-----Note-----\n\nIn the first test the optimal strategy is to increase the second skill to its maximum, and increase the two others by 1.\n\nIn the second test one should increase all skills to maximum.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def list_count {α} [BEq α] (p : α → Bool) (l : List α) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (if p x then 1 else 0) + list_count p xs\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def solve_hacknet (n A cf cm m : Nat) (skills : List Nat) : Nat × List Nat :=\n  sorry", "vc-theorems": "theorem solution_invariants {n A cf cm m : Nat} {skills ans : List Nat} {max_level : Nat}\n  (h : solve_hacknet n A cf cm m skills = (max_level, ans)) :\n  (ans.length = n) ∧\n  (∀ x ∈ ans, x ≤ A) ∧\n  (list_sum (List.map (λ i => max 0 ((ans.get! i) - (skills.get! i)))\n    (List.range n)) ≤ m) ∧\n  (max_level = cf * (list_count (λ x => x == A) ans) + cm * (List.foldl min A ans)) :=\nsorry\n\ntheorem zero_money {n A cf : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A cf 1 0 skills = (0, skills) :=\nsorry\n\ntheorem infinite_money {n A : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A 1 1 (Nat.max A 0) skills =\n    (n + A, List.replicate n A) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002025", "vc-description": "/-\nYou are given a string s, consisting of lowercase English letters, and the integer m.\n\nOne should choose some symbols from the given string so that any contiguous subsegment of length m has at least one selected symbol. Note that here we choose positions of symbols, not the symbols themselves.\n\nThen one uses the chosen symbols to form a new string. All symbols from the chosen position should be used, but we are allowed to rearrange them in any order.\n\nFormally, we choose a subsequence of indices 1 ≤ i_1 < i_2 < ... < i_{t} ≤ |s|. The selected sequence must meet the following condition: for every j such that 1 ≤ j ≤ |s| - m + 1, there must be at least one selected index that belongs to the segment [j,  j + m - 1], i.e. there should exist a k from 1 to t, such that j ≤ i_{k} ≤ j + m - 1.\n\nThen we take any permutation p of the selected indices and form a new string s_{i}_{p}_1s_{i}_{p}_2... s_{i}_{p}_{t}.\n\nFind the lexicographically smallest string, that can be obtained using this procedure.\n\n-----Input-----\n\nThe first line of the input contains a single integer m (1 ≤ m ≤ 100 000).\n\nThe second line contains the string s consisting of lowercase English letters. It is guaranteed that this string is non-empty and its length doesn't exceed 100 000. It is also guaranteed that the number m doesn't exceed the length of the string s.\n\n-----Output-----\n\nPrint the single line containing the lexicographically smallest string, that can be obtained using the procedure described above.\n\n-----Examples-----\nInput\n3\ncbabc\n\nOutput\na\n\nInput\n2\nabcab\n\nOutput\naab\n\nInput\n3\nbcabcbaccba\n\nOutput\naaabb\n\n-----Note-----\n\nIn the first sample, one can choose the subsequence {3} and form a string \"a\".\n\nIn the second sample, one can choose the subsequence {1, 2, 4} (symbols on this positions are 'a', 'b' and 'a') and rearrange the chosen symbols to form a string \"aab\".\n-/", "vc-preamble": "def isSorted (l : List Char) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def findSmallestSubstring (m : Nat) (s : String) : String :=\nsorry", "vc-theorems": "theorem find_smallest_substring_lowercase (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c.isLower ∨ r = \"\" :=\nsorry\n\ntheorem find_smallest_substring_sorted (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  isSorted r.data ∨ r = \"\" :=\nsorry\n\ntheorem find_smallest_substring_length (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  r.length ≤ s.length :=\nsorry\n\ntheorem find_smallest_substring_chars_subset (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c ∈ s.data :=\nsorry\n\ntheorem find_smallest_substring_alternating (m : Nat) :\n  let s := \"ababab\"\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c = 'a' ∨ c = 'b' :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"cbabc\"\n\n/--\ninfo: 'aab'\n-/\n#guard_msgs in\n#eval find_smallest_substring 2 \"abcab\"\n\n/--\ninfo: 'aaabb'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"bcabcbaccba\""}
{"id": "fvapps_002027", "vc-description": "/-\nSam has been teaching Jon the Game of Stones to sharpen his mind and help him devise a strategy to fight the white walkers. The rules of this game are quite simple:  The game starts with n piles of stones indexed from 1 to n. The i-th pile contains s_{i} stones. The players make their moves alternatively. A move is considered as removal of some number of stones from a pile. Removal of 0 stones does not count as a move. The player who is unable to make a move loses.\n\nNow Jon believes that he is ready for battle, but Sam does not think so. To prove his argument, Sam suggested that they play a modified version of the game.\n\nIn this modified version, no move can be made more than once on a pile. For example, if 4 stones are removed from a pile, 4 stones cannot be removed from that pile again.\n\nSam sets up the game and makes the first move. Jon believes that Sam is just trying to prevent him from going to battle. Jon wants to know if he can win if both play optimally.\n\n-----Input-----\n\nFirst line consists of a single integer n (1 ≤ n ≤ 10^6) — the number of piles.\n\nEach of next n lines contains an integer s_{i} (1 ≤ s_{i} ≤ 60) — the number of stones in i-th pile.\n\n-----Output-----\n\nPrint a single line containing \"YES\" (without quotes) if Jon wins, otherwise print \"NO\" (without quotes)\n\n-----Examples-----\nInput\n1\n5\n\nOutput\nNO\nInput\n2\n1\n2\n\nOutput\nYES\n\n-----Note-----\n\nIn the first case, Sam removes all the stones and Jon loses.\n\nIn second case, the following moves are possible by Sam: $\\{1,2 \\} \\rightarrow \\{0,2 \\}, \\{1,2 \\} \\rightarrow \\{1,0 \\}, \\{1,2 \\} \\rightarrow \\{1,1 \\}$ \n\nIn each of these cases, last move can be made by Jon to win the game as follows: $\\{0,2 \\} \\rightarrow \\{0,0 \\}, \\{1,0 \\} \\rightarrow \\{0,0 \\}, \\{1,1 \\} \\rightarrow \\{0,1 \\}$\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- We can represent permutation invariance by showing that if we have\n    two lists with the same elements (possibly in different order),\n    they produce the same result -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def stones_game (n : Nat) (stones : List Nat) : String :=\nsorry", "vc-theorems": "theorem stones_game_output_valid (n : Nat) (stones : List Nat) :\n  stones_game n stones = \"YES\" ∨ stones_game n stones = \"NO\" :=\nsorry\n\ntheorem stones_game_consistent (stones : List Nat) :\n  let n := stones.length\n  stones_game n stones = stones_game n stones :=\nsorry\n\ntheorem stones_game_permutation_invariant (stones stones_permuted : List Nat) :\n  stones.length = stones_permuted.length →\n  stones_game stones.length stones = stones_game stones_permuted.length stones_permuted :=\nsorry\n\ntheorem stones_game_identical_stones (n : Nat) :\n  let stones := List.replicate n 1\n  stones_game n stones = stones_game n stones :=\nsorry", "vc-postamble": "/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 1 [5]\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval stones_game 2 [1, 2]\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 3 [34, 44, 21]"}
{"id": "fvapps_002029", "vc-description": "/-\nBessie and the cows are playing with sequences and need your help. They start with a sequence, initially containing just the number 0, and perform n operations. Each operation is one of the following:  Add the integer x_{i} to the first a_{i} elements of the sequence.  Append an integer k_{i} to the end of the sequence. (And hence the size of the sequence increases by 1)  Remove the last element of the sequence. So, the size of the sequence decreases by one. Note, that this operation can only be done if there are at least two elements in the sequence. \n\nAfter each operation, the cows would like to know the average of all the numbers in the sequence. Help them!\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 2·10^5) — the number of operations. The next n lines describe the operations. Each line will start with an integer t_{i} (1 ≤ t_{i} ≤ 3), denoting the type of the operation (see above). If t_{i} = 1, it will be followed by two integers a_{i}, x_{i} (|x_{i}| ≤ 10^3; 1 ≤ a_{i}). If t_{i} = 2, it will be followed by a single integer k_{i} (|k_{i}| ≤ 10^3). If t_{i} = 3, it will not be followed by anything.\n\nIt is guaranteed that all operations are correct (don't touch nonexistent elements) and that there will always be at least one element in the sequence.\n\n-----Output-----\n\nOutput n lines each containing the average of the numbers in the sequence after the corresponding operation.\n\nThe answer will be considered correct if its absolute or relative error doesn't exceed 10^{ - 6}.\n\n-----Examples-----\nInput\n5\n2 1\n3\n2 3\n2 1\n3\n\nOutput\n0.500000\n0.000000\n1.500000\n1.333333\n1.500000\n\nInput\n6\n2 1\n1 2 20\n2 2\n1 2 -3\n3\n3\n\nOutput\n0.500000\n20.500000\n14.333333\n12.333333\n17.500000\n17.000000\n\n-----Note-----\n\nIn the second sample, the sequence becomes $\\{0 \\} \\rightarrow \\{0,1 \\} \\rightarrow \\{20,21 \\} \\rightarrow \\{20,21,2 \\} \\rightarrow \\{17,18,2 \\} \\rightarrow \\{17,18 \\} \\rightarrow \\{17 \\}$\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def running_sum (xs: List Int) : List Int :=\n  match xs with\n  | [] => []\n  | x::xs' => x :: (running_sum xs').map (λ s => s + x)", "vc-helpers": "", "vc-definitions": "def Operation := List Int\n\ndef solve_sequence_ops (ops: List Operation) : List Float :=\n  sorry", "vc-theorems": "theorem sequence_ops_result_properties (ops: List Operation) :\n  let result := solve_sequence_ops ops\n  (result.length = ops.length) ∧\n  (∀ x ∈ result, -1000000 ≤ x ∧ x ≤ 1000000) :=\nsorry\n\ntheorem remove_maintains_min_size (ops: List Operation) :\n  let remove_count := (ops.filter (λ op => op.head! = 3)).length\n  remove_count ≤ ops.length :=\nsorry\n\ntheorem append_only_averages (values: List Int)\n  (h1: ∀ x ∈ values, 1 ≤ x ∧ x ≤ 1000)\n  (h2: values.length ≥ 1 ∧ values.length ≤ 10) :\n  let ops := values.map (λ x => [2, x])\n  let result := solve_sequence_ops ops\n  ∀ i: Nat, i < values.length →\n    let sum := (running_sum values)[i]!\n    Float.abs (result[i]! - Float.ofInt (sum + 0) / Float.ofNat (i + 2)) < 0.000001 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002031", "vc-description": "/-\nPolycarp starts his own business. Tomorrow will be the first working day of his car repair shop. For now the car repair shop is very small and only one car can be repaired at a given time.\n\nPolycarp is good at marketing, so he has already collected n requests from clients. The requests are numbered from 1 to n in order they came.\n\nThe i-th request is characterized by two values: s_{i} — the day when a client wants to start the repair of his car, d_{i} — duration (in days) to repair the car. The days are enumerated from 1, the first day is tomorrow, the second day is the day after tomorrow and so on.\n\nPolycarp is making schedule by processing requests in the order from the first to the n-th request. He schedules the i-th request as follows:  If the car repair shop is idle for d_{i} days starting from s_{i} (s_{i}, s_{i} + 1, ..., s_{i} + d_{i} - 1), then these days are used to repair a car of the i-th client.  Otherwise, Polycarp finds the first day x (from 1 and further) that there are d_{i} subsequent days when no repair is scheduled starting from x. In other words he chooses the smallest positive x that all days x, x + 1, ..., x + d_{i} - 1 are not scheduled for repair of any car. So, the car of the i-th client will be repaired in the range [x, x + d_{i} - 1]. It is possible that the day x when repair is scheduled to start will be less than s_{i}. \n\nGiven n requests, you are asked to help Polycarp schedule all of them according to the rules above.\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 200) — the number of requests from clients.\n\nThe following n lines contain requests, one request per line. The i-th request is given as the pair of integers s_{i}, d_{i} (1 ≤ s_{i} ≤ 10^9, 1 ≤ d_{i} ≤ 5·10^6), where s_{i} is the preferred time to start repairing the i-th car, d_{i} is the number of days to repair the i-th car.\n\nThe requests should be processed in the order they are given in the input.\n\n-----Output-----\n\nPrint n lines. The i-th line should contain two integers — the start day to repair the i-th car and the finish day to repair the i-th car.\n\n-----Examples-----\nInput\n3\n9 2\n7 3\n2 4\n\nOutput\n9 10\n1 3\n4 7\n\nInput\n4\n1000000000 1000000\n1000000000 1000000\n100000000 1000000\n1000000000 1000000\n\nOutput\n1000000000 1000999999\n1 1000000\n100000000 100999999\n1000001 2000000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def scheduleRepairs (requests : List (Nat × Nat)) : List (Nat × Nat) :=\nsorry\n\ndef isNonOverlapping (intervals : List (Nat × Nat)) : Bool :=\nsorry\n\ndef totalDurationPreserved (requests : List (Nat × Nat)) (result : List (Nat × Nat)) : Bool :=\nsorry\n\ndef allPositive (intervals : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem schedule_repairs_non_overlapping (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true :=\nsorry\n\ntheorem schedule_repairs_preserves_duration (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  totalDurationPreserved requests result = true :=\nsorry\n\ntheorem schedule_repairs_all_positive (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  allPositive result = true :=\nsorry\n\ntheorem schedule_repairs_preserves_length (requests : List (Nat × Nat)) :\n  let result := scheduleRepairs requests\n  result.length = requests.length :=\nsorry\n\ntheorem schedule_repairs_handles_same_start (requests : List (Nat × Nat))\n  (h : ∀ p ∈ requests, p.fst = 1) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true ∧ totalDurationPreserved requests result = true :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [(9, 10), (1, 3), (4, 7)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(9, 2), (7, 3), (2, 4)]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval schedule_repairs [(1000000000, 1000000), (1000000000, 1000000), (100000000, 1000000), (1000000000, 1000000)]\n\n/--\ninfo: [(1, 5000000)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(1, 5000000)]"}
{"id": "fvapps_002032", "vc-description": "/-\nOleg the bank client and Igor the analyst are arguing again. This time, they want to pick a gift as a present for their friend, ZS the coder. After a long thought, they decided that their friend loves to eat carrots the most and thus they want to pick the best carrot as their present.\n\nThere are n carrots arranged in a line. The i-th carrot from the left has juiciness a_{i}. Oleg thinks ZS loves juicy carrots whereas Igor thinks that he hates juicy carrots. Thus, Oleg would like to maximize the juiciness of the carrot they choose while Igor would like to minimize the juiciness of the carrot they choose.\n\nTo settle this issue, they decided to play a game again. Oleg and Igor take turns to play the game. In each turn, a player can choose a carrot from either end of the line, and eat it. The game ends when only one carrot remains. Oleg moves first. The last remaining carrot will be the carrot that they will give their friend, ZS.\n\nOleg is a sneaky bank client. When Igor goes to a restroom, he performs k moves before the start of the game. Each move is the same as above (eat a carrot from either end of the line). After Igor returns, they start the game with Oleg still going first. \n\nOleg wonders: for each k such that 0 ≤ k ≤ n - 1, what is the juiciness of the carrot they will give to ZS if he makes k extra moves beforehand and both players play optimally?\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 ≤ n ≤ 3·10^5) — the total number of carrots.\n\nThe next line contains n space-separated integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). Here a_{i} denotes the juiciness of the i-th carrot from the left of the line.\n\n-----Output-----\n\nOutput n space-separated integers x_0, x_1, ..., x_{n} - 1. Here, x_{i} denotes the juiciness of the carrot the friends will present to ZS if k = i.\n\n-----Examples-----\nInput\n4\n1 2 3 5\n\nOutput\n3 3 5 5\n\nInput\n5\n1000000000 1000000000 1000000000 1000000000 1\n\nOutput\n1000000000 1000000000 1000000000 1000000000 1000000000\n\n-----Note-----\n\nFor the first example, \n\nWhen k = 0, one possible optimal game is as follows: Oleg eats the carrot with juiciness 1. Igor eats the carrot with juiciness 5. Oleg eats the carrot with juiciness 2. The remaining carrot has juiciness 3.\n\nWhen k = 1, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2. Igor eats the carrot with juiciness 5. The remaining carrot has juiciness 3.\n\nWhen k = 2, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3. The remaining carrot has juiciness 5.\n\nWhen k = 3, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3 beforehand. The remaining carrot has juiciness 5.\n\nThus, the answer is 3, 3, 5, 5.\n\nFor the second sample, Oleg can always eat the carrot with juiciness 1 since he always moves first. So, the remaining carrot will always have juiciness 1000000000.\n-/", "vc-preamble": "abbrev min' (a b : Nat) : Nat := if a ≤ b then a else b\n\ndef list_maximum (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => List.foldl Nat.max x xs", "vc-helpers": "", "vc-definitions": "def solve_carrot_game (n : Nat) (A : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem carrot_game_output_length {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  (solve_carrot_game n A).length = n :=\nsorry\n\ntheorem carrot_game_max_preserved {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  list_maximum (solve_carrot_game n A) = list_maximum A :=\nsorry\n\ntheorem carrot_game_elements_valid {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  ∀ x ∈ (solve_carrot_game n A),\n    x ∈ A ∨ ∃ (i : Fin (A.length - 1)),\n      x = min' (A[i]) (A[i.val + 1]) :=\nsorry\n\ntheorem carrot_game_identical_elements {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n)\n  (h3 : ∀ x ∈ A, x = 5) :\n  ∀ x ∈ (solve_carrot_game n A), x = 5 :=\nsorry\n\ntheorem carrot_game_last_element_is_max {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  List.getLast! (solve_carrot_game n A) = list_maximum A :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [3, 3, 5, 5]\n-/\n#guard_msgs in\n#eval solve_carrot_game 4 [1, 2, 3, 5]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_carrot_game 5 [1000000000, 1000000000, 1000000000, 1000000000, 1]\n\n/--\ninfo: [2, 8, 8]\n-/\n#guard_msgs in\n#eval solve_carrot_game 3 [2, 8, 2]"}
{"id": "fvapps_002035", "vc-description": "/-\nThere are many anime that are about \"love triangles\": Alice loves Bob, and Charlie loves Bob as well, but Alice hates Charlie. You are thinking about an anime which has n characters. The characters are labeled from 1 to n. Every pair of two characters can either mutually love each other or mutually hate each other (there is no neutral state).\n\nYou hate love triangles (A-B are in love and B-C are in love, but A-C hate each other), and you also hate it when nobody is in love. So, considering any three characters, you will be happy if exactly one pair is in love (A and B love each other, and C hates both A and B), or if all three pairs are in love (A loves B, B loves C, C loves A).\n\nYou are given a list of m known relationships in the anime. You know for sure that certain pairs love each other, and certain pairs hate each other. You're wondering how many ways you can fill in the remaining relationships so you are happy with every triangle. Two ways are considered different if two characters are in love in one way but hate each other in the other. Print this count modulo 1 000 000 007.\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).\n\nThe next m lines will contain the description of the known relationships. The i-th line will contain three integers a_{i}, b_{i}, c_{i}. If c_{i} is 1, then a_{i} and b_{i} are in love, otherwise, they hate each other (1 ≤ a_{i}, b_{i} ≤ n, a_{i} ≠ b_{i}, $c_{i} \\in \\{0,1 \\}$).\n\nEach pair of people will be described no more than once.\n\n-----Output-----\n\nPrint a single integer equal to the number of ways to fill in the remaining pairs so that you are happy with every triangle modulo 1 000 000 007. \n\n-----Examples-----\nInput\n3 0\n\nOutput\n4\n\nInput\n4 4\n1 2 1\n2 3 1\n3 4 0\n4 1 0\n\nOutput\n1\n\nInput\n4 4\n1 2 1\n2 3 1\n3 4 0\n4 1 1\n\nOutput\n0\n\n-----Note-----\n\nIn the first sample, the four ways are to:   Make everyone love each other  Make 1 and 2 love each other, and 3 hate 1 and 2 (symmetrically, we get 3 ways from this). \n\nIn the second sample, the only possible solution is to make 1 and 3 love each other and 2 and 4 hate each other.\n-/", "vc-preamble": "def DisjointSet := Nat → Nat", "vc-helpers": "", "vc-definitions": "def is_valid_relationship (n : Nat) (relationships : List (Nat × Nat × Nat)) : Bool :=\nsorry\n\ndef solve_love_triangles (n : Nat) (relationships : List (Nat × Nat × Nat)) : Nat :=\nsorry\n\ndef DisjointSet.find_set (ds : DisjointSet) (x : Nat) : Nat :=\nsorry\n\ndef DisjointSet.union (ds : DisjointSet) (x y : Nat) : DisjointSet :=\nsorry", "vc-theorems": "theorem empty_relationships_power_two (n : Nat) (h : n > 0) :\n  solve_love_triangles n [] = (2^(n-1)) % (10^9 + 7) :=\nsorry\n\ntheorem result_within_modulo_bounds (n : Nat) (relationships : List (Nat × Nat × Nat)) :\n  0 ≤ solve_love_triangles n relationships ∧\n  solve_love_triangles n relationships < 10^9 + 7 :=\nsorry\n\ntheorem contradictory_relationships_zero (n : Nat) (h : n ≥ 2) :\n  solve_love_triangles n [(1,2,1), (2,1,0)] = 0 :=\nsorry\n\ntheorem result_modularity (n : Nat) (relationships : List (Nat × Nat × Nat)) :\n  solve_love_triangles n relationships % (10^9 + 7) =\n  solve_love_triangles n relationships :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_love_triangles 3 []\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 0)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 1)]"}
{"id": "fvapps_002036", "vc-description": "/-\nIahub helps his grandfather at the farm. Today he must milk the cows. There are n cows sitting in a row, numbered from 1 to n from left to right. Each cow is either facing to the left or facing to the right. When Iahub milks a cow, all the cows that see the current cow get scared and lose one unit of the quantity of milk that they can give. A cow facing left sees all the cows with lower indices than her index, and a cow facing right sees all the cows with higher indices than her index. A cow that got scared once can get scared again (and lose one more unit of milk). A cow that has been milked once cannot get scared and lose any more milk. You can assume that a cow never loses all the milk she can give (a cow gives an infinitely amount of milk).\n\nIahub can decide the order in which he milks the cows. But he must milk each cow exactly once. Iahub wants to lose as little milk as possible. Print the minimum amount of milk that is lost.\n\n-----Input-----\n\nThe first line contains an integer n (1 ≤ n ≤ 200000). The second line contains n integers a_1, a_2, ..., a_{n}, where a_{i} is 0 if the cow number i is facing left, and 1 if it is facing right.\n\n-----Output-----\n\nPrint a single integer, the minimum amount of lost milk.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n-----Examples-----\nInput\n4\n0 0 1 0\n\nOutput\n1\nInput\n5\n1 0 1 0 1\n\nOutput\n3\n\n-----Note-----\n\nIn the first sample Iahub milks the cows in the following order: cow 3, cow 4, cow 2, cow 1. When he milks cow 3, cow 4 loses 1 unit of milk. After that, no more milk is lost.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_lost_milk (n: Nat) (cows: List Nat) : Nat :=\nsorry\n\ndef count_facing (cows: List Nat) (dir: Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_lost_milk_non_negative (n: Nat) (cows: List Nat) :\n  min_lost_milk n cows ≥ 0 :=\nsorry\n\ntheorem min_lost_milk_length (n: Nat) (cows: List Nat) :\n  cows.length = n → True :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 4 [0, 0, 1, 0]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_lost_milk 5 [1, 0, 1, 0, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 2 [1, 0]"}
{"id": "fvapps_002039", "vc-description": "/-\nThere are $n$ startups. Startups can be active or acquired. If a startup is acquired, then that means it has exactly one active startup that it is following. An active startup can have arbitrarily many acquired startups that are following it. An active startup cannot follow any other startup.\n\nThe following steps happen until there is exactly one active startup. The following sequence of steps takes exactly 1 day.  Two distinct active startups $A$, $B$, are chosen uniformly at random.  A fair coin is flipped, and with equal probability, $A$ acquires $B$ or $B$ acquires $A$ (i.e. if $A$ acquires $B$, then that means $B$'s state changes from active to acquired, and its starts following $A$).  When a startup changes from active to acquired, all of its previously acquired startups become active. \n\nFor example, the following scenario can happen: Let's say $A$, $B$ are active startups. $C$, $D$, $E$ are acquired startups under $A$, and $F$, $G$ are acquired startups under $B$: [Image]\n\nActive startups are shown in red. \n\nIf $A$ acquires $B$, then the state will be $A$, $F$, $G$ are active startups. $C$, $D$, $E$, $B$ are acquired startups under $A$. $F$ and $G$ have no acquired startups: $G$ \n\nIf instead, $B$ acquires $A$, then the state will be $B$, $C$, $D$, $E$ are active startups. $F$, $G$, $A$ are acquired startups under $B$. $C$, $D$, $E$ have no acquired startups: [Image] \n\nYou are given the initial state of the startups. For each startup, you are told if it is either acquired or active. If it is acquired, you are also given the index of the active startup that it is following.\n\nYou're now wondering, what is the expected number of days needed for this process to finish with exactly one active startup at the end.\n\nIt can be shown the expected number of days can be written as a rational number $P/Q$, where $P$ and $Q$ are co-prime integers, and $Q \\not= 0 \\pmod{10^9+7}$. Return the value of $P \\cdot Q^{-1}$ modulo $10^9+7$.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 500$), the number of startups.\n\nThe next line will contain $n$ space-separated integers $a_1, a_2, \\ldots, a_n$ ($a_i = -1$ or $1 \\leq a_i \\leq n$). If $a_i = -1$, then that means startup $i$ is active. Otherwise, if $1 \\leq a_i \\leq n$, then startup $i$ is acquired, and it is currently following startup $a_i$. It is guaranteed if $a_i \\not= -1$, then $a_{a_i} =-1$ (that is, all startups that are being followed are active).\n\n-----Output-----\n\nPrint a single integer, the expected number of days needed for the process to end with exactly one active startup, modulo $10^9+7$.\n\n-----Examples-----\nInput\n3\n-1 -1 -1\n\nOutput\n3\n\nInput\n2\n2 -1\n\nOutput\n0\n\nInput\n40\n3 3 -1 -1 4 4 -1 -1 -1 -1 -1 10 10 10 10 10 10 4 20 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 3 3 3 3 3 3 3 3\n\nOutput\n755808950\n\n-----Note-----\n\nIn the first sample, there are three active startups labeled $1$, $2$ and $3$, and zero acquired startups. Here's an example of how one scenario can happen  Startup $1$ acquires startup $2$ (This state can be represented by the array $[-1, 1, -1]$)  Startup $3$ acquires startup $1$ (This state can be represented by the array $[3, -1, -1]$)  Startup $2$ acquires startup $3$ (This state can be represented by the array $[-1, -1, 2]$).  Startup $2$ acquires startup $1$ (This state can be represented by the array $[2, -1, 2]$). \n\nAt this point, there is only one active startup, and this sequence of steps took $4$ days. It can be shown the expected number of days is $3$.\n\nFor the second sample, there is only one active startup, so we need zero days.\n\nFor the last sample, remember to take the answer modulo $10^9+7$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_startups (n : Nat) (arr : List Int) : Nat :=\n  sorry\n\ndef pow (base : Nat) (exp : Nat) (m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_in_valid_range (n : Nat) (arr : List Int) (h₁ : n > 0) (h₂ : arr.length = n) :\n  let result := solve_startups n arr\n  0 ≤ result ∧ result < 1000000007 :=\nsorry\n\ntheorem array_length_matches_n (n : Nat) (arr : List Int)\n  (h₁ : n > 0) (h₂ : arr.length ≥ 1) :\n  let truncated := (List.replicate n arr.head!).take n\n  let result := solve_startups n truncated\n  0 ≤ result ∧ result < 1000000007 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_startups 3 [-1, -1, -1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_startups 2 [2, -1]\n\n/--\ninfo: 755808950\n-/\n#guard_msgs in\n#eval solve_startups 40 [3, 3, -1, -1, 4, 4, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 4, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3]"}
{"id": "fvapps_002040", "vc-description": "/-\nNauuo is a girl who loves drawing circles.\n\nOne day she has drawn a circle and wanted to draw a tree on it.\n\nThe tree is a connected undirected graph consisting of $n$ nodes and $n-1$ edges. The nodes are numbered from $1$ to $n$.\n\nNauuo wants to draw a tree on the circle, the nodes of the tree should be in $n$ distinct points on the circle, and the edges should be straight without crossing each other.\n\n\"Without crossing each other\" means that every two edges have no common point or the only common point is an endpoint of both edges.\n\nNauuo wants to draw the tree using a permutation of $n$ elements. A permutation of $n$ elements is a sequence of integers $p_1,p_2,\\ldots,p_n$ in which every integer from $1$ to $n$ appears exactly once.\n\nAfter a permutation is chosen Nauuo draws the $i$-th node in the $p_i$-th point on the circle, then draws the edges connecting the nodes.\n\nThe tree is given, Nauuo wants to know how many permutations are there so that the tree drawn satisfies the rule (the edges are straight without crossing each other). She only wants to know the answer modulo $998244353$, can you help her?\n\nIt is obvious that whether a permutation is valid or not does not depend on which $n$ points on the circle are chosen.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($2\\le n\\le 2\\cdot 10^5$) — the number of nodes in the tree.\n\nEach of the next $n-1$ lines contains two integers $u$ and $v$ ($1\\le u,v\\le n$), denoting there is an edge between $u$ and $v$.\n\nIt is guaranteed that the given edges form a tree.\n\n-----Output-----\n\nThe output contains a single integer — the number of permutations suitable to draw the given tree on a circle satisfying the rule, modulo $998244353$.\n\n-----Examples-----\nInput\n4\n1 2\n1 3\n2 4\n\nOutput\n16\nInput\n4\n1 2\n1 3\n1 4\n\nOutput\n24\n\n-----Note-----\n\nExample 1\n\nAll valid permutations and their spanning trees are as follows.\n\n[Image]\n\nHere is an example of invalid permutation: the edges $(1,3)$ and $(2,4)$ are crossed.\n\n[Image]\n\nExample 2\n\nEvery permutation leads to a valid tree, so the answer is $4! = 24$.\n-/", "vc-preamble": "def factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def count_valid_permutations (n : Nat) (edges : List (Nat × Nat)) : Nat :=\nsorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem valid_tree_construction (n : Nat) (edges : List (Nat × Nat))\n  (h1 : is_valid_tree n edges) :\n  let result := count_valid_permutations n edges\n  ∃ (k : Nat), result = k ∧\n    k > 0 ∧\n    k ≤ n * factorial n :=\nsorry\n\ntheorem mod_result (n : Nat) (edges : List (Nat × Nat)) :\n  let result := count_valid_permutations n edges\n  result < 998244353 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval count_valid_permutations 4 [(1, 2), (1, 3), (2, 4)]\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval count_valid_permutations n [(1, 2), (1, 3), (1, 4)]\n\n/--\ninfo: 144\n-/\n#guard_msgs in\n#eval count_valid_permutations 6 [(2, 1), (3, 2), (4, 1), (5, 4), (1, 6)]"}
{"id": "fvapps_002042", "vc-description": "/-\nMitya has a rooted tree with $n$ vertices indexed from $1$ to $n$, where the root has index $1$. Each vertex $v$ initially had an integer number $a_v \\ge 0$ written on it. For every vertex $v$ Mitya has computed $s_v$: the sum of all values written on the vertices on the path from vertex $v$ to the root, as well as $h_v$ — the depth of vertex $v$, which denotes the number of vertices on the path from vertex $v$ to the root. Clearly, $s_1=a_1$ and $h_1=1$.\n\nThen Mitya erased all numbers $a_v$, and by accident he also erased all values $s_v$ for vertices with even depth (vertices with even $h_v$). Your task is to restore the values $a_v$ for every vertex, or determine that Mitya made a mistake. In case there are multiple ways to restore the values, you're required to find one which minimizes the total sum of values $a_v$ for all vertices in the tree.\n\n-----Input-----\n\nThe first line contains one integer $n$ — the number of vertices in the tree ($2 \\le n \\le 10^5$). The following line contains integers $p_2$, $p_3$, ... $p_n$, where $p_i$ stands for the parent of vertex with index $i$ in the tree ($1 \\le p_i < i$). The last line contains integer values $s_1$, $s_2$, ..., $s_n$ ($-1 \\le s_v \\le 10^9$), where erased values are replaced by $-1$.\n\n-----Output-----\n\nOutput one integer — the minimum total sum of all values $a_v$ in the original tree, or $-1$ if such tree does not exist.\n\n-----Examples-----\nInput\n5\n1 1 1 1\n1 -1 -1 -1 -1\n\nOutput\n1\n\nInput\n5\n1 2 3 1\n1 -1 2 -1 -1\n\nOutput\n2\n\nInput\n3\n1 2\n2 -1 1\n\nOutput\n-1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_tree (n : Nat) (parents : List Nat) : Bool :=\n  sorry\n\ndef solve_tree_values (n : Nat) (parents : List Nat) (sums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem single_node_tree (n : Int) (h : n > 0) :\n  solve_tree_values 1 [] [n] = n :=\nsorry\n\ntheorem star_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3 : ∀ p ∈ parents, p = 1)\n  (h4 : values.length = n)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if ∃ v ∈ values, v < 0\n  then result ≥ -1\n  else result ≥ values.get! 0 :=\nsorry\n\ntheorem path_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3 : values.length = n)\n  (h4 : ∀ (i : Nat), i < parents.length → parents.get! i ≤ i + 1)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if ∃ v ∈ values, v < 0\n  then result ≥ -1\n  else result ≥ values.get! 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 1, 1, 1] [1, -1, -1, -1, -1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 2, 3, 1] [1, -1, 2, -1, -1]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_tree_values 3 [1, 2] [2, -1, 1]"}
{"id": "fvapps_002044", "vc-description": "/-\nYou are given a Young diagram. \n\nGiven diagram is a histogram with $n$ columns of lengths $a_1, a_2, \\ldots, a_n$ ($a_1 \\geq a_2 \\geq \\ldots \\geq a_n \\geq 1$). [Image] Young diagram for $a=[3,2,2,2,1]$. \n\nYour goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a $1 \\times 2$ or $2 \\times 1$ rectangle.\n\n-----Input-----\n\nThe first line of input contain one integer $n$ ($1 \\leq n \\leq 300\\,000$): the number of columns in the given histogram.\n\nThe next line of input contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 300\\,000, a_i \\geq a_{i+1}$): the lengths of columns.\n\n-----Output-----\n\nOutput one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.\n\n-----Example-----\nInput\n5\n3 2 2 2 1\n\nOutput\n4\n\n-----Note-----\n\nSome of the possible solutions for the example:\n\n[Image] $\\square$\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t", "vc-helpers": "", "vc-definitions": "def solve_dominos (n : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_dominos_non_negative (n : Nat) (arr : List Nat) :\n  solve_dominos n arr ≥ 0 := by\n  sorry\n\ntheorem solve_dominos_max_bound (n : Nat) (arr : List Nat) :\n  solve_dominos n arr ≤ (list_sum arr / 2) := by\n  sorry\n\ntheorem solve_dominos_single_column (h : Nat) :\n  solve_dominos 1 [h] = h / 2 := by\n  sorry\n\ntheorem solve_dominos_unit_heights (n : Nat) (arr : List Nat)\n  (h : ∀ x ∈ arr, x = 1) :\n  solve_dominos n arr = arr.length / 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 5 [3, 2, 2, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dominos 5 [1, 1, 1, 1, 1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 3 [3, 3, 3]"}
{"id": "fvapps_002045", "vc-description": "/-\nVasya's got a birthday coming up and his mom decided to give him an array of positive integers a of length n.\n\nVasya thinks that an array's beauty is the greatest common divisor of all its elements. His mom, of course, wants to give him as beautiful an array as possible (with largest possible beauty). Unfortunately, the shop has only one array a left. On the plus side, the seller said that he could decrease some numbers in the array (no more than by k for each number).\n\nThe seller can obtain array b from array a if the following conditions hold: b_{i} > 0; 0 ≤ a_{i} - b_{i} ≤ k for all 1 ≤ i ≤ n.\n\nHelp mom find the maximum possible beauty of the array she will give to Vasya (that seller can obtain).\n\n-----Input-----\n\nThe first line contains two integers n and k (1 ≤ n ≤ 3·10^5; 1 ≤ k ≤ 10^6). The second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^6) — array a.\n\n-----Output-----\n\nIn the single line print a single number — the maximum possible beauty of the resulting array.\n\n-----Examples-----\nInput\n6 1\n3 6 10 12 13 16\n\nOutput\n3\n\nInput\n5 3\n8 21 52 15 77\n\nOutput\n7\n\n-----Note-----\n\nIn the first sample we can obtain the array:\n\n3 6 9 12 12 15\n\nIn the second sample we can obtain the next array:\n\n7 21 49 14 77\n-/\n\n-- Result is positive\n\n-- Result not larger than min value\n\n-- Remainder property\n\n-- Maximum value property", "vc-preamble": "def isSorted (l : List Nat) : Prop :=\nmatch l with\n| [] => True\n| x::xs => match xs with\n  | [] => True\n  | y::_ => x ≤ y ∧ isSorted xs", "vc-helpers": "", "vc-definitions": "def get_max_beauty (n k : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem get_max_beauty_properties\n  (n k : Nat) (arr : List Nat)\n  (h₁ : n > 0)\n  (h₂ : n ≤ 100)\n  (h₃ : k ≤ 100)\n  (h₄ : arr.length > 0)\n  (h₅ : arr.length ≤ 100)\n  (h₆ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  (h₇ : isSorted arr)\n  (h₈ : arr.Nodup) :\n  let result := get_max_beauty n k arr\n\n  result > 0 ∧\n\n  result ≤ arr.head! ∧\n\n  (∀ x ∈ arr, x % result ≤ k) ∧\n\n  ∀ i ∈ List.range 10,\n    i < arr.head! - result + 1 →\n    ∃ x ∈ arr, x % (result + i + 1) > k :=\nsorry\n\ntheorem same_k_different_n\n  (arr : List Nat)\n  (h₁ : arr.length ≥ 2)\n  (h₂ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  (h₃ : isSorted arr)\n  (h₄ : arr.Nodup) :\n  get_max_beauty arr.length 1 arr = get_max_beauty (arr.length - 1) 1 arr :=\nsorry\n\ntheorem k_zero_case\n  (n : Nat)\n  (arr : List Nat)\n  (h₁ : n > 0 ∧ n ≤ 10)\n  (h₂ : arr.length > 0 ∧ arr.length ≤ 10)\n  (h₃ : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000) :\n  let result := get_max_beauty n 0 arr\n  ∀ x ∈ arr, x % result = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_beauty 6 1 [3, 6, 10, 12, 13, 16]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_beauty 5 3 [8, 21, 52, 15, 77]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval get_max_beauty 13 11 [55, 16, 26, 40, 84, 80, 48, 52, 25, 43, 75, 21, 58]"}
{"id": "fvapps_002046", "vc-description": "/-\nYou are fishing with polar bears Alice and Bob. While waiting for the fish to bite, the polar bears get bored. They come up with a game. First Alice and Bob each writes a 01-string (strings that only contain character \"0\" and \"1\") a and b. Then you try to turn a into b using two types of operations:  Write parity(a) to the end of a. For example, $1010 \\rightarrow 10100$.  Remove the first character of a. For example, $1001 \\rightarrow 001$. You cannot perform this operation if a is empty. \n\nYou can use as many operations as you want. The problem is, is it possible to turn a into b?\n\nThe parity of a 01-string is 1 if there is an odd number of \"1\"s in the string, and 0 otherwise.\n\n-----Input-----\n\nThe first line contains the string a and the second line contains the string b (1 ≤ |a|, |b| ≤ 1000). Both strings contain only the characters \"0\" and \"1\". Here |x| denotes the length of the string x.\n\n-----Output-----\n\nPrint \"YES\" (without quotes) if it is possible to turn a into b, and \"NO\" (without quotes) otherwise.\n\n-----Examples-----\nInput\n01011\n0110\n\nOutput\nYES\n\nInput\n0011\n1110\n\nOutput\nNO\n\n-----Note-----\n\nIn the first sample, the steps are as follows: 01011 → 1011 → 011 → 0110\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_possible (a b : String) : Bool :=\n  sorry\n\ndef count_ones (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem ones_diff_bounds (a b : String) :\n  is_possible a b →\n  count_ones b ≤ ((count_ones a + 1) / 2) * 2\n  ∧\n  ¬is_possible a b →\n  count_ones b > ((count_ones a + 1) / 2) * 2 :=\nsorry\n\ntheorem same_string_always_possible (s : String) :\n  is_possible s s :=\nsorry\n\ntheorem all_zeros_possible (s zeros : String) :\n  (∀ c ∈ zeros.data, c = '0') →\n  s.length = zeros.length →\n  is_possible s zeros :=\nsorry\n\ntheorem length_invariant (s ones : String) :\n  (∀ c ∈ ones.data, c = '1') →\n  is_possible s ones ↔\n  ones.length ≤ ((count_ones s + 1) / 2) * 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"01011\" \"0110\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_possible \"0011\" \"1110\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"1\" \"0\""}
{"id": "fvapps_002053", "vc-description": "/-\nHamed has recently found a string t and suddenly became quite fond of it. He spent several days trying to find all occurrences of t in other strings he had. Finally he became tired and started thinking about the following problem. Given a string s how many ways are there to extract k ≥ 1 non-overlapping substrings from it such that each of them contains string t as a substring? More formally, you need to calculate the number of ways to choose two sequences a_1, a_2, ..., a_{k} and b_1, b_2, ..., b_{k} satisfying the following requirements:\n\n  k ≥ 1  $\\forall i(1 \\leq i \\leq k) 1 \\leq a_{i}, b_{i} \\leq|s|$  $\\forall i(1 \\leq i \\leq k) b_{i} \\geq a_{i}$  $\\forall i(2 \\leq i \\leq k) a_{i} > b_{i - 1}$  $\\forall i(1 \\leq i \\leq k)$  t is a substring of string s_{a}_{i}s_{a}_{i} + 1... s_{b}_{i} (string s is considered as 1-indexed). \n\nAs the number of ways can be rather large print it modulo 10^9 + 7.\n\n-----Input-----\n\nInput consists of two lines containing strings s and t (1 ≤ |s|, |t| ≤ 10^5). Each string consists of lowercase Latin letters.\n\n-----Output-----\n\nPrint the answer in a single line.\n\n-----Examples-----\nInput\nababa\naba\n\nOutput\n5\n\nInput\nwelcometoroundtwohundredandeightytwo\nd\n\nOutput\n274201\n\nInput\nddd\nd\n\nOutput\n12\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_substring_ways (s t : String) : Nat :=\nsorry\n\ndef is_substring (s t : String) : Bool :=\nsorry", "vc-theorems": "theorem count_substring_ways_nonnegative (s t : String) :\n  0 ≤ count_substring_ways s t ∧ count_substring_ways s t < 1000000007 :=\nsorry\n\ntheorem substring_gives_nonzero (s t : String)\n  (h : t.length > 0)\n  (h2 : is_substring s t = true) :\n  0 < count_substring_ways s t :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval count_substring_ways \"ababa\" \"aba\"\n\n/--\ninfo: 274201\n-/\n#guard_msgs in\n#eval count_substring_ways \"welcometoroundtwohundredandeightytwo\" \"d\"\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval count_substring_ways \"ddd\" \"d\""}
{"id": "fvapps_002054", "vc-description": "/-\nHave you ever used the chat application QQ? Well, in a chat group of QQ, administrators can muzzle a user for days.\n\nIn Boboniu's chat group, there's a person called Du Yi who likes to make fun of Boboniu every day.\n\nDu will chat in the group for $n$ days. On the $i$-th day:  If Du can speak, he'll make fun of Boboniu with fun factor $a_i$. But after that, he may be muzzled depending on Boboniu's mood.  Otherwise, Du won't do anything. \n\nBoboniu's mood is a constant $m$. On the $i$-th day:  If Du can speak and $a_i>m$, then Boboniu will be angry and muzzle him for $d$ days, which means that Du won't be able to speak on the $i+1, i+2, \\cdots, \\min(i+d,n)$-th days.  Otherwise, Boboniu won't do anything. \n\nThe total fun factor is the sum of the fun factors on the days when Du can speak.\n\nDu asked you to find the maximum total fun factor among all possible permutations of $a$.\n\n-----Input-----\n\nThe first line contains three integers $n$, $d$ and $m$ ($1\\le d\\le n\\le 10^5,0\\le m\\le 10^9$).\n\nThe next line contains $n$ integers $a_1, a_2, \\ldots,a_n$ ($0\\le a_i\\le 10^9$).\n\n-----Output-----\n\nPrint one integer: the maximum total fun factor among all permutations of $a$.\n\n-----Examples-----\nInput\n5 2 11\n8 10 15 23 5\n\nOutput\n48\n\nInput\n20 2 16\n20 5 8 2 18 16 2 16 16 1 5 16 2 13 6 16 4 17 21 7\n\nOutput\n195\n\n-----Note-----\n\nIn the first example, you can set $a'=[15, 5, 8, 10, 23]$. Then Du's chatting record will be:  Make fun of Boboniu with fun factor $15$.  Be muzzled.  Be muzzled.  Make fun of Boboniu with fun factor $10$.  Make fun of Boboniu with fun factor $23$. \n\nThus the total fun factor is $48$.\n-/", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs\n\ndef list_sum_of_largest (arr : List Nat) (n : Nat) : Nat :=\n  sum_list ((List.toArray arr |>.qsort (· ≥ ·) |>.toList).take n)", "vc-helpers": "", "vc-definitions": "def find_max_fun_factor (n d m : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem empty_above_m (n d : Nat) (arr : List Nat)\n  (h1 : 0 < n ∧ n ≤ 100)\n  (h2 : 0 < d ∧ d ≤ 10)\n  (h3 : arr.length = n)\n  (h4 : ∀ x ∈ arr, x < 1000) :\n  find_max_fun_factor n d 1000 arr = list_sum_of_largest arr n :=\nsorry\n\ntheorem single_element (n d m : Nat) (arr : List Nat)\n  (h1 : 0 < n ∧ n ≤ 100)\n  (h2 : 0 < d ∧ d ≤ 10)\n  (h3 : 0 ≤ m ∧ m ≤ 100)\n  (h4 : arr.length = n)\n  (h5 : ∀ x ∈ arr, x = 0) :\n  find_max_fun_factor n d m arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 48\n-/\n#guard_msgs in\n#eval find_max_fun_factor 5 2 11 #[8, 10, 15, 23, 5]\n\n/--\ninfo: 195\n-/\n#guard_msgs in\n#eval find_max_fun_factor 20 2 16 #[20, 5, 8, 2, 18, 16, 2, 16, 16, 1, 5, 16, 2, 13, 6, 16, 4, 17, 21, 7]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_max_fun_factor 1 1 0 #[0]"}
{"id": "fvapps_002065", "vc-description": "/-\nConsider a sequence [a_1, a_2, ... , a_{n}]. Define its prefix product sequence $[ a_{1} \\operatorname{mod} n,(a_{1} a_{2}) \\operatorname{mod} n, \\cdots,(a_{1} a_{2} \\cdots a_{n}) \\operatorname{mod} n ]$.\n\nNow given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].\n\n-----Input-----\n\nThe only input line contains an integer n (1 ≤ n ≤ 10^5).\n\n-----Output-----\n\nIn the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.\n\nIf any solution exists, you should output n more lines. i-th line contains only an integer a_{i}. The elements of the sequence should be different positive integers no larger than n.\n\nIf there are multiple solutions, you are allowed to print any of them.\n\n-----Examples-----\nInput\n7\n\nOutput\nYES\n1\n4\n3\n6\n5\n2\n7\n\nInput\n6\n\nOutput\nNO\n\n-----Note-----\n\nFor the second sample, there are no valid sequences.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_permutation_with_prefix_products (n : Nat) : List Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef check_prefix_products (result : List Nat) (n : Nat) : Bool :=\nsorry\n\ndef is_valid_permutation (result : List Nat) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem output_properties (n : Nat) (h : n ≥ 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length > 0 →\n    result.length = n ∧\n    result.head? = some 1 ∧\n    result.getLast? = some n ∧\n    is_valid_permutation result n ∧\n    check_prefix_products result n ∧\n    (is_prime n ∨ n = 4) :=\nsorry\n\ntheorem output_properties_empty (n : Nat) (h : n ≥ 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length = 0 →\n    ¬is_prime n ∧ n ≠ 4 :=\nsorry\n\ntheorem prime_numbers_have_solution (n : Nat) (h : is_prime n) :\n  let result := find_permutation_with_prefix_products n\n  result.length = n ∧\n  check_prefix_products result n :=\nsorry\n\ntheorem composite_numbers_have_no_solution (n : Nat) (h1 : n ≥ 6) (h2 : ¬is_prime n) (h3 : n ≠ 4) :\n  (find_permutation_with_prefix_products n).length = 0 :=\nsorry\n\ntheorem special_case_four :\n  find_permutation_with_prefix_products 4 = [1, 3, 2, 4] ∧\n  check_prefix_products [1, 3, 2, 4] 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: list(range(7))\n-/\n#guard_msgs in\n#eval sorted [1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_permutation_with_prefix_products(6)"}
{"id": "fvapps_002067", "vc-description": "/-\nPolycarp took $n$ videos, the duration of the $i$-th video is $a_i$ seconds. The videos are listed in the chronological order, i.e. the $1$-st video is the earliest, the $2$-nd video is the next, ..., the $n$-th video is the last.\n\nNow Polycarp wants to publish exactly $k$ ($1 \\le k \\le n$) posts in Instabram. Each video should be a part of a single post. The posts should preserve the chronological order, it means that the first post should contain one or more of the earliest videos, the second post should contain a block (one or more videos) going next and so on. In other words, if the number of videos in the $j$-th post is $s_j$ then:\n\n  $s_1+s_2+\\dots+s_k=n$ ($s_i>0$),  the first post contains the videos: $1, 2, \\dots, s_1$;  the second post contains the videos: $s_1+1, s_1+2, \\dots, s_1+s_2$;  the third post contains the videos: $s_1+s_2+1, s_1+s_2+2, \\dots, s_1+s_2+s_3$;  ...  the $k$-th post contains videos: $n-s_k+1,n-s_k+2,\\dots,n$. \n\nPolycarp is a perfectionist, he wants the total duration of videos in each post to be the same.\n\nHelp Polycarp to find such positive integer values $s_1, s_2, \\dots, s_k$ that satisfy all the conditions above.\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^5$). The next line contains $n$ positive integer numbers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^4$), where $a_i$ is the duration of the $i$-th video.\n\n-----Output-----\n\nIf solution exists, print \"Yes\" in the first line. Print $k$ positive integers $s_1, s_2, \\dots, s_k$ ($s_1+s_2+\\dots+s_k=n$) in the second line. The total duration of videos in each post should be the same. It can be easily proven that the answer is unique (if it exists).\n\nIf there is no solution, print a single line \"No\".\n\n-----Examples-----\nInput\n6 3\n3 3 1 4 1 6\n\nOutput\nYes\n2 3 1 \nInput\n3 3\n1 1 1\n\nOutput\nYes\n1 1 1 \nInput\n3 3\n1 1 2\n\nOutput\nNo\nInput\n3 1\n1 10 100\n\nOutput\nYes\n3\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded\n\n-- Length matches k\n\n-- Sizes sum to n\n\n-- All partitions have same sum", "vc-preamble": "def sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def check_possible_partition (n k : Nat) (arr : List Nat) : Option (List Nat) :=\nsorry\n\ndef getPrefixSums (arr : List Nat) (sizes : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem validate_partition_properties {n k : Nat} {arr : List Nat}\n  (h1 : k ≤ n)\n  (h2 : 0 < sumList arr) :\n  match check_possible_partition n k arr with\n  | none => True\n  | some result =>\n\n    result.length = k ∧\n\n    sumList result = n ∧\n\n    let partitions := getPrefixSums arr result;\n    match partitions with\n    | [] => True\n    | hd::_ => List.all partitions (fun x => x = hd) :=\nsorry\n\ntheorem impossible_partition {arr : List Nat}\n  (h : 0 < arr.length) :\n  check_possible_partition arr.length (arr.length + 1) arr = none :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002070", "vc-description": "/-\nKoa the Koala has a binary string $s$ of length $n$. Koa can perform no more than $n-1$ (possibly zero) operations of the following form:\n\nIn one operation Koa selects positions $i$ and $i+1$ for some $i$ with $1 \\le i < |s|$ and sets $s_i$ to $max(s_i, s_{i+1})$. Then Koa deletes position $i+1$ from $s$ (after the removal, the remaining parts are concatenated).\n\nNote that after every operation the length of $s$ decreases by $1$.\n\nHow many different binary strings can Koa obtain by doing no more than $n-1$ (possibly zero) operations modulo $10^9+7$ ($1000000007$)?\n\n-----Input-----\n\nThe only line of input contains binary string $s$ ($1 \\le |s| \\le 10^6$). For all $i$ ($1 \\le i \\le |s|$) $s_i = 0$ or $s_i = 1$.\n\n-----Output-----\n\nOn a single line print the answer to the problem modulo $10^9+7$ ($1000000007$).\n\n-----Examples-----\nInput\n000\n\nOutput\n3\n\nInput\n0101\n\nOutput\n6\n\nInput\n0001111\n\nOutput\n16\n\nInput\n00101100011100\n\nOutput\n477\n\n-----Note-----\n\nIn the first sample Koa can obtain binary strings: $0$, $00$ and $000$.\n\nIn the second sample Koa can obtain binary strings: $1$, $01$, $11$, $011$, $101$ and $0101$. For example:  to obtain $01$ from $0101$ Koa can operate as follows: $0101 \\rightarrow 0(10)1 \\rightarrow 011 \\rightarrow 0(11) \\rightarrow 01$.  to obtain $11$ from $0101$ Koa can operate as follows: $0101 \\rightarrow (01)01 \\rightarrow 101 \\rightarrow 1(01) \\rightarrow 11$. \n\nParentheses denote the two positions Koa selected in each operation.\n-/", "vc-preamble": "def MOD : Nat := 1000000007", "vc-helpers": "", "vc-definitions": "def solve_binary_string (s : String) : Nat :=\nsorry\n\ndef is_binary_string (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_binary_string_properties {s : String} (h : is_binary_string s = true) :\n  let result := solve_binary_string s\n  0 ≤ result ∧ result ≤ MOD :=\nsorry\n\ntheorem all_zeros {s : String} (h : ∀ c ∈ s.data, c = '0') :\n  solve_binary_string s = s.length :=\nsorry\n\ntheorem mod_property {s : String} (h : is_binary_string s = true) :\n  solve_binary_string s < MOD :=\nsorry\n\ntheorem split_ones {s : String} (h : is_binary_string s = true)\n  (h2 : s.data.filter (· = '1') = []) :\n  solve_binary_string s = String.length s :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_binary_string \"000\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_binary_string \"0101\"\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_binary_string \"0001111\""}
{"id": "fvapps_002072", "vc-description": "/-\nA function $f : R \\rightarrow R$ is called Lipschitz continuous if there is a real constant K such that the inequality |f(x) - f(y)| ≤ K·|x - y| holds for all $x, y \\in R$. We'll deal with a more... discrete version of this term.\n\nFor an array $h [ 1 . . n ]$, we define it's Lipschitz constant $L(h)$ as follows:  if n < 2, $L(h) = 0$  if n ≥ 2, $L(h) = \\operatorname{max} [ \\frac{|h [ j ] - h [ i ]|}{j - i} ]$ over all 1 ≤ i < j ≤ n \n\nIn other words, $L = L(h)$ is the smallest non-negative integer such that |h[i] - h[j]| ≤ L·|i - j| holds for all 1 ≤ i, j ≤ n.\n\nYou are given an array [Image] of size n and q queries of the form [l, r]. For each query, consider the subarray $s = a [ l . . r ]$; determine the sum of Lipschitz constants of all subarrays of $S$.\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n and q (2 ≤ n ≤ 100 000 and 1 ≤ q ≤ 100) — the number of elements in array [Image] and the number of queries respectively.\n\nThe second line contains n space-separated integers $a [ 1 . . n ]$ ($0 \\leq a [ i ] \\leq 10^{8}$).\n\nThe following q lines describe queries. The i-th of those lines contains two space-separated integers l_{i} and r_{i} (1 ≤ l_{i} < r_{i} ≤ n).\n\n-----Output-----\n\nPrint the answers to all queries in the order in which they are given in the input. For the i-th query, print one line containing a single integer — the sum of Lipschitz constants of all subarrays of [Image].\n\n-----Examples-----\nInput\n10 4\n1 5 2 9 1 3 4 2 1 7\n2 4\n3 8\n7 10\n1 9\n\nOutput\n17\n82\n23\n210\n\nInput\n7 6\n5 7 7 4 6 6 2\n1 2\n2 3\n2 6\n1 7\n4 7\n3 5\n\nOutput\n2\n0\n22\n59\n16\n8\n\n-----Note-----\n\nIn the first query of the first sample, the Lipschitz constants of subarrays of $[ 5,2,9 ]$ with length at least 2 are:  $L([ 5,2 ]) = 3$  $L([ 2,9 ]) = 7$  $L([ 5,2,9 ]) = 7$ \n\nThe answer to the query is their sum.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compute_lipschitz_sums (arr : List Nat) (queries : List (Nat × Nat)) : List Nat :=\nsorry\n\ndef sort (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem array_properties {arr : List Nat} (h: arr.length ≥ 2)\n  (hb: ∀ x, x ∈ arr → x ≤ 10^8) :\n  let result := compute_lipschitz_sums arr [(1, arr.length)]\n  result.length = 1 ∧\n  ∀ x, x ∈ result → x ≥ 0 :=\nsorry\n\ntheorem constant_array_sums {arr : List Nat} {queries : List (Nat × Nat)}\n  (h: arr.length ≥ 2)\n  (hconst: ∀ (i j : Fin arr.length), arr[i] = arr[j])\n  (hq: ∀ p, p ∈ queries → p.1 ≤ p.2 ∧ p.2 ≤ arr.length) :\n  ∀ x, x ∈ compute_lipschitz_sums arr queries → x = 0 :=\nsorry\n\ntheorem query_bounds_valid {arr : List Nat} {queries : List (Nat × Nat)}\n  (h: arr.length ≥ 2)\n  (hq: ∀ p, p ∈ queries → p.1 ≤ p.2 ∧ p.2 ≤ arr.length) :\n  let results := compute_lipschitz_sums arr queries\n  results.length = queries.length :=\nsorry\n\ntheorem monotonic_increasing_minimal {arr : List Nat}\n  (h: arr.length ≥ 2)\n  (hb: ∀ x, x ∈ arr → x ≤ 10) :\n  let sorted := sort arr\n  let orig_sum := (compute_lipschitz_sums arr [(1, arr.length)]).head!\n  let sorted_sum := (compute_lipschitz_sums sorted [(1, arr.length)]).head!\n  sorted_sum ≤ orig_sum :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: [17, 82, 23, 210]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [1, 5, 2, 9, 1, 3, 4, 2, 1, 7] [(2, 4), (3, 8), (7, 10), (1, 9)]\n\n/--\ninfo: [2, 0, 22, 59, 16, 8]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [5, 7, 7, 4, 6, 6, 2] [(1, 2), (2, 3), (2, 6), (1, 7), (4, 7), (3, 5)]\n\n/--\ninfo: [100000000, 100000000]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [100000000, 0] [(1, 2), (1, 2)]"}
{"id": "fvapps_002076", "vc-description": "/-\nIahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.\n\nThe game is played on a tree having n nodes, numbered from 1 to n. Each node i has an initial value init_{i}, which is either 0 or 1. The root of the tree is node 1.\n\nOne can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node x. Right after someone has picked node x, the value of node x flips, the values of sons of x remain the same, the values of sons of sons of x flips, the values of sons of sons of sons of x remain the same and so on.\n\nThe goal of the game is to get each node i to have value goal_{i}, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.\n\n-----Input-----\n\nThe first line contains an integer n (1 ≤ n ≤ 10^5). Each of the next n - 1 lines contains two integers u_{i} and v_{i} (1 ≤ u_{i}, v_{i} ≤ n; u_{i} ≠ v_{i}) meaning there is an edge between nodes u_{i} and v_{i}. \n\nThe next line contains n integer numbers, the i-th of them corresponds to init_{i} (init_{i} is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goal_{i} (goal_{i} is either 0 or 1).\n\n-----Output-----\n\nIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer x_{i}, representing that you pick a node x_{i}.\n\n-----Examples-----\nInput\n10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n\nOutput\n2\n4\n7\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_xor_tree (n : Nat) (edges : List (Nat × Nat)) (init : List Nat) (goal : List Nat) : List Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem basic_properties {n : Nat} {xor_values : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 20) (h3 : ∀ x ∈ xor_values, x = 0 ∨ x = 1)\n  (h4 : xor_values.length = n) :\n  let edges := List.map (fun i => (i + 2, (i + 2)/2)) (List.range (n-1))\n  let goal := xor_values\n  let init := List.replicate n 0\n  let result := solve_xor_tree n edges init goal\n  (∀ x ∈ result, x ≥ 1 ∧ x ≤ n) :=\nsorry\n\ntheorem single_node_zero {init goal : List Nat}\n  (h1 : init.length = 1) (h2 : goal.length = 1)\n  (h3 : init = [0]) (h4 : goal = [0]) :\n  solve_xor_tree 1 [] init goal = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval len solve_xor_tree(n, edges, init, goal)"}
{"id": "fvapps_002077", "vc-description": "/-\nLet's assume that   v(n) is the largest prime number, that does not exceed n;\n\n u(n) is the smallest prime number strictly greater than n. \n\nFind $\\sum_{i = 2}^{n} \\frac{1}{v(i) u(i)}$.\n\n-----Input-----\n\nThe first line contains integer t (1 ≤ t ≤ 500) — the number of testscases. \n\nEach of the following t lines of the input contains integer n (2 ≤ n ≤ 10^9).\n\n-----Output-----\n\nPrint t lines: the i-th of them must contain the answer to the i-th test as an irreducible fraction \"p/q\", where p, q are integers, q > 0.\n\n-----Examples-----\nInput\n2\n2\n3\n\nOutput\n1/6\n7/30\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Int) : Int :=\nsorry\n\ndef calc_fraction (n : Int) : Int × Int :=\nsorry\n\ndef fraction_to_str (frac : Int × Int) : String :=\nsorry", "vc-theorems": "theorem calc_fraction_valid_output {n : Int} (h : n ≥ 2) :\n  let (num, den) := calc_fraction n\n  den > 0 ∧ gcd num.natAbs den.natAbs = 1 :=\nsorry\n\ntheorem fraction_to_str_format {n : Int} (h : n ≥ 2) :\n  let frac := calc_fraction n\n  let str := fraction_to_str frac\n  ∃ num den : String,\n    str = num ++ \"/\" ++ den ∧\n    (frac.1 = String.toInt! num) ∧\n    (frac.2 = String.toInt! den) :=\nsorry\n\ntheorem gcd_properties {a b : Int} (ha : a > 0) (hb : b > 0) :\n  let g := gcd a b\n  g > 0 ∧ a % g = 0 ∧ b % g = 0 :=\nsorry\n\ntheorem calc_fraction_two :\n  calc_fraction 2 = (1, 6) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: '1/6'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(2)\n\n/--\ninfo: '7/30'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(3)\n\n/--\ninfo: '5/14'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(6)"}
{"id": "fvapps_002090", "vc-description": "/-\nVova and Marina love offering puzzles to each other. Today Marina offered Vova to cope with the following task.\n\nVova has a non-directed graph consisting of n vertices and m edges without loops and multiple edges. Let's define the operation of contraction two vertices a and b that are not connected by an edge. As a result of this operation vertices a and b are deleted and instead of them a new vertex x is added into the graph, and also edges are drawn from it to all vertices that were connected with a or with b (specifically, if the vertex was connected with both a and b, then also exactly one edge is added from x to it). Thus, as a result of contraction again a non-directed graph is formed, it contains no loops nor multiple edges, and it contains (n - 1) vertices.\n\nVova must perform the contraction an arbitrary number of times to transform the given graph into a chain of the maximum length. A chain of length k (k ≥ 0) is a connected graph whose vertices can be numbered with integers from 1 to k + 1 so that the edges of the graph connect all pairs of vertices (i, i + 1) (1 ≤ i ≤ k) and only them. Specifically, the graph that consists of one vertex is a chain of length 0. The vertices that are formed as a result of the contraction are allowed to be used in the following operations of contraction.\n\n [Image] The picture illustrates the contraction of two vertices marked by red. \n\nHelp Vova cope with his girlfriend's task. Find the maximum length of the chain that can be obtained from the resulting graph or else determine that it is impossible to obtain the chain.\n\n-----Input-----\n\nThe first line contains two integers n, m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the original graph.\n\nNext m lines contain the descriptions of edges in the format a_{i}, b_{i} (1 ≤ a_{i}, b_{i} ≤ n, a_{i} ≠ b_{i}), which means that there is an edge between vertices a_{i} and b_{i}. It is guaranteed that there is at most one edge between each pair of vertexes.\n\n-----Output-----\n\nIf it is impossible to obtain a chain from the given graph, print  - 1. Otherwise, print the maximum possible number of edges in the resulting chain.\n\n-----Examples-----\nInput\n5 4\n1 2\n2 3\n3 4\n3 5\n\nOutput\n3\n\nInput\n4 6\n1 2\n2 3\n1 3\n3 4\n2 4\n1 4\n\nOutput\n-1\n\nInput\n4 2\n1 3\n2 4\n\nOutput\n2\n\n-----Note-----\n\nIn the first sample test you can contract vertices 4 and 5 and obtain a chain of length 3.\n\nIn the second sample test it is initially impossible to contract any pair of vertexes, so it is impossible to achieve the desired result.\n\nIn the third sample test you can contract vertices 1 and 2 and obtain a chain of length 2.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_max_chain_length (n m : Nat) (edges : List (Nat × Nat)) : Int :=\nsorry\n\ndef to_adj_matrix (n : Nat) (edges : List (Nat × Nat)) : List (List Nat) :=\nsorry\n\ndef is_bipartite (adj : List (List Nat)) (colors : List Int) (start n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem bipartite_property (n m : Nat) (edges : List (Nat × Nat)) :\n  let result := solve_max_chain_length n m edges\n  let adj := to_adj_matrix n edges\n  ∀ colors : List Int,\n  result ≠ -1 →\n  colors.length = n →\n  (∀ i < n, colors[i]! = -1 ∨ colors[i]! = 0 ∨ colors[i]! = 1) →\n  ∀ start < n,\n  is_bipartite adj colors start n = true :=\nsorry\n\ntheorem empty_graph_property (n m : Nat) (edges : List (Nat × Nat)) :\n  m = 0 →\n  solve_max_chain_length n m edges = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_max_chain_length 5 4 [(1, 2), (2, 3), (3, 4), (3, 5)]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 6 [(1, 2), (2, 3), (1, 3), (3, 4), (2, 4), (1, 4)]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 2 [(1, 3), (2, 4)]"}
{"id": "fvapps_002095", "vc-description": "/-\nThere are n psychos standing in a line. Each psycho is assigned a unique integer from 1 to n. At each step every psycho who has an id greater than the psycho to his right (if exists) kills his right neighbor in the line. Note that a psycho might kill and get killed at the same step. \n\nYou're given the initial arrangement of the psychos in the line. Calculate how many steps are needed to the moment of time such, that nobody kills his neighbor after that moment. Look notes to understand the statement more precise.\n\n-----Input-----\n\nThe first line of input contains integer n denoting the number of psychos, (1 ≤ n ≤ 10^5). In the second line there will be a list of n space separated distinct integers each in range 1 to n, inclusive — ids of the psychos in the line from left to right.\n\n-----Output-----\n\nPrint the number of steps, so that the line remains the same afterward.\n\n-----Examples-----\nInput\n10\n10 9 7 8 6 5 3 4 2 1\n\nOutput\n2\n\nInput\n6\n1 2 3 4 5 6\n\nOutput\n0\n\n-----Note-----\n\nIn the first sample line of the psychos transforms as follows: [10 9 7 8 6 5 3 4 2 1]  →  [10 8 4]  →  [10]. So, there are two steps.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_psychos (n : Nat) (arr : List Nat) : Nat :=\n  sorry\n\ndef is_sorted_desc (arr : List Nat) : Bool :=\n  sorry\n\ndef is_strictly_sorted_asc (arr : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem empty_single_array :\n  solve_psychos 0 [] = 0 ∧\n  ∀ x : Nat, solve_psychos 1 [x] = 0 :=\nsorry\n\ntheorem solve_psychos_bounds :\n  ∀ (n : Nat) (arr : List Nat),\n  arr.length = n →\n  0 ≤ solve_psychos n arr ∧\n  solve_psychos n arr ≤ n - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_psychos 10 [10, 9, 7, 8, 6, 5, 3, 4, 2, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_psychos 6 [1, 2, 3, 4, 5, 6]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_psychos 6 [6, 5, 4, 3, 2, 1]"}
{"id": "fvapps_002098", "vc-description": "/-\nBarney lives in country USC (United States of Charzeh). USC has n cities numbered from 1 through n and n - 1 roads between them. Cities and roads of USC form a rooted tree (Barney's not sure why it is rooted). Root of the tree is the city number 1. Thus if one will start his journey from city 1, he can visit any city he wants by following roads.\n\n [Image] \n\nSome girl has stolen Barney's heart, and Barney wants to find her. He starts looking for in the root of the tree and (since he is Barney Stinson not a random guy), he uses a random DFS to search in the cities. A pseudo code of this algorithm is as follows:\n\nlet starting_time be an array of length n\n\ncurrent_time = 0\n\ndfs(v):\n\n        current_time = current_time + 1\n\n        starting_time[v] = current_time\n\n        shuffle children[v] randomly (each permutation with equal possibility)\n\n        // children[v] is vector of children cities of city v\n\n        for u in children[v]:\n\n                dfs(u)\n\nAs told before, Barney will start his journey in the root of the tree (equivalent to call dfs(1)).\n\nNow Barney needs to pack a backpack and so he wants to know more about his upcoming journey: for every city i, Barney wants to know the expected value of starting_time[i]. He's a friend of Jon Snow and knows nothing, that's why he asked for your help.\n\n-----Input-----\n\nThe first line of input contains a single integer n (1 ≤ n ≤ 10^5) — the number of cities in USC.\n\nThe second line contains n - 1 integers p_2, p_3, ..., p_{n} (1 ≤ p_{i} < i), where p_{i} is the number of the parent city of city number i in the tree, meaning there is a road between cities numbered p_{i} and i in USC.\n\n-----Output-----\n\nIn the first and only line of output print n numbers, where i-th number is the expected value of starting_time[i].\n\nYour answer for each city will be considered correct if its absolute or relative error does not exceed 10^{ - 6}.\n\n-----Examples-----\nInput\n7\n1 2 1 1 4 4\n\nOutput\n1.0 4.0 5.0 3.5 4.5 5.0 5.0 \n\nInput\n12\n1 1 2 2 4 4 3 3 1 10 8\n\nOutput\n1.0 5.0 5.5 6.5 7.5 8.0 8.0 7.0 7.5 6.5 7.5 8.0\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_tree_dfs (n : Nat) (parents : List Nat := []) : List Float :=\nsorry\n\ndef is_valid_tree (parents : List Nat) : Bool :=\nsorry\n\ndef abs (x : Float) : Float :=\nsorry", "vc-theorems": "theorem single_node_properties (n : Nat) (h : n = 1) :\n  let result := solve_tree_dfs n\n  (result.length = 1) ∧\n  (abs (result[0]! - 1.0) < 0.000001) :=\nsorry\n\ntheorem valid_tree_properties {n : Nat} {parents : List Nat}\n  (h : is_valid_tree parents = true) :\n  let result := solve_tree_dfs (n + 1) parents\n  (result.length = n + 1) ∧\n  (abs (result[0]! - 1.0) < 0.000001) ∧\n  (∀ i p, i < parents.length → p = parents[i]! → result[i+1]! > result[p-1]!) ∧\n  (∀ x, x ∈ result → x ≥ 1.0) ∧\n  (∀ x, x ∈ result → x ≤ Float.ofNat (n + 1)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002102", "vc-description": "/-\nThere are some ambiguities when one writes Berland names with the letters of the Latin alphabet.\n\nFor example, the Berland sound u can be written in the Latin alphabet as \"u\", and can be written as \"oo\". For this reason, two words \"ulyana\" and \"oolyana\" denote the same name.\n\nThe second ambiguity is about the Berland sound h: one can use both \"h\" and \"kh\" to write it. For example, the words \"mihail\" and \"mikhail\" denote the same name.\n\nThere are n users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?\n\nFormally, we assume that two words denote the same name, if using the replacements \"u\" [Image] \"oo\" and \"h\" [Image] \"kh\", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.\n\nFor example, the following pairs of words denote the same name:  \"koouper\" and \"kuooper\". Making the replacements described above, you can make both words to be equal: \"koouper\" $\\rightarrow$ \"kuuper\" and \"kuooper\" $\\rightarrow$ \"kuuper\".  \"khun\" and \"kkkhoon\". With the replacements described above you can make both words to be equal: \"khun\" $\\rightarrow$ \"khoon\" and \"kkkhoon\" $\\rightarrow$ \"kkhoon\" $\\rightarrow$ \"khoon\". \n\nFor a given list of words, find the minimal number of groups where the words in each group denote the same name.\n\n-----Input-----\n\nThe first line contains integer number n (2 ≤ n ≤ 400) — number of the words in the list.\n\nThe following n lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.\n\n-----Output-----\n\nPrint the minimal number of groups where the words in each group denote the same name.\n\n-----Examples-----\nInput\n10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n\nOutput\n4\n\nInput\n9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n\nOutput\n5\n\nInput\n2\nalex\nalex\n\nOutput\n1\n\n-----Note-----\n\nThere are four groups of words in the first example. Words in each group denote same name:  \"mihail\", \"mikhail\"  \"oolyana\", \"ulyana\"  \"kooooper\", \"koouper\"  \"hoon\", \"khun\", \"kkkhoon\" \n\nThere are five groups of words in the second example. Words in each group denote same name:  \"hariton\", \"kkkhariton\", \"khariton\"  \"hkariton\"  \"buoi\", \"boooi\", \"boui\"  \"bui\"  \"boi\" \n\nIn the third example the words are equal, so they denote the same name.\n-/\n\n/- Helper function to process a string by replacing kh sequences -/\n\n/- Helper function to process a string by replacing u with oo -/\n\n/- Helper function to fully process a string with all replacements -/", "vc-preamble": "def unique {α} [BEq α] (l: List α) : List α :=\n  l.foldl (fun acc x => if acc.elem x then acc else x :: acc) []", "vc-helpers": "", "vc-definitions": "def count_distinct_names (words: List String) : Nat :=\nsorry\n\ndef processKh (s: String) : String :=\nsorry\n\ndef processU (s: String) : String :=\nsorry", "vc-theorems": "def processString (s: String) : String := processKh (processU s)\n\ntheorem count_distinct_names_bounded (words: List String) (h: words ≠ []) :\n  let result := count_distinct_names words\n  result ≤ words.length ∧ result ≥ 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_distinct_names [\"mihail\", \"oolyana\", \"kooooper\", \"hoon\", \"ulyana\", \"koouper\", \"mikhail\", \"khun\", \"kuooper\", \"kkkhoon\"]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_names [\"hariton\", \"hkariton\", \"buoi\", \"kkkhariton\", \"boooi\", \"bui\", \"khariton\", \"boui\", \"boi\"]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_names [\"alex\", \"alex\"]"}
{"id": "fvapps_002103", "vc-description": "/-\nWriting light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it.\n\n[Image] \n\nThere are $n$ cities and $n-1$ two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from $1$ to $n$, and the city $1$ is the capital of the kingdom. So, the kingdom has a tree structure.\n\nAs the queen, Linova plans to choose exactly $k$ cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.\n\nA meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).\n\nTraveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.\n\nIn order to be a queen loved by people, Linova wants to choose $k$ cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($2\\le n\\le 2 \\cdot 10^5$, $1\\le k< n$)  — the number of cities and industry cities respectively.\n\nEach of the next $n-1$ lines contains two integers $u$ and $v$ ($1\\le u,v\\le n$), denoting there is a road connecting city $u$ and city $v$.\n\nIt is guaranteed that from any city, you can reach any other city by the roads.\n\n-----Output-----\n\nPrint the only line containing a single integer  — the maximum possible sum of happinesses of all envoys.\n\n-----Examples-----\nInput\n7 4\n1 2\n1 3\n1 4\n3 5\n3 6\n4 7\n\nOutput\n7\nInput\n4 1\n1 2\n1 3\n2 4\n\nOutput\n2\nInput\n8 5\n7 5\n1 7\n6 1\n3 7\n8 3\n2 1\n4 5\n\nOutput\n9\n\n-----Note-----\n\n[Image]\n\nIn the first example, Linova can choose cities $2$, $5$, $6$, $7$ to develop industry, then the happiness of the envoy from city $2$ is $1$, the happiness of envoys from cities $5$, $6$, $7$ is $2$. The sum of happinesses is $7$, and it can be proved to be the maximum one.\n\n[Image]\n\nIn the second example, choosing cities $3$, $4$ developing industry can reach a sum of $3$, but remember that Linova plans to choose exactly $k$ cities developing industry, then the maximum sum is $2$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\nsorry\n\ndef maxHappiness (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem maxHappiness_valid_tree (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges → True :=\nsorry\n\ntheorem maxHappiness_nonnegative (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges → maxHappiness n k edges ≥ 0 :=\nsorry\n\ntheorem maxHappiness_zero_when_k_geq_n (n : Nat) (k : Nat)\n  (edges : List (Nat × Nat)) :\n  isValidTree n edges →\n  k ≥ n →\n  maxHappiness n k edges = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval max_happiness 7 4 [(1, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7)]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_happiness 4 1 [(1, 2), (1, 3), (2, 4)]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval max_happiness 8 5 [(7, 5), (1, 7), (6, 1), (3, 7), (8, 3), (2, 1), (4, 5)]"}
{"id": "fvapps_002126", "vc-description": "/-\nRudolf is on his way to the castle. Before getting into the castle, the security staff asked him a question:\n\nGiven two binary numbers $a$ and $b$ of length $n$. How many different ways of swapping two digits in $a$ (only in $a$, not $b$) so that bitwise OR of these two numbers will be changed? In other words, let $c$ be the bitwise OR of $a$ and $b$, you need to find the number of ways of swapping two bits in $a$ so that bitwise OR will not be equal to $c$.\n\nNote that binary numbers can contain leading zeros so that length of each number is exactly $n$.\n\nBitwise OR is a binary operation. A result is a binary number which contains a one in each digit if there is a one in at least one of the two numbers. For example, $01010_2$ OR $10011_2$ = $11011_2$.\n\nWell, to your surprise, you are not Rudolf, and you don't need to help him$\\ldots$ You are the security staff! Please find the number of ways of swapping two bits in $a$ so that bitwise OR will be changed.\n\n-----Input-----\n\nThe first line contains one integer $n$ ($2\\leq n\\leq 10^5$) — the number of bits in each number.\n\nThe second line contains a binary number $a$ of length $n$.\n\nThe third line contains a binary number $b$ of length $n$.\n\n-----Output-----\n\nPrint the number of ways to swap two bits in $a$ so that bitwise OR will be changed.\n\n-----Examples-----\nInput\n5\n01011\n11001\n\nOutput\n4\n\nInput\n6\n011000\n010011\n\nOutput\n6\n\n-----Note-----\n\nIn the first sample, you can swap bits that have indexes $(1, 4)$, $(2, 3)$, $(3, 4)$, and $(3, 5)$.\n\nIn the second example, you can swap bits that have indexes $(1, 2)$, $(1, 3)$, $(2, 4)$, $(3, 4)$, $(3, 5)$, and $(3, 6)$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countValidBitSwaps (n : Nat) (a : String) (b : String) : Nat :=\n  sorry\n\ndef stringRepeat (s : String) (n : Nat) : String :=\n  sorry\n\ndef makeAlternatingString (n : Nat) (startBit : String) : String :=\n  sorry", "vc-theorems": "theorem countValidBitSwaps_returns_natural (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  ∃ (m : Nat), countValidBitSwaps n a b = m := by\nsorry\n\ntheorem countValidBitSwaps_nonnegative (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  countValidBitSwaps n a b ≥ 0 := by\nsorry\n\ntheorem countValidBitSwaps_all_zeros (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"0\" n) (stringRepeat \"0\" n) = 0 := by\nsorry\n\ntheorem countValidBitSwaps_all_ones (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"1\" n) (stringRepeat \"1\" n) = 0 := by\nsorry\n\ntheorem countValidBitSwaps_alternating (n : Nat) :\n  let alt1 := makeAlternatingString n \"0\"\n  let alt2 := makeAlternatingString n \"1\"\n  ∃ (m : Nat), countValidBitSwaps n alt1 alt2 = m := by\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 5 \"01011\" \"11001\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 6 \"011000\" \"010011\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 2 \"00\" \"00\""}
{"id": "fvapps_002129", "vc-description": "/-\nA bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\n\nSubsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\nYou are given a regular bracket sequence $s$ and an integer number $k$. Your task is to find a regular bracket sequence of length exactly $k$ such that it is also a subsequence of $s$.\n\nIt is guaranteed that such sequence always exists.\n\n-----Input-----\n\nThe first line contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$, both $n$ and $k$ are even) — the length of $s$ and the length of the sequence you are asked to find.\n\nThe second line is a string $s$ — regular bracket sequence of length $n$.\n\n-----Output-----\n\nPrint a single string — a regular bracket sequence of length exactly $k$ such that it is also a subsequence of $s$.\n\nIt is guaranteed that such sequence always exists.\n\n-----Examples-----\nInput\n6 4\n()(())\n\nOutput\n()()\n\nInput\n8 8\n(()(()))\n\nOutput\n(()(()))\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isRegular (s : String) : Bool :=\n  sorry\n\ndef findRegularSubsequence (s : String) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem find_regular_subsequence_properties\n  (input : String)\n  (k : Nat)\n  (h1 : isRegular input = true)\n  (h2 : k % 2 = 0)\n  (h3 : k ≤ input.length)\n  : let result := findRegularSubsequence input k\n    (result.length = k) ∧\n    (isRegular result = true) ∧\n    (∀ c, c ∈ result.data → c = '(' ∨ c = ')') ∧\n    (result.data.count '(' = result.data.count ')') ∧\n    (∀ c, c ∈ result.data → c ∈ input.data) :=\nsorry\n\ntheorem find_regular_subsequence_minimal_case :\n  (findRegularSubsequence \"()\" 2 = \"()\") ∧\n  (findRegularSubsequence \"()\" 0 = \"\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002131", "vc-description": "/-\nLittle Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.\n\nSergey gives Nastya the word t and wants to get the word p out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word t: a_1... a_{|}t|. We denote the length of word x as |x|. Note that after removing one letter, the indices of other letters don't change. For example, if t = \"nastya\" and a = [4, 1, 5, 3, 2, 6] then removals make the following sequence of words \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\" $\\rightarrow$ \"nastya\".\n\nSergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word p. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.\n\nIt is guaranteed that the word p can be obtained by removing the letters from word t.\n\n-----Input-----\n\nThe first and second lines of the input contain the words t and p, respectively. Words are composed of lowercase letters of the Latin alphabet (1 ≤ |p| < |t| ≤ 200 000). It is guaranteed that the word p can be obtained by removing the letters from word t.\n\nNext line contains a permutation a_1, a_2, ..., a_{|}t| of letter indices that specifies the order in which Nastya removes letters of t (1 ≤ a_{i} ≤ |t|, all a_{i} are distinct).\n\n-----Output-----\n\nPrint a single integer number, the maximum number of letters that Nastya can remove.\n\n-----Examples-----\nInput\nababcba\nabb\n5 3 4 1 7 6 2\n\nOutput\n3\nInput\nbbbabb\nbb\n1 6 3 4 2 5\n\nOutput\n4\n\n-----Note-----\n\nIn the first sample test sequence of removing made by Nastya looks like this:\n\n\"ababcba\" $\\rightarrow$ \"ababcba\" $\\rightarrow$ \"ababcba\" $\\rightarrow$ \"ababcba\" \n\nNastya can not continue, because it is impossible to get word \"abb\" from word \"ababcba\".\n\nSo, Nastya will remove only three letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sub (a b : List α) : Bool :=\nsorry\n\ndef sub_string (a b : String) : Bool :=\nsorry\n\ndef subword (t : List Int) (ord_ar : List Int) (n : Int) : List Int :=\nsorry\n\ndef bin_s (l r : Int) (f : Int → Bool) : Int := sorry\n\n@[simp] theorem sub_empty (a : List α) :\n  sub a [] = true := sorry\n\n@[simp] theorem sub_longer (a s : List α) :\n  List.length s > List.length a → sub a s = false := sorry\n\n@[simp] theorem sub_refl (a : List α) :\n  sub a a = true := sorry\n\n@[simp] theorem sub_string_empty (a b : String) :\n  sub_string a \"\" = true := sorry\n\n@[simp] theorem sub_string_longer (a b : String) :\n  String.length b > String.length a → sub_string a b = false := sorry\n\n@[simp] theorem sub_string_refl (a : String) :\n  sub_string a a = true :=\nsorry", "vc-theorems": "theorem subword_length (t : List Int) (ord_ar : List Int) (n : Int) :\n  List.length t = List.length ord_ar →\n  List.length (subword t ord_ar n) ≤ List.length t :=\nsorry\n\ntheorem bin_search_bounds (l r : Int) (f : Int → Bool) :\n  r > l + 1 →\n  let res := bin_s l r f\n  l ≤ res ∧ res ≤ r :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"ababcba\" \"abb\" [5, 3, 4, 1, 7, 6, 2]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve \"bbbabb\" \"bb\" [1, 6, 3, 4, 2, 5]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval solve \"cacaccccccacccc\" \"cacc\" [10, 9, 14, 5, 1, 7, 15, 3, 6, 12, 4, 8, 11, 13, 2]"}
{"id": "fvapps_002137", "vc-description": "/-\nYou are given a permutation $p_1, p_2, \\ldots, p_n$.\n\nIn one move you can swap two adjacent values.\n\nYou want to perform a minimum number of moves, such that in the end there will exist a subsegment $1,2,\\ldots, k$, in other words in the end there should be an integer $i$, $1 \\leq i \\leq n-k+1$ such that $p_i = 1, p_{i+1} = 2, \\ldots, p_{i+k-1}=k$.\n\nLet $f(k)$ be the minimum number of moves that you need to make a subsegment with values $1,2,\\ldots,k$ appear in the permutation.\n\nYou need to find $f(1), f(2), \\ldots, f(n)$.\n\n-----Input-----\n\nThe first line of input contains one integer $n$ ($1 \\leq n \\leq 200\\,000$): the number of elements in the permutation.\n\nThe next line of input contains $n$ integers $p_1, p_2, \\ldots, p_n$: given permutation ($1 \\leq p_i \\leq n$).\n\n-----Output-----\n\nPrint $n$ integers, the minimum number of moves that you need to make a subsegment with values $1,2,\\ldots,k$ appear in the permutation, for $k=1, 2, \\ldots, n$.\n\n-----Examples-----\nInput\n5\n5 4 3 2 1\n\nOutput\n0 1 3 6 10 \n\nInput\n3\n1 2 3\n\nOutput\n0 0 0\n-/", "vc-preamble": "def BinaryIndexedTree : Type := Unit", "vc-helpers": "", "vc-definitions": "def BinaryIndexedTree.mk (n : Nat) : BinaryIndexedTree :=\nsorry\n\ndef BinaryIndexedTree.add (self : BinaryIndexedTree) (i : Nat) (x : Int) : Unit :=\nsorry\n\ndef BinaryIndexedTree.sum (self : BinaryIndexedTree) (i : Nat) : Int :=\nsorry\n\ndef BinaryIndexedTree.sum_range (self : BinaryIndexedTree) (l r : Nat) : Int :=\nsorry\n\ndef BinaryIndexedTree.data (self : BinaryIndexedTree) : List Int :=\nsorry\n\ndef solve (n : Nat) (perm : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem bit_init_properties (n : Nat) (h : n > 0) :\n  let bit := BinaryIndexedTree.mk n\n  List.length (BinaryIndexedTree.data bit) = n + 1 ∧\n  List.all (BinaryIndexedTree.data bit) (λ x => x = 0) :=\nsorry\n\ntheorem bit_add_sum_properties (n i : Nat) (x : Int) (h1 : n > 0) (h2 : i > 0) (h3 : i ≤ n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := BinaryIndexedTree.add bit i x\n  BinaryIndexedTree.sum bit i = x ∧ BinaryIndexedTree.sum bit n = x :=\nsorry\n\ntheorem bit_range_sum_property (n l r : Nat) (h1 : n > 0) (h2 : l > 0) (h3 : r > 0)\n  (h4 : l ≤ r) (h5 : r ≤ n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := List.foldl (λ b i => BinaryIndexedTree.add b (i + l) 1) bit (List.range (r - l + 1))\n  BinaryIndexedTree.sum_range bit' l r = r - l + 1 :=\nsorry\n\ntheorem solve_properties (n : Nat) (perm : List Nat) (h1 : n > 0)\n  (h2 : List.length perm = n)\n  (h3 : ∀ i j, i < j → perm.get! i < perm.get! j)\n  (h4 : List.Nodup perm) :\n  let result := solve n perm\n  List.length result = n ∧\n  List.all result (λ x => x ≥ 0) ∧\n  result.head? = some 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [0, 1, 3, 6, 10]\n-/\n#guard_msgs in\n#eval solve 5 [5, 4, 3, 2, 1]\n\n/--\ninfo: [0, 0, 0]\n-/\n#guard_msgs in\n#eval solve 3 [1, 2, 3]\n\n/--\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 1 [1]"}
{"id": "fvapps_002138", "vc-description": "/-\nLet's denote as $\\text{popcount}(x)$ the number of bits set ('1' bits) in the binary representation of the non-negative integer x.\n\nYou are given multiple queries consisting of pairs of integers l and r. For each query, find the x, such that l ≤ x ≤ r, and $\\text{popcount}(x)$ is maximum possible. If there are multiple such numbers find the smallest of them.\n\n-----Input-----\n\nThe first line contains integer n — the number of queries (1 ≤ n ≤ 10000).\n\nEach of the following n lines contain two integers l_{i}, r_{i} — the arguments for the corresponding query (0 ≤ l_{i} ≤ r_{i} ≤ 10^18).\n\n-----Output-----\n\nFor each query print the answer in a separate line.\n\n-----Examples-----\nInput\n3\n1 2\n2 4\n1 10\n\nOutput\n1\n3\n7\n\n-----Note-----\n\nThe binary representations of numbers from 1 to 10 are listed below:\n\n1_10 = 1_2\n\n2_10 = 10_2\n\n3_10 = 11_2\n\n4_10 = 100_2\n\n5_10 = 101_2\n\n6_10 = 110_2\n\n7_10 = 111_2\n\n8_10 = 1000_2\n\n9_10 = 1001_2\n\n10_10 = 1010_2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_max_popcount (l r : Nat) : Nat :=\n  sorry\n\ndef popcount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_in_range (l r : Nat) :\n  let ordered_l := min l r\n  let ordered_r := max l r\n  let result := get_max_popcount ordered_l ordered_r\n  ordered_l ≤ result ∧ result ≤ ordered_r :=\nsorry\n\ntheorem same_number (x : Nat) :\n  get_max_popcount x x = x :=\nsorry\n\ntheorem consecutive_numbers (x : Nat) :\n  popcount (get_max_popcount x (x + 1)) ≥ popcount x :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval get_max_popcount 1 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_popcount 2 4\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_popcount 1 10"}
{"id": "fvapps_002140", "vc-description": "/-\nA tree is a graph with n vertices and exactly n - 1 edges; this graph should meet the following condition: there exists exactly one shortest (by number of edges) path between any pair of its vertices.\n\nA subtree of a tree T is a tree with both vertices and edges as subsets of vertices and edges of T.\n\nYou're given a tree with n vertices. Consider its vertices numbered with integers from 1 to n. Additionally an integer is written on every vertex of this tree. Initially the integer written on the i-th vertex is equal to v_{i}. In one move you can apply the following operation:  Select the subtree of the given tree that includes the vertex with number 1.  Increase (or decrease) by one all the integers which are written on the vertices of that subtree. \n\nCalculate the minimum number of moves that is required to make all the integers written on the vertices of the given tree equal to zero.\n\n-----Input-----\n\nThe first line of the input contains n (1 ≤ n ≤ 10^5). Each of the next n - 1 lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ n; a_{i} ≠ b_{i}) indicating there's an edge between vertices a_{i} and b_{i}. It's guaranteed that the input graph is a tree. \n\nThe last line of the input contains a list of n space-separated integers v_1, v_2, ..., v_{n} (|v_{i}| ≤ 10^9).\n\n-----Output-----\n\nPrint the minimum number of operations needed to solve the task.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n-----Examples-----\nInput\n3\n1 2\n1 3\n1 -1 1\n\nOutput\n3\n-/", "vc-preamble": "def list_max (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (list_max xs)", "vc-helpers": "", "vc-definitions": "def solve_tree_zeros (n : Nat) (edges : List (Nat × Nat)) (values : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_tree_zeros_nonnegative (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  solve_tree_zeros n edges values ≥ 0 :=\nsorry\n\ntheorem solve_tree_zeros_finite (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  ∃ (k : Nat), solve_tree_zeros n edges values = k :=\nsorry\n\ntheorem solve_tree_zeros_bounds (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :\n  solve_tree_zeros n edges values ≥ list_max (values.map Int.natAbs) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_zeros 3 [(1, 2), (1, 3)] [1, -1, 1]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_tree_zeros 5 [(2, 3), (4, 5), (2, 5), (1, 3)] [0, 2, 1, 4, 3]\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_tree_zeros 10 [(5, 6), (8, 2), (9, 3), (4, 1), (6, 10), (9, 8), (7, 10), (7, 4), (5, 2)] [0, -6, -9, -1, -5, -4, -2, -7, -8, -3]"}
{"id": "fvapps_002153", "vc-description": "/-\nZS the Coder loves mazes. Your job is to create one so that he can play with it. A maze consists of n × m rooms, and the rooms are arranged in n rows (numbered from the top to the bottom starting from 1) and m columns (numbered from the left to the right starting from 1). The room in the i-th row and j-th column is denoted by (i, j). A player starts in the room (1, 1) and wants to reach the room (n, m).\n\nEach room has four doors (except for ones at the maze border), one on each of its walls, and two adjacent by the wall rooms shares the same door. Some of the doors are locked, which means it is impossible to pass through the door. For example, if the door connecting (i, j) and (i, j + 1) is locked, then we can't go from (i, j) to (i, j + 1). Also, one can only travel between the rooms downwards (from the room (i, j) to the room (i + 1, j)) or rightwards (from the room (i, j) to the room (i, j + 1)) provided the corresponding door is not locked. [Image] This image represents a maze with some doors locked. The colored arrows denotes all the possible paths while a red cross denotes a locked door. \n\nZS the Coder considers a maze to have difficulty x if there is exactly x ways of travelling from the room (1, 1) to the room (n, m). Two ways are considered different if they differ by the sequence of rooms visited while travelling.\n\nYour task is to create a maze such that its difficulty is exactly equal to T. In addition, ZS the Coder doesn't like large mazes, so the size of the maze and the number of locked doors are limited. Sounds simple enough, right?\n\n-----Input-----\n\nThe first and only line of the input contains a single integer T (1 ≤ T ≤ 10^18), the difficulty of the required maze.\n\n-----Output-----\n\nThe first line should contain two integers n and m (1 ≤ n, m ≤ 50) — the number of rows and columns of the maze respectively.\n\nThe next line should contain a single integer k (0 ≤ k ≤ 300) — the number of locked doors in the maze.\n\nThen, k lines describing locked doors should follow. Each of them should contain four integers, x_1, y_1, x_2, y_2. This means that the door connecting room (x_1, y_1) and room (x_2, y_2) is locked. Note that room (x_2, y_2) should be adjacent either to the right or to the bottom of (x_1, y_1), i.e. x_2 + y_2 should be equal to x_1 + y_1 + 1. There should not be a locked door that appears twice in the list.\n\nIt is guaranteed that at least one solution exists. If there are multiple solutions, print any of them.\n\n-----Examples-----\nInput\n3\n\nOutput\n3 2\n0\n\nInput\n4\n\nOutput\n4 3\n3\n1 2 2 2\n3 2 3 3\n1 3 2 3\n\n-----Note-----\n\nHere are how the sample input and output looks like. The colored arrows denotes all the possible paths while a red cross denotes a locked door.\n\nIn the first sample case: [Image] \n\nIn the second sample case: [Image]\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def create_maze (T : Nat) : Nat × Nat × Nat × List (Nat × Nat × Nat × Nat) :=\nsorry\n\ndef is_valid_door (door : Nat × Nat × Nat × Nat) (n m : Nat) : Bool :=\nsorry\n\ndef are_doors_unique (doors : List (Nat × Nat × Nat × Nat)) : Bool :=\nsorry", "vc-theorems": "theorem minimal_maze_properties (T : Nat) (h : T > 0) (h2 : T ≤ 5) :\n  let (n, m, k, doors) := create_maze T\n  n = 4 ∧\n  m = 4 ∧\n  k ≥ 3 ∧\n  k ≤ 6 :=\nsorry\n\ntheorem large_maze_properties (T : Nat) (h : T ≥ 6^4) (h2 : T < 6^5) :\n  let (n, m, k, doors) := create_maze T\n  n = 12 ∧\n  m = 12 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002159", "vc-description": "/-\nLet $a_1, \\ldots, a_n$ be an array of $n$ positive integers. In one operation, you can choose an index $i$ such that $a_i = i$, and remove $a_i$ from the array (after the removal, the remaining parts are concatenated).\n\nThe weight of $a$ is defined as the maximum number of elements you can remove.\n\nYou must answer $q$ independent queries $(x, y)$: after replacing the $x$ first elements of $a$ and the $y$ last elements of $a$ by $n+1$ (making them impossible to remove), what would be the weight of $a$?\n\n-----Input-----\n\nThe first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 3 \\cdot 10^5$)  — the length of the array and the number of queries.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\leq a_i \\leq n$) — elements of the array.\n\nThe $i$-th of the next $q$ lines contains two integers $x$ and $y$ ($x, y \\ge 0$ and $x+y < n$).\n\n-----Output-----\n\nPrint $q$ lines, $i$-th line should contain a single integer  — the answer to the $i$-th query.\n\n-----Examples-----\nInput\n13 5\n2 2 3 9 5 4 6 5 7 8 3 11 13\n3 1\n0 0\n2 4\n5 0\n0 12\n\nOutput\n5\n11\n6\n1\n0\n\nInput\n5 2\n1 4 1 2 4\n0 0\n1 0\n\nOutput\n2\n0\n\n-----Note-----\n\nExplanation of the first query:\n\nAfter making first $x = 3$ and last $y = 1$ elements impossible to remove, $a$ becomes $[\\times, \\times, \\times, 9, 5, 4, 6, 5, 7, 8, 3, 11, \\times]$ (we represent $14$ as $\\times$ for clarity).\n\nHere is a strategy that removes $5$ elements (the element removed is colored in red):  $[\\times, \\times, \\times, 9, \\color{red}{5}, 4, 6, 5, 7, 8, 3, 11, \\times]$  $[\\times, \\times, \\times, 9, 4, 6, 5, 7, 8, 3, \\color{red}{11}, \\times]$  $[\\times, \\times, \\times, 9, 4, \\color{red}{6}, 5, 7, 8, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 7, \\color{red}{8}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, \\color{red}{7}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 3, \\times]$ (final state) \n\nIt is impossible to remove more than $5$ elements, hence the weight is $5$.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bitadd (idx : Nat) (val : Int) (bit : Array Int) : Array Int :=\n  sorry\n\ndef bitsum (idx : Nat) (bit : Array Int) : Int :=\n  sorry", "vc-theorems": "theorem bitadd_inverse (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx (-val) (bitadd idx val bit)) = bitsum idx bit :=\nsorry\n\ntheorem bitadd_retrieval (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx val bit) = bitsum idx bit + val :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002160", "vc-description": "/-\nThere are $n$ football teams in the world. \n\nThe Main Football Organization (MFO) wants to host at most $m$ games. MFO wants the $i$-th game to be played between the teams $a_i$ and $b_i$ in one of the $k$ stadiums. \n\nLet $s_{ij}$ be the numbers of games the $i$-th team played in the $j$-th stadium. MFO does not want a team to have much more games in one stadium than in the others. Therefore, for each team $i$, the absolute difference between the maximum and minimum among $s_{i1}, s_{i2}, \\ldots, s_{ik}$ should not exceed $2$.\n\nEach team has $w_i$ — the amount of money MFO will earn for each game of the $i$-th team. If the $i$-th team plays $l$ games, MFO will earn $w_i \\cdot l$.\n\nMFO needs to find what games in what stadiums they need to host in order to earn as much money as possible, not violating the rule they set.\n\nHowever, this problem is too complicated for MFO. Therefore, they are asking you to help them.\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, $k$ ($3 \\leq n \\leq 100$, $0 \\leq m \\leq 1\\,000$, $1 \\leq k \\leq 1\\,000$) — the number of teams, the number of games, and the number of stadiums.\n\nThe second line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($1 \\leq w_i \\leq 1\\,000$) — the amount of money MFO will earn for each game of the $i$-th game.\n\nEach of the following $m$ lines contains two integers $a_i$ and $b_i$ ($1 \\leq a_i, b_i \\leq n$, $a_i \\neq b_i$) — the teams that can play the $i$-th game. It is guaranteed that each pair of teams can play at most one game.\n\n-----Output-----\n\nFor each game in the same order, print $t_i$ ($1 \\leq t_i \\leq k$) — the number of the stadium, in which $a_i$ and $b_i$ will play the game. If the $i$-th game should not be played, $t_i$ should be equal to $0$.\n\nIf there are multiple answers, print any.\n\n-----Example-----\nInput\n7 11 3\n4 7 8 10 10 9 3\n6 2\n6 1\n7 6\n4 3\n4 6\n3 1\n5 3\n7 5\n7 3\n4 2\n1 4\n\nOutput\n3\n2\n1\n1\n3\n1\n2\n1\n2\n3\n2\n\n-----Note-----\n\nOne of possible solutions to the example is shown below: [Image]\n-/\n\n/- For a valid allocation, the number of games per stadium for each team differs by at most 2 -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The allocation list has the same length as the input game list -/\n\n/- Empty game list produces empty allocation -/\n\n/- Basic case works: two teams, one game, one stadium -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def allocate_stadium_games (n m k : Nat) (games : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem stadium_balance {n k : Nat} {games : List (Nat × Nat)} {allocation : List Nat}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1)\n  (h3 : allocation = allocate_stadium_games n games.length k games)\n  (h4 : ∀ g, g ∈ games → g.1 ≤ n ∧ g.2 ≤ n ∧ g.1 < g.2)\n  (h5 : ∀ s, s ∈ allocation → s ≥ 1 ∧ s ≤ k) :\n  ∀ t, t ≤ n →\n    ∀ s1 s2, s1 ≤ k → s2 ≤ k →\n      Nat.sub ((games.zip allocation).filter (λ p => (p.1.1 = t ∨ p.1.2 = t) ∧ p.2 = s1) |>.length)\n              ((games.zip allocation).filter (λ p => (p.1.1 = t ∨ p.1.2 = t) ∧ p.2 = s2) |>.length) ≤ 2 :=\nsorry\n\ntheorem allocation_length_eq_games {n k : Nat} {games : List (Nat × Nat)}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1) :\n  (allocate_stadium_games n games.length k games).length = games.length :=\nsorry\n\ntheorem empty_games_empty_allocation {n k : Nat}\n  (h1 : n ≥ 2)\n  (h2 : k ≥ 1) :\n  allocate_stadium_games n 0 k [] = [] :=\nsorry\n\ntheorem minimum_viable_case :\n  allocate_stadium_games 2 1 1 [(1, 2)] = [1] :=\nsorry", "vc-postamble": "/--\ninfo: m\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)"}
{"id": "fvapps_002161", "vc-description": "/-\nA festival will be held in a town's main street. There are n sections in the main street. The sections are numbered 1 through n from left to right. The distance between each adjacent sections is 1.\n\nIn the festival m fireworks will be launched. The i-th (1 ≤ i ≤ m) launching is on time t_{i} at section a_{i}. If you are at section x (1 ≤ x ≤ n) at the time of i-th launching, you'll gain happiness value b_{i} - |a_{i} - x| (note that the happiness value might be a negative value).\n\nYou can move up to d length units in a unit time interval, but it's prohibited to go out of the main street. Also you can be in an arbitrary section at initial time moment (time equals to 1), and want to maximize the sum of happiness that can be gained from watching fireworks. Find the maximum total happiness.\n\nNote that two or more fireworks can be launched at the same time.\n\n-----Input-----\n\nThe first line contains three integers n, m, d (1 ≤ n ≤ 150000; 1 ≤ m ≤ 300; 1 ≤ d ≤ n).\n\nEach of the next m lines contains integers a_{i}, b_{i}, t_{i} (1 ≤ a_{i} ≤ n; 1 ≤ b_{i} ≤ 10^9; 1 ≤ t_{i} ≤ 10^9). The i-th line contains description of the i-th launching.\n\nIt is guaranteed that the condition t_{i} ≤ t_{i} + 1 (1 ≤ i < m) will be satisfied.\n\n-----Output-----\n\nPrint a single integer — the maximum sum of happiness that you can gain from watching all the fireworks.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n-----Examples-----\nInput\n50 3 1\n49 1 1\n26 1 4\n6 1 10\n\nOutput\n-31\n\nInput\n10 2 1\n1 1000 4\n9 1000 4\n\nOutput\n1992\n-/", "vc-preamble": "def abs (n : Nat) (m : Nat) : Nat :=\n  if n ≥ m then n - m else m - n", "vc-helpers": "", "vc-definitions": "def solve_fireworks (n m d : Nat) (fireworks : List (Nat × Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem fireworks_total_balls_bound {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  solve_fireworks n m d fireworks ≤ (fireworks.foldl (fun acc p => acc + p.2.1) 0) + n :=\nsorry\n\ntheorem fireworks_timestamps_increasing {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  ∀ i, i < fireworks.length - 1 →\n    (fireworks.get ⟨i, sorry⟩).2.2 < (fireworks.get ⟨i+1, sorry⟩).2.2 :=\nsorry\n\ntheorem fireworks_positions_valid {n m d : Nat} {fireworks : List (Nat × Nat × Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  ∀ f ∈ fireworks, 1 ≤ f.1 ∧ f.1 ≤ n :=\nsorry\n\ntheorem single_firework_result {n balls d : Nat} {pos : Nat}\n  (h1 : n > 0) (h2 : balls > 0) (h3 : d > 0) (h4 : pos = n/2) :\n  solve_fireworks n 1 d [(pos, balls, 1)] =\n    balls - (List.range n).foldl (fun m i => min m (abs pos (i + 1))) (abs pos 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: -31\n-/\n#guard_msgs in\n#eval solve_fireworks 50 3 1 [(49, 1, 1), (26, 1, 4), (6, 1, 10)]\n\n/--\ninfo: 1992\n-/\n#guard_msgs in\n#eval solve_fireworks 10 2 1 [(1, 1000, 4), (9, 1000, 4)]\n\n/--\ninfo: 418\n-/\n#guard_msgs in\n#eval solve_fireworks 30 8 2 [(15, 97, 3), (18, 64, 10), (20, 14, 20), (16, 18, 36), (10, 23, 45), (12, 60, 53), (17, 93, 71), (11, 49, 85)]"}
{"id": "fvapps_002172", "vc-description": "/-\nYou are given two integer sequences, each of length N: a_1, ..., a_N and b_1, ..., b_N.\nThere are N^2 ways to choose two integers i and j such that 1 \\leq i, j \\leq N. For each of these N^2 pairs, we will compute a_i + b_j and write it on a sheet of paper.\nThat is, we will write N^2 integers in total.\nCompute the XOR of these N^2 integers.\nDefinition of XOR\nThe XOR of integers c_1, c_2, ..., c_m is defined as follows:\n - Let the XOR be X. In the binary representation of X, the digit in the 2^k's place (0 \\leq k; k is an integer) is 1 if there are an odd number of integers among c_1, c_2, ...c_m whose binary representation has 1 in the 2^k's place, and 0 if that number is even.\nFor example, let us compute the XOR of 3 and 5. The binary representation of 3 is 011, and the binary representation of 5 is 101, thus the XOR has the binary representation 110, that is, the XOR is 6.\n\n-----Constraints-----\n - All input values are integers.\n - 1 \\leq N \\leq 200,000\n - 0 \\leq a_i, b_i < 2^{28}\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\nb_1 b_2 ... b_N\n\n-----Output-----\nPrint the result of the computation.\n\n-----Sample Input-----\n2\n1 2\n3 4\n\n-----Sample Output-----\n2\n\nOn the sheet, the following four integers will be written: 4(1+3), 5(1+4), 5(2+3) and 6(2+4).\n-/\n\n/- For any valid input arrays A and B of length N, the output is non-negative and less than 2^30 -/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The result is symmetric with respect to input arrays -/\n\n/- When both input arrays are identical, the result is even -/\n\n/- When both input arrays contain only zeros, the result is zero -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compute_xor_sum (N : Nat) (A B : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) (h3 : ∀ x ∈ A, x ≤ 1000000) (h4 : ∀ x ∈ B, x ≤ 1000000) :\n  compute_xor_sum N A B ≥ 0 ∧ compute_xor_sum N A B < 2^30 :=\nsorry\n\ntheorem symmetry (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) :\n  compute_xor_sum N A B = compute_xor_sum N B A :=\nsorry\n\ntheorem identical_arrays (N : Nat) (A : List Nat) (h : A.length = N) :\n  2 ∣ compute_xor_sum N A A :=\nsorry\n\ntheorem zero_arrays (N : Nat) :\n  compute_xor_sum N (List.replicate N 0) (List.replicate N 0) = 0 :=\nsorry", "vc-postamble": "/--\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 2 [1, 2] [3, 4]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval compute_xor_sum 6 [4, 6, 0, 0, 3, 3] [0, 5, 6, 5, 0, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 5 [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]"}
{"id": "fvapps_002174", "vc-description": "/-\nAllen and Bessie are playing a simple number game. They both know a function $f: \\{0, 1\\}^n \\to \\mathbb{R}$, i. e. the function takes $n$ binary arguments and returns a real value. At the start of the game, the variables $x_1, x_2, \\dots, x_n$ are all set to $-1$. Each round, with equal probability, one of Allen or Bessie gets to make a move. A move consists of picking an $i$ such that $x_i = -1$ and either setting $x_i \\to 0$ or $x_i \\to 1$.\n\nAfter $n$ rounds all variables are set, and the game value resolves to $f(x_1, x_2, \\dots, x_n)$. Allen wants to maximize the game value, and Bessie wants to minimize it.\n\nYour goal is to help Allen and Bessie find the expected game value! They will play $r+1$ times though, so between each game, exactly one value of $f$ changes. In other words, between rounds $i$ and $i+1$ for $1 \\le i \\le r$, $f(z_1, \\dots, z_n) \\to g_i$ for some $(z_1, \\dots, z_n) \\in \\{0, 1\\}^n$. You are to find the expected game value in the beginning and after each change.\n\n-----Input-----\n\nThe first line contains two integers $n$ and $r$ ($1 \\le n \\le 18$, $0 \\le r \\le 2^{18}$).\n\nThe next line contains $2^n$ integers $c_0, c_1, \\dots, c_{2^n-1}$ ($0 \\le c_i \\le 10^9$), denoting the initial values of $f$. More specifically, $f(x_0, x_1, \\dots, x_{n-1}) = c_x$, if $x = \\overline{x_{n-1} \\ldots x_0}$ in binary.\n\nEach of the next $r$ lines contains two integers $z$ and $g$ ($0 \\le z \\le 2^n - 1$, $0 \\le g \\le 10^9$). If $z = \\overline{z_{n-1} \\dots z_0}$ in binary, then this means to set $f(z_0, \\dots, z_{n-1}) \\to g$.\n\n-----Output-----\n\nPrint $r+1$ lines, the $i$-th of which denotes the value of the game $f$ during the $i$-th round. Your answer must have absolute or relative error within $10^{-6}$.\n\nFormally, let your answer be $a$, and the jury's answer be $b$. Your answer is considered correct if $\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6}$.\n\n-----Examples-----\nInput\n2 2\n0 1 2 3\n2 5\n0 4\n\nOutput\n1.500000\n2.250000\n3.250000\n\nInput\n1 0\n2 3\n\nOutput\n2.500000\n\nInput\n2 0\n1 1 1 1\n\nOutput\n1.000000\n\n-----Note-----\n\nConsider the second test case. If Allen goes first, he will set $x_1 \\to 1$, so the final value will be $3$. If Bessie goes first, then she will set $x_1 \\to 0$ so the final value will be $2$. Thus the answer is $2.5$.\n\nIn the third test case, the game value will always be $1$ regardless of Allen and Bessie's play.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_game (n : Nat) (r : Nat) (initial : List Int) (changes : List (Nat × Int)) : List Float :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry\n\ndef list_average (l : List Int) : Float :=\n  sorry\n\ndef list_update (l : List Int) (idx : Nat) (val : Int) : List Int :=\n  sorry\n\ndef float_close (a b : Float) : Bool :=\n  sorry", "vc-theorems": "theorem solve_game_result_length {n r : Nat} {initial : List Int} {changes : List (Nat × Int)} :\n  initial.length = 2^n →\n  (∀ change, change ∈ changes → change.1 < 2^n) →\n  (solve_game n r initial changes).length = r + 1 :=\nsorry\n\ntheorem solve_game_averages {n r : Nat} {initial : List Int} {changes : List (Nat × Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : ∀ change, change ∈ changes → change.1 < 2^n)\n  (i : Fin r)\n  (h_changes_length : changes.length > i.val)\n  (h_result_length : (solve_game n r initial changes).length > i.val) :\n  let updated := list_update initial ((changes.get ⟨i.val, h_changes_length⟩).1) ((changes.get ⟨i.val, h_changes_length⟩).2)\n  float_close ((solve_game n r initial changes).get ⟨i.val, h_result_length⟩) (list_average updated) :=\nsorry\n\ntheorem solve_game_final_average {n r : Nat} {initial : List Int} {changes : List (Nat × Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : ∀ change, change ∈ changes → change.1 < 2^n)\n  (h_r : r > 0)\n  (h_changes_length : changes.length ≥ r)\n  (h_idx : r - 1 < changes.length)\n  (h_result_length : r < (solve_game n r initial changes).length) :\n  let final_update := list_update initial ((changes.get ⟨r-1, h_idx⟩).1) ((changes.get ⟨r-1, h_idx⟩).2)\n  float_close ((solve_game n r initial changes).get ⟨r, h_result_length⟩) (list_average final_update) :=\nsorry\n\ntheorem solve_game_no_changes {n : Nat} {initial : List Int}\n  (h_init : initial.length = 2^n)\n  (h_all_ones : ∀ x, x ∈ initial → x = 1)\n  (h_length : 0 < (solve_game n 0 initial []).length) :\n  (solve_game n 0 initial []).length = 1 ∧\n  float_close ((solve_game n 0 initial []).get ⟨0, h_length⟩) 1.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002175", "vc-description": "/-\nJohnny has just found the new, great tutorial: \"How to become a grandmaster?\". The tutorial tells many strange and unexpected for Johnny things, such as you have to be patient or that very important is solving many harder and harder problems. \n\nThe boy has found an online judge with tasks divided by topics they cover. He has picked $p^{k_i}$ problems from $i$-th category ($p$ is his favorite number). He wants to solve them in two weeks (the patience condition is too hard for Johnny, so for simplicity, he looks only at easy tasks, which can be solved in such a period). Now our future grandmaster has to decide which topics to cover first and which the second week. Help him assign topics in such a way, that workload is balanced.\n\nFormally, given $n$ numbers $p^{k_i}$, the boy wants to divide them into two disjoint sets, minimizing the absolute difference between sums of numbers in each set. Find the minimal absolute difference. Output the result modulo $10^{9}+7$.\n\n-----Input-----\n\nInput consists of multiple test cases. The first line contains one integer $t$ $(1 \\leq t \\leq 10^5)$ — the number of test cases. Each test case is described as follows:\n\nThe first line contains two integers $n$ and $p$ $(1 \\leq n, p \\leq 10^6)$. The second line contains $n$ integers $k_i$ $(0 \\leq k_i \\leq 10^6)$.\n\nThe sum of $n$ over all test cases doesn't exceed $10^6$.\n\n-----Output-----\n\nOutput one integer — the reminder of division the answer by $1\\,000\\,000\\,007$.\n\n-----Example-----\nInput\n4\n5 2\n2 3 4 4 3\n3 1\n2 10 1000\n4 5\n0 1 1 100\n1 8\n89\n\nOutput\n4\n1\n146981438\n747093407\n\n-----Note-----\n\nYou have to minimize the difference, not it's remainder. For example, if the minimum difference is equal to $2$, but there is also a distribution where the difference is $10^9 + 8$, then the answer is $2$, not $1$.\n\nIn the first test case of the example, there're the following numbers: $4$, $8$, $16$, $16$, and $8$. We can divide them into such two sets: ${4, 8, 16}$ and ${8, 16}$. Then the difference between the sums of numbers in sets would be $4$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MOD := 1000000007\n\ndef List.sort (l: List Nat) : List Nat :=\n  sorry\n\ndef solve_minimized_workload (n: Nat) (p: Nat) (workloads: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem workload_result_bounds (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p > 0) (h4: p ≤ 10)\n  (h5: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h6: workloads.length > 0) (h7: workloads.length ≤ 100) :\n  let result := solve_minimized_workload n p workloads\n  0 ≤ result ∧ result < MOD :=\nsorry\n\ntheorem workload_p_one_special_case (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p = 1)\n  (h4: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h5: workloads.length > 0) (h6: workloads.length ≤ 100) :\n  let result := solve_minimized_workload n p workloads\n  result = n % 2 ∧ (result = 0 ∨ result = 1) :=\nsorry\n\ntheorem workload_sort_invariant (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n ≤ 100) (h3: p > 0) (h4: p ≤ 10)\n  (h5: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h6: workloads.length > 0) (h7: workloads.length ≤ 100) :\n  solve_minimized_workload n p workloads =\n  solve_minimized_workload n p (List.sort workloads) :=\nsorry\n\ntheorem workload_length_matches_n (p: Nat) (workloads: List Nat)\n  (h1: p > 0) (h2: p ≤ 10)\n  (h3: ∀ w ∈ workloads, w ≥ 0 ∧ w ≤ 1000)\n  (h4: workloads.length > 0) (h5: workloads.length ≤ 100) :\n  let n := workloads.length\n  let result := solve_minimized_workload n p workloads\n  0 ≤ result ∧ result < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_minimized_workload 5 2 [2, 3, 4, 4, 3]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_minimized_workload 3 1 [2, 10, 1000]\n\n/--\ninfo: 146981438\n-/\n#guard_msgs in\n#eval solve_minimized_workload 4 5 [0, 1, 1, 100]"}
{"id": "fvapps_002177", "vc-description": "/-\nRecently Lynyrd and Skynyrd went to a shop where Lynyrd bought a permutation $p$ of length $n$, and Skynyrd bought an array $a$ of length $m$, consisting of integers from $1$ to $n$. \n\nLynyrd and Skynyrd became bored, so they asked you $q$ queries, each of which has the following form: \"does the subsegment of $a$ from the $l$-th to the $r$-th positions, inclusive, have a subsequence that is a cyclic shift of $p$?\" Please answer the queries.\n\nA permutation of length $n$ is a sequence of $n$ integers such that each integer from $1$ to $n$ appears exactly once in it.\n\nA cyclic shift of a permutation $(p_1, p_2, \\ldots, p_n)$ is a permutation $(p_i, p_{i + 1}, \\ldots, p_{n}, p_1, p_2, \\ldots, p_{i - 1})$ for some $i$ from $1$ to $n$. For example, a permutation $(2, 1, 3)$ has three distinct cyclic shifts: $(2, 1, 3)$, $(1, 3, 2)$, $(3, 2, 1)$.\n\nA subsequence of a subsegment of array $a$ from the $l$-th to the $r$-th positions, inclusive, is a sequence $a_{i_1}, a_{i_2}, \\ldots, a_{i_k}$ for some $i_1, i_2, \\ldots, i_k$ such that $l \\leq i_1 < i_2 < \\ldots < i_k \\leq r$.\n\n-----Input-----\n\nThe first line contains three integers $n$, $m$, $q$ ($1 \\le n, m, q \\le 2 \\cdot 10^5$) — the length of the permutation $p$, the length of the array $a$ and the number of queries.\n\nThe next line contains $n$ integers from $1$ to $n$, where the $i$-th of them is the $i$-th element of the permutation. Each integer from $1$ to $n$ appears exactly once.\n\nThe next line contains $m$ integers from $1$ to $n$, the $i$-th of them is the $i$-th element of the array $a$.\n\nThe next $q$ lines describe queries. The $i$-th of these lines contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le m$), meaning that the $i$-th query is about the subsegment of the array from the $l_i$-th to the $r_i$-th positions, inclusive.\n\n-----Output-----\n\nPrint a single string of length $q$, consisting of $0$ and $1$, the digit on the $i$-th positions should be $1$, if the subsegment of array $a$ from the $l_i$-th to the $r_i$-th positions, inclusive, contains a subsequence that is a cyclic shift of $p$, and $0$ otherwise.\n\n-----Examples-----\nInput\n3 6 3\n2 1 3\n1 2 3 1 2 3\n1 5\n2 6\n3 5\n\nOutput\n110\n\nInput\n2 4 3\n2 1\n1 1 2 2\n1 2\n2 3\n3 4\n\nOutput\n010\n\n-----Note-----\n\nIn the first example the segment from the $1$-st to the $5$-th positions is $1, 2, 3, 1, 2$. There is a subsequence $1, 3, 2$ that is a cyclic shift of the permutation. The subsegment from the $2$-nd to the $6$-th positions also contains a subsequence $2, 1, 3$ that is equal to the permutation. The subsegment from the $3$-rd to the $5$-th positions is $3, 1, 2$, there is only one subsequence of length $3$ ($3, 1, 2$), but it is not a cyclic shift of the permutation.\n\nIn the second example the possible cyclic shifts are $1, 2$ and $2, 1$. The subsegment from the $1$-st to the $2$-nd positions is $1, 1$, its subsequences are not cyclic shifts of the permutation. The subsegment from the $2$-nd to the $3$-rd positions is $1, 2$, it coincides with the permutation. The subsegment from the $3$ to the $4$ positions is $2, 2$, its subsequences are not cyclic shifts of the permutation.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_cyclic_permutation (n m q : Nat) (p : List Nat) (a : List Nat) (queries : List (Nat × Nat)) : String :=\n  sorry\n\ndef String.reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem result_is_valid_binary_string {n m q : Nat} {p a : List Nat} {queries : List (Nat × Nat)}\n  (h₁ : n > 0) (h₂ : m > 0) (h₃ : q > 0)\n  (h₄ : p.length = n) (h₅ : a.length = m)\n  (h₆ : queries.length = q)\n  (h₇ : ∀ x ∈ p, 1 ≤ x ∧ x ≤ n)\n  (h₈ : ∀ x ∈ a, 1 ≤ x ∧ x ≤ n)\n  (h₉ : ∀ q ∈ queries, 1 ≤ q.1 ∧ q.1 ≤ m ∧ 1 ≤ q.2 ∧ q.2 ≤ m ∧ q.1 ≤ q.2) :\n  let result := solve_cyclic_permutation n m q p a queries\n  result.length = q ∧ ∀ c ∈ result.data, c = '0' ∨ c = '1' :=\nsorry\n\ntheorem query_ordering_invariant {n m q : Nat} {p a : List Nat} {queries : List (Nat × Nat)}\n  (h₁ : n > 0) (h₂ : m > 0) (h₃ : q > 0)\n  (h₄ : p.length = n) (h₅ : a.length = m)\n  (h₆ : queries.length = q)\n  (h₇ : ∀ x ∈ p, 1 ≤ x ∧ x ≤ n)\n  (h₈ : ∀ x ∈ a, 1 ≤ x ∧ x ≤ n)\n  (h₉ : ∀ q ∈ queries, 1 ≤ q.1 ∧ q.1 ≤ m ∧ 1 ≤ q.2 ∧ q.2 ≤ m ∧ q.1 ≤ q.2) :\n  solve_cyclic_permutation n m q p a queries =\n  String.reverse (solve_cyclic_permutation n m q p a (List.reverse queries)) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: '110'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 3 6 3 [2, 1, 3] [1, 2, 3, 1, 2, 3] [[1, 5], [2, 6], [3, 5]]\n\n/--\ninfo: '010'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 2 4 3 [2, 1] [1, 1, 2, 2] [[1, 2], [2, 3], [3, 4]]\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 1 1 1 [1] [1] [[1, 1]]"}
{"id": "fvapps_002178", "vc-description": "/-\nRecently Vasya learned that, given two points with different $x$ coordinates, you can draw through them exactly one parabola with equation of type $y = x^2 + bx + c$, where $b$ and $c$ are reals. Let's call such a parabola an $U$-shaped one.\n\nVasya drew several distinct points with integer coordinates on a plane and then drew an $U$-shaped parabola through each pair of the points that have different $x$ coordinates. The picture became somewhat messy, but Vasya still wants to count how many of the parabolas drawn don't have any drawn point inside their internal area. Help Vasya.\n\nThe internal area of an $U$-shaped parabola is the part of the plane that lies strictly above the parabola when the $y$ axis is directed upwards.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100\\,000$) — the number of points.\n\nThe next $n$ lines describe the points, the $i$-th of them contains two integers $x_i$ and $y_i$ — the coordinates of the $i$-th point. It is guaranteed that all points are distinct and that the coordinates do not exceed $10^6$ by absolute value.\n\n-----Output-----\n\nIn the only line print a single integer — the number of $U$-shaped parabolas that pass through at least two of the given points and do not contain any of the given points inside their internal area (excluding the parabola itself).\n\n-----Examples-----\nInput\n3\n-1 0\n0 2\n1 0\n\nOutput\n2\n\nInput\n5\n1 0\n1 -1\n0 -1\n-1 0\n-1 -1\n\nOutput\n1\n\n-----Note-----\n\nOn the pictures below all $U$-shaped parabolas that pass through at least two given points are drawn for each of the examples. The $U$-shaped parabolas that do not have any given point inside their internal area are drawn in red.  [Image] The first example. \n\n [Image] The second example.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countEmptyParabolas (points : List (Int × Int)) : Nat :=\n  sorry\n\ndef makeParabolaPoints (a h k : Int) (n : Nat) : List (Int × Int) :=\n  sorry", "vc-theorems": "theorem countEmptyParabolas_nonnegative (points : List (Int × Int)) :\n  countEmptyParabolas points ≥ 0 := by\n  sorry\n\ntheorem countEmptyParabolas_single_point (point : Int × Int) :\n  countEmptyParabolas [point] = 0 := by\n  sorry\n\ntheorem countEmptyParabolas_through_parabola_points (a h k : Int) :\n  a ≠ 0 →\n  countEmptyParabolas (makeParabolaPoints a h k 5) ≥ 1 := by\n  sorry\n\ntheorem countEmptyParabolas_duplicate_x_values (points : List (Int × Int)) :\n  let deduped := points.foldl (fun acc (x, y) =>\n    match acc.find? (fun (x', _) => x' = x) with\n    | none => acc ++ [(x, y)]\n    | some (x', y') =>\n      if y > y'\n      then acc.map (fun (x'', y'') => if x'' = x then (x, y) else (x'', y''))\n      else acc\n    ) []\n  countEmptyParabolas points = countEmptyParabolas deduped := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-1, 0), (0, 2), (1, 0)]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, -1)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-751115, -925948)]"}
{"id": "fvapps_002179", "vc-description": "/-\nIn number world, two different numbers are friends if they have a lot in common, but also each one has unique perks.\n\nMore precisely, two different numbers $a$ and $b$ are friends if $gcd(a,b)$, $\\frac{a}{gcd(a,b)}$, $\\frac{b}{gcd(a,b)}$ can form sides of a triangle.\n\nThree numbers $a$, $b$ and $c$ can form sides of a triangle if $a + b > c$, $b + c > a$ and $c + a > b$.\n\nIn a group of numbers, a number is lonely if it doesn't have any friends in that group.\n\nGiven a group of numbers containing all numbers from $1, 2, 3, ..., n$, how many numbers in that group are lonely?\n\n-----Input-----\n\nThe first line contains a single integer $t$ $(1 \\leq t \\leq 10^6)$ - number of test cases.\n\nOn next line there are $t$ numbers, $n_i$ $(1 \\leq n_i \\leq 10^6)$ - meaning that in case $i$ you should solve for numbers $1, 2, 3, ..., n_i$.\n\n-----Output-----\n\nFor each test case, print the answer on separate lines: number of lonely numbers in group $1, 2, 3, ..., n_i$.\n\n-----Example-----\nInput\n3\n1 5 10\n\nOutput\n1\n3\n3\n\n-----Note-----\n\nFor first test case, $1$ is the only number and therefore lonely.\n\nFor second test case where $n=5$, numbers $1$, $3$ and $5$ are lonely.\n\nFor third test case where $n=10$, numbers $1$, $5$ and $7$ are lonely.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\nsorry\n\ndef checkNumbersFriends (a b : Nat) : Bool :=\nsorry\n\ndef countLonelyNumbers (n : Nat) : Nat :=\nsorry\n\ndef isTriangle (a b c : Nat) : Bool :=\nsorry\n\ndef solveTestCases (nums : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem gcd_positive (a b : Nat) : a > 0 → b > 0 → gcd a b > 0 :=\nsorry\n\ntheorem not_self_friends (a : Nat) : a > 0 →\n  checkNumbersFriends a a = false :=\nsorry\n\ntheorem lonely_numbers_bounds (n : Nat) : n > 0 →\n  countLonelyNumbers n ≤ n :=\nsorry\n\ntheorem gcd_divides (a b : Nat) : a > 0 → b > 0 →\n  a % (gcd a b) = 0 ∧ b % (gcd a b) = 0 :=\nsorry\n\ntheorem gcd_symmetric (a b : Nat) : a > 0 → b > 0 → gcd a b = gcd b a :=\nsorry\n\ntheorem triangle_inequality (a b c : Nat) : a > 0 → b > 0 → c > 0 →\n  isTriangle a b c = true →\n    a + b > c ∧ b + c > a ∧ a + c > b :=\nsorry\n\ntheorem triangle_symmetric (a b c : Nat) : a > 0 → b > 0 → c > 0 →\n  isTriangle a b c = isTriangle b c a ∧\n  isTriangle b c a = isTriangle c a b :=\nsorry\n\ntheorem friends_symmetric (a b : Nat) : a > 0 → b > 0 →\n  checkNumbersFriends a b = checkNumbersFriends b a :=\nsorry\n\ntheorem one_is_lonely : countLonelyNumbers 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [1, 3, 3]\n-/\n#guard_msgs in\n#eval solve_test_cases [1, 5, 10]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_test_cases [1]\n\n/--\ninfo: [3, 7]\n-/\n#guard_msgs in\n#eval solve_test_cases [10, 20]"}
{"id": "fvapps_002180", "vc-description": "/-\nIahub likes trees very much. Recently he discovered an interesting tree named propagating tree. The tree consists of n nodes numbered from 1 to n, each node i having an initial value a_{i}. The root of the tree is node 1.\n\nThis tree has a special property: when a value val is added to a value of node i, the value -val is added to values of all the children of node i. Note that when you add value -val to a child of node i, you also add -(-val) to all children of the child of node i and so on. Look an example explanation to understand better how it works.\n\nThis tree supports two types of queries:\n\n  \"1 x val\" — val is added to the value of node x;  \"2 x\" — print the current value of node x. \n\nIn order to help Iahub understand the tree better, you must answer m queries of the preceding type.\n\n-----Input-----\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1000). Each of the next n–1 lines contains two integers v_{i} and u_{i} (1 ≤ v_{i}, u_{i} ≤ n), meaning that there is an edge between nodes v_{i} and u_{i}.\n\nEach of the next m lines contains a query in the format described above. It is guaranteed that the following constraints hold for all queries: 1 ≤ x ≤ n, 1 ≤ val ≤ 1000.\n\n-----Output-----\n\nFor each query of type two (print the value of node x) you must print the answer to the query on a separate line. The queries must be answered in the order given in the input.\n\n-----Examples-----\nInput\n5 5\n1 2 1 1 2\n1 2\n1 3\n2 4\n2 5\n1 2 3\n1 1 2\n2 1\n2 2\n2 4\n\nOutput\n3\n3\n0\n\n-----Note-----\n\nThe values of the nodes are [1, 2, 1, 1, 2] at the beginning.\n\nThen value 3 is added to node 2. It propagates and value -3 is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So the values of the nodes are [1, 5, 1,  - 2,  - 1].\n\nThen value 2 is added to node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node 3 has no sons, so it cannot propagate from there. The values of the nodes are [3, 3,  - 1, 0, 1].\n\nYou can see all the definitions about the tree at the following link: http://en.wikipedia.org/wiki/Tree_(graph_theory)\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: unguarded", "vc-preamble": "def BIT (n : Nat) : Type := Unit", "vc-helpers": "", "vc-definitions": "def BIT.add (bit : BIT n) (i j v : Nat) : Unit :=\nsorry\n\ndef BIT.get_val (bit : BIT n) (i : Nat) : Nat :=\nsorry\n\ndef BIT.mk (n : Nat) : BIT n :=\nsorry\n\ndef solve_tree_queries (n : Nat) (costs : List Nat) (edges : List (List Nat)) (queries : List (List Nat)) : List Nat :=\nsorry", "vc-theorems": "theorem bit_get_after_add (n i : Nat) (h : i < n) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 1 :=\nsorry\n\ntheorem bit_accumulate_adds (n i : Nat) (h : i < n - 1) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 2 :=\nsorry\n\ntheorem solve_tree_queries_initial_cost\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (h : n ≥ 2) :\n  let queries := [[2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 :=\nsorry\n\ntheorem solve_tree_queries_update\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (val : Nat) (h : n ≥ 2) :\n  let queries := [[1,1,val], [2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 + val :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002181", "vc-description": "/-\nA rectangle with sides $A$ and $B$ is cut into rectangles with cuts parallel to its sides. For example, if $p$ horizontal and $q$ vertical cuts were made, $(p + 1) \\cdot (q + 1)$ rectangles were left after the cutting. After the cutting, rectangles were of $n$ different types. Two rectangles are different if at least one side of one rectangle isn't equal to the corresponding side of the other. Note that the rectangle can't be rotated, this means that rectangles $a \\times b$ and $b \\times a$ are considered different if $a \\neq b$.\n\nFor each type of rectangles, lengths of the sides of rectangles are given along with the amount of the rectangles of this type that were left after cutting the initial rectangle.\n\nCalculate the amount of pairs $(A; B)$ such as the given rectangles could be created by cutting the rectangle with sides of lengths $A$ and $B$. Note that pairs $(A; B)$ and $(B; A)$ are considered different when $A \\neq B$.\n\n-----Input-----\n\nThe first line consists of a single integer $n$ ($1 \\leq n \\leq 2 \\cdot 10^{5}$) — amount of different types of rectangles left after cutting the initial rectangle.\n\nThe next $n$ lines each consist of three integers $w_{i}, h_{i}, c_{i}$ $(1 \\leq w_{i}, h_{i}, c_{i} \\leq 10^{12})$ — the lengths of the sides of the rectangles of this type and the amount of the rectangles of this type.\n\nIt is guaranteed that the rectangles of the different types are different.\n\n-----Output-----\n\nOutput one integer — the answer to the problem.\n\n-----Examples-----\nInput\n1\n1 1 9\n\nOutput\n3\n\nInput\n2\n2 3 20\n2 4 40\n\nOutput\n6\n\nInput\n2\n1 2 5\n2 3 5\n\nOutput\n0\n\n-----Note-----\n\nIn the first sample there are three suitable pairs: $(1; 9)$, $(3; 3)$ and $(9; 1)$.\n\nIn the second sample case there are 6 suitable pairs: $(2; 220)$, $(4; 110)$, $(8; 55)$, $(10; 44)$, $(20; 22)$ and $(40; 11)$.\n\nHere the sample of cut for $(20; 22)$.\n\n [Image] \n\nThe third sample has no suitable pairs.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_rectangle_pairs (n : Nat) (rectangles : List (Nat × Nat × Nat)) : Nat :=\n  sorry\n\ndef sqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem non_negative_result (n : Nat) (rectangles : List (Nat × Nat × Nat)) :\n  count_rectangle_pairs n rectangles ≥ 0 :=\nsorry\n\ntheorem single_rect_count (rect : Nat × Nat × Nat) (count : Nat)\n    (h : rect.2.2 = count) :\n  let factors := (List.range (sqrt count)).filter (fun i => count % i = 0)\n  count_rectangle_pairs 1 [rect] = if sqrt count * sqrt count = count\n    then 2 * factors.length - 1\n    else 2 * factors.length :=\nsorry\n\ntheorem result_bounded_by_min_count (n : Nat) (rectangles : List (Nat × Nat × Nat))\n    (h : rectangles ≠ []) :\n  count_rectangle_pairs n rectangles ≤\n    List.foldl Nat.min ((List.head! rectangles).2.2)\n      (List.tail! rectangles |>.map (fun r => r.2.2)) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 1 [(1, 1, 9)]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(2, 3, 20), (2, 4, 40)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(1, 2, 5), (2, 3, 5)]"}
{"id": "fvapps_002188", "vc-description": "/-\nA subsequence of a string S is a string that can be obtained by deleting zero or more characters from S without changing the order of the remaining characters.\nFor example, arc, artistic and (an empty string) are all subsequences of artistic; abc and ci are not.\nYou are given a string A consisting of lowercase English letters.\nFind the shortest string among the strings consisting of lowercase English letters that are not subsequences of A.\nIf there are more than one such string, find the lexicographically smallest one among them.\n\n-----Constraints-----\n - 1 \\leq |A| \\leq 2 \\times 10^5\n - A consists of lowercase English letters.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nA\n\n-----Output-----\nPrint the lexicographically smallest string among the shortest strings consisting of lowercase English letters that are not subsequences of A.\n\n-----Sample Input-----\natcoderregularcontest\n\n-----Sample Output-----\nb\n\nThe string atcoderregularcontest contains a as a subsequence, but not b.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_shortest_non_subsequence (s : String) : String :=\n  sorry\n\ndef is_subsequence (needle haystack : String) : Bool :=\n  sorry\n\ndef generate_strings (length : Nat) : List String :=\n  sorry\n\ndef all_chars_in_range (s : String) : Bool :=\n  sorry\n\ndef all_lower (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_is_valid_string (s : String) :\n  let result := find_shortest_non_subsequence s\n  (result.length > 0) ∧ (all_lower result) := by\n  sorry\n\ntheorem result_is_minimal (s : String) :\n  let result := find_shortest_non_subsequence s\n  ∀ n : Nat, n < result.length →\n  ∀ possible : String, possible.length = n →\n  is_subsequence possible s := by\n  sorry\n\ntheorem result_for_all_letters {s : String} :\n  s.length = 26 →\n  (∀ c : Char, c.isLower → s.contains c) →\n  find_shortest_non_subsequence s = \"aa\" := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 'b'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"atcoderregularcontest\"\n\n/--\ninfo: 'aa'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"abcdefghijklmnopqrstuvwxyz\"\n\n/--\ninfo: 'aca'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"frqnvhydscshfcgdemurlfrutcpzhopfotpifgepnqjxupnskapziurswqazdwnwbgdhyktfyhqqxpoidfhjdakoxraiedxskywuepzfniuyskxiyjpjlxuqnfgmnjcvtlpnclfkpervxmdbvrbrdn\""}
{"id": "fvapps_002190", "vc-description": "/-\nYou are given a sequence D_1, D_2, ..., D_N of length N.\nThe values of D_i are all distinct.\nDoes a tree with N vertices that satisfies the following conditions exist?\n - The vertices are numbered 1,2,..., N.\n - The edges are numbered 1,2,..., N-1, and Edge i connects Vertex u_i and v_i.\n - For each vertex i, the sum of the distances from i to the other vertices is D_i, assuming that the length of each edge is 1.\nIf such a tree exists, construct one such tree.\n\n-----Constraints-----\n - 2 \\leq N \\leq 100000\n - 1 \\leq D_i \\leq 10^{12}\n - D_i are all distinct.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nD_1\nD_2\n:\nD_N\n\n-----Output-----\nIf a tree with n vertices that satisfies the conditions does not exist, print -1.\nIf a tree with n vertices that satisfies the conditions exist, print n-1 lines.\nThe i-th line should contain u_i and v_i with a space in between.\nIf there are multiple trees that satisfy the conditions, any such tree will be accepted.\n\n-----Sample Input-----\n7\n10\n15\n13\n18\n11\n14\n19\n\n-----Sample Output-----\n1 2\n1 3\n1 5\n3 4\n5 6\n6 7\n\nThe tree shown below satisfies the conditions.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkTreeWithDistances (N : Nat) (distances : List Nat) : List (Nat × Nat) ⊕ Unit :=\n  sorry\n\ndef isValidTree (N : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem arbitrary_inputs_valid {N : Nat} {distances : List Nat}\n  (h1 : N ≥ 2) (h2 : N ≤ 20) (h3 : distances.length = N) :\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :=\nsorry\n\ntheorem identical_distances_invalid {N : Nat} (h : N ≥ 2) :\n  let distances := List.replicate N N\n  checkTreeWithDistances N distances = .inr () :=\nsorry\n\ntheorem sequential_distances_valid {N : Nat} (h1 : N ≥ 2) (h2 : N ≤ 20) :\n  let distances := List.range N\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :=\nsorry\n\ntheorem edge_cases :\n  (checkTreeWithDistances 2 [1,1] = .inr ()) ∧\n  (checkTreeWithDistances 2 [0,0] = .inr ()) ∧\n  (match checkTreeWithDistances 3 [3,4,5] with\n   | .inl edges => isValidTree 3 edges = true\n   | .inr _ => False) :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: N1 - 1\n-/\n#guard_msgs in\n#eval len result\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval check_tree_with_distances 2 [1, 2]\n\n/--\ninfo: N3 - 1\n-/\n#guard_msgs in\n#eval len result"}
{"id": "fvapps_002191", "vc-description": "/-\nLet x be a string of length at least 1.\nWe will call x a good string, if for any string y and any integer k (k \\geq 2), the string obtained by concatenating k copies of y is different from x.\nFor example, a, bbc and cdcdc are good strings, while aa, bbbb and cdcdcd are not.\nLet w be a string of length at least 1.\nFor a sequence F=(\\,f_1,\\,f_2,\\,...,\\,f_m) consisting of m elements,\nwe will call F a good representation of w, if the following conditions are both satisfied:\n - For any i \\, (1 \\leq i \\leq m), f_i is a good string.\n - The string obtained by concatenating f_1,\\,f_2,\\,...,\\,f_m in this order, is w.\nFor example, when w=aabb, there are five good representations of w:\n - (aabb)\n - (a,abb)\n - (aab,b)\n - (a,ab,b)\n - (a,a,b,b)\nAmong the good representations of w, the ones with the smallest number of elements are called the best representations of w.\nFor example, there are only one best representation of w=aabb: (aabb).\nYou are given a string w. Find the following:\n - the number of elements of a best representation of w\n - the number of the best representations of w, modulo 1000000007 \\, (=10^9+7)\n(It is guaranteed that a good representation of w always exists.)\n\n-----Constraints-----\n - 1 \\leq |w| \\leq 500000 \\, (=5 \\times 10^5)\n - w consists of lowercase letters (a-z).\n\n-----Partial Score-----\n - 400 points will be awarded for passing the test set satisfying 1 \\leq |w| \\leq 4000.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nw\n\n-----Output-----\nPrint 2 lines.\n - In the first line, print the number of elements of a best representation of w.\n - In the second line, print the number of the best representations of w, modulo 1000000007.\n\n-----Sample Input-----\naab\n\n-----Sample Output-----\n1\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_good_substrings : String → Nat × Nat :=\n  fun _ => sorry\n\ndef reverseString : String → String :=\n  fun _ => sorry", "vc-theorems": "theorem solve_good_substrings_result_structure\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.1 > 0 ∧ result.2 > 0 :=\n  sorry\n\ntheorem solve_good_substrings_first_element_values\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.1 = 1 ∨ result.1 = 2 ∨ result.1 = s.length :=\n  sorry\n\ntheorem solve_good_substrings_count_bound\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.2 ≤ s.length - 1 ∨ result.2 = 1 :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"aab\"\n\n/--\ninfo: (2, 3)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"bcbc\"\n\n/--\ninfo: (3, 1)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"ddd\""}
{"id": "fvapps_002208", "vc-description": "/-\nImportant: All possible tests are in the pretest, so you shouldn't hack on this problem. So, if you passed pretests, you will also pass the system test.\n\nYou are an adventurer currently journeying inside an evil temple. After defeating a couple of weak monsters, you arrived at a square room consisting of tiles forming an n × n grid, surrounded entirely by walls. At the end of the room lies a door locked with evil magical forces. The following inscriptions are written on the door:\n\n The sound of clashing rocks will awaken the door! \n\nBeing a very senior adventurer, you immediately realize what this means. In the room next door lies an infinite number of magical rocks. There are four types of rocks:   '^': this rock moves upwards;  '<': this rock moves leftwards;  '>': this rock moves rightwards;  'v': this rock moves downwards. \n\nTo open the door, you first need to place the rocks on some of the tiles (one tile can be occupied by at most one rock). Then, you select a single rock that you have placed and activate it. The activated rock will then move in its direction until it hits another rock or hits the walls of the room (the rock will not move if something already blocks it in its chosen direction). The rock then deactivates. If it hits the walls, or if there have been already 10^7 events of rock becoming activated, the movements end. Otherwise, the rock that was hit becomes activated and this procedure is repeated.\n\nIf a rock moves at least one cell before hitting either the wall or another rock, the hit produces a sound. The door will open once the number of produced sounds is at least x. It is okay for the rocks to continue moving after producing x sounds.\n\nThe following picture illustrates the four possible scenarios of moving rocks.\n\n Moves at least one cell, then hits another rock. A sound is produced, the hit rock becomes activated.\n\n [Image] \n\n Moves at least one cell, then hits the wall (i.e., the side of the room). A sound is produced, the movements end.\n\n [Image] \n\n Does not move because a rock is already standing in the path. The blocking rock becomes activated, but no sounds are produced.\n\n [Image] \n\n Does not move because the wall is in the way. No sounds are produced and the movements end.\n\n [Image] \n\nAssume there's an infinite number of rocks of each type in the neighboring room. You know what to do: place the rocks and open the door!\n\n-----Input-----\n\nThe first line will consists of two integers n and x, denoting the size of the room and the number of sounds required to open the door. There will be exactly three test cases for this problem:\n\n  n = 5, x = 5;  n = 3, x = 2;  n = 100, x = 10^5. \n\nAll of these testcases are in pretest.\n\n-----Output-----\n\nOutput n lines. Each line consists of n characters — the j-th character of the i-th line represents the content of the tile at the i-th row and the j-th column, and should be one of these:\n\n  '^', '<', '>', or 'v': a rock as described in the problem statement.  '.': an empty tile. \n\nThen, output two integers r and c (1 ≤ r, c ≤ n) on the next line — this means that the rock you activate first is located at the r-th row from above and c-th column from the left. There must be a rock in this cell.\n\nIf there are multiple solutions, you may output any of them.\n\n-----Examples-----\nInput\n5 5\n\nOutput\n>...v\nv.<..\n..^..\n>....\n..^.<\n1 1\n\nInput\n3 2\n\nOutput\n>vv\n^<.\n^.<\n1 3\n\n-----Note-----\n\nHere's a simulation of the first example, accompanied with the number of sounds produced so far.\n\n $8$ 0 sound \n\n [Image] 1 sound \n\n $8$ 2 sounds \n\n $8$ 3 sounds \n\n $8$ 4 sounds \n\n $8$ still 4 sounds \n\nIn the picture above, the activated rock switches between the '^' rock and the '<' rock. However, no sound is produced since the '^' rock didn't move even a single tile. So, still 4 sound.\n\n [Image] 5 sounds \n\nAt this point, 5 sound are already produced, so this solution is already correct. However, for the sake of example, we will continue simulating what happens.\n\n [Image] 6 sounds \n\n [Image] 7 sounds \n\n [Image] still 7 sounds \n\n [Image] 8 sounds \n\nAnd the movement stops. In total, it produces 8 sounds. Notice that the last move produced sound.\n\nHere's a simulation of the second example:\n\n [Image] 0 sound \n\n [Image] 1 sound \n\n [Image] 2 sounds \n\nNow, the activated stone will switch continuously from one to another without producing a sound until it reaches the 10^7 limit, after which the movement will cease.\n\n [Image] \n\nIn total, it produced exactly 2 sounds, so the solution is correct.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "def Grid := List (List Char)", "vc-helpers": "", "vc-definitions": "def solve_rock_puzzle (n m : Nat) : Grid × (Nat × Nat) :=\nsorry\n\ndef count_arrows (grid : Grid) : Nat :=\nsorry\n\ndef is_square_grid (grid : Grid) : Bool :=\nsorry\n\ndef valid_start_pos (pos : Nat × Nat) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_rock_puzzle_dimensions {n : Nat} (h : n > 0) :\n  let (grid, start_pos) := solve_rock_puzzle n n\n  List.length grid = n ∧\n  is_square_grid grid = true ∧\n  valid_start_pos start_pos n = true :=\nsorry\n\ntheorem valid_characters {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  ∀ (i : Nat), i < List.length grid →\n  ∀ (j : Nat), j < List.length (List.get! grid i) →\n  let c := List.get! (List.get! grid i) j\n  c = '^' ∨ c = 'v' ∨ c = '<' ∨ c = '>' ∨ c = '.' :=\nsorry\n\ntheorem has_arrows {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  count_arrows grid > 0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002209", "vc-description": "/-\nLet us define two functions f and g on positive integer numbers.  $f(n) = \\text{product of non-zero digits of} n$\n\n$g(n) = \\left\\{\\begin{array}{ll}{n} & {\\text{if} n < 10} \\\\{g(f(n))} & {\\text{otherwise}} \\end{array} \\right.$ \n\nYou need to process Q queries. In each query, you will be given three integers l, r and k. You need to print the number of integers x between l and r inclusive, such that g(x) = k. \n\n-----Input-----\n\nThe first line of the input contains an integer Q (1 ≤ Q ≤ 2 × 10^5) representing the number of queries. \n\nQ lines follow, each of which contains 3 integers l, r and k (1 ≤ l ≤ r ≤ 10^6, 1 ≤ k ≤ 9).\n\n-----Output-----\n\nFor each query, print a single line containing the answer for that query.\n\n-----Examples-----\nInput\n4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n\nOutput\n1\n4\n0\n8\n\nInput\n4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n\nOutput\n3\n1\n1\n5\n\n-----Note-----\n\nIn the first example:  g(33) = 9 as g(33) = g(3 × 3) = g(9) = 9  g(47) = g(48) = g(60) = g(61) = 6  There are no such integers between 47 and 55.  g(4) = g(14) = g(22) = g(27) = g(39) = g(40) = g(41) = g(58) = 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getSpecialValue : Nat → Nat :=\n  sorry\n\ndef countNumbersWithSpecialValue : List (Nat × Nat × Nat) → List Nat :=\n  sorry", "vc-theorems": "theorem special_value_counts_correct {l r k : Nat} (h1 : l > 0) (h2 : r > l) (h3 : k > 0) (h4 : k ≤ 9) :\n  let count := (countNumbersWithSpecialValue [(l,r,k)]).head!;\n  count = ((List.range (r-l+1)).filter (fun x => getSpecialValue (x + l) = k)).length := by\n  sorry\n\ntheorem result_list_length_matches_queries {queries : List (Nat × Nat × Nat)} (h : queries.length > 0) :\n  (countNumbersWithSpecialValue queries).length = queries.length := by\n  sorry\n\ntheorem results_are_nonnegative {queries : List (Nat × Nat × Nat)} (h : queries.length > 0) :\n  List.all (countNumbersWithSpecialValue queries) (fun x => x ≥ 0) := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 4, 0, 8]\n-/\n#guard_msgs in\n#eval count_numbers_with_special_value [(22, 73, 9), (45, 64, 6), (47, 55, 7), (2, 62, 4)]\n\n/--\ninfo: [3, 1, 1, 5]\n-/\n#guard_msgs in\n#eval count_numbers_with_special_value [(82, 94, 6), (56, 67, 4), (28, 59, 9), (39, 74, 4)]"}
{"id": "fvapps_002211", "vc-description": "/-\nKalila and Dimna are two jackals living in a huge jungle. One day they decided to join a logging factory in order to make money. \n\nThe manager of logging factory wants them to go to the jungle and cut n trees with heights a_1, a_2, ..., a_{n}. They bought a chain saw from a shop. Each time they use the chain saw on the tree number i, they can decrease the height of this tree by one unit. Each time that Kalila and Dimna use the chain saw, they need to recharge it. Cost of charging depends on the id of the trees which have been cut completely (a tree is cut completely if its height equal to 0). If the maximum id of a tree which has been cut completely is i (the tree that have height a_{i} in the beginning), then the cost of charging the chain saw would be b_{i}. If no tree is cut completely, Kalila and Dimna cannot charge the chain saw. The chainsaw is charged in the beginning. We know that for each i < j, a_{i} < a_{j} and b_{i} > b_{j} and also b_{n} = 0 and a_1 = 1. Kalila and Dimna want to cut all the trees completely, with minimum cost. \n\nThey want you to help them! Will you?\n\n-----Input-----\n\nThe first line of input contains an integer n (1 ≤ n ≤ 10^5). The second line of input contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The third line of input contains n integers b_1, b_2, ..., b_{n} (0 ≤ b_{i} ≤ 10^9).\n\nIt's guaranteed that a_1 = 1, b_{n} = 0, a_1 < a_2 < ... < a_{n} and b_1 > b_2 > ... > b_{n}.\n\n-----Output-----\n\nThe only line of output must contain the minimum cost of cutting all the trees completely.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n5 4 3 2 0\n\nOutput\n25\n\nInput\n6\n1 2 3 10 20 30\n6 5 4 3 2 0\n\nOutput\n138\n-/", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | h::t => h + sum_list t", "vc-helpers": "", "vc-definitions": "def min_cost_to_cut_trees (n : Nat) (heights : List Nat) (costs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≥ 0 :=\nsorry\n\ntheorem min_cost_upper_bound (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs ≤ sum_list (heights.map (· * costs.head!)) :=\nsorry\n\ntheorem min_cost_last_worker_bound (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length ≥ 2)\n  (h2 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 100)\n  (h3 : costs.length = heights.length)\n  (h4 : ∀ c ∈ costs, c ≤ 100)\n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees heights.length heights costs ≥ heights.getLast! * costs.getLast! :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 25\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 0]\n\n/--\ninfo: 138\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 6 [1, 2, 3, 10, 20, 30] [6, 5, 4, 3, 2, 0]"}
{"id": "fvapps_002213", "vc-description": "/-\nVasya has written some permutation $p_1, p_2, \\ldots, p_n$ of integers from $1$ to $n$, so for all $1 \\leq i \\leq n$ it is true that $1 \\leq p_i \\leq n$ and all $p_1, p_2, \\ldots, p_n$ are different. After that he wrote $n$ numbers $next_1, next_2, \\ldots, next_n$. The number $next_i$ is equal to the minimal index $i < j \\leq n$, such that $p_j > p_i$. If there is no such $j$ let's let's define as $next_i = n + 1$.\n\nIn the evening Vasya went home from school and due to rain, his notebook got wet. Now it is impossible to read some written numbers. Permutation and some values $next_i$ are completely lost! If for some $i$ the value $next_i$ is lost, let's say that $next_i = -1$.\n\nYou are given numbers $next_1, next_2, \\ldots, next_n$ (maybe some of them are equal to $-1$). Help Vasya to find such permutation $p_1, p_2, \\ldots, p_n$ of integers from $1$ to $n$, that he can write it to the notebook and all numbers $next_i$, which are not equal to $-1$, will be correct. \n\n-----Input-----\n\nThe first line contains one integer $t$ — the number of test cases ($1 \\leq t \\leq 100\\,000$).\n\nNext $2 \\cdot t$ lines contains the description of test cases,two lines for each. The first line contains one integer $n$ — the length of the permutation, written by Vasya ($1 \\leq n \\leq 500\\,000$). The second line contains $n$ integers $next_1, next_2, \\ldots, next_n$, separated by spaces ($next_i = -1$ or $i < next_i \\leq n + 1$).\n\nIt is guaranteed, that the sum of $n$ in all test cases doesn't exceed $500\\,000$.\n\nIn hacks you can only use one test case, so $T = 1$.\n\n-----Output-----\n\nPrint $T$ lines, in $i$-th of them answer to the $i$-th test case.\n\nIf there is no such permutations $p_1, p_2, \\ldots, p_n$ of integers from $1$ to $n$, that Vasya could write, print the only number $-1$.\n\nIn the other case print $n$ different integers $p_1, p_2, \\ldots, p_n$, separated by spaces ($1 \\leq p_i \\leq n$). All defined values of $next_i$ which are not equal to $-1$ should be computed correctly $p_1, p_2, \\ldots, p_n$ using defenition given in the statement of the problem. If there exists more than one solution you can find any of them.\n\n-----Example-----\nInput\n6\n3\n2 3 4\n2\n3 3\n3\n-1 -1 -1\n3\n3 4 -1\n1\n2\n4\n4 -1 4 5\n\nOutput\n1 2 3\n2 1\n2 1 3\n-1\n1\n3 2 1 4\n\n-----Note-----\n\nIn the first test case for permutation $p = [1, 2, 3]$ Vasya should write $next = [2, 3, 4]$, because each number in permutation is less than next. It's easy to see, that it is the only satisfying permutation.\n\nIn the third test case, any permutation can be the answer because all numbers $next_i$ are lost.\n\nIn the fourth test case, there is no satisfying permutation, so the answer is $-1$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidPermutation (arr : List Int) : Bool :=\n  sorry\n\ndef solveNextPermutation (n : Nat) (arr : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem single_element_case {n : Nat} (h : n > 0) (h2 : n ≤ 100) :\n  solveNextPermutation 1 [-1] = [1] := by\n  sorry\n\ntheorem all_minus_ones {n : Nat} (h : n > 0) (h2 : n ≤ 20) :\n  let result := solveNextPermutation n (List.replicate n (-1))\n  isValidPermutation result ∧\n  result = (List.range n).map (fun x => Int.ofNat (x + 1)) := by\n  sorry\n\ntheorem sequential_pointers {n : Nat} (h : n > 1) (h2 : n ≤ 20) :\n  let nextVals := (List.range n).map (fun x => Int.ofNat (x + 2))\n  let result := solveNextPermutation n nextVals\n  isValidPermutation result := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval solve_next_permutation 3 [2, 3, 4]\n\n/--\ninfo: [2, 1]\n-/\n#guard_msgs in\n#eval solve_next_permutation 2 [3, 3]\n\n/--\ninfo: [3, 1, 2, 4]\n-/\n#guard_msgs in\n#eval solve_next_permutation 4 [4, -1, 4, 5]"}
{"id": "fvapps_002239", "vc-description": "/-\nIt is Borya's eleventh birthday, and he has got a great present: n cards with numbers. The i-th card has the number a_{i} written on it. Borya wants to put his cards in a row to get one greater number. For example, if Borya has cards with numbers 1, 31, and 12, and he puts them in a row in this order, he would get a number 13112.\n\nHe is only 11, but he already knows that there are n! ways to put his cards in a row. But today is a special day, so he is only interested in such ways that the resulting big number is divisible by eleven. So, the way from the previous paragraph is good, because 13112 = 1192 × 11, but if he puts the cards in the following order: 31, 1, 12, he would get a number 31112, it is not divisible by 11, so this way is not good for Borya. Help Borya to find out how many good ways to put the cards are there.\n\nBorya considers all cards different, even if some of them contain the same number. For example, if Borya has two cards with 1 on it, there are two good ways.\n\nHelp Borya, find the number of good ways to put the cards. This number can be large, so output it modulo 998244353.\n\n-----Input-----\n\nInput data contains multiple test cases. The first line of the input data contains an integer t — the number of test cases (1 ≤ t ≤ 100). The descriptions of test cases follow.\n\nEach test is described by two lines.\n\nThe first line contains an integer n (1 ≤ n ≤ 2000) — the number of cards in Borya's present.\n\nThe second line contains n integers a_{i} (1 ≤ a_{i} ≤ 10^9) — numbers written on the cards.\n\nIt is guaranteed that the total number of cards in all tests of one input data doesn't exceed 2000.\n\n-----Output-----\n\nFor each test case output one line: the number of ways to put the cards to the table so that the resulting big number was divisible by 11, print the number modulo 998244353.\n\n-----Example-----\nInput\n4\n2\n1 1\n3\n1 31 12\n3\n12345 67 84\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n2\n2\n2\n31680\n-/", "vc-preamble": "def MOD := 998244353", "vc-helpers": "", "vc-definitions": "def solve_test (n : Nat) (numbers : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_test_within_mod_bounds\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n ≥ 1) (h3 : n ≤ 9)\n  (h4 : ∀ x ∈ numbers, 1 ≤ x ∧ x ≤ 10^9) :\n  0 ≤ solve_test n numbers ∧ solve_test n numbers < MOD :=\nsorry\n\ntheorem solve_test_order_independent\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n ≥ 1) (h3 : n ≤ 9)\n  (h4 : ∀ x ∈ numbers, 1 ≤ x ∧ x ≤ 10^9) :\n  solve_test n numbers = solve_test n numbers.reverse :=\nsorry\n\ntheorem solve_test_large_identical_numbers\n  (n : Nat) (v : Nat) (h1 : n ≥ 2) (h2 : n ≤ 9) (h3 : v = 10^9)\n  (numbers : List Nat) (h4 : numbers = List.replicate n v) :\n  0 ≤ solve_test n numbers ∧ solve_test n numbers < MOD :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 2 [1, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [1, 31, 12]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [12345, 67, 84]\n\n/--\ninfo: 31680\n-/\n#guard_msgs in\n#eval solve_test 9 [1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"id": "fvapps_002240", "vc-description": "/-\nThe USA Construction Operation (USACO) recently ordered Farmer John to arrange a row of $n$ haybale piles on the farm. The $i$-th pile contains $a_i$ haybales. \n\nHowever, Farmer John has just left for vacation, leaving Bessie all on her own. Every day, Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile. Formally, in one day she can choose any two indices $i$ and $j$ ($1 \\le i, j \\le n$) such that $|i-j|=1$ and $a_i>0$ and apply $a_i = a_i - 1$, $a_j = a_j + 1$. She may also decide to not do anything on some days because she is lazy.\n\nBessie wants to maximize the number of haybales in pile $1$ (i.e. to maximize $a_1$), and she only has $d$ days to do so before Farmer John returns. Help her find the maximum number of haybales that may be in pile $1$ if she acts optimally!\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100$)  — the number of test cases. Next $2t$ lines contain a description of test cases  — two lines per test case.\n\nThe first line of each test case contains integers $n$ and $d$ ($1 \\le n,d \\le 100$) — the number of haybale piles and the number of days, respectively. \n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 100$)  — the number of haybales in each pile.\n\n-----Output-----\n\nFor each test case, output one integer: the maximum number of haybales that may be in pile $1$ after $d$ days if Bessie acts optimally.\n\n-----Example-----\nInput\n3\n4 5\n1 0 3 2\n2 2\n100 1\n1 8\n0\n\nOutput\n3\n101\n0\n\n-----Note-----\n\nIn the first test case of the sample, this is one possible way Bessie can end up with $3$ haybales in pile $1$:   On day one, move a haybale from pile $3$ to pile $2$  On day two, move a haybale from pile $3$ to pile $2$  On day three, move a haybale from pile $2$ to pile $1$  On day four, move a haybale from pile $2$ to pile $1$  On day five, do nothing  \n\nIn the second test case of the sample, Bessie can do nothing on the first day and move a haybale from pile $2$ to pile $1$ on the second day.\n-/", "vc-preamble": "def list_sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t\n\ndef calculate_movable_sum (n d : Nat) (haybales : List Nat) : Nat :=\n  let rec aux : Nat → Nat → Nat\n    | 0, acc => acc\n    | i+1, acc =>\n      let moves := d / (i+1)\n      let val := match haybales.get? i with\n        | none => 0\n        | some x => min moves x\n      aux i (acc + val)\n  aux (n-1) 0", "vc-helpers": "", "vc-definitions": "def solve_haystack (n : Nat) (d : Nat) (haybales : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_haystack_within_first_pile_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≥ (haybales.get ⟨0, sorry⟩) := by\n  sorry\n\ntheorem solve_haystack_within_total_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≤ list_sum haybales := by\n  sorry\n\ntheorem solve_haystack_within_movable_limit {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales ≤\n    (haybales.get ⟨0, sorry⟩) + calculate_movable_sum n d haybales := by\n  sorry\n\ntheorem solve_haystack_single_pile {d : Nat} {hay : Nat} :\n  solve_haystack 1 d [hay] = hay := by\n  sorry\n\ntheorem solve_haystack_zero_days {n : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n 0 haybales = haybales.get ⟨0, sorry⟩ := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_haystack 4 5 [1, 0, 3, 2]\n\n/--\ninfo: 101\n-/\n#guard_msgs in\n#eval solve_haystack 2 2 [100, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haystack 1 8 [0]"}
{"id": "fvapps_002246", "vc-description": "/-\nVasya is an active Internet user. One day he came across an Internet resource he liked, so he wrote its address in the notebook. We know that the address of the written resource has format: <protocol>://<domain>.ru[/<context>] \n\nwhere:  <protocol> can equal either \"http\" (without the quotes) or \"ftp\" (without the quotes),  <domain> is a non-empty string, consisting of lowercase English letters,  the /<context> part may not be present. If it is present, then <context> is a non-empty string, consisting of lowercase English letters. \n\nIf string <context> isn't present in the address, then the additional character \"/\" isn't written. Thus, the address has either two characters \"/\" (the ones that go before the domain), or three (an extra one in front of the context).\n\nWhen the boy came home, he found out that the address he wrote in his notebook had no punctuation marks. Vasya must have been in a lot of hurry and didn't write characters \":\", \"/\", \".\".\n\nHelp Vasya to restore the possible address of the recorded Internet resource.\n\n-----Input-----\n\nThe first line contains a non-empty string that Vasya wrote out in his notebook. This line consists of lowercase English letters only. \n\nIt is guaranteed that the given string contains at most 50 letters. It is guaranteed that the given string can be obtained from some correct Internet resource address, described above.\n\n-----Output-----\n\nPrint a single line — the address of the Internet resource that Vasya liked. If there are several addresses that meet the problem limitations, you are allowed to print any of them.\n\n-----Examples-----\nInput\nhttpsunrux\n\nOutput\nhttp://sun.ru/x\n\nInput\nftphttprururu\n\nOutput\nftp://http.ru/ruru\n\n-----Note-----\n\nIn the second sample there are two more possible answers: \"ftp://httpruru.ru\" and \"ftp://httpru.ru/ru\".\n-/", "vc-preamble": "def ValidProtocol (s : String) : Prop := s = \"http\" ∨ s = \"ftp\"\n\ndef IsValidDomainChar (c : Char) : Prop := c.isUpper ∨ c.isLower ∨ c.isDigit\n\ndef IsValidPathChar (c : Char) : Prop := c.isUpper ∨ c.isLower ∨ c.isDigit\n\ndef countChar (s : String) (c : Char) : Nat :=\n  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0\n\npartial def containsSubstr (haystack needle : String) : Bool :=\n  if needle.length = 0 then true\n  else if haystack.length < needle.length then false\n  else if haystack.take needle.length = needle then true\n  else containsSubstr (haystack.drop 1) needle\n\npartial def countSubstr (haystack needle : String) : Nat :=\n  if needle.length = 0 then 0\n  else if haystack.length < needle.length then 0\n  else if haystack.take needle.length = needle\n    then 1 + countSubstr (haystack.drop needle.length) needle\n    else countSubstr (haystack.drop 1) needle", "vc-helpers": "", "vc-definitions": "def format_internet_address (s : String) : String := \n  sorry", "vc-theorems": "theorem format_internet_address_starts_with_protocol (s : String) :\n  (s.startsWith \"http\" ∨ s.startsWith \"ftp\") →\n  (format_internet_address s).startsWith \"http://\" ∨\n  (format_internet_address s).startsWith \"ftp://\" := \nsorry\n\ntheorem format_internet_address_preserves_protocol (s : String) :\n  s.startsWith \"http\" → (format_internet_address s).startsWith \"http://\" := \nsorry\n\ntheorem format_internet_address_preserves_ftp (s : String) :\n  s.startsWith \"ftp\" → (format_internet_address s).startsWith \"ftp://\" := \nsorry\n\ntheorem format_internet_address_contains_ru (s : String) :\n  containsSubstr (format_internet_address s) \".ru\" = true := \nsorry\n\ntheorem format_internet_address_single_ru (s : String) :\n  countSubstr (format_internet_address s) \".ru\" = 1 := \nsorry\n\ntheorem format_internet_address_path_slashes (s : String) :\n  containsSubstr s \"ru\" = true →\n  s.length > (s.length - (s.takeRight (s.length - 2)).length) + 2 →\n  countChar (format_internet_address s) '/' = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"}
{"id": "fvapps_002250", "vc-description": "/-\nWe have a sequence A of N non-negative integers.\nCompute the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} over all sequences B of N non-negative integers whose sum is at most M, and print it modulo (10^9 + 7).\nHere, \\dbinom{B_i}{A_i}, the binomial coefficient, denotes the number of ways to choose A_i objects from B_i objects, and is 0 when B_i < A_i.\n\n-----Constraints-----\n - All values in input are integers.\n - 1 \\leq N \\leq 2000\n - 1 \\leq M \\leq 10^9\n - 0 \\leq A_i \\leq 2000\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 A_2 \\ldots A_N\n\n-----Output-----\nPrint the sum of \\prod _{i = 1} ^N \\dbinom{B_i}{A_i}, modulo (10^9 + 7).\n\n-----Sample Input-----\n3 5\n1 2 1\n\n-----Sample Output-----\n8\n\nThere are four sequences B such that \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} is at least 1:\n - B = \\{1, 2, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{2}{2} \\times \\dbinom{1}{1} = 1;\n - B = \\{2, 2, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{2}{1} \\times \\dbinom{2}{2} \\times \\dbinom{1}{1} = 2;\n - B = \\{1, 3, 1\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{3}{2} \\times \\dbinom{1}{1} = 3;\n - B = \\{1, 2, 2\\}, where \\prod _{i = 1} ^N \\dbinom{B_i}{A_i} = \\dbinom{1}{1} \\times \\dbinom{2}{2} \\times \\dbinom{2}{1} = 2.\nThe sum of these is 1 + 2 + 3 + 2 = 8.\n-/", "vc-preamble": "abbrev M : Nat := 1000000007\n\ndef list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def solve_sequence_sum (n m : Nat) (sequence : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_sequence_sum_nonneg (n m : Nat) (sequence : List Nat) :\n  solve_sequence_sum n m sequence ≥ 0 :=\nsorry\n\ntheorem solve_sequence_sum_special_case :\n  solve_sequence_sum 1 1 [0] = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_sequence_sum 3 5 [1, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_sequence_sum 1 1 [0]"}
{"id": "fvapps_002252", "vc-description": "/-\nFox Ciel wants to write a task for a programming contest. The task is: \"You are given a simple undirected graph with n vertexes. Each its edge has unit length. You should calculate the number of shortest paths between vertex 1 and vertex 2.\"\n\nSame with some writers, she wants to make an example with some certain output: for example, her birthday or the number of her boyfriend. Can you help her to make a test case with answer equal exactly to k?\n\n-----Input-----\n\nThe first line contains a single integer k (1 ≤ k ≤ 10^9).\n\n-----Output-----\n\nYou should output a graph G with n vertexes (2 ≤ n ≤ 1000). There must be exactly k shortest paths between vertex 1 and vertex 2 of the graph.\n\nThe first line must contain an integer n. Then adjacency matrix G with n rows and n columns must follow. Each element of the matrix must be 'N' or 'Y'. If G_{ij} is 'Y', then graph G has a edge connecting vertex i and vertex j. Consider the graph vertexes are numbered from 1 to n.\n\nThe graph must be undirected and simple: G_{ii} = 'N' and G_{ij} = G_{ji} must hold. And there must be at least one path between vertex 1 and vertex 2. It's guaranteed that the answer exists. If there multiple correct answers, you can output any of them. \n\n-----Examples-----\nInput\n2\nOutput\n4\nNNYY\nNNYY\nYYNN\nYYNN\nInput\n9\nOutput\n8\nNNYYYNNN\nNNNNNYYY\nYNNNNYYY\nYNNNNYYY\nYNNNNYYY\nNYYYYNNN\nNYYYYNNN\nNYYYYNNN\nInput\n1\nOutput\n2\nNY\nYN\n\n-----Note-----\n\nIn first example, there are 2 shortest paths: 1-3-2 and 1-4-2.\n\nIn second example, there are 9 shortest paths: 1-3-6-2, 1-3-7-2, 1-3-8-2, 1-4-6-2, 1-4-7-2, 1-4-8-2, 1-5-6-2, 1-5-7-2, 1-5-8-2.\n-/\n\n-- Apps difficulty: competition\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Matrix := List (List Char)\n\ndef is_valid_adjacency_matrix (m: Matrix) : Bool :=\nsorry\n\ndef is_symmetric (m: Matrix) : Bool :=\nsorry\n\ndef generate_graph (k: Nat) : Nat × Matrix :=\nsorry", "vc-theorems": "theorem generated_graph_is_valid (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_valid_adjacency_matrix matrix = true :=\nsorry\n\ntheorem generated_graph_is_symmetric (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_symmetric matrix = true :=\nsorry\n\ntheorem size_properties (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  n ≤ 4 * k ∧\n  matrix.length = n ∧\n  List.all matrix (fun row => row.length = n) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002253", "vc-description": "/-\n$n$ robots have escaped from your laboratory! You have to find them as soon as possible, because these robots are experimental, and their behavior is not tested yet, so they may be really dangerous!\n\nFortunately, even though your robots have escaped, you still have some control over them. First of all, you know the location of each robot: the world you live in can be modeled as an infinite coordinate plane, and the $i$-th robot is currently located at the point having coordinates ($x_i$, $y_i$). Furthermore, you may send exactly one command to all of the robots. The command should contain two integer numbers $X$ and $Y$, and when each robot receives this command, it starts moving towards the point having coordinates ($X$, $Y$). The robot stops its movement in two cases:  either it reaches ($X$, $Y$);  or it cannot get any closer to ($X$, $Y$). \n\nNormally, all robots should be able to get from any point of the coordinate plane to any other point. Each robot usually can perform four actions to move. Let's denote the current coordinates of the robot as ($x_c$, $y_c$). Then the movement system allows it to move to any of the four adjacent points:  the first action allows it to move from ($x_c$, $y_c$) to ($x_c - 1$, $y_c$);  the second action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c + 1$);  the third action allows it to move from ($x_c$, $y_c$) to ($x_c + 1$, $y_c$);  the fourth action allows it to move from ($x_c$, $y_c$) to ($x_c$, $y_c - 1$). \n\nUnfortunately, it seems that some movement systems of some robots are malfunctioning. For each robot you know which actions it can perform, and which it cannot perform.\n\nYou want to send a command so all robots gather at the same point. To do so, you have to choose a pair of integer numbers $X$ and $Y$ so that each robot can reach the point ($X$, $Y$). Is it possible to find such a point?\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 10^5$) — the number of queries.\n\nThen $q$ queries follow. Each query begins with one line containing one integer $n$ ($1 \\le n \\le 10^5$) — the number of robots in the query. Then $n$ lines follow, the $i$-th of these lines describes the $i$-th robot in the current query: it contains six integer numbers $x_i$, $y_i$, $f_{i, 1}$, $f_{i, 2}$, $f_{i, 3}$ and $f_{i, 4}$ ($-10^5 \\le x_i, y_i \\le 10^5$, $0 \\le f_{i, j} \\le 1$). The first two numbers describe the initial location of the $i$-th robot, and the following four numbers describe which actions the $i$-th robot can use to move ($f_{i, j} = 1$ if the $i$-th robot can use the $j$-th action, and $f_{i, j} = 0$ if it cannot use the $j$-th action).\n\nIt is guaranteed that the total number of robots over all queries does not exceed $10^5$.\n\n-----Output-----\n\nYou should answer each query independently, in the order these queries appear in the input.\n\nTo answer a query, you should do one of the following:  if it is impossible to find a point that is reachable by all $n$ robots, print one number $0$ on a separate line;  if it is possible to find a point that is reachable by all $n$ robots, print three space-separated integers on the same line: $1$ $X$ $Y$, where $X$ and $Y$ are the coordinates of the point reachable by all $n$ robots. Both $X$ and $Y$ should not exceed $10^5$ by absolute value; it is guaranteed that if there exists at least one point reachable by all robots, then at least one of such points has both coordinates not exceeding $10^5$ by absolute value.\n\n-----Example-----\nInput\n4\n2\n-1 -2 0 0 0 0\n-1 -2 0 0 0 0\n3\n1 5 1 1 1 1\n2 5 0 1 0 1\n3 5 1 0 0 0\n2\n1337 1337 0 1 1 1\n1336 1337 1 1 0 1\n1\n3 5 1 1 1 1\n\nOutput\n1 -1 -2\n1 2 5\n0\n1 -100000 -100000\n-/", "vc-preamble": "def in_bounds (x y : Int) : Bool :=\n-100000 ≤ x ∧ x ≤ 100000 ∧ -100000 ≤ y ∧ y ≤ 100000", "vc-helpers": "", "vc-definitions": "def Position := Int × Int × Bool × Bool × Bool × Bool\n\ndef find_robot_gather_point (robots : List Position) : List Int :=\nsorry", "vc-theorems": "theorem gather_point_valid (robots : List Position) :\n  let result := find_robot_gather_point robots\n  (result.length = 1 ∧ result = [0]) ∨\n  (result.length = 3 ∧\n   result.get! 0 = 1 ∧\n   let x := result.get! 1\n   let y := result.get! 2\n   in_bounds x y ∧\n   ∀ (robot : Position),\n   robot ∈ robots →\n   let (rx, ry, can_left, can_up, can_right, can_down) := robot\n   (¬can_left → x ≥ rx) ∧\n   (¬can_right → x ≤ rx) ∧\n   (¬can_up → y ≤ ry) ∧\n   (¬can_down → y ≥ ry)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, -1, -2]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[-1, -2, 0, 0, 0, 0], [-1, -2, 0, 0, 0, 0]]\n\n/--\ninfo: [1, 2, 5]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1, 5, 1, 1, 1, 1], [2, 5, 0, 1, 0, 1], [3, 5, 1, 0, 0, 0]]\n\n/--\ninfo: [0]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1337, 1337, 0, 1, 1, 1], [1336, 1337, 1, 1, 0, 1]]"}
{"id": "fvapps_002259", "vc-description": "/-\nYou have $n$ gifts and you want to give all of them to children. Of course, you don't want to offend anyone, so all gifts should be equal between each other. The $i$-th gift consists of $a_i$ candies and $b_i$ oranges.\n\nDuring one move, you can choose some gift $1 \\le i \\le n$ and do one of the following operations:\n\n  eat exactly one candy from this gift (decrease $a_i$ by one);  eat exactly one orange from this gift (decrease $b_i$ by one);  eat exactly one candy and exactly one orange from this gift (decrease both $a_i$ and $b_i$ by one). \n\nOf course, you can not eat a candy or orange if it's not present in the gift (so neither $a_i$ nor $b_i$ can become less than zero).\n\nAs said above, all gifts should be equal. This means that after some sequence of moves the following two conditions should be satisfied: $a_1 = a_2 = \\dots = a_n$ and $b_1 = b_2 = \\dots = b_n$ (and $a_i$ equals $b_i$ is not necessary).\n\nYour task is to find the minimum number of moves required to equalize all the given gifts.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 50$) — the number of gifts. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the number of candies in the $i$-th gift. The third line of the test case contains $n$ integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 10^9$), where $b_i$ is the number of oranges in the $i$-th gift.\n\n-----Output-----\n\nFor each test case, print one integer: the minimum number of moves required to equalize all the given gifts.\n\n-----Example-----\nInput\n5\n3\n3 5 6\n3 2 3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n1 1 1\n2 2 2\n6\n1 1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1 1\n3\n10 12 8\n7 5 4\n\nOutput\n6\n16\n0\n4999999995\n7\n\n-----Note-----\n\nIn the first test case of the example, we can perform the following sequence of moves:\n\n  choose the first gift and eat one orange from it, so $a = [3, 5, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 4, 6]$ and $b = [2, 2, 3]$;  choose the second gift and eat one candy from it, so $a = [3, 3, 6]$ and $b = [2, 2, 3]$;  choose the third gift and eat one candy and one orange from it, so $a = [3, 3, 5]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 4]$ and $b = [2, 2, 2]$;  choose the third gift and eat one candy from it, so $a = [3, 3, 3]$ and $b = [2, 2, 2]$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_to_equalize (n : Nat) (candies : List Nat) (oranges : List Nat) : Nat :=\n  sorry\n\ndef list_max (l : List Nat) : Nat :=\n  sorry\n\ndef list_min (l : List Nat) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≥ 0 :=\nsorry\n\ntheorem min_moves_lower_bound (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≥\n    max\n      (list_max candies - list_min candies)\n      (list_max oranges - list_min oranges) :=\nsorry\n\ntheorem min_moves_upper_bound (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges ≤\n    (list_sum (candies.map (λ x => x - list_min candies))) +\n    (list_sum (oranges.map (λ x => x - list_min oranges))) :=\nsorry\n\ntheorem identical_lists_zero_moves (n : Nat) (v : Nat) :\n  min_moves_to_equalize n (List.replicate n v) (List.replicate n v) = 0 :=\nsorry\n\ntheorem min_moves_symmetric (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges = min_moves_to_equalize n oranges candies :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [3, 5, 6] [3, 2, 3]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 1]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [10, 12, 8] [7, 5, 4]"}
{"id": "fvapps_002262", "vc-description": "/-\nYou are given an array $a$ consisting of $n$ integers. You have to find the length of the smallest (shortest) prefix of elements you need to erase from $a$ to make it a good array. Recall that the prefix of the array $a=[a_1, a_2, \\dots, a_n]$ is a subarray consisting several first elements: the prefix of the array $a$ of length $k$ is the array $[a_1, a_2, \\dots, a_k]$ ($0 \\le k \\le n$).\n\nThe array $b$ of length $m$ is called good, if you can obtain a non-decreasing array $c$ ($c_1 \\le c_2 \\le \\dots \\le c_{m}$) from it, repeating the following operation $m$ times (initially, $c$ is empty):  select either the first or the last element of $b$, remove it from $b$, and append it to the end of the array $c$. \n\nFor example, if we do $4$ operations: take $b_1$, then $b_{m}$, then $b_{m-1}$ and at last $b_2$, then $b$ becomes $[b_3, b_4, \\dots, b_{m-3}]$ and $c =[b_1, b_{m}, b_{m-1}, b_2]$.\n\nConsider the following example: $b = [1, 2, 3, 4, 4, 2, 1]$. This array is good because we can obtain non-decreasing array $c$ from it by the following sequence of operations:  take the first element of $b$, so $b = [2, 3, 4, 4, 2, 1]$, $c = [1]$;  take the last element of $b$, so $b = [2, 3, 4, 4, 2]$, $c = [1, 1]$;  take the last element of $b$, so $b = [2, 3, 4, 4]$, $c = [1, 1, 2]$;  take the first element of $b$, so $b = [3, 4, 4]$, $c = [1, 1, 2, 2]$;  take the first element of $b$, so $b = [4, 4]$, $c = [1, 1, 2, 2, 3]$;  take the last element of $b$, so $b = [4]$, $c = [1, 1, 2, 2, 3, 4]$;  take the only element of $b$, so $b = []$, $c = [1, 1, 2, 2, 3, 4, 4]$ — $c$ is non-decreasing. \n\nNote that the array consisting of one element is good.\n\nPrint the length of the shortest prefix of $a$ to delete (erase), to make $a$ to be a good array. Note that the required length can be $0$.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of $a$. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 2 \\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\n\nIt is guaranteed that the sum of $n$ does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n-----Output-----\n\nFor each test case, print the answer: the length of the shortest prefix of elements you need to erase from $a$ to make it a good array.\n\n-----Example-----\nInput\n5\n4\n1 2 3 4\n7\n4 3 3 8 4 5 2\n3\n1 1 1\n7\n1 3 1 4 5 3 2\n5\n5 4 3 2 3\n\nOutput\n0\n4\n0\n2\n3\n\n-----Note-----\n\nIn the first test case of the example, the array $a$ is already good, so we don't need to erase any prefix.\n\nIn the second test case of the example, the initial array $a$ is not good. Let's erase first $4$ elements of $a$, the result is $[4, 5, 2]$. The resulting array is good. You can prove that if you erase fewer number of first elements, the result will not be good.\n-/\n\n/- Theorem stating that result is always a valid index or 0 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Theorem stating that sorted ascending arrays return 0 -/\n\n/- Theorem stating that single element arrays return 0 -/\n\n/- Theorem stating that constant arrays return 0 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findShortestPrefix (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem find_shortest_prefix_bounds {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0) :\n  let result := findShortestPrefix n arr\n  0 ≤ result ∧ result < n :=\nsorry\n\ntheorem find_shortest_prefix_sorted_asc {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : ∀ i j, i < j → j < arr.length → arr[i]! ≤ arr[j]!) :\n  findShortestPrefix n arr = 0 :=\nsorry\n\ntheorem find_shortest_prefix_single {arr : List Int}\n  (h : arr.length = 1) :\n  findShortestPrefix 1 arr = 0 :=\nsorry\n\ntheorem find_shortest_prefix_constant {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : ∀ i j, i < arr.length → j < arr.length → arr[i]! = arr[j]!) :\n  findShortestPrefix n arr = 0 :=\nsorry", "vc-postamble": "/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 4 [1, 2, 3, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_shortest_prefix 7 [4, 3, 3, 8, 4, 5, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 3 [1, 1, 1]"}
{"id": "fvapps_002263", "vc-description": "/-\nInitially, you have the array $a$ consisting of one element $1$ ($a = [1]$).\n\nIn one move, you can do one of the following things:\n\n  Increase some (single) element of $a$ by $1$ (choose some $i$ from $1$ to the current length of $a$ and increase $a_i$ by one);  Append the copy of some (single) element of $a$ to the end of the array (choose some $i$ from $1$ to the current length of $a$ and append $a_i$ to the end of the array). \n\nFor example, consider the sequence of five moves:\n\n  You take the first element $a_1$, append its copy to the end of the array and get $a = [1, 1]$.  You take the first element $a_1$, increase it by $1$ and get $a = [2, 1]$.  You take the second element $a_2$, append its copy to the end of the array and get $a = [2, 1, 1]$.  You take the first element $a_1$, append its copy to the end of the array and get $a = [2, 1, 1, 2]$.  You take the fourth element $a_4$, increase it by $1$ and get $a = [2, 1, 1, 3]$. \n\nYour task is to find the minimum number of moves required to obtain the array with the sum at least $n$.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Then $t$ test cases follow.\n\nThe only line of the test case contains one integer $n$ ($1 \\le n \\le 10^9$) — the lower bound on the sum of the array.\n\n-----Output-----\n\nFor each test case, print the answer: the minimum number of moves required to obtain the array with the sum at least $n$.\n\n-----Example-----\nInput\n5\n1\n5\n42\n1337\n1000000000\n\nOutput\n0\n3\n11\n72\n63244\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves_required (n : Nat) : Nat :=\n  sorry\n\ndef nat_sqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_moves_non_negative (n : Nat) (h : n > 0) :\n  min_moves_required n ≥ 0 :=\nsorry\n\ntheorem min_moves_less_than_input (n : Nat) (h : n > 0) :\n  min_moves_required n ≤ n :=\nsorry\n\ntheorem min_moves_monotonic (n : Nat) (h : n > 1) :\n  min_moves_required n ≥ min_moves_required (n-1) :=\nsorry\n\ntheorem min_moves_base_case :\n  min_moves_required 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_required 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves_required 5\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval min_moves_required 42"}
{"id": "fvapps_002266", "vc-description": "/-\nYou are given a tree (connected graph without cycles) consisting of $n$ vertices. The tree is unrooted — it is just a connected undirected graph without cycles.\n\nIn one move, you can choose exactly $k$ leaves (leaf is such a vertex that is connected to only one another vertex) connected to the same vertex and remove them with edges incident to them. I.e. you choose such leaves $u_1, u_2, \\dots, u_k$ that there are edges $(u_1, v)$, $(u_2, v)$, $\\dots$, $(u_k, v)$ and remove these leaves and these edges.\n\nYour task is to find the maximum number of moves you can perform if you remove leaves optimally.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $k$ ($2 \\le n \\le 2 \\cdot 10^5$; $1 \\le k < n$) — the number of vertices in the tree and the number of leaves you remove in one move, respectively. The next $n-1$ lines describe edges. The $i$-th edge is represented as two integers $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$), where $x_i$ and $y_i$ are vertices the $i$-th edge connects. It is guaranteed that the given set of edges forms a tree.\n\nIt is guaranteed that the sum of $n$ does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n-----Output-----\n\nFor each test case, print the answer — the maximum number of moves you can perform if you remove leaves optimally.\n\n-----Example-----\nInput\n4\n8 3\n1 2\n1 5\n7 6\n6 8\n3 1\n6 4\n6 1\n10 3\n1 2\n1 10\n2 3\n1 5\n1 6\n2 4\n7 10\n10 9\n8 10\n7 2\n3 1\n4 5\n3 6\n7 4\n1 2\n1 4\n5 1\n1 2\n2 3\n4 3\n5 3\n\nOutput\n2\n3\n3\n4\n\n-----Note-----\n\nThe picture corresponding to the first test case of the example:\n\n[Image]\n\nThere you can remove vertices $2$, $5$ and $3$ during the first move and vertices $1$, $7$ and $4$ during the second move.\n\nThe picture corresponding to the second test case of the example:\n\n[Image]\n\nThere you can remove vertices $7$, $8$ and $9$ during the first move, then vertices $5$, $6$ and $10$ during the second move and vertices $1$, $3$ and $4$ during the third move.\n\nThe picture corresponding to the third test case of the example:\n\n$\\text{of}$\n\nThere you can remove vertices $5$ and $7$ during the first move, then vertices $2$ and $4$ during the second move and vertices $1$ and $6$ during the third move.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_leaf_removal (n k : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem leaf_removal_basic_properties {n k : Nat} {edges : List (Nat × Nat)}\n    (h1 : n ≥ 2)\n    (h2 : k ≥ 1)\n    (h3 : k ≤ 5)\n    (h4 : is_valid_tree n edges = true) :\n    let result := solve_leaf_removal n k edges\n    result ≥ 0 ∧ result ≤ (n + k - 1) / k :=\nsorry\n\ntheorem leaf_removal_single_node {k : Nat}\n    (h : k ≥ 1) :\n    solve_leaf_removal 1 k [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_leaf_removal 8 3 [(1, 2), (1, 5), (7, 6), (6, 8), (3, 1), (6, 4), (6, 1)]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_leaf_removal 10 3 [(1, 2), (1, 10), (2, 3), (1, 5), (1, 6), (2, 4), (7, 10), (10, 9), (8, 10)]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_leaf_removal 5 1 [(1, 2), (2, 3), (4, 3), (5, 3)]"}
{"id": "fvapps_002267", "vc-description": "/-\nThis is an easy version of the problem. In this version, all numbers in the given array are distinct and the constraints on $n$ are less than in the hard version of the problem.\n\nYou are given an array $a$ of $n$ integers (there are no equals elements in the array). You can perform the following operations on array elements:  choose any index $i$ ($1 \\le i \\le n$) and move the element $a[i]$ to the begin of the array;  choose any index $i$ ($1 \\le i \\le n$) and move the element $a[i]$ to the end of the array. \n\nFor example, if $n = 5$, $a = [4, 7, 2, 3, 9]$, then the following sequence of operations can be performed:   after performing the operation of the first type to the second element, the array $a$ will become $[7, 4, 2, 3, 9]$;  after performing the operation of the second type to the second element, the array $a$ will become $[7, 2, 3, 9, 4]$. \n\nYou can perform operations of any type any number of times in any order.\n\nFind the minimum total number of operations of the first and second type that will make the $a$ array sorted in non-decreasing order. In other words, what is the minimum number of operations that must be performed so the array satisfies the inequalities $a[1] \\le a[2] \\le \\ldots \\le a[n]$.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) — the number of test cases in the test. Then $t$ test cases follow.\n\nEach test case starts with a line containing an integer $n$ ($1 \\le n \\le 3000$) — length of the array $a$.\n\nThen follow $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) — an array that needs to be sorted by the given operations. All numbers in the given array are distinct.\n\nThe sum of $n$ for all test cases in one test does not exceed $3000$.\n\n-----Output-----\n\nFor each test case output one integer — the minimum total number of operations of the first and second type, which will make the array sorted in non-decreasing order.\n\n-----Example-----\nInput\n4\n5\n4 7 2 3 9\n5\n3 5 8 1 7\n5\n1 4 5 7 12\n4\n0 2 1 3\n\nOutput\n2\n2\n0\n2\n\n-----Note-----\n\nIn the first test case, you first need to move 3, and then 2 to the beginning of the array. Therefore, the desired sequence of operations: $[4, 7, 2, 3, 9] \\rightarrow [3, 4, 7, 2, 9] \\rightarrow [2, 3, 4, 7, 9]$.\n\nIn the second test case, you need to move the 1 to the beginning of the array, and the 8 — to the end. Therefore, the desired sequence of operations: $[3, 5, 8, 1, 7] \\rightarrow [1, 3, 5, 8, 7] \\rightarrow [1, 3, 5, 7, 8]$.\n\nIn the third test case, the array is already sorted.\n-/", "vc-preamble": "def isSorted (arr : List Int) : Prop :=\n  ∀ i j, i < j → j < arr.length → arr[i]! ≤ arr[j]!\n\ndef isStrictlySorted (arr : List Int) : Prop :=\n  ∀ i j, i < j → j < arr.length → arr[i]! < arr[j]!", "vc-helpers": "", "vc-definitions": "def minimum_operations (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds (arr : List Int) (h : arr ≠ []) :\n  0 ≤ minimum_operations arr ∧ minimum_operations arr ≤ arr.length :=\nsorry\n\ntheorem sorted_unique_needs_zero {arr : List Int} (h1 : arr ≠ [])\n  (h2 : isStrictlySorted arr) :\n  minimum_operations arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [4, 7, 2, 3, 9]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [3, 5, 8, 1, 7]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum_operations [1, 4, 5, 7, 12]"}
{"id": "fvapps_002269", "vc-description": "/-\nYou are given a garland consisting of $n$ lamps. States of the lamps are represented by the string $s$ of length $n$. The $i$-th character of the string $s_i$ equals '0' if the $i$-th lamp is turned off or '1' if the $i$-th lamp is turned on. You are also given a positive integer $k$.\n\nIn one move, you can choose one lamp and change its state (i.e. turn it on if it is turned off and vice versa).\n\nThe garland is called $k$-periodic if the distance between each pair of adjacent turned on lamps is exactly $k$. Consider the case $k=3$. Then garlands \"00010010\", \"1001001\", \"00010\" and \"0\" are good but garlands \"00101001\", \"1000001\" and \"01001100\" are not. Note that the garland is not cyclic, i.e. the first turned on lamp is not going after the last turned on lamp and vice versa.\n\nYour task is to find the minimum number of moves you need to make to obtain $k$-periodic garland from the given one.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 25~ 000$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $k$ ($1 \\le n \\le 10^6; 1 \\le k \\le n$) — the length of $s$ and the required period. The second line of the test case contains the string $s$ consisting of $n$ characters '0' and '1'.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^6$ ($\\sum n \\le 10^6$).\n\n-----Output-----\n\nFor each test case, print the answer — the minimum number of moves you need to make to obtain $k$-periodic garland from the given one.\n\n-----Example-----\nInput\n6\n9 2\n010001010\n9 3\n111100000\n7 4\n1111111\n10 3\n1001110101\n1 1\n1\n1 1\n0\n\nOutput\n1\n2\n5\n4\n0\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_garland (n k : Nat) (s : String) : Nat :=\nsorry\n\ndef is_valid_garland (n k : Nat) (s : String) : Bool :=\nsorry\n\ndef count_zeros (s : String) : Nat :=\nsorry\n\ndef all_ones (s : String) : Bool :=\nsorry\n\ndef all_zeros (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_garland_nonnegative (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  solve_garland n k s ≥ 0 :=\nsorry\n\ntheorem solve_garland_bounded_by_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  solve_garland n k s ≤ count_zeros s :=\nsorry\n\ntheorem solve_garland_all_ones (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  all_ones s →\n  solve_garland n k s = 0 :=\nsorry\n\ntheorem solve_garland_all_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s →\n  all_zeros s →\n  solve_garland n k s ≤ (n + k - 1) / k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_garland 9 2 \"010001010\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_garland 9 3 \"111100000\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_garland 1 1 \"0\""}
{"id": "fvapps_002270", "vc-description": "/-\nThere is a frog staying to the left of the string $s = s_1 s_2 \\ldots s_n$ consisting of $n$ characters (to be more precise, the frog initially stays at the cell $0$). Each character of $s$ is either 'L' or 'R'. It means that if the frog is staying at the $i$-th cell and the $i$-th character is 'L', the frog can jump only to the left. If the frog is staying at the $i$-th cell and the $i$-th character is 'R', the frog can jump only to the right. The frog can jump only to the right from the cell $0$.\n\nNote that the frog can jump into the same cell twice and can perform as many jumps as it needs.\n\nThe frog wants to reach the $n+1$-th cell. The frog chooses some positive integer value $d$ before the first jump (and cannot change it later) and jumps by no more than $d$ cells at once. I.e. if the $i$-th character is 'L' then the frog can jump to any cell in a range $[max(0, i - d); i - 1]$, and if the $i$-th character is 'R' then the frog can jump to any cell in a range $[i + 1; min(n + 1; i + d)]$.\n\nThe frog doesn't want to jump far, so your task is to find the minimum possible value of $d$ such that the frog can reach the cell $n+1$ from the cell $0$ if it can jump by no more than $d$ cells at once. It is guaranteed that it is always possible to reach $n+1$ from $0$.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.\n\nThe next $t$ lines describe test cases. The $i$-th test case is described as a string $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ characters 'L' and 'R'.\n\nIt is guaranteed that the sum of lengths of strings over all test cases does not exceed $2 \\cdot 10^5$ ($\\sum |s| \\le 2 \\cdot 10^5$).\n\n-----Output-----\n\nFor each test case, print the answer — the minimum possible value of $d$ such that the frog can reach the cell $n+1$ from the cell $0$ if it jumps by no more than $d$ at once.\n\n-----Example-----\nInput\n6\nLRLRRLL\nL\nLLR\nRRRR\nLLLLLL\nR\n\nOutput\n3\n2\n3\n1\n7\n1\n\n-----Note-----\n\nThe picture describing the first test case of the example and one of the possible answers:\n\n[Image]\n\nIn the second test case of the example, the frog can only jump directly from $0$ to $n+1$.\n\nIn the third test case of the example, the frog can choose $d=3$, jump to the cell $3$ from the cell $0$ and then to the cell $4$ from the cell $3$.\n\nIn the fourth test case of the example, the frog can choose $d=1$ and jump $5$ times to the right.\n\nIn the fifth test case of the example, the frog can only jump directly from $0$ to $n+1$.\n\nIn the sixth test case of the example, the frog can choose $d=1$ and jump $2$ times to the right.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_frog_jumps (s : String) : Nat :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem frog_jumps_positive_bound (s : String) :\n  solve_frog_jumps s ≥ 1 :=\nsorry\n\ntheorem frog_jumps_upper_bound (s : String) :\n  solve_frog_jumps s ≤ s.length + 2 :=\nsorry\n\ntheorem frog_jumps_consecutive_r (s : String) :\n  solve_frog_jumps s = solve_frog_jumps (s.replace \"R\" \"RR\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LRLRRLL\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"L\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LLR\""}
{"id": "fvapps_002271", "vc-description": "/-\nYou are given $n$ strings $a_1, a_2, \\ldots, a_n$: all of them have the same length $m$. The strings consist of lowercase English letters.\n\nFind any string $s$ of length $m$ such that each of the given $n$ strings differs from $s$ in at most one position. Formally, for each given string $a_i$, there is no more than one position $j$ such that $a_i[j] \\ne s[j]$.\n\nNote that the desired string $s$ may be equal to one of the given strings $a_i$, or it may differ from all the given strings.\n\nFor example, if you have the strings abac and zbab, then the answer to the problem might be the string abab, which differs from the first only by the last character, and from the second only by the first.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 100$) — the number of test cases. Then $t$ test cases follow.\n\nEach test case starts with a line containing two positive integers $n$ ($1 \\le n \\le 10$) and $m$ ($1 \\le m \\le 10$) — the number of strings and their length.\n\nThen follow $n$ strings $a_i$, one per line. Each of them has length $m$ and consists of lowercase English letters.\n\n-----Output-----\n\nPrint $t$ answers to the test cases. Each answer (if it exists) is a string of length $m$ consisting of lowercase English letters. If there are several answers, print any of them. If the answer does not exist, print \"-1\" (\"minus one\", without quotes).\n\n-----Example-----\nInput\n5\n2 4\nabac\nzbab\n2 4\naaaa\nbbbb\n3 3\nbaa\naaa\naab\n2 2\nab\nbb\n3 1\na\nb\nc\n\nOutput\nabab\n-1\naaa\nab\nz\n\n-----Note-----\n\nThe first test case was explained in the statement.\n\nIn the second test case, the answer does not exist.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingDistance (s1 s2 : String) : Nat :=\n  sorry\n\ndef verifyResult (result : String) (strings : List String) : Bool :=\n  sorry\n\ndef findSimilarString (strings : List String) (n m : Nat) : String :=\n  sorry\n\ndef isLower (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem find_similar_string_properties {strings : List String} {n m : Nat}\n  (h1 : n = strings.length)\n  (h2 : m > 0)\n  (h3 : ∀ s ∈ strings, s.length = m)\n  (result := findSimilarString strings n m) :\n    (result = \"-1\" ∨ result.length = m) ∧\n    (result = \"-1\" ∨ ∀ c ∈ result.data, isLower c) ∧\n    verifyResult result strings\n  :=\nsorry\n\ntheorem binary_strings_property {strings : List String} {n m : Nat}\n  (h1 : strings.length = 2)\n  (h2 : strings.head!.length = strings.tail!.head!.length)\n  (h3 : ∀ s ∈ strings, ∀ c ∈ s.data, c = 'a' ∨ c = 'b')\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :=\nsorry\n\ntheorem small_inputs_property {strings : List String} {n m : Nat}\n  (h1 : strings.length ≤ 3)\n  (h2 : strings.length > 0)\n  (h3 : ∀ s ∈ strings, s.length = strings.head!.length)\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '-1'\n-/\n#guard_msgs in\n#eval find_similar_string [\"aaaa\", \"bbbb\"] 2 4\n\n/--\ninfo: 'aaa'\n-/\n#guard_msgs in\n#eval find_similar_string [\"baa\", \"aaa\", \"aab\"] 3 3"}
{"id": "fvapps_002273", "vc-description": "/-\nThis is a hard version of the problem. In this version, the given array can contain equal elements and the constraints on $n$ are greater than in the easy version of the problem.\n\nYou are given an array $a$ of $n$ integers (the given array can contain equal elements). You can perform the following operations on array elements:  choose any index $i$ ($1 \\le i \\le n$) and move the element $a[i]$ to the begin of the array;  choose any index $i$ ($1 \\le i \\le n$) and move the element $a[i]$ to the end of the array. \n\nFor example, if $n = 5$, $a = [4, 7, 2, 2, 9]$, then the following sequence of operations can be performed:   after performing the operation of the first type to the second element, the array $a$ will become $[7, 4, 2, 2, 9]$;  after performing the operation of the second type to the second element, the array $a$ will become $[7, 2, 2, 9, 4]$. \n\nYou can perform operations of any type any number of times in any order.\n\nFind the minimum total number of operations of the first and second type that will make the $a$ array sorted in non-decreasing order. In other words, what is the minimum number of operations must be performed so the array satisfies the inequalities $a[1] \\le a[2] \\le \\ldots \\le a[n]$.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the test. Then $t$ test cases follow.\n\nEach test case starts with a line containing an integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the size of the array $a$.\n\nThen follow $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) — an array that needs to be sorted by the given operations. The given array can contain equal elements.\n\nThe sum of $n$ for all test cases in one test does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case output one integer — the minimum total number of operations of the first and second type, which will make the array sorted in non-decreasing order.\n\n-----Example-----\nInput\n9\n5\n4 7 2 2 9\n5\n3 5 8 1 7\n5\n1 2 2 4 5\n2\n0 1\n3\n0 1 0\n4\n0 1 0 0\n4\n0 1 0 1\n4\n0 1 0 2\n20\n16 15 1 10 0 14 0 10 3 9 2 5 4 5 17 9 10 20 0 9\n\nOutput\n2\n2\n0\n0\n1\n1\n1\n1\n16\n\n-----Note-----\n\nIn the first test case, you first need to move two 2, to the beginning of the array. Therefore, the desired sequence of operations: $[4, 7, 2, 2, 9] \\rightarrow [2, 4, 7, 2, 9] \\rightarrow [2, 2, 4, 7, 9]$.\n\nIn the second test case, you need to move the 1 to the beginning of the array, and the 8 — to the end. Therefore, the desired sequence of operations: $[3, 5, 8, 1, 7] \\rightarrow [1, 3, 5, 8, 7] \\rightarrow [1, 3, 5, 7, 8]$.\n\nIn the third test case, the array is already sorted.\n-/", "vc-preamble": "def isSorted {α : Type u} [Ord α] [LE α] (xs : List α) : Prop :=\n  match xs with\n  | [] => True\n  | [_] => True\n  | x :: y :: rest => x ≤ y ∧ isSorted (y :: rest)", "vc-helpers": "", "vc-definitions": "def min_ops_to_sort {α : Type u} [Ord α] (arr : List α) : Nat :=\n  sorry", "vc-theorems": "theorem translation_invariant (arr : List Int) (k : Int) :\n  min_ops_to_sort arr = min_ops_to_sort (arr.map (fun x => x + k)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [4, 7, 2, 2, 9]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [3, 5, 8, 1, 7]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_to_sort [1, 2, 2, 4, 5]"}
{"id": "fvapps_002279", "vc-description": "/-\nThis problem is actually a subproblem of problem G from the same contest.\n\nThere are $n$ candies in a candy box. The type of the $i$-th candy is $a_i$ ($1 \\le a_i \\le n$).\n\nYou have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $1$ and two candies of type $2$ is bad). \n\nIt is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.\n\nYour task is to find out the maximum possible size of the single gift you can prepare using the candies you have.\n\nYou have to answer $q$ independent queries.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries. Each query is represented by two lines.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of candies.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), where $a_i$ is the type of the $i$-th candy in the box.\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each query print one integer — the maximum possible size of the single gift you can compose using candies you got in this query with the restriction described in the problem statement.\n\n-----Example-----\nInput\n3\n8\n1 4 8 4 5 6 3 8\n16\n2 1 3 3 4 3 4 4 1 3 2 2 2 4 1 1\n9\n2 2 4 4 4 7 7 7 7\n\nOutput\n3\n10\n9\n\n-----Note-----\n\nIn the first query, you can prepare a gift with two candies of type $8$ and one candy of type $5$, totalling to $3$ candies.\n\nNote that this is not the only possible solution — taking two candies of type $4$ and one candy of type $6$ is also valid.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_candy_gift (n : Nat) (candies : List Nat) : Nat :=\n  sorry\n\ndef count_occurrences (a : Nat) (l : List Nat) : Nat :=\n  sorry\n\ndef frequency_list (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_candy_gift_bounded\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  solve_candy_gift n candies ≤ n :=\nsorry\n\ntheorem solve_candy_gift_nonnegative\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  0 ≤ solve_candy_gift n candies :=\nsorry\n\ntheorem solve_candy_gift_monotonic_frequencies\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : ∀ x ∈ candies, 1 ≤ x ∧ x ≤ 1000) :\n  let freqs := frequency_list candies\n  let result := solve_candy_gift n candies\n  ∀ i j, i < j → i < freqs.length → j < freqs.length →\n  let take_i := if i = 0 then result else min ((freqs.get! (i-1))-1) (freqs.get! i)\n  let take_j := if j = 0 then result else min ((freqs.get! (j-1))-1) (freqs.get! j)\n  take_i ≥ take_j :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_candy_gift 8 [1, 4, 8, 4, 5, 6, 3, 8]\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval solve_candy_gift 16 [2, 1, 3, 3, 4, 3, 4, 4, 1, 3, 2, 2, 2, 4, 1, 1]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_candy_gift 9 [2, 2, 4, 4, 4, 7, 7, 7, 7]"}
{"id": "fvapps_002280", "vc-description": "/-\nYou are given an array $a$ consisting of $n$ integers.\n\nIn one move, you can choose some index $i$ ($1 \\le i \\le n - 2$) and shift the segment $[a_i, a_{i + 1}, a_{i + 2}]$ cyclically to the right (i.e. replace the segment $[a_i, a_{i + 1}, a_{i + 2}]$ with $[a_{i + 2}, a_i, a_{i + 1}]$). \n\nYour task is to sort the initial array by no more than $n^2$ such operations or say that it is impossible to do that.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 100$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains one integer $n$ ($3 \\le n \\le 500$) — the length of $a$. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 500$), where $a_i$ is the $i$-th element $a$.\n\nIt is guaranteed that the sum of $n$ does not exceed $500$.\n\n-----Output-----\n\nFor each test case, print the answer: -1 on the only line if it is impossible to sort the given array using operations described in the problem statement, or the number of operations $ans$ on the first line and $ans$ integers $idx_1, idx_2, \\dots, idx_{ans}$ ($1 \\le idx_i \\le n - 2$), where $idx_i$ is the index of left border of the segment for the $i$-th operation. You should print indices in order of performing operations.\n\n-----Example-----\nInput\n5\n5\n1 2 3 4 5\n5\n5 4 3 2 1\n8\n8 4 5 2 3 6 7 3\n7\n5 2 1 6 4 7 3\n6\n1 2 3 3 6 4\n\nOutput\n0\n\n6\n3 1 3 2 2 3 \n13\n2 1 1 6 4 2 4 3 3 4 4 6 6 \n-1\n4\n3 3 4 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_array_sort (n : Nat) (arr : List Nat) : List Nat :=\nsorry\n\ndef List.sort (l : List Nat) : List Nat :=\nsorry\n\ndef List.swap3 (l : List α) (pos : Nat) : List α :=\nsorry", "vc-theorems": "theorem sort_already_sorted {n : Nat} {arr : List Nat} (h1 : n ≥ 3)\n  (h2 : arr = List.range' 1 n) :\n  solve_array_sort n arr = [0] :=\nsorry\n\ntheorem sort_result_correctness {n : Nat} {arr : List Nat} (h1 : n ≥ 3)\n  (h2 : arr.length = n)\n  (result : List Nat) (h3 : result = solve_array_sort n arr) :\n  result = [0] ∨ result = [Nat.zero] ∨\n  (match result with\n  | [] => False\n  | num_moves :: moves =>\n    moves.length = num_moves ∧\n    let final := moves.foldl\n      (λ acc pos => acc.swap3 (pos-1)) arr;\n    final.sort = List.range' 1 n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [1, 2, 3, 4, 5]\n\n/--\ninfo: [6, 3, 1, 3, 2, 2, 3]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [5, 4, 3, 2, 1]\n\n/--\ninfo: [4, 3, 3, 4, 4]\n-/\n#guard_msgs in\n#eval solve_array_sort 6 [1, 2, 3, 3, 6, 4]"}
{"id": "fvapps_002292", "vc-description": "/-\nWe define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. \n\nNow, given an integer n, write a function that returns true when it is a perfect number and false when it is not.\n\nExample:\n\nInput: 28\nOutput: True\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n\nNote:\nThe input number n will not exceed 100,000,000. (1e8)\n-/", "vc-preamble": "def perfect_numbers : List Int := [6, 28, 496, 8128, 33550336, 8589869056]\n\ndef small_perfect_numbers : List Int := [6, 28, 496, 8128]", "vc-helpers": "", "vc-definitions": "def check_perfect_number (n : Int) : Bool :=\n  sorry", "vc-theorems": "theorem known_perfect_numbers (n : Int) (h : n ∈ perfect_numbers) :\n  check_perfect_number n = true :=\nsorry\n\ntheorem most_numbers_not_perfect {n : Int} (h₁ : n ≥ 1) (h₂ : n ≤ 1000000)\n  (h₃ : n ∉ small_perfect_numbers) :\n  check_perfect_number n = false :=\nsorry\n\ntheorem non_positive_not_perfect {n : Int} (h : n ≤ 0) :\n  check_perfect_number n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_perfect_number 28\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 12\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 1"}
{"id": "fvapps_002295", "vc-description": "/-\nGiven an integer number n, return the difference between the product of its digits and the sum of its digits.\n\nExample 1:\nInput: n = 234\nOutput: 15 \nExplanation: \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n\nExample 2:\nInput: n = 4421\nOutput: 21\nExplanation: \nProduct of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21\n\nConstraints:\n\n1 <= n <= 10^5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def subtract_product_and_sum (n : Nat) : Int :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef product_of_list (l : List Nat) : Nat :=\nsorry\n\ndef sum_of_list (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_digit_zero (n : Nat) (h : n > 0 ∧ n < 10) :\n  subtract_product_and_sum n = 0 :=\nsorry\n\ntheorem three_digit_bounds (n : Nat) (h : n ≥ 100 ∧ n ≤ 999) :\n  subtract_product_and_sum n ≤ 729 ∧ subtract_product_and_sum n ≥ -27 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 234\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 4421\n\n/--\ninfo: -2\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 111"}
{"id": "fvapps_002299", "vc-description": "/-\nGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\n\nExample 1:\n\nInput: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n\nExample 2:\n\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n\nExample 3:\n\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def third_max (nums : List Int) : Int :=\nsorry\n\ndef max (nums : List Int) : Int :=\nsorry\n\ndef uniqueSorted (nums : List Int) : List Int :=\nsorry", "vc-theorems": "theorem third_max_is_in_list {nums : List Int} (h : nums ≠ []) :\n  third_max nums ∈ nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [3, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval third_max [1, 2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [2, 2, 3, 1]"}
{"id": "fvapps_002302", "vc-description": "/-\nGiven an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.\nA triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:\n\n0 <= i < j < k < arr.length\n|arr[i] - arr[j]| <= a\n|arr[j] - arr[k]| <= b\n|arr[i] - arr[k]| <= c\n\nWhere |x| denotes the absolute value of x.\nReturn the number of good triplets.\n\nExample 1:\nInput: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\nOutput: 4\nExplanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\n\nExample 2:\nInput: arr = [1,1,2,2,3], a = 0, b = 0, c = 1\nOutput: 0\nExplanation: No triplet satisfies all conditions.\n\nConstraints:\n\n3 <= arr.length <= 100\n0 <= arr[i] <= 1000\n0 <= a, b, c <= 1000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidTriplet (arr : List Int) (i j k a b c : Nat) : Bool :=\n  sorry\n\ndef countTripletsBruteforce (arr : List Int) (a b c : Nat) : Nat :=\n  sorry\n\ndef countGoodTriplets (arr : List Int) (a b c : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem countGoodTriplets_matches_bruteforce\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length ≥ 3)\n    (h2 : arr.length ≤ 20)\n    (h3 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100)\n    (h4 : a ≤ 50 ∧ b ≤ 50 ∧ c ≤ 50) :\n    countGoodTriplets arr a b c = countTripletsBruteforce arr a b c :=\nsorry\n\ntheorem countGoodTriplets_nonnegative\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length ≥ 3)\n    (h2 : arr.length ≤ 20) :\n    0 ≤ countGoodTriplets arr a b c :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_good_triplets [3, 0, 1, 1, 9, 7] 7 2 3\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 1, 2, 2, 3] 0 0 1\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 2, 3, 4, 5] 1 1 1"}
{"id": "fvapps_002303", "vc-description": "/-\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou may assume no duplicates in the array.\n\nExample 1:\n\nInput: [1,3,5,6], 5\nOutput: 2\n\nExample 2:\n\nInput: [1,3,5,6], 2\nOutput: 1\n\nExample 3:\n\nInput: [1,3,5,6], 7\nOutput: 4\n\nExample 4:\n\nInput: [1,3,5,6], 0\nOutput: 0\n-/", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def searchInsert (nums : List Int) (target : Int) : Nat :=\n  sorry", "vc-theorems": "theorem searchInsert_valid_index\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    0 ≤ result ∧ result ≤ nums.length :=\nsorry\n\ntheorem searchInsert_left_smaller\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    ∀ i, i < result → nums[i]! < target :=\nsorry\n\ntheorem searchInsert_right_greater_eq\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    ∀ i, result ≤ i → i < nums.length → nums[i]! ≥ target :=\nsorry\n\ntheorem searchInsert_maintains_order\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    let inserted := (nums.take result).append (target :: nums.drop result)\n    isSorted inserted :=\nsorry\n\ntheorem searchInsert_identity\n    {nums : List Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums)\n    {i : Nat} (h3 : i < nums.length) :\n    searchInsert nums nums[i]! = List.findIdx (· = nums[i]!) nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 5\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 7"}
{"id": "fvapps_002306", "vc-description": "/-\nGiven an array of integers, find if the array contains any duplicates.\n\nYour function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\nExample 1:\n\nInput: [1,2,3,1]\nOutput: true\n\nExample 2:\n\nInput: [1,2,3,4]\nOutput: false\n\nExample 3:\n\nInput: [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def contains_duplicate (nums : List Int) : Bool :=\n  sorry\n\ndef eraseDups (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem contains_duplicate_matches_set_size {nums : List Int} :\n  contains_duplicate nums = (nums.length ≠ (eraseDups nums).length) :=\nsorry\n\ntheorem contains_duplicate_set_membership {nums : List Int} :\n  contains_duplicate nums = ∃ i j, i < j ∧ j < nums.length ∧ nums[i]! = nums[j]! :=\nsorry\n\ntheorem unique_list_returns_false {nums : List Int}\n  (h : ∀ i j, i < j → j < nums.length → nums[i]! ≠ nums[j]!) :\n  ¬contains_duplicate nums :=\nsorry\n\ntheorem repeated_element_returns_true {nums : List Int} (h : nums ≠ []) :\n  contains_duplicate (nums ++ nums.take 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 1]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 4]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]"}
{"id": "fvapps_002308", "vc-description": "/-\nGiven two strings s and t , write a function to determine if t is an anagram of s.\n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nFollow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_anagram (s t : String) : Bool :=\n  sorry\n\ndef reverse (s : String) : String :=\n  sorry\n\ndef isPermutation (s t : String) : Bool :=\n  sorry", "vc-theorems": "theorem string_is_anagram_of_itself (s : String) :\n  is_anagram s s = true :=\nsorry\n\ntheorem different_length_strings_not_anagrams {s t : String}\n  (h : s.length ≠ t.length) :\n  is_anagram s t = false :=\nsorry\n\ntheorem reversed_string_is_anagram (s : String) :\n  is_anagram s (reverse s) = true :=\nsorry\n\ntheorem permuted_string_is_anagram (s t : String)\n  (h : isPermutation s t) :\n  is_anagram s t = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"anagram\" \"nagaram\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_anagram \"rat\" \"car\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"hello\" \"hello\""}
{"id": "fvapps_002312", "vc-description": "/-\nGiven two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 5100.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add_strings (a b : String) : String :=\n  sorry\n\ndef int_to_str (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem add_strings_matches_int_addition\n  (a b : Nat) (h1 : a ≤ 10^6) (h2 : b ≤ 10^6) :\n  add_strings (int_to_str a) (int_to_str b) = int_to_str (a + b) :=\nsorry\n\ntheorem add_zero_right (n : Nat) (h : n ≤ 10^6) :\n  add_strings (int_to_str n) \"0\" = int_to_str n :=\nsorry\n\ntheorem add_zero_left (n : Nat) (h : n ≤ 10^6) :\n  add_strings \"0\" (int_to_str n) = int_to_str n :=\nsorry\n\ntheorem add_strings_commutative (n : Nat) (h : n ≤ 10^6) :\n  add_strings (int_to_str n) (int_to_str 42) =\n  add_strings (int_to_str 42) (int_to_str n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '172'\n-/\n#guard_msgs in\n#eval add_strings \"123\" \"49\"\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval add_strings \"0\" \"0\"\n\n/--\ninfo: '1000'\n-/\n#guard_msgs in\n#eval add_strings \"999\" \"1\""}
{"id": "fvapps_002319", "vc-description": "/-\nGiven an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n\nExample 1:\n\nInput: [3, 1, 4, 1, 5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.\n\nExample 2:\n\nInput:[1, 2, 3, 4, 5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n\nExample 3:\n\nInput: [1, 3, 1, 5, 4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n\nNote:\n\nThe pairs (i, j) and (j, i) count as the same pair.\nThe length of the array won't exceed 10,000.\nAll the integers in the given input belong to the range: [-1e7, 1e7].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_k_diff_pairs (nums : List Int) (k : Int) : Int :=\n  sorry\n\ndef countOccurrences (nums : List Int) (x : Int) : Nat :=\n  sorry\n\ndef dedup (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem k_diff_pairs_property :\n  ∀ (nums : List Int) (k : Int),\n  let result := find_k_diff_pairs nums k\n  result ≥ 0 ∧ (k < 0 → result = 0) :=\nsorry\n\ntheorem positive_k_pairs_symmetric :\n  ∀ (nums : List Int) (k : Int),\n  k > 0 →\n  find_k_diff_pairs nums (-k) = 0 :=\nsorry\n\ntheorem k_diff_pairs_subset :\n  ∀ (nums : List Int) (k : Int),\n  k > 0 →\n  nums.length > 0 →\n  let subset := nums.take (nums.length / 2)\n  find_k_diff_pairs subset k ≤ find_k_diff_pairs nums k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [3, 1, 4, 1, 5] 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 2, 3, 4, 5] 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 3, 1, 5, 4] 0"}
{"id": "fvapps_002321", "vc-description": "/-\nYou are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.\n\nGiven a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.\n\nGiven a non-empty string S and a number K, format the string according to the rules described above.\n\nExample 1:\n\nInput: S = \"5F3Z-2e-9-w\", K = 4\n\nOutput: \"5F3Z-2E9W\"\n\nExplanation: The string S has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\nExample 2:\n\nInput: S = \"2-5g-3-J\", K = 2\n\nOutput: \"2-5G-3J\"\n\nExplanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n\nNote:\n\nThe length of string S will not exceed 12,000, and K is a positive integer.\nString S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\nString S is non-empty.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUppercase (c : Char) : Bool :=\nsorry\n\ndef toCharList (s : String) : List Char :=\nsorry\n\ndef removeDashes (s : String) : String :=\nsorry\n\ndef licenseKeyFormatting (s : String) (k : Nat) : String :=\nsorry", "vc-theorems": "theorem license_key_uppercase (s : String) (k : Nat) :\n  ∀ c ∈ toCharList (licenseKeyFormatting s k), isUppercase c = true\n  :=\nsorry\n\ntheorem license_key_same_length (s : String) (k : Nat) :\n  String.length (removeDashes (licenseKeyFormatting s k)) =\n  String.length (removeDashes s)\n  :=\nsorry\n\ntheorem license_key_group_sizes (s : String) (k : Nat) :\n  let result := licenseKeyFormatting s k\n  let groups := String.splitOn result \"-\"\n  groups.length ≤ 1 ∨\n  (∀ g ∈ groups.tail, String.length g = k) ∧ String.length groups.head! ≤ k\n  :=\nsorry\n\ntheorem license_key_empty (k : Nat) :\n  licenseKeyFormatting \"\" k = \"\"\n  :=\nsorry\n\ntheorem license_key_single_dash (k : Nat) :\n  licenseKeyFormatting \"-\" k = \"\"\n  :=\nsorry\n\ntheorem license_key_no_dashes (s : String) (k : Nat) :\n  (∀ c ∈ toCharList s, c ≠ '-') →\n  removeDashes (licenseKeyFormatting s k) = String.mk (List.map Char.toUpper (toCharList s))\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '5F3Z-2E9W'\n-/\n#guard_msgs in\n#eval license_key_formatting \"5F3Z-2e-9-w\" 4\n\n/--\ninfo: '2-5G-3J'\n-/\n#guard_msgs in\n#eval license_key_formatting \"2-5g-3-J\" 2\n\n/--\ninfo: 'A-B-C'\n-/\n#guard_msgs in\n#eval license_key_formatting \"a-b-c\" 1"}
{"id": "fvapps_002322", "vc-description": "/-\nWe have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).  \n\nNow given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.\n\nExample 1:\n\nInput: \nbits = [1, 0, 0]\nOutput: True\nExplanation: \nThe only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.\n\nExample 2:\n\nInput: \nbits = [1, 1, 1, 0]\nOutput: False\nExplanation: \nThe only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.\n\nNote:\n1 .\nbits[i] is always 0 or 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countTrailingOnes : List Nat → Nat\n  | [] => 0\n  | xs => sorry\n\ndef is_one_bit_character (bits : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem ends_with_zero {bits : List Nat} (h : bits ≠ []) :\n  bits.getLast (by exact h) = 0 →\n  is_one_bit_character bits = true ∨ is_one_bit_character bits = false :=\nsorry\n\ntheorem all_zeros_is_true {bits : List Nat} (h : bits ≠ []) :\n  (bits.all (fun x => x = 0)) →\n  is_one_bit_character bits = true :=\nsorry\n\ntheorem trailing_ones_parity {bits : List Nat} (h : bits.length ≥ 2) :\n  is_one_bit_character bits = (countTrailingOnes (bits.dropLast) % 2 = 0) :=\nsorry\n\ntheorem edge_cases_hold :\n  (is_one_bit_character [0] = true) ∧\n  (is_one_bit_character [0, 0] = true) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 0, 0]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 1, 1, 0]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [0, 0]"}
{"id": "fvapps_002324", "vc-description": "/-\nGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\nNote: For the purpose of this problem, we define empty string as valid palindrome.\n\nExample 1:\n\nInput: \"A man, a plan, a canal: Panama\"\nOutput: true\n\nExample 2:\n\nInput: \"race a car\"\nOutput: false\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (s : String) : Bool :=\n  sorry\n\ndef reverseString (s : String) : String :=\n  sorry", "vc-theorems": "theorem empty_string_is_palindrome :\n  is_palindrome \"\" = true :=\nsorry\n\ntheorem string_plus_reverse_is_palindrome {s : String} :\n  is_palindrome (s ++ reverseString s) = true :=\nsorry\n\ntheorem case_insensitive {s : String} :\n  is_palindrome s = is_palindrome (s.toUpper) ∧\n  is_palindrome s = is_palindrome (s.toLower) :=\nsorry\n\ntheorem punctuation_invariant {s p c : Char} :\n  is_palindrome (String.mk [c]) = is_palindrome (String.mk [c, p]) :=\nsorry\n\ntheorem single_char_is_palindrome {c : Char} :\n  is_palindrome (String.mk [c]) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"A man, a plan, a canal: Panama\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"race a car\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"\""}
{"id": "fvapps_002326", "vc-description": "/-\nGiven a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n\nIf the last word does not exist, return 0.\n\nNote: A word is defined as a character sequence consists of non-space characters only.\n\nExample:\n\nInput: \"Hello World\"\nOutput: 5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def splitString (s: String) : List String :=\n  sorry\n\ndef lengthOfLastWord (s: String) : Nat :=\n  sorry", "vc-theorems": "theorem length_of_last_word_nonnegative (s: String) :\n  lengthOfLastWord s ≥ 0 :=\nsorry\n\ntheorem length_of_last_word_matches_split (s: String) :\n  lengthOfLastWord s > 0 →\n  match splitString s with\n  | [] => True\n  | xs => lengthOfLastWord s = xs.getLast!.length\n  :=\nsorry\n\ntheorem length_of_last_word_empty_for_blank (s: String) :\n  s.trim.isEmpty → lengthOfLastWord s = 0 :=\nsorry\n\ntheorem length_of_last_word_ignores_trailing_spaces (s: String) :\n  lengthOfLastWord s = lengthOfLastWord s.trim :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello World\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval length_of_last_word \"   \"\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello   World   Program\""}
{"id": "fvapps_002327", "vc-description": "/-\nImplement strStr().\n\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\nExample 1:\n\nInput: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nExample 2:\n\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\n\nClarification:\n\nWhat should we return when needle is an empty string? This is a great question to ask during an interview.\n\nFor the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_str (haystack : String) (needle : String) : Int :=\n  sorry\n\ndef containsString (haystack needle : String) : Bool :=\n  sorry\n\ndef stringSlice (s : String) (start : Int) (last : Int) : String :=\n  sorry\n\ndef stringRepeat (s : String) (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem empty_needle_returns_zero {haystack : String} :\n  find_str haystack \"\" = 0 := by\nsorry\n\ntheorem empty_haystack_nonempty_needle_returns_minus_one {needle : String} (h : needle ≠ \"\") :\n  find_str \"\" needle = -1 := by\nsorry\n\ntheorem needle_not_found_returns_minus_one {haystack needle : String}\n  (h : containsString haystack needle = false) :\n  find_str haystack needle = -1 := by\nsorry\n\ntheorem result_is_valid_index {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  0 ≤ r ∧ r < String.length haystack := by\nsorry\n\ntheorem result_points_to_needle {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  (stringSlice haystack r (r + String.length needle)) = needle := by\nsorry\n\ntheorem no_earlier_occurrence {haystack needle : String}\n  (h1 : needle ≠ \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  containsString (stringSlice haystack 0 r) needle = false := by\nsorry\n\ntheorem repeated_needle_returns_zero {s : String} {n : Nat}\n  (h1 : s ≠ \"\") (h2 : n > 0) :\n  find_str (stringRepeat s n) s = 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_str \"hello\" \"ll\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_str \"aaaaa\" \"bba\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_str \"\" \"\""}
{"id": "fvapps_002329", "vc-description": "/-\nGiven a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\nYou can use each character in text at most once. Return the maximum number of instances that can be formed.\n\nExample 1:\n\nInput: text = \"nlaebolko\"\nOutput: 1\n\nExample 2:\n\nInput: text = \"loonbalxballpoon\"\nOutput: 2\n\nExample 3:\nInput: text = \"leetcode\"\nOutput: 0\n\nConstraints:\n\n1 <= text.length <= 10^4\ntext consists of lower case English letters only.\n-/", "vc-preamble": "def makeBalloonsString (n : Nat) : String :=\n  String.join (List.replicate n \"balloon\")", "vc-helpers": "", "vc-definitions": "def max_balloons (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem max_balloons_nonnegative (text : String) :\n  max_balloons text ≥ 0 :=\nsorry\n\ntheorem max_balloons_upper_bound (text : String) :\n  max_balloons text ≤ text.length / 7 :=\nsorry\n\ntheorem max_balloons_has_needed_chars (text : String) (c : Char) :\n  let result := max_balloons text\n  let needed := match c with\n    | 'b' => result\n    | 'a' => result\n    | 'l' => 2 * result\n    | 'o' => 2 * result\n    | 'n' => result\n    | _ => 0\n  (text.toList.filter (· = c)).length ≥ needed :=\nsorry\n\ntheorem max_balloons_exact (n : Nat) :\n  max_balloons (makeBalloonsString n) = n :=\nsorry\n\ntheorem max_balloons_no_relevant_chars (text : String)\n  (h : ∀ c ∈ text.toList, c ∉ ['b', 'a', 'l', 'o', 'n']) :\n  max_balloons text = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_balloons \"nlaebolko\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_balloons \"loonbalxballpoon\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_balloons \"leetcode\""}
{"id": "fvapps_002334", "vc-description": "/-\nGiven a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.\nReturn the minimum number of steps to make the given string empty.\nA string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.\nA string is called palindrome if is one that reads the same backward as well as forward.\n\nExample 1:\nInput: s = \"ababa\"\nOutput: 1\nExplanation: String is already palindrome\n\nExample 2:\nInput: s = \"abb\"\nOutput: 2\nExplanation: \"abb\" -> \"bb\" -> \"\". \nRemove palindromic subsequence \"a\" then \"bb\".\n\nExample 3:\nInput: s = \"baabb\"\nOutput: 2\nExplanation: \"baabb\" -> \"b\" -> \"\". \nRemove palindromic subsequence \"baab\" then \"b\".\n\nExample 4:\nInput: s = \"\"\nOutput: 0\n\nConstraints:\n\n0 <= s.length <= 1000\ns only consists of letters 'a' and 'b'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_palindrome_subseq (s : String) : Nat :=\nsorry\n\ndef is_palindrome (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem result_bounds (s : String) :\n  0 ≤ remove_palindrome_subseq s ∧ remove_palindrome_subseq s ≤ 2 :=\nsorry\n\ntheorem empty_string :\n  remove_palindrome_subseq \"\" = 0 :=\nsorry\n\ntheorem single_char_type (s : String) :\n  s.length = 1 → remove_palindrome_subseq s = 1 :=\nsorry\n\ntheorem only_valid_results (s : String) :\n  remove_palindrome_subseq s = 0 ∨\n  remove_palindrome_subseq s = 1 ∨\n  remove_palindrome_subseq s = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"ababa\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"abb\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"baabb\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"\""}
{"id": "fvapps_002341", "vc-description": "/-\nGiven two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.\nNote that after backspacing an empty text, the text will continue empty.\n\nExample 1:\nInput: S = \"ab#c\", T = \"ad#c\"\nOutput: true\nExplanation: Both S and T become \"ac\".\n\nExample 2:\nInput: S = \"ab##\", T = \"c#d#\"\nOutput: true\nExplanation: Both S and T become \"\".\n\nExample 3:\nInput: S = \"a##c\", T = \"#a#c\"\nOutput: true\nExplanation: Both S and T become \"c\".\n\nExample 4:\nInput: S = \"a#c\", T = \"b\"\nOutput: false\nExplanation: S becomes \"c\" while T becomes \"b\".\n\nNote:\n\n1 <= S.length <= 200\n1 <= T.length <= 200\nS and T only contain lowercase letters and '#' characters.\n\nFollow up:\n\nCan you solve it in O(N) time and O(1) space?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def backspace_compare (s1: String) (s2: String) : Bool :=\n  sorry\n\ndef normalize_backspace (s: String) : String :=\n  sorry", "vc-theorems": "theorem backspace_compare_matches_naive (s1 s2: String) :\n  backspace_compare s1 s2 = (normalize_backspace s1 = normalize_backspace s2) :=\nby\nsorry\n\ntheorem self_compare (s: String) :\n  backspace_compare s s = true :=\nby\nsorry\n\ntheorem symmetric (s1 s2: String) :\n  backspace_compare s1 s2 = backspace_compare s2 s1 :=\nby\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab#c\" \"ad#c\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab##\" \"c#d#\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval backspace_compare \"a#c\" \"b\""}
{"id": "fvapps_002344", "vc-description": "/-\nGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.\n\nNote:\n\nAll letters in hexadecimal (a-f) must be in lowercase.\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\nYou must not use any method provided by the library which converts/formats the number to hex directly.\n\nExample 1:\n\nInput:\n26\n\nOutput:\n\"1a\"\n\nExample 2:\n\nInput:\n-1\n\nOutput:\n\"ffffffff\"\n-/\n\n/- Helper function to convert hex string to number (just for theorem statements) -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_hex (n : Int) : String :=\nsorry\n\ndef hexToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem to_hex_positive_integers (n : Nat) (h : n < 2^32) :\n  let result := to_hex n\n  (hexToNat result = n) ∧\n  (result.length ≤ 8) ∧\n  (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) :=\nsorry\n\ntheorem to_hex_negative_integers (n : Int) (h1 : -(2^31) ≤ n) (h2 : n < 0) :\n  let result := to_hex n\n  (result.length = 8) ∧\n  (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) ∧\n  (let value := hexToNat result\n   if value ≥ 2^31 then\n     value - 2^32 = n\n   else\n     value = n) :=\nsorry\n\ntheorem to_hex_zero :\n  to_hex 0 = \"0\" :=\nsorry\n\ntheorem to_hex_length (n : Int) :\n  let result := to_hex n\n  1 ≤ result.length ∧ result.length ≤ 8 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1a'\n-/\n#guard_msgs in\n#eval to_hex 26\n\n/--\ninfo: 'ffffffff'\n-/\n#guard_msgs in\n#eval to_hex -1\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval to_hex 0"}
{"id": "fvapps_002347", "vc-description": "/-\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\n\nFor example:\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n\nExample 1:\n\nInput: \"A\"\nOutput: 1\n\nExample 2:\n\nInput: \"AB\"\nOutput: 28\n\nExample 3:\n\nInput: \"ZY\"\nOutput: 701\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def title_to_number (s : String) : Nat :=\n  sorry\n\ndef number_to_title (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem title_to_number_positive (title : String) :\n  title_to_number title > 0 := by\n  sorry\n\ntheorem title_to_number_monotone (title : String) :\n  (title.length > 1) →\n  title_to_number title > title_to_number (String.dropRight title 1) := by\n  sorry\n\ntheorem title_to_number_roundtrip (n : Nat) :\n  n > 0 → n ≤ 2^20 →\n  title_to_number (number_to_title n) = n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval title_to_number \"A\"\n\n/--\ninfo: 28\n-/\n#guard_msgs in\n#eval title_to_number \"AB\"\n\n/--\ninfo: 701\n-/\n#guard_msgs in\n#eval title_to_number \"ZY\""}
{"id": "fvapps_002356", "vc-description": "/-\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n             Total amount you can rob = 1 + 3 = 4.\n\nExample 2:\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\n             Total amount you can rob = 2 + 9 + 1 = 12.\n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 400\n-/", "vc-preamble": "def list_sum (nums : List Nat) : Nat :=\n  List.foldl Nat.add 0 nums", "vc-helpers": "", "vc-definitions": "def rob (nums : List Nat) : Nat :=\n  sorry\n\ndef elementsAtEvenIndices (nums : List Nat) : List Nat :=\n  sorry\n\ndef elementsAtOddIndices (nums : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem rob_nonnegative (nums : List Nat) :\n  rob nums ≥ 0 :=\nsorry\n\ntheorem rob_even_indices_bound (nums : List Nat) (h : nums ≠ []) :\n  rob nums ≥ List.foldl Nat.max 0 (elementsAtEvenIndices nums) :=\nsorry\n\ntheorem rob_odd_indices_bound (nums : List Nat) (h : nums ≠ []) :\n  rob nums ≥ List.foldl Nat.max 0 (elementsAtOddIndices nums) :=\nsorry\n\ntheorem rob_minimum_of_first_two (nums : List Nat) (h : nums.length ≥ 2) :\n  rob nums ≥ Nat.max (nums.get ⟨0, sorry⟩) (nums.get ⟨1, sorry⟩) :=\nsorry\n\ntheorem rob_subset_sum (nums : List Nat) :\n  rob nums ≤ list_sum nums :=\nsorry\n\ntheorem rob_empty :\n  rob [] = 0 :=\nsorry\n\ntheorem rob_singleton (n : Nat) :\n  rob [n] = n :=\nsorry\n\ntheorem rob_pair (n m : Nat) :\n  rob [n, m] = Nat.max n m :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval rob [1, 2, 3, 1]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval rob [2, 7, 9, 3, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval rob [2, 1]"}
{"id": "fvapps_002362", "vc-description": "/-\nYou are given an array A of strings.\nA move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.\nTwo strings S and T are special-equivalent if after any number of moves onto S, S == T.\nFor example, S = \"zzxy\" and T = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" -> \"xzzy\" -> \"xyzz\" that swap S[0] and S[2], then S[1] and S[3].\nNow, a group of special-equivalent strings from A is a non-empty subset of A such that:\n\nEvery pair of strings in the group are special equivalent, and;\nThe group is the largest size possible (ie., there isn't a string S not in the group such that S is special equivalent to every string in the group)\n\nReturn the number of groups of special-equivalent strings from A.\n\nExample 1:\nInput: [\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]\nOutput: 3\nExplanation: \nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.\n\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].  Note that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n\nExample 2:\nInput: [\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]\nOutput: 3\n\nNote:\n\n1 <= A.length <= 1000\n1 <= A[i].length <= 20\nAll A[i] have the same length.\nAll A[i] consist of only lowercase letters.\n-/\n\n-- Theorem: Number of groups is bounded by list size\n\n-- Theorem: Special equivalent strings belong to same group\n\n-- Theorem: Upper bound for unique strings\n\n-- Theorem: Function is permutation invariant", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numSpecialEquivGroups (strings : List String) : Nat :=\n  sorry\n\ndef isSpecialEquivalent (s1 s2 : String) : Bool :=\n  sorry\n\ndef belongsToGroup (s : String) (g : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem num_groups_bounded (strings : List String) :\n  1 ≤ numSpecialEquivGroups strings ∧ numSpecialEquivGroups strings ≤ strings.length :=\nsorry\n\ntheorem special_equiv_same_group (s1 s2 : String) :\n  isSpecialEquivalent s1 s2 = true →\n  ∃ g, belongsToGroup s1 g = true ∧ belongsToGroup s2 g = true :=\nsorry\n\ntheorem unique_strings_bound (strings : List String) (h : strings.Nodup) :\n  numSpecialEquivGroups strings ≤ strings.length :=\nsorry\n\ntheorem permutation_invariant (strings : List String) :\n  numSpecialEquivGroups strings = numSpecialEquivGroups strings.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abcd\", \"cdab\", \"cbad\", \"xyzz\", \"zzxy\", \"zzyx\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"aa\", \"bb\", \"ab\", \"ba\"]"}
{"id": "fvapps_002365", "vc-description": "/-\nWe have n chips, where the position of the ith chip is position[i].\nWe need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:\n\nposition[i] + 2 or position[i] - 2 with cost = 0.\nposition[i] + 1 or position[i] - 1 with cost = 1.\n\nReturn the minimum cost needed to move all the chips to the same position.\n\nExample 1:\n\nInput: position = [1,2,3]\nOutput: 1\nExplanation: First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\nExample 2:\n\nInput: position = [2,2,2,3,3]\nOutput: 2\nExplanation: We can move the two chips at poistion 3 to position 2. Each move has cost = 1. The total cost = 2.\n\nExample 3:\nInput: position = [1,1000000000]\nOutput: 1\n\nConstraints:\n\n1 <= position.length <= 100\n1 <= position[i] <= 10^9\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_cost_to_move_chips (positions: List Nat) : Nat :=\nsorry\n\ndef count_even (positions: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_cost_upper_bound (positions: List Nat) (h: positions ≠ []) :\n  min_cost_to_move_chips positions ≤ positions.length :=\nsorry\n\ntheorem min_cost_non_negative (positions: List Nat) :\n  min_cost_to_move_chips positions ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 2, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [2, 2, 2, 3, 3]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 1000000000]"}
{"id": "fvapps_002366", "vc-description": "/-\nGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\n\nExample 1:\n\nInput: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n\nNote:\n\nn is a positive integer, which is in the range of [1, 10000].\nAll the integers in the array will be in the range of [-10000, 10000].\n-/\n\n-- placeholder for sorting", "vc-preamble": "def List.sorted (xs : List Int) : List Int := xs\n\ndef evenIndexSum (xs : List Int) : Int :=\n  let rec loop : List Int → Int → Int → Int\n    | [], _, acc => acc\n    | (x::xs), i, acc => loop xs (i+1) (if i % 2 = 0 then acc + x else acc)\n  loop xs 0 0\n\ndef halfListSum (xs : List Int) : Int :=\n  let rec loop : List Int → Nat → Int → Int\n    | [], _, acc => acc\n    | _, 0, acc => acc\n    | (x::xs), n+1, acc => loop xs n (acc + x)\n  loop xs (xs.length / 2) 0", "vc-helpers": "", "vc-definitions": "def array_pair_sum (nums : List Int) : Int :=\nsorry", "vc-theorems": "theorem array_pair_sum_equals_even_indexed_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums = evenIndexSum (nums.sorted) :=\nsorry\n\ntheorem array_pair_sum_geq_smallest_half_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums ≥ halfListSum (nums.sorted) :=\nsorry\n\ntheorem array_pair_sum_positive {nums : List Int}\n  (h1 : nums.length % 2 = 0)\n  (h2 : ∀ x ∈ nums, x > 0) :\n  array_pair_sum nums > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 4, 3, 2]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 2, 3, 4]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 1, 2, 2]"}
{"id": "fvapps_002371", "vc-description": "/-\nGiven a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.  You may assume the given string consists of lowercase English letters only and its length  will not exceed 10000. \n\nExample 1:\n\nInput: \"abab\"\n\nOutput: True\n\nExplanation: It's the substring \"ab\" twice.\n\nExample 2:\n\nInput: \"aba\"\n\nOutput: False\n\nExample 3:\n\nInput: \"abcabcabcabc\"\n\nOutput: True\n\nExplanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def repeatedSubstringPattern (s: String) : Bool :=\nsorry\n\ndef rotateString (s: String) : String :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry\n\ndef allCharsSame (s: String) : Bool :=\nsorry", "vc-theorems": "theorem repeatedSubstringPattern_single_char {s: String} :\n  s.length = 1 → ¬repeatedSubstringPattern s :=\nsorry\n\ntheorem repeatedSubstringPattern_rotation {s: String} (h: s.length ≥ 2) :\n  repeatedSubstringPattern s →\n  repeatedSubstringPattern (rotateString s) :=\nsorry\n\ntheorem repeatedSubstringPattern_doubled {s: String} (h: s.length > 0) :\n  repeatedSubstringPattern (s ++ s) :=\nsorry\n\ntheorem repeatedSubstringPattern_n_times {s: String} (n: Nat)\n    (h1: s.length > 0) (h2: n ≥ 3) (h3: n ≤ 10) :\n  repeatedSubstringPattern (String.append s (String.append s s)) :=\nsorry\n\ntheorem repeatedSubstringPattern_prime_length {s: String} (h1: s.length > 1) :\n  isPrime s.length →\n  ¬allCharsSame s →\n  ¬repeatedSubstringPattern s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abab\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"aba\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abcabcabcabc\""}
{"id": "fvapps_002378", "vc-description": "/-\nGiven a valid (IPv4) IP address, return a defanged version of that IP address.\nA defanged IP address replaces every period \".\" with \"[.]\".\n\nExample 1:\nInput: address = \"1.1.1.1\"\nOutput: \"1[.]1[.]1[.]1\"\nExample 2:\nInput: address = \"255.100.50.0\"\nOutput: \"255[.]100[.]50[.]0\"\n\nConstraints:\n\nThe given address is a valid IPv4 address.\n-/", "vc-preamble": "def countChar (s : String) (c : Char) : Nat :=\n  s.toList.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def defang_ip_addr (s : String) : String :=\nsorry", "vc-theorems": "theorem defang_valid_ip_length {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  defanged.length = ip.length + 6 :=\nsorry\n\ntheorem defang_valid_ip_reversible {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  String.replace \"[.]\" \".\" defanged = ip :=\nsorry\n\ntheorem defang_valid_ip_count_dots {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  countChar defanged '[' = countChar ip '.' :=\nsorry\n\ntheorem defang_valid_ip_chars_match {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : ∀ x ∈ octets, x ≤ 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  let original_chars := ip.toList.filter (· ≠ '.')\n  let defanged_chars := defanged.toList.filter (fun c => c ≠ '[' ∧ c ≠ ']' ∧ c ≠ '.')\n  original_chars = defanged_chars :=\nsorry\n\ntheorem defang_generic_string_length (s : String) :\n  let defanged := defang_ip_addr s\n  defanged.length = s.length + (2 * countChar s '.') :=\nsorry\n\ntheorem defang_generic_string_reversible (s : String) :\n  let defanged := defang_ip_addr s\n  String.replace \"[.]\" \".\" defanged = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1[.]1[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"1.1.1.1\"\n\n/--\ninfo: '255[.]100[.]50[.]0'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"255.100.50.0\"\n\n/--\ninfo: '192[.]168[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"192.168.1.1\""}
{"id": "fvapps_002379", "vc-description": "/-\nGiven two integer arrays of equal length target and arr.\nIn one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps.\nReturn True if you can make arr equal to target, or False otherwise.\n\nExample 1:\nInput: target = [1,2,3,4], arr = [2,4,1,3]\nOutput: true\nExplanation: You can follow the next steps to convert arr to target:\n1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]\n2- Reverse sub-array [4,2], arr becomes [1,2,4,3]\n3- Reverse sub-array [4,3], arr becomes [1,2,3,4]\nThere are multiple ways to convert arr to target, this is not the only way to do so.\n\nExample 2:\nInput: target = [7], arr = [7]\nOutput: true\nExplanation: arr is equal to target without any reverses.\n\nExample 3:\nInput: target = [1,12], arr = [12,1]\nOutput: true\n\nExample 4:\nInput: target = [3,7,9], arr = [3,7,11]\nOutput: false\nExplanation: arr doesn't have value 9 and it can never be converted to target.\n\nExample 5:\nInput: target = [1,1,1,1,1], arr = [1,1,1,1,1]\nOutput: true\n\nConstraints:\n\ntarget.length == arr.length\n1 <= target.length <= 1000\n1 <= target[i] <= 1000\n1 <= arr[i] <= 1000\n-/\n\n/- Helper function for list sum -/\n\n/- Helper function to get nth element -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Helper function to check if one list is a permutation of another -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_be_equal (xs ys : List Int) : Bool :=\n  sorry\n\ndef isPerm (xs ys : List Int) : Bool :=\n  sorry\n\ndef listSum (xs : List Int) : Int :=\n  sorry\n\ndef getNth (xs : List Int) (n : Nat) : Int :=\n  sorry", "vc-theorems": "theorem identical_lists_are_equal (xs : List Int) :\n  can_be_equal xs xs = true :=\nsorry\n\ntheorem permuted_lists_are_equal {xs ys : List Int} :\n  isPerm xs ys → can_be_equal xs ys = true :=\nsorry\n\ntheorem different_value_not_equal {xs ys : List Int} (h1 : xs ≠ []) (h2 : ys ≠ []) :\n  (∃ i : Nat, getNth ys i = getNth xs i + (listSum xs + 1)) →\n  can_be_equal xs ys = false :=\nsorry\n\ntheorem different_length_not_equal {xs : List Int} (y : Int) :\n  can_be_equal xs (xs ++ [y]) = false :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [1, 2, 3, 4] [2, 4, 1, 3]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [7] [7]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval can_be_equal [3, 7, 9] [3, 7, 11]"}
{"id": "fvapps_002384", "vc-description": "/-\nGiven a string s, the power of the string is the maximum length of a non-empty substring that contains only one unique character.\nReturn the power of the string.\n\nExample 1:\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\nExample 2:\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\nExample 3:\nInput: s = \"triplepillooooow\"\nOutput: 5\n\nExample 4:\nInput: s = \"hooraaaaaaaaaaay\"\nOutput: 11\n\nExample 5:\nInput: s = \"tourist\"\nOutput: 1\n\nConstraints:\n\n1 <= s.length <= 500\ns contains only lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_power (s : List Char) : Nat :=\n  sorry\n\ndef max_run (s : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem max_power_lower_bound (s : List Char) (h : s.length > 0) :\n  max_power s ≥ 1 :=\nsorry\n\ntheorem max_power_upper_bound (s : List Char) :\n  max_power s ≤ s.length :=\nsorry\n\ntheorem max_power_equals_longest_run (s : List Char) (h : s.length > 0) :\n  max_power s = max_run s :=\nsorry\n\ntheorem max_power_single_char (s : List Char) (h : s.length > 0)\n  (h' : ∀ (i j : Fin s.length), s.get i = s.get j) :\n  max_power s = s.length :=\nsorry\n\ntheorem max_power_alternating (s : List Char) (h : s.length ≥ 2)\n  (h' : ∀ (i : Fin s.length),\n    if i.val % 2 = 0\n    then s.get i = 'a'\n    else s.get i = 'b') :\n  max_power s = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval max_power \"leetcode\"\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval max_power \"abbcccddddeeeeedcba\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_power \"tourist\""}
{"id": "fvapps_002386", "vc-description": "/-\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nExample 2:\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxProfit (prices: List Nat) : Nat :=\n  sorry\n\ndef maxPairwiseDiff (prices: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxprofit_bounds_pair (a b: Nat) :\n  maxProfit [a, b] = max 0 (b - a) :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval maxProfit [7, 1, 5, 3, 6, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval maxProfit [1, 2, 3, 4, 5]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval maxProfit [7, 6, 4, 3, 1]"}
{"id": "fvapps_002390", "vc-description": "/-\nGiven two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nExample 1:\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\n\nExample 2:\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\n\nExample 3:\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n\nNote:\nYou may assume both s and t have the same length.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_isomorphic (s1 s2 : List Char) : Bool :=\n  sorry\n\ndef unique_chars (s : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem isomorphic_same_length {s1 s2 : List Char} :\n  s1.length ≠ s2.length → ¬is_isomorphic s1 s2 :=\nsorry\n\ntheorem isomorphic_identical_strings {s : List Char} :\n  is_isomorphic s s :=\nsorry\n\ntheorem isomorphic_reversible {s1 s2 : List Char} :\n  s1.length = s2.length →\n  is_isomorphic s1 s2 = is_isomorphic s2 s1 :=\nsorry\n\ntheorem isomorphic_preserves_uniqueness {s1 s2 : List Char} :\n  s1.length = s2.length →\n  is_isomorphic s1 s2 →\n  unique_chars s1 = unique_chars s2 :=\nsorry\n\ntheorem isomorphic_repeated_chars {s1 s2 : List Char} :\n  s1.length = s2.length →\n  s1.length ≥ 2 →\n  unique_chars s1 = 1 →\n  (is_isomorphic s1 s2 ↔ unique_chars s2 = 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"egg\" \"add\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_isomorphic \"foo\" \"bar\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"paper\" \"title\""}
{"id": "fvapps_002392", "vc-description": "/-\nStudents are asked to stand in non-decreasing order of heights for an annual photo.\nReturn the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.\nNotice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.\n\nExample 1:\nInput: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation: \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nExample 2:\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nExample 3:\nInput: heights = [1,2,3,4,5]\nOutput: 0\n\nConstraints:\n\n1 <= heights.length <= 100\n1 <= heights[i] <= 100\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort (as : List Nat) : List Nat :=\nsorry\n\ndef countMismatches (xs ys : List Nat) : Nat :=\nsorry\n\ndef height_checker (heights : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem height_checker_singleton (x : Nat) :\n  height_checker [x] = 0 :=\nsorry\n\ntheorem height_checker_uniform (x n : Nat) :\n  n > 0 →\n  height_checker (List.replicate n x) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval height_checker [1, 1, 4, 2, 1, 3]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval height_checker [5, 1, 2, 3, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval height_checker [1, 2, 3, 4, 5]"}
{"id": "fvapps_002393", "vc-description": "/-\nGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_moves (nums : List Int) : Int :=\nsorry\n\ndef list_minimum (nums : List Int) : Int :=\nsorry\n\ndef list_maximum (nums : List Int) : Int :=\nsorry\n\ndef list_sum (nums : List Int) : Int :=\nsorry", "vc-theorems": "theorem min_moves_non_negative (nums : List Int) (h : nums ≠ []) :\n  min_moves nums ≥ 0 :=\nsorry\n\ntheorem min_moves_equal_elements (n : Int) (len : Nat) (h : len ≥ 1) :\n  min_moves (List.replicate len n) = 0 :=\nsorry\n\ntheorem min_moves_upper_bound (nums : List Int) (h : nums ≠ []) :\n  let min_val := list_minimum nums\n  min_moves nums ≤ list_sum (nums.map (λ x => x - min_val)) :=\nsorry\n\ntheorem min_moves_monotonic (nums : List Int) (h : nums.length ≥ 2) :\n  let new_nums := nums ++ [list_maximum nums]\n  min_moves new_nums ≥ min_moves nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves [1, 1, 1]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3, 4]"}
{"id": "fvapps_002396", "vc-description": "/-\nEvery email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.  (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.  (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? \n\nExample 1:\nInput: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails\n\nNote:\n\n1 <= emails[i].length <= 100\n1 <= emails.length <= 100\nEach emails[i] contains exactly one '@' character.\nAll local and domain names are non-empty.\nLocal names do not start with a '+' character.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidEmail (s : String) : Bool :=\n  sorry\n\ndef numUniqueEmails (emails : List String) : Nat :=\n  sorry", "vc-theorems": "theorem numUniqueEmails_bounds (emails : List String) :\n  let result := numUniqueEmails emails\n  0 ≤ result ∧ result ≤ emails.length :=\nsorry\n\ntheorem numUniqueEmails_idempotent (emails : List String) :\n  emails ≠ [] →\n  numUniqueEmails (emails ++ emails) = numUniqueEmails emails :=\nsorry\n\ntheorem numUniqueEmails_dot_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let dotted := String.join [local_domain.get! 0, \"@\", local_domain.get! 1]\n  numUniqueEmails [email, dotted] = 1 :=\nsorry\n\ntheorem numUniqueEmails_plus_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let plusAdded := String.join [local_domain.get! 0, \"+anything@\", local_domain.get! 1]\n  numUniqueEmails [email, plusAdded] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval num_unique_emails [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.email@leetcode.com\"]"}
{"id": "fvapps_002398", "vc-description": "/-\nGiven two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\n\nExample 1:\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\nOutput: 2\nExplanation: \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\n\nExample 2:\nInput: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\nOutput: 2\n\nExample 3:\nInput: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\nOutput: 1\n\nConstraints:\n\n1 <= arr1.length, arr2.length <= 500\n-10^3 <= arr1[i], arr2[j] <= 10^3\n0 <= d <= 100\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def find_distance_value (arr1 arr2 : List Int) (d : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_distance_value_non_negative\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 d ≥ 0 :=\nsorry\n\ntheorem find_distance_value_bounded\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 d ≤ arr1.length :=\nsorry\n\ntheorem find_distance_value_empty_arr2\n  (arr1 : List Int) (d : Nat)\n  (h : arr1 ≠ []) :\n  find_distance_value arr1 [] d = arr1.length :=\nsorry\n\ntheorem find_distance_value_zero_distance\n  (arr1 arr2 : List Int)\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  find_distance_value arr1 arr2 0 =\n    (arr1.filter (fun x => x ∉ arr2)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [4, 5, 8] [10, 9, 1, 8] 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [1, 4, 2, 3] [-4, -3, 6, 10, 20, 30] 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_distance_value [2, 1, 100, 3] [-5, -2, 10, -3, 7] 6"}
{"id": "fvapps_002399", "vc-description": "/-\nA sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.)\nThe rules of Goat Latin are as follows:\n\nIf a word begins with a vowel (a, e, i, o, or u), append \"ma\" to the end of the word.\n        For example, the word 'apple' becomes 'applema'.\n\nIf a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add \"ma\".\n        For example, the word \"goat\" becomes \"oatgma\".\n\nAdd one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n        For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end and so on.\n\nReturn the final sentence representing the conversion from S to Goat Latin. \n\nExample 1:\nInput: \"I speak Goat Latin\"\nOutput: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\nExample 2:\nInput: \"The quick brown fox jumped over the lazy dog\"\nOutput: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"\n\nNotes:\n\nS contains only uppercase, lowercase and spaces. Exactly one space between each word.\n1 <= S.length <= 150.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_goat_latin (s : String) : String :=\nsorry\n\ndef splitString (s : String) : List String :=\nsorry\n\ndef getStringAt (words : List String) (i : Nat) : String :=\nsorry\n\ndef endsWith (s : String) (suffix : String) : Bool :=\nsorry\n\ndef dropRight (s : String) (n : Nat) : String :=\nsorry\n\ndef firstChar (s : String) : Char :=\nsorry\n\ndef dropFirst (s : String) : String :=\nsorry\n\ndef countChar (s : String) (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem to_goat_latin_vowel_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let orig := splitString s\n  let result := splitString (to_goat_latin s)\n  let orig_word := getStringAt orig i\n  let transformed := dropRight (getStringAt result i) (2 + (i+1))\n  if (firstChar orig_word).toLower ∈ ['a', 'e', 'i', 'o', 'u'] then\n    transformed = orig_word\n  else\n    transformed = dropFirst orig_word ++ String.mk [firstChar orig_word] :=\nsorry\n\ntheorem to_goat_latin_trailing_a_count {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  countChar (getStringAt result i) 'a' ≥ i + 1 :=\nsorry\n\ntheorem to_goat_latin_preserves_word_count {s : String} :\n  (splitString s).length = (splitString (to_goat_latin s)).length :=\nsorry\n\ntheorem to_goat_latin_ma_suffix_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  let suffix := \"ma\" ++ String.mk (List.replicate (i+1) 'a')\n  endsWith (getStringAt result i) suffix :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval to_goat_latin \"I speak Goat Latin\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval to_goat_latin \"The quick brown fox\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval to_goat_latin \"Each word\""}
{"id": "fvapps_002403", "vc-description": "/-\nGiven a sentence that consists of some words separated by a single space, and a searchWord.\nYou have to check if searchWord is a prefix of any word in sentence.\nReturn the index of the word in sentence where searchWord is a prefix of this word (1-indexed).\nIf searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.\nA prefix of a string S is any leading contiguous substring of S.\n\nExample 1:\nInput: sentence = \"i love eating burger\", searchWord = \"burg\"\nOutput: 4\nExplanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence.\n\nExample 2:\nInput: sentence = \"this problem is an easy problem\", searchWord = \"pro\"\nOutput: 2\nExplanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index.\n\nExample 3:\nInput: sentence = \"i am tired\", searchWord = \"you\"\nOutput: -1\nExplanation: \"you\" is not a prefix of any word in the sentence.\n\nExample 4:\nInput: sentence = \"i use triple pillow\", searchWord = \"pill\"\nOutput: 4\n\nExample 5:\nInput: sentence = \"hello from the other side\", searchWord = \"they\"\nOutput: -1\n\nConstraints:\n\n1 <= sentence.length <= 100\n1 <= searchWord.length <= 10\nsentence consists of lowercase English letters and spaces.\nsearchWord consists of lowercase English letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prefix_of_word (sentence search : String) : Int :=\n  sorry\n\ndef startsWith (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef words (s : String) : List String :=\n  sorry", "vc-theorems": "theorem empty_search_property {sentence : String} :\n  is_prefix_of_word sentence \"\" = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i love eating burger\" \"burg\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"this problem is an easy problem\" \"pro\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i am tired\" \"you\""}
{"id": "fvapps_002404", "vc-description": "/-\nGiven a 32-bit signed integer, reverse digits of an integer.\n\nExample 1:\n\nInput: 123\nOutput: 321\n\nExample 2:\n\nInput: -123\nOutput: -321\n\nExample 3:\n\nInput: 120\nOutput: 21\n\nNote:\nAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n-/\n\n-- 32-bit integer bounds", "vc-preamble": "def INT32_MAX : Int := 2^31 - 1\n\ndef INT32_MIN : Int := -(2^31)", "vc-helpers": "", "vc-definitions": "def reverse_integer (x : Int) : Int :=\nsorry", "vc-theorems": "theorem reverse_integer_sign (x : Int) :\n  let result := reverse_integer x\n  (result = 0) ∨ (result > 0 ∧ x > 0) ∨ (result < 0 ∧ x < 0) :=\nsorry\n\ntheorem reverse_integer_bounds (x : Int) :\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX :=\nsorry\n\ntheorem single_digit_numbers (x : Int) :\n  0 ≤ x ∧ x ≤ 9 →\n  reverse_integer x = x :=\nsorry\n\ntheorem trailing_zeros (x : Int) :\n  x > 0 →\n  x % 10 = 0 →\n  reverse_integer x < x :=\nsorry\n\ntheorem int32_bounds (x : Int) :\n  INT32_MIN ≤ x ∧ x ≤ INT32_MAX →\n  let result := reverse_integer x\n  INT32_MIN ≤ result ∧ result ≤ INT32_MAX :=\nsorry\n\ntheorem overflow_cases :\n  reverse_integer 1534236469 = 0 ∧\n  reverse_integer (-2147483648) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 321\n-/\n#guard_msgs in\n#eval reverse_integer 123\n\n/--\ninfo: -321\n-/\n#guard_msgs in\n#eval reverse_integer -123\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval reverse_integer 120"}
{"id": "fvapps_002405", "vc-description": "/-\nGiven alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).\nYou have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\nReturn the reformatted string or return an empty string if it is impossible to reformat the string.\n\nExample 1:\nInput: s = \"a0b1c2\"\nOutput: \"0a1b2c\"\nExplanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations.\n\nExample 2:\nInput: s = \"leetcode\"\nOutput: \"\"\nExplanation: \"leetcode\" has only characters so we cannot separate them by digits.\n\nExample 3:\nInput: s = \"1229857369\"\nOutput: \"\"\nExplanation: \"1229857369\" has only digits so we cannot separate them by characters.\n\nExample 4:\nInput: s = \"covid2019\"\nOutput: \"c2o0v1i9d\"\n\nExample 5:\nInput: s = \"ab123\"\nOutput: \"1a2b3\"\n\nConstraints:\n\n1 <= s.length <= 500\ns consists of only lowercase English letters and/or digits.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef reformat (s : String) : String :=\nsorry", "vc-theorems": "def countLetters (s : String) : Nat :=\n  s.data.filter isAlpha |>.length\n\ndef countDigits (s : String) : Nat :=\n  s.data.filter isDigit |>.length\n\ntheorem reformat_empty_string (s : String) :\n  let letters := s.data.filter isAlpha |>.length\n  let digits := s.data.filter isDigit |>.length\n  letters - digits > 1 ∨ digits - letters > 1 →\n  reformat s = \"\" :=\nsorry\n\ntheorem reformat_preserves_length (s : String) :\n  reformat s ≠ \"\" →\n  (reformat s).length = s.length :=\nsorry\n\ntheorem reformat_preserves_chars (s : String) :\n  reformat s ≠ \"\" →\n  (reformat s).data = s.data :=\nsorry\n\ntheorem reformat_alternates (s : String) :\n  reformat s ≠ \"\" →\n  ∀ i < (reformat s).length - 1,\n    (isAlpha ((reformat s).data[i]!) = !isAlpha ((reformat s).data[i+1]!)) :=\nsorry\n\ntheorem reformat_preserves_letter_count (s : String) :\n  reformat s ≠ \"\" →\n  countLetters (reformat s) = countLetters s :=\nsorry\n\ntheorem reformat_preserves_digit_count (s : String) :\n  reformat s ≠ \"\" →\n  countDigits (reformat s) = countDigits s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval reformat \"leetcode\""}
{"id": "fvapps_002406", "vc-description": "/-\nThe count-and-say sequence is the sequence of integers with the first five terms as following:\n\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n\nGiven an integer n, generate the nth term of the count-and-say sequence.\n\nNote: Each term of the sequence of integers will be represented as a string.\n\nExample 1:\n\nInput: 1\nOutput: \"1\"\n\nExample 2:\n\nInput: 4\nOutput: \"1211\"\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Every output is a string of nonzero length -/\n\n/- The output only contains ASCII digits -/\n\n/- Each count-and-say result follows from the previous number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countAndSay (n: Nat) : String :=\n  sorry", "vc-theorems": "theorem countAndSay_one : countAndSay 1 = \"1\" :=\nsorry\n\ntheorem countAndSay_nonempty (n: Nat) (h: n > 0) :\n  (countAndSay n).length > 0 :=\nsorry\n\ntheorem countAndSay_digits_only (n: Nat) (h: n > 0) :\n  ∀ p: String.Pos,\n    '0' ≤ (countAndSay n).get p ∧ (countAndSay n).get p ≤ '9' :=\nsorry\n\ntheorem countAndSay_inductive_step (n: Nat) (h: n > 1) :\n  ∃ counts digits: List Nat,\n    counts.length = digits.length ∧\n    (∀ d ∈ digits, d ≤ 9) ∧\n    (∀ c ∈ counts, c > 0) ∧\n    countAndSay n = String.join (List.map (λ (p: Nat × Nat) => toString p.1 ++ toString p.2)\n                                        (List.zip counts digits)) :=\nsorry", "vc-postamble": "/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval count_and_say 1\n\n/--\ninfo: '1211'\n-/\n#guard_msgs in\n#eval count_and_say 4\n\n/--\ninfo: '111221'\n-/\n#guard_msgs in\n#eval count_and_say 5"}
{"id": "fvapps_002407", "vc-description": "/-\nGiven a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\nYour task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.\n\nExample 1:\n\nInput: [1, 2, 2, 3, 1]\nOutput: 2\nExplanation: \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.\n\nExample 2:\n\nInput: [1,2,2,3,1,4,2]\nOutput: 6\n\nNote:\nnums.length will be between 1 and 50,000.\nnums[i] will be an integer between 0 and 49,999.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_freq (l: List Int) : Nat :=\n  sorry\n\ndef find_shortest_subarray (l : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem shortest_subarray_bounds {l : List Int} (h: l ≠ []) :\n  1 ≤ find_shortest_subarray l ∧ find_shortest_subarray l ≤ l.length :=\nsorry\n\ntheorem single_element_list {l : List Int} (h: l.length = 1) :\n  find_shortest_subarray l = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1, 4, 2]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 1, 2, 2, 2, 1]"}
{"id": "fvapps_002408", "vc-description": "/-\nGiven an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).\n\nExample 1:\n\nInput: [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. \nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \n\nExample 2:\n\nInput: [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence is [2], its length is 1. \n\nNote:\nLength of the array will not exceed 10,000.\n-/", "vc-preamble": "def is_strictly_increasing (nums : List Int) (i : Nat) : Bool :=\n  i > 0 && i < nums.length && nums[i]! > nums[i-1]!", "vc-helpers": "", "vc-definitions": "def find_length_of_lcis (nums : List Int) : Nat :=\nsorry\n\ndef count_max_increasing (nums : List Int) : Nat :=\nsorry", "vc-theorems": "theorem lcis_length_properties (nums : List Int) :\n  let result := find_length_of_lcis nums\n  result ≥ 0 ∧\n  result ≤ nums.length ∧\n  (nums.length = 0 → result = 0) ∧\n  (nums.length > 0 → result ≥ 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 4, 7]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_length_of_lcis [2, 2, 2, 2, 2]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 7]"}
{"id": "fvapps_002409", "vc-description": "/-\nThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers x and y, calculate the Hamming distance.\n\nNote:\n0 ≤ x, y < 231.\n\nExample:\n\nInput: x = 1, y = 4\n\nOutput: 2\n\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\nThe above arrows point to positions where the corresponding bits are different.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingDistance (x y : Nat) : Nat :=\n  sorry\n\ndef bitLength (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem hamming_distance_symmetry (x y : Nat) :\n  hammingDistance x y = hammingDistance y x :=\nsorry\n\ntheorem hamming_distance_self (x : Nat) :\n  hammingDistance x x = 0 :=\nsorry\n\ntheorem hamming_distance_nonnegative (x y : Nat) :\n  hammingDistance x y ≥ 0 :=\nsorry\n\ntheorem hamming_distance_upper_bound (x y : Nat) :\n  hammingDistance x y ≤ max (bitLength x) (bitLength y) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_distance 1 4\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_distance 3 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_distance 0 7"}
{"id": "fvapps_002410", "vc-description": "/-\nGiven an integer n, return the number of trailing zeroes in n!.\n\nExample 1:\n\nInput: 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\n\nExample 2:\n\nInput: 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\n\nNote: Your solution should be in logarithmic time complexity.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def factorial (n : Nat) : Nat :=\n  sorry\n\ndef countTrailingZeroes (n : Nat) : Nat :=\n  sorry\n\ndef countActualZeros (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_matches_actual {n : Nat} (h : n ≤ 1000) :\n  countTrailingZeroes n = countActualZeros (factorial n) := by\n  sorry\n\ntheorem count_non_negative (n : Nat) :\n  countTrailingZeroes n ≥ 0 := by\n  sorry\n\ntheorem count_less_than_five {n : Nat} (h : n < 5) :\n  countTrailingZeroes n = 0 := by\n  sorry\n\ntheorem count_zero :\n  countTrailingZeroes 0 = 0 := by\n  sorry\n\ntheorem count_one :\n  countTrailingZeroes 1 = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 5\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 10"}
{"id": "fvapps_002417", "vc-description": "/-\nGiven a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.\n\nExample 1:\n\nInput: \"aba\"\nOutput: True\n\nExample 2:\n\nInput: \"abca\"\nOutput: True\nExplanation: You could delete the character 'c'.\n\nNote:\n\nThe string will only contain lowercase characters a-z.\nThe maximum length of the string is 50000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_palindrome (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "def isPalindrome (s : String) : Bool := s == reverse s\n\ntheorem palindrome_basic (s : String) :\n  isPalindrome s → valid_palindrome s :=\nsorry\n\ntheorem single_char_palindrome (s : String) :\n  s.length ≤ 1 → valid_palindrome s :=\nsorry\n\ntheorem palindrome_remove_char (s : String) :\n  s.length > 1 → isPalindrome s →\n  valid_palindrome (s.take (s.length - 1)) :=\nsorry\n\ntheorem nearly_palindrome (s : String) (x : Char) :\n  s.length ≥ 3 →\n  let palindrome := s ++ reverse s\n  let middle := palindrome.length / 2\n  let nearly_pal := palindrome.take middle ++ String.mk [x] ++ palindrome.drop middle\n  valid_palindrome nearly_pal :=\nsorry\n\ntheorem non_palindrome (s : String) :\n  s.length ≥ 2 →\n  ¬(isPalindrome s) →\n  (let count := (List.zip s.data (reverse s).data).filter (fun p => p.1 ≠ p.2) |>.length\n   count > 2) →\n  ¬(valid_palindrome s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"aba\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"abca\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval valid_palindrome \"abc\""}
{"id": "fvapps_002421", "vc-description": "/-\nGiven an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\nIf it is impossible to form any triangle of non-zero area, return 0.\n\nExample 1:\nInput: [2,1,2]\nOutput: 5\n\nExample 2:\nInput: [1,2,1]\nOutput: 0\n\nExample 3:\nInput: [3,2,3,4]\nOutput: 10\n\nExample 4:\nInput: [3,6,2,3]\nOutput: 8\n\nNote:\n\n3 <= A.length <= 10000\n1 <= A[i] <= 10^6\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n| [] => 0\n| x::xs => x + list_sum xs\n\ndef list_get (l: List Nat) (i: Nat) : Nat :=\nmatch l with\n| [] => 0\n| x::xs => if i = 0 then x else list_get xs (i-1)", "vc-helpers": "", "vc-definitions": "def largest_triangle_perimeter (xs: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem perimeter_bounds {nums : List Nat} (h : nums.length ≥ 3) :\n  let result := largest_triangle_perimeter nums\n  (result = 0 ∨ (result > 0 ∧ result ≤ list_sum nums)) :=\nsorry\n\ntheorem triangle_inequality {nums : List Nat} (h : nums.length ≥ 3) :\n  let result := largest_triangle_perimeter nums\n  result > 0 →\n  ∃ i j k, i < nums.length ∧ j < nums.length ∧ k < nums.length ∧\n          i ≠ j ∧ j ≠ k ∧ i ≠ k ∧\n          list_get nums i < list_get nums j + list_get nums k ∧\n          result ≥ list_get nums i + list_get nums j + list_get nums k :=\nsorry\n\ntheorem order_independent {nums nums' : List Nat} (h : nums.length ≥ 3)\n  (h2 : nums.length = nums'.length)\n  (h3 : ∀ x, x ∈ nums ↔ x ∈ nums') :\n  largest_triangle_perimeter nums = largest_triangle_perimeter nums' :=\nsorry\n\ntheorem non_positive_result {nums : List Nat} (h : nums.length ≥ 3)\n  (h₂ : ∀ x ∈ nums, x = 0) :\n  largest_triangle_perimeter nums = 0 :=\nsorry\n\ntheorem minimal_cases_unit :\n  largest_triangle_perimeter [1,1,1] = 3 :=\nsorry\n\ntheorem minimal_cases_invalid :\n  largest_triangle_perimeter [1,1,2] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [2, 1, 2]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [1, 2, 1]\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [3, 2, 3, 4]"}
{"id": "fvapps_002423", "vc-description": "/-\nAn array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array A is monotone increasing if for all i <= j, A[i] <= A[j].  An array A is monotone decreasing if for all i <= j, A[i] >= A[j].\nReturn true if and only if the given array A is monotonic.\n\nExample 1:\nInput: [1,2,2,3]\nOutput: true\n\nExample 2:\nInput: [6,5,4,4]\nOutput: true\n\nExample 3:\nInput: [1,3,2]\nOutput: false\n\nExample 4:\nInput: [1,2,4,5]\nOutput: true\n\nExample 5:\nInput: [1,1,1]\nOutput: true\n\nNote:\n\n1 <= A.length <= 50000\n-100000 <= A[i] <= 100000\n-/", "vc-preamble": "def isSorted (nums: List Int) : Bool :=\n  match nums with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)", "vc-helpers": "", "vc-definitions": "def is_monotonic (nums: List Int) : Bool :=\nsorry", "vc-theorems": "theorem empty_or_single_element_lists_monotonic (nums: List Int) :\n  nums.length ≤ 1 → is_monotonic nums :=\nsorry\n\ntheorem identical_elements_monotonic (nums: List Int) (x: Int) (h: nums.length ≥ 2) :\n  (∀ i: Fin nums.length, nums.get i = x) → is_monotonic nums :=\nsorry\n\ntheorem sorted_lists_monotonic (nums: List Int) (h: nums.length ≥ 2) :\n  isSorted nums → is_monotonic nums :=\nsorry\n\ntheorem non_monotonic_lists_false (nums: List Int) (h: nums.length ≥ 3) :\n  (∀ i: Fin nums.length, ∀ j: Fin nums.length,\n    i.val + 1 = j.val → ¬(nums.get i ≤ nums.get j)) ∧\n  (∀ i: Fin nums.length, ∀ j: Fin nums.length,\n    i.val + 1 = j.val → ¬(nums.get i ≥ nums.get j)) →\n  ¬is_monotonic nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [1, 2, 2, 3]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [6, 5, 4, 4]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_monotonic [1, 3, 2]"}
{"id": "fvapps_002430", "vc-description": "/-\nYou are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.\nRearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.\nReturn the string after rearranging the spaces.\n\nExample 1:\nInput: text = \"  this   is  a sentence \"\nOutput: \"this   is   a   sentence\"\nExplanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n\nExample 2:\nInput: text = \" practice   makes   perfect\"\nOutput: \"practice   makes   perfect \"\nExplanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.\n\nExample 3:\nInput: text = \"hello   world\"\nOutput: \"hello   world\"\n\nExample 4:\nInput: text = \"  walks  udp package   into  bar a\"\nOutput: \"walks  udp  package  into  bar  a \"\n\nExample 5:\nInput: text = \"a\"\nOutput: \"a\"\n\nConstraints:\n\n1 <= text.length <= 100\ntext consists of lowercase English letters and ' '.\ntext contains at least one word.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countSpaces (s : String) : Nat :=\n  sorry\n\ndef split (s : String) : List String :=\n  sorry\n\ndef startsWith (s : String) (c : Char) : Bool :=\n  sorry\n\ndef reorderSpaces (s : String) : String :=\n  sorry", "vc-theorems": "theorem reorderSpaces_preserves_spaces (s : String) :\n  countSpaces s = countSpaces (reorderSpaces s) := by\n  sorry\n\ntheorem reorderSpaces_preserves_words (s : String) :\n  split s = split (reorderSpaces s) := by\n  sorry\n\ntheorem reorderSpaces_no_leading_spaces (s : String) :\n  ¬startsWith (reorderSpaces s) ' ' := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'this   is   a   sentence'\n-/\n#guard_msgs in\n#eval reorder_spaces \"  this   is  a sentence \"\n\n/--\ninfo: 'practice   makes   perfect '\n-/\n#guard_msgs in\n#eval reorder_spaces \" practice   makes   perfect\"\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval reorder_spaces \"a\""}
{"id": "fvapps_002442", "vc-description": "/-\n=====Function Descriptions=====\ncollections.Counter()\nA counter is a container that stores elements as dictionary keys, and their counts are stored as dictionary values.\n\nSample Code\n>>> from collections import Counter\n>>> \n>>> myList = [1,1,2,3,4,5,3,2,3,4,2,1,2,3]\n>>> print Counter(myList)\nCounter({2: 4, 3: 4, 1: 3, 4: 2, 5: 1})\n>>>\n>>> print Counter(myList).items()\n[(1, 3), (2, 4), (3, 4), (4, 2), (5, 1)]\n>>> \n>>> print Counter(myList).keys()\n[1, 2, 3, 4, 5]\n>>> \n>>> print Counter(myList).values()\n[3, 4, 4, 2, 1]\n\n=====Problem Statement=====\nRaghu is a shoe shop owner. His shop has X number of shoes.\nHe has a list containing the size of each shoe he has in his shop.\nThere are N number of customers who are willing to pay x_i amount of money only if they get the shoe of their desired size. Your task is to compute how much money Raghu earned.\n\n=====Input Format=====\nThe first line contains X, the number of shoes.\nThe second line contains the space separated list of all the shoe sizes in the shop.\nThe third line contains N, the number of customers.\nThe next N lines contain the space separated values of the shoe size desired by the customer and x_i, the price of the shoe.\n\n=====Constraints=====\n0<X<10^3\n0<N≤10^3\n0<x_i<100\n2<shoe size<20\n\n=====Output Format=====\nPrint the amount of money earned by Raghu.\n-/\n\n-- Earnings cannot be negative (this is implied by Nat return type)\n\n-- Earnings cannot exceed sum of requested prices\n\n-- Cannot sell more shoes than inventory\n\n-- Empty inventory yields zero earnings\n\n-- Order of inventory doesn't affect earnings", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_shoe_shop_earnings (num_shoes : Nat) (shoe_sizes : List Nat)\n    (customer_requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef count_successful_sales (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) : Nat :=\n  sorry\n\ndef sum_request_prices (requests : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem earnings_nonnegative\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests ≥ 0 :=\nsorry\n\ntheorem earnings_upper_bound\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests ≤\n    sum_request_prices customer_requests :=\nsorry\n\ntheorem sales_limited_by_inventory\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat × Nat)) :\n    count_successful_sales shoe_sizes customer_requests ≤ shoe_sizes.length :=\nsorry\n\ntheorem empty_inventory_zero_earnings (requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings 0 [] requests = 0 :=\nsorry\n\ntheorem inventory_order_invariant\n    (num_shoes : Nat) (shoe_sizes : List Nat) (requests : List (Nat × Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes requests =\n    calculate_shoe_shop_earnings num_shoes shoe_sizes.reverse requests :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 200\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 10 [2, 3, 4, 5, 6, 8, 7, 6, 5, 18] [(6, 55), (6, 45), (6, 55), (4, 40), (18, 60), (10, 50)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 0 [] [(6, 55)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 1 [2] [(3, 50)]"}
{"id": "fvapps_002444", "vc-description": "/-\n=====Problem Statement=====\nA valid email address meets the following criteria:\n\nIt's composed of a username, domain name, and extension assembled in this format: username@domain.extension\nThe username starts with an English alphabetical character, and any subsequent characters consist of one or more of the following: alphanumeric characters, -,., and _.\nThe domain and extension contain only English alphabetical characters.\nThe extension is 1, 2, or 3 characters in length.\n\nGiven n pairs of names and email addresses as input, print each name and email address pair having a valid email address on a new line.\n\nHint: Try using Email.utils() to complete this challenge. For example, this code:\n\nimport email.utils\nprint email.utils.parseaddr('DOSHI <DOSHI@hackerrank.com>')\nprint email.utils.formataddr(('DOSHI', 'DOSHI@hackerrank.com'))\n\nproduces this output:\n\n('DOSHI', 'DOSHI@hackerrank.com')\nDOSHI <DOSHI@hackerrank.com>\n\n=====Input Format=====\nThe first line contains a single integer, n, denoting the number of email address.\nEach line i of the n subsequent lines contains a name and an email address as two space-separated values following this format:\nname <user@email.com>\n\n=====Constraints=====\n0<n<100\n\n=====Output Format=====\nPrint the space-separated name and email address pairs containing valid email addresses only. Each pair must be printed on a new line in the following format:\nname <user@email.com>\n\nYou must print each valid email address in the same order as it was received as input.\n-/\n\n/- For a list of valid email addresses, all should be returned unchanged -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of invalid email addresses, an empty list should be returned -/\n\n/- For a mixed list of valid and invalid emails, only valid ones should be returned -/\n\n/- Function should not crash on arbitrary string input -/", "vc-preamble": "def Email := String", "vc-helpers": "", "vc-definitions": "def validate_emails (emails : List Email) : List Email :=\nsorry\n\ndef isValidEmailFormat (e : Email) : Bool :=\nsorry", "vc-theorems": "theorem validate_valid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, isValidEmailFormat e) :\n  validate_emails emails = emails :=\nsorry\n\ntheorem validate_invalid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, ¬ isValidEmailFormat e) :\n  validate_emails emails = [] :=\nsorry\n\ntheorem validate_mixed_emails (emails : List Email)\n  (valid : List Email := emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :=\nsorry\n\ntheorem validate_arbitrary_input (inputs : List String) :\n  ∃ result, validate_emails inputs = result :=\nsorry", "vc-postamble": "/--\ninfo: ['DEXTER <dexter@hotmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"DEXTER <dexter@hotmail.com>\", \"VIRUS <virus!@variable.:p>\"]\n\n/--\ninfo: ['ALICE <alice123@gmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"ALICE <alice123@gmail.com>\"]\n\n/--\ninfo: ['CAROL <carol@xyz.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"INVALID <inv@k.>\", \"CAROL <carol@xyz.com>\"]"}
{"id": "fvapps_002446", "vc-description": "/-\n=====Function Descriptions=====\nCalendar Module\nThe calendar module allows you to output calendars and provides additional useful functions for them.\n\nclass calendar.TextCalendar([firstweekday])\n\nThis class can be used to generate plain text calendars.\n\nSample Code\n>>> import calendar\n>>> \n>>> print calendar.TextCalendar(firstweekday=6).formatyear(2015)\n                                  2015\n\n      January                   February                   March\nSu Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa\n             1  2  3       1  2  3  4  5  6  7       1  2  3  4  5  6  7\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       8  9 10 11 12 13 14\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      15 16 17 18 19 20 21\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      22 23 24 25 26 27 28\n25 26 27 28 29 30 31                                29 30 31\n\n       April                      May                       June\nSu Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa\n          1  2  3  4                      1  2          1  2  3  4  5  6\n 5  6  7  8  9 10 11       3  4  5  6  7  8  9       7  8  9 10 11 12 13\n12 13 14 15 16 17 18      10 11 12 13 14 15 16      14 15 16 17 18 19 20\n19 20 21 22 23 24 25      17 18 19 20 21 22 23      21 22 23 24 25 26 27\n26 27 28 29 30            24 25 26 27 28 29 30      28 29 30\n                          31\n\n        July                     August                  September\nSu Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa\n          1  2  3  4                         1             1  2  3  4  5\n 5  6  7  8  9 10 11       2  3  4  5  6  7  8       6  7  8  9 10 11 12\n12 13 14 15 16 17 18       9 10 11 12 13 14 15      13 14 15 16 17 18 19\n19 20 21 22 23 24 25      16 17 18 19 20 21 22      20 21 22 23 24 25 26\n26 27 28 29 30 31         23 24 25 26 27 28 29      27 28 29 30\n                          30 31\n\n      October                   November                  December\nSu Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa      Su Mo Tu We Th Fr Sa\n             1  2  3       1  2  3  4  5  6  7             1  2  3  4  5\n 4  5  6  7  8  9 10       8  9 10 11 12 13 14       6  7  8  9 10 11 12\n11 12 13 14 15 16 17      15 16 17 18 19 20 21      13 14 15 16 17 18 19\n18 19 20 21 22 23 24      22 23 24 25 26 27 28      20 21 22 23 24 25 26\n25 26 27 28 29 30 31      29 30                     27 28 29 30 31\n\n=====Problem Statement=====\nYou are given a date. Your task is to find what the day is on that date.\n\n=====Input Format=====\nA single line of input containing the space separated month, day and year, respectively, in MM DD YYYY format.\n\n=====Constraints=====\n2000<year<3000\n\n=====Output Format=====\nOutput the correct day in capital letters.\n-/", "vc-preamble": "structure Date where\n  month : Nat\n  day : Nat\n  year : Nat", "vc-helpers": "", "vc-definitions": "def get_weekday_name (month : Nat) (day : Nat) (year : Nat) : String :=\nsorry\n\ndef IsValidDate (d : Date) : Prop :=\nsorry\n\ndef weekday (d : Date) : Nat :=\nsorry\n\ndef calendar_day_name (n : Nat) : String :=\nsorry\n\ndef IsUppercase (s : String) : Prop :=\nsorry\n\ndef IsValidWeekdayName (s : String) : Prop :=\nsorry", "vc-theorems": "theorem get_weekday_name_matches_calendar\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 ≤ m ∧ m ≤ 12)\n    (h2 : 1 ≤ d ∧ d ≤ 31)\n    (h3 : 1900 ≤ y ∧ y ≤ 2100)\n    (h4 : IsValidDate ⟨m, d, y⟩) :\n    get_weekday_name m d y = calendar_day_name (weekday ⟨m, d, y⟩) :=\nsorry\n\ntheorem get_weekday_name_returns_uppercase\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 ≤ m ∧ m ≤ 12)\n    (h2 : 1 ≤ d ∧ d ≤ 31)\n    (h3 : 1900 ≤ y ∧ y ≤ 2100) :\n    IsValidDate ⟨m, d, y⟩ →\n    (IsUppercase (get_weekday_name m d y) ∧\n     IsValidWeekdayName (get_weekday_name m d y)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'WEDNESDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 8 5 2015\n\n/--\ninfo: 'SUNDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 1 1 2023\n\n/--\ninfo: 'MONDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 12 25 2023"}
{"id": "fvapps_002447", "vc-description": "/-\n=====Function Descriptions=====\nany()\nThis expression returns True if any element of the iterable is true. If the iterable is empty, it will return False.\n\nCode\n>>> any([1>0,1==0,1<0])\nTrue\n>>> any([1<0,2<1,3<2])\nFalse\n\nall()\nThis expression returns True if all of the elements of the iterable are true. If the iterable is empty, it will return True.\n\nCode\n>>> all(['a'<'b','b'<'c'])\nTrue\n>>> all(['a'<'b','c'<'b'])\nFalse\n\n=====Problem Statement=====\nYou are given a space separated list of integers. If all the integers are positive, then you need to check if any integer is a palindromic integer.\n\n=====Input Format=====\nThe first line contains an integer N. N is the total number of integers in the list. The second line contains the space separated list of N integers.\n\n=====Constraints=====\n0<N<100\n\n=====Output Format=====\nPrint True if all the conditions of the problem statement are satisfied. Otherwise, print False.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPalindrome (n : Nat) : Bool :=\n  sorry\n\ndef check_palindromic_positives (nums : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem palindromic_positives_negative_number\n  {nums : List Int}\n  (h : ∃ x ∈ nums, x ≤ 0) :\n  check_palindromic_positives nums = false :=\nsorry\n\ntheorem palindromic_positives_all_positive\n  {nums : List Int}\n  (h : ∀ x ∈ nums, x > 0) :\n  check_palindromic_positives nums =\n    nums.any (fun x => isPalindrome x.toNat) :=\nsorry\n\ntheorem single_digits_palindromic\n  {nums : List Int}\n  (h1 : ∀ x ∈ nums, x > 0)\n  (h2 : ∀ x ∈ nums, x < 10) :\n  check_palindromic_positives nums = true :=\nsorry\n\ntheorem non_positive_false\n  {nums : List Int}\n  (h : ∀ x ∈ nums, x ≤ 0)\n  (h_nonempty : nums ≠ []) :\n  check_palindromic_positives nums = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 9, 61, 5, 14]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [-1, 9, 61, 5, 14]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 34, 56, 78]"}
{"id": "fvapps_002448", "vc-description": "/-\n=====Function Descriptions=====\nIf we want to add a single element to an existing set, we can use the .add() operation.\nIt adds the element to the set and returns 'None'.\n\n=====Example=====\n>>> s = set('HackerRank')\n>>> s.add('H')\n>>> print s\nset(['a', 'c', 'e', 'H', 'k', 'n', 'r', 'R'])\n>>> print s.add('HackerRank')\nNone\n>>> print s\nset(['a', 'c', 'e', 'HackerRank', 'H', 'k', 'n', 'r', 'R'])\n\n=====Problem Statement=====\nApply your knowledge of the .add() operation to help your friend Rupal.\nRupal has a huge collection of country stamps. She decided to count the total number of distinct country stamps in her collection. She asked for your help. You pick the stamps one by one from a stack of N country stamps.\nFind the total number of distinct country stamps.\n\n=====Input Format=====\nThe fist line contains an integer N, the total number of country stamps.\nThe next N lines contains the name of the country where the stamp is from.\n\n=====Constraints=====\n0<N<1000\n\n=====Output Format=====\nOutput the total number of distinct country stamps on a single line.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_distinct_stamps (stamps : List String) : Nat :=\nsorry\n\ndef count_unique (l : List String) : Nat :=\nsorry", "vc-theorems": "theorem count_distinct_stamps_bounded (stamps : List String) :\n  count_distinct_stamps stamps ≤ stamps.length :=\nsorry\n\ntheorem count_distinct_stamps_deterministic (stamps : List String) :\n  count_distinct_stamps stamps = count_distinct_stamps stamps :=\nsorry\n\ntheorem count_distinct_stamps_nonnegative (stamps : List String) :\n  count_distinct_stamps stamps ≥ 0 :=\nsorry\n\ntheorem count_distinct_stamps_with_duplicates (stamps : List String) :\n  count_distinct_stamps (stamps ++ stamps) = count_distinct_stamps stamps :=\nsorry\n\ntheorem count_distinct_stamps_empty :\n  count_distinct_stamps [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"UK\", \"China\", \"USA\", \"France\", \"New Zealand\", \"UK\", \"France\"]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"India\", \"India\", \"India\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"Japan\", \"Korea\", \"China\"]"}
{"id": "fvapps_002449", "vc-description": "/-\n=====Problem Statement=====\nYou are asked to ensure that the first and last names of people begin with a capital letter in their passports. For example, alison heck should be capitalised correctly as Alison Heck. \n\nalison heck => Alison Heck\n\nGiven a full name, your task is to capitalize the name appropriately.\n\n=====Input Format=====\nA single line of input containing the full name, S.\n\n=====Constraints=====\n0<len(S)<1000\nThe string consists of alphanumeric characters and spaces.\n\nNote: in a word only the first character is capitalized. Example 12abc when capitalized remains 12abc.\n\n=====Output Format=====\nPrint the capitalized string, S.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (s : List Char) : String :=\nsorry\n\ndef capitalize_name (s : String) : String :=\nsorry\n\ndef splitOn (s : String) (p : Char → Bool) : List String :=\nsorry\n\ndef front (s : String) : Char :=\nsorry\n\ndef drop (s : String) (n : Nat) : String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef toLower (s : String) : String :=\nsorry\n\ndef length (s : String) : Nat :=\nsorry", "vc-theorems": "theorem capitalize_name_preserves_word_count (s : String) :\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :=\nsorry\n\ntheorem words_start_with_uppercase (s : String) (word : String) :\n  word ∈ splitOn (capitalize_name s) (fun x => x = ' ') →\n  word.length > 0 →\n  isAlpha (word.front) →\n  isUpper (word.front) ∧ word.drop 1 = toLower (word.drop 1) :=\nsorry\n\ntheorem whitespace_only_preserves_length (s : String) :\n  (∀ c ∈ s.data, c = ' ') →\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :=\nsorry\n\ntheorem non_alpha_preserved (s : String) :\n  (∀ c ∈ s.data, !isAlpha c) →\n  s.length > 0 →\n  capitalize_name s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002454", "vc-description": "/-\n=====Problem Statement=====\nYou are given an HTML code snippet of N lines.\nYour task is to detect and print all the HTML tags, attributes and attribute values.\n\nPrint the detected items in the following format:\n\nTag1\nTag2\n-> Attribute2[0] > Attribute_value2[0]\n-> Attribute2[1] > Attribute_value2[1]\n-> Attribute2[2] > Attribute_value2[2]\nTag3\n-> Attribute3[0] > Attribute_value3[0]\n\nThe -> symbol indicates that the tag contains an attribute. It is immediately followed by the name of the attribute and the attribute value.\nThe > symbol acts as a separator of attributes and attribute values.\n\nIf an HTML tag has no attribute then simply print the name of the tag.\n\nNote: Do not detect any HTML tag, attribute or attribute value inside the HTML comment tags (<!-- Comments -->). Comments can be multiline.\nAll attributes have an attribute value.\n\n=====Input Format=====\nThe first line contains an integer N, the number of lines in the HTML code snippet.\nThe next N lines contain HTML code.\n\n=====Constraints=====\n0<N<100\n\n=====Output Format=====\nPrint the HTML tags, attributes and attribute values in order of their occurrence from top to bottom in the snippet.\n\nFormat your answers as explained in the problem statement.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def split_lines (s : String) : List String :=\n  s.splitOn \"\\n\"", "vc-helpers": "", "vc-definitions": "def parse_html (s : String) : String :=\n  sorry\n\ndef is_lowercase_letter (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem single_tag_parse {tag : String}\n  (h : ∀ c, c ∈ tag.data → is_lowercase_letter c) :\n  parse_html s!\"<{tag}>\" = tag :=\nsorry\n\ntheorem tag_with_attrs_parse {tag : String} {attrs : List (String × String)}\n  (h1 : ∀ c, c ∈ tag.data → is_lowercase_letter c)\n  (h2 : ∀ (k v : String), (k, v) ∈ attrs → ∀ c, c ∈ k.data → is_lowercase_letter c) :\n  let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n  let html := s!\"<{tag} {attr_str}>\"\n  let result := split_lines (parse_html html)\n  result[0]! = tag ∧\n  (∀ i k v, attrs[i]! = (k,v) → result[i+1]! = s!\"-> {k} > {v}\") :=\nsorry\n\ntheorem multiple_tags_parse {tags : List String} {attrs_list : List (List (String × String))}\n  (h1 : tags.length > 0)\n  (h2 : attrs_list.length = tags.length)\n  (h3 : ∀ tag, tag ∈ tags → ∀ c, c ∈ tag.data → is_lowercase_letter c)\n  (h4 : ∀ attrs, attrs ∈ attrs_list → ∀ k v, (k,v) ∈ attrs → ∀ c, c ∈ k.data → is_lowercase_letter c) :\n  let html_parts := tags.zip attrs_list |>.map (fun (tag, attrs) =>\n    let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n    s!\"<{tag} {attr_str}>\"\n  )\n  let html := String.intercalate \"\\n\" html_parts\n  let result := split_lines (parse_html html)\n  ∀ i : Nat, i < tags.length →\n    result[i]! = tags[i]! ∧\n    ∀ j k v, attrs_list[i]![j]! = (k,v) →\n      result[i + j + 1]! = s!\"-> {k} > {v}\" :=\nsorry\n\ntheorem self_closing_tag_parse {tag : String}\n  (h : ∀ c, c ∈ tag.data → is_lowercase_letter c) :\n  parse_html s!\"<{tag}/>\" = tag :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002459", "vc-description": "/-\n=====Problem Statement=====\nYou are given a string S. S contains alphanumeric characters only. Your task is to sort the string S in the following manner:\nAll sorted lowercase letters are ahead of uppercase letters.\nAll sorted uppercase letters are ahead of digits.\nAll sorted odd digits are ahead of sorted even digits.\n\n=====Input Format=====\nA single line of input contains the string S.\n\n=====Constraints=====\n0<len(S)<1000\n\n=====Output Format=====\nOutput the sorted string S.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_str_special (s : String) : String :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry", "vc-theorems": "theorem sort_str_preserves_length (s : String) :\n  String.length (sort_str_special s) = String.length s := by\n  sorry\n\ntheorem sort_str_preserves_chars (s : String) :\n  String.toList (sort_str_special s) = String.toList s := by\n  sorry\n\ntheorem digits_ordered_by_parity_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hd1 : isDigit ((sort_str_special s).get i))\n    (hd2 : isDigit ((sort_str_special s).get j)) :\n    let d1 := (sort_str_special s).get i\n    let d2 := (sort_str_special s).get j\n    (d1.toNat % 2 = 0 → d2.toNat % 2 ≠ 1) ∧\n    (d1.toNat % 2 = d2.toNat % 2 → d1.toNat ≤ d2.toNat) := by\n  sorry\n\ntheorem letters_ordered_by_case_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hl1 : (isLower ((sort_str_special s).get i) ∨ isUpper ((sort_str_special s).get i)))\n    (hl2 : (isLower ((sort_str_special s).get j) ∨ isUpper ((sort_str_special s).get j))) :\n    let c1 := (sort_str_special s).get i\n    let c2 := (sort_str_special s).get j\n    (isUpper c1 → ¬isLower c2) ∧\n    ((isUpper c1 = isUpper c2) → c1 ≤ c2) := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_002460", "vc-description": "/-\n=====Function Descriptions=====\nConcatenate\n\nTwo or more arrays can be concatenated together using the concatenate function with a tuple of the arrays to be joined:\n\nimport numpy\n\narray_1 = numpy.array([1,2,3])\narray_2 = numpy.array([4,5,6])\narray_3 = numpy.array([7,8,9])\n\nprint numpy.concatenate((array_1, array_2, array_3))    \n\n#Output\n[1 2 3 4 5 6 7 8 9]\n\nIf an array has more than one dimension, it is possible to specify the axis along which multiple arrays are concatenated. By default, it is along the first dimension.\n\nimport numpy\n\narray_1 = numpy.array([[1,2,3],[0,0,0]])\narray_2 = numpy.array([[0,0,0],[7,8,9]])\n\nprint numpy.concatenate((array_1, array_2), axis = 1)   \n\n#Output\n[[1 2 3 0 0 0]\n [0 0 0 7 8 9]]    \n\n=====Problem Statement=====\nYou are given two integer arrays of size NXP and MXP (N & M are rows, and P is the column). Your task is to concatenate the arrays along axis 0.\n\n=====Input Format=====\nThe first line contains space separated integers N, M and P .\nThe next N lines contains the space separated elements of the P columns.\nAfter that, the next M lines contains the space separated elements of the P columns.\n\n=====Output Format=====\nPrint the concatenated array of size (N + M)XP.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Array.shape (a : Array (Array α)) : Nat × Nat :=\n  sorry\n\ndef concatenate_arrays {α : Type} (n m p : Nat) (array1 array2 : Array (Array α)) :\n  Array (Array α) :=\n  sorry", "vc-theorems": "theorem concatenate_arrays_shape (n m p : Nat) (array1 array2 : Array (Array α)) :\n  (concatenate_arrays n m p array1 array2).shape = (n + m, p) :=\nsorry\n\ntheorem concatenate_arrays_preserves_first (n m p : Nat) (array1 array2 : Array (Array α)) :\n  ∀ i < n, (concatenate_arrays n m p array1 array2)[i]! = array1[i]! :=\nsorry\n\ntheorem concatenate_arrays_preserves_second (n m p : Nat) (array1 array2 : Array (Array α)) :\n  ∀ i < m, (concatenate_arrays n m p array1 array2)[n + i]! = array2[i]! :=\nsorry\n\ntheorem concatenate_arrays_singleton (n p : Nat) (value : α)\n  (array1 : Array (Array α)) (array2 : Array (Array α)) :\n  array2.size = 1 →\n  (∀ i < n, (array1[i]!).size = p) →\n  (array2[0]!).size = p →\n  (concatenate_arrays n 1 p array1 array2).shape = (n + 1, p) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002469", "vc-description": "/-\n=====Function Descriptions=====\nfloor\nThe tool floor returns the floor of the input element-wise.\nThe floor of x is the largest integer i where i≤x.\n\nimport numpy\n\nmy_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\nprint numpy.floor(my_array)         #[ 1.  2.  3.  4.  5.  6.  7.  8.  9.]\n\nceil\nThe tool ceil returns the ceiling of the input element-wise.\nThe ceiling of x is the smallest integer i where i≥x.\n\nimport numpy\n\nmy_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\nprint numpy.ceil(my_array)          #[  2.   3.   4.   5.   6.   7.   8.   9.  10.]\n\nrint\nThe rint tool rounds to the nearest integer of input element-wise.\n\nimport numpy\n\nmy_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\nprint numpy.rint(my_array)          #[  1.   2.   3.   4.   6.   7.   8.   9.  10.]\n\n=====Problem Statement=====\nYou are given a 1-D array, A. Your task is to print the floor, ceil and rint of all the elements of A.\n\n=====Input Format=====\nA single line of input containing the space separated elements of array A.\n\n=====Output Format=====\nOn the first line, print the floor of A.\nOn the second line, print the ceil of A.\nOn the third line, print the rint of A.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n-- Properties for each element", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_transforms (input : String) : Array Float × Array Float × Array Float :=\nsorry\n\ndef transform_list (numbers : List Float) : Array Float × Array Float × Array Float :=\nsorry\n\ndef int_to_float (n : Int) : Float :=\nsorry", "vc-theorems": "theorem array_transforms_properties {numbers : List Float} (h : numbers.length > 0) :\n  let (floor_arr, ceil_arr, rint_arr) := transform_list numbers\n  let h_sizes : floor_arr.size = numbers.length ∧ ceil_arr.size = numbers.length ∧ rint_arr.size = numbers.length := by sorry\n\n  ∀ i : Fin numbers.length,\n    let idx : Nat := i.val\n    let h_floor : idx < floor_arr.size := by sorry\n    let h_ceil : idx < ceil_arr.size := by sorry\n    let h_rint : idx < rint_arr.size := by sorry\n\n    floor_arr[idx]'h_floor ≤ numbers[idx] ∧\n    ceil_arr[idx]'h_ceil ≥ numbers[idx] ∧\n    floor_arr[idx]'h_floor ≤ rint_arr[idx]'h_rint ∧\n    rint_arr[idx]'h_rint ≤ ceil_arr[idx]'h_ceil ∧\n    ceil_arr[idx]'h_ceil - floor_arr[idx]'h_floor ≤ 1 ∧\n    (rint_arr[idx]'h_rint - numbers[idx]).abs ≤ 0.5 :=\nsorry\n\ntheorem array_transforms_integers (n : Int) :\n  let res := array_transforms (toString n)\n  let floor_arr := res.1\n  let ceil_arr := res.2.1\n  let rint_arr := res.2.2\n  let h_size : 0 < floor_arr.size := by sorry\n\n  floor_arr = ceil_arr ∧\n  floor_arr = rint_arr ∧\n  floor_arr[0]'h_size = int_to_float n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002472", "vc-description": "/-\n=====Function Descriptions=====\nPolar coordinates are an alternative way of representing Cartesian coordinates or Complex Numbers.\nA complex number z\nz = x + yj\nis completely determined by its real part y. Here, j is the imaginary unit.\n\nA polar coordinate (r, φ) is completely determined by modulus r and phase angle φ.\nIf we convert complex number z to its polar coordinate, we find:\nr: Distance from z to origin, i.e., sqrt(x^2 + y^2)\nφ: Counter clockwise angle measured from the positive -axis to the line segment that joins z to the origin.\n\nPython's cmath module provides access to the mathematical functions for complex numbers.\ncmath.phase\nThis tool returns the phase of complex number z (also known as the argument of z).\n>>> phase(complex(-1.0, 0.0))\n3.1415926535897931\n\nabs\nThis tool returns the modulus (absolute value) of complex number z.\n>>> abs(complex(-1.0, 0.0))\n1.0\n\n=====Problem Statement=====\nYou are given a complex z. Your task is to convert it to polar coordinates.\n\n=====Input Format=====\nA single line containing the complex number z. Note: complex() function can be used in python to convert the input as a complex number.\n\n=====Constraints=====\nGiven number is a valid complex number\n\n=====Output Format=====\nOutput two lines:\nThe first line should contain the value of r.\nThe second line should contain the value of φ.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Simplified complex number representation", "vc-preamble": "def ℂ := Float × Float\n\ndef mkComplex (r i : Float) : ℂ := (r, i)", "vc-helpers": "", "vc-definitions": "def magnitude : ℂ → Float :=\nsorry\n\ndef phase : ℂ → Float :=\nsorry", "vc-theorems": "theorem get_polar_coords_zero :\n  let z := mkComplex 0 0\n  magnitude z = 0 ∧ phase z = 0 := by\nsorry\n\ntheorem get_polar_coords_real_positive :\n  let z := mkComplex 1 0\n  magnitude z = 1 ∧ phase z = 0 := by\nsorry\n\ntheorem get_polar_coords_real_negative :\n  let z := mkComplex (-1) 0\n  magnitude z = 1 ∧ phase z = 3.141592653589793 := by\nsorry\n\ntheorem get_polar_coords_complex :\n  let z := mkComplex 1 2\n  Float.abs (magnitude z - 2.23606797749979) < 1e-10 ∧\n  Float.abs (phase z - 1.1071487177940904) < 1e-10 := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_002475", "vc-description": "/-\n=====Problem Statement=====\nYou are given a positive integer N. Print a numerical triangle of height N - 1 like the one below:\n1\n22\n333\n4444\n55555\n......\n\nCan you do it using only arithmetic operations, a single for loop and print statement?\n\nUse no more than two lines. The first line (the for statement) is already written for you. You have to complete the print statement.\n\nNote: Using anything related to strings will give a score of 0.\n\n=====Input Format=====\nA single line containing integer, N.\n\n=====Constraints=====\n1≤N≤9\n\n=====Output Format=====\nPrint N - 1 lines as explained above.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numerical_triangle (n: Nat) : String :=\nsorry\n\ndef String.splitLines (s : String) : List String :=\nsorry\n\ndef String.allDigits (s : String) : Bool :=\nsorry\n\ndef String.toNat (s : String) : Option Nat :=\nsorry", "vc-theorems": "theorem numerical_triangle_increasing_length (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    ∀ i, 1 ≤ i → i < lines.length →\n    (lines.get! i).length > (lines.get! (i-1)).length :=\nsorry\n\ntheorem numerical_triangle_line_count (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    lines.length = n - 1 :=\nsorry\n\ntheorem numerical_triangle_valid_integers (n: Nat)\n    (h: 1 ≤ n ∧ n ≤ 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines ≠ [] →\n    ∀ line, line ∈ lines →\n    line.allDigits ∧\n    (∃ num, line.toNat = some num ∧ num > 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1\\n22\\n333\\n4444'\n-/\n#guard_msgs in\n#eval numerical_triangle 5\n\n/--\ninfo: '1\\n22'\n-/\n#guard_msgs in\n#eval numerical_triangle 3\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval numerical_triangle 2"}
{"id": "fvapps_002479", "vc-description": "/-\n=====Function Descriptions=====\nmean\n\nThe mean tool computes the arithmetic mean along the specified axis.\n\nimport numpy\n\nmy_array = numpy.array([ [1, 2], [3, 4] ])\n\nprint numpy.mean(my_array, axis = 0)        #Output : [ 2.  3.]\nprint numpy.mean(my_array, axis = 1)        #Output : [ 1.5  3.5]\nprint numpy.mean(my_array, axis = None)     #Output : 2.5\nprint numpy.mean(my_array)                  #Output : 2.5\n\nBy default, the axis is None. Therefore, it computes the mean of the flattened array.\n\nvar\n\nThe var tool computes the arithmetic variance along the specified axis.\n\nimport numpy\n\nmy_array = numpy.array([ [1, 2], [3, 4] ])\n\nprint numpy.var(my_array, axis = 0)         #Output : [ 1.  1.]\nprint numpy.var(my_array, axis = 1)         #Output : [ 0.25  0.25]\nprint numpy.var(my_array, axis = None)      #Output : 1.25\nprint numpy.var(my_array)                   #Output : 1.25\n\nBy default, the axis is None. Therefore, it computes the variance of the flattened array.\n\nstd\n\nThe std tool computes the arithmetic standard deviation along the specified axis.\n\nimport numpy\n\nmy_array = numpy.array([ [1, 2], [3, 4] ])\n\nprint numpy.std(my_array, axis = 0)         #Output : [ 1.  1.]\nprint numpy.std(my_array, axis = 1)         #Output : [ 0.5  0.5]\nprint numpy.std(my_array, axis = None)      #Output : 1.118033988749895\nprint numpy.std(my_array)                   #Output : 1.118033988749895\n\nBy default, the axis is None. Therefore, it computes the standard deviation of the flattened array.\n\n=====Problem Statement=====\nYou are given a 2-D array of size NXM.\nYour task is to find:\nThe mean along axis 1\nThe var along axis 0\nThe std along axis None\n\n=====Input Format=====\nThe first line contains the space separated values of N and M.\nThe next N lines contains M space separated integers.\n\n=====Output Format=====\nFirst, print the mean.\nSecond, print the var.\nThird, print the std.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def Matrix := Array (Array Float)", "vc-helpers": "", "vc-definitions": "def getRow (A : Matrix) (i : Nat) : Array Float :=\nsorry\n\ndef getCol (A : Matrix) (j : Nat) : Array Float :=\nsorry\n\ndef mean (A : Matrix) : Array Float :=\nsorry\n\ndef var (A : Matrix) : Array Float :=\nsorry\n\ndef std (A : Matrix) : Float :=\nsorry\n\ndef compute_stats (A : Matrix) : Array Float × Array Float × Float :=\nsorry", "vc-theorems": "theorem compute_stats_mean_property (A : Matrix) :\n  let (means, _, _) := compute_stats A\n  means = mean A :=\nsorry\n\ntheorem compute_stats_var_property (A : Matrix) :\n  let (_, vars, _) := compute_stats A\n  vars = var A :=\nsorry\n\ntheorem compute_stats_std_property (A : Matrix) :\n  let (_, _, stdev) := compute_stats A\n  stdev = std A :=\nsorry\n\ntheorem compute_stats_output_shape (A : Matrix) (h1 : A.size > 0) :\n  let (means, vars, _) := compute_stats A\n  means.size = A.size ∧ vars.size = (getRow A 0).size :=\nsorry\n\ntheorem compute_stats_empty (A : Matrix) (h : A.size = 0) :\n  compute_stats A = default :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002481", "vc-description": "/-\n=====Problem Statement=====\nGiven the participants' score sheet for your University Sports Day, you are required to find the runner-up score. You are given n scores. Store them in a list and find the score of the runner-up.\n\n=====Input Format=====\nThe first line contains n. The second line contains an array A[] of n integers each separated by a space.\n\n=====Constraints=====\n2≤n≤10\n-100≤A[i]≤ 100\n\n=====Output Format=====\nPrint the runner-up score.\n-/", "vc-preamble": "def all_lt (x : Int) (l : List Int) : Prop :=\n  ∀ y, y ∈ l → y < x", "vc-helpers": "", "vc-definitions": "def find_runner_up_score (scores: List Int) : Int :=\n  sorry", "vc-theorems": "theorem duplicate_max_case :\n  find_runner_up_score [1, 2, 2] = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 3, 6, 6, 5]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 2, 3, 4, 4]\n\n/--\ninfo: 50\n-/\n#guard_msgs in\n#eval find_runner_up_score [-100, 0, 50, 100, 100]"}
{"id": "fvapps_002482", "vc-description": "/-\n=====Function Descriptions=====\npoly\n\nThe poly tool returns the coefficients of a polynomial with the given sequence of roots.\n\nprint numpy.poly([-1, 1, 1, 10])        #Output : [  1 -11   9  11 -10]\n\nroots\n\nThe roots tool returns the roots of a polynomial with the given coefficients.\n\nprint numpy.roots([1, 0, -1])           #Output : [-1.  1.]\n\npolyint\n\nThe polyint tool returns an antiderivative (indefinite integral) of a polynomial.\n\nprint numpy.polyint([1, 1, 1])          #Output : [ 0.33333333  0.5         1.          0.        ]\n\npolyder\n\nThe polyder tool returns the derivative of the specified order of a polynomial.\n\nprint numpy.polyder([1, 1, 1, 1])       #Output : [3 2 1]\n\npolyval\n\nThe polyval tool evaluates the polynomial at specific value.\n\nprint numpy.polyval([1, -2, 0, 2], 4)   #Output : 34\n\npolyfit\n\nThe polyfit tool fits a polynomial of a specified order to a set of data using a least-squares approach.\n\nprint numpy.polyfit([0,1,-1, 2, -2], [0,1,1, 4, 4], 2)\n#Output : [  1.00000000e+00   0.00000000e+00  -3.97205465e-16]\n\nThe functions polyadd, polysub, polymul, and polydiv also handle proper addition, subtraction, multiplication, and division of polynomial coefficients, respectively.\n\n=====Problem Statement=====\nYou are given the coefficients of a polynomial P.\nYour task is to find the value of P at point x.\n\n=====Input Format=====\nThe first line contains the space separated value of the coefficients in P.\nThe second line contains the value of x.\n\n=====Output Format=====\nPrint the desired value.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def evaluatePolynomial (coeffs : List Float) (x : Float) : Float :=\n  sorry\n\ndef directPolynomial (coeffs : List Float) (x : Float) : Float :=\n  sorry", "vc-theorems": "theorem polynomial_evaluation_matches_direct\n  (coeffs : List Float) (x : Float)\n  (h1 : coeffs.length ≥ 1)\n  (h2 : coeffs.length ≤ 10)\n  (h3 : ∀ c ∈ coeffs, -1000000 ≤ c ∧ c ≤ 1000000)\n  (h4 : -100 ≤ x ∧ x ≤ 100) :\n  evaluatePolynomial coeffs x - directPolynomial coeffs x ≤ 1e-10 * directPolynomial coeffs x :=\nsorry\n\ntheorem polynomial_at_zero\n  (coeffs : List Float)\n  (h1 : coeffs ≠ [])\n  (h2 : coeffs.length ≤ 10)\n  (h3 : ∀ c ∈ coeffs, -1000000 ≤ c ∧ c ≤ 1000000) :\n  evaluatePolynomial coeffs 0 = coeffs.getLast h1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002483", "vc-description": "/-\n=====Problem Statement=====\nA newly opened multinational brand has decided to base their company logo on the three most common characters in the company name. They are now trying out various combinations of company names and logos based on this condition. Given a string s, which is the company name in lowercase letters, your task is to find the top three most common characters in the string.\nPrint the three most common characters along with their occurrence count.\nSort in descending order of occurrence count.\nIf the occurrence count is the same, sort the characters in alphabetical order.\n\nFor example, according to the conditions described above, GOOGLE would have it's logo with the letters G, O, E. \n\n=====Input Format=====\nA single line of input containing the string S.\n\n=====Constraints=====\n3≤len(S)≤10^4\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_top_three_chars (s : String) : String :=\n  sorry\n\ndef String.count (s : String) (c : String) : Nat :=\n  sorry", "vc-theorems": "theorem get_top_three_chars_valid_format (s : String)\n  (h : s.length > 0)\n  (h2 : ∀ c ∈ s.data, c.isLower) :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  1 ≤ lines.length ∧ lines.length ≤ 3 ∧\n  (∀ line ∈ lines, ∃ (char : String) (count : Nat),\n    line = s!\"{char} {count}\" ∧\n    char.length = 1 ∧\n    s.count char = count) ∧\n  (∀ i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    (parts1.get! 1).toNat! ≥ (parts2.get! 1).toNat!) ∧\n  (let chars := lines.map (λ l => (l.splitOn \" \").get! 0);\n   chars.eraseDups = chars) :=\nsorry\n\ntheorem get_top_three_chars_alphabetical_tiebreak (s : String)\n  (h : s.length ≥ 2)\n  (h2 : ∀ c ∈ s.data, c = 'a' ∨ c = 'b') :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  ∀ i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    let count1 := (parts1.get! 1).toNat!;\n    let count2 := (parts2.get! 1).toNat!;\n    let char1 := parts1.get! 0;\n    let char2 := parts2.get! 0;\n    count1 = count2 → char1 > char2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002488", "vc-description": "/-\n=====Function Descriptions=====\n.union()\n\nThe .union() operator returns the union of a set and the set of elements in an iterable.\nSometimes, the | operator is used in place of .union() operator, but it operates only on the set of elements in set.\nSet is immutable to the .union() operation (or | operation).\n\nExample\n\n>>> s = set(\"Hacker\")\n>>> print s.union(\"Rank\")\nset(['a', 'R', 'c', 'r', 'e', 'H', 'k', 'n'])\n\n>>> print s.union(set(['R', 'a', 'n', 'k']))\nset(['a', 'R', 'c', 'r', 'e', 'H', 'k', 'n'])\n\n>>> print s.union(['R', 'a', 'n', 'k'])\nset(['a', 'R', 'c', 'r', 'e', 'H', 'k', 'n'])\n\n>>> print s.union(enumerate(['R', 'a', 'n', 'k']))\nset(['a', 'c', 'r', 'e', (1, 'a'), (2, 'n'), 'H', 'k', (3, 'k'), (0, 'R')])\n\n>>> print s.union({\"Rank\":1})\nset(['a', 'c', 'r', 'e', 'H', 'k', 'Rank'])\n\n>>> s | set(\"Rank\")\nset(['a', 'R', 'c', 'r', 'e', 'H', 'k', 'n'])\n\n=====Problem Statement=====\n\nThe students of District College have subscriptions to English and French newspapers. Some students have subscribed only to English, some have subscribed to only French and some have subscribed to both newspapers.\n\nYou are given two sets of student roll numbers. One set has subscribed to the English newspaper, and the other set is subscribed to the French newspaper. The same student could be in both sets. Your task is to find the total number of students who have subscribed to at least one newspaper.\n\n=====Input Format=====\nThe first line contains an integer, n, the number of students who have subscribed to the English newspaper.\nThe second line contains n space separated roll numbers of those students.\nThe third line contains b, the number of students who have subscribed to the French newspaper.\nThe fourth line contains b space separated roll numbers of those students. \n\n=====Constraints=====\n0 < Total number of students in college < 1000\n\n=====Output Format=====\nOutput the total number of students who have at least one subscription.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def student_union (n1 : Nat) (eng : String) (n2 : Nat) (fre : String) : Nat :=\nsorry\n\ndef stringToList (s : String) : List Int :=\nsorry\n\ndef removeDuplicates (l : List Int) : List Int :=\nsorry", "vc-theorems": "theorem student_union_leq_sum_lengths {n1 n2 : Nat} {eng fre : String} :\n  student_union n1 eng n2 fre ≤ n1 + n2 :=\nsorry\n\ntheorem student_union_equals_union_length {n1 n2 : Nat} {eng fre : String} :\n  ∃ l1 l2 : List Int,\n    l1 = stringToList eng ∧\n    l2 = stringToList fre ∧\n    student_union n1 eng n2 fre = (removeDuplicates (l1 ++ l2)).length :=\nsorry\n\ntheorem student_union_identical_lists {n : Nat} {nums : String} :\n  student_union n nums n nums = (removeDuplicates (stringToList nums)).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval student_union 9 \"1 2 3 4 5 6 7 8 9\" 9 \"10 1 2 3 11 21 55 6 8\"\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"4 5 6\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"1 2 3\""}
{"id": "fvapps_002495", "vc-description": "/-\n=====Function Descriptions=====\ncollections.deque()\nA deque is a double-ended queue. It can be used to add or remove elements from both ends.\n\nDeques support thread safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.\n\nExample\nCode\n>>> from collections import deque\n>>> d = deque()\n>>> d.append(1)\n>>> print d\ndeque([1])\n>>> d.appendleft(2)\n>>> print d\ndeque([2, 1])\n>>> d.clear()\n>>> print d\ndeque([])\n>>> d.extend('1')\n>>> print d\ndeque(['1'])\n>>> d.extendleft('234')\n>>> print d\ndeque(['4', '3', '2', '1'])\n>>> d.count('1')\n1\n>>> d.pop()\n'1'\n>>> print d\ndeque(['4', '3', '2'])\n>>> d.popleft()\n'4'\n>>> print d\ndeque(['3', '2'])\n>>> d.extend('7896')\n>>> print d\ndeque(['3', '2', '7', '8', '9', '6'])\n>>> d.remove('2')\n>>> print d\ndeque(['3', '7', '8', '9', '6'])\n>>> d.reverse()\n>>> print d\ndeque(['6', '9', '8', '7', '3'])\n>>> d.rotate(3)\n>>> print d\ndeque(['8', '7', '3', '6', '9'])\n\n=====Problem Statement=====\nPerform append, pop, popleft and appendleft methods on an empty deque d.\n\n=====Input Format=====\nThe first line contains an integer N, the number of operations.\nThe next N lines contains the space separated names of methods and their values.\n\n=====Constraints=====\n0<N≤100\n\n=====Output Format=====\nPrint the space separated elements of deque d.\n-/", "vc-preamble": "def Operation := String × Int", "vc-helpers": "", "vc-definitions": "def DequeOp := List Operation\n\ndef splitString (s : String) : List String :=\n  sorry\n\ndef process_deque_operations (ops : List String) : String :=\n  sorry", "vc-theorems": "theorem append_only_operations_preserves_length\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\" ∨ (splitString op).get! 0 = \"appendleft\") :\n  (splitString (process_deque_operations ops)).length = ops.length :=\nsorry\n\ntheorem append_only_operations_preserves_elements\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\" ∨ (splitString op).get! 0 = \"appendleft\") :\n  ∃ perm : List String → List String,\n    perm (ops.map (λ op => (splitString op).get! 1)) =\n    splitString (process_deque_operations ops) :=\nsorry\n\ntheorem append_maintains_order\n  (ops : List String)\n  (h1 : ∀ op ∈ ops, (splitString op).get! 0 = \"append\") :\n  (splitString (process_deque_operations ops)) =\n  ops.map (λ op => (splitString op).get! 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1 2'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"append 2\", \"append 3\", \"appendleft 4\", \"pop\", \"popleft\"]\n\n/--\ninfo: '10 15'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 5\", \"appendleft 10\", \"pop\", \"append 15\"]\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"appendleft 2\", \"popleft\", \"pop\"]"}
{"id": "fvapps_002503", "vc-description": "/-\n=====Problem Statement=====\nYou are given a positive integer N.\nYour task is to print a palindromic triangle of size N.\n\nFor example, a palindromic triangle of size 5 is:\n1\n121\n12321\n1234321\n123454321\n\nYou can't take more than two lines. The first line (a for-statement) is already written for you.\nYou have to complete the code using exactly one print statement.\n\nNote:\nUsing anything related to strings will give a score of 0.\nUsing more than one for-statement will give a score of 0.\n\n=====Input Format=====\nA single line of input containing the integer N.\n\n=====Constraints=====\n0<N<10\n\n=====Output Format=====\nPrint the palindromic triangle of size N as explained above.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_palindrome_triangle (n: Nat) : String :=\n  sorry\n\ndef split_lines (s: String) : List String :=\n  sorry", "vc-theorems": "theorem palindrome_triangle_line_count {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.length = n :=\nsorry\n\ntheorem palindrome_triangle_lines_are_palindromes {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ line ∈ lines, line.data = (line.data.reverse) :=\nsorry\n\ntheorem palindrome_triangle_lines_increase {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ i, 0 < i → i < lines.length → (lines.get! i).length > (lines.get! (i-1)).length :=\nsorry\n\ntheorem palindrome_triangle_first_line {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.head! = \"1\" :=\nsorry\n\ntheorem palindrome_triangle_only_digits {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ line ∈ lines, ∀ c ∈ line.data, '0' ≤ c ∧ c ≤ '9' :=\nsorry\n\ntheorem palindrome_triangle_middle_increment {n: Nat} (h: 0 < n) (h2: n ≤ 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  ∀ i, 0 < i → i < lines.length →\n    let line := lines.get! i\n    let mid := line.length / 2\n    ∀ j, j < mid → line.data[j]! = Char.ofNat ((j + 1) + '0'.toNat) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1\\n121\\n12321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 3\n\n/--\ninfo: '1\\n121\\n12321\\n1234321\\n123454321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 5\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 1"}
{"id": "fvapps_002504", "vc-description": "/-\n=====Problem Statement=====\nYou are given a function f(X) = X^2. You are also given K lists. The ith list consists of N_i elements.\n\nYou have to pick one element from each list so that the value from the equation below is maximized:\nS = (f(X_1) + f(X_2) + ... + f(X_k))%M\nX_i denotes the element picked from the ith list. Find the maximized value S_max obtained.\n% denotes the modulo operator.\nNote that you need to take exactly one element from each list, not necessarily the largest element. You add the squares of the chosen elements and perform the modulo operation. The maximum value that you can obtain, will be the answer to the problem.\n\n=====Input Format=====\nThe first line contains 2 space separated integers K and M.\nThe next K lines each contains an integer N_i, denoting the number of elements in the ith list, followed by space separated integers denoting the elements in the list. \n\n=====Constraints=====\n1≤K≤7\n1≤M≤1000\n1≤N_i≤7\n1≤Magnitude of elements in list≤10^9\n\n=====Output Format=====\nOutput a single integer denoting the value S_max.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.product : List (List α) → List (List α)\n  | [] => [[]]\n  | (h :: t) => sorry\n\ndef sum [Add α] (l : List α) : α :=\n  sorry\n\ndef find_max_modular_sum (m : Nat) (lists : List (List Int)) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_modular_sum_bounds (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ []) :\n  let result := find_max_modular_sum m lists\n  0 ≤ result ∧ result < m := by\n  sorry\n\ntheorem find_max_modular_sum_matches_some_combo (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ []) :\n  let result := find_max_modular_sum m lists\n  ∃ combo ∈ List.product lists,\n    sum (combo.map (λ x => x * x)) % m = result := by\n  sorry\n\ntheorem find_max_modular_sum_mod_one (lists : List (List Int))\n    (h1 : lists ≠ [])\n    (h2 : ∀ l ∈ lists, l ≠ []) :\n  find_max_modular_sum 1 lists = 0 := by\n  sorry\n\ntheorem find_max_modular_sum_zeros (m : Nat) (lists : List (List Int))\n    (h1 : m > 1)\n    (h2 : lists ≠ [])\n    (h3 : ∀ l ∈ lists, l ≠ [])\n    (h4 : ∀ l ∈ lists, ∀ x ∈ l, x = 0) :\n  find_max_modular_sum m lists = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 206\n-/\n#guard_msgs in\n#eval find_max_modular_sum 1000 [[5, 4], [7, 8, 9], [5, 7, 8, 9, 10]]\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval find_max_modular_sum 100 [[1, 2], [3, 4]]"}
{"id": "fvapps_002515", "vc-description": "/-\n=====Function Descriptions=====\nPython has built-in string validation methods for basic data. It can check if a string is composed of alphabetical characters, alphanumeric characters, digits, etc.\n\nstr.isalnum()\nThis method checks if all the characters of a string are alphanumeric (a-z, A-Z and 0-9).\n\n>>> print 'ab123'.isalnum()\nTrue\n>>> print 'ab123#'.isalnum()\nFalse\n\nstr.isalpha()\nThis method checks if all the characters of a string are alphabetical (a-z and A-Z).\n\n>>> print 'abcD'.isalpha()\nTrue\n>>> print 'abcd1'.isalpha()\nFalse\n\nstr.isdigit()\nThis method checks if all the characters of a string are digits (0-9).\n\n>>> print '1234'.isdigit()\nTrue\n>>> print '123edsd'.isdigit()\nFalse\n\nstr.islower()\nThis method checks if all the characters of a string are lowercase characters (a-z).\n\n>>> print 'abcd123#'.islower()\nTrue\n>>> print 'Abcd123#'.islower()\nFalse\n\nstr.isupper()\nThis method checks if all the characters of a string are uppercase characters (A-Z).\n\n>>> print 'ABCD123#'.isupper()\nTrue\n>>> print 'Abcd123#'.isupper()\nFalse\n\n=====Problem Statement=====\nYou are given a string S.\nYour task is to find out if the string S contains: alphanumeric characters, alphabetical characters, digits, lowercase and uppercase characters.\n\n=====Input Format=====\nA single line containing a string S.\n\n=====Constraints=====\n0 < len(S) < 1000\n\n=====Output Format=====\nIn the first line, print True if S has any alphanumeric characters. Otherwise, print False.\nIn the second line, print True if S has any alphabetical characters. Otherwise, print False.\nIn the third line, print True if S has any digits. Otherwise, print False.\nIn the fourth line, print True if S has any lowercase characters. Otherwise, print False.\nIn the fifth line, print True if S has any uppercase characters. Otherwise, print False.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlnum (c : Char) : Bool :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef check_string_properties (s : String) : List Bool :=\nsorry", "vc-theorems": "theorem check_string_properties_bool (s : String) :\n  ∀ x ∈ check_string_properties s, x = true ∨ x = false :=\nsorry\n\ntheorem alpha_implies_alnum (s : String) :\n  (check_string_properties s).get! 1 = true → (check_string_properties s).get! 0 = true :=\nsorry\n\ntheorem digit_implies_alnum (s : String) :\n  (check_string_properties s).get! 2 = true → (check_string_properties s).get! 0 = true :=\nsorry\n\ntheorem case_implies_alpha (s : String) :\n  ((check_string_properties s).get! 3 = true ∨ (check_string_properties s).get! 4 = true) →\n  (check_string_properties s).get! 1 = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002516", "vc-description": "/-\n=====Function Descriptions=====\nitertools.combinations_with_replacement(iterable, r)\nThis tool returns\n\nlength subsequences of elements from the input iterable allowing individual elements to be repeated more than once.\n\nCombinations are emitted in lexicographic sorted order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.\n\nSample Code\n\n>>> from itertools import combinations_with_replacement\n>>> \n>>> print list(combinations_with_replacement('12345',2))\n[('1', '1'), ('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '2'), ('2', '3'), ('2', '4'), ('2', '5'), ('3', '3'), ('3', '4'), ('3', '5'), ('4', '4'), ('4', '5'), ('5', '5')]\n>>> \n>>> A = [1,1,3,3,3]\n>>> print list(combinations(A,2))\n[(1, 1), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (3, 3), (3, 3), (3, 3)]\n\n=====Problem Statement=====\nYou are given a string S.\nYour task is to print all possible size k replacement combinations of the string in lexicographic sorted order.\n\n=====Input Format=====\nA single line containing the string S and integer value k separated by a space.\n\n=====Constraints=====\n0<k≤len(S)\nThe string contains only UPPERCASE characters.\n\n=====Output Format=====\nPrint the combinations with their replacements of string S on separate lines.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_combinations_with_replacement (s : String) (k : Nat) : String :=\nsorry\n\ndef is_sorted (s : String) : Bool :=\nsorry\n\ndef all_chars_from (s : String) (chars : String) : Bool :=\nsorry\n\ndef all_length (s : String) (k : Nat) : Bool :=\nsorry\n\ndef no_duplicates (s : String) : Bool :=\nsorry", "vc-theorems": "theorem get_combinations_sorted (s : String) (k : Nat) :\n  is_sorted (get_combinations_with_replacement s k) = true :=\nsorry\n\ntheorem get_combinations_length (s : String) (k : Nat) :\n  all_length (get_combinations_with_replacement s k) k = true :=\nsorry\n\ntheorem get_combinations_chars (s : String) (k : Nat) :\n  all_chars_from (get_combinations_with_replacement s k) s = true :=\nsorry\n\ntheorem get_combinations_unique (s : String) (k : Nat) :\n  no_duplicates (get_combinations_with_replacement s k) = true :=\nsorry\n\ntheorem get_combinations_example1 :\n  get_combinations_with_replacement \"HACK\" 2 = \"AA\\nAC\\nAH\\nAK\\nCC\\nCH\\nCK\\nHH\\nHK\\nKK\" :=\nsorry\n\ntheorem get_combinations_example2 :\n  get_combinations_with_replacement \"XYZ\" 2 = \"XX\\nXY\\nXZ\\nYY\\nYZ\\nZZ\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002532", "vc-description": "/-\nWhat adds up\n===========\n\nGiven three arrays of integers your task is to create an algorithm that finds the numbers in the first two arrays whose sum is equal to any number in the third. The return value should be an array containing the values from the argument arrays that adds up. The sort order of the resulting array is not important. If no combination of numbers adds up return a empty array.\n\n### Example\nA small example: Given the three input arrays `a1 = [1, 2]; a2 = [4,3]; a3 = [6,5,8]`, we need to find the number pairs from `a1` and `a2` that sum up to a number in `a3` and return those three numbers in an array. In this example, the result from the function would be `[[1, 4, 5] , [2, 4, 6], [2, 3, 5]]`.\n```\nGiven three arrays\na1      a2      a3\n 1       4       6          (a1 a2 a3)    (a1 a2 a3)  (a1 a2 a3)\n 2       3       5      =>  [[1, 4, 5] ,  [2, 4, 6],  [2, 3, 5]]\n                 8\n\neach value in the result array contains one part from each of the arguments.\n```\n\n### Testing\nA function `compare_array` is given. This function takes two arrays and compares them invariant of sort order.\n\n```python\ntest.expect(compare_arrays(addsup([1,2], [3,1], [5,4]), [[1,3,4], [2,3,5]]))\n```\n\n### Greater goal\nFor extra honor try and make it as effective as possible. Discuss whats the most effective way of doing this. The fastest way i can do this is in *O(n^2)*. Can you do it quicker?\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def addsup (a1 a2 a3 : List Int) : List (Int × Int × Int) :=\n  sorry\n\ndef compare_arrays (arr1 arr2 : List (List Int)) : Bool :=\n  sorry", "vc-theorems": "theorem addsup_empty_input\n  (a1 a2 a3 : List Int)\n  : (a1 = [] ∨ a2 = []) → addsup a1 a2 a3 = [] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002533", "vc-description": "/-\nIn this Kata, you will check if it is possible to convert a string to a palindrome by changing one character. \n\nFor instance:\n```Haskell\nsolve (\"abbx\") = True, because we can convert 'x' to 'a' and get a palindrome. \nsolve (\"abba\") = False, because we cannot get a palindrome by changing any character. \nsolve (\"abcba\") = True. We can change the middle character. \nsolve (\"aa\") = False \nsolve (\"ab\") = True\n```\n\nGood luck!\n\nPlease also try [Single Character Palindromes](https://www.codewars.com/kata/5a2c22271f7f709eaa0005d3)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\nsorry\n\ndef stringReverse (s : String) : String :=\nsorry\n\ndef getMismatches (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_distance_property (s : String)\n    (h : s.length > 0)\n    (h2 : ∀ c ∈ s.data, c = 'a' ∨ c = 'b' ∨ c = 'c') :\n  let mismatches := getMismatches s\n  solve s = (mismatches = 1 ∨ (mismatches = 0 ∧ s.length % 2 = 1)) :=\nsorry\n\ntheorem solve_symmetry_property (s : String) (h : s.length > 0) :\n  solve s = solve (stringReverse s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbx\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"aa\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"ab\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abcba\""}
{"id": "fvapps_002541", "vc-description": "/-\nYou will be given a vector of strings. You must sort it alphabetically (case-sensitive, and based on the ASCII values of the chars) and then return the first value.\n\nThe returned value must be a string, and have `\"***\"` between each of its letters.\n\nYou should not remove or add elements from/to the array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def two_sort (strings : List String) : String :=\nsorry\n\ndef countSubstring (haystack : String) (needle : String) : Nat :=\nsorry\n\ndef minimum (xs : List String) : String :=\nsorry\n\ndef splitString (s : String) (sep : String) : List String :=\nsorry", "vc-theorems": "theorem two_sort_separator_count (strings : List String)\n  (h : strings.length > 0) :\n  (countSubstring (two_sort strings) \"***\") = (minimum strings).length - 1 :=\nsorry\n\ntheorem two_sort_recovers_min (strings : List String)\n  (h : strings.length > 0) :\n  let result := two_sort strings\n  let parts := splitString result \"***\"\n  (String.join parts) = minimum strings :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'b***i***t***c***o***i***n'\n-/\n#guard_msgs in\n#eval two_sort [\"bitcoin\", \"take\", \"over\", \"the\", \"world\", \"maybe\", \"who\", \"knows\", \"perhaps\"]\n\n/--\ninfo: 'a***r***e'\n-/\n#guard_msgs in\n#eval two_sort [\"turns\", \"out\", \"random\", \"test\", \"cases\", \"are\", \"easier\", \"than\", \"writing\", \"out\", \"basic\", \"ones\"]\n\n/--\ninfo: 'L***e***t***s'\n-/\n#guard_msgs in\n#eval two_sort [\"Lets\", \"all\", \"go\", \"on\", \"holiday\", \"somewhere\", \"very\", \"cold\"]"}
{"id": "fvapps_002549", "vc-description": "/-\nGiven a set of elements (integers or string characters) that may occur more than once, we need to know the amount of subsets that none of their values have repetitions.\nLet's see with an example:\n``` \nset numbers = {1, 2, 3, 4}\n``` \nThe subsets are:\n``` \n{{1}, {2}, {3}, {4}, {1,2}, {1,3}, {1,4}, {2,3}, {2,4},{3,4}, {1,2,3}, {1,2,4}, {1,3,4}, {2,3,4}, {1,2,3,4}} (15 subsets, as you can see the empty set, {}, is not counted)\n``` \nLet's see an example with repetitions of an element:\n```\nset letters= {a, b, c, d, d}\n```\nThe subsets for this case will be:\n```\n{{a}, {b}, {c}, {d}, {a,b}, {a,c}, {a,d}, {b,c}, {b,d},{c,d}, {a,b,c}, {a,b,d}, {a,c,d}, {b,c,d}, {a,b,c,d}} (15 subsets, only the ones that have no repeated elements inside)\n```\n\nThe function ```est_subsets()``` (javascript: ``estSubsets()```) will calculate the number of these subsets.\nIt will receive the array as an argument and according to its features will output the amount of different subsets without repetitions of its elements.\n```python\nest_subsets([1, 2, 3, 4]) == 15\nest_subsets(['a', 'b', 'c', 'd', 'd']) == 15\n```\nFeatures of the random tests:\n```\nLow Performance Tests: 40\nLength of the arrays between 6 and 15\n\nHigh Performance Tests: 80\nLength of the arrays between 15 and 100 (Python an Ruby) and between 15 and 50 javascript)\n```\nJust do it!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def est_subsets {α : Type} [BEq α] [Hashable α] (arr : List α) : Nat :=\n  sorry\n\ndef list_unique_count {α : Type} [BEq α] [Hashable α] (arr : List α) : Nat :=\n  sorry", "vc-theorems": "theorem est_subsets_count_prop {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :=\nsorry\n\ntheorem est_subsets_nonneg {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr ≥ 0 :=\nsorry\n\ntheorem est_subsets_empty {α : Type} [BEq α] [Hashable α] :\n  est_subsets ([] : List α) = 0 :=\nsorry\n\ntheorem est_subsets_duplicates {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = est_subsets (arr ++ arr) :=\nsorry\n\ntheorem est_subsets_is_nat {α : Type} [BEq α] [Hashable α] (arr : List α) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 3, 4]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [\"a\", \"b\", \"c\", \"d\", \"d\"]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 2, 3, 3, 3, 4]"}
{"id": "fvapps_002553", "vc-description": "/-\nCreate a function that takes a string as a parameter and does the following, in this order:\n\n1. replaces every letter with the letter following it in the alphabet (see note below)\n2. makes any vowels capital\n3. makes any consonants lower case\n\n**Note:** the alphabet should wrap around, so `Z` becomes `A`\n\nSo, for example the string `\"Cat30\"` would return `\"dbU30\"` (`Cat30 --> Dbu30 --> dbU30`)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isAlpha : Char → Bool :=\n  sorry\n\ndef changer : String → String :=\n  sorry", "vc-theorems": "theorem changer_length (s : String) :\n  s.length = (changer s).length :=\nsorry\n\ntheorem changer_nonalpha_unchanged {s : String} {i : String.Pos} {c : Char} :\n  c = s.get i → ¬(String.isAlpha c) → (changer s).get i = c :=\nsorry\n\ntheorem changer_empty :\n  changer \"\" = \"\" :=\nsorry\n\ntheorem changer_boundary_case :\n  changer \"abcxyz\" = \"bcdyzA\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'dbU30'\n-/\n#guard_msgs in\n#eval changer \"Cat30\"\n\n/--\ninfo: 'Ifmmp xpsmE'\n-/\n#guard_msgs in\n#eval changer \"Hello World\"\n\n/--\ninfo: 'A'\n-/\n#guard_msgs in\n#eval changer \"z\""}
{"id": "fvapps_002554", "vc-description": "/-\nComplete the method so that it formats the words into a single comma separated value. The last word should be separated by the word 'and' instead of a comma. The method takes in an array of strings and returns a single formatted string. Empty string values should be ignored. Empty arrays or null/nil values being passed into the method should result in an empty string being returned. \n\n```Python\nformat_words(['ninja', 'samurai', 'ronin']) # should return \"ninja, samurai and ronin\"\nformat_words(['ninja', '', 'ronin']) # should return \"ninja and ronin\"\nformat_words([]) # should return \"\"\n```\n```Haskell\nformatWords [\"ninja\", \"samurai\", \"ronin\"] -- should return \"ninja, samurai and ronin\"\nformatWords [\"ninja\", \"\", \"ronin\"] -- should return \"ninja and ronin\"\nformatWords [] -- should return \"\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def format_words (words : List String) : String :=\nsorry\n\ndef String.countSubstr (s1 s2 : String) : Nat :=\nsorry\n\ndef substringExists (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem format_words_empty_filtered :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).isEmpty →\n  format_words words = \"\" :=\nsorry\n\ntheorem format_words_contains_filtered :\n  ∀ (words : List String) (word : String),\n  word ≠ \"\" →\n  word ∈ words →\n  substringExists (format_words words) word = true :=\nsorry\n\ntheorem format_words_single_and :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).length > 1 →\n  substringExists (format_words words) \" and \" = true ∧\n  String.countSubstr (format_words words) \" and \" = 1 :=\nsorry\n\ntheorem format_words_no_and :\n  ∀ (words : List String),\n  (words.filter (fun w => w ≠ \"\")).length ≤ 1 →\n  substringExists (format_words words) \"and\" = false :=\nsorry\n\ntheorem format_words_maintains_order :\n  ∀ (words : List String),\n  ¬(words.filter (fun w => w ≠ \"\")).isEmpty →\n  let filtered := words.filter (fun w => w ≠ \"\")\n  substringExists (format_words words) filtered.head! ∧\n  substringExists (format_words words) filtered.getLast! ∧\n  format_words words = filtered.head! ∨\n  format_words words = filtered.head! ++ \", \" ++ filtered.getLast! ∨\n  format_words words = filtered.head! ++ \" and \" ++ filtered.getLast! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'ninja, samurai and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"samurai\", \"ronin\"]\n\n/--\ninfo: 'ninja'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\"]\n\n/--\ninfo: 'ninja and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"\", \"ronin\"]\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval format_words []"}
{"id": "fvapps_002556", "vc-description": "/-\nYou get a new job working for Eggman Movers.  Your first task is to write a method that will allow the admin staff to enter a person’s name and return what that person's role is in the company.\n\nYou will be given an array of object literals holding the current employees of the company.  You code must find the employee with the matching firstName and lastName and then return the role for that employee or if no employee is not found it should return \"Does not work here!\"\n\nThe array is preloaded and can be referenced using the variable `employees` (`$employees` in Ruby). It uses the following structure.\n\n```python\nemployees = [ {'first_name': \"Dipper\", 'last_name': \"Pines\", 'role': \"Boss\"}, ...... ]\n```\n\nThere are no duplicate names in the array and the name passed in will be a single string with a space between the first and last name i.e. Jane Doe or just a name.\n-/", "vc-preamble": "def valid_roles : List String :=\n  [\"Boss\", \"Truck Driver\", \"Warehouse Manager\", \"Sales Assistant\",\n   \"Admin\", \"Sales Manager\", \"Warehouse Picker\", \"Receptionist\", \"Trainee\"]", "vc-helpers": "", "vc-definitions": "def find_employees_role (name : String) : String :=\n  sorry", "vc-theorems": "theorem known_employee_roles_are_valid (name : String) (h : name.length > 0) :\n  let role := find_employees_role name\n  role = \"Does not work here!\" ∨ role ∈ valid_roles :=\nsorry\n\ntheorem returns_string (name : String) (h : name.length > 0) :\n  String.length (find_employees_role name) > 0 :=\nsorry\n\ntheorem unknown_single_name_returns_not_found (name : String) (h1 : name.length > 0)\n    (h2 : ¬(name.contains ' ')) :\n  find_employees_role name = \"Does not work here!\" :=\nsorry\n\ntheorem name_order_matters (first last : String)\n    (h1 : first.length > 0) (h2 : last.length > 0) :\n  let role1 := find_employees_role (first ++ \" \" ++ last)\n  let role2 := find_employees_role (last ++ \" \" ++ first)\n  (role1 ≠ \"Does not work here!\" ∧ role2 ≠ \"Does not work here!\") →\n  role1 ≠ role2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Truck Driver'\n-/\n#guard_msgs in\n#eval find_employees_role \"Morty Smith\"\n\n/--\ninfo: 'Admin'\n-/\n#guard_msgs in\n#eval find_employees_role \"Anna Bell\"\n\n/--\ninfo: 'Does not work here!'\n-/\n#guard_msgs in\n#eval find_employees_role \"Bell Jewel\""}
{"id": "fvapps_002559", "vc-description": "/-\n#Bubbleing around\n\nSince everybody hates chaos and loves sorted lists we should implement some more sorting algorithms. Your task is to implement a Bubble sort (for some help look at https://en.wikipedia.org/wiki/Bubble_sort) and return a list of snapshots after **each change** of the initial list.\n\ne.g. \n\nIf the initial list would be l=[1,2,4,3] my algorithm rotates l[2] and l[3] and after that it adds [1,2,3,4] to the result, which is a list of snapshots.\n```\n[1,2,4,3] should return [ [1,2,3,4] ]\n[2,1,4,3] should return [ [1,2,4,3], [1,2,3,4] ]\n[1,2,3,4] should return []\n```\n-/\n\n-- Property 1: Each step should be a valid permutation of original list\n\n-- Property 2: Each step should have one or more swaps from previous\n\n-- Property 3: Final state should be sorted\n\n-- Property 4: Number of steps should not exceed inversions\n\n-- Already sorted lists produce empty steps\n\n-- Empty list produces empty steps", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bubble (lst : List Int) : List (List Int) :=\nsorry\n\ndef isSorted (lst : List Int) : Bool :=\nsorry\n\ndef countInversions (lst : List Int) : Nat :=\nsorry", "vc-theorems": "theorem bubble_steps_are_permutations {lst : List Int} {step : List Int} :\n  step ∈ bubble lst → step.length = lst.length :=\nsorry\n\ntheorem bubble_steps_have_swaps {lst : List Int} {i : Nat} (h1 : i < (bubble lst).length) (h2 : i + 1 < (bubble lst).length) :\n  ∃ pos : Nat, pos < lst.length ∧\n    ((bubble lst).get ⟨i, h1⟩).get! pos ≠ ((bubble lst).get ⟨i+1, h2⟩).get! pos :=\nsorry\n\ntheorem bubble_final_step_sorted {lst : List Int} (h : bubble lst ≠ []) :\n  isSorted ((bubble lst).getLast h) :=\nsorry\n\ntheorem bubble_steps_bounded_by_inversions {lst : List Int} :\n  (bubble lst).length ≤ countInversions lst :=\nsorry\n\ntheorem bubble_sorted_empty {lst : List Int} :\n  isSorted lst → bubble lst = [] :=\nsorry\n\ntheorem bubble_empty :\n  bubble [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval bubble []\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval bubble [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n/--\ninfo: [[1, 3, 3, 4, 7, 2], [1, 3, 3, 4, 2, 7], [1, 3, 3, 2, 4, 7], [1, 3, 2, 3, 4, 7], [1, 2, 3, 3, 4, 7]]\n-/\n#guard_msgs in\n#eval bubble [1, 3, 3, 7, 4, 2]"}
{"id": "fvapps_002571", "vc-description": "/-\n# Task\n Given a `sequence` of integers, check whether it is possible to obtain a strictly increasing sequence by erasing no more than one element from it.\n\n# Example\n\n For `sequence = [1, 3, 2, 1]`, the output should be `false`;\n\n For `sequence = [1, 3, 2]`, the output should be `true`.\n\n# Input/Output\n\n - `[input]` integer array `sequence`\n\n    Constraints: `2 ≤ sequence.length ≤ 1000, -10000 ≤ sequence[i] ≤ 10000.`\n\n - `[output]` a boolean value\n\n    `true` if it is possible, `false` otherwise.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def almostIncreasingSequence (seq : List Int) : Bool :=\nsorry\n\ndef countDescendingPairs (seq : List Int) : Nat :=\nsorry\n\ndef isStrictlyIncreasing (seq : List Int) : Bool :=\nsorry\n\ndef countDuplicates (seq : List Int) : Nat :=\nsorry", "vc-theorems": "theorem strictly_increasing_always_true {seq : List Int} :\n  isStrictlyIncreasing seq → almostIncreasingSequence seq :=\nsorry\n\ntheorem duplicate_elements_property {seq : List Int} :\n  countDuplicates seq > 1 → ¬almostIncreasingSequence seq :=\nsorry\n\ntheorem too_many_drops_always_false {seq : List Int} :\n  countDescendingPairs seq > 1 → ¬almostIncreasingSequence seq :=\nsorry\n\ntheorem single_removal_property {seq : List Int} (i : Nat) (h : i < seq.length) :\n  isStrictlyIncreasing (seq.take i ++ seq.drop (i+1)) →\n  almostIncreasingSequence seq :=\nsorry\n\ntheorem single_element_always_true {seq : List Int} :\n  seq.length = 1 → almostIncreasingSequence seq :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2, 1]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 2, 3]"}
{"id": "fvapps_002579", "vc-description": "/-\n# One is the loneliest number\n\n## Task\n\nThe range of vision of a digit is its own value. `1` can see one digit to the left and one digit to the right,` 2` can see two digits, and so on.\n\nThus, the loneliness of a digit `N` is the sum of the digits which it can see.\n\nGiven a non-negative integer, your funtion must determine if there's at least one digit `1` in this integer such that its loneliness value is minimal.\n\n## Example\n\n```\nnumber = 34315\n```\n\ndigit | can see on the left | can see on the right | loneliness\n--- | --- | --- | ---\n3 | - | 431 | 4 + 3 + 1 = 8\n4 | 3 | 315 | 3 + 3 + 1 + 5 = 12\n3 | 34 | 15 | 3 + 4 + 1 + 5 = 13\n1 | 3 | 5 | 3 + 5 = 8\n5 | 3431 | - | 3 + 4 + 3 + 1 = 11\n\nIs there a `1` for which the loneliness is minimal? Yes.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n: Nat) : List Nat :=\nsorry\n\ndef visible_sum (n i: Nat) : Nat :=\nsorry\n\ndef min_visible_sum (n: Nat) : Nat :=\nsorry\n\ndef loneliest (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem loneliest_returns_bool (n: Nat) :\n  loneliest n = true ∨ loneliest n = false :=\nsorry\n\ntheorem loneliest_zero_one :\n  ∀ n: Nat, (∀ d: Nat, d ∈ (digits n) → d = 0 ∨ d = 1) →\n  loneliest n = true ↔ ∃ i, (digits n).get? i = some 1 ∧\n  (∀ j, j ≠ i → (digits n).get? j = some 0) :=\nsorry\n\ntheorem loneliest_same_digit :\n  ∀ n: Nat, (∀ i j: Nat, i < (digits n).length → j < (digits n).length →\n    (digits n).get ⟨i, sorry⟩ = (digits n).get ⟨j, sorry⟩) →\n  loneliest n = true ↔ (digits n).get ⟨0, sorry⟩ = 1 :=\nsorry\n\ntheorem loneliest_no_ones :\n  ∀ n: Nat, (∀ i: Nat, i < (digits n).length → (digits n).get ⟨i, sorry⟩ ≠ 1) →\n  loneliest n = false :=\nsorry\n\ntheorem loneliest_min_loneliness :\n  ∀ n: Nat, loneliest n = true ↔\n  (∃ i: Nat, (digits n).get? i = some 1 ∧\n   visible_sum n i = min_visible_sum n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 34315\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval loneliest 8854778\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 11111"}
{"id": "fvapps_002584", "vc-description": "/-\nGiven an array of integers, return the smallest common factors of all integers in the array.\n\nWhen i say **Smallest Common Factor** i mean the smallest number above 1 that can divide all numbers in the array without a remainder.\n\nIf there are no common factors above 1, return 1 (technically 1 is always a common factor).\n-/", "vc-preamble": "def listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => t.foldl min h\n\npartial def minFactor (n : Nat) : Nat :=\n  if n ≤ 1 then 1 else\n  let rec find (k : Nat) : Nat :=\n    if k * k > n then n\n    else if n % k = 0 then k\n    else find (k + 1)\n  find 2", "vc-helpers": "", "vc-definitions": "def scf (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem scf_basic_properties (nums : List Nat) :\n  let result := scf nums\n  (nums ≠ [] → 1 ≤ result ∧ result ≤ listMin nums) ∧\n  (nums = [] → result = 1) ∧\n  (∀ n ∈ nums, n % result = 0) ∧\n  (result > 1 → ¬ ∃ k, 2 ≤ k ∧ k < result ∧ ∀ n ∈ nums, n % k = 0) :=\nsorry\n\ntheorem scf_identical_numbers (n : Nat) (h : n ≥ 2) :\n  let nums := List.replicate 5 n\n  scf nums = minFactor n :=\nsorry\n\ntheorem scf_nonpositive_inputs (nums : List Nat) (h : ∀ n ∈ nums, n = 0) :\n  scf nums = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval scf [200, 30, 18, 8, 64, 34]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval scf [21, 45, 51, 27, 33]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval scf []"}
{"id": "fvapps_002586", "vc-description": "/-\nThis kata is all about adding numbers.\n\nYou will create a function named add. This function will return the sum of all the arguments. Sounds easy, doesn't it??\n\nWell here's the twist. The inputs will gradually increase with their index as parameter to the function.\n\n```python\n  add(3,4,5) #returns (3*1)+(4*2)+(5*3)=26\n```\nRemember the function will return 0 if no arguments are passed.\n\n## Example\n\n```python\n  add() #=> 0\n  add(1,2,3) #=> 14\n  add(1,4,-5,5) #=> 14\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "structure WeightedSum where\n  index : Nat\n  value : Int\n  deriving Repr\n\ndef makeWeightedSum (xs : List Int) : Int := match xs with\n  | [] => 0\n  | x::xs => x + makeWeightedSum xs", "vc-helpers": "", "vc-definitions": "def add (xs : List Int) : Int :=\nsorry", "vc-theorems": "theorem add_weighted_sum (xs : List Int) (h : xs ≠ []) :\n  ∃ n, add xs = n :=\nsorry\n\ntheorem add_single_number (x : Int) :\n  add [x] = x :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002587", "vc-description": "/-\nIn the following 6 digit number:\n\n```\n283910\n```\n\n`91` is the greatest sequence of 2 consecutive digits.\n\nIn the following 10 digit number:\n```\n1234567890\n```\n\n`67890` is the greatest sequence of 5 consecutive digits.\n\nComplete the solution so that it returns the greatest sequence of five consecutive digits found within the number given. The number will be passed in as a string of only digits. It should return a five digit integer. The number passed may be as large as 1000 digits. \n\n*Adapted from ProjectEuler.net*\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_largest_sequence (s : String) : Nat :=\n  sorry\n\ndef isSubstring (sub str : String) : Bool :=\n  sorry\n\ndef substring (s : String) (start len : Nat) : String :=\n  sorry", "vc-theorems": "theorem short_strings (s : String) :\n  s.length < 5 → find_largest_sequence s = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 98765\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567898765\"\n\n/--\ninfo: 67890\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567890\"\n\n/--\ninfo: 12345\n-/\n#guard_msgs in\n#eval find_largest_sequence \"12345\""}
{"id": "fvapps_002590", "vc-description": "/-\nYou are given a string of numbers between 0-9. Find the average of these numbers and return it as a floored whole number (ie: no decimal places) written out as a string. Eg:\n\n\"zero nine five two\" -> \"four\"\n\nIf the string is empty or includes a number greater than 9, return \"n/a\"\n-/", "vc-preamble": "def numWordsList := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef sum (l : List Nat) : Nat := l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def numToWord (n : Nat) : String :=\nsorry\n\ndef wordToNum (s : String) : Option Nat :=\nsorry\n\ndef average_string (s : String) : String :=\nsorry", "vc-theorems": "theorem average_string_valid_nums (words : List String)\n  (h : ∀ w ∈ words, w ∈ numWordsList) (h2 : words ≠ []) :\n  let nums := words.filterMap wordToNum\n  let avg := sum nums / nums.length\n  average_string (String.intercalate \" \" words) = numToWord avg :=\nsorry\n\ntheorem average_string_empty :\n  average_string \"\" = \"n/a\" :=\nsorry\n\ntheorem average_string_invalid (s : String)\n  (h : ∃ w ∈ s.split (· = ' '), w ∉ numWordsList) :\n  average_string s = \"n/a\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'four'\n-/\n#guard_msgs in\n#eval average_string \"zero nine five two\"\n\n/--\ninfo: 'three'\n-/\n#guard_msgs in\n#eval average_string \"four six two three\"\n\n/--\ninfo: 'n/a'\n-/\n#guard_msgs in\n#eval average_string \"\""}
{"id": "fvapps_002592", "vc-description": "/-\nAs a part of this Kata, you need to create a function that when provided with a triplet, returns the index of the numerical element that lies between the other two elements.\n\nThe input to the function will be an array of three distinct numbers (Haskell: a tuple).\n\nFor example:\n\n    gimme([2, 3, 1]) => 0\n\n*2* is the number that fits between *1* and *3* and the index of *2* in the input array is *0*.\n\nAnother example (just to make sure it is clear):\n\n    gimme([5, 10, 14]) => 1\n\n*10* is the number that fits between *5* and *14* and the index of *10* in the input array is *1*.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gimme (arr : List Float) : Nat :=\n  sorry\n\ndef sort (xs : List Float) : List Float :=\n  sorry\n\ndef sortInt (xs : List Int) : List Int :=\n  sorry\n\ndef gimmeInt (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem gimme_in_range {arr : List Float} (h : arr.length = 3) :\n  let res := gimme arr\n  0 ≤ res ∧ res ≤ 2 :=\nsorry\n\ntheorem gimme_gives_middle {arr : List Float} (h : arr.length = 3) :\n  let sorted := sort arr\n  let res := gimme arr\n  arr[res]! = sorted[1]! :=\nsorry\n\ntheorem gimme_integers_in_range {arr : List Int} (h : arr.length = 3) :\n  let res := gimmeInt arr\n  0 ≤ res ∧ res ≤ 2 :=\nsorry\n\ntheorem gimme_integers_middle {arr : List Int} (h : arr.length = 3) :\n  let sorted := sortInt arr\n  let res := gimmeInt arr\n  arr[res]! = sorted[1]! :=\nsorry\n\ntheorem gimme_preserves_input {arr : List Float} (h : arr.length = 3) :\n  let original := arr\n  let _ := gimme arr\n  arr = original :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [2, 3, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval gimme [5, 10, 14]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [-0.41, -23, 4]"}
{"id": "fvapps_002598", "vc-description": "/-\n###Instructions\n\nWrite a function that takes a negative or positive integer, which represents the number of minutes before (-) or after (+) Sunday midnight, and returns the current day of the week and the current time in 24hr format ('hh:mm') as a string. \n\n```python\nday_and_time(0)       should return 'Sunday 00:00'\nday_and_time(-3)      should return 'Saturday 23:57'\nday_and_time(45)      should return 'Sunday 00:45'\nday_and_time(759)     should return 'Sunday 12:39'\nday_and_time(1236)    should return 'Sunday 20:36'\nday_and_time(1447)    should return 'Monday 00:07'\nday_and_time(7832)    should return 'Friday 10:32'\nday_and_time(18876)   should return 'Saturday 02:36'\nday_and_time(259180)  should return 'Thursday 23:40' \nday_and_time(-349000) should return 'Tuesday 15:20'\n```\n-/\n\n/- For any integer minutes, the output matches expected day/time format -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Output repeats on weekly cycle -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def day_and_time (mins : Int) : String :=\nsorry", "vc-theorems": "theorem day_and_time_valid_format (mins : Int) :\n  let result := day_and_time mins\n  let parts := result.splitOn \" \"\n  let day := parts[0]!\n  let time := parts[1]!\n  let hours_mins := time.splitOn \":\"\n  let hours := hours_mins[0]!.toInt!\n  let minutes := hours_mins[1]!.toInt!\n  parts.length = 2 ∧\n  (day = \"Monday\" ∨ day = \"Tuesday\" ∨ day = \"Wednesday\" ∨\n   day = \"Thursday\" ∨ day = \"Friday\" ∨ day = \"Saturday\" ∨ day = \"Sunday\") ∧\n  0 ≤ hours ∧ hours ≤ 23 ∧\n  0 ≤ minutes ∧ minutes ≤ 59 :=\nsorry\n\ntheorem day_and_time_weekly_cycle (mins : Int) :\n  day_and_time mins = day_and_time (mins + 7*24*60) :=\nsorry", "vc-postamble": "/--\ninfo: 'Sunday 00:00'\n-/\n#guard_msgs in\n#eval day_and_time 0\n\n/--\ninfo: 'Saturday 23:57'\n-/\n#guard_msgs in\n#eval day_and_time -3\n\n/--\ninfo: 'Monday 00:07'\n-/\n#guard_msgs in\n#eval day_and_time 1447"}
{"id": "fvapps_002601", "vc-description": "/-\n## The story you are about to hear is true\nOur cat, Balor, sadly died of cancer in 2015.\n\nWhile he was alive, the three neighborhood cats Lou, Mustache Cat, and Raoul all recognized our house and yard as Balor's territory, and would behave respectfully towards him and each other when they would visit. \n\nBut after Balor died, gradually each of these three neighborhood cats began trying to claim his territory as their own, trying to drive the others away by growling, yowling, snarling, chasing, and even fighting, when one came too close to another, and no human was right there to distract or extract one of them before the situation could escalate. \n\nIt is sad that these otherwise-affectionate animals, who had spent many afternoons peacefully sitting and/or lying near Balor and each other on our deck or around our yard, would turn on each other like that. However, sometimes, if they are far enough away from each other, especially on a warm day when all they really want to do is pick a spot in the sun and lie in it, they will ignore each other, and once again there will be a Peaceable Kingdom.\n\n## Your Mission\nIn this, the first and simplest of a planned trilogy of cat katas :-), all you have to do is determine whether the distances between any visiting cats are large enough to make for a peaceful afternoon, or whether there is about to be an altercation someone will need to deal with by carrying one of them into the house or squirting them with water or what have you.\n\nAs input your function will receive a list of strings representing the yard as a grid, and an integer representing the minimum distance needed to prevent problems (considering the cats' current states of sleepiness). A point with no cat in it will be represented by a \"-\" dash. Lou, Mustache Cat, and Raoul will be represented by an upper case L, M, and R respectively. At any particular time all three cats may be in the yard, or maybe two, one, or even none. \n\nIf the number of cats in the yard is one or none, or if the distances between all cats are at least the minimum distance, your function should return True/true/TRUE (depending on what language you're using), but if there are two or three cats, and the distance between at least two of them is smaller than the minimum distance, your function should return False/false/FALSE.\n\n## Some examples\n(The yard will be larger in the random test cases, but a smaller yard is easier to see and fit into the instructions here.)\n\nIn this first example, there is only one cat, so your function should return True.\n```\n[\"------------\",\n \"------------\",\n \"-L----------\",\n \"------------\",\n \"------------\",\n \"------------\"], 10\n```\nIn this second example, Mustache Cat is at the point yard[1][3] and Raoul is at the point yard[4][7] -- a distance of 5, so because the distance between these two points is smaller than the specified minimum distance of 6, there will be trouble, and your function should return False. \n```\n[\"------------\",\n \"---M--------\",\n \"------------\",\n \"------------\",\n \"-------R----\",\n \"------------\"], 6\n```\nIn this third example, Lou is at yard[0][11], Raoul is at yard[1][2], and Mustache Cat at yard[5][2]. The distance between Lou and Raoul is 9.05538513814, the distance between Raoul and Mustache Cat is 4, and the distance between Mustache Cat and Lou is 10.295630141 -- all greater than or equal to the specified minimum distance of 4, so the three cats will nap peacefully, and your function should return True.\n```\n[\"-----------L\",\n \"--R---------\",\n \"------------\",\n \"------------\",\n \"------------\",\n \"--M---------\"], 4\n```\nHave fun!\n-/\n\n-- minimum distance computation", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def peaceful_yard (yard : List String) (distance : Float) : Bool :=\n  sorry\n\ndef mkRow (n : Nat) : String :=\n  sorry\n\ndef updateRow (s : String) (pos : Nat) (c : Char) : String :=\n  sorry\n\ndef distance (p1 p2 : Nat × Nat) : Float :=\n  sorry\n\ndef replaceNth {α : Type} (xs : List α) (n : Nat) (v : α) : List α :=\n  sorry", "vc-theorems": "theorem empty_yard_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size ≥ 1) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  peaceful_yard yard distance = true :=\nsorry\n\ntheorem single_cat_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size ≥ 1) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  let midPos := size / 2\n  let catRow := updateRow (List.get! yard midPos) midPos 'L'\n  let yard' := replaceNth yard midPos catRow\n  peaceful_yard yard' distance = true :=\nsorry\n\ntheorem cats_distance_property\n  {size : Nat} {distance : Float} {catPositions : List (Nat × Nat × Char)}\n  (h1 : size ≥ 2) (h2 : size ≤ 20)\n  (h3 : distance ≥ 0.1) (h4 : distance ≤ 30)\n  (h5 : catPositions.length ≤ 3)\n  (h6 : ∀ p ∈ catPositions, p.fst < size ∧ (p.snd.fst) < size ∧ (p.snd.snd) ∈ ['L', 'M', 'R']) :\n  let validPositions := catPositions.filter (λ p => p.fst < size ∧ (p.snd.fst) < size)\n  let emptyRow := mkRow size\n  let emptyYard := List.replicate size emptyRow\n  let yard := validPositions.foldl\n    (λ y p => replaceNth y p.fst (updateRow (List.get! y p.fst) (p.snd.fst) (p.snd.snd)))\n    emptyYard\n  peaceful_yard yard distance =\n    if validPositions.length ≤ 1\n    then true\n    else let positions := validPositions.map (λ p => (p.fst, p.snd.fst))\n         let minDist : Float := sorry\n         minDist ≥ distance :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"------------\", \"-L----------\", \"------------\", \"------------\", \"------------\"] 10\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"---M--------\", \"------------\", \"------------\", \"-------R----\", \"------------\"] 6\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"-----------L\", \"--R---------\", \"------------\", \"------------\", \"------------\", \"--M---------\"] 4"}
{"id": "fvapps_002615", "vc-description": "/-\nGiven: an array containing hashes of names\n\nReturn: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.\n\nExample:\n\n``` ruby\nlist([ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ])\n# returns 'Bart, Lisa & Maggie'\n\nlist([ {name: 'Bart'}, {name: 'Lisa'} ])\n# returns 'Bart & Lisa'\n\nlist([ {name: 'Bart'} ])\n# returns 'Bart'\n\nlist([])\n# returns ''\n```\n``` elixir\nlist([ %{name: \"Bart\"}, %{name: \"Lisa\"}, %{name: \"Maggie\"} ])\n# returns 'Bart, Lisa & Maggie'\n\nlist([ %{name: \"Bart\"}, %{name: \"Lisa\"} ])\n# returns 'Bart & Lisa'\n\nlist([ %{name: \"Bart\"} ])\n# returns 'Bart'\n\nlist([])\n# returns ''\n```\n``` javascript\nlist([ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ])\n// returns 'Bart, Lisa & Maggie'\n\nlist([ {name: 'Bart'}, {name: 'Lisa'} ])\n// returns 'Bart & Lisa'\n\nlist([ {name: 'Bart'} ])\n// returns 'Bart'\n\nlist([])\n// returns ''\n```\n```python\nnamelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ])\n# returns 'Bart, Lisa & Maggie'\n\nnamelist([ {'name': 'Bart'}, {'name': 'Lisa'} ])\n# returns 'Bart & Lisa'\n\nnamelist([ {'name': 'Bart'} ])\n# returns 'Bart'\n\nnamelist([])\n# returns ''\n```\n\nNote: all the hashes are pre-validated and will only contain A-Z, a-z, '-' and '.'.\n-/\n\n-- Result contains all original names\n\n-- Has & separator\n\n-- Has correct number of commas\n\n-- Last name appears after &", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def namelist (names : List (String × String)) : String :=\n  sorry\n\ndef containsSubstr (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef String.count (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem namelist_empty_list :\n  namelist [] = \"\" :=\nsorry\n\ntheorem namelist_single_name (name : String) :\n  namelist [(name, \"name\")] = name :=\nsorry\n\ntheorem namelist_multiple_names {n : ℕ} (names : List (String × String))\n  (h1 : names.length > 1)\n  (h2 : ∀ p ∈ names, p.2 = \"name\") :\n  let result := namelist names;\n  let all_names := names.map Prod.fst;\n\n  (∀ name ∈ all_names, containsSubstr result name)\n\n  ∧ containsSubstr result \" & \"\n\n  ∧ (String.count result ',' = names.length - 2)\n\n  ∧ (result.splitOn \" & \").get! 1 = names.getLast?.get!.1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Bart, Lisa & Maggie'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}, {\"name\": \"Maggie\"}]\n\n/--\ninfo: 'Bart & Lisa'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}]\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval namelist []"}
{"id": "fvapps_002618", "vc-description": "/-\nWrite a method that will search an array of strings for all strings that contain another string, ignoring capitalization. Then return an array of the found strings. \n\nThe method takes two parameters, the query string and the array of strings to search, and returns an array. \n\nIf the string isn't contained in any of the strings in the array, the method returns an array containing a single string: \"Empty\" (or `Nothing` in Haskell, or \"None\" in Python and C)\n\n### Examples\nIf the string to search for is \"me\", and the array to search is [\"home\", \"milk\", \"Mercury\", \"fish\"], the method should return [\"home\", \"Mercury\"].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.containsString (s₁ s₂ : String) : Bool :=\n  sorry\n\ndef word_search (query : String) (seq : List String) : List String :=\n  sorry", "vc-theorems": "theorem word_search_returns_nonempty (query : String) (seq : List String) :\n  word_search query seq ≠ [] :=\nsorry\n\ntheorem word_search_none_means_no_matches (query : String) (seq : List String) :\n  word_search query seq = [\"None\"] →\n  ∀ x ∈ seq, ¬(String.containsString (String.toLower x) (String.toLower query)) :=\nsorry\n\ntheorem word_search_results_contain_query (query : String) (seq : List String) :\n  ∀ x ∈ word_search query seq,\n  word_search query seq ≠ [\"None\"] →\n  String.containsString (String.toLower x) (String.toLower query) :=\nsorry\n\ntheorem word_search_results_subset (query : String) (seq : List String) :\n  ∀ x ∈ word_search query seq,\n  word_search query seq ≠ [\"None\"] →\n  x ∈ seq :=\nsorry\n\ntheorem word_search_finds_all_matches (query : String) (seq : List String) :\n  word_search query seq ≠ [\"None\"] →\n  List.length (word_search query seq) =\n  List.length (List.filter (fun x => String.containsString (String.toLower x) (String.toLower query)) seq) :=\nsorry\n\ntheorem word_search_empty_seq (query : String) :\n  word_search query [] = [\"None\"] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"ab\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/--\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"aB\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/--\ninfo: ['None']\n-/\n#guard_msgs in\n#eval word_search \"abcd\" [\"za\", \"aB\", \"Abc\", \"zAB\", \"zbc\"]"}
{"id": "fvapps_002624", "vc-description": "/-\nYour users passwords were all stole in the Yahoo! hack, and it turns out they have been lax in creating secure passwords.  Create a function that checks their new password (passed as a string) to make sure it meets the following requirements:\n\nBetween 8 - 20 characters\n\nContains only the following characters: (and at least one character from each category): uppercase letters, lowercase letters, digits, and the special characters !@#$%^&*?\n\nReturn \"valid\" if passed or else \"not valid\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_password (s : String) : String :=\n  sorry\n\ndef is_special_char (c : Char) : Bool :=\n  sorry\n\ndef has_lowercase (s : String) : Bool :=\n  sorry\n\ndef has_uppercase (s : String) : Bool :=\n  sorry\n\ndef has_digit (s : String) : Bool :=\n  sorry\n\ndef has_special (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem password_too_short {s : String} (h : s.length < 8) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_too_long {s : String} (h : s.length > 20) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_invalid_chars {s : String} (h : ∃ c ∈ s.data,\n  ¬(c.isLower ∨ c.isUpper ∨ c.isDigit ∨ is_special_char c)) :\n  check_password s = \"not valid\" :=\nsorry\n\ntheorem password_missing_required_chars {s : String}\n  (h1 : s.length ≥ 8)\n  (h2 : s.length ≤ 20)\n  (h3 : ∀ c ∈ s.data, (c.isLower ∨ c.isUpper ∨ c.isDigit ∨ is_special_char c))\n  (h4 : ¬(has_lowercase s ∧ has_uppercase s ∧ has_digit s ∧ has_special s)) :\n  check_password s = \"not valid\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"\"\n\n/--\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"Password123\"\n\n/--\ninfo: 'valid'\n-/\n#guard_msgs in\n#eval check_password \"P@ssw0rd123\""}
{"id": "fvapps_002628", "vc-description": "/-\nFind the length between 2 co-ordinates.  The co-ordinates are made of integers between -20 and 20 and will be given in the form of a 2D array:\n\n(0,0) and (5,-7) would be [ [ 0 , 0 ] , [ 5, -7 ] ]\n\nThe function must return the answer rounded to 2 decimal places in the form of a string.\n\n```python\nlength_of_line([[0, 0], [5, -7]]) => \"8.60\"\n```\n\nIf the 2 given co-ordinates are the same, the returned length should be \"0.00\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def length_of_line (coords : List (List Int)) : String :=\nsorry\n\ndef string_to_float (s : String) : Float :=\nsorry\n\ndef int_to_float (i : Int) : Float :=\nsorry", "vc-theorems": "theorem length_matches_pythagorean\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let result := string_to_float (length_of_line coords)\n  let expected := Float.sqrt (int_to_float ((x2 - x1) ^ 2 + (y2 - y1) ^ 2))\n  Float.abs (result - expected) < 0.01 :=\nsorry\n\ntheorem length_commutative\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2) :\n  length_of_line coords = length_of_line [coords[1]!, coords[0]!] :=\nsorry\n\ntheorem same_point_zero\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2) :\n  length_of_line [coords[0]!, coords[0]!] = \"0.00\" :=\nsorry\n\ntheorem triangle_inequality\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let mx := (x1 + x2) / 2\n  let my := (y1 + y2) / 2\n  let midpoint := [mx, my]\n  let result := string_to_float (length_of_line coords)\n  let via_mid := string_to_float (length_of_line [coords[0]!, midpoint]) +\n                 string_to_float (length_of_line [midpoint, coords[1]!])\n  result ≤ via_mid + 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1.41'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [1, 1]]\n\n/--\ninfo: '0.00'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [0, 0]]\n\n/--\ninfo: '13.04'\n-/\n#guard_msgs in\n#eval length_of_line [[-3, 4], [10, 5]]"}
{"id": "fvapps_002630", "vc-description": "/-\nIn mathematics, a [Diophantine equation](https://en.wikipedia.org/wiki/Diophantine_equation) is a polynomial equation, usually with two or more unknowns, such that only the integer solutions are sought or studied.\n\nIn this kata we want to find all integers `x, y` (`x >= 0, y >= 0`) solutions of a diophantine equation of the form:\n#### x^(2) - 4 \\* y^(2) = n\n\n(where the unknowns are `x` and `y`, and `n` is a given positive number)\nin decreasing order of the positive xi. \n\nIf there is no solution return `[]` or `\"[]\" or \"\"`. (See \"RUN SAMPLE TESTS\" for examples of returns).\n\n## Examples:\n\n```\nsolEquaStr(90005) --> \"[[45003, 22501], [9003, 4499], [981, 467], [309, 37]]\"\nsolEquaStr(90002) --> \"[]\"\n```\n\n## Hint:\n\nx^(2) - 4 \\* y^(2) = (x - 2\\*y) \\* (x + 2\\*y)\n-/\n\n/- The solutions to x² - 4y² = n are well-formed lists of pairs of natural numbers -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Each solution pair satisfies the equation x² - 4y² = n -/\n\n/- Solutions contain only positive x values and nonnegative y values -/\n\n/- Solutions are ordered by descending x values -/\n\n/- For n = 90002, there are no solutions -/\n\n/- For n = 5, there is exactly one solution: [[3,1]] -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sol_equa (n : Nat) : List (List Nat) :=\nsorry", "vc-theorems": "theorem sol_equa_well_formed (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    (∀ pair ∈ result, pair.length = 2) :=\nsorry\n\ntheorem sol_equa_satisfies_equation (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ pair ∈ result,\n      pair.get! 0 * pair.get! 0 - 4 * pair.get! 1 * pair.get! 1 = n :=\nsorry\n\ntheorem sol_equa_positive_values (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ pair ∈ result,\n      pair.get! 0 > 0 ∧ pair.get! 1 ≥ 0 :=\nsorry\n\ntheorem sol_equa_ordered (n : Nat) :\n  ∀ result : List (List Nat),\n    result = sol_equa n →\n    ∀ i < result.length - 1,\n      (result.get! i).get! 0 > (result.get! (i+1)).get! 0 :=\nsorry\n\ntheorem sol_equa_90002_empty :\n  sol_equa 90002 = [] :=\nsorry\n\ntheorem sol_equa_5_single :\n  sol_equa 5 = [[3,1]] :=\nsorry", "vc-postamble": "/--\ninfo: [[3, 1]]\n-/\n#guard_msgs in\n#eval sol_equa 5\n\n/--\ninfo: [[45003, 22501], [9003, 4499], [981, 467], [309, 37]]\n-/\n#guard_msgs in\n#eval sol_equa 90005\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval sol_equa 90002"}
{"id": "fvapps_002641", "vc-description": "/-\n### Background\n\nWe **all** know about \"balancing parentheses\" (plus brackets, braces and chevrons) and even balancing characters that are identical.  \n\nRead that last sentence again, I balanced different characters and identical characters twice and you didn't even notice... :)\n\n### Kata\nYour challenge in this kata is to write a piece of code to validate that a supplied string is balanced.\n\nYou must determine if all that is open is then closed, and nothing is closed which is not already open!\n\nYou will be given a string to validate, and a second string, where each pair of characters defines an opening and closing sequence that needs balancing.\n\nYou may assume that the second string always has an even number of characters.\n\n### Example\n```python\n# In this case '(' opens a section, and ')' closes a section\nis_balanced(\"(Sensei says yes!)\", \"()\")       # => True\nis_balanced(\"(Sensei says no!\", \"()\")         # => False\n\n# In this case '(' and '[' open a section, while ')' and ']' close a section\nis_balanced(\"(Sensei [says] yes!)\", \"()[]\")   # => True\nis_balanced(\"(Sensei [says) no!]\", \"()[]\")    # => False\n\n# In this case a single quote (') both opens and closes a section\nis_balanced(\"Sensei says 'yes'!\", \"''\")       # => True\nis_balanced(\"Sensei say's no!\", \"''\")         # => False\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_char (s : String) (c : Char) : Nat :=\nsorry\n\ndef take_prefix (s : String) (n : Nat) : String :=\nsorry\n\ndef is_balanced (s : String) (caps : String) : Bool :=\nsorry", "vc-theorems": "theorem single_char_caps_balance\n  (s : String)\n  (h : s.length > 0) :\n  is_balanced s \"xx\" = ((count_char s 'x') % 2 = 0) :=\nsorry\n\ntheorem empty_caps_always_balanced\n  (s : String) :\n  is_balanced s \"\" = true :=\nsorry\n\ntheorem standard_parens_properties\n  (s : String)\n  (h : is_balanced s \"()\") :\n  (count_char s '(' = count_char s ')') ∧\n  ∀ (p : Nat), p ≤ s.length →\n    count_char (take_prefix s p) '(' ≥ count_char (take_prefix s p) ')' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says yes!)\" \"()\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says no!\" \"()\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"-Hello Mother can you hear me?-\" \"--\""}
{"id": "fvapps_002645", "vc-description": "/-\nA faro shuffle of a deck of playing cards is a shuffle in which the deck is split exactly in half and then the cards in the two halves are perfectly interwoven, such that the original bottom card is still on the bottom and the original top card is still on top.\n\nFor example, faro shuffling the list\n```python\n['ace', 'two', 'three', 'four', 'five', 'six']\n```\ngives\n```python\n['ace', 'four', 'two', 'five', 'three', 'six' ]\n```\n\nIf 8 perfect faro shuffles are performed on a deck of 52 playing cards, the deck is restored to its original order.\n\nWrite a function that inputs an integer n and returns an integer representing the number of faro shuffles it takes to restore a deck of n cards to its original order.\n\nAssume n is an even number between 2 and 2000.\n-/\n\n/- Minimum number of cards (2) requires only one faro cycle -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Faro cycles for even number of cards is always positive -/\n\n/- Standard deck of 52 cards requires exactly 8 faro cycles -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def faro_cycles (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem faro_cycles_min : faro_cycles 2 = 1 :=\nsorry\n\ntheorem faro_cycles_positive_small (n : Nat) :\n  n = 4 ∨ n = 8 → faro_cycles n > 0 :=\nsorry\n\ntheorem faro_cycles_standard_deck : faro_cycles 52 = 8 :=\nsorry", "vc-postamble": "/--\ninfo: 1\n-/\n#guard_msgs in\n#eval faro_cycles 2\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval faro_cycles 52\n\n/--\ninfo: 540\n-/\n#guard_msgs in\n#eval faro_cycles 542"}
{"id": "fvapps_002648", "vc-description": "/-\n##Background - the Collatz Conjecture:\n\nImagine you are given a positive integer, `n`, then:\n\n* if `n` is even, calculate: `n / 2`\n* if `n` is odd, calculate: `3 * n + 1`\n\nRepeat until your answer is `1`. The Collatz conjecture states that performing this operation repeatedly, you will always eventually reach `1`.\n\nYou can try creating Collatz sequences with [this](http://www.codewars.com/kata/5286b2e162056fd0cb000c20) kata. For further information, see the [wiki page](https://en.wikipedia.org/wiki/Collatz_conjecture).\n\n##Now! Your task:\n\n**Given an array of positive integers, return the integer whose Collatz sequence is the longest.**\n\nExample:\n\n```python\nlongest_collatz([2, 4, 3])==3\n```\n\nExplanation: The Collatz sequence for `2` has a length of `1`, the sequence for `4` has a length of `2`, and the sequence for `3` has a length of `7`. So from our array, the integer `3` is the one with the longest Collatz sequence.\n\nHence, your function should return `3`.\n\n##Note:\n\nThere may be more than one answer, i.e. two or more integers produce the longest Collatz sequence, because they happen to have sequences of the same length. **In this case, your function should return the integer that appears first in the array.**\n\nExample:\nGiven an array: `[2, 5, 32]`, both `5` and `32` have Collatz sequences of length 5. These are also the longest sequences from our array.\n\nIn this case, our function returns `5`, because `5` comes before `32` in our array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def collatzLength (n : Nat) : Nat :=\n  sorry\n\ndef longestCollatz (nums : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem longest_collatz_is_member {nums : List Nat} (h : nums ≠ []) :\n  ∀ n, n = longestCollatz nums → n ∈ nums :=\nsorry\n\ntheorem longest_collatz_is_longest {nums : List Nat} (h : nums.length ≥ 2) :\n  ∀ n ∈ nums, n ≠ longestCollatz nums →\n    collatzLength (longestCollatz nums) ≥ collatzLength n :=\nsorry\n\ntheorem identical_numbers_gives_first (n : Nat) (l : List Nat)\n  (h : ∀ x ∈ l, x = n) :\n  longestCollatz l = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [1, 5, 27, 4]\n\n/--\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [64, 64, 27, 64]\n\n/--\ninfo: 75\n-/\n#guard_msgs in\n#eval longest_collatz [75, 226, 113, 340]"}
{"id": "fvapps_002651", "vc-description": "/-\nHere we have a function that help us spam our hearty laughter. But is not working! I need you to find out why...\n\nExpected results:\n\n```python\nspam(1)  ==> \"hue\"\nspam(6)  ==> \"huehuehuehuehuehue\"\nspam(14) ==> \"huehuehuehuehuehuehuehuehuehuehuehuehuehue\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.replicate (n : Nat) (s : String) : String :=\n  sorry\n\ndef spam (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem spam_multiplication (n : Nat) : n ≤ 1000 → spam n = String.replicate n \"hue\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'hue'\n-/\n#guard_msgs in\n#eval spam 1\n\n/--\ninfo: 'huehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 6\n\n/--\ninfo: 'huehuehuehuehuehuehuehuehuehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 14"}
{"id": "fvapps_002657", "vc-description": "/-\nThe citizens of Codeland read each word from right to left, meaning that lexicographical comparison works differently in their language. Namely, string ```a``` is lexicographically smaller than string ```b``` if either: ```a``` is a suffix of ```b``` (in common sense, i.e. ```b``` ends with a substring equal to ```a```); or their last ```k``` characters are the same but the ```(k + 1)th``` character from the right in string ```a``` is smaller than the same character in string ```b```.\n\nGiven an array of words in Codeland language, sort them lexicographically according to Codeland's unique rules.\n\nFor ```words = [\"nigeb\", \"ta\", \"eht\", \"gninnigeb\"]```, the output should be\n```unusualLexOrder(words) = [\"ta\", \"nigeb\", \"gninnigeb\", \"eht\"]```.\n\nIn particular, ```\"ta\" < \"nigeb\"``` because ```'a' < 'b'``` and ```\"nigeb\" < \"gninnigeb\"``` because the former word is a suffix of the latter.\n\nS: codefights.com\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unusual_lex_order (words: List String) : List String :=\n  sorry\n\ndef reverse (s: String) : String :=\n  sorry", "vc-theorems": "theorem output_length_matches_input (words: List String) (h: words.length > 0) :\n  (unusual_lex_order words).length = words.length :=\nsorry\n\ntheorem output_contains_same_elements (words: List String) (h: words.length > 0) :\n  ∀ x, (x ∈ unusual_lex_order words ↔ x ∈ words) :=\nsorry\n\ntheorem reverse_sorted_by_reversed_strings (words: List String) (h: words.length > 0) :\n  ∀ (i: Nat) (h': i + 1 < (unusual_lex_order words).length),\n    let result := unusual_lex_order words\n    Option.isSome (result[i]?) ∧ Option.isSome (result[i+1]?) →\n    reverse (Option.get! result[i]?) ≤ reverse (Option.get! result[i+1]?) :=\nsorry\n\ntheorem idempotent (words: List String) (h: words.length > 0) :\n  unusual_lex_order (unusual_lex_order words) = unusual_lex_order words :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002661", "vc-description": "/-\nCreate a function which answers the question \"Are you playing banjo?\".  \nIf your name starts with the letter \"R\" or lower case \"r\", you are playing banjo!\n\nThe function takes a name as its only argument, and returns one of the following strings:\n```\nname + \" plays banjo\" \nname + \" does not play banjo\"\n```\nNames given are always valid strings.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.hasSubstring (s1 s2 : String) : Bool :=\n  sorry\n\ndef areYouPlayingBanjo (name : String) : String :=\n  sorry", "vc-theorems": "theorem banjo_output_format (name : String) (h : name.length > 0) :\n  let result := areYouPlayingBanjo name\n  result.startsWith name ∧\n  result.endsWith \"banjo\" ∧\n  (result.hasSubstring \" plays banjo\" ∨ result.hasSubstring \" does not play banjo\") :=\nsorry\n\ntheorem starts_with_r_plays_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front = 'r' ∨ name.front = 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" plays banjo\" = true :=\nsorry\n\ntheorem not_r_does_not_play_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front ≠ 'r' ∧ name.front ≠ 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" does not play banjo\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Adam\"\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Ringo\"\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"rolf\""}
{"id": "fvapps_002665", "vc-description": "/-\n*Based on this Numberphile video: https://www.youtube.com/watch?v=Wim9WJeDTHQ*\n\n---\n\nMultiply all the digits of a nonnegative integer `n` by each other, repeating with the product until a single digit is obtained. The number of steps required is known as the **multiplicative persistence**.\n\nCreate a function that calculates the individual results of each step, not including the original number, but including the single digit, and outputs the result as a list/array. If the input is a single digit, return an empty list/array.\n\n## Examples\n```\nper(1)  = []\n\nper(10) = [0]\n// 1*0 = 0\n\nper(69) = [54, 20, 0]\n// 6*9 = 54 --> 5*4 = 20 --> 2*0 = 0\n\nper(277777788888899) = [4996238671872, 438939648, 4478976, 338688, 27648, 2688, 768, 336, 54, 20, 0]\n// 2*7*7*7*7*7*7*8*8*8*8*8*8*9*9 = 4996238671872 --> 4*9*9*6*2*3*8*6*7*1*8*7*2 = 4478976 --> ...\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def per (n : Nat) : List Nat :=\nsorry\n\ndef productOfDigits (n : Nat) : Nat :=\nsorry\n\ndef digitsOfNat (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem per_empty_for_single_digit (n : Nat) :\n  n < 10 → per n = [] :=\nsorry\n\ntheorem per_decreasing {n : Nat} {result : List Nat} :\n  result = per n →\n  ∀ i, ∀ h : i < result.length - 1,\n  result.get ⟨i, sorry⟩ ≥ result.get ⟨i+1, sorry⟩ :=\nsorry\n\ntheorem per_bounded_length (n : Nat) :\n  (per n).length ≤ 100 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval per 1\n\n/--\ninfo: [54, 20, 0]\n-/\n#guard_msgs in\n#eval per 69\n\n/--\ninfo: [4996238671872, 438939648, 4478976, 338688, 27648, 2688, 768, 336, 54, 20, 0]\n-/\n#guard_msgs in\n#eval per 277777788888899"}
{"id": "fvapps_002666", "vc-description": "/-\n# Task\n You are given a string consisting of `\"D\", \"P\" and \"C\"`. A positive integer N is called DPC of this string if it satisfies the following properties: \n\n ```\n For each i = 1, 2, ... , size of the string:\n\n If i-th character is \"D\", then N can be divided by i\n If i-th character is \"P\", then N and i should be relatively prime\n If i-th character is \"C\", then N should neither be divided by i \n                           nor be relatively prime with i```\n\nYour task is to find the smallest DPC of a given string, or return `-1` if there is no such. The result is guaranteed to be `<= 10^9`.\n\n# Example\n For `s = \"DDPDD\"`, the result should be `20`.\n\n `\"DDPDD\"` means `N` should `divided by 1,2,4,5`, and `N,3` should be relatively prime. The smallest N should be `20`.\n\n# Input/Output\n\n - `[input]` string `s`\n\n  The given string\n\n - `[output]` an integer\n\n  The smallest DPC of `s` or `-1` if it doesn't exist.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (a b : Nat) : Nat :=\n  sorry\n\ndef hasDPCProperties (n : Nat) (s : String) : Bool :=\n  sorry\n\ndef dpcSequence (s : String) : Int :=\n  sorry", "vc-theorems": "theorem dpc_satisfies_properties (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result = -1 ∨ (∃ n : Nat, result = n ∧ hasDPCProperties n s) :=\nsorry\n\ntheorem dpc_is_minimal (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result ≠ -1 → ∀ n : Nat, n < result.toNat → ¬hasDPCProperties n s :=\nsorry\n\ntheorem dpc_result_bounds (s : String) (h : s.length > 0 ∧ s.length ≤ 30) :\n  let result := dpcSequence s\n  result = -1 ∨ (1 ≤ result ∧ result ≤ 1000000000) :=\nsorry\n\ntheorem all_divisible_has_solution (s : String)\n  (h1 : s.length > 0 ∧ s.length ≤ 10)\n  (h2 : ∀ c ∈ s.data, c = 'D') :\n  dpcSequence s ≠ -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDPDD\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval dpc_sequence \"DPCPDPPPDCPDPDPC\"\n\n/--\ninfo: 15782844\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDDDPDDCCCDDPDCCPCDCDDPCPCCDDCD\""}
{"id": "fvapps_002667", "vc-description": "/-\n# Task\n\nChristmas is coming, and your task is to build a custom Christmas tree with the specified characters and the specified height.\n\n# Inputs:\n- `chars`: the specified characters. \n- `n`: the specified height. A positive integer greater than 2.\n\n# Output:\n- A multiline string. Each line is separated by `\\n`. A tree contains two parts: leaves and trunks. \n\nThe leaves should be `n` rows. The first row fill in 1 char, the second row fill in 3 chars, and so on. A single space will be added between two adjust chars, and some of the necessary spaces will be added to the left side, to keep the shape of the tree. No space need to be added to the right side.\n\nThe trunk should be at least 1 unit height, it depends on the value of the `n`. The minimum value of n is 3, and the height of the tree trunk is 1 unit height. If `n` increased by 3, and the tree trunk increased by 1 unit. For example, when n is 3,4 or 5, trunk should be 1 row; when n is 6,7 or 8, trunk should be 2 row; and so on.\n\nStill not understand the task? Look at the following example ;-)\n\n# Examples\n\nFor `chars = \"*@o\" and n = 3`,the output should be:\n```\n  *\n @ o\n* @ o\n  |\n```\n\nFor `chars = \"*@o\" and n = 6`,the output should be:\n```\n     *\n    @ o\n   * @ o\n  * @ o *\n @ o * @ o\n* @ o * @ o\n     |\n     |\n```\n\nFor `chars = \"1234\" and n = 6`,the output should be:\n```\n     1\n    2 3\n   4 1 2\n  3 4 1 2\n 3 4 1 2 3\n4 1 2 3 4 1\n     |\n     |\n```\n\nFor `chars = \"123456789\" and n = 3`,the output should be:\n```\n  1\n 2 3\n4 5 6\n  |\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def custom_christmas_tree (chars: String) (n: Nat) : String :=\nsorry\n\ndef splitLines (s: String) : List String :=\nsorry\n\ndef stringLength (s: String) : Nat :=\nsorry\n\ndef stringTrim (s: String) : String :=\nsorry", "vc-theorems": "theorem tree_structure_width (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  ∀ line ∈ splitLines tree, stringLength line ≤ 2 * n :=\nsorry\n\ntheorem trunk_structure (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let trunk_lines := (splitLines tree).drop n\n  (∀ line ∈ trunk_lines, stringTrim line = \"|\") ∧\n  trunk_lines.length = (n-1) / 3 + 1 :=\nsorry\n\ntheorem total_height (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  (splitLines tree).length = n + ((n-1) / 3 + 1) :=\nsorry\n\ntheorem tree_part_nonempty (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let tree_part := (splitLines tree).take n\n  ∀ line ∈ tree_part, stringTrim line ≠ \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002672", "vc-description": "/-\n# Convert number to reversed array of digits\n\nGiven a random non-negative number, you have to return the digits of this number within an array in reverse order.\n\n## Example:\n\n```\n348597 => [7,9,5,8,4,3]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitize (n : Nat) : List Nat :=\n  sorry\n\ndef digitsToNat (digits : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem digitize_single_digits {n : Nat} :\n  ∀ d ∈ digitize n, d ≤ 9 := by\n  sorry\n\ntheorem digitize_length_matches_input {n : Nat} :\n  (List.length (digitize n)) = String.length (toString n) := by\n  sorry\n\ntheorem digitize_reconstruction {n : Nat} :\n  n = digitsToNat (List.reverse (digitize n)) := by\n  sorry\n\ntheorem digitize_preserves_digits {n : Nat} :\n  List.map (fun d => toString d) (digitize n) =\n  (toString n).toList.map toString := by\n  sorry\n\ntheorem digitize_zero :\n  digitize 0 = [0] := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [1, 3, 2, 5, 3]\n-/\n#guard_msgs in\n#eval digitize 35231\n\n/--\ninfo: [7, 5, 3, 2, 8, 5, 3, 2]\n-/\n#guard_msgs in\n#eval digitize 23582357\n\n/--\ninfo: [8, 3, 7, 4, 6, 7, 4, 8, 9]\n-/\n#guard_msgs in\n#eval digitize 984764738"}
{"id": "fvapps_002675", "vc-description": "/-\n##Task:\n\nYou have to write a function **pattern** which creates the following pattern upto n number of rows. \n\n* If the Argument is 0 or a Negative Integer then it should return \"\" i.e. empty string.\n\n* If any odd number is passed as argument then the pattern should last upto the largest even number which is smaller than the passed odd number.\n\n* If the argument is 1 then also it should return \"\".\n\n##Examples:\n\npattern(8):\n\n    22\n    4444\n    666666\n    88888888\n\npattern(5):\n\n    22\n    4444\n\n```Note: There are no spaces in the pattern```\n\n```Hint: Use \\n in string to jump to next line```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef String.lines (s : String) : List String :=\nsorry\n\ndef toString (n : Int) : Char :=\nsorry", "vc-theorems": "theorem non_positive_returns_empty\n  (n : Int)\n  (h : n ≤ 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem output_format_empty\n  (n : Int)\n  (h : n = 1) :\n  pattern n = \"\" :=\nsorry\n\ntheorem output_format_content\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100)\n  (i : Nat)\n  (h3 : i > 0)\n  (h4 : i ≤ n/2) :\n  (pattern n).lines.get! (i-1) = String.mk (List.replicate (2*i) (toString (2*i))) :=\nsorry\n\ntheorem odd_even_equivalence\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100)\n  (h3 : n % 2 = 1) :\n  pattern n = pattern (n-1) :=\nsorry\n\ntheorem line_count\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n ≤ 100) :\n  (pattern n).lines.length = n/2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0\n\n/--\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 5"}
{"id": "fvapps_002676", "vc-description": "/-\nGiven an array of numbers (in string format), you must return a string. The numbers correspond to the letters of the alphabet in reverse order: a=26, z=1 etc. You should also account for `'!'`, `'?'` and `' '` that are represented by '27', '28' and '29' respectively.\n\nAll inputs will be valid.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def switcher (arr : List Nat) : String :=\nsorry\n\ndef is_valid_input (arr : List Nat) : Bool :=\nsorry\n\ndef is_valid_output (s : String) : Bool :=\nsorry\n\ndef expected_map (n : Nat) : String :=\nsorry", "vc-theorems": "theorem switcher_properties (arr : List Nat) :\n  is_valid_input arr →\n  let result := switcher arr\n  (is_valid_output result) ∧\n  (result.length = (arr.filter (· ≠ 0)).length) ∧\n  (result = String.join (arr.map expected_map)) :=\nsorry\n\ntheorem switcher_all_zeros (arr : List Nat) :\n  arr.all (· = 0) →\n  switcher arr = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'codewars'\n-/\n#guard_msgs in\n#eval switcher [\"24\", \"12\", \"23\", \"22\", \"4\", \"26\", \"9\", \"8\"]\n\n/--\ninfo: 'btswmdsbd kkw'\n-/\n#guard_msgs in\n#eval switcher [\"25\", \"7\", \"8\", \"4\", \"14\", \"23\", \"8\", \"25\", \"23\", \"29\", \"16\", \"16\", \"4\"]\n\n/--\ninfo: 'o?bfbtpel'\n-/\n#guard_msgs in\n#eval switcher [\"12\", \"28\", \"25\", \"21\", \"25\", \"7\", \"11\", \"22\", \"15\"]"}
{"id": "fvapps_002691", "vc-description": "/-\n# SpeedCode #2 - Array Madness\n\n## Objective\n\nGiven two **integer arrays** ```a, b```, both of ```length >= 1```, create a program that returns ```true``` if the **sum of the squares** of each element in ```a``` is **strictly greater than** the **sum of the cubes** of each element in ```b```.\n\nE.g.\n```python\narray_madness([4, 5, 6], [1, 2, 3]) => True #because 4 ** 2 + 5 ** 2 + 6 ** 2 > 1 ** 3 + 2 ** 3 + 3 ** 3\n```\nGet your timer out.  Are you ready?  Ready, get set, GO!!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfSquares (l : List Int) : Int :=\n  sorry\n\ndef sumOfCubes (l : List Int) : Int :=\n  sorry\n\ndef array_madness (a b : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem array_madness_correct (a b : List Int) (h1 : a.length > 0) (h2 : b.length > 0) :\n  array_madness a b = (sumOfSquares a > sumOfCubes b) :=\nsorry\n\ntheorem small_numbers_property\n    (a b : List Int)\n    (h1 : a.length > 0)\n    (h2 : b.length > 0)\n    (ha : ∀ x ∈ a, 0 ≤ x ∧ x ≤ 10)\n    (hb : ∀ x ∈ b, 1 ≤ x ∧ x ≤ 10)\n    (h : sumOfSquares a ≤ sumOfCubes b) :\n  array_madness a b = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [4, 5, 6] [1, 2, 3]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval array_madness [1, 2] [2, 3]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [5, 6, 7] [1, 1, 1]"}
{"id": "fvapps_002699", "vc-description": "/-\nPeter can see a clock in the mirror from the place he sits in the office.\nWhen he saw the clock shows 12:22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\nHe knows that the time is 11:38\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\nin the same manner:\n\n05:25 --> 06:35\n\n01:50 --> 10:10\n\n11:58 --> 12:02\n\n12:01 --> 11:59\n\nPlease complete the function `WhatIsTheTime(timeInMirror)`, where `timeInMirror` is the mirrored time (what Peter sees) as string.\n\nReturn the _real_ time as a string.\n\nConsider hours to be between 1 <= hour < 13.\n\nSo there is no 00:20, instead it is 12:20.\n\nThere is no 13:20, instead it is 01:20.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def what_is_the_time (time : String) : String :=\n  sorry\n\ndef is_valid_time (time : String) : Bool :=\n  sorry", "vc-theorems": "theorem mirror_time_format (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  (result.length = 5) ∧\n  (result.data.get ⟨2, by sorry⟩ = ':') ∧\n  (is_valid_time result = true) :=\nsorry\n\ntheorem mirror_time_symmetry (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  what_is_the_time (what_is_the_time time) = time :=\nsorry\n\ntheorem mirror_time_bounds (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  let hour := result.take 2\n  let minute := result.drop 3\n  (1 ≤ String.toNat! hour ∧ String.toNat! hour ≤ 12) ∧\n  (0 ≤ String.toNat! minute ∧ String.toNat! minute ≤ 59) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '05:25'\n-/\n#guard_msgs in\n#eval what_is_the_time \"06:35\"\n\n/--\ninfo: '12:01'\n-/\n#guard_msgs in\n#eval what_is_the_time \"11:59\"\n\n/--\ninfo: '11:58'\n-/\n#guard_msgs in\n#eval what_is_the_time \"12:02\""}
{"id": "fvapps_002702", "vc-description": "/-\n## Task\n An `ATM` ran out of 10 dollar bills and only has `100, 50 and 20` dollar bills.\n\n Given an amount between `40 and 10000 dollars (inclusive)` and assuming that the ATM wants to use as few bills as possible, determinate the minimal number of 100, 50 and 20 dollar bills the ATM needs to dispense (in that order).\n\n## Example\n\n For `n = 250`, the result should be `[2, 1, 0]`.\n\n For `n = 260`, the result should be `[2, 0, 3]`.\n\n For `n = 370`, the result should be `[3, 1, 1]`.\n\n## Input/Output\n\n - `[input]` integer `n`\n  Amount of money to withdraw. Assume that `n` is always exchangeable with `[100, 50, 20]` bills.\n - `[output]` integer array\n  An array of number of `100, 50 and 20` dollar bills needed to complete the withdraw (in that order).\n-/\n\n/- The withdraw function returns a valid solution for multiples of 10 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The withdraw function returns optimal solutions with limited 20s -/\n\n/- The withdraw function uses fifties efficiently -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def withdraw (n : Int) : (Int × Int × Int) :=\nsorry", "vc-theorems": "theorem withdraw_valid (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  hundreds ≥ 0 ∧ fifties ≥ 0 ∧ twenties ≥ 0 ∧\n  hundreds * 100 + fifties * 50 + twenties * 20 = amount :=\nsorry\n\ntheorem withdraw_optimal (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  twenties ≤ 4 :=\nsorry\n\ntheorem withdraw_fifty_efficient (amount : Int) (h : amount ≥ 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  fifties > 0 →\n  let remainder := amount - (hundreds * 100 + fifties * 50)\n  remainder ≥ 0 ∧ remainder % 20 = 0 :=\nsorry", "vc-postamble": "/--\ninfo: [0, 0, 2]\n-/\n#guard_msgs in\n#eval withdraw 40\n\n/--\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval withdraw 250\n\n/--\ninfo: [2, 0, 3]\n-/\n#guard_msgs in\n#eval withdraw 260"}
{"id": "fvapps_002706", "vc-description": "/-\nWrite a program that prints a chessboard with N rows and M columns with the following rules:\nThe top left cell must be an asterisk (*)\nAny cell touching (left, right, up or down) a cell with an asterisk must be a dot (.)\nAny cell touching (left, right, up or down) a cell with a dot must be an asterisk.\n\nA chessboard of 8 rows and 8 columns printed using these rules would be:\n```\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n*.*.*.*.\n.*.*.*.*\n```\nInput\n\nA single line with two integers N and M separated by space. The number N will represent the number of rows and M the number of columns.\n\nOutput\n\nReturn N lines each containing M characters with the chessboard pattern.\nEmpty string if N, M or both are 0.\n\nFrom: 2016 AIPO National Finals\nhttp://aipo.computing.dcu.ie/2016-aipo-national-finals-problems\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def chessboard (n: Nat) (m: Nat) : String :=\nsorry\n\ndef String.lines (s: String) : List String :=\nsorry\n\ndef String.characterAt (s: String) (i: Nat) : Char :=\nsorry", "vc-theorems": "theorem chessboard_empty_for_zero_dims {n m: Nat} :\n  (n = 0 ∨ m = 0) → chessboard n m = \"\" :=\nsorry\n\ntheorem chessboard_dimensions {n m: Nat} (h1 : n ≠ 0) (h2 : m ≠ 0) :\n  let lines := (chessboard n m).lines\n  lines.length = n ∧\n  ∀ l ∈ lines, l.length = m :=\nsorry\n\ntheorem chessboard_alternating_pattern {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let lines := (chessboard n m).lines\n  ∀ i j, i < n → j < m →\n    let line := lines[i]'(by sorry)\n    let char := line.characterAt j\n    ((i + j) % 2 = 0 → char = '*') ∧\n    ((i + j) % 2 ≠ 0 → char = '.') :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval chessboard 0 0\n\n/--\ninfo: '*.\\n.*'\n-/\n#guard_msgs in\n#eval chessboard 2 2\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval chessboard 8 8"}
{"id": "fvapps_002707", "vc-description": "/-\nDNA is a biomolecule that carries genetic information. It is composed of four different building blocks, called nucleotides: adenine (A), thymine (T), cytosine (C) and guanine (G). Two DNA strands join to form a double helix, whereby the nucleotides of one strand bond to the nucleotides of the other strand at the corresponding positions. The bonding is only possible if the nucleotides are complementary: A always pairs with T, and C always pairs with G.\n\nDue to the asymmetry of the DNA, every DNA strand has a direction associated with it. The two strands of the double helix run in opposite directions to each other, which we refer to as the 'up-down' and the 'down-up' directions.\n\nWrite a function `checkDNA` that takes in two DNA sequences as strings, and checks if they are fit to form a fully complementary DNA double helix. The function should return a Boolean `true` if they are complementary, and `false` if there is a sequence mismatch (Example 1 below).\n\nNote:\n\n- All sequences will be of non-zero length, and consisting only of `A`, `T`, `C` and `G` characters.\n- All sequences **will be given in the up-down direction**.\n- The two sequences to be compared can be of different length. If this is the case and one strand is entirely bonded by the other, and there is no sequence mismatch between the two (Example 2 below), your function should still return `true`.\n- If both strands are only partially bonded (Example 3 below), the function should return `false`.\n\nExample 1:\n\nExample 2:\n\nExample 3:\n\n---\n#### If you enjoyed this kata, check out also my other DNA kata: [**Longest Repeated DNA Motif**](http://www.codewars.com/kata/longest-repeated-dna-motif)\n-/\n\n/- The function check_DNA is symmetric: gives same result regardless of argument order -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Empty sequence matches any sequence -/\n\n/- Known complementary sequences match -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_DNA (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem check_DNA_symmetric (s1 s2 : String) :\n  check_DNA s1 s2 = check_DNA s2 s1 :=\nsorry\n\ntheorem check_DNA_empty (s : String) :\n  check_DNA s \"\" = true ∧ check_DNA \"\" s = true :=\nsorry\n\ntheorem check_DNA_basic_complement :\n  check_DNA \"ATGCTACG\" \"CGTAGCAT\" = true :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAT\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"GCTAGCACCCATTAGGAGATAC\" \"CTCCTAATGGGTG\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAA\""}
{"id": "fvapps_002708", "vc-description": "/-\nYou are provided with array of positive non-zero ints and int n representing n-th power (n >= 2).\n\nFor the given array, calculate the sum of each value to the n-th power. Then subtract the sum of the original array.\n\nExample 1: Input: {1, 2, 3}, 3 --> (1 ^ 3 + 2 ^ 3 + 3 ^ 3 ) - (1 + 2 + 3) --> 36 - 6 --> Output: 30\n\nExample 2: Input: {1, 2}, 5  --> (1 ^ 5 + 2 ^ 5) - (1 + 2) --> 33 - 3 --> Output: 30\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (n : Int) : Int :=\n  sorry\n\ndef sum (lst : List Int) : Int :=\n  sorry\n\ndef modified_sum (lst : List Int) (p : Nat) : Int :=\n  sorry", "vc-theorems": "theorem modified_sum_p_one {lst : List Int} (h : lst ≠ []) :\n  modified_sum lst 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2, 3] 3\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2] 5\n\n/--\ninfo: 68\n-/\n#guard_msgs in\n#eval modified_sum [3, 5, 7] 2"}
{"id": "fvapps_002711", "vc-description": "/-\nGiven an array of ints, return the index such that the sum of the elements to the right of that index equals the sum of the elements to the left of that index. If there is no such index, return `-1`. If there is more than one such index, return the left-most index.\n\nFor example: \n```\npeak([1,2,3,5,3,2,1]) = 3, because the sum of the elements at indexes 0,1,2 == sum of elements at indexes 4,5,6. We don't sum index 3.\npeak([1,12,3,3,6,3,1]) = 2\npeak([10,20,30,40]) = -1\n```\n\nThe special case of an array of zeros (for instance `[0,0,0,0]`) will not be tested. \n\nMore examples in the test cases. \n\nGood luck!\n\nPlease also try [Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Int) : Int :=\n  sorry\n\ndef peak (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem peak_equal_sums (arr : List Int) (h_size : arr.length > 0) :\n  let p := peak arr;\n  p ≠ -1 →\n  sum (arr.take (Int.toNat p)) = sum (arr.drop (Int.toNat (p + 1))) :=\nsorry\n\ntheorem peak_bounds (arr : List Int) :\n  let p := peak arr;\n  -1 ≤ p ∧ p < arr.length :=\nsorry\n\ntheorem peak_single_element (arr : List Int) (h : arr.length = 1) :\n  peak arr = 0 :=\nsorry\n\ntheorem peak_empty :\n  peak [] = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval peak [1, 2, 3, 5, 3, 2, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval peak [1, 12, 3, 3, 6, 3, 1]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval peak [10, 20, 30, 40]"}
{"id": "fvapps_002714", "vc-description": "/-\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n Given a string `str` that contains some \"(\" or \")\". Your task is to find the longest substring in `str`(all brackets in the substring are closed). The result is the length of the longest substring.\n\n For example:\n ```\n str = \"()()(\"\n findLongest(str) === 4 \n \"()()\" is the longest substring\n ```\n\n# Note:\n - All inputs are valid.\n - If no such substring found, return 0.\n - Please pay attention to the performance of code. ;-)\n - In the performance test(100000 brackets str x 100 testcases), the time consuming of each test case should be within 35ms. This means, your code should run as fast as a rocket ;-) \n\n# Some Examples\n ```\n findLongest(\"()\") === 2\n findLongest(\"()(\") === 2\n findLongest(\"()()\") === 4\n findLongest(\"()()(\") === 4\n findLongest(\"(()())\") === 6\n findLongest(\"(()(())\") === 6\n findLongest(\"())(()))\") === 4\n findLongest(\"))((\") === 0\n findLongest(\"\") === 0\n ```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findLongest (s : String) : Nat :=\n  sorry\n\ndef isValidParens (s : String) : Bool :=\n  sorry\n\ndef substringFromTo (s : String) (i j : Nat) : String :=\n  sorry", "vc-theorems": "theorem findLongest_valid (s : String) :\n  let result := findLongest s\n  result ≤ s.length ∧\n  result % 2 = 0 :=\nsorry\n\ntheorem findLongest_optimal (s : String) :\n  let result := findLongest s\n  ∀ i j, i < s.length → j ≤ s.length → j > i →\n    let substr := substringFromTo s i j\n    isValidParens substr → substr.length ≤ result :=\nsorry\n\ntheorem findLongest_exists (s : String) :\n  let result := findLongest s\n  result > 0 →\n  ∃ i j, i < s.length ∧ j ≤ s.length ∧ j > i ∧\n    let substr := substringFromTo s i j\n    substr.length = result ∧\n    isValidParens substr :=\nsorry\n\ntheorem findLongest_matched_pairs (n : Nat) :\n  let s := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  findLongest s = 2 * n :=\nsorry\n\ntheorem findLongest_unmatched_surround (n : Nat) :\n  n > 0 →\n  let balanced := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  let s := \")\" ++ balanced ++ \"(\"\n  findLongest s = 2 * n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \")()\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \"((()\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest \"())(()))\""}
{"id": "fvapps_002720", "vc-description": "/-\n# Task\n Miss X has only two combs in her possession, both of which are old and miss a tooth or two. She also has many purses of different length, in which she carries the combs. The only way they fit is horizontally and without overlapping. Given teeth' positions on both combs, find the minimum length of the purse she needs to take them with her.\n\n It is guaranteed that there is at least one tooth at each end of the comb. \n\n - Note, that the combs can not be rotated/reversed.\n\n# Example\n\n For `comb1 = \"*..*\" and comb2 = \"*.*\"`, the output should be `5`\n\n Although it is possible to place the combs like on the first picture, the best way to do this is either picture 2 or picture 3.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/combs/img/cbs.png?_tm=1484930552851)\n\n# Input/Output\n\n - `[input]` string `comb1`\n\n   A comb is represented as a string. If there is an asterisk ('*') in the ith position, there is a tooth there. Otherwise there is a dot ('.'), which means there is a missing tooth on the comb.\n\n   Constraints: 1 ≤ comb1.length ≤ 10.\n\n - `[input]` string `comb2`\n\n   The second comb is represented in the same way as the first one.\n\n   Constraints: 1 ≤ comb2.length ≤ 10.\n\n - `[output]` an integer\n\n   The minimum length of a purse Miss X needs.\n-/\n\n/- The result length is at least as long as the longest input -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The result length is at most the sum of input lengths -/\n\n/- The function is symmetric -/\n\n/- Strings of all dots combine to max length -/\n\n/- Strings of all stars combine to sum of lengths -/\n\n-- represents strings of only * and .", "vc-preamble": "def CombString := String", "vc-helpers": "", "vc-definitions": "def combs (a b : CombString) : Nat :=\nsorry", "vc-theorems": "theorem combs_min_length {a b : CombString} :\n  combs a b ≥ max a.length b.length :=\nsorry\n\ntheorem combs_max_length {a b : CombString} :\n  combs a b ≤ a.length + b.length :=\nsorry\n\ntheorem combs_symmetric {a b : CombString} :\n  combs a b = combs b a :=\nsorry\n\ntheorem combs_all_dots {a b : CombString}\n  (ha : ∀ c, c ∈ a.data → c = '.')\n  (hb : ∀ c, c ∈ b.data → c = '.') :\n  combs a b = max a.length b.length :=\nsorry\n\ntheorem combs_all_stars {a b : CombString}\n  (ha : ∀ c, c ∈ a.data → c = '*')\n  (hb : ∀ c, c ∈ b.data → c = '*') :\n  combs a b = a.length + b.length :=\nsorry", "vc-postamble": "/--\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*..*\" \"*.*\"\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*...*\" \"*.*\"\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval combs \"*..*.*\" \"*.***\""}
{"id": "fvapps_002721", "vc-description": "/-\nGiven an array of numbers, calculate the largest sum of all possible blocks of consecutive elements within the array. The numbers will be a mix of positive and negative values. If all numbers of the sequence are nonnegative, the answer will be the sum of the entire array. If all numbers in the array are negative, your algorithm should return zero. Similarly, an empty array should result in a zero return from your algorithm.\n\n```\nlargestSum([-1,-2,-3]) == 0\nlargestSum([]) == 0\nlargestSum([1,2,3]) == 6\n```\n\nEasy, right? This becomes a lot more interesting with a mix of positive and negative numbers:\n\n```\nlargestSum([31,-41,59,26,-53,58,97,-93,-23,84]) == 187\n```\n\nThe largest sum comes from elements in positions 3 through 7:\n```59+26+(-53)+58+97 == 187```\n\nOnce your algorithm works with these, the test-cases will try your submission with increasingly larger random problem sizes.\n-/", "vc-preamble": "def sum_positives (arr : List Int) : Int :=\n  (arr.filter (fun x => x > 0)).foldl (· + ·) 0\n\ndef is_contiguous_subsequence_sum (arr : List Int) (target : Int) : Bool :=\n  let n := arr.length\n  let indices := List.range n\n  indices.any fun i =>\n    let subSeqLengths := List.range (n - i)\n    subSeqLengths.any fun len =>\n      let subseqSum := (List.range len).foldl (fun sum j =>\n        match arr.get? (i + j) with\n        | none => sum\n        | some v => sum + v\n      ) 0\n      subseqSum = target", "vc-helpers": "", "vc-definitions": "def largest_sum (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem largest_sum_nonnegative (arr : List Int) :\n  largest_sum arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum [-1, -2, -3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum []\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval largest_sum [1, 2, 3]\n\n/--\ninfo: 187\n-/\n#guard_msgs in\n#eval largest_sum [31, -41, 59, 26, -53, 58, 97, -93, -23, 84]"}
{"id": "fvapps_002725", "vc-description": "/-\nAlan's child can be annoying at times.\n\nWhen Alan comes home and tells his kid what he has accomplished today, his kid never believes him. \n\nBe that kid.\n\nYour function 'AlanAnnoyingKid' takes as input a sentence spoken by Alan (a string). The sentence contains the following structure:\n\n    \"Today I \" + [action_verb] + [object] + \".\"\n\n    (e.g.: \"Today I played football.\")\n\nYour function will return Alan's kid response, which is another sentence with the following structure:\n\n    \"I don't think you \" + [action_performed_by_alan] + \" today, I think you \" + [\"did\" OR \"didn't\"] + [verb_of _action_in_present_tense] + [\" it!\" OR \" at all!\"]\n\n    (e.g.:\"I don't think you played football today, I think you didn't play at all!\")\n\nNote the different structure depending on the presence of a negation in Alan's first sentence (e.g., whether Alan says \"I dind't play football\", or \"I played football\").\n\n! Also note: Alan's kid is young and only uses simple, regular verbs that use a simple \"ed\" to make past tense. \nThere are random test cases.\n\nSome more examples:\n\n    input  = \"Today I played football.\"\n    output = \"I don't think you played football today, I think you didn't play at all!\"\n\n    input  = \"Today I didn't attempt to hardcode this Kata.\"\n    output = \"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"\n\n    input  = \"Today I didn't play football.\"\n    output = \"I don't think you didn't play football today, I think you did play it!\"\n\n    input  = \"Today I cleaned the kitchen.\"\n    output = \"I don't think you cleaned the kitchen today, I think you didn't clean at all!\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.substringExists (s : String) (sub : String) : Bool :=\nsorry\n\ndef alan_annoying_kid (phrase : String) : String :=\nsorry\n\ndef String.getWords (s : String) : List String :=\nsorry", "vc-theorems": "theorem alan_preserves_verb (phrase : String) (verb : String)\n  (h₁ : phrase.startsWith \"Today I\")\n  (h₂ : verb ∈ phrase.getWords) :\n  verb ∈ (alan_annoying_kid phrase).getWords :=\nsorry\n\ntheorem alan_response_structure (phrase : String) (h₁ : phrase.startsWith \"Today I\") :\n  let response := alan_annoying_kid phrase\n  response.startsWith \"I don't think you\" ∧\n  response.endsWith \"!\" ∧\n  response.substringExists \"today\" :=\nsorry\n\ntheorem alan_response_negation_negative (phrase : String) (h₁ : phrase.startsWith \"Today I didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you did\" ∧\n  response.substringExists \"it!\" :=\nsorry\n\ntheorem alan_response_negation_positive (phrase : String)\n  (h₁ : phrase.startsWith \"Today I\")\n  (h₂ : ¬phrase.substringExists \"didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you didn't\" ∧\n  response.substringExists \"at all!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I played football.\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I didn\"t play football.\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I cleaned the kitchen.\""}
{"id": "fvapps_002732", "vc-description": "/-\nGiven two arrays, the purpose of this Kata is to check if these two arrays are the same. \"The same\" in this Kata means the two arrays contains arrays of 2 numbers which are same and not necessarily sorted the same way. i.e. [[2,5], [3,6]] is same as [[5,2], [3,6]] or [[6,3], [5,2]] or [[6,3], [2,5]] etc\n\n[[2,5], [3,6]] is NOT the same as [[2,3], [5,6]]\nTwo empty arrays [] are the same\n[[2,5], [5,2]] is the same as [[2,5], [2,5]] but NOT the same as [[2,5]]\n[[2,5], [3,5], [6,2]] is the same as [[2,6], [5,3], [2,5]] or [[3,5], [6,2], [5,2]], etc\nAn array can be empty or contain a minimun of one array of 2 integers and up to 100 array of 2 integers \n\nNote:\n1. [[]] is not applicable because if the array of array are to contain anything, there have to be two numbers.\n2. 100 randomly generated tests that can contains either \"same\" or \"not same\" arrays.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sort (l : List α) : List α :=\n  sorry\n\ndef same (a b : List (List Int)) : Bool :=\n  sorry", "vc-theorems": "theorem same_reflexive (arr : List (List Int)) : same arr arr = true := by\n  sorry\n\ntheorem same_symmetric (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort →\n  same arr_a arr_b = true ∧ same arr_b arr_a = true := by\n  sorry\n\ntheorem same_single_array (nums : List Int) :\n  same [nums] [nums.reverse] = true := by\n  sorry\n\ntheorem same_order_invariant (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort →\n  same arr_a arr_b = true := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval same [[2, 5], [3, 6]] [[5, 2], [3, 6]]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval same [] []\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval same [[2, 3], [3, 2]] [[2, 3]]"}
{"id": "fvapps_002737", "vc-description": "/-\nYou are standing on top of an amazing Himalayan mountain. The view is absolutely breathtaking! you want to take a picture on your phone, but... your memory is full again! ok, time to sort through your shuffled photos and make some space...\n\nGiven a gallery of photos, write a function to sort through your pictures.\nYou get a random hard disk drive full of pics, you must return an array with the 5 most recent ones PLUS the next one (same year and number following the one of the last).\n\nYou will always get at least a photo and all pics will be in the format `YYYY.imgN`\n\nExamples:\n```python\nsort_photos[\"2016.img1\",\"2016.img2\",\"2015.img3\",\"2016.img4\",\"2013.img5\"]) ==[\"2013.img5\",\"2015.img3\",\"2016.img1\",\"2016.img2\",\"2016.img4\",\"2016.img5\"]\nsort_photos[\"2016.img1\"]) ==[\"2016.img1\",\"2016.img2\"]\n```\n-/\n\n-- Helper function to parse year from photo string\n\n-- Helper function to parse image number from photo string\n\n-- Year between 1000-9999\n\n-- Positive image number", "vc-preamble": "def Photo := String\n\ndef Year := Nat\n\ndef ImgNum := Nat\n\ninstance : Inhabited Photo := ⟨\"\"⟩\n\ninstance : LT Year := ⟨Nat.lt⟩\n\ninstance : LT ImgNum := ⟨Nat.lt⟩\n\ninstance : HAdd ImgNum Nat ImgNum := ⟨Nat.add⟩\n\ninstance : LT (Year × ImgNum) := ⟨λ a b => a.1 < b.1 ∨ (a.1 = b.1 ∧ a.2 < b.2)⟩", "vc-helpers": "", "vc-definitions": "def sort_photos (photos : List Photo) : List Photo :=\n  sorry\n\ndef parse_year (photo : Photo) : Year :=\n  sorry\n\ndef parse_imgnum (photo : Photo) : ImgNum :=\n  sorry", "vc-theorems": "theorem sort_photos_length (photos : List Photo) :\n  photos ≠ [] →\n  photos.length > 0 →\n  let result := sort_photos photos\n  result.length = min photos.length 5 + 1 := by\n  sorry\n\ntheorem sort_photos_contains_originals (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ i, i < result.length - 1 → result[i]! ∈ photos := by\n  sorry\n\ntheorem sort_photos_sorted (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ i j, i < j → j < result.length - 1 →\n    (parse_year result[i]!, parse_imgnum result[i]!) <\n    (parse_year result[j]!, parse_imgnum result[j]!) := by\n  sorry\n\ntheorem sort_photos_last_increments (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  parse_year result[result.length-1]! = parse_year result[result.length-2]! ∧\n  parse_imgnum result[result.length-1]! = parse_imgnum result[result.length-2]! + 1 := by\n  sorry\n\ntheorem sort_photos_format_valid (photos : List Photo) :\n  photos ≠ [] →\n  let result := sort_photos photos\n  ∀ p ∈ result, ∃ y n : Nat,\n    y ≥ 1000 ∧ y ≤ 9999 ∧\n    n > 0 ∧\n    parse_year p = y ∧\n    parse_imgnum p = n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\", \"2016.img2\", \"2015.img3\", \"2016.img4\", \"2013.img5\"]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\"]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img4\", \"2016.img5\", \"2016.img1\", \"2016.img3\", \"2016.img2\"]"}
{"id": "fvapps_002749", "vc-description": "/-\n## Description:\n\n Remove all exclamation marks from the end of words. Words are separated by spaces in the sentence.\n\n### Examples\n\n```\nremove(\"Hi!\") === \"Hi\"\nremove(\"Hi!!!\") === \"Hi\"\nremove(\"!Hi\") === \"!Hi\"\nremove(\"!Hi!\") === \"!Hi\"\nremove(\"Hi! Hi!\") === \"Hi Hi\"\nremove(\"!!!Hi !!hi!!! !hi\") === \"!!!Hi !!hi !hi\"\n```\n-/\n\n/- If a word in the input string doesn't contain exclamation marks,\n    it remains unchanged in the output -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- No word in the output string ends with an exclamation mark -/\n\n/- If a word starts with exclamation marks in the input,\n    it starts with the same exclamation marks in the output -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove (s : String) : String :=\n  sorry", "vc-theorems": "theorem words_preserved (s : String) :\n  ∀ w, w ∈ (s.split (· = ' ')) →\n  (¬ ('!' ∈ w.data)) →\n  w ∈ (remove s).split (· = ' ') :=\nsorry\n\ntheorem no_trailing_exclamations (s : String) :\n  ∀ w, w ∈ (remove s).split (· = ' ') →\n  ¬ w.endsWith \"!\" :=\nsorry\n\ntheorem leading_exclamations_preserved (s : String) :\n  ∀ w w', w ∈ s.split (· = ' ') →\n  w' ∈ (remove s).split (· = ' ') →\n  w.startsWith \"!\" → w' = w ∨ w'.startsWith \"!\" :=\nsorry", "vc-postamble": "/--\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!\"\n\n/--\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!!!\"\n\n/--\ninfo: '!Hi'\n-/\n#guard_msgs in\n#eval remove \"!Hi!\"\n\n/--\ninfo: 'Hi Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi! Hi!\"\n\n/--\ninfo: '!!!Hi !!hi !hi'\n-/\n#guard_msgs in\n#eval remove \"!!!Hi !!hi!!! !hi\""}
{"id": "fvapps_002755", "vc-description": "/-\n# Introduction \n\nKa ka ka cypher is a cypher used by small children in some country. When a girl wants to pass something to the other girls and there are some boys nearby, she can use Ka cypher. So only the other girls are able to understand her. \nShe speaks using KA, ie.: \n`ka thi ka s ka bo ka y ka i ka s ka u ka gly` what simply means `this boy is ugly`. \n\n# Task \n\nWrite a function `KaCokadekaMe` (`ka_co_ka_de_ka_me` in Python) that accepts a string word and returns encoded message using ka cypher. \nOur rules:\n- The encoded word should start from `ka`.\n- The `ka` goes after vowel (a,e,i,o,u)\n- When there is multiple vowels together, the `ka` goes only after the last `vowel`\n- When the word is finished by a vowel, do not add the `ka` after\n\n# Input/Output\n\nThe `word` string consists of only lowercase and uppercase characters. There is only 1 word to convert - no white spaces.\n\n# Example\n\n```\nKaCokadekaMe(\"a\");  //=> \"kaa\"\nKaCokadekaMe(\"ka\");  //=> \"kaka\"\nKaCokadekaMe(\"aa\"); //=> \"kaaa\"  \nKaCokadekaMe(\"Abbaa\"); //=> kaAkabbaa\nKaCokadekaMe(\"maintenance\"); //=> kamaikantekanakance\nKaCokadekaMe(\"Woodie\"); //=> kaWookadie\nKacokadekaMe(\"Incomprehensibilities\"); //=> kaIkancokamprekahekansikabikalikatiekas\n```\n\n# Remark\n\nKa cypher's country residents, please don't hate me for simplifying the way how we divide the words into \"syllables\" in the Kata. I don't want to make it too hard for other nations ;-P\n-/\n\n/- Helper functions -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ka_co_ka_de_ka_me (s: String) : String :=\nsorry\n\ndef isVowel (c: Char) : Bool :=\nsorry\n\ndef removeKa (s: String) : String :=\nsorry\n\ndef getConsonants (s: String) : String :=\nsorry", "vc-theorems": "theorem ka_prefix (word: String) :\n  String.isPrefixOf \"ka\" (ka_co_ka_de_ka_me word) :=\nsorry\n\ntheorem length_increases (word: String) :\n  word.length > 0 → (ka_co_ka_de_ka_me word).length > word.length :=\nsorry\n\ntheorem all_vowels (word: String) :\n  (∀ c ∈ word.data, isVowel c) →\n  ka_co_ka_de_ka_me word = \"ka\" ++ word :=\nsorry\n\ntheorem consonants_unchanged (word: String) :\n  getConsonants word = getConsonants (removeKa (ka_co_ka_de_ka_me word)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'kaa'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"a\"\n\n/--\ninfo: 'kamaikantekanakance'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"maintenance\"\n\n/--\ninfo: 'kaIkancokamprekahekansikabikalikatiekas'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"Incomprehensibilities\""}
{"id": "fvapps_002762", "vc-description": "/-\nVery simple, given a number, find its opposite.\n\nExamples:\n```\n1: -1\n14: -14\n-34: 34\n```\n\n~~~if:sql\nYou will be given a table: `opposite`, with a column: `number`. Return a table with a column: `res`.\n~~~\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Same theorems for real numbers -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def opposite (x : Int) : Int :=\nsorry\n\ndef opposite_real (x : Float) : Float :=\nsorry", "vc-theorems": "theorem double_negative_int (x : Int) :\n  opposite (opposite x) = x :=\nsorry\n\ntheorem double_negative_real (x : Float) :\n  opposite_real (opposite_real x) = x :=\nsorry\n\ntheorem zero_is_self_opposite :\n  opposite 0 = 0 :=\nsorry\n\ntheorem nonzero_not_self_opposite (x : Int) :\n  x ≠ 0 → opposite x ≠ x :=\nsorry\n\ntheorem sum_with_opposite_int (x : Int) :\n  x + opposite x = 0 :=\nsorry\n\ntheorem sum_with_opposite_real (x : Float) :\n  x + opposite_real x = 0 :=\nsorry", "vc-postamble": "/--\ninfo: -1\n-/\n#guard_msgs in\n#eval opposite 1\n\n/--\ninfo: 34\n-/\n#guard_msgs in\n#eval opposite -34\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval opposite 0"}
{"id": "fvapps_002763", "vc-description": "/-\nFind the volume of a cone whose radius and height are provided as parameters to the function `volume`. Use the value of PI provided by your language (for example: `Math.PI` in JS, `math.pi` in Python or `Math::PI` in Ruby) and round down the volume to an Interger.\n\nIf you complete this kata and there are no issues, please remember to give it a ready vote and a difficulty rating. :)\n-/", "vc-preamble": "def pi : Float := 3.14159", "vc-helpers": "", "vc-definitions": "def volume (radius height : Float) : Nat :=\n  sorry", "vc-theorems": "theorem volume_zero :\n  volume 0 0 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-- π is approximated as 3.14159 -/\n\n/--\ninfo: 153\n-/\n#guard_msgs in\n#eval volume 7 3\n\n/--\ninfo: 98520\n-/\n#guard_msgs in\n#eval volume 56 30\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval volume 0 0"}
{"id": "fvapps_002766", "vc-description": "/-\nAt the start of each season, every player in a football team is assigned their own unique squad number. Due to superstition or their history certain numbers are more desirable than others.\n\nWrite a function generateNumber() that takes two arguments, an array of the current squad numbers (squad) and the new player's desired number (n). If the new player's desired number is not already taken, return n, else if the desired number can be formed by adding two digits between 1 and 9, return the number formed by joining these two digits together. E.g. If 2 is taken, return 11 because 1 + 1 = 2. Otherwise return null. \n\nNote: Often there will be several different ways to form a replacement number. In these cases the number with lowest first digit should be given priority. E.g. If n = 15, but squad already contains 15, return 69, not 78.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef generate_number (squad : List Nat) (target : Nat) : Option Nat :=\n  sorry", "vc-theorems": "theorem generate_number_bounds {squad : List Nat} {n : Nat} :\n  1 ≤ n → n ≤ 99 →\n  ∀ result, generate_number squad n = some result →\n  1 ≤ result ∧ result ≤ 99 :=\nsorry\n\ntheorem generate_number_not_in_squad {squad : List Nat} {n : Nat} :\n  ∀ result, generate_number squad n = some result →\n  result ∉ squad :=\nsorry\n\ntheorem generate_number_digits_sum {squad : List Nat} {n : Nat} :\n  ∀ result, generate_number squad n = some result →\n  result ≠ n → sumOfDigits result = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 34\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 15, 69] 34\n\n/--\ninfo: 29\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 69] 11\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 38, 47, 56, 65, 69, 74, 83, 92] 11"}
{"id": "fvapps_002770", "vc-description": "/-\n*** No Loops Allowed ***\n\nYou will be given an array (a) and a limit value (limit). You must check that all values in the array are below or equal to the limit value. If they are, return true. Else, return false.\n\nYou can assume all values in the array are numbers.\n\nDo not use loops. Do not modify input array.\n\nLooking for more, loop-restrained fun? Check out the other kata in the series:\n\n https://www.codewars.com/kata/no-loops-2-you-only-need-one\n https://www.codewars.com/kata/no-loops-3-copy-within\n-/", "vc-preamble": "def list_maximum (l : List Int) : Option Int :=\n  l.foldl (fun acc x => match acc with\n    | none => some x\n    | some m => some (max m x)) none", "vc-helpers": "", "vc-definitions": "def small_enough (numbers : List Int) (limit : Int) : Bool :=\n  sorry", "vc-theorems": "theorem small_enough_characterization (numbers : List Int) (limit : Int)\n    (h : numbers ≠ []) :\n  small_enough numbers limit = ((list_maximum numbers).getD 0 ≤ limit) :=\nsorry\n\ntheorem small_enough_at_maximum (numbers : List Int) (h : numbers ≠ []) :\n  let max_val := (list_maximum numbers).getD 0\n  small_enough numbers max_val = true ∧\n  small_enough numbers (max_val - 1) = false :=\nsorry\n\ntheorem small_enough_scaling (numbers : List Int) (factor : Int)\n    (h : numbers ≠ []) (h_pos : factor > 0) :\n  let max_val := (list_maximum numbers).getD 0\n  let scaled_numbers := numbers.map (· * factor)\n  small_enough scaled_numbers (max_val * factor) = small_enough numbers max_val :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [66, 101] 200\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval small_enough [78, 117, 110, 99, 104, 117, 107, 115] 100\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [101, 45, 75, 105, 99, 107] 107"}
{"id": "fvapps_002777", "vc-description": "/-\n# Task\n The year of `2013` is the first year after the old `1987` with only distinct digits.\n\n Now your task is to solve the following problem: given a `year` number, find the minimum year number which is strictly larger than the given one and has only distinct digits.\n\n# Input/Output\n\n - `[input]` integer `year`\n\n `1000 ≤ year ≤ 9000`\n\n - `[output]` an integer\n\n  the minimum year number that is strictly larger than the input number `year` and all its digits are distinct.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (n : Nat) : List Nat :=\nsorry\n\ndef distinctDigitYear (year : Nat) : Nat :=\nsorry\n\ndef hasDistinctDigits (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem distinct_digit_year_greater_than_input (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  distinctDigitYear year > year :=\nsorry\n\ntheorem distinct_digit_year_has_four_digits (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  distinctDigitYear year ≥ 1000 :=\nsorry\n\ntheorem distinct_digit_year_has_distinct_digits (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  hasDistinctDigits (distinctDigitYear year) = true :=\nsorry\n\ntheorem distinct_digit_year_is_minimal (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 9000) :\n  ∀ y, year < y → y < distinctDigitYear year →\n    hasDistinctDigits y = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2013\n-/\n#guard_msgs in\n#eval distinct_digit_year 1987\n\n/--\ninfo: 2014\n-/\n#guard_msgs in\n#eval distinct_digit_year 2013"}
{"id": "fvapps_002785", "vc-description": "/-\n## Task\nGiven an array of strings, reverse them and their order in such way that their length stays the same as the length of the original inputs.\n\n### Example:\n\n```\nInput:  {\"I\", \"like\", \"big\", \"butts\", \"and\", \"I\", \"cannot\", \"lie!\"}\nOutput: {\"!\", \"eilt\", \"onn\", \"acIdn\", \"ast\", \"t\", \"ubgibe\", \"kilI\"}\n```\n\nGood luck!\n-/", "vc-preamble": "def listSum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def reverse_strings (arr : List String) : List String :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem reverse_strings_length_preserved (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  let result := reverse_strings arr\n  (result.length = arr.length) ∧\n  (∀ i, i < arr.length → (result.get ⟨i, sorry⟩).length = (arr.get ⟨i, sorry⟩).length) :=\nsorry\n\ntheorem reverse_strings_is_reversible (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  reverse_strings (reverse_strings arr) = arr :=\nsorry\n\ntheorem reverse_strings_total_chars_preserved (arr : List String)\n  (h : ∀ s ∈ arr, s.length > 0) :\n  let result := reverse_strings arr\n  (listSum (arr.map String.length)) = (listSum (result.map String.length)) ∧\n  String.reverse (String.join arr) = String.join result :=\nsorry\n\ntheorem reverse_strings_single_char (arr : List String)\n  (h : ∀ s ∈ arr, s.length = 1) :\n  String.join (reverse_strings arr) = String.reverse (String.join arr) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_strings [\"I\", \"like\", \"big\", \"butts\", \"and\", \"I\", \"cannot\", \"lie!\"]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_strings [\"?kn\", \"ipnr\", \"utotst\", \"ra\", \"tsn\", \"iksr\", \"uo\", \"yer\", \"ofebta\", \"eote\", \"vahu\", \"oyodpm\", \"ir\", \"hsyn\", \"amwoH\"]"}
{"id": "fvapps_002787", "vc-description": "/-\n# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and return who wins the fight. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3\n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3\n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.\n\n# Example\n\n# Alphabet war Collection\n\nAlphavet war \n\nAlphabet war - airstrike - letters massacre\n\nAlphabet wars - reinforces massacre\n\nAlphabet wars - nuclear strike\n\nAlphabet war - Wo lo loooooo priests join the war\n-/", "vc-preamble": "def valid_letters := ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']\n\ndef score_map (c : Char) : Int :=\n  match c with\n  | 'w' => 4\n  | 'p' => 3\n  | 'b' => 2\n  | 's' => 1\n  | 'm' => -4\n  | 'q' => -3\n  | 'd' => -2\n  | 'z' => -1\n  | _ => 0", "vc-helpers": "", "vc-definitions": "def alphabet_war (s : String) : String :=\nsorry", "vc-theorems": "theorem alphabet_war_valid_output (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_invalid_chars (s : String) :\n  alphabet_war s = \"Left side wins!\" ∨\n  alphabet_war s = \"Right side wins!\" ∨\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_scoring (s : String) (h : s.all (λ c => c ∈ valid_letters)) :\n  let score := s.foldr (λ c acc => acc + score_map c) 0\n  if score > 0 then\n    alphabet_war s = \"Left side wins!\"\n  else if score < 0 then\n    alphabet_war s = \"Right side wins!\"\n  else\n    alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ntheorem alphabet_war_opposing_sides (left right : String)\n  (h1 : left.all (λ c => c ∈ ['w', 'p', 'b', 's']))\n  (h2 : right.all (λ c => c ∈ ['m', 'q', 'd', 'z'])) :\n  alphabet_war (left ++ right) = \"Left side wins!\" ∨\n  alphabet_war (left ++ right) = \"Right side wins!\" ∨\n  alphabet_war (left ++ right) = \"Let's fight again!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/--\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"wq\"\n\n/--\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"zdqmwpbs\""}
{"id": "fvapps_002793", "vc-description": "/-\nGiven a lowercase string that has alphabetic characters only and no spaces, return the highest value of consonant substrings. Consonants are any letters of the alphabet except `\"aeiou\"`. \n\nWe shall assign the following values: `a = 1, b = 2, c = 3, .... z = 26`.\n\nFor example, for the word \"zodiacs\", let's cross out the vowels. We get: \"z **~~o~~** d **~~ia~~** cs\"\n\nFor C: do not mutate input.\n\nMore examples in test cases. Good luck!\n\nIf you like this Kata, please try:\n\n[Word values](https://www.codewars.com/kata/598d91785d4ce3ec4f000018)\n\n[Vowel-consonant lexicon](https://www.codewars.com/kata/59cf8bed1a68b75ffb000026)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Int :=\nsorry\n\ndef isVowel (c : Char) : Bool :=\nsorry\n\ndef isConsonant (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem solve_returns_nonnegative (s : String) :\n  solve s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 26\n-/\n#guard_msgs in\n#eval solve \"zodiac\"\n\n/--\ninfo: 57\n-/\n#guard_msgs in\n#eval solve \"strength\"\n\n/--\ninfo: 73\n-/\n#guard_msgs in\n#eval solve \"catchphrase\""}
{"id": "fvapps_002795", "vc-description": "/-\nA high school has a strange principal. On the first day, he has his students perform an odd opening day ceremony:\n\nThere are number of lockers \"n\" and number of students \"n\" in the school. The principal asks the first student to go to every locker and open it. Then he has the second student go to every second locker and close it. The third goes to every third locker and, if it is closed, he opens it, and if it is open, he closes it. The fourth student does this to every fourth locker, and so on. After the process is completed with the \"n\"th student, how many lockers are open?\n\nThe task is to write a function which gets any number as an input and returns the number of open lockers after last sudent complets his activity. So input of the function is just one number which shows number of lockers and number of students. For example if there are 1000 lockers and 1000 students in school then input is 1000 and function returns number of open lockers after 1000th student completes his action.\n\nThe given input is always an integer greater than or equal to zero that is why there is no need for validation.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef num_of_open_lockers (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem num_open_lockers_is_floor_sqrt (n : Nat) :\n  num_of_open_lockers n = sqrt n :=\nsorry\n\ntheorem num_open_lockers_nonnegative (n : Nat) :\n  num_of_open_lockers n ≥ 0 :=\nsorry\n\ntheorem num_open_lockers_squared_bound (n : Nat) :\n  (num_of_open_lockers n) * (num_of_open_lockers n) ≤ n :=\nsorry\n\ntheorem num_open_lockers_next_squared_bound (n : Nat) :\n  (num_of_open_lockers n + 1) * (num_of_open_lockers n + 1) > n :=\nsorry\n\ntheorem num_open_lockers_zero :\n  num_of_open_lockers 0 = 0 :=\nsorry\n\ntheorem num_open_lockers_one :\n  num_of_open_lockers 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval num_of_open_lockers 0\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval num_of_open_lockers 4\n\n/--\ninfo: 22\n-/\n#guard_msgs in\n#eval num_of_open_lockers 500"}
{"id": "fvapps_002798", "vc-description": "/-\nIn this Kata, you will be given an array of numbers in which two numbers occur once and the rest occur only twice. Your task will be to return the sum of the numbers that occur only once. \n\nFor example, `repeats([4,5,7,5,4,8]) = 15` because only the numbers `7` and `8` occur once, and their sum is `15`.\n\nMore examples in the test cases. \n\n```if:csharp\nDocumentation:\nKata.Repeats Method (List<Int32>)\n\nTakes a list where all ints are repeated twice, except two ints, and returns the sum of the ints of a list where those ints only occur once.\n\nSyntax\n\npublic\nstatic\nint Repeats(\nList<int> source\n    )\n\nParameters\n\nsource\n\nType: System.Collections.Generic.List<Int32>\nThe list to process.\n\nReturn Value\n\nType: System.Int32\n  The sum of the elements of the list where those elements have no duplicates.\n\n```\n\nGood luck!\n\nIf you like this Kata, please try: \n\n[Sum of prime-indexed elements](https://www.codewars.com/kata/59f38b033640ce9fc700015b)\n\n[Sum of integer combinations](https://www.codewars.com/kata/59f3178e3640cef6d90000d5)\n-/", "vc-preamble": "def sumList : List Int → Int\n  | [] => 0\n  | (h::t) => h + sumList t\n\ndef countList (x : Int) : List Int → Nat\n  | [] => 0\n  | (h::t) => (if h = x then 1 else 0) + countList x t\n\ninductive Perm : List Int → List Int → Prop where\n  | nil : Perm [] []\n  | cons : (x : Int) → {l₁ l₂ : List Int} → Perm l₁ l₂ → Perm (x::l₁) (x::l₂)", "vc-helpers": "", "vc-definitions": "def repeats (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem repeats_singles {arr : List Int} (h : arr.length ≥ 1) :\n  repeats arr = sumList (arr.filter (fun x => countList x arr = 1)) :=\nsorry\n\ntheorem repeats_duplicate_array {arr : List Int} (h : arr.length ≥ 1) :\n  repeats (arr ++ arr) = 0 :=\nsorry\n\ntheorem repeats_permutation {arr₁ arr₂ : List Int}\n  (h₁ : arr₁.length ≥ 2)\n  (h₂ : Perm arr₁ arr₂) :\n  repeats arr₁ = repeats arr₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval repeats [4, 5, 7, 5, 4, 8]\n\n/--\ninfo: 19\n-/\n#guard_msgs in\n#eval repeats [9, 10, 19, 13, 19, 13]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval repeats [16, 0, 11, 4, 8, 16, 0, 11]"}
{"id": "fvapps_002804", "vc-description": "/-\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #29\n\nYour friend Nhoj has dislexia, but can easily read messages if the words are written backwards.  \nCreate a function called `reverseSentence()/reverse_sentence()` that accepts a string argument. The function returns a string of the same length with each word reversed, but still in their original order.\n\n```python\nreverse_sentence(\"Hello !Nhoj Want to have lunch?\") # \"olleH johN! tnaW ot evah ?hcnul\"\n```\nNote:  \nA \"word\" should be considered a string split by a space character, \" \"\nLetter capitalization should be maintained.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.reverse (s : String) : String :=\nsorry\n\ndef split (s : String) (sep : String) : List String :=\nsorry\n\ndef reverse_sentence (s : String) : String :=\nsorry", "vc-theorems": "theorem word_count_preserved (words : List String) :\n  let sentence := \" \".intercalate words\n  let reversed := reverse_sentence sentence\n  (split sentence \" \").length = (split reversed \" \").length :=\nsorry\n\ntheorem empty_string :\n  reverse_sentence \"\" = \"\" :=\nsorry\n\ntheorem each_word_reversed (s : String) :\n  let original_words := split s \" \"\n  let result_words := split (reverse_sentence s) \" \"\n  ∀ i, i < original_words.length →\n    result_words[i]! = String.reverse original_words[i]! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_sentence \"Hello !Nhoj Want to have lunch?\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_sentence \"CodeWars rules!\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval reverse_sentence \"\""}
{"id": "fvapps_002809", "vc-description": "/-\nI found this interesting interview question just today:\n\n> *8 coins are given where all the coins have equal weight, except one. The odd one weights less than the others, not being of pure gold. In the worst case, how many iterations are actually needed to find the odd one out on a two plates scale*.\n\nI am asking you then to tell me what is the *minimum* amount of weighings it will take to measure `n` coins in every possible occurrence (including worst case scenario, ie: without relying on luck at all).\n\n`n` is guaranteed to be a positive integer.\n\n***Tip:*** being able to think *recursively* might help here :p\n\n***Note:*** albeit this is more clearly a logical than a coding problem, do not underestimate (or under-rank) the kata for requiring not necessarily wizard-class coding skills: a good coder is a master of pattern recognition and subsequent optimization ;)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def how_many_measurements (n : Nat) : Nat :=\n  sorry\n\ndef log3ceil (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem measurements_non_negative (n : Nat) (h : n > 0) :\n  how_many_measurements n ≥ 0 :=\nsorry\n\ntheorem measurements_sufficient (n : Nat) (h : n > 0) :\n  3^(how_many_measurements n) ≥ n :=\nsorry\n\ntheorem edge_case_one :\n  how_many_measurements 1 = 0 :=\nsorry\n\ntheorem edge_case_two :\n  how_many_measurements 2 = 1 :=\nsorry\n\ntheorem edge_case_three :\n  how_many_measurements 3 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval how_many_measurements 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 3\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval how_many_measurements 8\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval how_many_measurements 100"}
{"id": "fvapps_002810", "vc-description": "/-\nA forest fire has been spotted at *fire*, a simple 2 element array with x, y coordinates.\n\nThe forest service has decided to send smoke jumpers in by plane and drop them in the forest.\n\nThe terrain is dangerous and surveyors have determined that there are three possible safe *dropzones*, an array of three simple arrays with x, y coordinates. \n\nThe plane is en route and time is of the essence. Your mission is to return a simple [x,y] array with the coordinates of the dropzone closest to the fire. \n\nEDIT: \nThe airplane is leaving from the origin at 0,0. If your result returns two possible dropzones that are both an equal distance from the fire, choose the dropzone that is closest to 0,0.\n\nIf the two dropzones are both equal distance away from 0,0, then return the dropzone that is first in the given array. \n\nFor example, if you are given: fire = [1,1], possibleDZ = [0,1],[1,0],[2,2] . The answer is [0,1] because that is the first possible drop zone in the given array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def dropzone (fire : List Int) (dropzones : List (List Int)) : List Int :=\nsorry\n\ndef hypot (x y : Int) : Float :=\nsorry\n\ndef isClosestToFire (point fire : List Int) (points : List (List Int)) : Bool :=\nsorry\n\ndef isClosestToOrigin (point fire : List Int) (points : List (List Int)) : Bool :=\nsorry", "vc-theorems": "theorem dropzone_is_valid_point (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 → dropzone fire dropzones ∈ dropzones :=\nsorry\n\ntheorem dropzone_is_closest_to_fire (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 →\n  isClosestToFire (dropzone fire dropzones) fire dropzones = true :=\nsorry\n\ntheorem dropzone_is_closest_to_origin (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 → dropzones.length > 0 →\n  isClosestToOrigin (dropzone fire dropzones) fire dropzones = true :=\nsorry\n\ntheorem single_dropzone (fire dropzone_single : List Int) :\n  fire.length = 2 → dropzone_single.length = 2 →\n  dropzone fire [dropzone_single] = dropzone_single :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [7, 9]\n-/\n#guard_msgs in\n#eval dropzone [6, 8] [[3, 2], [6, 1], [7, 9]]\n\n/--\ninfo: [5, 5]\n-/\n#guard_msgs in\n#eval dropzone [9, 2] [[1, 4], [9, 9], [5, 5]]\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval dropzone [1, 1] [[0, 1], [1, 0], [2, 2]]"}
{"id": "fvapps_002812", "vc-description": "/-\n# A History Lesson\n\nThe Pony Express was a mail service operating in the US in 1859-60.\n\nIt reduced the time for messages to travel between the Atlantic and Pacific coasts to about 10 days, before it was made obsolete by the [transcontinental telegraph](https://en.wikipedia.org/wiki/First_transcontinental_telegraph).\n\n# How it worked\n\nThere were a number of *stations*, where:\n\n* The rider switched to a fresh horse and carried on, or\n* The mail bag was handed over to the next rider\n\n# Kata Task\n\n`stations` is a list/array of distances (miles) from one station to the next along the Pony Express route.\n\nImplement the `riders` method/function, to return how many riders are necessary to get the mail from one end to the other.\n\n**NOTE:** Each rider travels as far as he can, but never more than 100 miles.\n\n---\n*Good Luck.\nDM.*\n\n---\n\nSee also\n\n* The Pony Express\n* The Pony Express (missing rider)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def riders (stations : List Nat) : Nat :=\n  sorry\n\ndef calc_min_riders (stations: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem riders_positive (stations: List Nat) :\n  stations.all (fun x => x > 0 ∧ x ≤ 100) →\n  riders stations > 0 :=\nsorry\n\ntheorem riders_bounded (stations: List Nat) :\n  stations.all (fun x => x > 0 ∧ x ≤ 100) →\n  riders stations ≤ stations.length + 1 :=\nsorry\n\ntheorem riders_short_distances (stations: List Nat) :\n  stations.all (fun x => x ≤ 1) →\n  riders stations = 1 :=\nsorry\n\ntheorem riders_long_distances (stations: List Nat) :\n  stations.all (fun x => x ≥ 99 ∧ x ≤ 100) →\n  (riders stations = stations.length ∨ riders stations = stations.length + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval riders [18, 15]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval riders [43, 23, 40, 13]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval riders [33, 8, 16, 47, 30, 30, 46]"}
{"id": "fvapps_002823", "vc-description": "/-\nDefine two functions: `hex_to_bin` and `bin_to_hex` (or `hexToBin` and `binToHex`)\n\n# hex_to_bin\n\nTakes a hexadecimal string as an argument .\n\n**Note:** This string can contain upper or lower case characters and start with any amount of zeros.\n\nReturns the binary representation (without leading zeros) of the numerical value of the hexadecimal string.\n\nExamples:\n\n```\n\"00F\"    -->  \"1111\"\n\"5\"      -->  \"101\"\n\"00000\"  -->  \"0\"\n\"04D2\"   -->  \"10011010010\"\n```\n\n# bin_to_hex\n\nTakes a binary string (with or without leading zeros) as an argument .\n\nReturns the hexadecimal representation of the numerical value of the binary string.\n\n**Note:** Any non-numerical characters should be lower case\n\nExamples:\n\n```\n\"1111\"         -->  \"f\"\n\"000101\"       -->  \"5\"\n\"10011010010\"  -->  \"4d2\"\n```\n\n**Note:** You can assume all arguments are valid so there is no need for error checking.\n\nOh, and I've disabled a few things.\n\nAny feedback would be much appreciated\n-/\n\n-- Helper for theorem statement", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin_to_hex (b : String) : String :=\nsorry\n\ndef hex_to_bin (h : String) : String :=\nsorry\n\ndef is_hex_digit (c : Char) : Bool :=\nsorry", "vc-theorems": "def is_hex_string (s : String) : Bool :=\n  s.all is_hex_digit\n\ntheorem hex_to_bin_roundtrip (h : String) :\n  is_hex_string h →\n  bin_to_hex (hex_to_bin h) =\n    if h = \"\" then \"0\"\n    else if h = \"0\" then \"0\"\n    else h :=\nsorry\n\ntheorem empty_and_zero_bin_to_hex :\n  bin_to_hex \"\" = \"0\" ∧\n  bin_to_hex \"0\" = \"0\" :=\nsorry\n\ntheorem empty_and_zero_hex_to_bin :\n  hex_to_bin \"\" = \"0\" ∧\n  hex_to_bin \"0\" = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '5'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000101\"\n\n/--\ninfo: '4d2'\n-/\n#guard_msgs in\n#eval bin_to_hex \"10011010010\"\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000\"\n\n/--\ninfo: '1111'\n-/\n#guard_msgs in\n#eval hex_to_bin \"00F\"\n\n/--\ninfo: '101'\n-/\n#guard_msgs in\n#eval hex_to_bin \"5\"\n\n/--\ninfo: '10011010010'\n-/\n#guard_msgs in\n#eval hex_to_bin \"04D2\""}
{"id": "fvapps_002826", "vc-description": "/-\nGiven a natural number n, we want to know in how many ways we may express these numbers as product of other numbers.\n\nFor example the number\n```python\n 18 = 2 x 9 = 3 x 6 = 2 x 3 x 3 # (we do not consider the product 18 x 1), (3 ways) \n```\n\nSee this example a bit more complicated,\n```python\n60 = 2 x 30 = 3 x 20 =  4 x 15 = 5 x 12 = 6 x 10 = 2 x 2 x 15 = 2 x 3 x 10 = 2 x 5 x 6 =  3 x 4 x 5 = 2 x 2 x 3 x 5 (10 ways)\n```\nWe need the function ```prod_int_part()```, that receives a number n, and ouputs the amount of total different products with all the products of max length sorted in this way:\n\n1) each product will be expressed in a list of its factors in incresing order from left to right\n\n2) if there is more than one list-product, these lists should be ordered by the value of the first term, if two lists have the same term equal thay should be ordered by the value of the second term.\n\nLet's see some cases:\n```python\nprod_int_part(18) == [3, [2, 3, 3]]\n\nprod_int_part(60) == [10, [2, 2, 3, 5]\n```\n\nIf we have only one list-product with the maximum length, there is no use to have it with two nested braces, so the result will be like this case:\n```python\nprod_int_part(54) == [6, [2, 3, 3, 3]]\n```\n\nNow, let's see examples when ```n``` cannot be partitioned:\n```python\nprod_int_part(37) == [0, []]\n\nprod_int_part(61) == [0, []]\n```\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def prod_int_part (n: Nat) (min: Nat := 2) : Nat × List Nat :=\nsorry\n\ndef isPrime (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem prod_int_part_output_structure (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.1 ≥ 0 ∧ result.2.all (λ x => x ≥ 2) :=\nsorry\n\ntheorem prime_numbers_return_empty (n: Nat) (h: n ≥ 2) :\n  isPrime n → prod_int_part n = (0, []) :=\nsorry\n\ntheorem factors_multiply_to_input (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.2 ≠ [] → result.2.foldl (·*·) 1 = n :=\nsorry\n\ntheorem factors_are_ordered (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part n\n  result.2.length > 1 →\n  ∀ i, i < result.2.length - 1 →\n  result.2[i]! ≤ result.2[i+1]! :=\nsorry\n\ntheorem min_parameter_respects_boundary (n min: Nat) (h1: n ≥ 2) (h2: min ≥ 2) :\n  let result := prod_int_part n min\n  result.2.all (λ x => x ≥ min) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [3, [2, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 18\n\n/--\ninfo: [10, [2, 2, 3, 5]]\n-/\n#guard_msgs in\n#eval prod_int_part 60\n\n/--\ninfo: [6, [2, 3, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 54\n\n/--\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 37\n\n/--\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 61"}
{"id": "fvapps_002827", "vc-description": "/-\nYou have to build a pyramid.\n\nThis pyramid should be built from characters from a given string.\n\nYou have to create the code for these four methods:\n```python\nwatch_pyramid_from_the_side(characters):\n\nwatch_pyramid_from_above(characters):\n\ncount_visible_characters_of_the_pyramid(characters):\n\ncount_all_characters_of_the_pyramid(characters):\n```\n\nThe first method (\"FromTheSide\") shows the pyramid as you would see from the side.\nThe second method (\"FromAbove\") shows the pyramid as you would see from above.\nThe third method (\"CountVisibleCharacters\") should return the count of all characters, that are visible from outside the pyramid.\nThe forth method (\"CountAllCharacters\") should count all characters of the pyramid. Consider that the pyramid is completely solid and has no holes or rooms in it.\n\nEvery character will be used for building one layer of the pyramid. So the length of the given string will be the height of the pyramid. Every layer will be built with stones from the given character. There is no limit of stones.\nThe pyramid should have perfect angles of 45 degrees.\n\nExample: Given string: \"abc\"\n\nPyramid from the side:\n```\n  c\n bbb\naaaaa\n```\nPyramid from above:\n```\naaaaa\nabbba\nabcba\nabbba\naaaaa\n```\nCount of visible stones/characters: \n```\n25\n```\nCount of all used stones/characters:\n```\n35\n```\n\nThere is no meaning in the order or the choice of the characters. It should work the same for example \"aaaaa\" or \"54321\".\n\nHint: Your output for the side must always be a rectangle! So spaces at the end of a line must not be deleted or trimmed!\n\nIf the string is null or empty, you should exactly return this value for the watch-methods and -1 for the count-methods.\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have created other katas. Have a look if you like coding and challenges.\n-/\n\n-- Empty inputs theorem\n\n-- Visible characters theorem", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def watch_pyramid_from_the_side (chars : Option String) : Option String :=\nsorry\n\ndef watch_pyramid_from_above (chars : Option String) : Option String :=\nsorry\n\ndef count_visible_characters_of_the_pyramid (chars : Option String) : Int :=\nsorry\n\ndef count_all_characters_of_the_pyramid (chars : Option String) : Int :=\nsorry", "vc-theorems": "theorem empty_inputs {chars : Option String} :\n  chars = none ∨ chars = some \"\" →\n  watch_pyramid_from_the_side chars = chars ∧\n  watch_pyramid_from_above chars = chars ∧\n  count_visible_characters_of_the_pyramid chars = -1 ∧\n  count_all_characters_of_the_pyramid chars = -1 :=\nsorry\n\ntheorem count_visible_chars {s : String} (h : s.length > 0) :\n  count_visible_characters_of_the_pyramid (some s) =\n    (2 * s.length - 1) * (2 * s.length - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side None\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid None\n\n/--\ninfo: expected_side\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"abc\"\n\n/--\ninfo: expected_above\n-/\n#guard_msgs in\n#eval watch_pyramid_from_above test_str\n\n/--\ninfo: 25\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid test_str\n\n/--\ninfo: 35\n-/\n#guard_msgs in\n#eval count_all_characters_of_the_pyramid test_str"}
{"id": "fvapps_002828", "vc-description": "/-\nYour task is to write function which takes string and list of delimiters as an input and returns list of strings/characters after splitting given string.\n\nExample:\n```python\nmultiple_split('Hi, how are you?', [' ']) => ['Hi,', 'how', 'are', 'you?']\nmultiple_split('1+2-3', ['+', '-']) => ['1', '2', '3']\n```\n\nList of delimiters is optional and can be empty, so take that into account.\n\nImportant note: Result cannot contain empty string.\n-/\n\n-- placeholder split", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multiple_split (s : String) (delims : List String) : List String :=\n  sorry\n\ndef containsString (s : String) (sub : String) : Bool :=\n  sorry", "vc-theorems": "theorem multiple_split_nonempty_parts\n  (s : String) (delims : List String)\n  : ∀ (x : String), x ∈ multiple_split s delims → x.length > 0\n  := by\nsorry\n\ntheorem multiple_split_no_delims_in_result\n  (s : String) (delims : List String)\n  : ∀ (x : String) (d : String),\n    x ∈ multiple_split s delims →\n    d ∈ delims →\n    ¬ containsString x d\n  := by\nsorry\n\ntheorem multiple_split_empty_string\n  (delims : List String)\n  : multiple_split \"\" delims = []\n  := by\nsorry\n\ntheorem multiple_split_empty_delims\n  (s : String)\n  : multiple_split s [] = if s = \"\" then [] else [s]\n  := by\nsorry\n\ntheorem multiple_split_single_delim\n  (s : String) (delim : String)\n  (h : delim.length > 0)\n  : multiple_split s [delim] = (s.split (· == '.')).filter (fun x => x ≠ \"\")\n  := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['Hi', 'everybody']\n-/\n#guard_msgs in\n#eval multiple_split \"Hi everybody!\" [\" \", \"!\"]\n\n/--\ninfo: ['1', '2', '3']\n-/\n#guard_msgs in\n#eval multiple_split \"1+2-3\" [\"+\", \"-\"]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval multiple_split \"\" []"}
{"id": "fvapps_002829", "vc-description": "/-\n# Task\n Given an array of 2^(k) integers (for some integer `k`), perform the following operations until the array contains only one element:\n```\nOn the 1st, 3rd, 5th, etc. \niterations (1-based) replace each pair of consecutive elements with their sum;\nOn the 2nd, 4th, 6th, etc. \niterations replace each pair of consecutive elements with their product.\n```\nAfter the algorithm has finished, there will be a single element left in the array. Return that element.\n\n# Example\n\n For inputArray = [1, 2, 3, 4, 5, 6, 7, 8], the output should be 186.\n\n We have `[1, 2, 3, 4, 5, 6, 7, 8] -> [3, 7, 11, 15] -> [21, 165] -> [186]`, so the answer is 186.\n\n# Input/Output\n\n - `[input]` integer array `arr`\n\n   Constraints: 2^(1) ≤ arr.length ≤ 2^(5), -9 ≤ arr[i] ≤ 99.\n\n - `[output]` an integer\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef arrayConversion (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem array_conversion_power_of_two_length\n  {n : Nat} {arr : List Nat}\n  (h1 : n ≥ 1) (h2 : n ≤ 5)\n  (h3 : arr.length = 2^n) :\n  isPowerOfTwo arr.length = true ∧\n  arrayConversion arr ≥ 0 :=\nsorry\n\ntheorem array_conversion_deterministic\n  {arr : List Nat}\n  (h : isPowerOfTwo arr.length = true) :\n  arrayConversion arr = arrayConversion arr :=\nsorry\n\ntheorem array_conversion_monotonic\n  {arr : List Nat} {i : Nat}\n  (h1 : isPowerOfTwo arr.length = true)\n  (h2 : i < arr.length) :\n  let arr' := arr.set i (arr[i] + 1)\n  arrayConversion arr' ≥ arrayConversion arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 186\n-/\n#guard_msgs in\n#eval array_conversion [1, 2, 3, 4, 5, 6, 7, 8]\n\n/--\ninfo: 64\n-/\n#guard_msgs in\n#eval array_conversion [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\n/--\ninfo: 60\n-/\n#guard_msgs in\n#eval array_conversion [3, 3, 5, 5]"}
{"id": "fvapps_002831", "vc-description": "/-\nPolycarpus works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.\n\nLet's assume that a song consists of some number of words (that don't contain WUB). To make the dubstep remix of this song, Polycarpus inserts a certain number of words \"WUB\" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including \"WUB\", in one string and plays the song at the club.\n\nFor example, a song with words \"I AM X\" can transform into a dubstep remix as \"WUBWUBIWUBAMWUBWUBX\" and cannot transform into \"WUBWUBIAMWUBX\".\n\nRecently, Jonny has heard Polycarpus's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Polycarpus remixed. Help Jonny restore the original song.\n\n## Input\nThe input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters\n\n## Output\nReturn the words of the initial song that Polycarpus used to make a dubsteb remix. Separate the words with a space.\n\n## Examples\n\n```python\nsong_decoder(\"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\")\n  # =>  WE ARE THE CHAMPIONS MY FRIEND\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def songDecoder (s : String) : String :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry", "vc-theorems": "theorem no_wub_in_output (s : String) :\n  ¬isSubstring \"WUB\" (songDecoder s) :=\nsorry\n\ntheorem no_leading_trailing_spaces (s : String) :\n  ¬(songDecoder s).startsWith \" \" ∧ ¬(songDecoder s).endsWith \" \" :=\nsorry\n\ntheorem no_multiple_spaces (s : String) :\n  ¬isSubstring \"  \" (songDecoder s) :=\nsorry\n\ntheorem idempotent (s : String) :\n  songDecoder (songDecoder s) = songDecoder s :=\nsorry\n\ntheorem output_properties (s : String) :\n  let result := songDecoder s\n  String.length result ≥ 0 ∧\n  ¬isSubstring \"  \" result ∧\n  ¬result.startsWith \" \" ∧\n  ¬result.endsWith \" \" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'WE ARE THE CHAMPIONS MY FRIEND'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\"\n\n/--\ninfo: 'A B C'\n-/\n#guard_msgs in\n#eval song_decoder \"AWUBBWUBC\"\n\n/--\ninfo: 'O IPVCQAFWY Q XHDKCPYKCTWWY V FZ'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWUBOWUBWUBWUBIPVCQAFWYWUBWUBWUBQWUBWUBWUBXHDKCPYKCTWWYWUBWUBWUBVWUBWUBWUBFZWUBWUB\""}
{"id": "fvapps_002832", "vc-description": "/-\nThe numbers 12, 63 and 119 have something in common related with their divisors and their prime factors, let's see it.\n```\nNumbers PrimeFactorsSum(pfs)        DivisorsSum(ds)              Is ds divisible by pfs\n12         2 + 2 + 3 = 7         1 + 2 + 3 + 4 + 6 + 12 = 28            28 / 7 = 4,  Yes\n63         3 + 3 + 7 = 13        1 + 3 + 7 + 9 + 21 + 63 = 104         104 / 13 = 8, Yes\n119        7 + 17 = 24           1 + 7 + 17 + 119 = 144                144 / 24 = 6, Yes\n```\nThere is an obvius property you can see: the sum of the divisors of a number is divisible by the sum of its prime factors.\n\nWe need the function ```ds_multof_pfs()``` that receives two arguments: ```nMin``` and  ```nMax```, as a lower and upper limit (inclusives), respectively, and outputs a sorted list with the numbers that fulfill the property described above.\n\nWe represent the features of the described function:\n```python\nds_multof_pfs(nMin, nMax) -----> [n1, n2, ....., nl] # nMin ≤ n1 < n2 < ..< nl ≤ nMax\n```\nLet's see some cases:\n```python\nds_multof_pfs(10, 100) == [12, 15, 35, 42, 60, 63, 66, 68, 84, 90, 95]\n\nds_multof_pfs(20, 120) == [35, 42, 60, 63, 66, 68, 84, 90, 95, 110, 114, 119]\n```\nEnjoy it!!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "structure IsSorted (xs : List Nat) : Prop where\n  sorted : ∀ i j, i < xs.length → j < xs.length → i ≤ j → xs[i]! ≤ xs[j]!", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef prime_factors_sum (n : Nat) : Nat :=\nsorry\n\ndef divisors_sum (n : Nat) : Nat :=\nsorry\n\ndef ds_multof_pfs (nMin nMax : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem is_prime_properties {n : Nat} :\n  (n < 2 → is_prime n = false) ∧\n  (is_prime n = true → n ≥ 2) ∧\n  (is_prime n = true → ∀ i : Nat, 2 ≤ i ∧ i ≤ sqrt n → n % i ≠ 0) :=\nsorry\n\ntheorem prime_factors_sum_properties {n : Nat} (h : n ≥ 2) :\n  prime_factors_sum n > 0 ∧\n  prime_factors_sum n ≤ n * n :=\nsorry\n\ntheorem ds_multof_pfs_properties {nMin nMax : Nat} (h : nMin ≤ nMax) :\n  let result := ds_multof_pfs nMin nMax\n  IsSorted result ∧\n  (∀ x ∈ result, nMin ≤ x ∧ x ≤ nMax) ∧\n  (∀ n ∈ result, prime_factors_sum n > 0 ∧ (divisors_sum n) % (prime_factors_sum n) = 0) ∧\n  (∀ i j, i < result.length → j < result.length → i ≠ j → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002835", "vc-description": "/-\nYour job is to write function last_digits(n,d) which return the last `d` digits of an integer `n` as a list.\n`n` will be from 0 to 10^10\n\nExamples:\n\n`last_digits(1,1)     --> [1]`\n\n`last_digits(1234,2)   --> [3,4]`\n\n`last_digits(637547,6) --> [6,3,7,5,4,7]`\n\nSpecial cases:\n\nIf `d` > the number of digits, just return the number's digits as a list.\n\nIf `d` <= 0, then return an empty list.\n\nThis is the first kata I have made, so please report any issues.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def last_digits (n : Nat) (d : Int) : List Nat :=\nsorry\n\ndef list_to_string (l : List Nat) : String :=\nsorry\n\ndef nat_to_string (n : Nat) : String :=\nsorry", "vc-theorems": "theorem last_digits_empty_for_nonpositive (n : Nat) (d : Int) :\n  d <= 0 → last_digits n d = [] :=\nsorry\n\ntheorem last_digits_length_bound (n : Nat) (d : Int) :\n  d > 0 → List.length (last_digits n d) = min d.toNat (nat_to_string n).length :=\nsorry\n\ntheorem last_digits_are_digits (n : Nat) (d : Int) (x : Nat) :\n  x ∈ last_digits n d → x ≤ 9 :=\nsorry\n\ntheorem last_digits_match_string_suffix (n : Nat) (d : Int) :\n  d > 0 → list_to_string (last_digits n d) = (nat_to_string n).takeRight d.toNat :=\nsorry\n\ntheorem last_digits_full_number (n : Nat) :\n  list_to_string (last_digits n ((nat_to_string n).length + 1)) = nat_to_string n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval last_digits 1 1\n\n/--\ninfo: [3, 7, 6, 7]\n-/\n#guard_msgs in\n#eval last_digits 123767 4\n\n/--\ninfo: [1, 3, 4, 3]\n-/\n#guard_msgs in\n#eval last_digits 1343 5"}
{"id": "fvapps_002841", "vc-description": "/-\nYour task is to ___Reverse and Combine Words___. It's not too difficult, but there are some things you have to consider...\n\n### So what to do?\n\nInput: String containing different \"words\" separated by spaces\n\n```\n1. More than one word? Reverse each word and combine first with second, third with fourth and so on...\n   (odd number of words => last one stays alone, but has to be reversed too)\n2. Start it again until there's only one word without spaces\n3. Return your result...\n```\n\n### Some easy examples:\n```\nInput:  \"abc def\"\nOutput: \"cbafed\"\n\nInput:  \"abc def ghi 123\"\nOutput: \"defabc123ghi\"\n\nInput:  \"abc def gh34 434ff 55_eri 123 343\"\nOutput: \"43hgff434cbafed343ire_55321\"\n```\n\nI think it's clear?! First there are some static tests, later on random tests too...\n\n### Hope you have fun! :-)\n-/\n\n-- Result length should match total chars across merged words\n\n-- All input chars should appear in output in same quantities\n\n-- Number of words should roughly halve each iteration", "vc-preamble": "def countChar (c : Char) (s : String) : Nat :=\n  (s.toList.filter (· = c)).length", "vc-helpers": "", "vc-definitions": "def reverseAndCombineText (text : String) : String :=\nsorry", "vc-theorems": "theorem output_length_matches_input_chars (text : String) :\n  String.length (reverseAndCombineText text) =\n  String.length (String.replace text \" \" \"\") :=\nsorry\n\ntheorem chars_preserved (text : String) (c : Char) :\n  countChar c (String.replace text \" \" \"\") =\n  countChar c (reverseAndCombineText text) :=\nsorry\n\ntheorem halves_words_per_iteration (text : String) :\n  let wordCount := (text.split (· = ' ')).length\n  let maxIterations := if wordCount ≤ 1 then 0\n                       else (wordCount - 1).log2 + 1\n  ∀ result : String, result = reverseAndCombineText text →\n  (result.split (· = ' ')).length ≤\n    if wordCount ≤ 1 then 1 else wordCount / (2 ^ maxIterations) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'cbafed'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def\"\n\n/--\ninfo: 'defabcjklghi'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def ghi jkl\"\n\n/--\ninfo: 'trzwqfdstrteettr45hh4325543544hjhjh21lllll'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"234hh54 53455 sdfqwzrt rtteetrt hjhjh lllll12  44\""}
{"id": "fvapps_002848", "vc-description": "/-\nEverybody know that you passed to much time awake during night time...\n\nYour task here is to define how much coffee you need to stay awake after your night. \nYou will have to complete a function that take an array of events in arguments, according to this list you will return the number of coffee you need to stay awake during day time. **Note**: If the count exceed 3 please return 'You need extra sleep'.\n\nThe list of events can contain the following:\n\n- You come here, to solve some kata ('cw').\n\n- You have a dog or a cat that just decide to wake up too early ('dog' | 'cat').\n\n- You just watch a movie ('movie').\n\n- Other events can be present and it will be represent by arbitrary string, just ignore this one.\n\nEach event can be downcase/lowercase, or uppercase. If it is downcase/lowercase you need 1 coffee by events and if it is uppercase you need 2 coffees.\n-/", "vc-preamble": "def ValidEvent : Type := String\n\ndef VALID_EVENTS : List ValidEvent :=\n  [\"cw\", \"CW\", \"cat\", \"CAT\", \"dog\", \"DOG\", \"movie\", \"MOVIE\"]", "vc-helpers": "", "vc-definitions": "def isValidEvent (event : String) : Bool :=\n  sorry\n\ndef howMuchCoffee (events : List String) : Nat ⊕ String :=\n  sorry", "vc-theorems": "theorem invalid_events_ignored (events : List String) :\n  (∀ e ∈ events, e ∉ VALID_EVENTS) →\n  howMuchCoffee events = .inl 0 :=\nsorry\n\ntheorem valid_events (events : List String) :\n  (∀ e ∈ events, e ∈ VALID_EVENTS) →\n  let total := events.foldl (fun acc e => acc + if e.all Char.isUpper then 2 else 1) 0\n  if total > 3\n  then howMuchCoffee events = .inr \"You need extra sleep\"\n  else howMuchCoffee events = .inl total :=\nsorry\n\ntheorem single_event_empty :\n  howMuchCoffee [] = .inl 0 :=\nsorry\n\ntheorem single_valid_event (event : String) :\n  event ∈ VALID_EVENTS →\n  howMuchCoffee [event] = .inl (if event.all Char.isUpper then 2 else 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval how_much_coffee []\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\"]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval how_much_coffee [\"CW\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\"]\n\n/--\ninfo: 'You need extra sleep'\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"DOG\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"cw=others\"]"}
{"id": "fvapps_002849", "vc-description": "/-\nThe rgb function is incomplete. Complete it so that passing in RGB decimal values will result in a hexadecimal representation being returned. Valid decimal values for RGB are 0 - 255. Any values that fall out of that range must be rounded to the closest valid value.\n\nNote: Your answer should always be 6 characters long, the shorthand with 3 will not work here.\n\nThe following are examples of  expected output values:\n```python\nrgb(255, 255, 255) # returns FFFFFF\nrgb(255, 255, 300) # returns FFFFFF\nrgb(0,0,0) # returns 000000\nrgb(148, 0, 211) # returns 9400D3\n```\n```if:nasm\n\nchar \\*rgb(int r, int g, int b, char \\*outp)\n\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isHexDigit (c : Char) : Bool :=\nsorry\n\ndef rgb (r g b : Int) : String :=\nsorry\n\ndef hexStringToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem rgb_output_format (r g b : Int) :\n  let result := rgb r g b\n  (result.length = 6) ∧\n  (result.data.all isHexDigit)\n  :=\nsorry\n\ntheorem rgb_valid_inputs (r g b : Int)\n  (hr : 0 ≤ r ∧ r ≤ 255)\n  (hg : 0 ≤ g ∧ g ≤ 255)\n  (hb : 0 ≤ b ∧ b ≤ 255) :\n  let result := rgb r g b\n  let r_hex := result.take 2\n  let g_hex := result.drop 2 |>.take 2\n  let b_hex := result.drop 4 |>.take 2\n  (hexStringToNat r_hex = r) ∧\n  (hexStringToNat g_hex = g) ∧\n  (hexStringToNat b_hex = b)\n  :=\nsorry\n\ntheorem rgb_negative_inputs (r g b : Int)\n  (hr : r < 0)\n  (hg : g < 0)\n  (hb : b < 0) :\n  rgb r g b = \"000000\"\n  :=\nsorry\n\ntheorem rgb_large_inputs (r g b : Int)\n  (hr : r > 255)\n  (hg : g > 255)\n  (hb : b > 255) :\n  rgb r g b = \"FFFFFF\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '000000'\n-/\n#guard_msgs in\n#eval rgb 0 0 0\n\n/--\ninfo: '010203'\n-/\n#guard_msgs in\n#eval rgb 1 2 3\n\n/--\ninfo: '00FF7D'\n-/\n#guard_msgs in\n#eval rgb -20 275 125"}
{"id": "fvapps_002853", "vc-description": "/-\n# Invalid Login - Bug Fixing #11\n\nOh NO! Timmy has moved divisions... but now he's in the field of security. Timmy, being the top coder he is, has allowed some bad code through. You must help Timmy and filter out any injected code!\n\n## Task\n\nYour task is simple, search the password string for any injected code (Injected code is any thing that would be used to exploit flaws in the current code, so basically anything that contains `||` or `//`) if you find any you must return `\"Wrong username or password!\"` because no one likes someone trying to cheat their way in!\n\n## Preloaded\n\nYou will be given a preloaded class called `Database` with a method `login` this takes two parameters `username` and `password`. This is a generic login function which will check the database for the user it will return either `'Successfully Logged in!'` if it passes the test or `'Wrong username or password!'` if either the password is wrong or username does not exist.\n\n## Usage\n\n```python\ndatabase = Database()\ndatabase.login('Timmy', 'password')\n```\n-/", "vc-preamble": "def validUsers : List String := [\"Timmy\", \"Alice\", \"Johny\", \"Roger\", \"Simon\", \"Admin\"]", "vc-helpers": "", "vc-definitions": "def validate (username password : String) : String :=\n  sorry", "vc-theorems": "theorem invalid_username {username password : String}\n  (h : username ∉ validUsers) :\n  validate username password = \"Wrong username or password!\" :=\nsorry\n\ntheorem injection_attempt {username password1 password2 : String}\n  (h : username ∈ validUsers) :\n  validate username (password1 ++ \"||\" ++ password2) = \"Wrong username or password!\" :=\nsorry\n\ntheorem injection_attempt_slash {username password1 password2 : String}\n  (h : username ∈ validUsers) :\n  validate username (password1 ++ \"//\" ++ password2) = \"Wrong username or password!\" :=\nsorry\n\ntheorem valid_login_timmy :\n  validate \"Timmy\" \"password\" = \"Successfully Logged in!\" :=\nsorry\n\ntheorem valid_login_alice :\n  validate \"Alice\" \"alice\" = \"Successfully Logged in!\" :=\nsorry\n\ntheorem valid_user_response {username password : String}\n  (h : username ∈ validUsers) :\n  validate username password = \"Successfully Logged in!\" ∨\n  validate username password = \"Wrong username or password!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"\n\n/--\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"h4x0r\"\n\n/--\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Alice\" \"alice\"\n\n/--\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"||\"\"==\"\"\n\n/--\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Admin\" \"gs5bw\"||1==1//\""}
{"id": "fvapps_002864", "vc-description": "/-\nIn this Kata you need to write the method SharedBits that returns true if 2 integers share at least two '1' bits. For simplicity assume that all numbers are positive\n\nFor example\nint seven = 7;    //0111\nint ten = 10;     //1010\nint fifteen = 15; //1111\nSharedBits(seven, ten);     //false\nSharedBits(seven, fifteen); //true\nSharedBits(ten, fifteen);   //true\n\n- seven and ten share only a single '1' (at index 3)\n- seven and fifteen share 3 bits (at indexes 1, 2, and 3)\n- ten and fifteen  share 2 bits (at indexes 0 and 2)\n\nHint: you can do this with just string manipulation, but binary operators will make your life much easier.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countOnes (n : Nat) : Nat :=\n  sorry\n\ndef shared_bits (a b : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem shared_bits_symmetric\n  {a b : Nat} : shared_bits a b = shared_bits b a := by\n  sorry\n\ntheorem shared_bits_self\n  {x : Nat} : shared_bits x x = (countOnes x > 1) := by\n  sorry\n\ntheorem shared_bits_and\n  {a b : Nat} : shared_bits a b = (countOnes (a &&& b) > 1) := by\n  sorry\n\ntheorem shared_bits_single_bit\n  {x : Nat} (h : x ≤ 1) : shared_bits x x = false := by\n  sorry\n\ntheorem shared_bits_powers_two\n  {p1 p2 : Nat} (h1 : ∃ k1, p1 = 2^k1) (h2 : ∃ k2, p2 = 2^k2) :\n  shared_bits p1 p2 = false := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 1 2\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 7 10\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval shared_bits 7 15"}
{"id": "fvapps_002865", "vc-description": "/-\n# Task\n Given an integer `n`, find the maximal number you can obtain by deleting exactly one digit of the given number.\n\n# Example\n\n For `n = 152`, the output should be `52`;\n\n For `n = 1001`, the output should be `101`.\n\n# Input/Output\n\n - `[input]` integer `n`\n\n    Constraints: `10 ≤ n ≤ 1000000.`\n\n - `[output]` an integer\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def delete_digit (n : Nat) : Nat :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem delete_digit_length (n : Nat) (h : n ≥ 10) :\n  (toString (delete_digit n)).length = (toString n).length - 1 :=\nsorry\n\ntheorem delete_digit_smaller (n : Nat) (h : n ≥ 10) :\n  delete_digit n < n :=\nsorry\n\ntheorem delete_digit_natural (n : Nat) (h : n ≥ 10) :\n  delete_digit n ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 52\n-/\n#guard_msgs in\n#eval delete_digit 152\n\n/--\ninfo: 101\n-/\n#guard_msgs in\n#eval delete_digit 1001\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval delete_digit 10"}
{"id": "fvapps_002866", "vc-description": "/-\nSimple transposition is a basic and simple cryptography technique. We make 2 rows and put first a letter in the Row 1, the second in the Row 2, third in Row 1 and so on until the end. Then we put the text from Row 2 next to the Row 1 text and thats it.\n\nComplete the function that receives a string and encrypt it with this simple transposition.\n\n## Example\nFor example if the text to encrypt is: `\"Simple text\"`, the 2 rows will be:\n\nRow 1\nS\nm\nl\n\ne\nt\n\nRow 2\ni\np\ne\nt\nx\n\nSo the result string will be: `\"Sml etipetx\"`\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simple_transposition (s : String) : String :=\nsorry\n\ndef reverse_transposition (s : String) : String :=\nsorry\n\ndef stringTakeEveryNth (s : String) (start : Nat) : String :=\nsorry", "vc-theorems": "theorem length_preserved (s : String) :\n  (simple_transposition s).length = s.length :=\nsorry\n\ntheorem empty_and_single_char (s : String) :\n  s.length ≤ 1 → simple_transposition s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002867", "vc-description": "/-\nGiven a credit card number we can determine who the issuer/vendor is with a few basic knowns.\n\n```if:python\nComplete the function `get_issuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`.\n```\n```if-not:python\nComplete the function `getIssuer()` that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string `Unknown`.\n```\n```if:typescript\nWhere `Issuer` is defined with the following enum type.\n~~~typescript\nenum Issuer {\n  VISA = 'VISA',\n  AMEX = 'AMEX',\n  Mastercard = 'Mastercard',\n  Discover = 'Discover',\n  Unknown = 'Unknown',\n}\n~~~\n```\n\n```markdown\n| Card Type  | Begins With          | Number Length |\n|------------|----------------------|---------------|\n| AMEX       | 34 or 37             | 15            |\n| Discover   | 6011                 | 16            |\n| Mastercard | 51, 52, 53, 54 or 55 | 16            |\n| VISA       | 4                    | 13 or 16      |\n```\n\n```if:c,cpp\n**C/C++ note:** The return value in C is not freed.\n```\n\n## Examples\n\n```if-not:python\n~~~js\ngetIssuer(4111111111111111) == \"VISA\"\ngetIssuer(4111111111111) == \"VISA\"\ngetIssuer(4012888888881881) == \"VISA\"\ngetIssuer(378282246310005) == \"AMEX\"\ngetIssuer(6011111111111117) == \"Discover\"\ngetIssuer(5105105105105100) == \"Mastercard\"\ngetIssuer(5105105105105106) == \"Mastercard\"\ngetIssuer(9111111111111111) == \"Unknown\"\n~~~\n```\n```if:python\n~~~py\nget_issuer(4111111111111111) == \"VISA\"\nget_issuer(4111111111111) == \"VISA\"\nget_issuer(4012888888881881) == \"VISA\"\nget_issuer(378282246310005) == \"AMEX\"\nget_issuer(6011111111111117) == \"Discover\"\nget_issuer(5105105105105100) == \"Mastercard\"\nget_issuer(5105105105105106) == \"Mastercard\"\nget_issuer(9111111111111111) == \"Unknown\"\n~~~\n```\n-/", "vc-preamble": "inductive CardIssuer where\n  | AMEX : CardIssuer\n  | Discover : CardIssuer\n  | Mastercard : CardIssuer\n  | VISA : CardIssuer\n  | Unknown : CardIssuer\nderiving BEq\n\ndef CardIssuer.toString : CardIssuer → String\n  | AMEX => \"AMEX\"\n  | Discover => \"Discover\"\n  | Mastercard => \"Mastercard\"\n  | VISA => \"VISA\"\n  | Unknown => \"Unknown\"", "vc-helpers": "", "vc-definitions": "def get_issuer (number : Nat) : String :=\nsorry", "vc-theorems": "theorem issuer_is_valid (n : Nat) :\n  let result := get_issuer n\n  result = \"AMEX\" ∨ result = \"Discover\" ∨ result = \"Mastercard\" ∨ result = \"VISA\" ∨ result = \"Unknown\" :=\nsorry\n\ntheorem amex_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"34\" ∨ digits.take 2 = \"37\") → get_issuer n = \"AMEX\" ∧\n  (digits.take 2 = \"35\" ∨ digits.take 2 = \"36\") → get_issuer n = \"Unknown\" :=\nsorry\n\ntheorem visa_length_rules (n : Nat) :\n  let digits := n.repr\n  (digits.get! 0 = '4' ∧ (digits.length = 13 ∨ digits.length = 16)) →\n    get_issuer n = \"VISA\" ∧\n  (digits.get! 0 = '4' ∧ ¬(digits.length = 13 ∨ digits.length = 16)) →\n    get_issuer n = \"Unknown\" :=\nsorry\n\ntheorem mastercard_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"51\" ∨ digits.take 2 = \"52\" ∨ digits.take 2 = \"53\" ∨ digits.take 2 = \"54\" ∨ digits.take 2 = \"55\") →\n  digits.length = 16 →\n  get_issuer n = \"Mastercard\" :=\nsorry\n\ntheorem discover_rules (n : Nat) :\n  let digits := n.repr\n  digits.startsWith \"6011\" ∧ digits.length = 16 →\n    get_issuer n = \"Discover\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111111\n\n/--\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111\n\n/--\ninfo: 'AMEX'\n-/\n#guard_msgs in\n#eval get_issuer 378282246310005\n\n/--\ninfo: 'Mastercard'\n-/\n#guard_msgs in\n#eval get_issuer 5105105105105100\n\n/--\ninfo: 'Discover'\n-/\n#guard_msgs in\n#eval get_issuer 6011111111111117\n\n/--\ninfo: 'Unknown'\n-/\n#guard_msgs in\n#eval get_issuer 9111111111111111"}
{"id": "fvapps_002868", "vc-description": "/-\nCheck if given chord is minor or major.\n\n_____________________________________________________________\nRules:\n\n1. Basic minor/major chord have three elements.\n\n2. Chord is minor when interval between first and second element equals 3 and between second and third -> 4.\n\n3. Chord is major when interval between first and second element equals 4 and between second and third -> 3.\n\n4. In minor/major chord interval between first and third element equals... 7.\n\n_______________________________________________________________\nThere is a preloaded list of the 12 notes of a chromatic scale built on C. This means that there are (almost) all allowed note' s names in music.\n\nnotes = \n['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n\nNote that e. g. 'C#' - 'C' = 1, 'C' - 'C#' = 1, 'Db' - 'C' = 1 and 'B' - 'C' = 1. \n\nInput:\nString of notes separated by whitespace, e. g. 'A C# E'\n\nOutput:\nString message: 'Minor', 'Major' or 'Not a chord'.\n-/\n\n/- Returns the list of words in a string -/\n\n/- Invalid input types should return \"Not a chord\" -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Wrong number of notes (not equal to 3) should return \"Not a chord\" -/\n\n/- Invalid note names should return \"Not a chord\" -/\n\n/- Known major chords should return \"Major\" -/\n\n/- Known minor chords should return \"Minor\" -/\n\n/- Enharmonic equivalents should produce the same result -/\n\n/- The main function that determines if a chord is major, minor, or invalid -/", "vc-preamble": "def NoteNames : List String := [\"C\", \"C#\", \"Db\", \"D\", \"D#\", \"Eb\", \"E\", \"F\", \"F#\", \"Gb\", \"G\", \"G#\", \"Ab\", \"A\", \"A#\", \"Bb\", \"B\"]", "vc-helpers": "", "vc-definitions": "def minor_or_major (input : String) : String :=\nsorry\n\ndef splitString (s : String) : List String :=\nsorry", "vc-theorems": "theorem invalid_input_numeric (n : Nat) :\n  minor_or_major (toString n) = \"Not a chord\" :=\nsorry\n\ntheorem wrong_note_count (notes : String) :\n  (splitString notes).length ≠ 3 → minor_or_major notes = \"Not a chord\" :=\nsorry\n\ntheorem invalid_note_names (notes : String) :\n  (∃ note, note ∈ splitString notes ∧ note ∉ NoteNames) →\n  minor_or_major notes = \"Not a chord\" :=\nsorry\n\ntheorem known_major_chords :\n  minor_or_major \"C E G\" = \"Major\" ∧\n  minor_or_major \"F# A# C#\" = \"Major\" :=\nsorry\n\ntheorem known_minor_chords :\n  minor_or_major \"C Eb G\" = \"Minor\" ∧\n  minor_or_major \"F# A C#\" = \"Minor\" :=\nsorry\n\ntheorem enharmonic_equivalence (n1 n2 : String) (other1 other2 : String) :\n  ((n1 = \"C#\" ∧ n2 = \"Db\") ∨\n   (n1 = \"D#\" ∧ n2 = \"Eb\") ∨\n   (n1 = \"F#\" ∧ n2 = \"Gb\") ∨\n   (n1 = \"G#\" ∧ n2 = \"Ab\") ∨\n   (n1 = \"A#\" ∧ n2 = \"Bb\")) →\n  minor_or_major (s!\"{n1} {other1} {other2}\") =\n  minor_or_major (s!\"{n2} {other1} {other2}\") :=\nsorry", "vc-postamble": "/--\ninfo: 'Major'\n-/\n#guard_msgs in\n#eval minor_or_major \"C E G\"\n\n/--\ninfo: 'Minor'\n-/\n#guard_msgs in\n#eval minor_or_major \"C Eb G\"\n\n/--\ninfo: 'Not a chord'\n-/\n#guard_msgs in\n#eval minor_or_major \"C D G\""}
{"id": "fvapps_002878", "vc-description": "/-\nGiven a board of `NxN`, distributed with tiles labeled `0` to `N² - 1`(inclusive):\n\nA solved grid will have the tiles in order of label, left to right, top to bottom.\n\nReturn `true` if the board state is currently solved, and `false` if the board state is unsolved.\n\nInput will always be a square 2d array.\n\nFor example, a 2x2 solved grid:\n```\n[ [0, 1],\n  [2, 3] ]\n```\n\nA 2x2 unsolved grid:\n```\n[ [2, 1],\n  [0, 3] ]\n```\n-/\n\n-- actual swapping implementation would go here", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSolved (board : List (List Nat)) : Bool :=\n  sorry\n\ndef isSequential (board : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem solved_board_generated {n : Nat} (h : n > 0) (h2 : n ≤ 5) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  isSolved board = isSequential board :=\nsorry\n\ntheorem arbitrary_boards_match_sequential (board : List (List Nat))\n  (h : board.length > 0)\n  (h2 : board.length ≤ 5)\n  (h3 : ∀ row ∈ board, row.length = board.length) :\n  isSolved board = isSequential board :=\nsorry\n\ntheorem single_swap_breaks_solution\n  {n : Nat} (h : n > 0) (h2 : n ≤ 5)\n  (pos1 pos2 : Nat) (h3 : pos1 ≠ pos2) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  let total_size := n * n\n  let pos1' := pos1 % total_size\n  let pos2' := pos2 % total_size\n  let row1 := pos1' / n\n  let col1 := pos1' % n\n  let row2 := pos2' / n\n  let col2 := pos2' % n\n  let swapped_board := sorry\n  ¬(isSolved swapped_board) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0], [3, 2]]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0, 4], [3, 2, 7], [8, 5, 6]]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_solved [[0, 1], [2, 3]]"}
{"id": "fvapps_002880", "vc-description": "/-\n> In information theory and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other.\n\n(http://en.wikipedia.org/wiki/Levenshtein_distance)\n\nYour task is to implement a function which calculates the Levenshtein distance for two arbitrary strings.\n-/\n\n-- Non-negativity\n\n-- Identity\n\n-- Symmetry\n\n-- Triangle inequality\n\n-- Empty string", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def levenshtein (s1 s2 : String) : Nat :=\n  sorry\n\ndef repeatChar (c : Char) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem levenshtein_nonneg (s1 s2 : String) :\n  levenshtein s1 s2 ≥ 0 :=\nsorry\n\ntheorem levenshtein_identity (s : String) :\n  levenshtein s s = 0 :=\nsorry\n\ntheorem levenshtein_symm (s1 s2 : String) :\n  levenshtein s1 s2 = levenshtein s2 s1 :=\nsorry\n\ntheorem levenshtein_triangle (s1 s2 s3 : String) :\n  levenshtein s1 s2 ≤ levenshtein s1 s3 + levenshtein s3 s2 :=\nsorry\n\ntheorem levenshtein_empty_string (s : String) :\n  levenshtein s \"\" = s.length :=\nsorry\n\ntheorem levenshtein_empty_string_rev (s : String) :\n  levenshtein \"\" s = s.length :=\nsorry", "vc-postamble": "-- Repeated char prepending\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval levenshtein \"kitten\" \"sitting\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval levenshtein \"book\" \"back\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval levenshtein \"peter\" \"peter\""}
{"id": "fvapps_002882", "vc-description": "/-\nYour task is very simple. Just write a function `isAlphabetic(s)`, which takes an input string `s` in lowercase and returns `true`/`false` depending on whether the string is in alphabetical order or not.\n\nFor example, `isAlphabetic('kata')` is False as 'a' comes after 'k', but `isAlphabetic('ant')` is True.\n\nGood luck :)\n-/", "vc-preamble": "def isSorted (cs : List Char) : Prop :=\n  ∀ i j, i < j → j < cs.length → cs[i]! ≤ cs[j]!", "vc-helpers": "", "vc-definitions": "def alphabetic (s : String) : Bool :=\nsorry", "vc-theorems": "theorem empty_string_alphabetic :\n  alphabetic \"\" = true :=\nsorry\n\ntheorem single_char_alphabetic (c : Char) :\n  alphabetic (String.singleton c) = true :=\nsorry\n\ntheorem alphabetic_iff_sorted (s : String) :\n  alphabetic s = true ↔ isSorted s.data :=\nsorry\n\ntheorem alphabetic_monotonic (s : String) :\n  alphabetic s = true →\n  ∀ i : Nat, i + 1 < s.length →\n  s.data[i]! ≤ s.data[i+1]! :=\nsorry\n\ntheorem concat_nonalpha_equiv_sorted (ss : List String) (h : ss ≠ []) :\n  (∀ s ∈ ss, alphabetic s = false) →\n  alphabetic (String.join ss) = true ↔ isSorted (String.join ss).data :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"door\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"cell\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval alphabetic \"kata\""}
{"id": "fvapps_002888", "vc-description": "/-\nIn this Kata, you will be given a string and your task is to return the most valuable character. The value of a character is the difference between the index of its last occurrence and the index of its first occurrence. Return the character that has the highest value. If there is a tie, return the alphabetically lowest character. `[For Golang return rune]`\n\nAll inputs will be lower case. \n\n```\nFor example:\nsolve('a') = 'a'\nsolve('ab') = 'a'. Last occurrence is equal to first occurrence of each character. Return lexicographically lowest.\nsolve(\"axyzxyz\") = 'x'\n```\n\nMore examples in test cases. Good luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def firstIndex (s: String) (c: Char) : Nat :=\n  sorry\n\ndef lastIndex (s: String) (c: Char) : Nat :=\n  sorry\n\ndef solve (s: String) : Char :=\n  sorry", "vc-theorems": "theorem solve_returns_char_from_input (s: String) (h: s.length > 0) :\n  ∃ p: String.Pos, solve s = s.get p :=\nsorry\n\ntheorem solve_returns_char_with_minimal_first_last_diff (s: String) (h: s.length > 0) :\n  ∀ c: Char,\n  firstIndex s (solve s) - lastIndex s (solve s)\n  ≤ firstIndex s c - lastIndex s c :=\nsorry\n\ntheorem solve_returns_lexicographically_first_when_tied (s: String) (h: s.length > 0) :\n  ∀ c: Char,\n  (firstIndex s c - lastIndex s c = firstIndex s (solve s) - lastIndex s (solve s))\n  → solve s ≤ c :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"a\"\n\n/--\ninfo: 'x'\n-/\n#guard_msgs in\n#eval solve \"axyzxyz\"\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"dcbadcba\""}
{"id": "fvapps_002889", "vc-description": "/-\n*This kata is inspired by [Project Euler Problem #387](https://projecteuler.net/problem=387)*\n\n---\n\nA [Harshad number](https://en.wikipedia.org/wiki/Harshad_number) (or Niven number) is a number that is divisible by the sum of its digits. A *right truncatable Harshad number* is any Harshad number that, when recursively right-truncated, results in a Harshad number at each truncation. By definition, 1-digit numbers are **not** right truncatable Harshad numbers.\n\nFor example `201` (which is a Harshad number) yields `20`, then `2` when right-truncated, which are all Harshad numbers. Thus `201` is a *right truncatable Harshad number*.\n\n## Your task\n\nGiven a range of numbers (`(a, b)`, both included), return the list of right truncatable Harshad numbers in this range.\n\n```if-not:javascript\nNote: there are `500` random tests, with 0 <= `a` <= `b` <= 10^(16)\n```\n```if:javascript\nNote: there are `500` random tests, with `0 <= a <= b <= Number.MAX_SAFE_INTEGER`\n```\n\n## Examples\n\n```\n0, 20        -->  [10, 12, 18, 20]\n30, 100      -->  [30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100]\n90, 200      -->  [90, 100, 102, 108, 120, 126, 180, 200]\n200, 210     -->  [200, 201, 204, 207, 209, 210]\n1000, 2000   -->  [1000, 1002, 1008, 1020, 1026, 1080, 1088, 1200, 1204, 1206, 1260, 1800, 2000]\n2200, 2300   -->  []\n9000002182976, 9000195371842  -->  [9000004000000, 9000004000008]\n```\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n-/\n\n-- Result is sorted\n\n-- All numbers within bounds\n\n-- Each number divisible by sum of its digits", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef rthn_between (a b : Int) : List Int :=\n  sorry", "vc-theorems": "theorem rthn_between_ordered_bounds {a b : Int} (h : a ≤ b) (h₁ : 0 ≤ a) (h₂ : b ≤ 10000) :\n  let result := rthn_between a b\n\n  (∀ i j, i < j → i < List.length result → j < List.length result →\n    result[i]! ≤ result[j]!) ∧\n\n  (∀ x ∈ result, a ≤ x ∧ x ≤ b) ∧\n\n  (∀ x ∈ result, x % sumOfDigits (Int.toNat x) = 0) :=\nsorry\n\ntheorem rthn_between_same_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :\n  let result := rthn_between n n\n  (result ≠ [] →\n    List.length result = 1 ∧\n    result[0]! = n ∧\n    n % sumOfDigits (Int.toNat n) = 0) :=\nsorry\n\ntheorem rthn_between_inverted_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :\n  rthn_between n (n-1) = [] :=\nsorry\n\ntheorem rthn_between_edge_cases :\n  (rthn_between 0 0 = []) ∧\n  (rthn_between (-1) 10 = [10]) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [10, 12, 18, 20]\n-/\n#guard_msgs in\n#eval rthn_between 0 20\n\n/--\ninfo: [200, 201, 204, 207, 209, 210]\n-/\n#guard_msgs in\n#eval rthn_between 200 210\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval rthn_between 2200 2300"}
{"id": "fvapps_002892", "vc-description": "/-\nGiven some positive integers, I wish to print the integers such that all take up the same width by adding a minimum number of leading zeroes. No leading zeroes shall be added to the largest integer.\n\nFor example, given `1, 23, 2, 17, 102`, I wish to print out these numbers as follows:\n\n```python\n001\n023\n002\n017\n102\n```\n\nWrite a function `print_nums(n1, n2, n3, ...)` that takes a variable number of arguments and returns the string to be printed out.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.max (l: List Nat) : Nat :=\n  sorry\n\ndef intToStr (n: Nat) : String :=\n  sorry\n\ndef strLen (s: String) : Nat :=\n  sorry\n\ndef splitLines (s: String) : List String :=\n  sorry\n\ndef stringToNat (s: String) : Nat :=\n  sorry\n\ndef print_nums (nums: List Nat) : String :=\n  sorry", "vc-theorems": "theorem print_nums_empty (nums: List Nat) :\n  nums = [] → print_nums nums = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002895", "vc-description": "/-\nGiven a positive integer `n`, return first n dgits of Thue-Morse sequence, as a string (see examples).\n\nThue-Morse sequence is a binary sequence with 0 as the first element. The rest of the sequece is obtained by adding the Boolean (binary) complement of a group obtained so far.\n\n```\nFor example:\n\n0\n01\n0110\n01101001\nand so on...\n```\n\n![alt](https://upload.wikimedia.org/wikipedia/commons/f/f1/Morse-Thue_sequence.gif)\n\nEx.:\n```python\nthue_morse(1);  #\"0\"\nthue_morse(2);  #\"01\"\nthue_morse(5);  #\"01101\"\nthue_morse(10): #\"0110100110\"\n```\n\n- You don't need to test if n is valid - it will always be a positive integer.\n- `n` will be between 1 and 10000\n\n[Thue-Morse on Wikipedia](https://en.wikipedia.org/wiki/Thue%E2%80%93Morse_sequence)\n\n[Another kata on Thue-Morse](https://www.codewars.com/kata/simple-fun-number-106-is-thue-morse) by @myjinxin2015\n-/\n\n/- The length of thue_morse(n) equals n and contains only 0's and 1's -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any longer sequence starts with the shorter sequence -/\n\n/- If n > 0, the sequence starts with 0 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def thue_morse (n : Nat) : String :=\nsorry", "vc-theorems": "theorem thue_morse_length (n : Nat) :\n  (thue_morse n).length = n ∧\n  ∀ p : String.Pos,\n    String.contains \"01\" ((thue_morse n).get p) :=\nsorry\n\ntheorem thue_morse_prefix_consistency (n : Nat) :\n  (thue_morse (n + 1)).take n = thue_morse n :=\nsorry\n\ntheorem thue_morse_starts_correct (n : Nat) (h : n > 0) :\n  ∃ p : String.Pos, (thue_morse n).get p = '0' :=\nsorry", "vc-postamble": "/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval thue_morse 1\n\n/--\ninfo: '01'\n-/\n#guard_msgs in\n#eval thue_morse 2\n\n/--\ninfo: '01101'\n-/\n#guard_msgs in\n#eval thue_morse 5\n\n/--\ninfo: '0110100110'\n-/\n#guard_msgs in\n#eval thue_morse 10"}
{"id": "fvapps_002897", "vc-description": "/-\nWrite a function that replaces 'two', 'too' and 'to' with the number '2'. Even if the sound is found mid word (like in octopus) or not in lowercase grandma still thinks that should be replaced with a 2. Bless her.\n\n```text\n'I love to text' becomes 'I love 2 text'\n'see you tomorrow' becomes 'see you 2morrow'\n'look at that octopus' becomes 'look at that oc2pus'\n```\n\nNote that 'too' should become '2', not '2o'\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def textin (s : String) : String :=\n  sorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\n  sorry", "vc-theorems": "theorem result_is_string (s : String) :\n  textin s = textin s\n  := by\nsorry\n\ntheorem output_length_leq_input (s : String) :\n  (textin s).length ≤ s.length\n  := by\nsorry\n\ntheorem no_target_words (s : String) :\n  ¬containsSubstr (String.toLower (textin s)) \"two\" ∧\n  ¬containsSubstr (String.toLower (textin s)) \"too\" ∧\n  ¬containsSubstr (String.toLower (textin s)) \"to\"\n  := by\nsorry\n\ntheorem idempotent (s : String) :\n  textin (textin s) = textin s\n  := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_002905", "vc-description": "/-\nA **bouncy number** is a positive integer whose digits neither increase nor decrease. For example, `1235` is an increasing number, `5321` is a decreasing number, and `2351` is a bouncy number. By definition, all numbers under `100` are non-bouncy, and `101` is the first bouncy number. To complete this kata, you must write a function that takes a number and determines if it is bouncy.\n\nInput numbers will always be positive integers, but it never hurts to throw in some error handling : )\n\nFor clarification, the bouncy numbers between `100` and `125` are: `101, 102, 103, 104, 105, 106, 107, 108, 109, 120, and 121`.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_bouncy (n : Nat) : Bool :=\nsorry\n\ndef digits_sorted (n : Nat) : Bool :=\nsorry\n\ndef digits_sorted_reverse (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem small_numbers_not_bouncy (n : Nat) (h : n < 100) :\n  ¬ is_bouncy n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002913", "vc-description": "/-\nIn this Kata, you will be given a mathematical string and your task will be to remove all braces as follows:\n\n```Haskell\nsolve(\"x-(y+z)\") = \"x-y-z\"\nsolve(\"x-(y-z)\") = \"x-y+z\"\nsolve(\"u-(v-w-(x+y))-z\") = \"u-v+w+x+y-z\"\nsolve(\"x-(-y-z)\") = \"x+y+z\"\n```\n\nThere are no spaces in the expression. Only two operators are given: `\"+\" or \"-\"`. \n\nMore examples in test cases. \n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (expr : String) : String :=\nsorry\n\ndef isBalanced (expr : String) : Bool :=\nsorry\n\ndef validateResult (result : String) : Bool :=\nsorry", "vc-theorems": "theorem single_variables_theorem (vars : List Char)\n  (h1 : ∀ c ∈ vars, 'a' ≤ c ∧ c ≤ 'z')\n  (h2 : vars.length ≥ 1)\n  (h3 : vars.length ≤ 10) :\n  let expr := String.mk vars\n  let result := solve expr\n  validateResult result ∧\n  (∀ v ∈ vars, result.data.contains v) :=\nsorry\n\ntheorem nested_parens_theorem (vars : List Char)\n  (h1 : ∀ c ∈ vars, c = 'x' ∨ c = 'y' ∨ c = 'z')\n  (h2 : vars.length ≥ 1)\n  (h3 : vars.length ≤ 5) :\n  let expr := vars.foldl (fun acc v => acc ++ \"-(\" ++ String.mk [v] ++ \")\") (String.mk [vars.head!])\n  let result := solve expr\n  validateResult result ∧\n  (∀ v ∈ vars, result.data.contains v) :=\nsorry\n\ntheorem arbitrary_expressions_theorem (expr : String)\n  (h1 : expr.length ≥ 1)\n  (h2 : expr.length ≤ 20)\n  (h3 : ∀ c ∈ expr.data, c = 'x' ∨ c = 'y' ∨ c = 'z' ∨ c = '(' ∨ c = ')' ∨ c = '+' ∨ c = '-')\n  (h4 : isBalanced expr) :\n  let result := solve expr\n  validateResult result ∧\n  (∀ c ∈ result.data, c.isAlpha → c ∈ expr.data) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'x-y-z'\n-/\n#guard_msgs in\n#eval solve \"x-(y+z)\"\n\n/--\ninfo: 'x-y+z'\n-/\n#guard_msgs in\n#eval solve \"x-(y-z)\"\n\n/--\ninfo: 'u-v+w+x+y-z'\n-/\n#guard_msgs in\n#eval solve \"u-(v-w-(x+y))-z\""}
{"id": "fvapps_002919", "vc-description": "/-\nWell, those numbers were right and we're going to feed their ego.\n\nWrite a function, isNarcissistic, that takes in any amount of numbers and returns true if all the numbers are narcissistic. Return false for invalid arguments (numbers passed in as strings are ok).\n\nFor more information about narcissistic numbers (and believe me, they love it when you read about them) follow this link: https://en.wikipedia.org/wiki/Narcissistic_number\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_digits (n : Nat) : List Nat :=\nsorry\n\ndef is_narc (n : Nat) : Bool :=\nsorry\n\ndef is_narcissistic : List String → Bool :=\nsorry", "vc-theorems": "theorem get_digits_correct (n : Nat) :\n  get_digits n = (toString n).toList.map (fun c => c.toString.toNat!) :=\nsorry\n\ntheorem is_narc_sum_pow_digits (n : Nat) :\n  is_narc n = (n = ((get_digits n).map (fun d => d ^ (get_digits n).length)).foldl (· + ·) 0) :=\nsorry\n\ntheorem is_narcissistic_all (values : List String) :\n  is_narcissistic values = values.all (fun x =>\n    if let some n := x.toNat? then\n      is_narc n\n    else\n      false) :=\nsorry\n\ntheorem non_numeric_returns_false (s : String) :\n  ¬s.all Char.isDigit → ¬is_narcissistic [s] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_narcissistic 11\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic \"4\" 7 \"9\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic 407 8208"}
{"id": "fvapps_002922", "vc-description": "/-\nArray inversion indicates how far the array is from being sorted.\n\nInversions are pairs of elements in array that are out of order.\n\n## Examples\n\n```\n[1, 2, 3, 4]  =>  0 inversions\n[1, 3, 2, 4]  =>  1 inversion: 2 and 3\n[4, 1, 2, 3]  =>  3 inversions: 4 and 1, 4 and 2, 4 and 3\n[4, 3, 2, 1]  =>  6 inversions: 4 and 3, 4 and 2, 4 and 1, 3 and 2, 3 and 1, 2 and 1\n```\n\n## Goal\n\nThe goal is to come up with a function that can calculate inversions for any arbitrary array\n-/", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\ndef swap (l : List Int) (i j : Nat) (h1 : i < l.length) (h2 : j < l.length) : List Int :=\n  let arr := l.toArray\n  let tmp := arr[i]!\n  let arr := arr.set! i arr[j]!\n  let arr := arr.set! j tmp\n  arr.toList", "vc-helpers": "", "vc-definitions": "def count_inversions (lst : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem empty_list_zero_inversions :\n  count_inversions [] = 0 := by\n  sorry\n\ntheorem sorted_list_zero_inversions {lst : List Int} :\n  isSorted lst → count_inversions lst = 0 := by\n  sorry\n\ntheorem reversed_sorted_unique_inversions {lst : List Int} (h1 : List.Nodup lst) (h2 : isSorted lst) :\n  count_inversions (List.reverse lst) = (lst.length * (lst.length - 1)) / 2 := by\n  sorry\n\ntheorem single_swap_one_inversion {lst : List Int} (h1 : isSorted lst) (h2 : lst.length ≥ 2)\n  (h3 : lst[0]! ≠ lst[1]!)\n  (h4 : 0 < lst.length) (h5 : 1 < lst.length) :\n  count_inversions (swap lst 0 1 h4 h5) = 1 := by\n  sorry\n\ntheorem count_always_non_negative (lst : List Int) :\n  count_inversions lst ≥ 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[1, 2, 3]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_inversions #[2, 1, 3]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 2, 1]\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 3, 3, 3, 2, 1]"}
{"id": "fvapps_002925", "vc-description": "/-\n# Task\nConsider an array of integers `a`. Let `min(a)` be its minimal element, and let `avg(a)` be its mean.\n\nDefine the center of the array `a` as array `b` such that:\n\n```\n- b is formed from a by erasing some of its elements.\n- For each i, |b[i] - avg(a)| < min(a).\n- b has the maximum number of elements among all the arrays\n  satisfying the above requirements.\n```\n\nGiven an array of integers, return its center.\n\n# Input/Output\n\n`[input]` integer array `a`\n\n Unsorted non-empty array of integers.\n\n`2 ≤ a.length ≤ 50,`\n\n`1 ≤ a[i] ≤ 350.`\n\n`[output]` an integer array\n\n# Example\n\nFor `a = [8, 3, 4, 5, 2, 8]`, the output should be `[4, 5]`.\n\nHere `min(a) = 2, avg(a) = 5`.\n\nFor `a = [1, 3, 2, 1]`, the output should be `[1, 2, 1]`.\n\nHere `min(a) = 1, avg(a) = 1.75`.\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def list_minimum (lst : List Int) : Int :=\nsorry\n\ndef array_center (lst : List Int) : List Int :=\nsorry\n\ndef mean (lst : List Int) : Int :=\nsorry\n\ndef list_index_of (lst : List Int) (x : Int) : Nat :=\nsorry", "vc-theorems": "theorem array_center_is_subset {lst : List Int} (h : lst ≠ []) :\n  ∀ x, x ∈ array_center lst → x ∈ lst :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [4, 5]\n-/\n#guard_msgs in\n#eval array_center [8, 3, 4, 5, 2, 8]\n\n/--\ninfo: [1, 2, 1]\n-/\n#guard_msgs in\n#eval array_center [1, 3, 2, 1]\n\n/--\ninfo: [10, 11, 12, 13, 14]\n-/\n#guard_msgs in\n#eval array_center [10, 11, 12, 13, 14]"}
{"id": "fvapps_002926", "vc-description": "/-\nGiven a certain integer ```n```, we need a function ```big_primefac_div()```, that give an array with the highest prime factor and the highest divisor (not equal to n).\n\nLet's see some cases:\n```python\nbig_primefac_div(100) == [5, 50]\nbig_primefac_div(1969) == [179, 179]\n```\nIf n is a prime number the function will output an empty list:\n```python\nbig_primefac_div(997) == []\n```\nIf ```n``` is an negative integer number, it should be considered the division with tha absolute number of the value.\n```python\nbig_primefac_div(-1800) == [5, 900]\n```\nIf ```n``` is a float type, will be rejected if it has a decimal part with some digits different than 0. The output \"The number has a decimal part. No Results\". But  ```n ``` will be converted automatically to an integer if all the digits of the decimal part are 0.\n\n```python\nbig_primefac_div(-1800.00) == [5, 900]\nbig_primefac_div(-1800.1) == \"The number has a decimal part. No Results\"\n```\nOptimization and fast algorithms are a key factor to solve this kata.\nHappy coding and enjoy it!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\nsorry\n\ndef sqrt (n : Int) : Int :=\nsorry\n\ndef big_primefac_div (n : Int) : Option (Int × Int) :=\nsorry\n\ndef abs (n : Int) : Int :=\nsorry\n\ndef isInteger (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem big_primefac_div_int_valid {n : Int}\n  (h : 2 ≤ n) (h2 : n ≤ 10^6) :\n  if isInteger n then\n    match big_primefac_div n with\n    | none => True\n    | some (p, d) => p > 0 ∧ d > 0\n  else\n    big_primefac_div n = none :=\nsorry\n\ntheorem big_primefac_div_valid_pos_int {n : Int}\n  (h : 2 ≤ n) (h2 : n ≤ 10^6) :\n  match big_primefac_div n with\n  | none => ∀ i, 2 ≤ i → i ≤ sqrt n → ¬(n % i = 0)\n  | some (p, d) =>\n    1 < p ∧ 1 < d ∧\n    n % p = 0 ∧ n % d = 0 :=\nsorry\n\ntheorem big_primefac_div_neg {n : Int}\n  (h : -10^6 ≤ n) (h2 : n ≤ -2) :\n  big_primefac_div n = big_primefac_div (abs n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [5, 50]\n-/\n#guard_msgs in\n#eval big_primefac_div 100\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval big_primefac_div 997\n\n/--\ninfo: [5, 900]\n-/\n#guard_msgs in\n#eval big_primefac_div -1800.0"}
{"id": "fvapps_002928", "vc-description": "/-\nFollowing on from [Part 1](http://www.codewars.com/kata/filling-an-array-part-1/), part 2 looks at some more complicated array contents.\n\nSo let's try filling an array with...\n\n## ...square numbers\nThe numbers from `1` to `n*n`\n\n## ...a range of numbers\nA range of numbers starting from `start` and increasing by `step`\n\n## ...random numbers\nA bunch of random integers between `min` and `max`\n\n## ...prime numbers\nAll primes starting from `2` (obviously)...\n\nHOTE: All the above functions should take as their first parameter a number that determines the length of the returned array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def squares : Nat → List Nat\n| n =>\nsorry\n\ndef num_range : Nat → Int → Int → List Int\n| n, start, step =>\nsorry\n\ndef rand_range : Nat → Int → Int → List Int\n| n, mn, mx =>\nsorry\n\ndef primes : Nat → List Nat\n| n =>\nsorry", "vc-theorems": "theorem squares_length (n : Nat) : (squares n).length = n := by\n  sorry\n\ntheorem squares_values (n : Nat) (i : Nat) :\n  i < n → (squares n).get ⟨i, sorry⟩ = (i + 1) * (i + 1) := by\n  sorry\n\ntheorem num_range_length (n : Nat) (start step : Int) :\n  (num_range n start step).length = n := by\n  sorry\n\ntheorem num_range_start (n : Nat) (start step : Int) :\n  n > 0 → (num_range n start step).get ⟨0, sorry⟩ = start := by\n  sorry\n\ntheorem num_range_step (n : Nat) (start step : Int) :\n  n > 1 → (num_range n start step).get ⟨1, sorry⟩ - (num_range n start step).get ⟨0, sorry⟩ = step := by\n  sorry\n\ntheorem rand_range_length (n : Nat) (mn mx : Int) :\n  mn ≤ mx → (rand_range n mn mx).length = n := by\n  sorry\n\ntheorem rand_range_bounds (n : Nat) (mn mx : Int) (i : Nat) :\n  mn ≤ mx → i < n →\n  mn ≤ (rand_range n mn mx).get ⟨i, sorry⟩ ∧ (rand_range n mn mx).get ⟨i, sorry⟩ ≤ mx := by\n  sorry\n\ntheorem primes_length (n : Nat) :\n  (primes n).length = n := by\n  sorry\n\ntheorem primes_ordered (n : Nat) (i : Nat) :\n  n > 0 → i < n - 1 →\n  (primes n).get ⟨i, sorry⟩ < (primes n).get ⟨i + 1, sorry⟩ := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [1, 4, 9, 16, 25]\n-/\n#guard_msgs in\n#eval squares 5\n\n/--\ninfo: [1, 4, 9]\n-/\n#guard_msgs in\n#eval squares 3\n\n/--\ninfo: [0, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval num_range 5 0 1\n\n/--\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval num_range 3 2 2\n\n/--\ninfo: [2, 3, 5, 7, 11]\n-/\n#guard_msgs in\n#eval primes 5"}
{"id": "fvapps_002930", "vc-description": "/-\nMost of this problem is by the original author of [the harder kata](https://www.codewars.com/kata/556206664efbe6376700005c), I just made it simpler.\n\nI read a book recently, titled \"Things to Make and Do in the Fourth Dimension\" by comedian and mathematician Matt Parker ( [Youtube](https://www.youtube.com/user/standupmaths) ), and in the first chapter of the book Matt talks about problems he likes to solve in his head to take his mind off the fact that he is in his dentist's chair, we've all been there!\n\nThe problem he talks about relates to polydivisible numbers, and I thought a kata should be written on the subject as it's quite interesting. (Well it's interesting to me, so there!)\n\n### Polydivisib... huh what?\n\nSo what are they?\n\nA polydivisible number is divisible in an unusual way. The first digit is cleanly divisible by `1`, the first two digits are cleanly divisible by `2`, the first three by `3`, and so on.\n\n### Examples\n\nLet's take the number `1232` as an example.\n```\n1     / 1 = 1     // Works\n12    / 2 = 6     // Works\n123   / 3 = 41    // Works\n1232  / 4 = 308   // Works\n```\n`1232` is a polydivisible number.\n\nHowever, let's take the number `123220` and see what happens.\n```\n 1      /1 = 1    // Works\n 12     /2 = 6    // Works\n 123    /3 = 41   // Works\n 1232   /4 = 308  // Works\n 12322  /5 = 2464.4         // Doesn't work\n 123220 /6 = 220536.333...  // Doesn't work\n```\n`123220` is not polydivisible.\n\n### Your job: check if a number is polydivisible or not.\n\nReturn `true` if it is, and `false` if it isn't.\n\nNote: All inputs will be valid numbers between `0` and `2^53-1 (9,007,199,254,740,991)` (inclusive).   \nNote: All single digit numbers (including `0`) are trivially polydivisible.\nNote: Except for `0`, no numbers will start with `0`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def polydivisible (n : Nat) : Bool :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry\n\ndef take_prefix (n : Nat) (len : Nat) : Nat :=\nsorry", "vc-theorems": "theorem polydivisible_characterization {n : Nat} :\n  polydivisible n ↔\n  (∀ i : Nat, i > 0 ∧ i ≤ (digits n).length →\n    take_prefix n i % i = 0) :=\nsorry\n\ntheorem single_digit_polydivisible {n : Nat} :\n  n > 0 ∧ n < 10 → polydivisible n :=\nsorry\n\ntheorem polydivisible_positive {n : Int} :\n  n ≤ 0 → polydivisible n.toNat = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 1232\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval polydivisible 123220\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 987654"}
{"id": "fvapps_002932", "vc-description": "/-\nThe AKS algorithm for testing whether a number is prime is a polynomial-time test based on the following theorem: \n\nA number p is prime if and only if all the coefficients of the polynomial expansion of `(x − 1)^p − (x^p − 1)` are divisible by `p`.\n\nFor example, trying `p = 3`:\n\n     (x − 1)^3 − (x^3 − 1) = (x^3 − 3x^2 + 3x − 1) − (x^3 − 1) = − 3x^2 + 3x \n\nAnd all the coefficients are divisible by 3, so 3 is prime.\n\nYour task is to code the test function, wich will be given an integer and should return true or false based on the above theorem. You should efficiently calculate every coefficient one by one and stop when a coefficient is not divisible by p to avoid pointless calculations. The easiest way to calculate coefficients is to take advantage of binomial coefficients: http://en.wikipedia.org/wiki/Binomial_coefficient and pascal triangle: http://en.wikipedia.org/wiki/Pascal%27s_triangle . \n\nYou should also take advantage of the symmetry of binomial coefficients. You can look at these kata: http://www.codewars.com/kata/pascals-triangle and http://www.codewars.com/kata/pascals-triangle-number-2\n\nThe kata here only use the simple theorem. The general AKS test is way more complex.  The simple approach is a good exercie but impractical. The general AKS test will be the subject of another kata as it is one of the best performing primality test algorithms.\n\nThe main problem of this algorithm is the big numbers emerging from binomial coefficients in the polynomial expansion. As usual Javascript reach its limit on big integer very fast. (This simple algorithm is far less performing than a trivial algorithm here). You can compare the results with those of this kata: http://www.codewars.com/kata/lucas-lehmer-test-for-mersenne-primes Here, javascript can barely treat numbers bigger than 50, python can treat M13 but not M17.\n-/", "vc-preamble": "def small_primes : List Nat := [2, 3, 5, 7, 11, 13, 17, 19]", "vc-helpers": "", "vc-definitions": "def aks_test : Nat → Bool :=\n  sorry", "vc-theorems": "theorem known_small_primes_correct (n : Nat) (h : 2 ≤ n ∧ n < 20) :\n  aks_test n = true ↔ n ∈ small_primes := by \nsorry\n\ntheorem numbers_less_than_2_not_prime {n : Nat} (h : n ≤ 1) :\n  aks_test n = false := by \nsorry\n\ntheorem prime_divisibility {n : Nat} (h : n ≥ 2) :\n  aks_test n = true → ∀ d : Nat, 2 ≤ d → d < n → ¬(n % d = 0) := by \nsorry\n\ntheorem composite_has_divisor {n : Nat} (h₁ : n ≥ 2) (h₂ : aks_test n = false) :\n  ∃ d : Nat, 2 ≤ d ∧ d < n ∧ n % d = 0 := by \nsorry\n\ntheorem product_not_prime {n m : Nat} (h₁ : n > 1) (h₂ : m > 1) (h₃ : n * m ≤ 10000) :\n  aks_test (n * m) = false := by \nsorry\n\ntheorem aks_consistency (n : Nat) (h : n ≥ 2) :\n  aks_test n = aks_test n := by \nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval aks_test 3\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval aks_test 4\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval aks_test 5"}
{"id": "fvapps_002934", "vc-description": "/-\nYou will be given a string and you task is to check if it is possible to convert that string into a palindrome by removing a single character. If the string is already a palindrome, return `\"OK\"`. If it is not, and we can convert it to a palindrome by removing one character, then return `\"remove one\"`, otherwise return `\"not possible\"`. The order of the characters should not be changed.\n\nFor example:\n```Haskell\nsolve(\"abba\") = \"OK\". -- This is a palindrome\nsolve(\"abbaa\") = \"remove one\". -- remove the 'a' at the extreme right. \nsolve(\"abbaab\") = \"not possible\". \n```\n\nMore examples in the test cases. \n\nGood luck!\n\nIf you like this Kata, please try [Single Character Palindromes II](https://www.codewars.com/kata/5a66ea69e6be38219f000110)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : String :=\nsorry\n\ndef isPalindrome (s : String) : Bool :=\nsorry\n\ndef canBePalindromeWithOneRemoval (s : String) : Bool :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem solve_result_valid (s : String) :\n  solve s = \"OK\" ∨ solve s = \"remove one\" ∨ solve s = \"not possible\" :=\nsorry\n\ntheorem ok_means_palindrome (s : String) :\n  solve s = \"OK\" → isPalindrome s :=\nsorry\n\ntheorem remove_one_means_possible_palindrome (s : String) :\n  solve s = \"remove one\" → canBePalindromeWithOneRemoval s :=\nsorry\n\ntheorem not_possible_means_neither (s : String) :\n  solve s = \"not possible\" → ¬isPalindrome s ∧ ¬canBePalindromeWithOneRemoval s :=\nsorry\n\ntheorem solve_symmetric (s : String) :\n  solve s = solve (reverse s) :=\nsorry\n\ntheorem single_char_ok (s : String) :\n  s.length = 1 → solve s = \"OK\" :=\nsorry\n\ntheorem two_chars_property (s : String) (h : s.length = 2) :\n  (s.front = s.back → solve s = \"OK\") ∧\n  (s.front ≠ s.back → solve s = \"remove one\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'OK'\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/--\ninfo: 'remove one'\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/--\ninfo: 'not possible'\n-/\n#guard_msgs in\n#eval solve \"abbaab\""}
{"id": "fvapps_002938", "vc-description": "/-\nThe local transport authority is organizing an online picture contest.\nParticipants must take pictures of transport means in an original way, and then post the picture on Instagram using a specific ```hashtag```.\n\nThe local transport authority needs your help. They want you to take out the ```hashtag``` from the posted message. Your task is to implement the function\n\n```python\ndef omit_hashtag(message, hashtag):\n```\n\n## Examples \n\n```\n* (\"Sunny day! #lta #vvv\", \"#lta\") -> \"Sunny day!  #vvv\" (notice the double space)\n* (\"#lta #picture_contest\", \"#lta\") -> \" #picture_contest\"\n```\n\n## Notes\n\n* When multiple occurences of the hashtag are found, delete only the first one.\n\n* In C, you should modify the ```message```, as the function returns a void type. In Python, you should return the answer.\n\n* There can be erroneous messages where the hashtag isn't present. The message should in this case stay untouched.\n\n* The hashtag only consists of alphanumeric characters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def omit_hashtag (message : String) (hashtag : String) : String :=\nsorry\n\ndef String.count (s t : String) : Nat :=\nsorry\n\ndef String.containsSubstring (s t : String) : Bool :=\nsorry", "vc-theorems": "theorem omit_hashtag_length (message hashtag : String) :\n  String.length (omit_hashtag message hashtag) ≤ String.length message :=\nsorry\n\ntheorem omit_hashtag_unchanged (message hashtag : String) :\n  ¬(String.containsSubstring message hashtag) → omit_hashtag message hashtag = message :=\nsorry\n\ntheorem omit_hashtag_count (message hashtag : String) (h1 : hashtag ≠ \"\")\n  (h2 : String.count message hashtag > 1) :\n  String.count (omit_hashtag message hashtag) hashtag = String.count message hashtag - 1 :=\nsorry\n\ntheorem omit_empty_hashtag (message : String) :\n  omit_hashtag message \"\" = message :=\nsorry\n\ntheorem omit_from_empty_message (hashtag : String) (h1 : hashtag ≠ \"\") :\n  omit_hashtag \"\" hashtag = \"\" :=\nsorry\n\ntheorem omit_hashtag_not_found (message hashtag : String)\n  (h1 : message ≠ \"\") (h2 : hashtag ≠ \"\") :\n  ¬(String.containsSubstring message hashtag) → omit_hashtag message hashtag = message :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Sunny day!  #vvv'\n-/\n#guard_msgs in\n#eval omit_hashtag \"Sunny day! #lta #vvv\" \"#lta\"\n\n/--\ninfo: ' #picture_contest'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest\" \"#lta\"\n\n/--\ninfo: ' #picture_contest #lta'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest #lta\" \"#lta\""}
{"id": "fvapps_002947", "vc-description": "/-\nGiven a list of unique words. Find all pairs of distinct indices (i, j) in the given list so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\n\nExamples:\n\nNon-string inputs should be converted to strings.\n\nReturn an array of arrays containing pairs of distinct indices that form palindromes. Pairs should be returned in the order they appear in the original list.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome (s : String) : Bool :=\nsorry\n\ndef isPalindromePair (s1 s2 : String) : Bool :=\nsorry\n\ndef palindromePairs (words : List String) : List (Nat × Nat) :=\nsorry", "vc-theorems": "theorem palindrome_pairs_valid_indices\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ pair, pair ∈ result →\n    pair.1 < words.length ∧\n    pair.2 < words.length ∧\n    pair.1 ≠ pair.2 :=\nsorry\n\ntheorem palindrome_pairs_forms_palindrome\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ pair, pair ∈ result →\n    palindrome (words[pair.1]! ++ words[pair.2]!) :=\nsorry\n\ntheorem palindrome_pairs_complete\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ i j, i < words.length → j < words.length → i ≠ j →\n    palindrome (words[i]! ++ words[j]!) →\n    (i,j) ∈ result :=\nsorry\n\ntheorem palindrome_pairs_unique\n  (words : List String) (result : List (Nat × Nat))\n  (h : result = palindromePairs words) :\n  ∀ p1 p2, p1 ∈ result → p2 ∈ result → p1 = p2 ∨ p1.1 ≠ p2.1 ∨ p1.2 ≠ p2.2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [[0, 1], [1, 0]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"bat\", \"tab\", \"cat\"]\n\n/--\ninfo: [[0, 3], [2, 4], [3, 0], [4, 2]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"dog\", \"cow\", \"tap\", \"god\", \"pat\"]\n\n/--\ninfo: [[0, 4], [1, 2], [2, 1]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [5777, \"dog\", \"god\", True, 75]"}
{"id": "fvapps_002954", "vc-description": "/-\nYour goal is to return multiplication table for ```number``` that is always an integer from 1 to 10.\n\nFor example, a multiplication table (string) for ```number == 5``` looks like below:\n\n```\n1 * 5 = 5\n2 * 5 = 10\n3 * 5 = 15\n4 * 5 = 20\n5 * 5 = 25\n6 * 5 = 30\n7 * 5 = 35\n8 * 5 = 40\n9 * 5 = 45\n10 * 5 = 50\n```\n\nP. S. You can use ```\\n``` in string to jump to the next line.\n-/", "vc-preamble": "structure MultiTableOutput where\n  lines : List String\n  deriving Inhabited", "vc-helpers": "", "vc-definitions": "def multiTable (n : Nat) : String :=\nsorry\n\ndef String.count_spaces (s : String) : Nat :=\nsorry\n\ndef parseMultiTable (s : String) : MultiTableOutput :=\nsorry", "vc-theorems": "theorem multi_table_length (n : Nat) (h : n > 0) :\n  (parseMultiTable (multiTable n)).lines.length = 10 :=\nsorry\n\ntheorem multi_table_format (n : Nat) (h : n > 0) (i : Nat) (h2 : i > 0 ∧ i ≤ 10) :\n  let output := parseMultiTable (multiTable n)\n  let line := output.lines[i-1]!\n  ∃ num1 num2 result : String,\n    line = num1 ++ \" * \" ++ num2 ++ \" = \" ++ result ∧\n    String.toNat! num1 = i ∧\n    String.toNat! num2 = n ∧\n    String.toNat! result = i * n :=\nsorry\n\ntheorem multi_table_no_trailing_newline (n : Nat) (h : n > 0) :\n  let s := multiTable n\n  s.length > 0 ∧ s.data[s.length - 1]! ≠ '\\n' :=\nsorry\n\ntheorem multi_table_spacing (n : Nat) (h : n > 0) (line : String)\n  (h2 : line ∈ (parseMultiTable (multiTable n)).lines) :\n  line.count_spaces = 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1 * 5 = 5\\n2 * 5 = 10\\n3 * 5 = 15\\n4 * 5 = 20\\n5 * 5 = 25\\n6 * 5 = 30\\n7 * 5 = 35\\n8 * 5 = 40\\n9 * 5 = 45\\n10 * 5 = 50'\n-/\n#guard_msgs in\n#eval multi_table 5\n\n/--\ninfo: '1 * 1 = 1\\n2 * 1 = 2\\n3 * 1 = 3\\n4 * 1 = 4\\n5 * 1 = 5\\n6 * 1 = 6\\n7 * 1 = 7\\n8 * 1 = 8\\n9 * 1 = 9\\n10 * 1 = 10'\n-/\n#guard_msgs in\n#eval multi_table 1\n\n/--\ninfo: '1 * 3 = 3\\n2 * 3 = 6\\n3 * 3 = 9\\n4 * 3 = 12\\n5 * 3 = 15\\n6 * 3 = 18\\n7 * 3 = 21\\n8 * 3 = 24\\n9 * 3 = 27\\n10 * 3 = 30'\n-/\n#guard_msgs in\n#eval multi_table 3"}
{"id": "fvapps_002963", "vc-description": "/-\nThe vowel substrings in the word `codewarriors` are `o,e,a,io`. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring.\nVowels are any of `aeiou`. \n\n```if:csharp\nDocumentation:\nKata.Solve Method (String)\n\nReturns the length of the greatest continuous vowel substring in a string.\n\nSyntax\n\npublic\nstatic\nint Solve(\nstring str\n    )\n\nParameters\n\nstr\n\nType: System.String\nThe string to be processed.\n\nReturn Value\n\nType: System.Int32\n  The length of the greatest continuous vowel substring in str, or 0 if str contains no vowels.\n\nExceptions\n\nException\nCondition\n\nArgumentNullException\nstr is null.\n\n```\n\nGood luck!\n\nIf you like substring Katas, please try:\n\n[Non-even substrings](https://www.codewars.com/kata/59da47fa27ee00a8b90000b4)\n\n[Vowel-consonant lexicon](https://www.codewars.com/kata/59cf8bed1a68b75ffb000026)\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def vowel (c : Char) : Bool :=\nsorry\n\ndef solve (s : String) : Nat :=\nsorry", "vc-theorems": "theorem solve_all_vowels (s : String)\n  (h₁ : s.length > 0)\n  (h₂ : ∀ c ∈ s.data, vowel c = true) :\n  solve s = s.length :=\nsorry\n\ntheorem solve_interspersed\n  (vowels : List String)\n  (consonants : List String)\n  (h₁ : vowels.length > 0)\n  (h₂ : ∀ s ∈ vowels, s.length > 0)\n  (h₃ : ∀ s ∈ vowels, ∀ c ∈ s.data, vowel c = true)\n  (h₄ : ∀ s ∈ consonants, ∀ c ∈ s.data, vowel c = false) :\n  let combined := List.zip vowels consonants\n  let s := String.join (combined.map (fun p => p.1 ++ p.2))\n  solve s ≥ (List.foldl (fun acc x => max acc x.length) 0 vowels) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_002964", "vc-description": "/-\n###Lucky number\n\nWrite a function to find if a number is lucky or not. If the sum of all digits is 0 or multiple of 9 then the number is lucky.\n\n`1892376 => 1+8+9+2+3+7+6 = 36`. 36 is divisble by 9, hence number is lucky.\n\nFunction will return `true` for lucky numbers and `false` for others.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_lucky (n : Nat) : Bool :=\n  sorry\n\ndef sum_of_digits (n : Nat) : Nat :=\n  sorry\n\ndef concat_digits (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem lucky_digit_sum_property (n : Nat) :\n  is_lucky n = (sum_of_digits n = 0 ∨ sum_of_digits n % 9 = 0) :=\nsorry\n\ntheorem lucky_concatenation (n : Nat) :\n  is_lucky n → (\n    is_lucky (concat_digits n 9) ∧\n    is_lucky (concat_digits n 99)\n  ) :=\nsorry\n\ntheorem lucky_edge_cases :\n  is_lucky 0 ∧ is_lucky 9 ∧ is_lucky 99 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 1892376\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_lucky 189237\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 0"}
{"id": "fvapps_002966", "vc-description": "/-\nSo you've found a meeting room - phew! You arrive there ready to present, and find that someone has taken one or more of the chairs!! You need to find some quick.... check all the other meeting rooms to see if all of the chairs are in use.\n\nYour meeting room can take up to 8 chairs. `need` will tell you how many have been taken. You need to find that many.\n\n```if-not:java\nFind the spare chairs from the array of meeting rooms. Each meeting room array will have the number of occupants as a string. Each occupant is represented by 'X'. The room array will also have an integer telling you how many chairs there are in the room.\n```\n```if:java\nFind the spare chairs from the array of meeting rooms.\n~~~java\npublic class Room {\n  public final String occupants;  // number of occupants, each occupant is represented by 'X'\n  public final int chairs;        // number of chairs in the room\n}\n~~~\n```\n\nYou should return an array of integers that shows how many chairs you take from each room in order, up until you have the required amount.\n\n```if-not:java\nexample:\n[['XXX', 3], ['XXXXX', 6], ['XXXXXX', 9], ['XXX',2]] when you need 4 chairs:\n```\n```if:java\nexample:\n`[Room(\"XXX\", 3), Room(\"XXXXX\", 6), Room(\"XXXXXX\", 9), Room(\"XXX\",2)]` when you need 4 chairs:\n```\n\nresult -- > `[0, 1, 3]` (no chairs free in room 0, take 1 from room 1, take 3 from room 2. No need to consider room 4 as you have your 4 chairs already.\n\nIf you need no chairs, return `'Game On'`. If there aren't enough spare chairs available, return `'Not enough!'`\n\nMore in this series:\n\nThe Office I - Outed\nThe Office II - Boredeom Score\nThe Office III - Broken Photocopier\nThe Office IV - Find a Meeting Room\n-/", "vc-preamble": "def Room := (String × Nat)\n\ndef listSum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + listSum xs\n\ndef listAll : List Nat → (Nat → Bool) → Bool\n  | [], _ => true\n  | x::xs, p => p x && listAll xs p", "vc-helpers": "", "vc-definitions": "def meeting (rooms : List Room) (need : Nat) : String ⊕ List Nat :=\nsorry", "vc-theorems": "theorem meeting_zero_need {rooms : List Room} :\n  meeting rooms 0 = Sum.inl \"Game On\" :=\nsorry\n\ntheorem meeting_huge_need {rooms : List Room} {need : Nat} :\n  (need > listSum (rooms.map (fun r => max (r.2 - r.1.length) 0))) →\n  meeting rooms need = Sum.inl \"Not enough!\" :=\nsorry\n\ntheorem meeting_valid_solution {rooms : List Room} {need : Nat} {result : List Nat} :\n  meeting rooms need = Sum.inr result →\n  (\n    (result.length ≤ rooms.length) ∧\n    (listAll result (fun x => x ≥ 0)) ∧\n    (listSum result = need) ∧\n    (rooms.zip result).all (fun p =>\n      let room := p.1\n      let taken := p.2\n      taken ≤ max (room.2 - room.1.length) 0\n    )\n  ) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [0, 1, 3]\n-/\n#guard_msgs in\n#eval meeting [[\"XXX\", 3], [\"XXXXX\", 6], [\"XXXXXX\", 9]] 4\n\n/--\ninfo: 'Game On'\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 0\n\n/--\ninfo: [0, 2]\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 2"}
{"id": "fvapps_002970", "vc-description": "/-\nWrite a method named `getExponent(n,p)` that returns the largest integer exponent `x` such that p^(x) evenly divides `n`. if `p<=1` the method should return `null`/`None` (throw an `ArgumentOutOfRange` exception in C#).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_exponent (n p : Int) : Option Int :=\n  sorry\n\ndef pow (x y : Int) : Int :=\n  sorry", "vc-theorems": "theorem get_exponent_divides {n p : Int} (h1 : n ≥ 2) (h2 : p ≥ 2) :\n  match get_exponent n p with\n  | none => False\n  | some k =>\n    (k = 0 → n % p ≠ 0) ∧\n    (k > 0 → n % (pow p k) = 0 ∧ n % (pow p (k + 1)) ≠ 0)\n  :=\nsorry\n\ntheorem get_exponent_nonnegative {n p : Int} (h1 : n ≥ 2) (h2 : p ≥ 2) :\n  match get_exponent n p with\n  | none => False\n  | some k => k ≥ 0\n  :=\nsorry\n\ntheorem get_exponent_invalid_divisor {n p : Int} (h : p ≤ 1) :\n  get_exponent n p = none :=\nsorry\n\ntheorem get_exponent_prime_power {n p : Int} (h1 : n ≥ 2) (h2 : p = 2) :\n  get_exponent (n * (pow p 5)) p = Option.some ((get_exponent n p).getD 0 + 5) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval get_exponent 27 3\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval get_exponent 28 2\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval get_exponent 10 0"}
{"id": "fvapps_002972", "vc-description": "/-\n# Task\n Given a string `s`, find out if its characters can be rearranged to form a palindrome.\n\n# Example\n\n For `s = \"aabb\"`, the output should be `true`.\n\n We can rearrange `\"aabb\"` to make `\"abba\"`, which is a palindrome.\n\n# Input/Output\n\n - `[input]` string `s`\n\n    A string consisting of lowercase English letters.\n\n    Constraints:\n\n    `4 ≤ inputString.length ≤ 50.`\n\n - `[output]` a boolean value\n\n    `true` if the characters of the inputString can be rearranged to form a palindrome, `false` otherwise.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Count of chars with odd occurrences -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome_rearranging (s : String) : Bool :=\n  sorry\n\ndef String.reverse (s : String) : String :=\n  sorry\n\ndef String.repeating (c : Char) (n : Nat) : String :=\n  sorry\n\ndef odd_char_count (s : String) : Nat :=\nsorry", "vc-theorems": "theorem palindrome_rearranging_symmetry (s : String) :\n  palindrome_rearranging s = palindrome_rearranging (String.reverse s) :=\nsorry\n\ntheorem palindrome_rearranging_duplicates (s : String) (h : s.length > 0) :\n  palindrome_rearranging (s ++ s) = true :=\nsorry\n\ntheorem palindrome_rearranging_single_char (s : String) (h : s.length > 0) (c : Char) :\n  palindrome_rearranging (String.repeating c s.length) = true :=\nsorry\n\ntheorem palindrome_rearranging_empty_and_single (s : String) (h : s.length ≤ 1) :\n  palindrome_rearranging s = true :=\nsorry\n\ntheorem palindrome_rearranging_odd_counts (s : String) :\n  palindrome_rearranging s = (odd_char_count s ≤ 1) :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aabb\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"abbcabb\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aaabbb\""}
{"id": "fvapps_002975", "vc-description": "/-\nA trick I learned in elementary school to determine whether or not a number was divisible by three is to add all of the integers in the number together and to divide the resulting sum by three. If there is no remainder from dividing the sum by three, then the original number is divisible by three as well.\n\nGiven a series of numbers as a string, determine if the number represented by the string is divisible by three.\n\nYou can expect all test case arguments to be strings representing values greater than 0. \n\nExample:\n\n```\n\"123\"      -> true\n\"8409\"     -> true\n\"100853\"   -> false\n\"33333333\" -> true\n\"7\"        -> false\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def divisible_by_three (s : String) : Bool :=\n  sorry\n\ndef digit_sum (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem divisible_by_three_matches_mod (n : Nat) :\n  divisible_by_three (toString n) = (n % 3 = 0) :=\nsorry\n\ntheorem divisible_by_three_digit_sum (n : Nat) :\n  divisible_by_three (toString n) = (digit_sum (toString n) % 3 = 0) :=\nsorry\n\ntheorem append_zeros_preserves_divisibility (n : Nat) (k : Nat) (h : 0 < k ∧ k ≤ 10) :\n  divisible_by_three (toString n ++ String.mk (List.replicate k '0')) =\n  divisible_by_three (toString n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"123\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval divisible_by_three \"88\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"963210456\""}
{"id": "fvapps_002977", "vc-description": "/-\n# Task\n Let's call `product(x)` the product of x's digits. Given an array of integers a, calculate `product(x)` for each x in a, and return the number of distinct results you get.\n\n# Example\n\n For `a = [2, 8, 121, 42, 222, 23]`, the output should be `3`.\n\n Here are the products of the array's elements:\n```\n2: product(2) = 2;\n8: product(8) = 8;\n121: product(121) = 1 * 2 * 1 = 2;\n42: product(42) = 4 * 2 = 8;\n222: product(222) = 2 * 2 * 2 = 8;\n23: product(23) = 2 * 3 = 6.```\nAs you can see, there are only `3` different products: `2, 6 and 8.`\n\n# Input/Output\n\n - `[input]` integer array `a`\n\n    Constraints:\n\n    `1 ≤ a.length ≤ 10000,`\n\n    `1 ≤ a[i] ≤ 1000000000.`\n\n - `[output]` an integer\n\n    The number of different digit products in `a`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def uniqueDigitProducts (nums : List Nat) : Nat :=\n  sorry\n\ndef List.toSet (l : List α) : List α :=\n  sorry", "vc-theorems": "theorem uniqueDigitProducts_bounds_nat {nums : List Nat} (h : nums.length > 0) :\n  1 ≤ uniqueDigitProducts nums ∧ uniqueDigitProducts nums ≤ nums.length :=\nsorry\n\ntheorem uniqueDigitProducts_single_digits {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n ≤ 9) :\n  uniqueDigitProducts nums ≤ (List.toSet nums).length :=\nsorry\n\ntheorem uniqueDigitProducts_all_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n = 0) :\n  uniqueDigitProducts nums = 1 :=\nsorry\n\ntheorem uniqueDigitProducts_three_digit_no_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : ∀ n ∈ nums, 100 ≤ n ∧ n ≤ 999)\n  (h3 : ∀ n ∈ nums, ¬ toString n = \"0\") :\n  uniqueDigitProducts nums > 0 :=\nsorry\n\ntheorem uniqueDigitProducts_permutation {nums : List Nat}\n  (h : nums.length > 1) :\n  let n := nums[0]\n  let nums_with_perm := n :: nums\n  uniqueDigitProducts nums_with_perm ≥ uniqueDigitProducts nums :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval unique_digit_products [2, 8, 121, 42, 222, 23]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval unique_digit_products [239]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval unique_digit_products [100, 101, 111]"}
{"id": "fvapps_002983", "vc-description": "/-\nFrom this lesson, we learn about JS static object: ```Math```. It mainly helps us to carry out mathematical calculations. It has a lot of properties and methods. Some of the properties and methods we rarely used. So we only learn some common methods.\n\nThe properties of the Math object are some constants, such as PI, on behalf of the approximate value of pi. The usage is ```Math.PI```. I will no longer introduce one by one, please refer to the manual:\n\n  - [Math Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math)\n\nIn this lesson we learn three methods to turn a number into an integer: ```round()```, ```ceil()``` and ```floor()```. \n\nTheir definitions and detailed information:\n\n- [Math.round()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round)\n- [Math.ceil()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)\n- [Math.floor()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)\n\nFirst of all, we have to understand the first thing, all the methods of the Math object are static methods. It means that you need to use the Math method like this: ```Math.round(1.23)```. Not like this: ```(1.23).round()```.\n\nHere we use some examples to understand their usage:\n\nWe can see, ```ceil()``` always rounding up to get a large integer; ```floor()``` always rounding down to get a small integer; ```round()``` according to the fractional part and round it to integer.\n\nWhen the parameter is negative, they still works:\nIt should be noted that they are not working on the fractional part. If you want to keep two decimal places or otherwise, you should use [Methods of Number object--toFixed(), toExponential() and toPrecision()](http://www.codewars.com/kata/57256064856584bc47000611), or use the following techniques:\nIn the example above, we first multiply the number by 100, and then round it. the final result is to retain two decimal places.\n\nOk, lesson is over. let's us do some task.\n\n## Task\n\nCoding in function ```roundIt```. function accept 1 parameter ```n```. It's a number with a decimal point. Please use different methods based on the location of the decimal point, turn the number into an integer.\n\nIf the decimal point is on the left side of the number (that is, the count of digits on the left of the decimal point is less than that on the right), Using ```ceil()``` method.\n```\nroundIt(3.45) should return 4\n```\nIf the decimal point is on the right side of the number (that is, the count of digits on the left of the decimal point is more than that on the right), Using ```floor()``` method.\n```\nroundIt(34.5) should return 34\n```\nIf the decimal point is on the middle of the number (that is, the count of digits  on the left of the decimal point is equals that on the right), Using ```round()``` method.\n```\nroundIt(34.56) should return 35\n```\n\n## [Series](http://github.com/myjinxin2015/Katas-list-of-Training-JS-series)\n\n( ↑↑↑ Click the link above can get my newest kata list, Please add it to your favorites)\n\n - [#1: create your first JS function helloWorld](http://www.codewars.com/kata/571ec274b1c8d4a61c0000c8)\n - [#2: Basic data types--Number](http://www.codewars.com/kata/571edd157e8954bab500032d)\n - [#3:  Basic data types--String](http://www.codewars.com/kata/571edea4b625edcb51000d8e)\n - [#4:  Basic data types--Array](http://www.codewars.com/kata/571effabb625ed9b0600107a)\n - [#5:  Basic data types--Object](http://www.codewars.com/kata/571f1eb77e8954a812000837)\n - [#6:  Basic data types--Boolean and conditional statements if..else](http://www.codewars.com/kata/571f832f07363d295d001ba8)\n - [#7:  if..else and ternary operator](http://www.codewars.com/kata/57202aefe8d6c514300001fd)\n - [#8: Conditional statement--switch](http://www.codewars.com/kata/572059afc2f4612825000d8a)\n - [#9: loop statement --while and do..while](http://www.codewars.com/kata/57216d4bcdd71175d6000560)\n - [#10: loop statement --for](http://www.codewars.com/kata/5721a78c283129e416000999)\n - [#11: loop statement --break,continue](http://www.codewars.com/kata/5721c189cdd71194c1000b9b)\n - [#12: loop statement --for..in and for..of](http://www.codewars.com/kata/5722b3f0bd5583cf44001000)\n - [#13: Number object and  its properties](http://www.codewars.com/kata/5722fd3ab7162a3a4500031f)\n - [#14: Methods of Number object--toString() and toLocaleString()](http://www.codewars.com/kata/57238ceaef9008adc7000603)\n - [#15: Methods of Number object--toFixed(), toExponential() and toPrecision()](http://www.codewars.com/kata/57256064856584bc47000611)\n - [#16: Methods of String object--slice(), substring() and substr()](http://www.codewars.com/kata/57274562c8dcebe77e001012)\n - [#17: Methods of String object--indexOf(), lastIndexOf() and search()](http://www.codewars.com/kata/57277a31e5e51450a4000010)\n - [#18: Methods of String object--concat() split() and its good friend join()](http://www.codewars.com/kata/57280481e8118511f7000ffa)\n - [#19: Methods of String object--toUpperCase() toLowerCase() and replace()](http://www.codewars.com/kata/5728203b7fc662a4c4000ef3)\n - [#20: Methods of String object--charAt() charCodeAt() and fromCharCode()](http://www.codewars.com/kata/57284d23e81185ae6200162a)\n - [#21: Methods of String object--trim() and the string template](http://www.codewars.com/kata/5729b103dd8bac11a900119e)\n - [#22: Unlock new skills--Arrow function,spread operator and deconstruction](http://www.codewars.com/kata/572ab0cfa3af384df7000ff8)\n - [#23: methods of arrayObject---push(), pop(), shift() and unshift()](http://www.codewars.com/kata/572af273a3af3836660014a1)\n - [#24: methods of arrayObject---splice() and slice()](http://www.codewars.com/kata/572cb264362806af46000793)\n - [#25: methods of arrayObject---reverse() and sort()](http://www.codewars.com/kata/572df796914b5ba27c000c90)\n - [#26: methods of arrayObject---map()](http://www.codewars.com/kata/572fdeb4380bb703fc00002c)\n - [#27: methods of arrayObject---filter()](http://www.codewars.com/kata/573023c81add650b84000429)\n - [#28: methods of arrayObject---every() and some()](http://www.codewars.com/kata/57308546bd9f0987c2000d07)\n - [#29: methods of arrayObject---concat() and join()](http://www.codewars.com/kata/5731861d05d14d6f50000626)\n - [#30: methods of arrayObject---reduce() and reduceRight()](http://www.codewars.com/kata/573156709a231dcec9000ee8)\n - [#31: methods of arrayObject---isArray() indexOf() and toString()](http://www.codewars.com/kata/5732b0351eb838d03300101d)\n - [#32: methods of Math---round() ceil() and floor()](http://www.codewars.com/kata/5732d3c9791aafb0e4001236)\n - [#33: methods of Math---max() min() and abs()](http://www.codewars.com/kata/5733d6c2d780e20173000baa)\n - [#34: methods of Math---pow() sqrt() and cbrt()](http://www.codewars.com/kata/5733f948d780e27df6000e33)\n - [#35: methods of Math---log() and its family](http://www.codewars.com/kata/57353de879ccaeb9f8000564)\n - [#36: methods of Math---kata author's lover:random()](http://www.codewars.com/kata/5735956413c2054a680009ec)\n - [#37: Unlock new weapon---RegExp Object](http://www.codewars.com/kata/5735e39313c205fe39001173)\n - [#38: Regular Expression--\"^\",\"$\", \".\" and test()](http://www.codewars.com/kata/573975d3ac3eec695b0013e0)\n - [#39: Regular Expression--\"?\", \"*\", \"+\" and \"{}\"](http://www.codewars.com/kata/573bca07dffc1aa693000139)\n - [#40: Regular Expression--\"|\", \"[]\" and \"()\"](http://www.codewars.com/kata/573d11c48b97c0ad970002d4)\n - [#41: Regular Expression--\"\\\"](http://www.codewars.com/kata/573e6831e3201f6a9b000971)\n - [#42: Regular Expression--(?:), (?=) and (?!)](http://www.codewars.com/kata/573fb9223f9793e485000453)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def roundIt (x : Float) : Int :=\nsorry\n\ndef floor (x : Float) : Int :=\nsorry\n\ndef ceil (x : Float) : Int :=\nsorry\n\ndef floatToStr (x : Float) : String :=\nsorry", "vc-theorems": "theorem round_it_decimals (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) <\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = ceil x :=\nsorry\n\ntheorem round_it_decimals_floor (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) >\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = floor x :=\nsorry\n\ntheorem round_it_decimals_equal_length (x : Float)\n  (h₁ : Float.floor x ≠ x)\n  (h₂ : String.length (floatToStr (Float.floor (Float.abs x))) =\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = if x > 0 then ceil x else floor x :=\nsorry\n\ntheorem round_it_integers (n : Int) :\n  roundIt (Float.ofInt n) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval round_it 3.45\n\n/--\ninfo: 34\n-/\n#guard_msgs in\n#eval round_it 34.5\n\n/--\ninfo: 35\n-/\n#guard_msgs in\n#eval round_it 34.56"}
{"id": "fvapps_002988", "vc-description": "/-\nWrite a function that removes every lone 9 that is inbetween 7s.\n\n```python\nseven_ate9('79712312') => '7712312'\nseven_ate9('79797') => '777'\n```\n\nInput: String\nOutput: String\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def seven_ate9 (s : String) : String :=\nsorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\nsorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "def iterativeReplace (s : String) (n : Nat) : String :=\n  match n with\n  | 0 => s\n  | n + 1 =>\n    if containsSubstr s \"797\"\n    then iterativeReplace (s.replace \"797\" \"77\") n\n    else s\n\ntheorem output_is_string {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).all (fun c => c.isDigit) :=\nsorry\n\ntheorem output_length_correct {s : String} :\n  s.all (fun c => c.isDigit) →\n  (seven_ate9 s).length = s.length - (countSubstr s \"797\") :=\nsorry\n\ntheorem no_797_in_result {s : String} :\n  s.all (fun c => c.isDigit) →\n  ¬(containsSubstr (seven_ate9 s) \"797\") :=\nsorry\n\ntheorem only_797_modified {s : String} :\n  s.all (fun c => c.isDigit) →\n  seven_ate9 s = iterativeReplace s s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '7712312'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79712312\"\n\n/--\ninfo: '777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79797\"\n\n/--\ninfo: '7777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"7979797\""}
{"id": "fvapps_003000", "vc-description": "/-\nThe integer ```64``` is the first integer that has all of its digits even and furthermore, is a perfect square.\n\nThe second one is ```400``` and the third one ```484```.\n\nGive the numbers of this sequence that are in the range ```[a,b] ```(both values inclusive)\n\nExamples:\n``` python\neven_digit_squares(100, 1000) == [400, 484] # the output should be sorted.\neven_digit_squares(1000, 4000) == []\n``` \n\nFeatures of the random tests for ```even_digit_squares(a, b)```\n```\nnumber of Tests = 167\nmaximum value for a = 1e10\nmaximum value for b = 1e12\n```\nYou do not have to check the entries, ```a``` and ```b``` always positive integers and ```a < b``` \n\nHappy coding!!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.toString (n : Nat) : String :=\n  sorry\n\ndef is_even (n : Nat) : Bool :=\n  sorry\n\ndef List.sort {α : Type} [Ord α] (as : List α) : List α :=\n  sorry\n\ndef even_digit_squares (start : Nat) (stop : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem is_even_matches_digit_check (x : Nat) :\n  is_even x = (Nat.toString x |>.data |>.all (fun d => (Char.toNat d - 48) % 2 = 0)) :=\nsorry\n\ntheorem even_digit_squares_properties {a b : Nat}\n  (h : a ≤ 1000000 ∧ b ≤ 1000000) :\n  let start := min a b\n  let stop := max a b\n  let result := even_digit_squares start stop\n  (∀ x ∈ result, x ≥ start ∧ x ≤ stop) ∧\n  (∀ x ∈ result, is_even x = true) ∧\n  (∀ x ∈ result, ∃ y:Nat, y * y = x) ∧\n  (result = List.sort result) :=\nsorry\n\ntheorem single_point_range {x : Nat} (h : x ≤ 1000000) :\n  let result := even_digit_squares x x\n  result ≠ [] →\n  (result.length = 1 ∧\n   result.head! = x ∧\n   is_even x = true ∧\n   ∃ y:Nat, y * y = x) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003004", "vc-description": "/-\nDebug the functions\nShould be easy, begin by looking at the code. Debug the code and the functions should work.\nThere are three functions: ```Multiplication (x)``` ```Addition (+)``` and ```Reverse (!esreveR)```\n\ni {\n  font-size:16px;\n}\n\n#heading {\n  padding: 2em;\n  text-align: center;\n  background-color: #0033FF;\n  width: 100%;\n  height: 5em;\n}\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multi (l : List Int) : Int :=\nsorry\n\ndef add (l : List Int) : Int :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem multi_neutral (l : List Int) (h : l.length ≥ 1) :\n  multi (l ++ [1]) = multi l :=\nsorry\n\ntheorem multi_order_indep (l : List Int) (h : l.length ≥ 1) :\n  multi l = multi l.reverse :=\nsorry\n\ntheorem add_neutral (l : List Int) :\n  add (l ++ [0]) = add l :=\nsorry\n\ntheorem add_order_indep (l : List Int) :\n  add l = add l.reverse :=\nsorry\n\ntheorem add_recursive (l : List Int) (h : l ≠ []) :\n  add l = add (l.take (l.length - 1)) + l.getLast h :=\nsorry\n\ntheorem reverse_involution (s : String) :\n  reverse (reverse s) = s :=\nsorry\n\ntheorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :=\nsorry\n\ntheorem reverse_first_last_char (s : String) (h₁ : s.length > 0) :\n  let n := s.length\n  let rs := reverse s\n  rs.front = s.back ∧ rs.back = s.front :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 80\n-/\n#guard_msgs in\n#eval multi [8, 2, 5]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval add [1, 2, 3]\n\n/--\ninfo: 'olleh'\n-/\n#guard_msgs in\n#eval reverse \"hello\""}
{"id": "fvapps_003009", "vc-description": "/-\n# Task\n Suppose there are `n` people standing in a circle and they are numbered 1 through n in order. \n\n Person 1 starts off with a sword and kills person 2. He then passes the sword to the next person still standing, in this case person 3. Person 3 then uses the sword to kill person 4, and passes it to person 5. This pattern continues around and around the circle until just one person remains.\n\n What is the number of this person? \n\n# Example: \n\n For `n = 5`, the result should be `3`.\n```\n1 kills 2, passes to 3.\n3 kills 4, passes to 5.\n5 kills 1, passes to 3.\n3 kills 5 and wins.```\n\n# Input/Output\n\n - `[input]` integer `n`\n\n  The number of people. 1 through n standing in a circle.\n\n  `1 <= n <= 1e9`\n\n - `[output]` an integer\n\n  The index of the last person standing.\n-/\n\n/-\n  Main property theorems\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  Pattern theorems\n-/\n\n-- For n > 1, removing leading '1' from binary representation and appending '1'", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def circle_slash (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem circle_slash_range (n : Nat) (h : n > 0) :\n  1 ≤ circle_slash n ∧ circle_slash n ≤ n :=\nsorry\n\ntheorem circle_slash_odd_unless_power_of_two (n : Nat) (h : n > 0)\n  (h_not_power_2 : ¬∃k, n = 2^k) :\n  circle_slash n % 2 = 1 :=\nsorry\n\ntheorem circle_slash_power_of_two (k : Nat) :\n  circle_slash (2^k) = 1 :=\nsorry\n\ntheorem circle_slash_binary_pattern (n : Nat) (h : n > 1) :\n\n  circle_slash n = (n % (2^(Nat.log2 n))) * 2 + 1 :=\nsorry\n\ntheorem circle_slash_one :\n  circle_slash 1 = 1 :=\nsorry", "vc-postamble": "/--\ninfo: 3\n-/\n#guard_msgs in\n#eval circle_slash 5\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval circle_slash 11\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval circle_slash 16"}
{"id": "fvapps_003019", "vc-description": "/-\nA palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. Examples of numerical palindromes are: `2332, 110011, 54322345`\n\nFor a given number ```num```, write a function which returns an array of all the numerical palindromes contained within each number. The array should be sorted in ascending order and any duplicates should be removed.\n\nIn this kata, single digit numbers and numbers which start or end with zeros (such as `010` and `00`) are **NOT** considered valid numerical palindromes.  \n\nIf `num` contains no valid palindromes, return `\"No palindromes found\"`. \nOtherwise, return `\"Not valid\"` if the input is not an integer or is less than `0`.\n\n## Examples\n\n```\npalindrome(1221)      =>  [22, 1221]\npalindrome(34322122)  =>  [22, 212, 343, 22122]\npalindrome(1001331)   =>  [33, 1001, 1331]\npalindrome(1294)      =>  \"No palindromes found\"\npalindrome(\"1221\")    =>  \"Not valid\"\n```\n\n---\n\n### Other Kata in this Series:\n\nNumerical Palindrome #1\nNumerical Palindrome #1.5\nNumerical Palindrome #2\nNumerical Palindrome #3\nNumerical Palindrome #3.5\nNumerical Palindrome #4\nNumerical Palindrome #5\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome (n : Int) : String :=\nsorry\n\ndef isNumericPalindrome (n : Int) : Bool :=\nsorry\n\ndef contains (haystack : String) (needle : String) : Bool :=\nsorry\n\ndef stringToInt (s : String) : Option Int :=\nsorry", "vc-theorems": "theorem invalid_input_negative (n : Int) :\n  n < 0 → palindrome n = \"Not valid\"\n  :=\nsorry\n\ntheorem valid_input_contains_palindromes (n : Int) :\n  n ≥ 0 → palindrome n ≠ \"Not valid\" →\n  let result := palindrome n\n  let numStr := toString n\n  ∀ p ∈ result.split (· = ','),\n    (∃ s : String, s = p ∧ contains numStr s ∧\n      match stringToInt s with\n      | some i => isNumericPalindrome i\n      | none => false)\n  :=\nsorry\n\ntheorem valid_input_sorted_results (n : Int) :\n  n ≥ 0 → palindrome n ≠ \"Not valid\" →\n  let result := palindrome n\n  let nums := result.split (· = ',')\n  ∀ i j, i < j → j < nums.length →\n    match stringToInt (nums.get! i), stringToInt (nums.get! j) with\n    | some x, some y => x ≤ y\n    | _, _ => true\n  :=\nsorry\n\ntheorem no_palindromes_when_none_exist (n : Int) (numStr : String := toString n) :\n  n ≥ 0 →\n  (∀ s : String, contains numStr s →\n    match stringToInt s with\n    | some i => ¬isNumericPalindrome i\n    | none => true) →\n  palindrome n = \"No palindromes found\"\n  :=\nsorry\n\ntheorem invalid_input_float (f : Float) :\n  palindrome 0 = \"Not valid\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [22, 212, 343, 22122]\n-/\n#guard_msgs in\n#eval palindrome 34322122\n\n/--\ninfo: 'No palindromes found'\n-/\n#guard_msgs in\n#eval palindrome 1294\n\n/--\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome -123"}
{"id": "fvapps_003021", "vc-description": "/-\n# Task\n You are given three integers `l, d and x`. Your task is:\n```\n• determine the minimal integer n \n    such that l ≤ n ≤ d, and the sum of its digits equals x.\n• determine the maximal integer m \n    such that l ≤ m ≤ d, and the sum of its digits equals x.\n```\nIt is guaranteed that such numbers always exist.\n\n# Input/Output\n\n - `[input]` integer `l`\n\n - `[input]` integer `d`\n\n  `1 ≤ l ≤ d ≤ 10000.`\n\n - `[input]` integer `x`\n\n  `1 ≤ x ≤ 36`\n\n - `[output]` an integer array\n\n  Array of two elements, where the first element is `n`, and the second one is `m`.\n\n# Example\n\n For `l = 500, d = 505, x = 10`, the output should be `[505, 505]`.\n\n For `l = 100, d = 200, x = 10`, the output should be `[109, 190]`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_and_max (l d x : Nat) : List Nat :=\n  sorry\n\ndef sum_of_digits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_and_max_properties {l d x : Nat}\n  (h1: l ≤ d)\n  (h2: l > 0)\n  (h3: d ≤ 1000)\n  (h4: x ≤ 27)\n  (h5: ∃ n, l ≤ n ∧ n ≤ d ∧ sum_of_digits n = x) :\n  let result := min_and_max l d x\n  List.length result = 2 ∧\n  result[0]! ≤ result[1]! ∧\n  l ≤ result[0]! ∧ result[0]! ≤ d ∧\n  l ≤ result[1]! ∧ result[1]! ≤ d ∧\n  sum_of_digits result[0]! = x ∧\n  sum_of_digits result[1]! = x :=\nsorry\n\ntheorem min_and_max_identical_bounds {n : Nat}\n  (h1: n > 0)\n  (h2: n ≤ 1000) :\n  let x := sum_of_digits n\n  let result := min_and_max n n x\n  result[0]! = n ∧ result[1]! = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [109, 190]\n-/\n#guard_msgs in\n#eval min_and_max 100 200 10\n\n/--\ninfo: [505, 505]\n-/\n#guard_msgs in\n#eval min_and_max 500 505 10\n\n/--\ninfo: [104, 500]\n-/\n#guard_msgs in\n#eval min_and_max 99 501 5"}
{"id": "fvapps_003022", "vc-description": "/-\nBleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number N. Then she starts naming N, 2 × N, 3 × N, and so on.\nWhenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.\nBleatrix must start with N and must always name (i + 1) × N directly after i × N.\nFor example, suppose that Bleatrix picks N = 1692. She would count as follows:\n\nN = 1692. Now she has seen the digits 1, 2, 6, and 9.\n2N = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9.\n3N = 5076. Now she has seen all ten digits, and falls asleep.\n\nThe purpose of this kata is to return the last number Bleatrix Trotter sees before falling asleep.\nInput\nWill always be positive integer or zero\n\nOutput\nThe last number Bleatrix Trotter sees or \"INSOMNIA\" (-1 in Rust and C++) if she will count forever\n\nPlease note, this challenge is not my idea. It's from Google Code Jam 2016\n-/\n\n-- Define the special case", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def trotter (n: Int) : Int :=\nsorry\n\ndef isInsomnia (n: Int) : Bool :=\nsorry", "vc-theorems": "theorem trotter_positive_multiple {n : Int} (h : n > 0) :\n  ∃ k : Int, trotter n = n * k ∧ k > 0 :=\nsorry\n\ntheorem trotter_zero :\n  isInsomnia (trotter 0) = true :=\nsorry\n\ntheorem trotter_nonzero {n : Int} (h : n > 0) :\n  trotter n > 0 :=\nsorry\n\ntheorem trotter_grows {n : Int} (h : n > 0) :\n  trotter n ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 5076\n-/\n#guard_msgs in\n#eval trotter 1692\n\n/--\ninfo: 90\n-/\n#guard_msgs in\n#eval trotter 2\n\n/--\ninfo: 'INSOMNIA'\n-/\n#guard_msgs in\n#eval trotter 0"}
{"id": "fvapps_003024", "vc-description": "/-\nLooking at consecutive powers of `2`, starting with `2^1`:\n\n`2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, ...`\n\nNote that out of all the digits `0-9`, the last one ever to appear is `7`. It only shows up for the first time in the number `32768 (= 2^15)`.\n\nSo let us define LAST DIGIT TO APPEAR as the last digit to be written down when writing down all the powers of `n`, starting with `n^1`.\n\n## Your task\n\nYou'll be given a positive integer ```1 =< n <= 10000```, and must return the last digit to appear, as an integer.\n\nIf for any reason there are digits which never appear in the sequence of powers, return `None`/`nil`.\n\nPlease note: The Last digit to appear can be in the same number as the penultimate one. For example for `n = 8`, the last digit to appear is `7`, although `3` appears slightly before it, in the same number:\n`8, 64, 512, 4096, 32768, ...`\n-/\n\n-- Theorem stating result is a single digit if not None\n\n-- Theorem stating if result exists, it must appear last in sequence\n\n-- Theorem for None case - either powers stabilize or never complete", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits_of (n : Nat) : List Nat :=\nsorry\n\ndef digit_sequence_of_powers (n : Nat) : List Nat :=\nsorry\n\ndef last_digit_to_appear (n : Nat) : Option Nat :=\nsorry", "vc-theorems": "theorem result_is_single_digit {n d : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = some d) :\n  0 ≤ d ∧ d ≤ 9 :=\nsorry\n\ntheorem appears_last {n d : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = some d)\n  (digits : List Nat)\n  (nonempty : digits ≠ [])\n  (valid_digits : ∀ x, x ∈ digits → x ≤ 9)\n  (is_sequence : digits = digit_sequence_of_powers n)\n  (h_len : digits.length > 0) :\n  d = digits[digits.length - 1]'(Nat.sub_lt h_len (by exact Nat.zero_lt_one)) :=\nsorry\n\ntheorem none_result_characterization {n : Nat} (h : n ≥ 2)\n  (res : last_digit_to_appear n = none) :\n  (∀ k : Nat, k > 1 → digits_of (n^k) = digits_of n) ∨\n  (∃ x : Nat, x ≤ 9 ∧ ∀ k : Nat, k ≤ 100 → x ∉ digits_of (n^k)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 2\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 8\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval last_digit_to_appear 100"}
{"id": "fvapps_003026", "vc-description": "/-\nSam has opened a new sushi train restaurant - a restaurant where sushi is served on plates that travel around the bar on a conveyor belt and customers take the plate that they like.\n\nSam is using Glamazon's new visual recognition technology that allows a computer to record the number of plates at a customer's table and the colour of those plates.  The number of plates is returned as a string.  For example, if a customer has eaten 3 plates of sushi on a red plate the computer will return the string 'rrr'.\n\nCurrently, Sam is only serving sushi on red plates as he's trying to attract customers to his restaurant.  There are also small plates on the conveyor belt for condiments such as ginger and wasabi - the computer notes these in the string that is returned as a space ('rrr r' //denotes 4 plates of red sushi and a plate of condiment).\n\nSam would like your help to write a program for the cashier's machine to read the string and return the total amount a customer has to pay when they ask for the bill.  The current price for the dishes are as follows:  \n\n * Red plates of sushi ('r') - $2 each, but if a customer eats 5 plates the 5th one is free.\n * Condiments (' ') - free.\n\n```\nInput: String\nOutput: Number\n\nExamples:\n\nInput: 'rr'  Output: 4\nInput: 'rr rrr' Output: 8\nInput: 'rrrrr rrrrr' Output: 16\n\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total_bill (s : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem total_bill_nonnegative (s : String) :\n  total_bill s ≥ 0 :=\nsorry\n\ntheorem total_bill_even (s : String) :\n  total_bill s % 2 = 0 :=\nsorry\n\ntheorem total_bill_spaces (s : String) :\n  total_bill s = total_bill (s.replace \" \" \"\") :=\nsorry\n\ntheorem total_bill_repeated (n : Nat) (s : String) :\n  s = String.mk (List.replicate n 'r') →\n  total_bill s = 2 * (n - n/5) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval total_bill \"rr\"\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval total_bill \"rr rrr\"\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval total_bill \"rrrrr rrrrr\""}
{"id": "fvapps_003027", "vc-description": "/-\nIn this kata your mission is to rotate matrix counter - clockwise N-times.\n\nSo, you will have 2 inputs:\n\n    1)matrix\n\n    2)a number, how many times to turn it\n\nAnd an output is turned matrix.  \nExample:\n\n    matrix = [[1, 2, 3, 4],\n              [5, 6, 7, 8],\n              [9, 10, 11, 12],\n              [13, 14, 15, 16]]\n\n    times_to_turn = 1\n\nIt should return this:\n\n    [[4, 8, 12, 16],\n     [3, 7, 11, 15],\n     [2, 6, 10, 14],\n     [1, 5, 9, 13]])\n\nNote: all matrixes will be square. Also random tests will have big numbers in input (times to turn)\n\nHappy coding!\n-/", "vc-preamble": "def Matrix (α : Type) [BEq α] := List (List α)", "vc-helpers": "", "vc-definitions": "def is_valid_matrix {α : Type} [BEq α] (m : Matrix α) : Bool :=\nsorry\n\ndef rotate_against_clockwise {α : Type} [BEq α] (m : Matrix α) (times : Nat) : Matrix α :=\nsorry\n\ndef get_matrix_dimensions {α : Type} [BEq α] (m : Matrix α) : Nat × Nat :=\nsorry", "vc-theorems": "theorem dimensions_preserved {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  let dims := get_matrix_dimensions m\n  get_matrix_dimensions (rotate_against_clockwise m 1) = dims :=\nsorry\n\ntheorem rotation_modulo {α : Type} [BEq α] (m : Matrix α) (times : Nat) :\n  is_valid_matrix m →\n  rotate_against_clockwise m times = rotate_against_clockwise m (times % 4) :=\nsorry\n\ntheorem four_rotations_identity {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  rotate_against_clockwise m 4 = m :=\nsorry\n\ntheorem single_column_dimensions {α : Type} [BEq α] (m : Matrix α) :\n  is_valid_matrix m →\n  (∀ (row : List α), List.elem row m → List.length row = 1) →\n  let rotated := rotate_against_clockwise m 1\n  List.length rotated = List.length (List.head! m) ∧\n  ∀ (row : List α), List.elem row rotated → List.length row = List.length m :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2], [3, 4]] 1\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] 1\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval rotate_against_clockwise matrix2 2"}
{"id": "fvapps_003029", "vc-description": "/-\nImplement a function to calculate the sum of the numerical values in a nested list. For example :\n\n```python\nsum_nested([1, [2, [3, [4]]]]) -> 10\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Sum of empty nested lists is zero -/\n\n/- Sum of singleton list equals its element -/\n\n/- Sum of nested lists equals the sum of flattened list -/", "vc-preamble": "def listSum : List Int → Int\n  | [] => 0\n  | h :: t => h + listSum t", "vc-helpers": "", "vc-definitions": "def sumNested : List (List Int) → Int :=\n  sorry\n\ndef flatten : List (List Int) → List Int :=\n  sorry", "vc-theorems": "theorem sum_nested_equals_flatten_sum (l : List (List Int)) :\n  sumNested l = listSum (flatten l) := by\n  sorry\n\ntheorem sum_nested_empty_lists (l : List (List Int)) (h : ∀ x ∈ l, x = []) :\n  sumNested l = 0 := by\n  sorry\n\ntheorem sum_nested_singleton (n : Int) :\n  sumNested [[n]] = n := by\n  sorry", "vc-postamble": "/--\ninfo: 10\n-/\n#guard_msgs in\n#eval sum_nested [1, [2, [3, [4]]]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_nested [[[], []]]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval sum_nested [1, [1], [1, [1]], [1, [1], [1, [1]]]]"}
{"id": "fvapps_003034", "vc-description": "/-\nRaj was to move up through a pattern of stairs of a given number **(n)**. Help him to get to the    top using the function **stairs**.\n\n##Keep in mind :\n  * If **n<1** then return ' ' .\n  * There are a lot of spaces before the stair starts except for **pattern(1)**\n\n##Examples :\n  pattern(1)\n\n          1 1\n\n  pattern(6)\n\n                          1 1\n                      1 2 2 1  \n                  1 2 3 3 2 1\n              1 2 3 4 4 3 2 1\n          1 2 3 4 5 5 4 3 2 1\n      1 2 3 4 5 6 6 5 4 3 2 1\n\npattern(12)\n\n                                                  1 1\n                                              1 2 2 1\n                                          1 2 3 3 2 1\n                                      1 2 3 4 4 3 2 1\n                                  1 2 3 4 5 5 4 3 2 1\n                              1 2 3 4 5 6 6 5 4 3 2 1\n                          1 2 3 4 5 6 7 7 6 5 4 3 2 1\n                      1 2 3 4 5 6 7 8 8 7 6 5 4 3 2 1\n                  1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1\n              1 2 3 4 5 6 7 8 9 0 0 9 8 7 6 5 4 3 2 1\n          1 2 3 4 5 6 7 8 9 0 1 1 0 9 8 7 6 5 4 3 2 1\n      1 2 3 4 5 6 7 8 9 0 1 2 2 1 0 9 8 7 6 5 4 3 2 1\n-/\n\n-- Properties for stairs function\n\n-- Properties for step function\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def stairs (n : Int) : String :=\nsorry\n\ndef step (n : Int) : String :=\nsorry\n\ndef splitLines (s : String) : List String :=\nsorry\n\ndef rightJustify (s : String) (width : Int) : String :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef listToString (l : List Nat) : String :=\nsorry\n\ndef stringContains (s : String) (c : Char) : Prop :=\nsorry", "vc-theorems": "theorem stairs_empty_for_invalid_input (n : Int) :\n  n < 1 → stairs n = \" \" :=\nsorry\n\ntheorem stairs_line_count (n : Int) :\n  n ≥ 1 → (splitLines (stairs n)).length = n.toNat :=\nsorry\n\ntheorem stairs_line_width (n : Int) (line : String) :\n  n ≥ 1 → line ∈ splitLines (stairs n) → line.length ≤ (4 * n - 1).toNat :=\nsorry\n\ntheorem stairs_right_justified (n : Int) (line : String) :\n  n ≥ 1 → line ∈ splitLines (stairs n) →\n  line = rightJustify line (4 * n - 1) :=\nsorry\n\ntheorem step_length_correct (n : Int) :\n  n ≥ 1 → (splitLines (step n)).length = (2 * n - 1).toNat :=\nsorry\n\ntheorem step_digits_only (n : Int) (c : Char) :\n  n ≥ 1 → stringContains (step n) c → isDigit c ∨ c = ' ' :=\nsorry\n\ntheorem step_sequence (n : Int) (i : Nat) :\n  n ≥ 1 → i < n.toNat →\n  let nums := splitLines (step n);\n  let expected := toString ((i + 1) % 10);\n  nums.get? i = some expected :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003035", "vc-description": "/-\nIn case you might be unlucky enough not to know the best dark fantasy franchise ever, Berserk tells the story of a man that, hating gratuitous violence, decided to become a mercenary (thus one who sells violence, no gratuity anymore!) and starts an epic struggle against apparently unsormountable odds, unsure if he really wants to pursue a path of vengeance or to try to focus on his remaining and new loved ones.\n\n*The main character, Gatsu,ready to start yet another Tuesday*\n\nOk, the first part was a joke, but you can read more about the tale of the main character, a \"Byronic hero\" for wikipedia, in other pages like [here](https://en.wikipedia.org/wiki/Berserk_(manga%29).\n\nAfter an insanely long waiting, finally fans got the [follow up](https://en.wikipedia.org/wiki/Berserk_(2016_TV_series%29) of [the acclaimed 90s show](https://en.wikipedia.org/wiki/Berserk_(1997_TV_series%29).\n\nRegrettably, while the first adaption was considerably shortened, the latter was quite butchered, missing entire parts, like the \"lost children\" arc, but that would have actual children butchered and thus you might get why it was decided to skip it. And fan could somehow cope with it, if it was not for the very meager use of CG (Computer Graphic).\n\nLuckily, I am a simple man and every time Gatsu swings his humongous sword, that is enough to make me forget about everything else.\n\nYour goal is to build a Berserk Rater function that takes an array/list of events of each episode (as strings) and calculate a rating based on that: you start with a score of 0 (hey, it's a work from Miura-sensei, I have great expectations to satisfy!) and you have to:\n\n* subtract 2 each time \"CG\" is mentioned (case insensitive);\n* add 5 every time \"Clang\" is mentioned (case insensitive);\n* if a sentence has both \"Clang\" and \"CG\", \"Clang\" wins (add 5);\n* remove 1 every time neither is mentioned (I get bored easily, you know, particularly if you remove important parts and keep side character whining for half an episode).\n\nYou should then return a string, structured like this:\n\n* if the finale score is less than 0: \"worstest episode ever\";\n* if the score is between 0 and 10: the score itself, as a string;\n* if the finale score is more than 10: \"bestest episode ever\".\n\nExamples:\n```python\nberserk_rater([\"is this the CG from a P2 game?\",\"Hell, no! Even the CG in the Dreamcast game was more fluid than this!\",\"Well, at least Gatsu does his clang even against a mere rabbit\", \"Hey, Cosette was not in this part of the story!\", \"Ops, everybody dead again! Well, how boring...\"])==\"worstest episode ever\"\nberserk_rater([\"missing the Count arc\",\"lame CG\",\"Gatsu doing its clang against a few henchmen\", \"even more lame CG\"])==\"0\"\nberserk_rater([\"Farnese unable to shut the fuck up\",\"awful CG dogs assaulting everybody\", \"Gatsu clanging the pig apostle!\"])==\"2\"\nberserk_rater([\"spirits of the dead attacking Gatsu and getting clanged for good\", \"but the wheel spirits where really made with bad CG\", \"Isidoro trying to steal the dragon Slayer and getting a sort of clang on his face\", \"Gatsu vs. the possessed horse: clang!\", \"Farnese whining again...\",\"a shame the episode ends with that scrappy CG\"])==\"10\"\nberserk_rater([\"Holy chain knights being dicks\", \"Serpico almost getting clanged by Gatsu, but without losing his composure\",\"lame CG\",\"Luka getting kicked\",\"Gatsu going clang against the angels\", \"Gatsu clanging vs Mozgus, big time!\"])==\"bestest episode ever\"\n```\n\nExtra cookies if you manage to solve it all using a `reduce/inject` approach.\n\nOh, and in case you might want a taste of clang to fully understand it, [click](https://www.youtube.com/watch?v=IZgxH8MJFno) (one of the least gory samples I managed to find).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def berserk_rater (synopsis : List String) : String :=\n  sorry\n\ndef score (s : String) : Int :=\n  sorry\n\ndef String.hasSubstring (s₁ s₂ : String) : Bool :=\n  sorry", "vc-theorems": "theorem berserk_rater_output_format (synopsis : List String) :\n  let result := berserk_rater synopsis\n  (result = \"worstest episode ever\" ∨ result = \"bestest episode ever\" ∨ String.all result Char.isDigit) :=\nsorry\n\ntheorem berserk_rater_score_boundaries (synopsis : List String) :\n  let result := berserk_rater synopsis\n  let score_sum := List.foldl (· + ·) 0 (List.map (fun s => score s.toUpper) synopsis)\n  (result = \"worstest episode ever\" → score_sum < 0) ∧\n  (result = \"bestest episode ever\" → score_sum > 10) ∧\n  (result ≠ \"worstest episode ever\" ∧ result ≠ \"bestest episode ever\" →\n    0 ≤ result.toNat! ∧ result.toNat! ≤ 10) :=\nsorry\n\ntheorem score_function_output (s : String) :\n  let result := score s.toUpper\n  (result = 5 ∨ result = -2 ∨ result = -1) ∧\n  (s.toUpper.hasSubstring \"CLANG\" → result = 5) ∧\n  (s.toUpper.hasSubstring \"CG\" → (¬s.toUpper.hasSubstring \"CLANG\" → result = -2)) ∧\n  (¬s.toUpper.hasSubstring \"CLANG\" ∧ ¬s.toUpper.hasSubstring \"CG\" → result = -1) :=\nsorry\n\ntheorem score_precedence_clang_over_cg :\n  score \"CLANGCG\" = 5 ∧ score \"CGCLANG\" = 5 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'worstest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"is this the CG from a P2 game?\", \"Hell, no! Even the CG in the Dreamcast game was more fluid than this!\", \"Well, at least Gatsu does his clang even against a mere rabbit\", \"Hey, Cosette was not in this part of the story!\", \"Ops, everybody dead again! Well, how boring...\"]\n\n/--\ninfo: '2'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Farnese unable to shut the fuck up\", \"awful CG dogs assaulting everybody\", \"Gatsu clanging the pig apostle!\"]\n\n/--\ninfo: 'bestest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Holy chain knights being dicks\", \"Serpico almost getting clanged by Gatsu, but without losing his composure\", \"lame CG\", \"Luka getting kicked\", \"Gatsu going clang against the angels\", \"Gatsu clanging vs Mozgus, big time!\"]"}
{"id": "fvapps_003051", "vc-description": "/-\nYou receive the name of a city as a string, and you need to return a string that shows how many times each letter shows up in the string by using an asterisk (`*`).\n\nFor example:\n\n```\n\"Chicago\"  -->  \"c:**,h:*,i:*,a:*,g:*,o:*\"\n```\n\nAs you can see, the letter `c` is shown only once, but with 2 asterisks.\n\nThe return string should include **only the letters** (not the dashes, spaces, apostrophes, etc). There should be no spaces in the output, and the different letters are separated by a comma (`,`) as seen in the example above.\n\nNote that the return string must list the letters in order of their first appearence in the original string.\n\nMore examples:\n```\n\"Bangkok\"    -->  \"b:*,a:*,n:*,g:*,k:**,o:*\"\n\"Las Vegas\"  -->  \"l:*,a:**,s:**,v:*,e:*,g:*\"\n```\n\nHave fun! ;)\n-/", "vc-preamble": "structure SegmentInfo where\n  letter : Char\n  stars : String", "vc-helpers": "", "vc-definitions": "def get_strings (s : String) : String :=\nsorry\n\ndef is_alpha (c : Char) : Bool :=\nsorry\n\ndef to_lower (c : Char) : Char :=\nsorry\n\ndef parse_segment (s : String) : Option SegmentInfo :=\nsorry", "vc-theorems": "theorem get_strings_format_valid (s : String) (h : s ≠ \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\"\n  ∀ part ∈ segments,\n  part ≠ \"\" →\n  match parse_segment part with\n  | some info =>\n    is_alpha info.letter ∧\n    ∀ c ∈ info.stars.data, c = '*'\n  | none => False :=\nsorry\n\ntheorem get_strings_count_matches_freq (s : String) (h : s ≠ \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\" |>.filter (·≠ \"\")\n  ∀ seg ∈ segments,\n  match parse_segment seg with\n  | some info =>\n    let count := s.data.filter (fun c => to_lower c = to_lower info.letter) |>.length\n    info.stars.length = count\n  | none => False :=\nsorry\n\ntheorem get_strings_empty :\n  get_strings \"\" = \"\" :=\nsorry\n\ntheorem get_strings_example :\n  get_strings \"Chicago\" = \"c:**,h:*,i:*,a:*,g:*,o:*\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'c:**,h:*,i:*,a:*,g:*,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Chicago\"\n\n/--\ninfo: 'b:*,a:*,n:*,g:*,k:**,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Bangkok\"\n\n/--\ninfo: 'l:*,a:**,s:**,v:*,e:*,g:*'\n-/\n#guard_msgs in\n#eval get_strings \"Las Vegas\""}
{"id": "fvapps_003054", "vc-description": "/-\nBeaches are filled with sand, water, fish, and sun. Given a string, calculate how many times the words `\"Sand\"`, `\"Water\"`, `\"Fish\"`, and `\"Sun\"` appear without overlapping (regardless of the case).\n\n## Examples\n\n```python\nsum_of_a_beach(\"WAtErSlIde\")                    ==>  1\nsum_of_a_beach(\"GolDeNSanDyWateRyBeaChSuNN\")    ==>  3\nsum_of_a_beach(\"gOfIshsunesunFiSh\")             ==>  4\nsum_of_a_beach(\"cItYTowNcARShoW\")               ==>  0\n```\n-/\n\n-- Theorem: If a string has no beach words, sum is 0\n\n-- Theorem: Output is always non-negative and bounded by string length", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfABeach (s : String) : Nat :=\n  sorry\n\ndef substringExists (s : String) (substr : String) : Bool :=\n  sorry", "vc-theorems": "theorem no_beach_words (s : String) :\n  (¬ substringExists s \"sand\" ∧ ¬ substringExists s \"SAND\") →\n  (¬ substringExists s \"water\" ∧ ¬ substringExists s \"WATER\") →\n  (¬ substringExists s \"fish\" ∧ ¬ substringExists s \"FISH\") →\n  (¬ substringExists s \"sun\" ∧ ¬ substringExists s \"SUN\") →\n  sumOfABeach s = 0 :=\nsorry\n\ntheorem output_range (s : String) :\n  sumOfABeach s ≥ 0 ∧ sumOfABeach s ≤ s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"WAtErSlIde\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"GolDeNSanDyWateRyBeaChSuNN\"\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"gOfIshsunesunFiSh\""}
{"id": "fvapps_003056", "vc-description": "/-\n## Number pyramid\n\nNumber pyramid is a recursive structure where each next row is constructed by adding adjacent values of the current row. For example:\n\n```\nRow 1     [1     2     3     4]\nRow 2        [3     5     7]\nRow 3           [8    12]\nRow 4             [20]\n```\n\n___\n\n## Task\n\nGiven the first row of the number pyramid, find the value stored in its last row.\n\n___\n\n## Examples\n\n```python\nreduce_pyramid([1])        ==  1\nreduce_pyramid([3, 5])     ==  8\nreduce_pyramid([3, 9, 4])  ==  25\n```\n\n___\n\n## Performance tests\n\n```python\nNumber of tests: 10\nList size: 10,000\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reducePyramid (base : List Int) : Int :=\n  sorry\n\ndef referencePyramidReduce (base : List Int) : Int :=\n  sorry", "vc-theorems": "theorem matches_reference_implementation {base : List Int}\n  (h : base.length > 0 ∧ base.length ≤ 10) :\n  reducePyramid base = referencePyramidReduce base :=\nsorry\n\ntheorem single_element {base : List Int}\n  (h : base.length = 1) :\n  reducePyramid base = base.get ⟨0, sorry⟩ :=\nsorry\n\ntheorem two_elements {base : List Int}\n  (h : base.length = 2) :\n  reducePyramid base = base.get ⟨0, sorry⟩ + base.get ⟨1, sorry⟩ :=\nsorry\n\ntheorem singleton_list (x : Int) :\n  reducePyramid [x] = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval reduce_pyramid [1]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 5]\n\n/--\ninfo: 25\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 9, 4]"}
{"id": "fvapps_003059", "vc-description": "/-\nScheduling is how the processor decides which jobs(processes) get to use the processor and for how long. This can cause a lot of problems. Like a really long process taking the entire CPU and freezing all the other processes. One solution is Shortest Job First(SJF), which today you will be implementing.\n\nSJF works by, well, letting the shortest jobs take the CPU first. If the jobs are the same size then it is First In First Out (FIFO). The idea is that the shorter jobs will finish quicker, so theoretically jobs won't get frozen because of large jobs. (In practice they're frozen because of small jobs).\n\nYou will be implementing:\n```python\n  def SJF(jobs, index)\n```\n\nIt takes in:\n\n1. \"jobs\" a non-empty array of positive integers. They represent the clock-cycles(cc) needed to finish the job.\n2. \"index\" a positive integer. That represents the job we're interested in.\n\nSJF returns:\n\n1. A positive integer representing the cc it takes to complete the job at index.\n\nHere's an example:\n```\nSJF([3, 10, 20, 1, 2], 0)\nat 0cc [3, 10, 20, 1, 2] jobs[3] starts\nat 1cc [3, 10, 20, 0, 2] jobs[3] finishes, jobs[4] starts\nat 3cc [3, 10, 20, 0, 0] jobs[4] finishes, jobs[0] starts\nat 6cc [0, 10, 20, 0, 0] jobs[0] finishes\n```\n\nso:\n```\nSJF([3,10,20,1,2], 0) == 6\n```\n-/", "vc-preamble": "abbrev sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs\n\ndef filterWithIndex (l : List Nat) (p : Nat → Nat → Bool) : List Nat :=\n  let rec helper : List Nat → Nat → List Nat\n    | [], _ => []\n    | (x :: xs), i => if p i x then x :: helper xs (i+1) else helper xs (i+1)\n  helper l 0", "vc-helpers": "", "vc-definitions": "def SJF (jobs : List Nat) (index : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_job_returns_itself {jobs : List Nat} {job : Nat} (h : jobs = [job]) :\n  SJF jobs 0 = job :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 100\n-/\n#guard_msgs in\n#eval SJF [100] 0\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval SJF [3, 10, 20, 1, 2] 0\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval SJF [3, 10, 10, 20, 1, 2] 1"}
{"id": "fvapps_003060", "vc-description": "/-\nWe are interested in collecting the sets of six prime numbers, that having a starting prime p, the following values are also primes forming the sextuplet ```[p, p + 4, p + 6, p + 10, p + 12, p + 16]```\n\nThe first sextuplet that we find is ```[7, 11, 13, 17, 19, 23]```\n\nThe second one is ```[97, 101, 103, 107, 109, 113]```\n\nGiven a number ```sum_limit```, you should give the first sextuplet which sum (of its six primes) surpasses the sum_limit value.\n\n```python\nfind_primes_sextuplet(70) == [7, 11, 13, 17, 19, 23]\n\nfind_primes_sextuplet(600) == [97, 101, 103, 107, 109, 113]\n```\nFeatures of the tests:\n```\nNumber Of Tests = 18\n10000 < sum_limit < 29700000\n```\nIf you have solved this kata perhaps you will find easy to solve this one:\nhttps://www.codewars.com/kata/primes-with-two-even-and-double-even-jumps/\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findPrimesSextuplet (limit : Nat) : List Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem primes_sextuplet_length (limit : Nat) (h : limit ≥ 1000) :\n  (findPrimesSextuplet limit).length = 6 :=\nsorry\n\ntheorem primes_sextuplet_monotone (limit : Nat) (h : limit ≥ 1000) :\n  let result := findPrimesSextuplet limit\n  ∀ i j, i < j → i < result.length → j < result.length →\n  result[i]! < result[j]! :=\nsorry\n\ntheorem primes_sextuplet_all_prime (limit : Nat) (h : limit ≥ 1000) :\n  ∀ x ∈ findPrimesSextuplet limit, isPrime x = true :=\nsorry\n\ntheorem primes_sextuplet_diffs (limit : Nat) (h : limit ≥ 1000) :\n  let result := findPrimesSextuplet limit\n  let diffs := List.map (fun p => p.2 - p.1) (List.zip result result.tail)\n  diffs = [4,2,4,2,4] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [7, 11, 13, 17, 19, 23]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 70\n\n/--\ninfo: [97, 101, 103, 107, 109, 113]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 600\n\n/--\ninfo: [1091257, 1091261, 1091263, 1091267, 1091269, 1091273]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 2000000"}
{"id": "fvapps_003064", "vc-description": "/-\nThe first positive integer, `n`, with its value `4n² + 1`, being divisible by `5` and `13` is `4`. (condition 1)\n\nIt can be demonstrated that we have infinite numbers that may satisfy the above condition.\n\nIf we name **ai**, the different terms of the sequence of numbers with this property, we define `S(n)` as:\n\nWe are interested in working with numbers of this sequence from 10 to 15 digits. Could you elaborate a solution for these results?\n\nYou will be given an integer value `m`(always valid an positive) and you should output the closest value of the sequence to `m`.\n\nIf the given value `m` is in the sequence, your solution should return the same value.\n\nIn the case that there are two possible solutions: `s1` and `s2`, (`s1 < s2`), because `|m - s1| = |m - s2|`, output the highest solution `s2`\n\nNo hardcoded solutions are allowed.\n\nNo misterious formulae are required, just good observation to discover hidden patterns.\n\nSee the example tests to see output format and useful examples, edge cases are included.\n\nFeatures of the random tests\n`1000 <= m <= 5.2 e14`\n\n**Note** Sierpinsky presented the numbers that satisfy condition (1)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_sierpinski_sequence (n : Nat) : List Nat :=\n  sorry\n\ndef find_closest_value (m : Nat) : Nat :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sequence_is_strictly_increasing {n : Nat} (h : 0 < n) (h2 : n ≤ 10000) :\n  let seq := generate_sierpinski_sequence n\n  ∀ i, i + 1 < seq.length → seq.get! i < seq.get! (i + 1) :=\nsorry\n\ntheorem sequence_first_values {n : Nat} (h : 0 < n) (h2 : n ≤ 10000) :\n  let seq := generate_sierpinski_sequence n\n  seq.length ≥ 4 → seq.take 4 = [4, 13, 69, 130] :=\nsorry\n\ntheorem closest_value_properties {m : Nat} (h : 0 < m) (h2 : m ≤ 10000) :\n  let closest := find_closest_value m\n  let seq := generate_sierpinski_sequence (m * 2)\n  (closest ∈ seq) ∧\n  (∀ x ∈ seq, abs (closest - m) ≤ abs (x - m)) ∧\n  (∀ x ∈ seq, abs (x - m) = abs (closest - m) → x > m → closest ≥ x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_closest_value 1\n\n/--\ninfo: 5074\n-/\n#guard_msgs in\n#eval find_closest_value 5000\n\n/--\ninfo: 14313\n-/\n#guard_msgs in\n#eval find_closest_value 14313\n\n/--\ninfo: 18720\n-/\n#guard_msgs in\n#eval find_closest_value 18332"}
{"id": "fvapps_003074", "vc-description": "/-\nYou will be given a certain array of length ```n```, such that ```n > 4```, having positive and negative integers but there will be no zeroes and all the elements will occur once in it.\n\nWe may obtain an amount of ```n``` sub-arrays of length ```n - 1```, removing one element at a time (from left to right). \n\nFor each subarray, let's calculate the product and sum of its elements with the corresponding absolute value of the quotient, ```q = SubProduct/SubSum``` (if it is possible, SubSum cannot be 0). \nThen we select the array with the lowest value of ```|q|```(absolute value)\n\ne.g.: we have the array, ```arr = [1, 23, 2, -8, 5]```\n```\nSub Arrays            SubSum    SubProduct         |q|\n[23, 2, -8, 5]         22         -1840         83.636363\n[1, 2, -8, 5]           0           -80          No value\n[1, 23, -8, 5]         21          -920         43.809524\n[1, 23, 2, 5]          31           230          7.419355  <--- selected array\n[1, 23, 2, -8]         18           368         20.444444\n```\nLet's compare the given array with the selected subarray:\n```\n[1, 23, 2, -8, 5]\n[1, 23, 2,     5]\n```\nThe difference between them is at the index ```3``` for the given array, with element ```-8```, so we put both things for a result ```[3, -8]```.\n\nThat means that to obtain the selected subarray we have to take out the value -8 at index 3.\nWe need a function that receives an array as an argument and outputs the the pair ```[index, arr[index]]``` that generates the subarray with  the lowest value of ```|q|```.\n\n```python \nselect_subarray([1, 23, 2, -8, 5]) == [3, -8]\n```\nAnother case:\n```python \nselect_subarray([1, 3, 23, 4, 2, -8, 5, 18]) == [2, 23]\n```\nIn Javascript the function will be ```selectSubarray()```.\n\nWe may have some special arrays that may have more than one solution as the one that follows below.\n```python \nselect_subarray([10, 20, -30, 100, 200]) == [[3, 100], [4, 200]]\n```\nIf there is more than one result the function should output a 2Darray sorted by the index of the element removed from the array.\n\nThanks to Unnamed for detecting the special cases when we have multiple solutions.\n\nFeatures of the random tests:\n```\nNumber of tests = 200\nlength of the array, l, such that 20 <= l <= 100\n```\n\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def select_subarray (arr : List Int) : Nat × Int :=\n  sorry\n\ndef get_ratio (arr : List Int) (idx : Nat) : Float :=\n  sorry", "vc-theorems": "theorem select_subarray_index_bounds {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  (select_subarray arr).1 < arr.length := by\n  sorry\n\ntheorem select_subarray_matches_input {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  (select_subarray arr).2 = arr[(select_subarray arr).1]! := by\n  sorry\n\ntheorem select_subarray_minimum_ratio {arr : List Int}\n  (h_size : arr.length ≥ 2)\n  (h_nonzero : ∀ x ∈ arr, x ≠ 0) :\n  ∀ i < arr.length,\n    get_ratio arr (select_subarray arr).1 ≤ get_ratio arr i := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [3, -8]\n-/\n#guard_msgs in\n#eval select_subarray [1, 23, 2, -8, 5]\n\n/--\ninfo: [2, 23]\n-/\n#guard_msgs in\n#eval select_subarray [1, 3, 23, 4, 2, -8, 5, 18]\n\n/--\ninfo: [[3, 100], [4, 200]]\n-/\n#guard_msgs in\n#eval select_subarray [10, 20, -30, 100, 200]"}
{"id": "fvapps_003075", "vc-description": "/-\n## MTV Cribs is back!\n\n![](https://s-media-cache-ak0.pinimg.com/236x/1b/cf/f4/1bcff4f4621644461103576e40bde4ed.jpg)\n\n_If you haven't solved it already I recommend trying [this kata](https://www.codewars.com/kata/5834a44e44ff289b5a000075) first._\n\n## Task\n\nGiven `n` representing the number of floors build a penthouse like this:\n\n```\n        ___\n       /___\\                \n      /_____\\\n      |  _  |     1 floor\n      |_|_|_|\n\n       _____\n      /_____\\\n     /_______\\\n    /_________\\             \n   /___________\\\n   |           |\n   |    ___    |     2 floors\n   |   |   |   |\n   |___|___|___|\n\n      _______\n     /_______\\\n    /_________\\\n   /___________\\\n  /_____________\\\n /_______________\\\n/_________________\\\n|                 |         3 floors\n|                 |\n|      _____      |\n|     |     |     |\n|     |     |     |\n|_____|_____|_____|\n\n```\n\n**Note:** whitespace should be preserved on both sides of the roof. No invalid input tests.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def my_crib (n : Nat) : String :=\n  sorry\n\ndef splitLines (s : String) : List String :=\n  sorry", "vc-theorems": "theorem crib_width_consistency {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let width := 4 + 3 + 6 * (n - 1)\n  let lines := splitLines (my_crib n)\n  ∀ line ∈ lines, line.length = width :=\nsorry\n\ntheorem crib_roof_top {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let first_line := lines.head?\n  ∀ line, first_line = some line → line.replace \" \" \"\" = line.replace \"_\" \"\" :=\nsorry\n\ntheorem crib_sloping_roof {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let roof_lines := lines.take (3 + 2*(n-1))\n  ∀ line ∈ roof_lines, (line.contains '/') ∧ (line.contains '\\\\') :=\nsorry\n\ntheorem crib_wall_structure {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  let wall_lines := lines.drop (3 + 2*(n-1))\n  ∀ line ∈ wall_lines, line.startsWith \"|\" ∧ line.endsWith \"|\" :=\nsorry\n\ntheorem crib_bottom_line {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let lines := splitLines (my_crib n)\n  ∀ last_line, lines.getLast? = some last_line → last_line.contains '_' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval my_crib 1\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval my_crib 2\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval my_crib 3"}
{"id": "fvapps_003081", "vc-description": "/-\n# Task\nGiven an integer array `arr`. Your task is to remove one element, maximize the product of elements. \n\nThe result is the element which should be removed. If more than one valid results exist, return the smallest one.\n\n# Input/Output\n\n`[input]` integer array `arr`\n\nnon-empty unsorted integer array. It contains positive integer, negative integer or zero.\n\n`3 ≤ arr.length ≤ 15`\n\n`-10 ≤ arr[i] ≤ 10`\n\n`[output]` an integer\n\nThe element that should be removed.\n\n# Example\n\nFor `arr = [1, 2, 3]`, the output should be `1`.\n\nFor `arr = [-1, 2, -3]`, the output should be `2`.\n\nFor `arr = [-1, -2, -3]`, the output should be `-1`.\n\nFor `arr = [-1, -2, -3, -4]`, the output should be `-4`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minimum (l : List Int) : Option Int :=\nsorry\n\ndef maximum (l : List Int) : Option Int :=\nsorry\n\ndef maximum_product (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem maximum_product_in_array (arr : List Int) (h : arr ≠ []) :\n  ∃ x ∈ arr, maximum_product arr = x :=\nsorry\n\ntheorem maximum_product_even_negatives (arr : List Int) (h : arr ≠ [])\n  (h_even : (arr.filter (λ x => x < 0)).length % 2 = 0) :\n  let pos := arr.filter (λ x => x ≥ 0)\n  let neg := arr.filter (λ x => x < 0)\n  pos ≠ [] → (∃ m, minimum pos = some m ∧ maximum_product arr = m) ∨\n  pos = [] → (∃ m, minimum neg = some m ∧ maximum_product arr = m) :=\nsorry\n\ntheorem maximum_product_odd_negatives (arr : List Int) (h : arr ≠ [])\n  (h_odd : (arr.filter (λ x => x < 0)).length % 2 = 1) :\n  let neg := arr.filter (λ x => x < 0)\n  (¬ arr.contains 0 → (∃ m, maximum neg = some m ∧ maximum_product arr = m)) ∧\n  (arr.contains 0 → (∃ m, minimum neg = some m ∧ maximum_product arr = m)) :=\nsorry\n\ntheorem maximum_product_multiple_zeros (arr : List Int) (h : arr ≠ [])\n  (h_zeros : (arr.filter (λ x => x = 0)).length > 1) :\n  ∃ m, minimum arr = some m ∧ maximum_product arr = m :=\nsorry\n\ntheorem maximum_product_single_element (x : Int) :\n  maximum_product [x] = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval maximum_product [1, 2, 3]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval maximum_product [-1, 2, -3]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_product [-1, -2, -3]"}
{"id": "fvapps_003083", "vc-description": "/-\nYou and your best friend Stripes have just landed your first high school jobs! You'll be delivering newspapers to your neighbourhood on weekends. For your services you'll be charging a set price depending on the quantity of the newspaper bundles.\n\nThe cost of deliveries is:\n\n- $3.85 for 40 newspapers\n- $1.93 for 20\n- $0.97 for 10 \n- $0.49 for 5 \n- $0.10 for 1 \n\nStripes is taking care of the footwork doing door-to-door drops and your job is to take care of the finances. What you'll be doing is providing the cheapest possible quotes for your services.\n\nWrite a function that's passed an integer representing the amount of newspapers and returns the cheapest price. The returned number must be rounded to two decimal places.\n\n![Paperboy](http://mametesters.org/file_download.php?file_id=1016&type=bug)\n-/\n\n/- Ensures cheapest_quote returns a non-negative float -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Ensures cheapest_quote is strictly monotonically increasing -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def cheapest_quote (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem cheapest_quote_non_negative (n : Nat) :\n  let result := cheapest_quote n\n  result ≥ 0 :=\nsorry\n\ntheorem cheapest_quote_monotonic (n : Nat) : n > 0 →\n  cheapest_quote n > cheapest_quote (n-1) :=\nsorry", "vc-postamble": "/--\ninfo: 3.95\n-/\n#guard_msgs in\n#eval cheapest_quote 41\n\n/--\ninfo: 2.52\n-/\n#guard_msgs in\n#eval cheapest_quote 26\n\n/--\ninfo: 48.06\n-/\n#guard_msgs in\n#eval cheapest_quote 499"}
{"id": "fvapps_003089", "vc-description": "/-\nBob is a theoretical coder - he doesn't write code, but comes up with theories, formulas and algorithm ideas. You are his secretary, and he has tasked you with writing the code for his newest project - a method for making the short form of a word. Write a function ```shortForm```(C# ```ShortForm```, Python ```short_form```) that takes a string and returns it converted into short form using the rule: Remove all vowels, except for those that are the first or last letter. Do not count 'y' as a vowel, and ignore case. Also note, the string given will not have any spaces; only one word, and only Roman letters. \n\nExample:\n```\nshortForm(\"assault\");\nshort_form(\"assault\")\nShortForm(\"assault\");\n// should return \"asslt\"\n```\n\nAlso, FYI: I got all the words with no vowels from \nhttps://en.wikipedia.org/wiki/English_words_without_vowels\n-/", "vc-preamble": "def isConsonant (c : Char) : Bool :=\n  c ∈ ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n\ndef isVowel (c : Char) : Bool :=\n  c.toLower ∈ ['a', 'e', 'i', 'o', 'u']", "vc-helpers": "", "vc-definitions": "def short_form (s : String) : String :=\n  sorry", "vc-theorems": "theorem short_form_length {s : String} :\n  String.length (short_form s) ≤ String.length s :=\nsorry\n\ntheorem short_form_first_last {s : String} (h: String.length s > 0) :\n  (s.get! 0 = (short_form s).get! 0) ∧\n  (String.length s > 1 → s.get! (String.Pos.mk (s.length - 1)) = (short_form s).get! (String.Pos.mk ((short_form s).length - 1))) :=\nsorry\n\ntheorem short_form_consonants {s : String} (h : ∀ c, c ∈ s.data → isConsonant c) :\n  short_form s = s :=\nsorry\n\ntheorem short_form_case_preservation {s : String} :\n  ∀ c, c ∈ (short_form s).data → c ∈ s.data :=\nsorry\n\ntheorem short_form_middle_vowels_removed {s : String} :\n  ∀ i, 1 ≤ i → i < String.length (short_form s) - 1 →\n    ¬(isVowel ((short_form s).get! (String.Pos.mk i))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'asslt'\n-/\n#guard_msgs in\n#eval short_form \"assault\"\n\n/--\ninfo: 'rhythm'\n-/\n#guard_msgs in\n#eval short_form \"rhythm\"\n\n/--\ninfo: 'InSNe'\n-/\n#guard_msgs in\n#eval short_form \"InSaNe\""}
{"id": "fvapps_003090", "vc-description": "/-\nGiven a positive number n > 1 find the prime factor decomposition of n.\nThe result will be a string with the following form :\n```\n \"(p1**n1)(p2**n2)...(pk**nk)\"\n```\nwhere ```a ** b``` means ```a``` to the power of ```b```\n\nwith the p(i) in increasing order and n(i) empty if\nn(i) is 1.\n```\nExample: n = 86240 should return \"(2**5)(5)(7**2)(11)\"\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\nsorry\n\ndef get_factors (n : Nat) : List Nat :=\nsorry\n\ndef prime_factors (n : Nat) : String :=\nsorry", "vc-theorems": "theorem prime_factors_valid_format (n : Nat) (h : n ≥ 2) :\n  let result := prime_factors n\n  ∀ part : String,\n  part ∈ (String.split (prime_factors n) (· == ')')).filter (λ x => x ≠ \"\") →\n  (∃ base power : Nat,\n   ((String.contains part '*') →\n    part = s!\"{base}**{power}\" ∧\n    is_prime base ∧\n    power > 1) ∧\n   (¬String.contains part '*' →\n    part.toNat?.isSome ∧\n    is_prime part.toNat!)) :=\nsorry\n\ntheorem prime_factors_preserves_value (n : Nat) (h : n ≥ 2) :\n  let result := prime_factors n\n  let parts := (String.split result (· == ')')).filter (λ x => x ≠ \"\")\n  let reconstructed := parts.foldl\n    (λ acc part =>\n      if String.contains part '*'\n      then\n        let nums := String.split part (· == '*')\n        let base := (nums.get! 0).trim.toNat!\n        let power := (nums.get! 2).trim.toNat!\n        acc * (base ^ power)\n      else acc * part.trim.toNat!)\n    1\n  reconstructed = n :=\nsorry\n\ntheorem prime_number_input (p : Nat) (h₁ : p ≥ 2) (h₂ : is_prime p) :\n  prime_factors p = s!\"({p})\" :=\nsorry\n\ntheorem powers_of_two (n : Nat) (h : n ≥ 1) :\n  prime_factors (2^n) = s!\"(2**{n})\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003096", "vc-description": "/-\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #19\n\nYou work for an ad agency and your boss, Bob, loves a catchy slogan. He's always jumbling together \"buzz\" words until he gets one he likes. You're looking to impress Boss Bob with a function that can do his job for him.\n\nCreate a function called sloganMaker() that accepts an array of string \"buzz\" words. The function returns an array of all possible UNIQUE string permutations of the buzz words (concatonated and separated by spaces).\n\nYour boss is not very bright, so anticipate him using the same \"buzz\" word more than once, by accident. The function should ignore these duplicate string inputs.\n\n```\nsloganMaker([\"super\", \"hot\", \"guacamole\"]);\n//[ 'super hot guacamole',\n//  'super guacamole hot',\n//  'hot super guacamole',\n//  'hot guacamole super',\n//  'guacamole super hot',\n//  'guacamole hot super' ]\n\nsloganMaker([\"cool\", \"pizza\", \"cool\"]); // => [ 'cool pizza', 'pizza cool' ]\n```\n\nNote:  \nThere should be NO duplicate strings in the output array\n\nThe input array MAY contain duplicate strings, which should STILL result in an output array with all unique strings\n\nAn empty string is valid input\n\n```if-not:python,crystal\nThe order of the permutations in the output array does not matter\n```\n```if:python,crystal\nThe order of the output array must match those rules:\n1. Generate the permutations in lexicographic order of the original array.\n2. keep only the first occurence of a permutation, when duplicates are found.\n```\n-/", "vc-preamble": "def List.factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def List.unique {α} [BEq α] (xs : List α) : List α :=\nsorry\n\ndef slogan_maker (words: List String) : List String :=\nsorry\n\ndef containsString (s1 s2: String) : Bool :=\nsorry", "vc-theorems": "theorem slogan_maker_returns_string_list (words : List String) :\n  ∀ s, s ∈ slogan_maker words → s.length ≥ 0 :=\nsorry\n\ntheorem slogan_maker_contains_all_words (words : List String) :\n  ∀ slogan, slogan ∈ slogan_maker words →\n  ∀ word, word ∈ List.unique words →\n  containsString slogan word = true :=\nsorry\n\ntheorem slogan_maker_length (words : List String) :\n  (slogan_maker words).length = List.factorial (List.unique words).length :=\nsorry\n\ntheorem slogan_maker_order_independent (words₁ words₂ : List String) :\n  List.unique words₁ = List.unique words₂ →\n  slogan_maker words₁ = slogan_maker words₂ :=\nsorry\n\ntheorem slogan_maker_unique_results (words : List String) :\n  ∀ s₁ s₂, s₁ ∈ slogan_maker words → s₂ ∈ slogan_maker words →\n  s₁ = s₂ ∨ s₁ ≠ s₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['super']\n-/\n#guard_msgs in\n#eval slogan_maker [\"super\"]\n\n/--\ninfo: set(['super hot', 'hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\"])\n\n/--\ninfo: set(['super hot guacamole', 'super guacamole hot', 'hot super guacamole', 'hot guacamole super', 'guacamole super hot', 'guacamole hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\", \"guacamole\"])"}
{"id": "fvapps_003098", "vc-description": "/-\n# Background\n\nMy TV remote control has arrow buttons and an `OK` button.\n\nI can use these to move a \"cursor\" on a logical screen keyboard to type words...\n\n# Keyboard\n\nThe screen \"keyboard\" layout looks like this\n\n  #tvkb {\n    width : 400px;\n    border: 5px solid gray; border-collapse: collapse;\n  }\n  #tvkb td {\n    color : orange;\n    background-color : black;\n    text-align : center;\n    border: 3px solid gray; border-collapse: collapse;\n  }\n\nabcde123\nfghij456\nklmno789\npqrst.@0\nuvwxyz_/\naASP\n\n* `aA` is the SHIFT key. Pressing this key toggles alpha characters between UPPERCASE and lowercase\n* `SP` is the space character\n* The other blank keys in the bottom row have no function\n\n# Kata task\n\nHow many button presses on my remote are required to type the given `words`?\n\n## Notes\n\n* The cursor always starts on the letter `a` (top left)\n* The alpha characters are initially lowercase (as shown above)\n* Remember to also press `OK` to \"accept\" each letter\n* Take a direct route from one letter to the next\n* The cursor does not wrap (e.g. you cannot leave one edge and reappear on the opposite edge)\n* Although the blank keys have no function, you may navigate through them if you want to\n* Spaces may occur anywhere in the `words` string.\n* Do not press the SHIFT key until you need to. For example, with the word `e.Z`, the SHIFT change happens **after** the `.` is pressed (not before)\n\n# Example\n\nwords = `Code Wars`\n\n* C => `a`-`f`-`k`-`p`-`u`-`aA`-OK-`U`-`P`-`K`-`F`-`A`-`B`-`C`-OK = 14\n* o => `C`-`H`-`M`-`R`-`W`-`V`-`U`-`aA`-OK-`SP`-`v`-`q`-`l`-`m`-`n`-`o`-OK = 16\n* d => `o`-`j`-`e`-`d`-OK = 4\n* e => `d`-`e`-OK = 2\n* space => `e`-`d`-`c`-`b`-`g`-`l`-`q`-`v`-`SP`-OK = 9\n* W => `SP`-`aA`-OK-`SP`-`V`-`W`-OK = 6\n* a => `W`-`V`-`U`-`aA`-OK-`u`-`p`-`k`-`f`-`a`-OK = 10\n* r => `a`-`f`-`k`-`p`-`q`-`r`-OK = 6\n* s => `r`-`s`-OK = 2\n\nAnswer = 14 + 16 + 4 + 2 + 9 + 6 + 10 + 6 + 2 = 69\n\n*Good Luck!\nDM.*\n\nSeries\n* TV Remote\n* TV Remote (shift and space)\n* TV Remote (wrap)\n* TV Remote (symbols)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef tv_remote (s : String) : Nat :=\nsorry", "vc-theorems": "theorem tv_remote_basic_properties (s : String) : tv_remote s ≥ 0 :=\nsorry\n\ntheorem tv_remote_empty_string : tv_remote \"\" = 0 :=\nsorry\n\ntheorem tv_remote_case_sensitivity (s : String) :\n  s ≠ \"\" → tv_remote (s.map Char.toUpper) ≥ tv_remote (s.map Char.toLower) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 69\n-/\n#guard_msgs in\n#eval tv_remote \"Code Wars\"\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval tv_remote \"A\"\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval tv_remote \"does\""}
{"id": "fvapps_003099", "vc-description": "/-\nA function receives a certain numbers of integers ```n1, n2, n3 ..., np```(all positive and different from 0) and a factor ```k, k > 0```\n\nThe function rearranges the numbers ```n1, n2, ..., np``` in such order that generates the minimum number concatenating the digits and this number should be divisible by ```k```.\n\nThe order that the function receives their arguments is:\n```python\nrearranger(k, n1, n2, n3,....,np)\n```\n\n## Examples\n\n```python\nrearranger(4, 32, 3, 34, 7, 12)  == \"Rearrangement: 12, 3, 34, 7, 32 generates: 12334732 divisible by 4\"\n\nrearranger(10, 32, 3, 34, 7, 12) == \"There is no possible rearrangement\"\n```\nIf there are more than one possible arrengement for the same minimum number, your code should be able to handle those cases:\n```python\nrearranger(6, 19, 32, 2, 124, 20, 22) == \"Rearrangements: 124, 19, 20, 2, 22, 32 and 124, 19, 20, 22, 2, 32 generates: 124192022232 divisible by 6\"\n```\n\nThe arrangements should be in sorted order, as you see: `124, 19, 20, 2, 22, 32` comes first than `124, 19, 20, 22, 2, 32`.\n\nHave an enjoyable time!\n\n(Thanks to `ChristianE.Cooper` for his contribution to this kata)\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rearranger (k : Nat) (nums : List Nat) : String :=\nsorry\n\ndef splitString (s : String) (sep : String) : List String :=\nsorry\n\ndef trim (s : String) : String :=\nsorry\n\ndef toNat! (s : String) : Nat :=\nsorry\n\ndef getFirst (l : List α) : α :=\nsorry\n\ndef replace (s : String) (target : String) (replacement : String) : String :=\nsorry\n\ndef sortString (s : String) : String :=\nsorry\n\ndef joinStrings (l : List String) : String :=\nsorry", "vc-theorems": "theorem rearranger_divisible (k : Nat) (nums : List Nat) :\n  k > 0 → nums.length > 0 →\n  let result := rearranger k nums\n  result ≠ \"There is no possible rearrangement\" →\n  let parts := splitString result \"generates:\"\n  let numberStr := getFirst (splitString (getFirst (parts.tail)) \"divisible by\")\n  let number := toNat! (trim numberStr)\n  number % k = 0 :=\nsorry\n\ntheorem rearranger_preserves_digits (k : Nat) (nums : List Nat) :\n  k > 0 → nums.length > 0 →\n  let result := rearranger k nums\n  result ≠ \"There is no possible rearrangement\" →\n  let input_digits := nums.map toString |> joinStrings |> sortString\n  let parts := splitString result \"generates:\"\n  let first_part := trim (replace (getFirst parts) \"Rearrangement:\" \"\")\n  let result_digits := splitString first_part \", \" |> joinStrings |> sortString\n  input_digits = result_digits :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003111", "vc-description": "/-\n## Find Mean\n\nFind the mean (average) of a list of numbers in an array.\n\n## Information\n\nTo find the mean (average) of a set of numbers add all of the numbers together and divide by the number of values in the list.\n\nFor an example list of `1, 3, 5, 7`\n\n1. Add all of the numbers\n\n```\n1+3+5+7 = 16\n```\n\n2. Divide by the number of values in the list. In this example there are 4 numbers in the list.\n\n```\n16/4 = 4\n```\n\n3. The mean (or average) of this list is 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_average [Add α] [Div α] [OfNat α 0] : List α → α :=\n  sorry\n\ndef list_min : List Float → Float :=\n  sorry\n\ndef list_max : List Float → Float :=\n  sorry\n\ndef list_sum : List Float → Float :=\n  sorry\n\ndef abs (x : Float) : Float :=\n  sorry\n\ndef toFloat (n : Nat) : Float :=\n  sorry", "vc-theorems": "theorem find_average_empty {α} [Add α] [Div α] [OfNat α 0] (nums : List α) :\n  nums = [] → find_average nums = 0 := by\nsorry\n\ntheorem find_average_bounds (nums : List Float) (h : nums ≠ []) :\n  list_min nums ≤ find_average nums ∧\n  find_average nums ≤ list_max nums := by\nsorry\n\ntheorem find_average_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-10 := by\nsorry\n\ntheorem find_average_float_empty (nums : List Float) :\n  nums = [] → find_average nums = 0 := by\nsorry\n\ntheorem find_average_float_type (nums : List Float) (h : nums ≠ []) :\n  find_average nums + 0 = find_average nums := by\nsorry\n\ntheorem find_average_float_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-6 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_average [1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_average [1, 3, 5, 7]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []"}
{"id": "fvapps_003112", "vc-description": "/-\nIn this Kata, two players, Alice and Bob, are playing a palindrome game. Alice starts with `string1`, Bob starts with `string2`, and the board starts out as an empty string. Alice and Bob take turns; during a turn, a player selects a letter from his or her string, removes it from the string, and appends it to the board; if the board becomes a palindrome (of length >= 2), the player wins. Alice makes the first move. Since Bob has the disadvantage of playing second, then he wins automatically if letters run out or the board is never a palindrome. Note also that each player can see the other player's letters.\n\nThe problem will be presented as `solve(string1,string2)`. Return 1 if Alice wins and 2 it Bob wins.\n\nFor example:\n```Haskell\nsolve(\"abc\",\"baxy\") = 2 -- There is no way for Alice to win. If she starts with 'a', Bob wins by playing 'a'. The same case with 'b'. If Alice starts with 'c', Bob still wins because a palindrome is not possible. Return 2.\nsolve(\"eyfjy\",\"ooigvo\") = 1 -- Alice plays 'y' and whatever Bob plays, Alice wins by playing another 'y'. Return 1.\nsolve(\"abc\",\"xyz\") = 2 -- No palindrome is possible, so Bob wins; return 2\nsolve(\"gzyqsczkctutjves\",\"hpaqrfwkdntfwnvgs\") = 1 -- If Alice plays 'g', Bob wins by playing 'g'. Alice must be clever. She starts with 'z'. She knows that since she has two 'z', the win is guaranteed. Note that she also has two 's'. But she cannot play that. Can you see why? \nsolve(\"rmevmtw\",\"uavtyft\") = 1 -- Alice wins by playing 'm'. Can you see why? \n```\nPalindrome lengths should be at least `2` characters. More examples in the test cases. \n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s1 s2 : String) : Nat :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem solve_returns_valid_output (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve s1 s2 = 1 ∨ solve s1 s2 = 2 :=\nsorry\n\ntheorem solve_identical_chars (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0)\n    (h3 : ∀ (c : Char), s1.data.contains c → c = 'a')\n    (h4 : ∀ (c : Char), s2.data.contains c → c = 'a') :\n  solve s1 s2 = 2 :=\nsorry\n\ntheorem solve_with_duplicates (s : String)\n    (h1 : s.length ≥ 2) :\n  (∃ (c : Char), s.data.contains c ∧ countChar s c ≥ 2) → solve s \"\" = 1 ∧\n  (∀ (c : Char), s.data.contains c → countChar s c < 2) → solve s \"\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"abc\" \"xyz\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"eyfjy\" \"ooigv\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"qtkxttl\" \"utvohqk\""}
{"id": "fvapps_003118", "vc-description": "/-\nOnce upon a time, a CodeWarrior, after reading a [discussion on what can be the plural](http://www.codewars.com/kata/plural/discuss/javascript), took a look at [this page](http://en.wikipedia.org/wiki/Grammatical_number#Types_of_number\n) and discovered that **more than 1** \"kind of plural\" may exist. \n\nFor example [Sursurunga Language](http://en.wikipedia.org/wiki/Sursurunga_language) distinguishes 5 types of numbers: **singular** (1 thing), **dual** (2 things), '**trial**' or '**lesser paucal**' (3 or 4), '**greater paucal**' (more than 4) and **plural** (many).\n\nIn this kata, you'll have to handle only four types of numbers:\n\n- **singular**: 0 or 1 thing\n- **dual**: 2 things\n- **paucal**: 3 to 9 things\n- **plural**: more than 9 things\n\nTo add some flavor the **number-marker** will not be added in same places:\n\n- **singular**, no marker : `1 cat`\n- **dual**, prefixed \"`bu`\" : `2 cats -> 2 bucat`\n- **paucal**, suffixed \"`zo`\" : `4 cats -> 4 catzo`\n- **plural**, \"circumfixed `ga`\" : `100 cats -> 100 gacatga`\n\nAs you all (\"hawk eyes\") have seen, the final `s` of english plural **disappears**.\n\n( btw these markers, of course, have absolutely nothing to do with true sursurunga language, we're just talking about \"**pig**-sursurunga\" with **pig** as **pig** in \"**pig latin**\" )\n\n## Your Job . . .\n. . . if you accept it, will be to write a `sursurungal` function which get a `string` as argument and returns this string with words in it eventually converted to their \"pig-sursurunga number type\".\n\nIf a `number` ( *ie* 1 or more digit ) + a `space` + a `word` ( letters ) are found then the word should be converted.\n\n**Each** group of `number+space+word` found in the string should be evaluated.\n\n### Examples :\n\nYou may assume at least 1 `number+space+word` group will be provided.\n\n**Beware** `s` of english plural should be removed, not ending `s` of some singular words ( *eg* \"kiss\" )\n\nGood luck!\n-/\n\n-- Numbers remain unchanged in output\n\n-- Word transformation rules for different numbers\n\n-- Text without number-word pairs remains unchanged", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sursurungal (s : String) : String :=\nsorry\n\ndef containsDigit (s : String) (d : Nat) : Prop :=\nsorry\n\ndef containsWordAfterNumber (s : String) (n : Nat) (w : String) : Prop :=\nsorry", "vc-theorems": "theorem sursurungal_preserves_numbers {s : String} :\n  ∀ n : Nat, containsDigit s n → containsDigit (sursurungal s) n :=\nsorry\n\ntheorem word_transformation_rules {s : String} (n : Nat) (w : String) :\n  containsWordAfterNumber (sursurungal s) n w →\n  match n with\n  | 1 => ¬(w.startsWith \"bu\") ∧ ¬(w.startsWith \"ga\") ∧ ¬(w.endsWith \"zo\")\n  | 2 => w.startsWith \"bu\" ∧ ¬(w.startsWith \"ga\") ∧ ¬(w.endsWith \"zo\")\n  | n => if n ≤ 9\n        then ¬(w.startsWith \"bu\") ∧ ¬(w.startsWith \"ga\") ∧ w.endsWith \"zo\"\n        else w.startsWith \"ga\" ∧ w.endsWith \"ga\" ∧ ¬(w.endsWith \"zo\") :=\nsorry\n\ntheorem unchanged_text_without_numbers (s : String) :\n  (∀ n : Nat, ¬containsDigit s n) →\n  sursurungal s = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1 tomato'\n-/\n#guard_msgs in\n#eval sursurungal \"1 tomato\"\n\n/--\ninfo: '2 bubanana'\n-/\n#guard_msgs in\n#eval sursurungal \"2 bananas\"\n\n/--\ninfo: '3 bananazo'\n-/\n#guard_msgs in\n#eval sursurungal \"3 bananas\"\n\n/--\ninfo: '10 gabananaga'\n-/\n#guard_msgs in\n#eval sursurungal \"10 bananas\"\n\n/--\ninfo: '6 birdzo with 2 buwing each'\n-/\n#guard_msgs in\n#eval sursurungal \"6 birds with 2 wings each\"\n\n/--\ninfo: '\\n3 pigzo\\nmet 1 wolf\\n2 buday ago'\n-/\n#guard_msgs in\n#eval sursurungal \"\\n3 pigs\\nmet 1 wolf\\n2 days ago\""}
{"id": "fvapps_003127", "vc-description": "/-\nIn genetics, a sequence’s motif is a nucleotides (or amino-acid) sequence pattern. Sequence motifs have a biological significance. For more information you can take a look [here](https://en.wikipedia.org/wiki/Sequence_motif).\n\nFor this kata you need to complete the function `motif_locator`. This function receives 2 arguments - a sequence and a motif. Both arguments are strings.\n\nYou should return an array that contains all the start positions of the motif (in order). A sequence may contain 0 or more repetitions of the given motif. Note that the number of the first position is 1, not 0.\n\n**Some examples:**\n\n- For the `sequence` \"ACGTGGGGACTAGGGG\" and the `motif` \"GGGG\" the result should be [5, 13]. \n- For the `sequence` \"ACCGTACCAAGGGACC\" and the `motif` \"AAT\"  the result should be []\n- For the `sequence` \"GGG\" and the motif \"GG\" the result should be [1, 2]\n\n**Note**: You can take a look to my others bio-info kata [here](http://www.codewars.com/users/nbeck/authored)\n-/", "vc-preamble": "def DnaBases : List Char := ['A', 'C', 'G', 'T']\n\ndef isValidDnaChar (c : Char) : Bool :=\n  match DnaBases.find? (· == c) with\n  | some _ => true\n  | none => false\n\ndef isValidDnaString (s : String) : Bool :=\n  match s.data.find? (fun c => !isValidDnaChar c) with\n  | some _ => false\n  | none => true", "vc-helpers": "", "vc-definitions": "def motif_locator (sequence motif : String) : List Nat :=\nsorry\n\ndef substring (s : String) (start len : Nat) : String :=\nsorry", "vc-theorems": "theorem motif_positions_valid (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (∀ p ∈ positions, 0 < p ∧ p ≤ sequence.length) ∧\n  (∀ p ∈ positions, substring sequence (p-1) motif.length = motif) :=\nsorry\n\ntheorem positions_ordered_nonoverlap (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (∀ i j, i < j → j < positions.length → positions[i]! ≤ positions[j]!) ∧\n  (∀ i, i < positions.length - 1 → positions[i+1]! - positions[i]! ≥ motif.length) :=\nsorry\n\ntheorem empty_sequence (motif : String)\n  (h : isValidDnaString motif) :\n  motif_locator \"\" motif = [] :=\nsorry\n\ntheorem motif_longer_than_seq :\n  motif_locator \"ACG\" \"ACGT\" = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [3, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"TTCCGGAACC\" \"CC\"\n\n/--\ninfo: [1, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTTACAACGTTAG\" \"ACGT\"\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTACGTACGT\" \"AAA\""}
{"id": "fvapps_003136", "vc-description": "/-\n# Task\n\nJohn won the championship of a TV show. He can get some bonuses.\n\nHe needs to play a game to determine the amount of his bonus.\n\nHere are some cards in a row. A number is written on each card.\n\nIn each turn, John can take a card, but only from the beginning or the end of the row. Then multiply the number on the card by an coefficient 2^(i)(i means the ith turn). The product is John's bonus of current turn.\n\nAfter all the cards are taken away, the game is over. John's final bonus is the sum of all rounds of bonuses.\n\nObviously, the order in which John takes the cards will affect the amount of John's final bonus.\n\nYour task is to help John calculate the maximum amount of bonuses he can get.\n\n# Input\n\n- `cards`: An integer array. Each element represents the number on the card.\n  - `1 <= cards.length <= 30`\n  - `1 <= cards[i] <= 100`\n\n- All inputs are valid.\n\n# Output\n\nAn integer. the maximum amount of bonuses John can get.\n\n# Eaxmple\n\nFor `cards=[1,2,5]`, the output should be `50`.\n\n```\nAll possible orders are:\n1->2->5   bonus:1x2+2*4+5*8=50\n1->5->2   bonus:1x2+5*4+2*8=38\n5->1->2   bonus:5*2+1*4+2*8=30\n5->2->1   bonus:5*2+2*4+1*8=26\nThe maximum amount of bonus is 50.\n```\n-/\n\n/-- Helper function to sum a list of naturals -/", "vc-preamble": "def listSum : List Nat → Nat\n| [] => 0\n| (x::xs) => x + listSum xs", "vc-helpers": "", "vc-definitions": "def calculate : List Nat → Nat :=\n  sorry", "vc-theorems": "theorem calc_is_positive (cards : List Nat) :\n  cards ≠ [] → calculate cards ≥ 0 :=\n  sorry\n\ntheorem calc_single_element (cards : List Nat) (x : Nat) :\n  cards = [x] → calculate cards = 2 * x :=\n  sorry\n\ntheorem calc_increases_monotonic (cards : List Nat) (i : Nat) (hi : i < cards.length) :\n  let cards' := cards.set i (cards[i]! + 1);\n  calculate cards' ≥ calculate cards :=\n  sorry\n\ntheorem calc_bounded_by_double (cards : List Nat) :\n  cards ≠ [] → calculate cards ≤ listSum cards * (2 ^ cards.length) :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_003141", "vc-description": "/-\nAn array is defined to be `inertial`if the following conditions hold:\n```\na. it contains at least one odd value  \nb. the maximum value in the array is even \nc. every odd value is greater than every even value that is not the maximum value.\n```\neg:-\n```\nSo [11, 4, 20, 9, 2, 8] is inertial because \na. it contains at least one odd value [11,9] \nb. the maximum value in the array is 20 which is even \nc. the two odd values (11 and 9) are greater than all the even values that are not equal to 20 (the maximum), i.e., [4, 2, 8]\n```\nWrite a function called `is_inertial` that accepts an integer array and returns `true` if the array is inertial; otherwise it returns `false`.\n-/", "vc-preamble": "def maximum? : List Int → Option Int\n  | [] => none\n  | x::xs => some (xs.foldl max x)\n\ndef minimum? : List Int → Option Int\n  | [] => none\n  | x::xs => some (xs.foldl min x)", "vc-helpers": "", "vc-definitions": "def isInertial (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem empty_array\n  : ∀ (arr : List Int), arr = [] → isInertial arr = false := by\n  sorry\n\ntheorem no_odds\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    (∀ x ∈ arr, x % 2 = 0) →\n    isInertial arr = false := by\n  sorry\n\ntheorem max_must_be_even\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    match maximum? arr with\n    | none => True\n    | some max => max % 2 = 1 → isInertial arr = false := by\n  sorry\n\ntheorem odds_vs_evens\n  : ∀ (arr : List Int),\n    arr ≠ [] →\n    (∃ x ∈ arr, x % 2 = 1) →\n    match maximum? arr with\n    | none => True\n    | some max =>\n      max % 2 = 0 →\n      let odds := arr.filter (fun x => x % 2 = 1)\n      let evens := arr.filter (fun x => x % 2 = 0 && x ≠ max)\n      odds ≠ [] →\n      evens ≠ [] →\n      match minimum? odds, maximum? evens with\n      | some min_odd, some max_even => isInertial arr = (min_odd > max_even)\n      | _, _ => True := by\n  sorry\n\ntheorem single_element\n  : ∀ (n : Int), isInertial [n] = false := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial []\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial [581, -384, 140, -287]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_inertial [11, 4, 20, 9, 2, 8]"}
{"id": "fvapps_003143", "vc-description": "/-\nYou will be given two strings `a` and `b` consisting of lower case letters, but `a` will have at most one asterix character. The asterix (if any) can be replaced with an arbitrary sequence (possibly empty) of lowercase letters. No other character of string `a` can be replaced. If it is possible to replace the asterix in `a` to obtain string `b`, then string `b` matches the pattern. \n\nIf the string matches, return `true` else `false`. \n\n```\nFor example:\nsolve(\"code*s\",\"codewars\") = true, because we can replace the asterix(*) with \"war\" to match the second string. \nsolve(\"codewar*s\",\"codewars\") = true, because we can replace the asterix(*) with \"\" to match the second string. \nsolve(\"codewars\",\"codewars\") = true, because the strings already match.\nsolve(\"a\",\"b\") = false\n```\nMore examples in test cases. \n\nGood luck!\n-/", "vc-preamble": "def stringAppend (s1 s2: String) : String := String.append s1 s2", "vc-helpers": "", "vc-definitions": "def solve (pattern: String) (target: String) : Bool :=\nsorry", "vc-theorems": "theorem identical_strings_match\n  (s: String)\n  (h: s.data.all (fun c => c ≠ '*')) :\n  solve s s = true :=\nsorry\n\ntheorem wildcard_match\n  (p s m: String)\n  (h1: p.data.all (fun c => c ≠ '*'))\n  (h2: s.data.all (fun c => c ≠ '*'))\n  (h3: m.data.all (fun c => c ≠ '*')) :\n  solve (stringAppend (stringAppend p \"*\") s) (stringAppend (stringAppend p m) s) = true :=\nsorry\n\ntheorem different_strings_no_match\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c ≠ '*'))\n  (h2: s2.data.all (fun c => c ≠ '*'))\n  (h3: s1 ≠ s2) :\n  solve s1 s2 = false :=\nsorry\n\ntheorem multiple_wildcards_invalid\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c ≠ '*'))\n  (h2: s2.data.all (fun c => c ≠ '*')) :\n  solve (stringAppend (stringAppend (stringAppend s1 \"*\") s2) \"*\") \"anything\" = false :=\nsorry\n\ntheorem length_requirement\n  (p s m: String)\n  (h1: p.data.all (fun c => c ≠ '*'))\n  (h2: s.data.all (fun c => c ≠ '*')) :\n  (stringAppend (stringAppend p m) s).length ≥ (stringAppend (stringAppend p \"*\") s).length - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"code*s\" \"codewars\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"codewar*s\" \"codewars\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"code*warrior\" \"codewars\""}
{"id": "fvapps_003145", "vc-description": "/-\n## Overview\nResistors are electrical components marked with colorful stripes/bands to indicate both their resistance value in ohms and how tight a tolerance that value has. If you did my Resistor Color Codes kata, you wrote a function which took a string containing a resistor's band colors, and returned a string identifying the resistor's ohms and tolerance values.\n\nWell, now you need that in reverse: The previous owner of your \"Beyond-Ultimate Raspberry Pi Starter Kit\" (as featured in my Fizz Buzz Cuckoo Clock kata) had emptied all the tiny labeled zip-lock bags of components into the box, so that for each resistor you need for a project, instead of looking for text on a label, you need to find one with the sequence of band colors that matches the ohms value you need.\n\n## The resistor color codes\nYou can see this Wikipedia page for a colorful chart, but the basic resistor color codes are:\n\n0: black, 1: brown, 2: red, 3: orange, 4: yellow, 5: green, 6: blue, 7: violet, 8: gray, 9: white\n\nAll resistors have at least three bands, with the first and second bands indicating the first two digits of the ohms value, and the third indicating the power of ten to multiply them by, for example a resistor with a value of 47 ohms, which equals 47 * 10^0 ohms, would have the three bands \"yellow violet black\".\n\nMost resistors also have a fourth band indicating tolerance -- in an electronics kit like yours, the tolerance will always be 5%, which is indicated by a gold band. So in your kit, the 47-ohm resistor in the above paragraph would have the four bands \"yellow violet black gold\".\n\n## Your mission\nYour function will receive a string containing the ohms value you need, followed by a space and the word \"ohms\" (to avoid Codewars unicode headaches I'm just using the word instead of the ohms unicode symbol). The way an ohms value is formatted depends on the magnitude of the value:\n\n* For resistors less than 1000 ohms, the ohms value is just formatted as the plain number. For example, with the 47-ohm resistor above, your function would receive the string `\"47 ohms\"`, and return the string `\"yellow violet black gold\".\n\n* For resistors greater than or equal to 1000 ohms, but less than 1000000 ohms, the ohms value is divided by 1000, and has a lower-case \"k\" after it. For example, if your function received the string `\"4.7k ohms\"`, it would need to return the string `\"yellow violet red gold\"`.\n\n* For resistors of 1000000 ohms or greater, the ohms value is divided by 1000000, and has an upper-case \"M\" after it. For example, if your function received the string `\"1M ohms\"`, it would need to return the string `\"brown black green gold\"`. \n\nTest case resistor values will all be between 10 ohms and 990M ohms.\n\n## More examples, featuring some common resistor values from your kit\n```\n\"10 ohms\"        \"brown black black gold\"\n\"100 ohms\"       \"brown black brown gold\"\n\"220 ohms\"       \"red red brown gold\"\n\"330 ohms\"       \"orange orange brown gold\"\n\"470 ohms\"       \"yellow violet brown gold\"\n\"680 ohms\"       \"blue gray brown gold\"\n\"1k ohms\"        \"brown black red gold\"\n\"10k ohms\"       \"brown black orange gold\"\n\"22k ohms\"       \"red red orange gold\"\n\"47k ohms\"       \"yellow violet orange gold\"\n\"100k ohms\"      \"brown black yellow gold\"\n\"330k ohms\"      \"orange orange yellow gold\"\n\"2M ohms\"        \"red black green gold\"\n```\n\nHave fun!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encode_resistor_colors (ohm_str : String) : String :=\n  sorry\n\ndef String.toNat (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem resistor_colors_format {ohm_str : String}\n  (h : 10 ≤ ohm_str.toNat ∧ ohm_str.toNat ≤ 99000000) :\n  let result := encode_resistor_colors ohm_str\n  let colors := (result.split fun c => c = ' ')\n  (colors.length = 4) ∧\n  (colors[3]! = \"gold\") ∧\n  (∀ c ∈ colors, c ∈ [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\", \"gold\"]) :=\nsorry\n\ntheorem resistor_colors_value {ohm_str : String}\n  (h1 : ohm_str.contains 'k' →\n        1000 * (ohm_str.replace \"k\" \" \").toNat = ohm_str.toNat)\n  (h2 : ohm_str.contains 'M' →\n        1000000 * (ohm_str.replace \"M\" \" \").toNat = ohm_str.toNat)\n  (h3 : ¬ohm_str.contains 'k' ∧ ¬ohm_str.contains 'M' →\n        ohm_str.toNat = ohm_str.toNat)\n  (h4 : 10 ≤ ohm_str.toNat ∧ ohm_str.toNat ≤ 99000000) :\n  let result := encode_resistor_colors ohm_str\n  ohm_str.toNat = result.toNat :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003147", "vc-description": "/-\nReverse and invert all integer values in a given list. \n\nPython:\n\n    reverse_invert([1,12,'a',3.4,87,99.9,-42,50,5.6]) = [-1,-21,-78,24,-5]\n\nIgnore all other types than integer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reverseInvert (lst : List Int) : List Int :=\nsorry\n\ndef numReverse (n : Int) : Int :=\nsorry", "vc-theorems": "theorem reverseInvert_returns_list_of_ints {lst : List Int} :\n  ∀ x, x ∈ reverseInvert lst → x ∈ lst := by\nsorry\n\ntheorem reverseInvert_bounded {lst : List Int}\n    (h : ∀ x ∈ lst, -999 ≤ x ∧ x ≤ 999) :\n    ∀ (i : Fin lst.length),\n      let orig := lst.get i\n      let revNum := numReverse (Int.natAbs orig)\n      (reverseInvert lst).get ⟨i, by sorry⟩ = if orig > 0 then -revNum else revNum := by\nsorry\n\ntheorem reverseInvert_single_digits {lst : List Int} (h : ∀ x ∈ lst, 0 ≤ x ∧ x ≤ 9) :\n  ∀ (i : Fin lst.length),\n    (reverseInvert lst).get ⟨i, by sorry⟩ = -(lst.get i) := by\nsorry\n\ntheorem reverseInvert_length_preservation {lst : List Int} :\n  (reverseInvert lst).length = lst.length := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [-1, -2, -3, -4, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 2, 3, 4, 5]\n\n/--\ninfo: [-1, -21, -78, 24, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 12, \"a\", 3.4, 87, 99.9, -42, 50, 5.6]\n\n/--\ninfo: [9, 81, -99]\n-/\n#guard_msgs in\n#eval reverse_invert [-9, -18, 99]"}
{"id": "fvapps_003149", "vc-description": "/-\n# RoboScript #1 - Implement Syntax Highlighting\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nYou are a computer scientist and engineer who has recently founded a firm which sells a toy product called MyRobot which can move by receiving a set of instructions by reading a file containing a script.  Initially you have planned the robot to be able to interpret JavaScript files for its movement instructions but you later decided that it would make MyRobot too hard to operate for most customers out there who aren't even computer programmers in the first place.  For this reason, you have decided to invent a new (esoteric) scripting language called RoboScript which has a much simpler syntax so non-computer programmers can easily learn how to write scripts in this language which would enable them to properly operate MyRobot.  However, you are currently at the initial stage of inventing this new Esolang.  The first step to popularize this (esoteric) scripting language is naturally to invent a new editor for it which provides syntax highlighting for this language so your customers feel like they are writing a proper program when they are writing scripts for MyRobot.\n\n## Task\n\nYour MyRobot-specific (esoteric) scripting language called RoboScript only ever contains the following characters: `F`, `L`, `R`, the digits `0-9` and brackets (`(` and `)`).  Your goal is to write a function `highlight` which accepts 1 required argument `code` which is the RoboScript program passed in as a string and returns the script with syntax highlighting.  The following commands/characters should have the following colors:\n\n- `F` - Wrap this command around `` and `` tags so that it is highlighted pink in our editor\n- `L` - Wrap this command around `` and `` tags so that it is highlighted red in our editor\n- `R` - Wrap this command around `` and `` tags so that it is highlighted green in our editor\n- Digits from `0` through `9` - Wrap these around `` and `` tags so that they are highlighted orange in our editor\n- Round Brackets - Do not apply any syntax highlighting to these characters\n\nFor example:\n\nAnd for multiple characters with the same color, simply wrap them with a **single** `` tag of the correct color:\n\nNote that the use of `` tags must be **exactly** the same format as demonstrated above.  Even if your solution produces the same visual result as the expected answers, if you miss a space betwen `\"color:\"` and `\"green\"`, for example, you will fail the tests.\n\n## Kata in this Series\n\n1. **RoboScript #1 - Implement Syntax Highlighting**\n2. [RoboScript #2 - Implement the RS1 Specification](https://www.codewars.com/kata/5870fa11aa0428da750000da)\n3. [RoboScript #3 - Implement the RS2 Specification](https://www.codewars.com/kata/58738d518ec3b4bf95000192)\n4. [RoboScript #4 - RS3 Patterns to the Rescue](https://www.codewars.com/kata/594b898169c1d644f900002e)\n5. [RoboScript #5 - The Final Obstacle (Implement RSU)](https://www.codewars.com/kata/5a12755832b8b956a9000133)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def highlight (s : String) : String :=\nsorry\n\ndef colorFor (c : Char) : String :=\nsorry\n\ndef String.count (s : String) (sub : String) : Nat :=\nsorry", "vc-theorems": "theorem letter_get_correct_colors (c : Char) (h: c ∈ ['F', 'L', 'R']):\n  let color :=\n    match c with\n    | 'F' => \"pink\"\n    | 'L' => \"red\"\n    | 'R' => \"green\"\n    | _ => \"\"\n  colorFor c = color\n  :=\nsorry\n\ntheorem numbers_get_orange (c : Char) (h : c.isDigit) :\n  colorFor c = \"orange\" :=\nsorry\n\ntheorem consecutive_chars_single_span (s : String) (h: s.all (· = s.get! 0)) :\n  (highlight s).count \"<span\" = 1 :=\nsorry\n\ntheorem highlight_maintains_content (s : String) :\n  let stripped := (highlight s).replace \"<span\" \"\" |>.replace \"</span\" \"\" |>.replace \"style=\\\"color: pink\\\"\" \"\"\n                   |>.replace \"style=\\\"color: red\\\"\" \"\" |>.replace \"style=\\\"color: green\\\"\" \"\"\n                   |>.replace \"style=\\\"color: orange\\\"\" \"\"\n  stripped = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval highlight \"F3RF5LF7\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval highlight \"FFFR345F2LL\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval highlight \"FF(LF6(RF3)2)3\""}
{"id": "fvapps_003157", "vc-description": "/-\nThe number n is Evil if it has an even number of 1's in its binary representation.\nThe first few Evil numbers: 3, 5, 6, 9, 10, 12, 15, 17, 18, 20\nThe number n is Odious if it has an odd number of 1's in its binary representation.\nThe first few Odious numbers: 1, 2, 4, 7, 8, 11, 13, 14, 16, 19\nYou have to write a function that determine if a number is Evil of Odious, function should return \"It's Evil!\" in case of evil number and \"It's Odious!\" in case of odious number.\n\ngood luck :)\n-/", "vc-preamble": "def countOnes (n : Nat) : Nat :=\n  if n = 0 then 0\n  else if n % 2 = 1\n  then countOnes (n / 2) + 1\n  else countOnes (n / 2)", "vc-helpers": "", "vc-definitions": "def evil (n : Nat) : String :=\nsorry", "vc-theorems": "theorem evil_result_valid (n : Nat) :\n  (evil n = \"It's Evil!\") ∨ (evil n = \"It's Odious!\") :=\nsorry\n\ntheorem evil_xor_property (n m : Nat) :\n  let n_evil := evil n = \"It's Evil!\"\n  let m_evil := evil m = \"It's Evil!\"\n  let xor_evil := evil (n ^^^ m) = \"It's Evil!\"\n  (n_evil = m_evil) = xor_evil :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 1\n\n/--\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 2\n\n/--\ninfo: \"It's Evil!\"\n-/\n#guard_msgs in\n#eval evil 3"}
{"id": "fvapps_003165", "vc-description": "/-\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n Give you two number `m` and `n`(two positive integer, m < n), make a triangle pattern with number sequence `m to n`. The order is clockwise, starting from the top corner, like this:\n\n```\n When m=1 n=10  triangle is:\n    1\n   9 2\n  8 0 3\n 7 6 5 4\n```\n Note: The pattern only uses the last digit of each number; Each row separated by \"\\n\"; Each digit separated by a space; Left side may need pad some spaces, but don't pad the right side; If `m to n` can not make the triangle, return `\"\"`.\n\n# Some examples:\n\n```\nmakeTriangle(1,3) should return:\n 1\n3 2\n\nmakeTriangle(6,20) should return: \n\n    6\n   7 7\n  6 8 8\n 5 0 9 9\n4 3 2 1 0\n\nmakeTriangle(1,12) should return \"\"\n\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def isDigitChar (c : Char) : Bool :=\n  '0' ≤ c ∧ c ≤ '9'", "vc-helpers": "", "vc-definitions": "def make_triangle (m n : Nat) : String :=\n  sorry", "vc-theorems": "theorem make_triangle_valid_output_type {m n : Nat} :\n  ∀ r : String, r = make_triangle m n → (r = \"\" ∨ String.contains r '\\n') :=\nsorry\n\ntheorem make_triangle_digits_only {m n : Nat} (h : m ≤ n) (h2 : n - m + 1 ≤ 45) :\n  ∀ c : Char, c ∈ (make_triangle m n).toList →\n    (c = ' ' ∨ c = '\\n' ∨ isDigitChar c) :=\nsorry\n\ntheorem make_triangle_row_growth {m n : Nat} (h : m ≤ n) (h2 : n - m + 1 ≤ 45) :\n  let lines := String.split (make_triangle m n) (· = '\\n')\n  ∀ i : Nat, i < lines.length →\n    ∀ h : i < lines.length,\n    (String.split (String.trim (lines[i]'h)) (· = ' ')).length = i + 1 :=\nsorry\n\ntheorem make_triangle_total_elements {m n : Nat} (h : m ≤ n) :\n  let size := n - m + 1\n  let result := make_triangle m n\n  let lines := String.split result (· = '\\n')\n  result ≠ \"\" →\n  (lines.foldl (fun acc line =>\n    acc + (String.split (String.trim line) (· = ' ')).length) 0) = size :=\nsorry\n\ntheorem make_triangle_invalid_empty {m n : Nat} :\n  (m > n ∨ n - m + 1 > 45) → make_triangle m n = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003166", "vc-description": "/-\nConsider an array containing cats and dogs. Each dog can catch only one cat, but cannot catch a cat that is more than `n` elements away. Your task will be to return the maximum number of cats that can be caught.\n\nFor example:\n```Haskell\nsolve(['D','C','C','D','C'], 2) = 2, because the dog at index 0 (D0) catches C1 and D3 catches C4. \nsolve(['C','C','D','D','C','D'], 2) = 3, because D2 catches C0, D3 catches C1 and D5 catches C4.\nsolve(['C','C','D','D','C','D'], 1) = 2, because D2 catches C1, D3 catches C4. C0 cannot be caught because n == 1.\nsolve(['D','C','D','D','C'], 1) = 2, too many dogs, so all cats get caught!\n```\n\nDo not modify the input array. \n\nMore examples in the test cases. Good luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (arr : List Char) (reach : Nat) : Nat :=\n  sorry\n\ndef numChar (c : Char) (arr : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem solve_empty {reach : Nat} :\n  solve [] reach = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"D\", \"C\", \"C\", \"D\", \"C\"] 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 1"}
{"id": "fvapps_003172", "vc-description": "/-\nTranform of input array of zeros and ones to array in which counts number of continuous ones:\n\n[1, 1, 1, 0, 1] -> [3,1]\n-/", "vc-preamble": "def sum_list : List Int → Int\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def ones_counter (nums : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem ones_counter_positive (nums : List Int) :\n  ∀ x ∈ ones_counter nums, x > 0\n:=\nsorry\n\ntheorem ones_counter_sum (nums : List Int) :\n  sum_list (ones_counter nums) = sum_list nums\n:=\nsorry\n\ntheorem ones_counter_grouped (nums : List Int) :\n  ones_counter nums =\n    let rec group_ones (ns : List Int) (acc : Int) (result : List Int) : List Int :=\n      match ns with\n      | [] => if acc > 0 then result ++ [acc] else result\n      | x::xs => if x = 1\n                 then group_ones xs (acc + 1) result\n                 else if acc > 0\n                      then group_ones xs 0 (result ++ [acc])\n                      else group_ones xs 0 result\n    group_ones nums 0 []\n:=\nsorry\n\ntheorem ones_counter_all_zeros {nums : List Int} (h : ∀ x ∈ nums, x = 0) :\n  ones_counter nums = []\n:=\nsorry\n\ntheorem ones_counter_all_ones {nums : List Int} (h : ∀ x ∈ nums, x = 1) (h' : nums ≠ []) :\n  ones_counter nums = [((List.length nums) : Int)]\n:=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval ones_counter [0, 0, 0, 0, 0, 0, 0, 0]\n\n/--\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval ones_counter [1, 1, 1, 0, 0, 1, 0, 1, 1, 0]\n\n/--\ninfo: [1, 2, 4, 1]\n-/\n#guard_msgs in\n#eval ones_counter [1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1]"}
{"id": "fvapps_003176", "vc-description": "/-\n**Background**   \nYou most probably know, that the *kilo* used by IT-People differs from the\n*kilo* used by the rest of the world. Whereas *kilo* in kB is (mostly) intrepreted as 1024 Bytes (especially by operating systems) the non-IT *kilo* denotes the factor 1000 (as in \"1 kg is 1000g\"). The same goes for the prefixes mega, giga, tera, peta and so on.\nTo avoid misunderstandings (like your hardware shop selling you a 1E+12 Byte harddisk as 1 TB, whereas  your Windows states that it has only 932 GB, because the shop uses factor 1000 whereas operating systems use factor 1024 by default) the  International Electrotechnical Commission has proposed to use **kibibyte** for 1024 Byte.The according unit symbol would be **KiB**. Other Prefixes would be respectivly:   \n\n```\n1 MiB = 1024 KiB   \n1 GiB = 1024 MiB   \n1 TiB = 1024 GiB     \n```\n\n**Task**   \nYour task is to write a conversion function between the kB and the KiB-Units. The function receives as parameter a memory size including a unit and converts into the corresponding unit of the other system:\n\n```\nmemorysizeConversion ( \"10 KiB\") -> \"10.24 kB\"   \nmemorysizeConversion ( \"1 kB\") -> \"0.977 KiB\"   \nmemorysizeConversion ( \"10 TB\") -> \"9.095 TiB\"   \nmemorysizeConversion ( \"4.1 GiB\") -> \"4.402 GB\"   \n```\n\n**Hints**\n- the parameter always contains a (fractioned) number, a whitespace and a valid unit\n- units are case sensitive, valid units are **kB MB GB TB KiB MiB GiB TiB**\n- result must be rounded to 3 decimals (round half up,no trailing zeros) see examples above\n\n**Resources**\nIf you want to read more on ...ibi-Units:  \nhttps://en.wikipedia.org/wiki/Kibibyte\n-/", "vc-preamble": "def binary_units := [\"KiB\", \"MiB\", \"GiB\", \"TiB\"]\n\ndef metric_units := [\"kB\", \"MB\", \"GB\", \"TB\"]\n\ndef isValidIndex (i : Nat) : Prop :=\n  i < 4", "vc-helpers": "", "vc-definitions": "def memorysize_conversion (s : String) : String :=\nsorry", "vc-theorems": "theorem binary_units_length : binary_units.length = 4 :=\nsorry\n\ntheorem metric_units_length : metric_units.length = 4 :=\nsorry\n\ntheorem binary_to_metric_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 ≤ value) (h2 : value ≤ 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {binary_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith metric_units[unit_idx] :=\nsorry\n\ntheorem metric_to_binary_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 ≤ value) (h2 : value ≤ 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {metric_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith binary_units[unit_idx] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1.024 kB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"1 KiB\"\n\n/--\ninfo: '9.095 TiB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"10 TB\"\n\n/--\ninfo: '4.402 GB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"4.1 GiB\""}
{"id": "fvapps_003179", "vc-description": "/-\nThe prime numbers are not regularly spaced. For example from `2` to `3` the gap is `1`.\nFrom `3` to `5` the gap is `2`. From `7` to `11` it is `4`.\nBetween 2 and 50 we have the following pairs of 2-gaps primes:\n`3-5, 5-7, 11-13, 17-19, 29-31, 41-43`\n\nA prime gap of length n is a run of n-1 consecutive composite numbers between two **successive** primes (see: http://mathworld.wolfram.com/PrimeGaps.html).\n\nWe will write a function gap with parameters:\n\n`g` (integer >= 2) which indicates the gap we are looking for\n\n`m` (integer > 2) which gives the start of the search (m inclusive)\n\n`n` (integer >= m) which gives the end of the search (n inclusive)\n\nIn the example above `gap(2, 3, 50)` will return `[3, 5] or (3, 5) or {3, 5}` which is the first pair between 3 and 50 with a 2-gap.\n\nSo this function should return the **first** pair of two prime numbers spaced with a gap of `g`\nbetween the limits `m`, `n` if these numbers exist otherwise `nil or null or None or Nothing` (depending on the language). \n\nIn C++ return in such a case `{0, 0}`. In F# return `[||]`. In Kotlin return `[]`\n\n#Examples:\n`gap(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7}`\n\n`gap(2, 5, 5) --> nil. In C++ {0, 0}. In F# [||]. In Kotlin return `[]`\n\n`gap(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}`\n\n([193, 197] is also such a 4-gap primes between 130 and 200 but it's not the first pair)\n\n`gap(6,100,110) --> nil or {0, 0}` : between 100 and 110 we have `101, 103, 107, 109` but `101-107`is not a\n6-gap because there is `103`in between and `103-109`is not a 6-gap because there is `107`in between.\n\n# Note for Go\nFor Go: nil slice is expected when there are no gap between m and n.\nExample: gap(11,30000,100000) --> nil\n\n#Ref\nhttps://en.wikipedia.org/wiki/Prime_gap\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\nsorry\n\ndef isPrime (n : Nat) : Bool :=\nsorry\n\ndef gap (g m n : Nat) : Option (Nat × Nat) :=\nsorry", "vc-theorems": "theorem prime_divisibility {n : Nat} (h : n ≥ 2) :\n  isPrime n = true →\n  ∀ i : Nat, 2 ≤ i → i ≤ sqrt n → n % i ≠ 0 :=\nsorry\n\ntheorem composite_divisibility {n : Nat} (h : n ≥ 2) :\n  isPrime n = false →\n  (∃ i : Nat, 2 ≤ i ∧ i ≤ sqrt n ∧ n % i = 0) ∨ n < 2 :=\nsorry\n\ntheorem gap_result_valid {g m n : Nat} (hm : m ≥ 2) (hn : n ≥ 2) :\n  ∀ result : Nat × Nat,\n  gap g m n = some result →\n  let (p₁, p₂) := result\n  (isPrime p₁ = true ∧ isPrime p₂ = true) ∧\n  p₂ - p₁ = g ∧\n  m ≤ p₁ ∧ p₁ ≤ p₂ ∧ p₂ ≤ n ∧\n  ∀ x : Nat, p₁ < x → x < p₂ → isPrime x = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [3, 5]\n-/\n#guard_msgs in\n#eval gap 2 3 10\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval gap 6 100 110\n\n/--\ninfo: [163, 167]\n-/\n#guard_msgs in\n#eval gap 4 130 200"}
{"id": "fvapps_003180", "vc-description": "/-\nGiven two integers `a` and `x`, return the minimum non-negative number to **add to** / **subtract from** `a` to make it a multiple of `x`.\n\n```python\nminimum(10, 6)  #= 2\n\n10+2 = 12 which is a multiple of 6\n```\n\n## Note\n- 0 is always a multiple of `x`\n\n## Constraints\n\n**1 <= a <= 10^(6)**\n\n**1 <= x <= 10^(5)**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def abs (x : Int) : Int :=\n  sorry\n\ndef minimum (a x : Int) : Int :=\n  sorry", "vc-theorems": "theorem minimum_makes_number_divisible (a x : Int) (h : x ≠ 0) :\n  (a + minimum a x) % x = 0 ∨ (a - minimum a x) % x = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum 9 4\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum 10 6\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum 15 5"}
{"id": "fvapps_003189", "vc-description": "/-\n# Kata Task\n\nGiven a list of random integers, return the Three Amigos.\n\nThese are 3 numbers that live next to each other in the list, and who have the **most** in common with each other by these rules:\n* lowest statistical range\n* same parity\n\n# Notes\n\n* The list will contain at least 3 numbers\n* If there is more than one answer then return the first one found (reading the list left to right)\n* If there is no answer (e.g. no 3 adjacent numbers with same parity) then return an empty list.\n\n# Examples\n\n* ex1\n * Input = ```[1, 2, 34, 2, 1, 5, 3, 5, 7, 234, 2, 1]```\n * Result = ```[5,3,5]```\n\n* ex2\n * Input = ```[2, 4, 6, 8, 10, 2, 2, 2, 1, 1, 1, 5, 3]```\n * Result = ```[2,2,2]```\n\n* ex3\n * Input = ```[2, 4, 5, 3, 6, 3, 1, 56, 7, 6, 3, 12]```\n * Result = ```[]```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def threeAmigos (nums : List Int) : List Int :=\nsorry\n\ndef list_max (l : List Int) : Int :=\nsorry\n\ndef list_min (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem threeAmigos_valid_size {nums : List Int} :\n  let result := threeAmigos nums\n  List.length result = 0 ∨ List.length result = 3 :=\nsorry\n\ntheorem threeAmigos_consecutive {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨ ∃ i, i + 2 < List.length nums ∧\n    result = [nums[i]!, nums[i+1]!, nums[i+2]!] :=\nsorry\n\ntheorem threeAmigos_same_parity {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨ (∀ x ∈ result, x % 2 = result[0]! % 2) :=\nsorry\n\ntheorem threeAmigos_minimal_range {nums : List Int} (h : 3 ≤ List.length nums) :\n  let result := threeAmigos nums\n  result = [] ∨\n  (∀ i, i + 2 < List.length nums →\n    (∀ j, j ∈ [nums[i]!, nums[i+1]!, nums[i+2]!] → j % 2 = nums[i]! % 2) →\n    (list_max result - list_min result) ≤ (nums[i+2]! - nums[i]!)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [5, 3, 5]\n-/\n#guard_msgs in\n#eval three_amigos [1, 2, 34, 2, 1, 5, 3, 5, 7, 234, 2, 1]\n\n/--\ninfo: [2, 2, 2]\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 6, 8, 10, 2, 2, 2, 1, 1, 1, 5, 3]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 5, 3, 6, 3, 1, 56, 7, 6, 3, 12]"}
{"id": "fvapps_003196", "vc-description": "/-\nMy grandfather always predicted how old people would get, and right before he passed away he revealed his secret!\n\nIn honor of my grandfather's memory we will write a function using his formula!\n\n* Take a list of ages when each of your great-grandparent died.  \n* Multiply each number by itself.  \n* Add them all together.  \n* Take the square root of the result.  \n* Divide by two.\n\n## Example\n\n```R\npredict_age(65, 60, 75, 55, 60, 63, 64, 45) == 86\n```\n```python\npredict_age(65, 60, 75, 55, 60, 63, 64, 45) == 86\n```\n\nNote: the result should be rounded down to the nearest integer.\n\nSome random tests might fail due to a bug in the JavaScript implementation. Simply resubmit if that happens to you.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef predict_age (ages : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem predict_age_non_negative (ages : List Nat) :\n  0 ≤ predict_age ages :=\nsorry\n\ntheorem predict_age_is_nat (ages : List Nat) :\n  predict_age ages = predict_age ages :=\nsorry\n\ntheorem predict_age_order_independent (ages : List Nat) :\n  predict_age ages = predict_age ages.reverse :=\nsorry\n\ntheorem predict_age_zero :\n  predict_age [0] = 0 :=\nsorry\n\ntheorem predict_age_single (age : Nat) :\n  predict_age [age] = age / 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003200", "vc-description": "/-\n_Based on [Project Euler problem 35](https://projecteuler.net/problem=35)_\n\nA circular prime is a prime in which every circular permutation of that number is also prime. Circular permutations are created by rotating the digits of the number, for example: `197, 971, 719`. One-digit primes are circular primes by definition.\n\nComplete the function that dertermines if a number is a circular prime.\n\nThere are 100 random tests for numbers up to 10000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry\n\ndef circular_permutations (n : Nat) : List Nat :=\n  sorry\n\ndef is_prime (n : Nat) : Bool :=\n  sorry\n\ndef circular_prime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem circular_perms_length (n : Nat) (h : n > 0) :\n  List.length (circular_permutations n) = String.length (toString n) :=\nsorry\n\ntheorem circular_perms_digit_count (n : Nat) (h : n > 0) :\n  ∀ p ∈ circular_permutations n,\n    List.length (toString p).data = List.length (toString n).data :=\nsorry\n\ntheorem prime_basic_properties (n : Nat) :\n  is_prime n = true →\n    (n > 1 ∧\n     ∀ i, 2 ≤ i → i ≤ sqrt n → n % i ≠ 0) :=\nsorry\n\ntheorem circular_prime_properties (n : Nat) :\n  circular_prime n = true →\n    ∀ x ∈ circular_permutations n, is_prime x = true :=\nsorry\n\ntheorem circular_prime_symmetry (n : Nat) :\n  circular_prime n = true →\n    ∀ p ∈ circular_permutations n, circular_prime p = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 197\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval circular_prime 179\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 7"}
{"id": "fvapps_003207", "vc-description": "/-\nConsider the following numbers (where `n!` is `factorial(n)`):\n```\nu1 = (1 / 1!) * (1!)\nu2 = (1 / 2!) * (1! + 2!)\nu3 = (1 / 3!) * (1! + 2! + 3!)\n...\nun = (1 / n!) * (1! + 2! + 3! + ... + n!)\n```\n\nWhich will win: `1 / n!` or `(1! + 2! + 3! + ... + n!)`?\n\nAre these numbers going to `0` because of `1/n!` or to infinity due\nto the sum of factorials or to another number?\n\n## Task\nCalculate `(1 / n!) * (1! + 2! + 3! + ... + n!)` \nfor a given `n`, where `n` is an integer greater or equal to `1`.\n\nTo avoid discussions about rounding, return the result **truncated** to 6 decimal places, for example:\n```\n1.0000989217538616 will be truncated to 1.000098\n1.2125000000000001 will be truncated to 1.2125\n```\n\n## Remark\nKeep in mind that factorials grow rather rapidly, and you need to handle large inputs.\n\n## Hint\nYou could try to simplify the expression.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def going (n : Nat) : Float :=\nsorry\n\ndef calc_series (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem going_range (n : Nat) :\n  1 ≤ going n ∧ going n ≤ 2 :=\nsorry\n\ntheorem going_matches_calc_series (n : Nat) :\n  n ≥ 1 → n ≤ 100 → Float.abs (going n - calc_series n) < 0.000001 :=\nsorry\n\ntheorem going_decimal_places (n : Nat) :\n  ∃ k : Nat, k ≤ 6 ∧ going n * Float.ofNat (10^k) = Float.floor (going n * Float.ofNat (10^k)) :=\nsorry\n\ntheorem going_specific_values :\n  going 1 = 1.0 ∧ going 5 = 1.275 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1.275\n-/\n#guard_msgs in\n#eval going 5\n\n/--\ninfo: 1.2125\n-/\n#guard_msgs in\n#eval going 6\n\n/--\ninfo: 1.173214\n-/\n#guard_msgs in\n#eval going 7"}
{"id": "fvapps_003209", "vc-description": "/-\nGiven time in 24-hour format, convert it to words. \n\n```\nFor example:\n13:00 = one o'clock \n13:09 = nine minutes past one \n13:15 = quarter past one \n13:29 = twenty nine minutes past one\n13:30 = half past one \n13:31 = twenty nine minutes to two\n13:45 = quarter to two \n00:48 = twelve minutes to one\n00:08 = eight minutes past midnight\n12:00 = twelve o'clock\n00:00 = midnight\n\nNote: If minutes == 0, use 'o'clock'. If minutes <= 30, use 'past', and for minutes > 30, use 'to'. \n\n```\n\nMore examples in test cases. Good luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def timeToWords (time: String) : String :=\nsorry\n\ndef hasSubstring (s1 s2 : String) : Bool :=\nsorry\n\ndef endsWithStr (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem time_to_words_basic_format (hours : Nat) (minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 59) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  (hasSubstring result \"o'clock\" ∨ hasSubstring result \"past\" ∨\n   hasSubstring result \"to\" ∨ result = \"midnight\") :=\nsorry\n\ntheorem time_to_words_oclock (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:00\"\n  (hours = 0 → result = \"midnight\") ∧\n  (hours ≠ 0 → endsWithStr result \"o'clock\") :=\nsorry\n\ntheorem time_to_words_quarter_past (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:15\"\n  (hours = 0 → hasSubstring result \"quarter past midnight\") ∧\n  (hours ≠ 0 → hasSubstring result \"quarter past\") :=\nsorry\n\ntheorem time_to_words_half_past (hours : Nat) (h_hours : hours ≤ 23) :\n  let result := timeToWords s!\"#{hours}:30\"\n  (hours = 0 → hasSubstring result \"half past midnight\") ∧\n  (hours ≠ 0 → hasSubstring result \"half past\") :=\nsorry\n\ntheorem time_to_words_past_minutes (hours minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 29) (h_minutes_pos : minutes ≥ 1)\n  (h_not_quarter : minutes ≠ 15) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"past\" ∧ hasSubstring result \"minute\" ∧\n  (hasSubstring result \"minutes\" ↔ minutes ≠ 1) :=\nsorry\n\ntheorem time_to_words_to_minutes (hours minutes : Nat)\n  (h_hours : hours ≤ 23) (h_minutes : minutes ≤ 59) (h_minutes_low : minutes ≥ 31)\n  (h_not_quarter : minutes ≠ 45) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"to\" ∧ hasSubstring result \"minute\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: \"one o'clock\"\n-/\n#guard_msgs in\n#eval time_to_words \"13:00\"\n\n/--\ninfo: 'quarter past one'\n-/\n#guard_msgs in\n#eval time_to_words \"13:15\"\n\n/--\ninfo: 'midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"00:00\"\n\n/--\ninfo: 'quarter to midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"23:45\""}
{"id": "fvapps_003210", "vc-description": "/-\nFor building the encrypted string:Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.\nDo this n times!\n\nExamples:\n```\n\"This is a test!\", 1 -> \"hsi  etTi sats!\"\n\"This is a test!\", 2 -> \"hsi  etTi sats!\" -> \"s eT ashi tist!\"\n```\n\nWrite two methods:\n```python\ndef encrypt(text, n)\ndef decrypt(encrypted_text, n)\n```\n\n```Fsharp\nlet encrypt (str:string) (n:int) -> string\nlet decrypt (str:string) (n:int) -> string\n```\n\nFor both methods:\nIf the input-string is null or empty return exactly this value!\nIf n is <= 0 then return the input text.\n\nThis kata is part of the Simple Encryption Series:\nSimple Encryption #1 - Alternating Split\nSimple Encryption #2 - Index-Difference\nSimple Encryption #3 - Turn The Bits Around\nSimple Encryption #4 - Qwerty\n\nHave fun coding it and please don't forget to vote and rank this kata! :-)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encrypt (text : Option String) (n : Int) : Option String :=\n  sorry\n\ndef decrypt (text : Option String) (n : Int) : Option String :=\n  sorry", "vc-theorems": "theorem encrypt_decrypt_roundtrip {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  decrypt (encrypt (some text) n) n = some text :=\nsorry\n\ntheorem encrypt_edge_cases {text : Option String} {n : Int} (h1 : text = none ∨ text = some \"\") (h2 : n > 0) (h3 : n ≤ 10) :\n  encrypt text n = text :=\nsorry\n\ntheorem encrypt_invalid_n {text : String} {n : Int} (h1 : text.length > 0) (h2 : n ≤ 0) :\n  encrypt (some text) n = some text :=\nsorry\n\ntheorem encrypt_length_preserved {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  (encrypt (some text) n).map String.length = some text.length :=\nsorry\n\ntheorem encrypt_char_preservation {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n ≤ 10) :\n  (encrypt (some text) n).map (fun s => s.data.toArray.qsort (· ≤ ·)) = some (text.data.toArray.qsort (· ≤ ·)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'hsi  etTi sats!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 1\n\n/--\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"hsi  etTi sats!\" 1\n\n/--\ninfo: 's eT ashi tist!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 2\n\n/--\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"s eT ashi tist!\" 2\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\" 1\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval decrypt None 1"}
{"id": "fvapps_003212", "vc-description": "/-\nThe look and say sequence is a sequence in which each number is the result of a \"look and say\" operation on the previous element.\n\nConsidering for example the classical version startin with `\"1\"`: `[\"1\", \"11\", \"21, \"1211\", \"111221\", ...]`. You can see that the second element describes the first as `\"1(times number)1\"`, the third is `\"2(times number)1\"` describing the second, the fourth is `\"1(times number)2(and)1(times number)1\"` and so on.\n\nYour goal is to create a function which takes a starting string (not necessarily the classical `\"1\"`, much less a single character start) and return the nth element of the series.\n\n## Examples\n\n```python\nlook_and_say_sequence(\"1\", 1)   == \"1\"\nlook_and_say_sequence(\"1\", 3)   == \"21\"\nlook_and_say_sequence(\"1\", 5)   == \"111221\"\nlook_and_say_sequence(\"22\", 10) == \"22\"\nlook_and_say_sequence(\"14\", 2)  == \"1114\"\n```\nTrivia: `\"22\"` is the only element that can keep the series constant.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef isNonZeroDigit (c : Char) : Bool :=\nsorry\n\ndef look_and_say_sequence (s : String) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem sequence_preserves_digits (s : String) (n : Nat)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  ∀ c ∈ (look_and_say_sequence s n).data, isDigit c :=\nsorry\n\ntheorem sequence_length_monotonic (s : String) (n : Nat)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  (look_and_say_sequence s n).length ≤ (look_and_say_sequence s (n+1)).length :=\nsorry\n\ntheorem first_element_unchanged (s : String)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  look_and_say_sequence s 1 = s :=\nsorry\n\ntheorem repeating_digits_pattern (s : String)\n  (h : ∀ c ∈ s.data, isNonZeroDigit c) :\n  let result := look_and_say_sequence s 2\n  ∀ i < result.length / 2,\n    ∃ (p1 p2 : String.Pos),\n    isNonZeroDigit (result.get p1) ∧\n    isDigit (result.get p2) :=\nsorry\n\ntheorem known_repeating_sequence :\n  look_and_say_sequence \"22\" 9 = look_and_say_sequence \"22\" 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 1\n\n/--\ninfo: '21'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 3\n\n/--\ninfo: '111221'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 5\n\n/--\ninfo: '22'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"22\" 10\n\n/--\ninfo: '1114'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"14\" 2"}
{"id": "fvapps_003222", "vc-description": "/-\nA [Narcissistic Number](https://en.wikipedia.org/wiki/Narcissistic_number) is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).\n\nFor example, take 153 (3 digits):\n```\n    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n```\nand 1634 (4 digits):\n```\n    1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634\n```\n\nThe Challenge:\n\nYour code must return **true or false** depending upon whether the given number is a Narcissistic number in base 10.\n\nError checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.\n-/\n\n-- For any natural number, narcissistic returns a boolean\n\n-- The narcissistic function returns true when the sum of each digit raised to\n-- the power of number of digits equals the original number\n\n-- Known narcissistic numbers", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def narcissistic (n : Nat) : Bool :=\n  sorry\n\ndef digit_power_sum (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem narcissistic_returns_bool (n : Nat) :\n  ∃ (b : Bool), narcissistic n = b :=\nsorry\n\ntheorem narcissistic_digit_power_sum (n : Nat) :\n  narcissistic n = (n = digit_power_sum n) :=\nsorry\n\ntheorem known_narcissistic_numbers :\n  narcissistic 0 = true ∧\n  narcissistic 1 = true ∧\n  narcissistic 2 = true ∧\n  narcissistic 3 = true ∧\n  narcissistic 4 = true ∧\n  narcissistic 5 = true ∧\n  narcissistic 6 = true ∧\n  narcissistic 7 = true ∧\n  narcissistic 8 = true ∧\n  narcissistic 9 = true ∧\n  narcissistic 153 = true ∧\n  narcissistic 370 = true ∧\n  narcissistic 371 = true ∧\n  narcissistic 407 = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 153\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 1634\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval narcissistic 123"}
{"id": "fvapps_003223", "vc-description": "/-\nFor this exercise you will create a global flatten method. The method takes in any number of arguments and flattens them into a single array. If any of the arguments passed in are an array then the individual objects within the array will be flattened so that they exist at the same level as the other arguments. Any nested arrays, no matter how deep, should be flattened into the single array result.\n\nThe following are examples of how this function would be used and what the expected results would be:\n\n```python\nflatten(1, [2, 3], 4, 5, [6, [7]]) # returns [1, 2, 3, 4, 5, 6, 7]\nflatten('a', ['b', 2], 3, None, [[4], ['c']]) # returns ['a', 'b', 2, 3, None, 4, 'c']\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flatten {α : Type} : List (List α) → List α :=\n  sorry\n\ndef isNestedList {α : Type} : List (List α) → Bool :=\n  sorry", "vc-theorems": "theorem flatten_preserves_elements {α : Type} (lst : List (List α)) (inner : List α) :\n  inner ∈ lst →\n  ∀ x ∈ inner, x ∈ (flatten lst) :=\nsorry\n\ntheorem flatten_identity_on_simple_list {α : Type} (lst : List α) :\n  flatten [lst] = lst :=\nsorry\n\ntheorem flatten_length_simple {α : Type} (lst : List α) :\n  List.length (flatten [lst]) = List.length lst :=\nsorry\n\ntheorem flatten_nested_ints (lst : List (List Int)) (n : Int) :\n  n ∈ (flatten lst) →\n  ∃ inner : List Int, inner ∈ lst ∧ n ∈ inner :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003224", "vc-description": "/-\nCreate a function `sierpinski` to generate an ASCII representation of a Sierpinski triangle of order **N**. \n\nSeperate each line with `\\n`. You don't have to check the input value.\n\nThe output should look like this: \n\n     sierpinski(4)\n                   *               \n                  * *              \n                 *   *             \n                * * * *            \n               *       *           \n              * *     * *          \n             *   *   *   *         \n            * * * * * * * *        \n           *               *       \n          * *             * *      \n         *   *           *   *     \n        * * * *         * * * *    \n       *       *       *       *   \n      * *     * *     * *     * *  \n     *   *   *   *   *   *   *   * \n    * * * * * * * * * * * * * * * *\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.lines (s : String) : List String :=\nsorry\n\ndef String.count (s : String) (c : Char) : Nat :=\nsorry\n\ndef sierpinski (n : Nat) : String :=\nsorry", "vc-theorems": "theorem sierpinski_base : sierpinski 0 = \"*\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003225", "vc-description": "/-\nDivisors of 42 are : 1, 2, 3, 6, 7, 14, 21, 42.\nThese divisors squared are: 1, 4, 9, 36, 49, 196, 441, 1764.\nThe sum of the squared divisors is 2500 which is 50 * 50, a square!\n\nGiven two integers m, n (1 <= m <= n) we want to find all integers \nbetween m and n whose sum of squared divisors is itself a square.\n42 is such a number.\n\nThe result will be an array of arrays or of tuples (in C an array of Pair) or a string, each subarray having two elements,\nfirst the number whose squared divisors is a square and then the sum\nof the squared divisors.\n\n#Examples:\n```\nlist_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]\nlist_squared(42, 250) --> [[42, 2500], [246, 84100]]\n```\n\nThe form of the examples may change according to the language, see `Example Tests:` for more details.\n\n**Note**\n\nIn Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.\n-/", "vc-preamble": "def isPerfectSquare (n : Nat) : Prop :=\n  ∃ k : Nat, k * k = n", "vc-helpers": "", "vc-definitions": "def list_squared (m n : Nat) : List (Nat × Nat) :=\nsorry\n\ndef sumOfSquaredDivisors (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem list_squared_result_valid (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result,\n    ∃ (a b : Nat), pair = (a, b) ∧\n    m ≤ a ∧ a ≤ n :=\nsorry\n\ntheorem list_squared_divisors_sum (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result, pair.2 = sumOfSquaredDivisors pair.1 :=\nsorry\n\ntheorem list_squared_is_sorted (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ i, i + 1 < result.length →\n    (result[i]'sorry).1 < (result[i+1]'sorry).1 :=\nsorry\n\ntheorem list_squared_perfect_squares (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  ∀ pair ∈ result, isPerfectSquare pair.2 :=\nsorry\n\ntheorem list_squared_single_point (n : Nat) (h : 0 < n) :\n  let result := list_squared n n\n  result = [] ∨ result = [(n, sumOfSquaredDivisors n)] :=\nsorry\n\ntheorem list_squared_empty (m n : Nat) :\n  m > n → list_squared m n = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [[1, 1], [42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 1 250\n\n/--\ninfo: [[42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 42 250\n\n/--\ninfo: [[287, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 250 500"}
{"id": "fvapps_003232", "vc-description": "/-\nWith one die of 6 sides we will have six different possible results:```  1, 2, 3, 4, 5, 6``` .\n\nWith 2 dice of six sides, we will have 36 different possible results:\n``` \n(1,1),(1,2),(2,1),(1,3),(3,1),(1,4),(4,1),(1,5),\n(5,1), (1,6),(6,1),(2,2),(2,3),(3,2),(2,4),(4,2),\n(2,5),(5,2)(2,6),(6,2),(3,3),(3,4),(4,3),(3,5),(5,3),\n(3,6),(6,3),(4,4),(4,5),(5,4),(4,6),(6,4),(5,5),\n(5,6),(6,5),(6,6)\n``` \nSo, with 2 dice of 6 sides we get 36 different events.\n``` \n([6,6] ---> 36)\n``` \nBut with 2 different dice we can get for this case, the same number of events.\nOne die of ```4 sides```  and another of ```9 sides```  will produce the exact amount of events.\n``` \n([4,9] ---> 36)\n``` \nWe say that the dice set ```[4,9]``` is equivalent to ```[6,6]``` because both produce the same number of events.\n\nAlso we may have an amount of three dice producing the same amount of events. It will be for:\n``` \n[4,3,3] ---> 36\n``` \n(One die of 4 sides and two dice of 3 sides each)\n\nPerhaps you may think that the following set is equivalent: ```[6,3,2]``` but unfortunately dice have a **minimum of three sides** (well, really a \ntetrahedron with one empty side)\n\nThe task for this kata is to get the amount of equivalent dice sets, having **2 dice at least**,for a given set.\n\nFor example, for the previous case: [6,6] we will have 3 equivalent sets that are: ``` [4, 3, 3], [12, 3], [9, 4]``` .\n\nYou may assume that dice are available from 3 and above for any value up to an icosahedral die (20 sides).\n``` \n[5,6,4] ---> 5 (they are [10, 4, 3], [8, 5, 3], [20, 6], [15, 8], [12, 10])\n``` \nFor the cases we cannot get any equivalent set the result will be `0`.\nFor example for the set `[3,3]` we will not have equivalent dice.\n\nRange of inputs for Random Tests:\n``` \n3 <= sides <= 15\n2 <= dices <= 7\n``` \nSee examples in the corresponding box.\n\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def products (n : Nat) (k m : Nat) : List (List Nat) :=\nsorry\n\ndef eq_dice (dice : List Nat) : Nat :=\nsorry\n\ndef List.prod (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem eq_dice_single_die (n : Nat)\n  (h : 3 ≤ n ∧ n ≤ 20) :\n  eq_dice [n] = (products n 3 (min (n-1) 20)).length :=\nsorry\n\ntheorem eq_dice_small_pairs (d1 d2 : Nat)\n  (h1 : 3 ≤ d1 ∧ d1 ≤ 6)\n  (h2 : 3 ≤ d2 ∧ d2 ≤ 6) :\n  eq_dice [d1, d2] ≤ 5 :=\nsorry\n\ntheorem eq_dice_threes :\n  eq_dice [3, 3] = 0 :=\nsorry\n\ntheorem eq_dice_four :\n  eq_dice [4] = (products 4 3 3).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval eq_dice [6, 6]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval eq_dice [5, 6, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval eq_dice [3, 3]"}
{"id": "fvapps_003235", "vc-description": "/-\nIn this Kata, you will be given a string and two indexes (`a` and `b`). Your task is to reverse the portion of that string between those two indices inclusive. \n\n~~~if-not:fortran\n```\nsolve(\"codewars\",1,5) = \"cawedors\" -- elements at index 1 to 5 inclusive are \"odewa\". So we reverse them.\nsolve(\"cODEWArs\", 1,5) = \"cAWEDOrs\" -- to help visualize.\n```\n~~~\n~~~if:fortran\n```\nsolve(\"codewars\",2,6) = \"cawedors\" -- elements at indices 2 to 6 inclusive are \"odewa\". So we reverse them.\nsolve(\"cODEWArs\", 2,6) = \"cAWEDOrs\" -- to help visualize.\n```\n~~~\n\nInput will be lowercase and uppercase letters only. \n\nThe first index `a` will always be lower that than the string length; the second index `b` can be greater than the string length. More examples in the test cases. Good luck!\n\nPlease also try:\n\n[Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n\n[Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n\n~~~if:fortran\n*NOTE: You may assume that all input strings will* **not** *contain any (redundant) trailing whitespace.  In return, your returned string is* **not** *permitted to contain any (redundant) trailing whitespace.*\n~~~\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) (a b : Nat) : String :=\nsorry\n\ndef length (s : String) : Nat :=\nsorry\n\ndef substring (s : String) (start : Nat) (len : Nat) : String :=\nsorry\n\ndef reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem solve_length_preserved (s : String) (a b : Nat) (h : length s > 0) :\n  length (solve s a b) = length s :=\nsorry\n\ntheorem solve_preserves_outside_bounds (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) 0 start = substring s 0 start ∧\n  substring (solve s a b) finish (length s - finish) = substring s finish (length s - finish) :=\nsorry\n\ntheorem solve_reverses_middle (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) start (finish - start) = reverse (substring s start (finish - start)) :=\nsorry\n\ntheorem solve_identity_empty_range (s : String) (h : length s > 0) :\n  solve s 0 0 = s ∧\n  solve s (length s) (length s + 10) = s :=\nsorry\n\ntheorem solve_full_reversal (s : String) (h : length s > 0) :\n  solve s 0 (length s - 1) = reverse s :=\nsorry\n\ntheorem solve_single_char_identity (s : String) (idx : Nat) (h : length s > 0)\n  (limited_idx := min idx (length s - 1)) :\n  solve s limited_idx limited_idx = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003241", "vc-description": "/-\n# Task\n\nYou got a `scratch lottery`, you want to know how much money you win.\n\nThere are `6` sets of characters on the lottery. Each set of characters represents a chance to win. The text has a coating on it. When you buy the lottery ticket and then blow it off, you can see the text information below the coating.\n\nEach set of characters contains three animal names and a number, like this: `\"tiger tiger tiger 100\"`. If the three animal names are the same, Congratulations, you won the prize. You will win the same bonus as the last number.\n\nGiven the `lottery`, returns the total amount of the bonus.\n\n# Input/Output\n\n`[input]` string array `lottery`\n\nA string array that contains six sets of characters.\n\n`[output]` an integer\n\nthe total amount of the bonus.\n\n# Example\n\nFor \n```\nlottery = [\n\"tiger tiger tiger 100\",\n\"rabbit dragon snake 100\",\n\"rat ox pig 1000\",\n\"dog cock sheep 10\",\n\"horse monkey rat 5\",\n\"dog dog dog 1000\"\n]```\n\nthe output should be `1100`.\n\n`\"tiger tiger tiger 100\"` win $100, and `\"dog dog dog 1000\"` win $1000. \n\n`100 + 1000 = 1100`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def split (s : String) : List String :=\nsorry\n\ndef toNat (s : String) : Option Nat :=\nsorry\n\ndef scratch (tickets : List String) : Nat :=\nsorry", "vc-theorems": "theorem scratch_non_negative (tickets : List String) :\n  scratch tickets ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1100\n-/\n#guard_msgs in\n#eval scratch [\"tiger tiger tiger 100\", \"rabbit dragon snake 100\", \"rat ox pig 1000\", \"dog cock sheep 10\", \"horse monkey rat 5\", \"dog dog dog 1000\"]\n\n/--\ninfo: 350\n-/\n#guard_msgs in\n#eval scratch [\"cat cat cat 50\", \"dog dog dog 100\", \"pig pig pig 200\"]\n\n/--\ninfo: 500\n-/\n#guard_msgs in\n#eval scratch [\"owl eagle hawk 100\", \"cat mouse dog 200\", \"fish fish fish 500\"]"}
{"id": "fvapps_003242", "vc-description": "/-\nThe description is rather long but it tries to explain what a financing plan is. \n\nThe fixed monthly payment for a fixed rate mortgage is the amount paid by the borrower every month that ensures \nthat the loan is paid off in full with interest at the end of its term. \n\nThe monthly payment formula is based on the annuity formula. \nThe monthly payment `c` depends upon:\n\n- `rate` - the monthly interest rate is expressed as a decimal, not a percentage. \nThe monthly rate is simply the **given** yearly percentage rate divided by 100 and then by 12.\n\n- `term` - the number of monthly payments, called the loan's `term`.\n- `principal` - the amount borrowed, known as the loan's principal (or `balance`).\n\nFirst we have to determine `c`.\n\nWe have: `c = n /d` with `n = r * balance` and `d = 1 - (1 + r)**(-term)` where `**` is the `power` function (you can look at the reference below).\n\nThe payment `c` is composed of two parts. The first part pays the interest (let us call it `int`)\ndue for the balance of the given month, the second part repays the balance (let us call this part `princ`) hence for the following month we get a `new balance = old balance - princ` with `c = int + princ`. \n\nLoans are structured so that the amount of principal returned to the borrower starts out small and increases with each mortgage payment. \nWhile the mortgage payments in the first years consist primarily of interest payments, the payments in the final years consist primarily of principal repayment.\n\nA mortgage's amortization schedule provides a detailed look at precisely what portion of each mortgage payment is dedicated to each component.\n\nIn an example of a $100,000, 30-year mortgage with a rate of 6 percents the amortization schedule consists of 360 monthly payments.\nThe partial amortization schedule below shows with 2 decimal floats\nthe balance between principal and interest payments.\n\n--|num_payment|c          |princ      |int        |Balance    |\n--|-----------|-----------|-----------|-----------|-----------|\n--|1          |599.55     |99.55      |500.00     |99900.45   |\n--|...        |599.55     |...        |...        |...        |\n--|12         |599.55     |105.16     |494.39     |98,771.99  |\n--|...        |599.55     |...        |...        |...        |\n--|360        |599.55     |596.57     |2.98       |0.00       |\n\n# Task:\nGiven parameters \n```\nrate: annual rate as percent (don't forgent to divide by 100*12)\nbal: original balance (borrowed amount) \nterm: number of monthly payments\nnum_payment: rank of considered month (from 1 to term)\n```\nthe function `amort` will return a formatted string:\n\n`\"num_payment %d c %.0f princ %.0f int %.0f balance %.0f\" (with arguments num_payment, c, princ, int, balance`)\n\n# Examples:\n```\namort(6, 100000, 360, 1) ->\n\"num_payment 1 c 600 princ 100 int 500 balance 99900\"\n\namort(6, 100000, 360, 12) ->\n\"num_payment 12 c 600 princ 105 int 494 balance 98772\"\n\n```\n# Ref\n-/\n\n/- Helper function to check if string matches expected pattern -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Helper function to extract numeric values from amortization string output -/", "vc-preamble": "structure AmortValues where\n  num_payment : Int\n  payment : Int\n  principal : Int\n  interest : Int\n  balance : Float", "vc-helpers": "", "vc-definitions": "def amort (rate : Float) (bal : Int) (term : Int) (num_payments : Int) : String :=\nsorry\n\ndef extractValuesFromString (s : String) : AmortValues :=\nsorry\n\ndef matchesPattern (s : String) : Bool :=\nsorry", "vc-theorems": "theorem amort_output_format (rate : Float) (bal : Int) (term : Int) (num_payments : Int)\n  (h1 : rate ≥ 0.1) (h2 : rate ≤ 30.0)\n  (h3 : bal ≥ 1000) (h4 : bal ≤ 1000000)\n  (h5 : term ≥ 12) (h6 : term ≤ 360)\n  (h7 : num_payments ≥ 1) (h8 : num_payments ≤ term) :\n  let result := amort rate bal term num_payments\n  let values := extractValuesFromString result\n  (matchesPattern result) ∧\n  (values.num_payment = num_payments) ∧\n  (values.payment ≥ 0) ∧\n  (values.principal ≥ 0) ∧\n  (values.interest ≥ 0) ∧\n  (Int.natAbs (values.principal + values.interest - values.payment) ≤ 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003248", "vc-description": "/-\nWrite a function that will encrypt a given sentence into International Morse Code, both the input and out puts will be strings.\n\nCharacters should be separated by a single space.\nWords should be separated by a triple space.\n\nFor example, \"HELLO WORLD\" should return -> \".... . .-.. .-.. ---   .-- --- .-. .-.. -..\"\n\nTo find out more about Morse Code follow this link: https://en.wikipedia.org/wiki/Morse_code\n\nA preloaded object/dictionary/hash called CHAR_TO_MORSE will be provided to help convert characters to Morse Code.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validMorseChar (c : Char) : Bool :=\n  sorry\n\ndef encryption (s : String) : String :=\n  sorry", "vc-theorems": "theorem encryption_morse_chars\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ∀ c, c ∈ (encryption s).data → (c = '.' ∨ c = '-' ∨ c = ' ') :=\nsorry\n\ntheorem encryption_word_separation\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ((encryption s).splitOn \"   \").length = (s.splitOn \" \").length :=\nsorry\n\ntheorem encryption_letter_separation\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : ∀ word, word ∈ ((encryption s).splitOn \"   \") →\n    ∀ letter, letter ∈ (word.splitOn \" \") →\n    letter.length > 0 :=\nsorry\n\ntheorem encryption_case_insensitive\n  (s : String)\n  (h : ∀ c, c ∈ s.data → c.isUpper)\n  : encryption s = encryption s.toLower ∧\n    encryption s = encryption s.toUpper :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n-/\n#guard_msgs in\n#eval encryption \"HELLO WORLD\"\n\n/--\ninfo: '... --- ...'\n-/\n#guard_msgs in\n#eval encryption \"SOS\"\n\n/--\ninfo: '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-'\n-/\n#guard_msgs in\n#eval encryption \"THE QUICK BROWN FOX\""}
{"id": "fvapps_003253", "vc-description": "/-\nA [Word Square](https://en.wikipedia.org/wiki/Word_square) is a set of words written out in a square grid, such that the same words can be read both horizontally and vertically. The number of words, equal to the number of letters in each word, is known as the *order* of the square.\n\nFor example, this is an *order* `5` square found in the ruins of Herculaneum:\n\n![](https://i.gyazo.com/e226262e3ada421d4323369fb6cf66a6.jpg)\n\nGiven a string of various uppercase `letters`, check whether a *Word Square* can be formed from it. \n\nNote that you should use each letter from `letters` the exact number of times it occurs in the string. If a *Word Square* can be formed, return `true`, otherwise return `false`.\n\n__Example__\n\n  * For `letters = \"SATORAREPOTENETOPERAROTAS\"`, the output should be\n  `WordSquare(letters) = true`.\n    It is possible to form a *word square* in the example above.\n\n  * For `letters = \"AAAAEEEENOOOOPPRRRRSSTTTT\"`, (which is sorted form of `\"SATORAREPOTENETOPERAROTAS\"`), the output should also be\n  `WordSquare(letters) = true`.\n\n  * For `letters = \"NOTSQUARE\"`, the output should be\n  `WordSquare(letters) = false`.\n\n__Input/Output__\n\n* [input] string letters\n\n  A string of uppercase English letters.\n\n  Constraints: `3 ≤ letters.length ≤ 100`.\n\n* [output] boolean\n\n  `true`, if a Word Square can be formed;\n\n  `false`, if a Word Square cannot be formed.\n-/", "vc-preamble": "def countChar (c : Char) (s : List Char) : Nat :=\n  (s.filter (fun x => x = c)).length\n\ndef count_odd_occurrences (s : String) : Nat :=\n  let chars := s.toList\n  let counts := chars.map (fun c => countChar c chars)\n  (counts.filter (fun n => n % 2 = 1)).length", "vc-helpers": "", "vc-definitions": "def word_square (s : String) : Bool :=\nsorry", "vc-theorems": "theorem non_square_length_strings_are_false {s : String}\n  (h : ∃ n : Nat, n * n ≠ s.length) :\n  word_square s = false :=\nsorry\n\ntheorem all_same_letter_square_strings_are_valid (n : Nat) :\n  word_square (String.mk (List.replicate (n*n) 'A')) = true :=\nsorry\n\ntheorem alternating_letters_within_bounds (n : Nat) (h : n ≥ 2) :\n  let letters := List.replicate (n*n) 'A'\n  word_square (String.mk letters) = true :=\nsorry\n\ntheorem odd_count_characters_within_bounds (s : String) :\n  let n := s.length\n  if n*n ≠ s.length then\n    word_square s = false\n  else\n    word_square s = (count_odd_occurrences s ≤ n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"SATORAREPOTENETOPERAROTAS\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval word_square \"NOTSQUARE\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"CARDAREAREARDART\""}
{"id": "fvapps_003256", "vc-description": "/-\nComplete the function ```circleArea``` so that it will return the area of a circle with the given ```radius```. Round the returned number to two decimal places (except for Haskell). If the radius is not positive or not a number, return ```false```.\n\nExample:\n\n```python\ncircleArea(-1485.86)     #returns false\ncircleArea(0)            #returns false\ncircleArea(43.2673)      #returns 5881.25\ncircleArea(68)           #returns 14526.72\ncircleArea(\"number\")     #returns false\n```\n-/", "vc-preamble": "def pi : Float := 3.14159", "vc-helpers": "", "vc-definitions": "def circle_area (radius : Float) : Option Float :=\n  sorry", "vc-theorems": "theorem circle_area_invalid_inputs {x : Float} (h : x ≤ 0) :\n  circle_area x = none :=\nsorry\n\ntheorem circle_area_positive_inputs {x : Float} (h : x > 0) :\n  match circle_area x with\n  | some result =>\n    result > 0\n  | none => False :=\nsorry\n\ntheorem circle_area_zero :\n  circle_area 0 = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area 0\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area \"An integer\"\n\n/--\ninfo: 12.57\n-/\n#guard_msgs in\n#eval circle_area 2"}
{"id": "fvapps_003262", "vc-description": "/-\n# Introduction\n\nThere is a war and nobody knows - the alphabet war!  \nThere are two groups of hostile letters. The tension between left side letters and right side letters was too high and the war began. The letters called airstrike to help them in war - dashes and dots are spreaded everywhere on the battlefield.\n\n# Task\n\nWrite a function that accepts `fight` string consists of only small letters and `*` which means a bomb drop place. Return who wins the fight after bombs are exploded. When the left side wins return `Left side wins!`, when the right side wins return `Right side wins!`, in other case return `Let's fight again!`.\n\nThe left side letters and their power:\n```\n w - 4\n p - 3 \n b - 2\n s - 1\n```\nThe right side letters and their power:\n```\n m - 4\n q - 3 \n d - 2\n z - 1\n```\nThe other letters don't have power and are only victims.  \nThe `*` bombs kills the adjacent letters ( i.e. `aa*aa` => `a___a`, `**aa**` => `______` );\n\n# Example\n\n# Alphabet war Collection\n\nAlphavet war \n\nAlphabet war - airstrike - letters massacre\n\nAlphabet wars - reinforces massacre\n\nAlphabet wars - nuclear strike\n\nAlphabet war - Wo lo loooooo priests join the war\n-/", "vc-preamble": "def Result := String\nderiving Repr, BEq", "vc-helpers": "", "vc-definitions": "def alphabet_war (s : String) : Result :=\nsorry\n\ndef alphabet_war_valid_result (s : String) :\n  let result := alphabet_war s\n  result = \"Left side wins!\" ∨ result = \"Right side wins!\" ∨ result = \"Let's fight again!\" :=\nsorry\n\ndef only_left_letters_never_right (s : String) :\n  (∀ c ∈ s.data, c ∈ ['w', 'p', 'b', 's']) →\n  s.length > 0 →\n  alphabet_war s ≠ \"Right side wins!\" :=\nsorry\n\ndef only_right_letters_never_left (s : String) :\n  (∀ c ∈ s.data, c ∈ ['m', 'q', 'd', 'z']) →\n  s.length > 0 →\n  alphabet_war s ≠ \"Left side wins!\" :=\nsorry\n\ndef only_bombs_is_draw (s : String) :\n  (∀ c ∈ s.data, c = '*') →\n  s.length > 0 →\n  alphabet_war s = \"Let's fight again!\" :=\nsorry\n\ndef adjacent_bomb_nullifies (c : Char) :\n  c ∈ ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z'] →\n  alphabet_war (String.mk ['*', c]) = \"Let's fight again!\" ∧\n  alphabet_war (String.mk [c, '*']) = \"Let's fight again!\" :=\nsorry\n\ndef repeated_string_same_winner (s : String) :\n  (∀ c ∈ s.data, c ∈ ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']) →\n  s.length > 0 →\n  alphabet_war s = alphabet_war (s ++ s) :=\nsorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/--\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"z*dq*mw*pb*s\"\n\n/--\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"sz**z**zs\""}
{"id": "fvapps_003264", "vc-description": "/-\nIf we multiply the integer      `717 (n)` by `7 (k)`, the result will be equal to `5019`.\n\nConsider all the possible ways that this last number may be split as a string and calculate their corresponding sum obtained by adding the substrings as integers. When we add all of them up,... surprise, we got the original number `717`:\n\n```\nPartitions as string                Total Sums\n['5', '019']                        5 + 19 = 24\n['50', '19']                       50 + 19 = 69\n['501', '9']                      501 + 9 = 510\n['5', '0', '19']                5 + 0 + 19 = 24\n['5', '01', '9']                 5 + 1 + 9 = 15\n['50', '1', '9']                50 + 1 + 9 = 60\n['5', '0', '1', '9']         5 + 0 + 1 + 9 = 15\n                            ____________________\n                              Big Total:    717\n                            ____________________\n```\nIn fact, `717` is one of the few integers that has such property with a factor `k = 7`.\n\nChanging the factor `k`, for example to `k = 3`, we may see that the integer `40104` fulfills this property.\n\nGiven an integer `start_value` and an integer `k`, output the smallest integer `n`, but higher than `start_value`, that fulfills the above explained properties.\n\nIf by chance, `start_value`, fulfills the property, do not return `start_value` as a result, only the next integer. Perhaps you may find this assertion redundant if you understood well the requirement of the kata: \"output the smallest integer `n`, but higher than `start_value`\"\n\nThe values for `k` in the input may be one of these: `3, 4, 5, 7`\n\n### Features of the random tests\n\nIf you want to understand the style and features of the random tests, see the *Notes* at the end of these instructions.\n\nThe random tests are classified in three parts.\n\n- Random tests each with one of the possible values of `k` and a random `start_value` in the interval `[100, 1300]`\n- Random tests each with a `start_value` in a larger interval for each value of `k`, as follows:\n - for `k = 3`, a random `start value` in the range `[30000, 40000]`\n - for `k = 4`, a random `start value` in the range `[2000, 10000]`\n - for `k = 5`, a random `start value` in the range `[10000, 20000]`\n - for `k = 7`, a random `start value` in the range `[100000, 130000]`\n- More challenging tests, each with a random `start_value` in the interval `[100000, 110000]`.\n\nSee the examples tests.\n\nEnjoy it.\n\n# Notes:\n\n- As these sequences are finite, in other words, they have a maximum term for each value of k, the tests are prepared in such way that the `start_value`  will always be less than this maximum term. So you may be confident that your code will always find an integer.\n\n- The values of `k` that generate sequences of integers, for the constrains of this kata are: 2, 3, 4, 5, and 7. The case `k = 2` was not included because it generates only two integers.\n\n- The sequences have like \"mountains\" of abundance of integers but also have very wide ranges like \"valleys\" of scarceness. Potential solutions, even the fastest ones, may time out searching the next integer due to an input in one of these valleys. So it was intended to avoid these ranges.\n\nJavascript and Ruby versions will be released soon.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_higher (start_value k : Nat) : Nat :=\nsorry\n\ndef sum_part (n : Nat) : Nat :=\nsorry\n\ndef qualified : Nat → List Nat :=\nsorry", "vc-theorems": "theorem sum_part_properties {n : Nat} (hn : n > 0 ∧ n ≤ 1000) :\n  sum_part n ≥ n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003267", "vc-description": "/-\nIt's the academic year's end, fateful moment of your school report.\nThe averages must be calculated. All the students come to you and entreat you to calculate their average for them.\nEasy ! You just need to write a script.\n\nReturn the average of the given array rounded **down** to its nearest integer.\n\nThe array will never be empty.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_average (marks: List Nat) : Nat :=\nsorry\n\ndef list_maximum (l: List Nat) : Nat :=\nsorry\n\ndef list_minimum (l: List Nat) : Nat :=\nsorry\n\ndef list_sum (l: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem average_in_bounds {marks: List Nat} (h: marks ≠ []) :\n  let avg := get_average marks\n  avg ≤ list_maximum marks ∧ avg ≥ list_minimum marks :=\nsorry\n\ntheorem average_equals_div_sum {marks: List Nat} (h: marks ≠ []) :\n  get_average marks = list_sum marks / marks.length :=\nsorry\n\ntheorem empty_list_error :\n  get_average [] = get_average [] → False :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval get_average [2, 2, 2, 2]\n\n/--\ninfo: 25\n-/\n#guard_msgs in\n#eval get_average [1, 5, 87, 45, 8, 8]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval get_average [2, 5, 13, 20, 16, 16, 10]"}
{"id": "fvapps_003268", "vc-description": "/-\nIn genetics 2 differents DNAs sequences can code for the same protein. \n\nThis is due to the redundancy of the genetic code, in fact 2 different tri-nucleotide can code for the same amino-acid.\nFor example the tri-nucleotide 'TTT' and the tri-nucleotide 'TTC' both code for the amino-acid 'F'. For more information you can take a look [here](https://en.wikipedia.org/wiki/DNA_codon_table).\n\nYour goal in this kata is to define if two differents DNAs sequences code for exactly the same protein. Your function take the 2 sequences you should compare.\nFor some kind of simplicity here the sequences will respect the following rules:\n\n- It is a full protein sequence beginning with a Start codon and finishing by an Stop codon\n- It will only contain valid tri-nucleotide. \n\nThe translation hash is available for you under a translation hash `$codons` [Ruby] or `codons` [Python and JavaScript].\n\nTo better understand this kata you can take a look at this [one](https://www.codewars.com/kata/5708ef48fe2d018413000776), it can help you to start.\n-/", "vc-preamble": "def repeat_str (s : String) (n : Nat) : String :=\nmatch n with\n| 0 => \"\"\n| n+1 => s ++ repeat_str s n", "vc-helpers": "", "vc-definitions": "def code_for_same_protein (seq1 : String) (seq2 : String) : Bool :=\nsorry", "vc-theorems": "theorem identical_sequences_match\n  (seq : String) :\n  code_for_same_protein seq seq = true :=\nsorry\n\ntheorem different_length_no_match\n  (n : Nat) :\n  code_for_same_protein (repeat_str \"ATG\" n) (repeat_str \"ATG\" (n + 1)) = false :=\nsorry\n\ntheorem different_length_sequences_no_match\n  (seq1 seq2 : String) :\n  seq1.length ≠ seq2.length →\n  code_for_same_protein seq1 seq2 = false :=\nsorry\n\ntheorem code_for_same_protein_reflexive\n  (seq : String) :\n  code_for_same_protein seq seq = true :=\nsorry\n\ntheorem code_for_same_protein_symmetric\n  (seq1 seq2 : String) :\n  code_for_same_protein seq1 seq2 = true →\n  code_for_same_protein seq2 seq1 = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTCGTCAATTTAA\" \"ATGTCGTCAATTTAA\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGTTCTAA\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGATATAA\""}
{"id": "fvapps_003270", "vc-description": "/-\nGiven the sum and gcd of two numbers, return those two numbers in ascending order. If the numbers do not exist, return `-1`, (or `NULL` in C, `tuple (-1,-1)` in C#, `pair (-1,-1)` in C++,`None` in Rust, `array {-1,-1} ` in Java and Golang).\n\n```\nFor example: \nGiven sum = 12 and gcd = 4...\n\nsolve(12,4) = [4,8]. The two numbers 4 and 8 sum to 12 and have a gcd of 4.\n\nsolve(12,5) = -1. No two numbers exist that sum to 12 and have gcd of 5.\n\nsolve(10,2) = [2,8]. Note that [4,6] is also a possibility but we pick the one with the lower first element: 2 < 4, so we take [2,8].\n```\n\nMore examples in test cases. \n\nGood luck!\n-/\n\n-- For any x,y > 0:\n-- If solve returns None, then sum not divisible by gcd\n-- If solve returns Some (a,b), then:\n--   a + b = sum, gcd(a,b) = gcd, a ≤ b\n\n-- For any x > 0:\n-- solve(2x, x) = (x,x)", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (sum gcd : Nat) : Option (Nat × Nat) :=\n  sorry\n\ndef gcd (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_properties (x y : Nat) (h1: x > 0) (h2: y > 0) :\n  let s := x + y\n  let g := gcd x y\n  match solve s g with\n  | none => s % g ≠ 0\n  | some (a, b) => a + b = s ∧ gcd a b = g ∧ a ≤ b\n  :=\nsorry\n\ntheorem solve_same_number (x : Nat) (h: x > 0) :\n  solve (2*x) x = some (x, x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [3, 3]\n-/\n#guard_msgs in\n#eval solve 6 3\n\n/--\ninfo: [2, 6]\n-/\n#guard_msgs in\n#eval solve 8 2\n\n/--\ninfo: [4, 8]\n-/\n#guard_msgs in\n#eval solve 12 4"}
{"id": "fvapps_003273", "vc-description": "/-\nDue to another of his misbehaved, \nthe primary school's teacher of the young Gauß,  Herr J.G. Büttner, to keep the bored and unruly young schoolboy Karl Friedrich Gauss busy for a good long time, while he teaching arithmetic to his mates,\nassigned him the problem of adding up all the whole numbers from 1 through a given number `n`.\n\nYour task is to help the young Carl Friedrich to solve this problem as quickly as you can; so, he can astonish his teacher and rescue his recreation interval.\n\nHere's, an example:\n\n```\nf(n=100) // returns 5050 \n```\n\nIt's your duty to verify that n is a valid positive integer number. If not, please, return false (None for Python, null for C#).\n\n> **Note:** the goal of this kata is to invite you to think about some 'basic' mathematic formula and how you can do performance optimization on your code. \n\n> Advanced - experienced users should try to solve it in one line, without loops, or optimizing the code as much as they can.\n\n-----\n\n**Credits:** this kata was inspired by the farzher's kata 'Sum of large ints' . In fact, it can be seen as a sort of prep kata for that one.\n-/\n\n/- For positive integers, f(n) equals the sum of numbers from 1 to n -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For non-positive integers, f returns none -/\n\n/- For non-integer numeric inputs, f returns none -/\n\n/- For any non-numeric type α, f returns none -/\n\n/- f handles large inputs without overflow -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f (x : α) : Option Nat :=\nsorry", "vc-theorems": "theorem positive_integers_sum {n : Nat} (h : n > 0) :\n  f n = some (n * (n + 1) / 2) :=\nsorry\n\ntheorem non_positive_returns_none {n : Int} (h : n ≤ 0) :\n  f n = none :=\nsorry\n\ntheorem non_integer_returns_none (x : Float) :\n  f x = none :=\nsorry\n\ntheorem non_numeric_returns_none (α : Type) (x : α) :\n  f x = none :=\nsorry\n\ntheorem handles_large_inputs (n : Nat) :\n  f n ≠ none → ∃ m : Nat, f n = some m ∧ m > 0 :=\nsorry", "vc-postamble": "/--\ninfo: 5050\n-/\n#guard_msgs in\n#eval f 100\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval f 0\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval f 3.14"}
{"id": "fvapps_003275", "vc-description": "/-\nThis is a spin off of my first [kata](http://www.codewars.com/kata/56bc28ad5bdaeb48760009b0). You are given a list of character sequences as a comma separated string. Write a function which returns another string containing all the character sequences except the first and the last ones, separated by spaces. If the input string is empty, or the removal of the first and last items would cause the string to be empty, return a null value.\n-/\n\n/- Helper functions -/\n\n/- Main theorems that match property tests -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\n  sorry\n\ndef String.strip (s : String) : String :=\n  sorry\n\ndef array (s : String) : Option String :=\n  sorry\n\ndef joinWithSpaces (xs : List String) : String :=\n  sorry", "vc-theorems": "theorem array_none_when_not_enough_commas (s : String) :\n  s.count ',' < 2 →\n  array s = none :=\nsorry\n\ntheorem array_processes_middle_elements (s : String) :\n  s.count ',' ≥ 2 →\n  array s = some (joinWithSpaces (List.map String.strip (List.drop 1 (List.take (List.length (String.splitOn \",\" s) - 1) (String.splitOn \",\" s))))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval array \"\"\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1\"\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1,2\"\n\n/--\ninfo: '2'\n-/\n#guard_msgs in\n#eval array \"1,2,3\"\n\n/--\ninfo: '2 3'\n-/\n#guard_msgs in\n#eval array \"1,2,3,4\""}
{"id": "fvapps_003277", "vc-description": "/-\nThe snail crawls up the column. During the day it crawls up some distance. During the night she sleeps, so she slides down for some distance (less than crawls up during the day).\n\nYour function takes three arguments:\n1. The height of the column (meters)\n2. The distance that the snail crawls during the day (meters)\n3. The distance that the snail slides down during the night (meters)\n\nCalculate number of day when the snail will reach the top of the column.\n-/\n\n-- Helper function to simulate ceiling division", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def snail (column : Int) (day : Int) (night : Int) : Int :=\n  sorry\n\ndef ceilDiv (a b : Int) : Int :=\n  sorry", "vc-theorems": "theorem snail_result_positive {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night ≥ 0) :\n  snail column day night ≥ 1 :=\nsorry\n\ntheorem snail_reaches_top {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night ≥ 0) :\n  let result := snail column day night\n  (result * day) - ((result-1) * night) ≥ column :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval snail 3 2 1\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval snail 10 3 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval snail 5 10 3"}
{"id": "fvapps_003283", "vc-description": "/-\nIn this Kata, you will be given two integers `n` and `k` and your task is to remove `k-digits` from `n` and return the lowest number possible, without changing the order of the digits in `n`. Return the result as a string.\n\nLet's take an example of `solve(123056,4)`. We need to remove `4` digits from `123056` and return the lowest possible number. The best digits to remove are `(1,2,3,6)` so that the remaining digits are `'05'`. Therefore, `solve(123056,4) = '05'`. \n\nNote also that the order of the numbers in `n` does not change: `solve(1284569,2) = '12456',` because we have removed `8` and `9`. \n\nMore examples in the test cases.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isSubsequence (smaller larger : String) : Bool :=\n  sorry\n\ndef solve (n : Nat) (k : Nat) : String :=\n  sorry", "vc-theorems": "theorem solve_properties {n k : Nat} (h : k < (ToString.toString n).length) :\n  let result := solve n k\n  (result.length = (ToString.toString n).length - k) ∧\n  (isSubsequence result (ToString.toString n) = true) ∧\n  (result.toNat! ≤ n) :=\nsorry\n\ntheorem remove_zero_digits (n : Nat) :\n  solve n 0 = ToString.toString n :=\nsorry\n\ntheorem result_is_minimal {n k : Nat} (h1 : n ≥ 10) (h2 : k ≥ 1) (h3 : k < (ToString.toString n).length) :\n  let result := solve n k\n  ∀ (s : String),\n    isSubsequence s (ToString.toString n) = true →\n    s.length = (ToString.toString n).length - k →\n    result.toNat! ≤ s.toNat! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '05'\n-/\n#guard_msgs in\n#eval solve 123056 4\n\n/--\ninfo: '12456'\n-/\n#guard_msgs in\n#eval solve 1284569 2\n\n/--\ninfo: '12056'\n-/\n#guard_msgs in\n#eval solve 123056 1"}
{"id": "fvapps_003284", "vc-description": "/-\nGiven a string ``string`` that contains only letters, you have to find out the number of **unique** strings (including ``string`` itself) that can be produced by re-arranging the letters of the ``string``.  Strings are case **insensitive**.\n\nHINT: Generating all the unique strings and calling length on that isn't a great solution for this problem. It can be done a lot faster...\n\n## Examples\n\n```python\nuniqcount(\"AB\") = 2      # \"AB\", \"BA\"\nuniqcount(\"ABC\") = 6     # \"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\"\nuniqcount(\"ABA\") = 3     # \"AAB\", \"ABA\", \"BAA\"\nuniqcount(\"ABBb\") = 4    # \"ABBB\", \"BABB\", \"BBAB\", \"BBBA\"\nuniqcount(\"AbcD\") = 24   # \"ABCD\", etc.\n```\n-/", "vc-preamble": "def factorial : Nat → Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def List.prod : List Nat → Nat\n  | [] => 1\n  | x :: xs => x * prod xs\n\ndef isAscii (s : String) : Bool :=\n  sorry\n\ndef uniq_count (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem uniq_count_positive (s : String) :\n  uniq_count s > 0 :=\nsorry\n\ntheorem uniq_count_empty :\n  uniq_count \"\" = 1 :=\nsorry\n\ntheorem uniq_count_factorial_bound (s : String) :\n  uniq_count s ≤ factorial s.length :=\nsorry\n\ntheorem uniq_count_unique_chars {s : String} (h₁ : s ≠ \"\")\n  (h₂ : (s.toLower.data.eraseDups).length = s.length) :\n  uniq_count s = factorial s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval uniq_count \"ABC\"\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval uniq_count \"ABA\"\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval uniq_count \"AbcD\""}
{"id": "fvapps_003285", "vc-description": "/-\n# Two samurai generals are discussing dinner plans after a battle, but they can't seem to agree.\n\nThe discussion gets heated and you are cannot risk favoring either of them as this might damage your political standing with either of the two clans the samurai generals belong to. Thus, the only thing left to do is find what the common ground of what they are saying is.\n\nCompare the proposals with the following function: \n```python\ndef common_ground(s1,s2)\n```\n\nThe parameters ```s1``` and ```s2``` are the strings representing what each of the generals said. You should output a string containing the words in ```s1``` that also occur in ```s2```.\n\nEach word in the resulting string shall occur once, and the order of the words need to follow the order of the first occurence of each word in ```s2```.\n\nIf they are saying nothing in common, kill both samurai and blame a ninja. (output \"death\")\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def common_ground (s1 s2 : String) : String :=\n  sorry\n\ndef split (s : String) : List String :=\n  sorry", "vc-theorems": "theorem common_ground_subset (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result ≠ \"death\" →\n  (∀ w, w ∈ split result →\n    w ∈ split s1 ∧ w ∈ split s2) :=\nsorry\n\ntheorem common_ground_order (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result ≠ \"death\" →\n  ∀ i j, i < j → i < (split result).length → j < (split result).length →\n    let s2_words := split s2\n    let result_words := split result\n    s2_words.findIdx (· = result_words[i]!) <\n    s2_words.findIdx (· = result_words[j]!) :=\nsorry\n\ntheorem common_ground_no_overlap (s1 s2 : String) :\n  (∀ w1 w2, w1 ∈ split s1 → w2 ∈ split s2 → w1 ≠ w2) →\n  common_ground s1 s2 = \"death\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'eat chicken'\n-/\n#guard_msgs in\n#eval common_ground \"eat chicken\" \"eat chicken and rice\"\n\n/--\ninfo: 'drink a coke'\n-/\n#guard_msgs in\n#eval common_ground \"eat a burger and drink a coke\" \"drink a coke\"\n\n/--\ninfo: 'death'\n-/\n#guard_msgs in\n#eval common_ground \"i like turtles\" \"what are you talking about\""}
{"id": "fvapps_003292", "vc-description": "/-\nComplete the  function `scramble(str1, str2)` that returns `true` if a portion of ```str1``` characters can be rearranged to match ```str2```, otherwise returns ```false```.\n\n**Notes:**\n* Only lower case letters will be used (a-z). No punctuation or digits will be included.\n* Performance needs to be considered\n\n## Examples\n\n```python\nscramble('rkqodlw', 'world') ==> True\nscramble('cedewaraaossoqqyt', 'codewars') ==> True\nscramble('katas', 'steak') ==> False\n```\n-/\n\n-- Helper function to count char occurrences in string\n\n-- If scramble returns true, first string is at least as long as second\n\n-- A string can always be scrambled to form itself\n\n-- If scramble is true, all chars in s2 appear at least as many times in s1\n\n-- Any non-empty string can be scrambled to form empty string\n\n-- Empty string cannot form non-empty string\n\n-- Strings with disjoint character sets cannot be scrambled", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def scramble (s1 s2 : String) : Bool :=\n  sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem scramble_length_property (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 → scramble s1 s2 = true → s1.length ≥ s2.length :=\nsorry\n\ntheorem scramble_identical_strings (s : String) :\n  s.length > 0 → scramble s s = true :=\nsorry\n\ntheorem scramble_subset_property (s1 s2 : String) (c : Char) :\n  s1.length > 0 → s2.length > 0 → scramble s1 s2 = true →\n  (countChar s2 c) ≤ (countChar s1 c) :=\nsorry\n\ntheorem scramble_empty_second_string (s : String) :\n  s.length > 0 → scramble s \"\" = true :=\nsorry\n\ntheorem scramble_empty_first_string (c : Char) :\n  scramble \"\" (String.singleton c) = false :=\nsorry\n\ntheorem scramble_disjoint_alphabets (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 →\n  (∀ c, s1.contains c → ¬s2.contains c) →\n  scramble s1 s2 = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"rkqodlw\" \"world\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"cedewaraaossoqqyt\" \"codewars\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval scramble \"katas\" \"steak\""}
{"id": "fvapps_003293", "vc-description": "/-\nComplete the function that counts the number of unique consonants in a string (made up of printable ascii characters).\n\nConsonants are letters used in English other than `\"a\", \"e\", \"i\", \"o\", \"u\"`. We will count `\"y\"` as a consonant.\n\nRemember, your function needs to return the number of unique consonants - disregarding duplicates. For example, if the string passed into the function reads `\"add\"`, the function should return `1` rather than `2`, since `\"d\"` is a duplicate.\n\nSimilarly, the function should also disregard duplicate consonants of differing cases. For example, `\"Dad\"` passed into the function should return `1` as `\"d\"` and `\"D\"` are duplicates.\n\n## Examples\n\n```\n\"add\" ==> 1\n\"Dad\" ==> 1\n\"aeiou\" ==> 0\n\"sillystring\" ==> 7\n\"abcdefghijklmnopqrstuvwxyz\" ==> 21\n\"Count my unique consonants!!\" ==> 7\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_consonants (s : List Char) : Nat :=\n  sorry\n\ndef isConsonant (c : Char) : Bool :=\n  sorry\n\ndef isVowel (c : Char) : Bool :=\n  sorry\n\ndef toLower (c : Char) : Char :=\n  sorry\n\ndef toCharList (s : String) : List Char :=\n  sorry", "vc-theorems": "theorem count_consonants_bounds {s : List Char} :\n  0 ≤ count_consonants s ∧ count_consonants s ≤ 21 :=\nsorry\n\ntheorem count_consonants_case_insensitive {s : List Char} :\n  count_consonants s = count_consonants (List.map toLower s) :=\nsorry\n\ntheorem count_consonants_letters_only {s s' : List Char}\n  (h : s' = List.filter Char.isAlpha s) :\n  count_consonants s = count_consonants s' :=\nsorry\n\ntheorem count_consonants_vowels_only {s : List Char}\n  (h : ∀ c, c ∈ s → isVowel c) :\n  count_consonants s = 0 :=\nsorry\n\ntheorem count_consonants_consonants_only {s : List Char} {n : Nat}\n  (h1 : ∀ c, c ∈ s → isConsonant c)\n  (h2 : n = (List.map toLower s).eraseDups.length) :\n  count_consonants s = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval count_consonants \"sillystring\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_consonants \"aeiou\"\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval count_consonants \"abcdefghijklmnopqrstuvwxyz\""}
{"id": "fvapps_003294", "vc-description": "/-\nThe goal is to write a pair of functions the first of which will take a string of binary along with a specification of bits, which will return a numeric, signed complement in two's complement format. The second will do the reverse. It will take in an integer along with a number of bits, and return a binary string. \n\nhttps://en.wikipedia.org/wiki/Two's_complement\n\nThus, to_twos_complement should take the parameters binary = \"0000 0001\", bits = 8 should return 1. And, binary = \"11111111\", bits = 8 should return -1 . While, from_twos_complement should return \"00000000\" from the parameters n = 0, bits = 8 . And, \"11111111\" from n = -1, bits = 8. \n\nYou should account for some edge cases.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_twos_complement (binary : String) (bits : Nat) : Int :=\nsorry\n\ndef from_twos_complement (n : Int) (bits : Nat) : String :=\nsorry\n\ndef removeWhitespace (s : String) : String :=\nsorry", "vc-theorems": "theorem twos_complement_roundtrip (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : n ≥ -(2^(bits-1))) (h4 : n ≤ 2^(bits-1) - 1) :\n  to_twos_complement (from_twos_complement n bits) bits = n :=\nsorry\n\ntheorem binary_roundtrip (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : String.length binary = bits)\n  (h4 : ∀ c ∈ binary.data, c = '0' ∨ c = '1') :\n  from_twos_complement (to_twos_complement binary bits) bits = binary :=\nsorry\n\ntheorem bit_length (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64) :\n  String.length (from_twos_complement n bits) = bits ∧\n  (∀ c ∈ (from_twos_complement n bits).data, c = '0' ∨ c = '1') :=\nsorry\n\ntheorem whitespace_handling (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits ≤ 64)\n  (h3 : String.length (removeWhitespace binary) = bits)\n  (h4 : ∀ c ∈ (removeWhitespace binary).data, c = '0' ∨ c = '1') :\n  to_twos_complement binary bits = to_twos_complement (removeWhitespace binary) bits :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval to_twos_complement \"00000001\" 8\n\n/--\ninfo: '00000001'\n-/\n#guard_msgs in\n#eval from_twos_complement 1 8\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval to_twos_complement \"11111111\" 8\n\n/--\ninfo: '11111111'\n-/\n#guard_msgs in\n#eval from_twos_complement -1 8\n\n/--\ninfo: -1440552402\n-/\n#guard_msgs in\n#eval to_twos_complement \"1010 1010 0010 0010 1110 1010 0010 1110\" 32\n\n/--\ninfo: '10101010001000101110101000101110'\n-/\n#guard_msgs in\n#eval from_twos_complement -1440552402 32"}
{"id": "fvapps_003300", "vc-description": "/-\n# Task\n The number is considered to be `unlucky` if it does not have digits `4` and `7` and is divisible by `13`. Please count all unlucky numbers not greater than `n`.\n\n# Example\n\n For `n = 20`, the result should be `2` (numbers `0 and 13`).\n\n For `n = 100`, the result should be `7` (numbers `0, 13, 26, 39, 52, 65, and 91`)\n\n# Input/Output\n\n - `[input]` integer `n`\n\n `1 ≤ n ≤ 10^8(10^6 in Python)`\n\n - `[output]` an integer\n-/", "vc-preamble": "def containsChar (s : String) (c : Char) : Bool :=\n  s.any (fun x => x == c)\n\ndef isDivisibleBy13AndNoUnluckyDigits (i : Nat) : Bool :=\n  i % 13 == 0 &&\n  !containsChar (toString i) '4' &&\n  !containsChar (toString i) '7'", "vc-helpers": "", "vc-definitions": "def unlucky_number (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem unlucky_number_non_negative (n : Nat) :\n  unlucky_number n ≥ 0 :=\nsorry\n\ntheorem unlucky_number_zero :\n  unlucky_number 0 = 1 :=\nsorry\n\ntheorem unlucky_number_twelve :\n  unlucky_number 12 = 1 :=\nsorry\n\ntheorem unlucky_number_thirteen :\n  unlucky_number 13 = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval unlucky_number 20\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval unlucky_number 100\n\n/--\ninfo: 40\n-/\n#guard_msgs in\n#eval unlucky_number 1000"}
{"id": "fvapps_003305", "vc-description": "/-\n# Definition\n\n**_Extra perfect number_** *is the number that* **_first_** and **_last_** *bits* are **_set bits_**.\n\n____\n\n# Task\n\n**_Given_**  *a positive integer*   `N` ,  **_Return_** the **_extra perfect numbers_** *in range from*  `1`  to  `N` .\n____\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_Number_** *passed is always*  **_Positive_** .\n\n* **_Returned array/list_** should *contain the extra perfect numbers in ascending order*  **from lowest to highest**\n___\n\n# Input >> Output Examples\n\n```\nextraPerfect(3)  ==>  return {1,3}\n```\n## **_Explanation_**:\n\n# (1)10 =(1)2\n\n**First** and **last** bits as **_set bits_**.\n\n# (3)10 = (11)2\n\n**First** and **last** bits as **_set bits_**.\n___\n\n```\nextraPerfect(7)  ==>  return {1,3,5,7}\n```\n\n## **_Explanation_**:\n\n# (5)10 = (101)2\n\n**First** and **last** bits as **_set bits_**.\n\n# (7)10 = (111)2\n\n**First** and **last** bits as **_set bits_**.\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def isSorted (xs : List Nat) : Prop :=\n  ∀ i j, i < j → j < List.length xs → xs[i]! < xs[j]!", "vc-helpers": "", "vc-definitions": "def extra_perfect (n : Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem extra_perfect_only_odd {n : Nat} :\n  ∀ x, x ∈ extra_perfect n → x % 2 = 1 :=\nsorry\n\ntheorem extra_perfect_bounded {n : Nat} :\n  ∀ x, x ∈ extra_perfect n → x ≤ n :=\nsorry\n\ntheorem extra_perfect_length {n : Nat} :\n  List.length (extra_perfect n) = (n + 1) / 2 :=\nsorry\n\ntheorem extra_perfect_binary_ones {n : Nat} :\n  ∀ x, x ∈ extra_perfect n →\n    ((x &&& 1) = 1) ∧\n    ((x &&& (1 <<< (Nat.log2 x))) = (1 <<< (Nat.log2 x))) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003319", "vc-description": "/-\n## Overview\nResistors are electrical components marked with colorful stripes/bands to indicate both their resistance value in ohms and how tight a tolerance that value has. While you could always get a tattoo like Jimmie Rodgers to help you remember the resistor color codes, in the meantime, you can write a function that will take a string containing a resistor's band colors and return a string identifying the resistor's ohms and tolerance values.\n\n## The resistor color codes\nYou can see this Wikipedia page for a colorful chart, but the basic resistor color codes are:\n\nblack: 0, brown: 1, red: 2, orange: 3, yellow: 4, green: 5, blue: 6, violet: 7, gray: 8, white: 9\n\nEach resistor will have at least three bands, with the first and second bands indicating the first two digits of the ohms value, and the third indicating the power of ten to multiply them by, for example a resistor with the three bands \"yellow violet black\" would be 47 * 10^0 ohms, or 47 ohms.\n\nMost resistors will also have a fourth band that is either gold or silver, with gold indicating plus or minus 5% tolerance, and silver indicating 10% tolerance. Resistors that do not have a fourth band are rated at 20% tolerance. (There are also more specialized resistors which can have more bands and additional meanings for some of the colors, but this kata will not cover them.)\n\n## Your mission\nThe way the ohms value needs to be formatted in the string you return depends on the magnitude of the value:\n\n* For resistors less than 1000 ohms, return a string containing the number of ohms, a space, the word \"ohms\" followed by a comma and a space, the tolerance value (5, 10, or 20), and a percent sign. For example,  for the \"yellow violet black\" resistor mentioned above, you would return `\"47 ohms, 20%\"`. \n\n* For resistors greater than or equal to 1000 ohms, but less than 1000000 ohms, you will use the same format as above, except that the ohms value will be divided by 1000 and have a lower-case \"k\" after it. For example, for a resistor with bands of \"yellow violet red gold\", you would return `\"4.7k ohms, 5%\"`\n\n* For resistors of 1000000 ohms or greater, you will divide the ohms value by 1000000 and have an upper-case \"M\" after it. For example, for a resistor with bands of \"brown black green silver\", you would return `\"1M ohms, 10%\"`\n\nTest case resistor values will all be between 10 ohms and 990M ohms.\n\n## More examples, featuring some common resistor values\n```\n\"brown black black\"                \"10 ohms, 20%\"\n\"brown black brown gold\"          \"100 ohms, 5%\"\n\"red red brown\"                   \"220 ohms, 20%\"\n\"orange orange brown gold\"        \"330 ohms, 5%\"\n\"yellow violet brown silver\"      \"470 ohms, 10%\"\n\"blue gray brown\"                 \"680 ohms, 20%\"\n\"brown black red silver\"           \"1k ohms, 10%\"\n\"brown black orange\"              \"10k ohms, 20%\"\n\"red red orange silver\"           \"22k ohms, 10%\"\n\"yellow violet orange gold\"       \"47k ohms, 5%\"\n\"brown black yellow gold\"        \"100k ohms, 5%\"\n\"orange orange yellow gold\"      \"330k ohms, 5%\"\n\"red black green gold\"             \"2M ohms, 5%\"\n```\nHave fun! And if you enjoy this kata, check out the sequel: Resistor Color Codes, Part 2\n-/", "vc-preamble": "def COLOR_MAP : List (String × Nat) := [\n  (\"black\", 0), (\"brown\", 1), (\"red\", 2), (\"orange\", 3), (\"yellow\", 4),\n  (\"green\", 5), (\"blue\", 6), (\"violet\", 7), (\"gray\", 8), (\"white\", 9)\n]", "vc-helpers": "", "vc-definitions": "def decode_resistor_colors (bands : String) : String :=\nsorry\n\ndef String.toFloat (s : String) : Float :=\nsorry\n\ndef String.containsString (s : String) (substr : String) : Bool :=\nsorry", "vc-theorems": "theorem resistor_color_format\n  (first_band second_band multiplier : String)\n  (tolerance : Option String)\n  (h1 : first_band ∈ (COLOR_MAP.map (·.1)))\n  (h2 : second_band ∈ (COLOR_MAP.map (·.1)))\n  (h3 : multiplier ∈ (COLOR_MAP.map (·.1)))\n  (h4 : tolerance.getD \"\" ∈ [\"\", \"gold\", \"silver\"]) :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier} {tolerance.getD \"\"}\".trim)\n  (result.containsString \" ohms, \") ∧\n  (result.endsWith \"%\") ∧\n  (result.containsString \"\" ∨ result.containsString \"k\" ∨ result.containsString \"M\") :=\nsorry\n\ntheorem base_value_calculation\n  (first_band second_band multiplier : String)\n  (h1 : first_band ∈ [\"black\", \"brown\"])\n  (h2 : second_band ∈ [\"black\", \"brown\"])\n  (h3 : multiplier = \"black\") :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier}\")\n  let value := String.toFloat ((result.splitOn \" \").head!)\n  let expected :=\n    match COLOR_MAP.find? (·.1 = first_band), COLOR_MAP.find? (·.1 = second_band) with\n    | some (_, n1), some (_, n2) => Float.ofNat (n1 * 10 + n2)\n    | _, _ => 0.0\n  value = expected :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '47 ohms, 20%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet black\"\n\n/--\ninfo: '4.7k ohms, 5%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet red gold\"\n\n/--\ninfo: '1M ohms, 10%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"brown black green silver\""}
{"id": "fvapps_003321", "vc-description": "/-\nWrite function RemoveExclamationMarks which removes all exclamation marks from a given string.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countChars (s : String) (c : Char) : Nat :=\n  sorry\n\ndef remove_exclamation_marks (s : String) : String :=\n  sorry", "vc-theorems": "theorem no_exclamation_in_result (s : String) :\n  ¬(remove_exclamation_marks s).contains '!' := by\nsorry\n\ntheorem length_after_removal (s : String) :\n  (remove_exclamation_marks s).length = s.length - (countChars s '!') := by\nsorry\n\ntheorem result_equals_remove_exclamation (s : String) :\n  (remove_exclamation_marks s).replace \"!\" \"\" = remove_exclamation_marks s := by\nsorry\n\ntheorem unchanged_without_exclamation (s : String) (h : ¬s.contains '!') :\n  remove_exclamation_marks s = s := by\nsorry\n\ntheorem concatenation_property (s₁ s₂ : String) :\n  remove_exclamation_marks s₁ ++ remove_exclamation_marks s₂ =\n  remove_exclamation_marks (s₁ ++ s₂) := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hello World!\"\n\n/--\ninfo: 'Hi Hello'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hi! Hello!\"\n\n/--\ninfo: 'Oh, no'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Oh, no!!!\""}
{"id": "fvapps_003329", "vc-description": "/-\n## Task\n\nGiven a positive integer `n`, calculate the following sum: \n\n```\nn + n/2 + n/4 + n/8 + ...\n``` \n\nAll elements of the sum are the results of integer division.\n\n## Example\n\n```\n25  =>  25 + 12 + 6 + 3 + 1 = 47\n```\n-/\n\n/- For any positive n, halving_sum(n) is at least n -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any positive n, halving_sum(n) is less than 2*n -/\n\n/- For powers of 2, halving_sum(n) equals 2*n - 1 -/\n\n/- Base cases for n=1 and n=2 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def halving_sum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem halving_sum_lower_bound (n : Nat) (h : n > 0) :\n  halving_sum n ≥ n :=\nsorry\n\ntheorem halving_sum_upper_bound (n : Nat) (h : n > 0) :\n  halving_sum n < 2*n :=\nsorry\n\ntheorem halving_sum_power_of_two (n : Nat) (h : n > 0)\n  (h_pow : ∃ k, n = 2^k) :\n  halving_sum n = 2*n - 1 :=\nsorry\n\ntheorem halving_sum_base_cases :\n  (halving_sum 1 = 1) ∧ (halving_sum 2 = 3) :=\nsorry", "vc-postamble": "/--\ninfo: 47\n-/\n#guard_msgs in\n#eval halving_sum 25\n\n/--\ninfo: 247\n-/\n#guard_msgs in\n#eval halving_sum 127\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval halving_sum 1"}
{"id": "fvapps_003332", "vc-description": "/-\nHector the hacker has stolen some information, but it is encrypted. In order to decrypt it, he needs to write a function that will generate a decryption key from the encryption key which he stole (it is in hexadecimal). To do this, he has to determine the two prime factors `P` and `Q` of the encyption key, and return the product `(P-1) * (Q-1)`.\n\n**Note:** the primes used are < 10^(5)\n\n## Examples\n\nFor example if the encryption key is `\"47b\"`, it is 1147 in decimal. This factors to 31\\*37, so the key Hector needs is 1080 (= 30\\*36).\n\nMore examples:\n* input: `\"2533\"`, result: 9328 (primes: 89, 107)\n* input: `\"1ba9\"`, result: 6912 (primes: 73, 97)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_key (s : String) : Nat :=\n  sorry\n\ndef isPrime (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem find_key_edge_cases :\n  find_key \"0\" = 0 ∧ find_key \"1\" = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1080\n-/\n#guard_msgs in\n#eval find_key \"47b\"\n\n/--\ninfo: 9328\n-/\n#guard_msgs in\n#eval find_key \"2533\"\n\n/--\ninfo: 6912\n-/\n#guard_msgs in\n#eval find_key \"1ba9\""}
{"id": "fvapps_003335", "vc-description": "/-\n# Introduction \n\nThe ragbaby cipher is a substitution cipher that encodes/decodes a text using a keyed alphabet and their position in the plaintext word they are a part of.\n\nTo encrypt the text `This is an example.` with the key `cipher`, first construct a keyed alphabet:\n```\nc       i       p       h       e       r       a       b       d       f       g       j       k       l       m       n       o       q       s       t       u       v       w       x       y       z\n```\n\nThen, number the letters in the text as follows:\n```\nT       h       i       s               i       s               a       n               e       x       a       m       p       l       e       .\n1       2       3       4               1       2               1       2               1       2       3       4       5       6       7        \n```\n\nTo obtain the encoded text, replace each character of the word with the letter in the keyed alphabet the corresponding number of places to the right of it (wrapping if necessary). \nNon-alphabetic characters are preserved to mark word boundaries.\n\nOur ciphertext is then `Urew pu bq rzfsbtj.`\n\n# Task\n\nWirate functions `encode` and `decode` which accept 2 parameters:\n- `text` - string - a text to encode/decode\n- `key` -  string - a key\n\n# Notes\n\n- handle lower and upper case in `text` string\n- `key` consists of only lowercase characters\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidKey (k : String) : Bool :=\n  sorry\n\ndef encode (text key : String) : String :=\n  sorry", "vc-theorems": "theorem encode_preserves_non_letters (text key : String) :\n  isValidKey key → ∀ i, ¬(text.get! i).isAlpha →\n  (encode text key).get! i = text.get! i :=\nsorry\n\ntheorem encode_preserves_case (text key : String) :\n  isValidKey key → ∀ i,\n  let c := text.get! i\n  let e := (encode text key).get! i\n  c.isAlpha → (c.isUpper = e.isUpper) :=\nsorry\n\ntheorem encode_duplicate_key_chars (text key : String) :\n  isValidKey key →\n  encode text key = encode text (String.mk (key.data.eraseDups)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cipher\"\n\n/--\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cccciiiiippphheeeeerrrrr\""}
{"id": "fvapps_003336", "vc-description": "/-\nYour colleagues have been good enough(?) to buy you a birthday gift. Even though it is your birthday and not theirs, they have decided to play pass the parcel with it so that everyone has an even chance of winning. There are multiple presents, and you will receive one, but not all are nice... One even explodes and covers you in soil... strange office. To make up for this one present is a dog! Happy days! (do not buy dogs as presents, and if you do, never wrap them).\n\nDepending on the number of passes in the game (y), and the present you unwrap (x), return as follows:\n\nx == goodpresent --> return x with num of passes added to each charCode (turn to charCode, add y to each, turn back)\nx == crap || x == empty --> return string sorted alphabetically\nx == bang --> return string turned to char codes, each code reduced by number of passes and summed to a single figure\nx == badpresent --> return 'Take this back!'\nx == dog, return 'pass out from excitement y times' (where y is the value given for y).\n-/", "vc-preamble": "def isValidInput (x : String) : Bool :=\n  x = \"goodpresent\" ∨ x = \"crap\" ∨ x = \"empty\" ∨ x = \"bang\" ∨ x = \"badpresent\" ∨ x = \"dog\"", "vc-helpers": "", "vc-definitions": "def present (x : String) (y : Int) : String :=\nsorry", "vc-theorems": "theorem present_goodpresent_length (y : Int) :\n  String.length (present \"goodpresent\" y) = String.length \"goodpresent\" :=\nsorry\n\ntheorem present_crap_fixed (y : Int) :\n  present \"crap\" y = \"acpr\" :=\nsorry\n\ntheorem present_empty_fixed (y : Int) :\n  present \"empty\" y = \"empty\" :=\nsorry\n\ntheorem present_badpresent_fixed (y : Int) :\n  present \"badpresent\" y = \"Take this back!\" :=\nsorry\n\ntheorem present_dog_contains_number (y : Int) :\n  ∃ s : String, s = toString y ∧ present \"dog\" y = s :=\nsorry\n\ntheorem present_invalid_input (x : String) (h : ¬isValidInput x) :\n  ∃ err, present x 0 = err :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Take this back!'\n-/\n#guard_msgs in\n#eval present \"badpresent\" 3\n\n/--\ninfo: 'pxxmy{n|nw}'\n-/\n#guard_msgs in\n#eval present \"goodpresent\" 9\n\n/--\ninfo: 'pass out from excitement 23 times'\n-/\n#guard_msgs in\n#eval present \"dog\" 23"}
{"id": "fvapps_003342", "vc-description": "/-\n# Introduction and Warm-up (Highly recommended)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n___\n\n# Task\n\n**_Given_** an *array/list [] of integers* , **_Find_** **_The maximum difference_** *between the successive elements in its sorted form*. \n___\n\n# Notes \n\n* **_Array/list_** size is *at least 3*  .\n\n* **_Array/list's numbers_**  Will be **mixture of positives and negatives also zeros_**  \n\n* **_Repetition_** of numbers in *the array/list could occur*.\n\n* **_The Maximum Gap_** is *computed Regardless the sign*.\n\n___\n\n# Input >> Output Examples \n\n```\nmaxGap ({13,10,5,2,9}) ==> return (4)\n```\n\n## **_Explanation_**: \n\n* **_The Maximum Gap_** *after sorting the array is* `4` , *The difference between*   ``` 9 - 5 = 4 ``` .\n___\n\n```\nmaxGap ({-3,-27,-4,-2}) ==> return (23)\n```\n## **_Explanation_**: \n\n* **_The Maximum Gap_** *after sorting the array is* `23` , *The difference between*   ` |-4- (-27) | = 23` .\n\n*  **_Note_** : *Regardless the sign of negativity* .\n___\n\n```\nmaxGap ({-7,-42,-809,-14,-12}) ==> return (767)  \n```\n## **_Explanation_**: \n\n* **_The Maximum Gap_** *after sorting the array is* `767` , *The difference between*   ` | -809- (-42) | = 767` .\n\n*  **_Note_** : *Regardless the sign of negativity* .\n___\n\n```\nmaxGap ({-54,37,0,64,640,0,-15}) //return (576)\n```\n## **_Explanation_**: \n\n* **_The Maximum Gap_** *after sorting the array is* `576` , *The difference between*   ` | 64 - 640 | = 576` .\n\n*  **_Note_** : *Regardless the sign of negativity* .\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximum (xs : List Int) : Int :=\nsorry\n\ndef minimum (xs : List Int) : Int :=\nsorry\n\ndef sorted (xs : List Int) : List Int :=\nsorry\n\ndef max_gap (xs : List Int) : Int :=\nsorry", "vc-theorems": "theorem max_gap_positive (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs ≥ 0 :=\nsorry\n\ntheorem max_gap_bounded_by_range (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs ≤ maximum xs - minimum xs :=\nsorry\n\ntheorem max_gap_in_consecutive_diffs (xs : List Int) (h : xs.length ≥ 2) :\n  ∃ i : Nat, i < xs.length - 1 ∧\n    max_gap xs = (sorted xs).get ⟨i+1, sorry⟩ - (sorted xs).get ⟨i, sorry⟩ :=\nsorry\n\ntheorem max_gap_reversal_invariant (xs : List Int) (h : xs.length ≥ 2) :\n  max_gap xs = max_gap xs.reverse :=\nsorry\n\ntheorem max_gap_nonnegative_bounded (xs : List Int) (h : xs.length ≥ 2)\n  (h2 : ∀ x ∈ xs, x ≥ 0) :\n  max_gap xs ≤ maximum xs :=\nsorry\n\ntheorem max_gap_translation_invariant (xs : List Int) (c : Int) (h : xs.length ≥ 2) :\n  max_gap xs = max_gap (xs.map (· + c)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gap [13, 10, 2, 9, 5]\n\n/--\ninfo: 23\n-/\n#guard_msgs in\n#eval max_gap [-3, -27, -4, -2]\n\n/--\ninfo: 576\n-/\n#guard_msgs in\n#eval max_gap [-54, 37, 0, 64, -15, 640, 0]"}
{"id": "fvapps_003343", "vc-description": "/-\n## Description\nYour job is to create a simple password validation function, as seen on many websites. \n\nThe rules for a valid password are as follows:\n- There needs to be at least 1 uppercase letter.\n- There needs to be at least 1 lowercase letter.\n- There needs to be at least 1 number.\n- The password needs to be at least 8 characters long.\n\nYou are permitted to use any methods to validate the password.\n\n## Examples:\n\n### Extra info\n- You will only be passed strings.\n- The string can contain any standard keyboard character.\n- Accepted strings can be any length, as long as they are 8 characters or more.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLower (c : Char) : Bool :=\n  sorry\n\ndef isUpper (c : Char) : Bool :=\n  sorry\n\ndef isDigit (c : Char) : Bool :=\n  sorry\n\ndef is_valid_password (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem valid_password_conditions (s : String) :\n  (s.length ≥ 8) →\n  (∃ c, c ∈ s.data ∧ isLower c) →\n  (∃ c, c ∈ s.data ∧ isUpper c) →\n  (∃ c, c ∈ s.data ∧ isDigit c) →\n  is_valid_password s = true :=\nsorry\n\ntheorem invalid_password_too_short (s : String) :\n  s.length < 8 →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_upper (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isUpper c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_lower (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isLower c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem invalid_password_no_digit (s : String) :\n  s.length ≥ 8 →\n  (¬∃ c, c ∈ s.data ∧ isDigit c) →\n  is_valid_password s = false :=\nsorry\n\ntheorem empty_password_invalid :\n  is_valid_password \"\" = false :=\nsorry\n\ntheorem short_password_invalid :\n  is_valid_password \"aA1\" = false :=\nsorry\n\ntheorem valid_min_length_password :\n  is_valid_password \"aaaaA111\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd1234\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd123\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"abcd1234\""}
{"id": "fvapps_003347", "vc-description": "/-\nThis function should take two string parameters: a person's name (`name`) and a quote of theirs (`quote`), and return a string attributing the quote to the person in the following format:\n\n```python\n'[name] said: \"[quote]\"'\n```\n\nFor example, if `name` is `'Grae'` and `'quote'` is `'Practice makes perfect'` then your function should return the string\n```python\n'Grae said: \"Practice makes perfect\"'\n```\nUnfortunately, something is wrong with the instructions in the function body. Your job is to fix it so the function returns correctly formatted quotes.\n\nClick the \"Train\" button to get started, and be careful with your quotation marks.\n-/\n\n/- Property: Output contains both inputs and format is consistent -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Property: Quotes appear in correct places only -/\n\n/- Property: Function is deterministic -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def quotable (name : String) (quote : String) : String :=\nsorry", "vc-theorems": "theorem quotable_format (name quote : String)\n  (h1 : ¬ String.contains name '\"')\n  (h2 : ¬ String.contains quote '\"') :\n  (quotable name quote).startsWith name ∧\n  (quotable name quote).endsWith ('\"'.toString ++ quote ++ '\"'.toString) ∧\n  String.contains (quotable name quote) ' ' :=\nsorry\n\ntheorem quotable_quotes_placement (name quote : String)\n  (h1 : ¬ String.contains name '\"')\n  (h2 : ¬ String.contains quote '\"') :\n  ((quotable name quote).data.filter (· = '\"')).length = 2 :=\nsorry\n\ntheorem quotable_deterministic (name quote : String) :\n  quotable name quote = quotable name quote :=\nsorry", "vc-postamble": "/--\ninfo: 'Grae said: \"Practice makes perfect\"'\n-/\n#guard_msgs in\n#eval quotable \"Grae\" \"Practice makes perfect\"\n\n/--\ninfo: 'Alex said: \"Python is great fun\"'\n-/\n#guard_msgs in\n#eval quotable \"Alex\" \"Python is great fun\"\n\n/--\ninfo: 'Bethany said: \"Yes, way more fun than R\"'\n-/\n#guard_msgs in\n#eval quotable \"Bethany\" \"Yes, way more fun than R\""}
{"id": "fvapps_003349", "vc-description": "/-\n## The Problem\n\nJames is a DJ at a local radio station. As it's getting to the top of the hour, he needs to find a song to play that will be short enough to fit in before the news block. He's got a database of songs that he'd like you to help him filter in order to do that.\n\n## What To Do\n\nCreate `longestPossible`(`longest_possible` in python and ruby) helper function that takes 1 integer argument which is a maximum length of a song in seconds.\n\n`songs` is an array of objects which are formatted as follows:\n\n```python\n{'artist': 'Artist', 'title': 'Title String', 'playback': '04:30'}\n```\n\nYou can expect playback value to be formatted exactly like above.\n\nOutput should be a title of the longest song from the database that matches the criteria of not being longer than specified time. If there's no songs matching criteria in the database, return `false`.\n-/", "vc-preamble": "def song_durations : List String :=\n  [\"03:36\", \"06:48\", \"04:27\", \"03:50\", \"04:32\", \"04:22\", \"03:30\", \"03:25\", \"04:34\"]", "vc-helpers": "", "vc-definitions": "def calculate_seconds (time_str : String) : Nat :=\n  sorry\n\ndef longest_possible (seconds : Int) : Option String :=\n  sorry", "vc-theorems": "theorem calculate_seconds_basic_properties {minutes seconds : Nat}\n  (h1 : minutes ≤ 59) (h2 : seconds ≤ 59) :\n  (calculate_seconds s!\"{minutes}:{seconds}\" = minutes * 60 + seconds) ∧\n  (calculate_seconds s!\"{minutes}:{seconds}\" ≥ 0) :=\nsorry\n\ntheorem longest_possible_properties (seconds : Int) :\n  match longest_possible seconds with\n  | some result =>\n    result ∈ song_durations ∧\n    calculate_seconds result ≤ seconds ∧\n    ∀ s ∈ song_durations,\n      calculate_seconds s ≤ seconds →\n      calculate_seconds s ≤ calculate_seconds result\n  | none =>\n    ∀ duration ∈ song_durations,\n      calculate_seconds duration > seconds :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'For Reasons Unknown'\n-/\n#guard_msgs in\n#eval longest_possible 215\n\n/--\ninfo: 'YYZ'\n-/\n#guard_msgs in\n#eval longest_possible 270\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval longest_possible 13\n\n/--\ninfo: 'Surfing With The Alien'\n-/\n#guard_msgs in\n#eval longest_possible 300"}
{"id": "fvapps_003350", "vc-description": "/-\nA [Mersenne prime](https://en.wikipedia.org/wiki/Mersenne_prime) is a prime number that can be represented as:\nMn = 2^(n) - 1. Therefore, every Mersenne prime is one less than a power of two. \n\nWrite a function that will return whether the given integer `n` will produce a Mersenne prime or not.\n\nThe tests will check random integers up to 2000.\n-/", "vc-preamble": "def valid_mersenne_numbers : List Int :=\n  [2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279]", "vc-helpers": "", "vc-definitions": "def valid_mersenne (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem valid_mersenne_returns_bool (n : Int) :\n  valid_mersenne n = true ∨ valid_mersenne n = false :=\nsorry\n\ntheorem valid_mersenne_outside_range {n : Int} :\n  (n < 1 ∨ n > 1279) → valid_mersenne n = false :=\nsorry\n\ntheorem valid_mersenne_deterministic (n : Int) :\n  valid_mersenne n = valid_mersenne n :=\nsorry\n\ntheorem valid_mersenne_in_set {n : Int} :\n  1 ≤ n ∧ n ≤ 1279 →\n  valid_mersenne n = true ↔ n ∈ valid_mersenne_numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 3\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval valid_mersenne 11\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 127"}
{"id": "fvapps_003355", "vc-description": "/-\n# Kata Task\n\nYou are given a list of cogs in a gear train\n\nEach element represents the number of teeth of that cog\n\ne.g. `[100, 50, 25]` means \n* 1st cog has 100 teeth \n* 2nd cog has 50 teeth\n* 3rd cog has 25 teeth\n\nIf the ``nth`` cog rotates clockwise at 1 RPM what is the RPM of the cogs at each end of the gear train? \n\n**Notes**\n* no two cogs share the same shaft\n* return an array whose two elements are RPM of the first and last cogs respectively\n* use negative numbers for anti-clockwise rotation\n* for convenience `n` is zero-based\n* For C and NASM coders, the returned array will be `free`'d.\n\n---\n\nSeries:\n* Cogs\n* Cogs 2\n-/\n\n/- For accessing array elements safely -/", "vc-preamble": "def get? {α : Type} (xs : List α) (i : Nat) : Option α :=\n  if h : i < xs.length then some (xs.get ⟨i, h⟩) else none", "vc-helpers": "", "vc-definitions": "def cog_RPM (cogs: List Nat) (n: Nat) : List Int :=\nsorry", "vc-theorems": "theorem single_cog_property {cogs : List Nat} {n : Nat} (h : cogs.length = 1) :\n  cog_RPM cogs 0 = [1, 1] :=\nsorry\n\ntheorem cog_direction_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length) :\n  ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n  ((x > 0) ↔ (n % 2 = 0)) ∧\n  ((y > 0) ↔ ((cogs.length - n) % 2 = 1)) :=\nsorry\n\ntheorem cog_ratio_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : ∀ i, get? cogs i ≠ none) :\n  match get? cogs n, get? cogs 0, get? cogs (cogs.length - 1) with\n  | some cn, some c0, some cl =>\n    ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n    x.natAbs = cn / c0 ∧\n    y.natAbs = cn / cl\n  | _, _, _ => True :=\nsorry\n\ntheorem identical_cogs_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : ∀ i j, i < cogs.length → j < cogs.length → get? cogs i = get? cogs j) :\n  ∃ x y : Int, cog_RPM cogs n = [x, y] ∧\n  x.natAbs = 1 ∧ y.natAbs = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100] 0\n\n/--\ninfo: [1, -1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 0\n\n/--\ninfo: [-1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 1"}
{"id": "fvapps_003356", "vc-description": "/-\nIn this Kata we are passing a number (n) into a function. \n\nYour code will determine if the number passed is even (or not). \n\nThe function needs to return either a true or false. \n\nNumbers may be positive or negative, integers or floats.\n\nFloats are considered UNeven for this kata.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isEven (x : Int) : Bool :=\n  sorry\n\ndef isFloat (x : Float) : Bool :=\n  sorry\n\ndef isEvenFloat (x : Float) : Bool :=\n  sorry", "vc-theorems": "theorem even_plus_two (x : Int) :\n  isEven x = isEven (x + 2) :=\nsorry\n\ntheorem even_plus_one_diff (x : Int) :\n  isEven x ≠ isEven (x + 1) :=\nsorry\n\ntheorem times_two_even (x : Int) :\n  isEven (x * 2) = true :=\nsorry\n\ntheorem non_integer_float_not_even (x : Float) :\n  ¬isFloat x → isEvenFloat x = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_even 2\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 1\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 0.5"}
{"id": "fvapps_003361", "vc-description": "/-\nThe Earth has been invaded by aliens. They demand our beer and threaten to destroy the Earth if we do not supply the exact number of beers demanded.\n\nUnfortunately, the aliens only speak Morse code. Write a program to convert morse code into numbers using the following convention:\n\n1 .----\n2 ..---\n3 ...--\n4 ....-\n5 .....\n6 -....\n7 --...\n8 ---..\n9 ----.\n0 -----\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def morse_converter (s : String) : Nat :=\n  sorry\n\ndef convertToMorse (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem morse_converter_output_valid (s : String) :\n  let result := morse_converter s\n  result ≥ 0\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 11111\n-/\n#guard_msgs in\n#eval morse_converter \".----.----.----.----.----\"\n\n/--\ninfo: 207600\n-/\n#guard_msgs in\n#eval morse_converter \"..----------...-....----------\"\n\n/--\ninfo: 1234567890\n-/\n#guard_msgs in\n#eval morse_converter \".----..---...--....-.....-....--...---..----.-----\""}
{"id": "fvapps_003376", "vc-description": "/-\nYou are a skier (marked below by the `X`). You have made it to the Olympics! Well done.\n\n```\n\\_\\_\\_X\\_\n\\*\\*\\*\\*\\*\\\n\\*\\*\\*\\*\\*\\*\\\n\\*\\*\\*\\*\\*\\*\\*\\\n\\*\\*\\*\\*\\*\\*\\*\\*\\\n\\*\\*\\*\\*\\*\\*\\*\\*\\*\\\\.\\_\\_\\_\\_/\n```\n\nYour job in this kata is to calculate the maximum speed you will achieve during your downhill run. The speed is dictated by the height of the mountain. Each element of the array is a layer of the mountain as indicated by the diagram above (and further below). So for this example the mountain has a height of 5 (5 rows of stars). `Speed` is `mountain height * 1.5`.\n\nThe jump length is calculated by `(mountain height * speed * 9) / 10`. Jump length should be rounded to 2 decimal places.\n\nYou must return the length of the resulting jump as a string in the following format:\n\n* when less than 10 m: `\"X metres: He's crap!\"`\n* between 10 and 25 m: `\"X metres: He's ok!\"`\n* between 25 and 50 m: `\"X metres: He's flying!\"`\n* when more than 50 m: `\"X metres: Gold!!\"`\n\nSo in the example case above, the right answer would be `\"33.75 metres: He's flying!\"`\n\nSadly, it takes a lot of time to make arrays look like mountains, so the tests wont all look so nice. To give an example, the above mountain would look as follows in most cases:\n\n```\n[*****, ******, *******, ********, *********]\n```\nNot as much fun, eh?\n\n*p.s. if you think \"metre\" is incorrect, please [read this](https://en.wikipedia.org/wiki/Metre#Spelling)*\n-/", "vc-preamble": "def isValidMessage (msg: String) : Bool :=\n  msg = \"He's crap!\" || msg = \"He's ok!\" || msg = \"He's flying!\" || msg = \"Gold!!\"", "vc-helpers": "", "vc-definitions": "def ski_jump (mountain: List String) : String := \n  sorry\n\ndef stringToFloat (s: String) : Float := \n  sorry", "vc-theorems": "theorem ski_jump_output_format {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let parts := result.splitOn \" metres: \"\n  parts.length = 2 ∧\n  (let number := parts[0]!\n   let message := parts[1]!\n   stringToFloat number ≥ 0 ∧\n   isValidMessage message) :=\nsorry\n\ntheorem jump_length_proportional_to_height {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let jumpLength := stringToFloat (result.splitOn \" metres: \")[0]!\n  jumpLength = Float.ofNat mountain.length * (Float.ofNat mountain.length * 1.5) * 0.9 :=\nsorry\n\ntheorem message_thresholds {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let length := stringToFloat (result.splitOn \" metres: \")[0]!\n  let message := (result.splitOn \"metres: \")[1]!\n  (length < 10 → message = \"He's crap!\") ∧\n  (length ≥ 10 ∧ length < 25 → message = \"He's ok!\") ∧\n  (length ≥ 25 ∧ length < 50 → message = \"He's flying!\") ∧\n  (length ≥ 50 → message = \"Gold!!\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: \"1.35 metres: He's crap!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\"]\n\n/--\ninfo: \"12.15 metres: He's ok!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\", \"**\", \"***\"]\n\n/--\ninfo: \"48.60 metres: He's flying!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\", \"**\", \"***\", \"****\", \"*****\", \"******\"]"}
{"id": "fvapps_003378", "vc-description": "/-\nIn computer science and discrete mathematics, an [inversion](https://en.wikipedia.org/wiki/Inversion_%28discrete_mathematics%29) is a pair of places in a sequence where the elements in these places are out of their natural order. So, if we use ascending order for a group of numbers, then an inversion is when larger numbers appear before lower number in a sequence.\n\nCheck out this example sequence: ```(1, 2, 5, 3, 4, 7, 6)``` and we can see here three inversions\n```5``` and ```3```; ```5``` and ```4```; ```7``` and ```6```.\n\nYou are given a sequence of numbers and you should count the number of inversions in this sequence.\n\n```Input```: A sequence as a tuple of integers.\n\n```Output```: The inversion number as an integer.\n\nExample:\n```python\n  count_inversion((1, 2, 5, 3, 4, 7, 6)) == 3\n  count_inversion((0, 1, 2, 3)) == 0\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countInversion (s : List Int) : Nat :=\nsorry\n\ndef isSorted (s : List Int) : Bool :=\nsorry\n\ndef isAntiSorted (s : List Int) : Bool :=\nsorry", "vc-theorems": "theorem countInversion_nonnegative (s : List Int) :\n  countInversion s ≥ 0 :=\nsorry\n\ntheorem countInversion_sorted_zero (s : List Int) :\n  isSorted s = true → countInversion s = 0 :=\nsorry\n\ntheorem countInversion_reverse_sorted_max (s : List Int) :\n  let maxInv := s.length * (s.length - 1) / 2\n  isAntiSorted s = true → countInversion s ≤ maxInv :=\nsorry\n\ntheorem countInversion_small_seq (s : List Int) :\n  s.length ≤ 1 → countInversion s = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_inversion (1, 2, 5, 3, 4, 7, 6)\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversion (0, 1, 2, 3)\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_inversion (3, 2, 1, 0)"}
{"id": "fvapps_003386", "vc-description": "/-\nIn this Kata, we will calculate the **minumum positive number that is not a possible sum** from a list of positive integers. \n\n```\nsolve([1,2,8,7]) = 4 => we can get 1, 2, 3 (from 1+2), but we cannot get 4. 4 is the minimum number not possible from the list. \nsolve([4,1,2,3,12]) = 11. We can get 1, 2, 3, 4, 4+1=5, 4+2=6,4+3=7,4+3+1=8,4+3+2=9,4+3+2+1=10. But not 11. \nsolve([2,3,2,3,4,2,12,3]) = 1. We cannot get 1.\n```\nMore examples in test cases. \n\nGood luck!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (nums : List Nat) : Nat :=\nsorry\n\ndef sums (l : List Nat) : List Nat :=\nsorry\n\ndef findMin (s : List Nat) : Nat :=\nsorry\n\ndef sortList (l : List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem solve_returns_positive (nums : List Nat)\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 1000)\n  : solve nums > 0 :=\nsorry\n\ntheorem solve_order_invariant (nums : List Nat)\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 100)\n  : solve nums = solve (sortList nums) :=\nsorry\n\ntheorem solve_is_min_missing_sum {nums : List Nat}\n  (h : ∀ x ∈ nums, x > 0 ∧ x ≤ 10)\n  (h2 : nums.length ≤ 5)\n  : solve nums = findMin (sums nums) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003389", "vc-description": "/-\nYou are given three piles of casino chips: white, green and black chips:\n\n* the first pile contains only white chips\n* the second pile contains only green chips\n* the third pile contains only black chips\n\nEach day you take exactly two chips of different colors and head to the casino. You can choose any color, but you are not allowed to take two chips of the same color in a day.\n\nYou will be given an array representing the number of chips of each color and your task is to return the maximum number of days you can pick the chips. Each day you need to take exactly two chips.\n\n```python \nsolve([1,1,1]) = 1, because after you pick on day one, there will be only one chip left\nsolve([1,2,1] = 2, you can pick twice; you pick two chips on day one then on day two\nsolve([4,1,1]) = 2\n```\n\n```javascript \nsolve([1,1,1]) = 1, because after you pick on day one, there will be only one chip left\nsolve([1,2,1]) = 2, you can pick twice; you pick two chips on day one then on day two\nsolve([4,1,1]) = 2\n```\n\n```go \nsolve([1,1,1]) = 1, because after you pick on day one, there will be only one chip left\nsolve([1,2,1]) = 2, you can pick twice; you pick two chips on day one then on day two\nsolve([4,1,1]) = 2\n```\n\n```ruby \nsolve([1,1,1]) = 1, because after you pick on day one, there will be only one chip left\nsolve([1,2,1]) = 2, you can pick twice; you pick two chips on day, two chips on day two\nsolve([4,1,1]) = 2\n```\n\nMore examples in the test cases. Good luck!\n\nBrute force is not the way to go here. Look for a simplifying mathematical approach.\n-/", "vc-preamble": "def listSum : List Nat → Nat\n| [] => 0\n| x::xs => x + listSum xs\n\ndef listMin : List Nat → Nat\n| [] => 0\n| [x] => x\n| x::xs => min x (listMin xs)\n\ndef secondMin : List Nat → Nat\n| [] => 0\n| [_] => 0\n| l =>\n  let m := listMin l\n  listMin (l.filter (fun x => x ≠ m))", "vc-helpers": "", "vc-definitions": "def solve (chips : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_two_identical_bounded (a b : Nat)\n  (h₁ : a > 0)\n  (h₂ : b > 0) :\n  solve [a, a, b] ≤ (a + a + b) / 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve [1, 1, 1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [1, 2, 1]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval solve [8, 2, 8]"}
{"id": "fvapps_003400", "vc-description": "/-\nYou will receive an uncertain amount of integers in a certain order ```k1, k2, ..., kn```.\n\nYou form a new number of n digits in the following way:\nyou take one of the possible digits of the first given number, ```k1```, then the same with the given number ```k2```, repeating the same process up to ```kn``` and you concatenate these obtained digits(in the order that were taken) obtaining the new number. As you can see, we have many possibilities.\n\nLet's see the process above explained with three given numbers:\n```\nk1 = 23, k2 = 17, k3 = 89\nDigits Combinations   Obtained Number\n  ('2', '1', '8')           218    <---- Minimum\n  ('2', '1', '9')           219\n  ('2', '7', '8')           278\n  ('2', '7', '9')           279\n  ('3', '1', '8')           318\n  ('3', '1', '9')           319\n  ('3', '7', '8')           378\n  ('3', '7', '9')           379    <---- Maximum\n             Total Sum =   2388   (8 different values)\n```\nWe need the function that may work in this way:\n\n```python\nproc_seq(23, 17, 89) == [8, 218, 379, 2388]\n```\n\nSee this special case and deduce how the function should handle the cases which have many repetitions.\n\n```python\nproc_seq(22, 22, 22, 22) == [1, 2222] # we have only one obtained number, the minimum, maximum and total sum coincide\n```\n\nThe sequence of numbers will have numbers of n digits only. Numbers formed by leading zeroes will be discarded.\n\n```python\nproc_seq(230, 15, 8) == [4, 218, 358, 1152]\n```\n\nEnjoy it!!\n\nYou will never receive the number 0 and all the numbers will be in valid format.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def proc_seq : List Nat → List Nat\n  | xs => sorry\n\ndef countPermNoLeadingZero (n : Nat) (m : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem proc_seq_valid_output (nums : List Nat) :\n  let result := proc_seq nums\n  (result.length = 2 ∨ result.length = 4) ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  (result.length = 2 → result.head! = 1) ∧\n  (result.length = 4 →\n    result[1]! ≤ result[2]! ∧ result[1]! ≤ result[3]!) :=\nsorry\n\ntheorem proc_seq_leading_zeros (n : Nat) (h : n ≥ 100 ∧ n ≤ 999) :\n  let result := proc_seq [n, 0]\n  result.head! = countPermNoLeadingZero n 0 :=\nsorry\n\ntheorem proc_seq_small_nums {nums : List Nat} (h : 2 ≤ nums.length ∧ nums.length ≤ 3)\n  (h' : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 9) :\n  let result := proc_seq nums\n  (result.length = 2 ∨ result.length = 4) ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  (result.length = 2 → result.head! = 1) ∧\n  (result.length = 4 →\n    result[1]! ≤ result[2]! ∧ result[1]! ≤ result[3]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [8, 218, 379, 2388]\n-/\n#guard_msgs in\n#eval proc_seq 23 17 89\n\n/--\ninfo: [1, 2222]\n-/\n#guard_msgs in\n#eval proc_seq 22 22 22 22\n\n/--\ninfo: [4, 218, 358, 1152]\n-/\n#guard_msgs in\n#eval proc_seq 230 15 8"}
{"id": "fvapps_003405", "vc-description": "/-\nGiven two arrays of strings, return the number of times each string of the second array appears in the first array.\n\n#### Example\n\n```python\narray1 = ['abc', 'abc', 'xyz', 'cde', 'uvw']\narray2 = ['abc', 'cde', 'uap']\n```\n\nHow many times do the elements in `array2` appear in `array1`? \n\n* `'abc'` appears twice in the first array (2)\n* `'cde'` appears only once (1)\n* `'uap'` does not appear in the first array (0)\n\nTherefore, `solve(array1, array2) = [2, 1, 0]`\n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Word values](https://www.codewars.com/kata/598d91785d4ce3ec4f000018)\n\n[Non-even substrings](https://www.codewars.com/kata/59da47fa27ee00a8b90000b4)\n-/\n\n-- Length matches\n\n-- All counts are non-negative (satisfied by Nat type)\n\n-- Each count matches actual occurrences\n\n-- Count cannot exceed length of array1", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count {α} [BEq α] (a : α) (xs : List α) : Nat :=\n  sorry\n\ndef solve {α} [BEq α] (array1 array2 : List α) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_properties {α} [BEq α] (array1 array2 : List α)\n  (h1 : array1 ≠ []) (h2 : array2 ≠ []) :\n  let result := solve array1 array2;\n\n  result.length = array2.length\n\n  ∧ (∀ i elem, i < array2.length → array2.get ⟨i, by sorry⟩ = elem →\n      result.get ⟨i, by sorry⟩ = count elem array1)\n\n  ∧ ∀ x ∈ result, x ≤ array1.length :=\nsorry\n\ntheorem solve_identical_arrays {α} [BEq α] (array : List α)\n  (h : array ≠ []) :\n  let result := solve array array;\n  ∀ i c x, i < array.length →\n    result.get ⟨i, by sorry⟩ = c →\n    array.get ⟨i, by sorry⟩ = x →\n    c = count x array :=\nsorry\n\ntheorem solve_unique_array2 {α} [BEq α] (array1 array2 : List α)\n  (h1 : array1 ≠ []) (h2 : array2 ≠ [])\n  (unique : ∀ i j, i < array2.length → j < array2.length → i ≠ j →\n    array2.get ⟨i, by sorry⟩ ≠ array2.get ⟨j, by sorry⟩) :\n  solve array1 array2 = array2.map (λ x => count x array1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"abc\", \"xyz\", \"abcd\", \"cde\"] [\"abc\", \"cde\", \"uap\"]\n\n/--\ninfo: [2, 1, 2]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"xyz\", \"abc\", \"xyz\", \"cde\"] [\"abc\", \"cde\", \"xyz\"]\n\n/--\ninfo: [2, 0, 1]\n-/\n#guard_msgs in\n#eval solve [\"quick\", \"brown\", \"fox\", \"is\", \"quick\"] [\"quick\", \"abc\", \"fox\"]"}
{"id": "fvapps_003406", "vc-description": "/-\nIn the morning all the doors in the school are closed. The school is quite big: there are **N** doors. Then pupils start coming. It might be hard to believe, but all of them want to study! Also, there are exactly **N** children studying in this school, and they come one by one.\n\nWhen these strange children pass by some doors they change their status (i.e. Open -> Closed, Closed -> Open). Each student has their number, and each i-th student alters the status of every i-th door. For example: when the first child comes to the schools, he changes every first door (he opens all of them). The second one changes the status of every second door (he closes some doors: the 2nd, the 4th and so on). Finally, when the last one – the n-th – comes to the school, he changes the status of each n-th door (there's only one such door, though).\n\nYou need to count how many doors are left opened after all the students have come.\n\nExample:\n\n![](http://i.imgur.com/IqlOi2q.png)\n\n*Here you can see red squares – closed doors, green – opened ones.*\n\nInput:\n\n> n – the number of doors and students, n ∈ N, n ∈ [1, 100000]\n\nOutput:\n\n> o – the number of opened doors, o ∈ N\n\n--- \n\n```\ndoors(5)\n```\n\nShould return\n\n```\n2\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def doors (n : Nat) : Nat :=\nsorry\n\ndef sqrt (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem doors_non_negative (n : Nat) :\n  doors n ≥ 0 :=\nsorry\n\ntheorem doors_squared_leq (n : Nat) :\n  (doors n) * (doors n) ≤ n :=\nsorry\n\ntheorem doors_plus_one_squared_gt (n : Nat) :\n  (doors n + 1) * (doors n + 1) > n :=\nsorry\n\ntheorem doors_perfect_squares (n : Nat) :\n  doors (n * n) = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval doors 5\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval doors 10\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval doors 100"}
{"id": "fvapps_003407", "vc-description": "/-\nGiven an `x` and `y` find the smallest and greatest numbers **above** and **below** a given `n` that are divisible by both `x` and `y`.\n\n### Examples\n```python\ngreatest(2, 3, 20) => 18   # 18 is the greatest number under 20 that is divisible by both 2 and 3\nsmallest(2, 3, 20) => 24   # 24 is the smallest number above 20 that is divisible by both 2 and 3\n\ngreatest(5, 15, 100) => 90\nsmallest(5, 15, 100) => 105\n\ngreatest(123, 456, 789) => 0   # there are no numbers under 789 that are divisible by both 123 and 456\nsmallest(123, 456, 789) => 18696\n```\n\n**Notes:** \n\n1. you should never return `n` even if it is divisible by `x` and `y` always the number above or below it\n2. `greatest` should return 0 if there are no numbers under `n` that are divisible by both `x` and `y`\n3. and all arguments will be valid (integers greater than 0).\n\n### Note for Haskell users\n\n>Please take a look at [bkaes comment](http://www.codewars.com/kata/when-greatest-is-less-than-smallest/discuss#56418f0fbf1f44834d000050) and give us your opinion\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def greatest (x y n : Nat) : Nat :=\n  sorry\n\ndef smallest (x y n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem divisible_by_inputs {x y n : Nat} (hx : x > 0) (hy : y > 0) :\n  let g := greatest x y (max x y * 2)\n  let s := smallest x y (max x y * 2)\n  g % x = 0 ∧ g % y = 0 ∧ s % x = 0 ∧ s % y = 0 :=\nsorry\n\ntheorem bounds {x y n : Nat} (hx : x > 0) (hy : y > 0) (hn : n > 0) :\n  let g := greatest x y n\n  let s := smallest x y n\n  g < n ∧ s > n ∧ s > g :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval greatest 2 3 20\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval smallest 2 3 20\n\n/--\ninfo: 90\n-/\n#guard_msgs in\n#eval greatest 5 15 100\n\n/--\ninfo: 105\n-/\n#guard_msgs in\n#eval smallest 5 15 100\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval greatest 123 456 789\n\n/--\ninfo: 18696\n-/\n#guard_msgs in\n#eval smallest 123 456 789"}
{"id": "fvapps_003409", "vc-description": "/-\nYour task is to Combine two Strings. But consider the rule...\n\nBy the way you don't have to check errors or incorrect input values, everything is ok without bad tricks, only two input strings and as result one output string;-)...\n\nAnd here's the rule:  \nInput Strings `a` and `b`: For every character in string `a` swap the casing of every occurrence of the same character in string `b`. Then do the same casing swap with the inputs reversed. Return a single string consisting of the changed version of `a` followed by the changed version of `b`. A char of `a` is in `b` regardless if it's in upper or lower case - see the testcases too.  \nI think that's all;-)...\n\nSome easy examples:\n\n````\nInput: \"abc\" and \"cde\"      => Output: \"abCCde\" \nInput: \"ab\" and \"aba\"       => Output: \"aBABA\"\nInput: \"abab\" and \"bababa\"  => Output: \"ABABbababa\"\n````\n\nOnce again for the last example - description from `KenKamau`, see discourse;-):\n\na) swap the case of characters in string `b` for every occurrence of that character in string `a`  \nchar `'a'` occurs twice in string `a`, so we swap all `'a'` in string `b` twice. This means we start with `\"bababa\"` then `\"bAbAbA\"` => `\"bababa\"`  \nchar `'b'` occurs twice in string `a` and so string `b` moves as follows: start with `\"bababa\"` then `\"BaBaBa\"` => `\"bababa\"`\n\nb) then, swap the case of characters in string `a` for every occurrence in string `b`  \nchar `'a'` occurs `3` times in string `b`. So string `a` swaps cases as follows: start with `\"abab\"` then => `\"AbAb\"` => `\"abab\"` => `\"AbAb\"`  \nchar `'b'` occurs `3` times in string `b`. So string `a` swaps as follow: start with `\"AbAb\"` then => `\"ABAB\"` => `\"AbAb\"` => `\"ABAB\"`.\n\nc) merge new strings `a` and `b`  \nreturn `\"ABABbababa\"`\n\nThere are some static tests at the beginning and many random tests if you submit your solution.\n\nHope you have fun:-)!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.lower : String → String :=\n  sorry\n\ndef String.swapcase : String → String :=\n  sorry\n\ndef Char.swapcase : Char → Char :=\n  sorry\n\ndef String.count (s₁ s₂ : String) : Nat :=\n  sorry\n\ndef work_on_strings (s₁ s₂ : String) : String :=\n  sorry", "vc-theorems": "theorem work_on_strings_length (a b : String) :\n  (work_on_strings a b).length = a.length + b.length :=\nsorry\n\ntheorem work_on_strings_substring_lengths (a b : String) :\n  let result := work_on_strings a b\n  (result.take a.length).length = a.length ∧\n  (result.drop a.length).length = b.length :=\nsorry\n\ntheorem work_on_strings_case_swap_first (a b : String) (i : String.Pos) :\n  let result := work_on_strings a b\n  let base := result.get i\n  (b.lower.count (toString base).lower) % 2 = 1 →\n  result = result.set i (base.swapcase) :=\nsorry\n\ntheorem work_on_strings_case_swap_second (a b : String) (i : String.Pos) :\n  let result := work_on_strings a b\n  let base := result.get i\n  (a.lower.count (toString base).lower) % 2 = 1 →\n  result = result.set i (base.swapcase) :=\nsorry\n\ntheorem work_on_strings_empty (s : String) :\n  work_on_strings \"\" s = s ∧\n  work_on_strings s \"\" = s ∧\n  work_on_strings \"\" \"\" = \"\" :=\nsorry\n\ntheorem work_on_strings_idempotent (s : String) :\n  let result := work_on_strings s s\n  work_on_strings s s = result :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'abCCde'\n-/\n#guard_msgs in\n#eval work_on_strings \"abc\" \"cde\"\n\n/--\ninfo: 'ABABbababa'\n-/\n#guard_msgs in\n#eval work_on_strings \"abab\" \"bababa\"\n\n/--\ninfo: 'abcDEfgDEFGg'\n-/\n#guard_msgs in\n#eval work_on_strings \"abcdeFg\" \"defgG\""}
{"id": "fvapps_003413", "vc-description": "/-\nWe define the function `f1(n,k)`, as the least multiple of `n` that has all its digits less than `k`. \n\nWe define the function `f2(n,k)`, as the least multiple of `n` that has all the digits that are less than `k`.\n\nEach digit may occur more than once in both values of `f1(n,k)` and `f2(n,k)`.\n\nThe possible values for `n` and `k` according to these ranges for both functions `f1` and `f2` in this kata:\n``` \n1 <= n <= 1.000.000.000.000\n3 <= k <= 9\n``` \n\nFor example, let's see the value of both functions for `n = 71` and `k = 4`:\n``` \nf1(71,4) == 213 # all its digits less than 4\nf2(71,4) == 2130 # 0,1,2,3 all of them present \n```\nThe integer `76` is the first integer that has the same values of `f1` and `f2` for `k = 4`. \n```\nf1(76,4) = f2(76,4) = 10032\n```\nLet's call these kind of numbers, **forgiving numbers**. (Let's continue with the fashion of attributing personality traits to numbers and, of course, an unknown one)\nSo, `76` is the smallest forgiving number of order `4`.\nIn the same way, `485` is the smallest forgiving number of order `5`.\n\nCreate a function that given an integer `n` and the order `k`, will output the higher and closest forgiving number to `n` of order `k`.\n\nLet's see some examples:\n```\nfind_f1_eq_f2(500,5) == 547\nfind_f1_eq_f2(1600,6) == 1799\nfind_f1_eq_f2(14900,7) == 14996\n```\nIf the number `n` is a forgiving itself for a certain order `k`, the function will never output the same value, remember, closest and **higher** than `n`.\n\nFor example, `3456`, is a forgiving one of order `4`,\n```\nfind_f1_eq_f2(3456,4) == 3462\n```\n**Features of the tests:**\n\n* `n` and `k` will be always valid and positive integers.\n\n* A total of 8 fixed tests.\n\n* A total of 150 random tests in the ranges for `n` and `k` given above.\n\nI'll be waiting your awesome solution. :)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_f1_eq_f2 (n : Nat) (k : Nat) : Nat :=\nsorry\n\ndef appears_in (d : Nat) (n : Nat) : Prop :=\nsorry", "vc-theorems": "theorem find_f1_eq_f2_basic_case_1 :\n  find_f1_eq_f2 542 5 = 547 :=\nsorry\n\ntheorem find_f1_eq_f2_generates_digits (n k : Nat) (testn := find_f1_eq_f2 n k) :\n  ∃ m : Nat, ∀ d : Nat, d < k → ∃ i : Nat, i ≤ m ∧ appears_in d (testn * i) :=\nsorry\n\ntheorem find_f1_eq_f2_basic_case_2 :\n  find_f1_eq_f2 1750 6 = 1799 :=\nsorry\n\ntheorem find_f1_eq_f2_greater_than_input (n k : Nat) :\n  find_f1_eq_f2 n k ≥ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 547\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 542 5\n\n/--\ninfo: 1799\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 1750 6\n\n/--\ninfo: 14996\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 14990 7"}
{"id": "fvapps_003415", "vc-description": "/-\nYour task is to construct a building which will be a pile of n cubes.\nThe cube at the bottom will have a volume of n^3, the cube above \nwill have  volume of (n-1)^3 and so on until the top which will have a volume of 1^3.\n\nYou are given the total volume m of the building.\nBeing given m can you find the number n of cubes you will have to build?\n\nThe parameter of the function findNb `(find_nb, find-nb, findNb)` will be an integer m\nand you have to return the integer n such as\nn^3 + (n-1)^3 + ... + 1^3 = m\nif such a n exists or -1 if there is no such n.\n\n## Examples:\n```\nfindNb(1071225) --> 45\nfindNb(91716553919377) --> -1\n```\n-/\n\n/- For small perfect cubes (n ≤ 10), find_nb correctly returns n when given sum of first n cubes -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any volume that isn't sum of consecutive cubes, find_nb returns -1 -/\n\n/- find_nb returns -1 for non-positive inputs -/\n\n/- For valid inputs, find_nb returns a positive number that produces the input volume -/\n\n/- Any positive result from find_nb produces the claimed volume -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_nb (n : Int) : Int :=\nsorry\n\ndef sum_cubes (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem find_nb_small_perfect_cubes (n : Nat) (h : n ≤ 10) :\n  find_nb (sum_cubes n) = n :=\nsorry\n\ntheorem find_nb_invalid_volumes {n : Int} (h : n > 0) :\n  find_nb n = -1 ∨ sum_cubes (find_nb n).toNat = n :=\nsorry\n\ntheorem find_nb_nonpositive {n : Int} (h : n ≤ 0) :\n  find_nb n = -1 :=\nsorry\n\ntheorem find_nb_valid_result (n : Nat) :\n  let volume := sum_cubes n\n  let result := find_nb volume\n  result > 0 ∧ sum_cubes result.toNat = volume :=\nsorry\n\ntheorem find_nb_produces_volume {n : Int} (h : find_nb n > 0) :\n  sum_cubes (find_nb n).toNat = n :=\nsorry", "vc-postamble": "/--\ninfo: 45\n-/\n#guard_msgs in\n#eval find_nb 1071225\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_nb 91716553919377\n\n/--\ninfo: 2022\n-/\n#guard_msgs in\n#eval find_nb 4183059834009"}
{"id": "fvapps_003418", "vc-description": "/-\nThis kata is based on a [variation](https://www.codewars.com/kata/happy-numbers-5) of *Happy Numbers* by TySlothrop. It is advisable to complete it first to grasp the idea and then move on to this one.\n\n___\n\nHello, my dear friend, and welcome to another *Happy Numbers* kata! What? You're not interested in them anymore? They are all the same? But what if I say that this one is a *performance version*...  \n\n___\n\n# Your task:\n\nWrite a function `performant_numbers` which takes a number `n` as an argument and returns a list of all *happy numbers* from `1` to `n` inclusive. For example:\n\n```\nperformant_numbers(10)   =>  [1, 7, 10]\nperformant_numbers(50)   =>  [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49]\nperformant_numbers(100)  =>  [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100]\n```\n\n# Test suite:\n\n* `5000` tests with number `n` being up to `300000`\n* The reference solution takes around `4.9` seconds to calculate the result\n* you are not allowed to hardcode the sequence: you'll have to compute it (max length of the code: 1700 characters)\n\n___\n\nWill you take up the challenge?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_dig (n: Nat) : Nat :=\nsorry\n\ndef is_happy (n: Nat) : Bool :=\nsorry\n\ndef performant_numbers (n: Nat) : List Nat :=\nsorry", "vc-theorems": "theorem sum_dig_nonnegative (n: Nat) :\n  sum_dig n ≥ 0 :=\nsorry\n\ntheorem sum_dig_upper_bound (n: Nat) (k: Nat) :\n  sum_dig n ≤ k * 81 :=\nsorry\n\ntheorem is_happy_bool_result (n: Nat) :\n  is_happy n = true ∨ is_happy n = false :=\nsorry\n\ntheorem known_happy_numbers (n: Nat) :\n  n = 1 ∨ n = 7 ∨ n = 10 ∨ n = 13 ∨ n = 19 ∨ n = 23 ∨ n = 28 ∨ n = 31 →\n  is_happy n = true :=\nsorry\n\ntheorem known_unhappy_numbers (n: Nat) :\n  n = 2 ∨ n = 3 ∨ n = 4 ∨ n = 5 ∨ n = 6 ∨ n = 8 ∨ n = 9 →\n  is_happy n = false :=\nsorry\n\ntheorem performant_numbers_sorted (n: Nat) :\n  let result := performant_numbers n\n  ∀ i < result.length - 1,\n    result[i]! ≤ result[i+1]! :=\nsorry\n\ntheorem performant_numbers_bounded (n: Nat) :\n  ∀ x ∈ performant_numbers n, x ≤ n :=\nsorry\n\ntheorem performant_numbers_contains_happy (n: Nat) :\n  ∀ x ∈ [1, 7, 10, 13, 19, 23, 28, 31],\n    x ≤ n → x ∈ performant_numbers n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 7, 10]\n-/\n#guard_msgs in\n#eval performant_numbers 10\n\n/--\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49]\n-/\n#guard_msgs in\n#eval performant_numbers 50\n\n/--\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100]\n-/\n#guard_msgs in\n#eval performant_numbers 100"}
{"id": "fvapps_003426", "vc-description": "/-\nA country has coins with denominations\n```python\ncoins_list = d1 < d2 < · · · < dn.\n```\nYou want to make change for n cents, using the smallest number of coins.\n\n```python\n# Example 1: U.S. coins\nd1 = 1 d2 = 5 d3 = 10 d4 = 25\n\n## Optimal change for 37 cents – 1 quarter, 1 dime, 2 pennies.\n\n# Example 2: Alien Planet Z coins\nZ_coin_a = 1 Z_coin_b = 3 Z_coin_c = 4\n\n## Optimal change for 6 cents - 2 Z_coin_b's\n```\n\nWrite a function that will take a list of coin denominations and a desired amount and provide the least amount of coins needed.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def looseChange (coins: List Nat) (amount: Nat) : Int :=\n  sorry\n\ndef listMin (l: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem looseChange_result_bound (coins: List Nat) (amount: Nat) :\n  coins.length > 0 → let result := looseChange coins amount\n  result ≥ -1 := by\nsorry\n\ntheorem looseChange_zero (coins: List Nat) :\n  coins.length > 0 → looseChange coins 0 = 0 := by\nsorry\n\ntheorem looseChange_small_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  amount > 0 →\n  amount < listMin coins →\n  looseChange coins amount = -1 := by\nsorry\n\ntheorem looseChange_bounded_by_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  looseChange coins amount ≠ -1 →\n  looseChange coins amount ≤ amount := by\nsorry\n\ntheorem looseChange_optimal (coins: List Nat) (amount: Nat) :\n  coins.length > 0 →\n  let result := looseChange coins amount\n  result ≠ -1 →\n  ∀ (c : Nat),\n  c ∈ coins →\n  ¬∃ (n : Nat), n > result ∧ n * c = amount := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval loose_change [1, 5, 10, 25] 37\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval loose_change [1, 3, 4] 6\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval loose_change [25, 5, 10, 1, 21] 63"}
{"id": "fvapps_003429", "vc-description": "/-\nDefine a \"prime prime\" number to be a rational number written as one prime number over another prime number: `primeA / primeB` (e.g. `7/31`)\n\nGiven a whole number `N`, generate the number of \"prime prime\" rational numbers less than 1, using only prime numbers between `0` and `N` (non inclusive).\n\nReturn the count of these \"prime primes\", and the integer part  of their sum.\n\n## Example\n\n```python\nN = 6\n\n# The \"prime primes\" less than 1 are:\n2/3, 2/5, 3/5               # count: 3\n\n2/3 + 2/5 + 3/5 = 1.6667    # integer part: 1\n\nThus, the function should return 3 and 1.\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sieve (n : Nat) : List Nat :=\nsorry\n\ndef prime_primes (n : Nat) : Nat × Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem sieve_sorted (n : Nat) (h : n ≥ 2) :\n  let primes := sieve n\n  ∀ i h1 h2, primes.get ⟨i, h1⟩ < primes.get ⟨i+1, h2⟩ :=\nsorry\n\ntheorem prime_primes_nonneg (n : Nat) (h : n ≥ 2) :\n  let (count, total) := prime_primes n\n  count ≥ 0 ∧ total ≥ 0 :=\nsorry\n\ntheorem prime_primes_small_bound (n : Nat) (h : n ≥ 2) (h2 : n ≤ 10) :\n  let (count, _) := prime_primes n\n  count ≤ n * n / 2 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003432", "vc-description": "/-\nIn this kata, we want to discover a small property of numbers. \nWe say that a number is a **dd** number if it contains d occurences of a digit d, (d is in [1,9]).\n\n## Examples\n\n* 664444309 is a **dd** number, as it contains 4 occurences of the number 4\n* 30313, 122 are **dd** numbers as they respectively contain 3 occurences of the number 3, and (1 occurence of the number 1 AND 2 occurences of the number 2)\n* 123109, 0, 56542 are not **dd** numbers\n\n## Task \n\nYour task is to implement a function called `is_dd` (`isDd` in javascript) that takes a **positive** number (type depends on the language) and returns a boolean corresponding to whether the number is a **dd** number or not.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_dd (n : Nat) : Bool :=\nsorry\n\ndef countDigit (n : Nat) (d : Nat) : Nat :=\nsorry\n\ndef digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem dd_characterization (n : Nat) :\n  is_dd n = (∃ d : Nat, 1 ≤ d ∧ d ≤ 9 ∧ countDigit n d = d) :=\nsorry\n\ntheorem zero_not_counted (n : Nat) :\n  (∀ d : Nat, d ≠ 0 → countDigit n d ≠ d) →\n  is_dd n = false :=\nsorry\n\ntheorem count_digit_bounds (n d : Nat) :\n  countDigit n d ≤ (digits n).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 664444309\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 122\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 30313\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_dd 5023011"}
{"id": "fvapps_003438", "vc-description": "/-\n# Task\n You are given a regular array `arr`. Let's call a `step` the difference between two adjacent elements. \n\n Your task is to sum the elements which belong to the sequence of consecutive elements of length `at least 3 (but as long as possible)`, such that the steps between the elements in this sequence are the same.\n\n Note that some elements belong to two sequences and have to be counted twice.\n\n# Example\n\n For `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]`, the output should be `639`.\n```\nThere are 4 sequences of equal steps in the given array:\n{54, 70, 86} => step +16\n{1, -2, -5} => step -3\n{-5, 0, 5} => step +5\n{78, 145, 212} => step +67\nSo the answer is \n(54 + 70 + 86) + \n(1 - 2 - 5) + \n(-5 + 0 + 5) + \n(78 + 145 + 212) = 639.\nThe last element 15 was not be counted.\n```\n\n For `arr = [7, 2, 3, 2, -2, 400, 802]`, the output should be `1200`.\n ```\n There is only 1 sequence in arr:\n {-2, 400, 802} => step +402\n So the answer is: -2 + 400 + 802 = 1200\n ```\n\n For `arr = [1, 2, 3, 4, 5]`, the output should be `15`.\n\n Note that we should only count {1, 2, 3, 4, 5} as a whole, any other small subset such as {1, 2, 3},{2, 3, 4},{3, 4, 5} are belong to {1, 2, 3, 4, 5}.\n\n# Input/Output\n\n - `[input]` array.integer `arr`\n\n `3 ≤ arr.length ≤ 100`\n\n - `[output]` an integer\n\n The sum of sequences.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isArithmeticSequence (arr : List Int) : Bool :=\n  sorry\n\ndef sumOfRegularNumbers (arr : List Int) : Int :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem regular_numbers_properties {arr : List Int} (h : arr.length ≥ 3) :\n  let result := sumOfRegularNumbers arr\n  (result ≥ 0 ∨ (result < 0 ∧ ∃ x ∈ arr, x < 0)) ∧\n  (result ≠ 0 → ∃ i, i + 2 < arr.length ∧\n    isArithmeticSequence (arr.take 3))\n  :=\nsorry\n\ntheorem three_element_sequence {arr : List Int} (h : arr.length = 3) :\n  let d₁ := arr[0]! - arr[1]!\n  let d₂ := arr[1]! - arr[2]!\n  d₁ = d₂ → sumOfRegularNumbers arr = sum arr ∧\n  d₁ ≠ d₂ → sumOfRegularNumbers arr = 0 :=\nsorry\n\ntheorem non_overlapping_sequences {arr : List Int} (h : arr.length ≥ 4) :\n  let result := sumOfRegularNumbers arr\n  result > 0 →\n  ∃ i, i + 2 < arr.length ∧\n  (arr[i]! - arr[i+1]! = arr[i+1]! - arr[i+2]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 639\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]\n\n/--\ninfo: 1200\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [7, 2, 3, 2, -2, 400, 802]\n\n/--\ninfo: -13994\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [-1, 7000, 1, -6998, -13997]"}
{"id": "fvapps_003445", "vc-description": "/-\nThe __Hamming weight__ of a string is the number of symbols that are different from the zero-symbol of the alphabet used. There are several algorithms for efficient computing of the Hamming weight for numbers. In this Kata, speaking technically, you have to find out the number of '1' bits in a binary representation of a number. Thus,\n\nThe interesting part of this task is that you have to do it *without* string operation (hey, it's not really interesting otherwise)\n\n ;)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hammingWeight (n: Nat) : Nat :=\nsorry\n\ndef bitLength (n: Nat) : Nat :=\nsorry\n\ndef isPowerOfTwo (n: Nat) : Bool :=\nsorry", "vc-theorems": "theorem hamming_weight_nonnegative_and_bounded (x: Nat) :\n  hammingWeight x ≥ 0 ∧ hammingWeight x ≤ bitLength x :=\nsorry\n\ntheorem hamming_weight_power_of_two (x: Nat) :\n  x > 0 → isPowerOfTwo x → hammingWeight x = 1 :=\nsorry\n\ntheorem hamming_weight_zero_and_nonzero (x: Nat) :\n  hammingWeight 0 = 0 ∧ (x > 0 → hammingWeight x > 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval hamming_weight 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 1\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_weight 10\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_weight 21\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2048"}
{"id": "fvapps_003446", "vc-description": "/-\nOK, my warriors! Now that you beat the big BOSS, you can unlock three new skills. (Does it sound like we're playing an RPG? ;-)\n\n## The Arrow Function (JS only)\n\nThe first skill is the arrow function. Let's look at some examples to see how it works:\n\n```python\n#ignore this part, it is just for JS\n```\nAs you can see, its syntax is:\n\n```python\n#ignore this part, it is just for JS\n```\nIf only one parameter exists on the left side of the arrow, the bracket can be omitted. If only one expression exists on the right side of the arrow, the curly braces can also be omitted. The example below shows a function with the () and {} omitted.\n\n```python\n#ignore this part, it is just for JS\n```\nIf the right side of the arrow is a complex statement, you must use curly braces:\n\n```python\n#ignore this part, it is just for JS\n```\nSo far, our examples have used function assignment. However, an arrow function can also be used as a parameter to a function call, as well. When used as a parameter, the arrow function does not require a name. Let's rewrite the string.replace() example we saw from a previous training using our new skill:\n\n```python\n#ignore this part, it is just for JS\n```\nString.replace takes a regular expression and a function. The function is invoked on each substring matching the regex, and return the string replacement of that match. In this case, the arrow function takes the matched string as the parameter ```x```, and returns the upper cased value of ```x```.\n\nIn the soon to learn the arrayObject and its methods, there are many applications on the arrow function, which is the reason we first learn the arrow function. The arrow function has more complex usage and usage restrictions, but we don't need to learn to be so deep, so we only learn the contents of the above.\n\n## The Spread Operator\n\nThe second skill is the ```spread operator```. The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) are expected.\n\nIt looks like this: ...obj. It can be used in three places:\n\n1\\. In function calls:\n\n```python\ndef plus(a,b,c,d,e): return a+b+c+d+e\n\narg1=[1,2,3,4,5]\narg2=[2,3]\nprint plus(...arg1) #output is 15\nprint plus(...arg2) #output is 5\n```\n```...arg1``` spreads all the elements in arg1 into individual parameters to plus(). \nIn Javascript, it's also possible to use the spread operator in the middle of a parameter list, as was done with ```...arg2```.\n\n2\\. Creating array literals (JS and Ruby):\n```python\n#ignore this part, it is just for JS and Ruby\n```\n```...a``` spreads out the array's elements, making them individual elements in b.\n\n3\\. Used for ```deconstruction```. destructuring is also a new member of ES6. It is the third skill we learn in this training.\n\nFirst, let's look at a simple example of destructuring:\n```python\na,b=[1,2] #or [a,b]=[1,2]\nprint a #output is 1\nprint b #output is 2\n```\nDestructuring allows us to assign variables in a sentence-like form. Here's a slightly more complicated example:\n```python\na,b=[1,2] #or [a,b]=[1,2]\n#old way to swap them:\n#c=a; a=b; c=b\nb,a=[a,b] #or [b,a]=[a,b]\nprint a #output is 2\nprint b #output is 1\n```\nWith destructuring, we don't need a temporary variable to help us exchange the two values.\n\nYou can use the spread operator for destructuring like this:\n\n```python\n#ignore this part, it is just for JS\n```\nPlease note: the spread operator must  be the last variable: ```[...a,b]=[1,2,3,4,5]``` does not work.\n\n```a``` was assigned to the first element of the array, and``` b ```was initialized with the remaining elements in the array.\n\nJavascript note: If you see an ellipse ... in the argument list in a function declaration, it is not a spread operator, it is a structure called rest parameters. The rest parameter syntax allows us to represent an indefinite number of arguments as an array, like this:\n\n```python\ndef plus(*num):\n  rs=0\n  for x in num: rs+=x\n  return rs\nprint plus(1,2) #output is 3\nprint plus(3,4,5) #output is 12\n```\nThe rest paramater must be the last argument in the function definition argument list.\n\nIn the next example, we use a rest parameter to collect all the values passed to mul() after the first into an array. We then multiply each of them by the first parameter and return that array:\n```python\ndef mul(a,*b):\n  b=list(b) #default type would be tuple\n  for i in xrange(len(b)): b[i]*=a\n  return b\nprint mul(2,1,1,1) #output is [2,2,2]\nprint mul(2,1,2,3,4) #output is [2,4,6,8]\n```\n\nOk, the lesson is over. Did you get it all? Let's do a task, now.\n\n## Task\n\nCreate a function ```shuffleIt```. The function accepts two or more parameters. The first parameter arr is an array of numbers, followed by an arbitrary number of numeric arrays. Each numeric array contains two numbers, which are indices for elements in arr (the numbers will always be within bounds). For every such array, swap the elements. Try to use all your new skills: arrow functions, the spread operator, destructuring, and rest parameters.\n\nExample:\n```\nshuffleIt([1,2,3,4,5],[1,2]) should return [1,3,2,4,5]\nshuffleIt([1,2,3,4,5],[1,2],[3,4]) should return [1,3,2,5,4]\nshuffleIt([1,2,3,4,5],[1,2],[3,4],[2,3]) should return [1,3,5,2,4]\n```\n\n[Next training (#23 Array Methods) >>](http://www.codewars.com/kata/572af273a3af3836660014a1)\n\n## [Series](http://github.com/myjinxin2015/Katas-list-of-Training-JS-series)\n\n( ↑↑↑ Click the link above can get my newest kata list, Please add it to your favorites)\n\n - [#1: create your first JS function helloWorld](http://www.codewars.com/kata/571ec274b1c8d4a61c0000c8)\n - [#2: Basic data types--Number](http://www.codewars.com/kata/571edd157e8954bab500032d)\n - [#3:  Basic data types--String](http://www.codewars.com/kata/571edea4b625edcb51000d8e)\n - [#4:  Basic data types--Array](http://www.codewars.com/kata/571effabb625ed9b0600107a)\n - [#5:  Basic data types--Object](http://www.codewars.com/kata/571f1eb77e8954a812000837)\n - [#6:  Basic data types--Boolean and conditional statements if..else](http://www.codewars.com/kata/571f832f07363d295d001ba8)\n - [#7:  if..else and ternary operator](http://www.codewars.com/kata/57202aefe8d6c514300001fd)\n - [#8: Conditional statement--switch](http://www.codewars.com/kata/572059afc2f4612825000d8a)\n - [#9: loop statement --while and do..while](http://www.codewars.com/kata/57216d4bcdd71175d6000560)\n - [#10: loop statement --for](http://www.codewars.com/kata/5721a78c283129e416000999)\n - [#11: loop statement --break,continue](http://www.codewars.com/kata/5721c189cdd71194c1000b9b)\n - [#12: loop statement --for..in and for..of](http://www.codewars.com/kata/5722b3f0bd5583cf44001000)\n - [#13: Number object and  its properties](http://www.codewars.com/kata/5722fd3ab7162a3a4500031f)\n - [#14: Methods of Number object--toString() and toLocaleString()](http://www.codewars.com/kata/57238ceaef9008adc7000603)\n - [#15: Methods of Number object--toFixed(), toExponential() and toPrecision()](http://www.codewars.com/kata/57256064856584bc47000611)\n - [#16: Methods of String object--slice(), substring() and substr()](http://www.codewars.com/kata/57274562c8dcebe77e001012)\n - [#17: Methods of String object--indexOf(), lastIndexOf() and search()](http://www.codewars.com/kata/57277a31e5e51450a4000010)\n - [#18: Methods of String object--concat() split() and its good friend join()](http://www.codewars.com/kata/57280481e8118511f7000ffa)\n - [#19: Methods of String object--toUpperCase() toLowerCase() and replace()](http://www.codewars.com/kata/5728203b7fc662a4c4000ef3)\n - [#20: Methods of String object--charAt() charCodeAt() and fromCharCode()](http://www.codewars.com/kata/57284d23e81185ae6200162a)\n - [#21: Methods of String object--trim() and the string template](http://www.codewars.com/kata/5729b103dd8bac11a900119e)\n - [#22: Unlock new skills--Arrow function,spread operator and deconstruction](http://www.codewars.com/kata/572ab0cfa3af384df7000ff8)\n - [#23: methods of arrayObject---push(), pop(), shift() and unshift()](http://www.codewars.com/kata/572af273a3af3836660014a1)\n - [#24: methods of arrayObject---splice() and slice()](http://www.codewars.com/kata/572cb264362806af46000793)\n - [#25: methods of arrayObject---reverse() and sort()](http://www.codewars.com/kata/572df796914b5ba27c000c90)\n - [#26: methods of arrayObject---map()](http://www.codewars.com/kata/572fdeb4380bb703fc00002c)\n - [#27: methods of arrayObject---filter()](http://www.codewars.com/kata/573023c81add650b84000429)\n - [#28: methods of arrayObject---every() and some()](http://www.codewars.com/kata/57308546bd9f0987c2000d07)\n - [#29: methods of arrayObject---concat() and join()](http://www.codewars.com/kata/5731861d05d14d6f50000626)\n - [#30: methods of arrayObject---reduce() and reduceRight()](http://www.codewars.com/kata/573156709a231dcec9000ee8)\n - [#31: methods of arrayObject---isArray() indexOf() and toString()](http://www.codewars.com/kata/5732b0351eb838d03300101d)\n - [#32: methods of Math---round() ceil() and floor()](http://www.codewars.com/kata/5732d3c9791aafb0e4001236)\n - [#33: methods of Math---max() min() and abs()](http://www.codewars.com/kata/5733d6c2d780e20173000baa)\n - [#34: methods of Math---pow() sqrt() and cbrt()](http://www.codewars.com/kata/5733f948d780e27df6000e33)\n - [#35: methods of Math---log() and its family](http://www.codewars.com/kata/57353de879ccaeb9f8000564)\n - [#36: methods of Math---kata author's lover:random()](http://www.codewars.com/kata/5735956413c2054a680009ec)\n - [#37: Unlock new weapon---RegExp Object](http://www.codewars.com/kata/5735e39313c205fe39001173)\n - [#38: Regular Expression--\"^\",\"$\", \".\" and test()](http://www.codewars.com/kata/573975d3ac3eec695b0013e0)\n - [#39: Regular Expression--\"?\", \"*\", \"+\" and \"{}\"](http://www.codewars.com/kata/573bca07dffc1aa693000139)\n - [#40: Regular Expression--\"|\", \"[]\" and \"()\"](http://www.codewars.com/kata/573d11c48b97c0ad970002d4)\n - [#41: Regular Expression--\"\\\"](http://www.codewars.com/kata/573e6831e3201f6a9b000971)\n - [#42: Regular Expression--(?:), (?=) and (?!)](http://www.codewars.com/kata/573fb9223f9793e485000453)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shuffleIt {α : Type} : List α → List (Nat × Nat) → List α\n  | xs, swaps => sorry\n\ndef swapAt {α : Type} (xs : List α) (i j : Nat) (h₁ : i < xs.length) (h₂ : j < xs.length) : List α :=\n  sorry", "vc-theorems": "theorem shuffleIt_preserves_length {α : Type} (xs : List α) (swaps : List (Nat × Nat))\n  (h : ∀ p ∈ swaps, p.1 < xs.length ∧ p.2 < xs.length) :\n  (shuffleIt xs swaps).length = xs.length :=\nsorry\n\ntheorem shuffleIt_preserves_elements {α : Type} [BEq α] (xs : List α) (swaps : List (Nat × Nat))\n  (h : ∀ p ∈ swaps, p.1 < xs.length ∧ p.2 < xs.length) :\n  ∀ x, x ∈ xs ↔ x ∈ shuffleIt xs swaps :=\nsorry\n\ntheorem shuffleIt_no_swaps {α : Type} (xs : List α) :\n  shuffleIt xs [] = xs :=\nsorry\n\ntheorem shuffleIt_single_swap {α : Type} (xs : List α) (i j : Nat)\n  (h₁ : i < xs.length) (h₂ : j < xs.length) :\n  shuffleIt xs [(i,j)] = swapAt xs i j h₁ h₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 3, 2, 4, 5]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2]\n\n/--\ninfo: [1, 3, 2, 5, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4]\n\n/--\ninfo: [1, 3, 5, 2, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4] [2, 3]"}
{"id": "fvapps_003447", "vc-description": "/-\nYou have to create a function named reverseIt.\n\nWrite your function so that in the case a string or a number is passed in as the data , you will return the data in reverse order. If the data is any other type, return it as it is.\n\nExamples of inputs and subsequent outputs:\n```\n\"Hello\" -> \"olleH\"\n\n\"314159\" -> \"951413\"\n\n[1,2,3] -> [1,2,3]\n```\n-/\n\n/- Helper function to get nth char of string -/\n\n/- Type class for types that shouldn't be reversed -/", "vc-preamble": "def getNth (s : String) (n : Nat) : Char := s.data.get! n\n\nclass NonString (α : Type)", "vc-helpers": "", "vc-definitions": "def reverse_it {α : Type} (x : α) : α :=\nsorry", "vc-theorems": "theorem reverse_it_string_length {s : String} :\n  String.length (reverse_it s) = String.length s :=\nsorry\n\ntheorem reverse_it_string_reverses {s : String} {i : Nat} (h : i < String.length s) :\n  getNth (reverse_it s) i = getNth s (String.length s - 1 - i) :=\nsorry\n\ntheorem reverse_it_non_string_identity {α : Type} [NonString α] (x : α) :\n  reverse_it x = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'olleH'\n-/\n#guard_msgs in\n#eval reverse_it \"Hello\"\n\n/--\ninfo: 951413\n-/\n#guard_msgs in\n#eval reverse_it 314159\n\n/--\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval reverse_it [1, 2, 3]"}
{"id": "fvapps_003449", "vc-description": "/-\nWorking from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.\n\nSimilarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.\n\nWe shall call a positive integer that is neither increasing nor decreasing a \"bouncy\" number; for example, 155349.\n\nClearly there cannot be any bouncy numbers below one-hundred, but just over half of the numbers below one-thousand (525) are bouncy. In fact, the least number for which the proportion of bouncy numbers first reaches 50% is 538.\n\nSurprisingly, bouncy numbers become more and more common and by the time we reach 21780 the proportion of bouncy numbers is equal to 90%.\n\n#### Your Task\n\nComplete the bouncyRatio function.\n\nThe input will be the target ratio.\n\nThe output should be the smallest number such that the proportion of bouncy numbers reaches the target ratio.\n\nYou should throw an Error for a ratio less than 0% or greater than 99%.\n\n**Source**\n\n  - https://projecteuler.net/problem=112\n\n**Updates**\n\n  - 26/10/2015: Added a higher precision test case.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef isBouncyStr (s : String) : Bool :=\nsorry\n\ndef bouncyRatio (n : Float) : Float :=\nsorry", "vc-theorems": "theorem bouncy_sequence_property {n : Nat} (h : n ≥ 100) (h2 : n ≤ 100000) :\n  isBouncyStr (toString n) = true →\n  ∃ i j : String.Pos, i < j ∧\n  ((toString n).get i < (toString n).get j) ∧\n  ∃ k l : String.Pos, k < l ∧\n  ((toString n).get k > (toString n).get l) :=\nsorry\n\ntheorem bouncy_ratio_validation_zero :\n  ¬ ∃ x : Float, x = bouncyRatio 0 :=\nsorry\n\ntheorem bouncy_ratio_validation_one :\n  ¬ ∃ x : Float, x = bouncyRatio 1 :=\nsorry\n\ntheorem bouncy_ratio_validation_negative (n : Float) :\n  n < 0 →\n  ¬ ∃ x : Float, x = bouncyRatio n :=\nsorry\n\ntheorem bouncy_ratio_validation_above_one (n : Float) :\n  n > 1 →\n  ¬ ∃ x : Float, x = bouncyRatio n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 538\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.5\n\n/--\ninfo: 21780\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.9\n\n/--\ninfo: 3088\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.75"}
{"id": "fvapps_003450", "vc-description": "/-\n# Definition (Primorial Of a Number)\n\n*Is similar to factorial of a number*, **_In primorial_**, not all the natural numbers get multiplied, **_only prime numbers are multiplied to calculate the primorial of a number_**. It's denoted with **_P_****_#_** and it is the product of the first n prime numbers.\n___ \n\n# Task\n\n**_Given_** *a number N* , **_calculate its primorial_**. ![!alt](https://i.imgur.com/mdX8dJP.png)  ![!alt](https://i.imgur.com/mdX8dJP.png)  \n___\n\n# Notes\n\n* **_Only positive_** numbers *will be passed (N > 0)* .\n___\n\n# Input >> Output Examples:\n\n``` cpp\n1- numPrimorial (3) ==> return (30)\n```\n\n## **_Explanation_**:\n\n**_Since_** *the passed number is (3)* ,**_Then_** **_the primorial_** *should obtained by multiplying*  ```2 * 3 * 5 = 30 .```\n\n### Mathematically written as , **_P_**3**_#_** = 30 .\n___ \n\n## **_Explanation_**:\n\n**_Since_** *the passed number is (5)* ,**_Then_** **_the primorial_** *should obtained by multiplying*  ``` 2 * 3 * 5 * 7 * 11 = 2310 .```\n\n### Mathematically written as , **_P_**5**_#_** = 2310 .\n___\n\n## **_Explanation_**: \n\n**_Since_** *the passed number is (6)* ,**_Then_** **_the primorial_** *should obtained by multiplying*  ``` 2 * 3 * 5 * 7 * 11 * 13 = 30030 .```\n\n### Mathematically written as , **_P_**6**_#_** = 30030 .\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef getFirstNPrimes (n : Nat) : List Nat :=\n  sorry\n\ndef numPrimorial (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem primorial_equals_product_of_first_n_primes (n : Nat)\n  (h : n ≥ 1 ∧ n ≤ 10) :\n  numPrimorial n = (getFirstNPrimes n).foldl (·*·) 1 :=\nsorry\n\ntheorem primorial_is_strictly_increasing {n : Nat}\n  (h1 : n ≥ 1 ∧ n ≤ 10) (h2 : n > 1) :\n  numPrimorial n > numPrimorial (n-1) :=\nsorry\n\ntheorem primorial_is_divisible_by_smaller_primorials {n : Nat}\n  (h1 : n ≥ 1 ∧ n ≤ 10) (h2 : n > 1) :\n  numPrimorial n % numPrimorial (n-1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval num_primorial 3\n\n/--\ninfo: 2310\n-/\n#guard_msgs in\n#eval num_primorial 5\n\n/--\ninfo: 9699690\n-/\n#guard_msgs in\n#eval num_primorial 8"}
{"id": "fvapps_003456", "vc-description": "/-\nBob has a server farm crunching numbers. He has `nodes` servers in his farm. His company has a lot of work to do. \n\nThe work comes as a number `workload` which indicates how many jobs there are. Bob wants his servers to get an equal number of jobs each. If that is impossible, he wants the first servers to receive more jobs. He also wants the jobs sorted, so that the first server receives the first jobs.\n\nThe way this works, Bob wants an array indicating which jobs are going to which servers.\n\nCan you help him distribute all this work as evenly as possible onto his servers?\n\nExample\n-------\n\nBob has `2` servers and `4` jobs. The first server should receive job 0 and 1 while the second should receive 2 and 3.\n\n```\ndistribute(2, 4) # => [[0, 1], [2, 3]]\n```\n\nOn a different occasion Bob has `3` servers and `3` jobs. Each should get just one.\n\n```\ndistribute(3, 3) # => [[0], [1], [2]]\n```\n\nA couple of days go by and Bob sees a spike in jobs. Now there are `10`, but he hasn't got more than `4` servers available. He boots all of them. This time the first and second should get a job more than the third and fourth.\n\n```\ndistribute(4, 10) # => [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n```\n\nInput\n-----\n\nDon't worry about invalid inputs. That is, `nodes > 0` and `workload > 0` and both will always be integers.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def distribute (nodes : Nat) (workload : Nat) : List (List Nat) :=\n  sorry\n\ndef listMaximum (l : List Nat) : Nat :=\n  sorry\n\ndef listMinimum (l : List Nat) : Nat :=\n  sorry\n\ndef listSum (l : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem distribute_length {nodes workload : Nat}\n  (h : nodes ≤ workload ∨ workload = 0) :\n  (distribute nodes workload).length = nodes :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [[0, 1], [2, 3]]\n-/\n#guard_msgs in\n#eval distribute 2 4\n\n/--\ninfo: [[0], [1], [2]]\n-/\n#guard_msgs in\n#eval distribute 3 3\n\n/--\ninfo: [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n-/\n#guard_msgs in\n#eval distribute 4 10"}
{"id": "fvapps_003460", "vc-description": "/-\nIn this Kata, you will be given an array of unique elements, and your task is to rerrange the values so that the first max value is followed by the first minimum, followed by second max value then second min value, etc. \n\nFor example:\nThe first max is `15` and the first min is `7`. The second max is `12` and the second min is `10` and so on. \n\nMore examples in the test cases. \n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (arr : List Int) : List Int :=\n  sorry\n\ndef list_max (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem solve_maintains_elements {arr : List Int} (h : arr ≠ []) :\n  let result := solve arr\n  result.length = arr.length ∧\n  ∀ x, (result.count x = arr.count x) :=\nsorry\n\ntheorem solve_alternates_high_low {arr : List Int} (h : arr.length ≥ 2) :\n  let result := solve arr\n  ∀ i, i + 1 < result.length → i % 2 = 0 →\n  (result.get ⟨i, sorry⟩) ≥ (result.get ⟨i+1, sorry⟩) :=\nsorry\n\ntheorem solve_first_element_is_max {arr : List Int} (h : arr ≠ []) :\n  let result := solve arr\n  ∀ i, i < result.length →\n  (result.get ⟨0, sorry⟩) ≥ (result.get ⟨i, sorry⟩) :=\nsorry\n\ntheorem solve_empty_and_single {arr : List Int} :\n  arr.length ≤ 1 → solve arr = arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [15, 11, 10, 7, 12]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [91, 75, 86, 14, 82]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [1, 6, 9, 4, 3, 7, 8, 2]"}
{"id": "fvapps_003461", "vc-description": "/-\nWrite a function that takes a string which has integers inside it separated by spaces, and your task is to convert each integer in the string into an integer and return their sum.\n\n### Example\n```python\nsummy(\"1 2 3\")  ==> 6\n```\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def summy (s : String) : Int :=\nsorry\n\ndef sum (l : List Int) : Int :=\nsorry\n\ndef stringToList (s : String) : List Int :=\nsorry", "vc-theorems": "theorem summy_matches_direct_sum (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \" \" (List.map toString l)) = sum l :=\nsorry\n\ntheorem summy_handles_whitespace (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \"   \" (List.map toString l)) = sum l :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval summy \"1 2 3\"\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval summy \"10 10\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval summy \"0 0\""}
{"id": "fvapps_003462", "vc-description": "/-\nYou are a biologist working on the amino acid  composition of proteins. Every protein consists of a long chain of 20 different amino acids with different properties. \nCurrently, you are collecting data on the percentage, various amino acids make up a protein you are working on. As manually counting the occurences of amino acids takes too long (especially when counting more than one amino acid), you decide to write a program for this task:\n\nWrite a function that takes two arguments,\n 1. A (snippet of a) protein sequence\n 2. A list of amino acid residue codes \n\nand returns the rounded percentage of the protein that the given amino acids make up. \nIf no amino acid list is given, return the percentage of hydrophobic amino acid residues [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"].\n-/", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def aa_percentage (seq : String) (residues : List Char := ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) : Nat :=\nsorry", "vc-theorems": "theorem default_residues_in_bounds (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  0 ≤ aa_percentage seq ∧ aa_percentage seq ≤ 100 :=\nsorry\n\ntheorem custom_residues_in_bounds (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  0 ≤ aa_percentage seq residues ∧ aa_percentage seq residues ≤ 100 :=\nsorry\n\ntheorem empty_residues_gives_zero (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq [] = 0 :=\nsorry\n\ntheorem residue_count_matches (seq : String) (residues : List Char)\n  (h1 : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : ∀ c ∈ residues, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  aa_percentage seq residues =\n    ((sum_list (residues.map (λ r => seq.data.count r))) * 100 + seq.length / 2) / seq.length :=\nsorry\n\ntheorem default_residues_consistent (seq : String)\n  (h : ∀ c ∈ seq.data, c ∈ ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq = aa_percentage seq ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V'] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval aa_percentage \"MSRSLLLRFLLFLLLLPPLP\" [\"M\"]\n\n/--\ninfo: 29\n-/\n#guard_msgs in\n#eval aa_percentage \"RLMADDFFGQTLMAAAAAAQERRR\" [\"A\"]\n\n/--\ninfo: 50\n-/\n#guard_msgs in\n#eval aa_percentage \"PLPPLPLLEELELRPFFMAAGGTPLAMMGG\""}
{"id": "fvapps_003465", "vc-description": "/-\nI have started studying electronics recently, and I came up with a circuit made up of 2 LEDs and 3 buttons.\n\nHere 's how it works: 2 buttons (`red` and `blue`) are connected to the LEDs (`red` and `blue` respectively). Buttons pressing pattern will be remembered and represented through the LEDs when the third button is pressed.\n\n - Only one LED can blink at a time.\n - The LED will only blink once even if the button is held down.\n - The button must be released to be pressed again.\n - If a button is pressed while the other button is being held down, it will be ignored.\n - If two buttons are pressed simultaneously, the red button will be preferred.\n - If a button is released while the other is being held down, the other 's LED will blink.\n - `0` is up and `1` is down.\n - The two inputs will always have the same length.\n\nHere is an example:\n\n```Python\nRed:  \"10011010\"\nBlue: \"10110111\"\n#=> \"RBRB\"\n\nRed:  \"01001000\"\nBlue: \"01011100\"\n#=> \"RB\"\n\nRed:  \"01101000\"\nBlue: \"00111000\"\n#=> \"RB\"\n```\n\nPS:\n\nThis is my first time making a kata, so there may be some errors. \nYou may report to me if the description is too confusing. \nSorry for my poor grammar.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def seqR : String → Bool :=\n  sorry\n\ndef seqB : String → Bool :=\n  sorry\n\ndef button_sequences (r : String) (b : String) : String :=\n  sorry", "vc-theorems": "theorem button_sequences_valid_chars (r b : String) (h : r.length > 0 ∧ b.length > 0) :\n  ∀ c, c ∈ (button_sequences r b).toList → c = 'R' ∨ c = 'B' :=\nsorry\n\ntheorem button_sequences_length (r b : String) (h : r.length > 0 ∧ b.length > 0) :\n  (button_sequences r b).length ≤ min r.length b.length :=\nsorry\n\ntheorem button_sequences_all_zeros_red (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  ∀ c, c ∈ (button_sequences s zeros).toList → c = 'R' :=\nsorry\n\ntheorem button_sequences_all_zeros_blue (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  ∀ c, c ∈ (button_sequences zeros s).toList → c = 'B' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'RBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10011010\" \"10110111\"\n\n/--\ninfo: 'RB'\n-/\n#guard_msgs in\n#eval button_sequences \"01001000\" \"01011100\"\n\n/--\ninfo: 'RBRBRBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10101010\" \"01010101\""}
{"id": "fvapps_003471", "vc-description": "/-\nYour job is to change the given string `s` using a non-negative integer `n`.\n\nEach bit in `n` will specify whether or not to swap the case for each alphabetic character in `s`: if the bit is `1`, swap the case; if its `0`, leave it as is. When you finished with the last bit of `n`, start again with the first bit.\n\nYou should skip the checking of bits when a non-alphabetic character is encountered, but they should be preserved in their original positions.\n\n## Examples\n\n```\nswap('Hello world!', 11)  -->  'heLLO wORLd!'\n```\n...because `11` is `1011` in binary, so the 1st, 3rd, 4th, 5th, 7th, 8th and 9th alphabetical characters have to be swapped:\n```\nH e l l o  w o r l d !\n1 0 1 1 1  0 1 1 1 0\n^   ^ ^ ^    ^ ^ ^\n```\n\nMore examples:\n```\nswap(\"gOOd MOrniNg\", 7864)  -->  \"GooD MorNIng\"\nswap('', 11345)  -->  ''\nswap('the lord of the rings', 0)  -->  'the lord of the rings'\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\n  sorry\n\ndef swap (s : String) (n : Nat) : String :=\n  sorry\n\ndef swapcase (c : Char) : Char :=\n  sorry", "vc-theorems": "theorem swap_length_preserved (s : String) (n : Nat) :\n  (swap s n).length = s.length :=\nsorry\n\ntheorem swap_nonalpha_preserved (s : String) (n : Nat) (pos : String.Pos) :\n  ¬isAlpha (s.get pos) → (swap s n).get pos = s.get pos :=\nsorry\n\ntheorem swap_alpha_case (s : String) (n : Nat) (pos : String.Pos) :\n  isAlpha (s.get pos) →\n  (s.get pos).toLower = ((swap s n).get pos).toLower :=\nsorry\n\ntheorem swap_zero_identity (s : String) :\n  swap s 0 = s :=\nsorry\n\ntheorem swap_pattern_matches_binary (s : String) (n : Nat) (pos : String.Pos)\n    (binPattern : String) (idx : String.Pos) :\n  isAlpha (s.get pos) →\n  binPattern = (toString n).dropWhile (· = '0') →\n  (binPattern.get idx = '1' →\n    (swap s n).get pos = swapcase (s.get pos)) ∧\n  (binPattern.get idx = '0' →\n    (swap s n).get pos = s.get pos) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'heLLO wORLd!'\n-/\n#guard_msgs in\n#eval swap \"Hello world!\" 11\n\n/--\ninfo: 'GooD MorNIng'\n-/\n#guard_msgs in\n#eval swap \"gOOd MOrniNg\" 7864\n\n/--\ninfo: 'the lord of the rings'\n-/\n#guard_msgs in\n#eval swap \"the lord of the rings\" 0"}
{"id": "fvapps_003472", "vc-description": "/-\nConsider X as the  aleatory  variable that count the number of letters in a word. Write a function that, give in input an array of words (strings), calculate the  variance  of X.\nMax decimal of the variance : 4.\n\nSome wiki: Variance ,\n Aleatory variable \n\nExample:\n\nConsider \"Hello\" and \"World\":\n\nX is { 5 } with P(X = 5) = 1 beacuse the two words has the same length.  \nSo E[X] = 5 x 1 = 5 and the standard formula for variance is E[(X - u)^2] so  1 x (5-5)^2 = 0\nor you can calculate with the other formula E[X^2] - E[X]^2 = 5^2 x 1 - 5^2 = 0\n\nConsider \"Hi\" and \"World\":\n\nX is { 2, 5 } with P(X = 5) = 1/2 and P(X = 2) = 1/2.  \nSo E[X] = 5 x 1/2 + 2 x 1/2 = 3.5 and the standard formula for variance is E[(X - u)^2] so  1/2 x (2-3.5)^2 + 1/2 x (5 - 3.5)^2 = 2.25\nor you can calculate with the other formula E[X^2] - E[X]^2 = (5^2 x 1/2 + 2^2 x 1/2) - 3.5^2 = 2.25\n-/\n\n/- Our variance function -/\n\n/- Our variance matches statistics.pvariance -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Words of same length have variance 0 -/\n\n/- Variance is always nonnegative -/\n\n/- Empty list raises error -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pvariance (xs : List String) : Float :=\nsorry\n\ndef variance (xs : List String) : Float :=\nsorry", "vc-theorems": "theorem variance_matches_pvariance (words : List String) (h : words ≠ []) :\n  variance words = pvariance words :=\nsorry\n\ntheorem same_length_zero_variance (words : List String) (h1 : words ≠ [])\n  (h2 : ∀ w ∈ words, w.length = 5) : variance words = 0 :=\nsorry\n\ntheorem variance_nonnegative (words : List String) (h : words.length ≥ 2) :\n  variance words ≥ 0 :=\nsorry\n\ntheorem empty_list_error :\n  variance [] = 0/0 :=\nsorry", "vc-postamble": "/--\ninfo: 0\n-/\n#guard_msgs in\n#eval variance [\"Hello\", \"world\"]\n\n/--\ninfo: 2.25\n-/\n#guard_msgs in\n#eval variance [\"Hi\", \"world\"]\n\n/--\ninfo: 7.5556\n-/\n#guard_msgs in\n#eval variance [\"Variance\", \"is\", \"not\", \"a\", \"good\", \"stimator\"]"}
{"id": "fvapps_003473", "vc-description": "/-\nHappy traveller [Part 1]\n\nThere is a play grid NxN; Always square! \n\n   0  1  2  3\n0 [o, o, o, X]\n1 [o, o, o, o]\n2 [o, o, o, o]\n3 [o, o, o, o]\n\nYou start from a random point. I mean, you are given the coordinates of your start position in format (row, col). \n\nAnd your TASK is to define the number of unique paths to reach position X (always in the top right corner).\n\nFrom any point you can go only UP or RIGHT.\n\nImplement a function count_paths(N, (row, col)) which returns int; \nAssume input params are always valid.\n\nExample:\n\ncount_paths(1, (0, 0))\ngrid 1x1:\n\n[X]\n You are already in the target point, so return 0\n\ncount_paths(2, (1, 0))\ngrid 2x2:\n\n[o, X]\n[@, o]\n You are at point @; you can move UP-RIGHT or RIGHT-UP, and there are 2 possible unique paths here\n\ncount_paths(2, (1, 1))\ngrid 2x2:\n\n[o, X]\n[o, @]\n You are at point @; you can move only UP, so there is 1 possible unique path here\n\ncount_paths(3, (1, 0))\ngrid 3x3:\n\n[o, o, X]\n[@, o, o]\n[o, o, o]\n You are at point @; you can move UP-RIGHT-RIGHT or RIGHT-UP-RIGHT, or RIGHT-RIGHT-UP, and there are 3 possible unique paths here\n\nI think it's pretty clear =)\n\nbtw. you can use preloaded Grid class, which constructs 2d array for you. It's very very basic and simple. You can use numpy instead or any other way to produce the correct answer =)\n grid = Grid(2, 2, 0) \nsamegrid = Grid.square(2) will give you a grid[2][2], which you can print easily to console. \n\nprint(grid)\n\n[0, 0]\n[0, 0]\n\nEnjoy!\n\nYou can continue adventures:\nHappy traveller [Part 2]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose (n m : Nat) : Nat :=\n  sorry\n\ndef count_paths (n: Nat) (start_pos: Nat × Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_paths_one_by_one {n: Nat} (h: n = 1) :\n  count_paths n (0, 0) = 0 :=\nsorry\n\ntheorem count_paths_non_negative {n row col: Nat} (h1: row < n) (h2: col < n) (h3: n > 0) :\n  count_paths n (row, col) ≥ 0 :=\nsorry\n\ntheorem count_paths_only_vertical {n row col: Nat} (h1: col = n - 1) (h2: row > 0) (h3: row < n) (h4: n > 0) :\n  count_paths n (row, col) = 1 :=\nsorry\n\ntheorem count_paths_only_horizontal {n row col: Nat} (h1: row = 0) (h2: col < n - 1) (h3: n > 0) :\n  count_paths n (row, col) = 1 :=\nsorry\n\ntheorem count_paths_start_equals_target {n: Nat} (h: n ≥ 2) :\n  count_paths n (0, n-1) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_paths 1 (0, 0)\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_paths 2 (1, 0)\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval count_paths 3 (1, 0)\n\n/--\ninfo: 70\n-/\n#guard_msgs in\n#eval count_paths 5 (4, 0)"}
{"id": "fvapps_003476", "vc-description": "/-\n## Problem\n\nThere are `n` apples that need to be divided into four piles. We need two mysterious number `x` and `y`. Let The number of first pile equals to `x+y`, the number of second pile equals to `x-y`, the number of third pile equals to `x*y`, the number of fourth pile equals to `x/y`. We need to calculate how many apples are there in each pile.\n\nOf course, there won't be so many unknowns. We know the total number of apples(`n`) and the second mysterious number(`y`). \n\nFor example: there are 48 apples need to divided into four piles. y=3. that is, 1st pile should be x+3, 2nd pile should be x-3, 3rd pile should be x*3, 4th pile should be x/3.\nDo you know how much `x` is? `x` should be 9, because:\n```\n(9 + 3) + (9 - 3) + (9 * 3) + (9 / 3) = 12 + 6 + 27 + 3 = 48\n```\nSo, 48 apples should be divided into `12, 6, 27, 3`.\n\n## Task\n\nComplete function `fourPiles()`/`four_piles()` that accepts two arguments `n` and `y`, return an array contains the number of for piles. Each element in the result array should be a positive integer. If can not divide, please return `[]`.\n\n## Examples\n\n```\nfourPiles 48 3 -- [12,6,27,3]  \n//The elements are arranged in sequence according to:\n//   x+y,x-y,x*y,x/y\n\nfourPiles 100 4 -- [20,12,64,4]  \n-- Verify correctness:\n-- x=16,y=4\n(16+4) + (16-4) + (16*4) + (16/4) -- 100\n\n-- Edge case:\nfourPiles 25 4  -- []  -- [8,0,16,1] is not a correct answer\n\nfourPiles 24 4  -- []  -- can not divide\n```\n-/\n\n-- Result has length 4\n\n-- Elements follow x+y, x-y, x*y, x/y pattern for some x\n\n-- Elements are positive\n\n-- Sum equals input n\n\n-- If no solution, divmod has remainder", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | (h :: t) => h + sum_list t\n\ndef nth : List Nat → Nat → Option Nat\n  | [], _ => none\n  | (h :: t), 0 => some h\n  | (h :: t), n+1 => nth t n", "vc-helpers": "", "vc-definitions": "def four_piles (n : Nat) (y : Nat) : Option (List Nat) :=\nsorry", "vc-theorems": "theorem four_piles_properties_solution (n y : Nat) (h1 : n > 0) (h2 : y > 0) (h3 : y ≤ 100) :\n  match four_piles n y with\n  | some result =>\n\n    result.length = 4 ∧\n\n    ∃ x : Nat,\n      (nth result 0 = some (x + y)) ∧\n      (nth result 1 = some (x - y)) ∧\n      (nth result 2 = some (x * y)) ∧\n      (nth result 3 = some (x / y)) ∧\n\n    (∀ i ∈ result, i > 0) ∧\n\n    sum_list result = n\n  | none =>\n\n    let prod := n * y\n    let denom := (y + 1) * (y + 1)\n    prod % denom ≠ 0 ∨ (prod / denom = y)\n  :=\nsorry\n\ntheorem four_piles_properties_positive (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => ∀ x ∈ result, x > 0\n  | none => True\n  :=\nsorry\n\ntheorem four_piles_properties_sum (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => sum_list result = n\n  | none => True\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [12, 6, 27, 3]\n-/\n#guard_msgs in\n#eval four_piles 48 3\n\n/--\ninfo: [20, 12, 64, 4]\n-/\n#guard_msgs in\n#eval four_piles 100 4\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval four_piles 25 4"}
{"id": "fvapps_003480", "vc-description": "/-\nWhile most devs know about [big/little-endianness](https://en.wikipedia.org/wiki/Endianness), only a selected few know the secret of real hard core coolness with mid-endians.\n\nYour task is to take a number and return it in its mid-endian format, putting the most significant couple of bytes in the middle and all the others around it, alternating left and right.\n\nFor example, consider the number `9999999`, whose hexadecimal representation would be `98967F` in big endian (the classic you get converting); it becomes `7F9698` in little-endian and `96987F` in mid-endian.\n\nWrite a function to do that given a positive integer (in base 10) and remembering that you need to pad with `0`s when you get a single hex digit!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mid_endian (n : Nat) : String :=\nsorry\n\ndef natToHexString (n : Nat) : String :=\nsorry\n\ndef splitInPairs (s : String) : List String :=\nsorry", "vc-theorems": "theorem mid_endian_idempotent_bytes (n : Nat) :\n  let result := mid_endian n\n  let pairs := splitInPairs result\n  String.join pairs = result :=\nsorry\n\ntheorem mid_endian_valid_hex (n : Nat) :\n  ∃ h, (mid_endian n).toNat? = some h :=\nsorry\n\ntheorem mid_endian_even_length (n : Nat) :\n  (mid_endian n).length % 2 = 0 :=\nsorry\n\ntheorem mid_endian_sufficient_length (n : Nat) :\n  (mid_endian n).length ≥ (natToHexString n).length :=\nsorry\n\ntheorem mid_endian_hex_chars (n : Nat) :\n  ∀ i : Fin (mid_endian n).length,\n    (mid_endian n).data.get i ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] :=\nsorry\n\ntheorem mid_endian_single_byte (n : Nat) (h : n ≤ 0xFF) :\n  mid_endian n = natToHexString n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '96987F'\n-/\n#guard_msgs in\n#eval mid_endian 9999999\n\n/--\ninfo: '00'\n-/\n#guard_msgs in\n#eval mid_endian 0\n\n/--\ninfo: '0B0A0C'\n-/\n#guard_msgs in\n#eval mid_endian 658188"}
{"id": "fvapps_003486", "vc-description": "/-\nIn number theory, Euler's totient is an arithmetic function, introduced in 1763 by Euler, that counts the positive integers less than or equal to `n` that are relatively prime to `n`. Thus, if `n` is a positive integer, then `φ(n)`, notation introduced by Gauss in 1801, is the number of positive integers `k ≤ n` for which `gcd(n, k) = 1`.  \nThe totient function is important in number theory, mainly because it gives the order of the multiplicative group of integers modulo `n`. The totient function also plays a key role in the definition of the RSA encryption system.\n\nFor example `let n = 9`.  \nThen `gcd(9, 3) = gcd(9, 6) = 3` and `gcd(9, 9) = 9`.  \nThe other six numbers in the range `1 ≤ k ≤ 9` i.e. `1, 2, 4, 5, 7, 8` are relatively prime to `9`.  \nTherefore, `φ(9) = 6`.  \nAs another example, `φ(1) = 1` since `gcd(1, 1) = 1`.\n\nThere are generally two approaches to this function:\n\n* Iteratively counting the numbers `k ≤ n` such that `gcd(n,k) = 1`.\n\n* Using the Euler product formula.  \n  This is an explicit formula for calculating `φ(n)` depending on the prime divisor of `n`:  \n  `φ(n) = n * Product (1 - 1/p)` where the product is taken over the primes `p ≤ n` that divide `n`.  \n  For example: `φ(36) = 36 * (1 - 1/2) * (1 - 1/3) = 36 * 1/2 * 2/3 = 12`.  \n  This second method seems more complex and not likely to be faster, but in practice we will often look for `φ(n)` with `n` prime. It correctly gives `φ(n) = n - 1` if `n` is prime. \n\nYou have to code the Euler totient function, that takes an integer `1 ≤ n` as input and returns `φ(n)`.\n\n```if:javascript\nYou do have to check if `n` is a number, is an integer and that `1 ≤ n`; if that is not the case, the function should return `0`.\n```\n\n```if:python\nYou do have to check if `n` is a number, is an integer and that `1 ≤ n`; if that is not the case, the function should return `0`.\n```\n\n```if:racket\n`n` is always a positive integer.\n```\n\nInput range: `1 ≤ n ≤ 1e10`\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def totient (n : Int) : Int :=\nsorry\n\ndef gcd (a b : Int) : Int :=\nsorry\n\ndef isPrime (n : Int) : Bool :=\nsorry\n\ndef isInt (n : Int) : Bool :=\nsorry\n\ndef countCoprimes (n : Int) : Int :=\nsorry", "vc-theorems": "theorem totient_matches_coprime_count (n : Int) (h : n > 0) :\n  totient n = countCoprimes n :=\nsorry\n\ntheorem totient_invalid_inputs (n : Int) (h : n ≤ 0) :\n  totient n = 0 :=\nsorry\n\ntheorem totient_multiplicative (n₁ n₂ : Int) (h₁ : gcd n₁ n₂ = 1) (h₂ : n₁ > 0) (h₃ : n₂ > 0) :\n  totient (n₁ * n₂) = totient n₁ * totient n₂ :=\nsorry\n\ntheorem totient_prime (p : Int) (h₁ : p > 1) (h₂ : isPrime p) :\n  totient p = p - 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003489", "vc-description": "/-\nYou get an array of different numbers to sum up. But there is one problem, those numbers all have different bases.\nFor example:\n```python\nYou get an array of numbers with their base as an input:\n\n[[\"101\",16],[\"7640\",8],[\"1\",9]]\n```\n\nThe output should be the sum as an integer value with a base of 10, so according to the example this would be:\n\n4258\n```python\nA few more examples:\n[[\"101\",2], [\"10\",8]] --> 13\n[[\"ABC\",16], [\"11\",2]] --> 2751\n```\nBases can be between 2 and 36 (2<=base<=36)\n-/", "vc-preamble": "def sumList (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def toBase (num base : Nat) : String :=\n  sorry\n\ndef sumItUp (nums : List (String × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem sum_it_up_equals_decimal_sum {nums : List (Nat × Nat)} :\n  ∀ pairs : List (String × Nat),\n  (∀ p : String × Nat, p ∈ pairs →\n    ∃ n ∈ nums, p.1 = toBase n.1 p.2) →\n  sumItUp pairs = sumList (nums.map Prod.fst) :=\nsorry\n\ntheorem sum_it_up_empty : sumItUp [] = 0 :=\nsorry\n\ntheorem sum_it_up_single {n : String} {b : Nat} :\n  b ≥ 2 → b ≤ 36 →\n  ∃ k : Nat, sumItUp [(n, b)] = k :=\nsorry\n\ntheorem base_conversion_roundtrip {n : Nat} {b : Nat} :\n  n ≤ 1000000 → b ≥ 2 → b ≤ 36 →\n  ∃ k : Nat, k = n ∧ String.toNat! (toBase n b) = k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 2], [\"10\", 8]]\n\n/--\ninfo: 2751\n-/\n#guard_msgs in\n#eval sum_it_up [[\"ABC\", 16], [\"11\", 2]]\n\n/--\ninfo: 4258\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 16], [\"7640\", 8], [\"1\", 9]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_it_up []"}
{"id": "fvapps_003503", "vc-description": "/-\nIn this Kata, you will be given a string with brackets and an index of an opening bracket and your task will be to return the index of the matching closing bracket.  Both the input and returned index are 0-based **except in Fortran where it is 1-based**. An opening brace will always have a closing brace. Return `-1` if there is no answer (in Haskell, return `Nothing`; in Fortran, return `0`; in Go, return an error)\n\n### Examples\n\n```python\nsolve(\"((1)23(45))(aB)\", 0) = 10 -- the opening brace at index 0 matches the closing brace at index 10\nsolve(\"((1)23(45))(aB)\", 1) = 3 \nsolve(\"((1)23(45))(aB)\", 2) = -1 -- there is no opening bracket at index 2, so return -1\nsolve(\"((1)23(45))(aB)\", 6) = 9\nsolve(\"((1)23(45))(aB)\", 11) = 14\nsolve(\"((>)|?(*'))(yZ)\", 11) = 14\n```\n\nInput will consist of letters, numbers and special characters, but no spaces. The only brackets will be `(` and `)`. \n\nMore examples in the test cases. \n\nGood luck!\n\n~~~if:fortran\n*NOTE: In Fortran, you may assume that the input string will not contain any leading/trailing whitespace.*\n~~~\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) (idx : Nat) : Int :=\nsorry\n\ndef has_matching_parens (s : String) : Bool :=\nsorry\n\ndef is_valid_idx (s : String) (idx : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_invalid_index {s : String} {idx : Nat} :\n  ¬(is_valid_idx s idx) → solve s idx = -1 :=\nsorry\n\ntheorem solve_unmatched_parens {s : String} {idx : Nat} :\n  ¬(has_matching_parens s) → solve s idx = -1 :=\nsorry\n\ntheorem solve_valid_result {s : String} {idx : Nat} :\n  (solve s idx ≠ -1) →\n  is_valid_idx s idx ∧\n  (∃ result : Nat, solve s idx = result ∧\n    idx < s.length ∧ result < s.length ∧\n    s.data[idx]! = '(' ∧\n    s.data[result]! = ')' ∧\n    has_matching_parens (String.mk (List.take (result + 1 - idx) (List.drop idx s.data)))) :=\nsorry\n\ntheorem solve_all_open_parens {s : String} :\n  (∀ c ∈ s.data, c = '(') →\n  ∀ i : Nat, i < s.length →\n  solve s i = -1 :=\nsorry\n\ntheorem solve_all_close_parens {s : String} :\n  (∀ c ∈ s.data, c = ')') →\n  ∀ i : Nat, i < s.length →\n  solve s i = -1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 0\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 1\n\n/--\ninfo: 28\n-/\n#guard_msgs in\n#eval solve \"(g(At)IO(f)(tM(qk)YF(n)Nr(E)))\" 11"}
{"id": "fvapps_003504", "vc-description": "/-\nGiven a number `n`, make a down arrow shaped pattern.\n\nFor example, when `n = 5`, the output would be:\n\n    123454321\n     1234321\n      12321\n       121\n        1\n\nand for `n = 11`, it would be:\n\n    123456789010987654321\n     1234567890987654321\n      12345678987654321\n       123456787654321\n        1234567654321\n         12345654321\n          123454321\n           1234321\n            12321\n             121\n              1\n\nAn important thing to note in the above example is that the numbers greater than 9 still stay single digit, like after 9 it would be 0 - 9 again instead of 10 - 19.\n\nNote: There are spaces for the indentation on the left of each line and no spaces on the right.\n\nHave fun!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_a_down_arrow_of (n : Nat) : String :=\nsorry\n\ndef String.lines (s : String) : List String :=\nsorry\n\ndef String.padLeft (n : Nat) (c : Char) (s : String) : String :=\nsorry\n\ndef charToNat (c : Char) : Nat :=\nsorry", "vc-theorems": "theorem arrow_length (n : Nat) (h : 0 < n ∧ n ≤ 9) :\n  (get_a_down_arrow_of n).lines.length = n :=\nsorry\n\ntheorem arrow_leading_spaces (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let line := lines[i]!\n  (∃ rest : String, line = String.padLeft i ' ' rest) ∧\n  line.trim ≠ \"\" :=\nsorry\n\ntheorem arrow_decreasing_widths (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n - 1) :\n  let lines := (get_a_down_arrow_of n).lines\n  lines[i]!.length > lines[i+1]!.length :=\nsorry\n\ntheorem arrow_line_symmetry (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let stripped := lines[i]!.trim\n  let mid := stripped.length / 2\n  stripped.take mid = stripped.drop (mid+1) :=\nsorry\n\ntheorem arrow_sequential_digits (n : Nat) (h : 0 < n ∧ n ≤ 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let digits := lines[i]!.data.filter Char.isDigit\n  (∀ d ∈ digits, 0 < charToNat d ∧ charToNat d < 10) ∧\n  (digits.length > 1 →\n    ∀ j < digits.length/2 - 1,\n      charToNat digits[j+1]! - charToNat digits[j]! = 1) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003515", "vc-description": "/-\nTo celebrate the start of the Rio Olympics (and the return of 'the Last Leg' on C4 tonight) this is an Olympic inspired kata.\n\nGiven a string of random letters, you need to examine each. Some letters naturally have 'rings' in them. 'O' is an obvious example, but 'b', 'p', 'e', 'A', etc are all just as applicable. 'B' even has two!! Please note for this kata you can count lower case 'g' as only one ring.\n\nYour job is to count the 'rings' in each letter and divide the total number by 2. Round the answer down. Once you have your final score:\n\nif score is 1 or less,  return 'Not even a medal!';\nif score is 2, return 'Bronze!';\nif score is 3, return 'Silver!';\nif score is more than 3, return 'Gold!';\n\nDots over i's and any other letters don't count as rings.\n-/", "vc-preamble": "def CHARS_WITH_RINGS := \"abdegopqABBDOPQR\"\n\ndef POSSIBLE_OUTPUTS := [\"Not even a medal!\", \"Bronze!\", \"Silver!\", \"Gold!\"]", "vc-helpers": "", "vc-definitions": "def olympic_ring (s : String) : String :=\nsorry", "vc-theorems": "theorem output_in_possible_values (s : String) :\n  olympic_ring s ∈ POSSIBLE_OUTPUTS :=\nsorry\n\ntheorem empty_string_not_medal (s : String) :\n  (∀ c, c ∈ s.data → c ∉ CHARS_WITH_RINGS.data) →\n  olympic_ring s = \"Not even a medal!\" :=\nsorry\n\ntheorem no_ring_chars_not_medal (s : String) :\n  (∀ c, c ∈ s.data → c ∉ CHARS_WITH_RINGS.data) →\n  olympic_ring s = \"Not even a medal!\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Bronze!'\n-/\n#guard_msgs in\n#eval olympic_ring \"wHjMudLwtoPGocnJ\"\n\n/--\ninfo: 'Not even a medal!'\n-/\n#guard_msgs in\n#eval olympic_ring \"JKniLfLW\"\n\n/--\ninfo: 'Gold!'\n-/\n#guard_msgs in\n#eval olympic_ring \"IMBAWejlGRTDWetPS\""}
{"id": "fvapps_003526", "vc-description": "/-\nIn this kata, you need to make a (simplified) LZ78 encoder and decoder.\n[LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ78) is a dictionary-based compression method created in 1978. You will find a  detailed explanation about how it works below.\n\nThe input parameter will always be a non-empty string of upper case alphabetical characters. The maximum decoded string length is 1000 characters.\n\n# Instructions\n\n*If anyone has any ideas on how to make the instructions shorter / clearer, that would be greatly appreciated.*\n\nIf the below explanation is too confusing, just leave a comment and I'll be happy to help.\n\n---\n\nThe input is looked at letter by letter.\nEach letter wants to be matched with the longest dictionary substring at that current time.\n\nThe output is made up of tokens.\nEach token is in the format ``\nwhere `index` is the index of the longest dictionary value that matches the current substring\nand `letter` is the current letter being looked at.\n\nHere is how the string `'ABAABABAABAB'` is encoded:\n\n* First, a dictionary is initialised with the 0th item pointing to an empty string:\n\n```md\nDictionary      Input             Output\n0  |  ''        ABAABABAABAB\n```\n\n* The first letter is `A`. As it doesn't appear in the dictionary, we add `A` to the next avaliable index.\nThe token `<0, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A>\n1  |  A         ^\n```\n\n* The second letter is `B`. It doesn't appear in the dictionary, so we add `B` to the next avaliable index.\nThe token `<0, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B>\n1  |  A          ^\n2  |  B\n```\n\n* The third letter is `A` again: it already appears in the dictionary at position `1`. We add the next letter which is also `A`. `AA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<1, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A>\n1  |  A           ^^\n2  |  B\n3  |  AA\n```\n\n* The next letter is `B` again: it already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<2, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A>\n1  |  A             ^^\n2  |  B\n3  |  AA\n4  |  BA\n```\n\n* The next letter is `B`: it already appears in the dictionary and at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `A`. `BAA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A>\n1  |  A               ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n```\n\n* The next letter is `B`. It already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `B`. `BAB` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A> <4, B>\n1  |  A                  ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n6  |  BAB\n```\n\n* We have now reached the end of the string. We have the output tokens: `<0, A> <0, B> <1, A> <2, A> <4, A> <4, B>`.\nNow we just return the tokens without the formatting: `'0A0B1A2A4A4B'`\n\n**Note:**\n\nIf the string ends with a match in the dictionary, the last token should only contain the index of the dictionary. For example, `'ABAABABAABABAA'` (same as the example but with `'AA'` at the end) should return `'0A0B1A2A4A4B3'` (note the final `3`).\n\nTo decode, it just works the other way around.\n\n# Examples\n\nSome more examples:\n```\nDecoded                               Encoded\n\nABBCBCABABCAABCAABBCAA                0A0B2C3A2A4A6B6\nAAAAAAAAAAAAAAA                       0A1A2A3A4A\nABCABCABCABCABCABC                    0A0B0C1B3A2C4C7A6\nABCDDEFGABCDEDBBDEAAEDAEDCDABC        0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C\n```\n\nGood luck :)\n-/\n\n-- Helper function to check if character is uppercase\n\n-- Helper function to check if character is digit\n\n-- Helper function to check if string starts with 0 and uppercase letter\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encoder (s : String) : String :=\nsorry\n\ndef decoder (s : String) : String :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef isDigit (c : Char) : Bool :=\nsorry\n\ndef startsWithZeroUpper (s : String) : Bool :=\nsorry", "vc-theorems": "theorem encoder_output_format (s : String) (h : s ≠ \"\") :\n  (∀ c, c ∈ s.toList → isDigit c ∨ isUpper c) ∧\n  startsWithZeroUpper (encoder s) :=\nsorry\n\ntheorem encoder_length_bounds (s : String) (h : s ≠ \"\") :\n  String.length (encoder s) ≤ 3 * String.length s ∧\n  String.length (encoder s) ≥ String.length s / 2 :=\nsorry\n\ntheorem encoder_decoder_inverse (s : String) (h : s ≠ \"\") :\n  decoder (encoder s) = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003534", "vc-description": "/-\nCreate a function that returns the average of an array of numbers (\"scores\"), rounded to the nearest whole number. You are not allowed to use any loops (including for, for/in, while, and do/while loops).\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def average (l : List Int) : Int :=\n  sorry\n\ndef list_min (l : List Int) : Int :=\n  sorry\n\ndef list_max (l : List Int) : Int :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem average_in_range (l : List Int) (h : l ≠ []) :\n  let result := average l\n  let min_val := list_min l\n  let max_val := list_max l\n  min_val ≤ result ∧ result ≤ max_val := by\n  sorry\n\ntheorem average_close_to_mean (l : List Int) (h : l ≠ []) :\n  let result := average l\n  let mean := (list_sum l) / (List.length l)\n  (result - mean) < 1 ∧ (mean - result) < 1 := by\n  sorry\n\ntheorem average_shift (l : List Int) (shift : Int) (h : l ≠ []) :\n  average (List.map (· + shift) l) = average l + shift := by\n  sorry\n\ntheorem average_empty :\n  average [] = 0 ∧ False := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_003535", "vc-description": "/-\n## Task\n You are given an array of integers. On each move you are allowed to increase exactly one of its element by one. Find the minimal number of moves required to obtain a strictly increasing sequence from the input.\n\n## Example\n\n For `arr = [1, 1, 1]`, the output should be `3`.\n\n## Input/Output\n\n - `[input]` integer array `arr`\n\n    Constraints:\n\n    `3 ≤ inputArray.length ≤ 100,`\n\n    `-10000 ≤ inputArray[i] ≤ 10000.`\n\n - `[output]` an integer\n\n    The minimal number of moves needed to obtain a strictly increasing sequence from inputArray.\n\n    It's guaranteed that for the given test cases the answer always fits signed 32-bit integer type.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_change (arr : List Int) : Nat :=\n  sorry\n\ndef sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem array_change_returns_nonnegative (arr : List Int) (h : arr.length ≥ 1) :\n  array_change arr ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval array_change [1, 1, 1]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval array_change [-1000, 0, -2, 0]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval array_change [2, 1, 10, 1]"}
{"id": "fvapps_003542", "vc-description": "/-\nThis is simple version of harder [Square Sums](/kata/square-sums).\n\n# Square sums\n\nWrite function `square_sums_row` (or `squareSumsRow`/`SquareSumsRow` depending on language rules) that, given integer number `N` (in range `2..43`), returns array of integers `1..N` arranged in a way, so sum of each 2 consecutive numbers is a square.\n\nSolution is valid if and only if following two criterias are met:\n1. Each number in range `1..N` is used once and only once.\n2. Sum of each 2 consecutive numbers is a perfect square.\n\n### Example\nFor N=15 solution could look like this:\n\n`[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]`\n\n### Verification\n\n1. All numbers are used once and only once. When sorted in ascending order array looks like this:\n\n`[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]`\n\n2. Sum of each 2 consecutive numbers is a perfect square:\n\n```\n   16    16     16     16     16     16     16\n   /+\\   /+\\    /+\\    /+\\    /+\\    /+\\    /+\\\n[ 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8 ]\n      \\+/    \\+/    \\+/    \\+/    \\+/    \\+/    \\+/\n       9     25      9     25      9     25      9\n\n9 = 3*3\n16 = 4*4\n25 = 5*5\n```\n\nIf there is no solution, return `false` (or, `None` in scala). For example if `N=5`, then numbers `1,2,3,4,5` cannot be put into square sums row: `1+3=4`, `4+5=9`, but\n`2` has no pairs and cannot link `[1,3]` and `[4,5]`\n\n# Have fun!\n\nHarder version of this Kata is [here](/kata/square-sums).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_perfect_square (n : Nat) : Bool :=\n  sorry\n\ndef square_sums_row (n : Nat) : Option (List Nat) :=\n  sorry", "vc-theorems": "theorem square_sums_row_length {n : Nat} {result : List Nat} :\n  square_sums_row n = some result → result.length = n :=\nsorry\n\ntheorem square_sums_row_elements {n : Nat} {result : List Nat} :\n  square_sums_row n = some result →\n  result = (List.map (λ x => x + 1) (List.range n)) :=\nsorry\n\ntheorem square_sums_row_adjacent_pairs {n : Nat} {result : List Nat} :\n  square_sums_row n = some result →\n  ∀ i, i < result.length - 1 →\n  is_perfect_square (result[i]! + result[i+1]!) = true :=\nsorry\n\ntheorem square_sums_row_impossible_cases :\n  (square_sums_row 2 = none) ∧\n  (square_sums_row 3 = none) ∧\n  (square_sums_row 5 = none) ∧\n  (square_sums_row 24 = none) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 5\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 24\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval len square_sums_row(15)\n\n/--\ninfo: list(range(1, 16))\n-/\n#guard_msgs in\n#eval sorted result"}
{"id": "fvapps_003545", "vc-description": "/-\n# The die is cast!\n\nYour task in this kata is to write a \"dice roller\" that interprets a subset of [dice notation](http://en.wikipedia.org/wiki/Dice_notation).\n\n# Description\n\nIn most role-playing games, die rolls required by the system are given in the form `AdX`. `A` and `X` are variables, separated by the letter **d**, which stands for *die* or *dice*.\n\n - `A` is the number of dice to be rolled (usually omitted if 1).\n - `X` is the number of faces of each die.\n\nHere are some examples of input:\n\n# Modifiers\n\nAs an addition to the above rules the input may also contain modifiers in the form `+N` or `-N` where `N` is an integer.\n\nHere are some examples of input containing modifiers:\n\n*Modifiers must be applied **after** all dice has been summed up.*\n\n# Output\n\nYour function must support two types of output depending on the second argument; *verbose* and *summed*.\n\n## Summed output\nIf the verbose flag isn't set your function should sum up all the dice and modifiers and return the result as an integer.\n\n## Verbose output\nWith the verbose flag your function should return an object/hash containing an array (`dice`) with all the dice rolls, and a integer (`modifier`) containing the sum of the modifiers which defaults to zero.\n\nExample of verbose output:\n\n# Invalid input\nHere are some examples of invalid inputs:\n\n# Additional information\n\n - Your solution should ignore all whitespace.\n - `roll` should return `false` for invalid input.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isInt (n : Nat) : Bool :=\nsorry\n\ndef isDiceList (l : List Nat) : Bool :=\nsorry\n\ndef isValidDiceDesc : String → Bool :=\nsorry\n\ndef extractSides : String → Option Nat :=\nsorry\n\ndef roll (desc : String) (verbose : Bool := false) : Bool ⊕ (List Nat × Int) :=\nsorry", "vc-theorems": "theorem valid_roll_structure {desc : String} {result : List Nat × Int}\n  (h : roll desc true = Sum.inr result) :\n  ∃ (dice : List Nat) (modifier : Int), result = (dice, modifier) ∧\n  ∀ d ∈ dice, isInt d :=\nsorry\n\ntheorem invalid_roll {desc : String} (h : ¬isValidDiceDesc desc) :\n  roll desc false = Sum.inl false :=\nsorry\n\ntheorem non_string_input {α : Type} {x : α} [ToString α] :\n  roll (toString x) false = Sum.inl false :=\nsorry\n\ntheorem roll_range_properties {desc : String} {result : List Nat × Int} {sides : Nat}\n  (h₁ : roll desc true = Sum.inr result)\n  (h₂ : extractSides desc = some sides) :\n  ∀ die ∈ result.1, 1 ≤ die ∧ die ≤ sides :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval roll {}\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"abc\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval len result1[\"dice\"]"}
{"id": "fvapps_003549", "vc-description": "/-\n# Task\n\nIn the city, a bus named Fibonacci runs on the road every day.\n\nThere are `n` stations on the route. The Bus runs from station1 to stationn.\n\nAt the departure station(station1), `k` passengers get on the bus. \n\nAt the second station(station2), a certain number of passengers get on and the same number get off. There are still `k` passengers on the bus.\n\nFrom station3 to stationn-1, the number of boarding and alighting passengers follows the following rule:\n\n- At stationi, the number of people getting on is the sum of the number of people getting on at the two previous stations(stationi-1 and stationi-2)\n- The number of people getting off is equal to the number of people getting on at the previous station(stationi-1).\n\nAt stationn, all the passengers get off the bus. \n\nNow, The numbers we know are: `k` passengers get on the bus at station1, `n` stations in total, `m` passengers get off the bus at stationn.\n\nWe want to know: How many passengers on the bus when the bus runs out stationx.\n\n# Input\n\n- `k`: The number of passengers get on the bus at station1.\n  - `1 <= k <= 100`\n\n- `n`: The total number of stations(1-based).\n  - `6 <= n <= 30`\n\n- `m`: The number of passengers get off the bus at stationn.\n  - `1 <= m <= 10^10`\n\n- `x`: Stationx(1-based). The station we need to calculate.\n  - `3 <= m <= n-1`\n\n- All inputs are valid integers.\n\n# Output\n\nAn integer. The number of passengers on the bus when the bus runs out stationx.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sim (k n : Nat) (p : Float) : Float :=\n  sorry\n\ndef compute (k n m x : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sim_monotonic (k n : Nat)\n  (h1 : k ≥ 1) (h2 : n ≥ 2) :\n  sim k n 0 ≤ sim k n 1 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003555", "vc-description": "/-\n# Introduction\n\nThe Condi (Consecutive Digraphs) cipher was introduced by G4EGG (Wilfred Higginson) in 2011. The cipher preserves word divisions, and is simple to describe and encode, but it's surprisingly difficult to crack. \n\n# Encoding Algorithm\n\nThe encoding steps are:\n- Start with an `initial key`, e.g. `cryptogram`\n- Form a `key`, remove the key duplicated letters except for the first occurrence\n- Append to it, in alphabetical order all letters which do not occur in the `key`.  \n  The example produces: `cryptogambdefhijklnqsuvwxz`\n- Number the `key alphabet` starting with 1.\n```python\n1  2  3  4  5  6  7  8  9  10 11 12 13\nc  r  y  p  t  o  g  a  m  b  d  e  f \n14 15 16 17 18 19 20 21 22 23 24 25 26\nh  i  j  k  l  n  q  s  u  v  w  x  z\n```\n- One of the inputs to encoding algorithm is an `initial shift`, say `10`\n- Encode the first letter of your `message` by moving 10 places to the right from the letter's position in the key alphabet. If the first letter were say `o` then the letter 10 places to the right in the `key alphabet` is `j`, so `o` would be encoded as `j`. If you move past the end of the key alphabet you wrap back to the beginning. For example if the first letter were `s` then counting 10 places would bring you around to `t`.\n- Use the position of the previous plaintext letter as the number of places to move to encode the next plaintext number. If you have just encoded an `o` (position 6) , and you now want to encode say `n`, then you move 6 places to the right from `n` which brings you to `x`.\n- Keep repeating the previous step until all letters are encoded.\n\nDecoding is the reverse of encoding - you move to the left instead of to the right.\n\n# Task\n\nCreate two functions - `encode`/`Encode` and `decode`/`Decode` which implement Condi cipher encoding and decoding.\n\n# Inputs\n\n- `message` - a string to encode/decode\n- `key` - a key consists of only lower case letters\n- `initShift` - a non-negative integer representing the initial shift\n\n# Notes\n- Don't forget to remove the duplicated letters from the `key` except for the first occurrence \n- Characters which do not exist in the `key alphabet` should be coppied to the output string exactly like they appear in the `message` string\n- Check the test cases for samples\n-/", "vc-preamble": "def LOWER : String :=\n  \"abcdefghijklmnopqrstuvwxyz\"", "vc-helpers": "", "vc-definitions": "def encode (message : String) (key : String) (shift : Int) : String :=\n  sorry\n\ndef decode (message : String) (key : String) (shift : Int) : String :=\n  sorry", "vc-theorems": "theorem encode_decode_roundtrip\n  {message key : String} {shift : Int}\n  (h1 : ∀ c ∈ message.data, c.toString ∈ LOWER.data.map toString)\n  (h2 : key.length > 0)\n  (h3 : ∀ c ∈ key.data, c.toString ∈ LOWER.data.map toString) :\n  decode (encode message key shift) key shift = message :=\nsorry\n\ntheorem non_alphabet_chars_unchanged\n  {message key : String} {shift : Int}\n  (h1 : key.length > 0)\n  (h2 : ∀ c ∈ key.data, c.toString ∈ LOWER.data.map toString) :\n  ∀ (i : Nat) (h3 : i < message.length),\n    (message.data.get ⟨i, h3⟩) ∉ LOWER.data →\n    (encode message key shift).data.get ⟨i, sorry⟩ = message.data.get ⟨i, h3⟩ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'jx'\n-/\n#guard_msgs in\n#eval encode \"on\" \"cryptogram\" 10\n\n/--\ninfo: msg\n-/\n#guard_msgs in\n#eval decode \"jx\" key shift\n\n/--\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"keyword\" 5\n\n/--\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"secret\" 7"}
{"id": "fvapps_003562", "vc-description": "/-\nThe Binomial Form of a polynomial has many uses, just as the standard form does.  For comparison, if p(x) is in Binomial Form and q(x) is in standard form, we might write\n\np(x) := a0 \\* xC0 + a1 \\* xC1 + a2 \\* xC2 + ... + aN \\* xCN\n\nq(x) := b0 + b1 \\* x + b2 \\* x^(2) + ... + bN \\* x^(N)\n\nBoth forms have tricks for evaluating them, but tricks should not be necessary.  The most important thing to keep in mind is that aCb can be defined for non-integer values of a; in particular,\n\n```\naCb := a * (a-1) * (a-2) * ... * (a-b+1) / b!   // for any value a and integer values b\n    := a! / ((a-b)!b!)                          // for integer values a,b\n```\n\nThe inputs to your function are an array which specifies a polynomial in Binomial Form, ordered by highest-degree-first, and also a number to evaluate the polynomial at.  An example call might be\n\n```python\nvalue_at([1, 2, 7], 3)\n```\n\nand the return value would be 16, since 3C2 + 2 * 3C1 + 7 = 16.  In more detail, this calculation looks like\n\n```\n1 * xC2 + 2 * xC1 + 7 * xC0 :: x = 3\n3C2 + 2 * 3C1 + 7\n3 * (3-1) / 2! + 2 * 3 / 1! + 7\n3 + 6 + 7 = 16\n```\n\nMore information can be found by reading about [Binomial Coefficients](https://en.wikipedia.org/wiki/Binomial_coefficient) or about [Finite Differences](https://en.wikipedia.org/wiki/Finite_difference).\n\nNote that while a solution should be able to handle non-integer inputs and get a correct result, any solution should make use of rounding to two significant digits (as the official solution does) since high precision for non-integers is not the point here.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def value_at (poly: List Int) (x: Float) : Float :=\nsorry\n\ndef aCb (a: Float) (b: Int) : Float :=\nsorry\n\ndef intToFloat (i: Int) : Float :=\nsorry", "vc-theorems": "theorem value_at_results_finite (poly: List Int) (x: Float) (h1: poly.length > 0)\n  (h2: -10 ≤ x ∧ x ≤ 10) : ∃ (y: Float), value_at poly x = y :=\nsorry\n\ntheorem aCb_matches_binomial (a b: Int) (h1: 0 ≤ a ∧ a ≤ 10) (h2: 0 ≤ b ∧ b ≤ 10)\n  (h3: b ≤ a) : ∃ (y: Float), aCb (intToFloat a) b = y :=\nsorry\n\ntheorem aCb_results_finite (a: Float) (b: Int) (h1: -10 ≤ a ∧ a ≤ 10)\n  (h2: 0 ≤ b ∧ b ≤ 5) : ∃ (y: Float), aCb a b = y :=\nsorry\n\ntheorem value_at_constant (c: Int) (h1: -10 ≤ c ∧ c ≤ 10) :\n  (value_at [c] 123 - intToFloat c) < 0.01 ∧ (intToFloat c - value_at [c] 123) < 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7] 3\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 2\n\n/--\ninfo: 4.24\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 0.6"}
{"id": "fvapps_003566", "vc-description": "/-\nGerman mathematician Christian Goldbach (1690-1764) [conjectured](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture) that every even number greater than 2 can be represented by the sum of two prime numbers. For example, `10` can be represented as `3+7` or `5+5`.\n\nYour job is to make the function return a list containing all unique possible representations of `n` in an increasing order if `n` is an even integer; if `n` is odd, return an empty list. Hence, the first addend must always be less than or equal to the second to avoid duplicates.\n\nConstraints : `2 < n < 32000` and `n` is even\n\n## Examples\n```\n26  -->  ['3+23', '7+19', '13+13']\n\n100 -->  ['3+97', '11+89', '17+83', '29+71', '41+59', '47+53']\n\n7   -->  [] \n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def Nat.is_even (n : Nat) : Bool := n % 2 == 0", "vc-helpers": "", "vc-definitions": "def goldbach_partitions : Nat → List String :=\nsorry\n\ndef is_prime : Nat → Bool :=\nsorry", "vc-theorems": "theorem goldbach_odd_numbers_empty (n : Nat) :\n  n % 2 = 1 → goldbach_partitions n = [] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003568", "vc-description": "/-\nYou will be given an array of strings. The words in the array should mesh together where one or more letters at the end of one word will have the same letters (in the same order) as the next word in the array. But, there are times when all the words won't mesh. \n\nExamples of meshed words:\n\n  \"apply\" and \"plywood\"\n\n  \"apple\" and \"each\"\n\n  \"behemoth\" and \"mother\"\n\nExamples of words that don't mesh:\n\n  \"apply\" and \"playground\"\n\n  \"apple\" and \"peggy\"\n\n  \"behemoth\" and \"mathematics\"\n\nIf all the words in the given array mesh together, then your code should return the meshed letters in a string.\nYou won't know how many letters the meshed words have in common, but it will be at least one.\n\nIf all the words don't mesh together, then your code should return `\"failed to mesh\"`.\n\nInput: An array of strings. There will always be at least two words in the input array.\n\nOutput: Either a string of letters that mesh the words together or the string `\"failed to mesh\"`.\n\n## Examples\n\n#1:\n\n```\n[\"allow\", \"lowering\", \"ringmaster\", \"terror\"] --> \"lowringter\"\n```\nbecause:\n\n* the letters `\"low\"` in the first two words mesh together\n* the letters `\"ring\"` in the second and third word mesh together\n* the letters `\"ter\"` in the third and fourth words mesh together.\n\n#2:\n\n```\n[\"kingdom\", \"dominator\", \"notorious\", \"usual\", \"allegory\"] --> \"failed to mesh\"\n```\n\nAlthough the words `\"dominator\"` and `\"notorious\"` share letters in the same order, the last letters of the first word don't mesh with the first letters of the second word.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def word_mesh (words : List String) : String :=\nsorry\n\ndef isResult (s : String) : Bool :=\nsorry\n\ndef hasOverlap (s1 s2 : String) : Bool :=\nsorry\n\ndef isLowerAlpha (s : String) : Bool :=\nsorry", "vc-theorems": "theorem word_mesh_output_format\n  (words : List String)\n  (h1 : words.length ≥ 2)\n  (h2 : words.length ≤ 10)\n  (h3 : ∀ w ∈ words, w.length > 0) :\n  let result := word_mesh words\n  (result = \"failed to mesh\" ∨ isLowerAlpha result) :=\nsorry\n\ntheorem word_mesh_successful_overlap\n  (words : List String)\n  (h1 : words.length ≥ 2)\n  (h2 : words.length ≤ 5)\n  (h3 : ∀ w ∈ words, w.length > 0)\n  (h4 : ∀ i, i < words.length - 1 →\n    hasOverlap (words.get ⟨i, by sorry⟩) (words.get ⟨i+1, by sorry⟩)) :\n  let result := word_mesh words\n  result ≠ \"failed to mesh\" →\n  ∀ i, i < words.length - 1 →\n    hasOverlap (words.get ⟨i, by sorry⟩) (words.get ⟨i+1, by sorry⟩) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'lowringter'\n-/\n#guard_msgs in\n#eval word_mesh [\"allow\", \"lowering\", \"ringmaster\", \"terror\"]\n\n/--\ninfo: 'failed to mesh'\n-/\n#guard_msgs in\n#eval word_mesh [\"kingdom\", \"dominator\", \"notorious\", \"usual\", \"allegory\"]\n\n/--\ninfo: 'conumcal'\n-/\n#guard_msgs in\n#eval word_mesh [\"beacon\", \"condominium\", \"umbilical\", \"california\"]"}
{"id": "fvapps_003576", "vc-description": "/-\n~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getAllPrimeFactors (n : Int) : List Int :=\nsorry\n\ndef getUniquePrimeFactorsWithCount (n : Int) : List (List Int) :=\nsorry\n\ndef getUniquePrimeFactorsWithProducts (n : Int) : List Int :=\nsorry", "vc-theorems": "theorem prime_factors_product_equals_input {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  factors ≠ [] → factors.foldl (·*·) 1 = n :=\nsorry\n\ntheorem prime_factors_are_ordered {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  factors.length > 1 →\n  ∀ i : Fin (factors.length - 1), factors[i] ≤ factors[i.val + 1] :=\nsorry\n\ntheorem negative_inputs {n : Int} (h : n < 0) :\n  getAllPrimeFactors n = [] ∧\n  getUniquePrimeFactorsWithCount n = [[], []] ∧\n  getUniquePrimeFactorsWithProducts n = [] :=\nsorry\n\ntheorem count_matches_occurrences {n : Int} (h : 0 ≤ n) :\n  let factors := getAllPrimeFactors n\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  factors ≠ [] →\n  ∀ (p c : Int),\n  List.zip uniqueWithCount[0]! uniqueWithCount[1]! |>.contains (p, c) →\n  (factors.filter (·= p)).length = c :=\nsorry\n\ntheorem products_match_prime_power {n : Int} (h : 0 ≤ n) :\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  let products := getUniquePrimeFactorsWithProducts n\n  uniqueWithCount[0]! ≠ [] →\n  products.length = uniqueWithCount[0]!.length ∧\n  ∀ (p c prod : Int),\n  List.zip (List.zip uniqueWithCount[0]! uniqueWithCount[1]!) products |>.contains ((p, c), prod) →\n  prod = p * c :=\nsorry\n\ntheorem edge_cases :\n  getAllPrimeFactors 0 = [] ∧\n  getUniquePrimeFactorsWithCount 0 = [[], []] ∧\n  getUniquePrimeFactorsWithProducts 0 = [] ∧\n  getAllPrimeFactors 1 = [1] ∧\n  getUniquePrimeFactorsWithCount 1 = [[1], [1]] ∧\n  getUniquePrimeFactorsWithProducts 1 = [1] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [2, 2, 5, 5]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 100\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 0\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 1\n\n/--\ninfo: [[2, 5], [2, 2]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 100\n\n/--\ninfo: [[], []]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 0\n\n/--\ninfo: [[1], [1]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 1\n\n/--\ninfo: [4, 25]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 100\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 0\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 1"}
{"id": "fvapps_003577", "vc-description": "/-\nNaming multiple files can be a pain sometimes.\n\n#### Task:\n\nYour job here is to create a function that will take three parameters, `fmt`, `nbr` and `start`, and create an array of `nbr` elements formatted according to `frm` with the starting index `start`. `fmt` will have `` inserted at various locations; this is where the file index number goes in each file. \n\n#### Description of edge cases:\n\n1. If `nbr` is less than or equal to 0, or not whole, return an empty array.\n2. If `fmt` does not contain `''`, just return an array with `nbr` elements that are all equal to `fmt`. \n3. If `start` is not an integer, return an empty array.\n\n#### What each parameter looks like:\n\n```python\ntype(frm) #=> str\n  : \"text_to_stay_constant_from_file_to_file \"\ntype(nbr) #=> int\n  : number_of_files\ntype(start) #=> int\n  : index_no_of_first_file\ntype(name_file(frm, nbr, start)) #=> list\n```\n\n#### Some examples:\n\n```python\nname_file(\"IMG \", 4, 1)\n  #=> [\"IMG 1\", \"IMG 2\", \"IMG 3\", \"IMG 4\"])\nname_file(\"image #.jpg\", 3, 7)\n  #=> [\"image #7.jpg\", \"image #8.jpg\", \"image #9.jpg\"]\nname_file(\"# #\", 3, -2)\n  #=> [\"#-2 #-2\", \"#-1 #-1\", \"#0 #0\"]\n```\n\nAlso check out my other creations — [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\nIf you notice any issues or have any suggestions/comments whatsoever, please don't hesitate to mark an issue or just comment. Thanks!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def name_file (fmt: String) (nbr: Int) (start: Int) : List String :=\n  sorry\n\ndef containsIndexNo (s: String) : Bool :=\n  sorry\n\ndef containsNumber (s: String) (n: Int) : Bool :=\n  sorry", "vc-theorems": "theorem name_file_length\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000) :\n  (name_file fmt nbr start).length = nbr := by\nsorry\n\ntheorem name_file_index_numbers\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000)\n  (h5: containsIndexNo fmt = true) :\n  ∀ (i: Nat), i < nbr →\n    containsNumber (List.get! (name_file fmt nbr start) i) (start + i) = true := by\nsorry\n\ntheorem name_file_no_index\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr ≤ 1000) (h3: start ≥ -1000) (h4: start ≤ 1000)\n  (h5: containsIndexNo fmt = false) :\n  ∀ (x: String), x ∈ name_file fmt nbr start → x = fmt := by\nsorry\n\ntheorem name_file_invalid_number\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr ≤ 0) :\n  name_file fmt nbr start = [] := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_003578", "vc-description": "/-\n# RoboScript #2 - Implement the RS1 Specification\n\n## Disclaimer\n\nThe story presented in this Kata Series is purely fictional; any resemblance to actual programming languages, products, organisations or people should be treated as purely coincidental.\n\n## About this Kata Series\n\nThis Kata Series is based on a fictional story about a computer scientist and engineer who owns a firm that sells a toy robot called MyRobot which can interpret its own (esoteric) programming language called RoboScript.  Naturally, this Kata Series deals with the software side of things (I'm afraid Codewars cannot test your ability to build a physical robot!).\n\n## Story\n\nNow that you've built your own code editor for RoboScript with appropriate syntax highlighting to make it look like serious code, it's time to properly implement RoboScript so that our MyRobots can execute any RoboScript provided and move according to the will of our customers.  Since this is the first version of RoboScript, let's call our specification RS1 (like how the newest specification for JavaScript is called ES6 :p)\n\n## Task\n\nWrite an interpreter for RS1 called `execute()` which accepts 1 required argument `code`, the RS1 program to be executed.  The interpreter should return a string representation of the smallest 2D grid containing the full path that the MyRobot has walked on (explained in more detail later).\n\nInitially, the robot starts at the middle of a 1x1 grid.  Everywhere the robot walks it will leave a path `\"*\"`.  If the robot has not been at a particular point on the grid then that point will be represented by a whitespace character `\" \"`.  So if the RS1 program passed in to `execute()` is empty, then:\n\n```\n\"\"  -->  \"*\"\n```\n\nThe robot understands 3 major commands:\n\n- `F` - Move forward by 1 step in the direction that it is currently pointing.  Initially, the robot faces to the right.\n- `L` - Turn \"left\" (i.e. **rotate** 90 degrees **anticlockwise**)\n- `R` - Turn \"right\" (i.e. **rotate** 90 degrees **clockwise**)\n\nAs the robot moves forward, if there is not enough space in the grid, the grid should expand accordingly. So:\n\n```\n\"FFFFF\"  -->  \"******\"\n```\n\nAs you will notice, 5 `F` commands in a row should cause your interpreter to return a string containing 6 `\"*\"`s in a row.  This is because initially, your robot is standing at the middle of the 1x1 grid facing right.  It leaves a mark on the spot it is standing on, hence the first `\"*\"`.  Upon the first command, the robot moves 1 unit to the right.  Since the 1x1 grid is not large enough, your interpreter should expand the grid 1 unit to the right.  The robot then leaves a mark on its newly arrived destination hence the second `\"*\"`.  As this process is repeated 4 more times, the grid expands 4 more units to the right and the robot keeps leaving a mark on its newly arrived destination so by the time the entire program is executed, 6 \"squares\" have been marked `\"*\"` from left to right.\n\nEach row in your grid must be separated from the next by a CRLF (`\\r\\n`).  Let's look at another example:\n\n```\n\"FFFFFLFFFFFLFFFFFLFFFFFL\"  -->  \"******\\r\\n*    *\\r\\n*    *\\r\\n*    *\\r\\n*    *\\r\\n******\"\n```\n\nSo the grid will look like this:\n```\n******\n*    *\n*    *\n*    *\n*    *\n******\n```\n\nThe robot moves 5 units to the right, then turns left, then moves 5 units upwards, then turns left again, then moves 5 units to the left, then turns left again and moves 5 units downwards, returning to the starting point before turning left one final time.  Note that the marks do **not** disappear no matter how many times the robot steps on them, e.g. the starting point is still marked `\"*\"` despite the robot having stepped on it twice (initially and on the last step).\n\nAnother example:\n\n```\n\"LFFFFFRFFFRFFFRFFFFFFF\"  -->  \"    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   \"\n```\nSo the grid will look like this:\n```\n    ****\n    *  *\n    *  *\n********\n    *\n    *\n```\n\nInitially the robot turns left to face upwards, then moves upwards 5 squares, then turns right and moves 3 squares, then turns right again (to face downwards) and move 3 squares, then finally turns right again and moves 7 squares.\n\nSince you've realised that it is probably quite inefficient to repeat certain commands over and over again by repeating the characters (especially the `F` command - what if you want to move forwards 20 steps?), you decide to allow a shorthand notation in the RS1 specification which allows your customers to postfix a non-negative integer onto a command to specify how many times an instruction is to be executed:\n\n- `Fn` - Execute the `F` command `n` times (NOTE: `n` *may* be more than 1 digit long!)\n- `Ln` - Execute `L` n times\n- `Rn` - Execute `R` n times\n\nSo the example directly above can also be written as:\n\n```\n\"LF5RF3RF3RF7\"\n```\n\nThese 5 example test cases have been included for you :)\n\n## Kata in this Series\n\n1. [RoboScript #1 - Implement Syntax Highlighting](https://www.codewars.com/kata/roboscript-number-1-implement-syntax-highlighting)\n2. **RoboScript #2 - Implement the RS1 Specification**\n3. [RoboScript #3 - Implement the RS2 Specification](https://www.codewars.com/kata/58738d518ec3b4bf95000192)\n4. [RoboScript #4 - RS3 Patterns to the Rescue](https://www.codewars.com/kata/594b898169c1d644f900002e)\n5. [RoboScript #5 - The Final Obstacle (Implement RSU)](https://www.codewars.com/kata/5a12755832b8b956a9000133)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def execute (cmd : String) : String :=\n  sorry\n\ndef isValidOutput (result : String) : Bool :=\n  sorry", "vc-theorems": "theorem output_format_valid (cmd : String) :\n  isValidOutput (execute cmd) := by\n  sorry\n\ntheorem empty_input_yields_asterisk (cmd : String) :\n  cmd = \"\" → execute cmd = \"*\" := by\n  sorry\n\ntheorem rotation_only_yields_single_point (cmd : String)\n  (h : ∀ c ∈ cmd.data, c = 'R') :\n  execute cmd = \"*\" := by\n  sorry\n\ntheorem result_contains_origin (cmd : String) :\n  let result := execute cmd\n  result ≠ \"*\" →\n  ∃ line, line ∈ result.splitOn \"\\r\\n\" ∧ ('*' ∈ line.data) := by\n  sorry\n\ntheorem straight_line_is_continuous (cmd : String)\n  (h : ∀ c ∈ cmd.data, c = 'F') :\n  let result := execute cmd\n  (result.data.filter (· = '*')).length = cmd.length + 1 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '*'\n-/\n#guard_msgs in\n#eval execute \"\"\n\n/--\ninfo: '******'\n-/\n#guard_msgs in\n#eval execute \"FFFFF\"\n\n/--\ninfo: '    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   '\n-/\n#guard_msgs in\n#eval execute \"LFFFFFRFFFRFFFRFFFFFFF\""}
{"id": "fvapps_003579", "vc-description": "/-\nHello! Your are given x and y and 2D array size tuple (width, height) and you have to:\nCalculate the according index in 1D space (zero-based). \nDo reverse operation.\n\nImplement:\nto_1D(x, y, size):\n  --returns index in 1D space\nto_2D(n, size)\n  --returns x and y in 2D space\n\n1D array: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n2D array: [[0 -> (0,0), 1 -> (1,0), 2 -> (2,0)], \n           [3 -> (0,1), 4 -> (1,1), 5 -> (2,1)], \n           [6 -> (0,2), 7 -> (1,2), 8 -> (2,2)]]\n\nto_1D(0, 0, (3,3)) returns 0\nto_1D(1, 1, (3,3)) returns 4\nto_1D(2, 2, (3,3)) returns 8\nto_2D(5, (3,3)) returns (2,1)\nto_2D(3, (3,3)) returns (0,1)\n\nAssume all input are valid:\n\n1 < width  < 500; \n1 < height < 500\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_1D (x y : Nat) (size : Nat × Nat) : Nat :=\n  sorry\n\ndef to_2D (idx : Nat) (size : Nat × Nat) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem to_1D_to_2D_roundtrip (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let (x2, y2) := to_2D (to_1D x' y' size) size\n  x2 = x' ∧ y2 = y' :=\nsorry\n\ntheorem to_2D_to_1D_roundtrip (idx width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let idx' := idx % (width * height)\n  let (x, y) := to_2D idx' size\n  to_1D x y size = idx' :=\nsorry\n\ntheorem to_1D_bounds (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let idx := to_1D x' y' size\n  0 ≤ idx ∧ idx < width * height :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval to_1D 0 0 (3, 3)\n\n/--\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval to_2D 0 (3, 3)\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval to_1D 1 1 (3, 3)\n\n/--\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval to_2D 4 (3, 3)\n\n/--\ninfo: 14\n-/\n#guard_msgs in\n#eval to_1D 2 3 (4, 6)\n\n/--\ninfo: (2, 3)\n-/\n#guard_msgs in\n#eval to_2D 14 (4, 6)"}
{"id": "fvapps_003580", "vc-description": "/-\nCongratulations! That Special Someone has given you their phone number.\n\nBut WAIT, is it a valid number? \n\nYour task is to write a function that verifies whether a given string contains a valid British mobile (cell) phone number or not. \n\nIf valid, return 'In with a chance'.\n\nIf invalid, or if you're given an empty string, return 'Plenty more fish in the sea'.\n\nA number can be valid in the following ways: \n\nHere in the UK mobile numbers begin with '07' followed by 9 other digits, e.g. '07454876120'.\n\nSometimes the number is preceded by the country code, the prefix '+44', which replaces the '0' in ‘07’, e.g. '+447454876120'.\n\nAnd sometimes you will find numbers with dashes in-between digits or on either side, e.g. '+44--745---487-6120' or '-074-54-87-61-20-'. As you can see, dashes may be consecutive. \n\nGood Luck Romeo/Juliette!\n-/", "vc-preamble": "def YES : String := \"In with a chance\"\n\ndef NO : String := \"Plenty more fish in the sea\"", "vc-helpers": "", "vc-definitions": "def validateNumber (phone : String) : String :=\nsorry", "vc-theorems": "theorem valid_number_format (phone : String) (h1 : String.length phone > 0) :\n  validateNumber phone = YES ∨ validateNumber phone = NO :=\nsorry\n\ntheorem valid_uk_mobile (phone : String) (h1 : String.startsWith phone \"+44\" ∨ String.startsWith phone \"0\")\n    (h2 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :=\nsorry\n\ntheorem invalid_number_wrong_prefix (phone : String)\n    (h1 : ¬String.startsWith phone \"+44\" ∧ ¬String.startsWith phone \"0\") :\n  validateNumber phone = NO :=\nsorry\n\ntheorem invalid_number_wrong_length (phone : String)\n    (h1 : String.length (String.replace phone \"[^0-9]\" \"\") ≠ 11) :\n  validateNumber phone = NO :=\nsorry\n\ntheorem validates_with_dashes (phone : String)\n    (h1 : String.contains phone '-')\n    (h2 : String.startsWith (String.replace phone \"-\" \"\") \"+44\" ∨\n          String.startsWith (String.replace phone \"-\" \"\") \"0\")\n    (h3 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"07454876120\"\n\n/--\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"0745--487-61-20\"\n\n/--\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"+447535514555\"\n\n/--\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"0754876120\"\n\n/--\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"+337535512555\""}
{"id": "fvapps_003595", "vc-description": "/-\n## Task\n\nYou have to write three functions namely - `PNum, GPNum and SPNum` (JS, Coffee), `p_num, g_p_num and s_p_num` (Python and Ruby), `pNum, gpNum and spNum` (Java, C#), `p-num, gp-num and sp-num` (Clojure) - to check whether a given argument `n` is a Pentagonal, Generalized Pentagonal, or Square Pentagonal Number, and return `true` if it is and `false` otherwise.\n\n### Description\n\n`Pentagonal Numbers` - The nth pentagonal number Pn is the number of distinct dots in a pattern of dots consisting of the outlines of regular pentagons with sides up to n dots (means the side contains n number of dots), when the pentagons are overlaid so that they share one corner vertex.\n\n> First few Pentagonal Numbers are: 1, 5, 12, 22...\n\n`Generalized Pentagonal Numbers` - All the Pentagonal Numbers along with the number of dots inside the outlines of all the pentagons of a pattern forming a pentagonal number pentagon are called Generalized Pentagonal Numbers.\n\n> First few Generalized Pentagonal Numbers are: 0, 1, 2, 5, 7, 12, 15, 22...\n\n`Square Pentagonal Numbers` - The numbers which are Pentagonal Numbers and are also a perfect square are called Square Pentagonal Numbers. \n\n> First few are: 1, 9801, 94109401...\n\n### Examples\n\n#### Note: \n* Pn = Nth Pentagonal Number\n* Gpn = Nth Generalized Pentagonal Number\n\n     ^        ^          ^             ^                 ^\n    P1=1     P2=5      P3=12         P4=22             P5=35   //Total number of distinct dots used in the Pattern\n    Gp2=1    Gp4=5     Gp6=12        Gp8=22                    //All the Pentagonal Numbers are Generalised\n             Gp1=0     Gp3=2         Gp5=7             Gp7=15  //Total Number of dots inside the outermost Pentagon\n-/\n\n/- Helper function for pentagonal numbers -/\n\n/- Helper function for generalized pentagonal numbers -/", "vc-preamble": "def pen (n : Int) : Int := (3*n*n - n) / 2\n\ndef gen_pen (n : Int) : Int :=\n  if n >= 0 then (3*n*n - n) / 2 else (3*n*n + n) / 2", "vc-helpers": "", "vc-definitions": "def p_num (n : Int) : Bool :=\nsorry\n\ndef g_p_num (n : Int) : Bool :=\nsorry\n\ndef s_p_num (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem g_p_num_for_gen_pen (n : Int) : g_p_num (gen_pen n) = true :=\nsorry\n\ntheorem s_p_num_is_square_of_pentagonal_number {n : Int} (h : s_p_num n = true) :\n  ∃ k : Int,\n    k * k = n ∧\n    p_num k = true ∧\n    g_p_num n = true :=\nsorry\n\ntheorem non_square_not_s_p_num {n : Int} (h : ¬∃ k : Int, k * k = n) :\n  s_p_num n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 0\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 1\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 5\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 100\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 0\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 1\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 2\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 5\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 1\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 9801\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval s_p_num 100"}
{"id": "fvapps_003596", "vc-description": "/-\nYou've just recently been hired to calculate scores for a  Dart Board game!\n\nScoring specifications:\n\n* 0 points - radius above 10\n* 5 points - radius between 5 and 10 inclusive\n* 10 points - radius less than 5\n\n**If all radii are less than 5, award 100 BONUS POINTS!**\n\nWrite a function that accepts an array of radii (can be integers and/or floats), and returns a total score using the above specification.\n\nAn empty array should return 0.\n\n## Examples:\n-/", "vc-preamble": "def throw_points (r : Float) : Nat :=\n  if r < 5 then 10\n  else if r ≤ 10 then 5\n  else 0\n\ndef bonus_points (radiuses : List Float) : Nat :=\n  match radiuses with\n  | [] => 0\n  | xs => if (∀ r ∈ xs, r < 5) then 100 else 0", "vc-helpers": "", "vc-definitions": "def score_throws (radiuses : List Float) : Nat :=\nsorry", "vc-theorems": "theorem score_throws_empty :\n  score_throws [] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval score_throws [1, 5, 11]\n\n/--\ninfo: 140\n-/\n#guard_msgs in\n#eval score_throws [1, 2, 3, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval score_throws []"}
{"id": "fvapps_003598", "vc-description": "/-\n# Task\n You are given a `moment` in time and space. What you must do is break it down into time and space, to determine if that moment is from the past, present or future.\n\n `Time` is the sum of characters that increase time (i.e. numbers in range ['1'..'9'].\n\n `Space` in the number of characters which do not increase time (i.e. all characters but those that increase time).\n\n The moment of time is determined as follows:\n```\nIf time is greater than space, than the moment is from the future.\nIf time is less than space, then the moment is from the past.\nOtherwise, it is the present moment.```\n\n You should return an array of three elements, two of which are false, and one is true. The true value should be at the `1st, 2nd or 3rd` place for `past, present and future` respectively.\n\n# Examples\n\n For `moment = \"01:00 pm\"`, the output should be `[true, false, false]`.\n\n time equals 1, and space equals 7, so the moment is from the past.\n\n For `moment = \"12:02 pm\"`, the output should be `[false, true, false]`.\n\n time equals 5, and space equals 5, which means that it's a present moment.\n\n For `moment = \"12:30 pm\"`, the output should be `[false, false, true]`.\n\n time equals 6, space equals 5, so the moment is from the future.\n\n# Input/Output\n\n - `[input]` string `moment`\n\n  The moment of time and space that the input time came from.\n\n - `[output]` a boolean array\n\n  Array of three elements, two of which are false, and one is true. The true value should be at the 1st, 2nd or 3rd place for past, present and future respectively.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def moment_of_time_in_space (s : String) : List Bool :=\n  sorry\n\ndef sum_digits (s : String) : Nat :=\n  sorry\n\ndef count_non_digits (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem output_is_three_bools (s : String) :\n  let result := moment_of_time_in_space s\n  List.length result = 3 ∧\n  List.all result (fun x => x = true ∨ x = false) :=\nsorry\n\ntheorem exactly_one_true (s : String) :\n  let result := moment_of_time_in_space s\n  let count := List.foldl (fun acc b => acc + if b then 1 else 0) 0 result\n  count = 1 :=\nsorry\n\ntheorem time_space_comparison (s : String) :\n  let time := sum_digits s\n  let space := count_non_digits s\n  let result := moment_of_time_in_space s\n  (time < space → result = [true, false, false]) ∧\n  (time = space → result = [false, true, false]) ∧\n  (time > space → result = [false, false, true]) :=\nsorry\n\ntheorem permutation_invariant {s₁ s₂ : String} :\n  s₁.length = s₂.length →\n  (∀ c, s₁.find (· = c) = s₂.find (· = c)) →\n  moment_of_time_in_space s₁ = moment_of_time_in_space s₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [True, False, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"01:00 pm\"\n\n/--\ninfo: [False, True, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:02 pm\"\n\n/--\ninfo: [False, False, True]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:30 pm\""}
{"id": "fvapps_003604", "vc-description": "/-\n\"The Shell Game\" involves cups upturned on a playing surface, with a ball placed underneath one of them.  The index of the cups are swapped around multiple times. After that the players will try to find which cup contains the ball.\n\nYour task is as follows.  Given the cup that the ball starts under, and list of swaps, return the location of the ball at the end.  Cups are given like array/list indices.\n\nFor example, given the starting position `0` and the swaps `[(0, 1), (1, 2), (1, 0)]`:\n\n * The first swap moves the ball from `0` to `1`\n * The second swap moves the ball from `1` to `2`\n * The final swap doesn't affect the position of the ball.\n\n So\n\n```python\nfind_the_ball(0, [(0, 1), (2, 1), (0, 1)]) == 2\n```\n\nThere aren't necessarily only three cups in this game, but there will be at least two.  You can assume all swaps are valid, and involve two distinct indices.\n-/", "vc-preamble": "def iterateN (f : Nat → Nat) : Nat → Nat → Nat\n  | 0, x => x\n  | n+1, x => iterateN f n (f x)", "vc-helpers": "", "vc-definitions": "def find_the_ball (start : Nat) (swaps : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem find_the_ball_no_swaps (start : Nat) :\n  find_the_ball start [] = start :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_the_ball 5 []\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2)]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2), (2, 3)]"}
{"id": "fvapps_003607", "vc-description": "/-\n# Task\n John is new to spreadsheets. He is well aware of rows and columns, but he is not comfortable with spreadsheets numbering system.\n```\nSpreadsheet             Row Column\nA1                      R1C1\nD5                       R5C4\nAA48                    R48C27\nBK12                   R12C63```\nSince John has a lot of work to do both in row-column and spreadsheet systems, he needs a program that converts cell numbers from one system to another.\n\n# Example\n\n For `s = \"A1\"`, the result should be `\"R1C1\"`.\n\n For `s = \"R48C27\"`, the result should be `\"AA48\"`.\n\n- Input/Output\n\n - `[input]` string `s`\n\n  The position (in spreadsheet or row-column numbering system).\n\n  `Spreadsheet : A1 to CRXO65535`\n\n  `Row-Column: R1C1 to R65535C65535`\n\n - `[output]` a string\n\n  The position (in the opposite format; if input was in spreadsheet system, the output should be int row-column system, and vise versa).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def spreadsheet (s : String) : String :=\nsorry\n\ndef is_valid_a1 (s : String) : Bool :=\nsorry\n\ndef is_valid_r1c1 (s : String) : Bool :=\nsorry", "vc-theorems": "theorem a1_conversion {s : String} (h : is_valid_a1 s = true) :\n  is_valid_r1c1 (spreadsheet s) = true ∧\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem r1c1_conversion {s : String} (h : is_valid_r1c1 s = true) :\n  is_valid_a1 (spreadsheet s) = true ∧\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem conversion_idempotent_a1 {s : String} (h : is_valid_a1 s = true) :\n  spreadsheet (spreadsheet s) = s :=\nsorry\n\ntheorem conversion_idempotent_r1c1 {s : String} (h : is_valid_r1c1 s = true) :\n  spreadsheet (spreadsheet s) = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'R1C1'\n-/\n#guard_msgs in\n#eval spreadsheet \"A1\"\n\n/--\ninfo: 'AA48'\n-/\n#guard_msgs in\n#eval spreadsheet \"R48C27\"\n\n/--\ninfo: 'R12C63'\n-/\n#guard_msgs in\n#eval spreadsheet \"BK12\""}
{"id": "fvapps_003619", "vc-description": "/-\n# Task\n Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.\n\n After doing more research, Fred has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the `x` axis. Locations below the `x` axis are in the water. The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.)\n\n ![](http://media.openjudge.cn/images/1005/semicircle.GIF)\n\n Given two coordinates `x` and `y`, your task is to calculate that Fred Mapper's house will begin eroding in how many years.\n\n Note:\n\n 1. No property will appear exactly on the semicircle boundary: it will either be inside or outside. \n\n 2. All locations are given in miles.\n\n 3. (0,0) will not be given.\n\n# Example\n\n For `x = 1, y = 1`, the result should be `1`.\n\n After 1 year, Fred Mapper's house will begin eroding.\n\n For `x = 25, y = 0`, the result should be `20`.\n\n After 20 year, Fred Mapper's house will begin eroding.\n\n# Input/Output\n\n - `[input]` integer `x`\n\n  The X coordinates of the land Fred is considering. It will be an integer  point numbers measured in miles. \n\n  `-100 <= x <= 100`\n\n - `[input]` integer `y`\n\n  The Y coordinates of the land Fred is considering. It will be an integer point numbers measured in miles. \n\n  `0 <= y <= 100`\n\n - `[output]` an integer\n\n The first year (start from 1) this point will be within the semicircle AT THE END OF YEAR.\n-/\n\n-- Simplified for demo\n\n-- Simplified for demo", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Real := Int\n\ndef does_fred_need_houseboat (x y : Int) : Int :=\n  sorry\n\ndef pi : Int := 3\n\ndef ceil (r : Int) : Int :=\n  sorry", "vc-theorems": "theorem does_fred_need_houseboat_nonnegative {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y ≥ 0 := by\n  sorry\n\ntheorem does_fred_need_houseboat_symmetric {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y = does_fred_need_houseboat (-x) y := by\n  sorry\n\ntheorem does_fred_need_houseboat_increases {x y cx cy : Int}\n  (h1 : y ≥ 0)\n  (h2 : x.natAbs > 0 ∨ y > 0)\n  (h3 : cx = x / 2)\n  (h4 : cy = y / 2) :\n  does_fred_need_houseboat x y ≥ does_fred_need_houseboat cx cy := by\n  sorry\n\ntheorem does_fred_need_houseboat_formula {x y : Int} (h : y ≥ 0) :\n  does_fred_need_houseboat x y = ceil (pi * ((x * x) + (y * y)) / 100) := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 1 1\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 25 0\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 10 10"}
{"id": "fvapps_003627", "vc-description": "/-\nThe [Chinese zodiac](https://en.wikipedia.org/wiki/Chinese_zodiac) is a repeating cycle of 12 years, with each year being represented by an animal and its reputed attributes. The lunar calendar is divided into cycles of 60 years each, and each year has a combination of an animal and an element. There are 12 animals and 5 elements; the animals change each year, and the elements change every 2 years. The current cycle was initiated in the year of 1984 which was the year of the Wood Rat.\n\nSince the current calendar is Gregorian, I will only be using years from the epoch 1924.\n*For simplicity I am counting the year as a whole year and not from January/February to the end of the year.*\n\n##Task\n\nGiven a year, return the element and animal that year represents (\"Element Animal\"). \nFor example I'm born in 1998 so I'm an \"Earth Tiger\".\n\n```animals``` (or ```$animals``` in Ruby) is a preloaded array containing the animals in order:\n\n```['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', 'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']```\n\n```elements``` (or ```$elements``` in Ruby) is a preloaded array containing the elements in order:\n\n```['Wood', 'Fire', 'Earth', 'Metal', 'Water']```\n\nTell me your zodiac sign and element in the comments. Happy coding :)\n-/", "vc-preamble": "def Elements := [\"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\"]\n\ndef Animals := [\"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\",\n               \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\"]\n\ndef String.splitToList (s : String) : List String :=\n  s.split (· = ' ')", "vc-helpers": "", "vc-definitions": "def chinese_zodiac (year : Int) : String :=\nsorry", "vc-theorems": "theorem cycle_12_years {y : Int} (h : y ≥ 1900 ∧ y ≤ 2100) :\n  (chinese_zodiac y).splitToList[1]! = (chinese_zodiac (y + 12)).splitToList[1]! :=\nsorry\n\ntheorem cycle_10_years {y : Int} (h : y ≥ 1900 ∧ y ≤ 2100) :\n  (chinese_zodiac y).splitToList[0]! = (chinese_zodiac (y + 10)).splitToList[0]! :=\nsorry\n\ntheorem valid_format {year : Int} (h : year ≥ 1900 ∧ year ≤ 2100) :\n  let result := chinese_zodiac year\n  let parts := result.splitToList\n  parts[0]! ∈ Elements ∧ parts[1]! ∈ Animals :=\nsorry\n\ntheorem deterministic {year : Int} (h : year ≥ 1900 ∧ year ≤ 2100) :\n  chinese_zodiac year = chinese_zodiac year :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Wood Snake'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1965\n\n/--\ninfo: 'Earth Tiger'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1998\n\n/--\ninfo: 'Fire Monkey'\n-/\n#guard_msgs in\n#eval chinese_zodiac 2016"}
{"id": "fvapps_003631", "vc-description": "/-\nRegex Failure - Bug Fixing #2\nOh no, Timmy's received some hate mail recently but he knows better. Help Timmy fix his regex filter so he can be awesome again!\n-/\n\n/- Helper function to count occurrences of a substring -/\n\n/- Helper function to check if a string contains a substring -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def filter_words (s : String) : String :=\nsorry\n\ndef countSubstr (s : String) (sub : String) : Nat :=\nsorry\n\ndef containsSubstr (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem filter_words_output_is_string (s : String) :\n  filter_words s = filter_words s :=\nsorry\n\ntheorem filter_words_idempotent (s : String) :\n  filter_words (filter_words s) = filter_words s :=\nsorry\n\ntheorem filter_words_preserves_other_content (s : String) :\n  let banned_pattern := \"bad|mean|ugly|horrible|hideous\"\n  let remove_banned (str : String) := str.replace banned_pattern \"\"\n  remove_banned s = remove_banned (filter_words s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003633", "vc-description": "/-\nBelow is a right-angled triangle:\n\n```\n  |\\\n  | \\\n  |  \\\n  |   \\ \no |    \\ h \n  |     \\\n  |    θ \\\n  |_______\\ \n     a\n```\n\nYour challange is to write a function (```missingAngle``` in C/C#, ```missing_angle``` in Ruby), that calculates the angle θ in degrees to the nearest integer. You will be given three arguments representing each side: o, h and a. One of the arguments equals zero. Use the length of the two other sides to calculate θ. You will not be expected to handle any erronous data in your solution.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Float.toDegrees (x : Float) : Float :=\n  sorry\n\ndef Int.toFloat (x : Int) : Float :=\n  sorry\n\ndef missing_angle (h a o : Float) : Int :=\n  sorry", "vc-theorems": "theorem missing_angle_output_range (h a o : Float) :\n  h > 0 ∨ a > 0 ∨ o > 0 →\n  let angle := missing_angle h a o\n  0 ≤ angle ∧ angle ≤ 90 :=\nsorry\n\ntheorem missing_angle_with_missing_hyp (a o : Float) :\n  a > 0 ∧ o > 0 →\n  let angle := missing_angle 0 a o\n  (Int.toFloat angle - Float.toDegrees ((o/a).atan)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_with_missing_adj (h o : Float) :\n  h > 0 ∧ o > 0 →\n  let angle := missing_angle h 0 o\n  (Int.toFloat angle - Float.toDegrees ((o/h).asin)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_with_missing_opp (h a : Float) :\n  h > 0 ∧ a > 0 →\n  let angle := missing_angle h a 0\n  (Int.toFloat angle - Float.toDegrees ((a/h).acos)).abs ≤ 1 :=\nsorry\n\ntheorem missing_angle_two_zeros (o : Float) :\n  o > 0 →\n  ¬∃angle, missing_angle 0 0 o = angle :=\nsorry\n\ntheorem missing_angle_invalid_triangle (h a : Float) :\n  h > 0 ∧ a > 0 →\n  a > h →\n  ¬∃angle, missing_angle h a 0 = angle :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 0 400 300\n\n/--\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 5 4 0\n\n/--\ninfo: 39\n-/\n#guard_msgs in\n#eval missing_angle 8 0 5"}
{"id": "fvapps_003635", "vc-description": "/-\n# The Invitation\n\nMost of us played with toy blocks growing up. It was fun and you learned stuff. So what else can you do but rise to the challenge when a 3-year old exclaims, \"Look, I made a square!\", then pointing to a pile of blocks, \"Can _you_ do it?\"\n\n# These Blocks\n\nJust to play along, of course we'll be viewing these blocks in two dimensions. Depth now being disregarded, it turns out the pile has four different sizes of block: `1x1`, `1x2`, `1x3`, and `1x4`. The smallest one represents the area of a square, the other three are rectangular, and all differ by their width. Integers matching these four widths are used to represent the blocks in the input.\n\n# This Square\n\nWell, the kid made a `4x4` square from this pile, so you'll have to match that. Noticing the way they fit together, you realize the structure must be built in fours rows, one row at a time, where the blocks must be placed horizontally. With the known types of block, there are five types of row you could build:\n\n* 1 four-unit block\n* 1 three-unit block plus 1 one-unit bock (in either order)\n* 2 two-unit blocks\n* 1 two-unit block plus 2 one-unit blocks (in any order)\n* 4 one-unit blocks\n\nAmounts for all four of the block sizes in the pile will each vary from `0` to `16`. The total size of the pile will also vary from `0` to `16`. The order of rows is irrelevant. A valid square doesn't have to use up all the given blocks.\n\n# Some Examples\n\nGiven `1, 3, 2, 2, 4, 1, 1, 3, 1, 4, 2` there are many ways you could construct a square. Here are three possibilities, as described by their four rows:\n\n* 1 four-unit block\n* 2 two-unit blocks\n* 1 four-unit block\n* 4 one-unit blocks\n>\n* 1 three-unit block plus 1 one-unit block\n* 2 two-unit blocks\n* 1 four-unit block\n* 1 one-unit block plus 1 three-unit block\n>\n* 2 two-unit blocks\n* 1 three-unit block plus 1 one-unit block\n* 1 four-unit block\n* 2 one-unit blocks plus 1 two-unit block\n>\n\nGiven `1, 3, 2, 4, 3, 3, 2` there is no way to complete the task, as you could only build three rows of the correct length. The kid will not be impressed.\n\n* 2 two-unit blocks\n* 1 three-unit block plus 1 one-unit block\n* 1 four-unit block\n* (here only sadness)\n>\n\n# Input\n```python\nblocks ~ a random list of integers (1 <= x <= 4)\n```\n# Output\n```python\nTrue or False ~ whether you can build a square\n```\n# Enjoy!\n\nIf interested, I also have [this kata](https://www.codewars.com/kata/5cb7baa989b1c50014a53333) as well as [this other kata](https://www.codewars.com/kata/5cb5eb1f03c3ff4778402099) to consider solving.\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def build_square (blocks: List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem sum_16_if_buildable {blocks : List Nat} :\n  build_square blocks = true →\n  list_sum blocks ≥ 16 :=\nsorry\n\ntheorem input_unchanged {blocks : List Nat} :\n  build_square blocks = b →\n  blocks = blocks :=\nsorry\n\ntheorem invalid_pieces {blocks : List Nat} :\n  (∀ x ∈ blocks, x < 1 ∨ x > 4) →\n  build_square blocks = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [1, 1, 1, 1, 1, 1, 1, 2, 3, 4]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval build_square [1, 3, 2, 4, 3, 3, 2]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [4, 2, 2, 1, 1, 1, 1, 3, 3, 3, 1]"}
{"id": "fvapps_003640", "vc-description": "/-\nFour-digit palindromes start with `[1001,1111,1221,1331,1441,1551,1551,...]` and the number at position `2` is `1111`.  \n\nYou will be given two numbers `a` and `b`. Your task is to return the `a-digit` palindrome at position `b` if the palindromes were arranged in increasing order. \n\nTherefore, `palin(4,2) = 1111`, because that is the second element of the `4-digit` palindrome series.\n\nMore examples in the test cases. Good luck!\n\nIf you like palindrome Katas, please try:\n\n[Palindrome integer composition](https://www.codewars.com/kata/599b1a4a3c5292b4cc0000d5)\n\n[Life without primes](https://www.codewars.com/kata/59f8750ac374cba8f0000033)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palin (length pos : Nat) : Nat :=\nsorry\n\ndef is_palindrome (n : Nat) : Bool :=\nsorry\n\ndef num_length (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_digit_palindromes (pos : Nat) (h : 0 < pos ∧ pos < 10) :\n  let result := palin 1 pos\n  result = pos ∧ result < 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 22\n-/\n#guard_msgs in\n#eval palin 2 2\n\n/--\ninfo: 1441\n-/\n#guard_msgs in\n#eval palin 4 5\n\n/--\ninfo: 102201\n-/\n#guard_msgs in\n#eval palin 6 3"}
{"id": "fvapps_003649", "vc-description": "/-\nFor encrypting strings this region of chars is given (in this order!):\n\n* all letters (ascending, first all UpperCase, then all LowerCase)\n* all digits (ascending)\n* the following chars: `.,:;-?! '()$%&\"` \n\nThese are 77 chars! (This region is zero-based.)\n\nWrite two methods: \n```python\ndef encrypt(text)\ndef decrypt(encrypted_text)\n```\n\nPrechecks:\n1. If the input-string has chars, that are not in the region, throw an Exception(C#, Python) or Error(JavaScript).\n2. If the input-string is null or empty return exactly this value!\n\nFor building the encrypted string:\n1. For every second char do a switch of the case.\n2. For every char take the index from the region. Take the difference from the region-index of the char before (from the input text! Not from the fresh encrypted char before!). (Char2 = Char1-Char2)\nReplace the original char by the char of the difference-value from the region. In this step the first letter of the text is unchanged.\n3. Replace the first char by the mirror in the given region. (`'A' -> '\"'`, `'B' -> '&'`, ...)\n\nSimple example:\n\n* Input:  `\"Business\"`\n* Step 1: `\"BUsInEsS\"`\n* Step 2: `\"B61kujla\"`\n  * `B -> U`\n    * `B (1) - U (20) = -19`\n    * `-19 + 77 = 58`\n    * `Region[58] = \"6\"`\n  * `U -> s`\n    * `U (20) - s (44) = -24`\n    * `-24 + 77 = 53`\n    * `Region[53] = \"1\"`\n* Step 3: `\"&61kujla\"`\n\nThis kata is part of the Simple Encryption Series:\nSimple Encryption #1 - Alternating Split\nSimple Encryption #2 - Index-Difference\nSimple Encryption #3 - Turn The Bits Around\nSimple Encryption #4 - Qwerty\n\nHave fun coding it and please don't forget to vote and rank this kata! :-)\n-/", "vc-preamble": "def REGION : String := \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef charAtPos (s : String) (pos : Nat) : Char := s.data[pos]!", "vc-helpers": "", "vc-definitions": "def encrypt (s : String) : String :=\nsorry\n\ndef decrypt (s : String) : String :=\nsorry\n\ndef isValidText (s : String) : Bool :=\nsorry", "vc-theorems": "theorem encryption_decryption_roundtrip (s : String) (h : isValidText s = true) :\n  decrypt (encrypt s) = s :=\nsorry\n\ntheorem encrypted_uses_valid_chars (s : String) (h : isValidText s = true) (h2 : s ≠ \"\") :\n  isValidText (encrypt s) = true :=\nsorry\n\ntheorem invalid_chars_raise_exception (s : String) (h : isValidText s = false) :\n  encrypt s = \"\" ∧ decrypt s = \"\" :=\nsorry\n\ntheorem empty_string :\n  encrypt \"\" = \"\" ∧ decrypt \"\" = \"\" :=\nsorry\n\ntheorem second_chars_different (s : String) (h : isValidText s = true) (h2 : s.length ≥ 2) :\n  encrypt s ≠ s :=\nsorry\n\ntheorem first_char_mirrored (s : String) (h : isValidText s = true) (h2 : s ≠ \"\") :\n  (charAtPos (encrypt s) 0) = (charAtPos REGION (REGION.length - 1)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: encrypted1\n-/\n#guard_msgs in\n#eval encrypt \"Business\"\n\n/--\ninfo: text1\n-/\n#guard_msgs in\n#eval decrypt encrypted1\n\n/--\ninfo: encrypted2\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\"\n\n/--\ninfo: text2\n-/\n#guard_msgs in\n#eval decrypt encrypted2\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval decrypt \"\""}
{"id": "fvapps_003663", "vc-description": "/-\nUnscramble the eggs.\n\nThe string given to your function has had an \"egg\" inserted directly after each consonant.  You need to return the string before it became eggcoded.\n\n## Example\n\nKata is supposed to be for beginners to practice regular expressions, so commenting would be appreciated.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unscramble_eggs (s : String) : String :=\nsorry\n\ndef containsEgg (s : String) : Bool :=\nsorry\n\ndef countSpaces (s : String) : Nat :=\nsorry", "vc-theorems": "theorem no_eggs_in_result (s : String) :\n  containsEgg (unscramble_eggs s) = false :=\nsorry\n\ntheorem preserves_space_count (s : String) :\n  countSpaces s = countSpaces (unscramble_eggs s) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'code here'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"ceggodegge heggeregge\"\n\n/--\ninfo: 'FUN KATA'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"FeggUNegg KeggATeggA\"\n\n/--\ninfo: 'vegymite on toast'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"veggegeggyeggmeggitegge onegg teggoaseggtegg\""}
{"id": "fvapps_003677", "vc-description": "/-\nWrite a function that accepts two parameters, i) a string (containing a list of words) and ii) an integer (n).  The function should alphabetize the list based on the nth letter of each word.\n\nThe letters should be compared case-insensitive. If both letters are the same, order them normally (lexicographically), again, case-insensitive.\n\nexample:\n```javascript \nfunction sortIt('bid, zag', 2) //=> 'zag, bid'\n```\n```ruby \nfunction sortIt('bid, zag', 2) //=> 'zag, bid'\n```\n```python \nfunction sortIt('bid, zag', 2) #=> 'zag, bid'\n```\n\nThe length of all words provided in the list will be >= n.  The format will be \"x, x, x\". In Haskell you'll get a list of `String`s instead.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_it (s : String) (n : Nat) : String :=\nsorry\n\ndef isCharNSorted (words : List String) (n : Nat) : Bool :=\nsorry\n\ndef sameSets (s1 : List String) (s2 : List String) : Bool :=\nsorry\n\ndef wordsFromString (s : String) : List String :=\nsorry", "vc-theorems": "theorem sort_it_preserves_words (s : String) (n : Nat) :\n  n > 0 → sameSets (wordsFromString s) (wordsFromString (sort_it s n)) :=\nsorry\n\ntheorem sort_it_is_n_sorted (s : String) (n : Nat) (h : n > 0) :\n  isCharNSorted (wordsFromString (sort_it s n)) n :=\nsorry\n\ntheorem sort_it_first_char_is_normal_sort (s : String) :\n  sort_it s 1 = String.intercalate \", \" (wordsFromString s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003681", "vc-description": "/-\nThe T9 typing predictor helps with suggestions for possible word combinations on an old-style numeric keypad phone. Each digit in the keypad (2-9) represents a group of 3-4 letters. To type a letter, press once the key which corresponds to the letter group that contains the required letter. Typing words is done by typing letters of the word in sequence.\n\nThe letter groups and corresponding digits are as follows:\n```\n -----------------\n|  1  |  2  |  3  |\n|     | ABC | DEF |\n|-----|-----|-----|\n|  4  |  5  |  6  |\n| GHI | JKL | MNO |\n|-----|-----|-----|\n|  7  |  8  |  9  |\n| PQRS| TUV | WXYZ|\n -----------------\n```\n\nThe prediction algorithm tries to match the input sequence against a predefined dictionary of words. The combinations which appear in the dictionary are considered valid words and are shown as suggestions.\n\nGiven a list of words as a reference dictionary, and a non-empty string (of digits 2-9) as input, complete the function which returns suggestions based on the string of digits, which are found in the reference dictionary.\n\nFor example:\n```python\nT9(['hello', 'world'], '43556') returns ['hello']\nT9(['good', 'home', 'new'], '4663') returns ['good', 'home']\n```\n\nNote that the dictionary must be case-insensitive (`'hello'` and `'Hello'` are same entries). The list returned must contain the word as it appears in the dictionary (along with the case).\n\nExample:\n```python\nT9(['Hello', 'world'], '43556') returns ['Hello']\n```\n\nIf there is no prediction available from the given dictionary, then return the string containing first letters of the letter groups, which correspond to the input digits.\n\nFor example:\n```python\nT9([], '43556') returns ['gdjjm']\nT9(['gold', 'word'], '4663') returns ['gmmd']\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def translateTableNum (s : String) : String :=\n  sorry\n\ndef t9_predict (words : List String) (seq : String) : List String :=\n  sorry", "vc-theorems": "theorem t9_predict_never_empty (words : List String) (seq : String) :\n  seq ≠ \"\" → ∃ result, t9_predict words seq = result ∧ result.length > 0 :=\nsorry\n\ntheorem t9_predict_fallback_on_no_matches (words : List String) (seq : String) :\n  seq ≠ \"\" →\n  (∀ w ∈ words, translateTableNum w.toLower ≠ seq) →\n  ∃ result, t9_predict words seq = [result] ∧ result.length = seq.length :=\nsorry\n\ntheorem t9_predict_all_matches_sequence (words : List String) (seq : String) :\n  seq ≠ \"\" →\n  ∀ w ∈ t9_predict words seq, translateTableNum w.toLower = seq :=\nsorry\n\ntheorem t9_predict_empty_dict (seq : String) :\n  seq ≠ \"\" →\n  ∃ result, t9_predict [] seq = [result] ∧ result.length = seq.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['hello']\n-/\n#guard_msgs in\n#eval t9_predict [\"hello\", \"world\"] \"43556\"\n\n/--\ninfo: ['good', 'home']\n-/\n#guard_msgs in\n#eval t9_predict [\"good\", \"home\", \"new\"] \"4663\"\n\n/--\ninfo: ['gdjjm']\n-/\n#guard_msgs in\n#eval t9_predict [] \"43556\""}
{"id": "fvapps_003683", "vc-description": "/-\nYou love coffee and want to know what beans you can afford to buy it.\n\nThe first argument to your search function will be a number which represents your budget.\n\nThe second argument will be an array of coffee bean prices.\n\nYour 'search' function should return the stores that sell coffee within your budget. \n\nThe search function should return a string of prices for the coffees beans you can afford. The prices in this string are to be sorted in ascending order.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.toFloat (s : String) : Option Float :=\nsorry\n\ndef List.sort (l : List Float) (lt : Float → Float → Bool) : List Float := sorry\n\ndef search (budget : Float) (prices : List Float) : String :=\n  sorry", "vc-theorems": "theorem search_sorted (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  ∀ i, i < nums.length - 1 → nums[i]! ≤ nums[i+1]! :=\nsorry\n\ntheorem search_within_budget (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  ∀ x ∈ nums, x ≤ budget :=\nsorry\n\ntheorem search_includes_all_eligible (budget : Float) (prices : List Float)\n  (h1 : budget ≥ 0) (h2 : budget ≤ 1000)\n  (h3 : ∀ x ∈ prices, x ≥ 0 ∧ x ≤ 1000)\n  (h4 : prices ≠ []) :\n  let eligible := List.sort (prices.filter (· ≤ budget)) (·≤·)\n  let result := search budget prices\n  result = String.intercalate \",\" (eligible.map toString) :=\nsorry\n\ntheorem search_zero_budget (prices : List Float)\n  (h1 : ∀ x ∈ prices, x ≥ 0)\n  (h2 : prices ≠ []) :\n  let eligible := List.sort (prices.filter (·≤ 0)) (·≤·)\n  search 0 prices = String.intercalate \",\" (eligible.map toString) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1,2,2'\n-/\n#guard_msgs in\n#eval search 3 [6, 1, 2, 9, 2]\n\n/--\ninfo: '3,7,7,9,14'\n-/\n#guard_msgs in\n#eval search 14 [7, 3, 23, 9, 14, 20, 7]\n\n/--\ninfo: '0,1,2.7,5.5'\n-/\n#guard_msgs in\n#eval search 24 [2.7, 0, 100.9, 1, 5.5]"}
{"id": "fvapps_003688", "vc-description": "/-\n# RegExp Fun #1 - When I miss few days of gym\n\n## Disclaimer\n\nThe background story of this Kata is 100% fiction.  Any resemblance to real people or real events is **nothing more than a coincidence** and should be regarded as such.\n\n## Background Story\n\nYou are a person who loves to go to the gym everyday with the squad of people that you've known since early childhood.  However, you recently contracted a sickness that forced you to stay at home for over a week.  As you see your body getting weaker and weaker every day and as you see your biceps and triceps disappearing, you can't help but lay in bed and cry.  You're usually an optimistic person but this time negative thoughts come to your head ... \n\n![When I miss few days of gym](https://pics.onsizzle.com/Instagram-faf8c9.png)\n\n## Task\n\nAs can be seen from the funny image above (or am I the only person to find the picture above hilarious?) there is lots of slang.  Your task is to define a function ```gymSlang``` which accepts a string argument and does the following:\n\n1. Replace *all* instances of ```\"probably\"``` to ```\"prolly\"```\n2. Replace *all* instances of ```\"i am\"``` to ```\"i'm\"```\n3. Replace *all* instances of ```\"instagram\"``` to ```\"insta\"```\n4. Replace *all* instances of ```\"do not\"``` to ```\"don't\"```\n5. Replace *all* instances of ```\"going to\"``` to ```\"gonna\"```\n6. Replace *all* instances of ```\"combination\"``` to ```\"combo\"```\n\nYour replacement regexes **should be case-sensitive**, only replacing the words above with slang if the detected pattern is in **lowercase**.  However, please note that apart from 100% lowercase matches, you will **also have to replace matches that are correctly capitalized** (e.g. ```\"Probably\" => \"Prolly\"``` or ```\"Instagram\" => \"Insta\"```).\n\nFinally, your code will be tested to make sure that you have used **RegExp** replace in your code.\n\nEnjoy :D\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.findSubstr? (pattern : String) (s : String) : Option String.Pos :=\n  sorry\n\ndef gym_slang (s : String) : String :=\n  sorry", "vc-theorems": "theorem gym_slang_length (s : String) :\n  String.length (gym_slang s) ≤ String.length s :=\nsorry\n\ntheorem gym_slang_case_preserving_prob (s : String) :\n  (String.findSubstr? \"Probably\" s).isSome → (String.findSubstr? \"Prolly\" (gym_slang s)).isSome :=\nsorry\n\ntheorem gym_slang_case_preserving_prob_lower (s : String) :\n  (String.findSubstr? \"probably\" s).isSome → (String.findSubstr? \"prolly\" (gym_slang s)).isSome :=\nsorry\n\ntheorem gym_slang_all_transformations (s : String) :\n  let sLower := s.toLower\n  let resultLower := (gym_slang s).toLower\n  (Option.isSome (String.findSubstr? \"probably\" sLower) ↔ Option.isSome (String.findSubstr? \"prolly\" resultLower)) ∧\n  (Option.isSome (String.findSubstr? \"combination\" sLower) ↔ Option.isSome (String.findSubstr? \"combo\" resultLower)) :=\nsorry\n\ntheorem gym_slang_identity (s : String) :\n  (Option.isNone (String.findSubstr? \"probably\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"i am\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"instagram\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"do not\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"going to\" s.toLower)) →\n  (Option.isNone (String.findSubstr? \"combination\" s.toLower)) →\n  gym_slang s = s :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003698", "vc-description": "/-\nIn this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on: \n\n* make as few changes as possible. \n* if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase. \n\nFor example:\n```Haskell\nsolve(\"coDe\") = \"code\". Lowercase characters > uppercase. Change only the \"D\" to lowercase.\nsolve(\"CODe\") = \"CODE\". Uppercase characters > lowecase. Change only the \"e\" to uppercase.\nsolve(\"coDE\") = \"code\". Upper == lowercase. Change all to lowercase.\n```\n\nMore examples in test cases. Good luck!\n\nPlease also try:\n\n[Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n\n[Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : String :=\nsorry\n\ndef isUpper (s : String) : Bool :=\nsorry\n\ndef isLower (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_returns_either_upper_or_lower (s : String) :\n  (solve s = s.toUpper) ∨ (solve s = s.toLower) :=\nsorry\n\ntheorem solve_preserves_uppercase (s : String) :\n  isUpper s = true → solve s = s.toUpper :=\nsorry\n\ntheorem solve_preserves_lowercase (s : String) :\n  isLower s = true → solve s = s.toLower :=\nsorry\n\ntheorem solve_preserves_length (s : String) :\n  (solve s).length = s.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDe\"\n\n/--\ninfo: 'CODE'\n-/\n#guard_msgs in\n#eval solve \"CODe\"\n\n/--\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDE\""}
{"id": "fvapps_003700", "vc-description": "/-\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFinish the solution so that it returns the sum of all the multiples of 3 or 5 **below** the number passed in. \n\n> Note: If the number is a multiple of **both** 3 and 5, only count it *once*.\n> Also, if a number is negative, return 0(for languages that do have them)\n\n###### *Courtesy of projecteuler.net*\n-/", "vc-preamble": "def sumMultiples (n : Nat) : Int :=\n  (List.range n).map Int.ofNat\n  |>.filter (fun x => x % 3 = 0 ∨ x % 5 = 0)\n  |>.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def solution (n : Int) : Int :=\nsorry", "vc-theorems": "theorem solution_nonnegative (n : Int) :\n  solution n ≥ 0 ∧ (n ≤ 0 → solution n = 0) :=\nsorry\n\ntheorem multiples_property {n : Nat} :\n  0 < n →\n  solution (Int.ofNat n) = sumMultiples n :=\nsorry\n\ntheorem result_smaller_than_input_squared {n : Int} :\n  n > 0 → solution n < n * n :=\nsorry\n\ntheorem negative_inputs :\n  ∀ n : Int, n < 0 → solution n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 23\n-/\n#guard_msgs in\n#eval solution 10\n\n/--\ninfo: 78\n-/\n#guard_msgs in\n#eval solution 20\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solution 0"}
{"id": "fvapps_003707", "vc-description": "/-\nIn this Kata, you will be given a string of numbers in sequence and your task will be to return the missing number. If there is no number\nmissing or there is an error in the sequence, return `-1`.\n\nFor example:\n```Haskell\nmissing(\"123567\") = 4 \nmissing(\"899091939495\") = 92\nmissing(\"9899101102\") = 100\nmissing(\"599600601602\") = -1 -- no number missing\nmissing(\"8990919395\") = -1 -- error in sequence. Both 92 and 94 missing.\n```\nThe sequence will always be in ascending order.\n\nMore examples in the test cases. \n\nGood luck!\n-/\n\n/- For a sequence with one number removed, missing finds the removed number -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For a complete sequence with no gaps, missing returns -1 -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.isDigit : String → Bool :=\n  sorry\n\ndef missing : String → Int :=\n  sorry\n\ndef isSequence : String → Bool :=\n  sorry", "vc-theorems": "theorem missing_finds_gap {start : Nat} (h : start ≥ 1 ∧ start ≤ 99) :\n  ∀ seq target,\n  (∃ curr, curr = start ∧\n    seq = String.join (List.map toString (List.range curr)) ∧\n    target = curr + 1 ∧\n    isSequence (seq.replace (toString target) \"\")) →\n  missing (seq.replace (toString target) \"\") = target :=\nsorry\n\ntheorem missing_complete_sequence {start : Nat} (h : start ≥ 1 ∧ start ≤ 999) :\n  ∀ seq,\n  (∃ curr, curr = start ∧\n    seq = String.join (List.map toString (List.range curr)) ∧\n    isSequence seq) →\n  missing seq = -1 :=\nsorry", "vc-postamble": "/--\ninfo: 4\n-/\n#guard_msgs in\n#eval missing \"123567\"\n\n/--\ninfo: 92\n-/\n#guard_msgs in\n#eval missing \"899091939495\"\n\n/--\ninfo: 100\n-/\n#guard_msgs in\n#eval missing \"9899101102\""}
{"id": "fvapps_003710", "vc-description": "/-\nIn this Kata, you will sort elements in an array by decreasing frequency of elements. If two elements have the same frequency, sort them by increasing value. \n\nMore examples in test cases. \n\nGood luck!\n\nPlease also try [Simple time difference](https://www.codewars.com/kata/5b76a34ff71e5de9db0000f2)\n-/", "vc-preamble": "def List.isPermutationOf (l1 l2 : List Int) : Prop :=\n  ∀ x, (l1.filter (· = x)).length = (l2.filter (· = x)).length", "vc-helpers": "", "vc-definitions": "def solve (arr : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem solve_output_length {arr : List Int} (h : arr ≠ []) :\n  (solve arr).length = arr.length :=\nsorry\n\ntheorem solve_contains_same_elements {arr : List Int} (h : arr ≠ []) :\n  (solve arr).isPermutationOf arr :=\nsorry\n\ntheorem solve_maintains_frequency_order {arr : List Int} (h : arr ≠ []) :\n  let freq := fun x => (arr.filter (· = x)).length\n  ∀ i, i + 1 < (solve arr).length →\n    let curr := (solve arr).get! i\n    let next := (solve arr).get! (i+1)\n    freq curr > freq next ∨\n    (freq curr = freq next ∧ curr ≤ next) :=\nsorry\n\ntheorem solve_idempotent {arr : List Int} (h : arr ≠ []) :\n  solve (solve arr) = solve arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [2, 3, 5, 3, 7, 9, 5, 3, 7]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [1, 2, 3, 0, 5, 0, 1, 6, 8, 8, 6, 9, 1]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [5, 9, 6, 9, 6, 5, 9, 9, 4, 4]"}
{"id": "fvapps_003712", "vc-description": "/-\nAn expression is formed by taking the digits 1 to 9 in numerical order and then inserting into each gap between the numbers either a plus sign or a minus sign or neither.\n\nYour task is to write a method which takes one parameter and returns the **smallest possible number** of plus and minus signs necessary to form such an expression which equals the input.\n\n**Note:** All digits from 1-9 must be used exactly once.\n\nIf there is no possible expression that evaluates to the input, then return `null/nil/None`.\n\n~~~if:haskell\n`eval :: String -> Int` is available in `Preloaded` for your convenience.\n~~~\n\nThere are 50 random tests with upper bound of the input = 1000.\n\n## Examples\n\nWhen the input is 100, you need to return `3`, since that is the minimum number of signs required, because: 123 - 45 - 67 + 89 = 100 (3 operators in total).\n\nMore examples:\n```\n 11  -->  5  #  1 + 2 + 34 + 56 + 7 - 89 = 11\n100  -->  3  #  123 - 45 - 67 + 89 = 100\n766  -->  4  #  1 - 2 + 34 - 56 + 789 = 766\n160  -->  -  #  no solution possible\n```\n\nInspired by a [puzzle on BBC Radio 4](https://www.bbc.co.uk/programmes/p057wxwl) (which is unfortunately not available anymore)\n-/\n\n/- Helper function to check if expression uses given operators -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def operator_insertor (n : Int) : Option Int :=\nsorry\n\ndef expr_evaluates_to : Int → String → Prop :=\nsorry\n\ndef expr_uses_ops : List String → String → Prop :=\nsorry", "vc-theorems": "theorem operator_insertor_output_range (n : Int) :\n  match operator_insertor n with\n  | none => True\n  | some result => 0 ≤ result ∧ result ≤ 8\n  :=\nsorry\n\ntheorem operator_insertor_result_exists (n : Int) (result : Int) :\n  operator_insertor n = some result →\n  ∃ ops : List String,\n    (ops.length = result) ∧\n    (∀ op ∈ ops, op = \"+\" ∨ op = \"-\" ∨ op = \"\") ∧\n    (∃ expr : String, expr_evaluates_to n expr ∧ expr_uses_ops ops expr)\n  :=\nsorry\n\ntheorem operator_insertor_impossible_large (n : Int) :\n  n ≥ 10^10 → operator_insertor n = none :=\nsorry\n\ntheorem operator_insertor_impossible_small (n : Int) :\n  n ≤ -(10^10) → operator_insertor n = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-- Helper function to check if a string expression evaluates to a number -/\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval operator_insertor 11\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval operator_insertor 100\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval operator_insertor 160"}
{"id": "fvapps_003714", "vc-description": "/-\nGiven an array containing only integers, add all the elements and return the binary equivalent of that sum.\n\nIf the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.\n\n**Note:** The sum of an empty array is zero.\n\n```python\narr2bin([1,2]) == '11'\narr2bin([1,2,'a']) == False\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def arr2bin (arr : List α) : String :=\nsorry\n\ndef sumList (l : List Int) : Int :=\nsorry\n\ndef toBinaryString (n : Int) : String :=\nsorry\n\ndef allBinary (s : String) : Bool :=\nsorry\n\ndef stringToNat (s : String) : Nat :=\nsorry\n\ndef isAllInts (arr : List α) : Bool :=\nsorry\n\ndef listToInts (arr : List α) : List Int :=\nsorry", "vc-theorems": "theorem arr2bin_all_ints {arr : List Int} :\n  arr2bin arr = toBinaryString (sumList arr) :=\nsorry\n\ntheorem arr2bin_empty :\n  arr2bin ([] : List α) = \"0\" :=\nsorry\n\ntheorem arr2bin_positive_ints {arr : List Nat} :\n  let result := arr2bin arr\n  allBinary result ∧\n  stringToNat result = arr.foldl (init := 0) (·+·) :=\nsorry\n\ntheorem arr2bin_mixed_types {α} {arr : List α} :\n  (¬isAllInts arr → arr2bin arr = \"\") ∧\n  (isAllInts arr → arr2bin arr = toBinaryString (sumList (listToInts arr))) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '11'\n-/\n#guard_msgs in\n#eval arr2bin [1, 2]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval arr2bin [1, 2, \"a\"]\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval arr2bin []"}
{"id": "fvapps_003717", "vc-description": "/-\nIn elementary arithmetic a \"carry\" is a digit that is transferred from one column of digits to another column of more significant digits during a calculation algorithm.\n\nThis Kata is about determining the number of carries performed during the addition of multi-digit numbers.\n\nYou will receive an input string containing a set of pairs of numbers formatted as follows:\n\n```\n123 456\n555 555\n123 594\n```\n\nAnd your output should be a string formatted as follows:\n\n```\nNo carry operation\n1 carry operations\n3 carry operations\n```\n\n###Some Assumptions\n\n- Assume that numbers can be of any length.\n- But both numbers in the pair will be of the same length.\n- Although not all the numbers in the set need to be of the same length.\n- If a number is shorter, it will be zero-padded.\n- The input may contain any arbitrary number of pairs.\n-/", "vc-preamble": "def split (s : String) : List String := String.splitOn s \"\\n\"", "vc-helpers": "", "vc-definitions": "def countCarries (input : String) : String :=\nsorry\n\ndef carry_count (a b : Nat) : Nat :=\nsorry", "vc-theorems": "theorem single_line_carries_correct\n  (a b : Nat)\n  (h1 : a ≤ 999999)\n  (h2 : b ≤ 999999) :\n  let result := countCarries s!\"{a} {b}\"\n  let expected :=\n    let carry := carry_count a b\n    if carry = 0 then \"No carry operation\"\n    else s!\"{carry} carry operations\"\n  result = expected :=\nsorry\n\ntheorem multiple_lines_carries_length\n  {n : Nat}\n  (pairs : List (Nat × Nat))\n  (h1 : ∀ p : Nat × Nat, p ∈ pairs → (Prod.fst p) ≤ 9999 ∧ (Prod.snd p) ≤ 9999)\n  (h2 : pairs.length > 0)\n  (h3 : pairs.length ≤ 10) :\n  let input := String.intercalate \"\\n\" (pairs.map (λ p => s!\"{Prod.fst p} {Prod.snd p}\"))\n  (split (countCarries input)).length = pairs.length :=\nsorry\n\ntheorem single_digit_carries_correct\n  (a b : Nat)\n  (h1 : a ≤ 9)\n  (h2 : b ≤ 9) :\n  countCarries s!\"{a} {b}\" =\n    if a + b > 9 then \"1 carry operations\"\n    else \"No carry operation\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval count_carries \"123 456\\n555 555\\n123 594\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval count_carries \"99 99\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval count_carries \"1 9\\n123456789 111111101\""}
{"id": "fvapps_003718", "vc-description": "/-\nYour goal is to implement the method **meanVsMedian** which accepts an *odd-length* array of integers and returns one of the following:\n\n* 'mean' - in case **mean** value is **larger than** median value\n* 'median' - in case **median** value is **larger than** mean value\n* 'same' - in case both mean and median share the **same value**\n\nReminder: [Median](https://en.wikipedia.org/wiki/Median)\n\nArray will always be valid (odd-length >= 3)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mean_vs_median (l : List Int) : String :=\nsorry\n\ndef statistical_mean (l : List Int) : Float :=\nsorry\n\ndef statistical_median (l : List Int) : Float :=\nsorry", "vc-theorems": "theorem mean_vs_median_matches_statistics (l : List Int) (h : l ≠ []) :\n  let mean := statistical_mean l\n  let median := statistical_median l\n  mean_vs_median l = (if mean > median then \"mean\"\n                     else if median > mean then \"median\"\n                     else \"same\") :=\nsorry\n\ntheorem identical_numbers_return_same (l : List Int) (h1 : l ≠ [])\n  (h2 : ∀ x ∈ l, x = 1) :\n  mean_vs_median l = \"same\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'same'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 1, 1]\n\n/--\ninfo: 'mean'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 2, 37]\n\n/--\ninfo: 'median'\n-/\n#guard_msgs in\n#eval mean_vs_median [7, 14, -70]"}
{"id": "fvapps_003722", "vc-description": "/-\n# Task\n The `hamming distance` between a pair of numbers is the number of binary bits that differ in their binary notation. \n\n# Example\n\n For `a = 25, b= 87`, the result should be `4`\n```\n25: 00011001\n87: 01010111\n```\nThe `hamming distance` between these two would be 4 ( the `2nd, 5th, 6th, 7th` bit ).\n\n# Input/Output\n\n - `[input]` integer `a`\n\n  First Number. `1 <= a <= 2^20`\n\n - `[input]` integer `b`\n\n  Second Number. `1 <= b <= 2^20`\n\n - `[output]` an integer\n\n  Hamming Distance\n-/\n\n/- Hamming distance is symmetric -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Hamming distance between a number and itself is zero -/\n\n/- Hamming distance satisfies the triangle inequality -/\n\n/- Hamming distance is always nonnegative -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hamming_distance : Int → Int → Nat :=\n  sorry", "vc-theorems": "theorem hamming_distance_symmetric (a b : Int) :\n  hamming_distance a b = hamming_distance b a := by\n  sorry\n\ntheorem hamming_distance_self_zero (a : Int) :\n  hamming_distance a a = 0 := by\n  sorry\n\ntheorem hamming_distance_triangle_inequality (a b c : Int) :\n  hamming_distance a c ≤ hamming_distance a b + hamming_distance b c := by\n  sorry\n\ntheorem hamming_distance_nonnegative (a b : Int) :\n  hamming_distance a b ≥ 0 := by\n  sorry", "vc-postamble": "/--\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 25 87\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 256 302\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 543 634"}
{"id": "fvapps_003727", "vc-description": "/-\nSome numbers have funny properties. For example:\n\n> 89 --> 8¹ + 9² = 89 * 1\n\n> 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2\n\n> 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n\nGiven a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p \n- we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n. \n\nIn other words:\n\n> Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k\n\nIf it is the case we will return k, if not return -1.\n\n**Note**: n and p will always be given as strictly positive integers.\n\n```python\ndig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1\ndig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k\ndig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2\ndig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digSum (n : Nat) (p : Nat) : Nat :=\n  sorry\n\ndef digPow (n : Nat) (p : Nat) : Int :=\n  sorry", "vc-theorems": "theorem digPow_valid_result {n p : Nat} (h : digPow n p ≠ -1) :\n  digSum n p = (digPow n p).toNat * n ∧ digPow n p > 0 := by\n  sorry\n\ntheorem digPow_is_int (n p : Nat) :\n  ∃ k : Int, digPow n p = k := by\n  sorry\n\ntheorem digPow_power_one (n : Nat) :\n  digSum n 1 % n = 0 →\n  digPow n 1 = (digSum n 1) / n := by\n  sorry\n\ntheorem digPow_power_one_neg (n : Nat) :\n  digSum n 1 % n ≠ 0 →\n  digPow n 1 = -1 := by\n  sorry\n\ntheorem digPow_single_digit_power_one (n : Nat) :\n  n > 0 → n < 10 →\n  digPow n 1 = 1 := by\n  sorry\n\ntheorem digPow_large_power_is_int (n p : Nat) :\n  ∃ k : Int, digPow n p = k := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval dig_pow 89 1\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval dig_pow 92 1\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval dig_pow 695 2"}
{"id": "fvapps_003731", "vc-description": "/-\n# Letterss of Natac\nIn a game I just made up that doesn’t have anything to do with any other game that you may or may not have played, you collect resources on each turn and then use those resources to build settlements, roads, and cities or buy a development. Other kata about this game can be found [here](https://www.codewars.com/collections/59e6938afc3c49005900011f).\n\n## Task\nThis kata asks you to implement the function `build_or_buy(hand)` , which takes as input a `hand`, the resources you have (a string of letters representing the resources you have), and returns a list of the unique game objects you can build or buy given your hand. \n\nThere are five different resources, `'b'`, `'w'`, `'g'`, `'s'`, and `'o'`.\n\nGame objects and the resources required to build or buy them are as follows:\n1. `'road'`: `bw`\n2. `'settlement'`: `bwsg`\n3. `'city'`: `ooogg`\n4. `'development'`: `osg`\n\n## Examples\n```python\nbuild_or_buy(\"bwoo\")  => ['road']\nbuild_or_buy(\"bwsg\")  => ['road', 'settlement'] or ['settlement', 'road']\nbuild_or_buy(\"\")      => []\nbuild_or_buy(\"ogogoogogo\")  => ['city']\n\n```\n\n## Notes: \n1. Don't mutate the hand\n2. The order of the returned list doesn't matter\n3. You do not have to test for whether a hand is valid. \n4. The list will be interpreted to mean 'you can build any of these objects,' not 'you can build all these objects in one play'. See example 2 above, even though there is only one `'b'` and one `'w'` in `hand`, both `Road()` and `Settlement()` are in the list. \n5. A hand can be empty. In the event a hand is empty, you can't build or buy anything, so return an empty list, see example 3 above.\n6. Hand are between 0 and 39 in length.\n-/", "vc-preamble": "def ValidResources := \"bwsog\"\n\ndef countChar (s : List Char) (c : Char) : Nat :=\n  s.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def build_or_buy (hand : String) : List String :=\nsorry", "vc-theorems": "theorem build_or_buy_returns_list (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  build_or_buy hand ≠ [] ∨ build_or_buy hand = [] := by\n  sorry\n\ntheorem build_or_buy_valid_items (hand : String) (result : List String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  result = build_or_buy hand →\n  result.all (· ∈ [\"road\", \"settlement\", \"city\", \"development\"]) := by\n  sorry\n\ntheorem can_build_road (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"road\" ∈ build_or_buy hand →\n  countChar hand.data 'b' ≥ 1 ∧ countChar hand.data 'w' ≥ 1 := by\n  sorry\n\ntheorem can_build_settlement (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"settlement\" ∈ build_or_buy hand →\n  countChar hand.data 'b' ≥ 1 ∧ countChar hand.data 'w' ≥ 1 ∧\n  countChar hand.data 's' ≥ 1 ∧ countChar hand.data 'g' ≥ 1 := by\n  sorry\n\ntheorem can_build_city (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"city\" ∈ build_or_buy hand →\n  countChar hand.data 'o' ≥ 3 ∧ countChar hand.data 'g' ≥ 2 := by\n  sorry\n\ntheorem can_build_development (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  \"development\" ∈ build_or_buy hand →\n  countChar hand.data 'o' ≥ 1 ∧ countChar hand.data 's' ≥ 1 ∧\n  countChar hand.data 'g' ≥ 1 := by\n  sorry\n\ntheorem empty_hand_empty_result :\n  build_or_buy \"\" = [] := by\n  sorry\n\ntheorem result_consistency (hand : String) :\n  hand.data.all (· ∈ ValidResources.data) →\n  build_or_buy hand = build_or_buy hand := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['road']\n-/\n#guard_msgs in\n#eval build_or_buy \"bwoo\"\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval build_or_buy \"\"\n\n/--\ninfo: ['city']\n-/\n#guard_msgs in\n#eval build_or_buy \"ogogoogogo\""}
{"id": "fvapps_003733", "vc-description": "/-\n# Welcome to the Codewars Bar!\n\nCodewars Bar recommends you drink 1 glass of water per standard drink so you're not hungover tomorrow morning.\n\nYour fellow coders have bought you several drinks tonight in the form of a string. Return a string suggesting how many glasses of water you should drink to not be hungover.\n\n## Examples\n\n```\n\"1 beer\"  =>  \"1 glass of water\"\n\"1 shot, 5 beers and 1 glass of wine\"  =>  \"7 glasses of water\"\n```\n\n## Notes\n\n* To keep the things simple, we'll consider that anything with a number in front of it is a drink: `\"1 bear\" => \"1 glass of water\"` or `\"1 chainsaw and 2 pools\" => \"3 glasses of water\"`\n* The number in front of each drink lies in range `[1; 9]`\n-/\n\n/- For a single digit input, the function hydrate returns a string with the\n    same number of glasses of water, and uses \"glass\" for 1 and \"glasses\" otherwise -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of single digit numbers, hydrate returns a string with the sum of\n    the numbers as glasses of water -/\n\n/- For any string containing only letters and spaces, hydrate returns \"0 glasses of water\" -/\n\n/- For an empty string, hydrate returns \"0 glasses of water\" -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hydrate (s : String) : String :=\nsorry", "vc-theorems": "theorem hydrate_single_digit {n : Nat} (h : n ≤ 9) :\n  hydrate s!\"{n} drinks\" =\n    s!\"{n} {if n = 1 then \"glass\" else \"glasses\"} of water\" :=\nsorry\n\ntheorem hydrate_multiple_digits {nums : List Nat} (h : ∀ n ∈ nums, n ≤ 9) :\n  let sum := nums.foldl (· + ·) 0\n  hydrate (String.intercalate \" \" (nums.map toString)) =\n    s!\"{sum} {if sum = 1 then \"glass\" else \"glasses\"} of water\" :=\nsorry\n\ntheorem hydrate_no_numbers {s : String}\n  (h : ∀ c ∈ s.data, c = ' ' ∨ ('a' ≤ c ∧ c ≤ 'z')) :\n  hydrate s = \"0 glasses of water\" :=\nsorry\n\ntheorem hydrate_empty : hydrate \"\" = \"0 glasses of water\" :=\nsorry", "vc-postamble": "/--\ninfo: '1 glass of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 beer\"\n\n/--\ninfo: '3 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"2 glasses of wine and 1 shot\"\n\n/--\ninfo: '10 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 shot, 5 beers, 2 shots, 1 glass of wine, 1 beer\""}
{"id": "fvapps_003734", "vc-description": "/-\n## Task:\nYou have to write a function `pattern` which returns the following Pattern (See Pattern & Examples) upto `n` number of rows. \n\n* Note: `Returning` the pattern is not the same as `Printing` the pattern.\n\n### Rules/Note:\n* If `n < 1` then it should return \"\" i.e. empty string.\n* There are `no whitespaces` in the pattern.\n\n### Pattern:\n\n    (n)(n-1)(n-2)...4321\n    (n)(n-1)(n-2)...432\n    (n)(n-1)(n-2)...43\n    (n)(n-1)(n-2)...4\n    ...............\n    ..............\n    (n)(n-1)(n-2)\n    (n)(n-1)\n    (n)\n\n### Examples:\n\n* pattern(4):\n\n      4321\n      432\n      43\n      4\n\n* pattern(11):\n\n      1110987654321\n      111098765432\n      11109876543\n      1110987654\n      111098765\n      11109876\n      1110987\n      111098\n      11109\n      1110\n      11\n\n~~~if-not:cfml\n* Hint: Use \\n in string to jump to next line\n~~~\n~~~if:cfml\n* Hint: Use chr(10) in string to jump to next line\n~~~\n\n[List of all my katas](\"http://www.codewars.com/users/curious_db97/authored\")\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Nat) : String :=\nsorry", "vc-theorems": "def get_lines (n : Nat) : List String :=\n  (pattern n).split (· = '\\n')\n\ntheorem pattern_non_positive (n : Nat) (h : n = 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem pattern_first_line (n : Nat) (h : n > 0) :\n  (get_lines n)[0]! = String.join (List.map toString (List.range n)) :=\nsorry\n\ntheorem pattern_line_count (n : Nat) (h : n > 0) :\n  (get_lines n).length = n :=\nsorry\n\ntheorem pattern_line_length (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.length = n - i :=\nsorry\n\ntheorem pattern_line_starts_with_n (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.front.toString = toString n :=\nsorry\n\ntheorem pattern_descending_numbers (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  let nums := (get_lines n)[i]!.data.map (λ c => c.toString.toNat!);\n  nums == (List.range (n - i)).map (λ x => n - x) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '4321\\n432\\n43\\n4'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/--\ninfo: '21\\n2'\n-/\n#guard_msgs in\n#eval pattern 2\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"}
{"id": "fvapps_003737", "vc-description": "/-\nWe want to find the numbers higher or equal than 1000 that the sum of every four consecutives digits cannot be higher than a certain given value.\nIf the number is ``` num = d1d2d3d4d5d6 ```, and the maximum sum of 4 contiguous digits is ```maxSum```, then:\n```python\nd1 + d2 + d3 + d4 <= maxSum\nd2 + d3 + d4 + d5 <= maxSum\nd3 + d4 + d5 + d6 <= maxSum\n```\nFor that purpose, we need to create a function, ```max_sumDig()```, that receives ```nMax```, as the max value of the interval to study (the range (1000, nMax) ), and a certain value, ```maxSum```, the maximum sum that every four consecutive digits should be less or equal to. The function should output the following list with the data detailed bellow:\n\n```[(1), (2), (3)]```\n\n(1) - the amount of numbers that satisfy the constraint presented above \n\n(2) - the closest number to the mean of the results, if there are more than one, the smallest number should be chosen.\n\n(3) - the total sum of all the found numbers\n\nLet's see a case with all the details:\n```\nmax_sumDig(2000, 3) -------> [11, 1110, 12555]\n\n(1) -There are 11 found numbers: 1000, 1001, 1002, 1010, 1011, 1020, 1100, 1101, 1110, 1200 and 2000\n\n(2) - The mean of all the found numbers is:\n      (1000 + 1001 + 1002 + 1010 + 1011 + 1020 + 1100 + 1101 + 1110 + 1200 + 2000) /11 = 1141.36363,  \n      so 1110 is the number that is closest to that mean value.\n\n(3) - 12555 is the sum of all the found numbers\n      1000 + 1001 + 1002 + 1010 + 1011 + 1020 + 1100 + 1101 + 1110 + 1200 + 2000 = 12555\n\nFinally, let's see another cases\n```\nmax_sumDig(2000, 4) -----> [21, 1120, 23665]\n\nmax_sumDig(2000, 7) -----> [85, 1200, 99986]\n\nmax_sumDig(3000, 7) -----> [141, 1600, 220756]\n```\n\nHappy coding!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitsList (n : Nat) : List Nat :=\nsorry\n\ndef sumList (xs : List Nat) : Nat :=\nsorry\n\ndef check (n : Nat) (maxSum : Nat) : Bool :=\nsorry\n\ndef max_sumDig (nmax : Nat) (maxSum : Nat) : Nat × Nat × Nat :=\nsorry", "vc-theorems": "theorem check_type (n : Nat) (maxSum : Nat) : check n maxSum = true ∨ check n maxSum = false :=\nsorry\n\ntheorem check_max_sum (n : Nat) (maxSum : Nat)\n    (h1 : n ≥ 1000) (h2 : n < 10000) (h3 : maxSum ≤ 36) :\n  check n maxSum = true ↔\n    ∀ i, i + 4 ≤ (digitsList n).length →\n      sumList (List.drop i (List.take (i+4) (digitsList n))) ≤ maxSum :=\nsorry\n\ntheorem max_sumDig_constraints (nmax maxSum : Nat)\n    (h1 : nmax ≥ 2000) (h2 : nmax < 10000) (h3 : maxSum ≥ 3) (h4 : maxSum ≤ 36) :\n  let (count, closest, sum) := max_sumDig nmax maxSum\n  count ≥ 0 ∧\n  closest ≥ 1000 ∧\n  closest ≤ nmax ∧\n  check closest maxSum = true ∧\n  sum ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [11, 1110, 12555]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 3\n\n/--\ninfo: [21, 1120, 23665]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 4\n\n/--\ninfo: [85, 1200, 99986]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 7"}
{"id": "fvapps_003746", "vc-description": "/-\nWelcome. In this kata, you are asked to square every digit of a number and concatenate them.\n\nFor example, if we run 9119 through the function, 811181 will come out, because 9^(2) is 81 and 1^(2) is 1.\n\n**Note:** The function accepts an integer and returns an integer\n-/", "vc-preamble": "def square_len (n : Nat) : Nat := toString (n * n) |>.length\n\ndef listSum : List Nat → Nat\n| [] => 0\n| x :: xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def square_digits (n : Nat) : Nat :=\nsorry\n\ndef digits_to_nat (digits : List Nat) : Nat :=\nsorry\n\ndef nat_to_digits (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem single_digit_square {d : Nat} (h : d ≤ 9) :\n  square_digits d = d * d :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 9414\n-/\n#guard_msgs in\n#eval square_digits 3212\n\n/--\ninfo: 4114\n-/\n#guard_msgs in\n#eval square_digits 2112\n\n/--\ninfo: 811181\n-/\n#guard_msgs in\n#eval square_digits 9119"}
{"id": "fvapps_003747", "vc-description": "/-\nGiven an array, return the reversed version of the array (a different kind of reverse though), you reverse portions of the array, you'll be given a length argument which represents the length of each portion you are to reverse.\n\nE.g\n\n  if after reversing some portions of the array and the length of the remaining portion in the array is not up to the length argument, just reverse them.\n\n`selReverse(array, length)`\n\n- array - array to reverse\n- length - length of each portion to reverse\n\nNote : if the length argument exceeds the array length, reverse all of them, if the length argument is zero do not reverse at all.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For element preservation, we can state that any element in the original list\n   exists in the result list and vice versa -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sel_reverse (arr : List α) (length : Nat) : List α :=\n  sorry", "vc-theorems": "theorem length_preservation {α : Type} (arr : List α) (length : Nat) :\n  List.length (sel_reverse arr length) = List.length arr :=\nsorry\n\ntheorem elem_preservation {α : Type} (arr : List α) (length : Nat) (a : α) :\n  (a ∈ sel_reverse arr length) ↔ (a ∈ arr) :=\nsorry\n\ntheorem zero_length {α : Type} (arr : List α) :\n  sel_reverse arr 0 = arr :=\nsorry\n\ntheorem chunk_reversal {α : Type} (arr : List α) (length : Nat) (h : length > 0) :\n  ∀ i, i < List.length arr →\n  (sel_reverse arr length).get? i =\n    arr.get? (i/length * length + (length - 1 - i%length)) :=\nsorry\n\ntheorem length_one {α : Type} (arr : List α) :\n  sel_reverse arr 1 = arr :=\nsorry\n\ntheorem full_length {α : Type} (arr : List α) (h : arr ≠ []) :\n  sel_reverse arr (List.length arr) = arr.reverse :=\nsorry", "vc-postamble": "/--\ninfo: [6, 4, 2, 12, 10, 8, 16, 14]\n-/\n#guard_msgs in\n#eval sel_reverse [2, 4, 6, 8, 10, 12, 14, 16] 3\n\n/--\ninfo: [2, 1, 4, 3, 6, 5]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 2\n\n/--\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 0"}
{"id": "fvapps_003753", "vc-description": "/-\nWrite a function which outputs the positions of matching bracket pairs. The output should be a dictionary with keys the positions of the open brackets '(' and values the corresponding positions of the closing brackets ')'.\n\nFor example: input = \"(first)and(second)\" should return {0:6, 10:17}\n\nIf brackets cannot be paired or if the order is invalid (e.g. ')(') return False. In this kata we care only about the positions of round brackets '()', other types of brackets should be ignored.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Pos2Nat (p : String.Pos) : Nat :=\nsorry\n\ndef Nat2Pos (n : Nat) : String.Pos :=\nsorry\n\ndef bracket_pairs (s : String) : Option (List (String.Pos × String.Pos)) :=\nsorry", "vc-theorems": "theorem bracket_pairs_valid_indices {s : String} {pairs : List (String.Pos × String.Pos)}\n    (h1 : bracket_pairs s = some pairs)\n    (open_pos close_pos : String.Pos)\n    (h2 : (open_pos, close_pos) ∈ pairs) :\n    s.get open_pos = '(' ∧\n    s.get close_pos = ')' ∧\n    Pos2Nat open_pos < Pos2Nat close_pos :=\nsorry\n\ntheorem no_brackets_empty_result {s : String} :\n  (∀ c, c ∈ s.data → c ≠ '(' ∧ c ≠ ')') →\n  bracket_pairs s = some [] :=\nsorry\n\ntheorem only_closing_brackets_false {s : String} :\n  (∀ c, c ∈ s.data → c = ')') →\n  s ≠ \"\" →\n  bracket_pairs s = none :=\nsorry\n\ntheorem only_opening_brackets_false {s : String} :\n  (∀ c, c ∈ s.data → c = '(') →\n  s ≠ \"\" →\n  bracket_pairs s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: {3: 8}\n-/\n#guard_msgs in\n#eval bracket_pairs \"len(list)\"\n\n/--\ninfo: {}\n-/\n#guard_msgs in\n#eval bracket_pairs \"string\"\n\n/--\ninfo: {0: 9, 2: 4, 6: 7}\n-/\n#guard_msgs in\n#eval bracket_pairs \"(a(b)c()d)\""}
{"id": "fvapps_003754", "vc-description": "/-\n# Task\n\nYour task is to sort the characters in a string according to the following rules:\n```\n- Rule1: English alphabets are arranged from A to Z, case insensitive.\n  ie. \"Type\" --> \"epTy\"\n- Rule2: If the uppercase and lowercase of an English alphabet exist\n  at the same time, they are arranged in the order of oringal input.\n  ie. \"BabA\" --> \"aABb\"\n- Rule3: non English alphabet remain in their original position.\n  ie. \"By?e\" --> \"Be?y\"\n```\n\n# Input/Output\n\n`[input]` string `s`\n\nA non empty string contains any characters(English alphabets or non English alphabets).\n\n`[output]` a string\n\nA sorted string according to the rules above.\n\n# Example\n\nFor `s = \"cba\"`, the output should be `\"abc\"`.\n\nFor `s = \"Cba\"`, the output should be `\"abC\"`.\n\nFor `s = \"cCBbAa\"`, the output should be `\"AaBbcC\"`.\n\nFor `s = \"c b a\"`, the output should be `\"a b c\"`.\n\nFor `s = \"-c--b--a-\"`, the output should be `\"-a--b--c-\"`.\n\nFor `s = \"Codewars\"`, the output should be `\"aCdeorsw\"`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sortString (s : String) : String :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry\n\ndef isUpper (c : Char) : Bool :=\nsorry\n\ndef isLower (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem sort_string_preserves_length (s : String) :\n  (sortString s).length = s.length :=\nsorry\n\ntheorem sort_string_preserves_non_alpha (s : String) (i : String.Pos) :\n  ¬(isAlpha (s.get i)) →\n  (sortString s).get i = s.get i :=\nsorry\n\ntheorem sort_string_sorts_alpha (s : String) :\n  let result := sortString s\n  let alphaChars := result.data.filter isAlpha\n  ∀ i j, i < j → j < alphaChars.length →\n    (alphaChars.get ⟨i, by sorry⟩).toLower ≤ (alphaChars.get ⟨j, by sorry⟩).toLower :=\nsorry\n\ntheorem sort_string_preserves_case_counts (s : String) :\n  let result := sortString s\n  (result.data.filter isUpper).length = (s.data.filter isUpper).length ∧\n  (result.data.filter isLower).length = (s.data.filter isLower).length :=\nsorry\n\ntheorem sort_string_idempotent (s : String) :\n  sortString (sortString s) = sortString s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval sort_string \"cba\"\n\n/--\ninfo: 'abC'\n-/\n#guard_msgs in\n#eval sort_string \"Cba\"\n\n/--\ninfo: 'a b c'\n-/\n#guard_msgs in\n#eval sort_string \"c b a\""}
{"id": "fvapps_003755", "vc-description": "/-\nImplement a function which behaves like the 'uniq -c' command in UNIX. \n\nIt takes as input a sequence and returns a sequence in which all duplicate elements following each other have been reduced to one instance together with the number of times a duplicate elements occurred in the original array.\n\nExample:\n\n```python\n['a','a','b','b','c','a','b','c'] --> [('a',2),('b',2),('c',1),('a',1),('b',1),('c',1)]\n```\n-/", "vc-preamble": "def sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def uniq_c {α : Type u} (xs : List α) : List (α × Nat) :=\n  sorry", "vc-theorems": "theorem uniq_c_length_invariants {α : Type u} (xs : List α) :\n  let result := uniq_c xs\n  (∀ p ∈ result, (Prod.snd p) > 0) ∧\n  sum (result.map Prod.snd) = xs.length :=\nsorry\n\ntheorem uniq_c_groups_consecutive {α : Type u} [BEq α] (xs : List α) :\n  let result := uniq_c xs\n  let indices := List.range xs.length\n  ∀ (i j : Nat), i < xs.length → j < xs.length →\n    ∀ p ∈ result,\n      (i < j) →\n      (j - i < Prod.snd p) →\n      xs[i]? = some (Prod.fst p) →\n      xs[j]? = some (Prod.fst p) :=\nsorry\n\ntheorem uniq_c_single_element {α : Type u} [BEq α] (x : α) (n : Nat) :\n  uniq_c (List.replicate n x) = [(x, n)] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"b\", \"b\", \"c\", \"a\", \"b\", \"c\"]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval uniq_c [None, \"a\", \"a\"]"}
{"id": "fvapps_003761", "vc-description": "/-\nAmicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number. (A proper divisor of a number is a positive factor of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.) \n\nFor example, the smallest pair of amicable numbers is (220, 284); for the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110, of which the sum is 284; and the proper divisors of 284 are 1, 2, 4, 71 and 142, of which the sum is 220.\n\nDerive function ```amicableNumbers(num1, num2)``` which returns ```true/True``` if pair ```num1 num2``` are amicable, ```false/False``` if not.\n\nSee more at https://en.wikipedia.org/wiki/Amicable_numbers\n-/", "vc-preamble": "def list_sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + list_sum xs", "vc-helpers": "", "vc-definitions": "def get_divs (n : Nat) : List Nat := \n  sorry\n\ndef amicable_numbers (n1 n2 : Nat) : Bool := \n  sorry", "vc-theorems": "theorem get_divs_properties (n : Nat) (h : n > 0) :\n  let divs := get_divs n\n  (∀ d ∈ divs, n % d = 0) ∧\n  (∀ d ∈ divs, d > 0) ∧\n  (1 ∈ divs) ∧\n  (n = 1 → n ∈ divs) :=\nsorry\n\ntheorem amicable_symmetric_property (n : Nat) (h : n > 0) :\n  let divs_sum := list_sum (get_divs n)\n  (divs_sum > 0 ∧ divs_sum ≠ n) →\n  amicable_numbers n divs_sum = amicable_numbers divs_sum n :=\nsorry\n\ntheorem non_amicable_with_self (n : Nat) (h : n > 0) :\n  ¬amicable_numbers n n :=\nsorry\n\ntheorem amicable_commutative (n1 n2 : Nat) (h1 : n1 > 0) (h2 : n2 > 0) :\n  amicable_numbers n1 n2 = amicable_numbers n2 n1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval amicable_numbers 220 284\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval amicable_numbers 220 280\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval amicable_numbers 1184 1210"}
{"id": "fvapps_003769", "vc-description": "/-\n# Definition\n\nA **_Tidy number_**  *is a number whose*  **_digits are in non-decreasing order_**.\n___\n# Task\n\n**_Given_** a number, **_Find if it is Tidy or not_** . \n____\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_Number_** *passed is always*  **_Positive_** .\n\n* **_Return_** *the result as* a **_Boolean_** \n\n~~~if:prolog\n* Since prolog doesn't have booleans,  return value should be 1 for (True) or 0 for (false)\n~~~\n___\n\n# Input >> Output Examples\n\n```\ntidyNumber (12) ==> return (true)\n```\n\n## **_Explanation_**:\n\n**_The number's digits_**    `{ 1 , 2 }`  are *in non-Decreasing Order* (i.e) *1 <= 2* .\n____\n\n```\ntidyNumber (32) ==> return (false)\n```\n\n## **_Explanation_**:\n\n**_The Number's Digits_**  `{ 3, 2}`  are **_not in non-Decreasing Order_** (i.e) *3 > 2* .\n___\n\n```\ntidyNumber (1024) ==> return (false)\n```\n\n## **_Explanation_**:\n\n**_The Number's Digits_**  `{1 , 0, 2, 4}`  are **_not in non-Decreasing Order_**  as  *0 <= 1* .\n\n___\n\n```\ntidyNumber (13579) ==> return (true)\n```\n\n## **_Explanation_**:\n\n**_The number's digits_**    `{1 , 3, 5, 7, 9}`  are *in non-Decreasing Order* .\n____\n\n```\ntidyNumber (2335) ==> return (true)\n```\n\n## **_Explanation_**:\n\n**_The number's digits_**    `{2 , 3, 3, 5}`  are *in non-Decreasing Order* , **_Note_**   *3 <= 3* \n\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digits (n : Nat) : List Nat :=\n  sorry\n\ndef tidyNumber (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem tidy_number_returns_boolean (n : Nat) :\n  tidyNumber n = true ∨ tidyNumber n = false :=\nsorry\n\ntheorem single_digit_numbers_tidy (n : Nat) :\n  n < 10 → tidyNumber n = true :=\nsorry\n\ntheorem tidy_implies_non_decreasing_digits {n : Nat} {ds : List Nat} :\n  tidyNumber n = true →\n  ds = digits n →\n  ∀ i j, i < j → j < ds.length → ds[i]! ≤ ds[j]! :=\nsorry\n\ntheorem non_decreasing_digits_iff_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n →\n  (∀ i j, i < j → j < ds.length → ds[i]! ≤ ds[j]!) ↔ tidyNumber n = true :=\nsorry\n\ntheorem decreasing_digits_not_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n →\n  ds.length ≥ 2 →\n  (∃ i j, i < j ∧ j < ds.length ∧ ds[i]! > ds[j]!) →\n  tidyNumber n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval tidyNumber 12\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 32\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 1024"}
{"id": "fvapps_003771", "vc-description": "/-\nWrite a function that returns the number of '2's in the factorization of a number.  \nFor example,\n```python\ntwo_count(24)\n```\nshould return 3, since the factorization of 24 is 2^3 x 3\n```python\ntwo_count(17280)\n```\nshould return 7, since the factorization of 17280 is 2^7 x 5 x 3^3  \nThe number passed to two_count (twoCount)  will always be a positive integer greater than or equal to 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def two_count (n : Nat) : Nat :=\nsorry\n\ndef calc_divisions (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem two_count_non_negative (n : Nat) (h : n > 0) :\n  two_count n ≥ 0 :=\nsorry\n\ntheorem two_count_matches_divisions (n : Nat) (h : n > 0) :\n  two_count n = calc_divisions n :=\nsorry\n\ntheorem two_count_odd (n : Nat) (h₁ : n > 0) (h₂ : n % 2 = 1) :\n  two_count n = 0 :=\nsorry\n\ntheorem two_count_power_of_two (n : Nat) (h₁ : n > 0) (h₂ : n.isPowerOfTwo) :\n  two_count n = Nat.log2 n :=\nsorry\n\ntheorem two_count_multiplication (n k : Nat) (h : n > 0) :\n  two_count (n * 2^k) = two_count n + k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval two_count 24\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval two_count 17280\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval two_count 256"}
{"id": "fvapps_003776", "vc-description": "/-\nThe aim of this Kata is to write a function which will reverse the case of all consecutive duplicate letters in a string.  That is, any letters that occur one after the other and are identical.\n\nIf the duplicate letters are lowercase then they must be set to uppercase, and if they are uppercase then they need to be changed to lowercase. \n\n**Examples:**\n```python\nreverse_case(\"puzzles\")    Expected Result: \"puZZles\"\nreverse_case(\"massive\")    Expected Result: \"maSSive\"\nreverse_case(\"LITTLE\")     Expected Result: \"LIttLE\"\nreverse_case(\"shhh\")       Expected Result: \"sHHH\"\n```\n\nArguments passed will include only alphabetical letters A–Z or a–z.\n-/", "vc-preamble": "def IsRepeatStart (s : String) (i : String.Pos) : Prop :=\n  i = ⟨0⟩ ∨ s.get (String.Pos.mk (i.1 - 1)) = s.get i\n\ndef IsRepeatEnd (s : String) (i : String.Pos) : Prop :=\n  i.1 < s.length - 1 → s.get i = s.get (String.Pos.mk (i.1 + 1))", "vc-helpers": "", "vc-definitions": "def reverse (s : String) : String :=\nsorry", "vc-theorems": "theorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :=\nsorry\n\ntheorem reverse_preserves_non_repeats (s : String) (i : String.Pos) :\n  ¬IsRepeatStart s i → ¬IsRepeatEnd s i →\n  (reverse s).get i = s.get i :=\nsorry\n\ntheorem reverse_swaps_case_on_repeats (s : String) (i : String.Pos) :\n  IsRepeatStart s i ∨ IsRepeatEnd s i →\n  (reverse s).get i ≠ s.get i :=\nsorry\n\ntheorem reverse_idempotent_no_repeats (s : String)\n  (h : ∀ i : String.Pos, i.1 < s.length → ¬IsRepeatStart s i ∧ ¬IsRepeatEnd s i) :\n  reverse s = s :=\nsorry\n\ntheorem reverse_preserves_non_letters (s : String) (i : String.Pos)\n  (h : ¬(s.get i).isAlpha) :\n  (reverse s).get i = s.get i :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'heLLo world'\n-/\n#guard_msgs in\n#eval reverse \"hello world\"\n\n/--\ninfo: 'www'\n-/\n#guard_msgs in\n#eval reverse \"WWW\"\n\n/--\ninfo: 'bOOKKEEper'\n-/\n#guard_msgs in\n#eval reverse \"bookkeeper\""}
{"id": "fvapps_003777", "vc-description": "/-\nIn your class, you have started lessons about \"arithmetic progression\". Because you are also a programmer, you have decided to write a function.\n\nThis function, arithmetic_sequence_sum(a, r, n), should return the sum of the first (n) elements of a sequence in which each element is the sum of the given integer (a), and a number of occurences of the given integer (r), based on the element's position within the sequence.\n\nFor example:\n\narithmetic_sequence_sum(2, 3, 5) should return 40:\n\n```\n1     2        3          4            5\na + (a+r) + (a+r+r) + (a+r+r+r) + (a+r+r+r+r) \n2 + (2+3) + (2+3+3) + (2+3+3+3) + (2+3+3+3+3) = 40\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_ints (xs : List Int) : Int :=\n  sorry\n\ndef range (n : Int) : List Int :=\n  sorry\n\ndef arithmetic_sequence_sum (a r n : Int) : Int :=\n  sorry", "vc-theorems": "theorem arithmetic_sequence_properties\n  (a r n : Int)\n  (h : n > 0) :\n  let sum := arithmetic_sequence_sum a r n\n  let manual_sum := sum_ints (range n |>.map (fun i => a + r * i))\n  (sum = manual_sum) ∧\n  (arithmetic_sequence_sum a r 1 = a) ∧\n  (n > 1 → sum = arithmetic_sequence_sum a r (n-1) + (a + (n-1)*r)) :=\nsorry\n\ntheorem sequence_symmetry\n  (a r n : Int)\n  (h : n > 0) :\n  let last := a + (n-1)*r\n  arithmetic_sequence_sum a r n = arithmetic_sequence_sum last (-r) n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 440\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 3 2 20\n\n/--\ninfo: 110\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 2 2 10\n\n/--\ninfo: -80\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 1 -2 10"}
{"id": "fvapps_003780", "vc-description": "/-\nYou are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return `-1`.\n\n__For example:__\n\nLet's say you are given the array `{1,2,3,4,3,2,1}`:  \nYour function will return the index `3`, because at the 3rd position of the array, the sum of left side of the index (`{1,2,3}`) and the sum of the right side of the index (`{3,2,1}`) both equal `6`.\n\nLet's look at another one.  \nYou are given the array `{1,100,50,-51,1,1}`:  \nYour function will return the index `1`, because at the 1st position of the array, the sum of left side of the index (`{1}`) and the sum of the right side of the index (`{50,-51,1,1}`) both equal `1`.\n\nLast one:  \nYou are given the array `{20,10,-80,10,10,15,35}`  \nAt index 0 the left side is `{}`  \nThe right side is `{10,-80,10,10,15,35}`  \nThey both are equal to `0` when added. (Empty arrays are equal to 0 in this problem)  \nIndex 0 is the place where the left side and right side are equal.  \n\nNote: Please remember that in most programming/scripting languages the index of an array starts at 0.\n\n__Input:__  \nAn integer array of length `0 < arr < 1000`. The numbers in the array can be any integer positive or negative.\n\n__Output:__  \nThe lowest index `N` where the side to the left of `N` is equal to the side to the right of `N`. If you do not find an index that fits these rules, then you will return `-1`.\n\n__Note:__  \nIf you are given an array with multiple answers, return the lowest correct index.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_even_index (arr : List Int) : Nat :=\n  sorry\n\ndef sum_list (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem find_even_index_centered {n : Nat} :\n  let arr := List.replicate n 1 ++ [0] ++ List.replicate n 1\n  find_even_index arr = n\n  :=\nsorry\n\ntheorem find_even_index_single_element :\n  find_even_index [0] = 0 :=\nsorry\n\ntheorem find_even_index_single_nonzero :\n  find_even_index [1] = 0 :=\nsorry\n\ntheorem find_even_index_all_zeros :\n  find_even_index [0, 0, 0] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_even_index [1, 2, 3, 4, 3, 2, 1]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval find_even_index [1, 100, 50, -51, 1, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_even_index [20, 10, -80, 10, 10, 15, 35]"}
{"id": "fvapps_003781", "vc-description": "/-\nWe need to write some code to return the original price of a product, the return type must be of type decimal and the number must be rounded to two decimal places.\n\nWe will be given the sale price (discounted price), and the sale percentage, our job is to figure out the original price.\n\n### For example:\n\nGiven an item at $75 sale price after applying a 25% discount, the function should return the original price of that item before applying the sale percentage, which is ($100.00) of course, rounded to two decimal places.\n\nDiscoverOriginalPrice(75, 25) => 100.00M where 75 is the sale price (discounted price), 25 is the sale percentage and 100 is the original price\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def discover_original_price (price : Float) (percentage : Float) : Float :=\nsorry\n\ndef abs (x : Float) : Float :=\nsorry", "vc-theorems": "theorem discover_original_price_geq_discounted (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  discover_original_price price percentage ≥ price :=\nsorry\n\ntheorem discover_original_price_positive (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  0 < discover_original_price price percentage :=\nsorry\n\ntheorem discover_original_price_accurate (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  let original := discover_original_price price percentage\n  let discounted := original * (1 - percentage/100)\n  Float.abs (discounted - price) ≤ 0.02 :=\nsorry\n\ntheorem discover_original_price_100_dollars (percentage : Float)\n  (h1 : 0 < percentage) (h2 : percentage < 100) :\n  let discounted := 100 * (1 - percentage/100)\n  Float.abs (discover_original_price discounted percentage - 100) < 0.01 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 75 25\n\n/--\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 25 75\n\n/--\ninfo: Decimal('421.00')\n-/\n#guard_msgs in\n#eval discover_original_price 373.85 11.2"}
{"id": "fvapps_003794", "vc-description": "/-\n# Definition\n\n**_Strong number_** is the number that *the sum of the factorial of its digits is equal to number itself*.\n\n## **_For example_**:  **_145_**, since \n```\n1! + 4! + 5! = 1 + 24 + 120 = 145\n```\nSo, **_145_** is a **_Strong number_**. \n____\n\n# Task\n\n**_Given_** a number, **_Find if it is Strong or not_**.\n____\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* **_Number_** *passed is always*  **_Positive_**.\n* **_Return_** *the result as* **_String_**\n___\n\n# Input >> Output Examples\n\n```\nstrong_num(1) ==> return \"STRONG!!!!\"\n```\n\n## **_Explanation_**:\n\nSince , **_the sum of its digits' factorial of (1) is equal to number itself (1)_** , **_Then_** its a **_Strong_** .  \n____\n\n```\nstrong_num(123) ==> return \"Not Strong !!\"\n```\n\n## **_Explanation_**:\n\nSince **_the sum of its digits' factorial of 1! + 2! + 3! = 9 is not equal to number itself (123)_** , **_Then_** it's  **_Not Strong_** . \n___\n\n```\nstrong_num(2)  ==>  return \"STRONG!!!!\"\n```\n\n## **_Explanation_**:\n\nSince **_the sum of its digits' factorial of 2! = 2 is equal to number itself (2)_** , **_Then_** its a **_Strong_** .  \n____\n\n```\nstrong_num(150) ==> return \"Not Strong !!\"\n```\n\n## **_Explanation_**:\n\nSince **_the sum of its digits' factorial of 1! + 5! + 0! = 122 is not equal to number itself (150)_**, **_Then_** it's **_Not Strong_** . \n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/\n\n-- conversion of digits to number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def strong_num (n : Nat) : String :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry\n\ndef sumDigitFactorials (n : Nat) : Nat :=\nsorry\n\ndef digitsOfNat (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem strong_num_outputs_valid_string (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" ∨ strong_num n = \"Not Strong !!\") :=\nsorry\n\ntheorem strong_num_correctness (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" ↔ sumDigitFactorials n = n) :=\nsorry\n\ntheorem single_digit_strong_nums (n : Nat) :\n  n ≤ 9 →\n  (strong_num n = \"STRONG!!!!\" ↔ (n = 1 ∨ n = 2)) :=\nsorry\n\ntheorem digit_composition_property (digits : List Nat) :\n  (∀ d ∈ digits, d ≤ 9) →\n  let n := sorry\n  (strong_num n = \"STRONG!!!!\" ↔ (sumDigitFactorials n = n)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 145\n\n/--\ninfo: 'Not Strong !!'\n-/\n#guard_msgs in\n#eval strong_num 123\n\n/--\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 40585"}
{"id": "fvapps_003799", "vc-description": "/-\nWrite a function that reverses the bits in an integer.\n\nFor example, the number `417` is `110100001` in binary. Reversing the binary is `100001011` which is `267`.\n\nYou can assume that the number is not negative.\n-/\n\n-- Result is non-negative (trivial in Lean since Nat is used)\n\n-- Number of 1 bits is preserved\n\n-- Helper function to count ones\n\n-- Power of 2 input results in power of 2 output\n\n-- Edge cases", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reverse_bits (n : Nat) : Nat :=\nsorry\n\ndef count_ones (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem reverse_bits_nonneg (n : Nat) :\n  reverse_bits n ≥ 0 :=\nsorry\n\ntheorem reverse_bits_preserves_ones (n : Nat) (h : n < 2^32) :\n  count_ones n = count_ones (reverse_bits n) :=\nsorry\n\ntheorem reverse_bits_preserves_power_of_two (n : Nat) (h : n < 2^32)\n  (h₁ : n ≠ 0) (h₂ : n &&& (n - 1) = 0) :\n  (reverse_bits n) &&& ((reverse_bits n) - 1) = 0 :=\nsorry\n\ntheorem reverse_bits_zero :\n  reverse_bits 0 = 0 :=\nsorry\n\ntheorem reverse_bits_one :\n  reverse_bits 1 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 267\n-/\n#guard_msgs in\n#eval reverse_bits 417\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval reverse_bits 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval reverse_bits 1024"}
{"id": "fvapps_003804", "vc-description": "/-\n# Task\nGiven some sticks by an array `V` of positive integers, where V[i] represents the length of the sticks, find the number of ways we can choose three of them to form a triangle.\n\n# Example\n\n For `V = [2, 3, 7, 4]`, the result should be `1`.\n\n There is only `(2, 3, 4)` can form a triangle.\n\n For `V = [5, 6, 7, 8]`, the result should be `4`.\n\n `(5, 6, 7), (5, 6, 8), (5, 7, 8), (6, 7, 8)` \n\n# Input/Output\n\n - `[input]` integer array `V`\n\n stick lengths\n\n `3 <= V.length <= 100`\n\n `0 < V[i] <=100`\n\n - `[output]` an integer\n\n number of ways we can choose 3 sticks to form a triangle.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def choose (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef counting_triangles (sticks : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem triangle_count_properties {sticks : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 1000) :\n  let result := counting_triangles sticks\n  result ≥ 0 ∧ result ≤ choose sticks.length 3 :=\nsorry\n\ntheorem same_lengths_make_triangles {n : Nat} (h : n > 0) :\n  counting_triangles [n, n, n] = 1 :=\nsorry\n\ntheorem triangle_inequality {sticks : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 1000) :\n  ∃ a b c, (a ∈ sticks ∧ b ∈ sticks ∧ c ∈ sticks) ∧\n           (a + b > c → counting_triangles sticks > 0) :=\nsorry\n\ntheorem order_invariance {sticks sticksSorted : List Nat}\n  (h1 : sticks.length ≥ 3)\n  (h2 : ∀ x ∈ sticks, x > 0 ∧ x ≤ 100)\n  (h3 : ∀ x, (x ∈ sticks ↔ x ∈ sticksSorted)) :\n  counting_triangles sticks = counting_triangles sticksSorted :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval counting_triangles [2, 3, 7, 4]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [5, 6, 7, 8]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [2, 2, 2, 2]"}
{"id": "fvapps_003808", "vc-description": "/-\nWrite a function that takes an arbitrary number of strings and interlaces them (combines them by alternating characters from each string).\n\nFor example `combineStrings('abc', '123')` should return `'a1b2c3'`.\n\nIf the strings are different lengths the function should interlace them until each string runs out, continuing to add characters from the remaining strings.\n\nFor example `combineStrings('abcd', '123')` should return `'a1b2c3d'`.\n\nThe function should take any number of arguments and combine them.\n\nFor example `combineStrings('abc', '123', '£$%')` should return `'a1£b2$c3%'`.\n\n**Note: if only one argument is passed return only that string. If no arguments are passed return an empty string.**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def combine_strings : List String → String\n  | _ => sorry\n\ndef countChar (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem combine_strings_length (strings : List String) :\n  (combine_strings strings).length = List.foldl (· + ·) 0 (strings.map String.length) :=\nsorry\n\ntheorem combine_strings_freq (strings : List String) (s : String) (c : Char)\n  (h : s ∈ strings) :\n  (countChar (combine_strings strings) c) ≥\n  (countChar s c) :=\nsorry\n\ntheorem combine_strings_empty :\n  combine_strings [] = \"\" :=\nsorry\n\ntheorem combine_strings_singleton (s : String) :\n  combine_strings [s] = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\"\n\n/--\ninfo: 'a1b2c3'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\" \"123\"\n\n/--\ninfo: 'a1$b2%c3^d&'\n-/\n#guard_msgs in\n#eval combine_strings \"abcd\" \"123\" \"$%^&\""}
{"id": "fvapps_003809", "vc-description": "/-\n# Story\n\nYou and a group of friends are earning some extra money in the school holidays by re-painting the numbers on people's letterboxes for a small fee.\n\nSince there are 10 of you in the group each person just concentrates on painting one digit! For example, somebody will paint only the ```1```'s, somebody else will paint only the ```2```'s and so on...\n\nBut at the end of the day you realise not everybody did the same amount of work.\n\nTo avoid any fights you need to distribute the money fairly. That's where this Kata comes in.\n\n# Kata Task\n\nGiven the ```start``` and ```end``` letterbox numbers, write a method to return the frequency of all 10 digits painted.\n\n# Example\n\nFor ```start``` = 125, and ```end``` = 132\n\nThe letterboxes are\n* 125 = ```1```, ```2```, ```5```\n* 126 = ```1```, ```2```, ```6```\n* 127 = ```1```, ```2```, ```7```\n* 128 = ```1```, ```2```, ```8```\n* 129 = ```1```, ```2```, ```9```\n* 130 = ```1```, ```3```, ```0```\n* 131 = ```1```, ```3```, ```1```\n* 132 = ```1```, ```3```, ```2```\n\nThe digit frequencies are 1 x ```0```, 9 x ```1```, 6 x ```2``` etc...\n\nand so the method would return ```[1,9,6,3,0,1,1,1,1,1]```\n\n# Notes\n\n* 0 < ```start``` <= ```end```\n* In C, the returned value will be free'd.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def paint_letterboxes (start: Nat) (finish: Nat) : List Nat :=\nsorry\n\ndef str_count_digits (n: Nat) : List Nat :=\nsorry\n\ndef toString (n: Nat) : String :=\nsorry\n\ndef sum_list (l: List Nat) : Nat :=\nsorry", "vc-theorems": "theorem paint_letterboxes_range {start finish : Nat} (h: start ≤ finish) :\n  let result := paint_letterboxes start finish\n  List.length result = 10 ∧\n  (∀ x ∈ result, x ≥ 0) :=\nsorry\n\ntheorem paint_letterboxes_single_number (n: Nat) :\n  paint_letterboxes n n = str_count_digits n :=\nsorry\n\ntheorem paint_letterboxes_zero :\n  paint_letterboxes 0 0 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] :=\nsorry\n\ntheorem paint_letterboxes_non_negative {a b : Nat} :\n  ∀ x ∈ paint_letterboxes a b, x ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 9, 6, 3, 0, 1, 1, 1, 1, 1]\n-/\n#guard_msgs in\n#eval paint_letterboxes 125 132\n\n/--\ninfo: [2, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n-/\n#guard_msgs in\n#eval paint_letterboxes 1001 1001"}
{"id": "fvapps_003811", "vc-description": "/-\nMake multiple functions that will return the sum, difference, modulus, product, quotient, and the exponent respectively.\n\nPlease use the following function names:\n\naddition = **add**\n\nmultiply = **multiply**\n\ndivision = **divide** (both integer and float divisions are accepted)\n\nmodulus = **mod**\n\nexponential = **exponent**\n\nsubtraction = **subt**\n\n*Note: All math operations will be:\na (operation) b*\n-/\n\n-- Addition properties\n\n-- Multiplication properties\n\n-- Division properties\n\n-- Modulo properties\n\n-- Exponentiation properties\n\n-- Subtraction properties", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (a b : Int) : Int :=\nsorry\n\ndef multiply (a b : Int) : Int :=\nsorry\n\ndef divide (a b : Int) : Int :=\nsorry\n\ndef mod (a b : Int) : Int :=\nsorry\n\ndef exponent (a b : Int) : Int :=\nsorry\n\ndef subt (a b : Int) : Int :=\nsorry", "vc-theorems": "theorem add_commutative (a b : Int) : add a b = add b a :=\nsorry\n\ntheorem add_identity (a : Int) : add a 0 = a :=\nsorry\n\ntheorem add_associative (a b : Int) : add (add a b) 0 = add a (add b 0) :=\nsorry\n\ntheorem mult_commutative (a b : Int) : multiply a b = multiply b a :=\nsorry\n\ntheorem mult_identity (a : Int) : multiply a 1 = a :=\nsorry\n\ntheorem mult_zero (a : Int) : multiply a 0 = 0 :=\nsorry\n\ntheorem div_self {a : Int} (h : a ≠ 0) : divide a a = 1 :=\nsorry\n\ntheorem div_mult_cancel (a b : Int) (h : b ≠ 0) :\n  multiply (divide a b) b = a :=\nsorry\n\ntheorem mod_bounds (a b : Int) (h : b > 0) :\n  0 ≤ mod a b ∧ mod a b < b :=\nsorry\n\ntheorem mod_reconstruction (a b : Int) (h : b ≠ 0) :\n  a = multiply (divide a b) b + mod a b :=\nsorry\n\ntheorem exp_zero (a : Int) (h : a > 0) : exponent a 0 = 1 :=\nsorry\n\ntheorem exp_one (a : Int) : exponent a 1 = a :=\nsorry\n\ntheorem exp_growth (a b : Int) (h1 : a > 0) (h2 : b > 0) :\n  exponent a b ≥ a :=\nsorry\n\ntheorem subt_as_add (a b : Int) : subt a b = add a (-b) :=\nsorry\n\ntheorem subt_self (a : Int) : subt a a = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval add 1 2\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval add 5 7\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval add 0 0\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval multiply 2 3\n\n/--\ninfo: 25\n-/\n#guard_msgs in\n#eval multiply 5 5\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval divide 6 2\n\n/--\ninfo: 2.5\n-/\n#guard_msgs in\n#eval divide 5 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 7 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 10 3\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval exponent 2 3\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval exponent 3 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval subt 5 3\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval subt 10 7"}
{"id": "fvapps_003812", "vc-description": "/-\nGiven a string s, write a method (function) that will return true if its a valid single integer or floating number or false if its not.\n\nValid examples, should return true:\n\nshould return false:\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (s : String) : Bool :=\n  sorry\n\ndef String.toFloat? (s : String) : Option Float :=\n  sorry", "vc-theorems": "theorem valid_float_strings (f : Float) :\n  isDigit (toString f) = true :=\nsorry\n\ntheorem arbitrary_text (s : String) :\n  match s.toFloat? with\n  | some _ => isDigit s = true\n  | none => isDigit s = false\n  :=\nsorry\n\ntheorem whitespace_padding (s : String) (f : Float) :\n  isDigit (s ++ toString f ++ s) = true :=\nsorry\n\ntheorem edge_cases :\n  isDigit \"\" = false ∧\n  isDigit \" \" = false ∧\n  isDigit \"-0\" = true ∧\n  isDigit \"+0\" = true ∧\n  isDigit \"-.1\" = true ∧\n  isDigit \"+.1\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"-234.4\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval isDigit \"3 4\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"0.0\""}
{"id": "fvapps_003815", "vc-description": "/-\n# Task\n\nElections are in progress!\n\nGiven an array of numbers representing votes given to each of the candidates, and an integer which is equal to the number of voters who haven't cast their vote yet, find the number of candidates who still have a chance to win the election.\n\nThe winner of the election must secure strictly more votes than any other candidate. If two or more candidates receive the same (maximum) number of votes, assume there is no winner at all.\n\n**Note**: big arrays will be tested.\n\n# Examples\n\n```\nvotes = [2, 3, 5, 2]\nvoters = 3\n\nresult = 2\n```\n\n* Candidate `#3` may win, because he's already leading.\n* Candidate `#2` may win, because with 3 additional votes he may become the new leader.\n* Candidates `#1` and `#4` have no chance, because in the best case scenario each of them can only tie with the candidate `#3`.\n\n___\n\n```\nvotes = [3, 1, 1, 3, 1]\nvoters = 2\n\nresult = 2\n```\n\n* Candidate `#1` and `#4` can become leaders if any of them gets the votes.\n* If any other candidate gets the votes, they will get tied with candidates `#1` and `#4`.\n\n___\n\n```\nvotes = [1, 3, 3, 1, 1]\nvoters = 0\n\nresult = 0\n```\n\n* There're no additional votes to cast, and there's already a tie.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def elections_winners (votes: List Nat) (k: Nat) : Nat :=\n  sorry\n\ndef list_maximum (l: List Nat) (h: l.length > 0) : Nat :=\n  sorry\n\ndef list_minimum (l: List Nat) (h: l.length > 0) : Nat :=\n  sorry", "vc-theorems": "theorem elections_winners_properties_result_bounds\n  (votes: List Nat) (k: Nat) (h: votes.length > 0) :\n  let result := elections_winners votes k\n  0 ≤ result ∧ result ≤ votes.length :=\nsorry\n\ntheorem elections_winners_k_zero_result\n  (votes: List Nat) (h: votes.length > 0) :\n  let result := elections_winners votes 0\n  result = 0 ∨ result = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [2, 3, 5, 2] 3\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval elections_winners [1, 3, 3, 1, 1] 0\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [3, 1, 1, 3, 1] 2"}
{"id": "fvapps_003837", "vc-description": "/-\nLet's say take 2 strings, A and B, and define the similarity of the strings to be the length of the longest prefix common to both strings. For example, the similarity of strings `abc` and `abd` is 2, while the similarity of strings `aaa` and `aaab` is 3.\n\nwrite a function that calculates the sum of similarities of a string S with each of it's **suffixes**.\n\n```python\nstring_suffix('ababaa') => returns 11\nstring_suffix('abc') => returns 3\n```\n\nExplanation:\n\nIn the first case, the suffixes of the string are `ababaa`, `babaa`, `abaa`, `baa`, `aa` and `a`. The similarities of each of these strings with the string `ababaa` are 6,0,3,0,1,1 respectively. Thus the answer is 6 + 0 + 3 + 0 + 1 + 1 = 11.\n\nFor the second case, the answer is simply 3 + 0 + 0 = 3.\n\nNote : Each string will have at least one character - no need to check for empty strings :)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def strLen (s : String) : Nat :=\n  sorry\n\ndef stringSuffix (s : String) : Nat :=\n  sorry\n\ndef isRepeatedChar (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem string_suffix_positive (s : String) :\n  stringSuffix s ≥ 0 :=\nsorry\n\ntheorem string_suffix_ge_len (s : String) :\n  stringSuffix s ≥ strLen s :=\nsorry\n\ntheorem string_suffix_le_square (s : String) :\n  stringSuffix s ≤ strLen s * strLen s :=\nsorry\n\ntheorem string_suffix_repeated_char (s : String) :\n  isRepeatedChar s → stringSuffix s = (strLen s * (strLen s + 1)) / 2 :=\nsorry\n\ntheorem string_suffix_empty :\n  stringSuffix \"\" = 0 :=\nsorry\n\ntheorem string_suffix_slice (s : String) (i : Nat) :\n  i < strLen s → stringSuffix (s.drop i) ≤ stringSuffix s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval string_suffix \"abc\"\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval string_suffix \"ababaa\"\n\n/--\ninfo: 10\n-/\n#guard_msgs in\n#eval string_suffix \"aaaa\""}
{"id": "fvapps_003845", "vc-description": "/-\nYou will be given the prime factors of a number as an array.\nE.g: ```[2,2,2,3,3,5,5,13]```\n\nYou need to find the number, n, to which that prime factorization belongs.\nIt will be:\n```\nn = 2³.3².5².13 = 23400\n```\nThen, generate the divisors of this number.\n\nYour function ```get_num() or getNum()``` will receive an array with potentially unordered prime factors and should output: an array with the found integer n at index 0, the amount of total divisors (both prime and compound numbers) at index 1, followed the smallest factor (index 2, and the biggest one (last element)\n\nWe will see the example given above with the only difference that the array of the prime factors is unordered.\n\nThe list of divisors for that number (23400) is:\n```\n2, 3, 4, 5, 6, 8, 9, 10, 12, 13, 15, 18, 20, 24, 25, 26, 30, 36, 39, 40, 45, 50, 52, 60, 65, 72, 75, 78, 90, 100, 104, 117, 120, 130, 150, 156, 180, 195, 200, 225, 234, 260, 300, 312, 325, 360, 390, 450, 468, 520, 585, 600, 650, 780, 900, 936, 975, 1170, 1300, 1560, 1800, 1950, 2340, 2600, 2925, 3900, 4680, 5850, 7800, 11700 (not considering the integer 23400 itself)\n```\nThere is a total amount of ```71``` divisors. The smallest divisor is ```2``` and the highest ```11700```.\nSo the expected output will be: \n```\nget_num([2,13,2,5,2,5,3,3]) == [23400, 71, 2, 11700]\n```\nEnjoy!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_num (arr : List Nat) : List Nat :=\nsorry\n\ndef is_prime (n : Nat) : Bool :=\nsorry\n\ndef minimum (l : List Nat) (h : l.length > 0) : Nat :=\nsorry\n\ndef product (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem get_num_basic_properties {arr : List Nat} (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, 2 ≤ x ∧ x ≤ 20) :\n  let result := get_num arr\n  result.length = 4 ∧\n  result[0]! = product arr ∧\n  result[2]! = minimum arr h1 ∧\n  result[3]! = result[0]! / result[2]! :=\nsorry\n\ntheorem get_num_small_factors {arr : List Nat}\n  (h1 : 2 ≤ arr.length ∧ arr.length ≤ 3)\n  (h2 : ∀ x ∈ arr, 2 ≤ x ∧ x ≤ 7) :\n  let result := get_num arr\n  result[0]! > 0 ∧\n  result[1]! ≥ 0 ∧\n  result[2]! ≤ minimum arr (by exact Nat.zero_lt_of_lt h1.left) ∧\n  result[0]! % result[2]! = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: [150, 11, 2, 75]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 5, 5]\n\n/--\ninfo: [378, 15, 2, 189]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 3, 3, 7]\n\n/--\ninfo: [23400, 71, 2, 11700]\n-/\n#guard_msgs in\n#eval get_num [2, 13, 2, 5, 2, 5, 3, 3]"}
{"id": "fvapps_003851", "vc-description": "/-\nConsider the sequence `a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2`: \n\n`7, 8, 9, 10, 15, 18, 19, 20, 21, 22, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 69, 72, 73...`.\n\nLet us take the differences between successive elements of the sequence and\nget a second sequence `g: 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`.\n\nFor the sake of uniformity of the lengths of sequences **we add** a `1` at the head of g:\n\n`g: 1, 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`\n\nRemoving the 1s gives a third sequence:\n`p: 5, 3, 11, 3, 23, 3...`\nwhere you can see prime numbers.\n\n#Task:\nWrite functions:\n```\n1: an(n) with parameter n: returns the first n terms of the series a(n) (not tested)\n\n2: gn(n) with parameter n: returns the first n terms of the series g(n) (not tested)\n\n3: countOnes(n) with parameter n: returns the number of 1 in g(n) \n    (don't forget to add a `1` at the head) # (tested)\n\n4: p(n) with parameter n: returns an array of n unique prime numbers (not tested)\n\n5: maxp(n) with parameter n: returns the biggest prime number of the sequence pn(n) # (tested)\n\n6: anOver(n) with parameter n: returns an array (n terms) of the a(i)/i for every i such g(i) != 1 (not tested but interesting result)\n\n7: anOverAverage(n) with parameter n: returns as an *integer* the average of anOver(n)  (tested)\n```\n\n#Note:\nYou can write directly functions `3:`, `5:` and `7:`. There is no need to write functions `1:`, `2:`, `4:` `6:`\nexcept out of pure curiosity.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_ones (n : Nat) : Nat :=\n  sorry\n\ndef max_pn (n : Nat) : Nat :=\n  sorry\n\ndef an_over (n : Nat) : List Float :=\n  sorry\n\ndef an_over_average (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem count_ones_bounds {n : Nat} (h : n > 0) :\n  count_ones n ≤ n ∧ count_ones n ≥ 0 := by\nsorry\n\ntheorem count_ones_nat {n : Nat} (h : n > 0) :\n  count_ones n ≥ 0 := by\nsorry\n\ntheorem max_pn_gt_one {n : Nat} (h : n > 0) :\n  max_pn n > 1 := by\nsorry\n\ntheorem max_pn_nat {n : Nat} (h : n > 0) :\n  max_pn n ≥ 0 := by\nsorry\n\ntheorem an_over_length {n : Nat} (h : n > 0) :\n  (an_over n).length = n := by\nsorry\n\ntheorem an_over_all_positive {n : Nat} (h : n > 0) :\n  ∀ x ∈ an_over n, x > 0 := by\nsorry\n\ntheorem an_over_average_positive {n : Nat} (h : n > 0) :\n  an_over_average n > 0 := by\nsorry\n\ntheorem an_over_average_nat {n : Nat} (h : n > 0) :\n  an_over_average n ≥ 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_ones 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_ones 5\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pn 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval an_over_average 1"}
{"id": "fvapps_003859", "vc-description": "/-\nThe magic sum of 3s is calculated on an array by summing up odd numbers which include the digit `3`. Write a function `magic_sum` which accepts an array of integers and returns the sum.\n\n*Example:* `[3, 12, 5, 8, 30, 13]` results in `16` (`3` + `13`)\n\nIf the sum cannot be calculated, `0` should be returned.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def containsThree (n : Int) : Bool :=\n  sorry\n\ndef magicSum (nums : List Int) : Int :=\n  sorry\n\ndef sumList (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem magic_sum_filtering_contributing (nums : List Int) :\n  let contributing := nums.filter (fun x => x % 2 = 1 ∧ containsThree x)\n  contributing ≠ [] → magicSum nums = magicSum contributing := by\n  sorry\n\ntheorem magic_sum_filtering_non_contributing (nums : List Int) :\n  let non_contributing := nums.filter (fun x => x % 2 = 0 ∨ ¬containsThree x)\n  magicSum non_contributing = 0 := by\n  sorry\n\ntheorem magic_sum_order_invariant (nums : List Int) :\n  magicSum nums = magicSum nums.reverse := by\n  sorry\n\ntheorem magic_sum_duplicates (nums : List Int) :\n  magicSum (nums ++ nums) = 2 * magicSum nums := by\n  sorry\n\ntheorem magic_sum_empty :\n  magicSum [] = 0 := by\n  sorry\n\ntheorem magic_sum_valid_sum (nums : List Int) :\n  let valid := nums.filter (fun x => x % 2 = 1 ∧ containsThree x)\n  valid ≠ [] → magicSum nums = sumList valid := by\n  sorry\n\ntheorem magic_sum_all_invalid (nums : List Int) :\n  (∀ x ∈ nums, x % 2 = 0 ∨ ¬containsThree x) → magicSum nums = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval magic_sum [3]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 13]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 12, 5, 8, 30, 13]"}
{"id": "fvapps_003860", "vc-description": "/-\n# Scenario \n\n*You're saying good-bye your best friend* , **_See you next happy year_** . \n\n**_Happy Year_** *is the year with only distinct digits* , (e.g) **_2018_**\n\n___\n# Task\n\n**_Given_** a year, **_Find_** **_The next happy year_** or **_The closest year You'll see your best friend_**      ![!alt](https://i.imgur.com/mdX8dJP.png) ![!alt](https://i.imgur.com/mdX8dJP.png)\n\n___\n# Notes\n\n* **_Year_** Of Course always **_Positive_** .\n* **_Have no fear_** , *It is guaranteed that the answer exists* . \n* **_It's not necessary_** *that the year passed to the function is Happy one* .   \n* **_Input Year with in range_** *(1000  ≤  y  ≤  9000)*\n\n____\n# Input >> Output Examples:\n\n```\nnextHappyYear (7712) ==> return (7801)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *7801* . \n___\n\n```\nnextHappyYear (8989) ==> return (9012)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *9012* . \n___\n\n```\nnextHappyYear (1001) ==> return (1023)\n```\n\n## **_Explanation_**:\n\nAs the **_Next closest year with only distinct digits is_**  *1023* .\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/\n\n-- Helper functions", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_happy_year (year : Nat) : Nat :=\nsorry\n\ndef number_to_digits (n : Nat) : List Nat :=\nsorry\n\ndef count_unique (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem next_happy_year_increases (year : Nat)\n  (h : year ≥ 1000 ∧ year ≤ 8999) :\n  next_happy_year year > year :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1023\n-/\n#guard_msgs in\n#eval next_happy_year 1001\n\n/--\ninfo: 7801\n-/\n#guard_msgs in\n#eval next_happy_year 7712\n\n/--\ninfo: 9012\n-/\n#guard_msgs in\n#eval next_happy_year 8999"}
{"id": "fvapps_003875", "vc-description": "/-\nYour task is to find the first element of an array that is not consecutive.\n\nBy not consecutive we mean not exactly 1 larger than the previous element of the array.\n\nE.g. If we have an array `[1,2,3,4,6,7,8]` then `1` then `2` then `3` then `4` are all consecutive but `6` is not, so that's the first non-consecutive number.\n\n```if:c\nIf a non consecutive number is found then return `true` and set the passed in pointer to the number found.\n\nIf the whole array is consecutive then return `false`.\n```\n```if-not:c\nIf the whole array is consecutive then return `null`^(2).\n```\nThe array will always have at least `2` elements^(1) and all elements will be numbers. The numbers will also all be unique and in ascending order. The numbers could be positive or negative and the first non-consecutive could be either too!\n\nIf you like this Kata, maybe try this one next: https://www.codewars.com/kata/represent-array-of-numbers-as-ranges\n\n```if:c\n^(1) Can you write a solution that will return `false` for both `[]` and `[ x ]` (an empty array and one with a single number) though? (This is an empty array and one with a single number and is not tested for, but you can write your own example test. )\n```\n```if-not:c\n^(1) Can you write a solution that will return `null`^(2) for both `[]` and `[ x ]` though?  (This is an empty array and one with a single number and is not tested for, but you can write your own example test. )\n\n^(2)  \nSwift, Ruby and Crystal: `nil`  \nHaskell: `Nothing`  \nPython, Rust: `None`  \nJulia: `nothing`  \nNim: `none(int)` (See [options](https://nim-lang.org/docs/options.html))\n```\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def firstNonConsecutive (arr : List Int) : Option Int :=\n  sorry", "vc-theorems": "theorem empty_or_single_returns_none (arr : List Int) :\n  arr.length ≤ 1 → firstNonConsecutive arr = none :=\nsorry\n\ntheorem consecutive_returns_none (arr : List Int) (h : arr.length ≥ 2) :\n  (∀ i j, i + 1 = j → arr[i]? = some x → arr[j]? = some y → y = x + 1) →\n  firstNonConsecutive arr = none :=\nsorry\n\ntheorem non_consecutive_returns_first_break (arr : List Int) (gap : Int)\n    (h1 : arr.length ≥ 3) (h2 : (abs gap) > 1) :\n  let pos := arr.length / 2\n  let val := arr[pos]?\n  match val with\n  | none => True\n  | some x =>\n    let next := arr[pos+1]?\n    match next with\n    | none => True\n    | some y => x + gap = y → firstNonConsecutive arr = some y\n  :=\nsorry\n\ntheorem result_in_input (arr : List Int) :\n  match firstNonConsecutive arr with\n  | none => True\n  | some x => x ∈ arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 6, 7, 8]\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 5, 6, 7, 8]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval first_non_consecutive [-3, -2, 0, 1]"}
{"id": "fvapps_003877", "vc-description": "/-\n# Fun fact\nTetris was the first video game played in outer space\n\nIn 1993, Russian cosmonaut Aleksandr A. Serebrov spent 196 days on the Mir space station with a very special distraction: a gray Game Boy loaded with Tetris. During that time the game orbited the Earth 3,000 times and became the first video game played in space. The Game Boy was sold in a Bonhams auction for $1,220 during the Space History Sale in 2011.\n\n# Task\nParse the game log and determine how many lines have been cleared through the game. The game ends if all commands from input were interpreted or the maximum field height (30 units) is reached.\n\nA horizontal line, according to the rules of classic Tetris, is considered cleared if it represents a solid line without gaps formed by falling blocks.\nWhen such a line is formed, it disappears and any blocks above it fall down to fill the space.\n\n# Input\n```python\n['4L2', '3R4', '4L3', '3L4', '4R0', '1L2'] # example\n```\nAs an argument, you are given gamelog - an array of commands which you need to interpret.\n\nEach command has the same form:\n* The first character - the type of block (integer from 1 to 4, as in this kata we have only 4 types of blocks). Block types are described below.\n* The second - the direction of movement (`\"R\"` or `\"L\"` - right or left).\n* The third is an offset (integer from 0 to 4, as width of our field 9 units and new block always appears at the center of the field) relative to the starting position. Thus, `L4` means the leftmost position, and `R4` the rightmost, and `L0` is equivalent to `R0`.\n\n# Output\nThe total number of cleaned horizontal lines (`int`) to the end of the game. Note, if the field height is exceeded, then the game ends immediately.\n\n# Blocks\nIn this kata we have only 4 types of blocks. Yes, this is not a classic set of shapes, but this is only for simplicity.\n```\n# and their graphical representation:\n             ■\n         ■   ■\n     ■   ■   ■\n ■   ■   ■   ■\n---+---+---+---\n#1  #2  #3  #4\n```\n# Field\nGamefield (a rectangular vertical shaft) has width 9 units and height 30 units.\n\ntable, th, td {\n  border: 1px solid;\n}\n\nIndices can be represented as:\n\nL4\nL3\nL2\nL1\nL0/R0\nR1\nR2\nR3\nR4\n\n# Example 1\n```python\n>>> gamelog = ['1R4', '2L3', '3L2', '4L1', '1L0', '2R1', '3R2', '4R3', '1L4']\n>>> tetris(gamelog)\n1\n```\nGamefield before last command (_ means empty space):\n```\n___■___■_\n__■■__■■_\n_■■■_■■■_\n_■■■■■■■■\n```\nGamefield after all commands:\n```\n___■___■_\n__■■__■■_\n_■■■_■■■_\n```\nAs you can see, one solid line was cleared. So, answer is 1.\n\n# Example 2\n```python\n>>> gamelog = ['1L2', '4R2', '3L3', '3L1', '1L4', '1R4']\n>>> tetris(gamelog)\n0\n```\nGamefield after all commands:\n```\n _____■__\n_■_■__■__\n_■_■__■__\n■■■■__■_■\n```\nAs you can see, there is no solid lines, so nothing to clear. Our answer is 0, zero cleaned lines.\n\n# Note\n\nSince there is no rotation of blocks in our model and all blocks are very simple, do not overthink the task.\n\n# Other  \n\nIf you like the idea: leave feedback, and there will be more katas in the Tetris series.\n\n* 7 kyuTetris Series #1 — Scoring System\n* 6 kyuTetris Series #2 — Primitive Gameplay\n* 6 kyuTetris Series #3 — Adding Rotation (TBA)\n* 5 kyuTetris Series #4 — New Block Types (TBA)\n* 4 kyuTetris Series #5 — Complex Block Types (TBA?)\n-/", "vc-preamble": "def Position := String", "vc-helpers": "", "vc-definitions": "def Command := String\n\ndef tetris (commands : List Command) : Nat :=\n  sorry\n\ndef sumHeights (commands : List Command) : Nat :=\n  sorry", "vc-theorems": "theorem tetris_output_natural (commands : List Command) :\n  tetris commands ≥ 0 :=\nsorry\n\ntheorem tetris_height_limit (commands : List Command) (h : commands ≠ []) :\n  tetris commands < 30 :=\nsorry\n\ntheorem tetris_cleared_lines (commands : List Command) (h : commands ≠ []) :\n  tetris commands ≤ sumHeights commands :=\nsorry\n\ntheorem tetris_idempotent_empty_moves (commands : List Command) (h : commands ≠ []) :\n  let emptyMoves : List Command := [\"1L0\", \"1R0\"]\n  tetris commands = tetris (commands ++ emptyMoves) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval tetris [\"1R4\", \"2L3\", \"3L2\", \"4L1\", \"1L0\", \"2R1\", \"3R2\", \"4R3\", \"1L4\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval tetris [\"1L2\", \"4R2\", \"3L3\", \"3L1\", \"1L4\", \"1R4\"]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval tetris [\"4R4\", \"4L3\", \"4L2\", \"4L1\", \"4L0\", \"4R1\", \"4R2\", \"4R3\", \"3L4\"]"}
{"id": "fvapps_003884", "vc-description": "/-\nGiven two strings, the first being a random string and the second being the same as the first, but with three added characters somewhere in the string (three same characters),\n\nWrite a function that returns the added character\n\n### E.g\n\n```\nstring1 = \"hello\"\nstring2 = \"aaahello\"\n\n// => 'a'\n```\n\nThe above is just an example; the characters could be anywhere in the string and string2 is actually **shuffled**.\n\n### Another example\n\n```\nstring1 = \"abcde\"\nstring2 = \"2db2a2ec\"\n\n// => '2'\n```\n\nNote that the added character could also exist in the original string\n\n```\nstring1 = \"aabbcc\"\nstring2 = \"aacccbbcc\"\n\n// => 'c'\n```\n\nYou can assume that string2 will aways be larger than string1, and there will always be three added characters in string2.\n\n```if:c\nWrite the function `added_char()` that takes two strings and return the added character as described above.\n```\n\n```if:javascript\nWrite the function `addedChar()` that takes two strings and return the added character as described above.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\n  sorry\n\ndef added_char (base modified : String) : Char :=\n  sorry", "vc-theorems": "theorem added_char_correct (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  added_char base modified = c :=\nsorry\n\ntheorem length_difference (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  modified.length = base.length + 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"hello\" \"checlclo\"\n\n/--\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"aabbcc\" \"aacccbbcc\"\n\n/--\ninfo: '2'\n-/\n#guard_msgs in\n#eval added_char \"abcde\" \"2db2a2ec\""}
{"id": "fvapps_003887", "vc-description": "/-\n# Task\n Your Informatics teacher at school likes coming up with new ways to help you understand the material. When you started studying numeral systems, he introduced his own numeral system, which he's convinced will help clarify things. His numeral system has base 26, and its digits are represented by English capital letters - `A for 0, B for 1, and so on`.\n\n The teacher assigned you the following numeral system exercise: given a one-digit `number`, you should find all unordered pairs of one-digit numbers whose values add up to the `number`.\n\n# Example\n\n For `number = 'G'`, the output should be `[\"A + G\", \"B + F\", \"C + E\", \"D + D\"]`\n\n Translating this into the decimal numeral system we get: number = 6, so it is `[\"0 + 6\", \"1 + 5\", \"2 + 4\", \"3 + 3\"]`.\n\n# Input/Output\n\n - `[input]` string(char in C#) `number`\n\n   A character representing a correct one-digit number in the new numeral system.\n\n   Constraints: `'A' ≤ number ≤ 'Z'.`\n\n - `[output]` a string array\n\n   An array of strings in the format \"letter1 + letter2\", where \"letter1\" and \"letter2\" are correct one-digit numbers in the new numeral system. The strings should be sorted by \"letter1\".\n\n   Note that \"letter1 + letter2\" and \"letter2 + letter1\" are equal pairs and we don't consider them to be different.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isUpperCase (c : Char) : Bool :=\n  sorry\n\ndef toLetterIndex (c : Char) : Nat :=\n  sorry\n\ndef new_numeral_system (letter : Char) : List String :=\n  sorry", "vc-theorems": "theorem correct_format {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    s.length = 5 ∧ s.data.get ⟨1, sorry⟩ = ' ' ∧\n    s.data.get ⟨2, sorry⟩ = '+' ∧\n    s.data.get ⟨3, sorry⟩ = ' ' := by\n  sorry\n\ntheorem valid_letters {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    let first := s.data.get ⟨0, sorry⟩\n    let last := s.data.get ⟨4, sorry⟩\n    isUpperCase first ∧\n    isUpperCase last ∧\n    first ≤ letter ∧\n    last ≤ letter := by\n  sorry\n\ntheorem correct_sum {letter : Char} :\n  ∀ s ∈ new_numeral_system letter,\n    let first := s.data.get ⟨0, sorry⟩\n    let last := s.data.get ⟨4, sorry⟩\n    toLetterIndex first + toLetterIndex last = toLetterIndex letter := by\n  sorry\n\ntheorem left_side_sorted {letter : Char} :\n  let leftSide := (new_numeral_system letter).map (fun s => s.data.get ⟨0, sorry⟩)\n  ∀ i j, i < j → j < leftSide.length → leftSide[i]! ≤ leftSide[j]! := by\n  sorry\n\ntheorem middle_pair_equal {letter : Char} :\n  toLetterIndex letter % 2 = 0 →\n    let result := new_numeral_system letter\n    let midIdx := toLetterIndex letter / 2\n    let middle := result[midIdx]!\n    middle.data.get ⟨0, sorry⟩ = middle.data.get ⟨4, sorry⟩ := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_003888", "vc-description": "/-\nYour work is to write a method that takes a value and an index, and returns the value with the bit at given index flipped.\n\nThe bits are numbered from the least significant bit (index 1).\n\nExample:\n```python\nflip_bit(15, 4) == 7 # 15 in binary is 1111, after flipping 4th bit, it becomes 0111, i.e. 7\nflip_bit(15, 5) == 31 # 15 in binary is 1111, 5th bit is 0, after flipping, it becomes 11111, i.e., 31\n```\nNote : index number can be out of number's range : e.g number is 3 (it has 2 bits) and index number is 8(for C# this number is up to 31) -> result will be 131 \n\nSee more examples in test classes\n\nGood luck!\n-/\n\n-- States that flipping a bit twice returns the original value\n\n-- States that only the target bit changes", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flip_bit (value : Int) (bit_index : Nat) : Int :=\nsorry\n\ndef band (x y : Int) : Int :=\nsorry\n\ndef shiftLeft (x : Int) (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem flip_bit_reversible\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 ≤ bit_index) (h2 : bit_index ≤ 32) :\n  flip_bit (flip_bit value bit_index) bit_index = value :=\nsorry\n\ntheorem flip_bit_changes_target_bit\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 ≤ bit_index) (h2 : bit_index ≤ 32) :\n  ∃ bit_mask : Int,\n    bit_mask = shiftLeft 1 (bit_index - 1) ∧\n    band value bit_mask ≠ band (flip_bit value bit_index) bit_mask ∧\n    band value (bit_mask - 1) = band (flip_bit value bit_index) (bit_mask - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 32768\n-/\n#guard_msgs in\n#eval flip_bit 0 16\n\n/--\ninfo: 1073741823\n-/\n#guard_msgs in\n#eval flip_bit 2147483647 31\n\n/--\ninfo: 255\n-/\n#guard_msgs in\n#eval flip_bit 127 8"}
{"id": "fvapps_003889", "vc-description": "/-\nWrite a function that solves an algebraic expression given as a string. \n\n* The expression can include only sums and products. \n\n* The numbers in the expression are in standard notation (NOT scientific).\n\n* In contrast, the function should return a string with the calculated value given in scientific notation with 5 decimal digits. \n\n# Example:\n```python\nstrexpression = \"5 * 4 + 6\"\nsum_prod(strexpression) = \"2.60000e+01\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isScientificNotation (s : String) : Bool :=\nsorry\n\ndef sumProd (s : String) : String :=\nsorry\n\ndef stringToFloat (s : String) : Float :=\nsorry", "vc-theorems": "theorem sumProd_format {nums : List Float}\n  (h1 : ∀ n ∈ nums, 0.1 ≤ n ∧ n ≤ 100)\n  (h2 : 2 ≤ nums.length ∧ nums.length ≤ 4) :\n  isScientificNotation (sumProd (\"+\".intercalate (nums.map toString))) :=\nsorry\n\ntheorem sumProd_multiply (x y : Nat)\n  (h1 : 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ y ∧ y ≤ 100) :\n  (stringToFloat (sumProd (s!\"{x}*{y}\"))) = Float.ofNat (x * y) :=\nsorry\n\ntheorem sumProd_add (x y : Nat)\n  (h1 : 1 ≤ x ∧ x ≤ 100)\n  (h2 : 1 ≤ y ∧ y ≤ 100) :\n  (stringToFloat (sumProd (s!\"{x}+{y}\"))) = Float.ofNat (x + y) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '2.60000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5*4+6\"\n\n/--\ninfo: '2.90000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5+4*6\"\n\n/--\ninfo: '3.58000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5.4*4.0+6.2+8.0\""}
{"id": "fvapps_003895", "vc-description": "/-\n# Task\n\nWrite a function named `sumEvenNumbers`, taking a sequence of numbers as single parameter. Your function must return the sum of **the even values** of this sequence.\n\nOnly numbers without decimals like `4` or `4.0` can be even. \n\n## Input\n* sequence of numbers: those numbers could be integers and/or floats. \n\nFor example, considering this input value : `[4,3,1,2,5,10,6,7,9,8]`, then your function should return `30` (because `4 + 2 + 10 + 6 + 8 = 30`).\n-/", "vc-preamble": "def listSum (l : List Int) : Int :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def sumEvenNumbers (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_even_numbers_sums_evens (l : List Int) :\n  sumEvenNumbers l = listSum (l.filter (fun n => n % 2 = 0)) := by\n  sorry\n\ntheorem sum_even_numbers_is_even (l : List Int) :\n  sumEvenNumbers l % 2 = 0 := by\n  sorry\n\ntheorem sum_even_numbers_idempotent (l : List Int) :\n  let result := sumEvenNumbers l\n  result ≠ 0 → sumEvenNumbers [result] = result := by\n  sorry\n\ntheorem sum_even_numbers_empty :\n  sumEvenNumbers [] = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 30\n-/\n#guard_msgs in\n#eval sum_even_numbers [4, 3, 1, 2, 5, 10, 6, 7, 9, 8]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_even_numbers []\n\n/--\ninfo: 14\n-/\n#guard_msgs in\n#eval sum_even_numbers [-16, -32, 20, 21, 41, 42]"}
{"id": "fvapps_003900", "vc-description": "/-\nWrite a function that takes an integer and returns an array `[A, B, C]`, where `A` is the number of multiples of 3 (but not 5) below the given integer, `B` is the number of multiples of 5 (but not 3) below the given integer and `C` is the number of multiples of 3 and 5 below the given integer. \n\nFor example, `solution(20)` should return `[5, 2, 1]`\n\n~~~if:r\n```r\n# in R, returns a numeric vector\nsolution(20)\n[1] 5 2 1\n\nclass(solution(20))\n[1] \"numeric\"\n```\n~~~\n-/\n\n-- Sum matches total multiples\n\n-- Components match exclusive counts\n\n-- Edge cases\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Output format properties", "vc-preamble": "def isMultipleOf3 (x : Nat) : Bool := x % 3 == 0\n\ndef isMultipleOf5 (x : Nat) : Bool := x % 5 == 0", "vc-helpers": "", "vc-definitions": "def solution (n : Nat) : Array Nat :=\nsorry", "vc-theorems": "theorem solution_output_format (n : Nat) (h : n > 0) :\n  (solution n).size = 3 ∧\n  ∀ i < 3, (solution n)[i]! ≥ 0 :=\nsorry\n\ntheorem solution_sum_matches_multiples (n : Nat) (h : n > 0) :\n  let result := solution n\n  let total := result[0]! + result[1]! + result[2]!\n  let multiples := (List.range n).filter (fun x => isMultipleOf3 x || isMultipleOf5 x)\n  total = multiples.length :=\nsorry\n\ntheorem solution_component_counts (n : Nat) (h : n > 0) :\n  let result := solution n\n  let only3 := (List.range n).filter (fun x => isMultipleOf3 x && !isMultipleOf5 x)\n  let only5 := (List.range n).filter (fun x => isMultipleOf5 x && !isMultipleOf3 x)\n  let both := (List.range n).filter (fun x => isMultipleOf3 x && isMultipleOf5 x)\n  result[0]! = only3.length ∧\n  result[1]! = only5.length ∧\n  result[2]! = both.length :=\nsorry\n\ntheorem solution_edge_cases :\n  solution 1 = #[0, 0, 0] ∧\n  solution 3 = #[0, 0, 0] ∧\n  solution 4 = #[1, 0, 0] :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003909", "vc-description": "/-\nThis is the simple version of Shortest Code series. If you need some challenges, please try the [challenge version](http://www.codewars.com/kata/56f928b19982cc7a14000c9d)\n\n## Task: \n\n  Every uppercase letter is Father, The corresponding lowercase letters is the Son.\n\n  Give you a string ```s```, If the father and son both exist, keep them. If it is a separate existence, delete them. Return the result.\n\n  For example: \n\n   ```sc(\"Aab\")``` should return ```\"Aa\"```\n\n   ```sc(\"AabBc\")``` should return ```\"AabB\"```\n\n   ```sc(\"AaaaAaab\")``` should return ```\"AaaaAaa\"```(father can have a lot of son)\n\n   ```sc(\"aAAAaAAb\")``` should return ```\"aAAAaAA\"```(son also can have a lot of father ;-)\n\n### Series:\n - [Bug in Apple](http://www.codewars.com/kata/56fe97b3cc08ca00e4000dc9)\n - [Father and Son](http://www.codewars.com/kata/56fe9a0c11086cd842000008)\n - [Jumping Dutch act](http://www.codewars.com/kata/570bcd9715944a2c8e000009)\n - [Planting Trees](http://www.codewars.com/kata/5710443187a36a9cee0005a1)\n - [Give me the equation](http://www.codewars.com/kata/56fe9b65cc08cafbc5000de3)\n - [Find the murderer](http://www.codewars.com/kata/570f3fc5b29c702c5500043e)\n - [Reading a Book](http://www.codewars.com/kata/570ca6a520c69f39dd0016d4)\n - [Eat watermelon](http://www.codewars.com/kata/570df12ce6e9282a7d000947)\n - [Special factor](http://www.codewars.com/kata/570e5d0b93214b1a950015b1)\n - [Guess the Hat](http://www.codewars.com/kata/570ef7a834e61306da00035b)\n - [Symmetric Sort](http://www.codewars.com/kata/5705aeb041e5befba20010ba)\n - [Are they symmetrical?](http://www.codewars.com/kata/5705cc3161944b10fd0004ba)\n - [Max Value](http://www.codewars.com/kata/570771871df89cf59b000742)\n - [Trypophobia](http://www.codewars.com/kata/56fe9ffbc25bf33fff000f7c)\n - [Virus in Apple](http://www.codewars.com/kata/5700af83d1acef83fd000048)\n - [Balance Attraction](http://www.codewars.com/kata/57033601e55d30d3e0000633)\n - [Remove screws I](http://www.codewars.com/kata/5710a50d336aed828100055a)\n - [Remove screws II](http://www.codewars.com/kata/5710a8fd336aed00d9000594)\n - [Regular expression compression](http://www.codewars.com/kata/570bae4b0237999e940016e9)\n - [Collatz Array(Split or merge)](http://www.codewars.com/kata/56fe9d579b7bb6b027000001)\n - [Tidy up the room](http://www.codewars.com/kata/5703ace6e55d30d3e0001029)\n - [Waiting for a Bus](http://www.codewars.com/kata/57070eff924f343280000015)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsUpper (c : Char) : Bool :=\nsorry\n\ndef IsLower (c : Char) : Bool :=\nsorry\n\ndef swapcase (c : Char) : Char :=\nsorry\n\ndef sc (s : String) : String :=\nsorry", "vc-theorems": "theorem sc_subset (s : String) :\n  ∀ (c : Char), c ∈ (sc s).data → c ∈ s.data :=\nsorry\n\ntheorem sc_length (s : String) :\n  (sc s).length ≤ s.length :=\nsorry\n\ntheorem sc_swapcase_pairs (s : String) :\n  ∀ (c : Char), c ∈ (sc s).data → swapcase c ∈ (sc s).data :=\nsorry\n\ntheorem sc_all_upper (s : String) :\n  (∀ (c : Char), c ∈ s.data → IsUpper c) → sc s = \"\" :=\nsorry\n\ntheorem sc_all_lower (s : String) :\n  (∀ (c : Char), c ∈ s.data → IsLower c) → sc s = \"\" :=\nsorry\n\ntheorem sc_empty :\n  sc \"\" = \"\" :=\nsorry\n\ntheorem sc_idempotent (s : String) :\n  sc (sc s) = sc s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Aa'\n-/\n#guard_msgs in\n#eval sc \"Aab\"\n\n/--\ninfo: 'AabB'\n-/\n#guard_msgs in\n#eval sc \"AabBc\"\n\n/--\ninfo: 'SONson'\n-/\n#guard_msgs in\n#eval sc \"SONson\""}
{"id": "fvapps_003910", "vc-description": "/-\nA pair of numbers has a unique LCM but a single number can be the LCM of more than one possible\npairs. For example `12` is the LCM of `(1, 12), (2, 12), (3,4)` etc. For a given positive integer N, the number of different integer pairs with LCM is equal to N can be called the LCM cardinality of that number N. In this kata your job is to find out the LCM cardinality of a number.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lcm_cardinality (n : Nat) : Nat :=\nsorry\n\ndef lcm (a b : Nat) : Nat :=\nsorry\n\ndef divisors (n : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem lcm_cardinality_positive (n : Nat) (h : n ≥ 1) :\n  lcm_cardinality n ≥ 1 :=\nsorry\n\ntheorem lcm_cardinality_upper_bound (n : Nat) (h : n ≥ 1) :\n  let divs := List.length (divisors n)\n  lcm_cardinality n ≤ 1 + (divs * (divs - 1)) / 2 :=\nsorry\n\ntheorem lcm_cardinality_monotonic_powers_two (i : Nat) (h : i > 0) :\n  lcm_cardinality (2^i) ≥ lcm_cardinality (2^(i-1)) :=\nsorry\n\ntheorem lcm_factors_bound (n : Nat) (h : n ≥ 1) :\n  ∀ (a b : Nat), a ∈ divisors n → b ∈ divisors n → lcm a b ≤ n :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003912", "vc-description": "/-\nYou would like to get the 'weight' of a name by getting the sum of the ascii values. However you believe that capital letters should be worth more than mere lowercase letters. Spaces, numbers, or any other character are worth 0.\n\nNormally in ascii\n\n    a has a value of 97\n    A has a value of 65\n    ' ' has a value of 32\n    0 has a value of 48\n\nTo find who has the 'weightier' name you will switch all the values so:\n\n    A will be 97\n    a will be 65\n    ' ' will be 0\n    0 will be 0\n    etc...\n\nFor example Joe will have a weight of 254, instead of 286 using normal ascii values.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_weight (s : String) : Nat :=\n  sorry\n\ndef swapcase (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem get_weight_nonnegative (s : String) :\n  get_weight s ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 254\n-/\n#guard_msgs in\n#eval get_weight \"Joe\"\n\n/--\ninfo: 1275\n-/\n#guard_msgs in\n#eval get_weight \"George Washington\"\n\n/--\ninfo: 214\n-/\n#guard_msgs in\n#eval get_weight \"R2D2\""}
{"id": "fvapps_003913", "vc-description": "/-\n# Story\n\nDue to lack of maintenance the minute-hand has fallen off Town Hall clock face.\n\nAnd because the local council has lost most of our tax money to a Nigerian email scam there are no funds to fix the clock properly. \n\nInstead, they are asking for volunteer programmers to write some code that tell the time by only looking at the remaining hour-hand!\n\nWhat a bunch of cheapskates!\n\nCan you do it?\n\n# Kata\n\nGiven the ```angle``` (in degrees) of the hour-hand, return the time in HH:MM format. Round _down_ to the nearest minute.\n\n# Examples\n\n* ```12:00``` = 0 degrees\n\n* ```03:00``` = 90 degrees\n\n* ```06:00``` = 180 degrees\n\n* ```09:00``` = 270 degrees\n\n* ```12:00``` = 360 degrees\n\n# Notes\n\n* 0 <= ```angle``` <= 360\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def what_time_is_it (angle : Float) : String :=\nsorry\n\ndef str_to_hours_mins (s : String) : Nat × Nat :=\nsorry\n\ndef angle_to_total_mins (angle : Float) : Float :=\nsorry", "vc-theorems": "theorem time_format_valid {angle : Float} (h : 0 ≤ angle ∧ angle ≤ 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  result.length = 5 ∧\n  hours ≥ 1 ∧ hours ≤ 12 ∧\n  mins ≥ 0 ∧ mins ≤ 59 :=\nsorry\n\ntheorem time_calculation_consistent {angle : Float} (h : 0 ≤ angle ∧ angle ≤ 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  let expected_total_mins := angle / 360 * 12 * 60\n  let actual_total_mins := (hours % 12) * 60 + mins\n  (expected_total_mins - actual_total_mins.toFloat).abs < 2 :=\nsorry\n\ntheorem hour_boundaries_correct (angle : Nat) (h : angle < 360) :\n  let result := what_time_is_it angle.toFloat\n  let (hours, _) := str_to_hours_mins result\n  if angle < 30 then hours = 12\n  else hours = angle / 30 :=\nsorry\n\ntheorem specific_angles_correct :\n  (str_to_hours_mins (what_time_is_it 0)).1 = 12 ∧\n  (str_to_hours_mins (what_time_is_it 30)).1 = 1 ∧\n  (str_to_hours_mins (what_time_is_it 330)).1 = 11 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '12:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 0\n\n/--\ninfo: '03:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 90\n\n/--\ninfo: '01:30'\n-/\n#guard_msgs in\n#eval what_time_is_it 45"}
{"id": "fvapps_003917", "vc-description": "/-\n# Valid HK Phone Number\n\n## Overview\n\nIn Hong Kong, a valid phone number has the format ```xxxx xxxx``` where ```x``` is a decimal digit (0-9).  For example:\n\n## Task\n\nDefine two functions, ```isValidHKPhoneNumber``` and ```hasValidHKPhoneNumber```, that ```return```s whether a given string is a valid HK phone number and contains a valid HK phone number respectively (i.e. ```true/false``` values).\n\nIf in doubt please refer to the example tests.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidHKPhoneNumber (s : String) : Bool :=\nsorry\n\ndef hasValidHKPhoneNumber (s : String) : Bool :=\nsorry\n\ndef isValidDigitStr (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_number_is_accepted {d1 d2 : String} :\n  isValidDigitStr d1 → isValidDigitStr d2 →\n  isValidHKPhoneNumber (d1 ++ \" \" ++ d2) ∧\n  hasValidHKPhoneNumber (d1 ++ \" \" ++ d2) :=\nsorry\n\ntheorem invalid_numbers_are_rejected {s : String} :\n  (∃ i, String.get? s i = some ' ') →\n  (∃ i n, String.get? s i = some n ∧ (n < '0' ∨ n > '9')) →\n  ¬isValidHKPhoneNumber s :=\nsorry\n\ntheorem has_valid_number_with_text {d1 d2 pre suf : String} :\n  isValidDigitStr d1 → isValidDigitStr d2 →\n  hasValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) ∧\n  ¬isValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"1234 5678\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"abcd efgh\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"836g 2986\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"Call 1234 5678 now\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"No number here\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"8365 2986 is my number\""}
{"id": "fvapps_003922", "vc-description": "/-\nIn this Kata, we are going to determine if the count of each of the characters in a string can be equal if we remove a single character from that string.\n\nFor example:\n```\nsolve('abba') = false -- if we remove any character, the count of each character will not be equal.\nsolve('abbba') = true -- if we remove one b, the count of each character becomes 2.\nsolve('aaaa') = true -- if we remove one character, the remaining characters have same count.\nsolve('wwwf') = true -- if we remove f, the remaining letters have same count.\n```\nMore examples in the test cases. Empty string is not tested.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\nsorry\n\ndef countOccurrences (c : Char) (s : String) : Nat :=\nsorry\n\ndef allCountsEqual (s : String) : Bool :=\nsorry", "vc-theorems": "theorem solve_exists_char_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length ≥ 2) :\n  ∃ c : Char, c ∈ s.data ∧\n  allCountsEqual (s.replace (String.mk [c]) \"\") = true :=\nsorry\n\ntheorem solve_equal_counts_after_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length ≥ 2) :\n  ∃ c : Char, c ∈ s.data ∧\n  let s' := s.replace (String.mk [c]) \"\"\n  (∀ c₁ c₂, c₁ ∈ s'.data → c₂ ∈ s'.data →\n    countOccurrences c₁ s' = countOccurrences c₂ s') :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"aaaa\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbba\""}
{"id": "fvapps_003924", "vc-description": "/-\n## A square of squares\nYou like building blocks. You especially like building blocks that are squares. And what you even like more, is to arrange them into a square of square building blocks!\n\nHowever, sometimes, you can't arrange them into a square. Instead, you end up with an ordinary rectangle! Those blasted things! If you just had a way to know, whether you're currently working in vain… Wait! That's it! You just have to check if your number of building blocks is a _perfect square_.\n\n## Task\n\nGiven an integral number, determine if it's a [square number](https://en.wikipedia.org/wiki/Square_number):\n\n> In mathematics, a __square number__ or __perfect square__ is an integer that is the square of an integer; in other words, it is the product of some integer with itself.\n\nThe tests will _always_ use some integral number, so don't worry about that in dynamic typed languages.\n\n### Examples\n\n```\n-1  =>  false\n 0  =>  true\n 3  =>  false\n 4  =>  true\n25  =>  true\n26  =>  false\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_square (n : Int) : Bool :=\nsorry\n\ndef Int.sqrt (n : Int) : Int :=\nsorry", "vc-theorems": "theorem is_square_properties_1 {n : Int} :\n  is_square n = true → n ≥ 0 :=\nsorry\n\ntheorem is_square_properties_3 {n : Nat} :\n  is_square (n * n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003927", "vc-description": "/-\n# Bubblesort Algorithm\n\n## Overview\n\nThe Bubblesort Algorithm is one of many algorithms used to sort a list of similar items (e.g. all numbers or all letters) into either ascending order or descending order.  Given a list (e.g.):\n\n```python\n[9, 7, 5, 3, 1, 2, 4, 6, 8]\n```\n\nTo sort this list in ascending order using Bubblesort, you first have to compare the first two terms of the list.  If the first term is larger than the second term, you perform a swap.  The list then becomes:\n\n```python\n[7, 9, 5, 3, 1, 2, 4, 6, 8] # The \"9\" and \"7\" have been swapped because 9 is larger than 7 and thus 9 should be after 7\n```\n\nYou then proceed by comparing the 2nd and 3rd terms, performing a swap *when necessary*, and then the 3rd and 4th term, then the 4th and 5th term, etc. etc.  When you reach the end of the list, it is said that you have completed **1 complete pass**.\n\n## Task\n\nGiven an array of integers, your function `bubblesortOnce`/`bubblesort_once`/`BubblesortOnce` (or equivalent, depending on your language's naming conventions) should return a *new* array equivalent to performing exactly **1 complete pass** on the original array.  Your function should be pure, i.e. it should **not** mutate the input array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bubblesortOnce (xs : List Int) : List Int :=\n  sorry\n\ndef isSorted (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem output_same_length {xs : List Int} (h : xs ≠ []) :\n  List.length (bubblesortOnce xs) = List.length xs :=\nsorry\n\ntheorem input_unchanged {xs : List Int} (h : xs ≠ []) :\n  let original := xs\n  bubblesortOnce xs = bubblesortOnce original :=\nsorry\n\ntheorem at_least_one_swap_if_unsorted {xs : List Int} (h : xs ≠ []) :\n  List.length xs > 1 →\n  ¬isSorted xs →\n  bubblesortOnce xs ≠ xs :=\nsorry\n\ntheorem moves_max_element_right {xs : List Int} (h : xs ≠ []) :\n  List.length xs > 1 →\n  let result := bubblesortOnce xs\n  ∀ y ∈ List.take (List.length result - 1) result,\n  y ≤ List.get! result (List.length result - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval bubblesort_once [9, 7, 5, 3, 1, 2, 4, 6, 8]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval bubblesort_once [6, 3, 4, 9, 1, 2, 7, 8, 5]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval bubblesort_once [2, 4, 1]"}
{"id": "fvapps_003931", "vc-description": "/-\nIn number theory, an  **[abundant](https://en.wikipedia.org/wiki/Abundant_number)** number or an **[excessive](https://en.wikipedia.org/wiki/Abundant_number)** number is one for which the sum of it's **[proper divisors](http://mathworld.wolfram.com/ProperDivisor.html)** is greater than the number itself.  The integer **12** is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of **16**. The amount by which the sum exceeds the number is the **abundance**. The number **12** has an abundance of **4**, for example. Other initial abundant numbers are : 12, 18, 20, 24, 30, 36, 40, 42, 48, 54 etc . **Infinitely** many **odd** and **even** abundant numbers exist.    \nAs you should have guessed by now, in this kata your function will take a positive integer **h** as range input and return a nested array/list that will contain the following informations-    \n\n* Highest available **odd** or **even** abundant number in that range\n* It's **abundance**    \n\nExamples\n--------\nA few examples never hurt nobody, right???    \n\n```rust   \nabundant(15)  = [[12], [4]]\nabundant(19)  = [[18], [3]]\nabundant(100) = [[100], [17]]\nabundant(999) = [[996], [360]]\n```\n\nTips\n----\nThe problem involves some pretty big random numbers. So try to optimize your code for performance as far as you can. And yes, the input argument will always be positive integers. So no need to check there.\n\nGood luck!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- 12 is smallest abundant number", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDivisors (n : Int) : Int :=\n  sorry\n\ndef abundant (n : Int) : Option (List (List Int)) :=\n  sorry", "vc-theorems": "theorem abundant_output_structure\n  (h : Int)\n  (h_ge : h ≥ 12)\n  (h_le : h ≤ 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result) :\n  result.length = 2 ∧\n  ∀ sublist ∈ result, sublist.length = 1 ∧\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x ≥ 0 :=\nsorry\n\ntheorem abundant_properties\n  (h : Int)\n  (h_ge : h ≥ 12)\n  (h_le : h ≤ 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result)\n  (n : Int := (result.get! 0).get! 0)\n  (diff : Int := (result.get! 1).get! 0) :\n  n ≤ h ∧\n  n > 0 ∧\n  sumOfDivisors n > n ∧\n  sumOfDivisors n - n = diff :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003933", "vc-description": "/-\nComplete the method which accepts an array of integers, and returns one of the following:\n\n* `\"yes, ascending\"` - if the numbers in the array are sorted in an ascending order\n* `\"yes, descending\"` - if the numbers in the array are sorted in a descending order\n* `\"no\"` - otherwise\n\nYou can assume the array will always be valid, and there will always be one correct answer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_sorted_and_how (arr : List Int) : String :=\nsorry\n\ndef isSorted (arr : List Int) : Bool :=\nsorry\n\ndef isSortedDesc (arr : List Int) : Bool :=\nsorry", "vc-theorems": "theorem sorted_properties (arr : List Int) (h : arr.length > 0) :\n  match is_sorted_and_how arr with\n  | \"yes, ascending\" => isSorted arr = true\n  | \"yes, descending\" => isSortedDesc arr = true\n  | _ => ¬(isSorted arr) ∧ ¬(isSortedDesc arr)\n  :=\nsorry\n\ntheorem result_is_valid (arr : List Int) (h : arr.length > 0) :\n  is_sorted_and_how arr = \"yes, ascending\" ∨\n  is_sorted_and_how arr = \"yes, descending\" ∨\n  is_sorted_and_how arr = \"no\"\n  :=\nsorry\n\ntheorem ascending_lists (arr : List Int) (h : arr.length > 0) (h2 : isSorted arr) :\n  is_sorted_and_how arr = \"yes, ascending\"\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'yes, ascending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [1, 2]\n\n/--\ninfo: 'yes, descending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [15, 7, 3, -8]\n\n/--\ninfo: 'no'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [4, 2, 30]"}
{"id": "fvapps_003934", "vc-description": "/-\nWrite a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.  For example:\n\n```python\n  sum_digits(10)  # Returns 1\n  sum_digits(99)  # Returns 18\n  sum_digits(-32) # Returns 5\n```\n\nLet's assume that all numbers in the input will be integer values.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_digits (n : Int) : Int :=\n  sorry\n\ndef sum_of_digits_string (n : Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_digits_nonnegative (x : Int) :\n  sum_digits x ≥ 0 :=\nsorry\n\ntheorem sum_digits_symmetric (x : Int) :\n  sum_digits x = sum_digits (-x) :=\nsorry\n\ntheorem sum_digits_less_than_input (x : Int) (h : x.natAbs > 9) :\n  sum_digits x < x.natAbs :=\nsorry\n\ntheorem sum_digits_single_digit (x : Int)\n  (h : 0 ≤ x.natAbs ∧ x.natAbs ≤ 9) :\n  sum_digits x = x.natAbs :=\nsorry\n\ntheorem sum_digits_matches_string_sum (x : Int) :\n  x ≥ 0 → sum_digits x = sum_of_digits_string x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_digits 10\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval sum_digits 99\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_digits -32"}
{"id": "fvapps_003937", "vc-description": "/-\nFind the greatest common divisor of two positive integers. The integers can be large, so you need to find a clever solution. \n\nThe inputs `x` and `y` are always greater or equal to 1, so the greatest common divisor will always be an integer that is also greater or equal to 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mygcd (x y : Int) : Int :=\n  sorry\n\ndef abs (x : Int) : Int :=\n  sorry", "vc-theorems": "theorem gcd_positive_integers {x y : Int} (hx : x > 0) (hy : y > 0) :\n  let g := mygcd x y\n  g > 0 ∧ x % g = 0 ∧ y % g = 0 :=\nsorry\n\ntheorem gcd_identity {x : Int} :\n  mygcd x x = x :=\nsorry\n\ntheorem gcd_associative {x y : Int} (hx : x > 0) (hy : y > 0) :\n  mygcd (x * y) x = x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval mygcd 1 3\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval mygcd 60 12\n\n/--\ninfo: 334\n-/\n#guard_msgs in\n#eval mygcd 2672 5678"}
{"id": "fvapps_003941", "vc-description": "/-\nA rectangle can be split up into a grid of 1x1 squares, the amount of which being equal to the product of the two dimensions of the rectangle. Depending on the size of the rectangle, that grid of 1x1 squares can also be split up into larger squares, for example a 3x2 rectangle has a total of 8 squares, as there are 6 distinct 1x1 squares, and two possible 2x2 squares. A 4x3 rectangle contains 20 squares.\nYour task is to write a function `findSquares` that returns the total number of squares for any given rectangle, the dimensions of which being given as two integers with the first always being equal to or greater than the second.\n-/\n\n-- Result should be non-negative\n\n-- For 0 dimensions, result should be 0\n\n-- Result should be x*y for 1xN rectangles\n\n-- For a square, result should be sum of squares from 1 to side length", "vc-preamble": "def sum_squares (n : Nat) : Nat :=\n  Nat.rec 0 (fun k res => res + k*k) n", "vc-helpers": "", "vc-definitions": "def findSquares (x y : Nat) : Nat :=\nsorry", "vc-theorems": "theorem findSquares_nonneg (x y : Nat) :\n  findSquares x y ≥ 0 :=\nsorry\n\ntheorem findSquares_zero (x y : Nat) :\n  x = 0 ∨ y = 0 → findSquares x y = 0 :=\nsorry\n\ntheorem findSquares_stripe (x y : Nat) :\n  y = 1 → findSquares x y = x :=\nsorry\n\ntheorem findSquares_square (n : Nat) :\n  findSquares n n = sum_squares n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval findSquares 3 2\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval findSquares 4 3\n\n/--\ninfo: 100\n-/\n#guard_msgs in\n#eval findSquares 11 4"}
{"id": "fvapps_003942", "vc-description": "/-\nIn English and programming, groups can be made using symbols such as `()` and `{}` that change meaning. However, these groups must be closed in the correct order to maintain correct syntax.\n\nYour job in this kata will be to make a program that checks a string for correct grouping. For instance, the following groups are done correctly:\n\n```\n({})\n[[]()]\n[{()}]\n```\n\nThe next are done incorrectly:\n```\n{(})\n([]\n[])\n```\n\nA correct string cannot close groups in the wrong order, open a group but fail to close it, or close a group before it is opened.\n\nYour function will take an input string that may contain any of the symbols `()`, `{}` or `[]` to create groups.\n\nIt should return `True` if the string is empty or otherwise grouped correctly, or `False` if it is grouped incorrectly.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def group_check (s : String) : Bool :=\nsorry\n\ndef isOpening (c : Char) : Bool :=\nsorry\n\ndef isClosing (c : Char) : Bool :=\nsorry\n\ndef matching (o c : Char) : Bool :=\nsorry\n\ndef countOpening (s : String) : Nat :=\nsorry\n\ndef countClosing (s : String) : Nat :=\nsorry", "vc-theorems": "theorem empty_string_valid :\n  group_check \"\" = true :=\nsorry\n\ntheorem simple_pair_valid (o c : Char) :\n  isOpening o → matching o c →\n  group_check (String.mk [o, c]) = true :=\nsorry\n\ntheorem valid_brackets_equal_counts {s : String} :\n  group_check s = true →\n  countOpening s = countClosing s :=\nsorry\n\ntheorem only_opening_invalid {s : String} :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, isOpening c) →\n  group_check s = false :=\nsorry\n\ntheorem only_closing_invalid {s : String} :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, isClosing c) →\n  group_check s = false :=\nsorry\n\ntheorem nested_brackets_valid {opens : List Char} :\n  opens ≠ [] →\n  (∀ c ∈ opens, isOpening c) →\n  let closes := (opens.map (λ o => match o with\n    | '(' => ')'\n    | '{' => '}'\n    | '[' => ']'\n    | _ => ' ')).reverse\n  group_check (String.mk (opens ++ closes)) = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"({})\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"[[]()]\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval group_check \"{(})\""}
{"id": "fvapps_003946", "vc-description": "/-\nHere's a way to construct a list containing every positive rational number:\n\nBuild a binary tree where each node is a rational and the root is `1/1`, with the following rules for creating the nodes below:\n* The value of the left-hand node below `a/b` is `a/a+b`\n* The value of the right-hand node below `a/b` is `a+b/b`\n\nSo the tree will look like this:\n\n```\n                       1/1\n                  /           \\ \n            1/2                  2/1\n           /    \\              /     \\\n       1/3        3/2        2/3       3/1\n      /   \\      /   \\      /   \\     /   \\\n   1/4    4/3  3/5   5/2  2/5   5/3  3/4   4/1\n\n ...\n```\n\nNow traverse the tree, breadth first, to get a list of rationals.\n\n```\n[ 1/1, 1/2, 2/1, 1/3, 3/2, 2/3, 3/1, 1/4, 4/3, 3/5, 5/2, .. ]\n```\n\nEvery positive rational will occur, in its reduced form, exactly once in the list, at a finite index.\n\n```if:haskell\nIn the kata, we will use tuples of type `(Integer, Integer)` to represent rationals, where `(a, b)` represents `a / b`\n```\n```if:javascript\nIn the kata, we will use tuples of type `[ Number, Number ]` to represent rationals, where `[a,b]` represents `a / b`\n```\n\nUsing this method you could create an infinite list of tuples:\n\nmatching the list described above:\n\nHowever, constructing the actual list is too slow for our purposes. Instead, study the tree above, and write two functions:\n\nFor example:\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gcd (x y : Nat) : Nat :=\nsorry\n\ndef rat_at (n : Nat) : Nat × Nat :=\nsorry\n\ndef index_of (a b : Nat) : Nat :=\nsorry", "vc-theorems": "def coprime (x y : Nat) : Prop :=\n  gcd x y = 1\n\ntheorem rat_at_index_inverse (n : Nat) :\n  let (a, b) := rat_at n\n  index_of a b = n :=\nsorry\n\ntheorem base_cases :\n  rat_at 0 = (1, 1) ∧\n  index_of 1 1 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval rat_at 0\n\n/--\ninfo: (1, 3)\n-/\n#guard_msgs in\n#eval rat_at 3\n\n/--\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval rat_at 4\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval index_of 1 1"}
{"id": "fvapps_003956", "vc-description": "/-\nGiven a string, return the minimal number of parenthesis reversals needed to make balanced parenthesis. \n\nFor example:\n```Javascript\nsolve(\")(\") = 2 Because we need to reverse \")\" to \"(\" and \"(\" to \")\". These are 2 reversals. \nsolve(\"(((())\") = 1 We need to reverse just one \"(\" parenthesis to make it balanced.\nsolve(\"(((\") = -1 Not possible to form balanced parenthesis. Return -1.\n```\n\nParenthesis will be either `\"(\"` or `\")\"`. \n\nMore examples in the test cases. \n\nGood luck.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Int :=\n  sorry\n\ndef isBalanced (s : String) : Bool :=\n  sorry\n\ndef repeated_parens (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem solve_odd_length_returns_minus_one {s : String} :\n  (s.length % 2 = 1) → solve s = -1 :=\nsorry\n\ntheorem solve_valid_solution_bound {s : String} :\n  solve s ≥ 0 → solve s ≤ s.length :=\nsorry\n\ntheorem solve_empty_string :\n  solve \"\" = 0 :=\nsorry\n\ntheorem solve_single_paren_left :\n  solve \"(\" = -1 :=\nsorry\n\ntheorem solve_single_paren_right :\n  solve \")\" = -1 :=\nsorry\n\ntheorem solve_reversed_pair :\n  solve \")(\" = 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \")(\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"(((())\"\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve \"(((\""}
{"id": "fvapps_003957", "vc-description": "/-\n[Langton's ant](https://en.wikipedia.org/wiki/Langton%27s_ant) is a two-dimensional Turing machine invented in the late 1980s. The ant starts out on a grid of black and white cells and follows a simple set of rules that has complex emergent behavior.\n\n## Task\n\nComplete the function and return the `n`th iteration of Langton's ant with the given input.\n\n### Parameters:\n\n* `grid` - a two dimensional array of `1`s and `0`s (representing white and black cells respectively)\n* `column` - horizontal position of ant\n* `row` - ant's vertical position\n* `n` - number of iterations\n* `dir` - ant's current direction (0 - north, 1 - east, 2 - south, 3 - west), **should default to 0**\n\n**Note:** parameters `column` and `row` will always be inside the `grid`, and number of generations `n` will never be negative.\n\n## Output\n\nThe state of the `grid` after `n` iterations.\n\n## Rules\n\nThe ant can travel in any of the four cardinal directions at each step it takes. The ant moves according to the rules below:\n\n* At a white square (represented with `1`), turn 90° right, flip the color of the square, and move forward one unit.\n* At a black square (`0`), turn 90° left, flip the color of the square, and move forward one unit.\n\nThe grid has no limits and therefore if the ant moves outside the borders, the grid should be expanded with `0`s, respectively maintaining the rectangle shape.\n\n## Example\n\n```python\nant([[1]], 0, 0, 1, 0)   # should return: [[0, 0]]\n```\n\nInitially facing north (`0`), at the first iteration the ant turns right (because it stands on a white square, `1`), flips the square and moves forward.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def BLACK : Int := 1\n\ndef WHITE : Int := 0", "vc-helpers": "", "vc-definitions": "def ant (grid : List (List Int)) (col : Int) (row : Int) (steps : Int)\n  (direction : Int := 0) : List (List Int) :=\nsorry", "vc-theorems": "theorem ant_result_rectangular {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3)\n  (h6: grid.length > 0) (h7 : ∀ r ∈ grid, r.length = grid.head!.length) :\n  let result := ant grid col row steps dir\n  ∀ r ∈ result, r.length = result.head!.length :=\nsorry\n\ntheorem ant_result_valid_colors {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  ∀ r ∈ result, ∀ cell ∈ r, cell = BLACK ∨ cell = WHITE :=\nsorry\n\ntheorem ant_result_size {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  result.length ≥ grid.length ∧ result.head!.length ≥ grid.head!.length :=\nsorry\n\ntheorem ant_preserves_input {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) (h3: 0 ≤ steps) (h4: 0 ≤ dir) (h5: dir ≤ 3) :\n  let result := ant grid col row steps dir\n  grid = grid :=\nsorry\n\ntheorem ant_zero_steps {grid : List (List Int)} {col row : Int}\n  (h1: 0 ≤ col) (h2: 0 ≤ row) :\n  ant grid col row 0 = grid :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003959", "vc-description": "/-\nWrite a function named `repeater()` that takes two arguments (a string and a number), and returns a new string where the input string is repeated that many times.\n\n## Example:\n\nshould return\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For any non-empty repeater output, we can verify it consists of the original string repeated -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def repeater (s : String) (n : Nat) : String :=\nsorry", "vc-theorems": "theorem repeater_length (s : String) (n : Nat) :\n  (repeater s n).length = s.length * n :=\nsorry\n\ntheorem repeater_eq_concat (s : String) (n : Nat) :\n  repeater s n = String.join (List.replicate n s) :=\nsorry\n\ntheorem repeater_validity (s : String) (n : Nat) (h : n > 0) :\n  ∀ k : Nat, k < n → String.isPrefixOf s (repeater s n) :=\nsorry\n\ntheorem repeater_zero (s : String) :\n  repeater s 0 = \"\" :=\nsorry\n\ntheorem repeater_one (s : String) :\n  repeater s 1 = s :=\nsorry", "vc-postamble": "/--\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval repeater \"a\" 5\n\n/--\ninfo: 'NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNa'\n-/\n#guard_msgs in\n#eval repeater \"Na\" 16\n\n/--\ninfo: 'Wub Wub Wub Wub Wub Wub '\n-/\n#guard_msgs in\n#eval repeater \"Wub \" 6"}
{"id": "fvapps_003962", "vc-description": "/-\n# Introduction and Warm-up (Highly recommended)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n___\n\n# Task\n\n**_Given_** an **_array of integers_** , **_Find the minimum sum_** which is obtained *from summing each Two integers product* .\n___\n\n# Notes \n\n* **_Array/list_** *will contain* **_positives only_** . \n* **_Array/list_** *will always has* **_even size_**\n___\n\n# Input >> Output Examples\n\n```\nminSum({5,4,2,3}) ==> return (22) \n```\n\n## **_Explanation_**:\n\n* **_The minimum sum_** *obtained from summing each two integers product* ,  ` 5*2 + 3*4 = 22`\n___\n\n```\nminSum({12,6,10,26,3,24}) ==> return (342)\n```\n\n## **_Explanation_**:\n\n* **_The minimum sum_** *obtained from summing each two integers product* ,  ` 26*3 + 24*6 + 12*10 = 342`\n\n___\n\n```\nminSum({9,2,8,7,5,4,0,6}) ==> return (74)\n```\n\n## **_Explanation_**:\n\n* **_The minimum sum_** *obtained from summing each two integers product* ,  ` 9*0 + 8*2 +7*4 +6*5 = 74`\n\n___\n\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def sum : List Nat → Nat\n| [] => 0\n| (x::xs) => x + sum xs\n\ndef maxList : List Nat → Nat\n| [] => 0\n| [x] => x\n| (x::xs) => max x (maxList xs)\n\ndef zipWith (f : Nat → Nat → Nat) : List Nat → List Nat → List Nat\n| [], _ => []\n| _, [] => []\n| (x::xs), (y::ys) => f x y :: zipWith f xs ys\n\ndef pairwiseProduct (nums : List Nat) : Nat :=\n  let n := nums.length\n  let firstHalf := nums.take (n/2)\n  let secondHalf := (nums.drop (n/2)).reverse\n  sum (zipWith (fun x y => x * y) firstHalf secondHalf)", "vc-helpers": "", "vc-definitions": "def min_sum (nums : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_sum_non_negative (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≥ 0 :=\nsorry\n\ntheorem min_sum_upper_bound (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≤ sum nums * maxList nums :=\nsorry\n\ntheorem min_sum_reverse_invariant (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums = min_sum nums.reverse :=\nsorry\n\ntheorem min_sum_permutation_invariant (nums₁ nums₂ : List Nat)\n  (h1 : nums₁.length ≥ 2)\n  (h2 : nums₁.length % 2 = 0)\n  (h3 : nums₁.length = nums₂.length)\n  (h4 : ∀ x, nums₁.count x = nums₂.count x) :\n  min_sum nums₁ = min_sum nums₂ :=\nsorry\n\ntheorem min_sum_minimality (nums : List Nat)\n  (h : nums.length ≥ 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums ≤ pairwiseProduct nums :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_003967", "vc-description": "/-\nAs most of you might know already, a prime number is an integer `n` with the following properties:\n\n* it must be greater than 1\n* it must be divisible only by itself and 1\n\nAnd that's it: -15 or 8 are not primes, 5 or 97 are; pretty easy, isn't it?\n\nWell, turns out that primes are not just a mere mathematical curiosity and are very important, for example, to allow a lot of cryptographic algorithms.\n\nBeing able to tell if a number is a prime or not is thus not such a trivial matter and doing it with some efficient algo is thus crucial.\n\nThere are already more or less efficient (or sloppy) katas asking you to find primes, but here I try to be even more zealous than other authors.\n\nYou will be given a preset array/list with the first few `primes`. And you must write a function that checks if a given number `n` is a prime looping through it and, possibly, expanding the array/list of known primes only if/when necessary (ie: as soon as you check for a **potential prime which is greater than a given threshold for each** `n`, stop).\n\n#  Memoization\n\nStoring precomputed results for later re-use is a very popular programming technique that you would better master soon and that is called [memoization](https://en.wikipedia.org/wiki/Memoization); while you have your wiki open, you might also wish to get some info about the [sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) (one of the few good things I learnt as extra-curricular activity in middle grade) and, to be even more efficient, you might wish to consider [an interesting reading on searching from prime from a friend of mine](https://medium.com/@lcthornhill/why-does-the-6-iteration-method-work-for-testing-prime-numbers-ba6176f58082#.dppj0il3a) [she thought about an explanation all on her own after an evening event in which I discussed primality tests with my guys].\n\nYes, you will be checked even on that part. And you better be **very** efficient in your code if you hope to pass all the tests ;)\n\n**Dedicated to my trainees that worked hard to improve their skills even on a holiday: good work guys!**\n\n**Or should I say \"girls\" ;)? [Agata](https://www.codewars.com/users/aghh1504), [Ania](https://www.codewars.com/users/lisowska) [Dina](https://www.codewars.com/users/deedeeh) and (although definitely not one of my trainees) special mention to [NaN](https://www.codewars.com/users/nbeck)**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime : Nat → Bool :=\nsorry\n\ndef factorial (n : Nat) : Nat :=\nsorry\n\ndef factors_up_to (n : Nat) (k : Nat) : Bool :=\nsorry", "vc-theorems": "theorem not_prime_if_less_than_2 (n : Nat) (h : n ≤ 1) : ¬(is_prime n = true) :=\nsorry\n\ntheorem prime_iff_no_factors (n : Nat) (h : n ≥ 2) :\n  is_prime n = true ↔ ¬(factors_up_to n (n/2) = true) :=\nsorry\n\ntheorem wilson_prime_property (n : Nat) (h1 : n ≥ 2) (h2 : n ≤ 20) :\n  is_prime n = true → (factorial (n-1) + 1) % n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 2\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 29\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_prime 143"}
{"id": "fvapps_003971", "vc-description": "/-\nYou will be given two ASCII strings, `a` and `b`. Your task is write a function to determine which one of these strings is \"worth\" more, and return it.\n\nA string's worth is determined by the sum of its ASCII codepoint indexes. So, for example, the string `HELLO` has a value of 372: H is codepoint 72, E 69, L 76, and O is 79. The sum of these values is 372.\n\nIn the event of a tie, you should return the first string, i.e. `a`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.sumAscii (s : String) : Nat :=\nsorry\n\ndef highest_value (a b : String) : String :=\nsorry", "vc-theorems": "theorem highest_value_is_input (a b : String) :\n  let result := highest_value a b\n  result = a ∨ result = b :=\nsorry\n\ntheorem highest_value_maximizes_sum (a b : String) :\n  let result := highest_value a b\n  String.sumAscii result ≥ String.sumAscii (if result = a then b else a) :=\nsorry\n\ntheorem highest_value_equal_sums (a b : String) :\n  String.sumAscii a = String.sumAscii b →\n  highest_value a b = a :=\nsorry\n\ntheorem highest_value_identical (s : String) :\n  highest_value s s = s :=\nsorry\n\ntheorem highest_value_nonempty (a b : String) :\n  a.length > 0 →\n  b.length > 0 →\n  (highest_value a b).length > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'KkLlMmNnOoPp4567'\n-/\n#guard_msgs in\n#eval highest_value \"AaBbCcXxYyZz0189\" \"KkLlMmNnOoPp4567\"\n\n/--\ninfo: 'ABcd'\n-/\n#guard_msgs in\n#eval highest_value \"ABcd\" \"0123\"\n\n/--\ninfo: \"{}[]@~'#:;\"\n-/\n#guard_msgs in\n#eval highest_value \"!\"?$%^&*()\" \"{}[]@~\"#:;\""}
{"id": "fvapps_003974", "vc-description": "/-\n# Task\n Given an array `arr` and a number `n`. Call a pair of numbers from the array a `Perfect Pair` if their sum is equal to `n`.\n\n Find all of the perfect pairs and return the sum of their **indices**. \n\n Note that any element of the array can only be counted in one Perfect Pair. Also if there are multiple correct answers, return the smallest one.\n\n# Example\n\n For `arr = [1, 4, 2, 3, 0, 5] and n = 7`, the result should be `11`.\n\n Since the Perfect Pairs are `(4, 3)` and `(2, 5)` with indices `1 + 3 + 2 + 5 = 11`.\n\n For `arr = [1, 3, 2, 4] and n = 4`, the result should be `1`.\n\n Since the element at `index 0` (i.e. 1) and the element at `index 1` (i.e. 3) form the only Perfect Pair.\n\n# Input/Output\n\n - `[input]` integer array `arr`\n\n  array of non-negative integers.\n\n - `[input]` integer `n`\n\n  positive integer\n\n - `[output]` integer\n\n  sum of indices and 0 if no Perfect Pair exists.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pairwise_pairs : List Int → Int → List (Int × Int)\n| xs, n =>\nsorry\n\ndef pairwise : List Int → Int → Int\n| xs, n =>\nsorry", "vc-theorems": "theorem pairwise_nonnegative {arr : List Int} {n : Int} :\n  pairwise arr n ≥ 0 := by\nsorry\n\ntheorem pairwise_less_than_triangular {arr : List Int} {n : Int} :\n  let max_triangular := (arr.length * (arr.length - 1)) / 2\n  pairwise arr n ≤ max_triangular := by\nsorry\n\ntheorem pairwise_indices_sum_correctly {arr : List Int} {n : Int} :\n  let used_indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.foldr (· + ·) 0 used_indices = pairwise arr n := by\nsorry\n\ntheorem pairwise_indices_unique {arr : List Int} {n : Int} :\n  let indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.Nodup indices := by\nsorry\n\ntheorem pairwise_empty_zero {n : Int} :\n  pairwise [] n = 0 := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_003975", "vc-description": "/-\nThe number ```1331``` is the first positive perfect cube,  higher than ```1```, having all its digits odd (its cubic root is ```11```).\n\nThe next one is ```3375```.\n\nIn the interval [-5000, 5000] there are six pure odd digit perfect cubic numbers and are: ```[-3375,-1331, -1, 1, 1331, 3375]```\n\nGive the numbers of this sequence that are in the range ```[a,b] ```(both values inclusive)\n\nExamples:\n``` python\nodd_dig_cubic(-5000, 5000) == [-3375,-1331, -1, 1, 1331, 3375] # the output should be sorted.\nodd_dig_cubic(0, 5000) == [1, 1331, 3375]\nodd_dig_cubic(-1, 5000) == [-1, 1, 1331, 3375]\nodd_dig_cubic(-5000, -2) == [-3375,-1331]\n\n```\nFeatures of the random tests for python:\n```\nnumber of Tests = 94\nminimum value for a = -1e17\nmaximum value for b = 1e17\n```\nYou do not have to check the entries, ```a``` and ```b``` always integers and ```a < b``` \n\nWorking well in Python 2 and Python 3.\nTranslation into Ruby is coming soon.\n-/\n\n-- Helper function to check if a number's digits are all odd\n\n-- Helper function to check if a number is a perfect cube", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def odd_dig_cubic (a b : Int) : List Int :=\n  sorry\n\ndef hasAllOddDigits (n : Int) : Bool :=\n  sorry\n\ndef isPerfectCube (n : Int) : Bool :=\n  sorry", "vc-theorems": "theorem odd_dig_cubic_sorted (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ i, i + 1 < result.length → result[i]! ≤ result[i+1]! :=\nsorry\n\ntheorem odd_dig_cubic_all_cubes (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, isPerfectCube n :=\nsorry\n\ntheorem odd_dig_cubic_all_odd_digits (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, hasAllOddDigits n :=\nsorry\n\ntheorem odd_dig_cubic_in_range (a b : Int) :\n  let result := odd_dig_cubic a b\n  ∀ n ∈ result, min a b ≤ n ∧ n ≤ max a b :=\nsorry\n\ntheorem odd_dig_cubic_zero : odd_dig_cubic 0 0 = [] :=\nsorry\n\ntheorem odd_dig_cubic_one : odd_dig_cubic 1 1 = [1] :=\nsorry\n\ntheorem odd_dig_cubic_neg_one : odd_dig_cubic (-1) (-1) = [-1] :=\nsorry\n\ntheorem odd_dig_cubic_single_point (n : Int) :\n  let result := odd_dig_cubic n n\n  result ≠ [] → result.length = 1 ∧ result[0]! = n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [-3375, -1331, -1, 1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 5000\n\n/--\ninfo: [1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic 0 5000\n\n/--\ninfo: [-3375, -1331]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 -2"}
{"id": "fvapps_003979", "vc-description": "/-\n### What is simplifying a square root?\n\nIf you have a number, like 80, for example, you would start by finding the greatest perfect square divisible by 80. In this case, that's 16. Find the square root of 16, and multiply it by 80 / 16. Answer = 4 √5. \n\n##### The above example:\n\n![simplify_roots_example.png](https://i.postimg.cc/gjv2NwCm/simplify-roots-example.png)\n\n### Task:\n\nYour job is to write two functions, `simplify`, and `desimplify`, that simplify and desimplify square roots, respectively. (Desimplify isn't a word, but I couldn't come up with a better way to put it.) `simplify` will take an integer and return a string like \"x sqrt y\", and `desimplify` will take a string like \"x sqrt y\" and return an integer. For `simplify`, if a square root cannot be simplified, return \"sqrt y\". \n\n_Do not modify the input._\n\n### Some examples:\n\n```python\nsimplify(1)  #=> \"1\"\nsimplify(2)  #=> \"sqrt 2\"\nsimplify(3)  #=> \"sqrt 3\"\nsimplify(8)  #=> \"2 sqrt 2\"\nsimplify(15) #=> \"sqrt 15\"\nsimplify(16) #=> \"4\"\nsimplify(18) #=> \"3 sqrt 2\"\nsimplify(20) #=> \"2 sqrt 5\"\nsimplify(24) #=> \"2 sqrt 6\"\nsimplify(32) #=> \"4 sqrt 2\"\n\ndesimplify(\"1\")        #=> 1\ndesimplify(\"sqrt 2\")   #=> 2\ndesimplify(\"sqrt 3\")   #=> 3\ndesimplify(\"2 sqrt 2\") #=> 8\ndesimplify(\"sqrt 15\")  #=> 15\ndesimplify(\"4\")        #=> 16\ndesimplify(\"3 sqrt 2\") #=> 18\ndesimplify(\"2 sqrt 5\") #=> 20\ndesimplify(\"2 sqrt 6\") #=> 24\ndesimplify(\"4 sqrt 2\") #=> 32\n```\n\nAlso check out my other creations — [Square Roots: Approximation](https://www.codewars.com/kata/square-roots-approximation), [Square and Cubic Factors](https://www.codewars.com/kata/square-and-cubic-factors), [Keep the Order](https://www.codewars.com/kata/keep-the-order), [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n-/\n\n/- Desimplifying a simplified number returns the original number -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- A simplified expression contains at most one sqrt -/\n\n/- A simplified expression with no sqrt is a single number -/\n\n/- A simplified expression with sqrt is in format \"a sqrt b\" or \"sqrt b\" -/\n\n/- Desimplifying returns a positive integer -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def simplify (n : Nat) : String :=\nsorry\n\ndef desimplify (s : String) : Nat :=\nsorry\n\ndef containsSqrt (s : String) : Bool :=\nsorry\n\ndef countSqrt (s : String) : Nat :=\nsorry\n\ndef isNumeric (s : String) : Bool :=\nsorry\n\ndef splitByWhitespace (s : String) : List String :=\nsorry", "vc-theorems": "theorem simplify_desimplify_roundtrip (n : Nat) (h : n > 0) :\n  desimplify (simplify n) = n :=\nsorry\n\ntheorem simplify_sqrt_count (n : Nat) (h : n > 0) :\n  countSqrt (simplify n) ≤ 1 :=\nsorry\n\ntheorem simplify_no_sqrt (n : Nat) (h : n > 0) :\n  ¬containsSqrt (simplify n) → isNumeric (simplify n).trim :=\nsorry\n\ntheorem simplify_with_sqrt (n : Nat) (h : n > 0) :\n  let s := simplify n\n  let parts := splitByWhitespace s\n  containsSqrt s →\n    (parts.length = 2 ∧ parts.get! 0 = \"sqrt\" ∧ isNumeric (parts.get! 1)) ∨\n    (parts.length = 3 ∧ isNumeric (parts.get! 0) ∧ parts.get! 1 = \"sqrt\" ∧ isNumeric (parts.get! 2)) :=\nsorry\n\ntheorem desimplify_range (n : Nat) (h : n > 0) :\n  desimplify (simplify n) > 0 :=\nsorry", "vc-postamble": "/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval simplify 1\n\n/--\ninfo: '2 sqrt 2'\n-/\n#guard_msgs in\n#eval simplify 8\n\n/--\ninfo: '2 sqrt 5'\n-/\n#guard_msgs in\n#eval simplify 20\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval desimplify \"1\"\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 2\"\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 5\""}
{"id": "fvapps_003982", "vc-description": "/-\nAn Arithmetic Progression is defined as one in which there is a constant difference between the consecutive terms of a given series of numbers. You are provided with consecutive elements of an Arithmetic Progression. There is however one hitch: exactly one term from the original series is missing from the set of numbers which have been given to you. The rest of the given series is the same as the original AP.  Find the missing term.  \n\nYou have to write a function that receives a list, list size will always be at least 3 numbers. The missing term will never be the first or last one.\n\n## Example\n```python\nfind_missing([1, 3, 5, 9, 11]) == 7\n```\n\nPS: This is a sample question of the facebook engineer challenge on interviewstreet.\nI found it quite fun to solve on paper using math, derive the algo that way.\nHave fun!\n-/", "vc-preamble": "def list_range_int (n : Nat) : List Int :=\n  (List.range n).map Int.ofNat", "vc-helpers": "", "vc-definitions": "def find_missing (seq : List Int) : Int :=\n  sorry\n\ndef is_arithmetic_seq (seq : List Int) : Bool :=\nsorry", "vc-theorems": "theorem find_missing_complete_sequence\n  (start step : Int)\n  (length : Nat)\n  (h1 : length ≥ 3)\n  (h2 : length ≤ 10)\n  (h3 : -100 ≤ start)\n  (h4 : start ≤ 100)\n  (h5 : 1 ≤ step)\n  (h6 : step ≤ 20) :\n  let full_seq := (list_range_int length).map (fun i => start + i * step)\n  let i := length / 2\n  let seq_with_missing := (full_seq.take i) ++ (full_seq.drop (i+1))\n  find_missing seq_with_missing = (full_seq.get! i) :=\nsorry\n\ntheorem find_missing_existing_arithmetic\n  {seq : List Int}\n  (h1 : seq.length ≥ 3)\n  (h2 : seq.length ≤ 20)\n  (h3 : is_arithmetic_seq seq = true) :\n  let diff := seq.get! 1 - seq.get! 0\n  ∃ i, i < seq.length - 1 ∧\n       seq.get! (i+1) - seq.get! i ≠ diff →\n       find_missing seq = seq.get! i + diff :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_missing [1, 2, 3, 4, 6, 7, 8, 9]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 5, 9, 11]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 4]"}
{"id": "fvapps_004001", "vc-description": "/-\nA triangle is called an equable triangle if its area equals its perimeter. Return `true`, if it is an equable triangle, else return `false`. You will be provided with the length of sides of the triangle. Happy Coding!\n-/", "vc-preamble": "def isValidTriangle (a b c : Float) : Prop :=\n  (a + b > c) ∧ (b + c > a) ∧ (a + c > b)\n\ndef calculateArea (a b c : Float) : Float :=\n  let s := (a + b + c) / 2\n  Float.sqrt (s * (s - a) * (s - b) * (s - c))", "vc-helpers": "", "vc-definitions": "def equableTriangle (a b c : Float) : Bool :=\n  sorry\n\ndef isClose (x y : Float) (tol : Float) : Bool :=\n  sorry", "vc-theorems": "theorem equable_triangle_isosceles {x : Float} (h : x > 0)\n  (hvalid : isValidTriangle x x x) :\n  equableTriangle x x x = isClose (calculateArea x x x) (3 * x) 0.0001 := by\n  sorry\n\ntheorem equable_triangle_general {a b c : Float} (ha : a > 0) (hb : b > 0) (hc : c > 0)\n  (hvalid : isValidTriangle a b c) :\n  equableTriangle a b c = isClose (calculateArea a b c) (a + b + c) 0.0001 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 5 12 13\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval equable_triangle 2 3 4\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 6 25 29"}
{"id": "fvapps_004007", "vc-description": "/-\n# The museum of incredible dull things\n\nThe museum of incredible dull things wants to get rid of some exhibitions. Miriam, the interior architect, comes up with a plan to remove the most boring exhibitions. She gives them a rating, and then removes the one with the lowest rating.\n\nHowever, just as she finished rating all exhibitions, she's off to an important fair, so she asks you to write a program that tells her the ratings of the items after one removed the lowest one. Fair enough.\n\n# Task\n\nGiven an array of integers, remove the smallest value. **Do not mutate the original array/list**. If there are multiple elements with the same value, remove the one with a lower index. If you get an empty array/list, return an empty array/list.\n\nDon't change the order of the elements that are left.\n\n### Examples\n\n```python\nremove_smallest([1,2,3,4,5]) = [2,3,4,5]\nremove_smallest([5,3,2,1,4]) = [5,3,2,4]\nremove_smallest([2,2,1,2,1]) = [2,2,2,1]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_smallest (list : List Int) : List Int :=\n  sorry\n\ndef minimum (list : List Int) : Option Int :=\n  sorry\n\ndef list_eq (l1 l2 : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem remove_smallest_length (list : List Int) :\n  list = [] → remove_smallest list = [] ∧\n  list ≠ [] → List.length (remove_smallest list) = List.length list - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [2, 3, 4, 5]\n-/\n#guard_msgs in\n#eval remove_smallest [1, 2, 3, 4, 5]\n\n/--\ninfo: [2, 2, 2, 1]\n-/\n#guard_msgs in\n#eval remove_smallest [2, 2, 1, 2, 1]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval remove_smallest []"}
{"id": "fvapps_004008", "vc-description": "/-\nYour program will receive an array of complex numbers represented as strings. Your task is to write the  `complexSum` function which have to return the sum as a string.\n\nComplex numbers can be written in the form of `a+bi`, such as `2-3i` where `2` is the real part, `3` is the imaginary part, and `i` is the \"imaginary unit\". \n\nWhen you add two complex numbers, the real and the imaginary part needs to be added separately,so for example `2+3i + 5-i = (2+5)+(3i-i) = 7+2i`\n\nBoth the complex and the imaginary part can be 0, so `123`, `-2i` or `i` are also complex numbers.\n\nComplex numbers must be returned in their shortest form, so e.g. `0+1*i` should be just `i`, and `10+0i` should be `10`. This is also how you will get them!\n\nFor simplicity, the coefficients will always be integers. If the array is empty, return `0`.\n\nHave fun! :)\n-/\n\n-- Sum of complex numbers is equal to sum of separate numbers\n\n-- Sum of pure imaginary numbers has no real part\n\n-- Empty list sums to zero\n\n-- List of zeros sums to zero", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def complex_sum (arr : List String) : String :=\nsorry\n\ndef complex_str (real imag : Int) : String :=\nsorry\n\ndef real_part (s : String) : Int :=\nsorry\n\ndef imag_part (s : String) : Int :=\nsorry\n\ndef list_sum (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem complex_sum_equals_separate_sums {arr : List String} :\n  ∀ (real_sum imag_sum : Int),\n  complex_sum arr = complex_str real_sum imag_sum →\n  real_sum = list_sum (arr.map real_part) ∧\n  imag_sum = list_sum (arr.map imag_part) :=\nsorry\n\ntheorem pure_imaginary_sum {arr : List String} :\n  arr.all (λ s => s = \"i\") →\n  complex_sum arr = complex_str 0 arr.length :=\nsorry\n\ntheorem empty_list_sums_to_zero :\n  complex_sum [] = \"0\" :=\nsorry\n\ntheorem zeros_sum_to_zero {arr : List String} :\n  arr.all (λ s => s = \"0\") →\n  complex_sum arr = \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '5+2i'\n-/\n#guard_msgs in\n#eval complex_sum [\"2+3i\", \"3-i\"]\n\n/--\ninfo: '6i'\n-/\n#guard_msgs in\n#eval complex_sum [\"i\", \"2i\", \"3i\"]\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval complex_sum []"}
{"id": "fvapps_004010", "vc-description": "/-\nVariation of this nice kata, the war has expanded and become dirtier and meaner; both even and odd numbers will fight with their pointy `1`s. And negative integers are coming into play as well, with, ça va sans dire, a negative contribution (think of them as spies or saboteurs).\n\nAgain, three possible outcomes: `odds win`, `evens win` and `tie`.\n\nExamples:\n\n```python\nbits_war([1,5,12]) => \"odds win\" #1+101 vs 1100, 3 vs 2\nbits_war([7,-3,20]) => \"evens win\" #111-11 vs 10100, 3-2 vs 2\nbits_war([7,-3,-2,6]) => \"tie\" #111-11 vs -1+110, 3-2 vs -1+2\n```\n-/", "vc-preamble": "def sum_list_nat : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + sum_list_nat xs", "vc-helpers": "", "vc-definitions": "def bits_war (numbers : List Int) : String :=\nsorry\n\ndef bitsToCount (n : Int) : Nat :=\nsorry", "vc-theorems": "theorem bits_war_returns_valid_result (numbers : List Int) (h : numbers.length > 0) :\n  (bits_war numbers = \"odds win\") ∨\n  (bits_war numbers = \"evens win\") ∨\n  (bits_war numbers = \"tie\") :=\nsorry\n\ntheorem bits_war_all_zeros (numbers : List Int) :\n  (∀ n ∈ numbers, n = 0) →\n  bits_war numbers = \"tie\" :=\nsorry\n\ntheorem bits_war_all_positive (numbers : List Int) (h : numbers.length > 0) :\n  (∀ n ∈ numbers, n ≥ 0) →\n  let odd_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 1)).map bitsToCount)\n  let even_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 0)).map bitsToCount)\n  bits_war numbers = if odd_bits > even_bits then \"odds win\"\n                     else if even_bits > odd_bits then \"evens win\"\n                     else \"tie\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'odds win'\n-/\n#guard_msgs in\n#eval bits_war [1, 5, 12]\n\n/--\ninfo: 'evens win'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, 20]\n\n/--\ninfo: 'tie'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, -2, 6]"}
{"id": "fvapps_004011", "vc-description": "/-\n# Task\n Given a string `str`, reverse it omitting all non-alphabetic characters.\n\n# Example\n\n For `str = \"krishan\"`, the output should be `\"nahsirk\"`.\n\n For `str = \"ultr53o?n\"`, the output should be `\"nortlu\"`.\n\n# Input/Output\n\n - `[input]` string `str`\n\n  A string consists of lowercase latin letters, digits and symbols.\n\n - `[output]` a string\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (c : Char) : Bool :=\n  sorry\n\ndef reverse_letter (s : String) : String :=\n  sorry", "vc-theorems": "theorem reverse_letter_only_letters (s : String) :\n  ∀ (c : Char), c ∈ (reverse_letter s).data → isAlpha c := by\n  sorry\n\ntheorem reverse_letter_length (s : String) :\n  (reverse_letter s).length = (s.toList.filter isAlpha).length := by\n  sorry\n\ntheorem reverse_letter_idempotent (s : String) :\n  reverse_letter (reverse_letter s) = String.mk (s.toList.filter isAlpha) := by\n  sorry\n\ntheorem reverse_letter_preserves_case (s : String) :\n  ∃ (perm : List Char → List Char),\n    (reverse_letter s).data.map Char.toLower =\n    (String.mk (s.toList.filter isAlpha)).data.map Char.toLower := by\n  sorry\n\ntheorem reverse_letter_empty_no_letters (s : String) :\n  (∀ c ∈ s.data, ¬isAlpha c) →\n  reverse_letter s = \"\" := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_004013", "vc-description": "/-\nGoldbach's conjecture is one of the oldest and best-known unsolved problems in number theory and all of mathematics. It states:\n\nEvery even integer greater than 2 can be expressed as the sum of two primes.\nFor example: \n\n`6 = 3 + 3`\n`8 = 3 + 5`\n`10 = 3 + 7 = 5 + 5`\n`12 = 5 + 7`\n\nSome rules for the conjecture: \n\n- pairs should be descending like [3,5] not [5,3]\n\n- all pairs should be in ascending order based on the first element of the pair: \n`[[5, 13], [7, 11]]` is accepted \nbut `[[7, 11],[5, 13]]` is not accepted.\n\nWrite the a function that find all identical pairs of prime numbers:\n```python\ndef goldbach(even_number)\n```\nYou should return an array of containing pairs of primes, like:\n```python\n[[5, 13], [7, 11]]  # even_number = 18\n```\nor\n```python\n[[3, 31], [5, 29], [11, 23], [17, 17]] # even_number = 34\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPrime (n : Nat) : Bool :=\n  sorry\n\ndef goldbach (n : Nat) : List (List Nat) :=\n  sorry", "vc-theorems": "theorem goldbach_valid_sums {n : Nat} (h : n ≥ 4) (h2 : n % 2 = 0) :\n  let result := goldbach n\n  (∀ x ∈ result, x.length = 2) ∧\n  (∀ x ∈ result, x[0]! + x[1]! = n) ∧\n  (∀ x ∈ result, x[0]! ≤ x[1]!) :=\nsorry\n\ntheorem goldbach_small_inputs {n : Nat} (h : n ≤ 3) :\n  goldbach n = [] :=\nsorry\n\ntheorem goldbach_four :\n  goldbach 4 = [[2, 2]] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [[3, 7], [5, 5]]\n-/\n#guard_msgs in\n#eval goldbach 10\n\n/--\ninfo: [[5, 47], [11, 41], [23, 29]]\n-/\n#guard_msgs in\n#eval goldbach 52\n\n/--\ninfo: [[5, 53], [11, 47], [17, 41], [29, 29]]\n-/\n#guard_msgs in\n#eval goldbach 58"}
{"id": "fvapps_004017", "vc-description": "/-\nI assume most of you are familiar with the ancient legend of the rice (but I see wikipedia suggests [wheat](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem), for some reason) problem, but a quick recap for you: a young man asks as a compensation only `1` grain of rice for the first square, `2` grains for the second, `4` for the third, `8` for the fourth and so on, always doubling the previous.\n\nYour task is pretty straightforward (but not necessarily easy): given an amount of grains, you need to return up to which square of the chessboard one should count in order to get at least as many.\n\nAs usual, a few examples might be way better than thousands of words from me:\n\n```python\nsquares_needed(0) == 0\nsquares_needed(1) == 1\nsquares_needed(2) == 2\nsquares_needed(3) == 2\nsquares_needed(4) == 3\n```\n\nInput is always going to be valid/reasonable: ie: a non negative number; extra cookie for *not* using a loop to compute square-by-square (at least not directly) and instead trying a smarter approach [hint: some peculiar operator]; a trick converting the number might also work: impress me!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (f: Nat → Nat) (n: Nat) : Nat :=\n  sorry\n\ndef squares_needed (n: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem squares_needed_zero :\n  squares_needed 0 = 0 :=\nsorry\n\ntheorem squares_needed_one :\n  squares_needed 1 = 1 :=\nsorry\n\ntheorem squares_needed_power_two :\n  squares_needed (2^10) = 11 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval squares_needed 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval squares_needed 1\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 3\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval squares_needed 4"}
{"id": "fvapps_004021", "vc-description": "/-\nWrite function avg which calculates average of numbers in given list.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_average (numbers : List Float) : Float :=\nsorry\n\ndef sum (l : List Float) : Float :=\nsorry\n\ndef minimum? (l : List Float) : Option Float :=\nsorry\n\ndef maximum? (l : List Float) : Option Float :=\nsorry\n\ndef sumInt (l : List Int) : Int :=\nsorry", "vc-theorems": "theorem integer_list_average (numbers : List Int) :\n  find_average (numbers.map Float.ofInt) =\n    match numbers with\n    | [] => 0\n    | _  => Float.ofInt (sumInt numbers) / Float.ofInt numbers.length :=\nsorry\n\ntheorem empty_list_average :\n  find_average [] = 0 :=\nsorry\n\ntheorem average_between_min_max (numbers : List Float) (h : numbers ≠ []) :\n  match minimum? numbers, maximum? numbers with\n  | some min, some max => min ≤ find_average numbers ∧ find_average numbers ≤ max\n  | _, _ => True :=\nsorry\n\ntheorem average_times_length_equals_sum (numbers : List Float) :\n  match numbers with\n  | [] => find_average numbers = 0\n  | _  => find_average numbers * (Float.ofNat numbers.length) = sum numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_average [1, 2, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []\n\n/--\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_average [1.5, 2.5, 3.5]"}
{"id": "fvapps_004022", "vc-description": "/-\nA palindrome is a word, phrase, number, or other sequence of characters which reads the same backward as forward. Examples of numerical palindromes are: \n\n* 232\n* 110011\n* 54322345\n\nComplete the function to test if the given number (`num`) **can be rearranged** to form a numerical palindrome or not. Return a boolean (`true` if it can be rearranged to a palindrome, and `false` if it cannot). Return `\"Not valid\"` if the input is not an integer or is less than 0.\n\nFor this kata, single digit numbers are **NOT** considered numerical palindromes.  \n\n## Examples\n\n```\n5        =>  false\n2121     =>  true\n1331     =>  true \n3357665  =>  true \n1294     =>  false \n\"109982\" =>  \"Not valid\"\n-42      =>  \"Not valid\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def palindrome : (n : Int) → String ⊕ Bool :=\nsorry\n\ndef countOddDigits (n : Int) : Nat :=\nsorry", "vc-theorems": "theorem negative_numbers {n : Int} (h : n < 0) : palindrome n = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem different_digits_odd_count {n : Int} (h1 : n ≥ 100) (h2 : n ≤ 9999)\n  (h3 : countOddDigits n > 1) : palindrome n = Sum.inr false :=\nsorry\n\ntheorem non_integers_text (s : String) : palindrome 0 = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem non_integers_dec (d : Float) : palindrome 0 = Sum.inl \"Not valid\" :=\nsorry\n\ntheorem single_digits {n : Int} (h1 : n ≥ 0) (h2 : n ≤ 9) :\n  palindrome n = Sum.inr false :=\nsorry\n\ntheorem repeated_digits {n : Int} (h1 : n ≥ 1) (h2 : n ≤ 9) :\n  palindrome (n * 11) = Sum.inr true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome 5\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome 1331\n\n/--\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome \"ololo\""}
{"id": "fvapps_004028", "vc-description": "/-\nThis kata aims to show the vulnerabilities of hashing functions for short messages.\n\nWhen provided with a SHA-256 hash, return the value that was hashed. You are also given the characters that make the expected value, but in alphabetical order.\n\nThe returned value is less than 10 characters long. Return `nil` for Ruby and Crystal, `None` for Python, `null` for Java when the hash cannot be cracked with the given characters.\n\n---\n\nExample:\n--------\n```\nExample arguments: '5694d08a2e53ffcae0c3103e5ad6f6076abd960eb1f8a56577040bc1028f702b', 'cdeo'\nCorrect output: 'code'\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sha256_cracker (h: String) (chars: String) : Option String :=\n  sorry\n\ndef sha256 (s: String) : String :=\n  sorry", "vc-theorems": "theorem found_string_matches_hash\n  {s h chars result: String} :\n  (h = sha256 s) →\n  (chars = s.toList.toString) →\n  (sha256_cracker h chars = some result) →\n  (sha256 result = h) ∧\n  (∀ c, c ∈ result.data → c ∈ chars.data) :=\nsorry\n\ntheorem invalid_chars_return_none\n  {s h invalid_chars chars: String} :\n  (h = sha256 s) →\n  (chars = (invalid_chars.toList.filter (fun c => !s.data.contains c)).toString) →\n  (chars ≠ \"\") →\n  sha256_cracker h chars = none :=\nsorry\n\ntheorem empty_chars_returns_none\n  {s h: String} :\n  (h = sha256 s) →\n  sha256_cracker h \"\" = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'GoOutside'\n-/\n#guard_msgs in\n#eval sha256_cracker \"b8c49d81cb795985c007d78379e98613a4dfc824381be472238dbd2f974e37ae\" \"deGioOstu\"\n\n/--\ninfo: 'code'\n-/\n#guard_msgs in\n#eval sha256_cracker \"5694d08a2e53ffcae0c3103e5ad6f6076abd960eb1f8a56577040bc1028f702b\" \"cdeo\""}
{"id": "fvapps_004029", "vc-description": "/-\n*Recreation of [Project Euler problem #6](https://projecteuler.net/problem=6)*\n\nFind the difference between the sum of the squares of the first `n` natural numbers `(1 <= n <= 100)` and the square of their sum.\n\n## Example\nFor example, when `n = 10`:\n\n* The square of the sum of the numbers is:\n\n  (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)^(2) = 55^(2) = 3025\n\n* The sum of the squares of the numbers is:\n\n 1^(2) + 2^(2) + 3^(2) + 4^(2) + 5^(2) + 6^(2) + 7^(2) + 8^(2) + 9^(2) + 10^(2) = 385\n\nHence the difference between square of the sum of the first ten natural numbers and the sum of the squares of those numbes is: 3025 - 385 = 2640\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def difference_of_squares (n : Nat) : Nat :=\n  sorry\n\ndef sum_up_to (n : Nat) : Nat :=\n  sorry\n\ndef sum_squares_up_to (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem difference_non_negative {n : Nat} :\n  difference_of_squares n ≥ 0 :=\nsorry\n\ntheorem zero_and_one_cases :\n  difference_of_squares 0 = 0 ∧ difference_of_squares 1 = 0 :=\nsorry\n\ntheorem strictly_increasing {n : Nat} (h : n ≥ 2) :\n  difference_of_squares n > difference_of_squares (n-1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 170\n-/\n#guard_msgs in\n#eval difference_of_squares 5\n\n/--\ninfo: 2640\n-/\n#guard_msgs in\n#eval difference_of_squares 10\n\n/--\ninfo: 25164150\n-/\n#guard_msgs in\n#eval difference_of_squares 100"}
{"id": "fvapps_004031", "vc-description": "/-\nIn this Kata, you will be given two numbers, n and k and your task will be to return the k-digit array that sums to n and has the maximum possible GCD.\n\nFor example, given `n = 12, k = 3`, there are a number of possible `3-digit` arrays that sum to `12`, such as `[1,2,9], [2,3,7], [2,4,6], ...` and so on. Of all the possibilities, the one with the highest GCD is `[2,4,6]`. Therefore, `solve(12,3) = [2,4,6]`.\n\nNote also that digits cannot be repeated within the sub-array, so `[1,1,10]` is not a possibility. Lastly, if there is no such array, return an empty array.\n\nMore examples in the test cases.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n k : Nat) : List Nat :=\nsorry\n\ndef isStrictlyIncreasing (lst : List Nat) : Bool :=\nsorry\n\ndef checkSum (n : Nat) (lst : List Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_large_k (n k : Nat) (h1 : n > 0) (h2 : k > n) :\n  (solve n k).length = 0 :=\nsorry\n\ntheorem solve_k_equals_one (n : Nat) (h : n > 0) :\n  let result := solve n 1\n  result.length > 0 → result = [n] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval solve 12 3\n\n/--\ninfo: [3, 6, 9]\n-/\n#guard_msgs in\n#eval solve 18 3\n\n/--\ninfo: [2, 4, 6, 12]\n-/\n#guard_msgs in\n#eval solve 24 4"}
{"id": "fvapps_004037", "vc-description": "/-\n## Task:\n\nYou have to write a function `pattern` which returns the following Pattern(See Examples) upto desired number of rows. \n\n* Note:`Returning` the pattern is not the same as `Printing` the pattern.\n\n### Parameters:\n\n    pattern(        n        ,        x        );\n                    ^                 ^         \n                    |                 |         \n             Term upto which   Number of times  \n              Basic Pattern     Basic Pattern   \n                should be         should be     \n                 created          repeated      \n                                horizontally    \n\n* Note: `Basic Pattern` means what we created in [Complete the pattern #12](\"http://www.codewars.com/kata/558ac25e552b51dbc60000c3\")\n### Rules/Note:\n\n* The pattern should be created using only unit digits.\n* If `n < 1` then it should return \"\" i.e. empty string.\n* If `x <= 1` then the basic pattern should not be repeated horizontally.\n* `The length of each line is same`, and is equal to the length of longest line in the pattern.\n* Range of Parameters (for the sake of CW Compiler) :\n  + `n ∈ (-∞,50]`\n  + `x ∈ (-∞,25]`\n* If only one argument is passed then the function `pattern` should run as if `x <= 1`.\n* The function `pattern` should work when extra arguments are passed, by ignoring the extra arguments.\n\n###Examples:\n\n* Having Two Arguments-\n\n + pattern(4,3):\n\n        1     1     1     1\n         2   2 2   2 2   2 \n          3 3   3 3   3 3  \n           4     4     4   \n          3 3   3 3   3 3  \n         2   2 2   2 2   2 \n        1     1     1     1\n\n  + pattern(10,2):\n\n        1                 1                 1\n         2               2 2               2 \n          3             3   3             3  \n           4           4     4           4   \n            5         5       5         5    \n             6       6         6       6     \n              7     7           7     7      \n               8   8             8   8       \n                9 9               9 9        \n                 0                 0         \n                9 9               9 9        \n               8   8             8   8       \n              7     7           7     7      \n             6       6         6       6     \n            5         5       5         5    \n           4           4     4           4   \n          3             3   3             3  \n         2               2 2               2 \n        1                 1                 1\n\n* Having Only One Argument-\n\n  + pattern(25):\n\n        1                                               1\n         2                                             2 \n          3                                           3  \n           4                                         4   \n            5                                       5    \n             6                                     6     \n              7                                   7      \n               8                                 8       \n                9                               9        \n                 0                             0         \n                  1                           1          \n                   2                         2           \n                    3                       3            \n                     4                     4             \n                      5                   5              \n                       6                 6               \n                        7               7                \n                         8             8                 \n                          9           9                  \n                           0         0                   \n                            1       1                    \n                             2     2                     \n                              3   3                      \n                               4 4                       \n                                5                        \n                               4 4                       \n                              3   3                      \n                             2     2                     \n                            1       1                    \n                           0         0                   \n                          9           9                  \n                         8             8                 \n                        7               7                \n                       6                 6               \n                      5                   5              \n                     4                     4             \n                    3                       3            \n                   2                         2           \n                  1                           1          \n                 0                             0         \n                9                               9        \n               8                                 8       \n              7                                   7      \n             6                                     6     \n            5                                       5    \n           4                                         4   \n          3                                           3  \n         2                                             2 \n        1                                               1\n\n[List of all my katas](\"http://www.codewars.com/users/curious_db97/authored\")\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef String.reverse (s : String) : String :=\nsorry\n\ndef Nat.toString (n : Nat) : String :=\nsorry", "vc-theorems": "theorem pattern_invalid_n (n : Int) (h : n ≤ 0) :\n  pattern n = \"\" :=\nsorry\n\ntheorem pattern_valid_num_lines {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  lines.length = 2 * n - 1 :=\nsorry\n\ntheorem pattern_valid_sequence {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  ∀ i, i ≤ mid →\n    ∃ c, c ∈ String.toList (lines[i]!) ∧\n    c = ((i + 1).toString.toList[0]!) :=\nsorry\n\ntheorem pattern_reverse {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  (lines.take mid).reverse = lines.drop (mid + 1) :=\nsorry\n\ntheorem pattern_symmetric {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  ∀ line ∈ lines, line = line.reverse :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 3\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 4 2\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern -5 3"}
{"id": "fvapps_004045", "vc-description": "/-\nIn Dark Souls, players level up trading souls for stats. 8 stats are upgradable this way: vitality, attunement, endurance, strength, dexterity, resistance, intelligence, and faith. Each level corresponds to adding one point to a stat of the player's choice. Also, there are 10 possible classes each having their own starting level and stats:\n\n```\nWarrior     (Level 4):  11, 8, 12, 13, 13, 11, 9, 9\nKnight      (Level 5):  14, 10, 10, 11, 11, 10, 9, 11\nWanderer    (Level 3):  10, 11, 10, 10, 14, 12, 11, 8\nThief       (Level 5):  9, 11, 9, 9, 15, 10, 12, 11\nBandit      (Level 4):  12, 8, 14, 14, 9, 11, 8, 10\nHunter      (Level 4):  11, 9, 11, 12, 14, 11, 9, 9\nSorcerer    (Level 3):  8, 15, 8, 9, 11, 8, 15, 8\nPyromancer  (Level 1):  10, 12, 11, 12, 9, 12, 10, 8\nCleric      (Level 2):  11, 11, 9, 12, 8, 11, 8, 14\nDeprived    (Level 6):  11, 11, 11, 11, 11, 11, 11, 11\n```\n\nFrom level 1, the necessary souls to level up each time up to 11 are `673`, `690`, `707`, `724`, `741`, `758`, `775`, `793`, `811`, and `829`. Then from 11 to 12 and onwards the amount is defined by the expression `round(pow(x, 3) * 0.02 + pow(x, 2) * 3.06 + 105.6 * x - 895)` where `x` is the number corresponding to the next level.\n\nYour function will receive a string with the character class and a list of stats. It should calculate which level is required to get the desired character build and the amount of souls needed to do so. The result should be a string in the format: `'Starting as a [CLASS], level [N] will require [M] souls.'` where `[CLASS]` is your starting class, `[N]` is the required level, and `[M]` is the amount of souls needed respectively.\n-/", "vc-preamble": "def isValidCharacter (c : String) : Bool :=\n  match c with\n  | \"warrior\" | \"knight\" | \"wanderer\" | \"thief\" | \"bandit\"\n  | \"hunter\" | \"sorcerer\" | \"pyromancer\" | \"cleric\" | \"deprived\" => true\n  | _ => false\n\ndef isValidBuild (b : List Nat) : Bool :=\n  b.length = 8 && b.all (fun x => x ≥ 1 && x ≤ 99)\n\ndef baseStats (c : String) : List Nat :=\n  match c with\n  | \"warrior\" => [11, 8, 12, 13, 13, 11, 9, 9]\n  | \"knight\" => [14, 10, 10, 11, 11, 10, 9, 11]\n  | \"wanderer\" => [10, 11, 10, 10, 14, 12, 11, 8]\n  | \"thief\" => [9, 11, 9, 9, 15, 10, 12, 11]\n  | \"bandit\" => [12, 8, 14, 14, 9, 11, 8, 10]\n  | \"hunter\" => [11, 9, 11, 12, 14, 11, 9, 9]\n  | \"sorcerer\" => [8, 15, 8, 9, 11, 8, 15, 8]\n  | \"pyromancer\" => [10, 12, 11, 12, 9, 12, 10, 8]\n  | \"cleric\" => [11, 11, 9, 12, 8, 11, 8, 14]\n  | \"deprived\" => [11, 11, 11, 11, 11, 11, 11, 11]\n  | _ => []", "vc-helpers": "", "vc-definitions": "def souls (character : String) (build : List Nat) : String :=\n  sorry", "vc-theorems": "theorem souls_returns_valid_string\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    result.startsWith s!\"Starting as a {c}\" ∧\n    (\"level\" ∈ result.splitOn \" \") ∧\n    (\"will require\" ∈ result.splitOn \" \") ∧\n    result.endsWith \"souls.\" :=\nsorry\n\ntheorem souls_returns_non_negative_souls\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    let soulsNeeded := result.splitOn \"require \" |>.get! 1 |>.splitOn \" souls\" |>.get! 0 |>.toNat!\n    soulsNeeded ≥ 0 :=\nsorry\n\ntheorem zero_change_requires_zero_souls\n    {c : String}\n    (hc : isValidCharacter c = true) :\n    let result := souls c (baseStats c)\n    result.endsWith \"will require 0 souls.\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Starting as a deprived, level 6 will require 0 souls.'\n-/\n#guard_msgs in\n#eval souls \"deprived\" [11, 11, 11, 11, 11, 11, 11, 11]\n\n/--\ninfo: 'Starting as a pyromancer, level 2 will require 673 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [10, 12, 11, 12, 9, 12, 11, 8]\n\n/--\ninfo: 'Starting as a pyromancer, level 12 will require 8348 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [16, 12, 11, 12, 9, 12, 13, 10]"}
{"id": "fvapps_004050", "vc-description": "/-\nYou're re-designing a blog and the blog's posts have the following format for showing the date and time a post was made: \n\n*Weekday* *Month* *Day*, *time*\ne.g., \nFriday May 2, 7pm\n\nYou're running out of screen real estate, and on some pages you want to display a shorter format, *Weekday* *Month* *Day* that omits the time.\n\nWrite a function, shortenToDate, that takes the Website date/time in its original string format, and returns the shortened format.\n\nAssume shortenToDate's input will always be a string, e.g. \"Friday May 2, 7pm\". Assume shortenToDate's output will be the shortened string, e.g., \"Friday May 2\".\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def StringMatches (pattern str : String) : Bool :=\nsorry\n\ndef shorten_to_date (s : String) : String :=\nsorry", "vc-theorems": "theorem shorten_to_date_property (dateString : String) :\n  (dateString.contains ',' : Bool) ∧\n  (StringMatches \"[A-Za-z]+ [A-Za-z]+ \\\\d+, \\\\d+(?:am|pm)\" dateString) →\n  let result := shorten_to_date dateString\n  ¬(result.contains ',' : Bool) ∧\n  result = (dateString.splitOn \",\").get! 0 ∧\n  result.length < dateString.length :=\nsorry\n\ntheorem shorten_to_date_requires_comma (s : String) :\n  ¬((s.contains ',' : Bool) ∧ (s.splitOn \",\").length = 2) →\n  False :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Friday May 2'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Friday May 2, 7pm\"\n\n/--\ninfo: 'Tuesday January 29'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Tuesday January 29, 10pm\"\n\n/--\ninfo: 'Wed September 1'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Wed September 1, 3am\""}
{"id": "fvapps_004051", "vc-description": "/-\nYour task is to write a function named `do_math` that receives a single argument. \nThis argument is a string that contains multiple whitespace delimited numbers. Each number has a single alphabet letter somewhere within it.\n```\nExample : \"24z6 1x23 y369 89a 900b\"\n```\nAs shown above, this alphabet letter can appear anywhere within the number. You have to extract the letters and sort the numbers according to their corresponding letters. \n```\nExample : \"24z6 1x23 y369 89a 900b\" will become 89 900 123 369 246 (ordered according to the alphabet letter)\n```\nHere comes the difficult part, now you have to do a series of computations on the numbers you have extracted.\n\n* The sequence of computations are `+ - * /`. Basic math rules do **NOT** apply, you have to do each computation in exactly this order.\n* This has to work for any size of numbers sent in (after division, go back to addition, etc).\n* In the case of duplicate alphabet letters, you have to arrange them according to the number that appeared first in the input string.\n* Remember to also round the final answer to the nearest integer.\n\n```\nExamples :\n\"24z6 1x23 y369 89a 900b\" = 89 + 900 - 123 * 369 / 246 = 1299\n\"24z6 1z23 y369 89z 900b\" = 900 + 369 - 246 * 123 / 89 = 1414\n\"10a 90x 14b 78u 45a 7b 34y\" = 10 + 45 - 14 * 7 / 78 + 90 - 34 = 60\n``` \nGood luck and may the CODE be with you!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def do_math (input : String) : Int :=\n  sorry\n\ndef make_alpha_num (nums : List Int) (letters : List String) : String :=\n  sorry", "vc-theorems": "theorem do_math_returns_int {nums : List Int} {letters : List String}\n  (h_nums_size : nums.length ≥ 2 ∧ nums.length ≤ 10)\n  (h_letters_size : letters.length ≥ 2 ∧ letters.length ≤ 10)\n  (h_nums_bound : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 1000)\n  (h_letters_single : ∀ l ∈ letters, l.length = 1)\n  : ∃ n : Int, do_math (make_alpha_num nums letters) = n :=\nsorry\n\ntheorem letter_position_invariant {letter : String}\n  (h_letter_single : letter.length = 1) :\n  do_math (\"123\" ++ letter ++ \" 456\" ++ letter) =\n  do_math (letter ++ \"123 \" ++ letter ++ \"456\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1414\n-/\n#guard_msgs in\n#eval do_math \"24z6 1z23 y369 89z 900b\"\n\n/--\ninfo: 1299\n-/\n#guard_msgs in\n#eval do_math \"24z6 1x23 y369 89a 900b\"\n\n/--\ninfo: 60\n-/\n#guard_msgs in\n#eval do_math \"10a 90x 14b 78u 45a 7b 34y\""}
{"id": "fvapps_004053", "vc-description": "/-\nRound any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solution (x : Float) : Float :=\nsorry\n\ndef floor (x : Float) : Float :=\nsorry\n\ndef ceil (x : Float) : Float :=\nsorry", "vc-theorems": "theorem solution_output_options (x : Float) :\n  let floorX := floor x\n  solution x = floorX ∨ solution x = floorX + 0.5 ∨ solution x = ceil x\n  :=\nsorry\n\ntheorem solution_within_half (x : Float) :\n  (solution x - x) ≤ 0.5 ∧ (x - solution x) ≤ 0.5\n  :=\nsorry\n\ntheorem solution_cases (x : Float) :\n  let floorX := floor x\n  (x - floorX < 0.25 → solution x = floorX) ∧\n  (x - floorX < 0.75 ∧ x - floorX ≥ 0.25 → solution x = floorX + 0.5) ∧\n  (x - floorX ≥ 0.75 → solution x = ceil x)\n  :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solution 4.2\n\n/--\ninfo: 4.5\n-/\n#guard_msgs in\n#eval solution 4.6\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solution 4.75"}
{"id": "fvapps_004064", "vc-description": "/-\nJohnny is a farmer and he annually holds a beet farmers convention \"Drop the beet\".\n\nEvery year he takes photos of farmers handshaking. Johnny knows that no two farmers handshake more than once. He also knows that some of the possible handshake combinations may not happen.\n\nHowever, Johnny would like to know the minimal amount of people that participated this year just by counting all the handshakes.\n\nHelp Johnny by writing a function, that takes the amount of handshakes and returns the minimal amount of people needed to perform these handshakes (a pair of farmers handshake only once).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getParticipants (h : Nat) : Nat :=\n  sorry\n\ndef choose (n k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem handshakes_bounds (h : Nat) :\n  let n := getParticipants h\n  let possibleHandshakes := if n ≥ 2 then choose n 2 else 0\n  n ≥ 1 ∧ possibleHandshakes ≥ h :=\nsorry\n\ntheorem basic_cases :\n  getParticipants 0 = 1 ∧\n  getParticipants 1 = 2 ∧\n  getParticipants 6 = 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval get_participants 0\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval get_participants 1\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval get_participants 6"}
{"id": "fvapps_004067", "vc-description": "/-\nCreate a program that will return whether an input value is a str, int, float, or bool. Return the name of the value.\n\n### Examples\n- Input = 23 --> Output = int\n- Input = 2.3 --> Output = float\n- Input = \"Hello\" --> Output = str\n- Input = True --> Output = bool\n-/\n\n/- For any given value, the types function returns a string that should be consistent -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The types function is reflexive -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def types (x : α) : String :=\nsorry", "vc-theorems": "theorem types_matches_type_name {α : Type} (x : α) :\n  types x = types x :=\nsorry\n\ntheorem types_preserves_equality {α : Type} (x : α) :\n  types x = types x :=\nsorry", "vc-postamble": "/--\ninfo: 'int'\n-/\n#guard_msgs in\n#eval types 23\n\n/--\ninfo: 'float'\n-/\n#guard_msgs in\n#eval types 2.3\n\n/--\ninfo: 'str'\n-/\n#guard_msgs in\n#eval types \"Hello\"\n\n/--\ninfo: 'bool'\n-/\n#guard_msgs in\n#eval types True"}
{"id": "fvapps_004074", "vc-description": "/-\nWrite a function getMean that takes as parameters an array (arr) and 2 integers (x and y). The function should return the mean between the mean of the the first x elements of the array and the mean of the last y elements of the array.\n\nThe mean should be computed if both x and y have values higher than 1 but less or equal to the array's length. Otherwise the function should return -1.\n\ngetMean([1,3,2,4], 2, 3) should return 2.5 because: the mean of the the first 2 elements of the array is (1+3)/2=2 and the mean of the last 3 elements of the array is (4+2+3)/3=3 so the mean of those 2 means is (2+3)/2=2.5.\n\ngetMean([1,3,2,4], 1, 2) should return -1 because x is not higher than 1.\n\ngetMean([1,3,2,4], 2, 8) should return -1 because 8 is higher than the array's length.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Array.getSum (arr : Array Int) (n : Nat) : Int :=\n  sorry\n\ndef Array.getMean (arr : Array Int) (x y : Int) : Float :=\n  sorry", "vc-theorems": "theorem invalid_x_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 → x ≤ 0 → Array.getMean arr x y = -1 :=\nsorry\n\ntheorem invalid_y_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 → y ≤ 0 → Array.getMean arr x y = -1 :=\nsorry\n\ntheorem indices_larger_than_array {arr : Array Int} {x y : Int} :\n  x > arr.size ∨ y > arr.size →\n  Array.getMean arr x y = -1 :=\nsorry\n\ntheorem mean_properties {arr : Array Int} {x y : Int} :\n  arr.size ≥ 2 →\n  1 < x ∧ x ≤ arr.size →\n  1 < y ∧ y ≤ arr.size →\n  let firstMean := Float.ofInt (Array.getSum arr x.toNat) / Float.ofInt x;\n  let secondMean := Float.ofInt (Array.getSum (arr.extract (arr.size - y.toNat) arr.size) y.toNat) / Float.ofInt y;\n  let expected := (firstMean + secondMean) / 2;\n  (Array.getMean arr x y - expected).abs < 1e-10 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004079", "vc-description": "/-\n## Description\n\nThe task is described in the title: find the sum of all numbers with the same digits(permutations) **including** duplicates. However, due to the fact that this is a performance edition kata, `num` can go up to `10**10000`. That's a number with 10001 digits(at most). Be sure to use efficient algorithms and good luck! All numbers tested for will be positive.\n\n**Examples**\n```\nsum_arrangements(98) returns 89+98 = 187\nsum_arrangements(123) returns 1332 #123 + 132 + 213 + 231 + 312 + 321 = 1332\nsum_arrangements(1185) returns 99990 #1185 + 1158 + 1815 + 1851 + 1518 + 1581 + 1185 + 1158 + 1815 + 1851 + 1518 + 1581 + 8115 + 8151 + 8115 + 8151 + 8511 + 8511 + 5118 + 5181 + 5118 + 5181 + 5811 + 5811 = 99990\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_arrangements (n : Nat) : Nat :=\nsorry\n\ndef digit_sum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem deterministic (n : Nat) :\n  sum_arrangements n = sum_arrangements n := by\nsorry\n\ntheorem multiple_of_digit_sum (n : Nat) (h : n > 0) :\n  sum_arrangements n % digit_sum n = 0 := by\nsorry\n\ntheorem single_digit (n : Nat) (h : n > 0) (h₂ : n < 10) :\n  sum_arrangements n = n := by\nsorry\n\ntheorem positive_output (n : Nat) (h : n > 0) :\n  sum_arrangements n > 0 := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 187\n-/\n#guard_msgs in\n#eval sum_arrangements 98\n\n/--\ninfo: 1332\n-/\n#guard_msgs in\n#eval sum_arrangements 123\n\n/--\ninfo: 99990\n-/\n#guard_msgs in\n#eval sum_arrangements 1185"}
{"id": "fvapps_004086", "vc-description": "/-\nWhen provided with a String, capitalize all vowels\n\nFor example:\n\nInput : \"Hello World!\"\n\nOutput : \"HEllO WOrld!\"\n\nNote: Y is not a vowel in this kata.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.swap : String → String :=\n  sorry\n\ndef Char.isVowel (c : Char) : Bool :=\n  let vowels := ['a', 'e', 'i', 'o', 'u']\n  sorry", "vc-theorems": "theorem swap_preserves_length (s : String) :\n  (String.swap s).length = s.length := \nsorry\n\ntheorem swap_idempotent (s : String) :\n  String.swap (String.swap s) = String.swap s := \nsorry\n\ntheorem swap_preserves_non_vowels (s : String) (i : String.Pos) :\n  ¬(Char.isVowel (s.get i)) →\n  (String.swap s).get i = s.get i := \nsorry\n\ntheorem swap_capitalizes_vowels (s : String) (i : String.Pos) :\n  (Char.isVowel (s.get i)) →\n  ((String.swap s).get i).isUpper = true ∧\n  ((String.swap s).get i).toLower = (s.get i).toLower := \nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'HEllOWOrld!'\n-/\n#guard_msgs in\n#eval swap \"HelloWorld!\"\n\n/--\ninfo: 'SUndAy'\n-/\n#guard_msgs in\n#eval swap \"Sunday\"\n\n/--\ninfo: 'AbrAcAdAbrA'\n-/\n#guard_msgs in\n#eval swap \"abracadabra\""}
{"id": "fvapps_004090", "vc-description": "/-\n# Task\n In ChessLand there is a small but proud chess bishop with a recurring dream. \n\n In the dream the bishop finds itself on an `n × m` chessboard with mirrors along each edge, and it is not a bishop but a ray of light. This ray of light moves only along diagonals (the bishop can't imagine any other types of moves even in its dreams), it never stops, and once it reaches an edge or a corner of the chessboard it reflects from it and moves on.\n\n Given the initial position and the direction of the ray, find its position after `k` steps where a step means either moving from one cell to the neighboring one or reflecting from a corner of the board.\n\n# Example\n\n For `boardSize = [3, 7], initPosition = [1, 2], initDirection = [-1, 1] and k = 13,` the output should be `[0, 1]`.\n\n Here is the bishop's path:\n```\n[1, 2] -> [0, 3] -(reflection from the top edge)\n         -> [0, 4] -> [1, 5] -> [2, 6] -(reflection from the bottom right corner)\n         -> [2, 6] ->[1, 5] -> [0, 4] -(reflection from the top edge)\n         -> [0, 3] ->[1, 2] -> [2, 1] -(reflection from the bottom edge)\n         -> [2, 0] -(reflection from the left edge)\n         -> [1, 0] -> [0, 1]```\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/chessBishopDream/img/example.png?_tm=1472324389202)\n\n# Input/Output\n\n - `[input]` integer array `boardSize`\n\n    An array of two integers, the number of `rows` and `columns`, respectively. Rows are numbered by integers from `0 to boardSize[0] - 1`, columns are numbered by integers from `0 to boardSize[1] - 1` (both inclusive).\n\n    Constraints: `1 ≤ boardSize[i] ≤ 20.`\n\n - `[input]` integer array `initPosition`\n\n    An array of two integers, indices of the `row` and the `column` where the bishop initially stands, respectively.\n\n    Constraints:  `0 ≤ initPosition[i] < boardSize[i]`.\n\n - `[input]` integer array `initDirection`\n\n    An array of two integers representing the initial direction of the bishop. \n\n    If it stands in `(a, b)`, the next cell he'll move to is `(a + initDirection[0], b + initDirection[1])` or whichever it'll reflect to in case it runs into a mirror immediately.\n\n    Constraints: `initDirection[i] ∈ {-1, 1}`.\n\n - `[input]` integer `k`\n\n    Constraints: `1 ≤ k ≤ 1000000000`.\n\n - `[output]` an integer array\n\n    The position of the bishop after `k` steps.\n-/", "vc-preamble": "def inRange (x: Int) (lower: Int) (upper: Int) : Prop :=\n  lower ≤ x ∧ x < upper", "vc-helpers": "", "vc-definitions": "def chessBishopDream (boardSize: List Int) (initPos: List Int) (initDir: List Int) (k: Nat) : List Int :=\n  sorry", "vc-theorems": "theorem bishop_within_boundaries\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, inRange (result[i]!) 0 (boardSize[i]!)) :=\nsorry\n\ntheorem bishop_periodic\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1) :\n  let period := (4 * boardSize[0]! * boardSize[1]!).toNat\n  chessBishopDream boardSize initPos initDir period =\n  chessBishopDream boardSize initPos initDir 0 :=\nsorry\n\ntheorem bishop_reflection\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize, 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir, x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, result[i]! ≤ boardSize[i]!) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [3, 7] [1, 2] [-1, 1] 13\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [1, 2] [0, 0] [1, 1] 6\n\n/--\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [2, 2] [1, 0] [1, 1] 12"}
{"id": "fvapps_004098", "vc-description": "/-\nChuck has lost count of how many asses he has kicked...\n\nChuck stopped counting at 100,000 because he prefers to kick things in the face instead of counting. That's just who he is.\n\nTo stop having to count like a mere mortal chuck developed his own special code using the hairs on his beard. You do not need to know the details of how it works, you simply need to know that the format is as follows: 'A8A8A8A8A8.-A%8.88.'\n\nIn Chuck's code, 'A' can be any capital letter and '8' can be any number 0-9 and any %, - or . symbols must not be changed.\n\nYour task, to stop Chuck beating your ass with his little finger, is to use regex to verify if the number is a genuine Chuck score. If not it's probably some crap made up by his nemesis Bruce Lee. Return true if the provided count passes, and false if it does not.  \n\n```Javascript\nExample:\n     'A8A8A8A8A8.-A%8.88.' <- don't forget final full stop :D\\n\nTests:\n     'A2B8T1Q9W4.-F%5.34.' == true;\n     'a2B8T1Q9W4.-F%5.34.' == false; (small letter)\n     'A2B8T1Q9W4.-F%5.3B.' == false; (last char should be number) \n     'A2B8T1Q9W4.£F&5.34.' == false; (symbol changed from - and %)\n ```\n\nThe pattern only needs to appear within the text. The full input can be longer, i.e. the pattern can be surrounded by other characters... Chuck loves to be surrounded!\n\nReady, steady, VERIFY!!\n-/\n\n/- Any string matching the pattern [A-Z][0-9] repeated 5 times, followed by\n    .-[A-Z]%[0-9].[0-9][0-9]. should return true -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any string not matching the pattern should return false -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def body_count (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_code_returns_true {code : String}\n  (h : ∃ (a₁ a₂ a₃ a₄ a₅ : Char) (n₁ n₂ n₃ n₄ n₅ : Nat) (last_letter : Char)\n        (last_num dec₁ dec₂ : Nat),\n    'A' ≤ a₁ ∧ a₁ ≤ 'Z' ∧\n    'A' ≤ a₂ ∧ a₂ ≤ 'Z' ∧\n    'A' ≤ a₃ ∧ a₃ ≤ 'Z' ∧\n    'A' ≤ a₄ ∧ a₄ ≤ 'Z' ∧\n    'A' ≤ a₅ ∧ a₅ ≤ 'Z' ∧\n    'A' ≤ last_letter ∧ last_letter ≤ 'Z' ∧\n    n₁ ≤ 9 ∧ n₂ ≤ 9 ∧ n₃ ≤ 9 ∧ n₄ ≤ 9 ∧ n₅ ≤ 9 ∧\n    last_num ≤ 9 ∧\n    dec₁ ≤ 9 ∧ dec₂ ≤ 9 ∧\n    code = String.mk [a₁, Char.ofNat (n₁ + 48),\n                     a₂, Char.ofNat (n₂ + 48),\n                     a₃, Char.ofNat (n₃ + 48),\n                     a₄, Char.ofNat (n₄ + 48),\n                     a₅, Char.ofNat (n₅ + 48),\n                     '.', '-', last_letter, '%',\n                     Char.ofNat (last_num + 48), '.',\n                     Char.ofNat (dec₁ + 48), Char.ofNat (dec₂ + 48), '.']) :\n  body_count code = true :=\nsorry\n\ntheorem invalid_code_returns_false {s : String}\n  (h : ¬∃ (a₁ a₂ a₃ a₄ a₅ : Char) (n₁ n₂ n₃ n₄ n₅ : Nat) (last_letter : Char)\n        (last_num dec₁ dec₂ : Nat),\n    'A' ≤ a₁ ∧ a₁ ≤ 'Z' ∧\n    'A' ≤ a₂ ∧ a₂ ≤ 'Z' ∧\n    'A' ≤ a₃ ∧ a₃ ≤ 'Z' ∧\n    'A' ≤ a₄ ∧ a₄ ≤ 'Z' ∧\n    'A' ≤ a₅ ∧ a₅ ≤ 'Z' ∧\n    'A' ≤ last_letter ∧ last_letter ≤ 'Z' ∧\n    n₁ ≤ 9 ∧ n₂ ≤ 9 ∧ n₃ ≤ 9 ∧ n₄ ≤ 9 ∧ n₅ ≤ 9 ∧\n    last_num ≤ 9 ∧\n    dec₁ ≤ 9 ∧ dec₂ ≤ 9 ∧\n    s = String.mk [a₁, Char.ofNat (n₁ + 48),\n                  a₂, Char.ofNat (n₂ + 48),\n                  a₃, Char.ofNat (n₃ + 48),\n                  a₄, Char.ofNat (n₄ + 48),\n                  a₅, Char.ofNat (n₅ + 48),\n                  '.', '-', last_letter, '%',\n                  Char.ofNat (last_num + 48), '.',\n                  Char.ofNat (dec₁ + 48), Char.ofNat (dec₂ + 48), '.']) :\n  body_count s = false :=\nsorry", "vc-postamble": "/--\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"A6C2E5Z9A4.-F%8.08.\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"PP P6A6T5F5S3.-Z%1.11.hgr\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval body_count \"b4A1D1I8B4.-E%8.76.\""}
{"id": "fvapps_004107", "vc-description": "/-\n*This kata is based on [Project Euler Problem #349](https://projecteuler.net/problem=349). You may want to start with solving [this kata](https://www.codewars.com/kata/langtons-ant) first.*\n\n---\n\n[Langton's ant](https://en.wikipedia.org/wiki/Langton%27s_ant) moves on a regular grid of squares that are coloured either black or white.\nThe ant is always oriented in one of the cardinal directions (left, right, up or down) and moves  according to the following rules:\n- if it is on a black square, it flips the colour of the square to white, rotates 90 degrees counterclockwise and moves forward one square.\n- if it is on a white square, it flips the colour of the square to black, rotates 90 degrees clockwise and moves forward one square.\n\nStarting with a grid that is **entirely white**, how many squares are black after `n` moves of the ant?\n\n**Note:** `n` will go as high as 10^(20)\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n-/", "vc-preamble": "def abs (n : Nat) : Nat :=\n  n", "vc-helpers": "", "vc-definitions": "def langtons_ant (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem langtons_ant_non_negative (n : Nat) :\n  langtons_ant n ≥ 0 :=\nsorry\n\ntheorem langtons_ant_first_moves (n : Nat) :\n  (n = 0 → langtons_ant n = 0) ∧\n  (n = 1 → langtons_ant n = 1) ∧\n  (n ≥ 2 → langtons_ant n ≤ n) :=\nsorry\n\ntheorem langtons_ant_periodic (n1 n2 : Nat) :\n  n1 ≥ 9977 → n2 ≥ 9977 →\n  (n1 - n2) % 104 = 0 →\n  (if langtons_ant n1 ≥ langtons_ant n2\n   then langtons_ant n1 - langtons_ant n2\n   else langtons_ant n2 - langtons_ant n1) =\n    12 * (if (n1 - 9977) / 104 ≥ (n2 - 9977) / 104\n          then (n1 - 9977) / 104 - (n2 - 9977) / 104\n          else (n2 - 9977) / 104 - (n1 - 9977) / 104) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval langtons_ant 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval langtons_ant 1\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval langtons_ant 2\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval langtons_ant 10\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval langtons_ant 100"}
{"id": "fvapps_004108", "vc-description": "/-\n**Introduction**\n Little Petya very much likes sequences. However, recently he received a sequence as a gift from his mother.\n Petya didn't like it at all! He decided to make a single replacement. After this replacement, Petya would like to the sequence in increasing order.\n He asks himself: What is the lowest possible value I could have got after making the replacement and sorting the sequence?\n\n**About the replacement**\n Choose exactly one element from the sequence and replace it with another integer > 0. You are **not allowed** to replace a number with itself, or to change no number at all.\n\n**Task**\n Find the lowest possible sequence after performing a valid replacement, and sorting the sequence.\n\n**Input:**\n Input contains sequence with `N` integers. All elements of the sequence > 0. The sequence will never be empty.\n\n**Output:**\n Return sequence with `N` integers — which includes the lowest possible values of each sequence element, after the single replacement and sorting has been performed.\n\n**Examples**:\n```\n([1,2,3,4,5])  =>  [1,1,2,3,4]\n([4,2,1,3,5])  =>  [1,1,2,3,4]\n([2,3,4,5,6])  =>  [1,2,3,4,5]\n([2,2,2])      =>  [1,2,2]\n([42])         =>  [1]\n```\n-/", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-helpers": "", "vc-definitions": "def sort_number (l : List Int) : List Int :=\nsorry", "vc-theorems": "theorem sort_number_length {l : List Int} (h : l ≠ []) :\n  (sort_number l).length = l.length :=\nsorry\n\ntheorem sort_number_first {l : List Int} (h : l ≠ []) :\n  (sort_number l).head! = 1 :=\nsorry\n\ntheorem sort_number_deterministic {l : List Int} (h : l ≠ []) :\n  sort_number l = sort_number l :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [1, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval sort_number [1, 2, 3, 4, 5]\n\n/--\ninfo: [1, 2, 2]\n-/\n#guard_msgs in\n#eval sort_number [2, 2, 2]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval sort_number [42]"}
{"id": "fvapps_004110", "vc-description": "/-\nWhat is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example:\n\n```\n'abba' & 'baab' == true\n\n'abba' & 'bbaa' == true\n\n'abba' & 'abbba' == false\n\n'abba' & 'abca' == false\n```\n\nWrite a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example:\n\nanagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) => ['aabb', 'bbaa']\n\nanagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) => ['carer', 'racer']\n\nanagrams('laser', ['lazing', 'lazy',  'lacer']) => []\n-/\n\n-- Result is subset of input\n\n-- Each result same length as input\n\n-- Each result has same letters\n\n-- Contains all valid anagrams", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def anagrams (word : String) (words : List String) : List String :=\nsorry\n\ndef sameLetters (word1 word2 : String) : Bool :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem anagram_properties (word : String) (words : List String) :\n  let result := anagrams word words\n\n  (∀ w ∈ result, w ∈ words) ∧\n\n  (∀ w ∈ result, String.length w = String.length word) ∧\n\n  (∀ w ∈ result, sameLetters w word) ∧\n\n  (∀ w ∈ words, sameLetters w word → w ∈ result) :=\nsorry\n\ntheorem empty_list (word : String) :\n  anagrams word [] = [] :=\nsorry\n\ntheorem same_word (word : String) :\n  anagrams word [word] = [word] :=\nsorry\n\ntheorem reversed_word (word : String) :\n  let reversed := reverseString word\n  anagrams word [reversed] = [reversed] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ['aabb', 'bbaa']\n-/\n#guard_msgs in\n#eval anagrams \"abba\" [\"aabb\", \"abcd\", \"bbaa\", \"dada\"]\n\n/--\ninfo: ['carer', 'racer']\n-/\n#guard_msgs in\n#eval anagrams \"racer\" [\"crazer\", \"carer\", \"racar\", \"caers\", \"racer\"]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval anagrams \"laser\" [\"lazing\", \"lazy\", \"lacer\"]"}
{"id": "fvapps_004111", "vc-description": "/-\n*Shamelessly stolen from Here :)*\n\nYour server has sixteen memory banks; each memory bank can hold any number of blocks. You must write a routine to balance the blocks between the memory banks.\n\nThe reallocation routine operates in cycles. In each cycle, it finds the memory bank with the most blocks (ties won by the lowest-numbered memory bank) and redistributes those blocks among the banks. To do this, it removes all of the blocks from the selected bank, then moves to the next (by index) memory bank and inserts one of the blocks. It continues doing this until it runs out of blocks; if it reaches the last memory bank, it wraps around to the first one.\n\nWe need to know how many redistributions can be done before a blocks-in-banks configuration is produced that has been seen before.\n\nFor example, imagine a scenario with only four memory banks:\n\n* The banks start with 0, 2, 7, and 0 blocks (`[0,2,7,0]`). The third bank has the most blocks (7), so it is chosen for redistribution.\n* Starting with the next bank (the fourth bank) and then continuing one block at a time, the 7 blocks are spread out over the memory banks. The fourth, first, and second banks get two blocks each, and the third bank gets one back. The final result looks like this: 2 4 1 2.\n* Next, the second bank is chosen because it contains the most blocks (four). Because there are four memory banks, each gets one block. The result is: 3 1 2 3.\n* Now, there is a tie between the first and fourth memory banks, both of which have three blocks. The first bank wins the tie, and its three blocks are distributed evenly over the other three banks, leaving it with none: 0 2 3 4.\n* The fourth bank is chosen, and its four blocks are distributed such that each of the four banks receives one: 1 3 4 1.\n* The third bank is chosen, and the same thing happens: 2 4 1 2.\nAt this point, we've reached a state we've seen before: 2 4 1 2 was already seen. The infinite loop is detected after the fifth block redistribution cycle, and so the answer in this example is 5.\n\nReturn the number of redistribution cycles completed before a configuration is produced that has been seen before.\n\nPeople seem to be struggling, so here's a visual walkthrough of the above example: http://oi65.tinypic.com/dmshls.jpg\n\nNote: Remember, memory access is very fast. Yours should be too.\n\n**Hint for those who are timing out:** Look at the number of cycles happening even in the sample tests. That's a _lot_ of different configurations, and a lot of different times you're going to be searching for a matching sequence. Think of ways to cut down on the time this searching process takes.\n\nPlease upvote if you enjoyed! :)\n-/", "vc-preamble": "def list_sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def mem_alloc (banks : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem mem_alloc_positive (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks > 0 :=\nsorry\n\ntheorem mem_alloc_preserves_input (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :=\nsorry\n\ntheorem mem_alloc_deterministic (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 70\n-/\n#guard_msgs in\n#eval mem_alloc [5, 1, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 600]\n\n/--\ninfo: 316\n-/\n#guard_msgs in\n#eval mem_alloc [53, 21, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 60]\n\n/--\ninfo: 826\n-/\n#guard_msgs in\n#eval mem_alloc [14, 21, 10, 0, 1, 7, 0, 14, 3, 12, 8, 10, 17, 12, 0, 19]"}
{"id": "fvapps_004115", "vc-description": "/-\n## Story\n\nThere are four warriors, they need to go through a dark tunnel. Tunnel is very narrow, every time only can let two warriors through, and there are lot of dangerous traps. Fortunately, they have a lamp that can illuminate the tunnel to avoid being trapped by the trap.\n\nIn order to pass this tunnel, they need five steps:\n\n1. Two people go through the tunnel with the lamp\n2. And then one people come back with the lamp\n3. And then two people go through the tunnel with the lamp\n4. And then one people come back with the lamp\n5. And then two people go through the tunnel with the lamp\n\nEach warrior has his own walking speed, we need to calculate the shortest time they have to cross the tunnel.\n\nFor example:\n\nFour warriors is `a,b,c,d`. Their speed are `[3,4,5,6]`. It means they need 3 minutes, 4 minutes, 5 minutes and 6 minutes to cross the tunnel. The shortest crossing time should be 21 minutes, the method is as follows:\n\n```\na and b go through the tunnel  ---> Spend 4 minutes\n(Time spent should be calculated by the person who is slow)\na come back                    ---> Spend 3 minutes\na and c go through the tunnel  ---> Spend 5 minutes\na come back                    ---> Spend 3 minutes\na and d go through the tunnel  ---> Spend 6 minutes\n```\nDo you have any other better way?\n\n## Task\nComplete function `shortestTime()` that accepts 1 argument: `speed` that are the spent time of four warriors. Returns the shortest time that all warriors go through the tunnel.\n\n**Note: The method in example above is not always the best way.**\n\n## Example\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortest_time (speeds: List Int) : Int :=\n  sorry\n\ndef List.sorted (l: List Int) : List Int :=\n  sorry\n\ndef isPermutation (l1 l2: List Int) : Bool :=\n  sorry", "vc-theorems": "theorem shortest_time_positive (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  shortest_time speeds > 0 :=\nsorry\n\ntheorem shortest_time_min_bound (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds ≥ sorted[0]! + sorted[1]! + sorted[3]! :=\nsorry\n\ntheorem shortest_time_two_crossings (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds ≥ 2 * (sorted[0]! + sorted[1]!) :=\nsorry\n\ntheorem shortest_time_order_invariant (speeds1 speeds2: List Int)\n  (h1: speeds1.length = 4)\n  (h2: speeds2.length = 4)\n  (h3: ∀ x ∈ speeds1, x ≥ 1)\n  (h4: ∀ x ∈ speeds2, x ≥ 1)\n  (h5: isPermutation speeds1 speeds2) :\n  shortest_time speeds1 = shortest_time speeds2 :=\nsorry\n\ntheorem shortest_time_monotonic (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: ∀ x ∈ speeds, x ≥ 1)\n  (i: Nat)\n  (h3: i < speeds.length) :\n  let increased := speeds.set i (speeds[i]! + 1)\n  shortest_time increased ≥ shortest_time speeds :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n#eval shortest_time [3, 4, 5, 6]\n\n/--\ninfo: 41\n-/\n#guard_msgs in\n#eval shortest_time [3, 7, 10, 18]\n\n/--\ninfo: 27\n-/\n#guard_msgs in\n#eval shortest_time [5, 5, 6, 7]"}
{"id": "fvapps_004121", "vc-description": "/-\nMaya writes weekly articles to a well known magazine, but she is missing one word each time she is about to send the article to the editor. The article is not complete without this word. Maya has a friend, Dan, and he is very good with words, but he doesn't like to just give them away. He texts Maya a number and she needs to find out the hidden word. \nThe words can contain only the letter: \"a\", \"b\", \"d\", \"e\", \"i\", \"l\", \"m\", \"n\", \"o\", and \"t\".\n\nLuckily, Maya has the key:\n\n\"a\" - 6\n\"b\" - 1 \n\"d\" - 7\n\"e\" - 4\n\"i\" - 3\n\"l\" - 2\n\"m\" - 9\n\"n\" - 8\n\"o\" - 0\n\"t\" - 5\n\nYou can help Maya by writing a function that will take a number between 100 and 999999 and return a string with the word. \n\nThe input is always a number, contains only the numbers in the key. \nThe output should be always a string with one word, all lowercase.\n\nMaya won't forget to thank you at the end of her article :)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hidden (n : Nat) : String :=\nsorry\n\ndef hidden_withInt (n : Int) : String :=\nsorry", "vc-theorems": "theorem hidden_length_matches_input {n : Nat} :\n  (toString n).length = (hidden n).length :=\nsorry\n\ntheorem hidden_rejects_negative (n : Int) :\n  n < 0 → hidden_withInt n = \"\" :=\nsorry\n\ntheorem hidden_valid_chars {n : Nat} {c : Char} :\n  c ∈ (hidden n).data → c ∈ ['o', 'b', 'l', 'i', 'e', 'a', 't', 'd', 'n', 'm'] :=\nsorry\n\ntheorem hidden_consistent_mapping {n₁ n₂ : Nat} {i : Nat} {pos1 : String.Pos} {pos2 : String.Pos} :\n  i < min (toString n₁).length (toString n₂).length →\n  (toString n₁).get pos1 = (toString n₂).get pos2 →\n  (hidden n₁).get pos1 = (hidden n₂).get pos2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'aid'\n-/\n#guard_msgs in\n#eval hidden 637\n\n/--\ninfo: 'dean'\n-/\n#guard_msgs in\n#eval hidden 7468\n\n/--\ninfo: 'email'\n-/\n#guard_msgs in\n#eval hidden 49632"}
{"id": "fvapps_004142", "vc-description": "/-\nThere exist two zeroes: +0 (or just 0) and -0.\n\nWrite a function that returns `true` if the input number is -0 and `false` otherwise (`True` and `False` for Python).\n\nIn JavaScript / TypeScript / Coffeescript the input will be a number.\n\nIn Python / Java / C / NASM / Haskell / the input will be a float.\n-/\n\n/- Helper function to emulate sign behavior -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_negative_zero (x : Float) : Bool :=\nsorry\n\ndef getSign (x : Float) : Float :=\nsorry\n\ndef posInf : Float :=\nsorry\n\ndef negInf : Float :=\nsorry\n\ndef nanFloat : Float :=\nsorry", "vc-theorems": "theorem is_negative_zero_main (x : Float) :\n  is_negative_zero x = true ↔ (getSign x < 0 ∧ x = 0) :=\nsorry\n\ntheorem is_negative_zero_special_cases :\n  is_negative_zero posInf = false ∧\n  is_negative_zero negInf = false ∧\n  is_negative_zero nanFloat = false :=\nsorry\n\ntheorem is_negative_zero_integers (n : Int) :\n  is_negative_zero (Float.ofInt n) = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-- Constants for special float values -/\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_negative_zero -0.0\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero 0.0\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero -5.0"}
{"id": "fvapps_004143", "vc-description": "/-\nA generalization of Bézier surfaces, called the S-patch, uses an interesting scheme for indexing its control points.\n\nIn the case of an n-sided surface of degree d, each index has n non-negative integers that sum to d, and all possible configurations are used.\n\nFor example, for a 3-sided quadratic (degree 2) surface the control points are:\n\n> indices 3 2 => [[0,0,2],[0,1,1],[0,2,0],[1,0,1],[1,1,0],[2,0,0]]\n\nGiven the degree and the number of sides, generate all control point indices.\nThe order of the indices in the list can be arbitrary, so for the above example\n\n> [[1,1,0],[2,0,0],[0,0,2],[0,2,0],[0,1,1],[1,0,1]]\n\nis also a good solution.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def indices (n d : Nat) : List (List (List Nat)) :=\nsorry\n\ndef sumIndices (idx : List (List Nat)) : Nat :=\nsorry\n\ndef starsAndBars (n k : Nat) : Nat :=\nsorry", "vc-theorems": "theorem indices_valid (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :\n  ∀ idx, idx ∈ indices n d →\n    idx.length = 1 ∧\n    idx.head!.length = n ∧\n    (∀ x, x ∈ idx.head! → x ≤ d) ∧\n    sumIndices idx = d :=\nsorry\n\ntheorem indices_unique (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :\n  ∀ i j, i ∈ indices n d → j ∈ indices n d → i ≠ j → i.head! ≠ j.head! :=\nsorry\n\ntheorem indices_zero (n : Nat) (h1: 0 < n) (h2: n ≤ 10) :\n  indices n 0 = [List.replicate 1 (List.replicate n 0)] :=\nsorry\n\ntheorem indices_singleton (d : Nat) (h: d ≤ 10) :\n  indices 1 d = [[[d]]] :=\nsorry\n\ntheorem indices_count (n d : Nat) (h1: 0 < n) (h2: n ≤ 5) (h3: d ≤ 5) :\n  (indices n d).length = starsAndBars n d :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval len indices(3, 2)\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval len idx[0]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval sum idx[0]"}
{"id": "fvapps_004152", "vc-description": "/-\nWe define the \"unfairness\" of a list/array as the *minimal* difference between max(x1,x2,...xk) and min(x1,x2,...xk), for all possible combinations of k elements you can take from the list/array; both minimum and maximum of an empty list/array are considered to be 0.\n\n**More info and constraints:**\n\n* lists/arrays can contain values repeated more than once, plus there are usually more combinations that generate the required minimum;\n* the list/array's length can be any value from 0 to 10^(6);\n* the value of k will range from 0 to the length of the list/array,\n* the minimum unfairness of an array/list with less than 2 elements is 0.\n\nFor example:\n\n```python\nmin_unfairness([30,100,1000,150,60,250,10,120,20],3)==20 #from max(30,10,20)-min(30,10,20)==20, minimum unfairness in this sample\nmin_unfairness([30,100,1000,150,60,250,10,120,20],5)==90 #from max(30,100,60,10,20)-min(30,100,60,10,20)==90, minimum unfairness in this sample\nmin_unfairness([1,1,1,1,1,1,1,1,1,2,2,2,2,2,2],10)==1 #from max(1,1,1,1,1,1,1,1,1,2)-min(1,1,1,1,1,1,1,1,1,2)==1, minimum unfairness in this sample\nmin_unfairness([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],10)==0 #from max(1,1,1,1,1,1,1,1,1,1)-min(1,1,1,1,1,1,1,1,1,1)==0, minimum unfairness in this sample\nmin_unfairness([1,1,-1],2)==0 #from max(1,1)-min(1,1)==0, minimum unfairness in this sample\n```\n\n**Note:** shamelessly taken from [here](https://www.hackerrank.com/challenges/angry-children), where it was created and debatably categorized and ranked.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_unfairness (arr : List Int) (k : Nat) : Int :=\n  sorry\n\ndef listMax (xs : List Int) : Int :=\n  sorry\n\ndef listMin (xs : List Int) : Int :=\n  sorry\n\ndef sortList (xs : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem min_unfairness_non_negative {arr : List Int} {k : Nat}\n  (h : arr.length > 0) (h2 : k > 0) (h3 : k ≤ arr.length) :\n  min_unfairness arr k ≥ 0 :=\nsorry\n\ntheorem min_unfairness_k_one {arr : List Int}\n  (h : arr.length > 0) :\n  min_unfairness arr 1 = 0 :=\nsorry\n\ntheorem min_unfairness_max_difference {arr : List Int} {k : Nat}\n  (h1 : arr.length > 1) (h2 : k > 0) (h3 : k ≤ arr.length) :\n  min_unfairness arr k ≤ listMax arr - listMin arr :=\nsorry\n\ntheorem min_unfairness_sort_invariant {arr : List Int} {k : Nat}\n  (h1 : k > 1) (h2 : arr.length ≥ k) :\n  min_unfairness arr k = min_unfairness (sortList arr) k :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval min_unfairness [30, 100, 1000, 150, 60, 250, 10, 120, 20] 3\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_unfairness [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2] 10\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_unfairness [] 0"}
{"id": "fvapps_004153", "vc-description": "/-\n## Task\nIn this kata you'll be given a string of English digits \"collapsed\" together, like this:\n\n`zeronineoneoneeighttwoseventhreesixfourtwofive`\n\nYour task is to split the string back to digits:\n\n`zero nine one one eight two seven three six four two five`\n\n## Examples\n```\nthree -> three\neightsix -> eight six\nfivefourseven -> five four seven\nninethreesixthree -> nine three six three\nfivethreefivesixthreenineonesevenoneeight -> five three five six three nine one seven one eight\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def NUMBER_WORDS : List String := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef uncollapse (s : String) : String :=\n  sorry\n\ndef isSubstring (pattern : String) (s : String) : Bool :=\n  sorry", "vc-theorems": "theorem uncollapse_random_combinations (numbers : List String)\n  (h : numbers ≠ [] ∧ ∀ n ∈ numbers, n ∈ NUMBER_WORDS) :\n  uncollapse (String.join numbers) = String.join (List.intersperse \" \" numbers) :=\nsorry\n\ntheorem uncollapse_preserves_order (numbers : List String)\n  (h : numbers.length ≥ 2 ∧ ∀ n ∈ numbers, n ∈ NUMBER_WORDS) :\n  (uncollapse (String.join numbers)).split (. == ' ') = numbers :=\nsorry\n\ntheorem uncollapse_single_number (num : String)\n  (h : num ∈ NUMBER_WORDS) :\n  uncollapse num = num :=\nsorry\n\ntheorem uncollapse_invalid_input (s : String)\n  (h : ∀ word ∈ NUMBER_WORDS, isSubstring word s = false) :\n  uncollapse s = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'three'\n-/\n#guard_msgs in\n#eval uncollapse \"three\"\n\n/--\ninfo: 'eight six'\n-/\n#guard_msgs in\n#eval uncollapse \"eightsix\"\n\n/--\ninfo: 'five four seven'\n-/\n#guard_msgs in\n#eval uncollapse \"fivefourseven\""}
{"id": "fvapps_004157", "vc-description": "/-\n# Right in the Center\n\n_This is inspired by one of Nick Parlante's exercises on the [CodingBat](https://codingbat.com/java) online code practice tool._\n\nGiven a sequence of characters, does `\"abc\"` appear in the CENTER of the sequence?\n\nThe sequence of characters could contain more than one `\"abc\"`.\n\nTo define CENTER, the number of characters in the sequence to the left and right of the \"abc\" (which is in the middle) must differ by at most one.\n\nIf it is in the CENTER, return `True`. Otherwise, return `False`.\n\nWrite a function as the solution for this problem. This kata looks simple, but it might not be easy.\n\n## Example\n\n    is_in_middle(\"AAabcBB\")  ->  True\n    is_in_middle(\"AabcBB\")   ->  True\n    is_in_middle(\"AabcBBB\")  ->  False\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_in_middle (s : String) : Bool :=\nsorry\n\ndef containsSubstring (s₁ s₂ : String) : Bool :=\nsorry", "vc-theorems": "theorem empty_or_short_string (s : String) :\n  s.length ≤ 3 → is_in_middle s = false :=\nsorry\n\ntheorem without_abc (s : String) :\n  containsSubstring s \"abc\" = false → is_in_middle s = false :=\nsorry\n\ntheorem equal_padding (n : Nat) :\n  let s := String.mk (List.replicate n 'A') ++ \"abc\" ++ String.mk (List.replicate n 'A')\n  is_in_middle s = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_in_middle \"AAabcBB\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"AabcBBB\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"\""}
{"id": "fvapps_004165", "vc-description": "/-\nYour task is to ___find the next higher number (int) with same '1'- Bits___.\n\nI.e. as much `1` bits as before and output next higher than input. Input is always an int in between 1 and 1<<30 (inclusive). No bad cases or special tricks... \n\n### Some easy examples:\n\n```\nInput: 129  => Output: 130 (10000001 => 10000010)\nInput: 127 => Output: 191 (01111111 => 10111111)\nInput: 1 => Output: 2 (01 => 10)\nInput: 323423 => Output: 323439 (1001110111101011111 => 1001110111101101111)\n```\n\nFirst some static tests, later on many random tests too;-)!\n\n### Hope you have fun! :-)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_higher (n : Nat) : Nat :=\n  sorry\n\ndef countOnes (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem next_higher_preserves_bit_count (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  countOnes n = countOnes (next_higher n) :=\nsorry\n\ntheorem next_higher_is_higher (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  next_higher n > n :=\nsorry\n\ntheorem next_higher_power_two (i : Nat) (h : i < 8) :\n  next_higher (2^i) = 2^(i+1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 256\n-/\n#guard_msgs in\n#eval next_higher 128\n\n/--\ninfo: 191\n-/\n#guard_msgs in\n#eval next_higher 127\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval next_higher 1"}
{"id": "fvapps_004170", "vc-description": "/-\n# Task\n\n**_Given_** *an array of N integers, you have to find* **_how many times_** *you have to* **_add up the smallest numbers_** *in the array until* **_their Sum_**  *becomes greater or equal to* **_K_**.\n___\n\n# Notes: \n\n* **_List size_**  is *at least 3*.\n\n* **_All numbers_**  *will be*  **_positive_**.\n\n* **_Numbers_**  could  *occur more than once* ,   **_(Duplications may exist)_**.\n\n* Threshold  **_K_**  will *always be reachable*.\n___\n# Input >> Output Examples\n\n```\nminimumSteps({1, 10, 12, 9, 2, 3}, 6)  ==>  return (2)\n```\n## **_Explanation_**:\n\n* We  *add two smallest elements*  **_(1 + 2)_**,  *their sum is 3* .\n\n* **_Then_**  we  **_add the next smallest number to it (3 + 3)_** , so  *the sum becomes 6* .\n\n* **_Now_**  the result is greater or equal to **_6_** ,  *Hence the output is (2) i.e (2) operations are required to do this* .\n___\n```\nminimumSteps({8 , 9, 4, 2}, 23)  ==> return (3)\n```\n## **_Explanation_**:\n\n* We  *add two smallest elements*  **_(4 + 2)_**,  *their sum is 6* .\n\n* **_Then_**  we  **_add the next smallest number to it (6 + 8)_** , so *the sum becomes 14* .\n\n* **_Now_**  we  **_add the next smallest number (14 + 9)_** , so *the sum becomes 23*  .\n\n* **_Now_**  the result is greater or equal to **_23_** ,  *Hence the output is (3) i.e (3) operations are required to do this* .\n___\n```\nminimumSteps({19,98,69,28,75,45,17,98,67}, 464)  ==>  return (8)\n```\n## **_Explanation_**:\n\n* We  *add two smallest elements*  **_(19 + 17)_**,  *their sum is 36* .\n\n* **_Then_**  we  **_add the next smallest number to it (36 + 28)_** , so *the sum becomes 64* .\n\n* We need to **_keep doing this_** *until **_the sum_** becomes greater or equal to **_K_** (464 in this case)*, which will require **_8_** Steps .\n___\n ## Expected Time Complexity `O(n Log n)`\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "def sumList (l : List Nat) : Nat :=\n  l.foldl (·+·) 0", "vc-helpers": "", "vc-definitions": "def minimum_steps (arr : List Nat) (n : Nat) : Option Nat :=\n  sorry\n\ndef List.sort (l : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem minimum_steps_nonnegative (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result → result ≥ 0 :=\nsorry\n\ntheorem minimum_steps_less_than_length (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result → result < arr.length :=\nsorry\n\ntheorem minimum_steps_sum_sufficient (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result →\n  sumList (List.take (result + 1) (arr.sort)) ≥ n :=\nsorry\n\ntheorem minimum_steps_sum_necessary (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n ≠ none) :\n  ∀ result, minimum_steps arr n = some result →\n  result > 0 → sumList (List.take result (arr.sort)) < n :=\nsorry\n\ntheorem minimum_steps_sort_invariant (arr : List Nat) (n : Nat) :\n  minimum_steps (arr.sort) n = minimum_steps arr n :=\nsorry\n\ntheorem minimum_steps_single_element_target_le (x : Nat) (n : Nat) :\n  n ≤ x → minimum_steps [x] n = some 0 :=\nsorry\n\ntheorem minimum_steps_first_element_sufficient (x y z : Nat) :\n  minimum_steps [x, y, z] y = some 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [4, 6, 3] 7\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [10, 9, 9, 8] 17\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval minimum_steps [8, 9, 10, 4, 2] 23"}
{"id": "fvapps_004172", "vc-description": "/-\nIn this Kata, we will check if a string contains consecutive letters as they appear in the English alphabet and if each letter occurs only once. \n\n```Haskell\nRules are: (1) the letters are adjacent in the English alphabet, and (2) each letter occurs only once.\n\nFor example: \nsolve(\"abc\") = True, because it contains a,b,c\nsolve(\"abd\") = False, because a, b, d are not consecutive/adjacent in the alphabet, and c is missing.\nsolve(\"dabc\") = True, because it contains a, b, c, d\nsolve(\"abbc\") = False, because b does not occur once.\nsolve(\"v\") = True\n```\nAll inputs will be lowercase letters. \n\nMore examples in test cases. Good luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Bool :=\n  sorry\n\ndef eraseDuplicates (xs : List α) : List α :=\n  sorry\n\ndef sortList (xs : List α) : List α :=\n  sorry", "vc-theorems": "theorem solve_valid_string_properties (s : String) :\n  solve s →\n  (s.length : Nat) = (eraseDuplicates s.toList).length ∧\n  sortList (s.toList.map Char.toLower) = s.toList := by\n  sorry\n\ntheorem solve_invalid_chars (s : String) :\n  s.toList.all (λ c => ¬c.isLower) →\n  ¬(solve s) := by\n  sorry\n\ntheorem solve_duplicates (s : String) :\n  s.length > 0 →\n  ¬(solve (s ++ s)) := by\n  sorry\n\ntheorem solve_empty :\n  ¬(solve \"\") := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abc\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abd\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"dabc\""}
{"id": "fvapps_004175", "vc-description": "/-\n# Palindrome strings\n\nA palindrome is a word, phrase, number, or other sequence of characters which reads the same backward or forward. This includes capital letters, punctuation, and word dividers.\n\nImplement a function that checks if something is a palindrome.\n\n## Examples\n```\nisPalindrome(\"anna\")   ==> true\nisPalindrome(\"walter\") ==> false\nisPalindrome(12321)    ==> true\nisPalindrome(123456)   ==> false\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_palindrome (α : Type) [ToString α] (x : α) : Bool :=\n  sorry\n\ndef reverse (s : String) : String :=\n  sorry", "vc-theorems": "theorem string_palindrome_property (s : String) :\n  is_palindrome String s = (s = reverse s) :=\nsorry\n\ntheorem integer_palindrome_property (n : Int) :\n  is_palindrome Int n = (toString n = reverse (toString n)) :=\nsorry\n\ntheorem palindrome_type_invariant (s : String) :\n  is_palindrome String s = is_palindrome String (toString s) :=\nsorry\n\ntheorem empty_string_is_palindrome :\n  is_palindrome String \"\" = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"anna\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"walter\"\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome 12321"}
{"id": "fvapps_004182", "vc-description": "/-\n## Task\n\nComplete function `splitOddAndEven`, accept a number `n`(n>0), return an array that contains the continuous parts of odd or even digits.\n\nPlease don't worry about digit `0`, it won't appear ;-)\n\n## Examples\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isOdd (n : Nat) : Bool :=\n  sorry\n\ndef split_odd_and_even (n : Nat) : List Nat :=\n  sorry\n\ndef charToNat (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem split_returns_list (n : Nat) (h : n > 0) :\n  ∃ (l : List Nat), split_odd_and_even n = l\n  := by\nsorry\n\ntheorem digits_have_same_parity (n : Nat) (h : n > 0) :\n  ∀ x, x ∈ split_odd_and_even n →\n    let digits := (toString x).data\n    ∀ d, d ∈ digits →\n      ∀ h : 0 < digits.length,\n        isOdd (charToNat d) = isOdd (charToNat (digits[0]'h))\n  := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_004186", "vc-description": "/-\nConsider the prime number `23`. If we sum the square of its digits we get:\n`2^2 + 3^2 = 13`, then for `13: 1^2 + 3^2 = 10`, and finally for `10: 1^2 + 0^2 = 1`. \n\nSimilarly, if we start with prime number `7`, the sequence is: `7->49->97->130->10->1`.\n\nGiven a range, how many primes within that range will eventually end up being `1`? \n\nThe upperbound for the range is `50,000`. A range of `(2,25)` means that: `2 <= n < 25`. \n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Prime reversion](https://www.codewars.com/kata/59b46276afcda204ed000094)\n\n[Domainant primes](https://www.codewars.com/kata/59ce11ea9f0cbc8a390000ed)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef end_one (n : Nat) : Bool :=\n  sorry\n\ndef solve (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem is_prime_not_small (n : Nat) :\n  n ≤ 1 → is_prime n = false :=\nsorry\n\ntheorem is_prime_no_factors (n : Nat) :\n  is_prime n = true →\n  ∀ i : Nat, 2 ≤ i → i ≤ n^(1/2) → n % i ≠ 0 :=\nsorry\n\ntheorem prime_multiplication (n : Nat) :\n  2 < n → is_prime (2*n) = false :=\nsorry\n\ntheorem end_one_is_bool (n : Nat) :\n  end_one n = true ∨ end_one n = false :=\nsorry\n\ntheorem end_one_for_one :\n  end_one 1 = true :=\nsorry\n\ntheorem end_one_special_cases (n : Nat) :\n  (n = 1 ∨ n = 10) → end_one n = true :=\nsorry\n\ntheorem solve_bounded (a b : Nat) :\n  a ≤ b →\n  0 ≤ solve a b ∧ solve a b ≤ b - a :=\nsorry\n\ntheorem solve_wrong_order (a b : Nat) :\n  b < a → solve a b = 0 :=\nsorry\n\ntheorem solve_unit_range (n : Nat) :\n  solve n (n+1) = 0 ∨ solve n (n+1) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 1 25\n\n/--\ninfo: 28\n-/\n#guard_msgs in\n#eval solve 100 1000\n\n/--\ninfo: 47\n-/\n#guard_msgs in\n#eval solve 100 2000"}
{"id": "fvapps_004190", "vc-description": "/-\nImplement a class/function, which should parse time expressed as `HH:MM:SS`, or `null/nil/None` otherwise.\n\nAny extra characters, or minutes/seconds higher than 59 make the input invalid, and so should return `null/nil/None`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (h : String) (m : String) (s : String) : String :=\nsorry\n\ndef isDigit (s : String) : Bool :=\nsorry\n\ndef toSeconds (s : String) : Option Nat :=\nsorry\n\ndef fromNat (n : Nat) : String :=\nsorry\n\ndef isValidTimeFormat (s : String) : Bool :=\nsorry", "vc-theorems": "theorem valid_time_conversion\n  {h : Nat} {m : Nat} {s : Nat}\n  (h_bound : h ≤ 99)\n  (m_bound : m ≤ 59)\n  (s_bound : s ≤ 59) :\n  toSeconds (toString (fromNat h) (fromNat m) (fromNat s)) = some (h * 3600 + m * 60 + s) :=\nsorry\n\ntheorem invalid_format_returns_none\n  (s : String)\n  (h_invalid : ¬(isValidTimeFormat s)) :\n  toSeconds s = none :=\nsorry\n\ntheorem invalid_hours\n  (h m s : String)\n  (h_invalid : h.toNat? = some (Nat.succ 99)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem invalid_minutes\n  (h m s : String)\n  (m_invalid : m.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem invalid_seconds\n  (h m s : String)\n  (s_invalid : s.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :=\nsorry\n\ntheorem missing_components_none\n  (s : String)\n  (h_missing : ¬(isValidTimeFormat s)) :\n  toSeconds s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval to_seconds \"00:00:00\"\n\n/--\ninfo: 3723\n-/\n#guard_msgs in\n#eval to_seconds \"01:02:03\"\n\n/--\ninfo: 359999\n-/\n#guard_msgs in\n#eval to_seconds \"99:59:59\""}
{"id": "fvapps_004191", "vc-description": "/-\nWelcome\n\nThis kata is inspired by This Kata\n\nWe have a string s\n\nWe have a number n\n\nHere is a function that takes your string, concatenates the even-indexed chars to the front, odd-indexed chars to the back.\n\nExamples\n\n    s = \"Wow Example!\"\n    result = \"WwEapeo xml!\"\n    s = \"I'm JomoPipi\"\n    result = \"ImJm ii' ooPp\"\n\nThe Task:\n\nreturn the result of the string after applying the function to it n times.\n\nexample where s = \"qwertyuio\" and n = 2:\n\n    after 1 iteration  s = \"qetuowryi\"\n    after 2 iterations s = \"qtorieuwy\"\n    return \"qtorieuwy\"\n\n Note \n\nthere's a lot of tests, big strings,\nand n is greater than a billion\n\nso be ready to optimize.\n\nafter doing this: do it's best friend!\n\n# Check out my other kata!\n\nMatrix Diagonal Sort OMG\nString -> N iterations -> String\nString -> X iterations -> String\nANTISTRING\nArray - squareUp b!\nMatrix - squareUp b!\nInfinitely Nested Radical Expressions\npipi Numbers!\n-/", "vc-preamble": "def isSameChars (s₁ s₂ : String) : Prop :=\n  ∀ c : Char, (s₁.data.countP (· = c)) = (s₂.data.countP (· = c))", "vc-helpers": "", "vc-definitions": "def jumbledString (s : String) (n : Int) : String :=\nsorry", "vc-theorems": "theorem jumbledString_length_preserved (s : String) (n : Int) (h : s.length > 0) :\n  (jumbledString s n).length = s.length :=\nsorry\n\ntheorem jumbledString_same_chars (s : String) (n : Int) (h : s.length > 0) :\n  isSameChars s (jumbledString s n) :=\nsorry\n\ntheorem jumbledString_periodic (s : String) (n : Int) (h : s.length > 0) :\n  ∃ k : Nat, k > 0 ∧\n  jumbledString s n = jumbledString s (n % k) :=\nsorry\n\ntheorem jumbledString_empty_or_singleton (s : String) (n : Int) :\n  s.length ≤ 1 → jumbledString s n = s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Sc o!uhWw'\n-/\n#guard_msgs in\n#eval jumbled_string \"Such Wow!\" 1\n\n/--\ninfo: 'bexltept merae'\n-/\n#guard_msgs in\n#eval jumbled_string \"better example\" 2\n\n/--\ninfo: 'qtorieuwy'\n-/\n#guard_msgs in\n#eval jumbled_string \"qwertyuio\" 2"}
{"id": "fvapps_004196", "vc-description": "/-\n# Task\n\nGiven an array of integers, sum consecutive even numbers and consecutive odd numbers. Repeat the process while it can be done and return the length of the final array.\n\n# Example\n\nFor `arr = [2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]`\n\nThe result should be `6`.\n\n```\n[2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]  -->\n         2+2+6       0+2+0     5+5+7+7       3+3+9\n[2, 1,   10,    5,    2,        24,     4,   15   ] -->\n                               2+24+4\n[2, 1,   10,    5,             30,           15   ]\nThe length of final array is 6\n```\n\n# Input/Output\n\n- `[input]` integer array `arr`\n\n  A non-empty array, \n\n  `1 ≤ arr.length ≤ 1000`\n\n  `0 ≤ arr[i] ≤ 1000`\n\n- `[output]` an integer\n\n  The length of the final array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumGroups (arr : List Int) : Int :=\nsorry\n\ndef getNextArr (arr : List Int) : List Int :=\nsorry\n\ndef countAlternatingParity (arr : List Int) : Nat :=\nsorry", "vc-theorems": "theorem sum_groups_returns_positive :\n  ∀ (arr : List Int), arr ≠ [] → 0 < sumGroups arr :=\nsorry\n\ntheorem sum_groups_alternating_parity_bound :\n  ∀ (arr : List Int), arr ≠ [] →\n  sumGroups arr ≤ countAlternatingParity arr :=\nsorry\n\ntheorem sum_groups_monotonic_reduction :\n  ∀ (arr : List Int), arr ≠ [] →\n  ∀ (next : List Int), next = getNextArr arr →\n  next ≠ arr →\n  List.length next ≤ List.length arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 3, 3, 3, 9, 2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_groups [1, 1, 2, 2]"}
{"id": "fvapps_004204", "vc-description": "/-\nSimilarly to the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-i/), you will need to return a boolean value if the base string can be expressed as the repetition of one subpattern.\n\nThis time there are two small changes:\n\n* if a subpattern has been used, it will be repeated at least twice, meaning the subpattern has to be shorter than the original string;\n* the strings you will be given might or might not be created repeating a given subpattern, then shuffling the result.\n\nFor example:\n\n```python\nhas_subpattern(\"a\") == False #no repeated shorter sub-pattern, just one character\nhas_subpattern(\"aaaa\") == True #just one character repeated\nhas_subpattern(\"abcd\") == False #no repetitions\nhas_subpattern(\"babababababababa\") == True #repeated \"ba\"\nhas_subpattern(\"bbabbaaabbaaaabb\") == True #same as above, just shuffled\n```\nStrings will never be empty and can be composed of any character (just consider upper- and lowercase letters as different entities) and can be pretty long (keep an eye on performances!).\n\nIf you liked it, go for either the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-i/) or the [next kata](https://www.codewars.com/kata/string-subpattern-recognition-iii/) of the series!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def has_subpattern (s : String) : Bool :=\n  sorry\n\ndef gcd (a b : Nat) : Nat :=\n  sorry\n\ndef reduce (f : Nat → Nat → Nat) (xs : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_char_string_property (s : String) :\n  (s.length > 1 ∧ s.data.eraseDups.length = 1) → has_subpattern s\n  ∧\n  (s.length = 1) → ¬has_subpattern s :=\nsorry\n\ntheorem repeat_property (s : String) :\n  s.length ≥ 2 →\n  has_subpattern s →\n  has_subpattern (s ++ s) ∧ has_subpattern (s ++ s ++ s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004208", "vc-description": "/-\n# Task\n\nFind the integer from `a` to `b` (included) with the greatest number of divisors. For example:\n\n```\ndivNum(15, 30)   ==> 24\ndivNum(1, 2)     ==> 2\ndivNum(0, 0)     ==> 0\ndivNum(52, 156)  ==> 120\n```\n\nIf there are several numbers that have the same (maximum) number of divisors, the smallest among them should be returned. Return the string `\"Error\"` if `a > b`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countDivisors (n : Nat) : Nat :=\n  sorry\n\ndef divNum (a b : Nat) : Option Nat :=\n  sorry", "vc-theorems": "theorem divNum_invalid_range {a b : Nat} (h : a > b) :\n  divNum a b = none :=\nsorry\n\ntheorem divNum_result_in_range {a b : Nat} (h : a ≤ b) (result : Nat) :\n  divNum a b = some result → a ≤ result ∧ result ≤ b :=\nsorry\n\ntheorem divNum_max_divisors {a b result : Nat} (h : a ≤ b) :\n  divNum a b = some result →\n  ∀ x, a ≤ x ∧ x ≤ b → countDivisors x ≤ countDivisors result :=\nsorry\n\ntheorem divNum_equal_inputs (x : Nat) :\n  divNum x x = some x :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 24\n-/\n#guard_msgs in\n#eval div_num 15 30\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval div_num 1 2\n\n/--\ninfo: 'Error'\n-/\n#guard_msgs in\n#eval div_num 159 4"}
{"id": "fvapps_004215", "vc-description": "/-\n# Task\n Consider a string of lowercase Latin letters and space characters (\" \"). \n\n First, rearrange the letters in each word `alphabetically`. \n\n And then rearrange the words in ascending order of the sum of their characters' `ASCII` values. \n\n If two or more words have the same `ASCII` value, rearrange them by their length in ascending order; If their length still equals to each other, rearrange them `alphabetically`.\n\n Finally, return the result.\n\n# Example\n\n For `s = \"batman is bruce wayne\"`, the result should be `\"is bceru aenwy aamntb\"`.\n``` \nAfter rearranging the letters the string turns into\n\"aamntb is bceru aenwy\".\nThe ASCII values of each word are: [627, 220, 529, 548].\nAfter sorting the words the following string is obtained:\n\"is bceru aenwy aamntb\" (with ASCII values of [220, 529, 548, 627]).```\n\n For `s = \"peter parker is spiderman\"`, the result should be `\"is eeprt aekprr adeimnprs\"`\n\n `(ASCII values: [220, 554, 645, 963])`\n\n# Input/Output\n\n - `[input]` string `s`\n\n  A string of lowercase words. Each word is separated by exactly one space character.\n\n - `[output]` a string\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def revamp (s : String) : String :=\nsorry\n\ndef sumChars (s : String) : Nat :=\nsorry\n\ndef sortString (s : String) : String :=\nsorry", "vc-theorems": "theorem output_has_same_word_count (s : String) :\n  (String.split (revamp s) (· = ' ')).length = (String.split s (· = ' ')).length :=\nsorry\n\ntheorem words_internally_sorted (s : String) :\n  let result := String.split (revamp s) (· = ' ')\n  ∀ word, word ∈ result →\n    word = sortString word :=\nsorry\n\ntheorem empty_string :\n  revamp \"\" = \"\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004218", "vc-description": "/-\nCreate the function ```consecutive(arr)``` that takes an array of integers and return the minimum number of integers needed to make the contents of ```arr``` consecutive from the lowest number to the highest number.\nFor example:  If ```arr``` contains [4, 8, 6] then the output should be 2 because two numbers need to be added to the array (5 and 7) to make it a consecutive array of numbers from 4 to 8. Numbers in ```arr``` will be unique.\n-/\n\n-- Helper function to find maximum in list\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n-- Helper function to find minimum in list", "vc-preamble": "def listMax : List Int → Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)\n\ndef listMin : List Int → Int\n  | [] => 0\n  | (x::xs) => min x (listMin xs)", "vc-helpers": "", "vc-definitions": "def consecutive (lst : List Int) : Int :=\nsorry", "vc-theorems": "theorem consecutive_empty : consecutive [] = 0 :=\nsorry\n\ntheorem consecutive_property {lst : List Int} (h : lst ≠ []) :\n  consecutive lst = listMax lst - listMin lst + 1 - lst.length :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004221", "vc-description": "/-\nPrior to having fancy iPhones, teenagers would wear out their thumbs sending SMS\nmessages on candybar-shaped feature phones with 3x4 numeric keypads.\n\n    ------- ------- -------\n    |     | | ABC | | DEF |\n    |  1  | |  2  | |  3  |\n    ------- ------- -------\n    ------- ------- -------\n    | GHI | | JKL | | MNO |\n    |  4  | |  5  | |  6  |\n    ------- ------- -------\n    ------- ------- -------\n    |PQRS | | TUV | | WXYZ|\n    |  7  | |  8  | |  9  |\n    ------- ------- -------\n    ------- ------- -------\n    |     | |space| |     |\n    |  *  | |  0  | |  #  |\n    ------- ------- -------\n\nPrior to the development of T9 (predictive text entry) systems, the method to\ntype words was called \"multi-tap\" and involved pressing a button repeatedly to\ncycle through the possible values.\n\nFor example, to type a letter `\"R\"` you would press the `7` key three times (as\nthe screen display for the current character cycles through `P->Q->R->S->7`).  A\ncharacter is \"locked in\" once the user presses a different key or pauses for a\nshort period of time (thus, no extra button presses are required beyond what is\nneeded for each letter individually). The zero key handles spaces, with one press of the key producing a space and two presses producing a zero.\n\nIn order to send the message `\"WHERE DO U WANT 2 MEET L8R\"` a teen would have to\nactually do 47 button presses.  No wonder they abbreviated.\n\nFor this assignment, write a module that can calculate the amount of button\npresses required for any phrase. Punctuation can be ignored for this exercise. Likewise, you can assume the phone doesn't distinguish between upper/lowercase characters (but you should allow your module to accept input in either for convenience).\n\nHint: While it wouldn't take too long to hard code the amount of keypresses for\nall 26 letters by hand, try to avoid doing so! (Imagine you work at a phone\nmanufacturer who might be testing out different keyboard layouts, and you want\nto be able to test new ones rapidly.)\n-/\n\n/- For any string made up of valid keypad characters, the number of presses\n    should be at least the length of the string, and each character should\n    be present in one of the buttons -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The number of presses required should be the same regardless of case -/\n\n/- For strings containing only numbers and spaces, the number of presses\n    should be at least the length of the string -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BUTTONS : List String :=\nsorry\n\ndef presses (s : String) : Nat :=\nsorry", "vc-theorems": "theorem keypad_chars_valid (s : String) :\n  (∀ c ∈ s.data, ∃ button ∈ BUTTONS, c ∈ button.data) →\n  presses s ≥ s.length :=\nsorry\n\ntheorem case_insensitive (button : String) :\n  button ∈ BUTTONS →\n  presses button.toUpper = presses button.toLower :=\nsorry\n\ntheorem numeric_and_space_presses (s : String) :\n  (∀ c ∈ s.data, c ∈ [' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) →\n  presses s ≥ s.length :=\nsorry", "vc-postamble": "/--\ninfo: 9\n-/\n#guard_msgs in\n#eval presses \"LOL\"\n\n/--\ninfo: 13\n-/\n#guard_msgs in\n#eval presses \"HOW R U\"\n\n/--\ninfo: 47\n-/\n#guard_msgs in\n#eval presses \"WHERE DO U WANT 2 MEET L8R\""}
{"id": "fvapps_004222", "vc-description": "/-\nConsider integer coordinates x, y in the Cartesian plan and three functions f, g, h\ndefined by:\n```\nf: 1 <= x <= n, 1 <= y <= n --> f(x, y) = min(x, y)\ng: 1 <= x <= n, 1 <= y <= n --> g(x, y) = max(x, y)\nh: 1 <= x <= n, 1 <= y <= n --> h(x, y) = x + y\n``` \nwhere n is a given integer (n >= 1, guaranteed) and x, y are integers.\n\nIn the table below you can see the value of the function f with n = 6.\n\n  ---|*0* |*1*|*2*|*3*|*4*|*5*|*6*|\n  -- |--|--|--|--|--|--|--|\n  *6*|- |1 |2 |3 |4 |5 |6 |\n  *5*|- |1 |2 |3 |4 |5 |5 |\n  *4*|- |1 |2 |3 |4 |4 |4 |\n  *3*|- |1 |2 |3 |3 |3 |3 |\n  *2*|- |1 |2 |2 |2 |2 |2 |\n  *1*|- |1 |1 |1 |1 |1 |1 |\n  *0*|- |- |- |- |- |- |- |\n\nThe task is to calculate the sum of f(x, y), g(x, y) and h(x, y) for all integers x and y such that (1 <= x <= n, 1 <= y <= n).\n\nThe function sumin (sum of f) will take n as a parameter and return the sum of min(x, y) in the domain 1 <= x <= n, 1 <= y <= n.\nThe function sumax (sum of g) will take n as a parameter and return the sum of max(x, y) in the same domain.\nThe function sumsum (sum of h) will take n as a parameter and return the sum of x + y in the same domain.\n\n#Examples:\n```\nsumin(6) --> 91\nsumin(45) --> 31395\nsumin(999) --> 332833500\nsumin(5000) --> 41679167500\n\nsumax(6) --> 161\nsumax(45) --> 61755\nsumax(999) --> 665167500\nsumax(5000) --> 83345832500\n\nsumsum(6) --> 252\nsumsum(45) --> 93150\nsumsum(999) --> 998001000\nsumsum(5000) --> 125025000000\n```\n\n#Hint:\n1. Try to avoid nested loops\n2. Note that h = f + g\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumin (n : Nat) : Nat :=\nsorry\n\ndef sumax (n : Nat) : Nat :=\nsorry\n\ndef sumsum (n : Nat) : Nat :=\nsorry\n\ndef sumOfMins (n : Nat) : Nat :=\nsorry\n\ndef sumOfMaxs (n : Nat) : Nat :=\nsorry\n\ndef sumOfSums (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem sumax_positive (n : Nat) (h : n > 0) :\n  sumax n > 0 :=\nsorry\n\ntheorem sumsum_equals_sumin_plus_sumax (n : Nat) :\n  sumsum n = sumin n + sumax n :=\nsorry\n\ntheorem sumin_positive (n : Nat) (h : n > 0) :\n  sumin n > 0 :=\nsorry\n\ntheorem sumin_le_sumax (n : Nat) :\n  sumin n ≤ sumax n :=\nsorry\n\ntheorem sumax_ge_sumin (n : Nat) :\n  sumax n ≥ sumin n :=\nsorry\n\ntheorem sumsum_positive (n : Nat) (h : n > 0) :\n  sumsum n > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 55\n-/\n#guard_msgs in\n#eval sumin 5\n\n/--\ninfo: 91\n-/\n#guard_msgs in\n#eval sumin 6\n\n/--\ninfo: 1240\n-/\n#guard_msgs in\n#eval sumin 15\n\n/--\ninfo: 161\n-/\n#guard_msgs in\n#eval sumax 6\n\n/--\ninfo: 61755\n-/\n#guard_msgs in\n#eval sumax 45\n\n/--\ninfo: 671650\n-/\n#guard_msgs in\n#eval sumax 100\n\n/--\ninfo: 252\n-/\n#guard_msgs in\n#eval sumsum 6\n\n/--\ninfo: 93150\n-/\n#guard_msgs in\n#eval sumsum 45\n\n/--\ninfo: 1010000\n-/\n#guard_msgs in\n#eval sumsum 100"}
{"id": "fvapps_004227", "vc-description": "/-\nComplete the function which returns the weekday according to the input number:\n\n* `1` returns `\"Sunday\"`\n* `2` returns `\"Monday\"`\n* `3` returns `\"Tuesday\"`\n* `4` returns `\"Wednesday\"`\n* `5` returns `\"Thursday\"`\n* `6` returns `\"Friday\"`\n* `7` returns `\"Saturday\"`\n* Otherwise returns `\"Wrong, please enter a number between 1 and 7\"`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def WEEKDAY : Nat → String :=\nsorry\n\ndef ERROR : String :=\nsorry\n\ndef whatday (n : Int) : String :=\nsorry", "vc-theorems": "theorem whatday_spec (n : Int) :\n  (1 ≤ n ∧ n ≤ 7 → ∃ (i : Nat), whatday n = WEEKDAY i) ∧\n  (¬(1 ≤ n ∧ n ≤ 7) → whatday n = ERROR) :=\nsorry\n\ntheorem valid_weekday (n : Int) (h : 1 ≤ n ∧ n ≤ 7) :\n  ∃ (i : Nat), whatday n = WEEKDAY i :=\nsorry\n\ntheorem invalid_weekday (n : Int) (h : ¬(1 ≤ n ∧ n ≤ 7)) :\n  whatday n = ERROR :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Sunday'\n-/\n#guard_msgs in\n#eval whatday 1\n\n/--\ninfo: 'Saturday'\n-/\n#guard_msgs in\n#eval whatday 7\n\n/--\ninfo: ERROR\n-/\n#guard_msgs in\n#eval whatday 0"}
{"id": "fvapps_004235", "vc-description": "/-\n## Task\n\nGiven a positive integer as input, return the output as a string in the following format: \n\nEach element, corresponding to a digit of the number, multiplied by a power of 10 in such a way that with the sum of these elements you can obtain the original number.\n\n## Examples\n\nInput | Output\n---   | ---\n0     | \"\"\n56    | \"5\\*10+6\"\n60    | \"6\\*10\"\n999   | \"9\\*100+9\\*10+9\"\n10004 | \"1\\*10000+4\"\n\nNote: `input >= 0`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def splitString (s : String) (sep : String) : List String :=\nsorry\n\ndef containsString (s : String) (sub : String) : Bool :=\nsorry\n\ndef startsWithString (s : String) (pre : String) : Bool :=\nsorry\n\ndef simplify (n : Nat) : String :=\nsorry", "vc-theorems": "theorem simplify_zero :\n  simplify 0 = \"\" :=\nsorry\n\ntheorem simplify_format_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  terms.length > 0 :=\nsorry\n\ntheorem simplify_terms_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  ∀ t ∈ terms,\n    (containsString t \"*\" ∧\n     let parts := splitString t \"*\"\n     parts.length = 2 ∧\n     let digit := parts[0]!\n     let power := parts[1]!\n     startsWithString power \"10\" ∧\n     let digitNum := digit.toNat!\n     1 ≤ digitNum ∧ digitNum ≤ 9)\n    ∨\n    (¬containsString t \"*\" ∧\n     t.all Char.isDigit ∧\n     let termNum := t.toNat!\n     1 ≤ termNum ∧ termNum ≤ 9) :=\nsorry\n\ntheorem simplify_sums_to_input (n : Nat) :\n  let terms := splitString (simplify n) \"+\"\n  terms.foldl\n    (fun acc t =>\n      if containsString t \"*\" then\n        let parts := splitString t \"*\"\n        acc + parts[0]!.toNat! * parts[1]!.toNat!\n      else\n        acc + t.toNat!)\n    0\n  = n :=\nsorry\n\ntheorem simplify_no_leading_zeros (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  ∀ t ∈ terms, ¬startsWithString t \"0\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '5*10+6'\n-/\n#guard_msgs in\n#eval simplify 56\n\n/--\ninfo: '9*100+9*10+9'\n-/\n#guard_msgs in\n#eval simplify 999\n\n/--\ninfo: '1*10000+4'\n-/\n#guard_msgs in\n#eval simplify 10004"}
{"id": "fvapps_004242", "vc-description": "/-\nFind the closest prime number under a certain integer ```n``` that has the maximum possible amount of even digits.\n\nFor ```n = 1000```, the highest prime under ```1000``` is ```887```, having two even digits (8 twice)\n\nNaming ```f()```, the function that gives that prime, the above case and others will be like the following below.\n```\nf(1000) ---> 887 (even digits: 8, 8)\n\nf(1210) ---> 1201 (even digits: 2, 0)\n\nf(10000) ---> 8887\n\nf(500) ---> 487\n\nf(487) ---> 467\n``` \nFeatures of the random tests:\n```\nNumber of tests = 28\n1000 <= n <= 5000000\n```\n\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f (n : Int) : Int :=\n  sorry\n\ndef is_prime (n : Int) : Bool :=\n  sorry\n\ndef count_even_digits (n : Int) : Nat :=\n  sorry", "vc-theorems": "theorem f_result_is_prime (n : Int) (h : n ≥ 2) :\n  is_prime (f n) = true ∨ f n = 0 :=\nsorry\n\ntheorem f_result_less_than_input (n : Int) (h : n ≥ 2) :\n  f n ≤ n :=\nsorry\n\ntheorem f_result_has_max_even_digits (n : Int) (h : n ≥ 2) :\n  f n ≠ 0 →\n  ∀ i : Int, 2 ≤ i → i ≤ n → is_prime i = true →\n  count_even_digits i ≤ count_even_digits (f n) :=\nsorry\n\ntheorem f_result_largest_for_same_even_digits (n : Int) (h : n ≥ 2) :\n  f n ≠ 0 →\n  ∀ i : Int, f n < i → i ≤ n → is_prime i = true →\n  count_even_digits i = count_even_digits (f n) → False :=\nsorry\n\ntheorem f_small_inputs (n : Int) (h : n ≤ 1) :\n  f n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 887\n-/\n#guard_msgs in\n#eval f 1000\n\n/--\ninfo: 8887\n-/\n#guard_msgs in\n#eval f 10000\n\n/--\ninfo: 487\n-/\n#guard_msgs in\n#eval f 500"}
{"id": "fvapps_004251", "vc-description": "/-\nYou task is to implement an simple interpreter for the notorious esoteric language [HQ9+](https://esolangs.org/wiki/HQ9+) that will work for a single character input:\n\n- If the input is `'H'`, return `'Hello World!'`\n- If the input is `'Q'`, return the input\n- If the input is `'9'`, return the full lyrics of [99 Bottles of Beer](http://www.99-bottles-of-beer.net/lyrics.html). It should be formatted like this:\n\n```if:rust\n__Note__: In Rust, return `Some` containing the appropriate value.\n```\n\n```\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n97 bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n...\n...\n...\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n1 bottle of beer on the wall, 1 bottle of beer.\nTake one down and pass it around, no more bottles of beer on the wall.\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n```\n\n- For everything else, don't return anything (return `null` in C#, `None` in Rust).\n\n(`+` has no visible effects so we can safely ignore it.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def HQ9 (s : String) : Option String :=\n  sorry\n\ndef contains (haystack needle : String) : Bool :=\n  sorry\n\ndef count (haystack needle : String) : Nat :=\n  sorry", "vc-theorems": "theorem hq9_invalid_none :\n  HQ9 \"\" = none ∧ HQ9 \" \" = none :=\nsorry\n\ntheorem h_returns_hello :\n  HQ9 \"H\" = some \"Hello World!\" :=\nsorry\n\ntheorem q_returns_q :\n  HQ9 \"Q\" = some \"Q\" :=\nsorry\n\ntheorem nine_returns_song (result : String) :\n  HQ9 \"9\" = some result →\n  contains result \"99 bottles of beer\" = true ∧\n  contains result \"1 bottle of beer\" = true ∧\n  contains (String.toLower result) \"no more bottles of beer\" = true ∧\n  count result \"of beer\" ≥ 190 ∧\n  count result \"\\n\" ≥ 99 :=\nsorry\n\ntheorem non_hq9_returns_none (s : String) :\n  s ≠ \"H\" → s ≠ \"Q\" → s ≠ \"9\" →\n  HQ9 s = none :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval HQ9 \"X\"\n\n/--\ninfo: 'Hello World!'\n-/\n#guard_msgs in\n#eval HQ9 \"H\"\n\n/--\ninfo: 'Q'\n-/\n#guard_msgs in\n#eval HQ9 \"Q\""}
{"id": "fvapps_004270", "vc-description": "/-\nShare price\n===========\n\nYou spent all your saved money to buy some shares.\n\nYou bought it for `invested`, and want to know how much it's worth, but all the info you can quickly get are just the change the shares price made in percentages.\n\nYour task:\n----------\nWrite the function `sharePrice()` that calculates, and returns the current price of your share, given the following two arguments:\n\n- `invested`(number), the amount of money you initially invested in the given share\n\n- `changes`(array of numbers), contains your shares daily movement percentages\n\nThe returned number, should be in string format, and it's precision should be fixed at 2 decimal numbers.\n\nHave fun!\n\n>**Hint:** Try to write the function in a functional manner!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def share_price (invested : Float) (changes : List Float) : String :=\n  sorry\n\ndef parseFloat? (s : String) : Option Float :=\n  sorry", "vc-theorems": "theorem share_price_valid_format {invested : Float} {changes : List Float}\n  (h1 : invested > 0)\n  (h2 : ∀ c ∈ changes, c ≥ -99.99 ∧ c ≤ 1000) :\n  ∃ p d,\n    share_price invested changes = p ++ \".\" ++ d ∧\n    d.length = 2 ∧\n    (parseFloat? (share_price invested changes)).isSome ∧\n    ∃ x, parseFloat? (share_price invested changes) = some x ∧ x ≥ 0 :=\nsorry\n\ntheorem share_price_empty_changes {invested : Float}\n  (h : invested > 0) :\n  share_price invested [] = toString invested ++ \".\" ++ \"00\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '100.00'\n-/\n#guard_msgs in\n#eval share_price 100 []\n\n/--\ninfo: '75.00'\n-/\n#guard_msgs in\n#eval share_price 100 [-50, 50]\n\n/--\ninfo: '1113.64'\n-/\n#guard_msgs in\n#eval share_price 1000 [0, 2, 3, 6]"}
{"id": "fvapps_004275", "vc-description": "/-\nYour task is to validate rhythm with a meter.\n\n_________________________________________________\nRules:\n\n1. Rhythmic division requires that in one whole note (1) there are two half notes (2) or four quarter notes (4) or eight eighth notes (8). \nExamples: 1 = 2 + 2, 1 = 4 + 4 + 4 + 4 ... \nNote that: 2 = 4 + 4, 4 = 8 + 8, 2 = 8 + 8 + 4 ... \n\n2. Meter gives an information how many rhythmic types of notes should be in one bar. Bar is the the primary section of a musical score.\nExamples: \n          4/4 -> 4 quarter notes in a bar\n          5/2 -> 5 half notes in a bar\n          3/8 -> 3 eighth notes in a bar\nNote that: \nfor 4/4 valid bars are: '4444', '88888888', '2488' ...\nfor 5/2 valid bars are: '22222', '2244244', '8888244888844' ...\nfor 3/8 valid bars are: '888', '48' ...\n\n3. Anacrusis occurs when all bars but the first and last are valid, and the notes in the first and last bars when combined would also make a valid bar.\n\nExamples: \nfor 4/4 valid anacrusis is -> 44|...|44 or 88|...|888888 or 2|...|488 \nfor 5/2 valid anacrusis is -> 22|...|222 or 222|...|22 or  2244|...|244\nfor 3/8 valid anacrusis is -> 8|...|88 or 4|...|8 or 8|...|4\nNote:\nWhen anacrusis is valid but other bars in score are not -> return 'Invalid rhythm'\n________________________________________________\n\nInput:\nmeter - array: eg. [4, 4],\nscore - string, bars separated with '|': eg. '4444|8484842|888'\n\nOutput:\nstring message: 'Valid rhythm', 'Valid rhythm with anacrusis' or 'Invalid rhythm'\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For valid rhythms, internal bars should sum to the correct total -/\n\n/- Invalid meter denominators result in invalid rhythms -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPowerOfTwo (n : Nat) : Bool :=\n  sorry\n\ndef validateRhythm (meter : List Nat) (score : String) : String :=\n  sorry", "vc-theorems": "theorem validate_rhythm_result_options (meter : List Nat) (score : String) :\n  let result := validateRhythm meter score;\n  result = \"Valid rhythm\" ∨ result = \"Valid rhythm with anacrusis\" ∨ result = \"Invalid rhythm\" :=\nsorry\n\ntheorem validate_rhythm_valid_bars_sum (meter : List Nat) (score : String)\n  (h1 : meter.length = 2) (h2 : meter[0]! > 0) (h3 : meter[1]! > 0)\n  (h4 : let result := validateRhythm meter score;\n        result = \"Valid rhythm\" ∨ result = \"Valid rhythm with anacrusis\") :\n  let bars := score.splitOn \"|\";\n  ∀ bar ∈ bars.tail.dropLast, bar ≠ \"\" →\n  ∃ barSum target : Nat,\n    barSum = target ∧ target = meter[0]! / meter[1]! :=\nsorry\n\ntheorem validate_rhythm_invalid_meter_denom (meter : List Nat)\n  (h1 : meter.length = 2)\n  (h2 : meter[1]! > 0)\n  (h3 : ¬(IsPowerOfTwo meter[1]!)) :\n  validateRhythm meter \"4|4\" = \"Invalid rhythm\" :=\nsorry", "vc-postamble": "/--\ninfo: 'Invalid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [4, 4] \"4444|8484842|888\"\n\n/--\ninfo: 'Valid rhythm with anacrusis'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 4] \"4|44|88\"\n\n/--\ninfo: 'Valid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 2] \"22|22|22\""}
{"id": "fvapps_004288", "vc-description": "/-\nIn this Kata, you will be given an integer `n` and your task will be to return `the largest integer that is <= n and has the highest digit sum`.\n\nFor example:\n```\nsolve(100) = 99. Digit Sum for 99 = 9 + 9 = 18. No other number <= 100 has a higher digit sum.\nsolve(10) = 9\nsolve(48) = 48. Note that 39 is also an option, but 48 is larger.\n```\n\nInput range is `0 < n < 1e11`\n\nMore examples in the test cases.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\n  sorry\n\ndef sumOfDigits (n : Nat) : Nat :=\n  sorry\n\ndef isPowerOfTen (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem solve_result_bounded (n : Nat) (h : n > 0) :\n  let result := solve n\n  result ≥ 0 ∧ result ≤ n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 99\n-/\n#guard_msgs in\n#eval solve 100\n\n/--\ninfo: 48\n-/\n#guard_msgs in\n#eval solve 48\n\n/--\ninfo: 999\n-/\n#guard_msgs in\n#eval solve 1000"}
{"id": "fvapps_004289", "vc-description": "/-\nA number is simply made up of digits.  \nThe number 1256 is made up of the digits 1, 2, 5, and 6.  \nFor 1256 there are 24 distinct permutations of the digits:  \n1256, 1265, 1625, 1652, 1562, 1526, 2156, 2165, 2615, 2651, 2561, 2516,   \n5126, 5162, 5216, 5261, 5621, 5612, 6125, 6152, 6251, 6215, 6521, 6512.\n\nYour goal is to write a program that takes a number, n, and returns the average value of all distinct permutations of the digits in n.  Your answer should be rounded to the nearest integer. For the example above the return value would be 3889. * \n\n  n will never be negative\n\nA few examples:\n```python\npermutation_average(2)\nreturn 2\n\npermutation_average(25)\n>>> 25 + 52 = 77\n>>> 77 / 2 = 38.5\nreturn 39 *\n\npermutation_average(20)\n>>> 20 + 02 = 22\n>>> 22 / 2 = 11\nreturn 11\n\npermutation_average(737)\n>>> 737 + 377 + 773 = 1887\n>>> 1887 / 3 = 629\nreturn 629\n\n```\n\nNote: Your program should be able to handle numbers up to 6 digits long\n~~~if:python\n\\* Python version 3 and above uses Banker Rounding so the expected values for those tests would be 3888 and 38 respectively\n~~~\n~~~if-not:python\n\\* ignore these marks, they're for Python only\n~~~\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def permutation_average (n : Int) : Int :=\n  sorry\n\ndef permutation_average_str (s : String) : Int :=\n  sorry", "vc-theorems": "theorem permutation_average_returns_integer (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 999) :\n  ∃ i : Int, permutation_average n = i := by\n  sorry\n\ntheorem string_int_equivalent (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 999) :\n  permutation_average n = permutation_average_str (toString n) := by\n  sorry\n\ntheorem leading_zeros_valid (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 99) :\n  ∃ i : Int, permutation_average_str (\"0\" ++ toString n) = i := by\n  sorry\n\ntheorem result_within_bounds (n : Int)\n  (h : 10 ≤ n ∧ n ≤ 999) :\n  permutation_average n ≥ 0 ∧ permutation_average n ≤ n := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval permutation_average 2\n\n/--\ninfo: 38\n-/\n#guard_msgs in\n#eval permutation_average 25\n\n/--\ninfo: 629\n-/\n#guard_msgs in\n#eval permutation_average 737"}
{"id": "fvapps_004306", "vc-description": "/-\nWhy would we want to stop to only 50 shades of grey? Let's see to how many we can go. \n\nWrite a function that takes a number n as a parameter and return an array containing n shades of grey in hexadecimal code (`#aaaaaa` for example). The array should be sorted in ascending order starting with `#010101`, `#020202`, etc. (using lower case letters).\n\n```python\ndef shades_of_grey(n):\n  return '''n shades of grey in an array'''\n```\n\nAs a reminder, the grey color is composed by the same number of red, green and blue: `#010101`, `#aeaeae`, `#555555`, etc. Also, `#000000` and `#ffffff` are not accepted values.\n\nWhen n is negative, just return an empty array.\nIf n is higher than 254, just return an array of 254 elements.\n\nHave fun\n-/\n\n/- Each output is a valid list of strings where each string is a valid hex color -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Non-positive inputs return empty list -/\n\n/- Output length is constrained between 0 and min(n, 254) -/\n\n/- Values are monotonically increasing -/\n\n/- RGB components are equal for each color -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidHexColor (color : String) : Bool :=\nsorry\n\ndef shadesOfGrey (n : Int) : List String :=\nsorry", "vc-theorems": "theorem shadesOfGrey_outputs_valid_list (n : Int) :\n  ∀ x ∈ shadesOfGrey n, isValidHexColor x :=\nsorry\n\ntheorem nonpositive_input_returns_empty {n : Int} (h : n ≤ 0) :\n  shadesOfGrey n = [] :=\nsorry\n\ntheorem output_length_constraints (n : Int) :\n  List.length (shadesOfGrey n) = min (max 0 n) 254 :=\nsorry\n\ntheorem values_monotonic_increasing {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 254) :\n  let result := shadesOfGrey n\n  let values := result.map (fun color => (color.take 3).toNat!)\n  ∀ i j, i < j → j < values.length → values[i]! < values[j]! :=\nsorry\n\ntheorem rgb_components_equal {n : Int} (h1 : 1 ≤ n) (h2 : n ≤ 254) :\n  let result := shadesOfGrey n\n  ∀ color ∈ result,\n    color.get! ⟨1⟩ = color.get! ⟨3⟩ ∧\n    color.get! ⟨3⟩ = color.get! ⟨5⟩ :=\nsorry", "vc-postamble": "/--\ninfo: []\n-/\n#guard_msgs in\n#eval shades_of_grey -1\n\n/--\ninfo: ['#010101']\n-/\n#guard_msgs in\n#eval shades_of_grey 1\n\n/--\ninfo: ['#010101', '#020202', '#030303']\n-/\n#guard_msgs in\n#eval shades_of_grey 3"}
{"id": "fvapps_004308", "vc-description": "/-\nCreate your own mechanical dartboard that gives back your score based on the coordinates of your dart.\n\nTask:\n\nUse the scoring rules for a standard dartboard:\n\nFinish method:\n\n```python\ndef get_score(x,y):\n```\n\nThe coordinates are `(x, y)` are always relative to the center of the board (0, 0). The unit is millimeters. If you throw your dart 5 centimeters to the left and 3 centimeters below, it is written as:\n\n```python\nscore = get_score(-50, -30)\n```\n\nPossible scores are:Outside of the board: `\"X\"`Bull's eye: `\"DB\"`Bull: `\"SB\"`A single number, example: `\"10\"`A triple number: `\"T10\"`A double number: `\"D10\"`\nA throw that ends exactly on the border of two sections results in a bounce out. You can ignore this because all the given coordinates of the tests are within the sections.\nThe diameters of the circles on the dartboard are:Bull's eye: `12.70 mm`Bull: `31.8 mm`Triple ring inner circle: `198 mm`Triple ring outer circle: `214 mm`Double ring inner circle: `324 mm`Double ring outer circle: `340 mm`\n\nIf you liked this kata, you can continue with: Let's Play Darts: Beat The Power!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def distance (x y : Float) : Float :=\n  sorry\n\ndef angle (x y : Float) : Float :=\n  sorry\n\ndef get_score (x y : Float) : String :=\n  sorry\n\ndef ValidScores : List String :=\n  sorry", "vc-theorems": "theorem get_score_returns_valid : ∀ x y : Float, x ≥ -200 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 →\n  get_score x y ∈ ValidScores :=\nsorry\n\ntheorem same_distance_angle_same_score : ∀ x y x2 y2 : Float,\n  x ≥ -200 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 ∧\n  x2 ≥ -200 ∧ x2 ≤ 200 ∧ y2 ≥ -200 ∧ y2 ≤ 200 →\n  distance x y = distance x2 y2 ∧ angle x y = angle x2 y2 →\n  get_score x y = get_score x2 y2 :=\nsorry\n\ntheorem outside_board_is_X : ∀ x y : Float,\n  x > 170.1 ∧ x ≤ 200 ∧ y ≥ -200 ∧ y ≤ 200 →\n  get_score x y = \"X\" :=\nsorry\n\ntheorem bulls_eye_region : ∀ x y : Float,\n  x ≥ -6.35 ∧ x ≤ 6.35 ∧ y ≥ -6.35 ∧ y ≤ 6.35 ∧\n  distance x y ≤ 6.35 →\n  get_score x y = \"DB\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'X'\n-/\n#guard_msgs in\n#eval get_score -133.69 -147.38\n\n/--\ninfo: 'DB'\n-/\n#guard_msgs in\n#eval get_score 4.06 0.71\n\n/--\ninfo: 'T2'\n-/\n#guard_msgs in\n#eval get_score 55.53 -87.95"}
{"id": "fvapps_004310", "vc-description": "/-\nCreate a __moreZeros__ function which will __receive a string__ for input, and __return an array__ (or null terminated string in C) containing only the characters from that string whose __binary representation of its ASCII value__ consists of _more zeros than ones_. \n\nYou should __remove any duplicate characters__, keeping the __first occurence__ of any such duplicates, so they are in the __same order__ in the final array as they first appeared in the input string.\n\nExamples\n\nAll input will be valid strings of length > 0. Leading zeros in binary should not be counted.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binary_zeros_count (c : Char) : Nat :=\n  sorry\n\ndef binary_ones_count (c : Char) : Nat :=\n  sorry\n\ndef more_zeros (s : String) : List Char :=\n  sorry", "vc-theorems": "theorem more_zeros_results_unique (s : String) :\n  let result := more_zeros s\n  (List.length result = List.length (List.eraseDups result)) ∧\n  (∀ c ∈ result, s.data.contains c) := by\n  sorry\n\ntheorem more_zeros_binary_property (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ result, binary_zeros_count c > binary_ones_count c := by\n  sorry\n\ntheorem more_zeros_inclusion_complete (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ s.data,\n    binary_zeros_count c > binary_ones_count c →\n    c ∉ result →\n    (s.data.filter (· = c)).length > 1 := by\n  sorry\n\ntheorem more_zeros_ascii_printable (s : String) :\n  let result := more_zeros s\n  ∀ c ∈ result, 32 ≤ c.toNat ∧ c.toNat ≤ 127 := by\n  sorry", "vc-postamble": ""}
{"id": "fvapps_004317", "vc-description": "/-\n# Letterss of Natac\nIn a game I just made up that doesn’t have anything to do with any other game that you may or may not have played, you collect resources on each turn and then use those resources to build things like roads, settlements and cities. If you would like to try other kata about this game, they can be found **[here](https://www.codewars.com/collections/59e6938afc3c49005900011f)**\n\n## Task\n\nThis kata asks you to implement a time efficient version of the function `play_if_enough(hand, play)` , which takes as input a `hand`, the resources you have (a string of letters representing the resources you have), and a `play`, (a string of letters representing the resources required to build a certain game object), and returns a tuple (list in r) of a boolean value, corresponding to whether you have enough resources, and your hand. If you had enough to build the object, the returned hand is your resources minus those you used to build the object. If not, it is your original hand (the one passed to the function).  \n\nFor example, if it takes 3 ore and 2 grain to build a city, `play` is `”ooogg”`. If `hand` is `”ooooogggssbbb”`, then `play_if_enough(hand, play)` returns `(True, “oogssbbb”)`. \n\n## Examples\n```python\nplay_if_enough(\"ooooogggssbbb\", \"ooogg\")  => (True, \"oogssbbb\")\nplay_if_enough(\"oogssbbb\", \"bwsg\")        => (False, \"oogssbbb\")\nplay_if_enough(\"\", \"bw\")                  => (False, \"\")\nplay_if_enough(\"abcdefghij\", \"aa\")        => (False, \"abcdefghij\")\n\n```\n## Notes: \n1. The order of resources in your hand (or play) is not relevant. You can shuffle your hand any way you'd like, so long as you have the same number of each resource.\n2. There are 26 different resources, each represented by a lower case letter a-z, so a valid hand is a string of lower case letters.\n3. A valid play is a string of any number of lower case letters.\n4. You do not have to test for whether a hand or play is valid. \n5. A hand can be empty, but a play can't. In the event a hand is empty, you don't have the cards to play, so return `(False, \"\")`, in the correct data structure for your language, see example 4 above.\n6. Tests include hand sizes of up to 150000 elements and play sizes up to 10000 elements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def play_if_enough (hand play : String) : Bool × String :=\n  sorry\n\ndef String.count (s : String) (c : Char) : Nat :=\n  sorry", "vc-theorems": "theorem play_if_enough_success_length {hand play : String} :\n  let res := play_if_enough hand play\n  res.1 → res.2.length = hand.length - play.length :=\nsorry\n\ntheorem play_if_enough_success_subset {hand play : String} {c : Char} :\n  let res := play_if_enough hand play\n  res.1 → res.2.count c ≤ hand.count c :=\nsorry\n\ntheorem play_if_enough_failure_preserves {hand play : String} :\n  let res := play_if_enough hand play\n  ¬res.1 → res.2 = hand :=\nsorry\n\ntheorem play_if_enough_empty_succeeds {hand : String} :\n  (play_if_enough hand \"\").1 = true :=\nsorry\n\ntheorem play_if_enough_too_long_fails {hand play : String} :\n  play.length > hand.length →\n  ¬(play_if_enough hand play).1 :=\nsorry\n\ntheorem play_if_enough_impossible_preserves {hand : String} :\n  let impossible := String.mk (List.replicate (hand.length + 1) 'z')\n  let res := play_if_enough hand impossible\n  ¬res.1 ∧ res.2 = hand :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: (False, '')\n-/\n#guard_msgs in\n#eval play_if_enough \"\" \"bw\"\n\n/--\ninfo: (True, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"ooooogggssbbb\" \"ooogg\"\n\n/--\ninfo: (False, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"oogssbbb\" \"bwsg\""}
{"id": "fvapps_004318", "vc-description": "/-\n# Do names have colors?\n\n*Now they do.*\n\nMake a function that takes in a name (Any string two chars or longer really, but the name is the idea) and use the ascii values of it's substrings to produce the hex value of its color! Here is how it's going to work:\n\n* The first two hexadecimal digits are the *SUM* of the value of characters (modulo 256).\n* The second two are the *PRODUCT* of all the characters (again, modulo 256, which is one more than `FF` in hexadecimal).\n* The last two are the *ABSOLUTE VALUE of the DIFFERENCE* between the first letter, and the sum of every other letter. (I think you get the idea with the modulo thing).\n\nFor example `\"Jack\"` returns `\"79CAE5\"`, which is... **baby blue!**\n```\n\"Jack\"  #  \"J\" = 74, \"a\" = 97, \"c\" = 99, \"k\" = 107\n\n74 + 97 + 99 + 107 = 377                   -->  mod 256 = 121  -->  hex: 79\n74 * 97 * 99 * 107 = 76036554              -->  mod 256 = 202  -->  hex: CA\n74 - (97 + 99 + 107) = -229  --> abs: 229  -->  mod 256 = 229  -->  hex: E5\n```\n\nNOTE: The function should return `None/nil` when the input is less than two chars.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def string_color (s : String) : Option String :=\nsorry\n\ndef hexToNat (s : String) : Nat :=\nsorry", "vc-theorems": "theorem string_color_short_strings {s : String} (h : s.length ≤ 1) :\n  string_color s = none :=\nsorry\n\ntheorem string_color_valid_ranges {s : String} (h : s.length ≥ 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    let r := hexToNat result\n    let g := hexToNat result\n    let b := hexToNat result\n    r ≤ 255 ∧ g ≤ 255 ∧ b ≤ 255 :=\nsorry\n\ntheorem string_color_longer_strings {s : String} (h : s.length ≥ 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    result.length = 6 ∧\n    (∀ c ∈ result.data, c ∈ ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']) :=\nsorry\n\ntheorem string_color_deterministic {s : String} :\n  string_color s = string_color s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"A\"\n\n/--\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"\"\n\n/--\ninfo: '79CAE5'\n-/\n#guard_msgs in\n#eval string_color \"Jack\""}
{"id": "fvapps_004320", "vc-description": "/-\n# Task\nYou are a lifelong fan of your local football club, and proud to say you rarely miss a game. Even though you're a superfan, you still hate boring games. Luckily, boring games often end in a draw, at which point the winner is determined by a penalty shoot-out, which brings some excitement to the viewing experience. Once, in the middle of a penalty shoot-out, you decided to count the lowest total number of shots required to determine the winner. So, given the number of shots each team has already made and the current score, `how soon` can the game end?\n\nIf you are not familiar with penalty shoot-out rules, here they are:\n\n`Teams take turns to kick from the penalty mark until each has taken five kicks. However, if one side has scored more successful kicks than the other could possibly reach with all of its remaining kicks, the shoot-out immediately ends regardless of the number of kicks remaining.`\n\n`If at the end of these five rounds of kicks the teams have scored an equal number of successful kicks, additional rounds of one kick each will be used until the tie is broken.`\n\n# Input/Output\n\n`[input]` integer `shots`\n\nAn integer, the number of shots each team has made thus far.\n\n`0 ≤ shots ≤ 100.`\n\n`[input]` integer array `score`\n\nAn array of two integers, where score[0] is the current score of the first team and score[1] - of the second team.\n\n`score.length = 2,`\n\n`0 ≤ score[i] ≤ shots.`\n\n`[output]` an integer\n\nThe minimal possible total number of shots required to determine the winner.\n\n# Example\n\nFor `shots = 2 and score = [1, 2]`, the output should be `3`.\n\nThe possible 3 shots can be: \n```\nshot1: the first team misses the penalty\nshot2: the second team scores\nshot3: the first one misses again```\n\nthen, score will be [1, 3]. As the first team can't get 2 more points in the last remaining shot until the end of the initial five rounds, the winner is determined.\n\nFor `shots = 10 and score = [10, 10]`, the output should be `2`.\n\nIf one of the teams misses the penalty and the other one scores, the game ends.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def penaltyShots (shots: Nat) (scores: List Nat) : Nat :=\nsorry\n\ndef abs (n: Int) : Nat :=\nsorry", "vc-theorems": "theorem penalty_shots_score_range {shots score1 score2: Nat}\n  (h1: score1 ≤ shots) (h2: score2 ≤ shots)\n  (h3: shots ≤ 20) (h4: score1 ≤ 20) (h5: score2 ≤ 20)\n  (h6: abs (Int.subNatNat score1 score2) ≤ (if shots > 4 then 2 else 5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ (if shots > 4 then 2 else 5 - shots + 1) :=\nsorry\n\ntheorem penalty_shots_sudden_death {shots score1 score2: Nat}\n  (h1: shots > 4) (h2: score1 ≤ shots) (h3: score2 ≤ shots)\n  (h4: abs (Int.subNatNat score1 score2) ≤ 2) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ 2 :=\nsorry\n\ntheorem penalty_shots_regular_rounds {shots score1 score2: Nat}\n  (h1: shots ≤ 4) (h2: score1 ≤ shots) (h3: score2 ≤ shots)\n  (h4: abs (Int.subNatNat score1 score2) ≤ (5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 ≤ result ∧ result ≤ (5 - shots + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval penaltyShots 2 [1, 2]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 10 [10, 10]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 5 [5, 5]"}
{"id": "fvapps_004330", "vc-description": "/-\nAssume `\"#\"` is like a backspace in string. This means that string `\"a#bc#d\"` actually is `\"bd\"`\n\nYour task is to process a string with `\"#\"` symbols.\n\n## Examples\n\n```\n\"abc#d##c\"      ==>  \"ac\"\n\"abc##d######\"  ==>  \"\"\n\"#######\"       ==>  \"\"\n\"\"              ==>  \"\"\n```\n-/", "vc-preamble": "def count_hashtags (s : String) : Nat :=\n  s.foldl (fun acc c => if c = '#' then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def clean_string (s : String) : String :=\nsorry", "vc-theorems": "theorem clean_string_idempotent (s : String) :\n  clean_string (clean_string s) = clean_string s :=\nsorry\n\ntheorem clean_string_no_hashtags (s : String) :\n  ¬(String.contains (clean_string s) '#') :=\nsorry\n\ntheorem clean_string_append {s₁ s₂ : String}\n  (h₁ : ¬(String.contains s₁ '#'))\n  (h₂ : ¬(String.contains s₂ '#')) :\n  clean_string (s₁ ++ s₂) = clean_string s₁ ++ clean_string s₂ :=\nsorry\n\ntheorem clean_string_length (s : String) :\n  String.length (clean_string s) ≤ String.length s - count_hashtags s :=\nsorry\n\ntheorem clean_string_empty :\n  clean_string \"\" = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'ac'\n-/\n#guard_msgs in\n#eval clean_string \"abc#d##c\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval clean_string \"#######\"\n\n/--\ninfo: 'jf'\n-/\n#guard_msgs in\n#eval clean_string \"abjd####jfk#\""}
{"id": "fvapps_004331", "vc-description": "/-\nDecompose a number `num` into an array (tuple in Haskell, array of arrays `long[][]` in C# or Java) of the form `[[k1,k2,k3...], r]`,  `([k1,k2,k3...], r)` in Haskell, `[[k1,k2,k3...], [r]]` in C# or Java) such that:\n\n1. each kn is more than one\n2. eack kn is maximized (first maximizing for 2 then 3 then 4 and so on)\n3. and 2^(k1) + 3^(k2) + 4^(k3) + ... + n^(kn-1) + r = num\n\n##Examples\n```\n# when there are no `k` more than 1:\n\n3 \n\n[[], 3] = \n\n3\n\n# when the remainder is zero:\n\n8330475\n\n[[22, 13, 10, 8, 7, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2], 0] = \n\n2 ^ 22 + 3 ^ 13 + 4 ^ 10 + 5 ^ 8 + 6 ^ 7 + 7 ^ 6 + 8 ^ 6 + 9 ^ 5 + 10 ^ 5 + 11 ^ 5 + 12 ^ 4 + 13 ^ 4 + 14 ^ 4 + 15 ^ 3 + 16 ^ 3 + 17 ^ 3 + 18 ^ 3 + 19 ^ 3 + 20 ^ 3 + 21 ^ 2 + 22 ^ 2 + 23 ^ 2 + 24 ^ 2 + 0 = 8330475\n\n# when there is both `k` and a remainder:\n\n26 \n\n[[4, 2], 1] = \n\n2 ^ 4 + 3 ^ 2 + 1 = 26\n\n# when there is neither `k` nor a remainder:\n\n0\n\n[[], 0] = \n\n0\n```\n\nAs allways any feedback would be much appreciated\n-/\n\n/- Decompose function's list result contains only numbers greater than 1 -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Decompose function's remainder is non-negative -/\n\n/- The decomposition recomposes back to the original number -/\n\n/- Negative inputs return empty list and same number as remainder -/\n\n/- Small inputs (0,1) return empty list and same number -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def decompose : Int → List Nat × Int :=\nsorry", "vc-theorems": "theorem decompose_result_gt_one (n : Int) :\n  let (result, _) := decompose n\n  ∀ k ∈ result, k > 1 :=\nsorry\n\ntheorem decompose_remainder_nonneg (n : Int) :\n  let (_, remainder) := decompose n\n  remainder ≥ 0 :=\nsorry\n\ntheorem decompose_recompose (n : Int) :\n  let (result, remainder) := decompose n\n  let recomposed := remainder + (List.foldl (fun acc (i, k) => acc + (i + 2)^k) 0\n    (List.zip (List.range result.length) result))\n  recomposed = n :=\nsorry\n\ntheorem decompose_negative (n : Int) :\n  n < 0 →\n  decompose n = ([], n) :=\nsorry\n\ntheorem decompose_small_inputs (n : Int) :\n  n = 0 ∨ n = 1 →\n  decompose n = ([], n) :=\nsorry", "vc-postamble": "/--\ninfo: [[], 3]\n-/\n#guard_msgs in\n#eval decompose 3\n\n/--\ninfo: [[4, 2], 1]\n-/\n#guard_msgs in\n#eval decompose 26\n\n/--\ninfo: [[], 0]\n-/\n#guard_msgs in\n#eval decompose 0"}
{"id": "fvapps_004332", "vc-description": "/-\nGiven a string (`str`) containing a base-10 integer between `0` and `10000`, convert the integer to its binary representation. At that point, obtain a count of the maximum amount of consecutive 0s. From there, return the count in written form with a capital letter.\n\nIn the very first example, we have an argument of `\"9\"` which is being passed to the method. The binary representation of `9` is `1001` which can be read as: one, zero, zero, one. There are, at most, two consecutive 0s, resulting in the integer `2` as the value of the count. The output in the block of code above reflects the final step of taking `2` from standard form to the written form `\"Two\"` as prompted.\n\nIn the very last example, we have an argument of `\"550\"` which is being passed to the method. The binary representation of `550` is `1000100110` which can be read as: one, zero, zero, zero, one, zero, zero, one, one, zero. There are, at most, three consecutive 0s, resulting in the integer `3` as the value of the count. The output in the block of code above reflects the final step of taking `3` from standard form to the written form of `\"Three\"` as prompted.\n\nOne way, among many, to visualize the end of each step might look like:\n```\nmax_consec_zeros(\"777\")\n1: \"777\"\n2: 777\n3: 1100001001\n4: 4\n5: \"Four\"\nmax_consec_zeros(\"777\") => \"Four\"\n```\nHappy coding!\n-/\n\n-- Property 1: Function should work for any valid positive integer string input\n\n-- Property 2: Powers of 2 should have n-1 consecutive zeros\n\n-- Property 3: Result should be same for equivalent decimal values", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_consec_zeros (n: String) : String :=\n  sorry\n\ndef toWord (n: Nat) : String :=\n  sorry", "vc-theorems": "theorem max_consec_zeros_valid_input {n: String} (h: ∃ (k: Nat), k > 0 ∧ k ≤ 10^6 ∧ n = toString k) :\n  let result := max_consec_zeros n\n  ∃ word, word ∈ [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n                  \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\"] ∧ result = word :=\nsorry\n\ntheorem powers_of_two_zeros {n: Nat} (h: n > 0 ∧ n ≤ 12) :\n  max_consec_zeros (toString (2^n)) = toWord (n-1) :=\nsorry\n\ntheorem equivalent_decimal_values {n: Nat} (h: n > 0 ∧ n ≤ 10000) :\n  max_consec_zeros (toString n) = max_consec_zeros (toString (n : Nat)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Two'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"9\"\n\n/--\ninfo: 'Three'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"550\"\n\n/--\ninfo: 'Eight'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"256\""}
{"id": "fvapps_004337", "vc-description": "/-\nTake debugging to a whole new level:\n\nGiven a string, remove every *single* bug.\n\nThis means you must remove all instances of the word 'bug' from within a given string, *unless* the word is plural ('bugs').\n\nFor example, given 'obugobugobuoobugsoo', you should return 'ooobuoobugsoo'.\n\nAnother example: given 'obbugugo', you should return 'obugo'.\n\nNote that all characters will be lowercase.\n\nHappy squishing!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def debug (s : String) : String :=\nsorry\n\ndef String.containsSubstr (s str : String) : Bool :=\nsorry\n\ndef String.countOccurrences (s str : String) : Nat :=\nsorry", "vc-theorems": "theorem debug_basic_properties (s : String) :\n  let result := debug s\n  (¬ result.containsSubstr \"bug\" ∨ result.containsSubstr \"bugs\") ∧\n  result.length ≤ s.length ∧\n  result = s.replace \"bug\" \"\" :=\nsorry\n\ntheorem debug_preserves_bugs (s : String) (h : ∀ c ∈ s.data, c = 'b' ∨ c = 'u' ∨ c = 'g' ∨ c = 's') :\n  (debug s).countOccurrences \"bugs\" = s.countOccurrences \"bugs\" :=\nsorry\n\ntheorem debug_idempotent (s : String) :\n  debug (debug s) = debug s :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'ooobuoobugsoo'\n-/\n#guard_msgs in\n#eval debug \"obugobugobuoobugsoo\"\n\n/--\ninfo: 'bugs gy'\n-/\n#guard_msgs in\n#eval debug \"bugs buggy\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval debug \"bugbugbugbug\""}
{"id": "fvapps_004340", "vc-description": "/-\n# Task\nTwo arrays are called similar if one can be obtained from another by swapping at most one pair of elements.\n\nGiven two arrays, check whether they are similar.\n\n# Example\n\nFor `A = [1, 2, 3]` and `B = [1, 2, 3]`, the output should be `true;`\n\nFor `A = [1, 2, 3]` and `B = [2, 1, 3]`, the output should be `true;`\n\nFor `A = [1, 2, 2]` and `B = [2, 1, 1]`, the output should be `false.`\n\n# Input/Output\n\n- `[input]` integer array `A`\n\nArray of integers.\n\nConstraints: `3 ≤ A.length ≤ 10000, 1 ≤ A[i] ≤ 1000.`\n\n- `[input]` integer array `B`\n\nArray of integers of the same length as `A`.\n\nConstraints: `B.length = A.length, 1 ≤ B[i] ≤ 1000.`\n\n- `[output]` a boolean value\n\n`true` if `A` and `B` are similar, `false` otherwise.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def are_similar (xs ys : List Int) : Bool :=\nsorry\n\ndef insertSort (xs : List Int) : List Int :=\nsorry", "vc-theorems": "theorem identical_lists_are_similar {xs : List Int} (h : xs ≠ []) :\n  are_similar xs xs :=\nsorry\n\ntheorem different_contents_not_similar {xs ys : List Int} :\n  insertSort xs ≠ insertSort ys →\n  ¬(are_similar xs ys) :=\nsorry\n\ntheorem single_swap_makes_similar {xs : List Int} (h : xs.length ≥ 2) :\n  let ys := xs.set 0 (xs.get! 1) |>.set 1 (xs.get! 0)\n  are_similar xs ys :=\nsorry\n\ntheorem multiple_swaps_not_similar {xs : List Int} (h : xs.length ≥ 3) :\n  let ys := xs.set 0 (xs.get! 1)\n            |>.set 1 (xs.get! 2)\n            |>.set 2 (xs.get! 0)\n  (List.length (List.filter (fun p => p.1 ≠ p.2) (List.zip xs ys))) > 2 →\n  ¬(are_similar xs ys) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [1, 2, 3]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [2, 1, 3]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 2] [2, 1, 1]"}
{"id": "fvapps_004354", "vc-description": "/-\nWrite a function that takes a number or a string and gives back the number of **permutations without repetitions** that can generated using all of its element.; more on permutations [here](https://en.wikipedia.org/wiki/Permutation).\n\nFor example, starting with:\n```\n1\n45\n115\n\"abc\"\n```\n\nYou could respectively generate:\n```\n1\n45,54\n115,151,511\n\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"\n```\n\nSo you should have, in turn:\n```python\nperms(1)==1\nperms(45)==2\nperms(115)==3\nperms(\"abc\")==6\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def perms (s : String) : Nat :=\nsorry\n\ndef listPerms (l : List α) : List (List α) :=\nsorry\n\ndef listToString (l : List Char) : String :=\nsorry\n\ndef numUnique (xs : List String) : Nat :=\nsorry", "vc-theorems": "theorem perms_matches_unique_perms_int {n : Nat} :\n  perms (toString n) = numUnique ((listPerms (toString n).data).map listToString) :=\nsorry\n\ntheorem perms_matches_unique_perms_str {s : String} :\n  perms s = numUnique ((listPerms s.data).map listToString) :=\nsorry\n\ntheorem perms_order_invariant {n : Nat} :\n  perms (toString n) = perms (toString n) :=\nsorry\n\ntheorem perms_positive_int {s : String} (h : s.length > 0) :\n  perms s > 0 :=\nsorry\n\ntheorem perms_single_char {c : Char} :\n  perms (String.mk [c]) = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval perms 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval perms 25\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval perms \"abc\""}
{"id": "fvapps_004362", "vc-description": "/-\n# Task\n If string has more than one neighboring dashes(e.g. --) replace they with one dash(-). \n\n Dashes are considered neighbors even if there is some whitespace **between** them.\n\n# Example\n\n For `str = \"we-are- - - code----warriors.-\"`\n\n The result should be `\"we-are- code-warriors.-\"`\n\n# Input/Output\n\n - `[input]` string `str`\n\n - `[output]` a string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def replace_dashes_as_one (s : String) : String :=\nsorry\n\ndef remove_dashes (s : String) : String :=\nsorry\n\ndef containsSubstring (s : String) (sub : String) : Bool :=\nsorry", "vc-theorems": "theorem no_consecutive_dashes\n  (s : String) :\n  ¬ (containsSubstring (replace_dashes_as_one s) \"--\") ∧ \n  ¬ (containsSubstring (replace_dashes_as_one s) \"- -\") :=\nsorry\n\ntheorem preserves_non_dash_chars\n  (s : String) :\n  remove_dashes s = remove_dashes (replace_dashes_as_one s) :=\nsorry\n\ntheorem idempotent\n  (s : String) :\n  replace_dashes_as_one (replace_dashes_as_one s) = replace_dashes_as_one s :=\nsorry\n\ntheorem dash_only_strings\n  (s : String)\n  (h : ∀ c, String.contains s c → (c = '-' ∨ c = ' ')) :\n  (∀ c, String.contains (replace_dashes_as_one s) c → (c = '-' ∨ c = ' ')) ∧\n  ¬ (containsSubstring (replace_dashes_as_one s) \"--\") ∧ \n  ¬ (containsSubstring (replace_dashes_as_one s) \"- -\") :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'we-are- code-warriors.-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"we-are- - - code----warriors.-\"\n\n/--\ninfo: 'a-b-c'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a---b- - -c\"\n\n/--\ninfo: 'a-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a------\""}
{"id": "fvapps_004366", "vc-description": "/-\n# Task\n Initially a number `1` is written on a board. It is possible to do the following operations with it:\n```\nmultiply the number by 3;\nincrease the number by 5.```\nYour task is to determine that using this two operations step by step, is it possible to obtain number `n`?\n\n# Example\n\n For `n = 1`, the result should be `true`.\n\n `1 = 1`\n\n For `n = 2`, the result should be `false`.\n\n For `n = 3`, the result should be `true`.\n\n `1 x 3 = 3`\n\n For `n = 4`, the result should be `false`.\n\n For `n = 5`, the result should be `false`.\n\n For `n = 6`, the result should be `true`.\n\n `1 + 5 = 6`\n\n For `n = 18`, the result should be `true`.\n\n `1 + 5 = 6  --> 6 x 3 = 18`\n\n For `n = 32`, the result should be `true`.\n\n `1 x 3 x 3 x 3 = 27  --> 27 + 5 = 32`\n\n For `n = 100`, the result should be `false`.\n\n For `n = 101`, the result should be `true`.\n\n `1 + 5 + 5 + 5 ... +5 = 101`\n\n# Input / Output\n\n - `[input]` integer n\n\n  positive integer, n ≤ 100000\n\n - `[output]` a boolean value\n\n  `true` if N can be obtained using given operations, `false` otherwise.\n-/", "vc-preamble": "def bitLength (n : Nat) : Nat :=\n  if n = 0 then 0 else Nat.log2 n + 1", "vc-helpers": "", "vc-definitions": "def number_increasing (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem impossible_values_2 : number_increasing 2 = false :=\nsorry\n\ntheorem impossible_values_4 : number_increasing 4 = false :=\nsorry\n\ntheorem impossible_values_7 : number_increasing 7 = false :=\nsorry\n\ntheorem impossible_values_12 : number_increasing 12 = false :=\nsorry\n\ntheorem impossible_values_17 : number_increasing 17 = false :=\nsorry\n\ntheorem impossible_values_22 : number_increasing 22 = false :=\nsorry\n\ntheorem multiples_of_five (n : Nat) (h₁ : n > 1) (h₂ : n % 5 = 0) :\n  number_increasing n = false :=\nsorry\n\ntheorem start_point :\n  number_increasing 1 = true :=\nsorry\n\ntheorem multiples_of_three_reachable (n : Nat) (h₁ : n > 1)\n  (h₂ : n = 3^(bitLength (bitLength (n - 1)))) :\n  number_increasing n = true :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 1\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval number_increasing 2\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 6\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 18\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 32"}
{"id": "fvapps_004369", "vc-description": "/-\n##Task:\nYou have to write a function `add` which takes two binary numbers as strings and returns their sum as a string.\n\n##Note:\n* You are `not allowed to convert binary to decimal & vice versa`.\n* The sum should contain `No leading zeroes`.\n\n##Examples:\n```\nadd('111','10'); => '1001'\nadd('1101','101'); => '10010'\nadd('1101','10111') => '100100'\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (a b : String) : String :=\nsorry\n\ndef binary_to_int (s : String) : Nat :=\nsorry\n\ndef is_valid_binary (s : String) : Bool :=\nsorry", "vc-theorems": "theorem strips_leading_zeros (binary : String) :\n  let result := add binary \"0\"\n  (result.startsWith \"0\" → result = \"0\") ∧\n  binary_to_int result = binary_to_int binary :=\nsorry\n\ntheorem add_commutative (a b : String) :\n  add a b = add b a :=\nsorry\n\ntheorem matches_integer_addition (a b : String) :\n  let result := add a b\n  is_valid_binary result ∧\n  binary_to_int result = binary_to_int a + binary_to_int b :=\nsorry\n\ntheorem identity (binary : String) :\n  binary_to_int (add binary \"0\") = binary_to_int binary :=\nsorry\n\ntheorem empty_strings_zero :\n  add \"\" \"\" = \"0\" :=\nsorry\n\ntheorem empty_string_one :\n  add \"\" \"1\" = \"1\" ∧ add \"1\" \"\" = \"1\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1001'\n-/\n#guard_msgs in\n#eval add \"111\" \"10\"\n\n/--\ninfo: '10010'\n-/\n#guard_msgs in\n#eval add \"1101\" \"101\"\n\n/--\ninfo: '100100'\n-/\n#guard_msgs in\n#eval add \"1101\" \"10111\""}
{"id": "fvapps_004380", "vc-description": "/-\nThe four bases found in DNA are adenine (A), cytosine (C), guanine (G) and thymine (T).\n\nIn genetics, GC-content is the percentage of Guanine (G) and Cytosine (C) bases on a DNA molecule that are either guanine or cytosine. \n\nGiven a DNA sequence (a string) return the GC-content in percent, rounded up to 2 decimal digits for Python, not rounded in all other languages.\n\nFor more information about GC-content you can take a look to [wikipedia GC-content](https://en.wikipedia.org/wiki/GC-content).\n\n**For example**: the GC-content of the following DNA sequence is 50%:\n\"AAATTTCCCGGG\".\n\n**Note**: You can take a look to my others bio-info kata [here](http://www.codewars.com/users/nbeck/authored)\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def gc_content (s : String) : Float :=\nsorry\n\ndef count (s : String) (c : String) : Nat :=\nsorry", "vc-theorems": "theorem gc_content_bounded (s : String) :\n  0.0 ≤ gc_content s ∧ gc_content s ≤ 100.0 :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004388", "vc-description": "/-\n# Task\n Pac-Man got lucky today! Due to minor performance issue all his enemies have frozen. Too bad Pac-Man is not brave enough to face them right now, so he doesn't want any enemy to see him. \n\n Given a gamefield of size `N` x `N`, Pac-Man's position(`PM`) and his enemies' positions(`enemies`), your task is to count the number of coins he can collect without being seen.\n\n An enemy can see a Pac-Man if they are standing on the same row or column. \n\n It is guaranteed that no enemy can see Pac-Man on the starting position. There is a coin on each empty square (i.e. where there is no Pac-Man or enemy).\n\n# Example\n\n For `N = 4, PM = [3, 0], enemies = [[1, 2]]`, the result should be `3`.\n```\nLet O represent coins, P - Pac-Man and E - enemy.\nOOOO\nOOEO\nOOOO\nPOOO```\nPac-Man cannot cross row 1 and column 2. \n\n He can only collect coins from points `(2, 0), (2, 1) and (3, 1)`, like this:\n ```\nx is the points that Pac-Man can collect the coins.\nOOOO\nOOEO\nxxOO\nPxOO\n ```\n\n# Input/Output\n\n - `[input]` integer `N`\n\n  The field size.\n\n - `[input]` integer array `PM`\n\n  Pac-Man's position (pair of integers)\n\n - `[input]` 2D integer array `enemies`\n\n  Enemies' positions (array of pairs)\n\n - `[output]` an integer\n\n  Number of coins Pac-Man can collect.\n\n# More PacMan Katas\n\n - [Play PacMan: Devour all](https://www.codewars.com/kata/575c29d5fcee86cb8b000136)\n\n - [Play PacMan 2: The way home](https://www.codewars.com/kata/575ed46e23891f67d90000d8)\n-/\n\n/- Theorem ensuring result is an integer bounded by board size -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Theorem for specific cases -/\n\n/- Empty board -/\n\n/- Single enemy -/\n\n/- Multiple enemies -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pac_man (size : Nat) (pacman : List Nat) (enemies : List (List Nat)) : Int :=\nsorry", "vc-theorems": "theorem pac_man_result_bounds\n  (size : Nat)\n  (px py : Nat)\n  (enemies : List (List Nat))\n  (h : size ≥ 2) :\n  let normalizedPx := px % size\n  let normalizedPy := py % size\n  let result := pac_man size [normalizedPx, normalizedPy] enemies\n  result ≥ -1 ∧ result ≤ size * size - 1 :=\nsorry\n\ntheorem pac_man_specific_cases :\n\n  pac_man 3 [0, 0] [] = 8 ∧\n\n  pac_man 4 [3, 0] [[1, 2]] = 3 ∧\n\n  pac_man 2 [0, 0] [[0, 1], [1, 0], [1, 1]] = 0 :=\nsorry", "vc-postamble": "/--\ninfo: 3\n-/\n#guard_msgs in\n#eval pac_man 4 [3, 0] [[1, 2]]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval pac_man 3 [0, 0] []\n\n/--\ninfo: 19\n-/\n#guard_msgs in\n#eval pac_man 8 [1, 1] [[5, 4]]"}
{"id": "fvapps_004391", "vc-description": "/-\n## Your story\nYou've always loved both Fizz Buzz katas and cuckoo clocks, and when you walked by a garage sale and saw an ornate cuckoo clock with a missing pendulum, and a \"Beyond-Ultimate Raspberry Pi Starter Kit\" filled with all sorts of sensors and motors and other components, it's like you were suddenly hit by a beam of light and knew that it was your mission to combine the two to create a computerized Fizz Buzz cuckoo clock!\n\nYou took them home and set up shop on the kitchen table, getting more and more excited as you got everything working together just perfectly. Soon the only task remaining was to write a function to select from the sounds you had recorded depending on what time it was:\n\n## Your plan\n* When a minute is evenly divisible by three, the clock will say the word \"Fizz\".\n* When a minute is evenly divisible by five, the clock will say the word \"Buzz\".\n* When a minute is evenly divisible by both, the clock will say \"Fizz Buzz\", with two exceptions:\n  1. On the hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo bird will come out and \"Cuckoo\" between one and twelve times depending on the hour.\n  2. On the half hour, instead of \"Fizz Buzz\", the clock door will open, and the cuckoo will come out and \"Cuckoo\" just once. \n* With minutes that are not evenly divisible by either three or five, at first you had intended to have the clock just say the numbers ala Fizz Buzz, but then you decided at least for version 1.0 to just have the clock make a quiet, subtle \"tick\" sound for a little more clock nature and a little less noise.\n\nYour input will be a string containing hour and minute values in 24-hour time, separated by a colon, and with leading zeros. For example, 1:34 pm would be `\"13:34\"`.\n\nYour return value will be a string containing the combination of Fizz, Buzz, Cuckoo, and/or tick sounds that the clock needs to make at that time, separated by spaces. Note that although the input is in 24-hour time, cuckoo clocks' cuckoos are in 12-hour time. \n\n## Some examples\n```\n\"13:34\"       \"tick\"\n\"21:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n\"11:15\"       \"Fizz Buzz\"\n\"03:03\"       \"Fizz\"\n\"14:30\"       \"Cuckoo\"\n\"08:55\"       \"Buzz\"\n\"00:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n\"12:00\"       \"Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo Cuckoo\"\n```\nHave fun!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def splitOnSpace (s : String) : List String :=\n  s.split (fun c => c = ' ')", "vc-helpers": "", "vc-definitions": "def fizz_buzz_cuckoo_clock (time : String) : String :=\n  sorry", "vc-theorems": "theorem output_is_nonempty (time : String) :\n  time.length = 5 → (fizz_buzz_cuckoo_clock time).length > 0 :=\nsorry\n\ntheorem half_hour_single_cuckoo (hour : Nat) (h : hour ≤ 23) :\n  let time := (if hour < 10 then \"0\" else \"\") ++ toString hour ++ \":30\"\n  fizz_buzz_cuckoo_clock time = \"Cuckoo\" :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004399", "vc-description": "/-\n# Definition\n\nA **number** is called **_Automorphic number_** if and only if *its square ends in the same digits as the number itself*.\n___\n\n# Task\n\n**_Given_** a **number** *determine if it Automorphic or not* .\n___\n\n# Warm-up (Highly recommended)\n\n# [Playing With Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n___\n\n# Notes \n\n* The **_number_** passed to the function is **_positive_** \n\n* **_Single-digit_** numbers are considered **_Automorphic number_**.\n___\n# Input >> Output Examples \n\n```\nautoMorphic (25) -->> return \"Automorphic\" \n```\n## **_Explanation_**:\n\n* `25` squared is `625` , **_Ends with the same number's digits which are 25_** .\n___\n```\nautoMorphic (13) -->> return \"Not!!\"\n```\n## **_Explanation_**:\n\n* `13` squared is `169` , **_Not ending with the same number's digits which are 69_** .\n___ \n```\nautoMorphic (76) -->> return \"Automorphic\"\n```\n## **_Explanation_**:\n\n* `76` squared is `5776` , **_Ends with the same number's digits which are 76_** .\n___\n```\nautoMorphic (225) -->> return \"Not!!\"\n```\n## **_Explanation_**:\n\n* `225` squared is `50625` , **_Not ending with the same number's digits which are 225_** .\n___ \n```\nautoMorphic (625) -->> return \"Automorphic\"\n```\n## **_Explanation_**:\n\n* `625` squared is `390625` , **_Ends with the same number's digits which are 625_** .\n___ \n```\nautoMorphic (1) -->> return \"Automorphic\"\n```\n## **_Explanation_**:\n\n* `1` squared is `1` , **_Ends with the same number's digits which are 1_** .\n___\n```\nautoMorphic (6) -->> return \"Automorphic\"\n```\n## **_Explanation_**:\n\n* `6` squared is `36` , **_Ends with the same number's digits which are 6_** \n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "def length (s : String) : Nat := s.data.length", "vc-helpers": "", "vc-definitions": "def automorphic (n : Nat) : String :=\n  sorry\n\ndef endsWith (s1 s2 : String) : Bool :=\nsorry", "vc-theorems": "theorem automorphic_returns_valid_string (n : Nat) :\n  automorphic n = \"Automorphic\" ∨ automorphic n = \"Not!!\" :=\nsorry\n\ntheorem automorphic_definition (n : Nat) :\n  automorphic n = \"Automorphic\" ↔ endsWith (ToString.toString (n * n)) (ToString.toString n) = true :=\nsorry\n\ntheorem automorphic_zero_property (n : Nat) :\n  n = 0 → automorphic n = \"Automorphic\" :=\nsorry\n\ntheorem automorphic_length_property (n : Nat) :\n  n > 0 →\n  automorphic n = \"Automorphic\" →\n  length (ToString.toString (n * n)) ≥ length (ToString.toString n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 6\n\n/--\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 25\n\n/--\ninfo: 'Not!!'\n-/\n#guard_msgs in\n#eval automorphic 53"}
{"id": "fvapps_004410", "vc-description": "/-\nConsider an array that has no prime numbers, and none of its elements has any prime digit. It would start with: `[1,4,6,8,9,10,14,16,18,..]`. \n\n`12` and `15` are not in the list because `2` and `5` are primes.\n\nYou will be given an integer `n` and your task will be return the number at that index in the array. \nFor example:\n```\nsolve(0) = 1\nsolve(2) = 6\n``` \n\nMore examples in the test cases.\n\nGood luck!\n\nIf you like Prime Katas, you will enjoy this Kata: [Simple Prime Streaming](https://www.codewars.com/kata/5a908da30025e995880000e3)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (n : Nat) : Nat :=\nsorry\n\ndef is_composite (n : Nat) : Bool :=\nsorry\n\ndef isDigitIn (d : Char) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_positive (n : Nat) :\n  solve n > 0 :=\nsorry\n\ntheorem solve_monotonic {n : Nat} (h : n > 0) :\n  solve n > solve (n-1) :=\nsorry\n\ntheorem solve_deterministic (n : Nat) :\n  solve n = solve n :=\nsorry\n\ntheorem solve_zero :\n  solve 0 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 0\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 2\n\n/--\ninfo: 44\n-/\n#guard_msgs in\n#eval solve 10"}
{"id": "fvapps_004411", "vc-description": "/-\nYour task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.\n\nNote: Numbers can be from 1 to 9. So 1 will be the first word (not 0).\n\nIf the input string is empty, return an empty string.\nThe words in the input String will only contain valid consecutive numbers.\n\n## Examples\n\n```\n\"is2 Thi1s T4est 3a\"  -->  \"Thi1s is2 3a T4est\"\n\"4of Fo1r pe6ople g3ood th5e the2\"  -->  \"Fo1r the2 g3ood 4of th5e pe6ople\"\n\"\"  -->  \"\"\n```\n-/", "vc-preamble": "def isSorted (as : List Nat) : Prop :=\n  ∀ i j, i < j → j < as.length → as[i]! ≤ as[j]!", "vc-helpers": "", "vc-definitions": "def order (sentence : String) : String :=\n  sorry\n\ndef splitString (s : String) (sep : Char) : List String :=\n  sorry\n\ndef findNumber (s : String) : Option Nat :=\n  sorry", "vc-theorems": "theorem order_preserves_empty_string :\n  order \"\" = \"\" :=\nsorry\n\ntheorem order_sorts_by_numbers {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers :=\nsorry\n\ntheorem order_preserves_words {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  let resultWords := splitString (order sentence) ' '\n  words.eraseDups = resultWords.eraseDups ∧\n  words.length = resultWords.length :=\nsorry\n\ntheorem order_all_properties {sentence : String} {words : List String} :\n  words = splitString sentence ' ' →\n  (sentence = \"\" → order sentence = \"\") ∧\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers ∧\n  words.eraseDups = resultWords.eraseDups ∧\n  words.length = resultWords.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval order \"is2 Thi1s T4est 3a\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval order \"4of Fo1r pe6ople g3ood th5e the2\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval order \"\""}
{"id": "fvapps_004421", "vc-description": "/-\nConvert a hash into an array. Nothing more, Nothing less.\n\n```\n{name: 'Jeremy', age: 24, role: 'Software Engineer'}\n```\nshould be converted into\n\n```\n[[\"name\", \"Jeremy\"], [\"age\", 24], [\"role\", \"Software Engineer\"]]\n```\n\n```if:python,javascript,crystal\n**Note**: The output array should be sorted alphabetically.\n```\n\nGood Luck!\n-/", "vc-preamble": "def LePair (p1 p2: String × (String ⊕ Int)) : Prop :=\n  p1.1 ≤ p2.1", "vc-helpers": "", "vc-definitions": "def convert_hash_to_array (d: List (String × (String ⊕ Int))) : List (String × (String ⊕ Int)) :=\n  sorry", "vc-theorems": "theorem convert_hash_output_is_sorted (d: List (String × (String ⊕ Int))) :\n  let result := convert_hash_to_array d\n  List.Pairwise LePair result ∧\n  (∀ x ∈ result, ∃ k v, x = (k, v)) ∧\n  result = d :=\nsorry\n\ntheorem convert_hash_empty_dict :\n  convert_hash_to_array [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\"}\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\", \"age\": 24, \"role\": \"Software Engineer\"}\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval convert_hash_to_array {}"}
{"id": "fvapps_004425", "vc-description": "/-\nGiven is a md5 hash of a five digits long PIN. It is given as string.\nMd5 is a function to hash your password:\n\"password123\" ===> \"482c811da5d5b4bc6d497ffa98491e38\"\n\nWhy is this useful?\nHash functions like md5 can create a hash from string in a short time and it is impossible to find out the password, if you only got the hash. The only way is cracking it, means try every combination, hash it and compare it with the hash you want to crack. (There are also other ways of attacking md5 but that's another story)\nEvery Website and OS is storing their passwords as hashes, so if a hacker gets access to the database, he can do nothing, as long the password is safe enough.\n\nWhat is a hash:\nhttps://en.wikipedia.org/wiki/Hash_function#:~:text=A%20hash%20function%20is%20any,table%20called%20a%20hash%20table.\n\nWhat is md5:\nhttps://en.wikipedia.org/wiki/MD5\n\nNote: Many languages have build in tools to hash md5. If not, you can write your own md5 function or google for an example.\n\nHere is another kata on generating md5 hashes:\nhttps://www.codewars.com/kata/password-hashes\n\nYour task is to return the cracked PIN as string.\n\nThis is a little fun kata, to show you, how weak PINs are and how important a bruteforce protection is, if you create your own login.\n\nIf you liked this kata, here is an extension with short passwords:\nhttps://www.codewars.com/kata/59146f7b4670ba520900000a\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isDigit (c : Char) : Bool :=\nsorry\n\ndef allDigits (s : String) : Bool :=\nsorry\n\ndef md5hash (s : String) : String :=\nsorry\n\ndef crack (hash : String) : String :=\nsorry", "vc-theorems": "theorem crack_roundtrip {num : Nat} (h : num ≤ 99999) :\n  let numStr := toString num\n  let paddedStr := if numStr.length < 5 then String.mk (List.replicate (5 - numStr.length) '0') ++ numStr else numStr\n  crack (md5hash paddedStr) = paddedStr :=\nsorry\n\ntheorem crack_invalid_hash (s : String)\n  (h1 : s = \"invalid_hash\" ∨ s = \"\") :\n  crack s = \"\" :=\nsorry\n\ntheorem crack_random_hash (hash : String)\n  (h1 : hash.length = 32) :\n  let result := crack hash\n  (result = \"\") ∨\n  (result.length = 5 ∧\n   allDigits result = true ∧\n   md5hash result = hash) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '12345'\n-/\n#guard_msgs in\n#eval crack \"827ccb0eea8a706c4c34a16891f84e7b\"\n\n/--\ninfo: '00078'\n-/\n#guard_msgs in\n#eval crack \"86aa400b65433b608a9db30070ec60cd\""}
{"id": "fvapps_004427", "vc-description": "/-\nYou probably know the 42 number as \"The answer to life, the universe and everything\" according to Douglas Adams' \"The Hitchhiker's Guide to the Galaxy\". For Freud, the answer was quite different.\n\nIn the society he lived in, people-women in particular- had to repress their sexual needs and desires. This was simply how the society was at the time. \nFreud then wanted to study the illnesses created by this, and so he digged to the root of their desires. This led to some of the most important psychoanalytic theories to this day, Freud being the father of psychoanalysis.\n\nNow, basically, when a person hears about Freud, s/he hears \"sex\" because for Freud, everything was basically related to, and explained by sex. \n\nIn this kata, the toFreud() function will take a string as its argument, and return a string with every word replaced by the explanation to everything, according to Freud. Note that an empty string, or no arguments, should result in the ouput being \"\"(empty string).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def split (s : String) (sep : Char → Bool) : List String :=\nsorry\n\ndef trim (s : String) : String :=\nsorry\n\ndef to_freud (s : String) : String :=\nsorry", "vc-theorems": "theorem empty_string_returns_empty :\n  to_freud \"\" = \"\" :=\nsorry\n\ntheorem only_whitespace_returns_empty (s : String) :\n  trim s = \"\" → to_freud s = \"\" :=\nsorry\n\ntheorem non_empty_only_contains_sex (s : String) :\n  trim s ≠ \"\" →\n  List.all (split (to_freud s) (· = ' ')) (· = \"sex\") :=\nsorry\n\ntheorem preserves_word_count (s : String) :\n  trim s ≠ \"\" →\n  (split (to_freud s) (· = ' ')).length = (split (trim s) (· = ' ')).length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'sex'\n-/\n#guard_msgs in\n#eval to_freud \"test\"\n\n/--\ninfo: 'sex sex sex sex'\n-/\n#guard_msgs in\n#eval to_freud \"This is a test\"\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval to_freud \"\""}
{"id": "fvapps_004428", "vc-description": "/-\nThe alphabetized kata\n---------------------\n\nRe-order the characters of a string, so that they are concatenated into a new string in \"case-insensitively-alphabetical-order-of-appearance\" order. Whitespace and punctuation shall simply be removed!\n\nThe input is restricted to contain no numerals and only words containing the english alphabet letters.\n\nExample: \n\n```python\nalphabetized(\"The Holy Bible\") # \"BbeehHilloTy\"\n```\n\n_Inspired by [Tauba Auerbach](http://www.taubaauerbach.com/view.php?id=73)_\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def alphabetized (s : String) : String :=\nsorry\n\ndef sorted_list (l : List Char) : List Char :=\nsorry\n\ndef isAlpha (c : Char) : Bool :=\nsorry", "vc-theorems": "theorem alphabetized_is_sorted (s : String) :\n  let result := alphabetized s\n  result = String.mk (sorted_list (result.data)) :=\nsorry\n\ntheorem alphabetized_only_letters (s : String) :\n  let result := alphabetized s\n  ∀ c ∈ result.data, isAlpha c :=\nsorry\n\ntheorem alphabetized_preserves_count (s : String) :\n  let result := alphabetized s\n  let original_letters := s.data.filter isAlpha\n  result.length = original_letters.length ∧\n  sorted_list (result.data.map Char.toLower) = sorted_list (original_letters.map Char.toLower) :=\nsorry\n\ntheorem alphabetized_empty_string :\n  alphabetized \"\" = \"\" :=\nsorry\n\ntheorem alphabetized_no_letters (s : String) :\n  (∀ c ∈ s.data, ¬isAlpha c) →\n  alphabetized s = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval alphabetized \"\"\n\n/--\ninfo: 'BbeehHilloTy'\n-/\n#guard_msgs in\n#eval alphabetized \"The Holy Bible\"\n\n/--\ninfo: 'aaaaCcdddeLnooorstTWy'\n-/\n#guard_msgs in\n#eval alphabetized \"CodeWars can\"t Load Today\""}
{"id": "fvapps_004438", "vc-description": "/-\nYou're a buyer/seller and your buisness is at stake... You ___need___ to make profit... Or at least, you need to lose the least amount of money!  \nKnowing a list of prices for buy/sell operations, you need to pick two of them. Buy/sell market is evolving across time and the list represent this evolution. First, you need to buy one item, then sell it later. Find the best profit you can do.\n\n### Example:\n\nGiven an array of prices `[3, 10, 8, 4]`, the best profit you could make would be `7` because you buy at `3` first, then sell at `10`.\n\n# Input:\n\nA list of prices (integers), of length 2 or more.\n\n# Output:\n\nThe result of the best buy/sell operation, as an integer.\n\n### Note:\nBe aware you'll face lists with several thousands of elements, so think about performance.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_profit (prices : List Nat) : Int :=\nsorry\n\ndef maximum (l : List Nat) : Nat :=\nsorry\n\ndef minimum (l : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_profit_bounds {prices : List Nat} (h : prices.length ≥ 2) :\n  max_profit prices ≤ (maximum prices) - (minimum prices) :=\nsorry\n\ntheorem ascending_max_profit {prices : List Nat} (h : prices.length ≥ 2)\n  (ascending : ∀ (i : Nat), i + 1 < prices.length → prices[i]! ≤ prices[i + 1]!) :\n  max_profit prices = prices.getLast! - prices.head! :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval max_profit [10, 7, 5, 8, 11, 9]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval max_profit [3, 4]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval max_profit [9, 9]"}
{"id": "fvapps_004439", "vc-description": "/-\nEvery Turkish citizen has an identity number whose validity can be checked by these set of rules:\n\n- It is an 11 digit number\n- First digit can't be zero\n- Take the sum of 1st, 3rd, 5th, 7th and 9th digit and multiply it by 7.\nThen subtract the sum of 2nd, 4th, 6th and 8th digits from this value.\nModulus 10 of the result should be equal to 10th digit.\n- Sum of first ten digits' modulus 10 should be equal to eleventh digit.\n\nExample:\n\n    10167994524\n    //  1+1+7+9+5= 23   // \"Take the sum of 1st, 3rd, 5th, 7th and 9th digit...\"\n    //    23 * 7= 161   //  \"...and multiply it by 7\"\n    //   0+6+9+4 = 19   // \"Take the sum of 2nd, 4th, 6th and 8th digits...\"\n    // 161 - 19 = 142   // \"...and subtract from first value\"\n    // \"Modulus 10 of the result should be equal to 10th digit\"\n    10167994524\n             ^ = 2 = 142 % 10\n    // 1+0+1+6+7+9+9+4+5+2 = 44\n    // \"Sum of first ten digits' modulus 10 should be equal to eleventh digit\"\n    10167994524\n              ^ = 4 = 44 % 10\n\nYour task is to write a function to check the validity of a given number.\nReturn `true` or `false` accordingly.\n\nNote: The input can be a string in some cases.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_tenth_digit (digits : List Nat) : Nat :=\nsorry\n\ndef calculate_last_digit (digits : List Nat) : Nat :=\nsorry\n\ndef check_valid_tr_number (n : String) : Bool :=\nsorry", "vc-theorems": "theorem invalid_length_returns_false (n : String) :\n  n.length ≠ 11 → check_valid_tr_number n = false :=\nsorry\n\ntheorem valid_number_is_accepted {digits : List Nat} (h1 : digits.length = 9)\n  (h2 : digits.head! ≠ 0) :\n  let tenth := calculate_tenth_digit digits\n  let full_digits := digits ++ [tenth]\n  let last := calculate_last_digit full_digits\n  check_valid_tr_number (toString (full_digits ++ [last])) = true :=\nsorry\n\ntheorem invalid_check_digits_returns_false {n : String} (h1 : n.length = 11) :\n  let digits := n.toList.map (·.toString.toNat!)\n  digits[9]! ≠ calculate_tenth_digit (digits.take 9) ∨\n  digits[10]! ≠ calculate_last_digit (digits.take 10) →\n  check_valid_tr_number n = false :=\nsorry\n\ntheorem invalid_type_returns_false (n : String) :\n  ¬(∀ c : Char, c ∈ n.data → c.isDigit) →\n  check_valid_tr_number n = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 36637640050\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval check_valid_tr_number 12762438338\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 10167994524"}
{"id": "fvapps_004455", "vc-description": "/-\nConsider a sequence, which is formed by the following rule: next term is taken as the smallest possible non-negative integer, which is not yet in the sequence, so that `no 3` terms of sequence form an arithmetic progression.\n\n## Example\n\n`f(0) = 0` -- smallest non-negative  \n`f(1) = 1` -- smallest non-negative, which is not yet in the sequence  \n`f(2) = 3` -- since `0, 1, 2` form an arithmetic progression  \n`f(3) = 4` -- neither of `0, 1, 4`, `0, 3, 4`, `1, 3, 4` form an arithmetic progression, so we can take smallest non-negative, which is larger than `3`  \n`f(4) = 9` --  `5, 6, 7, 8` are not good, since `1, 3, 5`, `0, 3, 6`, `1, 4, 7`, `0, 4, 8` are all valid arithmetic progressions.  \n\netc...\n\n## The task\n\nWrite a function `f(n)`, which returns the `n-th` member of sequence.\n\n## Limitations\n\nThere are `1000` random tests with `0 <= n <= 10^9`, so you should consider algorithmic complexity of your solution.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sequence (n : Nat) : Nat :=\nsorry\n\ndef toBinaryString (n : Nat) : List Nat :=\nsorry\n\ndef fromBase3 (digits : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem sequence_nonnegative (n : Nat) :\n  sequence n ≥ 0 :=\nsorry\n\ntheorem sequence_monotonic {n : Nat} (h : n > 0) :\n  sequence n > sequence (n - 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-- Helper functions for binary/base-3 conversion -/\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sequence 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval sequence 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval sequence 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval sequence 3\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval sequence 4\n\n/--\ninfo: 7329\n-/\n#guard_msgs in\n#eval sequence 334"}
{"id": "fvapps_004463", "vc-description": "/-\n## Task:\n\nYou have to write a function **pattern** which returns the following Pattern(See Examples) upto (2n-1) rows, where n is parameter.\n\n### Rules/Note:\n* If the Argument is 0 or a Negative Integer then it should return \"\" i.e. empty string.\n* All the lines in the pattern have same length i.e equal to the number of characters in the longest line.\n* Range of n is (-∞,100]\n\n## Examples:\n\npattern(5):\n\n        1    \n       121   \n      12321  \n     1234321 \n    123454321\n     1234321 \n      12321  \n       121   \n        1    \n\npattern(10):\n\n             1         \n            121        \n           12321       \n          1234321      \n         123454321     \n        12345654321    \n       1234567654321   \n      123456787654321  \n     12345678987654321 \n    1234567890987654321\n     12345678987654321 \n      123456787654321  \n       1234567654321   \n        12345654321    \n         123454321     \n          1234321      \n           12321       \n            121        \n             1         \n\npattern(15):\n\n                  1              \n                 121             \n                12321            \n               1234321           \n              123454321          \n             12345654321         \n            1234567654321        \n           123456787654321       \n          12345678987654321      \n         1234567890987654321     \n        123456789010987654321    \n       12345678901210987654321   \n      1234567890123210987654321  \n     123456789012343210987654321 \n    12345678901234543210987654321\n     123456789012343210987654321 \n      1234567890123210987654321  \n       12345678901210987654321   \n        123456789010987654321    \n         1234567890987654321     \n          12345678987654321      \n           123456787654321       \n            1234567654321        \n             12345654321         \n              123454321          \n               1234321           \n                12321            \n                 121             \n                  1              \n\npattern(20):\n\n                       1                   \n                      121                  \n                     12321                 \n                    1234321                \n                   123454321               \n                  12345654321              \n                 1234567654321             \n                123456787654321            \n               12345678987654321           \n              1234567890987654321          \n             123456789010987654321         \n            12345678901210987654321        \n           1234567890123210987654321       \n          123456789012343210987654321      \n         12345678901234543210987654321     \n        1234567890123456543210987654321    \n       123456789012345676543210987654321   \n      12345678901234567876543210987654321  \n     1234567890123456789876543210987654321 \n    123456789012345678909876543210987654321\n     1234567890123456789876543210987654321 \n      12345678901234567876543210987654321  \n       123456789012345676543210987654321   \n        1234567890123456543210987654321    \n         12345678901234543210987654321     \n          123456789012343210987654321      \n           1234567890123210987654321       \n            12345678901210987654321        \n             123456789010987654321         \n              1234567890987654321          \n               12345678987654321           \n                123456787654321            \n                 1234567654321             \n                  12345654321              \n                   123454321               \n                    1234321                \n                     12321                 \n                      121                  \n                       1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern (n : Int) : String :=\nsorry\n\ndef lines (s : String) : List String :=\nsorry\n\ndef reverseString (s : String) : String :=\nsorry", "vc-theorems": "theorem pattern_negative_or_zero (n : Int) :\n  n ≤ 0 → pattern n = \"\" :=\nsorry\n\ntheorem pattern_num_lines (n : Int) :\n  n > 0 → (lines (pattern n)).length = 2*n - 1 :=\nsorry\n\ntheorem pattern_symmetric_lines (n : Int) (i : Nat) :\n  n > 0 → i < n-1 →\n  (lines (pattern n)).get ⟨i, sorry⟩ = (lines (pattern n)).get ⟨n.toNat * 2 - 2 - i, sorry⟩ :=\nsorry\n\ntheorem pattern_middle_line_palindrome (n : Int) :\n  n > 0 →\n  let middle := (lines (pattern n)).get ⟨(n-1).toNat, sorry⟩\n  middle = reverseString middle :=\nsorry\n\ntheorem pattern_middle_line_length (n : Int) :\n  n > 0 →\n  let middle := (lines (pattern n)).get ⟨(n-1).toNat, sorry⟩\n  middle.length = 2*n-1 :=\nsorry\n\ntheorem pattern_line_length (n : Int) (i : Nat) :\n  n > 0 → i < n →\n  let line := (lines (pattern n)).get ⟨i, sorry⟩\n  line.length = 2*(i+1)-1 + 2*(n.toNat-(i+1)) :=\nsorry\n\ntheorem pattern_line_palindrome (n : Int) (i : Nat) :\n  n > 0 → i < n →\n  let line := (lines (pattern n)).get ⟨i, sorry⟩\n  line.trim = reverseString (line.trim) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval pattern 1\n\n/--\ninfo: '  1  \\n 121 \\n12321\\n 121 \\n  1  '\n-/\n#guard_msgs in\n#eval pattern 3\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"}
{"id": "fvapps_004467", "vc-description": "/-\nWrite a function ```convert_temp(temp, from_scale, to_scale)``` converting temperature from one scale to another. \nReturn converted temp value. \n\nRound converted temp value to an integer(!).\n\nReading: http://en.wikipedia.org/wiki/Conversion_of_units_of_temperature\n\n```\npossible scale inputs:\n    \"C\"  for Celsius\n    \"F\"  for Fahrenheit\n    \"K\"  for Kelvin\n    \"R\"  for Rankine\n    \"De\" for Delisle\n    \"N\"  for Newton\n    \"Re\" for Réaumur\n    \"Ro\" for Rømer\n```\n\n```temp``` is a number, ```from_scale``` and ```to_scale``` are strings. \n\n```python\nconvert_temp(   100, \"C\",  \"F\") # => 212\nconvert_temp(    40, \"Re\", \"C\") # => 50\nconvert_temp(    60, \"De\", \"F\") # => 140\nconvert_temp(373.15, \"K\",  \"N\") # => 33\nconvert_temp(   666, \"K\",  \"K\") # => 666\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def convert_temp (temp : Float) (from_scale : String) (to_scale : String) : Int :=\n  sorry\n\ndef round (x : Float) : Int :=\n  sorry\n\ndef int_to_float (n : Int) : Float :=\n  sorry", "vc-theorems": "theorem convert_temp_identity {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  convert_temp temp scale scale = round temp := by\n  sorry\n\ntheorem convert_temp_returns_int {temp : Float} {from_scale to_scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) :\n  ∃ n : Int, convert_temp temp from_scale to_scale = n := by\n  sorry\n\ntheorem convert_temp_kelvin_roundtrip {temp : Float} {scale : String}\n  (h1 : -1000 ≤ temp) (h2 : temp ≤ 1000) (h3 : scale ≠ \"K\") :\n  let kelvin := int_to_float (convert_temp temp scale \"K\")\n  let back := convert_temp kelvin \"K\" scale\n  (back - round temp) ≤ 2 ∧ (round temp - back) ≤ 2 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 212\n-/\n#guard_msgs in\n#eval convert_temp 100 \"C\" \"F\"\n\n/--\ninfo: 50\n-/\n#guard_msgs in\n#eval convert_temp 40 \"Re\" \"C\"\n\n/--\ninfo: 140\n-/\n#guard_msgs in\n#eval convert_temp 60 \"De\" \"F\"\n\n/--\ninfo: 33\n-/\n#guard_msgs in\n#eval convert_temp 373.15 \"K\" \"N\"\n\n/--\ninfo: 666\n-/\n#guard_msgs in\n#eval convert_temp 666 \"K\" \"K\""}
{"id": "fvapps_004481", "vc-description": "/-\n#### Task:\n\nYour job here is to write a function (`keepOrder` in JS/CoffeeScript, `keep_order` in Ruby/Crystal/Python, `keeporder` in Julia), which takes a sorted array `ary` and a value `val`, and returns the lowest index where you could insert `val` to maintain the sorted-ness of the array. The input array will always be sorted in ascending order. It may contain duplicates.\n\n_Do not modify the input._\n\n#### Some examples:\n\n```python\nkeep_order([1, 2, 3, 4, 7], 5) #=> 4\n                      ^(index 4)\nkeep_order([1, 2, 3, 4, 7], 0) #=> 0\n          ^(index 0)\nkeep_order([1, 1, 2, 2, 2], 2) #=> 2\n                ^(index 2)\n```\n\nAlso check out my other creations — [Naming Files](https://www.codewars.com/kata/naming-files), [Elections: Weighted Average](https://www.codewars.com/kata/elections-weighted-average), [Identify Case](https://www.codewars.com/kata/identify-case), [Split Without Loss](https://www.codewars.com/kata/split-without-loss), [Adding Fractions](https://www.codewars.com/kata/adding-fractions),\n[Random Integers](https://www.codewars.com/kata/random-integers), [Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose), [Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1), and [Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2).\n\nIf you notice any issues or have any suggestions/comments whatsoever, please don't hesitate to mark an issue or just comment. Thanks!\n-/", "vc-preamble": "def min_of_list (arr : List Int) : Int :=\n  match arr with\n  | [] => 0\n  | x::xs => xs.foldl min x\n\ndef max_of_list (arr : List Int) : Int :=\n  match arr with\n  | [] => 0\n  | x::xs => xs.foldl max x", "vc-helpers": "", "vc-definitions": "def keep_order (arr : List Int) (val : Int) : Nat :=\nsorry", "vc-theorems": "theorem keep_order_bounds {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  0 ≤ idx ∧ idx ≤ arr.length :=\nsorry\n\ntheorem keep_order_before {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  ∀ i, i < idx → arr[i]! < val :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 5\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 0\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval keep_order [1, 1, 2, 2, 2] 2"}
{"id": "fvapps_004489", "vc-description": "/-\n## Task\n In your favorite game, you must shoot a target with a water-gun to gain points. Each target can be worth a different amount of points. \n\n You are guaranteed to hit every target that you try to hit. You cannot hit consecutive targets though because targets are only visible for one second (one at a time) and it takes you a full second to reload your water-gun after shooting (you start the game already loaded).\n\n Given an array `vals` with the order of each target's point value, determine the maximum number of points that you can win.\n\n## Example\n For `vals = [1, 2, 3, 4]`, the result should be `6`.\n\n your optimal strategy would be to let the first one pass and shoot the second one with value 2 and the 4th one with value 4 thus:\n\n `vals[1](2) + vals[3](4) = 6`\n\n For `vals = [5, 5, 5, 5, 5]`, the result should be `15`.\n\n your optimal strategy would be to shoot the 1st, 3rd and 5th value:\n\n `5 + 5 + 5 = 15`\n\n You haven't shoot the 2nd, 4th value because you are reloading your water-gun after shooting other values.\n\n Note that the value can be zero or negative, don't shoot them ;-)\n\n For `vals = [0, 0, -1, -1]`, the result should be `0`.\n\n For `vals = [5, -2, -9, -4]`, the result should be `5`.\n\n Shoot the first one is enough.\n\n## Input/Output\n\n - `[input]` integer array `vals`\n\n  The point values (negative or non-negative) of the targets (in order of appearance).\n\n - `[output]` an integer\n\n  The maximum number of points that you can score.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (l : List Int) : Int :=\nsorry\n\ndef maximum? (l : List Int) : Option Int :=\nsorry\n\ndef filterWithIndex (l : List Int) (f : Nat → Int → Bool) : List Int :=\nsorry\n\ndef target_game (vals : List Int) : Int :=\nsorry", "vc-theorems": "theorem target_game_nonneg (vals : List Int)\n  (h : vals ≠ []) :\n  target_game vals ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval target_game [1, 2, 3, 4]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval target_game [5, 5, 5, 5, 5]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval target_game [5, -2, -9, -4]"}
{"id": "fvapps_004491", "vc-description": "/-\nEver since you started work at the grocer, you have been faithfully logging down each item and its category that passes through. One day, your boss walks in and asks, \"Why are we just randomly placing the items everywhere? It's too difficult to find anything in this place!\" Now's your chance to improve the system, impress your boss, and get that raise!\n\nThe input is a comma-separated list with category as the prefix in the form `\"fruit_banana\"`. Your task is to group each item into the 4 categories `Fruit, Meat, Other, Vegetable` and output a string with a category on each line followed by a sorted comma-separated list of items.\n\nFor example, given:\n\n```\n\"fruit_banana,vegetable_carrot,fruit_apple,canned_sardines,drink_juice,fruit_orange\"\n```\n\noutput:\n\n```\n\"fruit:apple,banana,orange\\nmeat:\\nother:juice,sardines\\nvegetable:carrot\"\n```\n\nAssume that:\n1. Only strings of the format `category_item` will be passed in\n2. Strings will always be in lower case\n3. Input will not be empty\n4. Category and/or item will not be empty\n5. There will be no duplicate items\n6. All categories may not have items\n-/", "vc-preamble": "inductive Category where\n  | fruit : Category\n  | meat : Category\n  | vegetable : Category\n  | other : Category\nderiving BEq, Repr\n\nstructure GroceryItem where\n  category : Category\n  name : String\nderiving Repr\n\ndef length4 (s : List α) : Prop := s.length = 4\n\ninductive isSorted : List String → Prop where\n  | nil : isSorted []\n  | single : (x : String) → isSorted [x]\n  | cons : (x y : String) → (rest : List String) →\n          x <= y → isSorted (y::rest) → isSorted (x::y::rest)", "vc-helpers": "", "vc-definitions": "def group_groceries (input : String) : String :=\n  sorry\n\ndef isValidCategoryName (name : String) : Bool :=\n  sorry", "vc-theorems": "theorem group_groceries_produces_four_lines (input : String) :\n  length4 ((group_groceries input).splitOn \"\\n\") :=\nsorry\n\ntheorem group_groceries_uses_expected_categories (input : String) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  lines[0]!.startsWith \"fruit:\" ∧\n  lines[1]!.startsWith \"meat:\" ∧\n  lines[2]!.startsWith \"other:\" ∧\n  lines[3]!.startsWith \"vegetable:\" :=\nsorry\n\ntheorem group_groceries_items_sorted (input : String) (i : Nat) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  let items := (lines[i]!.splitOn \":\")[1]!.splitOn \",\"\n  items.length > 0 → isSorted items :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,meat_chicken,drink_juice\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,fruit_apple,canned_sardines,drink_juice,fruit_orange\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_orange\""}
{"id": "fvapps_004496", "vc-description": "/-\nFor a given two numbers your mission is to derive a function that evaluates whether two given numbers are **abundant**, **deficient** or **perfect** and whether together they are **amicable**.\n\n### Abundant Numbers\nAn abundant number or excessive number is a number for which the sum of its proper divisors is greater than the number itself.\n\nThe integer 12 is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of 16 (> 12).\n\n### Deficient Numbers\nA deficient number is a number for which the sum of its proper divisors is less than the number itself.\n\nThe first few deficient numbers are: 1, 2, 3, 4, 5, 7, 8, 9.\n\n### Perfect Numbers\nA perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself. \n\nThe first perfect number is 6, because 1, 2, and 3 are its proper positive divisors, and 1 + 2 + 3 = 6.\n\n### Amicable Numbers\nAmicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number. (A proper divisor of a number is a positive factor of that number other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.)\n\nFor example, the smallest pair of amicable numbers is (220, 284); for the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110, of which the sum is 284; and the proper divisors of 284 are 1, 2, 4, 71 and 142, of which the sum is 220.\n\n### The Function\n\nFor a given two numbers, derive function `deficientlyAbundantAmicableNumbers(num1, num2)` which returns a string with first and second word either abundant or deficient depending on whether `num1` or `num2` are abundant, deficient or perfect. The string should finish with either amicable or not amicable depending on the relationship between `num1` and `num2`.\n\ne.g. `deficientlyAbundantAmicableNumbers(220, 284)` returns `\"abundant deficient amicable\"` as 220 is an abundant number, 284 is a deficient number and amicable because 220 and 284 are an amicable number pair. \n\nSee Part 1 - [Excessively Abundant Numbers](http://www.codewars.com/kata/56a75b91688b49ad94000015)\n\nSee Part 2 - [The Most Amicable of Numbers](http://www.codewars.com/kata/56b5ebaa26fd54188b000018)\n-/\n\n/- The kind function only outputs \"abundant\", \"deficient\", or \"perfect\" -/\n\n/- Properties of deficiently abundant amicable numbers output -/\n\n/- Symmetric property of amicable numbers -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumOfDivs (n : Nat) : Nat :=\nsorry\n\ndef kind (n : Nat) (sum : Nat) : String :=\nsorry\n\ndef deficientlyAbundantAmicableNumbers (n1 n2 : Nat) : String :=\nsorry", "vc-theorems": "theorem kind_outputs {n : Nat} (h : n > 0) :\n  let sum := sumOfDivs n\n  let k := kind n sum\n  (k = \"abundant\" ∨ k = \"deficient\" ∨ k = \"perfect\") :=\nsorry\n\ntheorem deficientlyabundant_properties {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result := deficientlyAbundantAmicableNumbers n1 n2\n  let sum1 := sumOfDivs n1\n  let sum2 := sumOfDivs n2\n  let is_amicable := sum1 = n2 ∧ sum2 = n1 ∧ n1 ≠ n2\n  result.contains 'n' = !is_amicable :=\nsorry\n\ntheorem symmetric_property {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result1 := deficientlyAbundantAmicableNumbers n1 n2\n  let result2 := deficientlyAbundantAmicableNumbers n2 n1\n  result1.contains 'n' = result2.contains 'n' :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004497", "vc-description": "/-\nSimilar to the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/), but this time you need to operate with shuffled strings to identify if they are composed repeating a subpattern\n\nSince there is no deterministic way to tell which pattern was really the original one among all the possible permutations of a fitting subpattern, return a subpattern with sorted characters, otherwise return the base string with sorted characters (you might consider this case as an edge case, with the subpattern being repeated only once and thus equalling the original input string).\n\nFor example:\n\n```python\nhas_subpattern(\"a\") == \"a\"; #no repeated pattern, just one character\nhas_subpattern(\"aaaa\") == \"a\" #just one character repeated\nhas_subpattern(\"abcd\") == \"abcd\" #base pattern equals the string itself, no repetitions\nhas_subpattern(\"babababababababa\") == \"ab\" #remember to return the base string sorted\"\nhas_subpattern(\"bbabbaaabbaaaabb\") == \"ab\" #same as above, just shuffled\n```\n\nIf you liked it, go for either the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/) or the [next kata](https://www.codewars.com/kata/string-subpattern-recognition-iv/) of the series!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n-- Result length less than input length\n\n-- Result chars are sorted\n\n-- Result chars come from input", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\nsorry\n\ndef String.toCharArray (s : String) : Array Char :=\nsorry\n\ndef String.fromCharArray (arr : Array Char) : String :=\nsorry\n\ndef has_subpattern (s : String) : String :=\nsorry", "vc-theorems": "theorem output_is_substring (s : String) (h : s.length > 0) :\n  let result := has_subpattern s\n\n  result.length ≤ s.length ∧\n\n  (∀ i j, i < j → i < result.length → j < result.length →\n    result.toCharArray[i]! ≤ result.toCharArray[j]!) ∧\n\n  (∀ c, c ∈ result.toCharArray.toList → c ∈ s.toCharArray.toList) :=\nsorry\n\ntheorem output_pattern_reconstruction (s : String) (h : s.length > 0) :\n  let pattern := has_subpattern s\n  let counts_s := s.toCharArray.toList.map (fun c => (c, s.count c))\n  let counts_p := pattern.toCharArray.toList.map (fun c => (c, pattern.count c))\n  pattern.length > 0 →\n  ∃ ratio : Nat, ∀ (s_c p_c : Char) (s_count p_count : Nat),\n    (s_c, s_count) ∈ counts_s →\n    (p_c, p_count) ∈ counts_p →\n    s_count = p_count * ratio :=\nsorry\n\ntheorem idempotent (s : String) (h : s.length > 0) :\n  has_subpattern s = has_subpattern (has_subpattern s) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004501", "vc-description": "/-\n=====Function Descriptions=====\nre.findall()\n\nThe expression re.findall() returns all the non-overlapping matches of patterns in a string as a list of strings.\nCode\n\n>>> import re\n>>> re.findall(r'\\w','http://www.hackerrank.com/')\n['h', 't', 't', 'p', 'w', 'w', 'w', 'h', 'a', 'c', 'k', 'e', 'r', 'r', 'a', 'n', 'k', 'c', 'o', 'm']\n\nre.finditer()\n\nThe expression re.finditer() returns an iterator yielding MatchObject instances over all non-overlapping matches for the re pattern in the string.\nCode\n\n>>> import re\n>>> re.finditer(r'\\w','http://www.hackerrank.com/')\n<callable-iterator object at 0x0266C790>\n>>> map(lambda x: x.group(),re.finditer(r'\\w','http://www.hackerrank.com/'))\n['h', 't', 't', 'p', 'w', 'w', 'w', 'h', 'a', 'c', 'k', 'e', 'r', 'r', 'a', 'n', 'k', 'c', 'o', 'm']\n\n=====Problem Statement=====\nYou are given a string S. It consists of alphanumeric characters, spaces and symbols(+,-).\nYour task is to find all the substrings of S that contains 2 or more vowels.\nAlso, these substrings must lie in between 2 consonants and should contain vowels only.\n\nNote :\nVowels are defined as: AEIOU and aeiou.\nConsonants are defined as: QWRTYPSDFGHJKLZXCVBNM and qwrtypsdfghjklzxcvbnm.\n\n=====Input Format=====\nA single line of input containing string S.\n\n=====Constraints=====\n0<len(S)<100\n\n=====Output Format=====\nPrint the matched substrings in their order of occurrence on separate lines.\nIf no match is found, print -1.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isVowel (c : Char) : Bool :=\n  sorry\n\ndef find_vowel_substrings (s : String) : List String :=\n  sorry", "vc-theorems": "theorem find_vowel_substrings_valid_input {s : String}\n  (h : ∃ pre mid post : String,\n    (∀ c, c ∈ pre.data → !isVowel c) ∧\n    (∀ c, c ∈ mid.data → isVowel c) ∧\n    (∀ c, c ∈ post.data → !isVowel c) ∧\n    mid.length ≥ 2 ∧\n    s = pre ++ mid ++ post) :\n  ∃ result : List String,\n    find_vowel_substrings s = result ∧\n    result ≠ [\"-1\"] ∧\n    ∀ substr ∈ result,\n      substr.length ≥ 2 ∧\n      ∀ c, c ∈ substr.data → isVowel c :=\nsorry\n\ntheorem find_vowel_substrings_invalid_input {s : String}\n  (h : ∀ c, c ∈ s.data → !isVowel c) :\n  find_vowel_substrings s = [\"-1\"] :=\nsorry\n\ntheorem find_vowel_substrings_general {s : String} :\n  let result := find_vowel_substrings s\n  result = [\"-1\"] ∨\n  (∀ substr ∈ result,\n    substr.length ≥ 2 ∧\n    ∀ c, c ∈ substr.data → isVowel c) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004502", "vc-description": "/-\nYou are given four positive integers $n$, $m$, $a$, $b$ ($1 \\le b \\le n \\le 50$; $1 \\le a \\le m \\le 50$). Find any such rectangular matrix of size $n \\times m$ that satisfies all of the following conditions:\n\n  each row of the matrix contains exactly $a$ ones;  each column of the matrix contains exactly $b$ ones;  all other elements are zeros. \n\nIf the desired matrix does not exist, indicate this.\n\nFor example, for $n=3$, $m=6$, $a=2$, $b=1$, there exists a matrix satisfying the conditions above:\n\n$$ \\begin{vmatrix} 0 & 1 & 0 & 0 & 0 & 1 \\\\ 1 & 0 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 & 0 \\end{vmatrix} $$\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Then $t$ test cases follow.\n\nEach test case is described by four positive integers $n$, $m$, $a$, $b$ ($1 \\le b \\le n \\le 50$; $1 \\le a \\le m \\le 50$), where $n$ and $m$ are the sizes of the matrix, and $a$ and $b$ are the number of ones for rows and columns, respectively.\n\n-----Output-----\n\nFor each test case print:\n\n  \"YES\" (without quotes) and the required matrix (if there are several answers, print any) if it exists, or  \"NO\" (without quotes) if it does not exist. \n\nTo print the matrix $n \\times m$, print $n$ rows, each of which consists of $m$ numbers $0$ or $1$ describing a row of the matrix. Numbers must be printed without spaces.\n\n-----Example-----\nInput\n5\n3 6 2 1\n2 2 2 1\n2 2 2 2\n4 4 2 2\n2 1 1 2\n\nOutput\nYES\n010001\n100100\n001010\nNO\nYES\n11\n11\nYES\n1100\n1100\n0011\n0011\nYES\n1\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Matrix := List (List Bool)\n\ndef solveMatrix (m n a b : Nat) : Option Matrix :=\n  sorry\n\ndef matrixToStr (m : Matrix) : String :=\n  sorry", "vc-theorems": "theorem solve_matrix_valid_2_2_1_1 :\n  ∃ (result : Matrix),\n    solveMatrix 2 2 1 1 = some result ∧\n    matrixToStr result = \"10\\n01\"\n  :=\nsorry\n\ntheorem solve_matrix_valid_2_2_2_2 :\n  ∃ (result : Matrix),\n    solveMatrix 2 2 2 2 = some result ∧\n    matrixToStr result = \"11\\n11\"\n  :=\nsorry\n\ntheorem solve_matrix_valid_3_6_2_1 :\n  ∃ (result : Matrix),\n    solveMatrix 3 6 2 1 = some result ∧\n    matrixToStr result = \"110000\\n001100\\n000011\"\n  :=\nsorry\n\ntheorem solve_matrix_impossible_2_2_2_1 :\n  solveMatrix 2 2 2 1 = none :=\nsorry\n\ntheorem solve_matrix_impossible_3_3_3_1 :\n  solveMatrix 3 3 3 1 = none :=\nsorry\n\ntheorem solve_matrix_impossible_greater_dimensions :\n  (∀ m n : Nat, m > 0 → n > 0 →\n    (∀ a b : Nat, (a > m ∨ b > n) →\n      solveMatrix m n a b = none)) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result"}
{"id": "fvapps_004507", "vc-description": "/-\nThe business has been suffering for years under the watch of Homie the Clown. Every time there is a push to production it requires 500 hands-on deck, a massive manual process, and the fire department is on stand-by along with Fire Marshall Bill the king of manual configuration management. He is called a Fire Marshall because production pushes often burst into flames and rollbacks are a hazard.\n\nThe business demands change and as such has hired a new leader who wants to convert it all to DevOps…..there is a new Sheriff in town.\n\nThe Sheriff's first order of business is to build a DevOps team. He likes Microservices, Cloud, Open-Source, and wants to push to production 9500 times per day without even pressing a button, beautiful seamless immutable infrastructure properly baked in the Continuous Delivery oven is the goal.\n\nThe only problem is Homie the Clown along with Legacy Pete are grandfathered in and union, they started out in the era of green screens and punch cards and are set in their ways. They are not paid by an outcome but instead are measured by the amount of infrastructure under management and total staff headcount.\n\nThe Sheriff has hired a new team of DevOps Engineers. They advocate Open Source, Cloud, and never doing a manual task more than one time. They believe Operations to be a first class citizen with Development and are preparing to shake things up within the company. \n\nSince Legacy is not going away, yet, the Sheriff's job is to get everyone to cooperate so DevOps and the Cloud will be standard. The New Kids on the Block have just started work and are looking to build common services with Legacy Pete and Homie the Clown. \n```\nEvery Time the NKOTB propose a DevOps pattern…… \n\nHomie stands up and says \"Homie don't Play that!\"\n\nIE: \n\nNKOTB Say -> \"We need Cloud now!\"\n\nHomie Say -> \"Cloud! Homie dont play that!\"\n\nNKOTB Say -> \"We need Automation now!\"\n\nHomie Say -> \"Automation! Homie dont play that!\"\n\nNKOTB Say -> \"We need Microservices now!\"\n\nHomie Say -> \"Microservices! Homie dont play that!\"\n\n```\n\nTask \n\nYou will receive a two-dimensional array with strings made of the NKOTB’s requirements. Each Array contains a domain of DevOps patterns that each of the 5 NKOTB are asking for.\n\nThe requirements array will ALWAYS have five sub-arrays structured like this:\n```\nrequirements[0] = monitoring\nrequirements[1] = automation\nrequirements[2] = deployment\nrequirements[3] = cloud\nrequirements[4] = microservices\n\nEach sub-array will always contain strings in the same format\n\nThe strings will always be in the following format(case insensitive):\n\n\"We need Microservices now!\"\n\nYour job is to create the response from Homie the Clown following the pattern above. \n\nThen return the responses in an array.\n\n\"Microservices! Homie dont play that!\"\n```\nThe first word of the response is always Capitalized and all other letters are lowercase regardless of how you recieve them, the rest of the sentence is always in the format ``` Homie dont play that!```. Strings should be returned in the same order.\n```\nIn addition to the responses create a count of each domain and return it as the last element of the return array in the following format.\n\n'6 monitoring objections, 4 automation, 6 deployment pipeline, 6 cloud, and 3 microservices.'\n\n```\nFor more information on Homie the Clown.\n\nhttps://www.youtube.com/watch?v=_QhuBIkPXn0\n\nFire Marshall Bill on Vacation!\n\nhttps://www.youtube.com/watch?v=IIIsCB4Y8sw#t=202.002651\n-/", "vc-preamble": "def List.sumLength (l: List (List α)) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x.length + xs.sumLength", "vc-helpers": "", "vc-definitions": "def String.hasPattern (s pattern: String) : Prop :=\nsorry\n\ndef String.hasSuffix (s suffix: String) : Prop :=\nsorry\n\ndef nkotb_vs_homie (reqs: List (List String)) : List String :=\nsorry", "vc-theorems": "theorem response_count (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  : (nkotb_vs_homie reqs).length = (reqs.sumLength + 1) :=\nsorry\n\ntheorem responses_end_with_homie (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  (result := nkotb_vs_homie reqs)\n  (i: Fin result.length)\n  (h3: i.val < reqs.sumLength)\n  : (result.get ⟨i.val, i.isLt⟩).hasSuffix \"! Homie dont play that!\" :=\nsorry\n\ntheorem summary_contains_sections (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: ∀ cat ∈ reqs, cat.length > 0 ∧ cat.length ≤ 5)\n  (result := nkotb_vs_homie reqs)\n  (h3: reqs.sumLength < result.length)\n  : let summary := result.get ⟨reqs.sumLength, h3⟩\n    summary.hasPattern \"monitoring objections\" ∧\n    summary.hasPattern \"automation\" ∧\n    summary.hasPattern \"deployment pipeline\" ∧\n    summary.hasPattern \"cloud\" ∧\n    summary.hasPattern \"microservices\" :=\nsorry\n\ntheorem empty_categories_response\n  (empty_reqs: List (List String))\n  (h1: empty_reqs = [[], [], [], [], []])\n  : nkotb_vs_homie empty_reqs = [\"0 monitoring objections, 0 automation, 0 deployment pipeline, 0 cloud, and 0 microservices.\"] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval nkotb_vs_homie [[\"We need Monitoring now!\"], [\"We need Automation now!\"], [\"We need Deployment now!\"], [\"We need Cloud now!\"], [\"We need Microservices now!\"]]"}
{"id": "fvapps_004519", "vc-description": "/-\nBe u(n) a sequence beginning with:\n```\nu[1]  = 1,  u[2]  = 1,  u[3]  = 2,  u[4]  = 3,  u[5]  = 3,  u[6] = 4,\n\nu[7]  = 5,  u[8]  = 5,  u[9]  = 6,  u[10] = 6,  u[11] = 6,  u[12] = 8,\n\nu[13] = 8,  u[14] = 8,  u[15] = 10, u[16] = 9,  u[17] = 10, u[18] = 11,\n\nu[19] = 11, u[20] = 12, u[21] = 12, u[22] = 12, u[23] = 12 etc...\n\n```\n- How is`u[8]` calculated?\n\nWe have `u[7] = 5` and `u[6] = 4`. These numbers tell us that we have to go backwards from index `8` to index `8 - 5 = 3` and to index `8 - 4 = 4` so to index `3` and `4`.\n\n``` u[3] = 2``` and ```u[4] = 3```  hence ```u[8] = u[3] + u[4] = 2 + 3 = 5```.\n\n- Another example: let us calculate `u[13]`. At indexes `12` and `11` we have `8` and `6`. Going backwards of `8` and `6` from `13` we get indexes `13 - 8 = 5` and `13 - 6 = 7`. \n\n``` u[5] = 3```  and ``` u[7] = 5```  so ``` u[13] = u[5] + u[7] = 3 + 5 = 8``` .\n\n## Task\n- 0) Express u(n) as a function of n, u[n - 1], u[n - 2]. (not tested).\n\n- 1) Given two numbers `n, k (integers > 2)` write the function `length_sup_u_k(n, k) or lengthSupUK or length-sup-u-k` returning the number of terms `u[i] >= k` with `1 <= i <= n`. \nIf we look above we can see that between `u[1]` and `u[23]` we have four `u[i]` greater or equal to `12`: `length_sup_u_k(23, 12) => 4`\n\n- 2) Given `n (integer > 2)` write the function `comp(n)` returning the number of times where a term of `u` is less than its **predecessor** up to and including u[n]. \n\n## Examples:\n\n```\nu(900) => 455 (not tested)\nu(90000) => 44337 (not tested)\n\nlength_sup_u_k(23, 12) => 4\nlength_sup_u_k(50, 10) => 35\nlength_sup_u_k(500, 100) => 304\n\ncomp(23) => 1 (since only u(16) < u(15))\ncomp(100) => 22\ncomp(200) => 63\n```\n\n## Note: Shell\nShell tests only `lengthSupUk`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def length_sup_u_k (n : Nat) (k : Nat) : Nat :=\n  sorry\n\ndef comp (n : Nat) : Nat :=\n  sorry\n\ndef u1 : List Nat :=\n  sorry", "vc-theorems": "theorem length_sup_u_k_bounds (n k : Nat) (h : n > 0) :\n  0 ≤ length_sup_u_k n k ∧ length_sup_u_k n k ≤ n :=\nsorry\n\ntheorem comp_bounds (n : Nat) (h : n > 1) :\n  0 ≤ comp n ∧ comp n ≤ n - 1 :=\nsorry\n\ntheorem comp_deterministic (n : Nat) :\n  comp n = comp n :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval length_sup_u_k 23 12\n\n/--\ninfo: 35\n-/\n#guard_msgs in\n#eval length_sup_u_k 50 10\n\n/--\ninfo: 304\n-/\n#guard_msgs in\n#eval length_sup_u_k 500 100\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval comp 23\n\n/--\ninfo: 22\n-/\n#guard_msgs in\n#eval comp 100\n\n/--\ninfo: 63\n-/\n#guard_msgs in\n#eval comp 200"}
{"id": "fvapps_004522", "vc-description": "/-\nEverybody loves **pi**, but what if **pi** were a square? Given a number of digits ```digits```, find the smallest integer whose square is greater or equal to the sum of the squares of the first ```digits``` digits of pi, including the ```3``` before the decimal point.\n\n**Note:** Test cases will not extend beyond 100 digits; the first 100 digits of pi are pasted here for your convenience:\n```\n31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\n```\n\n## Examples\n\n```\ndigits   = 1   #  [3]\nexpected = 3   #  sqrt(3^2) = 3\n\ndigits   = 3   #  [3, 1, 4]\nexpected = 6   #  sqrt(3^2 + 1^2 + 4^2) = 5.099 --> 6\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxLen : Nat :=\nsorry\n\ndef sum_squares (n : Nat) : Nat :=\nsorry\n\ndef square_pi (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem square_pi_monotone {n₁ n₂ : Nat} (h : n₁ ≤ n₂) (h2 : n₂ ≤ maxLen) :\n  square_pi n₁ ≤ square_pi n₂ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval square_pi 1\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval square_pi 3\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval square_pi 5"}
{"id": "fvapps_004524", "vc-description": "/-\nIn Scala, an underscore may be used to create a partially applied version of an infix operator using placeholder syntax. For example, `(_ * 3)` is a function that multiplies its input by 3. With a bit of manipulation, this idea can be extended to work on any arbitrary expression.\n\nCreate an value/object named `x` that acts as a placeholder in an arithmetic expression. The placeholder should support the four basic integer arithmetic operations: addition, subtraction, multiplication, and integral (floor) division. When the expression with placeholders is called, it should fill the placeholders in the expression from left to right (regardless of operator precedence) with the values it is given.\n\nHere are a few examples:\n```\ncalling (x + 3)       with [1]   gives 1 + 3               = 4\ncalling (10 - x)      with [4]   gives 10 - 4              = 6\ncalling (x + 2 * x)   with [1 3] gives 1 + 2 * 3   = 1 + 6 = 7\ncalling ((x + 2) * x) with [1 3] gives (1 + 2) * 3 = 3 * 3 = 9\ncalling (4 * (x / 2)) with [5]   gives 4 * (5 / 2) = 4 * 2 = 8\n```\n\nAll inputs and outputs to/from the expression will be integer types. All expressions tested in this kata will be valid, i.e. there will be no division by zero and the number of values passed in will always be the same as the number of placeholders.\n\nNote: `eval` and `exec` are disabled\n-/\n\n-- Apps difficulty: introductory\n\n-- Assurance level: unguarded", "vc-preamble": "def add : Int → Int → Int := fun a b => a + b\n\ndef sub : Int → Int → Int := fun a b => a - b\n\ndef mul : Int → Int → Int := fun a b => a * b\n\ndef div : Int → Int → Int := fun a b => a / b", "vc-helpers": "", "vc-definitions": "def x : List Int → Int :=\nsorry", "vc-theorems": "theorem placeholder_identity (args : List Int) (h : args.length > 0) :\n  x args = args.head! := by\nsorry\n\ntheorem placeholder_binary_ops_forward (a b : Int) :\n  (add (x [a]) b) = add a b ∧\n  (sub (x [a]) b) = sub a b ∧\n  (mul (x [a]) b) = mul a b := by\nsorry\n\ntheorem placeholder_binary_ops_reverse (a b : Int) :\n  add b (x [a]) = add b a ∧\n  sub b (x [a]) = sub b a ∧\n  mul b (x [a]) = mul b a := by\nsorry\n\ntheorem placeholder_binary_ops_div (a b : Int) :\n  b ≠ 0 → div (x [a]) b = div a b := by\nsorry\n\ntheorem placeholder_binary_ops_div_reverse (a b : Int) :\n  a ≠ 0 → div b (x [a]) = div b a := by\nsorry\n\ntheorem placeholder_chaining (args : List Int) (h : args.length > 1) :\n  add (x [args.head!]) (x [args.tail.head!]) = add args.head! args.tail.head! ∧\n  mul (x [args.head!]) (x [args.tail.head!]) = mul args.head! args.tail.head! ∧\n  add (x [args.head!]) (mul 2 (x [args.tail.head!])) = add args.head! (mul 2 args.tail.head!) := by\nsorry\n\ntheorem placeholder_constant_folding (a : Int) :\n  add (add 2 3) (x [a]) = add 5 a ∧\n  add (mul 2 3) (x [a]) = add 6 a := by\nsorry", "vc-postamble": ""}
{"id": "fvapps_004527", "vc-description": "/-\n*** Nova polynomial derivative*** \n\nThis kata is from a series on polynomial handling. ( [#1](http://www.codewars.com/kata/nova-polynomial-1-add-1)   [#2](http://www.codewars.com/kata/570eb07e127ad107270005fe)  [#3](http://www.codewars.com/kata/5714041e8807940ff3001140 )   [#4](http://www.codewars.com/kata/571a2e2df24bdfd4e20001f5))\n\nConsider a polynomial in a list where each element in the list element corresponds to the factors. The factor order is the position in the list. The first element is the zero order factor (the constant).\n\np = [a0, a1, a2, a3] signifies the polynomial a0 + a1x + a2x^2 + a3*x^3\n\nIn this kata return the derivative of a polynomial:\n\n```python \npoly_derivative([1, 2] ) = [2]\npoly_derivative([9, 1, 3]) =  [1, 6]\n```\n\nPrevious Katas on Nova polynomial:\n\n 1. [poly_add](http://www.codewars.com/kata/nova-polynomial-1-add-1) \n 2. [poly_multiply](http://www.codewars.com/kata/570eb07e127ad107270005fe).\n 3. [poly_subtract](http://www.codewars.com/kata/5714041e8807940ff3001140 )\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def poly_derivative (p : List Int) : List Int :=\n  sorry\n\ndef scaleList (k : Int) (xs : List Int) : List Int :=\n  sorry\n\ndef zeroList (n : Nat) : List Int :=\n  sorry", "vc-theorems": "theorem derivative_length {p : List Int} (h : p ≠ []) :\n  (poly_derivative p).length = p.length - 1 :=\nsorry\n\ntheorem derivative_constant {p : List Int} (h : p.length = 1) :\n  poly_derivative p = [] :=\nsorry\n\ntheorem derivative_linear {p : List Int} (h : p.length ≥ 2) :\n  (poly_derivative p).get! 0 = p.get! 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [2]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2]\n\n/--\ninfo: [1, 6]\n-/\n#guard_msgs in\n#eval poly_derivative [9, 1, 3]\n\n/--\ninfo: [2, 6, 12]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2, 3, 4]"}
{"id": "fvapps_004529", "vc-description": "/-\nMy 5th kata, and 1st in a planned series of rock climbing themed katas.\n\nIn rock climbing ([bouldering](https://en.wikipedia.org/wiki/Bouldering) specifically), the V/Vermin (USA) climbing grades start at `'VB'` (the easiest grade), and then go `'V0'`, `'V0+'`, `'V1'`, `'V2'`, `'V3'`, `'V4'`, `'V5'` etc. up to `'V17'` (the hardest grade). You will be given a `list` (`lst`) of climbing grades and you have to write a function (`sort_grades`) to `return` a `list` of the grades sorted easiest to hardest.\n\nIf the input is an empty `list`, `return` an empty `list`; otherwise the input will always be a valid `list` of one or more grades.\n\nPlease do vote, rank, and provide any feedback on the kata.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def GradeString : Type := String\nderiving Inhabited\n\ndef grade_val (v : GradeString) : Int :=\n  sorry\n\ndef sort_grades (grades : List GradeString) : List GradeString :=\n  sorry", "vc-theorems": "theorem sort_preserves_size (grades : List GradeString) :\n  List.length (sort_grades grades) = List.length grades :=\nsorry\n\ntheorem sort_preserves_elements (grades : List GradeString) (g : GradeString) :\n  g ∈ grades ↔ g ∈ sort_grades grades :=\nsorry\n\ntheorem sort_is_ordered (grades : List GradeString) :\n  ∀ i : Nat, i + 1 < List.length (sort_grades grades) →\n  grade_val (List.get! (sort_grades grades) i) ≤\n  grade_val (List.get! (sort_grades grades) (i + 1)) :=\nsorry\n\ntheorem empty_list_sort :\n  sort_grades [] = [] :=\nsorry\n\ntheorem sort_idempotent (grades : List GradeString) :\n  sort_grades (sort_grades grades) = sort_grades grades :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval sort_grades []\n\n/--\ninfo: ['VB', 'V0', 'V1', 'V3']\n-/\n#guard_msgs in\n#eval sort_grades [\"V1\", \"VB\", \"V3\", \"V0\"]\n\n/--\ninfo: ['V0+', 'V1', 'V2']\n-/\n#guard_msgs in\n#eval sort_grades [\"V0+\", \"V2\", \"V1\"]"}
{"id": "fvapps_004534", "vc-description": "/-\n# Task\n Let's say that number a feels comfortable with number b if a ≠ b and b lies in the segment` [a - s(a), a + s(a)]`, where `s(x)` is the sum of x's digits.\n\n How many pairs (a, b) are there, such that a < b, both a and b lie on the segment `[L, R]`, and each number feels comfortable with the other?\n\n# Example\n\n For `L = 10 and R = 12`, the output should be `2`\n\n Here are all values of s(x) to consider:\n```\ns(10) = 1, so 10 is comfortable with 9 and 11;\ns(11) = 2, so 11 is comfortable with 9, 10, 12 and 13;\ns(12) = 3, so 12 is comfortable with 9, 10, 11, 13, 14 and 15.\nThus, there are 2 pairs of numbers comfortable \nwith each other within the segment [10; 12]: \n(10, 11) and (11, 12).\n```\n# Input/Output\n\n - `[input]` integer `L`\n\n    Constraints: `1 ≤ L ≤ R ≤ 1000`\n\n - `[input]` integer `R`\n\n    Constraints: `1 ≤ L ≤ R ≤ 1000`\n\n - `[output]` an integer\n\n    The number of pairs satisfying all the above conditions.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitSum (n : Nat) : Nat :=\n  sorry\n\ndef countComfortablePairs (l r : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem window_size (start : Nat) (window : Nat)\n  (h1 : start ≥ 1) (h2 : start ≤ 100) (h3 : window ≥ 0) (h4 : window ≤ 10) :\n  let result := countComfortablePairs start (start + window)\n  result ≥ 0 ∧ result ≤ (window + 1) * window / 2 :=\nsorry\n\ntheorem single_number (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 1000) :\n  countComfortablePairs n n = 0 :=\nsorry\n\ntheorem pairs_symmetry (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 100) :\n  let allPairs := countComfortablePairs 1 n\n  allPairs ≥ 0 ∧ allPairs ≤ n * 2 :=\nsorry\n\ntheorem small_ranges :\n  countComfortablePairs 1 1 = 0 ∧\n  countComfortablePairs 1 2 ≥ 0 ∧\n  countComfortablePairs 9 10 ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 10 12\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 1 9\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 13 13"}
{"id": "fvapps_004535", "vc-description": "/-\nWe will use the Flesch–Kincaid Grade Level to evaluate the readability of a piece of text. This grade level is an approximation for what schoolchildren are able to understand a piece of text. For example, a piece of text with a grade level of 7 can be read by seventh-graders and beyond.\n\nThe way to calculate the grade level is as follows:\n\n    (0.39 * average number of words per sentence) + (11.8 * average number of syllables per word) - 15.59\n\nWrite a function that will calculate the Flesch–Kincaid grade level for any given string. Return the grade level rounded to two decimal points.\n\nIgnore hyphens, dashes, apostrophes, parentheses, ellipses and abbreviations.\n\nRemember that the text can contain more than one sentence: code accordingly!\n\n**HINT**: Count the number of vowels as an approximation for the number of syllables, but count groups of vowels as one (e.g. `deal` is one syllable). **Do not** count `y` as a vowel!\n\n## Example\n\n```python\n\"The turtle is leaving.\" ==> 3.67\n```\n\nThe average number of words per sentence is `4` and the average number of syllables per word is `1.5`. The score is then `(0.39 * 4) +  (11.8 * 1.5) - 15.59` = `3.67`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count (s : String) (pattern : String) : Nat :=\n  sorry\n\ndef SENTENCE : String :=\n  sorry\n\ndef SYLLABLE : String :=\n  sorry\n\ndef flesch_kincaid (text : String) : Float :=\n  sorry", "vc-theorems": "theorem flesch_kincaid_result_is_float (text : String) (h : text.length > 0) :\n  ∃ (f : Float), flesch_kincaid text = f :=\nsorry\n\ntheorem flesch_kincaid_count_properties (text : String)\n  (h₁ : text.length > 0)\n  (h₂ : count text SENTENCE = 1) :\n  let words := count text \" \" + 1\n  let sentences := count text SENTENCE\n  let syllables := count text SYLLABLE\n  words ≥ 1 ∧\n  sentences = 1 ∧\n  syllables ≥ 0 ∧\n  syllables ≤ text.length :=\nsorry\n\ntheorem syllable_counting_vowels_only (text : String)\n  (h₁ : text.length > 0)\n  (h₂ : ∀ c ∈ text.data, c ∈ ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']) :\n  let syllables := count text SYLLABLE\n  syllables ≥ 1 ∧ syllables ≤ text.length :=\nsorry\n\ntheorem flesch_kincaid_is_finite (words : List String)\n  (h : words.length > 0)\n  (h₂ : ∀ w ∈ words, w.length > 0)\n  (h₃ : ∀ w ∈ words, ∀ c ∈ w.data, c.isLower) :\n  let sentence := String.intercalate \" \" words ++ \".\"\n  ∃ (result : Float), flesch_kincaid sentence = result :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 3.67\n-/\n#guard_msgs in\n#eval flesch_kincaid \"The turtle is leaving.\"\n\n/--\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Hi there.\"\n\n/--\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Go home.\""}
{"id": "fvapps_004553", "vc-description": "/-\nAmong the ruins of an ancient city a group of archaeologists found a mysterious function with lots of HOLES in it called ```getNum(n)``` (or `get_num(n)` in ruby, python, or r). They tried to call it with some arguments. And finally they got this journal:\nThe archaeologists were totally stuck with this challenge. They were all in desperation but then.... came YOU the SUPER-AWESOME programmer. Will you be able to understand the mystery of this function and rewrite it?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_num (n : Nat) : Nat :=\nsorry\n\ndef countDigits (n : Nat) : Nat :=\nsorry\n\ndef natToString (n : Nat) : String :=\nsorry", "vc-theorems": "theorem get_num_zero : get_num 0 = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval get_num 123\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval get_num 6609\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval get_num 8888"}
{"id": "fvapps_004555", "vc-description": "/-\nDescription:\n\n#Task:\n\nWrite a function that returns true if the number is a \"Very Even\" number.\n\nIf a number is a single digit, then it is simply \"Very Even\" if it itself is even.\n\nIf it has 2 or more digits, it is \"Very Even\" if the sum of it's digits is \"Very Even\".\n\n#Examples:\n```\ninput(88) => returns false -> 8 + 8 = 16 -> 1 + 6 = 7 => 7 is odd \n\ninput(222) => returns true\n\ninput(5) => returns false\n\ninput(841) => returns true -> 8 + 4 + 1 = 13 -> 1 + 3 => 4 is even\n```\n\nNote: The numbers will always be 0 or positive integers!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_very_even_number (n : Nat) : Bool :=\nsorry\n\ndef digitSum (n : Nat) : Nat :=\nsorry\n\ndef singleDigitSum (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem very_even_single_digit (n : Nat) :\n  n < 10 → is_very_even_number n = (n % 2 = 0) :=\nsorry\n\ntheorem very_even_digit_sum (n : Nat) :\n  is_very_even_number n = (singleDigitSum n % 2 = 0) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_very_even_number 88\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 222\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 841"}
{"id": "fvapps_004557", "vc-description": "/-\nYou must create a function, `spread`, that takes a function and a list of arguments to be applied to that function. You must make this function return the result of calling the given function/lambda with the given arguments.\n\neg:\n```python\nspread(someFunction, [1, true, \"Foo\", \"bar\"] ) \n# is the same as...\nsomeFunction(1, true, \"Foo\", \"bar\")\n```\n-/", "vc-preamble": "def sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sum t", "vc-helpers": "", "vc-definitions": "def spread {α β : Type u} (f : α → β) (args : List α) : β :=\n  sorry", "vc-theorems": "theorem spread_matches_direct_call {α β : Type u} (f : α → β) (x : α) :\n  spread f [x] = f x :=\nsorry\n\ntheorem spread_list_sum (nums : List Nat) :\n  spread (fun xs => sum xs) [nums] = sum nums :=\nsorry\n\ntheorem spread_concat_strings (strings : List String) :\n  spread (fun args => String.join args) [strings] = String.join strings :=\nsorry\n\ntheorem spread_empty_unit (f : Unit → Option α) :\n  spread f [] = f () :=\nsorry\n\ntheorem spread_single_identity :\n  spread (fun x:Nat => x) [42] = 42 :=\nsorry\n\ntheorem spread_too_many_args_fails :\n  ¬(∃ (res:Nat), spread (fun x:Nat => x) [1, 2] = res) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval spread lambda x, y: x + y [2, 3]\n\n/--\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval spread lambda x, y, z: x + y + z [\"a\", \"b\", \"c\"]\n\n/--\ninfo: 42\n-/\n#guard_msgs in\n#eval spread lambda: 42 []"}
{"id": "fvapps_004562", "vc-description": "/-\n# Introduction\n\nMastermind or Master Mind is a code-breaking game for two players. The modern game with pegs was invented in 1970 by Mordecai Meirowitz, an Israeli postmaster and telecommunications expert. It resembles an earlier pencil and paper game called Bulls and Cows that may date back a century or more. (Source Wikipedia)\n\n# Rules\n\n1. The Mastermind (computer) will select 4 colours. The colours are randomly selected from [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]. Colours can be duplicated but there will always be exactly 4.\n\n2. The Mastermind will return an array back to you. For every correctly positioned colour in the array an element of “Black” is returned. For every correct colour but in the wrong position an element of “White” will be returned.\n\n3. Passing the correct array will pass the Kata test and return \"WON!\".\n\n4. Passing an invalid colour will fail the test with the error \"Error: you have given an invalid colour!\"\n\n5. Passing an invalid array length will fail the test with the error \"Error: you must pass 4 colours!\"\n\n6. Guessing more than 60 times will fail the test with the error \"Error: you have had more than 60 tries!\"\n\n7. All colours are capitalised\n\n8. The return array will be shuffled!\n\n# Task\n\nYour task is to create a method called mastermind() that will take an object called  game. The object has already been preloaded so you do not need to worry about it.\n\nWithin your method you must pass an array into the game object method .check(). This will evoke the object to check your array to see if it is correct.\n\n# Example\n\nIf the Mastermind selected the following colours\n\nThen the array you are trying to solve is `[\"Red\", \"Blue\", \"Green\", \"Yellow\"]`\nSo you guess with \n\n`[\"Red\", \"Orange\", \"Yellow\", \"Orange\"]`\n\nYour method would look like this.\n```python\ndef mastermind(game):\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n```\nThe element `0 => Red` is at the correct index so `Black` is added to the return array. Element `2 => Yellow` is in the array but at the wrong index possition so `White` is added to the return array.\n\nThe Mastermind would then return `[\"Black\", \"White\"]` (But not necessarily in that order as the return array is shuffled my the Mastermind).\n\nKeep guessing until you pass the correct solution which will pass the Kata.\n\n# Check result\nTo check the Masterminds return value\n```python\n  answer = game.check([\"Red\", \"Orange\", \"Yellow\", \"Orange\"])\n  print (answer)\n```\n\nGood luck and enjoy!\n\n# Kata Series\nIf you enjoyed this, then please try one of my other Katas. Any feedback, translations and grading of beta Katas are greatly appreciated. Thank you.\n\n Maze Runner\n Scooby Doo Puzzle\n Driving License\n Connect 4\n Vending Machine\n Snakes and Ladders\n Mastermind\n Guess Who?\n Am I safe to drive?\n Mexican Wave\n Pigs in a Pen\n Hungry Hippos\n Plenty of Fish in the Pond\n Fruit Machine\n Car Park Escape\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def VALID_COLORS := [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]\n\nstructure Game where\n  solution : List String := []\n  tries : Nat := 0\n  deriving Repr", "vc-helpers": "", "vc-definitions": "def Game.check (g : Game) (guess : List String) : List String :=\nsorry\n\ndef matches_result (code guess result : List String) : Bool :=\nsorry\n\ndef mastermind (g : Game) : Unit :=\nsorry", "vc-theorems": "theorem mastermind_always_solves {solution : List String}\n  (h1 : solution.length = 4)\n  (h2 : ∀ x ∈ solution, x ∈ VALID_COLORS) :\n  ∀ g : Game, g.solution = solution → g.tries ≤ 60 :=\nsorry\n\ntheorem matches_result_symmetric {code guess : List String}\n  (h1 : code.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ code, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result code guess (List.replicate 4 \"Black\") =\n  matches_result guess code (List.replicate 4 \"Black\") :=\nsorry\n\ntheorem matches_result_self {guess : List String}\n  (h1 : guess.length = 4)\n  (h2 : ∀ x ∈ guess, x ∈ VALID_COLORS) :\n  matches_result guess guess (List.replicate 4 \"Black\") = true :=\nsorry\n\ntheorem game_check_invalid_inputs (g : Game) :\n  (∀ guess : List String, guess.length ≠ 4 → g.check guess = []) ∧\n  (∀ guess : List String, (∃ x ∈ guess, x ∉ VALID_COLORS) → g.check guess = []) ∧\n  (g.tries ≥ 60 → ∀ guess : List String, g.check guess = []) :=\nsorry\n\ntheorem check_result_length {solution guess : List String}\n  (h1 : solution.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : ∀ x ∈ solution, x ∈ VALID_COLORS)\n  (h4 : ∀ x ∈ guess, x ∈ VALID_COLORS)\n  (g : Game)\n  (h5 : g.solution = solution) :\n  let result := g.check guess\n  (result.length ≤ 4 ∧ ∀ x ∈ result, x = \"Black\" ∨ x = \"White\") :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004571", "vc-description": "/-\nYour task is to find all the elements of an array that are non consecutive.\n\nA number is non consecutive if it is not exactly one larger than the previous element in the array. The first element gets a pass and is never considered non consecutive.\n\n~~~if:javascript,haskell,swift\nCreate a function named `allNonConsecutive`\n~~~\n~~~if:python,rust\nCreate a function name `all_non_consecutive`\n~~~\n\nE.g., if we have an array `[1,2,3,4,6,7,8,15,16]` then `6` and `15` are non-consecutive.\n\n~~~if:javascript,python\nYou should return the results as an array of objects with two values `i: ` and `n: `.\n~~~\n~~~if:haskell,swift,rust\nYou should return the results as an array of tuples with two values: the index of the non-consecutive number and the non-consecutive number.\n~~~\n\nE.g., for the above array the result should be:\n```python\n[\n  {'i': 4, 'n': 6},\n  {'i': 7, 'n': 15}\n]\n```\n\nIf the whole array is consecutive or has one element then return an empty array.\n\nThe array elements will all be numbers. The numbers will also all be unique and in ascending order. The numbers could be positive and/or negetive and the gap could be larger than one.\n\nIf you like this kata, maybe try this one next: https://www.codewars.com/kata/represent-array-of-numbers-as-ranges\n-/", "vc-preamble": "def List.Sorted {α : Type} (r : α → α → Prop) (l : List α) : Prop :=\n  ∀ i j (h1 : i < j) (h2 : j < l.length), r (l.get ⟨i, Nat.lt_trans h1 h2⟩) (l.get ⟨j, h2⟩)\n\nstructure Result where\n  i : Nat\n  n : Int", "vc-helpers": "", "vc-definitions": "def all_non_consecutive (arr : List Int) : List Result :=\n  sorry", "vc-theorems": "theorem consecutive_not_in_result (arr : List Int) (h : arr.length ≥ 2) :\n  ∀ i (h1 : i < arr.length - 1),\n  arr.get ⟨i+1, by omega⟩ = arr.get ⟨i, by omega⟩ + 1 →\n  ¬∃ r ∈ all_non_consecutive arr, r.i = i + 1 :=\nsorry\n\ntheorem non_consecutive_in_result (arr : List Int) (h : arr.length ≥ 2) :\n  ∀ i, (h1 : i < arr.length - 1) →\n  arr.get ⟨i+1, by omega⟩ ≠ arr.get ⟨i, by omega⟩ + 1 →\n  ∃ r ∈ all_non_consecutive arr, r.i = i + 1 ∧ r.n = arr.get ⟨i+1, by omega⟩ :=\nsorry\n\ntheorem indices_ascending (arr : List Int) (h : arr.length ≥ 2) :\n  let result := all_non_consecutive arr\n  result.length > 1 →\n  List.Sorted (·≤·) (result.map Result.i) :=\nsorry\n\ntheorem valid_indices (arr : List Int) (h : arr.length ≥ 2) :\n  ∀ r ∈ all_non_consecutive arr,\n  1 ≤ r.i ∧ r.i < arr.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval all_non_consecutive [1, 2, 3, 4, 6, 7, 8, 15, 16]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval all_non_consecutive [1, 2, 3, 4, 5]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval all_non_consecutive [-3, -2, -1, 1, 2, 4, 5]"}
{"id": "fvapps_004572", "vc-description": "/-\nBackwards Read Primes are primes that when read backwards in base 10 (from right to left) \nare a different prime. (This rules out primes which are palindromes.)\n```\nExamples:\n13 17 31 37 71 73 are Backwards Read Primes\n```\n13 is such because it's prime and read from right to left writes 31 which is prime too. Same for the others.\n\n## Task\nFind all Backwards Read Primes between two positive given numbers (both inclusive), the second one always being greater than or equal to the first one. The resulting array or the resulting string will be ordered following the natural order of the prime numbers.\n\n## Example\n\nbackwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \nbackwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967]\nbackwardsPrime(501, 599) => []\n\n## Note for Forth\nReturn only the first backwards-read prime between start and end\nor 0 if you don't find any\n\n```python\nbackwards_prime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] \nbackwards_prime(9900, 10000) => [9923, 9931, 9941, 9967]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_prime : Nat → Bool :=\nsorry\n\ndef reverse : Nat → Nat :=\nsorry\n\ndef backwards_prime : Nat → Nat → List Nat :=\nsorry", "vc-theorems": "theorem backwards_prime_empty_range :\n  backwards_prime 1 0 = [] ∧\n  backwards_prime 0 1 = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: [13, 17, 31, 37, 71, 73, 79, 97]\n-/\n#guard_msgs in\n#eval backwards_prime 2 100\n\n/--\ninfo: [9923, 9931, 9941, 9967]\n-/\n#guard_msgs in\n#eval backwards_prime 9900 10000\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval backwards_prime 501 599"}
{"id": "fvapps_004573", "vc-description": "/-\nWe've got a message from the **Librarian**. As usual there're many `o` and `k` in it and, as all codewarriors don't know \"Ook\" language we need that you translate this message.\n\n**tip** : it seems traditional \"Hello World!\" would look like :\n`Ok, Ook, Ooo?  Okk, Ook, Ok?  Okk, Okk, Oo?  Okk, Okk, Oo?  Okk, Okkkk?  Ok, Ooooo?  Ok, Ok, Okkk?  Okk, Okkkk?  Okkk, Ook, O?  Okk, Okk, Oo?  Okk, Ook, Oo?  Ook, Ooook!`\n\nYour task is to implement a function `okkOokOo(okkOookk)`, that would take the `okkOookk` message as input and return a decoded human-readable string.\n\n*eg*:\n```python\nokkOokOo('Ok, Ook, Ooo!')  # -> 'H'\nokkOokOo('Ok, Ook, Ooo?  Okk, Ook, Ok?  Okk, Okk, Oo?  Okk, Okk, Oo?  Okk, Okkkk!')  # -> 'Hello'\nokkOokOo('Ok, Ok, Okkk?  Okk, Okkkk?  Okkk, Ook, O?  Okk, Okk, Oo?  Okk, Ook, Oo?  Ook, Ooook!')  # -> 'World!'\n```\n-/\n\n/- The function correctly encodes basic ASCII characters -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The function handles multiple characters correctly -/\n\n/- The length of output matches the number of separators plus one -/\n\n/- The output only contains printable ASCII characters -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def okkOokOo (s : String) : String :=\n  sorry", "vc-theorems": "theorem basic_ascii_encoding (input : String) :\n  okkOokOo \"Ok, Ook, Ooo!\" = \"H\" :=\nsorry\n\ntheorem multiple_char_encoding :\n  okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\" = \"He\" :=\nsorry\n\ntheorem length_matches_separators :\n  String.length (okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\") = 2 :=\nsorry\n\ntheorem output_is_printable_ascii (s : String) (c : Char) :\n  c ∈ (okkOokOo s).data →\n  32 ≤ c.toNat ∧ c.toNat ≤ 126 :=\nsorry", "vc-postamble": "/--\ninfo: 'H'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo!\"\n\n/--\ninfo: 'Hello'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo?  Okk, Ook, Ok?  Okk, Okk, Oo?  Okk, Okk, Oo?  Okk, Okkkk!\"\n\n/--\ninfo: 'World!'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ok, Okkk?  Okk, Okkkk?  Okkk, Ook, O?  Okk, Okk, Oo?  Okk, Ook, Oo?  Ook, Ooook!\""}
{"id": "fvapps_004576", "vc-description": "/-\nThe accounts of the \"Fat to Fit Club (FFC)\" association are supervised by John as a volunteered accountant.\nThe association is funded through financial donations from generous benefactors. John has a list of\nthe first `n` donations: `[14, 30, 5, 7, 9, 11, 15]`\nHe wants to know how much the next benefactor should give to the association so that the \naverage of the first `n + 1` donations should reach an average of `30`.\nAfter doing the math he found `149`. He thinks that he made a mistake.\nCould you help him?\n\nif `dons = [14, 30, 5, 7, 9, 11, 15]` then `new_avg(dons, 30) --> 149`\n\nThe function `new_avg(arr, navg)` should return the expected donation\n(rounded up to the next integer) that will permit to reach the average `navg`. \n\nShould the last donation be a non positive number `(<= 0)` John wants us to throw (or raise) an error or\n\n- return Nothing in Haskell\n- return None in F#, Ocaml, Scala\n- return `-1` in C, Fortran,  Nim, PowerShell, Go, Prolog\n- echo `ERROR` in Shell\n- raise-argument-error in Racket\n\nso that he clearly sees that his expectations are not great enough.\n\nNotes: \n\n- all donations and `navg` are numbers (integers or floats), `arr` can be empty.\n- See examples below and \"Test Samples\" to see which return is to be done.\n\n```\nnew_avg([14, 30, 5, 7, 9, 11, 15], 92) should return 645\nnew_avg([14, 30, 5, 7, 9, 11, 15], 2) \nshould raise an error (ValueError or invalid_argument or argument-error or DomainError) \nor return `-1` or ERROR or Nothing or None depending on the language.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def new_avg (donations : List Int) (targetAvg : Int) : Option Int :=\n  sorry\n\ndef list_sum (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem new_avg_type_and_positive (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  r > 0 :=\nsorry\n\ntheorem new_avg_achieves_target (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  ((list_sum donations + r) / (donations.length + 1) - targetAvg).natAbs < 1 :=\nsorry\n\ntheorem new_avg_none_when_negative (donations : List Int) (targetAvg : Int) :\n  donations ≠ [] →\n  (donations.length + 1) * targetAvg - list_sum donations ≤ 0 →\n  new_avg donations targetAvg = none :=\nsorry\n\ntheorem new_avg_positive_large_target (donations : List Int) (maxDonation : Int) :\n  donations ≠ [] →\n  (∀ d ∈ donations, d ≥ 0 ∧ d ≤ maxDonation) →\n  let targetAvg := maxDonation + 100\n  ∀ r : Int, new_avg donations targetAvg = some r →\n  r > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 149\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 30\n\n/--\ninfo: 645\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 92"}
{"id": "fvapps_004577", "vc-description": "/-\nThis Kata is the first in the [Rubiks Cube collection](https://www.codewars.com/collections/rubiks-party).\n\n[This](https://ruwix.com/the-rubiks-cube/notation/) or [this](https://ruwix.com/the-rubiks-cube/notation/advanced/) websites will be very usefull for this kata, if there will be some lack of understanding after the description. There are plenty of examples and a 3D model that can perform all needed rotations.\n\nIn this Kata you will give the cube the ability to rotate.\n\nThe Rubik's Cube is made of six faces. F(ront), L(eft), R(ight), B(ack), U(p), D(own)\n\nBelow a two dimensional representation of the cube.\n```\n      +-----+\n      |     |\n      |  U  |\n      |     |\n+-----+-----+-----+-----+\n|     |     |     |     |\n|  L  |  F  |  R  |  B  |\n|     |     |     |     |\n+-----+-----+-----+-----+\n      |     |\n      |  D  |\n      |     |\n      +-----+\n```\n\nOn every face you can see nine stickers. Every sticker can be one of the six colors: Yellow, Blue, Red, Green, Orange, White. In this Kata they are represented with according small letters (y, b, r, g, o, w,).\n\nA solved cube has on every face only one color:\n```\n      +-----+\n      |y y y|\n      |y y y|\n      |y y y|\n+-----+-----+-----+-----+\n|b b b|r r r|g g g|o o o|\n|b b b|r r r|g g g|o o o|\n|b b b|r r r|g g g|o o o|\n+-----+-----+-----+-----+\n      |w w w|\n      |w w w|\n      |w w w|\n      +-----+\n```\nEvery sticker on a face in this Kata has a positional number\n```\n+-----+\n|1 2 3|\n|4 5 6|\n|7 8 9|\n+-----+\n```\nSo the state of the face could be represented in a 9 character string consisting of the possible colors.\n```\n+-----+\n|y r b|\n|o o w|   state == \"yrboowygb\"\n|y g b|\n+-----+\n```\nSo a state of the cube is a 54 character long string consisting of the state of every face in this order: U L F R B D\n```\n      +-----+\n      |y y y|\n      |y y y|      state == \"yyyyyyyyybbbbbbbbbrrrrrrrrrgggggggggooooooooowwwwwwwww\"\n      |y y y|\n+-----+-----+-----+-----+\n|b b b|r r r|g g g|o o o|\n|b b b|r r r|g g g|o o o|\n|b b b|r r r|g g g|o o o|\n+-----+-----+-----+-----+\n      |w w w|\n      |w w w|\n      |w w w|\n      +-----+\n```\n\n# Rotations\nTo make things easier I have preloded the `state_representation(state)` function that can visialise a state.\n\n## basic rotations\nEvery face can rotate.\n\n- The direction of a rotation is always defined on your \"axis of sight\" when your looking at a face of the cube.\n- A rotation of a face is written with an uppercase letter: `F`, `B`, ...\n- Clockwise and counterclockwise rotations are distinguished by an apostroph, added to the letter for the counterclockwise rotations.\n\nExamples:\n- `F` rotates the front face clockwise.\n- `F'` rotates the front face conterclockwise.\n\nYou can rotate a face twice with a `2` after the letter. E.g. `F2` rotates the front face clockwise twice.\n\n## slice rotations\nThere is a possibility to rotate only a middle layer of the cube. These are called slice turns. There are three: `M, E, S`. There is no obvious clockwise or counterclockwise directions, so the are some special standarts:\n\n`M`(idle) the layer between `L` and `R`, turn direction as `L`\n\n`E`(quator) the layer between `D` and `U`, turn direction as `D`\n\n`S`(tanding) the layer between `F` and `B`, turn direction as `F`\n\n```\nAfter a \"M\" turn\n      +-----+\n      |y o y|\n      |y o y|      state == \"yoyyoyyoybbbbbbbbbryrryrryrgggggggggowoowoowowrwwrwwrw\"\n      |y o y|\n+-----+-----+-----+-----+\n|b b b|r y r|g g g|o w o|\n|b b b|r y r|g g g|o w o|\n|b b b|r y r|g g g|o w o|\n+-----+-----+-----+-----+\n      |w r w|\n      |w r w|\n      |w r w|\n      +-----+\n```\n\n## whole cube rotations\n\nThere are three more letters you should consider: `X, Y, Z`. This are basically rotating the whole cube along one of the 3D axis.\n\n## double layer rotations\n\nThis are some kind of combined rotations. There are 6: `f, r, u, l, d, b`. Yes, like the 'basic rotations' but lowercase. A `f` means that you rotate the `F` face and the next slice layer with it IN THE SAME DIRECTION (in the F case its `S`). \n\nThis is the whole list of possible rotations that the cube should perform:\n```\nF R U L D B F' R' U' L' D' B' F2 R2 U2 L2 D2 B2\nM E S M' E' S' M2 E2 S2\nf r u l d b f' r' u' l' d' b' f2 r2 u2 l2 d2 b2\nX Y Z X' Y' Z' X2 Y2 Z2\n```\nI have preloded a dictionary `single_rotations` that includes every single state to mentioned rotations.\n`single_rotations[\"F2\"] == \"yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww\"`\n\n# Task\nimplement the `perform(sequence)` function that takes a string with space separeted values witha sequence of rotations. \nE.g. `F R2 f X M2 L' U2 d' Z M' B`\nThe cube always starts in a solved state (\"yyyyyyyyybbbbbbbbbrrrrrrrrrgggggggggooooooooowwwwwwwww\")\n\nThe function should return the changed state of the cube after the sequence.\n```\nperform(\"F U\") == \"byybyybyyrrrbbwbbwyggrrrrrroooyggyggbbwoooooogggwwwwww\"\n```\n\nEnjoy ^_^\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def f : List (List Int) → List (List Int) :=\nsorry\n\ndef g : List (List Int) → List (List Int) :=\nsorry\n\ndef perform : String → String :=\nsorry", "vc-theorems": "theorem f_g_inverse {matrix : List (List Int)} (h1 : matrix.length > 0)\n  (h2 : ∀ row ∈ matrix, row.length > 0)\n  (h3 : ∀ row ∈ matrix, row.length = matrix.head!.length) :\n  f (g matrix) = matrix :=\nsorry\n\ntheorem perform_maintains_valid_colors (sequence : String) :\n  ∀ c, c.toString ∈ (perform sequence).data.map toString →\n  c = 'y' ∨ c = 'g' ∨ c = 'b' ∨ c = 'o' ∨ c = 'r' ∨ c = 'w' :=\nsorry\n\ntheorem perform_F_move :\n  perform \"F\" = \"yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww\" :=\nsorry\n\ntheorem perform_F2_move :\n  perform \"F2\" = \"yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww\" :=\nsorry\n\ntheorem perform_F_prime_move :\n  perform \"F'\" = \"yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\n\n/--\ninfo: 'yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww'\n-/\n#guard_msgs in\n#eval perform \"F2\"\n\n/--\ninfo: 'yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\""}
{"id": "fvapps_004587", "vc-description": "/-\n### Background\nOne way to order a nested (reddit-style) commenting system is by giving each comment a rank. \n\nGeneric comments on a thread start with rank 1 and increment, so the second comment on a thread would have rank 2. A reply to comment 1 will be ranked 1.1, and a reply to comment 1.1 will be ranked 1.1.1 . The second comment to reply to comment 1 would be ranked 1.2 .\n\nNote that since 1.1.1 is a valid rank, the ranks given are of type string.   \n\n### Task: \nGiven a list of comment ranks (strings), order them as a comment thread would appear \n\n### Assumptions:  \n* there will always be a rank 1 in the given input\n* ranks are of type string\n* rank numbers are incremented, and not skippped (1.1 could be followed by 1.2, not 1.3)\n\n### Example order:\n```\n[\n  '1',\n  '1.1',\n  '1.2',\n  '1.2.1',\n  '2',\n  '3',\n  '3.1',\n  '3.1.1',\n  '3.2'\n]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_ranks (ranks: List String) : List String :=\nsorry\n\ndef is_valid_version (s: String) : Bool :=\nsorry\n\ndef loose_version_le (v1 v2: String) : Bool :=\nsorry", "vc-theorems": "theorem sort_ranks_maintains_elements (ranks: List String)\n  (h: ∀ x ∈ ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  ∀ x, (x ∈ ranks ↔ x ∈ sorted) ∧\n  sorted.length = ranks.length :=\nsorry\n\ntheorem sort_ranks_ordering (ranks: List String)\n  (h1: ranks.length ≥ 2)\n  (h2: ∀ x ∈ ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  ∀ (i: Nat) (h: i + 1 < sorted.length),\n    loose_version_le (sorted[i]'(Nat.lt_of_lt_of_le (Nat.lt_succ_self i) (Nat.le_of_lt h)))\n                    (sorted[i+1]'h) :=\nsorry\n\ntheorem sort_ranks_idempotent (ranks: List String)\n  (h: ∀ x ∈ ranks, is_valid_version x) :\n  sort_ranks (sort_ranks ranks) = sort_ranks ranks :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_ranks [\"2\", \"1\", \"1.1\"]\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_ranks [\"3.1\", \"1\", \"1.1\", \"2\", \"3\", \"1.2\", \"3.2\", \"1.2.1\", \"3.1.1\"]\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_ranks [\"3\", \"2\", \"1\"]"}
{"id": "fvapps_004589", "vc-description": "/-\nThis kata is the first of a sequence of four about \"Squared Strings\".\n\nYou are given a string of `n` lines, each substring being `n` characters long: For example:\n\n`s = \"abcd\\nefgh\\nijkl\\nmnop\"`\n\nWe will study some transformations of this square of strings.\n\n- Vertical mirror:\nvert_mirror (or vertMirror or vert-mirror)\n```\nvert_mirror(s) => \"dcba\\nhgfe\\nlkji\\nponm\"\n```\n- Horizontal mirror:\nhor_mirror (or horMirror or hor-mirror)\n```\n hor_mirror(s) => \"mnop\\nijkl\\nefgh\\nabcd\"\n```\n\nor printed:\n\n```\nvertical mirror   |horizontal mirror   \nabcd --> dcba     |abcd --> mnop \nefgh     hgfe     |efgh     ijkl \nijkl     lkji     |ijkl     efgh \nmnop     ponm     |mnop     abcd \n```\n\n# Task:\n- Write these two functions\n\nand\n\n- high-order function `oper(fct, s)` where\n\n - fct is the function of one variable f to apply to the string `s`\n(fct will be one of `vertMirror, horMirror`)\n\n# Examples:\n```\ns = \"abcd\\nefgh\\nijkl\\nmnop\"\noper(vert_mirror, s) => \"dcba\\nhgfe\\nlkji\\nponm\"\noper(hor_mirror, s) => \"mnop\\nijkl\\nefgh\\nabcd\"\n```\n# Note:\nThe form of the parameter `fct` in oper\nchanges according to the language. You can see each form according to the language in \"Sample Tests\".\n\n# Bash Note:\nThe input strings are separated by `,` instead of `\\n`. The output strings should be separated by `\\r` instead of `\\n`. See \"Sample Tests\".\n\nForthcoming katas will study other transformations.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "def line_lengths_preserved (orig result : List String) : Prop :=\n  ∀ i, i < orig.length → (orig.get! i).length = (result.get! i).length", "vc-helpers": "", "vc-definitions": "def split (s : String) (c : Char) : List String :=\nsorry\n\ndef vert_mirror (s : String) : String :=\nsorry\n\ndef hor_mirror (s : String) : String :=\nsorry\n\ndef oper (f : String → String) (s : String) : String :=\nsorry\n\ndef reverse_string (s : String) : String :=\nsorry", "vc-theorems": "def all_lines_reversed (orig result : List String) : Prop :=\n  ∀ i, i < orig.length → result.get! i = reverse_string (orig.get! i)\n\ntheorem vert_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper vert_mirror s) '\\n'\n  lines.length = result_lines.length ∧\n  all_lines_reversed lines result_lines ∧\n  line_lengths_preserved lines result_lines := by\nsorry\n\ntheorem hor_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper hor_mirror s) '\\n'\n  lines.length = result_lines.length ∧\n  result_lines = List.reverse lines := by\nsorry\n\ntheorem vert_mirror_involution (s : String) :\n  oper vert_mirror (oper vert_mirror s) = s := by\nsorry\n\ntheorem hor_mirror_involution (s : String) :\n  oper hor_mirror (oper hor_mirror s) = s := by\nsorry", "vc-postamble": "/-\ninfo: 'dcba\\nhgfe\\nlkji\\nponm'\n-/\n#guard_msgs in\n#eval oper vert_mirror \"abcd\\nefgh\\nijkl\\nmnop\"\n\n/-\ninfo: 'mnop\\nijkl\\nefgh\\nabcd'\n-/\n#guard_msgs in\n#eval oper hor_mirror s1\n\n/-\ninfo: 'ba\\ndc'\n-/\n#guard_msgs in\n#eval oper vert_mirror \"ab\\ncd\"\n\n/-\ninfo: 'cd\\nab'\n-/\n#guard_msgs in\n#eval oper hor_mirror s2"}
{"id": "fvapps_004592", "vc-description": "/-\nJohn and his wife Ann have decided to go to Codewars. \n\nOn first day Ann will do one kata and John - he wants to know how it is working - 0 kata.\n\nLet us call `a(n)` - and `j(n)` - the number of katas done by Ann - and John - at day `n`. We have `a(0) = 1` and in the same manner `j(0) = 0`.\n\nThey have chosen the following rules:\n\n- On day `n` the number of katas done by Ann should be `n` minus the number of katas done by John at day `t`, `t` being equal to the number of katas done\nby Ann herself at day `n - 1`.\n\n- On day `n` the number of katas done by John should be `n` minus the number of katas done by Ann at day `t`, `t` being equal to the number of katas done\nby John himself at day `n - 1`.\n\nWhoops! I think they need to lay out a little clearer exactly what there're getting themselves into!\n\n# Could you write:\n- 1) two functions `ann` and `john (parameter n)` giving the list of the numbers of katas Ann and John should take on the first n days (see first examples below)? \n- 2) The total number of katas taken by ann `function sum_ann(n)` and john `function sum_john(n)` - on the first n days? \n\nThe functions in 1) are not tested in Fortran and not tested in Shell.\n\n# Examples:\n```\njohn(11) -->  [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]\nann(6) -->  [1, 1, 2, 2, 3, 3]\n\nsum_john(75) -->  1720\nsum_ann(150) -->  6930\n```\n\n# Shell Note:\nsumJohnAndAnn has two parameters:\n\nfirst one : n (number of days, $1)\n\nsecond one : which($2) ->\n\n- 1 for getting John's sum\n\n- 2 for getting Ann's sum.\n\nSee \"Sample Tests\".\n\n# Note: \n\nKeep an eye on performance.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def john (n : Nat) : List Nat :=\nsorry\n\ndef ann (n : Nat) : List Nat :=\nsorry\n\ndef sum_john (n : Nat) : Nat :=\nsorry\n\ndef sum_ann (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem sequences_start_correctly {n : Nat} (h : n > 0) :\n  (john n).get ⟨0, sorry⟩ = 0 ∧ (ann n).get ⟨0, sorry⟩ = 1 :=\nsorry\n\ntheorem sequence_lengths {n : Nat} (h : n > 0) :\n  (john n).length = n ∧ (ann n).length = n :=\nsorry\n\ntheorem sequences_nonnegative {n : Nat} (h : n > 0) :\n  (∀ x ∈ john n, x ≥ 0) ∧ (∀ x ∈ ann n, x ≥ 0) :=\nsorry\n\ntheorem sum_functions_match {n : Nat} (h : n > 0) :\n  sum_john n = ((john n).foldl (· + ·) 0) ∧\n  sum_ann n = ((ann n).foldl (· + ·) 0) :=\nsorry\n\ntheorem sequence_relationship {n : Nat} (h : n > 0) :\n  ∀ i : Nat, i < n → i > 0 →\n    ((john n).get ⟨i, sorry⟩ = i - (ann n).get ⟨(john n).get ⟨i-1, sorry⟩, sorry⟩) ∧\n    ((ann n).get ⟨i, sorry⟩ = i - (john n).get ⟨(ann n).get ⟨i-1, sorry⟩, sorry⟩) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]\n-/\n#guard_msgs in\n#eval john 11\n\n/--\ninfo: [1, 1, 2, 2, 3, 3]\n-/\n#guard_msgs in\n#eval ann 6\n\n/--\ninfo: 1720\n-/\n#guard_msgs in\n#eval sum_john 75\n\n/--\ninfo: 6930\n-/\n#guard_msgs in\n#eval sum_ann 150"}
{"id": "fvapps_004595", "vc-description": "/-\nWrite a function getNumberOfSquares that will return how many integer (starting from 1, 2...) numbers raised to power of 2 and then summed up are less than some number given as a parameter.\n\nE.g 1: For n = 6 result should be 2 because 1^2 + 2^2 = 1 + 4 = 5 and 5 < 6\nE.g 2: For n = 15 result should be 3 because 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14 and 14 < 15\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_number_of_squares (n : Int) : Nat :=\n  sorry\n\ndef sum_squares (n : Nat) : Int :=\n  sorry\n\ndef next_square (n : Nat) : Int :=\n  sorry", "vc-theorems": "theorem known_sequence_values :\n  (get_number_of_squares 1 = 0) ∧\n  (get_number_of_squares 2 = 1) ∧\n  (get_number_of_squares 6 = 2) ∧\n  (get_number_of_squares 15 = 3) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval get_number_of_squares 6\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval get_number_of_squares 15\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval get_number_of_squares 100"}
{"id": "fvapps_004596", "vc-description": "/-\nAn array is **circularly sorted** if the elements are sorted in ascending order, but displaced, or rotated, by any number of steps. \n\nComplete the function/method that determines if the given array of integers is circularly sorted.\n\n## Examples\n\nThese arrays are circularly sorted (`true`):\n```\n[2, 3, 4, 5, 0, 1]       -->  [0, 1] + [2, 3, 4, 5]\n[4, 5, 6, 9, 1]          -->  [1] + [4, 5, 6, 9]\n[10, 11, 6, 7, 9]        -->  [6, 7, 9] + [10, 11]\n[1, 2, 3, 4, 5]          -->  [1, 2, 3, 4, 5]\n[5, 7, 43, 987, -9, 0]   -->  [-9, 0] + [5, 7, 43, 987]\n[1, 2, 3, 4, 1]          -->  [1] + [1, 2, 3, 4]\n```\n\nWhile these are not (`false`):\n```\n[4, 1, 2, 5]\n[8, 7, 6, 5, 4, 3]\n[6, 7, 4, 8]\n[7, 6, 5, 4, 3, 2, 1]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def circularly_sorted (xs : List Int) : Bool :=\n  sorry\n\ndef isSorted (xs : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem sorted_is_circular {xs : List Int} (h : xs.length > 0) :\n  isSorted xs → circularly_sorted xs = true :=\nsorry\n\ntheorem rotated_sorted_is_circular {xs : List Int} (h : xs.length > 0) (distinct : List.Nodup xs) :\n  ∀ i, i < xs.length → circularly_sorted (List.drop i xs ++ List.take i xs) = true :=\nsorry\n\ntheorem singleton_is_circular {x : Int} :\n  circularly_sorted [x] = true :=\nsorry\n\ntheorem empty_raises {xs : List Int} (h : xs.length = 0) :\n  circularly_sorted xs = false :=\nsorry\n\ntheorem unsorted_not_circular {xs : List Int} (h : xs.length > 1)\n  (not_sorted : ∀ i, i < xs.length → ¬(isSorted (List.drop i xs ++ List.take i xs))) :\n  circularly_sorted xs = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [2, 3, 4, 5, 0, 1]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [1, 2, 3, 4, 5]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval circularly_sorted [4, 1, 2, 5]"}
{"id": "fvapps_004612", "vc-description": "/-\nWhen we have a 2x2 square matrix we may have up to 24 different ones changing the positions of the elements.\n\nWe show some of them\n```\na  b   a  b    a  c    a  c   a  d    a  d    b  a    b  a\nc  d   d  c    d  b    b  d   b  c    c  b    c  d    d  c\n```\nYou may think to generate the remaining ones until completing the set of 24 matrices.\n\nGiven a certain matrix of numbers, that may be repeated or not, calculate the total number of possible matrices that may be generated, changing the position of the elements.\n\nE.g:\nCase one\n```\nA = [[1,2,3],\n     [3,4,5]]   #a 2x3 rectangle matrix with number 3 twice\n```     \ngenerates a set of ```360``` different matrices\n\nCase two\n```\nA = [[1,1,1], \n     [2,2,3], \n     [3,3,3]]\n```\ngenerates a set of ```1260``` different matrices.\n\nCase three\n```\nA = [[1,2,3],\n     [4,5,6],\n     [7,8,9]]\n```     \ngenerates a set of ```362880``` different matrices\n\nThis kata is not meant to apply a brute force algorithm to try to count the total amount of marices.\n\nFeatures of The Random Tests\n``` \nnumber of tests = 100\n2 ≤ m ≤ 9\n2 ≤ n ≤ 9\n``` \nEnjoy it!\n\nAvailable only in Python 2, Javascript and Ruby by the moment.\n-/\n\n-- Result is a natural number\n\n-- Result is bounded by factorial of total elements", "vc-preamble": "def factorial (n: Nat) : Nat :=\n  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def count_perms (matrix: List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem count_perms_single_element :\n  count_perms [[1]] = 1 := by\nsorry\n\ntheorem count_perms_dimensions_preserved {m n: Nat} (matrix: List (List Nat))\n  (h1: matrix.length = m)\n  (h2: ∀ row ∈ matrix, row.length = n) :\n  let result := count_perms matrix\n\n  0 < result ∧\n\n  result ≤ factorial (m * n) := by\nsorry\n\ntheorem count_perms_all_same {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_perms matrix = 1 := by\nsorry\n\ntheorem count_perms_all_different {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.map (fun i =>\n    List.map (fun j => i * n + j + 1) (List.range n)\n  ) (List.range m)\n  count_perms matrix = factorial (m * n) := by\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 360\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [3, 4, 5]]\n\n/--\ninfo: 1260\n-/\n#guard_msgs in\n#eval count_perms [[1, 1, 1], [2, 2, 3], [3, 3, 3]]\n\n/--\ninfo: 362880\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}
{"id": "fvapps_004618", "vc-description": "/-\nThe date is March 24, 2437 and the the Earth has been nearly completely destroyed by the actions of its inhabitants. Our last hope in this disaster lies in a shabby time machine built from old toasters and used microwave parts.  \n\nThe World Time Agency requires you to travel back in time to prevent disaster.  You are ordered to \"remove\" certain babies from the timeline.  \n\nHistorical newspapers and records provide the Date, Month, and Year for each mission.  Unfortunately the time machine takes input only as the number of days to travel back in time.  It is your job to calculate how many days you will need to travel back from today's date (March 24, 2437) for each mission.\n\nFor example, if a historical newspaper says a dangerous baby was born on:\nDate = 21, Month = 3, Year = 2437\nThen your function must compute that it was 3 Days ago.\n\nAnother example would be that a baby born on Date = 24, Month = 3, Year = 2436 would have been born 365 days ago.\n\nYou will not have time travel past the year 0.\n\nNote that while this is a fairly simple task, it is complicated by the fact that newspapers used the Julian calendar instead of the current Gregorian calendar prior to September 14, 1752.  In 1752, it was declared that Sep 2, 1752 was proceeded immediately by September 14, 1752, entirely omitting September 3-13. Furthermore, the rules for leap years changed on that date.\n\nAfter 1752, leap years are on any year divisible by four, except for years which are divisible by 100. An exception to that exception is that years divisible by 400 are always leap years.  For example, 1803, 1900, 2001, 2019, and 2100 are not leap years, but 1804, 2000 and 2020 are leap years. \nHowever in the Julian calander prior to and including 1752, leap years were on every year divisible by 4, without the exception of years divisible by 100.  The years 1752, 1700, 1600, and 0 were all leap years.\n\nGood luck agent, the world depends on you!\n\nNote: It is not required, but if you find it helpful to visualize the switch from the Julian to the Gregorian calendar, please see these links:\n\nPlease observe that much of September 1752 is missing here: https://www.timeanddate.com/calendar/?year=1752&country=1\n\nPlease observe that 1700 is a leap year here: https://www.timeanddate.com/calendar/?year=1700&country=1\n-/", "vc-preamble": "def dateCompare (d1 m1 y1 d2 m2 y2 : Int) : Bool :=\n  if y1 ≠ y2 then y1 > y2\n  else if m1 ≠ m2 then m1 > m2\n  else d1 > d2", "vc-helpers": "", "vc-definitions": "def days_until (date month year : Int) : Int :=\n  sorry\n\ndef isValidDate (date month year : Int) : Bool :=\n  sorry\n\ndef dateDiffDays (d1 m1 y1 d2 m2 y2 : Int) : Int :=\n  sorry", "vc-theorems": "theorem days_until_is_int {date month year : Int}\n  (h : isValidDate date month year = true) :\n  ∃ n : Int, days_until date month year = n :=\nsorry\n\ntheorem days_until_target_date {date month year : Int}\n  (h1 : date = 24)\n  (h2 : month = 3)\n  (h3 : year = 2437) :\n  days_until date month year = 0 :=\nsorry\n\ntheorem days_until_future_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare date month year 24 3 2437 = true) :\n  days_until date month year < 0 :=\nsorry\n\ntheorem days_until_past_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare 24 3 2437 date month year = true) :\n  days_until date month year > 0 :=\nsorry\n\ntheorem days_until_symmetry {date month year : Int}\n  (h : isValidDate date month year = true) :\n  days_until date month year = dateDiffDays year month date 2437 3 24 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval days_until 21 3 2437\n\n/--\ninfo: 365\n-/\n#guard_msgs in\n#eval days_until 24 3 2436\n\n/--\ninfo: 28\n-/\n#guard_msgs in\n#eval days_until 24 2 2437"}
{"id": "fvapps_004627", "vc-description": "/-\nThe objective is to write a method that takes two integer parameters and returns a single integer equal to the number of 1s in the binary representation of the greatest common divisor of the parameters. \n\nTaken from Wikipedia:\n\"In mathematics, the greatest common divisor (gcd) of two or more integers, when at least one of them is not zero, is the largest positive integer that divides the numbers without a remainder. For example, the GCD of 8 and 12 is 4.\"\n\nFor example: the greatest common divisor of 300 and 45 is 15. The binary representation of 15 is 1111, so the correct output would be 4.\n\nIf both parameters are 0, the method should return 0.\nThe function must be able to handle negative input.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def binary_gcd (x y : Int) : Nat :=\n  sorry\n\ndef popCount (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem binary_gcd_matches_gcd (x y : Int) :\n  binary_gcd x y = popCount (Int.gcd x y) :=\nsorry\n\ntheorem binary_gcd_symmetric_same (n : Int) :\n  binary_gcd n n = binary_gcd n (-n) :=\nsorry\n\ntheorem binary_gcd_symmetric_zero (n : Int) :\n  binary_gcd n 0 = binary_gcd 0 n :=\nsorry\n\ntheorem binary_gcd_positive_bounds (x y : Int) (hx : x > 0) (hy : y > 0) :\n  let result := binary_gcd x y\n  0 ≤ result ∧ result ≤ max x.natAbs.log2 y.natAbs.log2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval binary_gcd 300 45\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_gcd 0 0\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval binary_gcd -8 12"}
{"id": "fvapps_004636", "vc-description": "/-\nThis kata is part one of precise fractions series (see pt. 2: http://www.codewars.com/kata/precise-fractions-pt-2-conversion).\n\nWhen dealing with fractional values, there's always a problem with the precision of arithmetical operations. So lets fix it!\n\nYour task is to implement class ```Fraction``` that takes care of simple fraction arithmetics. Requirements:\n\n* class must have two-parameter constructor `Fraction(numerator, denominator)`; passed values will be non-zero integers, and may be positive or negative.\n* two conversion methods must be supported:\n * `toDecimal()` returns decimal representation of fraction\n * `toString()` returns string with fractional representation of stored value in format:\n\n    [ SIGN ] [ WHOLES ] [ NUMERATOR / DENOMINATOR ]\n   * **Note**: each part is returned only if it is available and non-zero, with the only possible space character going between WHOLES and fraction. Examples: '-1/2', '3', '-5 3/4'\n\n* The fractional part must always be normalized (ie. the numerator and denominators must not have any common divisors).\n* Four operations need to be implemented: `add`, `subtract`, `multiply` and `divide`. Each of them may take integers as well as another `Fraction` instance as an argument, and must return a new `Fraction` instance.\n* Instances must be immutable, hence none of the operations may modify either of the objects it is called upon, nor the passed argument.\n\n #### Python Notes\n* If one integer is passed into the initialiser, then the fraction should be assumed to represent an integer not a fraction.\n* You must implement the standard operator overrides `__add__`, `__sub__`, `__mul__`, `__div__`, in each case you should support `other` being an `int` or another instance of `Fraction`.\n* Implement `__str__` and `to_decimal` in place of `toString` and `toDecimal` as described above.\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString (n : Int) (d : Int) : String :=\nsorry\n\ndef toDecimal (n : Int) (d : Int) : Float :=\nsorry\n\ndef intToFloat (i : Int) : Float :=\nsorry\n\ndef stringToFloat (s : String) : Float :=\nsorry", "vc-theorems": "theorem sign_property (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  (n * d < 0 → s.startsWith \"-\") ∧\n  (n * d > 0 → ¬s.startsWith \"-\") :=\nsorry\n\ntheorem format_property (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  let parts := (s.dropWhile (·=='-')).splitOn \" \"\n  match parts with\n  | [p] =>\n    if p.any (·=='/') then\n      let nums := p.splitOn \"/\"\n      nums.length = 2 ∧\n      nums[0]!.all Char.isDigit ∧\n      nums[1]!.all Char.isDigit\n    else\n      p.all Char.isDigit\n  | [whole, frac] =>\n    whole.all Char.isDigit ∧\n    let fracParts := frac.splitOn \"/\"\n    fracParts.length = 2 ∧\n    fracParts[0]!.all Char.isDigit ∧\n    fracParts[1]!.all Char.isDigit ∧\n    fracParts[0]!.toNat! < fracParts[1]!.toNat!\n  | _ => False :=\nsorry\n\ntheorem decimal_conversion (n d : Int) (h : d ≠ 0) :\n  toDecimal n d = (intToFloat n / intToFloat d) :=\nsorry\n\ntheorem string_matches_value (n d : Int) (h : d ≠ 0) :\n  let s := toString n d\n  let val :=\n    if s.any (·==' ') then\n      let parts := (s.dropWhile (·=='-')).splitOn \" \"\n      let whole := intToFloat parts[0]!.toInt!\n      let fracParts := (parts[1]!.splitOn \"/\")\n      let num := intToFloat fracParts[0]!.toInt!\n      let den := intToFloat fracParts[1]!.toInt!\n      whole + (num / den)\n    else if s.any (·=='/') then\n      let parts := (s.dropWhile (·=='-')).splitOn \"/\"\n      (intToFloat parts[0]!.toInt!) / (intToFloat parts[1]!.toInt!)\n    else\n      stringToFloat s\n  toDecimal n d = (if s.startsWith \"-\" then -val else val) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004638", "vc-description": "/-\n# Task\n You are implementing your own HTML editor. To make it more comfortable for developers you would like to add an auto-completion feature to it.\n\n Given the starting HTML tag, find the appropriate end tag which your editor should propose.\n\n# Example\n\n For startTag = \"<button type='button' disabled>\", the output should be \"</button>\";\n\n For startTag = \"<i>\", the output should be \"</i>\".\n\n# Input/Output\n\n - `[input]` string `startTag`/`start_tag`\n\n - `[output]` a string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def html_end_tag_by_start_tag (start_tag: String) : String :=\n  sorry\n\ndef is_valid_tag_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_tag_first_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_attr_name_char (c: Char) : Bool :=\n  sorry\n\ndef is_valid_attr_value_char (c: Char) : Bool :=\n  sorry", "vc-theorems": "theorem html_end_tag_starts_with_close : ∀ (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).startsWith \"</\" = true :=\nsorry\n\ntheorem html_end_tag_ends_with_angle : ∀ (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).endsWith \">\" = true :=\nsorry\n\ntheorem html_end_tag_matches_start : ∀ (start_tag : String),\n  let start_name := (start_tag.drop 1).splitOn \" \" |>.head!.dropRight 1\n  let end_name := (html_end_tag_by_start_tag start_tag).drop 2 |>.dropRight 1\n  start_name = end_name :=\nsorry\n\ntheorem html_end_tag_no_attributes : ∀ (start_tag : String),\n  ¬(html_end_tag_by_start_tag start_tag).contains ' ' :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: '</i>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<i>\"\n\n/--\ninfo: '</button>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<button type=\"button\" disabled>\"\n\n/--\ninfo: '</div>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<div class=\"main\" id=\"content\" style=\"width:100px\">\""}
{"id": "fvapps_004644", "vc-description": "/-\nGiven a certain array of integers, create a function that may give the minimum number that may be divisible for all the numbers of the array.\n\n```python\nmin_special_mult([2, 3 ,4 ,5, 6, 7]) == 420\n```\nThe array may have integers that occurs more than once:\n```python\nmin_special_mult([18, 22, 4, 3, 21, 6, 3]) == 2772\n```\nThe array should have all its elements integer values. If the function finds an invalid entry (or invalid entries) like strings of the alphabet or symbols will not do the calculation and will compute and register them, outputting a message in singular or plural, depending on the number of invalid entries.\n\n```python\nmin_special_mult([16, 15, 23, 'a', '&', '12']) == \"There are 2 invalid entries: ['a', '&']\"\n\nmin_special_mult([16, 15, 23, 'a', '&', '12', 'a']) == \"There are 3 invalid entries: ['a', '&', 'a']\"\n\nmin_special_mult([16, 15, 23, 'a', '12']) == \"There is 1 invalid entry: a\"\n```\nIf the string is a valid number, the function will convert it as an integer.\n```python\nmin_special_mult([16, 15, 23, '12']) == 5520\n\nmin_special_mult([16, 15, 23, '012']) == 5520\n```\nAll the `None`/`nil` elements of the array will be ignored:\n```python\nmin_special_mult([18, 22, 4, , None, 3, 21, 6, 3]) == 2772\n```\nIf the array has a negative number, the function will convert to a positive one.\n```python\nmin_special_mult([18, 22, 4, , None, 3, -21, 6, 3]) == 2772\n\nmin_special_mult([16, 15, 23, '-012']) == 5520\n```\n\nEnjoy it\n-/\n\n/- Helper function to convert strings to a list containing each character -/", "vc-preamble": "def stringToList (s : String) : List Char := s.data\n\ndef stringContains (s₁ s₂ : String) : Prop := ∃ pre post : String, s₁ = pre ++ s₂ ++ post", "vc-helpers": "", "vc-definitions": "def min_special_mult (numbers : List Int) : Int ⊕ String :=\nsorry\n\ndef parseAsInt (s : String) : Option Int :=\nsorry", "vc-theorems": "theorem valid_numbers_only (numbers : List Int)\n  (h : ∀ n ∈ numbers, n > 0)\n  : ∃ result, (min_special_mult numbers = Sum.inl result ∧ result > 0) :=\nsorry\n\ntheorem invalid_entries (valid_nums invalid_nums : List String)\n  (h1 : invalid_nums.length > 0)\n  (h2 : invalid_nums.length ≤ 5)\n  (h3 : ∀ n ∈ invalid_nums, ∃ c ∈ (stringToList n), c.isAlpha ∨ c ∈ ['&', '$', '#', '@'])\n  (h4 : ∀ n ∈ valid_nums, (parseAsInt n).isSome)\n  : let valid_int_nums := valid_nums.filterMap parseAsInt\n    ∃ result : String,\n    (min_special_mult valid_int_nums = Sum.inr result)\n    ∧ (stringContains result (toString invalid_nums.length))\n    ∧ (∀ inv ∈ invalid_nums, stringContains result inv) :=\nsorry\n\ntheorem lcm_properties (numbers : List Int)\n  (h1 : numbers.length ≥ 2)\n  (h2 : numbers.length ≤ 5)\n  (h3 : ∀ n ∈ numbers, n > 0)\n  : ∃ result, min_special_mult numbers = Sum.inl result\n      ∧ ∀ n ∈ numbers, result % n = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 420\n-/\n#guard_msgs in\n#eval min_special_mult [2, 3, 4, 5, 6, 7]\n\n/--\ninfo: \"There are 2 invalid entries: ['a', '&']\"\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"a\", \"&\", \"12\"]\n\n/--\ninfo: 5520\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"-012\"]"}
{"id": "fvapps_004645", "vc-description": "/-\nIn this kata, we're going to create the function `nato` that takes a `word` and returns a string that spells the word using the [NATO phonetic alphabet](https://en.wikipedia.org/wiki/NATO_phonetic_alphabet).\n\nThere should be a space between each word in the returned string, and the first letter of each word should be capitalized.\n\nFor those of you that don't want your fingers to bleed, this kata already has a dictionary typed out for you.\n\n``` python\nnato(\"Banana\") # == \"Bravo Alpha November Alpha November Alpha\"\n```\n``` ruby\nnato(\"Banana\") # == \"Bravo Alpha November Alpha November Alpha\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAlpha (s : String) : Bool :=\n  sorry\n\ndef nato (s : String) : String :=\n  sorry", "vc-theorems": "theorem nato_output_format {s : String}\n  (h : s.all (fun c => c.isAlpha)) :\n  let result := nato s\n  let words := result.split (· = ' ')\n  (∀ w ∈ words, isAlpha w ∨ w.contains '-') ∧\n  words.length = s.length :=\nsorry\n\ntheorem nato_case_insensitive {s : String}\n  (h : s.all (fun c => 'A' ≤ c ∧ c ≤ 'Z')) :\n  nato s = nato s.toUpper :=\nsorry\n\ntheorem nato_valid_codes {s : String}\n  (h : s.all (fun c => 'A' ≤ c ∧ c ≤ 'Z')) :\n  let natoWords := [\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\",\n                   \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\",\n                   \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\",\n                   \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\",\n                   \"Uniform\", \"Victor\", \"Whiskey\", \"X-ray\",\n                   \"Yankee\", \"Zulu\"]\n  let result := nato s\n  ∀ w ∈ result.split (· = ' '), w ∈ natoWords :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'Bravo Alpha November Alpha November Alpha'\n-/\n#guard_msgs in\n#eval nato \"Banana\"\n\n/--\ninfo: 'Hotel India'\n-/\n#guard_msgs in\n#eval nato \"Hi\"\n\n/--\ninfo: 'Alpha Bravo Charlie'\n-/\n#guard_msgs in\n#eval nato \"ABC\""}
{"id": "fvapps_004650", "vc-description": "/-\nGiven an array `A` and an integer `x`, map each element in the array to `F(A[i],x)` then return the xor sum of the resulting array.\n\nwhere F(n,x) is defined as follows:\n\nF(n, x) = ^(x)Cx **+** ^(x+1)Cx **+** ^(x+2)Cx **+** ... **+** ^(n)Cx\n\nand ^(n)Cx represents [Combination](https://en.m.wikipedia.org/wiki/Combination) in mathematics\n\n### Example\n\n```python\na = [7, 4, 11, 6, 5]\nx = 3\n\n# after mapping, `a` becomes [F(7,3), F(4,3), F(11,3), F(6,3), F(5,3)]\n\nreturn F(7,3) ^ F(4,3) ^ F(11,3) ^ F(6,3) ^ F(5,3)\n#=> 384\n```\n##### e.g\nF(7, 3) = ^(3)C3 + ^(4)C3 + ^(5)C3  + ^(6)C3 + ^(7)C3\n\n## Constraints\n\n**1 <= x <= 10**\n\n**x <= A[i] <= 10^(4)**\n\n**5 <= |A| <= 10^(3)**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Nat.choose (n k : Nat) : Nat :=\nsorry\n\ndef List.sort (l : List Nat) : List Nat :=\nsorry\n\ndef transform (arr : List Nat) (x : Nat) : Nat :=\nsorry", "vc-theorems": "theorem transform_single_element (n x : Nat) (h : x ≤ n) :\n  transform [n] x = (List.range (n - x + 1)).foldl (fun acc i => acc + Nat.choose (i + x) x) 0 :=\nsorry\n\ntheorem transform_shuffle (arr : List Nat) (x : Nat) (h : ∀ n ∈ arr, n ≥ x) :\n  transform arr x = transform (List.sort arr) x :=\nsorry\n\ntheorem transform_zero_x (arr : List Nat) :\n  transform arr 0 = List.foldl (fun acc n => acc + (n + 1)) 0 arr :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 384\n-/\n#guard_msgs in\n#eval transform [7, 4, 11, 6, 5] 3\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval transform [5, 6, 7] 2\n\n/--\ninfo: 462\n-/\n#guard_msgs in\n#eval transform [10] 5"}
{"id": "fvapps_004652", "vc-description": "/-\n# Task\n Given a rectangular matrix containing only digits, calculate the number of different `2 × 2` squares in it.\n\n# Example\n\n For\n```\nmatrix = [[1, 2, 1],\n          [2, 2, 2],\n          [2, 2, 2],\n          [1, 2, 3],\n          [2, 2, 1]]\n```\nthe output should be `6`.\n\n Here are all 6 different 2 × 2 squares:\n\n ```\n 1 2\n 2 2\n\n 2 1\n 2 2\n\n 2 2\n 2 2\n\n 2 2\n 1 2\n\n 2 2\n 2 3\n\n 2 3\n 2 1\n ```\n\n# Input/Output\n\n - `[input]` 2D integer array `matrix`\n\n    Constraints: \n\n    `1 ≤ matrix.length ≤ 100,`\n\n    `1 ≤ matrix[i].length ≤ 100,`\n\n    `0 ≤ matrix[i][j] ≤ 9.`\n\n - `[output]` an integer\n\n    The number of different `2 × 2` squares in matrix.\n-/\n\n-- Number of different squares is always positive and has an upper bound\n\n-- A matrix filled with same value has exactly 1 unique square\n\n-- Rotating a matrix preserves number of unique squares", "vc-preamble": "def Matrix := List (List Nat)", "vc-helpers": "", "vc-definitions": "def different_squares : Matrix → Nat :=\nsorry\n\ndef rotateMatrix (m : Matrix) : Matrix :=\nsorry\n\ndef isValidMatrix (m : Matrix) : Bool :=\nsorry\n\ndef isAllValue (m : Matrix) (v : Nat) : Bool :=\nsorry", "vc-theorems": "theorem different_squares_bounds (m : Matrix) :\n  isValidMatrix m →\n  1 ≤ different_squares m ∧\n  different_squares m ≤ (m.length - 1) * ((m.head!).length - 1) :=\nsorry\n\ntheorem same_value_matrix_one_square (m : Matrix) (v : Nat) :\n  isValidMatrix m →\n  isAllValue m v →\n  different_squares m = 1 :=\nsorry\n\ntheorem different_squares_rotation_invariant (m : Matrix) :\n  isValidMatrix m →\n  different_squares m = different_squares (rotateMatrix m) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval different_squares [[1, 2, 1], [2, 2, 2], [2, 2, 2], [1, 2, 3], [2, 2, 1]]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[1, 1], [1, 1]]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[9, 9, 9], [9, 9, 9], [9, 9, 9]]"}
{"id": "fvapps_004662", "vc-description": "/-\nSuzuki needs help lining up his students!\n\nToday Suzuki will be interviewing his students to ensure they are progressing in their training. He decided to schedule the interviews based on the length of the students name in descending order. The students will line up and wait for their turn.\n\nYou will be given a string of student names. Sort them and return a list of names in descending order.\n\nHere is an example input:\n```python\nstring = 'Tadashi Takahiro Takao Takashi Takayuki Takehiko Takeo Takeshi Takeshi'\n```\nHere is an example return from your function:\n\n```python\n lst = ['Takehiko',\n        'Takayuki',\n        'Takahiro',\n        'Takeshi',\n        'Takeshi',\n        'Takashi',\n        'Tadashi',\n        'Takeo',\n        'Takao']\n``` \n\nNames of equal length will be returned in reverse alphabetical order (Z->A) such that:\n\n```python\nstring = \"xxa xxb xxc xxd xa xb xc xd\"\n\n```\nReturns\n\n```python\n['xxd', 'xxc', 'xxb', 'xxa', 'xd', 'xc', 'xb', 'xa']\n\n``` \nPlease also try the other Kata in this series..\n\n* [Help Suzuki count his vegetables...](https://www.codewars.com/kata/56ff1667cc08cacf4b00171b)\n* [Help Suzuki purchase his Tofu!](https://www.codewars.com/kata/57d4ecb8164a67b97c00003c)\n* [Help Suzuki pack his coal basket!](https://www.codewars.com/kata/57f09d0bcedb892791000255)\n* [Help Suzuki rake his garden!](https://www.codewars.com/kata/571c1e847beb0a8f8900153d)\n* [How many stairs will Suzuki climb in 20 years?](https://www.codewars.com/kata/56fc55cd1f5a93d68a001d4e)\n-/\n\n/-\n  lineupStudentsLengthPreserved:\n  For any list of students, the length of the output list\n  equals the length of the input list\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  lineupStudentsSorted:\n  For any two adjacent elements in the result,\n  if they have equal length then they are reverse alphabetically sorted,\n  otherwise the first is longer than the second\n-/\n\n/-\n  lineupStudentsPreservesElements:\n  The output list contains exactly the same elements as the input\n-/\n\n/-\n  lineupStudentsSingleElement:\n  A single name returns a singleton list with that name\n-/\n\n/-\n  lineupStudentsEmpty:\n  An empty string input returns an empty list\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lineup_students (input : String) : List String :=\nsorry", "vc-theorems": "theorem lineupStudentsLengthPreserved (input : String) (names : List String) :\n  names = lineup_students input →\n  (lineup_students input).length = names.length :=\nsorry\n\ntheorem lineupStudentsSorted {result : List String} (i : Nat) (h : i + 1 < result.length) :\n  let a := result[i]!\n  let b := result[i+1]!\n  (a.length = b.length → a ≥ b) ∧\n  (a.length ≠ b.length → a.length > b.length) :=\nsorry\n\ntheorem lineupStudentsPreservesElements (input : String) (names : List String) :\n  names = lineup_students input →\n  ∀ x, (x ∈ names ↔ x ∈ lineup_students input) :=\nsorry\n\ntheorem lineupStudentsSingleElement (name : String) :\n  lineup_students name = [name] :=\nsorry\n\ntheorem lineupStudentsEmpty :\n  lineup_students \"\" = [] :=\nsorry", "vc-postamble": "/--\ninfo: expected1\n-/\n#guard_msgs in\n#eval lineup_students \"Tadashi Takahiro Takao Takashi Takayuki Takehiko Takeo Takeshi Takeshi\"\n\n/--\ninfo: expected2\n-/\n#guard_msgs in\n#eval lineup_students \"xxa xxb xxc xxd xa xb xc xd\"\n\n/--\ninfo: expected3\n-/\n#guard_msgs in\n#eval lineup_students \"aaa bbb ccc\""}
{"id": "fvapps_004668", "vc-description": "/-\nCreate a function ```sel_number()```, that will select numbers that fulfill the following constraints:\n\n1) The numbers should have 2 digits at least.\n\n2) They should have their respective digits in increasing order from left to right. \nExamples: 789, 479, 12678, have these feature. But 617, 89927 are not of this type.\nIn general, if ```d1, d2, d3....``` are the digits of a certain number ```i``` \nExample:\n```( i = d1d2d3d4d5) so, d1 < d2 < d3 < d4 < d5```\n\n3) They cannot have digits that occurs twice or more. Example: 8991 should be discarded.\n\n4) The difference between neighbouring pairs of digits cannot exceed certain value. \nExample: If the difference between contiguous digits cannot excced 2, so 1345, 23568 and 234578 pass this test. Other numbers like 1456, 389, 157 don't belong to that group because in the first number(1456), the difference between second and first digit 4 - 1 > 2; in the next one(389), we have 8 - 3 > 2; and see by yourself why 157 should be discarded.\nIn general, taking the example above of ```i = d1d2d3d4d5```:\n```\nd2 - d1 <= d;\n\nd3 - d2 <= d;\n\nd4 - d3 <= d;\n\nd5 - d4 <= d;\n```\nThe function should accept two arguments n and d; n is the upper limit of the range to work with(all the numbers should be less or equal than n), and d is maximum difference  between every pair of its contiguous digits. It's clear that 1 <= d <= 8.\n\nHere we have some cases:\n```\nsel_number(0,1) = 0 # n = 0, empty range\nsel_number(3, 1) = 0 # n = 3, numbers should be higher or equal than 12\nsel_number(13, 1) = 1 # only 12 fulfill the requirements\nsel_number(20, 2) = 2 # 12 and 13 are the numbers\nsel_number(30, 2) = 4 # 12, 13, 23 and 24 are the selected ones\nsel_number(44, 2) = 6 # 12, 13, 23, 24, 34 and 35 are valid ones\nsel_number(50, 3) = 12 # 12, 13, 14, 23, 24, 25, 34, 35, 36, 45, 46 and 47 are valid\n```\nCompare the last example with this one:\n```\nsel_number(47, 3) = 12 # 12, 13, 14, 23, 24, 25, 34, 35, 36, 45, 46 and 47 are valid \n```\n(because the instructions says the value of may be included if it fulfills the above constraints of course)\n\nHappy coding!!\n-/\n\n/- Helper function to count numbers with ascending unique digits -/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- Helper function to check if digits are ascending and unique -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sel_number (n : Nat) (d : Nat) : Nat :=\n  sorry\n\ndef hasAscendingUniqueDigits (n : Nat) : Bool :=\n  sorry\n\ndef countAscendingUnique (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sel_number_non_negative (n d : Nat) :\n  sel_number n d ≥ 0 :=\nsorry\n\ntheorem sel_number_under_twelve (n d : Nat) :\n  n < 12 → sel_number n d = 0 :=\nsorry\n\ntheorem sel_number_unique_bound (n : Nat) :\n  sel_number n 0 ≤ String.length (toString n) :=\nsorry\n\ntheorem sel_number_monotonic_d (n : Nat) :\n  ∀ d₁ d₂ : Nat, d₁ ≤ d₂ → d₂ < 10 → n ≥ 12 →\n    sel_number n d₁ ≤ sel_number n d₂ :=\nsorry\n\ntheorem sel_number_monotonic_n (d n₁ n₂ : Nat) :\n  n₁ ≤ n₂ → n₁ ≥ 12 → d < 10 →\n    sel_number n₁ d ≤ sel_number n₂ d :=\nsorry", "vc-postamble": "/--\ninfo: 2\n-/\n#guard_msgs in\n#eval sel_number 20 2\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sel_number 0 1\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval sel_number 50 3"}
{"id": "fvapps_004669", "vc-description": "/-\nWrite the function `resistor_parallel` that receive an undefined number of resistances parallel resistors and return the total resistance.\n\nYou can assume that there will be no 0 as parameter.  \nAlso there will be at least 2 arguments.\n\nFormula:  \n`total = 1 / (1/r1 + 1/r2 + .. + 1/rn)`\n\nExamples:  \n`resistor_parallel(20, 20)` will return `10.0`  \n`resistor_parallel(20, 20, 40)` will return `8.0`\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded", "vc-preamble": "def sum_list : List Float → Float\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def resistor_parallel (r : List Float) : Float :=\nsorry", "vc-theorems": "theorem parallel_resistance_positive {r : List Float} (h : ∀ x ∈ r, x > 0) :\n  resistor_parallel r > 0 :=\nsorry\n\ntheorem single_resistor_identity {r : Float} (h : r > 0) :\n  resistor_parallel [r] = r :=\nsorry\n\ntheorem parallel_symmetric {r1 r2 : Float} (h1 : r1 > 0) (h2 : r2 > 0) :\n  resistor_parallel [r1, r2] = resistor_parallel [r2, r1] :=\nsorry\n\ntheorem inverse_sum_relationship {r : List Float} (h : ∀ x ∈ r, x > 0) :\n  1 / (resistor_parallel r) = sum_list (r.map (λ x => 1/x)) :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004680", "vc-description": "/-\n[Harshad numbers](http://en.wikipedia.org/wiki/Harshad_number) (also called Niven numbers) are positive numbers that can be divided (without remainder) by the sum of their digits.\n\nFor example, the following numbers are Harshad numbers:\n\n* 10, because 1 + 0 = 1 and 10 is divisible by 1\n* 27, because 2 + 7 = 9 and 27 is divisible by 9\n* 588, because 5 + 8 + 8 = 21 and 588 is divisible by 21\n\nWhile these numbers are not:\n\n* 19, because 1 + 9 = 10 and 19 is not divisible by 10\n* 589, because 5 + 8 + 9 = 22 and 589 is not divisible by 22\n* 1001, because 1 + 1 = 2 and 1001 is not divisible by 2\n\nHarshad numbers can be found in any number base, but we are going to focus on base 10 exclusively.\n\n## Your task\n\nYour task is to complete the skeleton Harshad object (\"static class\") which has 3 functions:\n\n* ```isValid()``` that checks if `n` is a Harshad number or not\n* ```getNext()``` that returns the next Harshad number > `n`\n* ```getSerie()``` that returns a series of `n` Harshad numbers, optional `start` value not included\n\nYou do not need to care about the passed parameters in the test cases, they will always be valid integers (except for the start argument in `getSerie()` which is optional and should default to `0`).\n\n**Note:** only the first 2000 Harshad numbers will be checked in the tests.\n\n## Examples\n\n```python\nHarshad.is_valid(1)          ==>  True\nHarshad.get_next(0)          ==>  1\nHarshad.get_series(3)        ==>  [ 1, 2, 3 ]\nHarshad.get_series(3, 1000)  ==>  [ 1002, 1008, 1010 ]\n```\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def digitsSum (n : Nat) : Nat :=\nsorry\n\ndef is_valid (n : Nat) : Bool :=\nsorry\n\ndef get_next (n : Nat) : Nat :=\nsorry\n\ndef get_series (count start : Nat) : List Nat :=\nsorry", "vc-theorems": "theorem harshad_property {n : Nat} (h : n > 0) (valid : is_valid n = true) :\n  n % digitsSum n = 0 :=\nsorry\n\ntheorem get_next_properties {n : Nat} :\n  let next := get_next n\n  next > n ∧\n  is_valid next = true ∧\n  ∀ x, n < x → x < next → is_valid x = false :=\nsorry\n\ntheorem get_series_properties {count start : Nat} (h : count > 0) :\n  let series := get_series count start\n  List.length series = count ∧\n  (∀ i, i + 1 < List.length series →\n    series[i]'(by sorry) < series[i+1]'(by sorry)) ∧\n  (∀ x ∈ series, x > start) ∧\n  (∀ x ∈ series, is_valid x = true) :=\nsorry\n\ntheorem next_harshad_valid {n : Nat} :\n  is_valid (get_next n) = true :=\nsorry", "vc-postamble": ""}
{"id": "fvapps_004687", "vc-description": "/-\nImagine the following situations:\n\n- A truck loading cargo\n- A shopper on a budget\n- A thief stealing from a house using a large bag\n- A child eating candy very quickly\n\nAll of these are examples of ***The Knapsack Problem***, where there are more things that you ***want*** to take with you than you ***can*** take with you.\n\nThe Problem\n===\n\nGiven a container with a certain capacity and an assortment of discrete items with various sizes and values (and an infinite supply of each item), determine the combination of items that fits within the container and maximizes the value of the collection.\n\nHowever, **DO NOT** attempt to solve the problem **EXACTLY!** (we will do that in Part 2)\n\nThe Simplification\n===\n\nBecause the optimal collection of items is **MUCH** more difficult to determine than a nearly-optimal collection, this kata will only focus on one specific nearly-optimal solution: the greedy solution. The greedy solution is that which always adds an item to the collection if it has the highest value-to-size ratio.\n\nFor example, if a \"greedy thief\" with a 10-Liter knapsack sees two types of items\n\n- a 6-Liter item worth $9 (1.5 $/L)\n\n- a 5-Liter item worth $5 (1.0 $/L)\n\nthe thief will take 1 of the 6-Liter items instead of 2 of the 5-Liter items. Although this means the thief will only profit $9 instead of $10, the decision algorithm is much simpler. Maybe the thief is bad at math.\n\nNow, go be bad at math!\n\nThe Kata\n===\n\nWrite the function `knapsack` that takes two parameters, `capacity` and `items`, and returns a list of quantities.\n\n`capacity` will be a positive number\n\n`items` will be an array of arrays of positive numbers that gives the items' sizes and values in the form [[size 1, value 1], [size 2, value 2], ...]\n\n`knapsack` will return an array of integers that specifies the quantity of each item to take according to the greedy solution (the order of the quantities must match the order of `items`)\n-/", "vc-preamble": "def sumList (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sumList t\n\ndef zipWithIndex {α : Type} (l : List α) : List (Nat × α) :=\n  let rec aux (i : Nat) (xs : List α) : List (Nat × α) :=\n    match xs with\n    | [] => []\n    | h :: t => (i, h) :: aux (i+1) t\n  aux 0 l", "vc-helpers": "", "vc-definitions": "def knapsack (capacity : Nat) (items : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem knapsack_result_length_matches_input\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    (knapsack capacity items).length = items.length :=\nsorry\n\ntheorem knapsack_result_nonnegative\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    ∀ x ∈ knapsack capacity items, x ≥ 0 :=\nsorry\n\ntheorem knapsack_total_size_within_capacity\n    (capacity : Nat) (items : List (Nat × Nat)) :\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    sumList sizes ≤ capacity :=\nsorry\n\ntheorem knapsack_optimal_ratio\n    (capacity : Nat) (items : List (Nat × Nat)) (i : Nat) :\n    i < items.length →\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    let total_size := sumList sizes\n    let ratio := items[i]!.2 / items[i]!.1\n    items[i]!.1 + total_size ≤ capacity →\n    ∀ j < items.length,\n      items[j]!.2 / items[j]!.1 = 0 ∨ items[j]!.2 / items[j]!.1 < ratio :=\nsorry\n\ntheorem knapsack_zero_capacity\n    (items : List (Nat × Nat)) :\n    knapsack 0 items = List.replicate items.length 0 :=\nsorry\n\ntheorem knapsack_empty_items\n    (capacity : Nat) :\n    knapsack capacity [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[6, 9], [5, 5]]\n\n/--\ninfo: [5, 0, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[2, 3], [3, 4], [4, 5]]\n\n/--\ninfo: [0, 0]\n-/\n#guard_msgs in\n#eval knapsack 5 [[10, 2], [12, 4]]"}
{"id": "fvapps_004693", "vc-description": "/-\nCreate a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.\n\nModern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.\n\nExample:\n```python\nsolution(1000) # should return 'M'\n```\n\nHelp:\n```\nSymbol  Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1,000\n```\n\nRemember that there can't be more than 3 identical symbols in a row.\n\nMore about roman numerals - http://en.wikipedia.org/wiki/Roman_numerals\n-/\n\n/- Map Roman numerals to their decimal values -/", "vc-preamble": "def romanValues : List (Char × Nat) :=\n  [('I', 1), ('V', 5), ('X', 10), ('L', 50), ('C', 100), ('D', 500), ('M', 1000)]", "vc-helpers": "", "vc-definitions": "def solution (n : Nat) : String :=\nsorry\n\ndef isSubstring (s₁ s₂ : String) : Bool :=\nsorry\n\ndef convertToNums (s : String) : List Nat :=\nsorry", "vc-theorems": "theorem monotonically_decreasing_values (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  let numericValues := convertToNums (solution n)\n  ∀ i j, i < j → j < numericValues.length →\n    (numericValues.get ⟨i, sorry⟩) ≥ (numericValues.get ⟨j, sorry⟩) :=\nsorry\n\ntheorem valid_roman_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ∀ c, String.contains (solution n) c → c ∈ ['M', 'D', 'C', 'L', 'X', 'V', 'I'] :=\nsorry\n\ntheorem length_constraints (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  (n ≤ 3 → (solution n).length ≤ 3) ∧\n  (n ≤ 8 → (solution n).length ≤ 4) ∧\n  (n ≤ 39 → (solution n).length ≤ 6) :=\nsorry\n\ntheorem no_four_consecutive_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ¬isSubstring \"IIII\" (solution n) ∧\n  ¬isSubstring \"XXXX\" (solution n) ∧\n  ¬isSubstring \"CCCC\" (solution n) ∧\n  ¬isSubstring \"MMMM\" (solution n) :=\nsorry\n\ntheorem valid_subtractive_pairs (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :\n  ¬isSubstring \"IL\" (solution n) ∧\n  ¬isSubstring \"IC\" (solution n) ∧\n  ¬isSubstring \"ID\" (solution n) ∧\n  ¬isSubstring \"IM\" (solution n) ∧\n  ¬isSubstring \"XD\" (solution n) ∧\n  ¬isSubstring \"XM\" (solution n) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 'I'\n-/\n#guard_msgs in\n#eval solution 1\n\n/--\ninfo: 'MCMXC'\n-/\n#guard_msgs in\n#eval solution 1990\n\n/--\ninfo: 'MMVIII'\n-/\n#guard_msgs in\n#eval solution 2008"}
{"id": "fvapps_004696", "vc-description": "/-\nIn this kata, your task is to implement what I call **Iterative Rotation Cipher (IRC)**. To complete the task, you will create an object with two methods, `encode` and `decode`. (For non-JavaScript versions, you only need to write the two functions without the enclosing dict)\n\nInput\nThe encode method will receive two arguments — a positive integer n and a string value.\nThe decode method will receive one argument — a string value.\nOutput\nEach method will return a string value.\nHow It Works\nEncoding and decoding are done by performing a series of character and substring rotations on a string input.\nEncoding: The number of rotations is determined by the value of n. The sequence of rotations is applied in the following order:\n Step 1: remove all spaces in the string (but remember their positions)\n Step 2: shift the order of characters in the new string to the right by n characters\n Step 3: put the spaces back in their original positions\n Step 4: shift the characters of each substring (separated by one or more consecutive spaces) to the right by n\n\nRepeat this process until it has been completed n times in total.\nThe value n is then prepended to the resulting string with a space.\nDecoding: Decoding simply reverses the encoding process.\nTest Example\n\n```python\nquote = 'If you wish to make an apple pie from scratch, you must first invent the universe.'\nsolution = '10 hu fmo a,ys vi utie mr snehn rni tvte .ysushou teI fwea pmapi apfrok rei tnocsclet'\nIterativeRotationCipher['encode'](10,quote) == solution; //True\n\n'''Step-by-step breakdown:\nStep 1 — remove all spaces:\n'Ifyouwishtomakeanapplepiefromscratch,youmustfirstinventtheuniverse.'\n\nStep 2 — shift the order of string characters to the right by 10:\n'euniverse.Ifyouwishtomakeanapplepiefromscratch,youmustfirstinventth'\n\nStep 3 — place the spaces back in their original positions:\n'eu niv erse .I fyou wi shtom ake anap plepiefr oms crat ch,yo umustf irs tinventth'\n\nStep 4 — shift the order of characters for each space-separated substring to the right by 10:\n'eu vni seer .I oufy wi shtom eak apan frplepie som atcr ch,yo ustfum sir htinventt'\n\nRepeat the steps 9 more times before returning the string with '10 ' prepended.\n'''\n```\n\nTechnical Details\n\n- Input will always be valid.\n- The characters used in the strings include any combination of alphanumeric characters, the space character, the newline character, and any of the following: `_!@#$%^&()[]{}+-*/=\"'<>,.?:;`.\n\nIf you enjoyed this kata, be sure to check out [my other katas](https://www.codewars.com/users/docgunthrop/authored).\n-/\n\n/- For any number n and text, decoding after encoding returns original text -/\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The first word of encoded text equals the input number n as string -/\n\n/- Empty string cases -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def encode (n : Nat) (s : String) : String :=\nsorry\n\ndef decode (s : String) : String :=\nsorry", "vc-theorems": "theorem encode_decode_roundtrip (n : Nat) (text : String) :\n  decode (encode n text) = text :=\nsorry\n\ntheorem encode_starts_with_n (n : Nat) (text : String) :\n  List.get! (String.splitOn (encode n text) \" \") 0 = toString n :=\nsorry\n\ntheorem empty_string_case1 : decode (encode 5 \"\") = \"\" :=\nsorry\n\ntheorem empty_string_case2 : encode 0 \"\" = \"0 \" :=\nsorry", "vc-postamble": "/--\ninfo: solution\n-/\n#guard_msgs in\n#eval encode 10 \"If you wish to make an apple pie from scratch, you must first invent the universe.\"\n\n/--\ninfo: quote\n-/\n#guard_msgs in\n#eval decode encode(10, quote)\n\n/--\ninfo: test2\n-/\n#guard_msgs in\n#eval decode encode(3, test2)\n\n/--\ninfo: test3\n-/\n#guard_msgs in\n#eval decode encode(5, test3)"}
{"id": "fvapps_004697", "vc-description": "/-\n# Story\n\nThose pesky rats have returned and this time they have taken over the Town Square.\n\nThe Pied Piper has been enlisted again to play his magical tune and coax all the rats towards him.\n\nBut some of the rats are deaf and are going the wrong way!\n\n# Kata Task\n\nHow many deaf rats are there?\n\n## Input Notes\n\n* The Town Square is a rectangle of square paving stones (the Square has 1-15 pavers per side)\n* The Pied Piper is always present\n\n## Output Notes\n* Deaf rats are those that are moving to paving stone **further away** from the Piper than where they are now\n* Use Euclidian distance for your calculations\n\n## Legend\n\n* `P` = The Pied Piper\n* `←` `↑` `→` `↓` `↖` `↗` `↘` `↙` = Rats going in different directions\n* space = Everything else\n\n# Examples\n\nex1 - has 1 deaf rat\n\n↗ P              \n  ↘   ↖\n  ↑              \n↗        \n\n---\n\nex2 - has 7 deaf rats\n\n    ↗            \nP ↓   ↖ ↑\n    ←   ↓\n  ↖ ↙   ↙\n↓ ↓ ↓\n-/", "vc-preamble": "def listSum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + listSum xs\n\ndef countChar (s: String) (c: Char) : Nat :=\n  s.toList.filter (· == c) |>.length", "vc-helpers": "", "vc-definitions": "def DIRS := [('←', (0,-1)), ('↑', (-1,0)), ('→', (0,1)), ('↓', (1,0)),\n            ('↖', (-1,-1)), ('↗', (-1,1)), ('↘', (1,1)), ('↙', (1,-1))]\n\ndef count_deaf_rats (town: List String) : Nat :=\n  sorry", "vc-theorems": "theorem valid_output_range (town: List String)\n  (h1: town.length > 0)\n  (h2: listSum (town.map (fun row => countChar row 'P')) = 1)\n  : let total_rats := listSum (town.map (fun row =>\n      listSum ((DIRS.map Prod.fst).map (fun c => countChar row c))))\n    let result := count_deaf_rats town\n    0 ≤ result ∧ result ≤ total_rats :=\nsorry\n\ntheorem empty_town :\n  count_deaf_rats [\" P \"] = 0 :=\nsorry\n\ntheorem simple_case :\n  count_deaf_rats [\"P →\", \"← ←\"] = 2 :=\nsorry\n\ntheorem all_directions :\n  let dirChars := DIRS.map Prod.fst\n  let town := [\"P \" ++ String.mk dirChars]\n  let result := count_deaf_rats town\n  0 ≤ result ∧ result ≤ DIRS.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"↗ P     \", \"  ↘   ↖\", \"  ↑     \", \"↗       \"]\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"    ↗    \", \"P ↓   ↖ ↑\", \"    ←   ↓\", \"  ↖ ↙   ↙\", \"↓ ↓ ↓    \"]"}
{"id": "fvapps_004708", "vc-description": "/-\nGiven a random bingo card and an array of called numbers, determine if you have a bingo!\n\n*Parameters*: `card` and `numbers` arrays.\n\n*Example input*:\n```\ncard = [\n  ['B', 'I', 'N', 'G', 'O'],\n  [1, 16, 31, 46, 61],\n  [3, 18, 33, 48, 63],\n  [5, 20, 'FREE SPACE', 50, 65],\n  [7, 22, 37, 52, 67],\n  [9, 24, 39, 54, 69]\n]\n\nnumbers = ['B1', 'I16', 'N31', 'G46', 'O61']\n```\n\n*Output*: ```true``` if you have a bingo, ```false``` if you do not.\n\nYou have a bingo if you have a complete row, column, or diagonal - each consisting of 5 numbers, or 4 numbers and the FREE SPACE.\n\n### Constraints:\nEach column includes 5 random numbers within a range (inclusive):  \n`'B':  1 - 15`  \n`'I': 16 - 30`  \n`'N': 31 - 45`  \n`'G': 46 - 60`  \n`'O': 61 - 75`  \n\n### Notes:\n* All numbers will be within the above ranges.\n* `FREE SPACE` will not be included in the numbers array but always counts towards a bingo.\n* The first array of the card is the column headers.\n* `numbers` array will include only tiles present in the card, without duplicates.\n\n___\n\n## Examples:\n```\ncard:\n------------------------------\n| B  | I  |   N    | G  | O  |\n==============================\n| 2  | 17 |   32   | 47 | 74 |\n------------------------------\n| 14 | 25 |   44   | 48 | 62 |\n------------------------------\n| 5  | 22 | 'FREE' | 49 | 67 |\n------------------------------\n| 10 | 23 |   45   | 59 | 73 |\n------------------------------\n| 1  | 30 |   33   | 58 | 70 |\n------------------------------\n\nnumbers: ['N32', 'N45', 'B7', 'O75', 'N33', 'N41, 'I18', 'N44']\n\n// return true - you have bingo at ['N32', 'N44', 'FREE', 'N45', 'N33']\n```\n\nThe inspiration for this kata originates from completing the [Bingo Card](http://www.codewars.com/kata/566d5e2e57d8fae53c00000c) by FrankK.\n-/", "vc-preamble": "def Card := List (List (Option Nat))", "vc-helpers": "", "vc-definitions": "def CalledNumber := String\n\ndef bingo (card : Card) (numbers : List CalledNumber) : Bool :=\n  sorry\n\ndef cardNumberToString (n : Option Nat) : CalledNumber :=\n  sorry", "vc-theorems": "theorem bingo_returns_boolean (card : Card) (numbers : List CalledNumber) :\n  ∃ b : Bool, bingo card numbers = b :=\nsorry\n\ntheorem free_space_is_center (card : Card) :\n  card.get? 2 >>= (·.get? 2) = some none :=\nsorry\n\ntheorem empty_calls_no_bingo (card : Card) :\n  ¬(bingo card []) :=\nsorry\n\ntheorem all_numbers_called_is_bingo (card : Card) (numbers : List CalledNumber)\n  (h : ∀ (i j : Nat), i < card.length → j < (card.get! i).length →\n       (card.get! i).get! j ≠ none →\n       cardNumberToString ((card.get! i).get! j) ∈ numbers) :\n  bingo card numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\", \"O61\"]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\"]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"N31\", \"N33\", \"N37\", \"N39\"]"}
{"id": "fvapps_004713", "vc-description": "/-\nThe function sigma 1, σ1 in mathematics, is known as the one that gives the sum of the divisors of an integer number.\n\nFor example for the number 10,\n```python\nσ1(10) = 18 # because the divisors of 10 are: 1, 2, 5, 10\n\nσ1(10) = 1 + 2 + 5 + 10 = 18\n```\nYou can see the graph of this important function up to 250:\n\nThe number 528 and its reversed, 825 have equal value for the function σ1.\n```python\nσ1(528) = σ1(825)\n\ndivisors of 528 are: 1, 2, 3, 4, 6, 8, 11, 12, 16, 22, 24, 33, 44, 48, 66, 88, 132, 176, 264 and 528\n\nthe sum of the divisors of 528 is 1488\n\ndivisors of 825 are: 1, 3, 5, 11, 15, 25, 33, 55, 75, 165, 275 and 825\n\nthe sum of the divisors of 825 is 1488\n```\nIn fact 528 is the smallest non palindromic integer that has this property.\n\nWe need a function, ```equal_sigma1()```, that may collect all the positive integers that fulfill the property described above.\n\nThe function receives an upper limit, ```nMax```, will output the total sum of these numbers and its reversed while are less or equal nMax.\n\nLet's see some cases:\n```python\nequal_sigma1(100) = 0 # There are no numbers.\n\nequal_sigma1(1000) = 1353 # 528 and its revesed 825 were found, 528 +  825 = 1353\n\nequal_sigma1(2000) = 4565 # There are four numbers_: 528 + 825 + 1561 + 1651 = 4565\n\nequal_sigma1(1600) = 2914 # Now we have three numbers: 528 + 825 + 1561 = 2914\n\nequal_sigma1(1561) = 2914\n```\nThe palindromic numbers (like 88, 808, 929), numbers that are equal to its reversed should be discarded.\n\nHappy coding!!\n\n(For more information about the general sigma function see at: https://en.wikipedia.org/wiki/Divisor_function)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_divisors (n: Nat) : Nat :=\n  sorry\n\ndef equal_sigma1 (nmax: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem sum_divisors_positive (n: Nat) (h: n ≥ 1) :\n  let result := sum_divisors n\n  result ≥ 1 ∧ result ≥ n :=\nsorry\n\ntheorem equal_sigma1_properties (nmax: Nat) (h: nmax ≥ 1) :\n  let result := equal_sigma1 nmax\n  result ≥ 0 ∧ (nmax < 528 → result = 0) :=\nsorry\n\ntheorem sum_divisors_multiplication_property (n: Nat) (h: n ≥ 1) :\n  ∀ k : Nat,\n  let divisors := (List.range n).filterMap (fun i =>\n    if n % (i+1) = 0 then some (i+1) else none)\n  k * k = n →\n  sum_divisors n ≤ 2 * n :=\nsorry\n\ntheorem equal_sigma1_symmetry (nmax: Nat) :\n  let result := equal_sigma1 nmax\n  ∀ n, n ≥ 528 → n ≤ nmax →\n  n = 528 ∨ n = 1561 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval equal_sigma1 100\n\n/--\ninfo: 1353\n-/\n#guard_msgs in\n#eval equal_sigma1 1000\n\n/--\ninfo: 4565\n-/\n#guard_msgs in\n#eval equal_sigma1 2000"}
{"id": "fvapps_004714", "vc-description": "/-\nThe principal of a school likes to put challenges to the students related with finding words of certain features.\nOne day she said: \"Dear students, the challenge for today is to find a word that has only one vowel and seven consonants but cannot have the letters \"y\" and \"m\". I'll give a special award for the first student that finds it.\" One of the students used his dictionary and spent all the night without sleeping, trying in vain to find the word. The next day, the word had not been found yet.\nThis student observed that the principal has a pattern in the features for the wanted words: \n\n- The word should have **n** vowels, may be repeated, for example: in \"engineering\", n = 5.\n\n- The word should have **m** consonants, may be repeated also: in \"engineering\", m = 6.\n\n- The word should not have some forbidden letters (in an array), forbid_letters\n\nYou will be provided with a list of words, WORD_LIST(python/crystal), wordList(javascript), wordList (haskell), $word_list(ruby), and you have to create the function, ```wanted_words()```, that receives the three arguments in the order given above, ```wanted_words(n, m, forbid_list)```and output an array with the word or an array, having the words in the order given in the pre-loaded list, in the case of two or more words were found.\n\nLet's see some cases:\n\n```python\nwanted_words(1, 7, [\"m\", \"y\"]) == [\"strength\"]\nwanted_words(3, 7, [\"m\", \"y\"]) == ['afterwards', 'background', 'photograph', 'successful', 'understand']\n```\n\nFor cases where no words are found the function will output an empty array.\n\n```python\nwanted_words(3, 7, [\"a\", \"s\" , \"m\", \"y\"]) == []\n```\n\nHelp our student to win this and the next challenges of the school. He needs to sure about a suspect that he has. That many times there are no solutions for what the principal is asking for.\nAll words have its letters in lowercase format.\nEnjoy it!\n-/\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "vc-preamble": "def isVowel (c : Char) : Bool :=\n  c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'\n\ndef WORD_LIST : List String :=\n  [\"strength\", \"afterwards\", \"background\", \"photograph\", \"successful\", \"understand\"]", "vc-helpers": "", "vc-definitions": "def wanted_words (vowel_count : Nat) (consonant_count : Nat) (forbidden : List Char) : List String :=\n  sorry", "vc-theorems": "theorem result_are_strings (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f → w.length ≥ 0\n  :=\nsorry\n\ntheorem exact_vowel_count (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  (List.filter isVowel w.data).length = v\n  :=\nsorry\n\ntheorem exact_total_length (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  w.length = v + c\n  :=\nsorry\n\ntheorem no_forbidden_chars (v c : Nat) (f : List Char) :\n  ∀ (w : String), w ∈ wanted_words v c f →\n  ∀ (x : Char), x ∈ f → ¬(x ∈ w.data)\n  :=\nsorry", "vc-postamble": ""}
