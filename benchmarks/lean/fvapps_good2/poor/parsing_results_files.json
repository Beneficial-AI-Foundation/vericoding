{
  "fvapps_000000.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n : Nat) (words : List String) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_structure (n : Nat) (words : List String) :\n  let result := solve n words\n  (result = [-1] \u2228\n   (result.length \u2265 1 \u2227\n    \u2200 x \u2208 result, \u2203 i : Int, x = i \u2227\n    let count := result[0]!\n    result.length = count + 1 \u2227\n    \u2200 i \u2208 result.tail, 1 \u2264 i \u2227 i \u2264 n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_minimal_flips (n : Nat) (words : List String) :\n  let result := solve n words\n  result \u2260 [-1] \u2192\n  let zeros_to_ones := (words.filter (\u03bb w => w.front = '0' \u2227 w.back = '1')).length\n  let ones_to_zeros := (words.filter (\u03bb w => w.front = '1' \u2227 w.back = '0')).length\n  let min_flips := (abs (zeros_to_ones - ones_to_zeros)) / 2\n  result[0]! = min_flips :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3]\n-/\n#guard_msgs in\n#eval solve 4 [\"0001\", \"1000\", \"0011\", \"0111\"]\n\n/-\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve 3 [\"010\", \"101\", \"0\"]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 2 [\"00000\", \"00001\"]"
      }
    ]
  },
  "fvapps_000001.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_max_diagonal_moves (n m k : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 0 then n else -n"
      },
      {
        "type": "cond",
        "string": "theorem result_bound (n m k : Int) (h: -1000 <= n \u2227 n <= 1000) (h2: -1000 <= m \u2227 m <= 1000) (h3: 0 <= k \u2227 k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  r = -1 \u2228 r \u2264 k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_parity (n m k : Int) (h: -1000 <= n \u2227 n <= 1000) (h2: -1000 <= m \u2227 m <= 1000) (h3: 0 <= k \u2227 k <= 2000) :\n  let r := solve_max_diagonal_moves n m k\n  let max_dist := max (abs n) (abs m)\n  r \u2260 -1 \u2192 (r % 2 = max_dist % 2 \u2228 r % 2 = (max_dist - 1) % 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem insufficient_moves (n : Int) (h: 1 <= n \u2227 n <= 1000) :\n  let k := abs n - 1\n  solve_max_diagonal_moves n n k = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem symmetry (n m : Int) (h: -1000 <= n \u2227 n <= 1000) (h2: -1000 <= m \u2227 m <= 1000) :\n  let k := max (abs n) (abs m) * 2\n  let r1 := solve_max_diagonal_moves n m k\n  let r2 := solve_max_diagonal_moves (-n) m k\n  let r3 := solve_max_diagonal_moves n (-m) k\n  let r4 := solve_max_diagonal_moves (-n) (-m) k\n  r1 = r2 \u2227 r2 = r3 \u2227 r3 = r4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 2 2 3\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 4 3 7\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_diagonal_moves 10 1 9"
      }
    ]
  },
  "fvapps_000003.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_water_difference (n : Nat) (k : Nat) (barrels : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to sum a list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n  | [] => 0\n  | x :: xs => x + listSum xs\n/- Helper function to sort list descending -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def sortDescending (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get maximum of non-empty list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listMaximum : List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | x :: xs => if x > listMaximum xs then x else listMaximum xs\n/- Helper function to take first n elements -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def takeFront : Nat \u2192 List Nat \u2192 List Nat\n  | 0, _ => []\n  | _, [] => []\n  | n+1, x :: xs => x :: takeFront n xs\n/- max_water_difference returns sum of k+1 largest values -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_water_diff_equals_k_plus_one_largest\n  {n k : Nat} {barrels : List Nat}\n  (h\u2081 : barrels.length = n)\n  (h\u2082 : k < n) :\n  max_water_difference n k barrels =\n    listSum (takeFront (k+1) (sortDescending barrels)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- max_water_difference result is greater than or equal to max barrel -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_water_diff_ge_max_barrel\n  {n k : Nat} {barrels : List Nat}\n  (h\u2081 : barrels.length = n)\n  (h\u2082 : k < n)\n  (h\u2083 : barrels \u2260 []) :\n  max_water_difference n k barrels \u2265 listMaximum barrels :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- max_water_difference result is less than or equal to sum of all barrels -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_water_diff_le_total_sum\n  {n k : Nat} {barrels : List Nat}\n  (h\u2081 : barrels.length = n)\n  (h\u2082 : k < n) :\n  max_water_difference n k barrels \u2264 listSum barrels :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- max_water_difference does not modify input list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_water_diff_preserves_input\n  {n k : Nat} {barrels : List Nat}\n  (h\u2081 : barrels.length = n)\n  (h\u2082 : k < n) :\n  let original := barrels\n  let _ := max_water_difference n k barrels\n  barrels = original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 10\n-/\n#guard_msgs in\n#eval max_water_difference 4 1 [5, 5, 5, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_water_difference 3 2 [0, 0, 0]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval max_water_difference 5 2 [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_000007.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Heap := List Int"
      },
      {
        "type": "sig",
        "string": "def ins (l : Heap) (x : Int) : Heap :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def pop (l : Heap) : Int \u00d7 Heap :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The heap maintains the min-heap property after insertions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem heap_maintains_min_property {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  \u2200 i, 2 \u2264 i \u2192 i < h'.length \u2192\n    match h'.get? i, h'.get? (i/2) with\n    | some vi, some vp => vi \u2265 vp\n    | _, _ => True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- The heap extracts elements in sorted order -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem heap_gives_sorted_output {h : Heap} (xs : List Int) :\n  let h' := xs.foldl (fun acc x => ins acc x) h\n  let rec extract (h : Heap) (n : Nat) : List Int :=\n    match n with\n    | 0 => []\n    | n+1 => match pop h with\n      | (x, h') => x :: extract h' n\n  \u2200 i j xi xj, i < j \u2192 j < (extract h' h'.length).length \u2192\n    (extract h' h'.length).get? i = some xi \u2192\n    (extract h' h'.length).get? j = some xj \u2192\n    xi \u2264 xj :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Single value insertion and extraction works correctly -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem heap_single_value (x : Int) :\n  let h := ins [] x\n  pop h = (x, []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_election 3 [[1, 5], [2, 10], [2, 8]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_election 7 [[0, 1], [3, 1], [1, 1], [6, 1], [1, 1], [4, 1], [4, 1]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_election 6 [[2, 6], [2, 3], [2, 8], [2, 7], [4, 4], [5, 5]]"
      }
    ]
  },
  "fvapps_000009.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_alice_score (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sortByLengthDesc (ls : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def getAlternateSum (ls : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_not_exceed_input_length\n  (s : String) :\n  count_alice_score s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_nonnegative\n  (s : String) :\n  count_alice_score s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_or_zeros_returns_zero\n  (s : String) :\n  (s.isEmpty \u2228 s.all (\u00b7 = '0')) \u2192 count_alice_score s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_full_score\n  (s : String) :\n  s.all (\u00b7 = '1') \u2192\n  s.length > 0 \u2192\n  count_alice_score s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_alice_score \"01111001\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_alice_score \"111111\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_alice_score \"101010101\""
      }
    ]
  },
  "fvapps_000011.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_grid_area (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def min_width_height_from_path (s : String) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_grid_area_positive (s : String) :\n  min_grid_area s > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_grid_area_nonempty (s : String) (h : s.length > 0) :\n  min_grid_area s \u2265 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_grid_area_empty :\n  min_grid_area \"\" = 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_grid_area_single_char (c : Char) (h : c = 'W' \u2228 c = 'A' \u2228 c = 'S' \u2228 c = 'D') :\n  min_grid_area (String.mk [c]) = 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_grid_area_bounds (s : String) :\n  let (w, h) := min_width_height_from_path s\n  min_grid_area s \u2265 min (w * h) 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval min_grid_area \"DSAWWAW\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_grid_area \"D\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_grid_area \"WA\""
      }
    ]
  },
  "fvapps_000019.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs"
      },
      {
        "type": "sig",
        "string": "def listToFinset (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  l.eraseDups"
      },
      {
        "type": "sig",
        "string": "def windowsOfSize (l : List Nat) (size : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def min_subscriptions (n k d : Nat) (shows : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subscriptions_output_bounds\n  (shows : List Nat)\n  (h1 : shows \u2260 [])\n  (h2 : \u2200 x \u2208 shows, 1 \u2264 x \u2227 x \u2264 100) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min n (maximum shows)\n  let result := min_subscriptions n k d shows\n  1 \u2264 result \u2227 result \u2264 (listToFinset shows).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subscriptions_window_size_one\n  (shows : List Nat)\n  (h1 : shows \u2260 [])\n  (h2 : \u2200 x \u2208 shows, 1 \u2264 x) :\n  let n := shows.length\n  let k := maximum shows\n  min_subscriptions n k 1 shows = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subscriptions_window_size_equals_length\n  (shows : List Nat)\n  (k : Nat)\n  (h1 : shows \u2260 [])\n  (h2 : \u2200 x \u2208 shows, 1 \u2264 x)\n  (h3 : 1 \u2264 k) :\n  let n := shows.length\n  min_subscriptions n k n shows = (listToFinset shows).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subscriptions_repeated_elements\n  (shows : List Nat)\n  (h1 : shows \u2260 [])\n  (h2 : \u2200 x \u2208 shows, 1 \u2264 x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := n\n  min_subscriptions n k d shows = min_subscriptions (2*n) k d (shows ++ shows) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subscriptions_sliding_window\n  (shows : List Nat)\n  (window_size : Nat)\n  (h1 : shows.length \u2265 2)\n  (h2 : window_size \u2265 2)\n  (h3 : \u2200 x \u2208 shows, 1 \u2264 x) :\n  let n := shows.length\n  let k := maximum shows\n  let d := min window_size n\n  let result := min_subscriptions n k d shows\n  let windows := windowsOfSize shows d\n  let min_unique := (windows.map (fun w => (listToFinset w).length)).foldl Nat.min n\n  result = min_unique :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subscriptions 5 2 2 [1, 2, 1, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_subscriptions 9 3 3 [3, 3, 3, 2, 2, 2, 1, 1, 1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_subscriptions 4 10 4 [10, 8, 6, 4]"
      }
    ]
  },
  "fvapps_000022.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calc_seq (a k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasZeroDigit (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_seq_basic_properties {a k : Nat} (ha : a > 0) (hk : k > 0) :\n  let result := calc_seq a k\n  -- Result is always non-negative\n  result \u2265 0 \u2227\n  -- k=1 returns original number\n  calc_seq a 1 = a \u2227\n  -- k>1 implies result >= input\n  (k > 1 \u2192 result \u2265 a) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval calc_seq 1 4\n\n/-\ninfo: 487\n-/\n#guard_msgs in\n#eval calc_seq 487 1\n\n/-\ninfo: 628\n-/\n#guard_msgs in\n#eval calc_seq 487 7"
      }
    ]
  },
  "fvapps_000030.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_string_alternation (n : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Main theorem combining several properties of solve_string_alternation:\n  1. Output is non-negative\n  2. Output is less than string length\n  3. Output relates to number of adjacent duplicates\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_string_alternation_properties (s : String) (n : Nat)\n  (h1 : s.length = n) (h2 : n > 0) (h3 : \u2200c \u2208 s.data, c = '0' \u2228 c = '1') :\n  let result := solve_string_alternation n s\n  let adjacent_same := (List.zip s.data s.data.tail).filter (fun p => p.1 = p.2) |>.length\n  (result \u2265 0) \u2227\n  (result < n) \u2227\n  (result = (adjacent_same + adjacent_same % 2) / 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Perfectly alternating strings require no operations -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_string_alternation_perfect_alt (n : Nat) (h : n \u2265 2) :\n  let s := String.mk (List.map (fun i => if i % 2 = 0 then '0' else '1') (List.range n))\n  solve_string_alternation n s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For strings of all same characters, result depends on length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_string_alternation_all_same (n : Nat) (h : n > 0) :\n  let s := String.mk (List.replicate n '0')\n  solve_string_alternation n s = ((n-1) + (n-1) % 2) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_string_alternation 2 \"10\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_string_alternation 4 \"0110\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_string_alternation 8 \"11101000\""
      }
    ]
  },
  "fvapps_000038.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_card_game (n k1 k2 : Nat) (arr1 arr2 : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem card_game_returns_bool (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = true \u2228\n  solve_card_game n k1 k2 arr1 arr2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem card_game_compares_maxes (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : k1 > 0) (h2 : k2 > 0) (h3 : arr1.length > 0) (h4 : arr2.length > 0) :\n  solve_card_game n k1 k2 arr1 arr2 = (maximum arr1 > maximum arr2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_lists_error (n : Nat) :\n  \u2200 (arr1 arr2 : List Int),\n  arr1.length = 0 \u2192 arr2.length = 0 \u2192\n  solve_card_game n 0 0 arr1 arr2 = default :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_maxes_false (n k1 k2 : Nat) (arr1 arr2 : List Int)\n  (h1 : arr1.length > 0) (h2 : arr2.length > 0)\n  (h3 : maximum arr2 = maximum arr1) :\n  solve_card_game n arr1.length arr2.length arr1 arr2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 2 1 1 [2] [1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve_card_game 5 2 3 [2, 3] [1, 4, 5]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve_card_game 3 1 2 [3] [1, 2]"
      }
    ]
  },
  "fvapps_000043.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_dishes (n : Nat) (a : List Nat) (b : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl Nat.max 0"
      },
      {
        "type": "cond",
        "string": "theorem solve_dishes_leq_max_cook_time (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n \u2265 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : \u2200 x \u2208 a, x \u2265 1) (h5 : \u2200 x \u2208 b, x \u2265 1) :\n    solve_dishes n a b \u2264 list_maximum a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_dishes_non_negative (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n \u2265 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : \u2200 x \u2208 a, x \u2265 1) (h5 : \u2200 x \u2208 b, x \u2265 1) :\n    solve_dishes n a b \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_dishes_valid_solution (n : Nat) (a : List Nat) (b : List Nat)\n    (h1 : n \u2265 1) (h2 : a.length = n) (h3 : b.length = n) (h4 : \u2200 x \u2208 a, x \u2265 1) (h5 : \u2200 x \u2208 b, x \u2265 1) :\n    let result := solve_dishes n a b\n    let remaining := result - (List.range n).foldl (\u03bb acc i =>\n      if a[i]! > result then acc + b[i]! else acc) 0\n    remaining \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_cook_and_wait_times (n : Nat) (times : List Nat)\n    (h1 : n \u2265 1) (h2 : times.length = n) (h3 : \u2200 x \u2208 times, x \u2265 1) :\n    solve_dishes n times times \u2264 list_maximum times :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_dishes 4 [3, 7, 4, 5] [2, 1, 2, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_dishes 4 [1, 2, 3, 4] [3, 3, 3, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dishes 2 [1, 2] [10, 10]"
      }
    ]
  },
  "fvapps_000046.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_rock_paper_scissors (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def beats (move1 move2 : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getMostFrequentMove (s : String) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_preservation (s : String) :\n  s.length > 0 \u2192 (solve_rock_paper_scissors s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_moves (s : String) (i : String.Pos) :\n  s.length > 0 \u2192\n  (solve_rock_paper_scissors s).get i = 'R' \u2228\n  (solve_rock_paper_scissors s).get i = 'P' \u2228\n  (solve_rock_paper_scissors s).get i = 'S' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_response (s : String) :\n  s.length > 0 \u2192 \u2200 i j : String.Pos,\n  (solve_rock_paper_scissors s).get i = (solve_rock_paper_scissors s).get j :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem beats_most_frequent (s : String) (h: s.length > 0):\n  let mostFrequent := getMostFrequentMove s\n  let firstChar := (solve_rock_paper_scissors s).front\n  beats firstChar mostFrequent :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: len(test_input)\n-/\n#guard_msgs in\n#eval len solve_rock_paper_scissors(test_input)"
      }
    ]
  },
  "fvapps_000053.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_sequence (n : Nat) (comp_str : String) : (List Nat \u00d7 List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def verifySequenceMatchesComparisons (seq : List Nat) (comps : List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_length_matches_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 \u2192\n  min_seq.length = n \u2227 max_seq.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequences_follow_comparisons\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 \u2192\n  verifySequenceMatchesComparisons min_seq (comp_str.data) \u2227\n  verifySequenceMatchesComparisons max_seq (comp_str.data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequences_use_consecutive_integers\n  {n : Nat} {comp_str : String} :\n  let (min_seq, max_seq) := solve_sequence n comp_str\n  n = comp_str.length + 1 \u2192\n  \u2200 k, k \u2264 n \u2192 (k \u2208 min_seq \u2194 k \u2264 n \u2227 k > 0) \u2227\n               (k \u2208 max_seq \u2194 k \u2264 n \u2227 k > 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_value_edge_case\n  {n : Nat} :\n  n = 1 \u2192\n  solve_sequence n \"\" = ([1], [1]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set min3\n\n/-\ninfo: set(range(1, 6))\n-/\n#guard_msgs in\n#eval set max3"
      }
    ]
  },
  "fvapps_000059.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_array_differences (n : Nat) (arr : List Int) : Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Properties for all-negative-ones case -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem all_neg_ones_result {n : Nat} {arr : List Int}\n  (h : \u2200 x \u2208 arr, x = -1) :\n  solve_array_differences n arr = (0, 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Main property about adjacent differences being bounded by result -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem adjacent_differences_bounded {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  \u2200 i < arr.length - 1,\n    arr[i]! \u2260 -1 \u2192 arr[i+1]! \u2260 -1 \u2192\n    (arr[i]! - arr[i+1]!).natAbs \u2264 ans :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Property about the x value working for -1 positions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem x_value_maintains_bound {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  \u2200 i < arr.length,\n    arr[i]! = -1 \u2192\n    (i > 0 \u2192 arr[i-1]! \u2260 -1 \u2192 (arr[i-1]! - x).natAbs \u2264 ans) \u2227\n    (i < arr.length - 1 \u2192 arr[i+1]! \u2260 -1 \u2192 (x - arr[i+1]!).natAbs \u2264 ans) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Property about result types and non-negativity -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_properties {n : Nat} {arr : List Int} :\n  let (ans, x) := solve_array_differences n arr\n  ans \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: (1, 11)\n-/\n#guard_msgs in\n#eval solve_array_differences 5 [-1, 10, -1, 12, -1]\n\n/-\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval solve_array_differences 2 [-1, -1]\n\n/-\ninfo: (1, 2)\n-/\n#guard_msgs in\n#eval solve_array_differences 4 [1, -1, 3, -1]"
      }
    ]
  },
  "fvapps_000065.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.sorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_gift_distribution (n : Nat) (a b : List Int) : List Int \u00d7 List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gift_distribution_output {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  (necklace.sorted = true) \u2227 (bracelet.sorted = true) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gift_distribution_nonempty {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace.length > 0 \u2227 bracelet.length > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gift_distribution_preserves_elements {n : Nat} {a b : List Int} :\n  let (necklace, bracelet) := solve_gift_distribution n a b\n  necklace = a.sort \u2227 bracelet = b.sort := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000066.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_string_swaps (n: Nat) (s t: String) : String \u00d7 List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def apply_swaps (s t: String) (swaps: List (Nat \u00d7 Nat)) : String \u00d7 String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_chars (s: String) : Char \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "constr",
        "string": "inductive Even : Nat \u2192 Prop where\n  | zero : Even 0\n  | plus_two : (n : Nat) \u2192 Even n \u2192 Even (n + 2)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem identical_strings_always_possible\n  (n: Nat) (s: String) (h1: n > 0) (h2: n \u2264 100) :\n  let res := solve_string_swaps n s s\n  res.1 = \"Yes\" \u2227 res.2.length \u2264 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n \u2264 100) :\n  let res := solve_string_swaps n s t\n  res.1 = \"Yes\" \u2192\n    (res.2.length \u2264 2 * n \u2227\n     \u2203 final_s final_t,\n       (apply_swaps s t res.2) = (final_s, final_t) \u2227\n       final_s = final_t) \u2227\n  res.1 = \"No\" \u2192\n    res.2 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem character_count_invariant\n  (n: Nat) (s t: String) (h1: n > 0) (h2: n \u2264 100) :\n  let res := solve_string_swaps n s t\n  let char_counts := count_chars (s ++ t)\n  res.1 = \"Yes\" \u2194 \u2200 c, Even (char_counts c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000069.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_replacements (n k : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def max_char_count (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_replacements_nonneg (n k : Nat) (s : String) :\n  min_replacements n k s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_replacements_bounded (n k : Nat) (s : String) :\n  min_replacements n k s \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_string_zero (n k : Nat) (s : String) :\n  s = String.mk (List.replicate n 'a') \u2192\n  min_replacements n (min k n) s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_replacements_type (n k : Nat) (s : String) :\n  min_replacements n k s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_replacements 6 2 \"abaaba\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_replacements 6 3 \"abaaba\"\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval min_replacements 36 9 \"hippopotomonstrosesquippedaliophobia\""
      }
    ]
  },
  "fvapps_000070.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_array_zeroes (n : Nat) (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => h + sum t"
      },
      {
        "type": "cond",
        "string": "theorem solve_array_zeroes_nonnegative (n : Nat) (arr : List Int) :\n  solve_array_zeroes n arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_array_zeroes_all_positives (n : Nat) (arr : List Int) :\n  (List.all arr (fun x => x \u2265 0)) \u2192 solve_array_zeroes n arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 5, -3, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_array_zeroes 2 [1, -1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_array_zeroes 4 [-3, 2, -3, 4]"
      }
    ]
  },
  "fvapps_000090.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def intList (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidPermutation (n : Nat) (result : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def satisfiesQConstraints (result : List Int) (q : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solvePermutationCode (n : Nat) (q : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_property (n : Nat) :\n  n > 0 \u2192 n \u2264 10 \u2192\n  let q := [Int.ofNat n]\n  let result := solvePermutationCode 1 q\n  result = [Int.ofNat n] \u2228 result = [-1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strictly_increasing_property (n : Nat) :\n  n > 0 \u2192 n \u2264 10 \u2192\n  let q := intList n\n  let result := solvePermutationCode n q\n  isValidPermutation n result = true \u2227\n  satisfiesQConstraints result q = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 4, 5, 2]\n-/\n#guard_msgs in\n#eval solve_permutation_code 5 [1, 3, 4, 5, 5]\n\n/-\ninfo: [-1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 4 [1, 1, 3, 4]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_permutation_code 1 [1]"
      }
    ]
  },
  "fvapps_000098.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def clean_binary_string (n : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_of_zeros (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_of_ones (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_preserves_all_zeros (n : Nat) :\n  clean_binary_string n (string_of_zeros n) = string_of_zeros n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_preserves_all_ones (n : Nat) :\n  clean_binary_string n (string_of_ones n) = string_of_ones n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_preserves_monotonic_transitions (n : Nat) (s : String) :\n  s = \"0001\" \u2228 s = \"0011\" \u2228 s = \"0111\" \u2192 clean_binary_string n s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_shortens_alternating (n : Nat) :\n  clean_binary_string 4 \"0101\" = \"001\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_shortens_complex_pattern (n : Nat) :\n  clean_binary_string 8 \"11001101\" = \"01\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_reduces_to_minimal (n : Nat) :\n  clean_binary_string 6 \"100110\" = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '0001111111'\n-/\n#guard_msgs in\n#eval clean_binary_string 10 \"0001111111\"\n\n/-\ninfo: '001'\n-/\n#guard_msgs in\n#eval clean_binary_string 4 \"0101\"\n\n/-\ninfo: '01'\n-/\n#guard_msgs in\n#eval clean_binary_string 8 \"11001101\""
      }
    ]
  },
  "fvapps_000102.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_game (n m : Nat) (grid : List (List Nat)) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countEmptyRows (grid : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (grid.filter (fun row => row.all (fun x => x = 0))).length"
      },
      {
        "type": "sig",
        "string": "def countEmptyCols (n m : Nat) (grid : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let isEmptyCol (j : Nat) := (List.range n).all (fun i =>\n    match grid.get? i with\n    | none => true\n    | some row => match row.get? j with\n      | none => true\n      | some x => x = 0)\n  (List.range m).filter isEmptyCol |>.length"
      },
      {
        "type": "cond",
        "string": "theorem solve_game_returns_valid_winner (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : \u2200 row \u2208 grid, row.length = m)\n  (h5 : \u2200 row \u2208 grid, \u2200 x \u2208 row, x = 0 \u2228 x = 1) :\n  solve_game n m grid = \"Ashish\" \u2228 solve_game n m grid = \"Vivek\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem winner_depends_on_empty_lines (n m : Nat) (grid : List (List Nat))\n  (h1 : n > 0) (h2 : m > 0) (h3 : grid.length = n)\n  (h4 : \u2200 row \u2208 grid, row.length = m)\n  (h5 : \u2200 row \u2208 grid, \u2200 x \u2208 row, x = 0 \u2228 x = 1) :\n  let empty_rows := countEmptyRows grid\n  let empty_cols := countEmptyCols n m grid\n  let min_empty := min empty_rows empty_cols\n  solve_game n m grid = \"Ashish\" \u2194 min_empty % 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_grid (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 0)\n  solve_game n m grid = (if min n m % 2 = 1 then \"Ashish\" else \"Vivek\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_empty_lines (n m : Nat) (h1 : n > 0) (h2 : m > 0) :\n  let grid := List.replicate n (List.replicate m 1)\n  solve_game n m grid = \"Vivek\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 0]]\n\n/-\ninfo: 'Ashish'\n-/\n#guard_msgs in\n#eval solve_game 2 2 [[0, 0], [0, 1]]\n\n/-\ninfo: 'Vivek'\n-/\n#guard_msgs in\n#eval solve_game 2 3 [[1, 0, 1], [1, 1, 0]]"
      }
    ]
  },
  "fvapps_000104.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_magic_candies (n : Nat) (k : Nat) (candies : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_minimum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_magic_candies_minimum_case\n  (k : Nat)\n  (h1 : k \u2265 1) (h2 : k \u2264 1000) :\n  solve_magic_candies 2 k [1, 1] = k - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_magic_candies 2 2 [1, 1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 5 [1, 2, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_magic_candies 3 7 [3, 2, 2]"
      }
    ]
  },
  "fvapps_000107.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPowerOfTwo (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def min_divisions (n : Nat) (boxes : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_divisions_properties (n : Nat) (boxes : List Nat)\n  (h1 : n \u2265 1) (h2 : \u2200 x \u2208 boxes, isPowerOfTwo x = true) :\n  let result := min_divisions n boxes;\n  (result \u2260 -1 \u2192\n    (result \u2265 0 \u2227\n     sum boxes \u2265 n)) \u2227\n  (sum boxes < n \u2192\n    result = -1) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_divisions_with_sum (boxes : List Nat)\n  (h : \u2200 x \u2208 boxes, isPowerOfTwo x = true) :\n  let n := sum boxes;\n  let result := min_divisions n boxes;\n  result = 0 \u2228 result = -1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_divisions *test1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_divisions *test2\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_divisions *test3"
      }
    ]
  },
  "fvapps_000108.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_peaks (window : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_door_peaks (n k : Nat) (arr : List Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem peaks_atleast_one {n k : Nat} {arr : List Nat}\n  (h1 : n \u2265 3)\n  (h2 : k \u2265 3)\n  (h3 : k \u2264 n)\n  (h4 : arr.length = n) :\n  let (peaks, _) := solve_door_peaks n k arr\n  peaks \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem position_in_range {n k : Nat} {arr : List Nat}\n  (h1 : n \u2265 3)\n  (h2 : k \u2265 3)\n  (h3 : k \u2264 n)\n  (h4 : arr.length = n) :\n  let (_, pos) := solve_door_peaks n k arr\n  1 \u2264 pos \u2227 pos \u2264 n - k + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem peaks_match_window {n k : Nat} {arr : List Nat}\n  (h1 : n \u2265 3)\n  (h2 : k \u2265 3)\n  (h3 : k \u2264 n)\n  (h4 : arr.length = n) :\n  let (peaks, pos) := solve_door_peaks n k arr\n  let window := arr.take k\n  count_peaks window = peaks - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 8 6 [1, 2, 4, 1, 2, 4, 1, 2]\n\n/-\ninfo: (2, 2)\n-/\n#guard_msgs in\n#eval solve_door_peaks 5 3 [3, 2, 3, 2, 1]\n\n/-\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_door_peaks 10 4 [4, 3, 4, 3, 2, 3, 2, 1, 0, 1]"
      }
    ]
  },
  "fvapps_000110.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_polygon (grid : List (List Nat)) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isConvex (polygon : List (Nat \u00d7 Nat)) : Bool := sorry\n\ndef replaceNth {\u03b1 : Type} (xs : List \u03b1) (n : Nat) (v : \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  match n, xs with\n  | _, [] => []\n  | 0, x::xs => v::xs\n  | n+1, x::xs => x :: replaceNth xs n v"
      },
      {
        "type": "cond",
        "string": "theorem square_shape_valid (size : Nat) (h1 : size \u2265 7) (h2 : size \u2264 20) :\n  let grid := List.replicate size (List.replicate size 0)\n  let mid := size / 2\n  let centerRow := replaceNth (List.replicate size 0) mid 2\n  let modifiedGrid := replaceNth grid mid centerRow\n  let polygon := solve_polygon modifiedGrid\n  polygon.length = 4 \u2227 isConvex polygon :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [(2, 3), (2, 4), (6, 6), (5, 2)]\n-/\n#guard_msgs in\n#eval solve_polygon [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 2, 2, 1, 0], [0, 1, 2, 3, 4, 2, 0, 0], [0, 2, 4, 4, 4, 2, 0, 0], [0, 1, 2, 2, 3, 2, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]\n\n/-\ninfo: [(2, 2), (2, 3), (3, 3), (3, 2)]\n-/\n#guard_msgs in\n#eval solve_polygon [[0, 0, 0, 0, 0], [0, 1, 2, 1, 0], [0, 2, 4, 2, 0], [0, 1, 2, 1, 0], [0, 0, 0, 0, 0]]\n\n/-\ninfo: [(2, 5), (4, 5), (4, 2)]\n-/\n#guard_msgs in\n#eval solve_polygon [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 2, 1, 0, 0], [0, 1, 3, 4, 2, 0, 0], [0, 0, 1, 3, 2, 0, 0], [0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]"
      }
    ]
  },
  "fvapps_000114.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_xor_sum (n : Nat) (arr : List Nat) : List Nat := sorry\n\ndef xor_fold (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h::t => t.foldl Nat.xor h"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h::t => h + list_sum t"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_sum_length {n : Nat} {arr : List Nat} :\n  arr \u2260 [] \u2192\n  let result := solve_xor_sum n arr\n  List.length result = 0 \u2228 List.length result = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_sum_verifies {n : Nat} {arr : List Nat} :\n  arr \u2260 [] \u2192\n  let result := solve_xor_sum n arr\n  let full_arr := arr ++ result\n  list_sum full_arr = 2 * xor_fold full_arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_sum_bounds {n : Nat} {arr : List Nat} :\n  arr \u2260 [] \u2192\n  let result := solve_xor_sum n arr\n  let total := list_sum arr\n  \u2200 x \u2208 result, x \u2265 0 \u2227 x \u2264 2 * total :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval solve_xor_sum 4 [1, 2, 3, 6]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval len solve_xor_sum(1, [8])\n\n/-\ninfo: 2 * (arr[0] ^ arr[1] ^ arr[2])\n-/\n#guard_msgs in\n#eval sum [8] + result\n\n/-\ninfo: 2 * xor\n-/\n#guard_msgs in\n#eval sum [1, 1] + result"
      }
    ]
  },
  "fvapps_000115.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_naruto_seals (n m : Nat) (rows cols : List (List Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_matrix (result : List (List Nat)) (n m : Nat) (rows cols : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def makeMatrix (n m : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dimensions_check (n m : Nat) (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  List.length result = n \u2227 \u2200 row \u2208 result, List.length row = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutations_check (n m : Nat) (h1 : 0 < n) (h2 : n \u2264 5) (h3 : 0 < m) (h4 : m \u2264 5) :\n  let matrix := makeMatrix n m\n  let result := solve_naruto_seals n m matrix matrix\n  is_valid_matrix result n m matrix matrix = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_cell_check :\n  solve_naruto_seals 1 1 [[1]] [[1]] = [[1]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000116.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_teams (n: Nat) (x: Nat) (skills: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sort (l: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_bounds\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: \u2200 s \u2208 skills, s \u2265 1 \u2227 s \u2264 100) :\n  let result := max_teams n x skills\n  0 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_sort_invariant\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h: skills.length = n) :\n  max_teams n x skills = max_teams n x (list_sort skills) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_impossible_target\n  (n: Nat) (x: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: x > (list_sum skills) * n) :\n  max_teams n x skills = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_min_requirement\n  (n: Nat) (skills: List Nat)\n  (h1: skills.length = n)\n  (h2: \u2200 s \u2208 skills, s \u2265 1) :\n  max_teams n 1 skills = (List.filter (\u03bb s => s \u2265 1) skills).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_empty\n  (x: Nat) :\n  max_teams 0 x [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_teams_uniform_skills\n  (n: Nat) (skill: Nat)\n  (h1: skill \u2265 1)\n  (h2: skill \u2264 100) :\n  max_teams n skill (List.replicate n skill) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_teams 5 10 [7, 11, 2, 9, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_teams 4 8 [2, 4, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_teams 4 11 [1, 3, 3, 7]"
      }
    ]
  },
  "fvapps_000119.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_min_skill_diff (n: Nat) (arr: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (xs: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (xs: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x: Nat) (y: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "if x \u2265 y then x - y else y - x"
      },
      {
        "type": "sig",
        "string": "def list_sort (xs: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_differences (xs: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_skill_diff_properties {n: Nat} {arr: List Nat} (h1: n < arr.length) (h2: 1 \u2264 n) (h3: arr.length \u2265 2)\n(h4: \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 1000) :\n  let result := solve_min_skill_diff n arr\n  result \u2265 0 \u2227 result \u2264 list_max arr - list_min arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_values_property {arr: List Nat} (h1: arr.length \u2265 2)\n(h2: \u2200 x \u2208 arr, x = 1) :\n  let n := arr.length / 2\n  solve_min_skill_diff n arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_sequence_property {n: Nat} {arr: List Nat}\n(h1: n < arr.length) (h2: 1 \u2264 n) (h3: 2 \u2264 arr.length) (h4: arr.length \u2264 20)\n(h5: \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 100) :\n  let result := solve_min_skill_diff n arr\n  let sorted := list_sort arr\n  let diffs := list_differences sorted\n  result \u2208 diffs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 1 [1, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 3 [6, 5, 4, 1, 2, 3]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_skill_diff 5 [13, 4, 20, 13, 2, 5, 8, 3, 17, 16]"
      }
    ]
  },
  "fvapps_000120.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def take (n : Nat) (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def drop (n : Nat) (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def map (f : Int \u2192 Int) (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxScore (cards : List Int) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxScore_invalid_inputs_empty\n  (k : Nat) :\n  maxScore [] k = 0 := -- should fail\n  sorry\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval maxScore [1, 2, 3, 4, 5, 6, 1] 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maxScore [2, 2, 2] 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval maxScore [1, 1000, 1] 1"
      }
    ]
  },
  "fvapps_000123.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def super_pow (base : Int) (exponent_digits : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pow_mod (base exp m : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem super_pow_range (base : Int) (exp_digits : List Int)\n  (h1 : base > 0)\n  (h2 : exp_digits.length > 0)\n  (h3 : exp_digits.length \u2264 10)\n  (h4 : \u2200 d \u2208 exp_digits, 0 \u2264 d \u2227 d \u2264 9) :\n  let result := super_pow base exp_digits\n  0 \u2264 result \u2227 result < 1337 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem super_pow_small_exp (base : Int) (exp_digit : Int)\n  (h1 : base > 0)\n  (h2 : 0 \u2264 exp_digit)\n  (h3 : exp_digit < 5) :\n  super_pow base [exp_digit] = pow_mod base exp_digit 1337 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem super_pow_zero (base : Int)\n  (h : base > 0) :\n  super_pow base [0] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem super_pow_one (base : Int) (exp_digits : List Int)\n  (h1 : exp_digits.length > 0)\n  (h2 : exp_digits.length \u2264 5)\n  (h3 : \u2200 d \u2208 exp_digits, 0 \u2264 d \u2227 d \u2264 9) :\n  super_pow 1 exp_digits = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval super_pow 2 [3]\n\n/-\ninfo: 1024\n-/\n#guard_msgs in\n#eval super_pow 2 [1, 0]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval super_pow 3 [2]"
      }
    ]
  },
  "fvapps_000125.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def profitable_schemes (G : Nat) (P : Nat) (group : List Nat) (profit : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n-- Basic properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem profitable_schemes_non_negative (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem profitable_schemes_mod_bound (G P : Nat) (group profit : List Nat) :\n  profitable_schemes G P group profit < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty list cases"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem profitable_schemes_empty_zero_profit (G : Nat) :\n  profitable_schemes G 0 [] [] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem profitable_schemes_empty_positive_profit (G P : Nat) :\n  P > 0 \u2192 profitable_schemes G P [] [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Scaling property"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem profitable_schemes_scaling (G P : Nat) (group profit : List Nat) :\n  group \u2260 [] \u2192\n  profit.length = group.length \u2192\n  profitable_schemes G P group profit =\n  profitable_schemes G (2 * P) group (List.map (fun p => 2 * p) profit) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval profitable_schemes 5 3 [2, 2] [2, 3]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval profitable_schemes 10 5 [2, 3, 5] [6, 7, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval profitable_schemes 1 1 [1] [1]"
      }
    ]
  },
  "fvapps_000126.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_number {n : Int} (h : -1000 \u2264 n \u2227 n \u2264 1000) :\n  calculate s!\"{n}\" = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def makeParens (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => \"\"\n  | n+1 => \"(\" ++ makeParens n"
      },
      {
        "type": "cond",
        "string": "theorem addition {a b : Int} (h : -100 \u2264 a \u2227 a \u2264 100 \u2227 -100 \u2264 b \u2227 b \u2264 100) :\n  calculate s!\"{a}+{b}\" = a + b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nested_parentheses {n : Int} (h : -50 \u2264 n \u2227 n \u2264 50) :\n  calculate s!\"{makeParens n.toNat}1{makeParens n.toNat}\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem parentheses_operations {a b : Int} (h : -50 \u2264 a \u2227 a \u2264 50 \u2227 -50 \u2264 b \u2227 b \u2264 50) :\n  calculate s!\"({a})+({b})\" = a + b \u2227\n  calculate s!\"({a})-({b})\" = a - b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_invariance (spaces : String) (h : \u2200 c \u2208 spaces.data, c = ' ') :\n  calculate \"1+2\" = calculate s!\"{spaces}1{spaces}+{spaces}2{spaces}\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calculate \"\"1 + 1\"\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calculate \"\" 2-1 + 2 \"\"\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval calculate \"\"(1+(4+5+2)-3)+(6+8)\"\""
      }
    ]
  },
  "fvapps_000128.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.repeat (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def number_of_arrays (s : String) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_valid {d : Char} {k : Nat}\n  (h1 : d \u2208 ['1', '2', '3', '4', '5', '6', '7', '8', '9'])\n  (h2 : k > 0)\n  : number_of_arrays (String.mk [d]) k = if (d.toNat - 48) \u2264 k then 1 else 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_zero_invalid {k : Nat} (h : k > 0)\n  : number_of_arrays \"0\" k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10000\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval number_of_arrays \"1000\" 10\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval number_of_arrays \"1317\" 2000"
      }
    ]
  },
  "fvapps_000131.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def balanced_string (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_equal_quarters (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_length_returns_negative {s : String} :\n  (s.length % 4 \u2260 0) \u2192 balanced_string s = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_within_bounds {s : String} :\n  balanced_string s \u2260 -1 \u2192\n  0 \u2264 balanced_string s \u2227 balanced_string s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval balanced_string \"QWER\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval balanced_string \"QQWE\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval balanced_string \"QQQW\""
      }
    ]
  },
  "fvapps_000137.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minDeletionSize (A : List (List Char)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Output is bounded between 0 and string length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_bounds (A : List (List Char)) (h : A.all (\u03bb s => s.length = A.head!.length)) :\n  let result := minDeletionSize A\n  0 \u2264 result \u2227 result \u2264 A.head!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Already sorted columns need 0 deletions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sorted_columns_zero_deletions (A : List (List Char)) (h : A.all (\u03bb s => s.length = A.head!.length)) :\n  let sorted_columns := A -- imagine this is the input with sorted columns\n  minDeletionSize sorted_columns = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Reverse sorted columns need at most string length deletions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_sorted_most_deletions (A : List (List Char)) (h\u2081 : A \u2260 []) (h\u2082 : A.all (\u03bb s => s.length = A.head!.length)) :\n  let reverse_sorted := A -- imagine this is input with reverse sorted columns\n  minDeletionSize reverse_sorted \u2264 A.head!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Identical strings need 0 deletions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem identical_strings_zero_deletions (A : List (List Char)) (s : List Char)\n    (h\u2081 : A \u2260 []) (h\u2082 : A.all (\u03bb str => str = s)) :\n  minDeletionSize A = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_deletion_size [\"ca\", \"bb\", \"ac\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_deletion_size [\"xc\", \"yb\", \"za\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_deletion_size [\"zyx\", \"wvu\", \"tsr\"]"
      }
    ]
  },
  "fvapps_000139.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numRescueBoats (people : List Nat) (limit : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMax (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rescue_boats_minimum (people : List Nat) (h : people \u2260 []) :\n  let limit := listMax people\n  numRescueBoats people limit \u2265 (people.length + 1) / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rescue_boats_maximum (people : List Nat) (h : people \u2260 []) :\n  let limit := listMax people\n  numRescueBoats people limit \u2264 people.length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rescue_boats_deterministic (people : List Nat) (h : people \u2260 []) :\n  let limit := listMax people\n  numRescueBoats people limit = numRescueBoats people limit := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_person_per_boat (weights : List Nat) (h : weights \u2260 []) :\n  let min_limit := listMin weights\n  numRescueBoats weights min_limit = weights.length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_same_result (people : List Nat) (limit : Nat)\n    (h1 : people.length \u2265 2) (h2 : \u2200 x \u2208 people, x \u2264 100) (h3 : limit \u2264 100) :\n  numRescueBoats people limit = numRescueBoats (listSort people) limit := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRescueBoats [1, 2] 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 2, 2, 1] 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numRescueBoats [3, 5, 3, 4] 5"
      }
    ]
  },
  "fvapps_000141.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def total_fruit (tree : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_fruit_bounds {tree : List Nat} (h : tree \u2260 []) :\n  1 \u2264 total_fruit tree \u2227 total_fruit tree \u2264 tree.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxSubseqLengthWithTwoTypes (tree : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_fruit_min_length {tree : List Nat} (h : tree.length \u2265 3) :\n  total_fruit tree \u2265 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval total_fruit [0, 1, 2, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval total_fruit [1, 2, 3, 2, 2]"
      }
    ]
  },
  "fvapps_000148.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def partition_disjoint (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "constr",
        "string": "axiom List.maximum' : List Int \u2192 Int"
      },
      {
        "type": "constr",
        "string": "axiom List.Sorted : List Int \u2192 Prop"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def partitioned_at (p : Nat) (nums : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  let left := (nums.take p)\n  let right := (nums.drop p)\n  let left_max := List.maximum' left\n  (\u2200 x \u2208 left, x \u2264 left_max) \u2227\n  (\u2200 x \u2208 right, x \u2265 left_max)"
      },
      {
        "type": "cond",
        "string": "theorem partition_point_valid : \u2200 nums, nums.length \u2265 2 \u2192\n  let res := partition_disjoint nums\n  1 \u2264 res \u2227 res \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem partition_left_properties : \u2200 nums, nums.length \u2265 2 \u2192\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let left_max := List.maximum' left\n  \u2200 x \u2208 left, x \u2264 left_max :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem partition_right_properties : \u2200 nums, nums.length \u2265 2 \u2192\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  \u2200 x \u2208 right, x \u2265 left_max :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_list_partitions_at_one : \u2200 nums, nums.length \u2265 2 \u2192\n  List.Sorted nums \u2192\n  partition_disjoint nums = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_smaller_elements_after_partition : \u2200 nums, nums.length \u2265 2 \u2192\n  let res := partition_disjoint nums\n  let left := nums.take res\n  let right := nums.drop res\n  let left_max := List.maximum' left\n  \u00ac\u2203 x \u2208 right, x < left_max :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [5, 0, 3, 8, 6]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval partition_disjoint [1, 1, 1, 0, 6, 12]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval partition_disjoint [3, 1, 2, 4, 5]"
      }
    ]
  },
  "fvapps_000149.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasThreeRepeated (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def strongPasswordChecker (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_non_negative (s : String) :\n  strongPasswordChecker s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_password_needs_no_changes (s : String) :\n  (s.length \u2265 6 \u2227 s.length \u2264 20 \u2227\n   s.any isLower \u2227\n   s.any isUpper \u2227\n   s.any isDigit \u2227\n   \u00achasThreeRepeated s) \u2192\n  strongPasswordChecker s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_password_minimum_changes (s : String) :\n  s.length < 6 \u2192\n  strongPasswordChecker s \u2265 6 - s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem long_password_minimum_changes (s : String) :\n  s.length > 20 \u2192\n  strongPasswordChecker s \u2265 s.length - 20 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_categories_minimum_changes (s : String) :\n  let missing := (if s.any isLower then 0 else 1) +\n                 (if s.any isUpper then 0 else 1) +\n                 (if s.any isDigit then 0 else 1)\n  strongPasswordChecker s \u2265 missing :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_chars_minimum_changes (s : String) :\n  (\u2200 c : Char, c \u2208 s.data \u2192 c = 'a') \u2192\n  s.length \u2265 3 \u2192\n  strongPasswordChecker s \u2265 s.length / 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"a\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"aA1\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval strongPasswordChecker \"1337C0d3\""
      }
    ]
  },
  "fvapps_000150.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_distance (positions : List Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def can_place_balls (distance : Nat) (sorted_pos : List Nat) (m : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_distance_bounds {positions : List Nat} {m : Nat}\n  (h1 : positions.length \u2265 2)\n  (h2 : m \u2265 2)\n  (h3 : m \u2264 positions.length)\n  (h4 : \u2200 x \u2208 positions, x \u2265 1 \u2227 x \u2264 1000000000) :\n  let result := max_distance positions m\n  result \u2265 0 \u2227\n  result \u2264 (positions[positions.length-1]! - positions[0]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_distance_placement {positions : List Nat} {m : Nat}\n  (h1 : positions.length \u2265 2)\n  (h2 : m \u2265 2)\n  (h3 : m \u2264 positions.length)\n  (h4 : \u2200 x \u2208 positions, x \u2265 1 \u2227 x \u2264 1000000000) :\n  let result := max_distance positions m\n  can_place_balls result positions m = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_distance_maximal {positions : List Nat} {m : Nat}\n  (h1 : positions.length \u2265 2)\n  (h2 : m \u2265 2)\n  (h3 : m \u2264 positions.length)\n  (h4 : \u2200 x \u2208 positions, x \u2265 1 \u2227 x \u2264 1000000000) :\n  let result := max_distance positions m\n  result < (positions[positions.length-1]! - positions[0]!) \u2192\n  can_place_balls (result + 1) positions m = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_distance_input_preservation {positions : List Nat} {m : Nat}\n  (h1 : positions.length \u2265 2)\n  (h2 : m \u2265 2)\n  (h3 : m \u2264 positions.length) :\n  positions = positions :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_distance_edge_cases :\n  max_distance [1, 1000000000] 2 = 999999999 \u2227\n  max_distance [1,2,3] 3 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 7] 3\n\n/-\ninfo: 999999999\n-/\n#guard_msgs in\n#eval max_distance [5, 4, 3, 2, 1, 1000000000] 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_distance [1, 2, 3, 4, 5, 6] 4"
      }
    ]
  },
  "fvapps_000154.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isSubsequence (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def shortestCommonSupersequence (s\u2081 s\u2082 : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scs_contains_both_strings (s\u2081 s\u2082 : String) :\n  let result := shortestCommonSupersequence s\u2081 s\u2082\n  isSubsequence s\u2081 result = true \u2227 isSubsequence s\u2082 result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scs_same_string (s : String) :\n  shortestCommonSupersequence s s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scs_length_bounds (s\u2081 s\u2082 : String) :\n  let result := shortestCommonSupersequence s\u2081 s\u2082\n  result.length \u2265 max s\u2081.length s\u2082.length \u2227\n  result.length \u2264 s\u2081.length + s\u2082.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scs_empty_string (s : String) :\n  shortestCommonSupersequence \"\" s = s \u2227\n  shortestCommonSupersequence s \"\" = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'cabac'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"abac\" \"cab\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len shortest_common_supersequence(\"abc\", \"def\")\n\n/-\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval shortest_common_supersequence \"aaaaa\" \"aa\""
      }
    ]
  },
  "fvapps_000161.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minInteger (num : String) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringToList (s : String) : List Char := s.data"
      },
      {
        "type": "sig",
        "string": "def listToString (l : List Char) : String := String.mk l\n\ndef charListOrdered (l\u2081 l\u2082 : List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l\u2081, l\u2082 with\n  | [], [] => true\n  | x::xs, y::ys => if x.val < y.val then true\n                    else if x.val = y.val then charListOrdered xs ys\n                    else false\n  | _, _ => false"
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem minInteger_length (num : String) (k : Nat) :\n  (minInteger num k).length = num.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInteger_leq_input (num : String) (k : Nat) :\n  minInteger num k \u2264 num :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInteger_zero_k (num : String) :\n  minInteger num 0 = num :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInteger_monotonic (num : String) (k\u2081 k\u2082 : Nat) :\n  k\u2081 \u2264 k\u2082 \u2192 minInteger num k\u2082 \u2264 minInteger num k\u2081 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInteger_char_count (num : String) (k : Nat) (c : Char) :\n  countChar c (minInteger num k) = countChar c num :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '1342'\n-/\n#guard_msgs in\n#eval minInteger \"4321\" 4\n\n/-\ninfo: '010'\n-/\n#guard_msgs in\n#eval minInteger \"100\" 1\n\n/-\ninfo: '36789'\n-/\n#guard_msgs in\n#eval minInteger \"36789\" 1000"
      }
    ]
  },
  "fvapps_000163.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_flips (a b c : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_ones (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitwise_or (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_flips_non_negative (a b c : Nat) :\n  min_flips a b c \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_flips_identity_left (c : Nat) :\n  min_flips c 0 c = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_flips_identity_right (c : Nat) :\n  min_flips 0 c c = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_flips 2 6 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_flips 4 2 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_flips 1 2 3"
      }
    ]
  },
  "fvapps_000167.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_length_of_shortest_subarray (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isNonDecreasing (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def removeSubarray (arr : List Int) (start : Nat) (len : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Output is between 0 and length of array"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_bounds (arr : List Int) :\n  let result := find_length_of_shortest_subarray arr\n  0 \u2264 result \u2227 result \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- There exists some subarray of length result that when removed makes array non-decreasing"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem valid_removal_exists (arr : List Int) (h : arr \u2260 []) :\n  let result := find_length_of_shortest_subarray arr\n  \u2203 i : Nat, i + result \u2264 arr.length \u2227\n    isNonDecreasing (removeSubarray arr i result) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Cannot remove fewer elements to make array non-decreasing"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cannot_remove_fewer (arr : List Int) (h : arr \u2260 []) :\n  let result := find_length_of_shortest_subarray arr\n  result = 0 \u2192 isNonDecreasing arr\n  \u2227\n  result > 0 \u2192 \u2200 i : Nat, i + (result - 1) \u2264 arr.length \u2192\n    \u00acisNonDecreasing (removeSubarray arr i (result - 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Sorted array returns 0"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sorted_returns_zero (arr : List Int) (h : arr \u2260 []) :\n  isNonDecreasing arr \u2192 find_length_of_shortest_subarray arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Small arrays"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem small_arrays (arr : List Int) :\n  arr.length \u2264 1 \u2192 find_length_of_shortest_subarray arr = 0\n  \u2227\n  (arr.length = 2 \u2192\n    find_length_of_shortest_subarray arr =\n      if arr.get! 0 \u2264 arr.get! 1 then 0 else 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3, 10, 4, 2, 3, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [5, 4, 3, 2, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_length_of_shortest_subarray [1, 2, 3]"
      }
    ]
  },
  "fvapps_000168.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxProduct (nums : List Int) : Int := sorry\n\ndef listMax (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => List.foldl max h t"
      },
      {
        "type": "sig",
        "string": "def listProd (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 1\n  | h :: t => List.foldl (\u00b7 * \u00b7) h t"
      },
      {
        "type": "cond",
        "string": "theorem maxProduct_empty_list :\n  maxProduct [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxProduct_single_element (x : Int) :\n  maxProduct [x] = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxProduct_nonneg_with_zero (nums : List Int) :\n  (0 \u2208 nums) \u2192 maxProduct nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval maxProduct [2, 3, -2, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxProduct [-2, 0, -1]\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval maxProduct [-2, 3, -4]"
      }
    ]
  },
  "fvapps_000169.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxDiff (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDiff_single_digit (n : Nat) (h : n < 10) : maxDiff n = 8 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDiff_properties (n : Nat) :\n  n \u2265 10 \u2192\n  maxDiff n \u2265 0 \u2227\n  maxDiff n \u2264 999999 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDiff_nonnegative (n : Nat) : maxDiff n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to get number of digits\n\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 888\n-/\n#guard_msgs in\n#eval maxDiff 555\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval maxDiff 9\n\n/-\ninfo: 820000\n-/\n#guard_msgs in\n#eval maxDiff 123456"
      }
    ]
  },
  "fvapps_000170.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_arrange (arr : List Int) (k : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Even (n : Nat) : Prop := \u2203 k, n = 2 * k\n\ndef countOdds (xs : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc x => if x % 2 = 1 then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_result_type (arr : List Int) (k : Nat) :\n  can_arrange arr k = true \u2228 can_arrange arr k = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_even_length {arr : List Int} {k : Nat} :\n  can_arrange arr k = true \u2192 List.length arr % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_k_one {arr : List Int} :\n  can_arrange arr 1 = true \u2194 List.length arr % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_k_two {arr : List Int} :\n  can_arrange arr 2 = true \u2192\n  Even (countOdds arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_empty {k : Nat} :\n  can_arrange [] k = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_arrange_singleton {x : Int} {k : Nat} :\n  can_arrange [x] k = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 10, 6, 7, 8, 9] 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_arrange [1, 2, 3, 4, 5, 6] 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_arrange [-1, 1, -2, 2, -3, 3, -4, 4] 3"
      }
    ]
  },
  "fvapps_000173.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isScramble (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_strings_are_scramble (s : String) :\n  isScramble s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_lengths_not_scramble (s : String) :\n  isScramble s (s ++ \"a\") = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- We'll use substring operations instead of direct char manipulation -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem different_chars_not_scramble (s : String) (h : s.length > 0) :\n  \u2200 (s2 : String), s.length = s2.length \u2192 (\u2203 c, s.contains c \u2260 s2.contains c) \u2192\n  isScramble s s2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_two_strings_scramble (s1 s2 : String) :\n  s1.length = 2 \u2192 s2.length = 2 \u2192 (\u2200 c, s1.contains c = s2.contains c) \u2192\n  isScramble s1 s2 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scramble_symmetric (s1 s2 : String) :\n  isScramble s1 s2 = isScramble s2 s1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_strings_are_scramble :\n  isScramble \"\" \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"great\" \"rgeat\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_scramble \"abcde\" \"caebd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_scramble \"a\" \"a\""
      }
    ]
  },
  "fvapps_000177.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_refuel_stops (target : Nat) (start_fuel : Nat) (stations : List (Nat \u00d7 Nat)) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x :: xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_result_valid (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat \u00d7 Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result \u2265 -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_sufficient_start_fuel (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat \u00d7 Nat)) :\n  start_fuel \u2265 target \u2192\n  min_refuel_stops target start_fuel stations = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_impossible (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat \u00d7 Nat)) :\n  let total_fuel := start_fuel + list_sum (stations.map Prod.snd)\n  total_fuel < target \u2192\n  min_refuel_stops target start_fuel stations = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_stations_ordered (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat \u00d7 Nat)) :\n  stations.length > 0 \u2192\n  \u2200 i : Nat, i < stations.length - 1 \u2192\n  (stations.get! i).1 \u2264 (stations.get! (i+1)).1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_bound (target : Nat) (start_fuel : Nat)\n    (stations : List (Nat \u00d7 Nat)) :\n  let result := min_refuel_stops target start_fuel stations\n  result \u2260 -1 \u2192\n  result \u2264 stations.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_empty_stations_sufficient (start_fuel target : Nat) :\n  target \u2264 start_fuel \u2192\n  min_refuel_stops target start_fuel [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_empty_stations_insufficient (start_fuel target : Nat) :\n  start_fuel < target \u2192\n  min_refuel_stops target start_fuel [] = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_refuel_stops_zero_start_fuel (target : Nat) (stations : List (Nat \u00d7 Nat)) :\n  min_refuel_stops target 0 stations = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_refuel_stops 1 1 []\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 1 [[10, 100]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_refuel_stops 100 10 [[10, 60], [20, 30], [30, 30], [60, 40]]"
      }
    ]
  },
  "fvapps_000184.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_operations_max_profit (customers: List Nat) (boarding_cost: Nat) (running_cost: Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (xs: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "xs.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem min_operations_result_valid\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: \u2200 x \u2208 customers, x \u2264 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    result = -1 \u2228 result > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_operations_max_rotations\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: \u2200 x \u2208 customers, x \u2264 1000)\n  : let result := min_operations_max_profit customers boarding_cost running_cost\n    let total := list_sum customers\n    let max_rotations := total / 4 + (if total % 4 = 0 then 0 else 1)\n    result = -1 \u2228 result \u2264 max_rotations + total :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem high_running_cost_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: customers.length \u2264 10)\n  (h3: boarding_cost > 0)\n  (h4: boarding_cost \u2264 10)\n  (h5: \u2200 x \u2208 customers, x \u2264 10)\n  : min_operations_max_profit customers boarding_cost 1000 = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem high_profit_scenario_profitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost \u2265 100)\n  (h3: \u2200 x \u2208 customers, x \u2265 100 \u2227 x \u2264 1000)\n  : min_operations_max_profit customers boarding_cost 1 > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_customers_unprofitable\n  (customers: List Nat)\n  (boarding_cost: Nat)\n  (running_cost: Nat)\n  (h1: customers.length > 0)\n  (h2: boarding_cost > 0)\n  (h3: running_cost > 0)\n  (h4: \u2200 x \u2208 customers, x = 0)\n  : min_operations_max_profit customers boarding_cost running_cost = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_operations_max_profit [8, 3] 5 6\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_operations_max_profit [10, 9, 6] 6 4\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_operations_max_profit [3, 4, 0, 5, 1] 1 92"
      }
    ]
  },
  "fvapps_000187.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def atMostNGivenDigitSet (digits : List String) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countValidDigits (digits : List String) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (digits.filter (fun d => d.toNat?.getD 0 \u2264 n)).length"
      },
      {
        "type": "cond",
        "string": "theorem result_nonnegative {digits : List String} {n : Nat} :\n  0 \u2264 atMostNGivenDigitSet digits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_within_max_possible {digits : List String} {n : Nat} :\n  let max_len := toString n |>.length\n  atMostNGivenDigitSet digits n \u2264 (digits.length ^ max_len) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_result {digits : List String} {n : Nat} :\n  n < 10 \u2192\n  atMostNGivenDigitSet digits n = countValidDigits digits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_digit_list_fails (n : Nat) :\n  atMostNGivenDigitSet [] n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_basic_cases_1 :\n  atMostNGivenDigitSet [\"1\"] 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_basic_cases_2 :\n  atMostNGivenDigitSet [\"9\"] 10 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_000189.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h :: t => h + sum t"
      },
      {
        "type": "sig",
        "string": "def min_set_size (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listRange (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  (List.range n).map Int.ofNat"
      },
      {
        "type": "cond",
        "string": "theorem min_set_size_positive (arr : List Int) (h : arr \u2260 []) :\n  min_set_size arr > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_set_size_upper_bound (arr : List Int) (h : arr \u2260 []) :\n  min_set_size arr \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_set_size_removes_half (arr : List Int) (h : arr \u2260 []) :\n  let countMap := arr.map (fun x => (arr.filter (\u00b7 = x)).length)\n  let removed := countMap.take (min_set_size arr)\n  sum removed \u2265 arr.length / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_set_size_all_same (arr : List Int) (h : arr \u2260 []) :\n  (\u2200 i j, i < arr.length \u2192 j < arr.length \u2192 arr[i]! = arr[j]!) \u2192\n  min_set_size arr = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_set_size_all_unique (n : Nat) :\n  min_set_size (listRange n) = (n + 1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_set_size [3, 3, 3, 3, 5, 5, 5, 2, 2, 7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_set_size [7, 7, 7, 7, 7, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval min_set_size [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
      }
    ]
  },
  "fvapps_000191.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_of_prime_factors (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Basic properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  n > 1 \u2227 \u2200 k, 2 \u2264 k \u2192 k < n \u2192 \u00ac(n % k = 0)"
      },
      {
        "type": "sig",
        "string": "def pow (base exp : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_prime_factors_positive {n : Int} (h : n \u2265 2) :\n  sum_of_prime_factors n > 0 \u2227 sum_of_prime_factors n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_prime_factors_nonpositive {n : Int} (h : n \u2264 1) :\n  sum_of_prime_factors n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For prime numbers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_prime_factors_of_prime {n : Int} (h : is_prime n) :\n  sum_of_prime_factors n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For prime powers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_prime_factors_of_prime_power {p k : Int}\n  (hp : is_prime p) (hk : k > 0) :\n  sum_of_prime_factors (pow p k) = p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For products"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_prime_factors_of_product {a b : Int} (ha : a \u2265 2) (hb : b \u2265 2) :\n  sum_of_prime_factors (a * b) \u2264 sum_of_prime_factors a + sum_of_prime_factors b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000192.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxSubarraySumCircular (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isEmpty (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxElem (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAllPositive (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAllNegative (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rotate (nums : List Int) (i : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element (nums : List Int) (h : nums.length = 1) (first : Int) :\n  nums = [first] \u2192 maxSubarraySumCircular nums = first :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, 3, -2, 1]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [5, -3, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maxSubarraySumCircular [-2, -3, -1]"
      }
    ]
  },
  "fvapps_000195.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longest_consecutive (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_nonnegative (nums : List Int) :\n  longest_consecutive nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def removeDuplicates (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_as_deduplicated (nums : List Int) :\n  longest_consecutive nums = longest_consecutive (removeDuplicates nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sortList (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_same_as_unsorted (nums : List Int) :\n  nums \u2260 [] \u2192 longest_consecutive nums = longest_consecutive (sortList nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_leq_input_len (nums : List Int) :\n  longest_consecutive nums \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_zero (nums : List Int) :\n  nums = [] \u2192 longest_consecutive nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_one (nums : List Int) (x : Int) :\n  nums = [x] \u2192 longest_consecutive nums = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reversed_same (nums : List Int) :\n  nums \u2260 [] \u2192 longest_consecutive nums = longest_consecutive nums.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_consecutive [100, 4, 200, 1, 3, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval longest_consecutive [1, 2, 0, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_consecutive []"
      }
    ]
  },
  "fvapps_000209.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def myPow (x : Float) (n : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isClose (a b : Float) (relTol absTol : Float := 0.0) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem myPow_matches_mathPow {x : Float} {n : Int}\n  (x_range : 0.1 \u2264 x \u2227 x \u2264 10)\n  (n_range : -5 \u2264 n \u2227 n \u2264 5) :\n  isClose (myPow x n) (Float.pow x (Float.ofInt n)) (relTol := 1e-5) (absTol := 1e-5) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem myPow_zero_exponent {x : Float}\n  (x_range : 0.1 \u2264 x \u2227 x \u2264 10) :\n  myPow x 0 = 1.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem myPow_inverse_property {x : Float} {n : Int}\n  (x_range : 0.1 \u2264 x \u2227 x \u2264 10)\n  (n_range : 1 \u2264 n \u2227 n \u2264 2) :\n  isClose ((myPow x n) * (myPow x (-n))) 1.0 (relTol := 1e-5) (absTol := 1e-5) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000211.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isGoodArray (nums : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listGcd (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem good_array_gcd {nums : List Nat} (h : nums \u2260 []) :\n  isGoodArray nums = true \u2194 listGcd nums = 1\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiples_not_good {n : Nat} (h : n \u2265 2) :\n  isGoodArray [n, 2*n, 3*n, 4*n] = false\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scale_makes_not_good {nums : List Nat} (h : nums \u2260 []) :\n  isGoodArray (nums.map (\u00b7 * 2)) = false\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[12, 5, 7, 23]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isGoodArray #[29, 6, 10]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isGoodArray #[3, 6]"
      }
    ]
  },
  "fvapps_000213.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def subarrayBitwiseORs (nums: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_nonnegative {nums: List Nat} (h: nums \u2260 []) :\n  subarrayBitwiseORs nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countUnique (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (List.foldl (fun acc x => if acc.contains x then acc else x::acc) [] l).length"
      },
      {
        "type": "cond",
        "string": "theorem result_upper_bound {nums: List Nat} (h: nums \u2260 []) :\n  subarrayBitwiseORs nums \u2264 (nums.length * (nums.length + 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_subarray {nums: List Nat} (h: nums \u2260 []) :\n  subarrayBitwiseORs nums \u2265 countUnique nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [0]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 1, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 2, 4]"
      }
    ]
  },
  "fvapps_000217.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longest_dup_substring (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstringOf (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOccurrences (needle haystack : String) (start : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longest_dup_occurs_twice {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  if result.length > 0 then\n    countOccurrences result s 0 \u2265 2\n  else True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasLongerDuplicate (s : String) (len : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_longer_duplicate_exists {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  \u2200 len, len > result.length \u2192\n  hasLongerDuplicate s len = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longest_dup_is_substring {s : String} (h : s.length > 0) :\n  let result := longest_dup_substring s\n  isSubstringOf result s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000222.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPerfectSquare (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => true\n  | n + 1 =>\n    let sq := sqrt n\n    sq * sq = n"
      },
      {
        "type": "sig",
        "string": "def numSquarefulPerms (A: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_bounds\n  (A: List Nat)\n  (h1: \u2200 x \u2208 A, 1 \u2264 x \u2227 x \u2264 100) :\n  let result := numSquarefulPerms A\n  0 \u2264 result \u2227 result \u2264 factorial A.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_permutations\n  (A: List Nat)\n  (h1: A.length \u2265 2)\n  (h2: \u2200 x \u2208 A, 1 \u2264 x \u2227 x \u2264 100)\n  (h3: numSquarefulPerms A > 0) :\n  \u2203 i, i < A.length - 1 \u2227 isPerfectSquare (A[i]! + A[i+1]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_elements\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: \u2200 x \u2208 A, 1 \u2264 x \u2227 x \u2264 100)\n  (x: Nat)\n  (h3: x = A[0]!) :\n  numSquarefulPerms (List.replicate A.length x) = 0 \u2228\n  numSquarefulPerms (List.replicate A.length x) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorting_invariance\n  (A: List Nat)\n  (h1: A.length > 0)\n  (h2: \u2200 x \u2208 A, 1 \u2264 x \u2227 x \u2264 100) :\n  numSquarefulPerms A = numSquarefulPerms (List.reverse A) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 17, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numSquarefulPerms [2, 2, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval numSquarefulPerms [1, 1]"
      }
    ]
  },
  "fvapps_000223.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longestOnes (A : List Nat) (K : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isConsecutiveOnes (A : List Nat) (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxConsecutiveOnes (A : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_upper_bound (A : List Nat) (K : Nat) :\n  longestOnes A K \u2264 A.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_min_bound (A : List Nat) (K : Nat) (n : Nat) :\n  isConsecutiveOnes A n \u2192 n \u2264 longestOnes A K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_zero_k (A : List Nat) :\n  longestOnes A 0 = maxConsecutiveOnes A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_large_k (A : List Nat) (K : Nat) :\n  K \u2265 A.length \u2192 longestOnes A K = A.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_single_zero (K : Nat) :\n  longestOnes [0] K = min 1 K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longestOnes_single_one (K : Nat) :\n  longestOnes [1] K = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0] 2\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval longestOnes [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1] 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestOnes [1, 1, 1, 1] 2"
      }
    ]
  },
  "fvapps_000224.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_vowels (s : String) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_vowels (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_vowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_vowels_monotonic {s : String} {k : Nat}\n  (h1 : k < String.length s) :\n  max_vowels s k \u2264 max_vowels s (k + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_vowels_empty {k : Nat}\n  (h1 : k > 0) :\n  max_vowels \"\" k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_vowels \"abciiidef\" 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_vowels \"leetcode\" 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_vowels \"rhythms\" 4"
      }
    ]
  },
  "fvapps_000230.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_parens_to_add (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_balanced (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string : min_parens_to_add \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unmatched_open (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n '(')) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unmatched_close (n : Nat) :\n  min_parens_to_add (String.mk (List.replicate n ')')) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_parens_to_add \"())\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_parens_to_add \"(((\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_parens_to_add \"()\""
      }
    ]
  },
  "fvapps_000236.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def frequency_sort (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOccurrences (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem frequency_sort_maintains_length (s : String) :\n  (frequency_sort s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_000242.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def replace_words (dict : List String) (sentence : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitIntoWords (s : String) : List String := s.split (\u00b7 == ' ')"
      },
      {
        "type": "sig",
        "string": "def wordCount (s : String) : Nat := (splitIntoWords s).length"
      },
      {
        "type": "cond",
        "string": "theorem replace_words_output_length_matches_input\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  wordCount (replace_words dict sentence) = words.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem replace_words_output_words_valid\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  \u2200 (i : Nat) (h : i < words.length),\n    result[i]! = words[i]! \u2228 result[i]! \u2208 dict :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem replace_words_replacement_preserves_prefix\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let result := splitIntoWords (replace_words dict sentence)\n  \u2200 (i : Nat) (h : i < words.length),\n    result[i]! \u2208 dict \u2192 words[i]!.startsWith result[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_dict_preserves_input\n  (dict : List String) (word : String) (h_dict : dict = []) :\n  replace_words dict word = word :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem replace_words_idempotent\n  (dict : List String) (words : List String) (h_words : words.length > 0)\n  (h_dict : dict.length > 0)\n  (sentence := String.intercalate \" \" words) :\n  let once := replace_words dict sentence\n  let twice := replace_words dict once\n  once = twice :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'the cat was rat by the bat'\n-/\n#guard_msgs in\n#eval replace_words [\"cat\", \"bat\", \"rat\"] \"the cattle was rattled by the battery\"\n\n/-\ninfo: 'a a a'\n-/\n#guard_msgs in\n#eval replace_words [\"a\", \"aa\", \"aaa\"] \"aa aaa aaaa\""
      }
    ]
  },
  "fvapps_000243.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minSumOfLengths (arr : List Int) (target : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfSubarray (arr : List Int) (i j : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  (arr.take j).drop i |>.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_return_negative_one (target : Int) :\n  minSumOfLengths [] target = -1 \u2227\n  minSumOfLengths [1] (2 : Int) = -1 \u2227\n  minSumOfLengths [0] (0 : Int) = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_result_bounds {arr : List Int} {target : Int}\n  (h1 : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 100)\n  (h2 : 1 \u2264 target \u2227 target \u2264 1000)\n  (h3 : arr \u2260 [])\n  (h4 : minSumOfLengths arr target \u2260 -1) :\n  2 \u2264 minSumOfLengths arr target \u2227 minSumOfLengths arr target \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_result_implies_no_valid_subarrays {arr : List Int} {target : Int}\n  (h1 : \u2200 x \u2208 arr, 0 \u2264 x \u2227 x \u2264 10)\n  (h2 : 0 \u2264 target \u2227 target \u2264 20)\n  (h3 : \u00ac\u2203 i j, 0 \u2264 i \u2227 i < j \u2227 j \u2264 arr.length \u2227\n       sumOfSubarray arr i j = target) :\n  minSumOfLengths arr target = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_one_implies_no_non_overlapping_subarrays {arr : List Int} {target : Int}\n  (h1 : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 10)\n  (h2 : 1 \u2264 target \u2227 target \u2264 20)\n  (h3 : arr.length \u2265 4)\n  (h4 : minSumOfLengths arr target = -1) :\n  \u00ac\u2203 i j k l,\n    0 \u2264 i \u2227 i < j \u2227 j \u2264 k \u2227 k < l \u2227 l \u2264 arr.length \u2227\n    sumOfSubarray arr i j = target \u2227\n    sumOfSubarray arr k l = target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [3, 2, 2, 4, 3] 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [7, 3, 4, 7] 7\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_sum_of_lengths [4, 3, 2, 6, 2, 3, 4] 6"
      }
    ]
  },
  "fvapps_000244.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.rectangular (grid : List (List \u03b1)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def contains_cycle (grid : List (List Char)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_cycle_empty_raises : \u2200 (grid : List (List Char)),\n  grid = [] \u2228 grid.head?.map (\u03bb row => row = []) = some true \u2192\n  contains_cycle grid = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_cycle_returns_bool : \u2200 (grid : List (List Char)),\n  grid \u2260 [] \u2192\n  grid.head?.map (\u03bb row => row \u2260 []) = some true \u2192\n  grid.rectangular = true \u2192\n  (contains_cycle grid = true \u2228 contains_cycle grid = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_cycle_all_same_char : \u2200 (c : Char) (n : Nat),\n  n > 0 \u2192\n  let grid := List.replicate n (List.replicate n c);\n  contains_cycle grid = (n > 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_cycle_checkerboard : \u2200 (n : Nat),\n  n \u2265 2 \u2192\n  let grid := List.map (\u03bb i => List.map (\u03bb j => if (i+j)%2 = 0 then 'a' else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_cycle_border : \u2200 (n : Nat),\n  n \u2265 3 \u2192\n  let grid := List.map (\u03bb i => List.map (\u03bb j =>\n    if i = 0 \u2228 i = n-1 \u2228 j = 0 \u2228 j = n-1\n    then 'a'\n    else 'b') (List.range n)) (List.range n);\n  contains_cycle grid = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"a\", \"a\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"b\", \"b\", \"a\"], [\"a\", \"a\", \"a\", \"a\"]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_cycle [[\"c\", \"c\", \"c\", \"a\"], [\"c\", \"d\", \"c\", \"c\"], [\"c\", \"c\", \"e\", \"c\"], [\"f\", \"c\", \"c\", \"c\"]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_cycle [[\"a\", \"b\", \"b\"], [\"b\", \"z\", \"b\"], [\"b\", \"b\", \"a\"]]"
      }
    ]
  },
  "fvapps_000249.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listMax (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def findMinMoves (machines : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_moves_non_negative\n  {machines : List Nat}\n  (h : findMinMoves machines \u2260 -1) :\n  findMinMoves machines \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_moves_preserves_sum\n  {machines : List Nat}\n  (h : findMinMoves machines \u2260 -1) :\n  sum machines = machines.length * (sum machines / machines.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_moves_lower_bound\n  {machines : List Nat}\n  (h : findMinMoves machines \u2260 -1) :\n  findMinMoves machines \u2265\n    max (listMax machines - sum machines / machines.length) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_moves_negative_one\n  {machines : List Nat}\n  (h : findMinMoves machines = -1) :\n  sum machines % machines.length \u2260 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_moves [1, 0, 5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_moves [0, 3, 0]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_moves [0, 2, 0]"
      }
    ]
  },
  "fvapps_000254.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_smallest_divisor (nums : List Nat) (threshold : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def ceil_div (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (a + b - 1) / b"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => List.foldl max x xs"
      },
      {
        "type": "cond",
        "string": "theorem single_element_case {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length = 1)\n  (h2 : threshold > 0)\n  (h3 : \u2200 x \u2208 nums, 1 \u2264 x \u2227 x \u2264 1000000)\n  (h4 : threshold \u2264 1000000) :\n  find_smallest_divisor nums threshold = ceil_div nums[0] threshold :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded {nums : List Nat} {threshold : Nat}\n  (h1 : nums.length > 0)\n  (h2 : nums.length \u2264 10)\n  (h3 : \u2200 x \u2208 nums, 1 \u2264 x \u2227 x \u2264 100)\n  (h4 : 1 \u2264 threshold \u2227 threshold \u2264 100) :\n  1 \u2264 find_smallest_divisor nums threshold \u2227\n  find_smallest_divisor nums threshold \u2264 list_max nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_smallest_divisor [1, 2, 5, 9] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_smallest_divisor [2, 3, 5, 7, 11] 11\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_smallest_divisor [19] 5"
      }
    ]
  },
  "fvapps_000255.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def wiggleMaxLength (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem wiggle_length_bounds (arr : List Int) :\n  0 \u2264 wiggleMaxLength arr \u2227 wiggleMaxLength arr \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_increasing_bound (arr : List Int) :\n  arr.length > 1 \u2192 isSorted arr = true \u2192 wiggleMaxLength arr \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_array_property (arr : List Int) :\n  arr.length < 2 \u2192 wiggleMaxLength arr = arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_decreasing_bound (arr : List Int) :\n  arr.length > 1 \u2192 isSorted (List.reverse arr) = true \u2192 wiggleMaxLength arr \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shift_invariance (arr : List Int) (k : Int) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (\u00b7 + k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scale_invariance (arr : List Int) (k : Int) (h : k \u2260 0) :\n  wiggleMaxLength arr = wiggleMaxLength (arr.map (\u00b7 * k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_invariance (arr : List Int) :\n  wiggleMaxLength arr = wiggleMaxLength (List.reverse arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 7, 4, 9, 2, 5]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 17, 5, 10, 13, 15, 10, 5, 16, 8]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval wiggle_max_length [1, 2, 3, 4, 5, 6, 7, 8, 9]"
      }
    ]
  },
  "fvapps_000256.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_kth_largest (nums : List Int) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def max_list (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def min_list (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sort_desc (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_kth_largest_element_membership\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k \u2264 nums.length) :\n  (find_kth_largest nums k) \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_kth_largest_lower_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k \u2264 nums.length) :\n  (nums.filter (fun x => x \u2265 find_kth_largest nums k)).length \u2265 k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_kth_largest_upper_bound\n  (nums : List Int) (k : Nat) (h : k > 0) (h' : k \u2264 nums.length) :\n  (nums.filter (fun x => x > find_kth_largest nums k)).length < k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 1, 5, 6, 4] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_kth_largest [3, 2, 3, 1, 2, 4, 5, 5, 6] 4\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_kth_largest [2, 1, 3, 4, 5, 6] 2"
      }
    ]
  },
  "fvapps_000257.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Solution := String\n\ndef isSolvable (words : List String) (result : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isAlpha (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution_constraints {words : List String} {result : String}\n  (h1 : \u2200 w \u2208 words, isAlpha w \u2227 isUpper w)\n  (h2 : isAlpha result \u2227 isUpper result)\n  (h3 : words.length > 0)\n  (h4 : \u2200 w \u2208 words, w.length > 0)\n  (h5 : result.length \u2265 words.foldr (fun w acc => max w.length acc) 0) :\n  \u2203 solution : Bool, isSolvable words result = solution :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_valid_cases_work\n  (h1 : isSolvable [\"SEND\", \"MORE\"] \"MONEY\" = true)\n  (h2 : isSolvable [\"SIX\", \"SEVEN\", \"SEVEN\"] \"TWENTY\" = true) :\n  \u2200 words result,\n    (words = [\"SEND\", \"MORE\"] \u2227 result = \"MONEY\") \u2228\n    (words = [\"SIX\", \"SEVEN\", \"SEVEN\"] \u2227 result = \"TWENTY\") \u2192\n    isSolvable words result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem modified_valid_case_exists_solution\n  {words result : String}\n  (h1 : words.length > 0)\n  (h2 : result.length > 0)\n  (h3 : \u2203 (orig_words : List String) (orig_result : String),\n        ((orig_words = [\"SEND\", \"MORE\"] \u2227 orig_result = \"MONEY\") \u2228\n         (orig_words = [\"SIX\", \"SEVEN\", \"SEVEN\"] \u2227 orig_result = \"TWENTY\")) \u2227\n        words.length = orig_result.length) :\n  \u2203 solution : Bool, isSolvable [words] result = solution :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_000258.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_non_overlapping (nums: List Int) (target: Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n: Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_non_overlapping_non_negative (nums: List Int) (target: Int) :\n  max_non_overlapping nums target \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_non_overlapping_bounded_by_length (nums: List Int) (target: Int) :\n  max_non_overlapping nums target \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_non_overlapping_empty_list (target: Int) :\n  max_non_overlapping [] target = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_non_overlapping_all_zeros (n: Nat) :\n  max_non_overlapping (List.replicate n 0) 0 = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_non_overlapping_self_consistent (nums: List Int) (target: Int) :\n  max_non_overlapping nums target = max_non_overlapping nums target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [1, 1, 1, 1, 1] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_non_overlapping [-1, 3, 5, 1, 4, 2, -9] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_non_overlapping [0, 0, 0] 0"
      }
    ]
  },
  "fvapps_000259.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def num_good_splits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def uniqueChars (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_good_splits_bounds (s : String) (h : s.length > 0) :\n  num_good_splits s \u2264 s.length - 1 \u2227 num_good_splits s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_good_splits \"aacaba\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_good_splits \"abcd\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval num_good_splits \"aaaaa\""
      }
    ]
  },
  "fvapps_000263.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_happy_string (n k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def all_chars_abc (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def no_adjacent_same (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def starts_with_a (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem happy_string_properties (n k : Nat)\n  (h1 : 0 < n) (h2 : n \u2264 10) (h3 : 0 < k) (h4 : k \u2264 1000) :\n  let s := get_happy_string n k\n  let max_possible := 3 * 2^(n-1)\n  -- Length property\n  (s.length = n \u2228 s.length = 0) \u2227\n  -- Character set property\n  all_chars_abc s \u2227\n  -- Adjacent character property\n  (s.length > 1 \u2192 no_adjacent_same s) \u2227\n  -- Empty string property\n  ((k > max_possible \u2192 s.length = 0) \u2227\n   (k \u2264 max_possible \u2192 s.length = n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem n1_special_case (k : Nat)\n  (h1 : 0 < k) (h2 : k \u2264 10) :\n  let s := get_happy_string 1 k\n  (k \u2264 3 \u2192 (s = \"a\" \u2228 s = \"b\" \u2228 s = \"c\")) \u2227\n  (k > 3 \u2192 s = \"\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k1_special_case (n : Nat)\n  (h1 : 0 < n) (h2 : n \u2264 5) :\n  let s := get_happy_string n 1\n  s.length = n \u2227\n  starts_with_a s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval get_happy_string 1 3\n\n/-\ninfo: 'cab'\n-/\n#guard_msgs in\n#eval get_happy_string 3 9\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval get_happy_string 1 4"
      }
    ]
  },
  "fvapps_000270.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def num_times_all_blue (lights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def remove_duplicates (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_bounds (lights : List Nat) (h : lights \u2260 []) :\n  let valid := lights.filter (fun x => x \u2264 lights.length)\n  let nodupes := remove_duplicates valid\n  0 \u2264 num_times_all_blue nodupes \u2227 num_times_all_blue nodupes \u2264 nodupes.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutation_correctness {n : Nat} (lights : List Nat)\n  (h1 : lights.length = n)\n  (h2 : \u2200 x, x \u2208 lights \u2192 x \u2264 n)\n  (h3 : \u2200 x, x \u2208 lights \u2192 (lights.filter (\u00b7 = x)).length = 1) :\n  num_times_all_blue lights =\n    (List.range lights.length).foldl\n      (fun acc i =>\n        let rightmost := (lights.take (i+1)).foldl Nat.max 0\n        if i+1 = rightmost then acc + 1 else acc)\n      0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invariants (lights : List Nat) (h : lights \u2260 []) :\n  let valid := lights.filter (fun x => x \u2264 lights.length)\n  let nodupes := remove_duplicates valid\n  let h2 := sorry -- proof that nodupes \u2260 []\n  (nodupes.getLast h2 = nodupes.length \u2192 num_times_all_blue nodupes \u2265 1) \u2227\n  num_times_all_blue nodupes \u2264 nodupes.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_times_all_blue [2, 1, 3, 5, 4]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_times_all_blue [3, 2, 4, 1, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_times_all_blue [4, 1, 2, 3]"
      }
    ]
  },
  "fvapps_000275.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxSideLength (mat: List (List Int)) (threshold: Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def minElem (list: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (list: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (list: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def floorSqrt (n: Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSideLength_bounds {mat : List (List Int)} {threshold : Int}\n  (h1 : \u2200 row \u2208 mat, row.length = mat[0]!.length) :\n  let result := maxSideLength mat threshold\n  0 \u2264 result \u2227 result \u2264 min mat.length mat[0]!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSideLength_low_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : \u2200 row \u2208 mat, row.length = mat[0]!.length)\n  (h2 : threshold < minElem (mat.map minElem)) :\n  maxSideLength mat threshold = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSideLength_high_threshold {mat : List (List Int)} {threshold : Int}\n  (h1 : \u2200 row \u2208 mat, row.length = mat[0]!.length)\n  (h2 : threshold \u2265 listSum (mat.map sumList)) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSideLength_zero_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : \u2200 row \u2208 mat, row.length = mat[0]!.length)\n  (h2 : \u2200 row \u2208 mat, \u2200 x \u2208 row, x = 0)\n  (h3 : threshold \u2265 0) :\n  maxSideLength mat threshold = min mat.length mat[0]!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSideLength_ones_matrix {mat : List (List Int)} {threshold : Int}\n  (h1 : \u2200 row \u2208 mat, row.length = mat[0]!.length)\n  (h2 : \u2200 row \u2208 mat, \u2200 x \u2208 row, x = 1) :\n  maxSideLength mat threshold \u2264 floorSqrt threshold :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2], [1, 1, 3, 2, 4, 3, 2]] 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSideLength [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]] 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maxSideLength [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]] 6"
      }
    ]
  },
  "fvapps_000276.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if x < 0 then -x else x"
      },
      {
        "type": "sig",
        "string": "def maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def smallest_distance_pair : List Int \u2192 Nat \u2192 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem smallest_distance_pair_properties {nums : List Int} {k : Nat}\n    (h1 : nums.length \u2265 2)\n    (h2 : k \u2265 1)\n    (h3 : k \u2264 (nums.length * (nums.length - 1)) / 2)\n    (h4 : \u2200 x \u2208 nums, -100 \u2264 x \u2227 x \u2264 100) :\n    let result := smallest_distance_pair nums k;\n    result \u2265 0 \u2227\n    result \u2264 maximum nums - minimum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_elements {n : List Int} (h : n.length \u2265 2) :\n  smallest_distance_pair (List.replicate n.length (n.get! 0)) 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_input_equivalence {nums : List Int} (h : nums.length \u2265 2) :\n  smallest_distance_pair nums 1 = smallest_distance_pair (nums.reverse.reverse) 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 1, 3] 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 3, 1] 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval smallest_distance_pair [1, 6, 1] 3"
      }
    ]
  },
  "fvapps_000286.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def least_interval (tasks : List Char) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countFrequencies (tasks : List Char) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxFrequency (tasks : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxFrequencyCount (tasks : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem least_interval_zero_cooldown (tasks : List Char) (h : tasks \u2260 []) :\n  least_interval tasks 0 = tasks.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem least_interval_basic_properties (tasks : List Char) (n : Nat) (h : tasks \u2260 []) :\n  let result := least_interval tasks n\n  let max_freq := maxFrequency tasks\n  let max_freq_count := maxFrequencyCount tasks\n  let min_possible := (max_freq - 1) * (n + 1) + max_freq_count\n  result \u2265 tasks.length \u2227 result \u2265 min_possible :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem least_interval_upper_bound (tasks : List Char) (n : Nat) (h : tasks \u2260 []) :\n  least_interval tasks n \u2264 tasks.length * (n + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"] 2\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"A\", \"A\"] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval least_interval [\"A\", \"B\", \"C\", \"D\"] 0"
      }
    ]
  },
  "fvapps_000294.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_uncrossed_lines (a b : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.min_length (a b : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  min a.length b.length"
      },
      {
        "type": "sig",
        "string": "def List.everyOther : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [x] => [x]\n  | x :: _ :: xs => x :: everyOther xs"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_nonnegative (a b : List Nat) :\n  max_uncrossed_lines a b \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_upper_bound (a b : List Nat) :\n  max_uncrossed_lines a b \u2264 min a.length b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_empty (a b : List Nat) :\n  a = [] \u2228 b = [] \u2192 max_uncrossed_lines a b = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_identical (a : List Nat) :\n  max_uncrossed_lines a a = a.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_reverse (a b : List Nat) :\n  max_uncrossed_lines a b = max_uncrossed_lines a.reverse b.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_uncrossed_lines_edge_cases :\n  max_uncrossed_lines [] [] = 0 \u2227\n  max_uncrossed_lines [1] [] = 0 \u2227\n  max_uncrossed_lines [] [1] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 4, 2] [1, 2, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [2, 5, 1, 2, 5] [10, 5, 2, 1, 5, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_uncrossed_lines [1, 3, 7, 1, 7, 5] [1, 9, 2, 5, 1]"
      }
    ]
  },
  "fvapps_000296.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_sum_after_partitioning (arr : List Int) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def len (l : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounds {arr : List Int} {k : Nat}\n  (h1 : arr.length > 0)\n  (h2 : \u2200 x \u2208 arr, x > 0)\n  (h3 : k > 0)\n  (h4 : k \u2264 100) :\n  sum arr \u2264 max_sum_after_partitioning arr k \u2227\n  max_sum_after_partitioning arr k \u2264 len arr * max arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_equals_one {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : \u2200 x \u2208 arr, x > 0) :\n  max_sum_after_partitioning arr 1 = sum arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_equals_length {arr : List Int}\n  (h1 : arr.length > 0)\n  (h2 : \u2200 x \u2208 arr, x > 0) :\n  max_sum_after_partitioning arr arr.length = len arr * max arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element {arr : List Int} {k : Nat}\n  (h1 : arr.length = 1)\n  (h2 : k > 0) :\n  max_sum_after_partitioning arr k = arr[0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 84\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 15, 7, 9, 2, 5, 10] 3\n\n/-\ninfo: 83\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1, 4, 1, 5, 7, 3, 6, 1, 9, 9, 3] 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_sum_after_partitioning [1] 1"
      }
    ]
  },
  "fvapps_000301.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longestArithSeqLength (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countMaxOccurrences (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let counts := arr.map (\u03bb x => arr.count x)\n  counts.foldl Nat.max 0"
      },
      {
        "type": "cond",
        "string": "theorem min_length_at_least_two {arr : List Int} (h : arr.length \u2265 1) :\n  longestArithSeqLength arr \u2265 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dupes_counted_properly {arr : List Int} (h : arr.length \u2265 2) :\n  longestArithSeqLength arr \u2265 countMaxOccurrences arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arithmetic_sequence_preserved {arr : List Int} (h\u2081 : arr.length \u2265 3) (h\u2082 : arr.length \u2264 10) :\n  let diff := arr[1]! - arr[0]!\n  let arithSeq := (List.range arr.length).map (\u03bb i => arr[0]! + diff * (Int.ofNat i))\n  longestArithSeqLength arithSeq = arithSeq.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_same_result {arr : List Int} (h : arr.length \u2265 2) :\n  longestArithSeqLength arr = longestArithSeqLength arr.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [3, 6, 9, 12]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval longestArithSeqLength [9, 4, 7, 2, 10]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longestArithSeqLength [20, 1, 15, 3, 10, 5, 8]"
      }
    ]
  },
  "fvapps_000302.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def getDigits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Function that returns the largest number not exceeding n whose digits are monotone increasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def monotoneIncreasingDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to compare Options -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def optionLE (a b : Option Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  match a, b with\n  | some x, some y => x \u2264 y\n  | none, _ => True\n  | _, none => False"
      },
      {
        "type": "other",
        "string": "/- For any number n, its monotone increasing digits result will have digits in non-decreasing order\n    and will not exceed the original number n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_is_monotone_increasing (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  (\u2200 i j : Nat, i < j \u2192 j < digits.length \u2192 optionLE (digits[i]?) (digits[j]?)) \u2227\n  result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- For any number n, its monotone increasing digits result is maximal - incrementing any digit\n    would either make it exceed n or break the monotone increasing property -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem largest_possible_result (n : Nat) :\n  let result := monotoneIncreasingDigits n\n  let digits := getDigits result\n  \u2200 i : Nat, i < digits.length \u2192\n    let digit := digits[i]?\n    match digit with\n    | none => True\n    | some d => d = 9 \u2228\n      (let incrementedDigits := digits.set i (d + 1)\n       let incrementedNum := incrementedDigits.foldl (fun acc d => acc * 10 + d) 0\n       incrementedNum > n \u2228\n       \u00ac(\u2200 j k : Nat, j < k \u2192 k < incrementedDigits.length \u2192\n           optionLE (incrementedDigits[j]?) (incrementedDigits[k]?))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Single digit numbers remain unchanged when applying monotone increasing digits -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem single_digit_unchanged (n : Nat) :\n  n < 10 \u2192 monotoneIncreasingDigits n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Numbers that are already monotone increasing remain unchanged -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem already_monotone_unchanged (n : Nat) :\n  let digits := getDigits n\n  (\u2200 i j : Nat, i < j \u2192 j < digits.length \u2192 optionLE (digits[i]?) (digits[j]?)) \u2192\n  monotoneIncreasingDigits n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 9\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 10\n\n/-\ninfo: 1234\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 1234\n\n/-\ninfo: 299\n-/\n#guard_msgs in\n#eval monotone_increasing_digits 332"
      }
    ]
  },
  "fvapps_000304.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shortestSubarray (arr : List Int) (k : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "sig",
        "string": "def toNat (i : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if i \u2264 0 then 0 else i.natAbs"
      },
      {
        "type": "cond",
        "string": "theorem impossible_cases (k : Int) :\n  shortestSubarray [] k = -1 \u2227\n  shortestSubarray [0] k = -1 \u2227\n  shortestSubarray [0,0] k = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_only (arr : List Int) (k : Int) (h1 : \u2200 x \u2208 arr, 0 < x) (h2 : 0 < k) :\n  let result := shortestSubarray arr k\n  if result = -1 then\n    \u2200 start len : Nat, start + len \u2264 arr.length \u2192\n      sumList ((arr.take (start + len)).drop start) < k\n  else\n    (\u2203 start : Nat, start + (toNat result) \u2264 arr.length \u2227\n      sumList ((arr.take (start + (toNat result))).drop start) \u2265 k) \u2227\n    (\u2200 len : Nat, len < (toNat result) \u2192 \u2200 start : Nat, start + len \u2264 arr.length \u2192\n      sumList ((arr.take (start + len)).drop start) < k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounds (arr : List Int) (k : Int) (h1 : 0 < k) (h2 : \u00acarr.isEmpty) :\n  let result := shortestSubarray arr k\n  if result = -1 then True\n  else 1 \u2264 result \u2227 result \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortestSubarray [1] 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval shortestSubarray [1, 2] 4\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval shortestSubarray [2, -1, 2] 3"
      }
    ]
  },
  "fvapps_000305.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_days (bloom_day : List Nat) (m k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_result (bloom_day : List Nat) (m k : Nat) (result : Int) : Bool := sorry\n\ndef list_minimum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => xs.foldl min x"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => xs.foldl max x"
      },
      {
        "type": "cond",
        "string": "theorem min_days_is_valid (bloom_day : List Nat) (m k : Nat) :\n  m > 0 \u2192 k > 0 \u2192 is_valid_result bloom_day m k (min_days bloom_day m k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_days_is_minimal (bloom_day : List Nat) (m k : Nat) :\n  m > 0 \u2192 k > 0 \u2192\n  min_days bloom_day m k \u2260 -1 \u2192\n  \u00ac is_valid_result bloom_day m k (min_days bloom_day m k - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_days_within_bounds (bloom_day : List Nat) (m k : Nat) :\n  m > 0 \u2192 k > 0 \u2192 bloom_day \u2260 [] \u2192\n  min_days bloom_day m k \u2260 -1 \u2192\n  min_days bloom_day m k \u2265 list_minimum bloom_day \u2227\n  min_days bloom_day m k \u2264 list_maximum bloom_day :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_days_identical_values (bloom_day : List Nat) (m k : Nat) :\n  m > 0 \u2192 k > 0 \u2192\n  (\u2200 x \u2208 bloom_day, x = 1) \u2192\n  (min_days bloom_day m k = if bloom_day.length \u2265 m * k then 1 else -1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_days [1, 10, 3, 10, 2] 3 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_days [1, 10, 3, 10, 2] 3 2\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval min_days [7, 7, 7, 7, 12, 7, 7] 2 3"
      }
    ]
  },
  "fvapps_000310.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxSizeSlices (slices: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sumList xs"
      },
      {
        "type": "sig",
        "string": "def maxList : List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (maxList xs)\n\ndef sortList : List Nat \u2192 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_size_bounds {slices : List Nat}\n  (h1: slices.length \u2265 3)\n  (h2: \u2200 x \u2208 slices, x \u2265 1 \u2227 x \u2264 100) :\n  let result := maxSizeSlices slices\n  result > 0 \u2227\n  result \u2264 sumList slices \u2227\n  result \u2265 maxList slices :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_size_elements {slices : List Nat}\n  (h1: slices.length \u2265 3)\n  (h2: \u2200 x \u2208 slices, x \u2265 1 \u2227 x \u2264 100) :\n  let n := slices.length\n  maxSizeSlices slices \u2264 sumList (List.take (n/3) (sortList slices)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_case_three {slices : List Nat}\n  (h1: slices.length = 3)\n  (h2: \u2200 x \u2208 slices, x \u2265 1 \u2227 x \u2264 100) :\n  maxSizeSlices slices = maxList slices :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxSizeSlices [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval maxSizeSlices [8, 9, 8, 6, 1, 1]\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval maxSizeSlices [4, 1, 2, 5, 8, 3, 1, 9, 7]"
      }
    ]
  },
  "fvapps_000312.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minOperations (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_nonnegative (nums : List Nat) :\n  minOperations nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxList : List Nat \u2192 Nat\n  | [] => 0\n  | (x::xs) => max x (maxList xs)"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_at_least_nonzero_count (nums : List Nat) :\n  minOperations nums \u2265 (nums.filter (\u03bb x => x > 0)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_at_least_max_bits (nums : List Nat) :\n  nums.length > 0 \u2192 nums \u2260 [] \u2192\n  minOperations nums \u2265 (String.length (toString (maxList nums))).pred :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_all_zeros (nums : List Nat) :\n  (\u2200 x \u2208 nums, x = 0) \u2192 minOperations nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_nonzero_lower_bound (nums : List Nat) :\n  (\u2200 x \u2208 nums, x > 0) \u2192 minOperations nums \u2265 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minOperations_powers_two_bound (nums : List Nat) (max : Nat) :\n  nums.length > 0 \u2192\n  (\u2200 x \u2208 nums, \u2203 n, x = 2^n) \u2192\n  max = maxList nums \u2192\n  minOperations nums \u2264 (String.length (toString max)) + nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval minOperations [1, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval minOperations [2, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval minOperations [4, 2, 5]"
      }
    ]
  },
  "fvapps_000313.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def checkIfCanBreak (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- If two strings are compared with checkIfCanBreak, they must have same length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_if_can_break_same_length (s1 s2 : String) :\n  checkIfCanBreak s1 s2 \u2192 String.length s1 = String.length s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A string can always break itself -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_if_can_break_reflexive (s : String) :\n  checkIfCanBreak s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The break relationship is symmetric -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_if_can_break_symmetric (s1 s2 : String) :\n  checkIfCanBreak s1 s2 = checkIfCanBreak s2 s1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- A sorted string can always break its unsorted version -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sorted_string_breaks_unsorted (s sorted : String)\n  (h : \u2200 i j : String.Pos, i < j \u2192 sorted.get i \u2264 sorted.get j)\n  (h2 : sorted.length = s.length)\n  (h3 : \u2200 c, c \u2208 sorted.data \u2194 c \u2208 s.data) :\n  checkIfCanBreak sorted s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"abc\" \"xya\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_if_can_break \"abe\" \"acd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_if_can_break \"leetcodee\" \"interview\""
      }
    ]
  },
  "fvapps_000314.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_patches (nums : List Nat) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Define sorted property"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isSorted (as : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < as.length \u2192 as[i]! \u2264 as[j]!"
      },
      {
        "type": "comment",
        "string": "-- All results are natural numbers and input list remains sorted"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_patches_basic_properties {nums : List Nat} {n : Nat}\n  (h : isSorted nums) :\n  let result := min_patches nums n\n  Nat.zero \u2264 result \u2227 isSorted nums := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty list produces positive result"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_patches_empty_list {n : Nat} :\n  let result := min_patches [] n\n  0 < result := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is non-negative for small n"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_patches_small_n {nums : List Nat} (n : Nat)\n  (h\u2081 : isSorted nums)\n  (h\u2082 : nums \u2260 [])\n  (h\u2083 : \u2200 x \u2208 nums, n < x) :\n  0 \u2264 min_patches nums n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Specific cases"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_patches_minimal_cases_1 :\n  min_patches [1] 1 = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_patches_minimal_cases_2 :\n  min_patches [2] 1 = 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_patches_minimal_cases_3 :\n  min_patches [1,2] 2 = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_patches [1, 3] 6\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_patches [1, 5, 10] 20\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_patches [1, 2, 2] 5"
      }
    ]
  },
  "fvapps_000316.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxDistance (grid : List (List Int)) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def rotateGrid (grid : List (List Int)) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDistance_bounds (grid : List (List Int)) :\n  let result := maxDistance grid\n  result \u2265 -1 \u2227 (result \u2260 -1 \u2192 result \u2264 2 * grid.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDistance_all_water (grid : List (List Int)) :\n  (\u2200 row \u2208 grid, \u2200 cell \u2208 row, cell = 0) \u2192\n  maxDistance grid = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDistance_all_land (grid : List (List Int)) :\n  (\u2200 row \u2208 grid, \u2200 cell \u2208 row, cell = 1) \u2192\n  maxDistance grid = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDistance_rotation {grid : List (List Int)} :\n  maxDistance grid = maxDistance (rotateGrid grid) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxDistance_edge_cases :\n  maxDistance [[1]] = -1 \u2227\n  maxDistance [[0]] = -1 \u2227\n  maxDistance [[1,0],[0,0]] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maxDistance [[1, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maxDistance [[0, 0, 0], [0, 0, 0], [0, 0, 0]]"
      }
    ]
  },
  "fvapps_000319.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find132pattern (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_132_pattern_brute_force (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (nums : List Int) (cmp : Int \u2192 Int \u2192 Bool) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find132pattern_matches_bruteforce {nums : List Int} :\n  find132pattern nums = has_132_pattern_brute_force nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_sequences_return_false {nums : List Int} :\n  List.length nums \u2264 2 \u2192 find132pattern nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_increasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x \u2264 y) \u2192 find132pattern nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_decreasing_no_pattern {nums : List Int} :\n  isSorted nums (fun x y => x \u2265 y) \u2192 find132pattern nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_elements_no_pattern {nums : List Int} {x : Int} :\n  nums.length \u2265 3 \u2192 nums = List.replicate nums.length x \u2192 find132pattern nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval find132pattern [1, 2, 3, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [3, 1, 4, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval find132pattern [-1, 3, 2, 0]"
      }
    ]
  },
  "fvapps_000321.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_numeric (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isInteger (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDecimal (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isWhitespace (c : Char) : Bool := c = ' ' || c = '\\t' || c = '\\n' || c = '\\r'"
      },
      {
        "type": "cond",
        "string": "theorem integer_pattern (s : String)\n  (h : isInteger s) :\n  is_numeric s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decimal_pattern (s : String)\n  (h : isDecimal s) :\n  is_numeric s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_chars (s : String)\n  (h\u2081 : s.length > 0)\n  (h\u2082 : \u2200 c \u2208 s.data, c \u2208 ['a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\n                           'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\n                           'x', 'y', 'z', 'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I',\n                           'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\n                           'U', 'V', 'W', 'X', 'Y', 'Z', '!', '@', '#', '$', '%',\n                           '^', '&', '*', '(', ')', '_', '{', '}', '[', ']', ';',\n                           ':', '<', '>', '?'])\n  (h\u2083 : \u2200 c \u2208 s.data, c \u2260 'e' \u2227 c \u2260 'E') :\n  is_numeric s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_handling (s : String) (ws : String)\n  (h\u2081 : \u2200 c \u2208 ws.data, isWhitespace c)\n  (h\u2082 : isInteger s \u2228 isDecimal s)\n  (h\u2083 : s.trim \u2260 \"\") :\n  is_numeric (ws ++ s ++ ws) = is_numeric s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000323.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_palindromic_substrings (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def string_reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def string_repeat (c : Char) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_palindromes (s : String) (h : s.length > 0) :\n  count_palindromic_substrings s \u2265 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  count_palindromic_substrings \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"abc\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"aaa\"\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval count_palindromic_substrings \"racecar\""
      }
    ]
  },
  "fvapps_000331.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def simplify_path (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_path_segment (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) (c : Char) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dot_references_resolve\n  {segments : List String}\n  (valid_segs : \u2200 s \u2208 segments, s = \".\" \u2228 s = \"..\" \u2228 is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let result := simplify_path path\n  result.startsWith \"/\" \u2227 \".\" \u2209 splitString result '/'\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem redundant_slashes\n  (slashes : String)\n  (h : \u2200 c \u2208 slashes.toList, c = '/') :\n  simplify_path slashes = \"/\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent\n  {segments : List String}\n  (valid_segs : \u2200 s \u2208 segments, is_valid_path_segment s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let once := simplify_path path\n  simplify_path once = once\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem root_path :\n  simplify_path \"/\" = \"/\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '/home'\n-/\n#guard_msgs in\n#eval simplify_path \"/home/\"\n\n/-\ninfo: '/c'\n-/\n#guard_msgs in\n#eval simplify_path \"/a/./b/../../c/\"\n\n/-\ninfo: '/home/foo'\n-/\n#guard_msgs in\n#eval simplify_path \"/home//foo/\""
      }
    ]
  },
  "fvapps_000338.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def contains_permutation (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def IsPermutation (s1 s2 : String) : Prop :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_empty_string {s : String} :\n  contains_permutation \"\" s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_shorter_string {s1 s2 : String} :\n  s2.length < s1.length \u2192 contains_permutation s1 s2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_self {s : String} :\n  contains_permutation s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_concat {s : String} :\n  contains_permutation s (s ++ s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_permutation_invariant {s1 s2 s1_perm : String} :\n  IsPermutation s1 s1_perm \u2192\n  contains_permutation s1 s2 = contains_permutation s1_perm s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_permutation_single_char {c : Char} {s : String} :\n  contains_permutation (String.mk [c]) s = String.contains s c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidbaooo\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"ab\" \"eidboaoo\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_permutation \"hello\" \"ooolleoabceh\""
      }
    ]
  },
  "fvapps_000339.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum_sum_with_deletion (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_scaling {arr : List Int} {scale : Int}\n  (h : arr \u2260 []) (hs : scale > 0) :\n  maximum_sum_with_deletion (List.map (\u00b7 * scale) arr) =\n  maximum_sum_with_deletion arr * scale :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, 0, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [1, -2, -2, 3]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_sum_with_deletion [-1, -1, -1, -1]"
      }
    ]
  },
  "fvapps_000356.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unique_letter_string (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_letter_string_positive (s : String) (h : s.length > 0) :\n  unique_letter_string s > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_letter_string_reverse_invariant (s : String) (h : s.length > 0) :\n  unique_letter_string s = unique_letter_string (string_reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_append_char (s : String) (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_letter_string_monotone (s : String) (h : s.length > 0)\n  (h1 : 0 < s.length) :\n  unique_letter_string (string_append_char s (s.get 0)) > unique_letter_string s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_letter_string_bounded (s : String) (h : s.length > 0) :\n  unique_letter_string s < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_letter_string_single_char (s : String) (h : s.length = 1) :\n  unique_letter_string s = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABC\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval unique_letter_string \"ABA\"\n\n/-\ninfo: 92\n-/\n#guard_msgs in\n#eval unique_letter_string \"LEETCODE\""
      }
    ]
  },
  "fvapps_000362.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numBusesToDestination (routes: List (List Nat)) (source: Nat) (target: Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findMaxInList (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findMaxInRoutes (routes: List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_path_property\n  (routes: List (List Nat))\n  (h: routes \u2260 [])\n  (h2: \u2200 r \u2208 routes, r \u2260 []) :\n  let maxStop := findMaxInRoutes routes\n  numBusesToDestination routes 0 (maxStop + 1) = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_range_property\n  (routes: List (List Nat))\n  (h: routes \u2260 [])\n  (h2: \u2200 r \u2208 routes, r \u2260 [])\n  (start: Nat)\n  (route: List Nat)\n  (routeEnd: Nat)\n  (h3: route \u2208 routes)\n  (h4: routeEnd \u2208 route) :\n  numBusesToDestination routes start routeEnd \u2265 -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_routes_property\n  (routes: List (List Nat))\n  (h: routes = [] \u2228 routes = [[]]) :\n  numBusesToDestination routes 1 2 = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 7], [3, 6, 7]] 1 6\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2, 3], [3, 4, 5]] 1 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numBusesToDestination [[1, 2], [2, 3], [3, 4]] 1 4"
      }
    ]
  },
  "fvapps_000364.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_profit (k : Nat) (prices : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def lastElem (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => lastElem xs"
      },
      {
        "type": "cond",
        "string": "theorem single_price_zero_profit (k : Nat) (p : Nat) :\n  max_profit k [p] = 0 := sorry\n\nprivate def pairwise_profits (prices : List Nat) : Nat :=\n  sorry\n\nprivate def isSorted (l : List Nat) : Prop :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_profit 2 [2, 4, 1]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_profit 2 [3, 2, 6, 5, 0, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_profit 1 [1, 2, 3, 4]"
      }
    ]
  },
  "fvapps_000366.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum_gap (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def Permutation (l1 l2 : List \u03b1) : Prop :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sort (l : List \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_gap_empty_or_singleton {nums : List Nat} :\n  nums.length \u2264 1 \u2192 maximum_gap nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_gap_nonnegative {nums : List Nat} :\n  maximum_gap nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_gap_bounded {nums : List Nat} :\n  nums.length > 0 \u2192\n  maximum_gap nums \u2264 List.foldl Nat.max 0 nums - List.foldl Nat.min 0 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_gap_is_max_consecutive_diff {nums : List Nat} (h : nums.length > 1) :\n  let sorted := sort nums (fun x y => x < y)\n  let gaps := List.zipWith (fun x y => y - x) sorted (List.drop 1 sorted)\n  maximum_gap nums = List.foldl Nat.max 0 gaps :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_gap_permutation_invariant {nums\u2081 nums\u2082 : List Nat} :\n  nums\u2081.length > 1 \u2192\n  Permutation nums\u2081 nums\u2082 \u2192\n  maximum_gap nums\u2081 = maximum_gap nums\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [3, 6, 9, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maximum_gap [10]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval maximum_gap [1, 2, 2, 5, 7, 10]"
      }
    ]
  },
  "fvapps_000370.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxSum (nums1 : List Nat) (nums2 : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasCommonElements (l1 l2 : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumUniqueElements (l1 l2 : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumCommonElements (l1 l2 : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxsum_positive (nums1 nums2 : List Nat)\n  (h1 : \u2200 x \u2208 nums1, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2 : \u2200 x \u2208 nums2, 1 \u2264 x \u2227 x \u2264 1000)\n  (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  maxSum nums1 nums2 \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxsum_under_modulo (nums1 nums2 : List Nat)\n  (h1 : \u2200 x \u2208 nums1, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2 : \u2200 x \u2208 nums2, 1 \u2264 x \u2227 x \u2264 1000)\n  (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  maxSum nums1 nums2 < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxsum_lower_bound (nums1 nums2 : List Nat)\n  (h1 : \u2200 x \u2208 nums1, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2 : \u2200 x \u2208 nums2, 1 \u2264 x \u2227 x \u2264 1000)\n  (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let common := sumCommonElements nums1 nums2\n  let unique1 := sumUniqueElements nums1 nums2\n  let unique2 := sumUniqueElements nums2 nums1\n  maxSum nums1 nums2 \u2265 min (unique1 + common) (unique2 + common) % (10^9 + 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval maxSum [2, 4, 5, 8, 10] [4, 6, 8, 9]\n\n/-\ninfo: 109\n-/\n#guard_msgs in\n#eval maxSum [1, 3, 5, 7, 9] [3, 5, 100]\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval maxSum [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]"
      }
    ]
  },
  "fvapps_000372.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_subarray_len (target : Nat) (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def slice (l : List Nat) (start : Nat) (len : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_subarray_len_empty {target : Nat} :\n  min_subarray_len target [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_subarray_len 7 [2, 3, 1, 2, 4, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 5 []\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_subarray_len 10 [1, 1, 1]"
      }
    ]
  },
  "fvapps_000374.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_malware_spread (graph : List (List Int)) (initial : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_in_initial {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  initial.contains result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get spread after removing a node -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def get_spread (graph : List (List Int)) (initial : List Int) (removed : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem smallest_among_equal_spreads {graph : List (List Int)} {initial : List Int} :\n  let result := min_malware_spread graph initial\n  \u2200 node : Int,\n    node \u2208 initial \u2192\n    node < result \u2192\n    get_spread graph initial node \u2265 get_spread graph initial result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_graph_properties {graph : List (List Int)} :\n  let n := graph.length\n  graph.length > 0 \u2192\n  (\u2200 row \u2208 graph, row.length = n) \u2192\n  (\u2200 (i j : Nat), i < n \u2192 j < n \u2192\n    (graph.get! i).get! j = (graph.get! i).get! j) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 0], [0, 0, 1]] [0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0], [1, 1, 1], [0, 1, 1]] [0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_malware_spread [[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]] [0, 1]"
      }
    ]
  },
  "fvapps_000379.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def split_array_same_average (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem split_array_verification {arr : List Int}\n  (h : split_array_same_average arr = true)\n  (h1 : arr.length \u2265 2)\n  (h2 : \u2200 x \u2208 arr, x \u2265 0 \u2227 x \u2264 100) :\n  \u2203 (subset1 subset2 : List Int),\n    subset1 \u2260 [] \u2227\n    subset2 \u2260 [] \u2227\n    (\u2200 x, x \u2208 subset1 \u2228 x \u2208 subset2 \u2194 x \u2208 arr) \u2227\n    (sum_list subset1) * subset2.length = (sum_list subset2) * subset1.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_false {x : Int} (h : x \u2265 1 \u2227 x \u2264 10) :\n  split_array_same_average [x] = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_elements_splittable {x : Int} {n : Nat}\n  (h : n \u2265 2) :\n  split_array_same_average (List.replicate n x) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [1, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval split_array_same_average [3, 1, 2]"
      }
    ]
  },
  "fvapps_000381.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def getMaxRepetitions (s1: String) (n1: Nat) (s2: String) (n2: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_subsequence (s1 s2: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_non_negative (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_positive_implies_common_chars (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 n1 s2 n2 > 0 \u2192 \u2203 c, c \u2208 s2.data \u2227 c \u2208 s1.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_in_n1 (s1: String) (n1: Nat) (s2: String) (n2: Nat) :\n  getMaxRepetitions s1 (n1 + 1) s2 n2 \u2265 getMaxRepetitions s1 n1 s2 n2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_in_s1_length (s1: String) (n1: Nat) (s2: String) (n2: Nat)\n  (h1: s1.length > 0) (h2: s2.length > 0) :\n  getMaxRepetitions (s1 ++ s1) n1 s2 n2 \u2265 getMaxRepetitions s1 n1 s2 n2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_string_division (s: String) :\n  getMaxRepetitions s 3 s 2 = 3 / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_match (s1: String) (n1: Nat) :\n  (\u2200 c, c \u2208 s1.data \u2192 c \u2260 'c') \u2192\n  getMaxRepetitions s1 n1 \"c\" 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"acb\" 4 \"ab\" 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"aaa\" 3 \"aa\" 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval getMaxRepetitions \"baba\" 2 \"ba\" 1"
      }
    ]
  },
  "fvapps_000382.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def numWays (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem numWays_non_negative (s : String) :\n  numWays s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numWays \"10101\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval numWays \"1001\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numWays \"0000\""
      }
    ]
  },
  "fvapps_000383.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_nth_ugly_number (n a b c : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_divisible (num a b c : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ugly_number_divisible (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  let result := find_nth_ugly_number n a b c\n  result % a = 0 \u2228 result % b = 0 \u2228 result % c = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ugly_number_positive (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ugly_number_min_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c \u2265 min a (min b c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ugly_number_max_bound (n a b c : Nat) (h1 : n > 0) (h2 : a > 0) (h3 : b > 0) (h4 : c > 0) :\n  find_nth_ugly_number n a b c \u2264 n * min a (min b c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ugly_number_equal_divisors (a : Nat) (h : a > 0) :\n  find_nth_ugly_number 1 a a a = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 3 2 3 5\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 4 2 3 4\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_nth_ugly_number 5 2 11 13"
      }
    ]
  },
  "fvapps_000384.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_moves_to_equal (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sort (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def median (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_non_negative (nums : List Int) :\n  0 \u2264 min_moves_to_equal nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_equal_median (nums : List Int) (h : nums \u2260 []) :\n  min_moves_to_equal nums = nums.foldl (fun acc x => acc + abs (x - median nums)) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_nums_zero_moves (n : Int) (nums : List Int) (h : \u2200 x \u2208 nums, x = n) :\n  min_moves_to_equal nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_invariant (nums : List Int) :\n  min_moves_to_equal nums = min_moves_to_equal (sort nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 1, 1]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 10, 2, 9]"
      }
    ]
  },
  "fvapps_000386.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def smallest_repunit_div_by_k (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any natural number k, smallest_repunit_div_by_k(k) is either -1 or between 1 and k inclusive -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_range (k : Nat) :\n  let result := smallest_repunit_div_by_k k\n  result = -1 \u2228 (1 \u2264 result \u2227 result \u2264 k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Certain numbers like 2,4,5,6,8,10 should return -1 as no repunit divides them -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem invalid_inputs :\n  smallest_repunit_div_by_k 2 = -1 \u2227\n  smallest_repunit_div_by_k 4 = -1 \u2227\n  smallest_repunit_div_by_k 5 = -1 \u2227\n  smallest_repunit_div_by_k 6 = -1 \u2227\n  smallest_repunit_div_by_k 8 = -1 \u2227\n  smallest_repunit_div_by_k 10 = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- If the result is not -1, then the repunit number of that length should be divisible by k -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_divisibility (k : Nat) (result : Int) :\n  smallest_repunit_div_by_k k = result \u2192\n  result \u2260 -1 \u2192\n  \u2203 repunit : Nat, repunit % k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval smallest_repunit_div_by_k 3"
      }
    ]
  },
  "fvapps_000389.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_valid_encoding (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_decodings (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def num_decodings (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_strings (s : String) :\n  is_valid_encoding s \u2192 num_decodings s = count_decodings s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_strings (s : String) :\n  \u00acis_valid_encoding s \u2192 num_decodings s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  num_decodings \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem starting_zero (s : String) :\n  s.length > 0 \u2192 s.front = '0' \u2192 num_decodings s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_valid_numbers (s : String) :\n  is_valid_encoding s \u2192 s.length \u2264 6 \u2192 num_decodings s = count_decodings s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_decodings \"12\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_decodings \"226\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval num_decodings \"06\""
      }
    ]
  },
  "fvapps_000390.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def largest_rectangle_area (heights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMaximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listModify (l : List Nat) (i : Nat) (f : Nat \u2192 Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_non_negative (heights : List Nat) :\n  0 \u2264 largest_rectangle_area heights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_upper_bound (heights : List Nat) :\n  heights \u2260 [] \u2192\n  largest_rectangle_area heights \u2264 (List.length heights) * (listMaximum heights) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_at_least_max_height (heights : List Nat) :\n  heights \u2260 [] \u2192\n  largest_rectangle_area heights \u2265 listMaximum heights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_empty (heights : List Nat) :\n  heights = [] \u2192\n  largest_rectangle_area heights = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_tall_column (heights : List Nat) :\n  heights \u2260 [] \u2192\n  let tall_height := (listMaximum heights) + 1\n  let new_heights := heights ++ [tall_height]\n  largest_rectangle_area new_heights \u2265 tall_height :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_rectangle_area_monotonic (heights : List Nat) (i : Nat) :\n  i < List.length heights \u2192\n  let increased := listModify heights i (\u00b7 + 1)\n  largest_rectangle_area increased \u2265 largest_rectangle_area heights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 5, 6, 2, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval largest_rectangle_area [2, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_rectangle_area []"
      }
    ]
  },
  "fvapps_000391.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxSumDivThree (nums: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (nums: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_divisible_by_3 (nums: List Nat) :\n  maxSumDivThree nums % 3 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_bounded (nums: List Nat) :\n  maxSumDivThree nums \u2264 sum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_nonnegative (nums: List Nat) :\n  maxSumDivThree nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_all_divisible (nums: List Nat)\n  (h: \u2200 n \u2208 nums, n % 3 = 0) :\n  maxSumDivThree nums = sum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_none_divisible (nums: List Nat)\n  (h1: nums \u2260 [])\n  (h2: \u2200 n \u2208 nums, n % 3 \u2260 0) :\n  maxSumDivThree nums \u2264 sum nums \u2227\n  maxSumDivThree nums % 3 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumDivThree_monotonic (nums: List Nat) :\n  maxSumDivThree nums \u2264 maxSumDivThree (nums ++ [3]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval maxSumDivThree [3, 6, 5, 1, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxSumDivThree [4]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval maxSumDivThree [1, 2, 3, 4, 4]"
      }
    ]
  },
  "fvapps_000394.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def array_stats (numbers: List Int) : Float \u00d7 Float \u00d7 Float \u00d7 Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl min h t)"
      },
      {
        "type": "sig",
        "string": "def listMax (xs : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | (h::t) => Float.ofInt (List.foldl max h t)"
      },
      {
        "type": "sig",
        "string": "def listSum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | (h::t) => h + listSum t"
      },
      {
        "type": "sig",
        "string": "def sorted (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_empty :\n  array_stats [] = (0, 0, 0, 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_mean (numbers: List Int) (h: numbers \u2260 []) :\n  let (mean, _, _, _) := array_stats numbers\n  (mean - Float.ofInt (listSum numbers) / Float.ofInt numbers.length).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_minmax (numbers: List Int) (h: numbers \u2260 []) :\n  let (_, _, min_val, max_val) := array_stats numbers\n  min_val = listMin numbers \u2227\n  max_val = listMax numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_ordering (numbers: List Int) (h: numbers \u2260 []) :\n  let (mean, median, min_val, max_val) := array_stats numbers\n  min_val \u2264 median \u2227 median \u2264 max_val \u2227\n  min_val \u2264 mean \u2227 mean \u2264 max_val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_median_even (numbers: List Int) (h: numbers \u2260 [])\n  (h2: numbers.length % 2 = 0) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt ((List.get! s ((numbers.length)/2 - 1)) + (List.get! s (numbers.length/2)))/2).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_stats_median_odd (numbers: List Int) (h: numbers \u2260 [])\n  (h2: numbers.length % 2 = 1) :\n  let (_, median, _, _) := array_stats numbers\n  let s := sorted numbers\n  (median - Float.ofInt (List.get! s (numbers.length/2))).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000398.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_best_value (arr : List Nat) (target : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_capped_vals (arr : List Nat) (cap : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (arr : List Nat) (h : arr \u2260 []) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_best_value_bounds {arr : List Nat} {target : Nat} (h : arr \u2260 []) :\n  let result := find_best_value arr target\n  0 \u2264 result \u2227 result \u2264 list_maximum arr h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_best_value_minimizes {arr : List Nat} {target : Nat} (h : arr \u2260 []) :\n  let result := find_best_value arr target\n  let curr_diff := abs (sum_capped_vals arr result - target)\n  let less := max 0 (result - 1)\n  let more := min (list_maximum arr h) (result + 1)\n  curr_diff \u2264 abs (sum_capped_vals arr less - target) \u2227\n  curr_diff \u2264 abs (sum_capped_vals arr more - target) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_best_value_target_one {arr : List Nat} (h : arr \u2260 []) :\n  let result := find_best_value arr 1\n  result = 0 \u2228 result = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_best_value [4, 9, 3] 10\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_best_value [2, 3, 5] 10\n\n/-\ninfo: 11361\n-/\n#guard_msgs in\n#eval find_best_value [60864, 25176, 27249, 21296, 20204] 56803"
      }
    ]
  },
  "fvapps_000400.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_power (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def getKth (lo hi k : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_power_always_terminates (x : Int)\n  (h : x \u2265 1) :\n  get_power x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem getKth_input_validation (lo hi k : Int)\n  (h1 : lo \u2265 1)\n  (h2 : hi \u2265 1)\n  (h3 : lo \u2264 hi)\n  (h4 : k \u2265 1)\n  (h5 : k \u2264 hi - lo + 1) :\n  lo \u2264 getKth lo hi k \u2227 getKth lo hi k \u2264 hi :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem getKth_sorting_property (lo hi : Int)\n  (h1 : lo \u2265 1)\n  (h2 : hi \u2265 1)\n  (h3 : lo \u2264 hi)\n  (k1 k2 : Int)\n  (h4 : k1 \u2265 1)\n  (h5 : k2 \u2265 1)\n  (h6 : k1 \u2264 hi - lo + 1)\n  (h7 : k2 \u2264 hi - lo + 1)\n  (h8 : k1 < k2) :\n  get_power (getKth lo hi k1) < get_power (getKth lo hi k2) \u2228\n  (get_power (getKth lo hi k1) = get_power (getKth lo hi k2) \u2227\n   getKth lo hi k1 \u2264 getKth lo hi k2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem getKth_single_element (x : Int)\n  (h : x \u2265 1) :\n  getKth x x 1 = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval getKth 12 15 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval getKth 7 11 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval getKth 1 1 1"
      }
    ]
  },
  "fvapps_000402.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numRollsToTarget (d f t : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def M := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem impossible_target (d f t : Nat) :\n  (t < d \u2228 t > d*f) \u2192 numRollsToTarget d f t = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_die_possible (f t : Nat) :\n  1 \u2264 t \u2227 t \u2264 f \u2192 numRollsToTarget 1 f t = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_die_impossible (f t : Nat) :\n  (t < 1 \u2228 t > f) \u2192 numRollsToTarget 1 f t = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem above_max_target (d f : Nat) :\n  numRollsToTarget d f (d*f+1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 1 6 3\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 6 7\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval numRollsToTarget 2 5 10"
      }
    ]
  },
  "fvapps_000403.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def break_palindrome (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def strRepeat (c : Char) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_palindrome (n : Nat) (h : n = 1) :\n  break_palindrome (strRepeat 'a' n) = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_a_string_breaks_to_b (s : String) (h\u2081 : s.length \u2265 2) (h\u2082 : \u2200 c \u2208 s.data, c = 'a') :\n  break_palindrome s = (s.dropRight 1).push 'b' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem break_gives_different_string (s : String) (h\u2081 : s.length \u2265 2) (h\u2082 : is_palindrome s = true) :\n  break_palindrome s \u2260 s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem break_gives_non_palindrome (s : String) (h\u2081 : s.length \u2265 2) (h\u2082 : is_palindrome s = true) :\n  is_palindrome (break_palindrome s) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem break_preserves_length (s : String) (h\u2081 : s.length \u2265 2) (h\u2082 : is_palindrome s = true) :\n  (break_palindrome s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'aaccba'\n-/\n#guard_msgs in\n#eval break_palindrome \"abccba\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval break_palindrome \"a\"\n\n/-\ninfo: 'ab'\n-/\n#guard_msgs in\n#eval break_palindrome \"aa\""
      }
    ]
  },
  "fvapps_000404.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_winner (arr : List Int) (k : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.maximum' (l : List Int) (h : l \u2260 []) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.findIndex (l : List Int) (p : Int \u2192 Bool) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sorted (l : List Int) (r : Int \u2192 Int \u2192 Bool) : Prop :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem winner_exists_in_array (arr : List Int) (h : arr \u2260 []) :\n  \u2200 k, k > 0 \u2192 get_winner arr k \u2208 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval get_winner [2, 1, 3, 5, 4, 6, 7] 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_winner [3, 2, 1] 10\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval get_winner [1, 9, 8, 2, 3, 7, 6, 4, 5] 7"
      }
    ]
  },
  "fvapps_000406.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def CatMouseGame (graph : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For a valid graph input, the output is either 0, 1 or 2 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def IsValidGraph (graph : List (List Nat)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  graph \u2260 [] \u2227\n  \u2200 neighbors \u2208 graph, \u2200 x \u2208 neighbors, x < graph.length"
      },
      {
        "type": "other",
        "string": "/- The cat-mouse game output range theorem only applies to valid graphs -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cat_mouse_game_output_range (graph : List (List Nat)) :\n  CatMouseGame graph = 0 \u2228 CatMouseGame graph = 1 \u2228 CatMouseGame graph = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- A graph is valid if:\n1. It is non-empty\n2. Each node's neighbors are valid indices into the graph -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cat_mouse_game_output_range_valid (graph : List (List Nat)) :\n  IsValidGraph graph \u2192\n  CatMouseGame graph = 0 \u2228 CatMouseGame graph = 1 \u2228 CatMouseGame graph = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval cat_mouse_game [[2, 5], [3], [0, 4, 5], [1, 4, 5], [2, 3], [0, 2, 3], [], []]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval cat_mouse_game [[1, 3], [0], [3], [0, 2]]"
      }
    ]
  },
  "fvapps_000407.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findMedianSortedArrays (nums1 : List Int) (nums2 : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def getMedian (l : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def mergeSorted (l1 l2 : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMedianSortedArrays_correct (nums1 nums2 : List Int)\n  (h : \u00ac(nums1.length = 0 \u2227 nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = getMedian (mergeSorted nums1 nums2) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMedianSortedArrays_symmetric (nums1 nums2 : List Int)\n  (h : \u00ac(nums1.length = 0 \u2227 nums2.length = 0)) :\n  findMedianSortedArrays nums1 nums2 = findMedianSortedArrays nums2 nums1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMedianSortedArrays_bounded (nums1 nums2 : List Int)\n  (h1 : \u2200 x \u2208 nums1, -1000 \u2264 x \u2227 x \u2264 1000)\n  (h2 : \u2200 x \u2208 nums2, -1000 \u2264 x \u2227 x \u2264 1000)\n  (h3 : \u00ac(nums1.length = 0 \u2227 nums2.length = 0)) :\n  -1000 \u2264 findMedianSortedArrays nums1 nums2 \u2227\n  findMedianSortedArrays nums1 nums2 \u2264 1000 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 3] #[2]\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1, 2] #[3, 4]\n\n/-\ninfo: 3.0\n-/\n#guard_msgs in\n#eval find_median_sorted_arrays #[1] #[2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_000410.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countVowels (s : String) : List Char \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def verifySubstringVowels (s : String) (start length : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findLongestEvenVowelSubstring (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid_length (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  0 \u2264 result \u2227 result \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_has_even_vowels (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  result > 0 \u2192\n  \u2203 i : Nat, i + result \u2264 s.length \u2227 verifySubstringVowels s i result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_longer_valid_substring_exists (s : String) :\n  let result := findLongestEvenVowelSubstring s\n  \u2200 length : Nat, result < length \u2192 length \u2264 s.length \u2192\n  \u2200 i : Nat, i + length \u2264 s.length \u2192\n  \u00ac(verifySubstringVowels s i length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_empty :\n  findLongestEvenVowelSubstring \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_single_nonvowel (c : Char) (h : c \u2209 ['a', 'e', 'i', 'o', 'u']) :\n  findLongestEvenVowelSubstring (String.mk [c]) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"eleetminicoworoep\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"leetcodeisgreat\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_longest_even_vowel_substring \"bcbcbc\""
      }
    ]
  },
  "fvapps_000412.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_longest_palindrome (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.isSubstringOf (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.substring (str : String) (start len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_longest_palindrome_is_substring (s : String) :\n  (find_longest_palindrome s).isSubstringOf s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_longest_palindrome_is_palindrome (s : String) :\n  (find_longest_palindrome s).isPalindrome = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_longest_palindrome_length (s : String) :\n  (find_longest_palindrome s).length \u2265 min 1 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_longest_palindrome_maximal (s : String) (start len : Nat) :\n  let substr := String.substring s start len\n  substr.isPalindrome = true \u2192 (find_longest_palindrome s).length \u2265 substr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nonempty_input_nonempty_output (s : String) (h : s.length > 0) :\n  (find_longest_palindrome s).length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_input_returns_itself (s : String) (h : s.isPalindrome = true) :\n  find_longest_palindrome s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"cbbd\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_longest_palindrome \"a\""
      }
    ]
  },
  "fvapps_000413.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longest_arithmetic_subsequence (arr: List Int) (diff: Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOccurrences (xs : List Int) (x : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxOccurrences (xs : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem las_length_bounded {arr: List Int} {diff: Int} :\n  arr \u2260 [] \u2192 longest_arithmetic_subsequence arr diff \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem las_non_negative {arr: List Int} {diff: Int} :\n  arr \u2260 [] \u2192 longest_arithmetic_subsequence arr diff \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem las_zero_diff {arr: List Int} :\n  arr \u2260 [] \u2192 longest_arithmetic_subsequence arr 0 = maxOccurrences arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem las_reverse_symmetry {arr: List Int} {diff: Int} :\n  arr \u2260 [] \u2192 diff > 0 \u2192\n    longest_arithmetic_subsequence arr diff =\n    longest_arithmetic_subsequence arr.reverse (-diff) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 2, 3, 4] 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 3, 5, 7] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_arithmetic_subsequence [1, 5, 7, 8, 5, 3, 4, 2, 1] -2"
      }
    ]
  },
  "fvapps_000416.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reordered_power_of_2 (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_powers_of_2 (max_digits : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sorted_digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem power_2_permutations_property {n : Nat} (h : reordered_power_of_2 n = true) :\n  \u2203 p, (p = 2^(Nat.log2 p)) \u2227 sorted_digits n = sorted_digits p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_property {n : Nat} (h : List.length (digits n) = 1) :\n  reordered_power_of_2 n = (n = 1 \u2228 n = 2 \u2228 n = 4 \u2228 n = 8) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem leading_zeros_property {n : Nat} (h : n < 10) :\n  reordered_power_of_2 n = reordered_power_of_2 (10 * n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval reordered_power_of_2 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval reordered_power_of_2 16"
      }
    ]
  },
  "fvapps_000421.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_subarray_mins (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_subarray_mins_non_negative (nums : List Nat) :\n  sum_subarray_mins nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_subarray_mins_modulo_bound (nums : List Nat) :\n  sum_subarray_mins nums < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_subarray_mins_singleton (n : Nat) :\n  sum_subarray_mins [n] = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_subarray_mins_min_bound {nums : List Nat} (h : nums.length \u2265 2) :\n  sum_subarray_mins nums \u2265 list_min nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_subarray_mins_append_larger {nums : List Nat} (h : nums.length \u2265 2) :\n  let max := list_max nums\n  sum_subarray_mins (nums ++ [max + 1]) % (10^9 + 7) \u2265 sum_subarray_mins nums % (10^9 + 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 17\n-/\n#guard_msgs in\n#eval sum_subarray_mins [3, 1, 2, 4]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_subarray_mins [1]\n\n/-\ninfo: 444\n-/\n#guard_msgs in\n#eval sum_subarray_mins [11, 81, 94, 43, 3]"
      }
    ]
  },
  "fvapps_000431.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def consecutive_numbers_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSquare (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_always_positive (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_less_than_input (n : Nat) (h : n > 0) :\n  consecutive_numbers_sum n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_edge_cases :\n  consecutive_numbers_sum 1 = 1 \u2227\n  consecutive_numbers_sum 2 = 1 \u2227\n  consecutive_numbers_sum 3 = 2 \u2227\n  consecutive_numbers_sum 4 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 9\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval consecutive_numbers_sum 15"
      }
    ]
  },
  "fvapps_000439.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findMin (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def rotateList (xs : List Int) (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMin_singleton (n : Int) :\n  findMin [n] = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMin_pair (a b : Int) :\n  findMin [a, b] = min a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMin_triple (a b c : Int) :\n  findMin [a, b, c] = min (min a b) c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findMin_rotated_sorted_unique {nums : List Int} (h1 : nums.length \u2265 4)\n    (h2 : List.Pairwise (\u00b7 \u2260 \u00b7) nums) (h3 : \u2200 x \u2208 nums, -100 \u2264 x \u2227 x \u2264 100) :\n  findMin (rotateList nums (nums.length / 2)) = listMin nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [3, 4, 5, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval findMin [4, 5, 6, 7, 0, 1, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval findMin [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_000440.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isContinuationByte (x : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countRequiredBytes (firstByte : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def validUtf8 (data : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_utf8_property (data : List Nat) (h : \u2200 x \u2208 data, x \u2264 255) :\n  validUtf8 data = true \u2192\n  \u2203 i : Nat,\n    i < data.length \u2227\n    let required := countRequiredBytes (data.get \u27e8i, sorry\u27e9)\n    required \u2265 0 \u2227\n    i + required < data.length \u2227\n    \u2200 j, i + 1 \u2264 j \u2227 j \u2264 i + required \u2192\n      isContinuationByte (data.get \u27e8j, sorry\u27e9) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_utf8_property_contra (data : List Nat) (h : \u2200 x \u2208 data, x \u2264 255) :\n  validUtf8 data = false \u2192\n  \u2203 i : Nat,\n    i < data.length \u2227\n    (countRequiredBytes (data.get \u27e8i, sorry\u27e9) < 0 \u2228\n     i + countRequiredBytes (data.get \u27e8i, sorry\u27e9) \u2265 data.length \u2228\n     \u2203 j, i + 1 \u2264 j \u2227 j \u2264 i + countRequiredBytes (data.get \u27e8i, sorry\u27e9) \u2227\n       isContinuationByte (data.get \u27e8j, sorry\u27e9) = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ascii_always_valid (data : List Nat) (h : \u2200 x \u2208 data, x \u2264 127) :\n  validUtf8 data = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem continuation_bytes_invalid (data : List Nat) (h1 : data \u2260 [])\n    (h2 : \u2200 x \u2208 data, x \u2265 128 \u2227 x \u2264 191) :\n  validUtf8 data = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [197, 130, 1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_utf8 [235, 140, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [240, 162, 138, 147]"
      }
    ]
  },
  "fvapps_000442.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_difficulty (difficulties: List Nat) (days: Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| [x] => x\n| x::xs => max x (list_maximum xs)"
      },
      {
        "type": "sig",
        "string": "def list_sort (l: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| x::xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem min_difficulty_invalid_days {difficulties : List Nat} {days : Nat} :\n  days > difficulties.length \u2192 min_difficulty difficulties days = -1\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difficulty_lb_max {difficulties : List Nat} {days : Nat} :\n  days \u2264 difficulties.length \u2192\n  min_difficulty difficulties days \u2265 0 \u2192\n  min_difficulty difficulties days \u2265 list_maximum difficulties\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difficulty_lb_sum_min {difficulties : List Nat} {days : Nat} :\n  days \u2264 difficulties.length \u2192\n  min_difficulty difficulties days \u2265 0 \u2192\n  min_difficulty difficulties days \u2265 list_sum (List.take days (list_sort difficulties))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difficulty_single_day {difficulties : List Nat} :\n  difficulties.length > 0 \u2192\n  min_difficulty difficulties 1 = list_maximum difficulties\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difficulty_monotonic {difficulties : List Nat} {days : Nat} :\n  days > 1 \u2192\n  days \u2264 difficulties.length \u2192\n  min_difficulty difficulties days \u2265 0 \u2192\n  min_difficulty difficulties (days-1) \u2265 0 \u2192\n  min_difficulty difficulties days \u2265 min_difficulty difficulties (days-1)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_difficulty [6, 5, 4, 3, 2, 1] 2\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_difficulty [9, 9, 9] 4\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difficulty [1, 1, 1] 3"
      }
    ]
  },
  "fvapps_000444.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum_swap (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countDigit (d n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_swap_result_ge (n : Nat) :\n  maximum_swap n \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_swap_edge_cases :\n  maximum_swap 0 = 0 \u2227\n  maximum_swap 1 = 1 \u2227\n  maximum_swap 10 = 10 \u2227\n  maximum_swap 99 = 99 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7236\n-/\n#guard_msgs in\n#eval maximum_swap 2736\n\n/-\ninfo: 9973\n-/\n#guard_msgs in\n#eval maximum_swap 9973\n\n/-\ninfo: 9913\n-/\n#guard_msgs in\n#eval maximum_swap 1993"
      }
    ]
  },
  "fvapps_000445.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Grid := List (List Nat)\n\ndef isPrintable (grid: Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidGrid (grid: Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match grid with\n  | [] => false\n  | row::rows =>\n    match row with\n    | [] => false\n    | _::_ =>\n      let width := row.length\n      rows.all (\u03bb r => r.length = width)"
      },
      {
        "type": "cond",
        "string": "theorem grid_validity {grid: Grid} (h: isValidGrid grid) :\n  \u2203 (row: List Nat) (rows: List (List Nat)), grid = row::rows :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem printable_returns_bool (grid: Grid) :\n  isPrintable grid = true \u2228 isPrintable grid = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_color_printable {grid: Grid} (h1: isValidGrid grid)\n  (h2: \u2200 (i j: Nat) (hi: i < grid.length) (hj: j < (grid.get \u27e8i, hi\u27e9).length),\n    (grid.get \u27e8i, hi\u27e9).get \u27e8j, hj\u27e9 = 1) :\n  isPrintable grid = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem symmetric_grid_printable_rotation {grid: Grid} {n: Nat}\n  (h1: isValidGrid grid)\n  (h2: grid.length = n)\n  (h3: \u2200 (i: Nat) (hi: i < grid.length),\n    (grid.get \u27e8i, hi\u27e9).length = n) :\n  isPrintable grid = isPrintable (List.map List.reverse grid).reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_cases :\n  (isPrintable [[1,1], [1,1]] = true) \u2227\n  (isPrintable [[1]] = true) \u2227\n  (isPrintable [[1,2], [2,1]] = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isPrintable [[1, 1, 1, 1], [1, 1, 3, 3], [1, 1, 3, 4], [5, 5, 1, 4]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isPrintable [[1, 2, 1], [2, 1, 2], [1, 2, 1]]"
      }
    ]
  },
  "fvapps_000452.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countServers (grid : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_grid (grid : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_ones (grid : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countServers_non_negative (grid : List (List Nat)) :\n  is_valid_grid grid \u2192 countServers grid \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countServers_upper_bound (grid : List (List Nat)) :\n  is_valid_grid grid \u2192 countServers grid \u2264 count_ones grid :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_server_result (grid : List (List Nat)) :\n  is_valid_grid grid \u2192 count_ones grid = 1 \u2192 countServers grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_grid_zero {m n : Nat} (grid : List (List Nat)) :\n  m > 0 \u2192 n > 0 \u2192\n  grid = List.replicate m (List.replicate n 0) \u2192\n  countServers grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem full_grid_count {n : Nat} (grid : List (List Nat)) :\n  n \u2265 2 \u2192\n  grid = List.replicate n (List.replicate n 1) \u2192\n  countServers grid = n * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem diagonal_only_zero {n : Nat} (grid : List (List Nat)) :\n  n \u2265 2 \u2192\n  grid = List.map\n    (fun i => List.map (fun j => if i = j then 1 else 0) (List.range n))\n    (List.range n) \u2192\n  countServers grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [0, 1]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval countServers [[1, 0], [1, 1]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval countServers [[1, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1]]"
      }
    ]
  },
  "fvapps_000453.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 0 then n else -n"
      },
      {
        "type": "sig",
        "string": "def maxValueAfterReverse (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def diffSum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match nums with\n  | [] => 0\n  | [_] => 0\n  | x :: xs => List.foldl (fun acc (pair : Int \u00d7 Int) => acc + abs (pair.1 - pair.2)) 0 (List.zip (x::xs) xs)"
      },
      {
        "type": "cond",
        "string": "theorem maxValueAfterReverse_nonnegative (nums : List Int) :\n  maxValueAfterReverse nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxValueAfterReverse_geq_base (nums : List Int) :\n  maxValueAfterReverse nums \u2265 diffSum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxValueAfterReverse_small_lists {nums : List Int} (h : nums.length \u2264 2) :\n  match nums with\n  | [] => maxValueAfterReverse nums = 0\n  | [_] => maxValueAfterReverse nums = 0\n  | [x, y] => maxValueAfterReverse nums = abs (x - y)\n  | _ => True\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxValueAfterReverse_monotonic_defined (nums : List Int) (h : nums.length \u2265 3) :\n  \u2203 (n n' : Int), maxValueAfterReverse nums = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 3, 1, 5, 4]\n\n/-\ninfo: 68\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [2, 4, 9, 24, 2, 1, 10]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval maxValueAfterReverse [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_000465.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def range_sum (nums : List Nat) (n : Nat) (left right : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def partialSums (nums : List Nat) (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem range_sum_output_properties {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : \u2200 x \u2208 nums, x \u2265 1 \u2227 x \u2264 1000)\n  (h4 : left \u2265 1 \u2227 right \u2265 1)\n  (h5 : left \u2264 20 \u2227 right \u2264 20) :\n  let result := range_sum nums n left right\n  result \u2265 0 \u2227 result < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem range_sum_monotonic {nums : List Nat} {n left right : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : left < right)\n  (h4 : right \u2264 n) :\n  range_sum nums n left (right-1) \u2264 range_sum nums n left right :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem range_sum_single_element {nums : List Nat} {n k : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : k \u2264 n)\n  (h4 : k > 0) :\n  let pSums := partialSums nums n\n  \u2200 h : k - 1 < pSums.length,\n  range_sum nums n k k = pSums.get \u27e8k-1, h\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem range_sum_full_range {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty)\n  (h3 : \u2200 x \u2208 nums, x \u2265 1 \u2227 x \u2264 100) :\n  range_sum nums n 1 (n * (n+1) / 2) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem range_sum_first_element {nums : List Nat} {n : Nat}\n  (h1 : nums.length = n)\n  (h2 : !nums.isEmpty) :\n  range_sum nums n 1 1 = listMin nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 5\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 3 4\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval range_sum [1, 2, 3, 4] 4 1 10"
      }
    ]
  },
  "fvapps_000474.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def primePalindrome (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem primePalindrome_geq_input\n  (n : Nat)\n  (h1 : n \u2265 2)\n  (h2 : n \u2264 19990) :\n  primePalindrome n \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval primePalindrome 6\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval primePalindrome 8\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval primePalindrome 13"
      }
    ]
  },
  "fvapps_000476.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bin (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def query_string (s : String) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstring (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem query_string_with_all_prefixes (n : Nat) (h : 0 < n \u2227 n \u2264 20) :\n  let binary_nums := String.join (List.map bin (List.range n))\n  query_string binary_nums n = true\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem query_string_correct (s : String) (n : Nat) (h : 0 < n \u2227 n \u2264 20) :\n  query_string s n = true \u2194\n    \u2200 i : Nat, 1 \u2264 i \u2227 i \u2264 n \u2192 containsSubstring s (bin i)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"0110\" 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval query_string \"0110\" 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval query_string \"11011\" 2"
      }
    ]
  },
  "fvapps_000477.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def kth_smallest_in_sorted_matrix (matrix : List (List Int)) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_sorted (row : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_matrix_sorted (matrix : List (List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_rows_handled_raises\n  (matrix : List (List Int))\n  (h1 : matrix = [] \u2228 \u00ac\u2203row \u2208 matrix, row \u2260 []) :\n  \u2200k, k \u2260 0 \u2192 kth_smallest_in_sorted_matrix matrix k = default :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15]] 8\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 2], [3, 4]] 3\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval kth_smallest_in_sorted_matrix [[1, 5, 9], [10, 11, 13], [12, 13, 15], [], []] 8"
      }
    ]
  },
  "fvapps_000478.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_width_ramp (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x \u2264 y && isSorted (y::rest)"
      },
      {
        "type": "sig",
        "string": "def isStrictlyDecreasing (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x > y && isStrictlyDecreasing (y::rest)"
      },
      {
        "type": "sig",
        "string": "def hasNoDups (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | x::xs => !(xs.contains x) && hasNoDups xs"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_non_negative (nums : List Int) :\n  max_width_ramp nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_upper_bound (nums : List Int) :\n  max_width_ramp nums \u2264 max 0 (nums.length - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_small_lists (nums : List Int) :\n  nums.length \u2264 1 \u2192 max_width_ramp nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_valid_ramp_exists (nums : List Int) (h : max_width_ramp nums > 0) :\n  \u2203 i j, \u2203 (hi : i < nums.length) (hj : j < nums.length),\n         i < j \u2227 j - i \u2265 max_width_ramp nums \u2227\n         (nums.get \u27e8i, hi\u27e9) \u2264 (nums.get \u27e8j, hj\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_monotonic_increasing (nums : List Int) :\n  nums.length > 1 \u2192\n  isSorted nums = true \u2192\n  max_width_ramp nums = nums.length - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_width_ramp_strictly_decreasing (nums : List Int) :\n  nums.length > 0 \u2192\n  isStrictlyDecreasing nums = true \u2192\n  hasNoDups nums = true \u2192\n  max_width_ramp nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_width_ramp [6, 0, 8, 2, 1, 5]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_width_ramp [9, 8, 1, 0, 1, 9, 4, 0, 4, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_width_ramp [1, 0]"
      }
    ]
  },
  "fvapps_000481.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def strWithout3a3b (a b : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def contains_substring (s main : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_string (s : String) (a_count b_count : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  count_char s 'a' = a_count \u2227\n  count_char s 'b' = b_count \u2227\n  \u00accontains_substring \"aaa\" s \u2227\n  \u00accontains_substring \"bbb\" s"
      },
      {
        "type": "cond",
        "string": "theorem equal_counts {n : Nat} (h : n > 0) :\n  let s := strWithout3a3b n n\n  is_valid_string s n n \u2227 s.length = 2 * n\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem double_a_count {n : Nat} :\n  let s := strWithout3a3b (2 * n) n\n  is_valid_string s (2 * n) n \u2227 s.length = 3 * n\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_000483.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longestDecomposition (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isReversed (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def allCharsSame (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem decomposition_length {s : String} (h : s \u2260 \"\") :\n  1 \u2264 longestDecomposition s \u2227 longestDecomposition s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenated_decomposition {s : String} (h : s \u2260 \"\") :\n  longestDecomposition (s ++ s) \u2265 2 * longestDecomposition s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval longestDecomposition \"ghiabcdefhelloadamhelloabcdefghi\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longestDecomposition \"merchant\"\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval longestDecomposition \"antaprezatepzapreanta\""
      }
    ]
  },
  "fvapps_000484.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def lastStoneWeightII (stones : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sum xs"
      },
      {
        "type": "cond",
        "string": "theorem lastStoneWeight_nonNegative (stones : List Nat) :\n  lastStoneWeightII stones \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lastStoneWeight_upperBound (stones : List Nat) :\n  lastStoneWeightII stones \u2264 sum stones :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lastStoneWeight_identical_pairs (stones : List Nat) :\n  stones.length = 2 \u2192 stones[0]! = stones[1]! \u2192 lastStoneWeightII stones = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lastStoneWeight_single_stone (stones : List Nat) (x : Nat) :\n  stones = [x] \u2192 lastStoneWeightII stones = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lastStoneWeight_identical_values (stones : List Nat) (x : Nat) :\n  (\u2200 i, i < stones.length \u2192 stones[i]! = x) \u2192 lastStoneWeightII stones \u2264 x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 7, 4, 1, 8, 1]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval lastStoneWeightII [1, 1, 1]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval lastStoneWeightII [2, 2]"
      }
    ]
  },
  "fvapps_000485.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_increment_for_unique (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sorted (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def makeUnique (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_increment_nonneg (nums : List Int) :\n  min_increment_for_unique nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_increment_empty (nums : List Int) :\n  nums = [] \u2192 min_increment_for_unique nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_increment_single (nums : List Int) (x : Int) :\n  nums = [x] \u2192 min_increment_for_unique nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_increment_sort_invariant (nums : List Int) :\n  min_increment_for_unique nums = min_increment_for_unique (sorted nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_increment_makes_unique (nums : List Int) :\n  let result := sorted nums\n  let incremented := makeUnique result\n  min_increment_for_unique nums = (sumList incremented - sumList result) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_increment_for_unique [1, 2, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_increment_for_unique [3, 2, 1, 2, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_increment_for_unique []"
      }
    ]
  },
  "fvapps_000490.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shortest_palindrome (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringReverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_contains_original (s : String) :\n  (shortest_palindrome s).endsWith s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_is_palindrome (s : String) :\n  isPalindrome (shortest_palindrome s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_minimal_length (s : String) :\n  (shortest_palindrome s).length \u2264 2 * s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_empty_single_char (s : String) :\n  s = \"\" \u2228 s.length = 1 \u2192 shortest_palindrome s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_starts_with_reversed_suffix (s : String) :\n  s \u2260 \"\" \u2192\n  let result := shortest_palindrome s\n  let suffixLen := result.length - s.length\n  suffixLen > 0 \u2192\n  (result.take suffixLen) = stringReverse (s.takeRight suffixLen) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_palindrome_single_char_string (s : String) (c : Char) :\n  s.all (\u00b7 = c) \u2192 shortest_palindrome s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'aaacecaaa'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"aacecaaa\"\n\n/-\ninfo: 'dcbabcd'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"abcd\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval shortest_palindrome \"a\""
      }
    ]
  },
  "fvapps_000494.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validParens (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSubsequence (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minRemoveToMakeValid (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "inductive CharIn (s : String) where\n  | mk (c : Char) (h : s.data.contains c) : CharIn s\n\n-- All chars in result are valid"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_contains_valid_chars (s : String) :\n  \u2200 c, (minRemoveToMakeValid s).data.contains c \u2192\n    c = '(' \u2228 c = ')' \u2228 c = 'a' \u2228 c = 'b' \u2228 c = 'c' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result has balanced parentheses"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_has_balanced_parens (s : String) :\n  validParens (minRemoveToMakeValid s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is a subsequence of input"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_is_subsequence (s : String) :\n  isSubsequence (minRemoveToMakeValid s) s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Strings without parens are unchanged"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem no_parens_unchanged (s : String) :\n  (\u2200 c, s.data.contains c \u2192 c \u2260 '(' \u2227 c \u2260 ')') \u2192\n  minRemoveToMakeValid s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty string case"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  minRemoveToMakeValid \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Only open brackets become empty"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem only_open_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n '(')) = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Only close brackets become empty"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem only_close_brackets (n : Nat) :\n  minRemoveToMakeValid (String.mk (List.replicate n ')')) = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'lee(t(c)o)de'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"lee(t(c)o)de)\"\n\n/-\ninfo: 'ab(c)d'\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"a)b(c)d\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval minRemoveToMakeValid \"))((\""
      }
    ]
  },
  "fvapps_000497.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_intersection (arr1 arr2 : List Int) : List Int := sorry\n\ndef isSortedList (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "sig",
        "string": "def sortList (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem self_intersection {arr : List Int} :\n  get_intersection arr arr = sortList arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem intersection_sorted {arr1 arr2 : List Int} :\n  isSortedList (get_intersection arr1 arr2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem intersection_elements_in_both {arr1 arr2 : List Int} (x : Int) :\n  x \u2208 get_intersection arr1 arr2 \u2192 x \u2208 arr1 \u2227 x \u2208 arr2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem intersection_count_bound {arr1 arr2 : List Int} (x : Int) :\n  (get_intersection arr1 arr2).count x \u2264 min (arr1.count x) (arr2.count x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_intersection_left {arr : List Int} :\n  get_intersection [] arr = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_intersection_right {arr : List Int} :\n  get_intersection arr [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem intersection_commutative {arr1 arr2 : List Int} :\n  get_intersection arr1 arr2 = get_intersection arr2 arr1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000504.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def modular_pow (base exponent modulus : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_totient_ratio (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_totient_ratio_small_values :\n  find_max_totient_ratio 2 = 2 \u2227\n  find_max_totient_ratio 4 = 3 \u2227\n  find_max_totient_ratio 10 = 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_totient_ratio 4"
      }
    ]
  },
  "fvapps_000505.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_inversions (arr : List Nat) (n : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_non_negative (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sorted (xs : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 i < xs.length \u2192 j < xs.length \u2192\n    xs[i]! \u2264 xs[j]!"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_sorted_zero (arr : List Nat) (n : Nat) (m : Nat) :\n  sorted arr \u2192 count_inversions arr n m = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_scale_invariant (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m = count_inversions (List.map (\u00b7 * 2) arr) n m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_monotone (arr : List Nat) (n : Nat) (m1 m2 : Nat) :\n  m1 \u2264 m2 \u2192 count_inversions arr n m1 \u2264 count_inversions arr n m2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_single_element (n m : Nat) (a : Nat) :\n  count_inversions [a] n m = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_inversions_same_elements (n m a : Nat) :\n  count_inversions [a,a,a] n m = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval count_inversions [2, 1, 3] 3 3\n\n/-\ninfo: 30000\n-/\n#guard_msgs in\n#eval count_inversions [99, 2, 1000, 24] 4 100"
      }
    ]
  },
  "fvapps_000513.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def perfect_square_range_query (arr : List Nat) (queries : List (Nat \u00d7 Nat \u00d7 Nat)) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_perfect_square (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def product_range (arr : List Nat) (s e : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem query_response_format\n  (arr : List Nat) (queries : List (Nat \u00d7 Nat \u00d7 Nat)) :\n  let result := perfect_square_range_query arr queries\n  let type_1_count := (queries.filter (fun q => q.fst = 1)).length\n  result.length = type_1_count \u2227\n  result.all (fun r => r = \"YES\" \u2228 r = \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_update_consistency\n  (arr : List Nat) (queries : List (Nat \u00d7 Nat \u00d7 Nat)) (i : Nat) (h : i < queries.length) :\n  let result := perfect_square_range_query arr queries\n  let q := queries[i]'h\n  (q.fst = 1 \u2192\n    let product := product_range arr (q.2.1 - 1) (q.2.2)\n    (result[i]? = some \"YES\") = is_perfect_square product) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_range\n  (arr : List Nat) (i : Nat) (h : i < arr.length) :\n  let queries := List.range arr.length |>.map (fun i => (1, i+1, i+1))\n  let result := perfect_square_range_query arr queries\n  result[i]? = some (if is_perfect_square (arr[i]'h) then \"YES\" else \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000520.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_antimatching (n m : Nat) (edges : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def vertex_degree (v : Nat) (edges : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem antimatching_nonnegative (n m : Nat) (edges : List (Nat \u00d7 Nat)) :\n  solve_antimatching n m edges \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem antimatching_empty_graph (n : Nat) :\n  solve_antimatching n 0 [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem antimatching_single_vertex :\n  solve_antimatching 1 0 [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem antimatching_single_edge :\n  solve_antimatching 2 1 [(1,2)] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem antimatching_triangle :\n  solve_antimatching 3 3 [(1,2), (2,3), (1,3)] = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_antimatching 3 3 [(1, 2), (1, 3), (2, 3)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_antimatching 4 2 [(1, 2), (3, 4)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_antimatching 5 0 []"
      }
    ]
  },
  "fvapps_000526.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_largest_subset_with_mex (n m : Nat) (arr : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def mex (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_subset_result_valid (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_subset_result_cases (n m : Nat) (arr : List Nat) :\n  let result := find_largest_subset_with_mex n m arr\n  (result = -1 \u2228 result = n \u2228 result = n - (List.count m arr)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 3 [1, 2, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 4 2 [1, 3, 4, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_subset_with_mex 3 5 [1, 2, 3]"
      }
    ]
  },
  "fvapps_000532.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_ball_bounces (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPowerOfTwo (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allOnesInBinary (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOnesInBinary (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_negative_result (distance : Nat) :\n  count_ball_bounces distance \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 13\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ball_bounces 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ball_bounces 16"
      }
    ]
  },
  "fvapps_000540.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_sequence_length (n : Nat) (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_fibonacci_sequence (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let rec helper (i : Nat) (curr_max curr_fib : Nat) : Nat :=\n    if i \u2265 arr.length then curr_max\n    else match arr.get? i, arr.get? (i-1), arr.get? (i-2) with\n    | some x, some y, some z =>\n      if x = y + z then\n        helper (i+1) (max curr_max (curr_fib + 1)) (curr_fib + 1)\n      else\n        helper (i+1) curr_max 2\n    | _, _, _ => curr_max\n  termination_by arr.length - i\n  helper 2 2 2"
      },
      {
        "type": "cond",
        "string": "theorem find_max_sequence_length_empty :\n  find_max_sequence_length 0 [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 5 [2, 3, 5, 1, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_sequence_length 3 [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_sequence_length 2 [1, 2]"
      }
    ]
  },
  "fvapps_000541.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_robot_position (t : Nat) : Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def manhattan_distance (x y : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  Int.natAbs x + Int.natAbs y"
      },
      {
        "type": "cond",
        "string": "theorem coordinates_are_integers (t : Nat) (h : t > 0) :\n  let (x, y) := find_robot_position t\n  True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem position_uniqueness (t : Nat) (h : t > 0) :\n  find_robot_position t = find_robot_position t :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_position_is_up :\n  find_robot_position 1 = (0, 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (0, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 1\n\n/-\ninfo: (-1, 1)\n-/\n#guard_msgs in\n#eval find_robot_position 2\n\n/-\ninfo: (2, 4)\n-/\n#guard_msgs in\n#eval find_robot_position 50"
      }
    ]
  },
  "fvapps_000555.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n"
      },
      {
        "type": "sig",
        "string": "def count_distinct_sequences (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsChar (s : String) (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.data.contains c"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_basic_properties (s : String) :\n  let result := count_distinct_sequences s\n  result \u2264 factorial s.length \u2227\n  0 < result \u2227\n  result = result\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_special_substring (s : String) :\n  let result := count_distinct_sequences s\n  ((containsChar s 'k' \u2227 containsChar s 'a' \u2227 containsChar s 'r') \u2228\n   (containsChar s 's' \u2227 containsChar s 'h' \u2227 containsChar s 'i')) \u2192\n  result < factorial s.length\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_karshi_all_letters (s : String) :\n  let result := count_distinct_sequences s\n  (containsChar s 'k' \u2227 containsChar s 'a' \u2227 containsChar s 'r' \u2227\n   containsChar s 's' \u2227 containsChar s 'h' \u2227 containsChar s 'i') \u2192\n  result < factorial s.length - factorial (s.length - 2)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_exact_karshi (s : String) :\n  s.length = 6 \u2192\n  (s.data.toArray.qsort (\u00b7 < \u00b7) = \"karshi\".data.toArray.qsort (\u00b7 < \u00b7)) \u2192\n  count_distinct_sequences s = factorial 6 - 2 * factorial 4\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_length_properties (s : String) :\n  let result := count_distinct_sequences s\n  (s.length \u2264 2 \u2192 result = factorial s.length) \u2227\n  (s.length > 6 \u2227 containsChar s 'k' \u2227 containsChar s 'a' \u2227\n   containsChar s 'r' \u2227 containsChar s 's' \u2227 containsChar s 'h' \u2227\n   containsChar s 'i' \u2192\n    result = factorial s.length - 2 * factorial (s.length - 2) + factorial (s.length - 4))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"karp\"\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval count_distinct_sequences \"abcd\""
      }
    ]
  },
  "fvapps_000556.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reduce_recipe (ingredients : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcdl (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reduce_recipe_proportions (ingredients : List Nat)\n  (h : \u2200 x \u2208 ingredients, x > 0) :\n  let result := reduce_recipe ingredients\n  \u2200 i j, i < ingredients.length \u2192 j < ingredients.length \u2192\n    ingredients[i]! * result[j]! = ingredients[j]! * result[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reduce_recipe_gcd (ingredients : List Nat)\n  (h : \u2200 x \u2208 ingredients, x > 0) :\n  gcdl (reduce_recipe ingredients) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_divides (a b : Nat) (h\u2081 : a > 0) (h\u2082 : b > 0) :\n  let g := gcd a b\n  g \u2223 a \u2227 g \u2223 b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_commutative (a b : Nat) (h\u2081 : a > 0) (h\u2082 : b > 0) :\n  gcd a b = gcd b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reduce_recipe_nat (ingredients : List Nat)\n  (h : \u2200 x \u2208 ingredients, x > 0) :\n  \u2200 x, x \u2208 reduce_recipe ingredients \u2192 x > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval reduce_recipe [4, 4]\n\n/-\ninfo: [2, 3, 4]\n-/\n#guard_msgs in\n#eval reduce_recipe [2, 3, 4]\n\n/-\ninfo: [1, 5, 3, 2]\n-/\n#guard_msgs in\n#eval reduce_recipe [3, 15, 9, 6]"
      }
    ]
  },
  "fvapps_000559.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_subarray (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_positive_returns_full_array {arr : List Int}\n  (h : \u2200 x \u2208 arr, x \u2265 0) (nonempty : arr \u2260 []) :\n  find_max_subarray arr = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_subarrays_bounded_by_negatives (arr : List Int) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_is_maximal {arr : List Int} (nonempty : arr \u2260 []) :\n  let result := find_max_subarray arr\n  let result_sum := sum_list result\n  \u2200 subarray \u2208 all_subarrays_bounded_by_negatives arr,\n    sum_list subarray \u2264 result_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000567.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_make_sequence_good (n : Nat) (sequence : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_nonnegative (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_negative (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_result_is_yes_or_no (n : Nat) (sequence : List Int) :\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" \u2228 result = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem yes_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"YES\" \u2192\n  sum_nonnegative sequence \u2265 Int.natAbs (sum_negative sequence) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_case_sums_property (n : Nat) (sequence : List Int) :\n  can_make_sequence_good n sequence = \"NO\" \u2192\n  sum_nonnegative sequence < Int.natAbs (sum_negative sequence) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_sequence (x : Int) :\n  can_make_sequence_good 1 [x] = (if x \u2265 0 then \"YES\" else \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_length_valid (sequence : List Int) :\n  let n := sequence.length\n  let result := can_make_sequence_good n sequence\n  result = \"YES\" \u2228 result = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 1 [-1]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 2 [1, 2]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_make_sequence_good 3 [1, -2, 3]"
      }
    ]
  },
  "fvapps_000569.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_evil_sorcerer (n : Nat) (p : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_evil_sorcerer_properties {n : Nat} {p : List Nat}\n  (n_pos : n > 0) (p_pos : \u2200 x \u2208 p, x > 0) :\n  let result := solve_evil_sorcerer n p\n  -- Result is non-negative\n  result \u2265 0 \u2227\n  -- Result is less than or equal to n\n  result \u2264 n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_properties {a b : Nat} (a_pos : a > 0) (b_pos : b > 0) :\n  let g := gcd a b\n  -- GCD divides both numbers\n  (a % g = 0 \u2227 b % g = 0) \u2227\n  -- GCD is positive\n  g > 0 \u2227\n  -- GCD is largest such number\n  \u2200 i, g < i \u2192 i \u2264 min a b \u2192 \u00ac(a % i = 0 \u2227 b % i = 0) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 4 [5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 6 [2, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_evil_sorcerer 1 [20201220]"
      }
    ]
  },
  "fvapps_000572.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if x \u2265 0 then x else -x"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def minPizzaCuts (n : Nat) (angles : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- GCD theorems"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem gcd_positive {a b : Int} (h : a \u2260 0 \u2228 b \u2260 0) :\n  gcd (abs a) (abs b) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_divides {a b : Int} :\n  let d := gcd (abs a) (abs b)\n  (a \u2260 0 \u2192 abs a % d = 0) \u2227\n  (b \u2260 0 \u2192 abs b % d = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Pizza cuts theorems"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem minPizzaCuts_nonnegative {n : Nat} {angles : List Nat} :\n  minPizzaCuts n angles \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPizzaCuts_upper_bound {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles + n \u2264 360 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPizzaCuts_rotation_invariant {n : Nat} {angles : List Nat}\n  (h : List.length angles = n) :\n  minPizzaCuts n angles =\n  minPizzaCuts n (List.map (fun x => (x + 45) % 360) angles) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_pizza_cuts 4 [0, 90, 180, 270]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [90, 210]\n\n/-\ninfo: 358\n-/\n#guard_msgs in\n#eval min_pizza_cuts 2 [0, 1]"
      }
    ]
  },
  "fvapps_000581.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_stone_array (n k : Nat) (A : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_minimum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem stone_array_output_length {n k : Nat} {A : List Int} :\n  List.length (solve_stone_array n k A) = List.length A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stone_array_zero_k {n : Nat} {A : List Int} :\n  solve_stone_array n 0 A = A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_000582.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_valid_shifts (n : Nat) (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def verify_shift (arr : List Nat) (shift_pos : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounds (n : Nat) (nums : List Nat)\n  (h1 : 2 \u2264 n) (h2 : n \u2264 20) (h3 : nums.length = n) :\n  0 \u2264 count_valid_shifts n nums \u2227 count_valid_shifts n nums \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_same_gives_zero (n : Nat)\n  (h1 : 2 \u2264 n) (h2 : n \u2264 20) :\n  count_valid_shifts n (List.replicate n 1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_shifts 6 [1, 1, 2, 1, 1, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_valid_shifts 4 [1, 2, 1, 1]"
      }
    ]
  },
  "fvapps_000604.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isInfixOf (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def substr (s : String) (i len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_stem (words : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stem_exists_in_all_words (words : List String) :\n  let stem := find_stem words\n  \u2200 word \u2208 words, isInfixOf stem word :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stem_is_substring_of_first_word (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  isInfixOf stem (words.get \u27e80, h\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stem_length_consistency (words : List String) (h : words.length > 0) :\n  let stem := find_stem words\n  let first := words.get \u27e80, h\u27e9\n  \u2200 i j, i < j \u2192 j \u2264 first.length \u2192\n    let substring := substr first i (j-i)\n    (\u2200 word \u2208 words, isInfixOf substring word) \u2192\n    substring.length \u2264 stem.length \u2228\n    (substring.length = stem.length \u2227 stem \u2264 substring) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'grace'\n-/\n#guard_msgs in\n#eval find_stem [\"grace\", \"graceful\", \"disgraceful\", \"gracefully\"]\n\n/-\ninfo: 'cat'\n-/\n#guard_msgs in\n#eval find_stem [\"cat\", \"catch\", \"cathedral\"]\n\n/-\ninfo: 'python'\n-/\n#guard_msgs in\n#eval find_stem [\"python\", \"pythonic\", \"pythoness\"]"
      }
    ]
  },
  "fvapps_000606.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort_numbers (nums : List Int) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_numbers_ascending (nums : List Int) :\n  let result := sort_numbers nums;\n  result.length = nums.length \u2227\n  isSorted (result.map String.toInt!) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_numbers_idempotent_list (nums : List Int) :\n  sort_numbers nums = sort_numbers nums := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_numbers_bounds (nums : List Int) (h : nums \u2260 []) :\n  let result := sort_numbers nums\n  let vals := result.map String.toInt!\n  vals.head! \u2264 vals.getLast! \u2227\n  \u2200 x \u2208 vals, vals.head! \u2264 x \u2227 x \u2264 vals.getLast! := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000607.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def cristo_sutra (input : List Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "sig",
        "string": "def parseResults (strs : List String) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cristo_sutra_length (input : List Nat) :\n  input.length > 0 \u2192 (cristo_sutra input).length = input.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cristo_sutra_base_cases :\n  cristo_sutra [1] = [\"0 1\"] \u2227\n  cristo_sutra [2] = [\"2 1\"] \u2227\n  cristo_sutra [3] = [\"3 2\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_000608.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_subarrays (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_valid_subarrays (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_subarrays_singleton (x : Nat) :\n  solve_subarrays 1 [x] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_subarrays_alternating_nonneg (n : Nat) :\n  let arr := List.replicate (2*n) 100000000 ++ List.replicate (2*n) 900000000\n  solve_subarrays (4*n) arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_subarrays 3 [100000000, 900000000, 100000000]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 1 [900000000]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_subarrays 2 [100000000, 100000000]"
      }
    ]
  },
  "fvapps_000610.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gameWinner (config : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gameWinner_returns_valid_player (config : String) :\n  (gameWinner config = \"Chef\" \u2228 gameWinner config = \"Aleksa\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countBlacksBeforeWhite (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countBlacksAfterWhite (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chef_wins_equal_blacks (config : String)\n  (h : countBlacksBeforeWhite config = countBlacksAfterWhite config) :\n  gameWinner config = \"Chef\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aleksa_wins_unequal_blacks (config : String)\n  (h : countBlacksBeforeWhite config \u2260 countBlacksAfterWhite config) :\n  gameWinner config = \"Aleksa\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chef_wins_single_white (config : String)\n  (h : config = \"W\") :\n  gameWinner config = \"Chef\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Chef'\n-/\n#guard_msgs in\n#eval game_winner \"W\"\n\n/-\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BW\"\n\n/-\ninfo: 'Aleksa'\n-/\n#guard_msgs in\n#eval game_winner \"BWBB\""
      }
    ]
  },
  "fvapps_000614.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_tallest_mountain (n : Nat) (heights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| h::t => List.foldl Nat.max h t"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| h::t => List.foldl Nat.min h t"
      },
      {
        "type": "cond",
        "string": "theorem find_tallest_in_list {n : Nat} {heights : List Nat} (h : heights \u2260 []) :\n  find_tallest_mountain n heights \u2208 heights\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_preserved {n : Nat} {heights : List Nat} :\n  heights.length = n \u2192\n  heights.length = n\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_mountain_height {height : Nat} :\n  find_tallest_mountain 1 [height] = height\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_tallest_mountain 5 [4, 7, 6, 3, 1]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval find_tallest_mountain 3 [10, 20, 30]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_tallest_mountain 1 [5]"
      }
    ]
  },
  "fvapps_000617.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_quadruples (n : Nat) (target : Int) (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMax : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)"
      },
      {
        "type": "sig",
        "string": "def listSum : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => x + listSum xs"
      },
      {
        "type": "cond",
        "string": "theorem count_quadruples_returns_natural\n  (nums : List Int) (target : Int) (h : nums.length \u2265 4) :\n  count_quadruples nums.length target nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_quadruples_binary_for_four\n  (nums : List Int) (target : Int) (h : nums.length = 4) :\n  count_quadruples nums.length target nums = 0 \u2228\n  count_quadruples nums.length target nums = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem insufficient_elements_gives_zero\n  (nums : List Int) (target : Int) (h : nums.length < 4) :\n  count_quadruples nums.length target nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_quadruples 6 20 [3, 1, 1, 2, 5, 10]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_quadruples 6 13 [1, 2, 3, 4, 5, 4]"
      }
    ]
  },
  "fvapps_000618.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_valid_parens (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max_nested_depth (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_balanced_parens (n : Nat) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_properties (n k : Nat) (h1 : n > 0) (h2 : k > 0) (h3 : n \u2264 100) (h4 : k \u2264 100) :\n  let result := solve_balanced_parens n k\n  if result = \"-1\" then\n    k = 2 \u2228 k = 4 \u2228 n % 2 \u2260 0 \u2228 n = k\n  else\n    result.length = n \u2227\n    (\u2200 c, c \u2208 result.data \u2192 c = '(' \u2228 c = ')') \u2227\n    is_valid_parens result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_k_cases (n : Nat) (h1 : n > 1) (h2 : n \u2264 100) (h3 : n % 2 = 0) :\n  let k := 3\n  let result := solve_balanced_parens n k\n  if result \u2260 \"-1\" then\n    result = String.mk (List.replicate (n/2) '(' ++ List.replicate (n/2) ')') else True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 4 2\n\n/-\ninfo: '(())(())'\n-/\n#guard_msgs in\n#eval solve_balanced_parens 8 6"
      }
    ]
  },
  "fvapps_000623.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_spaceship_cooldown (n d : Nat) (arrivals : List Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.max x"
      },
      {
        "type": "sig",
        "string": "def list_minimum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::xs => xs.foldl Nat.min x"
      },
      {
        "type": "comment",
        "string": "-- Result should be non-negative"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem spaceship_cooldown_nonnegative\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length \u2265 2)\n  : solve_spaceship_cooldown n d arrivals \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Cooldown should not exceed max time window plus delay"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem spaceship_cooldown_upper_bound\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length \u2265 2)\n  : solve_spaceship_cooldown n d arrivals \u2264\n    ((list_maximum arrivals) - (list_minimum arrivals)).toFloat + d.toFloat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Monotonicity with respect to delay"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem spaceship_cooldown_monotone_delay\n  (n d : Nat)\n  (arrivals : List Nat)\n  (h : arrivals.length \u2265 2)\n  : solve_spaceship_cooldown n d arrivals \u2264 solve_spaceship_cooldown n (d + 1) arrivals :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Known values"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem spaceship_cooldown_known_value1 :\n  solve_spaceship_cooldown 3 2 [3, 2, 3] = 1.5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spaceship_cooldown_known_value2 :\n  solve_spaceship_cooldown 2 1 [5, 6] = 2.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000624.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_legendary_prime_game (n: Nat) (p a b: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_prime_result_bounds (n: Nat) (h: n > 0) (h2: n \u2264 5):\n  let p := List.replicate n 2\n  let a := List.replicate n 1\n  let b := List.replicate n 1\n  let result := solve_legendary_prime_game n p a b\n  result > 0 \u2227 result < (10^9 + 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 540\n-/\n#guard_msgs in\n#eval solve_legendary_prime_game 3 [2, 3, 5] [2, 1, 2] [1, 1, 1]"
      }
    ]
  },
  "fvapps_000627.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_string_length (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is non-negative"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_string_length_non_negative (s : String) (h : s.length > 0) :\n  min_string_length s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is at most input length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_string_length_upper_bound (s : String) (h : s.length > 0) :\n  min_string_length s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Single character sequence reduces to at most 1"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_string_length_same_char (s : String) (h : s.length > 0)\n  (h' : \u2200 (i j : String.Pos), s.get i = s.get j) :\n  min_string_length s \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Palindrome property"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_string_length_palindrome (s : String) (h : s.length > 0) :\n  min_string_length s = min_string_length (reverseString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_string_length \"abccd\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_string_length \"abbac\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_string_length \"aaaa\""
      }
    ]
  },
  "fvapps_000629.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hill_jumping_competition (n : Nat) (heights : List Nat) (operations : List (List Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_operation (op : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "match op with\n| h::t =>\n  if h = 1 then t.length = 2 && List.head! t \u2265 1 && List.get! t 1 \u2265 1\n  else if h = 2 then t.length = 3 && List.head! t \u2265 1 && List.get! t 1 \u2265 List.head! t\n  else false\n| [] => false"
      },
      {
        "type": "cond",
        "string": "theorem hill_jumping_result_length (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation \u2192\n  (hill_jumping_competition n heights operations).length =\n    (List.filter (fun op => List.head! op = 1) operations).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hill_jumping_bounds (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation \u2192\n  List.all (hill_jumping_competition n heights operations) (fun x => x \u2265 1 \u2227 x \u2264 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hill_jumping_preserves_heights (n : Nat) (heights : List Nat) (operations : List (List Nat)) :\n  List.all operations is_valid_operation \u2192\n  let original := heights\n  let _ := hill_jumping_competition n heights operations\n  heights = original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 5 [1, 2, 3, 4, 5] [[1, 1, 2], [2, 3, 4, -1], [1, 1, 2]]\n\n/-\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval hill_jumping_competition 3 [1, 3, 2] [[1, 1, 1], [2, 1, 2, 1], [1, 1, 1]]"
      }
    ]
  },
  "fvapps_000630.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidGrid (grid : List (List Char)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (grid : List (List Char)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isGravityConsistent (grid : List (List Char)) (force : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solveParticleGrid (n m : Nat) (grid : List (List Char)) (forces : List Char) : List (List Char) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem grid_dimensions {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  List.length result = n \u2227\n  \u2200 row \u2208 result, List.length row = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem grid_valid_chars {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  \u2200 row \u2208 result, \u2200 c \u2208 row, c = '0' \u2228 c = '1' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem preserved_ones_count {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid) :\n  let result := solveParticleGrid n m grid forces\n  countOnes grid = countOnes result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem final_gravity_consistent {n m : Nat} {grid : List (List Char)} {forces : List Char}\n  (h1 : isValidGrid grid)\n  (h2 : forces \u2260 []) :\n  let result := solveParticleGrid n m grid forces\n  let lastForce := List.getLast forces h2\n  isGravityConsistent result lastForce :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000634.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def game (n : Nat) (health : List Nat) (laser_energy : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_result_non_negative (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_result_bounded (n : Nat) (health : List Nat) (laser_energy : Nat) :\n  game n health laser_energy \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_empty_list (laser_energy : Nat) :\n  game 0 [] laser_energy = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_zero_energy (n : Nat) (health : List Nat) (h : health \u2260 []) :\n  game n health 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_energy_threshold (n : Nat) (health : List Nat) (laser_energy : Nat)\n  (h1 : health \u2260 []) (h2 : laser_energy < listMin health) :\n  game n health laser_energy = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_sufficient_energy (n : Nat) (health : List Nat) (h : health \u2260 []) :\n  game n health (2 * listSum health) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_000643.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MODULO := 1000000007\n\ndef sum_odds_in_range (l r : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_alternate_odd_sum (d l r : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_non_negative (d l r : Nat) :\n  solve_alternate_odd_sum d l r \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_start_end_even (d l : Nat) :\n  l % 2 = 0 \u2192\n  solve_alternate_odd_sum d l l = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_range (d : Nat) :\n  \u2200 l r : Nat, r < l \u2192\n  solve_alternate_odd_sum d l r = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 114\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 10 33\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 2 1 7\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_alternate_odd_sum 3 1 9"
      }
    ]
  },
  "fvapps_000652.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_complete_team (N : Nat) (S : Nat) (prices : List Nat) (positions : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_lists :\n  can_complete_team 0 0 [] [] = \"no\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_list (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| h::t => List.foldl min h t"
      },
      {
        "type": "cond",
        "string": "theorem all_defenders_or_forwards_only (p\u2081 p\u2082 p\u2083 : Nat) :\n  can_complete_team 3 50 [p\u2081, p\u2082, p\u2083] [0, 0, 0] = \"no\" \u2227\n  can_complete_team 3 50 [p\u2081, p\u2082, p\u2083] [1, 1, 1] = \"no\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_input_result {N S : Nat} {prices positions : List Nat}\n  (h\u2081 : N \u2265 2)\n  (h\u2082 : S < 100)\n  (h\u2083 : prices.length = N)\n  (h\u2084 : positions.length = N)\n  (h\u2085 : \u2200 p \u2208 prices, p \u2265 1 \u2227 p \u2264 100)\n  (h\u2086 : \u2200 p \u2208 positions, p = 0 \u2228 p = 1)\n  (h\u2087 : positions.get! 0 = 0)\n  (h\u2088 : positions.get! 1 = 1) :\n  can_complete_team N S prices positions = \"yes\" \u2228\n  can_complete_team N S prices positions = \"no\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_input_cost {N S : Nat} {prices positions : List Nat}\n  (h\u2081 : N \u2265 2)\n  (h\u2082 : S < 100)\n  (h\u2083 : prices.length = N)\n  (h\u2084 : positions.length = N)\n  (h\u2085 : \u2200 p \u2208 prices, p \u2265 1 \u2227 p \u2264 100)\n  (h\u2086 : \u2200 p \u2208 positions, p = 0 \u2228 p = 1)\n  (h\u2087 : positions.get! 0 = 0)\n  (h\u2088 : positions.get! 1 = 1) :\n  let min_defender := min_list (List.filterMap (\u03bb i => if positions.get! i = 0 then some (prices.get! i) else none) (List.range N))\n  let min_forward := min_list (List.filterMap (\u03bb i => if positions.get! i = 1 then some (prices.get! i) else none) (List.range N))\n  100 - S \u2265 min_defender + min_forward \u2194 can_complete_team N S prices positions = \"yes\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem team_costs {N S : Nat} {prices : List Nat}\n  (h\u2081 : N \u2265 2)\n  (h\u2082 : S < 100)\n  (h\u2083 : prices.length = N)\n  (h\u2084 : \u2200 p \u2208 prices, p \u2265 1 \u2227 p \u2264 100)\n  (h\u2085 : can_complete_team N S prices (List.map (\u03bb i => i % 2) (List.range N)) = \"yes\") :\n  100 - S \u2265 min_list (List.filterMap (\u03bb i => if i % 2 = 0 then some (prices.get! i) else none) (List.range N)) +\n           min_list (List.filterMap (\u03bb i => if i % 2 = 1 then some (prices.get! i) else none) (List.range N)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'yes'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [3, 8, 6, 5] [0, 1, 1, 0]\n\n/-\ninfo: 'no'\n-/\n#guard_msgs in\n#eval can_complete_team 4 90 [5, 7, 6, 5] [0, 1, 1, 0]"
      }
    ]
  },
  "fvapps_000669.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isUniform (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countTransitions (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def swapBits (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_string_result_valid {s : String} (h : s.length > 0) :\n  isUniform s = \"uniform\" \u2228 isUniform s = \"non-uniform\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_same_chars_uniform {s : String} (h\u2081 : s.length > 0)\n  (h\u2082 : \u2200 (i j : String.Pos), s.get i = s.get j) :\n  isUniform s = \"uniform\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transitions_gt_two_nonuniform {s : String} (h\u2081 : s.length > 0)\n  (h\u2082 : countTransitions s > 2) :\n  isUniform s = \"non-uniform\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transitions_leq_two_uniform {s : String} (h\u2081 : s.length > 0)\n  (h\u2082 : countTransitions s \u2264 2) :\n  isUniform s = \"uniform\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_reverse_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (reverseString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_swap_eq {s : String} (h : s.length > 0) :\n  isUniform s = isUniform (swapBits s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"00000000\"\n\n/-\ninfo: 'non-uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10101010\"\n\n/-\ninfo: 'uniform'\n-/\n#guard_msgs in\n#eval check_uniform \"10000001\""
      }
    ]
  },
  "fvapps_000674.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def calculate_factorials (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_factorial :\n  calculate_factorials [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem factorial_zero :\n  calculate_factorials [0] = [1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem factorial_one :\n  calculate_factorials [1] = [1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_000678.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_consecutive_power (arr : List Int) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_sublist (l : List Int) (i : Nat) (len : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_consecutive_power_is_k_consecutive\n  {arr : List Int} {k : Nat} (h : k \u2264 arr.length) :\n  \u2203 i, i + k \u2264 arr.length \u2227\n    find_max_consecutive_power arr k = sum_sublist arr i k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_consecutive_power_is_maximum\n  {arr : List Int} {k : Nat} (h : k \u2264 arr.length) :\n  \u2200 i, i + k \u2264 arr.length \u2192\n    sum_sublist arr i k \u2264 find_max_consecutive_power arr k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_consecutive_power_equals_sum_when_k_equals_length\n  {arr : List Int} :\n  find_max_consecutive_power arr arr.length = list_sum arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_consecutive_power_nonnegative\n  {arr : List Int} {k : Nat} (h : k \u2264 arr.length)\n  (h_nonneg : \u2200 x \u2208 arr, 0 \u2264 x) :\n  0 \u2264 find_max_consecutive_power arr k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, 2, 3, 4, 5] 3\n\n/-\ninfo: -3\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [-1, -2, -3, -4, -5] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_consecutive_power [1, -2, 3, -4, 5] 3"
      }
    ]
  },
  "fvapps_000679.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def phi (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_passcode (a m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem phi_positive (n : Nat) (h : n > 0) : phi n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem phi_upper_bound (n : Nat) : phi n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem phi_one : phi 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_passcode_positive (a m : Nat) (h\u2081 : a > 0) (h\u2082 : m > 0) :\n  solve_passcode a m > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_passcode_upper_bound (a m : Nat) (h\u2081 : a > 0) (h\u2082 : m > 0) :\n  solve_passcode a m \u2264 m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_passcode_one (a : Nat) (h : a > 0) :\n  solve_passcode a 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_passcode_coprime (a m : Nat) (h\u2081 : a > 0) (h\u2082 : m > 0)\n  (h\u2083 : Nat.gcd a m = 1) :\n  solve_passcode a m = phi m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_passcode_gcd (a m : Nat) (h\u2081 : a > 0) (h\u2082 : m > 0) :\n  solve_passcode a m = phi (m / Nat.gcd a m) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_passcode 4 9\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_passcode 5 10\n\n/-\ninfo: 9999999966\n-/\n#guard_msgs in\n#eval solve_passcode 42 9999999967"
      }
    ]
  },
  "fvapps_000681.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minRobberyCost (n : Nat) (costs : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => List.foldl min h t"
      },
      {
        "type": "sig",
        "string": "def findMinValidPath (costs : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let range4 := [0, 1, 2, 3]\n  let maxVal := 10000  -- arbitrary large value\n  let bank1 := costs.head!\n  let bank2 := costs.get! 1\n  listMin (List.map (fun w1 =>\n    listMin (List.map (fun w2 =>\n      if w1 \u2260 w2 then bank1[w1]! + bank2[w2]! else maxVal\n    ) range4)\n  ) range4)"
      },
      {
        "type": "cond",
        "string": "theorem single_bank_result (costs : List (List Nat))\n  (h1 : costs.length = 1)\n  (h2 : \u2200 lst \u2208 costs, lst.length = 4)\n  (h3 : \u2200 lst \u2208 costs, \u2200 x \u2208 lst, x > 0) :\n  minRobberyCost 1 costs = listMin (costs.head!) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_banks_positive (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : \u2200 lst \u2208 costs, lst.length = 4)\n  (h3 : \u2200 lst \u2208 costs, \u2200 x \u2208 lst, x > 0) :\n  minRobberyCost 2 costs > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_banks_lower_bound (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : \u2200 lst \u2208 costs, lst.length = 4)\n  (h3 : \u2200 lst \u2208 costs, \u2200 x \u2208 lst, x > 0) :\n  minRobberyCost 2 costs \u2265 listMin (costs.head!) + listMin (costs.get! 1) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_banks_min_path (costs : List (List Nat))\n  (h1 : costs.length = 2)\n  (h2 : \u2200 lst \u2208 costs, lst.length = 4)\n  (h3 : \u2200 lst \u2208 costs, \u2200 x \u2208 lst, x > 0) :\n  minRobberyCost 2 costs = findMinValidPath costs := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 3 [[4, 7, 2, 9], [5, 6, 4, 7], [2, 6, 4, 3]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_robbery_cost 2 [[1, 2, 3, 4], [5, 6, 7, 8]]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval min_robbery_cost 1 [[10, 20, 30, 40]]"
      }
    ]
  },
  "fvapps_000682.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_optimal_split (N k : Nat) (powers : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calc_product (values : List Nat) (split : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_optimal_split_properties1 {N k : Nat} {powers : List Nat} (h1: N \u2265 2) (h2: k \u2265 1)\n    (h3: powers.length = N) (h4: \u2200 x \u2208 powers, x \u2264 10) :\n    let result := find_optimal_split N k powers\n    1 \u2264 result \u2227 result \u2264 N-1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_optimal_split_properties2 {N k : Nat} {powers : List Nat} (h1: N \u2265 2) (h2: k \u2265 1)\n    (h3: powers.length = N) (h4: \u2200 x \u2208 powers, x \u2264 10) :\n    let values := powers.map (fun p => k^p)\n    let result := find_optimal_split N k powers\n    let optimal_product := calc_product values result\n    \u2200 i, 1 \u2264 i \u2192 i < N \u2192 calc_product values i \u2264 optimal_product :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_optimal_split 5 2 [1, 1, 3, 3, 5]"
      }
    ]
  },
  "fvapps_000685.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solveEugeneHomework (a n m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def repeatedNum (a n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_eugene_homework_range (a n m : Nat)\n  (ha : 1 \u2264 a \u2227 a \u2264 10^9)\n  (hn : 1 \u2264 n \u2227 n \u2264 100)\n  (hm : 2 \u2264 m \u2227 m \u2264 10^9) :\n  let result := solveEugeneHomework a n m\n  0 \u2264 result \u2227 result < m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_eugene_homework_correct (a n m : Nat)\n  (ha : 1 \u2264 a \u2227 a \u2264 10^9)\n  (hn : 1 \u2264 n \u2227 n \u2264 100)\n  (hm : 2 \u2264 m \u2227 m \u2264 10^9) :\n  solveEugeneHomework a n m = repeatedNum a n % m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem modulo_one_is_zero (a n : Nat)\n  (ha : 1 \u2264 a \u2227 a \u2264 10^6)\n  (hn : 1 \u2264 n \u2227 n \u2264 100) :\n  solveEugeneHomework a n 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_repeat (a m : Nat)\n  (ha : 1 \u2264 a \u2227 a \u2264 10^6)\n  (hm : 2 \u2264 m \u2227 m \u2264 10^6) :\n  solveEugeneHomework a 1 m = a % m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_eugene_homework 12 2 17\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_eugene_homework 523 3 11\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_eugene_homework 1000 3 7"
      }
    ]
  },
  "fvapps_000687.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_trips (n : Nat) (k : Nat) (weights : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "sig",
        "string": "def list_maximum : List Nat \u2192 Nat\n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (list_maximum xs)"
      },
      {
        "type": "cond",
        "string": "theorem min_trips_basic_properties\n  (weights : List Nat) (k : Nat) (n : Nat) (h1 : n = weights.length) :\n  let result := min_trips n k weights\n  ((\u2203 w \u2208 weights, w > k) \u2192 result = -1) \u2227\n  ((\u2200 w \u2208 weights, w \u2264 k) \u2192\n    result > 0 \u2227\n    result \u2264 n \u2227\n    result * k \u2265 list_sum weights) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_trips_monotonic\n  (weights : List Nat) (n : Nat) (h1 : n = weights.length) :\n  let k\u2081 := list_maximum weights\n  let k\u2082 := k\u2081 + 1\n  min_trips n k\u2081 weights \u2265 min_trips n k\u2082 weights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_trips_zero_weights\n  (k : Nat) (weights : List Nat) (n : Nat) (h1 : n = weights.length)\n  (h2 : \u2200 w \u2208 weights, w = 0) :\n  let result := min_trips n k weights\n  result = 0 \u2228 result = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_trips 1 1 [2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_trips 2 4 [1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_trips 3 6 [3, 4, 2]"
      }
    ]
  },
  "fvapps_000688.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_mountain_secret (n : Nat) (edges : List (Nat \u00d7 Nat)) : String := sorry\n\ndef parseNums (s : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  (s.split (\u00b7 = ' ')).filterMap String.toNat?"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => x \u2264 y && isSorted (y :: rest)"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_produces_unique_nums {n : Nat} {edges : List (Nat \u00d7 Nat)}\n    (h1 : n \u2265 2)\n    (h2 : edges.length > 0)\n    (h3 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2264 n \u2227 e.2 \u2264 n)\n    (h4 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2260 e.2) :\n    let nums := parseNums (find_mountain_secret n edges)\n    nums.length = nums.eraseDups.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_valid_range {n : Nat} {edges : List (Nat \u00d7 Nat)}\n    (h1 : n \u2265 2)\n    (h2 : edges.length > 0)\n    (h3 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2264 n \u2227 e.2 \u2264 n)\n    (h4 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2260 e.2) :\n    let nums := parseNums (find_mountain_secret n edges)\n    \u2200 x \u2208 nums, 1 \u2264 x \u2227 x \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_contains_root {n : Nat} {edges : List (Nat \u00d7 Nat)}\n    (h1 : n \u2265 2)\n    (h2 : edges.length > 0)\n    (h3 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2264 n \u2227 e.2 \u2264 n)\n    (h4 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2260 e.2) :\n    let nums := parseNums (find_mountain_secret n edges)\n    1 \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_sorted {n : Nat} {edges : List (Nat \u00d7 Nat)}\n    (h1 : n \u2265 2)\n    (h2 : edges.length > 0)\n    (h3 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2264 n \u2227 e.2 \u2264 n)\n    (h4 : \u2200 (e : Nat \u00d7 Nat), e \u2208 edges \u2192 e.1 \u2260 e.2) :\n    let nums := parseNums (find_mountain_secret n edges)\n    isSorted nums = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_specific_case_1 :\n    find_mountain_secret 5 [(1,2), (1,3), (2,4), (2,5)] = \"1 2 3 4 5\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mountain_secret_specific_case_2 :\n    find_mountain_secret 3 [(1,2), (1,3)] = \"1 2 3\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '1 2 3 4 5'\n-/\n#guard_msgs in\n#eval find_mountain_secret 5 [(1, 2), (1, 3), (2, 4), (2, 5)]\n\n/-\ninfo: '1 2 3'\n-/\n#guard_msgs in\n#eval find_mountain_secret 3 [(1, 2), (1, 3)]"
      }
    ]
  },
  "fvapps_000690.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_gcd (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gcd_of_list (numbers : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_valid : \u2200 (n : Nat) (arr : List Nat),\n  arr \u2260 [] \u2192 solve n arr = arr.head! \u2228 solve n arr = arr.getLast! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_optimality : \u2200 (n : Nat) (arr : List Nat),\n  arr \u2260 [] \u2192\n  (arr.length = 1 \u2192 solve n arr = arr.head!) \u2227\n  (arr.length > 1 \u2192 solve n arr \u2265 arr.head! \u2227 solve n arr \u2265 arr.getLast!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 1 [2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 3 [6, 9, 3]\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval solve 4 [12, 18, 24, 36]"
      }
    ]
  },
  "fvapps_000693.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_find_odd_multiple (n : Nat) (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isEven (x : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  x % 2 == 0"
      },
      {
        "type": "cond",
        "string": "theorem all_even_no_odd_multiple {n : Nat} {arr : List Int} :\n  (\u2200 x \u2208 arr, isEven x = true) \u2192\n  can_find_odd_multiple n arr = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_number_case (x : Int) :\n  can_find_odd_multiple 1 [x] = (!isEven x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_property {n : Nat} {arr : List Int} :\n  n = arr.length \u2192\n  can_find_odd_multiple n arr = true \u2228 can_find_odd_multiple n arr = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem parity_preservation {n : Nat} {arr : List Int} :\n  can_find_odd_multiple n arr = can_find_odd_multiple n arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000694.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.index {\u03b1} [BEq \u03b1] (xs : List \u03b1) (x : \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_subsequence (s1 : String) (s2 : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_is_subsequence_of_itself (seq : List Nat) (h : seq.length > 0) :\n  \u2200 x \u2208 seq, x > 0 \u2227 x \u2264 100 \u2192\n  check_subsequence (toString seq) (toString seq) = \"Yes\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_element_not_subsequence (seq : List Nat) (invalid : Nat) (h1 : seq.length > 0) :\n  (\u2200 x \u2208 seq, x > 0 \u2227 x \u2264 100) \u2192\n  invalid > 100 \u2227 invalid \u2264 200 \u2192\n  check_subsequence (toString seq) (toString invalid) = \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_element_is_subsequence (seq : List Nat) (h : seq.length > 1) :\n  \u2200 x \u2208 seq, x > 0 \u2227 x \u2264 100 \u2192\n  check_subsequence (toString seq) (toString (seq.get! 0)) = \"Yes\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_elements_subsequence (seq : List Nat) (start : Nat)\n  (h1 : seq.length \u2265 3) (h2 : start < seq.length - 1) :\n  \u2200 x \u2208 seq, x > 0 \u2227 x \u2264 100 \u2192\n  let subseq := (seq.drop start).take 2\n  \u2200 i < subseq.length - 1,\n    seq.index (subseq[i]!) < seq.index (subseq[i+1]!) \u2192\n  check_subsequence (toString seq) (toString subseq) = \"Yes\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 2 3 4 5 6\" \"2 3 4\"\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval check_subsequence \"22 5 6 33 1 4\" \"4 15\"\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval check_subsequence \"1 3 4 2\" \"1 2\""
      }
    ]
  },
  "fvapps_000696.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_string_weight (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def string_reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  \u27e8s.data.reverse\u27e9"
      },
      {
        "type": "cond",
        "string": "theorem length_weight_relationship {s : String}\n  (h : \u2200 c \u2208 s.data, 'A' \u2264 c \u2227 c \u2264 'Z') :\n  s.length \u2264 calculate_string_weight s \u2227 calculate_string_weight s \u2264 27 * s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invariant_under_reversal {s : String}\n  (h : \u2200 c \u2208 s.data, 'A' \u2264 c \u2227 c \u2264 'Z') :\n  calculate_string_weight s = calculate_string_weight (string_reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem weight_additive {s1 s2 : String}\n  (h1 : \u2200 c \u2208 s1.data, 'A' \u2264 c \u2227 c \u2264 'Z')\n  (h2 : \u2200 c \u2208 s2.data, 'A' \u2264 c \u2227 c \u2264 'Z') :\n  calculate_string_weight (s1 ++ s2) = calculate_string_weight s1 + calculate_string_weight s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem a_highest_weight :\n  calculate_string_weight \"A\" > calculate_string_weight \"Z\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem a_weight_27 :\n  calculate_string_weight \"A\" = 27 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem z_weight_2 :\n  calculate_string_weight \"Z\" = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval calculate_string_weight \"A\"\n\n/-\ninfo: 65\n-/\n#guard_msgs in\n#eval calculate_string_weight \"AND\""
      }
    ]
  },
  "fvapps_000697.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def leastPrimeDivisors (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def dividing_machine (n m : Nat) (arr : List Nat) (ops : List (List Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem least_prime_divisors_are_prime (n : Nat) :\n  (\u2200 p \u2208 leastPrimeDivisors n, p > 1) \u2227\n  (\u2200 p \u2208 leastPrimeDivisors n, \u2200 i : Nat, 2 \u2264 i \u2227 i * i \u2264 p \u2192 p % i \u2260 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dividing_machine_valid_result {n m : Nat} {arr : List Nat} {ops : List (List Nat)}\n  (h_ops : \u2200 op \u2208 ops, op.length = 3 \u2227\n          (op.get! 0 < 2 \u2227 1 \u2264 op.get! 1 \u2227 op.get! 1 \u2264 op.get! 2 \u2227 op.get! 2 \u2264 n)) :\n  (dividing_machine n m arr ops).length = (ops.filter (fun op => op.get! 0 = 1)).length \u2227\n  \u2200 x \u2208 dividing_machine n m arr ops, x \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_number_valid {x : Nat} (h : x \u2265 1) :\n  let result := dividing_machine 1 1 [x] [[1,1,1]]\n  result.length = 1 \u2227 result.get! 0 \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [5, 3, 5, 11]\n-/\n#guard_msgs in\n#eval dividing_machine 6 7 [2, 5, 8, 10, 3, 44] [[1, 2, 6], [0, 2, 3], [1, 2, 6], [0, 4, 6], [1, 1, 6], [0, 1, 6], [1, 4, 6]]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval dividing_machine 2 2 [1, 3] [[0, 2, 2], [1, 1, 2]]"
      }
    ]
  },
  "fvapps_000702.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bin_expo (x n p : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function for calculating palindrome count -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def calculate_palindromes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Calculated palindromes are non-negative integers less than modulus -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem palindrome_count_bounds (n : Nat) (h : 0 < n) :\n  let result := calculate_palindromes n\n  0 \u2264 result \u2227 result < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Binary exponentiation results are within valid modulo range -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bin_expo_bounds (x n p : Nat) :\n  let result := bin_expo x n p\n  0 \u2264 result \u2227 result < p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Binary exponentiation of anything to power 0 equals 1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bin_expo_zero (x p : Nat) :\n  bin_expo x 0 p = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Binary exponentiation of x to power 1 equals x mod p -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bin_expo_one (x p : Nat) :\n  bin_expo x 1 p = x % p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Known values for small inputs -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem small_n_cases :\n  calculate_palindromes 1 = 26 \u2227\n  calculate_palindromes 2 = 52 \u2227\n  calculate_palindromes 3 = 728 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Results differ between consecutive odd and even inputs -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem palindrome_parity (n : Nat) (h : 0 < n) :\n  n % 2 = 1 \u2192 calculate_palindromes n \u2260 calculate_palindromes (n + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 26\n-/\n#guard_msgs in\n#eval calculate_palindromes 1\n\n/-\ninfo: 52\n-/\n#guard_msgs in\n#eval calculate_palindromes 2\n\n/-\ninfo: 728\n-/\n#guard_msgs in\n#eval calculate_palindromes 3"
      }
    ]
  },
  "fvapps_000705.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_permutation (n : Nat) (k : Nat) (indices : List Nat) : (String \u00d7 List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_permutation (perm : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_indices_descending (perm indices : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem basic_case_1 :\n  solve_permutation 1 1 [1] = (\"YES\", [1]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem basic_case_2 :\n  solve_permutation 2 1 [1] = (\"NO\", []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_000707.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_meals (ingredients : List (List Char)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_char (c : Char) (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (s.filter (fun x => x = c)).length"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sum_list xs"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_non_negative (ingredients : List (List Char)) :\n  max_meals ingredients \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_c (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 (sum_list (ingredients.map (count_char 'c'))) / 2 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_o (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 sum_list (ingredients.map (count_char 'o')) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_d (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 sum_list (ingredients.map (count_char 'd')) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_e (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 (sum_list (ingredients.map (count_char 'e'))) / 2 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_h (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 sum_list (ingredients.map (count_char 'h')) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_bounded_by_f (ingredients : List (List Char)) :\n  max_meals ingredients \u2264 sum_list (ingredients.map (count_char 'f')) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_empty_list :\n  max_meals [] = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_doubles (ingredients : List (List Char)) :\n  ingredients \u2260 [] \u2192\n  max_meals (ingredients.map (fun s => s ++ s)) \u2265 max_meals ingredients := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_meals_with_invalid_chars (ingredients : List (List Char)) :\n  max_meals ingredients \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_meals [\"cplusplus\", \"oscar\", \"deck\", \"fee\", \"hat\", \"near\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_meals [\"code\", \"hacker\", \"chef\", \"chaby\", \"dumbofe\"]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_meals [\"codechef\", \"chefcode\", \"fehcedoc\", \"cceeohfd\", \"codechef\"]"
      }
    ]
  },
  "fvapps_000710.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := List (List Int)"
      },
      {
        "type": "sig",
        "string": "def StrMatrix := List String\n\ndef solve_matrix_moves (n m : Nat) (matrix : StrMatrix) : Matrix :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def replicate_zeros (n : Nat) (m : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def create_matrix_with_one (n m : Nat) : StrMatrix :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem matrix_dimensions {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  result.length = n \u2227\n  \u2200 (row : List Int), List.elem row result \u2192 row.length = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matrix_all_zeros {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n  \u2200 (row : List Int), List.elem row result \u2192\n  \u2200 (x : Int), List.elem x row \u2192 x = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_one {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n  let i := n / 2\n  let j := m / 2\n  let matrix := create_matrix_with_one n m\n  let result := solve_matrix_moves n m matrix\n  (List.get! result i |>.get! j) = 0 \u2227\n  (\u2200 k, k < m \u2192 k \u2260 j \u2192 (List.get! result i |>.get! k) = 1) \u2227\n  (\u2200 k, k < n \u2192 k \u2260 i \u2192 (List.get! result k |>.get! j) = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000713.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.padRight (default : \u03b1) (n : Nat) (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_weird_distance (n : Nat) (alice_speeds : List Nat) (bob_speeds : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def running_sum_equal (alice_speeds bob_speeds : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_speeds_sum_to_length\n  (n : Nat)\n  (h1 : n > 0)\n  (h2 : n \u2264 100) :\n  find_weird_distance n (List.replicate n 1) (List.replicate n 1) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_weird_distance 4 [1, 3, 3, 4] [1, 2, 4, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [2, 3] [3, 2]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_weird_distance 2 [3, 3] [3, 3]"
      }
    ]
  },
  "fvapps_000714.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_smallest_palindrome (len: Nat) (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_palindrome_result_length\n  (len: Nat) (s: String) (h\u2081: len > 0) (h\u2082: s.length > 0) :\n  (find_smallest_palindrome len s).length = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def lexMin (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  s.data.foldl (fun acc c => if c < acc.get! 0 then String.mk [c] else acc) (String.mk [s.get! 0])"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_palindrome_in_original\n  (len: Nat) (s: String) (h\u2081: len > 0) (h\u2082: s.length > 0) :\n  s.contains ((find_smallest_palindrome len s).get! 0) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_palindrome_lexmin\n  (len: Nat) (s: String) (h\u2081: len > 0) (h\u2082: s.length > 0) :\n  find_smallest_palindrome len s = lexMin s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'y'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 2 \"zy\"\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 1 \"cd\"\n\n/-\ninfo: 'm'\n-/\n#guard_msgs in\n#eval find_smallest_palindrome 3 \"mom\""
      }
    ]
  },
  "fvapps_000717.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minPointsForStringConversion (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPoints_nonNegative (s : String) (h : s.length > 0) :\n  minPointsForStringConversion s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allSameChar (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPoints_zero_for_same_chars (s : String) (h1 : s.length > 0) (h2 : allSameChar s = true) :\n  minPointsForStringConversion s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minCharOfString (s : String) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxCharOfString (s : String) : Char := sorry\n\ndef naiveLowerBound (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let minChar := minCharOfString s\n  let maxChar := maxCharOfString s\n  min\n    (s.data.foldl (fun acc c => acc + (c.toNat - minChar.toNat)) 0)\n    (s.data.foldl (fun acc c => acc + (c.toNat - maxChar.toNat)) 0)"
      },
      {
        "type": "cond",
        "string": "theorem minPoints_upper_bound (s : String) (h : s.length > 0) :\n  minPointsForStringConversion s \u2264 s.length * (('z'.toNat) - ('a'.toNat)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPoints_repeated_string (s : String) (h : s.length > 0) :\n  minPointsForStringConversion (s ++ s) = 2 * minPointsForStringConversion s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minPoints_naive_bound (s : String) (h : s.length > 0) :\n  minPointsForStringConversion s \u2264 naiveLowerBound s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_points_for_string_conversion \"abba\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_points_for_string_conversion \"a\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_points_for_string_conversion \"zzz\""
      }
    ]
  },
  "fvapps_000718.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_land_split (x y : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_properties (n : Nat) (h : n \u2264 1000) :\n  (n < 2 \u2192 is_prime n = false) \u2227\n  (is_prime n = true \u2192 n \u2265 2) \u2227\n  (is_prime n = true \u2192 \u2200 i : Nat, 2 \u2264 i \u2192 i \u2264 100 \u2192 \u00ac(n % i = 0)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_land_split_properties (x y : Nat) (h\u2081 : x \u2264 100) (h\u2082 : y \u2264 100) (h\u2083 : y \u2264 x) :\n  (check_land_split x y = \"YES\" \u2228 check_land_split x y = \"NO\") \u2227\n  (check_land_split x y = \"NO\" \u2194 is_prime (x*x - y*y)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_land_split_equal_sides (x : Nat) (h : x \u2264 100) :\n  check_land_split x x = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_land_split_zero_inner (x : Nat) (h : x \u2264 100) :\n  check_land_split x 0 = \"NO\" \u2194 is_prime (x*x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 7 5\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval check_land_split 6 5\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval check_land_split 10 8"
      }
    ]
  },
  "fvapps_000719.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calc_army_power (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The army power is always at least 1 for positive inputs -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem army_power_always_positive (n : Nat) (h : n \u2265 1) :\n  calc_army_power n \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The army power is monotonic increasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem army_power_monotonic (n : Nat) (h : n > 1) :\n  calc_army_power n \u2265 calc_army_power (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Known base cases for the army power function -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem army_power_base_cases :\n  (calc_army_power 1 = 1) \u2227 (calc_army_power 4 = 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The army power is bounded above by n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem army_power_bounded (n : Nat) (h : n \u2265 1) :\n  calc_army_power n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_army_power 24\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_army_power 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_army_power 4"
      }
    ]
  },
  "fvapps_000722.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def compute_super_factor_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_product : List Nat \u2192 Nat\n  | [] => 1\n  | x :: xs => x * list_product xs"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x :: xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem compute_super_factor_sum_positive (n : Nat) (h : n \u2265 2) :\n  compute_super_factor_sum n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_super_factor_sum_primes (n : Nat) (h1 : n \u2265 2) (h2 : is_prime n = true) :\n  compute_super_factor_sum n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_super_factor_sum_multiplicative (a b : Nat) (h1 : a \u2265 1) (h2 : b \u2265 1) :\n  compute_super_factor_sum (a * b) \u2265 min (compute_super_factor_sum a) (compute_super_factor_sum b) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_super_factor_sum_product_relation (factors : List Nat)\n  (h1 : \u2200 x \u2208 factors, x \u2265 2) (h2 : factors.length > 0) :\n  compute_super_factor_sum (list_product factors) \u2265\n  list_sum (List.map compute_super_factor_sum (List.filter (fun x => x > 1) factors)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 6\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 7\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval compute_super_factor_sum 12"
      }
    ]
  },
  "fvapps_000726.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_temple_operations (n : Nat) (heights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t"
      },
      {
        "type": "cond",
        "string": "theorem min_temple_operations_nonnegative (n : Nat) (heights : List Nat) :\n  heights.length = n \u2192\n  min_temple_operations n heights \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_temple_operations_preserves_input (n : Nat) (heights : List Nat) :\n  heights.length = n \u2192\n  heights = heights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_temple_operations_bounded_by_sum (n : Nat) (heights : List Nat) :\n  heights.length = n \u2192\n  min_temple_operations n heights \u2264 list_sum heights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_temple_operations_perfect (heights : List Nat) :\n  heights = [1,2,3,2,1] \u2192\n  min_temple_operations 5 heights = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_temple_operations 3 [1, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_temple_operations 4 [1, 1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_temple_operations 5 [1, 2, 6, 2, 1]"
      }
    ]
  },
  "fvapps_000727.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minArraySize (height : Nat) : Nat := (2 ^ height) - 1\n\ndef calcMaxProduct (height : Nat) (values : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def treeProduct (values : List Nat) (height : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_max_product_zero_height (values : List Nat) :\n  calcMaxProduct 0 values = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_max_product_bounds {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length \u2265 minArraySize height) :\n  0 \u2264 calcMaxProduct height values \u2227 calcMaxProduct height values < 1000000007 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_product_monotonic {height : Nat} {values : List Nat}\n  (h1 : height > 0)\n  (h2 : values.length \u2265 minArraySize height)\n  (h3 : \u2200 x \u2208 values, x > 0) :\n  let scaledValues := values.map (\u00b7 * 2)\n  treeProduct scaledValues height > treeProduct values height := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_array_size_valid (height : Nat) :\n  minArraySize height = 2^height - 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_product 2 #[1, 2, 3]\n\n/-\ninfo: 105\n-/\n#guard_msgs in\n#eval calc_max_product 3 #[3, 1, 5, 2, 6, 4, 7]"
      }
    ]
  },
  "fvapps_000729.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solveDie (n : Nat) (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidConfig (config : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- If solveDie returns [0], it indicates no valid configuration exists.\n    Otherwise, returns a valid die configuration that works with the input sequence. -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem die_configuration_theorem (n : Nat) (nums : List Nat) :\n  let result := solveDie n nums\n  result = [0] \u2228 isValidConfig result \u2227\n    \u2200 i : Nat, i + 1 < n \u2192\n      nums[i]! \u2260 nums[i+1]! \u2227\n      nums[i+1]! \u2260 result[nums[i]! - 1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- If there are adjacent equal numbers in the input sequence,\n    no valid die configuration exists -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem adjacent_same_numbers_theorem (n : Nat) (nums : List Nat) :\n  (\u2203 i : Nat, i + 1 < n \u2227 nums[i]! = nums[i+1]!) \u2192\n  solveDie n nums = [0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000732.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_min_wire_length (n : Nat) (has_electricity : String) (coordinates : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Basic properties -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_wire_length_non_negative (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : \u2203 i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_wire_length_bounded (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : \u2203 i < n, has_electricity.data.get! i = '1')\n  (h5 : coordinates.length \u2265 1) :\n  solve_min_wire_length n has_electricity coordinates \u2264 (coordinates.getLast! - coordinates.head!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_wire_length_all_electrified (n : Nat) (has_electricity : String) (coordinates : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : \u2200 i < n, has_electricity.data.get! i = '1') :\n  solve_min_wire_length n has_electricity coordinates = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Sorting property -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_wire_length_requires_sorted (n : Nat) (has_electricity : String) (coordinates unsorted : List Nat)\n  (h1 : coordinates.length = n)\n  (h2 : has_electricity.length = n)\n  (h3 : isSorted coordinates = true)\n  (h4 : unsorted.length = n)\n  (h5 : coordinates \u2260 unsorted)\n  (h6 : coordinates \u2260 []) :\n  solve_min_wire_length n has_electricity coordinates \u2260\n  solve_min_wire_length n has_electricity unsorted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_min_wire_length 2 \"01\" [1, 2]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_min_wire_length 3 \"100\" [1, 5, 6]"
      }
    ]
  },
  "fvapps_000735.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_divisible_permutations (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_divisible_permutations_valid_output (n : Nat) :\n  n > 0 \u2192 check_divisible_permutations n = 0 \u2228 check_divisible_permutations n = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_divisible_permutations_single_digits :\n  check_divisible_permutations 1 = 0 \u2227 check_divisible_permutations 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_divisible_permutations 19\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 385\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_permutations 246"
      }
    ]
  },
  "fvapps_000736.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.minimum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_common_divisors (nums: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_common_divisors_contains_prime_factors {nums: List Nat}\n  (h1: nums.length \u2265 2)\n  (h2: \u2200 n \u2208 nums, n \u2265 1 \u2227 n \u2264 100) :\n  \u2200 i: Nat, 2 \u2264 i \u2227 i \u2264 List.minimum nums \u2192\n  (\u2200 n \u2208 nums, n % i = 0) \u2192\n  (\u2200 j, 2 \u2264 j \u2227 j < i \u2192 i % j \u2260 0) \u2192\n  i \u2208 find_common_divisors nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_common_divisors_sorted {nums: List Nat}\n  (h1: nums.length \u2265 2)\n  (h2: \u2200 n \u2208 nums, n \u2265 2 \u2227 n \u2264 1000) :\n  find_common_divisors nums = List.sort (find_common_divisors nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_common_divisors_greater_than_one {nums: List Nat}\n  (h1: nums.length \u2265 2)\n  (h2: \u2200 n \u2208 nums, n \u2265 2 \u2227 n \u2264 1000) :\n  \u2200 x \u2208 find_common_divisors nums, x > 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_common_divisors_bounded_by_min {nums: List Nat}\n  (h1: nums.length \u2265 2)\n  (h2: \u2200 n \u2208 nums, n \u2265 2 \u2227 n \u2264 1000) :\n  \u2200 x \u2208 find_common_divisors nums, x \u2264 List.minimum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval find_common_divisors [38, 6, 34]\n\n/-\ninfo: [2, 3, 6]\n-/\n#guard_msgs in\n#eval find_common_divisors [12, 18, 24]\n\n/-\ninfo: [5]\n-/\n#guard_msgs in\n#eval find_common_divisors [10, 15, 20]"
      }
    ]
  },
  "fvapps_000737.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_min_potatoes (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_potatoes_returns_prime_sum\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x \u2264 1000) (h4 : y \u2264 1000) :\n  let result := find_min_potatoes x y\n  result \u2265 0 \u2227 isPrime (x + y + result) = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_potatoes_with_equal_inputs\n  (x : Nat) (h1 : x > 0) (h2 : x \u2264 1000) :\n  let result := find_min_potatoes x x\n  isPrime (2*x + result) = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_potatoes_reasonable_bounds\n  (x y : Nat) (h1 : x > 0) (h2 : y > 0) (h3 : x \u2264 100) (h4 : y \u2264 100) :\n  find_min_potatoes x y \u2264 x + y := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 3\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_potatoes 4 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_potatoes 1 1"
      }
    ]
  },
  "fvapps_000740.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_prime_factor (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_prime_factors_count (nums : List Nat) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_prime_factor\n  (nums : List Nat)\n  (h1 : \u2200 x \u2208 nums, x \u2265 2 \u2227 x \u2264 10000)\n  (h2 : nums.length > 0) :\n  let result := find_max_prime_factor nums\n  let factors := get_prime_factors_count nums\n  \u2203 freq, (result, freq) \u2208 factors :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_same_prime\n  (nums : List Nat)\n  (h : \u2200 x \u2208 nums, x = 2)\n  (h2 : nums.length > 0) :\n  find_max_prime_factor nums = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 2, 15, 6, 8, 5, 10]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_prime_factor [4, 8, 12, 15]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval find_max_prime_factor [3, 5, 7, 11]"
      }
    ]
  },
  "fvapps_000744.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_convert_binary_strings (s p : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_ones (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_adjacent_ones (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_string_convertible (s : String)\n  (h : s \u2260 \"\") :\n  can_convert_binary_strings s s = \"Yes\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem conversion_preserves_ones (s p : String)\n  (h1 : s \u2260 \"\") (h2 : p \u2260 \"\")\n  (h3 : s.length = p.length) :\n  (can_convert_binary_strings s p = \"Yes\") \u2194 (count_ones s = count_ones p) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cannot_convert_ones_to_zeros (s p : String)\n  (h1 : s \u2260 \"\")\n  (h2 : s.length = p.length)\n  (h3 : has_adjacent_ones s = true)\n  (h4 : p = s.replace \"11\" \"00\") :\n  can_convert_binary_strings s p = \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"00\" \"00\"\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"101\" \"010\"\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_convert_binary_strings \"0110\" \"0011\""
      }
    ]
  },
  "fvapps_000747.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_rectangle_areas (n : Nat) (numbers : List Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_rectangle_areas_ordering\n  (numbers : List Nat)\n  (h : numbers.length \u2265 2) :\n  let (max_area, min_area) := find_rectangle_areas numbers.length numbers\n  max_area \u2265 min_area :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximumTwoProduct (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimumTwoProduct (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_rectangle_areas_minimal\n  (numbers : List Nat)\n  (h : numbers = [1, 1]) :\n  find_rectangle_areas 2 numbers = (1, 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_rectangle_areas_preserves_input\n  (numbers : List Nat)\n  (h : numbers.length \u2265 2) :\n  let original := numbers\n  let _ := find_rectangle_areas numbers.length numbers\n  numbers = original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (20, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 5 [4, 2, 1, 5, 3]\n\n/-\ninfo: (12, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 4 [1, 2, 3, 4]\n\n/-\ninfo: (30, 2)\n-/\n#guard_msgs in\n#eval find_rectangle_areas 6 [5, 4, 3, 2, 1, 6]"
      }
    ]
  },
  "fvapps_000749.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tree_mex (n : Nat) (parents : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (parents : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_mex_positive (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents \u2192 solve_tree_mex n parents > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_mex_ge_nodes (n : Nat) (parents : List Nat) :\n  is_valid_tree n parents \u2192 solve_tree_mex n parents \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_mex_monotonic (n : Nat) (parents : List Nat) :\n  n > 2 \u2192\n  is_valid_tree n parents \u2192\n  solve_tree_mex n parents > solve_tree_mex (n-1) (parents.take (n-2)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_tree_formula (n : Nat) :\n  n \u2265 2 \u2192\n  solve_tree_mex n (List.map (fun i => i) (List.range (n-1))) = n * (n+1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_mex 3 [1, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_tree_mex 5 [1, 1, 2, 2]"
      }
    ]
  },
  "fvapps_000766.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_nth_number (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- The function always returns positive integers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nth_number_positive (n : Nat) (h : n > 0) :\n  find_nth_number n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The first 5 elements follow a specific pattern -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sequence_initial_pattern :\n  find_nth_number 1 = 1 \u2227\n  find_nth_number 2 = 6 \u2227\n  find_nth_number 3 = 7 \u2227\n  find_nth_number 4 = 36 \u2227\n  find_nth_number 5 = 37 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For odd positions after 3, each number is previous number plus 1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem odd_index_increment (n : Nat) (h1 : n > 3) (h2 : n % 2 = 1) :\n  find_nth_number n = find_nth_number (n-1) + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_nth_number 3\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval find_nth_number 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_nth_number 1"
      }
    ]
  },
  "fvapps_000771.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_snuffles_array (n d : Nat) (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def verify_solution (n d: Nat) (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem snuffles_array_properties {n d : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : d > 0)\n  (h3 : d \u2264 n)\n  (h4 : arr.length = n) :\n  let result := solve_snuffles_array n d arr\n  (result \u2265 0 \u2192 verify_solution n d arr = true) \u2227\n  (result = -1 \u2192\n    (\u2203 i : Nat, i < d \u2227\n      let group := (List.range arr.length).filter (fun j => j % d = i)\n      let group_sum := list_sum (group.map (fun j => arr.get! j))\n      let group_avg := group_sum / group.length\n      group_avg \u2260 (list_sum arr / arr.length))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_equal_array_zero {n : Nat} {x : Int}\n  (h1 : n > 0) :\n  solve_snuffles_array n 1 (List.replicate n x) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_snuffles_array 5 2 [1, 4, 5, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_snuffles_array 3 1 [1, 4, 1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_snuffles_array 4 2 [3, 4, 3, 5]"
      }
    ]
  },
  "fvapps_000772.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_possible_strings (n : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem count_possible_strings_short_input (n : Nat) (s : String) :\n  n \u2264 s.length \u2192 count_possible_strings n s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_possible_strings_long_input (n : Nat) (s : String) :\n  n > s.length \u2192 count_possible_strings n s > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_possible_strings_monotone_in_string_length (s : String) :\n  let n := s.length + 2\n  count_possible_strings n s > count_possible_strings n (s.append \"a\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1326\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"a\"\n\n/-\ninfo: 76\n-/\n#guard_msgs in\n#eval count_possible_strings 3 \"ab\""
      }
    ]
  },
  "fvapps_000777.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def DAYS : List String := [\"saturday\", \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\"]\n\ndef indexOfDay (day: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solveCompetitionDuration (startDay endDay: String) (l r: Nat) : String \u2295 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem competition_duration_impossible {startDay endDay: String} {l r: Nat}\n  (h1: l \u2264 r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"impossible\") :\n  \u2200 x, l \u2264 x \u2192 x \u2264 r \u2192\n    x % 7 \u2260 ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem competition_duration_many {startDay endDay: String} {l r: Nat}\n  (h1: l \u2264 r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inl \"many\") :\n  \u2203 x y, l \u2264 x \u2227 x < y \u2227 y \u2264 r \u2227\n    x % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) \u2227\n    y % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem competition_duration_specific {startDay endDay: String} {l r n: Nat}\n  (h1: l \u2264 r)\n  (h2: solveCompetitionDuration startDay endDay l r = Sum.inr n) :\n  l \u2264 n \u2227 n \u2264 r \u2227\n  n % 7 = ((indexOfDay endDay - indexOfDay startDay + 8) % 7) \u2227\n  (\u2200 x, l \u2264 x \u2192 x < n \u2192 x % 7 \u2260 n % 7) \u2227\n  n + 7 > r :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_day_property {day: String}\n  (h: day \u2208 DAYS) :\n  solveCompetitionDuration day day 1 20 = Sum.inr 7 \u2228\n  solveCompetitionDuration day day 1 20 = Sum.inl \"many\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 2 4\n\n/-\ninfo: 'many'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"monday\" \"wednesday\" 1 20\n\n/-\ninfo: 'impossible'\n-/\n#guard_msgs in\n#eval solve_competition_duration \"saturday\" \"sunday\" 3 5"
      }
    ]
  },
  "fvapps_000780.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_min (n : Nat) (seq : String) : Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum : List Int \u2192 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum : List Int \u2192 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_permutation_invariant {nums1 nums2 : List Int} (n : Nat)\n  (seq1 seq2 : String)\n  (h1 : n = nums1.length)\n  (h2 : n = nums2.length)\n  (h3 : seq1 = String.intercalate \" \" (List.map toString nums1))\n  (h4 : seq2 = String.intercalate \" \" (List.map toString nums2))\n  (h5 : nums2.isPerm nums1) :\n  find_max_min n seq1 = find_max_min n seq2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_single_element (n : Nat) (x : Int) (seq : String)\n  (h1 : n = 1)\n  (h2 : seq = toString x) :\n  find_max_min n seq = (x, x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (9, 2)\n-/\n#guard_msgs in\n#eval find_max_min 5 \"3 2 7 9 4\"\n\n/-\ninfo: (10, 5)\n-/\n#guard_msgs in\n#eval find_max_min 3 \"10 5 8\"\n\n/-\ninfo: (1000, 250)\n-/\n#guard_msgs in\n#eval find_max_min 4 \"1000 250 750 500\""
      }
    ]
  },
  "fvapps_000789.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_largest_triangle (n : Nat) (nums : List Nat) : String \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_triangle (sides : List Nat) : Bool := sorry\n\ndef list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7+\u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_triangle_empty_input\n  (nums : List Nat) (h : nums.length < 3) :\n  find_largest_triangle nums.length nums = (\"NO\", []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_triangle_returns_valid\n  (nums : List Nat) (h : nums.length \u2265 3)\n  (h2 : (find_largest_triangle nums.length nums).1 = \"YES\") :\n  let result := (find_largest_triangle nums.length nums).2\n  is_valid_triangle result \u2227\n  result.length = 3 \u2227\n  \u2200 x \u2208 result, x \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_triangle_is_max\n  (nums : List Nat) (h : nums.length \u2265 3)\n  (h2 : (find_largest_triangle nums.length nums).1 = \"YES\") :\n  let result := (find_largest_triangle nums.length nums).2\n  \u2200 i j k, i < nums.length \u2192 j < nums.length \u2192 k < nums.length \u2192\n  i \u2260 j \u2192 j \u2260 k \u2192 i \u2260 k \u2192\n  is_valid_triangle [nums.get! i, nums.get! j, nums.get! k] \u2192\n  list_sum [nums.get! i, nums.get! j, nums.get! k] \u2264 list_sum result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_triangle_no_implies_no_valid\n  (nums : List Nat) (h : nums.length \u2265 3)\n  (h2 : (find_largest_triangle nums.length nums).1 = \"NO\") :\n  \u2200 i j k, i < nums.length \u2192 j < nums.length \u2192 k < nums.length \u2192\n  i \u2260 j \u2192 j \u2260 k \u2192 i \u2260 k \u2192\n  \u00acis_valid_triangle [nums.get! i, nums.get! j, nums.get! k] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_triangle_preserves_valid_triangle\n  (sides : List Nat) (h : sides.length = 3)\n  (h2 : is_valid_triangle sides) :\n  find_largest_triangle sides.length sides = (\"YES\", sides) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000793.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_x (n k : Nat) (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def compute_cost (x : Int) (k : Nat) (arr : List Int) : Int := sorry\n\ndef list_min (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => List.foldl min x xs"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => List.foldl max x xs"
      },
      {
        "type": "cond",
        "string": "theorem find_min_x_is_int {n k : Nat} {arr : List Int} (h : arr.length > 0)\n  (h1 : k > 0) (h2 : k \u2264 5) :\n  \u2203 (y : Int), find_min_x n k arr = y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_x_in_range {n k : Nat} {arr : List Int} (h : arr.length > 0)\n  (h1 : k > 0) (h2 : k \u2264 5) :\n  find_min_x n k arr \u2265 (list_min arr - n) \u2227\n  find_min_x n k arr \u2264 (list_max arr + n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_x_order_invariant {n k : Nat} {arr : List Int} (h : arr.length > 0)\n  (h1 : k > 0) (h2 : k \u2264 5) :\n  find_min_x n k arr = find_min_x n k arr.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_x_local_optimum {n k : Nat} {arr : List Int}\n  (h : arr.length \u2265 3) (h1 : k > 0) (h2 : k \u2264 3) :\n  let x := find_min_x n k arr\n  let cost := compute_cost x k arr\n  let nearby_costs := [compute_cost (x-2) k arr, compute_cost (x-1) k arr,\n                      compute_cost (x+1) k arr, compute_cost (x+2) k arr]\n  \u2200 c \u2208 nearby_costs, c \u2265 cost * (9/10) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_min_x 3 1 [6, 1, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_min_x 3 2 [6, 1, 7]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_x 3 3 [6, 1, 7]"
      }
    ]
  },
  "fvapps_000794.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def determine_winner (n : Nat) (cells : List Nat) : String := sorry\n\ndef is_valid_cell_list (cells : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  cells.all (fun x => x = 0 \u2228 x = 1)"
      },
      {
        "type": "sig",
        "string": "def count_max_consecutive_zeros (cells : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem winner_determined_by_max_zeros (n : Nat) (cells : List Nat)\n  (h : is_valid_cell_list cells) :\n  determine_winner n cells =\n    if count_max_consecutive_zeros cells % 2 = 1\n    then \"Yes\"\n    else \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem determine_winner_returns_yes_or_no (n : Nat) (cells : List Nat)\n  (h : is_valid_cell_list cells) :\n  determine_winner n cells = \"Yes\" \u2228 determine_winner n cells = \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_loses (n : Nat) :\n  determine_winner n (List.replicate n 1) = \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_winner (n : Nat) :\n  determine_winner n (List.replicate n 0) =\n    if n % 2 = 1\n    then \"Yes\"\n    else \"No\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval determine_winner 7 [1, 1, 0, 0, 0, 1, 1]\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval determine_winner 8 [1, 0, 1, 1, 1, 0, 0, 1]\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval determine_winner 4 [1, 1, 0, 1]"
      }
    ]
  },
  "fvapps_000804.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_components (n: Nat) (edges: List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_tree (n: Nat) (edges: List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_graph_components {n: Nat} (h: n \u2265 2) :\n  let edges := List.range (n-1) |>.map (\u03bbi => (i+1, i+2))\n  find_max_components n edges = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 7 [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_components 3 [(1, 2), (2, 3)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_components 4 [(1, 2), (1, 3), (1, 4)]"
      }
    ]
  },
  "fvapps_000809.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_ad_revenue (n: Nat) (team_strengths: List Nat) : Nat := sorry\n\ndef getPairs (l: List Nat) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => []\n  | x :: xs => (xs.map (fun y => (x, y))) ++ getPairs xs"
      },
      {
        "type": "sig",
        "string": "def abs (n: Nat) (m: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 m then n - m else m - n"
      },
      {
        "type": "sig",
        "string": "def pairSum (pairs: List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match pairs with\n  | [] => 0\n  | (x, y) :: rest => abs x y + pairSum rest"
      },
      {
        "type": "cond",
        "string": "theorem revenue_nonnegative (n: Nat) (team_strengths: List Nat)\n  (h1: n \u2265 2) (h2: team_strengths.length = n) :\n  calculate_ad_revenue n team_strengths \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem revenue_matches_manual_calc (n: Nat) (team_strengths: List Nat)\n  (h1: n \u2265 2) (h2: team_strengths.length = n) :\n  calculate_ad_revenue n team_strengths = pairSum (getPairs team_strengths) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem revenue_pair_count (n: Nat) (team_strengths: List Nat)\n  (h1: n \u2265 2) (h2: team_strengths.length = n) :\n  (getPairs team_strengths).length = n * (n-1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_strengths_zero_revenue (n: Nat) (x: Nat)\n  (h1: n \u2265 2) :\n  calculate_ad_revenue n (List.replicate n x) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_cases :\n  calculate_ad_revenue 2 [0, 0] = 0 \u2227\n  calculate_ad_revenue 2 [0, 1] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval calculate_ad_revenue 4 [3, 10, 3, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval calculate_ad_revenue 2 [1, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_ad_revenue 3 [10, 10, 10]"
      }
    ]
  },
  "fvapps_000812.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_interesting_subsequences (n k : Nat) (a : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sortList (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_interesting_subsequences_properties (n k : Nat) (a : List Nat)\n    (h1 : n > 0) (h2 : k > 0) (h3 : List.length a > 0) :\n    k \u2264 List.length a \u2192\n    0 \u2264 count_interesting_subsequences n k a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_input_equivalence (a : List Nat)\n    (h1 : List.length a \u2265 2) :\n    let k := List.length a / 2\n    count_interesting_subsequences (List.length a) k (sortList a) =\n    count_interesting_subsequences (List.length a) k a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem kth_element_boundary (a : List Nat)\n    (h1 : List.length a \u2265 2) (h2 : List.length a \u2264 10) :\n    let k := List.length a / 2\n    let sorted := sortList a\n    k > 0 \u2192\n    k \u2264 List.length a \u2192\n    \u2203 x, List.elem x a \u2227 x = List.get! sorted (k-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 4 2 [1, 2, 3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 3 2 [2, 2, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_interesting_subsequences 5 3 [1, 1, 2, 2, 3]"
      }
    ]
  },
  "fvapps_000817.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_velocity (n : Nat) (shops : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max_list (l : List Nat) : Nat := sorry\n\ndef enumerate_add (shops : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  let range := List.range shops.length\n  List.map (fun i => shops[i]! + i) range"
      },
      {
        "type": "cond",
        "string": "theorem min_velocity_greater_than_max_attractiveness (n : Nat) (shops : List Nat)\n  (h : shops.length > 0) :\n  find_min_velocity n shops \u2265 max_list shops :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_velocity_accounts_for_position (n : Nat) (shops : List Nat) (pos : Nat)\n  (h1 : pos < shops.length) (h2 : shops.length > 0) :\n  find_min_velocity n shops \u2265 shops[pos]! + pos :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_velocity_allows_decreasing_speeds (n : Nat) (shops : List Nat)\n  (h : shops.length \u2265 2) :\n  \u2200 i : Nat, i < shops.length \u2192\n  find_min_velocity n shops - i \u2265 shops[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_velocity_is_optimal (n : Nat) (shops : List Nat)\n  (h : shops.length > 0) :\n  find_min_velocity n shops = max_list (enumerate_add shops) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_min_velocity 5 [6, 5, 4, 3, 2]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_min_velocity 5 [3, 4, 3, 1, 1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_velocity 3 [4, 2, 1]"
      }
    ]
  },
  "fvapps_000823.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tweet_clicks (n : Nat) (clicks : List String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_click_command (n : Nat) (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_tweet_count (prev : Nat) (cmd : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_length_matches_input {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n \u2264 100) (h3 : clicks.length > 0) :\n  (solve_tweet_clicks n clicks).length = clicks.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem counts_are_nonnegative {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n \u2264 100) (h3 : clicks.length > 0) :\n  \u2200 x \u2208 solve_tweet_clicks n clicks, 0 \u2264 x \u2227 x \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closeall_resets_to_zero {n : Nat} {clicks : List String}\n  (h1 : n > 0) (h2 : n \u2264 100) (h3 : clicks.length > 0) :\n  \u2200 (i : Nat) (h : i < clicks.length),\n  clicks.get \u27e8i, h\u27e9 = \"CLOSEALL\" \u2192\n  (solve_tweet_clicks n clicks).get \u27e8i, by rw [output_length_matches_input h1 h2 h3]; exact h\u27e9 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 2, 3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 3 [\"CLICK 1\", \"CLICK 2\", \"CLICK 3\", \"CLICK 2\", \"CLOSEALL\", \"CLICK 1\"]\n\n/-\ninfo: [1, 2, 0]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 2 [\"CLICK 1\", \"CLICK 2\", \"CLOSEALL\"]\n\n/-\ninfo: [1, 0, 1]\n-/\n#guard_msgs in\n#eval solve_tweet_clicks 4 [\"CLICK 1\", \"CLICK 1\", \"CLICK 2\"]"
      }
    ]
  },
  "fvapps_000827.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_team_score (n : Nat) (ratings : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs\n\ndef take_last (n : Nat) (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  let rev := l.reverse\n  (rev.take n).reverse"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_upper_bound\n  (ratings : List Nat) (h : ratings.length \u2265 3) :\n  find_max_team_score ratings.length ratings \u2264 list_sum (take_last 3 ratings) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_lower_bound\n  (ratings : List Nat) (h : ratings.length \u2265 3) :\n  find_max_team_score ratings.length ratings \u2265 list_sum (ratings.take 3) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_three_elements\n  (ratings : List Nat) (h : ratings.length = 3) :\n  find_max_team_score ratings.length ratings = list_sum ratings :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_consecutive\n  (ratings : List Nat) (h : ratings.length \u2265 3) (i : Nat) (hi : i + 2 < ratings.length) :\n  find_max_team_score ratings.length ratings \u2265\n    ratings[i]! + ratings[i+1]! + ratings[i+2]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_wrapping\n  (ratings : List Nat) (h : ratings.length \u2265 3) (i : Nat) :\n  find_max_team_score ratings.length ratings \u2265\n    ratings[i % ratings.length]! +\n    ratings[(i + 1) % ratings.length]! +\n    ratings[(i + 2) % ratings.length]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_team_score_all_equal\n  (n : Nat) (h : n \u2265 3) :\n  find_max_team_score n (List.replicate n 1) = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [10, 40, 30, 30, 20, 0, 0]\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval find_max_team_score 7 [50, 20, 30, 10, 40, 15, 25]\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval find_max_team_score 3 [10, 20, 30]"
      }
    ]
  },
  "fvapps_000829.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd : Nat \u2192 Nat \u2192 Nat\n| a, b => sorry"
      },
      {
        "type": "sig",
        "string": "def max_gcd_sum : List Nat \u2192 Nat\n| xs => sorry"
      },
      {
        "type": "sig",
        "string": "def list_max : List Nat \u2192 Nat\n| [] => 0\n| (x::xs) => max x (list_max xs)"
      },
      {
        "type": "sig",
        "string": "def list_min : List Nat \u2192 Nat\n| [] => 0\n| (x::xs) => min x (list_min xs)"
      },
      {
        "type": "cond",
        "string": "theorem matches_reference (nums : List Nat) (h : \u2200 x \u2208 nums, x > 0) :\n  \u2203 result, max_gcd_sum nums = result := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_larger_than_input (nums : List Nat) (h : \u2200 x \u2208 nums, x > 0) :\n  max_gcd_sum nums \u2265 list_max nums \u2227 max_gcd_sum nums \u2265 list_min nums := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_handling (nums : List Nat) (dupes : List Nat)\n  (h : \u2200 x \u2208 nums, x > 0) (h2 : \u2200 x \u2208 dupes, x \u2208 nums) :\n  max_gcd_sum nums = max_gcd_sum (nums ++ dupes) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element (x : Nat) (h : x > 0) :\n  max_gcd_sum [x] = 2 * x := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval max_gcd_sum [4, 4, 7, 6]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gcd_sum [2, 2, 2]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval max_gcd_sum [3, 6, 9, 12]"
      }
    ]
  },
  "fvapps_000835.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_race_wins (n : Nat) (my_times : List Nat) (opp_times: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDescending (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < l.length \u2192 j < l.length \u2192 i < j \u2192\n    match l.get? i, l.get? j with\n    | some x, some y => x \u2265 y\n    | _, _ => True"
      },
      {
        "type": "cond",
        "string": "theorem max_race_wins_result_bounds {n : Nat} {my_times opp_times : List Nat}\n  (h1 : n > 0) (h2 : n \u2264 100)\n  (h3 : \u2200 x \u2208 my_times, 1 \u2264 x \u2227 x \u2264 1000)\n  (h4 : \u2200 x \u2208 opp_times, 1 \u2264 x \u2227 x \u2264 1000) :\n  let result := max_race_wins n my_times opp_times\n  0 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_race_wins_length {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : n > 0)\n  (h2 : my_times_out.length = n)\n  (h3 : opp_times_out.length = n)\n  (h4 : max_race_wins n my_times opp_times > 0) : True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_race_wins_sorted {n : Nat} {my_times opp_times my_times_out opp_times_out : List Nat}\n  (h1 : max_race_wins n my_times opp_times > 0)\n  (h2 : isDescending my_times_out)\n  (h3 : isDescending opp_times_out) : True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 3 [5, 4, 1] [5, 4, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_race_wins 2 [3, 1] [2, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_race_wins 4 [5, 4, 3, 2] [6, 5, 4, 1]"
      }
    ]
  },
  "fvapps_000838.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_banana_speed (pile_count : Nat) (hours : Nat) (piles : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "sig",
        "string": "def nat_ceil_div (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (a + b - 1) / b"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_singleton_one :\n  min_banana_speed 1 1 [1] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_singleton_hundred :\n  min_banana_speed 1 1 [100] = 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_two_ones :\n  min_banana_speed 2 2 [1, 1] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_banana_speed 3 3 [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_banana_speed 3 4 [1, 2, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_banana_speed 4 5 [4, 3, 2, 7]"
      }
    ]
  },
  "fvapps_000842.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_special_sum (n: Int) (k: Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_case (n: Int) (k: Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pow (x: Int) (n: Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => 1\n  | n + 1 => x * pow x n"
      },
      {
        "type": "cond",
        "string": "theorem calculate_special_sum_nonnegative\n  (n: Int) (k: Int)\n  (hn: n \u2265 0) (hk: k \u2265 2) (hk2: k \u2264 100) :\n  calculate_special_sum n k \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_special_sum_upper_bound\n  (n: Int) (k: Int) (power: Nat)\n  (hn: n \u2265 0) (hk: k \u2265 2) (hk2: k \u2264 100)\n  (hp: pow k power \u2264 n) :\n  calculate_special_sum n k \u2264 (n * (n+1))/2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_special_sum_negative_input\n  (n: Int) (k: Int)\n  (hn: n < 0) (hk: k \u2265 2) (hk2: k \u2264 100) :\n  calculate_special_sum n k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_case_format\n  (n: Int) (k: Int)\n  (hn: n \u2265 0) (hk: k \u2265 2) (hk2: k \u2264 100) :\n  solve_case n k = \"Case #1: \" ++ toString (calculate_special_sum n k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000844.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_beautiful_subarrays (n k : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_array (arr : List Nat) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sorted (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_bounds (n k : Nat) (arr : List Nat) :\n  1 \u2264 n \u2227 n \u2264 100 \u2227\n  1 \u2264 k \u2227 k \u2264 100 \u2227\n  arr.length = n \u2227\n  (\u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 2000) \u2192\n  0 \u2264 count_beautiful_subarrays n k arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_arrays (n k : Nat) :\n  1 \u2264 n \u2227 n \u2264 10 \u2227\n  1 \u2264 k \u2227 k \u2264 10 \u2192\n  n \u2264 count_beautiful_subarrays n k (List.replicate n 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_vs_unsorted (n k : Nat) (arr : List Nat) :\n  1 \u2264 n \u2227 n \u2264 10 \u2227\n  1 \u2264 k \u2227 k \u2264 10 \u2227\n  is_valid_array arr n \u2192\n  count_beautiful_subarrays n k (list_sorted arr) = count_beautiful_subarrays n k arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_case (k : Nat) :\n  1 \u2264 k \u2227 k \u2264 10 \u2192\n  count_beautiful_subarrays 1 k [1] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 3 3 [1, 2, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 1 1 [1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_beautiful_subarrays 2 2 [2, 1]"
      }
    ]
  },
  "fvapps_000847.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_ant_grid (R C : Nat) (grid : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_direction (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = 'U' || c = 'D' || c = 'L' || c = 'R'"
      },
      {
        "type": "sig",
        "string": "def make_empty_string (n : Nat) (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_directions (grid : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_ant_grid_output_props (R C : Nat) (grid : List String)\n  (h : R > 0 \u2227 C > 0) :\n  let result := solve_ant_grid R C grid;\n  result \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_grid_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 \u2227 C > 0)\n  (h2 : \u2200 (row : String), row \u2208 grid \u2192 \u2200 (c : Char), c \u2208 row.data \u2192 (c = '-' \u2228 c = '#')) :\n  solve_ant_grid R C grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_ant_zero_pairs (R C : Nat) (grid : List String)\n  (h1 : R > 0 \u2227 C > 0)\n  (h2 : count_directions grid \u2264 1) :\n  solve_ant_grid R C grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_empty_grid_zero (R C : Nat) (h : R > 0 \u2227 C > 0) :\n  let empty_row := make_empty_string C '-';\n  let grid := List.replicate R empty_row;\n  solve_ant_grid R C grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_walls_grid_zero (R C : Nat) (h : R > 0 \u2227 C > 0) :\n  let wall_row := make_empty_string C '#';\n  let grid := List.replicate R wall_row;\n  solve_ant_grid R C grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_ant_top_left_zero (R C : Nat) (ant : Char)\n  (h1 : R > 0 \u2227 C > 0)\n  (h2 : is_direction ant) :\n  let first_row := (String.push (make_empty_string (C-1) '-') ant);\n  let empty_row := make_empty_string C '-';\n  let rest_rows := List.replicate (R-1) empty_row;\n  let grid := first_row :: rest_rows;\n  solve_ant_grid R C grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"R--\", \"---\", \"--U\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_ant_grid 1 4 [\"-R-L\"]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_ant_grid 3 3 [\"-D-\", \"R-L\", \"-U-\"]"
      }
    ]
  },
  "fvapps_000850.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_topics_prepared (N M S : Nat) (topic_hours : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_any (l : List Nat) (f : Nat \u2192 Bool) : Bool := sorry\n\ndef list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h :: t => h + list_sum t"
      },
      {
        "type": "cond",
        "string": "theorem max_topics_non_negative (N M S : Nat) (topic_hours : List Nat) :\n  N > 0 \u2192 M > 0 \u2192 S > 0 \u2192 S \u2264 16 \u2192 topic_hours.length > 0 \u2192\n  max_topics_prepared N M S topic_hours \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_topics_bounded_by_length (N M S : Nat) (topic_hours : List Nat) :\n  N > 0 \u2192 M > 0 \u2192 S > 0 \u2192 S \u2264 16 \u2192 topic_hours.length > 0 \u2192\n  max_topics_prepared N M S topic_hours \u2264 topic_hours.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_topics_zero_when_s_too_large (N M S : Nat) (topic_hours : List Nat) :\n  N > 0 \u2192 M > 0 \u2192 S \u2265 17 \u2192 topic_hours.length > 0 \u2192\n  max_topics_prepared N M S topic_hours = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_topics_bounded_by_feasible (N M S : Nat) (topic_hours : List Nat) :\n  N > 0 \u2192 M > 0 \u2192 S > 0 \u2192 S \u2264 16 \u2192 topic_hours.length > 0 \u2192\n  max_topics_prepared N M S topic_hours \u2264\n    (List.countP (fun h => h/S \u2264 2) topic_hours) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_topics_prepared 5 4 10 [10, 24, 30, 19, 40]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_topics_prepared 5 4 16 [7, 16, 35, 10, 15]"
      }
    ]
  },
  "fvapps_000855.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Float.ofString? (s: String) : Option Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Float.ofString! (s: String) : Float := (Float.ofString? s).get!"
      },
      {
        "type": "sig",
        "string": "def calculate_donut_areas (radii : List Int) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_donut_areas_length_match (radii : List Int) :\n  (calculate_donut_areas radii).length = radii.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_donut_areas_decimal_format (radii : List Int) (result : String) :\n  result \u2208 calculate_donut_areas radii \u2192\n  (\u2203 n d : String, result = n ++ \".\" ++ d \u2227 d.length = 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_donut_areas_accuracy (radius : Int) :\n  let area := calculate_donut_areas [radius]\n  let expected := (Float.ofInt (radius * radius)) * 3.14\n  let actual := Float.ofString! area.head!\n  (actual - expected).abs < 0.01 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_donut_areas_negative_valid (radii : List Int)\n  (h : \u2200 r \u2208 radii, r < 0) :\n  (calculate_donut_areas radii).length = radii.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000864.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_proxy_attendance (D : Nat) (S : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countP (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_range {D : Nat} {S : String} (h : D \u2265 5) (h2 : D \u2264 100) (h3 : S.length = D) :\n  let result := solve_proxy_attendance D S\n  result = -1 \u2228 result \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_present {D : Nat} (h : D \u2265 5) (h2 : D \u2264 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'P')) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem too_many_absences {D : Nat} (h : D \u2265 5) (h2 : D \u2264 100) :\n  solve_proxy_attendance D (String.mk (List.replicate D 'A')) = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 9 \"PAAPPAPPP\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 5 \"PAAAA\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_proxy_attendance 8 \"PPPPPPPP\""
      }
    ]
  },
  "fvapps_000867.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_steps (i j : Nat) (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max : List Nat \u2192 Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (list_max xs)\n\ndef iterate_steps (i j steps : Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  match steps with\n  | 0 => (i, j)\n  | n+1 =>\n    let (cur_i, cur_j) := iterate_steps i j n\n    if cur_i \u2264 cur_j then\n      (cur_i + cur_j, cur_j)\n    else\n      (cur_i, cur_j + cur_i)"
      },
      {
        "type": "cond",
        "string": "theorem find_min_steps_nonnegative {i j : Nat} {nums : List Nat} :\n  find_min_steps i j nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_steps_monotonic {i j target : Nat} (hi : i > 1) (hj : j > 1) :\n  find_min_steps i j [target] \u2264 find_min_steps (i-1) (j-1) [target] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 1 2 [5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_steps 2 2 [3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_steps 1 1 [3, 4, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_min_steps 2 1 [5]"
      }
    ]
  },
  "fvapps_000878.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def IsFinite (x : Float) : Prop := sorry\n\ndef find_mirror_position (x1 y1 x2 y2 : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_mirror_position_basic_properties\n  (x1 y1 x2 y2 : Float)\n  (h1 : abs (x2 - x1) > 1e-6)  -- Not vertical\n  (h2 : abs (y2 + y1) > 1e-6)  -- Avoid division by zero\n  : IsFinite (find_mirror_position x1 y1 x2 y2) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_000879.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max : List Nat \u2192 Nat\n| [] => 0\n| [x] => x\n| (x::xs) => Nat.max x (max xs)"
      },
      {
        "type": "sig",
        "string": "def sum : List Nat \u2192 Nat\n| [] => 0\n| (x::xs) => x + sum xs\n\ndef can_cyborg_escape (n : Nat) (target : Nat) (powers : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse : List Nat \u2192 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem target_less_than_max_always_possible\n  (powers : List Nat) (target : Nat) (h1 : powers \u2260 []) :\n  target \u2264 max powers \u2192 can_cyborg_escape (powers.length) target powers = true := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem target_greater_than_sum_impossible\n  (powers : List Nat) (extra : Nat) (h1 : powers \u2260 []) :\n  let target := sum powers + extra + 1\n  can_cyborg_escape (powers.length) target powers = false := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem symmetric_input\n  (powers : List Nat) (h1 : powers \u2260 []) :\n  let target := sum powers / 2\n  can_cyborg_escape (powers.length) target powers =\n    can_cyborg_escape (powers.length) target (reverse powers) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 4 8 [5, 1, 4, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_cyborg_escape 3 4 [3, 1, 2]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_cyborg_escape 2 7 [5, 5]"
      }
    ]
  },
  "fvapps_000882.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_valid_snake_procession (report : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_segment (s\u2081 s\u2082 : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_snake_formations (report : String) :\n  (\u2200 i j : String.Pos, j.1 = i.1 + 1 \u2192\n    (report.get i = '.' \u2228 (report.get i = 'H' \u2227 report.get j = 'T'))) \u2192\n  check_valid_snake_procession report = \"Valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_counts_if_valid (report : String) :\n  check_valid_snake_procession report = \"Valid\" \u2192\n  let h_count := report.toList.filter (\u00b7 = 'H') |>.length\n  let t_count := report.toList.filter (\u00b7 = 'T') |>.length\n  h_count = t_count :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem running_count_bounds_if_valid (report : String) (n : Nat) :\n  check_valid_snake_procession report = \"Valid\" \u2192\n  n \u2264 report.length \u2192\n  let h_count := (report.take n).toList.filter (\u00b7 = 'H') |>.length\n  let t_count := (report.take n).toList.filter (\u00b7 = 'T') |>.length\n  let count := h_count - t_count\n  count \u2265 0 \u2227 count \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"..H..T...HTH....T.\"\n\n/-\ninfo: 'Invalid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"H..H..T..T\"\n\n/-\ninfo: 'Valid'\n-/\n#guard_msgs in\n#eval check_valid_snake_procession \"HT\""
      }
    ]
  },
  "fvapps_000887.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_min_distance (n k : Nat) (x : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper functions for max/min"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listMax (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | (h::t) => List.foldl max h t"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | (h::t) => List.foldl min h t"
      },
      {
        "type": "sig",
        "string": "def listToSorted (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => []\n  | (h::t) => h :: t -- simplified for theorem statement"
      },
      {
        "type": "comment",
        "string": "-- Non-negative result"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def generateRange (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  List.map Int.ofNat (List.range n)"
      },
      {
        "type": "comment",
        "string": "-- Evenly spaced points"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_distance_nonneg\n    {n k : Nat} {x : List Int}\n    (h1 : n \u2265 2)\n    (h2 : k \u2265 2)\n    (h3 : k \u2264 n)\n    (h4 : x.length = n)\n    (h5 : \u2200 i \u2208 x, i \u2265 1 \u2227 i \u2264 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result bounded by max distance"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_distance_bounded\n    {n k : Nat} {x : List Int}\n    (h1 : n \u2265 2)\n    (h2 : k \u2265 2)\n    (h3 : k \u2264 n)\n    (h4 : x.length = n)\n    (h5 : \u2200 i \u2208 x, i \u2265 1 \u2227 i \u2264 1000)\n    (h6 : x.Nodup) :\n    find_max_min_distance n k x \u2264 listMax x - listMin x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Special case for k=2"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_distance_k2\n    {n : Nat} {x : List Int}\n    (h1 : n \u2265 2)\n    (h2 : x.length = n)\n    (h3 : \u2200 i \u2208 x, i \u2265 1 \u2227 i \u2264 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x \u2264 listMax x - listMin x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Sorting invariance"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_distance_sort_invariant\n    {n : Nat} {x : List Int}\n    (h1 : n \u2265 2)\n    (h2 : x.length = n)\n    (h3 : \u2200 i \u2208 x, i \u2265 1 \u2227 i \u2264 1000)\n    (h4 : x.Nodup) :\n    find_max_min_distance n 2 x = find_max_min_distance n 2 (listToSorted x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Evenly spaced integers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_max_min_distance_evenly_spaced\n    {n k : Nat}\n    (h1 : n \u2265 2)\n    (h2 : k \u2265 2)\n    (h3 : k \u2264 n) :\n    find_max_min_distance n k (generateRange n) = (n-1) / (k-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_min_distance 2 2 [1, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 5 3 [1, 2, 8, 4, 9]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_min_distance 4 2 [1, 2, 3, 4]"
      }
    ]
  },
  "fvapps_000888.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def fst_minus (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if a \u2265 b then a - b else b - a"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_delivery_time (n m k : Nat) (deliveries : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_delivery_time_non_negative (n m k : Nat) (deliveries : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) :\n  min_delivery_time n m k deliveries \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_delivery_time_same_point (n : Nat) :\n  let m := n\n  let deliveries := [(1,1,1,1)]\n  min_delivery_time n m 1 deliveries = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_delivery_time_bounded (n m k : Nat) (deliveries : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) :\n  min_delivery_time n m k deliveries \u2264\n    list_sum (deliveries.map (fun (d: Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat) =>\n      let (x1, y1, x2, y2) := d\n      2 * (fst_minus x1 x2 + fst_minus y1 y2))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_delivery_time 5 4 3 [[2, 3, 4, 1], [1, 4, 5, 2], [3, 3, 5, 3]]\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval min_delivery_time 10 2 3 [[1, 2, 10, 2], [2, 1, 9, 1], [4, 1, 7, 1]]"
      }
    ]
  },
  "fvapps_000891.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_min_pairs (n : Nat) (k : Int) (arr : List Int) : Int \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_pairs_with_diff (arr : List Int) (k : Int) (min_diff : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_min_pairs_nonneg_diff (n : Nat) (k : Int) (arr : List Int)\n  (h1: n \u2265 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  min_diff \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_min_pairs_positive_count (n : Nat) (k : Int) (arr : List Int)\n  (h1: n \u2265 2) (h2: arr.length = n) :\n  let (_, count) := solve_min_pairs n k arr\n  count > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_min_pairs_count_accurate (n : Nat) (k : Int) (arr : List Int)\n  (h1: n \u2265 2) (h2: arr.length = n) :\n  let (min_diff, count) := solve_min_pairs n k arr\n  count_pairs_with_diff arr k min_diff = count := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_min_pairs_minimal (n : Nat) (k : Int) (arr : List Int)\n  (h1: n \u2265 2) (h2: arr.length = n) :\n  let (min_diff, _) := solve_min_pairs n k arr\n  \u2200 i j, 0 \u2264 i \u2227 i < n \u2227 j > i \u2227 j < n \u2192\n    let diff := arr[i]! + arr[j]! - k\n    if diff \u2265 0 then diff \u2265 min_diff else -diff \u2265 min_diff := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_min_pairs_permutation_invariant (n : Nat) (k : Int) (arr1 arr2 : List Int)\n  (h1: n \u2265 2) (h2: arr1.length = n) (h3: arr2.length = n)\n  (h4: arr2.Perm arr1) :\n  solve_min_pairs n k arr1 = solve_min_pairs n k arr2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: (1, 4)\n-/\n#guard_msgs in\n#eval solve_min_pairs 4 9 [4, 4, 2, 6]\n\n/-\ninfo: (2, 1)\n-/\n#guard_msgs in\n#eval solve_min_pairs 2 10 [3, 5]\n\n/-\ninfo: (4, 3)\n-/\n#guard_msgs in\n#eval solve_min_pairs 3 12 [4, 4, 4]"
      }
    ]
  },
  "fvapps_000896.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_unique_balls (arr1 arr2 : List Int) : List Int := sorry\n\ndef isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | [_] => true\n  | x::y::xs => x \u2264 y \u2227 isSorted (y::xs)"
      },
      {
        "type": "sig",
        "string": "def count (x : Int) (l : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h::t => (if h = x then 1 else 0) + count x t"
      },
      {
        "type": "cond",
        "string": "theorem unique_balls_elements_from_inputs {arr1 arr2 : List Int} :\n  let result := find_unique_balls arr1 arr2\n  \u2200 x \u2208 result, x \u2208 arr1 ++ arr2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_arrays_empty {arr : List Int} :\n  find_unique_balls arr arr = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 5, 6]\n-/\n#guard_msgs in\n#eval find_unique_balls [1, 2, 3, 4] [2, 3, 4, 5, 6]\n\n/-\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval find_unique_balls [1, 2, 3] [4, 5, 6]\n\n/-\ninfo: [4]\n-/\n#guard_msgs in\n#eval find_unique_balls [1, 1, 2, 3] [2, 2, 3, 4]"
      }
    ]
  },
  "fvapps_000902.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_bulb_fluctuations (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countSquaresNotDiv3 (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_non_negative (n: Nat) :\n  solve_bulb_fluctuations n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_less_than_input (n: Nat) :\n  solve_bulb_fluctuations n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_edge_cases_0 :\n  solve_bulb_fluctuations 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_edge_cases_1 :\n  solve_bulb_fluctuations 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_edge_cases_2 :\n  solve_bulb_fluctuations 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_edge_cases_3 :\n  solve_bulb_fluctuations 3 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_edge_cases_9 :\n  solve_bulb_fluctuations 9 = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 20\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_bulb_fluctuations 100"
      }
    ]
  },
  "fvapps_000904.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def generate_pattern (n : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumRange (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_numbers (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  \u2200 i, i < n \u2192 (pattern.get! i).get! 0 = sumRange 1 (i+2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_differences (n : Nat) (h : n > 0) :\n  let pattern := generate_pattern n\n  \u2200 i j, i < n \u2192 j + 1 < (pattern.get! i).length \u2192\n    let row := pattern.get! i\n    let diff := row.get! (j+1) - row.get! j\n    if j + i + 1 < n\n      then diff = j + i + 1\n      else diff = 2*n - (j + i + 1) - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000917.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_subarray_sum (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => max x (list_max xs)"
      },
      {
        "type": "sig",
        "string": "def list_min : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => min x (list_min xs)"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => x + list_sum xs"
      },
      {
        "type": "sig",
        "string": "def get_subarrays (arr : List Int) : List (List Int) := sorry\n\ndef subarray_sums (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  (get_subarrays arr).map list_sum"
      },
      {
        "type": "cond",
        "string": "theorem max_subarray_sum_at_least_one_element {arr : List Int} (h : arr \u2260 []) :\n  find_max_subarray_sum arr \u2265 list_max arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_subarray_sum_positive_only {arr : List Int} (h : arr \u2260 [])\n  (h_pos : \u2200 x \u2208 arr, x \u2265 0) :\n  find_max_subarray_sum arr \u2265 list_sum arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_subarray_sum_empty_and_nonempty (arr : List Int) :\n  (arr = [] \u2192 find_max_subarray_sum arr = 0) \u2227\n  (arr \u2260 [] \u2192 find_max_subarray_sum arr \u2265 list_min arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_subarray_contiguous {arr : List Int} (h : arr \u2260 []) :\n  find_max_subarray_sum arr = list_max (subarray_sums arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_subarray_base_cases :\n  find_max_subarray_sum [] = 0 \u2227\n  find_max_subarray_sum [0] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_subarray_sum [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval find_max_subarray_sum arr2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_max_subarray_sum arr3\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_max_subarray_sum arr4\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_max_subarray_sum arr5"
      }
    ]
  },
  "fvapps_000919.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_bucket_probability (N K : Nat) (arr : List (List Nat)) : List Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_float (xs : List Float) : Float := sorry\n\ndef list_sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem bucket_probability_properties\n  (N K : Nat) (arr : List (List Nat))\n  (h1 : N > 0)\n  (h2 : K > 0)\n  (h3 : \u2200 row \u2208 arr, row.length = K \u2227 list_sum row > 0)\n  (result := solve_bucket_probability N K arr) :\n  result.length = K \u2227\n  (sum_float result - 1).abs < 0.000001 \u2227\n  \u2200 p \u2208 result, 0 \u2264 p \u2227 p \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bucket_single_bucket\n  (result := solve_bucket_probability 1 1 [[1]]) :\n  (result[0]! - 1).abs < 0.000001 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bucket_equal_prob_1\n  (result := solve_bucket_probability 1 2 [[1, 1]]) :\n  \u2200 r \u2208 result, (r - 0.5).abs < 0.000001 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bucket_equal_prob_2\n  (result := solve_bucket_probability 2 2 [[1, 1], [1, 1]]) :\n  \u2200 r \u2208 result, (r - 0.5).abs < 0.000001 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000923.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Building := Int \u00d7 Int \u00d7 Int \u00d7 Int\n\ndef av (buildings : List Building) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def val (buildings : List Building) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def diff (l1 l2 : List Building) : List Building :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem av_nonnegative (buildings : List Building) :\n  av buildings \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem val_nonnegative (buildings : List Building) :\n  val buildings \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem av_sum_fourth (buildings : List Building) :\n  av buildings = buildings.foldl (\u03bb acc b => acc + b.2.2.2) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem val_sum_third (buildings : List Building) :\n  val buildings = buildings.foldl (\u03bb acc b => acc + b.2.2.1) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem diff_properties (l1 l2 : List Building) :\n  \u2200 x \u2208 diff l1 l2, x \u2208 l1 \u2227 x \u2209 l2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000928.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Point := Float \u00d7 Float\n\ndef calc_expected_area (n: Nat) (vertices: List Point) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (xs : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::xs => xs.foldl max x"
      },
      {
        "type": "other",
        "string": "/- Helper function to get the minimum value from a list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def list_min (xs : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::xs => xs.foldl min x"
      },
      {
        "type": "cond",
        "string": "theorem area_is_non_negative {n: Nat} {vertices: List Point} :\n  vertices.length = n \u2192 n \u2265 3 \u2192\n  calc_expected_area n vertices \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get the maximum value from a list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem area_smaller_than_bounding_box {n: Nat} {vertices: List Point} :\n  vertices.length = n \u2192 n \u2265 3 \u2192\n  let xs := vertices.map (\u00b7.1)\n  let ys := vertices.map (\u00b7.2)\n  calc_expected_area n vertices \u2264 (list_max xs - list_min xs) * (list_max ys - list_min ys) + 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem area_invariant_under_translation {n: Nat} {vertices: List Point}\n  {dx dy: Float} :\n  vertices.length = n \u2192 n \u2265 3 \u2192\n  let translated := vertices.map (fun (x, y) => (x + dx, y + dy))\n  (calc_expected_area n vertices - calc_expected_area n translated).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem area_scales_quadratically {n: Nat} {vertices: List Point} :\n  vertices.length = n \u2192 n \u2265 3 \u2192\n  let scaled := vertices.map (fun (x, y) => (2*x, 2*y))\n  (calc_expected_area n scaled - 4 * calc_expected_area n vertices).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000939.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_path_costs (n: Nat) (parents: List Nat) (values: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n: Nat) (parents: List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_length_matches_input\n  (n: Nat) (values: List Nat) (parents: List Nat) :\n  (n > 0) \u2192\n  (n > values.length \u2192 True) \u2192\n  (parents = List.replicate (n-1) 1) \u2192\n  (calculate_path_costs n parents (values.take n)).length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_costs_increase_with_depth\n  (n: Nat) (parent_nodes: List Nat) (values: List Nat) :\n  (n \u2265 2) \u2192\n  (parent_nodes.length = n-1) \u2192\n  (values.length \u2265 n) \u2192\n  (is_valid_tree n parent_nodes = true) \u2192\n  \u2200 i, i \u2265 1 \u2192 i < n \u2192\n    let result := calculate_path_costs n parent_nodes (values.take n)\n    result.length = n \u2192\n    (i-1) < parent_nodes.length \u2192\n    parent_nodes[i-1]! - 1 < result.length \u2192\n    result[i]! \u2265 result[parent_nodes[i-1]! - 1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000943.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.minimum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_min_height_diff (n : Nat) (k : Nat) (heights : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_height_diff_single_window {n : Nat} {heights : List Int}\n  (h1 : heights.length > 0)\n  (h2 : heights.length = n)\n  : find_min_height_diff n 1 heights = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_height_diff 5 3 [10, 15, 11, 14, 12]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_height_diff 4 2 [4, 2, 1, 3]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval find_min_height_diff 6 4 [5, 10, 15, 20, 25, 30]"
      }
    ]
  },
  "fvapps_000944.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_diff (N : Nat) (K : Nat) (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sort (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_diff_non_negative (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_diff_reverse_invariant (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length > 0) :\n  find_max_diff N K arr = find_max_diff N K arr.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_diff_single_element (N : Nat) (K : Nat) (arr : List Int)\n    (h : arr.length = 1) :\n  find_max_diff N K arr = 2 * K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_diff 4 3 [4, 2, 5, 1]\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval find_max_diff 3 5 [2, 5, 3]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_diff 2 2 [1, 3]"
      }
    ]
  },
  "fvapps_000952.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_horse_skill_diff (n : Nat) (skills : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is non-negative"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_horse_skill_diff_nonneg {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length \u2265 2) :\n  min_horse_skill_diff n skills \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is at most the range of skills"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_horse_skill_diff_le_range {n : Nat} {skills : List Nat}\n  (h : skills.length = n) (h2 : skills.length \u2265 2) :\n  min_horse_skill_diff n skills \u2264 list_max skills - list_min skills :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is at most any adjacent difference in sorted elements"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_horse_skill_diff_le_adjacent {n : Nat} {skills : List Nat} {i : Nat}\n  (h : skills.length = n) (h2 : skills.length \u2265 2) (h3 : i < skills.length - 1) :\n  min_horse_skill_diff n skills \u2264\n    (list_sort skills).get! (i+1) - (list_sort skills).get! i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is invariant under list reordering"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_horse_skill_diff_order_inv {n : Nat} {skills shuffled : List Nat}\n  (h : skills.length = n) (h2 : skills.length \u2265 2)\n  (h3 : list_sort skills = list_sort shuffled) :\n  min_horse_skill_diff n skills = min_horse_skill_diff n shuffled :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- n must match list length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_horse_skill_diff_invalid {n : Nat} {skills : List Nat}\n  (h : skills.length \u2260 n) :\n  min_horse_skill_diff n skills = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 5 [4, 9, 1, 32, 13]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 3 [4, 5, 6]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval min_horse_skill_diff 4 [1, 10, 100, 1000]"
      }
    ]
  },
  "fvapps_000956.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_longest_dividing_subsequence (nums: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def powers_of_two : List Nat :="
      },
      {
        "type": "impl",
        "string": "  let rec mk_powers : Nat \u2192 List Nat\n    | 0 => []\n    | n+1 => if (2^n \u2264 1000) then (2^n)::(mk_powers n) else mk_powers n\n  mk_powers 10"
      },
      {
        "type": "cond",
        "string": "theorem length_bounds {nums: List Nat}\n  (h1: \u2200 x \u2208 nums, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2: nums.length > 0) :\n  1 \u2264 find_longest_dividing_subsequence nums \u2227\n  find_longest_dividing_subsequence nums \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem powers_of_two_sequence :\n  find_longest_dividing_subsequence powers_of_two = powers_of_two.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_divisible_sequence {nums: List Nat}\n  (h1: \u2200 x \u2208 nums, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2: nums.length \u2265 2)\n  (h3: \u2200 (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val \u2192 (nums.get j) % (nums.get i) = 0)\n  (h4: \u2200 (i: Fin nums.length) (j: Fin nums.length),\n    i.val < j.val \u2192 nums.get i \u2264 nums.get j) :\n  find_longest_dividing_subsequence nums = nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_case_singleton :\n  find_longest_dividing_subsequence [1] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 3, 7, 8, 14, 39, 145, 76, 320]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [2, 11, 16, 12, 36, 60, 71, 17, 29, 144, 288, 129, 432, 993]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest_dividing_subsequence [1, 2, 4, 8]"
      }
    ]
  },
  "fvapps_000957.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_building_arrangement (n k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def nums_to_nat_list (s : String) : List Nat := sorry\n\ndef range_from_one (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  List.range n |>.map (\u00b7 + 1)"
      },
      {
        "type": "sig",
        "string": "def list_to_string (l : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  l.map toString |>.intersperse \" \" |>.foldl (\u00b7 ++ \u00b7) \"\""
      },
      {
        "type": "cond",
        "string": "theorem zero_distance_ascending (n : Nat) (h : n \u2265 2) :\n  find_building_arrangement n 0 = list_to_string (range_from_one n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_case_three_two :\n  find_building_arrangement 3 2 = \"CAPTAIN AMERICA EVADES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_case_two_two :\n  find_building_arrangement 2 2 = \"CAPTAIN AMERICA EVADES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_arrangement_condition (n k : Nat) (s : String) :\n  let nums := nums_to_nat_list s\n  find_building_arrangement n k = s \u2192\n  (s = \"CAPTAIN AMERICA EVADES\" \u2228\n  (nums.length = n \u2227\n   nums.mergeSort (\u00b7 \u2264 \u00b7) = range_from_one n \u2227\n   \u2200 i j, i < nums.length \u2192 j < nums.length \u2192\n     (if i \u2265 j then i - j else j - i) = k \u2192\n     (if nums[i]! \u2265 nums[j]! then nums[i]! - nums[j]! else nums[j]! - nums[i]!) = 1))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '2 1'\n-/\n#guard_msgs in\n#eval find_building_arrangement 2 1\n\n/-\ninfo: '1 2 3'\n-/\n#guard_msgs in\n#eval find_building_arrangement 3 0\n\n/-\ninfo: 'CAPTAIN AMERICA EVADES'\n-/\n#guard_msgs in\n#eval find_building_arrangement 3 2"
      }
    ]
  },
  "fvapps_000963.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidPolygon (vertices: List (Int \u00d7 Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Signature for the main function -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def calculateMinCost (vertices: List (Int \u00d7 Int)) (stripes: List (Float \u00d7 Int)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_positive (vertices: List (Int \u00d7 Int)) (stripes: List (Float \u00d7 Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  calculateMinCost vertices stripes > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_integer (vertices: List (Int \u00d7 Int)) (stripes: List (Float \u00d7 Int))\n  (h1: isValidPolygon vertices = true)\n  (h2: stripes.length > 0) :\n  \u2203 n: Nat, calculateMinCost vertices stripes = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_stripes_error (vertices: List (Int \u00d7 Int))\n  (h1: isValidPolygon vertices = true) :\n  \u2200 result, calculateMinCost vertices [] \u2260 result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (1000, 0), (1000, 2000), (0, 2000)] [(1000, 10), (2000, 15)]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calculate_min_cost [(0, 0), (4, 0), (2, 3)] [(5, 2)]"
      }
    ]
  },
  "fvapps_000967.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_winner_and_max_lead (rounds : List (Nat \u00d7 Nat)) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_max_leads (rounds : List (Nat \u00d7 Nat)) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  rounds.foldl (fun acc r =>\n    let p1Total := acc.1 + r.1\n    let p2Total := acc.2 + r.2\n    if p1Total > p2Total\n    then (p1Total - p2Total, acc.2)\n    else (acc.1, p2Total - p1Total)\n  ) (0, 0)"
      },
      {
        "type": "cond",
        "string": "theorem winner_is_valid (rounds : List (Nat \u00d7 Nat)) :\n  let (winner, _) := find_winner_and_max_lead rounds\n  winner = 1 \u2228 winner = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_lead_nonnegative (rounds : List (Nat \u00d7 Nat)) :\n  let (_, maxLead) := find_winner_and_max_lead rounds\n  maxLead \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (1, 58)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(140, 82), (89, 134), (90, 110), (112, 106), (88, 90)]\n\n/-\ninfo: (1, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(10, 5), (20, 15), (30, 25)]\n\n/-\ninfo: (2, 15)\n-/\n#guard_msgs in\n#eval find_winner_and_max_lead [(5, 10), (15, 20), (25, 30)]"
      }
    ]
  },
  "fvapps_000973.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_chakra_needed (n m : Nat) (soint_powers soint_levels sofloat_powers sofloat_levels : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_chakra_cases :\n  (min_chakra_needed 1 1 [10] [1] [5] [1] = 0) \u2227\n  (min_chakra_needed 2 2 [10, 20] [1, 2] [5, 15] [1, 2] = 0) \u2227\n  (min_chakra_needed 2 3 [10, 20] [1, 2] [5, 5, 18] [2, 2, 1] = 8) \u2227\n  (min_chakra_needed 2 2 [10, 10] [1, 1] [20, 20] [1, 1] = 20) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | (x::xs) => x + list_sum xs\n-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval min_chakra_needed 2 3 [10, 20] [1, 2] [5, 5, 18] [2, 2, 1]\n\n/-\ninfo: 89\n-/\n#guard_msgs in\n#eval min_chakra_needed 5 5 [73, 69, 36, 77, 43] [87, 13, 36, 46, 93] [49, 74, 78, 99, 59] [46, 93, 87, 13, 36]"
      }
    ]
  },
  "fvapps_000976.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_largest_gcd_1_subarray (arr : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reduce_gcd (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.firstElem (l : List Nat) (h : l.length > 0) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => by contradiction\n  | x::_ => x"
      },
      {
        "type": "cond",
        "string": "theorem gcd_one_returns_full_length {arr : List Nat} (h1 : arr.length \u2265 2) (h2 : \u2200 x \u2208 arr, x \u2265 1)\n    (h3 : reduce_gcd arr = 1) :\n  find_largest_gcd_1_subarray arr = arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_gcd_one_returns_negative {arr : List Nat} (h1 : arr.length \u2265 2) (h2 : \u2200 x \u2208 arr, x \u2265 1)\n    (h3 : reduce_gcd arr > 1) :\n  find_largest_gcd_1_subarray arr = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem return_bounds {arr : List Nat} (h1 : arr.length \u2265 2) (h2 : \u2200 x \u2208 arr, x \u2265 2) :\n  find_largest_gcd_1_subarray arr = -1 \u2228\n  (1 \u2264 find_largest_gcd_1_subarray arr \u2227 find_largest_gcd_1_subarray arr \u2264 arr.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_elements_no_gcd_one {arr : List Nat} (h1 : arr.length \u2265 2)\n    (h2 : \u2200 x \u2208 arr, \u2200 y \u2208 arr, x = y) :\n  \u2200 x \u2208 arr, x \u2260 1 \u2192 find_largest_gcd_1_subarray arr = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [7, 2]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [2, 2, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_largest_gcd_1_subarray [6, 10, 15, 25]"
      }
    ]
  },
  "fvapps_000977.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_disjoint_subarrays (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def triangular_num (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "n * (n + 1) / 2"
      },
      {
        "type": "cond",
        "string": "theorem solve_disjoint_subarrays_output_bounds {n : Nat} {arr : List Nat}\n  (hn : n > 0)\n  (harr_size : arr.length = n)\n  (harr_bounds : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 1000) :\n  let result := solve_disjoint_subarrays n arr\n  0 \u2264 result \u2227 result < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_disjoint_subarrays_singleton {arr : List Nat}\n  (hsingle : arr.length = 1)\n  (hbound : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 10) :\n  solve_disjoint_subarrays 1 arr = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_disjoint_subarrays_all_equal {n : Nat} {arr : List Nat}\n  (hn : n > 1)\n  (harr_size : arr.length = n)\n  (harr_bounds : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 10)\n  (hall_equal : \u2200 x \u2208 arr, x = arr.head!) :\n  solve_disjoint_subarrays n arr = (triangular_num n) * (triangular_num n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 2 [3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 3 [1, 2, 2]\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_disjoint_subarrays 5 [1, 1, 2, 2, 2]"
      }
    ]
  },
  "fvapps_000979.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_running_patterns (n : Nat) (k : Nat) (distances : List Nat) (recorded : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- The output is a natural number between 0 and n-k -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_running_patterns_bounds (n k : Nat) (distances recorded : List Nat)\n    (hn : n \u2265 2) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : \u2200 i j, i < j \u2192 j < n \u2192 distances.get! i \u2264 distances.get! j)\n    (hdist_unique : \u2200 i j, i < j \u2192 j < n \u2192 distances.get! i \u2260 distances.get! j)\n    (hrec : recorded.length = k) :\n    let result := solve_running_patterns n k distances recorded\n    0 \u2264 result \u2227 result \u2264 n - k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- A pattern matches against itself at least once -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_running_patterns_self_match (n k : Nat) (distances : List Nat)\n    (hn : n \u2265 3) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length = n)\n    (hdist_sorted : \u2200 i j, i < j \u2192 j < n \u2192 distances.get! i \u2264 distances.get! j)\n    (hdist_unique : \u2200 i j, i < j \u2192 j < n \u2192 distances.get! i \u2260 distances.get! j) :\n    let diffs := List.zipWith (fun x y => x - y) (distances.drop 1) distances\n    let pattern := List.take k diffs\n    solve_running_patterns n k distances pattern \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Basic cases work correctly -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_running_patterns_basic_cases :\n    solve_running_patterns 2 1 [1,2] [1] = 1 \u2227\n    solve_running_patterns 3 1 [1,2,3] [1] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 1 [1, 5, 10, 12, 14] [5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 2 [5, 8, 13, 16, 21] [3, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 3 [2, 6, 8, 11, 16] [2, 3, 5]"
      }
    ]
  },
  "fvapps_000980.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countUpper (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countLower (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "inductive MessageType where\n  | chef\n  | brother\n  | both\n  | none\n  deriving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def classify_message (N : Nat) (K : Nat) (s : String) : MessageType :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem classify_message_properties {N K : Nat} {s : String} :\n  let upper := countUpper s\n  let lower := countLower s\n  match classify_message N K s with\n  | MessageType.chef => lower > K \u2227 upper \u2264 K\n  | MessageType.brother => upper > K \u2227 lower \u2264 K\n  | MessageType.both => upper \u2264 K \u2227 lower \u2264 K\n  | MessageType.none => upper > K \u2227 lower > K\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_upper {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'A')) = MessageType.brother :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_lower {N : Nat} (h : N > 0) :\n  classify_message N (N-1) (String.mk (List.replicate N 'a')) = MessageType.chef :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_k_large {N : Nat} (h : N > 1) {s : String} :\n  classify_message N 0 s = MessageType.none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_k_small {N : Nat} (h : N = 1) {s : String} :\n  classify_message N 0 s \u2260 MessageType.none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'chef'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"frauD\"\n\n/-\ninfo: 'brother'\n-/\n#guard_msgs in\n#eval classify_message 5 1 \"FRAUD\"\n\n/-\ninfo: 'both'\n-/\n#guard_msgs in\n#eval classify_message 4 4 \"Life\""
      }
    ]
  },
  "fvapps_000981.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_nice (s: List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_nice_strings (s: List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_nice_strings_non_negative (s: List Char) :\n  count_nice_strings s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_nice_strings_upper_bound (s: List Char) :\n  count_nice_strings s \u2264 (s.length * (s.length + 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_has_zero_nice (s: List Char) :\n  s.length = 0 \u2192 count_nice_strings s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_nice_min_length (s: List Char) :\n  is_nice s \u2192 s.length \u2265 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_strings_not_nice (s: List Char) :\n  s.length \u2264 1 \u2192 \u00ac(is_nice s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nice_string_conditions (s: List Char) (i: Nat) :\n  is_nice s \u2192\n  (\u2200 i, i < s.length \u2192 s.get! 0 = s.get! i) \u2228\n  (\u2200 i, i > 0 \u2192 i < s.length \u2192 Char.toNat (s.get! i) > Char.toNat (s.get! (i-1))) \u2228\n  (\u2200 i, i > 0 \u2192 i < s.length \u2192 Char.toNat (s.get! i) < Char.toNat (s.get! (i-1))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nice_string_has_nice_count (s: List Char) :\n  s.length \u2265 2 \u2192\n  is_nice s \u2192\n  count_nice_strings s \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_matches_actual_nice (s: List Char) :\n  count_nice_strings s =\n    (List.foldl (fun acc i =>\n      acc + List.foldl (fun inner_acc j =>\n        if is_nice (List.take (j + 1) (List.drop i s))\n        then inner_acc + 1\n        else inner_acc)\n      0 (List.range (s.length - i)))\n    0 (List.range s.length)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"aaa\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abc\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_nice_strings \"abbc\""
      }
    ]
  },
  "fvapps_000993.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_cake_festival (families : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) : List String := sorry\n\ndef isVerdict (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s = \"POSSIBLE\" || s = \"IMPOSSIBLE\""
      },
      {
        "type": "sig",
        "string": "def isVerdictWithNumber (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  let parts := s.splitOn \" \"\n  match parts with\n  | [verdict, num] => isVerdict verdict && (num.toInt?.isSome)\n  | _ => false"
      },
      {
        "type": "comment",
        "string": "-- Output format theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cake_festival_output_format (families : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) :\n  let results := solve_cake_festival families;\n  -- Results is non-empty\n  results.length > 0\n  -- All but last result have format \"VERDICT N\"\n  \u2227 (\u2200 i : Fin (results.length - 1), isVerdictWithNumber results[i]!)\n  -- Last result is just POSSIBLE/IMPOSSIBLE\n  \u2227 isVerdict results[results.length - 1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Valid differences theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cake_festival_valid_diffs (families : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) :\n  let results := solve_cake_festival families;\n  results.length = families.length + 1\n  \u2227 \u2200 i : Fin families.length,\n    let (slices, _, _, _) := families[i];\n    let parts := (results[i]!).splitOn \" \";\n    match parts with\n    | [\"POSSIBLE\", n] => (n.toInt?.get! \u2265 0)\n    | [\"IMPOSSIBLE\", n] => (n.toInt?.get! > 0)\n    | _ => False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Final verdict theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cake_festival_final_verdict (families : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) :\n  let results := solve_cake_festival families;\n  let extra := results.take (results.length - 1) |>.foldl (\u03bb acc res =>\n    let parts := res.splitOn \" \"\n    match parts with\n    | [\"POSSIBLE\", n] => acc + n.toInt?.getD 0\n    | _ => acc) 0;\n  let less := results.take (results.length - 1) |>.foldl (\u03bb acc res =>\n    let parts := res.splitOn \" \"\n    match parts with\n    | [\"IMPOSSIBLE\", n] => acc + n.toInt?.getD 0\n    | _ => acc) 0;\n  results[results.length - 1]! = \"POSSIBLE\" \u2194 extra \u2265 less :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Single member family theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem single_member_family\n  (slices smallest luck : Nat)\n  (h1 : slices > 0) (h2 : smallest > 0) (h3 : luck > 0) :\n  let results := solve_cake_festival [(slices, 1, smallest, luck)];\n  results.length = 2\n  \u2227 if smallest \u2264 slices then\n      results[0]! = s!\"POSSIBLE {slices - smallest}\"\n    else\n      results[0]! = s!\"IMPOSSIBLE {smallest - slices}\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000994.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_sequence (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sequence_non_negative (arr : List Nat) :\n  \u2200 x \u2208 find_sequence arr, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChanges (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let indices := List.range (arr.length - 1)\n  indices.foldl (fun acc i =>\n    if h : i < arr.length \u2227 i + 1 < arr.length then\n      if arr[i]'h.left \u2260 arr[i+1]'h.right then\n        acc + 1\n      else acc\n    else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem find_sequence_trailing_zero (arr : List Nat) :\n  arr.length > 0 \u2192 arr.getLast! = 0 \u2192\n  (find_sequence arr).getLast! = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sequence_run_lengths (arr : List Nat) (pos : Nat) (h : pos < arr.length) :\n  let val := arr[pos]'h\n  let run_length := (find_sequence arr).get! pos\n  \u2203 actual_count : Nat,\n    (\u2200 i, pos \u2264 i \u2227 i < pos + actual_count \u2192\n      \u2203 h' : i < arr.length, arr[i]'h' = val) \u2227\n    (val = 0 \u2227 pos + actual_count = arr.length \u2192 run_length = 0) \u2227\n    (\u00ac(val = 0 \u2227 pos + actual_count = arr.length) \u2192 run_length = actual_count) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sequence_length (arr : List Nat) :\n  arr.length > 0 \u2192\n  (find_sequence arr).length = 1 + countChanges arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_000997.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def power (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def order (x : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_armstrong (x : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_numbers (numbers : List Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem power_properties (x : Nat) (y : Nat) :\n  (y = 0 \u2192 power x y = 1) \u2227\n  (y = 1 \u2192 power x y = x) \u2227\n  (y = 2 \u2192 power x y = x * x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_properties (x : Nat) :\n  (x = 0 \u2192 order x = 0) \u2227\n  (0 < x \u2227 x < 10 \u2192 order x = 1) \u2227\n  (10 \u2264 x \u2227 x < 100 \u2192 order x = 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_armstrong_properties (x : Nat) :\n  (x < 10 \u2192 is_armstrong x = \"FEELS GOOD\") \u2227\n  (is_armstrong x = \"FEELS GOOD\" \u2228 is_armstrong x = \"FEELS BAD\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_numbers_properties (numbers : List Nat) :\n  (numbers = [] \u2192 check_numbers numbers = []) \u2227\n  (List.length (check_numbers numbers) = List.length numbers) \u2227\n  (\u2200 x \u2208 check_numbers numbers, x = \"FEELS GOOD\" \u2228 x = \"FEELS BAD\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['FEELS GOOD', 'FEELS BAD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [153, 11, 1634]\n\n/-\ninfo: ['FEELS GOOD', 'FEELS GOOD', 'FEELS GOOD']\n-/\n#guard_msgs in\n#eval check_numbers [370, 371, 407]\n\n/-\ninfo: ['FEELS BAD', 'FEELS BAD', 'FEELS BAD']\n-/\n#guard_msgs in\n#eval check_numbers [123, 555, 999]"
      }
    ]
  },
  "fvapps_001000.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_triangle (h : Int) (s : Int) : Int \u00d7 Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def format_output (triangle : Int \u00d7 Int \u00d7 Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_triangle_valid_output {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h \u2264 1000000) (s_bound : s \u2264 1000000) :\n  let (a, b, c) := find_triangle h s\n  if a \u2260 -1 then\n    a > 0 \u2227 b > 0 \u2227 c > 0 \u2227  -- Positive sides\n    c = h \u2227                   -- Height matches\n    a * b / 2 = s \u2227          -- Area matches\n    a \u2264 b                    -- Ordered sides\n  else True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_output_valid {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h \u2264 1000000) (s_bound : s \u2264 1000000) :\n  let result := format_output (find_triangle h s)\n  if result \u2260 \"-1\" then\n    -- Simplified String validation since we lack string manipulation operations\n    result.length > 0\n  else True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_inequality {h s : Int}\n  (h_pos : h > 0) (s_pos : s > 0) (h_bound : h \u2264 1000) (s_bound : s \u2264 1000) :\n  let (a, b, c) := find_triangle h s\n  if a \u2260 -1 then\n    a + b > c \u2227 b + c > a \u2227 a + c > b  -- Triangle inequality\n  else True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '3.000000 4.000000 5.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(5, 6)\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval format_output find_triangle(6, 10)\n\n/-\ninfo: '285168.817674 546189.769984 616153.000000'\n-/\n#guard_msgs in\n#eval format_output find_triangle(616153, 77878145466)"
      }
    ]
  },
  "fvapps_001007.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_crowds (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem solve_crowds_nonnegative (n : Nat) :\n  solve_crowds n \u2265 0 \u2227 solve_crowds n < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_crowds_small_n (n : Nat) (h : n \u2264 2) :\n  solve_crowds n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_crowds_upper_bound (n : Nat) (h : n \u2265 3) :\n  solve_crowds n < 2^n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_crowds_known_values_3 :\n  solve_crowds 3 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_crowds_known_values_4 :\n  solve_crowds 4 = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_crowds 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_crowds 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_crowds 2"
      }
    ]
  },
  "fvapps_001014.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solveBinaryNames (name : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem binary_names_result_range\n  (name : String)\n  (h : \u2203 c \u2208 name.data, c.isAlpha) :\n  0 \u2264 solveBinaryNames name \u2227 solveBinaryNames name < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match c.toLower with\n  | 'a' | 'e' | 'i' | 'o' | 'u' => true\n  | _ => false"
      },
      {
        "type": "cond",
        "string": "theorem only_letters_matter\n  (name : String)\n  (h : \u2203 c \u2208 name.data, c.isAlpha) :\n  solveBinaryNames name = solveBinaryNames (String.mk (name.data.filter Char.isAlpha)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_vowels_zero\n  (name : String)\n  (h\u2081 : name.length > 0)\n  (h\u2082 : \u2200 c \u2208 name.data, isVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_consonants_one\n  (name : String)\n  (h\u2081 : name.length > 0)\n  (h\u2082 : \u2200 c \u2208 name.data, c.isAlpha \u2227 \u00acisVowel c) :\n  solveBinaryNames name = ((2 ^ name.length - 1) % MOD) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 173\n-/\n#guard_msgs in\n#eval solve_binary_names \"codechef\""
      }
    ]
  },
  "fvapps_001018.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "sig",
        "string": "def find_max_distinct_subarray_sum (n k : Nat) (arr : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def allEqual (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 x y, x \u2208 l \u2192 y \u2208 l \u2192 x = y"
      },
      {
        "type": "sig",
        "string": "def uniqueCount (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (l.eraseDups).length"
      },
      {
        "type": "cond",
        "string": "theorem max_distinct_subarray_sum_within_bounds\n  {n k : Nat} {arr : List Nat} (h1 : k \u2264 n) (h2 : n = arr.length)\n  (h3 : \u2200 x, x \u2208 arr \u2192 1 \u2264 x \u2227 x \u2264 100) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 \u2228\n  result \u2264 (List.range (n - k + 1)).foldl (fun acc i =>\n    max acc (sum ((arr.take (i + k)).drop i))) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_elements_sum_first_k\n  {n k : Nat} {arr : List Nat}\n  (h1 : k \u2264 n) (h2 : n = arr.length)\n  (h3 : allEqual arr) (h4 : \u2200 x, x \u2208 arr \u2192 x > 0) :\n  find_max_distinct_subarray_sum n k arr = sum (arr.take k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distinct_count_consistent\n  {n k : Nat} {arr : List Nat}\n  (h1 : k \u2264 n) (h2 : n = arr.length) :\n  let result := find_max_distinct_subarray_sum n k arr\n  result = -1 \u2228\n  \u2200 i, i + k \u2264 n \u2192\n    sum ((arr.take (i + k)).drop i) = result \u2192\n    uniqueCount ((arr.take (i + k)).drop i) = uniqueCount arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 10 6 [8, 8, 3, 5, 3, 8, 5, 7, 7, 7]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 5 3 [1, 2, 1, 2, 3]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_max_distinct_subarray_sum 4 2 [5, 5, 5, 5]"
      }
    ]
  },
  "fvapps_001019.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longestValidPrefix (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValid (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_non_negative (s : String) :\n  longestValidPrefix s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_not_exceed_length (s : String) :\n  longestValidPrefix s \u2264 String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_even (s : String) :\n  longestValidPrefix s % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_char_makes_invalid (s : String) :\n  longestValidPrefix s < String.length s \u2192\n  let withNext := s.take (longestValidPrefix s + 1)\n  \u00acisValid withNext :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perfect_pairs_full_length (n : Nat) :\n  let s := String.mk (List.append (List.replicate n '<') (List.replicate n '>'))\n  longestValidPrefix s = 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_zero :\n  longestValidPrefix \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_right_zero :\n  longestValidPrefix \">\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_left_zero :\n  longestValidPrefix \"<\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<<>>\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"><\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval longest_valid_prefix \"<>>>\""
      }
    ]
  },
  "fvapps_001029.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def value (a b : Nat) (op : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_expression (expr : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem value_commutativity {a b : Nat} {op : String} (h : op = \"&\" \u2228 op = \"|\") :\n  value a b op = value b a op := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem value_nonnegativity {a b : Nat} {op : String} (h : op = \"&\" \u2228 op = \"|\" \u2228 op = \"^\") :\n  value a b op \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_expr_type {expr : String} :\n  \u2203 (n : Nat), solve_expression expr = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_expr_nonneg {expr : String} :\n  solve_expression expr \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 43\n-/\n#guard_msgs in\n#eval solve_expression \"3^40|10^2\"\n\n/-\ninfo: 95\n-/\n#guard_msgs in\n#eval solve_expression \"92^95|56&2&3\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_expression \"1&2|3\""
      }
    ]
  },
  "fvapps_001031.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_remainders (cases : List String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any list of test cases, the length of results matches the input length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_remainders_length (cases : List String) :\n  (find_remainders cases).length = cases.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Each remainder in the result is correctly computed -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_remainders_correct (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 \u2192 a > 0 \u2192\n  find_remainders [test_case] = [a % b] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- All remainders are non-negative and less than their divisors -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_remainders_bounds (test_case : String) (a b : Nat) (h : test_case = s!\"{a} {b}\") :\n  b > 0 \u2192 a > 0 \u2192\n  let r := (find_remainders [test_case]).head!\n  0 \u2264 r \u2227 r < b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Division by one always yields zero remainder -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_remainders_div_by_one (a : Nat) (h : a > 0) :\n  find_remainders [s!\"{a} 1\"] = [0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [1, 100, 10]\n-/\n#guard_msgs in\n#eval find_remainders [\"1 2\", \"100 200\", \"40 15\"]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_remainders [\"7 3\"]\n\n/-\ninfo: [0, 3]\n-/\n#guard_msgs in\n#eval find_remainders [\"10 2\", \"15 4\"]"
      }
    ]
  },
  "fvapps_001032.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_grid (n m : Nat) (house_coords : List (Nat \u00d7 Nat)) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_house_distances (n m : Nat) (grid : List String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | (x::xs) => x + sum_list xs\n\ndef list_get (xs : List Nat) (i : Nat) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs, i with\n  | [], _ => none\n  | (x::_), 0 => some x\n  | (_::xs), n+1 => list_get xs n"
      },
      {
        "type": "cond",
        "string": "theorem house_distances_properties\n  (n m : Nat) (coords : List (Nat \u00d7 Nat))\n  (h_n : n > 0) (h_m : m > 0)\n  (h_coords : coords.length \u2265 2)\n  (h_valid : \u2200 (p : Nat \u00d7 Nat), p \u2208 coords \u2192 p.1 < n \u2227 p.2 < m)\n  (h_unique : \u2200 (p q : Nat \u00d7 Nat), p \u2208 coords \u2192 q \u2208 coords \u2192 p = q \u2228 p \u2260 q) :\n  let result := solve_house_distances n m (make_grid n m coords);\n  let num_pairs := (coords.length * (coords.length - 1)) / 2;\n  result.length = n + m - 2 \u2227\n  (\u2200 x \u2208 result, x \u2265 0) \u2227\n  sum_list result = num_pairs \u2227\n  (sum_list result > 0 \u2192\n   \u2200 i x, i < result.length \u2192 list_get result i = some x \u2192 x > 0 \u2192 i + 1 \u2265 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_case\n  (n m : Nat)\n  (h_n : n \u2265 2) (h_m : m \u2265 2) :\n  let corner_houses := [(0,0), (n-1,m-1)];\n  let result := solve_house_distances n m (make_grid n m corner_houses);\n  list_get result (n+m-3) = some 1 \u2227\n  sum_list result = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001034.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tile_count (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem result_non_negative_and_bounded (n : Nat) :\n  let result := solve_tile_count n\n  0 \u2264 result \u2227 result < MOD := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem modulo_consistency (n : Nat) :\n  solve_tile_count n = solve_tile_count n % MOD := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_cases_correct :\n  solve_tile_count 0 = 1 \u2227\n  solve_tile_count 1 = 2 \u2227\n  solve_tile_count 2 = 6 \u2227\n  solve_tile_count 3 = 16 \u2227\n  solve_tile_count 4 = 42 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_tile_count 2\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_tile_count 3\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval solve_tile_count 4"
      }
    ]
  },
  "fvapps_001038.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def process_bit_queries (x : Nat) (queries : List (List Nat)) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_conversion_preserves_number (x : Nat) (h : x < 2^64) (pos : Nat)\n(h2 : pos > 0 \u2227 pos < 64) :\n  process_bit_queries x [[1, pos]] =\n    [if x &&& (1 <<< (pos - 1)) \u2260 0 then \"ON\" else \"OFF\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def drop {\u03b1} (n : Nat) (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001055.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tree_trimming (n : Nat) (parents : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (parents : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_trimming_bounds {n : Nat} {parents : List Nat}\n  (h1 : n \u2265 2) (h2 : is_valid_tree n parents = true) :\n  let result := solve_tree_trimming n parents\n  1 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_tree_optimum {n : Nat} {parents : List Nat}\n  (h1 : n \u2265 2) (h2 : n \u2264 3) (h3 : is_valid_tree n parents = true) :\n  solve_tree_trimming n parents = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_tree_bounds {n : Nat}\n  (h : n \u2265 2) :\n  let parents := List.range (n-1)\n  let result := solve_tree_trimming n parents\n  1 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem star_tree_bounds {n : Nat}\n  (h : n \u2265 2) :\n  let parents := List.replicate (n-1) 1\n  let result := solve_tree_trimming n parents\n  1 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_tree_trimming 13 [1, 1, 1, 1, 1, 4, 3, 4, 4, 3, 4, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_trimming 3 [1, 1]"
      }
    ]
  },
  "fvapps_001057.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_transform_triangle (n : Nat) : String := sorry\n\ndef satisfies_triangle_inequality (n : Nat) (even_side : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  even_side < 2*n \u2227 n + n > even_side"
      },
      {
        "type": "sig",
        "string": "def has_integer_height (n : Nat) (even_side : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_format (n : Nat) (h : n > 0) :\n  can_transform_triangle n = \"YES\" \u2228 can_transform_triangle n = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem yes_case_valid (n : Nat) (h : n > 0) (h2 : can_transform_triangle n = \"YES\") :\n  \u2203 even_side : Nat,\n    even_side % 2 = 0 \u2227\n    even_side \u2265 2 \u2227\n    even_side \u2264 2*n \u2227\n    satisfies_triangle_inequality n even_side \u2227\n    has_integer_height n even_side :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_case_invalid (n : Nat) (h : n > 0) (h2 : can_transform_triangle n = \"NO\") :\n  \u2200 even_side : Nat,\n    even_side % 2 = 0 \u2192\n    even_side \u2265 2 \u2192\n    even_side \u2264 2*n \u2192\n    \u00ac(satisfies_triangle_inequality n even_side \u2227 has_integer_height n even_side) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_transform_triangle 5\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_transform_triangle 3\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_transform_triangle 10"
      }
    ]
  },
  "fvapps_001064.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_stones_removed (n : Nat) (piles : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "sig",
        "string": "def alternating_elements : List Nat \u2192 List Nat\n  | [] => []\n  | [x] => [x]\n  | x::_::xs => x :: alternating_elements xs"
      },
      {
        "type": "cond",
        "string": "theorem max_stones_removed_identity (n : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n piles = max_stones_removed n piles :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_stones_removed_n_independent (n\u2081 n\u2082 : Nat) (piles : List Nat) (h : piles.length > 0) :\n  max_stones_removed n\u2081 piles = max_stones_removed n\u2082 piles :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_stones_removed 3 [1, 2, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval max_stones_removed 4 [4, 3, 2, 1]"
      }
    ]
  },
  "fvapps_001066.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def nc3 (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve (n : Nat) (c : Nat) (k : Nat) (lines : List (List Nat)) (v : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem nc3_nonnegative (n : Nat) :\n  nc3 n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nc3_zero_for_small_n (n : Nat) :\n  n < 3 \u2192 nc3 n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nc3_formula (n : Nat) :\n  nc3 n = n * (n-1) * (n-2) / 6 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_nonnegative (n c k : Nat) (lines : List (List Nat)) (v : List Nat) :\n  solve n c k lines v \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_bounded_by_combinations\n  (n c k : Nat) (lines : List (List Nat)) (v : List Nat)\n  (validLines := List.filter (fun line => line.get! 2 \u2264 c) lines) :\n  solve n c k lines v \u2264 nc3 validLines.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty :\n  solve 0 1 1 [] [1] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_minimal :\n  solve 1 1 1 [[0,0,1]] [1] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 7 2 13 [[1, 10, 1], [1, 14, 2], [6, 4, 1], [2, 2, 1], [0, 12, 2], [2, 11, 2], [0, 6, 1]] [8, 10]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 6 1 20 [[1, 5, 1], [2, 11, 1], [4, 0, 1], [6, 8, 1], [0, 11, 1], [3, 3, 1]] [9]"
      }
    ]
  },
  "fvapps_001069.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_cooking_time (n: Nat) (times: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sorted_take (l: List Nat) (n: Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cooking_time_lower_bound_half_sum {n: Nat} {times: List Nat}\n  (h1: 1 \u2264 n) (h2: n \u2264 100) (h3: times.length \u2265 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times \u2265 (list_sum usedTimes) / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cooking_time_lower_bound_max {n: Nat} {times: List Nat}\n  (h1: 1 \u2264 n) (h2: n \u2264 100) (h3: times.length \u2265 1) :\n  min_cooking_time n times \u2265 list_maximum (times.take n) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cooking_time_upper_bound_sum {n: Nat} {times: List Nat}\n  (h1: 1 \u2264 n) (h2: n \u2264 100) (h3: times.length \u2265 1) :\n  let usedTimes := list_sorted_take times (min n times.length)\n  min_cooking_time n times \u2264 list_sum usedTimes := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cooking_time_equal_times {n: Nat} (h1: 1 \u2264 n) (h2: n \u2264 100) :\n  let times := List.replicate n 10\n  min_cooking_time n times = ((n + 1) / 2) * 10 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cooking_time_single_item {times: List Nat} (h: times.length \u2265 1) :\n  min_cooking_time 1 times = list_maximum times := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [2, 2, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_cooking_time 3 [1, 2, 3]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_cooking_time 4 [2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_001071.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_goodness_sum (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef num_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_increasing (n : Nat) (h : 1 < n) (h2 : n \u2264 10000) :\n  calculate_goodness_sum 1 (n-1) \u2264 calculate_goodness_sum 1 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 75\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 9 12\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 1 5\n\n/-\ninfo: 66\n-/\n#guard_msgs in\n#eval calculate_goodness_sum 10 12"
      }
    ]
  },
  "fvapps_001078.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_max_path_profits (n: Nat) (values: List Nat) (edges: List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n: Nat) (edges: List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_node_case (n: Nat) (values: List Nat) :\n  n = 1 \u2192 solve_max_path_profits n values [] = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_inputs_result_properties (n: Nat) (values: List Nat) (edges: List (Nat \u00d7 Nat)) :\n  n \u2265 2 \u2192\n  values.length \u2265 n \u2192\n  is_valid_tree n edges = true \u2192\n  let result := solve_max_path_profits n values edges\n  (result \u2265 0 \u2227 result \u2264 10^9 + 7) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_graph_properties (n: Nat) (values: List Nat) :\n  n \u2265 2 \u2192\n  values.length \u2265 n \u2192\n  let edges := List.range (n-1) |>.map (fun i => (i+1, i+2))\n  let result := solve_max_path_profits n values edges\n  result \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval solve_max_path_profits 4 [1, 2, 3, 4] [(1, 2), (2, 3), (2, 4)]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval solve_max_path_profits 5 [1, 2, 3, 4, 5] [(1, 2), (2, 3), (3, 4), (4, 5)]"
      }
    ]
  },
  "fvapps_001081.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_operations_to_alternating (n : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_alternating (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def make_alternating_01 (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def make_alternating_10 (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniform_string_flips (n : Nat) (c : Char) :\n  let s := String.mk (List.replicate n c)\n  let ops := min_operations_to_alternating n s\n  ops = n/2 \u2228 ops = (n+1)/2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_result_bounded (n : Nat) (s : String) :\n  s.length = n \u2192\n  let ops := min_operations_to_alternating n s\n  0 \u2264 ops \u2227 ops \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1011\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 4 \"1111\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_operations_to_alternating 6 \"101010\""
      }
    ]
  },
  "fvapps_001082.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_sum_submatrix (matrix : Array (Array Int)) : Array (Array Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int := sorry\n\ndef array_max (arr : Array Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  arr.foldl (fun acc x => max acc x) (-999999)"
      },
      {
        "type": "sig",
        "string": "def matrix_max (matrix : Array (Array Int)) : Int :="
      },
      {
        "type": "impl",
        "string": "  matrix.foldl (fun acc row => max acc (array_max row)) (-999999)"
      },
      {
        "type": "cond",
        "string": "theorem singleton_matrix_is_own_max_sum\n  (val : Int)\n  (matrix : Array (Array Int))\n  (h : matrix = #[#[val]]) :\n  find_max_sum_submatrix matrix = #[#[val]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001085.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def seriesSumSolver (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_returns_valid_name (n : Nat)\n    (h : 1 \u2264 n \u2227 n \u2264 1000000) :\n    seriesSumSolver n = \"Ravi\" \u2228 seriesSumSolver n = \"Jhon\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def squaredSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_alternates (n : Nat)\n    (h : 1 \u2264 n \u2227 n \u2264 10000) :\n    (seriesSumSolver n = \"Ravi\" \u2194 squaredSum n % 2 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_consistent (n : Nat)\n    (h : 1 \u2264 n \u2227 n \u2264 1000000) :\n    seriesSumSolver n = seriesSumSolver n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_works_on_edge_cases_1 :\n    seriesSumSolver 1 = \"Ravi\" \u2228 seriesSumSolver 1 = \"Jhon\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_works_on_edge_cases_2 :\n    seriesSumSolver 2 = \"Ravi\" \u2228 seriesSumSolver 2 = \"Jhon\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem series_sum_solver_works_on_edge_cases_3 :\n    seriesSumSolver 1000000 = \"Ravi\" \u2228 seriesSumSolver 1000000 = \"Jhon\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Jhon'\n-/\n#guard_msgs in\n#eval series_sum_solver 2\n\n/-\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 3\n\n/-\ninfo: 'Ravi'\n-/\n#guard_msgs in\n#eval series_sum_solver 4"
      }
    ]
  },
  "fvapps_001090.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidNamePart (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def formatName (input: List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def formatNameStr (input: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_name_list_properties {parts: List String}\n  (h: \u2203 p \u2208 parts, isValidNamePart p = true) :\n  let result := formatName parts\n  let resultParts := result.split (\u00b7 = ' ')\n  -- Result is a string\n  result.length \u2265 0 \u2227\n  -- Last part is capitalized original\n  resultParts.getLast! = (parts.getLast!).capitalize \u2227\n  -- Other parts are initials\n  (parts.length > 1 \u2192\n    \u2200 i < parts.length - 1,\n    resultParts[i]! = s!\"{(parts[i]!).get 0}.\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_name_string_properties {input: String}\n  (h: \u2203 c \u2208 input.data, c.isAlpha) :\n  let validParts := (input.split (\u00b7 = ' ')).filter isValidNamePart\n  let result := formatNameStr input\n  let resultParts := result.split (\u00b7 = ' ')\n  (validParts.length > 0) \u2192\n  -- Result is a string\n  result.length \u2265 0 \u2227\n  -- Parts lengths match\n  resultParts.length = validParts.length \u2227\n  -- Initials format\n  (validParts.length > 1 \u2192\n    \u2200 i < validParts.length - 1,\n    (resultParts[i]!).endsWith \".\" \u2227\n    (resultParts[i]!).length = 2) \u2227\n  -- Last name is starts with uppercase\n  (resultParts.getLast!).get 0 \u2265 'A' \u2227\n  (resultParts.getLast!).get 0 \u2264 'Z' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"gandhi\"\n\n/-\ninfo: 'M. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"mahatma gandhI\"\n\n/-\ninfo: 'M. K. Gandhi'\n-/\n#guard_msgs in\n#eval format_name \"Mohndas KaramChand gandhi\""
      }
    ]
  },
  "fvapps_001094.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_frequent_numbers (n : Nat) (k : Nat) (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count {\u03b1} [BEq \u03b1] (as : List \u03b1) (a : \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "sig",
        "string": "def uniqueSort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem frequent_numbers_properties\n  (n : Nat) (k : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k \u2264 19)\n  (h3 : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 20) :\n  let result := find_frequent_numbers n k arr\n  -- Result contains only numbers appearing more than k times\n  \u2200 num \u2208 result, count arr num > k\n  -- All numbers appearing more than k times are in result\n  \u2227 \u2200 num \u2208 arr, count arr num > k \u2192 num \u2208 result\n  -- Result is sorted\n  \u2227 isSorted result\n  -- All result elements exist in input array\n  \u2227 \u2200 num \u2208 result, num \u2208 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_zero_returns_unique\n  (n : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 20) :\n  find_frequent_numbers n 0 arr = uniqueSort arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem large_k_returns_empty\n  (n : Nat) (k extra : Nat) (arr : List Nat)\n  (h1 : n = arr.length)\n  (h2 : k = n + extra)\n  (h3 : \u2200 x \u2208 arr, 1 \u2264 x \u2227 x \u2264 20) :\n  find_frequent_numbers n k arr = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [2, 5]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 5 1 [5, 2, 1, 2, 5]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 6 2 [1, 1, 1, 2, 2, 3]\n\n/-\ninfo: [1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval find_frequent_numbers 4 0 [4, 2, 3, 1]"
      }
    ]
  },
  "fvapps_001100.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_gift_pair (n : Nat) (prices : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def process_test_cases (numCases : Nat) (cases : List (Nat \u00d7 List Nat)) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def permutation (xs : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_order_independence (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n (permutation prices) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_result (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = \"Accepted\" \u2228 find_gift_pair n prices = \"Rejected\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_deterministic (n : Nat) (prices : List Nat) :\n  find_gift_pair n prices = find_gift_pair n prices :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_test_cases_preserves_result (n : Nat) (prices : List Nat) :\n  let test_cases := [(n, prices)]\n  let results := process_test_cases 1 test_cases\n  results.length = 1 \u2227\n  results[0]! = find_gift_pair n prices :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_empty : find_gift_pair 0 [] = \"Rejected\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_single : find_gift_pair 1 [1000] = \"Rejected\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_too_small : find_gift_pair 3 [1, 1, 1] = \"Rejected\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gift_pair_too_large : find_gift_pair 3 [2001, 2001, 2001] = \"Rejected\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 5 [10, 2, 1000, 50, 1000]\n\n/-\ninfo: 'Rejected'\n-/\n#guard_msgs in\n#eval find_gift_pair 3 [500, 500, 500]\n\n/-\ninfo: 'Accepted'\n-/\n#guard_msgs in\n#eval find_gift_pair 4 [1000, 1000, 50, 60]"
      }
    ]
  },
  "fvapps_001106.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_binary_flips (n k : Nat) (s : String) : Nat \u00d7 String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_alternating (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_consecutive (s : String) (k : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_flips_basic_properties {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 0) (h3 : s.length = n) (h4 : \u2200 c \u2208 s.data, c = '0' \u2228 c = '1') :\n  let (flips, result) := solve_binary_flips n k s\n  -- Output type properties\n  flips \u2265 0 \u2227\n  result.length = n \u2227\n  (\u2200 c \u2208 result.data, c = '0' \u2228 c = '1') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_one_alternating {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : \u2200 c \u2208 s.data, c = '0' \u2228 c = '1') :\n  let (_, result) := solve_binary_flips n 1 s\n  is_alternating result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_gt_one_consecutive {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 1) (h3 : s.length = n) (h4 : \u2200 c \u2208 s.data, c = '0' \u2228 c = '1') :\n  let (_, result) := solve_binary_flips n k s\n  check_consecutive result k = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_equals_n_no_flips {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length = n) (h3 : \u2200 c \u2208 s.data, c = '0' \u2228 c = '1') :\n  let (flips, result) := solve_binary_flips n n s\n  flips = 0 \u2227 result = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001111.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countPalindromeCompletions (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_nonnegative (s : String) :\n  countPalindromeCompletions s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mkPos (s : String) (i : Nat) (h : i < s.length) : String.Pos := \u27e8i\u27e9"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_impossible_case (s : String) (i : Nat)\n  (h1 : i < s.length / 2)\n  (h2 : i < s.length)\n  (h3 : s.length - 1 - i < s.length)\n  (h4 : s.get (mkPos s i h2) \u2260 '?' \u2227 s.get (mkPos s (s.length - 1 - i) h3) \u2260 '?')\n  (h5 : s.get (mkPos s i h2) \u2260 s.get (mkPos s (s.length - 1 - i) h3)) :\n  countPalindromeCompletions s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_bounded (s : String) :\n  countPalindromeCompletions s \u2264 10000009 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_all_question_marks (s : String) (h : \u2200 c \u2208 s.data, c = '?') :\n  countPalindromeCompletions s = (26 ^ ((s.length + 1) / 2)) % 10000009 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_no_question_marks (s : String) (h : '?' \u2209 s.data) :\n  countPalindromeCompletions s = if isPalindrome s then 1 else 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_deterministic (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countPalindromeCompletions_symmetry (s : String) :\n  countPalindromeCompletions s = countPalindromeCompletions (reverseString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"?\"\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"??\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_palindrome_completions \"aba\""
      }
    ]
  },
  "fvapps_001112.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_squares (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Every positive number can be decomposed into a sum of squares,\n    and the count of squares is positive and not larger than the input number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_squares_basic_properties (n : Nat) (h : n > 0) :\n  let result := count_squares n\n  0 < result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- The decomposition count equals 1 for perfect squares -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_squares_perfect (n : Nat) (h : n > 0) :\n  count_squares (n * n) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Basic results for small numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_squares_small_numbers :\n  count_squares 1 = 1 \u2227\n  count_squares 2 = 2 \u2227\n  count_squares 3 = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The sum of squares used in decomposition equals the input number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_squares_sum_property (n : Nat) (h : n > 0) :\n  \u2203 (squares : List Nat),\n    squares.length \u2264 count_squares n \u2227\n    (\u2200 x \u2208 squares, \u2203 k, x = k * k) \u2227\n    (squares.foldl (\u00b7 + \u00b7) 0 = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 85\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_squares 114\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_squares 10"
      }
    ]
  },
  "fvapps_001118.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_helper_thanks (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_helper_thanks_result_valid (n : Int) :\n  (solve_helper_thanks n = \"-1\") \u2228\n  (solve_helper_thanks n = \"Thanks for helping Chef!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_multiple_cases (nums : List Int) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_multiple_cases_length (nums : List Int) :\n  (solve_multiple_cases nums).length = nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_helper_thanks_condition (n : Int) :\n  (n < 10) = (solve_helper_thanks n = \"Thanks for helping Chef!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_multiple_cases_valid_results (nums : List Int) :\n  \u2200 x \u2208 solve_multiple_cases nums,\n    (x = \"-1\") \u2228 (x = \"Thanks for helping Chef!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_multiple_cases_condition (nums : List Int) :\n  \u2200 (i : Nat), i < nums.length \u2192\n    ((nums[i]! < 10) =\n     ((solve_multiple_cases nums)[i]! = \"Thanks for helping Chef!\")) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: test1_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [1, 12, -5]\n\n/-\ninfo: test2_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [-20, 0, 20]\n\n/-\ninfo: test3_expected\n-/\n#guard_msgs in\n#eval solve_multiple_cases [9, 10]"
      }
    ]
  },
  "fvapps_001120.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_ciel_number_prices (menu_items : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem count_result_bounded (menu_items : List String) :\n  0 \u2264 count_ciel_number_prices menu_items \u2227\n  count_ciel_number_prices menu_items \u2264 menu_items.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_result_bounded_with_format\n  (menu_items : List String)\n  (h : \u2200 item \u2208 menu_items, \u2203 words price, item = words ++ \" \" ++ price \u2227 price.all (\u03bb c => '0' \u2264 c \u2227 c \u2264 '9')) :\n  0 \u2264 count_ciel_number_prices menu_items \u2227\n  count_ciel_number_prices menu_items \u2264 menu_items.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ciel_numbers_positive\n  (menu_items : List String)\n  (h : \u2203 item \u2208 menu_items,\n    let price := (item.split (\u00b7 = ' ')).getLast!\n    price.all (\u03bb c => c = '8' \u2228 c = '5' \u2228 c = '3') \u2227\n    count_char price '8' \u2265 count_char price '5' \u2227\n    count_char price '5' \u2265 count_char price '3') :\n  count_ciel_number_prices menu_items > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"milk 58\", \"Ciel\"s Drink 80\", \"The curry 2nd edition 888888\", \"rice omelet 85855\", \"unagi 1\", \"The first and last letters can be a space 358\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"menu 8\", \"special 853\", \"dessert 123\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_ciel_number_prices [\"item 44\", \"item2 77\"]"
      }
    ]
  },
  "fvapps_001128.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_subarrays_with_min (arr : List Int) (k : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Result should never be negative"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_nonneg {arr : List Int} {k : Int}\n  (h1 : arr \u2260 []) :\n  count_subarrays_with_min arr k \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- If k is less than min(arr), result should be 0"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_less_than_min {arr : List Int} {k : Int}\n  (h1 : arr \u2260 [])\n  (h2 : k < list_min arr) :\n  count_subarrays_with_min arr k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- If k equals min(arr), result should be at least length of array"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_equals_min {arr : List Int} {k : Int}\n  (h1 : arr \u2260 [])\n  (h2 : k = list_min arr) :\n  count_subarrays_with_min arr k \u2265 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Single element array returns 1 if element equals k, 0 otherwise"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_single_elem {arr : List Int} {k : Int}\n  (h1 : arr.length = 1) :\n  count_subarrays_with_min arr k = if arr.head! = k then 1 else 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For array of identical elements, result is n*(n+1)/2"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_identical_elems {arr : List Int} {k : Int}\n  (h1 : arr \u2260 [])\n  (h2 : \u2200 x \u2208 arr, x = k) :\n  count_subarrays_with_min arr k = (arr.length * (arr.length + 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For any k, result with k should be >= result with k+1"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_subarrays_monotonic {arr : List Int} {k : Int}\n  (h1 : arr \u2260 [])\n  (h2 : \u2200 x \u2208 arr, x > 0) :\n  count_subarrays_with_min arr k \u2265 count_subarrays_with_min arr (k+1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [2, 2] 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_subarrays_with_min [3] 3"
      }
    ]
  },
  "fvapps_001133.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solveBalancedDigits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def makeBalancedString (m n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_fours_and_sevens {n : Nat} (h : n > 0) (h2 : n \u2264 50) :\n  let s := makeBalancedString n n\n  let result := solveBalancedDigits s\n  result \u2265 1 \u2227 result < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arbitrary_fours_and_sevens {m n : Nat}\n  (h1 : m > 0) (h2 : m \u2264 50) (h3 : n > 0) (h4 : n \u2264 50) :\n  let s := makeBalancedString m n\n  let result := solveBalancedDigits s\n  result \u2265 0 \u2227 result < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_string_bounds {s : String}\n  (h : s.length > 0) (h2 : s.length \u2264 50)\n  (h3 : \u2200 c \u2208 s.data, c = '4' \u2228 c = '7') :\n  let result := solveBalancedDigits s\n  result \u2265 0 \u2227 result < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"47\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_balanced_digits \"4477\""
      }
    ]
  },
  "fvapps_001136.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def lcm (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_lovers_lcm (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Properties relating to lcm and gcd with same inputs"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lcm_self (n : Nat) : lcm n n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_self (n : Nat) (h : n > 0) : gcd n n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Properties with 1"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lcm_one (n : Nat) (h : n > 0) : lcm n 1 = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_one (n : Nat) (h : n > 0) : gcd n 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Commutativity properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lcm_comm (a b : Nat) : lcm a b = lcm b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_comm (a b : Nat) : gcd a b = gcd b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Solution validation"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_lovers_valid_output (n : Nat) (h : n > 0) :\n  solve_lovers_lcm n = \"Nova's gonna kill me\" \u2228\n  solve_lovers_lcm n = \"YESS(sunglass emo)\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Deterministic output"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_lovers_deterministic (n : Nat) :\n  solve_lovers_lcm n = solve_lovers_lcm n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 111\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 10\n\n/-\ninfo: 'YESS(sunglass emo)'\n-/\n#guard_msgs in\n#eval solve_lovers_lcm 100"
      }
    ]
  },
  "fvapps_001140.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def canSplitEvenly (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countPossibleSwaps (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solveSwaps (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_swaps_returns_valid_count (n : Nat) (h : n > 0) :\n  let result := solveSwaps n\n  result \u2265 0 \u2227 result \u2264 countPossibleSwaps n \u2227\n  (\u00accanSplitEvenly n \u2192 result = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_swaps_small_sequences (n : Nat) (h1 : n > 0) (h2 : n \u2264 2) :\n  solveSwaps n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_swaps 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_swaps 7"
      }
    ]
  },
  "fvapps_001142.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digitSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDivisibleByDigitSum (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem isDivisibleByDigitSum_spec (n : Nat) (h : n > 0) :\n  let ds := digitSum n\n  isDivisibleByDigitSum n = \"Yes\" \u2194 n % ds = 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isDivisibleByDigitSum_returns_valid_result (n : Nat) (h : n > 0) :\n  isDivisibleByDigitSum n = \"Yes\" \u2228 isDivisibleByDigitSum n = \"No\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 16\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 27\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval is_divisible_by_digit_sum 45"
      }
    ]
  },
  "fvapps_001154.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max_removable_steps (n : Nat) (s : String) : Nat := sorry\n\ndef absDiff (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if x \u2265 y then x - y else y - x"
      },
      {
        "type": "cond",
        "string": "theorem max_removable_steps_le_n {n : Nat} {s : String} :\n  n > 0 \u2192 max_removable_steps n s \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_removable_steps_empty {n : Nat} :\n  n > 0 \u2192 max_removable_steps n \"\" = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_removable_steps 7 \"ULUDLLU\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_removable_steps 4 \"RUUR\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_removable_steps 4 \"LRLR\""
      }
    ]
  },
  "fvapps_001155.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_travel_time (n a b c d p q y : Nat) (cities : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_travel_time_non_negative (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n \u2265 4) (h2 : n \u2264 100)\n  (h3 : p \u2265 1) (h4 : p \u2264 100)\n  (h5 : q \u2265 1) (h6 : q \u2264 100)\n  (h7 : y \u2264 100000)\n  (h8 : cities.length \u2265 4) (h9 : cities.length \u2264 100)\n  (h10 : \u2200 x \u2208 cities, -100000 \u2264 x \u2227 x \u2264 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_travel_time_upper_bound (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n \u2265 4) (h2 : n \u2264 100)\n  (h3 : p \u2265 1) (h4 : p \u2264 100)\n  (h5 : q \u2265 1) (h6 : q \u2264 100)\n  (h7 : y \u2264 100000)\n  (h8 : cities.length \u2265 4) (h9 : cities.length \u2264 100)\n  (h10 : \u2200 x \u2208 cities, -100000 \u2264 x \u2227 x \u2264 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4) :\n  min_travel_time n a b c d p q y cities \u2264 (abs (cities[b-1] - cities[a-1])) * p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_travel_time_identical_cities (n a b c d p q y : Nat) (cities : List Int)\n  (h1 : n \u2265 4) (h2 : n \u2264 100)\n  (h3 : p \u2265 1) (h4 : p \u2264 100)\n  (h5 : q \u2265 1) (h6 : q \u2264 100)\n  (h7 : y \u2264 100000)\n  (h8 : cities.length \u2265 4) (h9 : cities.length \u2264 100)\n  (h10 : \u2200 x \u2208 cities, -100000 \u2264 x \u2227 x \u2264 100000)\n  (h11 : a = 1) (h12 : b = 3)\n  (h13 : c = 2) (h14 : d = 4)\n  (h15 : cities[a-1] = cities[b-1]) :\n  min_travel_time n a b c d p q y cities = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 3 2 4 3 2 4 [1, 2, 3, 4]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_travel_time 4 1 4 2 3 2 1 10 [0, 1, 2, 3]"
      }
    ]
  },
  "fvapps_001157.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_coins_and_sum (n: Nat) : List Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_is_sorted {\u03b1: Type} (l: List \u03b1) (less_eq : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 less_eq (l.get \u27e8i, sorry\u27e9) (l.get \u27e8j, sorry\u27e9)"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x :: xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem coins_length_matches_input {n: Nat} (h: 1 \u2264 n \u2227 n \u2264 17):\n  (get_coins_and_sum n).fst.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem coins_are_positive {n: Nat} (h: 1 \u2264 n \u2227 n \u2264 17):\n  \u2200 x \u2208 (get_coins_and_sum n).fst, 0 < x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001158.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_contiguous_generators (N : Nat) (A : List Nat) (queries : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_gcd (lst : List Nat) : Nat := sorry\n\ndef count_divisible (k : Nat) (A : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  List.foldl (fun acc x => if k % x = 0 then acc + 1 else acc) 0 A"
      },
      {
        "type": "comment",
        "string": "-- Result length matches queries length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_length_matches_queries\n  {N : Nat} {A : List Nat} {queries : List Nat} :\n  List.length (solve_contiguous_generators N A queries) = List.length queries :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- All results are non-negative (trivial in Nat type)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem all_results_nonnegative\n  {N : Nat} {A : List Nat} {queries : List Nat} :\n  \u2200 x \u2208 solve_contiguous_generators N A queries, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result[K] \u2265 min(divisible_count, N)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_geq_min_divisible_count\n  {N : Nat} {A : List Nat} {queries : List Nat}\n  (i : Nat) (k : Nat) (h\u2081 : i < List.length queries) :\n  let divisible_count := count_divisible k A\n  let result := solve_contiguous_generators N A queries\n  result.get! i \u2265 min divisible_count N :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Each element should generate at least itself"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem single_element_generates_self\n  {N : Nat} {A : List Nat} :\n  \u2200 x \u2208 solve_contiguous_generators N A A, x \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- GCD of contiguous subsequence divides generating values"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem gcd_subsequence_property\n  {N : Nat} {A : List Nat} {K : Nat}\n  (i j : Nat) (h\u2081 : i \u2264 j) (h\u2082 : j < N) :\n  let subseq := A.take (j+1) |>.drop i\n  let subseq_gcd := list_gcd subseq\n  K % subseq_gcd = 0 \u2192\n  (solve_contiguous_generators N A [K]).get! 0 \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 2, 3]\n-/\n#guard_msgs in\n#eval solve_contiguous_generators 2 [2, 4] [1, 2, 8]"
      }
    ]
  },
  "fvapps_001162.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSpace (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_elements (s : String) : Nat \u00d7 Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_elements_totals (s : String) :\n  let (uppers, digits, spaces) := count_elements s\n  let total := uppers + digits + spaces\n  total \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  count_elements \"\" = (0, 0, 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001167.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef solve_f_n (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def direct_calc (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_cases :\n  solve_f_n 1 = 1 \u2227\n  solve_f_n 2 = 2 \u2227\n  solve_f_n 3 = 12 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_f_n 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_f_n 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_f_n 2"
      }
    ]
  },
  "fvapps_001172.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def track_rakesh (m n rx ry : Nat) (moves : String) : String := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.filter (\u00b7 == c) |>.length"
      },
      {
        "type": "sig",
        "string": "def stringReverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk (s.toList.reverse)"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_result_type (m n rx ry : Nat) (moves : String) :\n  track_rakesh m n rx ry moves = \"DANGER\" \u2228\n  track_rakesh m n rx ry moves = \"REACHED\" \u2228\n  track_rakesh m n rx ry moves = \"SOMEWHERE\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_danger_condition (m n rx ry : Nat) (moves : String) :\n  let net_x := countChar moves 'R' - countChar moves 'L'\n  let net_y := countChar moves 'U' - countChar moves 'D'\n  (net_x < 0 \u2228 net_x > m \u2228 net_y < 0 \u2228 net_y > n) \u2192\n  track_rakesh m n rx ry moves = \"DANGER\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_reached_condition (m n rx ry : Nat) (moves : String) :\n  let net_x := countChar moves 'R' - countChar moves 'L'\n  let net_y := countChar moves 'U' - countChar moves 'D'\n  (net_x = rx \u2227 net_y = ry) \u2192\n  track_rakesh m n rx ry moves = \"REACHED\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_somewhere_condition (m n rx ry : Nat) (moves : String) :\n  let net_x := countChar moves 'R' - countChar moves 'L'\n  let net_y := countChar moves 'U' - countChar moves 'D'\n  (\u00ac(net_x < 0 \u2228 net_x > m \u2228 net_y < 0 \u2228 net_y > n)) \u2192\n  (\u00ac(net_x = rx \u2227 net_y = ry)) \u2192\n  track_rakesh m n rx ry moves = \"SOMEWHERE\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_no_movement (m n : Nat) :\n  track_rakesh m n 0 0 \"\" = \"REACHED\" \u2227\n  track_rakesh m n 1 1 \"\" = \"SOMEWHERE\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem track_rakesh_inverse_movement (m n : Nat) (moves : String) :\n  moves \u2260 \"\" \u2192\n  track_rakesh m n 0 0 (moves ++ stringReverse moves) = \"REACHED\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'REACHED'\n-/\n#guard_msgs in\n#eval track_rakesh 20 20 4 5 \"LLUUUUURRRRRR\"\n\n/-\ninfo: 'DANGER'\n-/\n#guard_msgs in\n#eval track_rakesh 10 10 3 4 \"UDUDDRR\"\n\n/-\ninfo: 'SOMEWHERE'\n-/\n#guard_msgs in\n#eval track_rakesh 5 5 2 2 \"RRU\""
      }
    ]
  },
  "fvapps_001179.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calc_max_moves (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_max_moves_non_negative (x : Nat) :\n  calc_max_moves x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_max_moves_monotonic (x : Nat) :\n  x > 0 \u2192 calc_max_moves x \u2265 calc_max_moves (x-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval calc_max_moves 3\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval calc_max_moves 8\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calc_max_moves 9"
      }
    ]
  },
  "fvapps_001180.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_anagram_pairs (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_anagram_pairs_nonneg (s : String) :\n  find_anagram_pairs s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_anagram_pairs_empty_or_single (s : String) :\n  s.length \u2264 1 \u2192 find_anagram_pairs s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001187.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_tomu_win (n : Nat) (k : Nat) (arr : List Nat) : String := sorry\n\ndef getOddElements (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  l.zipWith (fun i x => if i % 2 = 1 then some x else none) (List.range l.length)\n   |>.filterMap id"
      },
      {
        "type": "sig",
        "string": "def getEvenElements (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  l.zipWith (fun i x => if i % 2 = 0 then some x else none) (List.range l.length)\n   |>.filterMap id"
      },
      {
        "type": "comment",
        "string": "-- Property: Result is always either \"YES\" or \"NO\""
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem can_tomu_win_valid_output (n k : Nat) (arr : List Nat) :\n  can_tomu_win n k arr = \"YES\" \u2228 can_tomu_win n k arr = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property: When k=0, if Tomu's initial sum \u2264 Motu's initial sum, result is \"NO\""
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem k_zero_no_improvement (n : Nat) (arr : List Nat)\n  (h1 : arr.length = n)\n  (h2 : (getOddElements arr).foldl (\u00b7 + \u00b7) 0 \u2264 (getEvenElements arr).foldl (\u00b7 + \u00b7) 0) :\n  can_tomu_win n 0 arr = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property: With k \u2265 n, if array has distinct values, Tomu can win"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem large_k_wins (n : Nat) (arr : List Nat)\n  (h1 : arr.length = n)\n  (h2 : n > 1)\n  (h3 : \u2203 (x y : Nat), x \u2208 arr \u2227 y \u2208 arr \u2227 x > y) :\n  can_tomu_win n n arr = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property: Base cases work correctly"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem base_cases :\n  can_tomu_win 1 0 [1] = \"NO\" \u2227\n  can_tomu_win 2 1 [1, 2] = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_tomu_win 6 0 [1, 1, 1, 1, 1, 1]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_tomu_win 5 1 [2, 4, 6, 3, 4]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_tomu_win 4 2 [1, 5, 3, 2]"
      }
    ]
  },
  "fvapps_001191.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_good_group (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_good_group (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def substring (s : String) (start len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def get_char (s : String) (i : Nat) : Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_good_result_bounds {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  1 \u2264 res \u2227 res \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exists_valid_substring {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  \u2203 start : Nat, start + res \u2264 s.length \u2227\n    is_good_group (substring s start res) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_longer_good_groups {s : String} (h : s.length > 0) :\n  let res := find_max_good_group s\n  \u2200 len : Nat, len > res \u2192 len \u2264 s.length \u2192\n    \u2200 i : Nat, i + len \u2264 s.length \u2192\n      \u00acis_good_group (substring s i len) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_digit_max_length {s : String} (h : s.length > 0)\n  (h_same : \u2200 i j : Nat, i < s.length \u2192 j < s.length \u2192\n            get_char s i = get_char s j) :\n  find_max_good_group s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_good_group \"123343\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_good_group \"95665\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_good_group \"2323\""
      }
    ]
  },
  "fvapps_001195.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_possible_ascii_chars (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasDuplicates (s: List \u03b1) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_uppercase_ascii (input: String)\n    (h: input.all (fun c => '0' \u2264 c \u2227 c \u2264 '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    result.all (fun c => 65 \u2264 c.toNat \u2227 c.toNat \u2264 90) \u2227\n    \u00achasDuplicates result.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chars_derive_from_input (input: String)\n    (h: input.all (fun c => '0' \u2264 c \u2227 c \u2264 '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    let input_chars := input.data\n    \u2200 c \u2208 result.data, \u2203 d \u2208 input_chars, d.toNat = (c.toNat / 10) + '0'.toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_digits_give_empty (input: String)\n    (h: input.all (fun c => '0' \u2264 c \u2227 c \u2264 '4'))\n    (h_size: input.length > 0) :\n    find_possible_ascii_chars input = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicates_are_removed (input: String)\n    (h: input.all (fun c => '0' \u2264 c \u2227 c \u2264 '9'))\n    (h_size: input.length > 0) :\n    let result := find_possible_ascii_chars input\n    \u00achasDuplicates result.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'A'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"65\"\n\n/-\ninfo: 'AB'\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"566\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval find_possible_ascii_chars \"11\""
      }
    ]
  },
  "fvapps_001200.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_divisible_by_five : String \u2192 Nat\n  | s => sorry\n\ndef contains_five_or_zero (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.contains '0' || s.contains '5'"
      },
      {
        "type": "cond",
        "string": "theorem check_divisible_outputs_zero_or_one (s : String) :\n  (check_divisible_by_five s = 0) \u2228 (check_divisible_by_five s = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_divisible_leading_zero (s : String) :\n  check_divisible_by_five (\"0\" ++ s) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_divisible_by_five \"19\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_divisible_by_five \"385\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_divisible_by_five \"1234\""
      }
    ]
  },
  "fvapps_001210.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_virus_spread (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter (\u00b7 = '1') |>.length"
      },
      {
        "type": "cond",
        "string": "theorem solve_virus_spread_type (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le 0 (solve_virus_spread N init_pop D isolations) \u2227\n  Nat.le (solve_virus_spread N init_pop D isolations) N :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_virus_spread_no_infected (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  (\u2200 c, c \u2208 init_pop.data \u2192 c \u2260 '1') \u2192\n  solve_virus_spread N init_pop D isolations = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_virus_spread_no_isolation (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  D = 0 \u2192\n  solve_virus_spread N init_pop D isolations = countOnes init_pop :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_virus_spread_monotonic (N : Nat) (init_pop : String) (D : Nat) (isolations : List Nat) :\n  Nat.le (countOnes init_pop) (solve_virus_spread N init_pop D isolations) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_virus_spread 9 \"000010000\" 3 [2, 5, 8]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_virus_spread 5 \"00001\" 1 [5]"
      }
    ]
  },
  "fvapps_001215.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_time_for_multiple_of_nine (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def digit_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_within_bounds (n : Nat) (h : n > 0) :\n  let result := min_time_for_multiple_of_nine n\n  result \u2265 0 \u2227 result \u2264 8 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 1989\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 86236\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_time_for_multiple_of_nine 90210"
      }
    ]
  },
  "fvapps_001221.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_gem_game (n m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The result of solve_gem_game is never negative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_gem_game_nonneg (n m : Nat) :\n  solve_gem_game n m \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- When m=1, result follows pattern based on n being even/odd -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_gem_game_m_one (n : Nat) :\n  solve_gem_game n 1 = if n % 2 = 0 then n/2 else n/2 + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For m > (n+1)/2, result equals m -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_gem_game_large_m (n m : Nat) (h : m > (n+1)/2) :\n  solve_gem_game n m = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_gem_game 4 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_gem_game 6 3\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_gem_game 10 1"
      }
    ]
  },
  "fvapps_001222.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def base5 (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def seq (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_kth_magical_number (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digitList (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isEvenDigit (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base5_zero :\n  base5 0 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base5_digits_bounded (n : Nat) :\n  \u2200 d \u2208 base5 n, 0 \u2264 d \u2227 d \u2264 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem magical_increasing (k : Nat) :\n  k > 1 \u2192\n  get_kth_magical_number (k-1) < get_kth_magical_number k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_kth_magical_number 2\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval get_kth_magical_number 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval get_kth_magical_number 1"
      }
    ]
  },
  "fvapps_001230.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Grid := List String\n\ndef isValidGrid (grid : Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solveHauntedLand (grid : Grid) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countStars (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.filter (\u00b7 = '*') |>.length"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem solve_haunted_land_output_valid (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_grid_returns_zero (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : \u2200 (row : String), List.contains grid row \u2192 \u00ac row.contains '*') :\n  solveHauntedLand grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_house_returns_one (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : listSum (grid.map countStars) = 1) :\n  solveHauntedLand grid = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded_by_dimensions (grid : Grid)\n  (h : isValidGrid grid = true) :\n  solveHauntedLand grid \u2264 max grid.length (grid.head?.map String.length |>.getD 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem inhabited_houses_positive_time (grid : Grid)\n  (h1 : isValidGrid grid = true)\n  (h2 : \u2203 (row : String), List.contains grid row \u2227 row.contains '*') :\n  solveHauntedLand grid \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"*.\", \"..\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_haunted_land [\".*..\", \"***.\", \".*..\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haunted_land [\"...\", \"...\"]"
      }
    ]
  },
  "fvapps_001233.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_elements_needed (N K : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def permutation (l1 l2 : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  l1.length = l2.length \u2227 \u2200 x, x \u2208 l1 \u2194 x \u2208 l2"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_non_negative (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_upper_bound (N K : Nat) (arr : List Nat) :\n  min_elements_needed N K arr \u2264 K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_complete_powers (N K : Nat) (arr : List Nat) :\n  (\u2200 i : Nat, i < K \u2192 (2^i) \u2208 arr) \u2192\n  min_elements_needed N K arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_empty (K : Nat) :\n  min_elements_needed 0 K [] = K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_singleton_min (K : Nat) :\n  min_elements_needed 1 K [1] = K - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_singleton_max (K : Nat) :\n  min_elements_needed 1 K [2^K] = K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_elements_perm_invariant (N K : Nat) (arr\u2081 arr\u2082 : List Nat) :\n  permutation arr\u2081 arr\u2082 \u2192\n  min_elements_needed N K arr\u2081 = min_elements_needed N K arr\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_elements_needed 2 2 [3, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_elements_needed 7 3 [3, 7, 5, 4, 6, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_elements_needed 1 3 [2]"
      }
    ]
  },
  "fvapps_001243.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def binaryStringToDecimal (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_in_valid_range (s : String) (h : s.length > 0) :\n  binaryStringToDecimal s < 10^9 + 7 \u2227 binaryStringToDecimal s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_vowels_max_value (s : String) (h : s.length > 0)\n  (h2 : \u2200 c \u2208 s.data, isVowel c) :\n  binaryStringToDecimal s = (2^s.length - 1) % (10^9 + 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_consonants_zero (s : String) (h : s.length > 0)\n  (h2 : \u2200 c \u2208 s.data, \u00acisVowel c) :\n  binaryStringToDecimal s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_vowel_positions_equal (s1 s2 : String)\n  (h1 : s1.length > 0)\n  (h2 : s1.length = s2.length)\n  (h3 : \u2200 (i : String.Pos), isVowel (s1.get i) = isVowel (s2.get i)) :\n  binaryStringToDecimal s1 = binaryStringToDecimal s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"hello\"\n\n/-\ninfo: 31\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"aeiou\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_string_to_decimal \"xyz\""
      }
    ]
  },
  "fvapps_001249.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_symmetric_zero_diag (B : List (List Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve (N: Nat) (Q: Nat) (B: List (List Nat)) (queries: List (Nat \u00d7 List Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_A (B: List (List Int)) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def update_B (B: List (List Nat)) (p: Nat) (R: List Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_shape_correct {N Q: Nat} {B: List (List Nat)} {queries: List (Nat \u00d7 List Nat)}\n  (h1: N = 3)\n  (h2: List.length B = N)\n  (h3: \u2200 row \u2208 B, List.length row = N)\n  (h4: List.length queries \u2265 1)\n  (h5: List.length queries \u2264 3)\n  : let result := solve N Q B queries\n    List.length result = List.length queries + 1 \u2227\n    \u2200 row \u2208 result, List.length row = N :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distances_preserved {A: List Int} {N: Nat}\n  (h1: List.length A = N)\n  (h2: N = 3)\n  : let B := List.map (\u03bb i => List.map (\u03bb j => Int.natAbs (A.get \u27e8i, by sorry\u27e9 - A.get \u27e8j, by sorry\u27e9)) (List.range N)) (List.range N)\n    let reconstructed := get_A (B.map (List.map Int.ofNat))\n    \u2200 (i j : Fin reconstructed.length),\n    Int.natAbs (reconstructed.get i - reconstructed.get j) = (B.get \u27e8i.val, by sorry\u27e9).get \u27e8j.val, by sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem update_B_symmetric {N p: Nat} {R: List Nat}\n  (h1: N \u2265 2)\n  (h2: N \u2264 5)\n  (h3: p < N)\n  (h4: List.length R \u2265 N)\n  : let B := List.replicate N (List.replicate N 0)\n    let updated := update_B B p (List.take N R)\n    \u2200 (i j : Fin N),\n    (updated.get \u27e8i.val, by sorry\u27e9).get \u27e8j.val, by sorry\u27e9 =\n    (updated.get \u27e8j.val, by sorry\u27e9).get \u27e8i.val, by sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001250.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_obtain_k (n : Nat) (k : Nat) (edges : List (Nat \u00d7 Nat)) (values : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_obtain_k_returns_valid_output (n : Nat) (k : Nat) (edges : List (Nat \u00d7 Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  (can_obtain_k n k edges values = \"YES\") \u2228 (can_obtain_k n k edges values = \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_obtain_k_identical_values_consistent (n : Nat) (k : Nat) (edges : List (Nat \u00d7 Nat))\n    (h1 : is_valid_tree n edges = true) :\n  let values := List.replicate n 1\n  can_obtain_k n k edges values = can_obtain_k n k edges values :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_obtain_k_valid_edges (n : Nat) (k : Nat) (edges : List (Nat \u00d7 Nat))\n    (values : List Nat) (h1 : is_valid_tree n edges = true) :\n  edges.length = n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 6 85 [(1, 2), (2, 3), (2, 4), (4, 5), (3, 6)] [3, 5, 4, 7, 1, 9]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_obtain_k 3 4 [(1, 2), (1, 3)] [2, 3, 1]\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_obtain_k 4 100 [(1, 2), (2, 3), (2, 4)] [3, 4, 2, 5]"
      }
    ]
  },
  "fvapps_001252.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_city_paths (n: Nat) (roads: List (Nat \u00d7 Nat)) (start: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper definition for valid graphs"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def is_valid_graph (n: Nat) (roads: List (Nat \u00d7 Nat)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 (u v: Nat), (u,v) \u2208 roads \u2192\n    (1 \u2264 u \u2227 u \u2264 n) \u2227\n    (1 \u2264 v \u2227 v \u2264 n) \u2227\n    (u \u2260 v) \u2227\n    (\u2200 (u' v': Nat), (u',v') \u2208 roads \u2192 (u',v') = (u,v) \u2228 (u',v') \u2260 (u,v))"
      },
      {
        "type": "cond",
        "string": "theorem solve_city_paths_single_node :\n  solve_city_paths 1 [] 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_city_paths_two_nodes :\n  solve_city_paths 2 [(1,2)] 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_city_paths 3 [(1, 2), (1, 3)] 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_city_paths 5 [(1, 2), (1, 3), (2, 4), (2, 5)] 1"
      }
    ]
  },
  "fvapps_001260.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def nextPermutation (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve (n k : Nat) (perms : List (List Int)) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPermutation (arr1 arr2 : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSortedDesc (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_permutation_preserves_elements (arr : List Int) :\n  isPermutation arr (nextPermutation arr) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_permutation_idempotent_at_max {arr : List Int}\n  (h : isSortedDesc arr) :\n  nextPermutation arr = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_permutation_lexicographically_larger {arr : List Int} :\n  nextPermutation arr \u2265 arr \u2228 isSortedDesc arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_correct_length (n k : Nat) (perms : List (List Int)) :\n  (solve n k perms).length = perms.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_preserves_permutations (n k : Nat) (perms : List (List Int)) :\n  \u2200 i, i < perms.length \u2192\n    isPermutation (perms.get \u27e8i, sorry\u27e9) ((solve n k perms).get \u27e8i, sorry\u27e9) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001262.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isString : (s : String) \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def canReorderString : (s : String) \u2192 String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidLifetime (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem canReorderString_valid_output (s : String) :\n  (canReorderString s = \"YES\") \u2228 (canReorderString s = \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem canReorderString_matches_validity (s : String) :\n  canReorderString s = (if isValidLifetime s then \"YES\" else \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exactly_nine_chars (s : String) (h : s.length = 9) :\n  countChar 'L' s \u2265 2 \u2192\n  countChar 'T' s \u2265 2 \u2192\n  countChar 'I' s \u2265 2 \u2192\n  countChar 'M' s \u2265 2 \u2192\n  countChar 'E' s \u2265 1 \u2192\n  canReorderString s = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem more_than_nine_chars (s : String) (h : s.length > 9) :\n  countChar 'L' s \u2265 2 \u2192\n  countChar 'T' s \u2265 2 \u2192\n  countChar 'I' s \u2265 2 \u2192\n  countChar 'M' s \u2265 2 \u2192\n  countChar 'E' s \u2265 2 \u2192\n  canReorderString s = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEAZAZAITLME\"\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LLLTTTIIIMMMEEEAHA\"\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_reorder_string \"LTIMEM\""
      }
    ]
  },
  "fvapps_001263.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_messi_passing (n_passes: Nat) (k_teammates: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem two_passes_equals_teammates {k: Nat} (h: k \u2264 1000) (h2: k \u2265 1) :\n  solve_messi_passing 2 k = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded_by_power {n k: Nat} (h1: n \u2265 2) (h2: n \u2264 1000)\n    (h3: k \u2265 1) (h4: k \u2264 1000) :\n  solve_messi_passing n k \u2264 k^(n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_messi_passing 2 4\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 4 2\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_messi_passing 3 3"
      }
    ]
  },
  "fvapps_001267.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.size {\u03b1} : List \u03b1 \u2192 Nat\n  | [] => 0\n  | _::xs => 1 + xs.size\n\ndef sequence_generator (n k : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_positive_prefixes (seq : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def Int.abs (i : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_length (n k : Nat) (h1 : n > 0) (h2 : k \u2264 100) :\n  (sequence_generator n k).size = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_elements (n k : Nat) (h1 : n > 0) (h2 : k \u2264 100) (h3 : i < n) :\n  let seq := sequence_generator n k\n  \u2200 i : Nat, i < n \u2192 Int.abs (seq.get \u27e8i, sorry\u27e9) = i + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_prefix_count (n k : Nat) (h1 : n > 0) (h2 : k \u2264 100) :\n  count_positive_prefixes (sequence_generator n k) \u2264 min k n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_positive_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n n\n  (\u2200 i : Nat, i < n \u2192 seq.get \u27e8i, sorry\u27e9 > 0) \u2227\n  seq = List.map (Int.ofNat \u2218 Nat.succ) (List.range n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_negative_case (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n 0\n  (\u2200 i : Nat, i < n \u2192 seq.get \u27e8i, sorry\u27e9 < 0) \u2227\n  seq = List.map (fun i => -Int.ofNat (i + 1)) (List.range n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval sequence_generator 3 3"
      }
    ]
  },
  "fvapps_001268.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_divisor (nums: List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_divides_all (d: Nat) (nums: List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_gcd (nums: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_divides_all_numbers (nums: List Nat) :\n  let result := find_min_divisor nums\n  result \u2260 -1 \u2192 is_divides_all result.toNat nums = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_one_means_no_common_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 \u2192 list_gcd nums = 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_minimal_divisor (nums: List Nat) :\n  let result := find_min_divisor nums\n  result \u2260 -1 \u2192\n  \u2200 d: Nat, 2 \u2264 d \u2192 d < result.toNat \u2192\n  is_divides_all d nums = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid_number (nums: List Nat) :\n  let result := find_min_divisor nums\n  result = -1 \u2228 result \u2265 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [2, 4, 8]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_divisor [4, 7, 5]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_divisor [12, 18, 24]"
      }
    ]
  },
  "fvapps_001277.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_qualified_teams (n : Nat) (k : Nat) (scores : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_qualified_teams_bounds (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k \u2264 scores.length)\n    (h3 : scores.length = n) :\n    k \u2264 count_qualified_teams n k scores \u2227 count_qualified_teams n k scores \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs"
      },
      {
        "type": "sig",
        "string": "def list_unique (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 (i j : Fin l.length), i.val \u2260 j.val \u2192 l[i] \u2260 l[j]"
      },
      {
        "type": "cond",
        "string": "theorem count_qualified_teams_deterministic (n : Nat) (k : Nat) (scores : List Int)\n    (h1 : k > 0)\n    (h2 : k \u2264 scores.length)\n    (h3 : scores.length = n) :\n    count_qualified_teams n k scores = count_qualified_teams n k scores :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 5 1 [3, 5, 2, 4, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_qualified_teams 6 4 [6, 5, 4, 3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_qualified_teams 4 2 [10, 10, 8, 8]"
      }
    ]
  },
  "fvapps_001282.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calcMinOpsLuckyNum (n : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Basic properties about operation counting -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def countNonLuckyDigits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_nonnegative (n : String) :\n  calcMinOpsLuckyNum n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_ops_is_length (n : String) :\n  calcMinOpsLuckyNum n \u2264 n.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Helper function to count non-lucky digits -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem ops_equals_non_lucky_digits (n : String) :\n  calcMinOpsLuckyNum n = countNonLuckyDigits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"25\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"46\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval calc_min_ops_lucky_num \"99\""
      }
    ]
  },
  "fvapps_001288.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_supw_time (n : Nat) (days : List Nat) : Nat := sorry\n\ndef list_min (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl min x xs"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "sig",
        "string": "def list_take_last (n : Nat) (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, x::xs => x :: list_take_last n xs"
      },
      {
        "type": "cond",
        "string": "theorem min_supw_time_monotonic (n : Nat) (days : List Nat) (i : Nat) (x : Nat)\n  (h1 : n = days.length) (h2 : n \u2265 3) (h3 : i < n) :\n  let days' := List.set days i (days[i] + x)\n  min_supw_time n days' \u2265 min_supw_time n days :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_supw_time 10 [3, 2, 1, 1, 2, 3, 1, 3, 2, 1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval min_supw_time 8 [3, 2, 3, 2, 3, 5, 1, 3]"
      }
    ]
  },
  "fvapps_001290.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countDigits (a b : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sumList xs"
      },
      {
        "type": "sig",
        "string": "def isSorted : List String \u2192 Bool\n  | [] => true\n  | [_] => true\n  | x::y::rest => x \u2264 y && isSorted (y::rest)"
      },
      {
        "type": "cond",
        "string": "theorem countDigits_format_valid {a b : Nat} (h : a \u2264 b) (n : Nat) (h1 : n < 10^4) :\n  let result := countDigits a b\n  let pairs := (result.split (\u00b7 = ' '))\n  pairs.length = 10 \u2227\n  (\u2200 p \u2208 pairs, \u2203 d c, (p.split (\u00b7 = ':')) = [d, c] \u2227\n     d \u2208 [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"] \u2227\n     (\u2200 ch \u2208 c.data, ch.isDigit)) \u2227\n  isSorted (pairs.map (fun p => ((p.split (\u00b7 = ':')).get! 0))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countDigits_count_valid {a b : Nat} (h : a \u2264 b) :\n  let result := countDigits a b\n  let counts := ((result.split (\u00b7 = ' ')).map\n    (fun p => String.toNat! ((p.split (\u00b7 = ':')).get! 1)))\n  let digitCount := (List.range (b - a + 1)).map\n    (fun i => (toString (i + a)).length)\n  sumList counts = sumList digitCount :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countDigits_single_num_valid (n : Nat) :\n  let result := countDigits n n\n  let counts := ((result.split (\u00b7 = ' ')).map\n    (fun p => String.toNat! ((p.split (\u00b7 = ':')).get! 1)))\n  \u2200 d : Nat, d < 10 \u2192\n    (counts.get! d) = ((toString n).data.filter\n      (fun c => c = (toString d).data.get! 0)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0'\n-/\n#guard_msgs in\n#eval count_digits 10 15\n\n/-\ninfo: '0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1'\n-/\n#guard_msgs in\n#eval count_digits 912 912\n\n/-\ninfo: '0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120'\n-/\n#guard_msgs in\n#eval count_digits 900 999"
      }
    ]
  },
  "fvapps_001291.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_candies_for_party (people_counts: List Nat) (remainder: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def lcm (a b : Nat) : Nat := Nat.div (a * b) (gcd a b)"
      },
      {
        "type": "cond",
        "string": "theorem remainder_divides_result (people_counts: List Nat) (remainder: Nat) (count: Nat)\n  (h: count \u2208 people_counts) (h2: count > 0) :\n  count \u2223 (min_candies_for_party people_counts remainder - remainder) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 3] 1\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval min_candies_for_party [2, 4, 6] 1\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_candies_for_party [5] 2"
      }
    ]
  },
  "fvapps_001293.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_largest_n (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_steps_to_zero (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_n_returns_valid (k : Nat) (h : k > 0) (h2 : k \u2264 1000) :\n  find_largest_n k \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_largest_n_edge_cases :\n  find_largest_n 1 = 0 \u2227\n  find_largest_n 2 = 9 \u2227\n  find_largest_n 3 = 10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval find_largest_n 2\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_largest_n 3\n\n/-\ninfo: 170\n-/\n#guard_msgs in\n#eval find_largest_n 100"
      }
    ]
  },
  "fvapps_001298.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encodeAscii (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def decodeAsciiMessage (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem decode_matches_input {s : String}\n    (h1 : s \u2260 \"\")\n    (h2 : \u2200 c \u2208 s.data, 32 \u2264 c.toNat \u2227 c.toNat \u2264 126) :\n    decodeAsciiMessage (encodeAscii s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decoded_chars_in_ascii_range {s : String}\n    (h1 : s \u2260 \"\")\n    (h2 : \u2200 c \u2208 s.data, 32 \u2264 c.toNat \u2227 c.toNat \u2264 126) :\n    \u2200 c \u2208 (decodeAsciiMessage (encodeAscii s)).data,\n      32 \u2264 c.toNat \u2227 c.toNat \u2264 126 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encoded_is_numeric {s : String}\n    (h1 : s \u2260 \"\")\n    (h2 : \u2200 c \u2208 s.data, 32 \u2264 c.toNat \u2227 c.toNat \u2264 126) :\n    \u2200 c \u2208 (encodeAscii s).data, c.isDigit :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"721011081081113287111114108100\"\n\n/-\ninfo: 'Welcome to India'\n-/\n#guard_msgs in\n#eval decode_ascii_message \"871011089911110910132116111327311010010597\""
      }
    ]
  },
  "fvapps_001302.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_permutation_divisible_by_3 (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sort_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_permutation_returns_binary (n : Nat) :\n  check_permutation_divisible_by_3 n = 0 \u2228 check_permutation_divisible_by_3 n = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 18\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 308\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval check_permutation_divisible_by_3 123"
      }
    ]
  },
  "fvapps_001318.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_plates_max_deliciousness (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countLeadingZeros (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countTrailingZeros (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_plates_result_bounds {n : Nat} {arr : List Nat}\n  (h : arr.length = n) (h2 : n > 0) :\n  let result := min_plates_max_deliciousness n arr\n  1 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 4 [1, 2, 3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 5 [3, 2, 0, 3, 0]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_plates_max_deliciousness 3 [0, 0, 0]"
      }
    ]
  },
  "fvapps_001319.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tourist_spots (n : Nat) (roads : List String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidRoad : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tourist_spots_output_is_float (n : Nat) (roads : List String)\n    (h : n \u2265 2) (h2 : roads.length > 0) :\n  \u2203 (f : Float), solve_tourist_spots n roads = f :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tourist_spots_total_weight\n    {n : Nat} {roads : List String} {weights : List Float}\n    (h : n \u2265 2)\n    (h2 : roads.length > 0)\n    (h3 : weights = roads.map (fun r => sorry)) :\n  solve_tourist_spots n roads \u2264 weights.foldl (. + .) 0.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tourist_spots_invalid_input\n    {n : Nat} {roads : List String}\n    (h : n \u2265 2)\n    (h2 : \u2203 r \u2208 roads, \u00ac isValidRoad r) :\n  solve_tourist_spots n roads = 0.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001328.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_temp_difference (today_high today_low normal_high normal_low : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.contains? (s : String) (substr : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.toFloat (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Int.toFloat (i : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem temp_diff_result_format (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high \u2265 today_low) (h2 : normal_high \u2265 normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  \u2203 (diff : String) (dir : String),\n    result = diff ++ \" DEGREE(S) \" ++ dir ++ \" NORMAL\" \u2227\n    (dir = \"ABOVE\" \u2228 dir = \"BELOW\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem temp_diff_nonnegative (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high \u2265 today_low) (h2 : normal_high \u2265 normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let parts := result.splitOn \" DEGREE(S) \"\n  let diff := parts[0]!\n  String.toFloat diff \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem temp_diff_direction (today_high today_low normal_high normal_low : Int)\n  (h1 : today_high \u2265 today_low) (h2 : normal_high \u2265 normal_low) :\n  let result := calculate_temp_difference today_high today_low normal_high normal_low\n  let avg_today : Float := (today_high.toFloat + today_low.toFloat) / 2\n  let avg_normal : Float := (normal_high.toFloat + normal_low.toFloat) / 2\n  (avg_today > avg_normal \u2192 result.contains? \"ABOVE\") \u2227\n  (avg_today \u2264 avg_normal \u2192 result.contains? \"BELOW\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001334.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_pizza_time (n : Nat) (k : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_ones (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pizza_time_bounds (n k: Nat) (s: String) :\n  n > 0 \u2192 s.length = n \u2192\n  let result := max_pizza_time n k s\n  0 \u2264 result \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pizza_time_upper_bound (n k: Nat) (s: String) :\n  n > 0 \u2192 s.length = n \u2192\n  max_pizza_time n k s \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pizza_time_all_ones (n: Nat) :\n  n > 0 \u2192\n  let s := String.mk (List.replicate n '1')\n  max_pizza_time n 0 s = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pizza_time_all_zeros (n: Nat) :\n  n > 0 \u2192\n  let s := String.mk (List.replicate n '0')\n  let k := n / 2\n  max_pizza_time n k s = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pizza_time 13 2 \"0101110000101\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_pizza_time 6 3 \"100001\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval max_pizza_time 5 2 \"10001\""
      }
    ]
  },
  "fvapps_001344.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_cheat_possibilities (a b : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countDivisors (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_numbers_returns_negative_one\n  {x : Nat} (h : x > 0) (h2 : x \u2264 1000) :\n  solve_cheat_possibilities x x = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_symmetric\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a \u2264 1000) (h4 : b \u2264 1000) :\n  solve_cheat_possibilities a b = solve_cheat_possibilities b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_nonnegative_for_different\n  {a b : Nat} (h1 : a > 0) (h2 : b > 0) (h3 : a \u2264 1000) (h4 : b \u2264 1000) (h5 : a \u2260 b) :\n  solve_cheat_possibilities a b \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perfect_squares_have_odd_factors\n  {n : Nat} (h1 : n > 0) (h2 : n \u2264 100) :\n  solve_cheat_possibilities 0 (n * n) % 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 2 6\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 5 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_cheat_possibilities 10 14"
      }
    ]
  },
  "fvapps_001355.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_xor_parity (n m : Nat) (arr queries : List Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def popCount (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_parity_output_format {n m : Nat} {arr queries : List Nat}\n    (h1 : arr.length > 0) (h2 : queries.length > 0)\n    (h3 : arr.length = n) (h4 : queries.length = m) :\n    let result := solve_xor_parity n m arr queries\n    result.length = queries.length \u2227\n    \u2200 r \u2208 result,\n      \u2203 evens odds : Nat,\n        r = toString evens ++ \" \" ++ toString odds \u2227\n        evens + odds = arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_parity_idempotent {n : Nat} {arr : List Nat} {query : Nat}\n    (h : arr.length > 0) (h2 : arr.length = n) :\n    solve_xor_parity n 1 arr [query] = solve_xor_parity n 1 arr [query] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_xor_parity_singleton {x query : Nat} :\n    let result := solve_xor_parity 1 1 [x] [query]\n    let r := result[0]!\n    let evens := (r.splitOn \" \")[0]!.toNat!\n    let odds := (r.splitOn \" \")[1]!.toNat!\n    evens + odds = 1 \u2227\n    (if (popCount (x.xor query)) % 2 = 0\n     then evens = 1 \u2227 odds = 0\n     else evens = 0 \u2227 odds = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['2 4']\n-/\n#guard_msgs in\n#eval solve_xor_parity 6 1 [4, 2, 15, 9, 8, 8] [3]\n\n/-\ninfo: ['0 2']\n-/\n#guard_msgs in\n#eval solve_xor_parity 2 1 [1, 2] [3]\n\n/-\ninfo: ['0 1']\n-/\n#guard_msgs in\n#eval solve_xor_parity 1 1 [5] [7]"
      }
    ]
  },
  "fvapps_001358.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_ones_in_binary (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_bits : Int \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "  fun n => if n = 0 then 0 else (n % 2).natAbs + count_bits (n / 2)\ndecreasing_by sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_nonnegative_basic {x : Int} (h : x \u2265 0) :\n  count_ones_in_binary x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_negative_has_ones {x : Int} (h : x < 0) :\n  count_ones_in_binary x > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_power_of_two {x : Int} (h1 : x > 0) (h2 : x % 2 = 0) :\n  count_ones_in_binary x = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_equals_bit_count {x : Int} (h : x \u2265 0) :\n  count_ones_in_binary x = count_bits x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_ones_in_binary test_input[0]"
      }
    ]
  },
  "fvapps_001360.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_race_encounters (x : Int) (r speed1 speed2 : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem race_encounters_non_negative\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 \u2265 -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem race_encounters_less_than_laps\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 < x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem race_encounters_speed_symmetry\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r speed2 speed1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem race_encounters_speed_scaling\n  (x : Int) (r speed1 speed2 : Float)\n  (h1 : x > 0)\n  (h2 : r > 0)\n  (h3 : speed1 > 0)\n  (h4 : speed2 > 0)\n  (h5 : Float.abs (speed1 - speed2) > 0.0001) :\n  solve_race_encounters x r speed1 speed2 = solve_race_encounters x r (2 * speed1) (2 * speed2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 3 10 2 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_race_encounters 2 20 5 10\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_race_encounters 4 15 3 6"
      }
    ]
  },
  "fvapps_001361.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def decryptPassword (rules : List (Char \u00d7 Char)) (encrypted : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def replaceChar (s : String) (oldChar newChar : Char) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_rules_preserve_number {num : Nat} (h : num \u2264 1000000) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  stringToNat decrypted = num\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_rules_no_leading_zeros {num : Nat} (h : num \u2264 1000000) (h2 : num \u2260 0) :\n  let encrypted := toString num\n  let decrypted := decryptPassword [] encrypted\n  \u00ac(decrypted.get 0 = '0')\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_rules_single_zero :\n  decryptPassword [] \"0\" = \"0\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simple_substitutions_preserve_number\n  {rules : List (Char \u00d7 Char)}\n  {num : Nat}\n  (h1 : num \u2264 1000000)\n  (h2 : \u2200 r1 r2, r1 \u2208 rules \u2192 r2 \u2208 rules \u2192 r1.1 = r2.1 \u2192 r1 = r2)\n  (h3 : \u2200 r, r \u2208 rules \u2192 r.1 \u2208 \"abcdefghijklmnopqrstuvwxyz\".data)\n  (h4 : \u2200 r, r \u2208 rules \u2192 r.2 \u2208 \"0123456789\".data)\n  (h5 : rules.length \u2264 5) :\n  let numStr := toString num\n  let encrypted := rules.foldl (fun acc r => replaceChar acc r.2 r.1) numStr\n  let decrypted := decryptPassword rules encrypted\n  stringToNat decrypted = num\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '3'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"5\", \"3\"), (\"3\", \"1\")] \"5\"\n\n/-\ninfo: '1800'\n-/\n#guard_msgs in\n#eval decrypt_password [] \"01800.00\"\n\n/-\ninfo: '321.33098'\n-/\n#guard_msgs in\n#eval decrypt_password [(\"x\", \"0\"), (\"d\", \"3\"), (\"#\", \".\")] \"0xd21#dd098x\""
      }
    ]
  },
  "fvapps_001363.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := List String"
      },
      {
        "type": "sig",
        "string": "def Query := Nat \u00d7 Char"
      },
      {
        "type": "sig",
        "string": "def Result := String\n\ndef check_matrix_exists (L R : Nat) (matrix : Matrix) (queries : List Query) : List Result :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def all_same_matrix (c : Char) (L R : Nat) : Matrix :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_matrix_exists_results_match_queries\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  List.length results = List.length queries :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_matrix_exists_valid_results\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  \u2200 r \u2208 results, r = \"yes\" \u2228 r = \"no\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_matrix_exists_size_constraint\n  (matrix : Matrix) (queries : List Query) (L R : Nat) :\n  let results := check_matrix_exists L R matrix queries\n  \u2200 (q : Query) (r : Result),\n    (q, r) \u2208 List.zip queries results \u2192\n    q.1 > min L R \u2192 r = \"no\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_matrix_exists_all_same_char\n  (matrix : Matrix) (queries : List Query) (L R : Nat) (c : Char) :\n  let all_same := all_same_matrix c L R\n  let results := check_matrix_exists L R all_same queries\n  \u2200 (q : Query) (r : Result),\n    (q, r) \u2208 List.zip queries results \u2192\n    (q.2 = c \u2192 r = \"yes\" \u2194 q.1 \u2264 min L R) \u2227\n    (q.2 \u2260 c \u2192 r = \"no\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001364.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_make_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def process_test_case (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_stays_true {s : String} :\n  s = reverse s \u2192 can_make_palindrome s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_is_palindrome {s : String} :\n  s.length = 1 \u2192 can_make_palindrome s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_preserves_palindrome {s : String} :\n  can_make_palindrome s = can_make_palindrome (reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_returns_yes_no {s : String}\n  (h : s.length > 0) :\n  process_test_case s = \"YES\" \u2228 process_test_case s = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_matches_can_make {s : String} :\n  (process_test_case s = \"YES\") = can_make_palindrome s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem basic_palindrome_cases :\n  can_make_palindrome \"a\" \u2227\n  can_make_palindrome \"aa\" \u2227\n  can_make_palindrome \"aba\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"aaa\"\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval process_test_case \"abc\"\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval process_test_case \"abdbca\""
      }
    ]
  },
  "fvapps_001368.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_max_gcd (s : String) (m x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_properties (a b : Int) (h : b \u2260 0) :\n  let g := gcd a.natAbs b.natAbs\n  g > 0 \u2227 a.natAbs % g = 0 \u2227 b.natAbs % g = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_max_gcd_basic_properties\n  (s : String) (m x y : Nat)\n  (h1 : s.length > 0)\n  (h2 : s.length \u2264 10)\n  (h3 : m \u2264 5)\n  (h4 : m > 0)\n  (h5 : x \u2264 3)\n  (h6 : y \u2264 3)\n  (h7 : x \u2264 y) :\n  let result := solve_max_gcd s m x y\n  result \u2265 0 \u2227\n  result \u2264 (sorry) -- max of all valid partition numbers\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_max_gcd_partition_bounds\n  (s : String)\n  (h1 : s.length > 0)\n  (h2 : s.length \u2264 5) :\n  let m := s.length\n  let full_partition := solve_max_gcd s m 0 m\n  let single_partition := solve_max_gcd s m 0 0\n  full_partition \u2265 0 \u2227\n  (single_partition = sorry \u2228 single_partition = 0) -- equal to integer value of s or 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_001371.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.replicate (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Function signature we're reasoning about"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def count_safe_buildings (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Properties from hypothesis test"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isSafeBuilding (s : String) (i : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_safe_buildings_equals_safe_spots (s : String) :\n  count_safe_buildings s =\n    (List.range s.length).foldl (fun acc i =>\n      if isSafeBuilding s i then acc + 1 else acc) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_safe_buildings_nonnegative (s : String) :\n  count_safe_buildings s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_safe_buildings_bounded (s : String) :\n  count_safe_buildings s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper definition for checking if building at index i is safe"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_returns_length (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"0\" n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_returns_zero (s : String) (n : Nat) :\n  count_safe_buildings (String.replicate \"1\" n) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Edge cases"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_string_returns_zero :\n  count_safe_buildings \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_zero_returns_one :\n  count_safe_buildings \"0\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_one_returns_zero :\n  count_safe_buildings \"1\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_safe_buildings \"010\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_safe_buildings \"10001\"\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_safe_buildings \"0000000\""
      }
    ]
  },
  "fvapps_001378.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_expected_beauty (n : Nat) (beauties : List Nat) (probs : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxList (l : List Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "  Float.ofNat (l.foldl max 0)"
      },
      {
        "type": "sig",
        "string": "def listXor (l : List Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "  Float.ofNat (l.foldl Nat.xor 0)"
      },
      {
        "type": "cond",
        "string": "theorem expected_beauty_bounds {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (h3 : \u2200 p \u2208 probs, 0 \u2264 p \u2227 p \u2264 1)\n    (h4 : beauties.length > 0)\n    : 0 \u2264 calculate_expected_beauty n beauties probs \u2227\n      calculate_expected_beauty n beauties probs \u2264 maxList beauties :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem probabilities_zero_one {n : Nat} {beauties : List Nat}\n    (h1 : beauties.length = n)\n    : calculate_expected_beauty n beauties (List.replicate n 0) = 0 \u2227\n      calculate_expected_beauty n beauties (List.replicate n 1) =\n        listXor beauties :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem symmetry {n : Nat} {beauties : List Nat} {probs : List Float}\n    (h1 : beauties.length = n)\n    (h2 : probs.length = n)\n    (\u03c3 : List.Perm beauties (beauties.take n))\n    (\u03c4 : List.Perm probs (probs.take n))\n    : calculate_expected_beauty n beauties probs =\n      calculate_expected_beauty n (beauties.take n) (probs.take n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001382.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_lucky_string (a b : String) : String := sorry\n\ndef isDigitChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  '0' \u2264 c \u2227 c \u2264 '9'"
      },
      {
        "type": "sig",
        "string": "def isLuckyChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = '4' \u2228 c = '7'"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_only_lucky_chars (a b : String)\n  (h_a : \u2200 c \u2208 a.data, isDigitChar c)\n  (h_b : \u2200 c \u2208 b.data, isDigitChar c) :\n  \u2200 c \u2208 (get_lucky_string a b).data, isLuckyChar c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_seven_before_four (a b : String)\n  (h_a : \u2200 c \u2208 a.data, isDigitChar c)\n  (h_b : \u2200 c \u2208 b.data, isDigitChar c)\n  (h_has_both : '7' \u2208 (get_lucky_string a b).data \u2227 '4' \u2208 (get_lucky_string a b).data) :\n  \u2203 pos_seven pos_four,\n    pos_seven < pos_four \u2227\n    (get_lucky_string a b).data.get! pos_seven = '7' \u2227\n    (get_lucky_string a b).data.get! pos_four = '4' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_length (a b : String)\n  (h_a : \u2200 c \u2208 a.data, isDigitChar c)\n  (h_b : \u2200 c \u2208 b.data, isDigitChar c) :\n  (get_lucky_string a b).length \u2264 a.length + b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_deterministic (a b : String)\n  (h_a : \u2200 c \u2208 a.data, isDigitChar c)\n  (h_b : \u2200 c \u2208 b.data, isDigitChar c) :\n  get_lucky_string a b = get_lucky_string a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_identical_inputs (s : String)\n  (h : \u2200 c \u2208 s.data, isDigitChar c) :\n  get_lucky_string s s = get_lucky_string s s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_commutative (a b : String)\n  (h_a : \u2200 c \u2208 a.data, isDigitChar c)\n  (h_b : \u2200 c \u2208 b.data, isDigitChar c) :\n  get_lucky_string a b = get_lucky_string b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_string_preserves_counts (s : String)\n  (h : \u2200 c \u2208 s.data, isDigitChar c)\n  (h_nonempty : s.length > 0) :\n  let result := get_lucky_string s s\n  let count_4s := (s.data.filter (\u00b7 = '4')).length\n  let count_7s := (s.data.filter (\u00b7 = '7')).length\n  (result.data.filter (\u00b7 = '4')).length \u2264 2 * count_4s \u2227\n  (result.data.filter (\u00b7 = '7')).length \u2264 2 * count_7s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '7'\n-/\n#guard_msgs in\n#eval get_lucky_string \"4\" \"7\"\n\n/-\ninfo: '74'\n-/\n#guard_msgs in\n#eval get_lucky_string \"435\" \"479\"\n\n/-\ninfo: '777744'\n-/\n#guard_msgs in\n#eval get_lucky_string \"1675475\" \"9756417\""
      }
    ]
  },
  "fvapps_001384.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Point := Int \u00d7 Int"
      },
      {
        "type": "sig",
        "string": "def Rectangle := List Point\n\ndef calculate_rectangle_characteristics (points : Rectangle) : Float \u00d7 Float \u00d7 Float \u00d7 Float \u00d7 Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def length (points : Rectangle) : Float :="
      },
      {
        "type": "impl",
        "string": "  let (l, _, _, _, _) := calculate_rectangle_characteristics points\n  l"
      },
      {
        "type": "sig",
        "string": "def width (points : Rectangle) : Float :="
      },
      {
        "type": "impl",
        "string": "  let (_, w, _, _, _) := calculate_rectangle_characteristics points\n  w"
      },
      {
        "type": "sig",
        "string": "def area (points : Rectangle) : Float :="
      },
      {
        "type": "impl",
        "string": "  let (_, _, a, _, _) := calculate_rectangle_characteristics points\n  a"
      },
      {
        "type": "sig",
        "string": "def perimeter (points : Rectangle) : Float :="
      },
      {
        "type": "impl",
        "string": "  let (_, _, _, p, _) := calculate_rectangle_characteristics points\n  p"
      },
      {
        "type": "sig",
        "string": "def diagonal (points : Rectangle) : Float :="
      },
      {
        "type": "impl",
        "string": "  let (_, _, _, _, d) := calculate_rectangle_characteristics points\n  d"
      },
      {
        "type": "cond",
        "string": "theorem length_positive (points : Rectangle) :\n  length points > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem width_positive (points : Rectangle) :\n  width points > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem area_is_length_times_width (points : Rectangle) :\n  area points = length points * width points :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perimeter_formula (points : Rectangle) :\n  perimeter points = 2 * (length points + width points) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem diagonal_formula (points : Rectangle) :\n  diagonal points = Float.sqrt (length points * length points + width points * width points) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem diagonal_larger_than_sides (points : Rectangle) :\n  diagonal points > length points \u2227 diagonal points > width points :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem measurements_match_points (points : Rectangle) (h : points.length = 4) :\n  \u2203 x1 x2 y1 y2 : Int,\n    (x2 > x1 \u2227 y2 > y1) \u2227\n    points = [(x1, y1), (x1, y2), (x2, y1), (x2, y2)] \u2227\n    length points = Float.ofInt (x2 - x1) \u2227\n    width points = Float.ofInt (y2 - y1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001385.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_troops_to_ruin (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_troops_bounds (s: String) :\n  let result := find_min_troops_to_ruin s\n  0 \u2264 result \u2227 result \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_troops (s: String) :\n  s = \"\" \u2192 find_min_troops_to_ruin s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_troops (s: String) :\n  s \u2260 \"\" \u2227 isPalindrome s \u2192 find_min_troops_to_ruin s = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_palindrome_troops (s: String) :\n  s \u2260 \"\" \u2227 \u00acisPalindrome s \u2192 find_min_troops_to_ruin s = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abbabaab\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"abba\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_troops_to_ruin \"ab\""
      }
    ]
  },
  "fvapps_001402.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longest_contiguous_subsequence (N Q K : Nat) (A : List Nat) (S : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_max_consecutive_ones (A : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_length_matches_question_marks {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : \u2200 x \u2208 A, x \u2264 1) :\n  (longest_contiguous_subsequence N Q K A S).length =\n    (S.data.filter (. = '?')).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem results_bounded_by_k {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : \u2200 x \u2208 A, x \u2264 1) :\n  \u2200 x \u2208 (longest_contiguous_subsequence N Q K A S), x \u2264 K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem results_non_negative {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : \u2200 x \u2208 A, x \u2264 1) :\n  \u2200 x \u2208 (longest_contiguous_subsequence N Q K A S), x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_array_gives_zero_result {N Q K : Nat} {A : List Nat} {S : String}\n  (h1 : N > 0) (h2 : Q > 0) (h3 : K > 0)\n  (h4 : \u2200 x \u2208 A, x = 0) :\n  \u2200 x \u2208 (longest_contiguous_subsequence N Q K A S), x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_question_mark_result {N K : Nat} {A : List Nat}\n  (h1 : N > 0) (h2 : K > 0)\n  (h3 : \u2200 x \u2208 A, x \u2264 1)\n  (h4 : (longest_contiguous_subsequence N 1 K A \"?\").length > 0) :\n  (longest_contiguous_subsequence N 1 K A \"?\")[0]! = min (count_max_consecutive_ones A) K :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 3, 3]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 5 5 3 [1, 1, 0, 1, 1] \"?!?!?\"\n\n/-\ninfo: [1, 1, 1]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 3 3 2 [1, 0, 1] \"???\"\n\n/-\ninfo: [4, 4]\n-/\n#guard_msgs in\n#eval longest_contiguous_subsequence 4 2 4 [1, 1, 1, 1] \"??\""
      }
    ]
  },
  "fvapps_001413.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isLeapYear (year : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDate (year month day : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countCorrectPills (dateStr : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_date_count (year month day : Int) :\n  1 \u2264 year \u2227 year \u2264 9999 \u2192\n  1 \u2264 month \u2227 month \u2264 12 \u2192\n  1 \u2264 day \u2227 day \u2264 31 \u2192\n  isValidDate year month day \u2192\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem leap_year_feb29_count (year : Int) :\n  1 \u2264 year \u2227 year \u2264 9999 \u2192\n  isLeapYear year \u2192\n  let result := countCorrectPills s!\"{year}:02:29\"\n  result \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem thirty_day_months_count (year month day : Int) :\n  1 \u2264 year \u2227 year \u2264 9999 \u2192\n  (month = 4 \u2228 month = 6 \u2228 month = 9 \u2228 month = 11) \u2192\n  1 \u2264 day \u2227 day \u2264 30 \u2192\n  isValidDate year month day \u2192\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem thirtyone_day_months_count (year month day : Int) :\n  1 \u2264 year \u2227 year \u2264 9999 \u2192\n  (month = 1 \u2228 month = 3 \u2228 month = 5 \u2228 month = 7 \u2228 month = 8 \u2228 month = 10 \u2228 month = 12) \u2192\n  1 \u2264 day \u2227 day \u2264 31 \u2192\n  isValidDate year month day \u2192\n  let result := countCorrectPills s!\"{year}:{month}:{day}\"\n  result \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2019:03:31\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2020:02:28\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_correct_pills \"2000:12:31\""
      }
    ]
  },
  "fvapps_001417.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Nat.toHexString (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.trimLeftZeros (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hexToDecimal (l: List String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hex_to_decimal_length (l: List String) :\n  l.length = (hexToDecimal l).length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hex_to_decimal_non_negative (l: List String) (i: Nat) (h: i < (hexToDecimal l).length) :\n  (hexToDecimal l).get \u27e8i, h\u27e9 \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hex_to_decimal_roundtrip (l: List String) :\n  let converted := hexToDecimal l\n  let back_to_hex := converted.map Nat.toHexString\n  let normalized := l.map String.trimLeftZeros\n  back_to_hex = normalized := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hex_to_decimal_increasing (l: List String) (i: Nat) (h\u2081: i < l.length) (h\u2082: i < (hexToDecimal l).length) :\n  let num := l.get \u27e8i, h\u2081\u27e9\n  num.length > 1 \u2192\n  (hexToDecimal l).get \u27e8i, h\u2082\u27e9 > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [10]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\"]\n\n/-\ninfo: [6691]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"1A23\"]\n\n/-\ninfo: [10, 6691, 11306]\n-/\n#guard_msgs in\n#eval hex_to_decimal [\"A\", \"1A23\", \"2C2A\"]"
      }
    ]
  },
  "fvapps_001419.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_robots_meeting (n m k1 k2 : Nat) (grid : Array (Array Nat)) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Any valid result should be either -1 or non-negative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_valid_range {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 \u2228 result \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Trivial 1x1 grid case should return 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem trivial_case :\n  let grid := #[#[0]]\n  solve_robots_meeting 1 1 1 1 grid = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Any valid result should not exceed grid dimensions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_bounds {n m k1 k2 : Nat} {grid : Array (Array Nat)} :\n  let result := solve_robots_meeting n m k1 k2 grid\n  result = -1 \u2228 result \u2264 n * m := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_robots_meeting 4 4 1 1 #[[0, 1, 1, 0], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]"
      }
    ]
  },
  "fvapps_001422.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countDigit (n : Nat) (d : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_digit_frequency (nums : List Nat) (target : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_digit_freq_in_list (nums : List Nat) (target : Nat)\n  (h : nums \u2260 []) :\n  find_max_digit_frequency nums target \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_digit_freq_is_max (nums : List Nat) (target : Nat)\n  (h : nums \u2260 []) :\n  \u2200 n \u2208 nums, countDigit (find_max_digit_frequency nums target) target \u2265\n              countDigit n target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_target_returns_first (nums : List Nat) (target : Nat)\n  (h : nums \u2260 [])\n  (h2 : \u2200 n \u2208 nums, countDigit n target = 0) :\n  find_max_digit_frequency nums target = nums.head! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_freq_returns_first (nums : List Nat) (target : Nat)\n  (h : nums \u2260 []) (n : Nat) (hn : n \u2208 nums) :\n  countDigit n target = countDigit (find_max_digit_frequency nums target) target \u2192\n  n = find_max_digit_frequency nums target \u2228\n  nums.findIdx (. = n) > nums.findIdx (. = find_max_digit_frequency nums target) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '1323'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"345\", \"1323\", \"165\", \"98\", \"456\"] \"3\"\n\n/-\ninfo: '335'\n-/\n#guard_msgs in\n#eval find_max_digit_frequency [\"335\", \"876\", \"98\", \"1323\", \"349\"] \"3\""
      }
    ]
  },
  "fvapps_001423.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_anagram_positions (haystack : String) (needle : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function that converts a string to a sorted char array for anagram comparison -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def stringToSortedArray (s : String) : Array Char :="
      },
      {
        "type": "impl",
        "string": "  (s.data.toArray).qsort (\u00b7 \u2264 \u00b7)"
      },
      {
        "type": "cond",
        "string": "theorem output_format {s : String} :\n  let result := find_anagram_positions s \"test\"\n  result.startsWith \"The antidote is found in\" \u2227\n  result.endsWith \".\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_word_not_counted {word : String} :\n  word \u2260 \"\" \u2192\n  find_anagram_positions word word = \"The antidote is found in .\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001424.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_anagrams (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def manual_count_anagrams (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_anagrams_positive (s : String) (h : s.length > 0) :\n  count_anagrams s \u2265 0 \u2227 count_anagrams s < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_anagrams_letter_order_invariant (s : String) (h : s.length > 0) :\n  count_anagrams s = count_anagrams s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"ab\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_anagrams \"aa\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_anagrams \"aA\"\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval count_anagrams \"AAbaz\""
      }
    ]
  },
  "fvapps_001429.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_ops_for_self_destruct (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- If the input string length is odd, min_ops_for_self_destruct returns -1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem odd_length_returns_negative (s : String) :\n  String.length s % 2 = 1 \u2192 min_ops_for_self_destruct s = -1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- If the input string contains only 0s or only 1s, min_ops_for_self_destruct returns -1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem all_ones_or_zeroes_returns_negative (s : String) :\n  (\u2200c \u2208 s.data, c = '0') \u2228 (\u2200c \u2208 s.data, c = '1') \u2192\n  min_ops_for_self_destruct s = -1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- If min_ops_for_self_destruct returns a non-negative result, it is bounded by half the string length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_bounds (s : String) :\n  min_ops_for_self_destruct s \u2260 -1 \u2192\n  0 \u2264 min_ops_for_self_destruct s \u2227 min_ops_for_self_destruct s \u2264 String.length s / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- For balanced strings with equal counts of 0s and 1s and even length, min_ops_for_self_destruct returns 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem balanced_strings_need_zero_ops (s : String) :\n  String.length s % 2 = 0 \u2192\n  (s.data.filter (\u00b7 = '0')).length = (s.data.filter (\u00b7 = '1')).length \u2192\n  min_ops_for_self_destruct s = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- The result equals half the absolute difference between counts of 0s and 1s when not -1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem operations_count (s : String) :\n  min_ops_for_self_destruct s \u2260 -1 \u2192\n  min_ops_for_self_destruct s =\n    (Int.natAbs ((s.data.filter (\u00b7 = '0')).length - (s.data.filter (\u00b7 = '1')).length)) / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"001101\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"1101\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_ops_for_self_destruct \"110\""
      }
    ]
  },
  "fvapps_001433.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def PizzaGrid := List String"
      },
      {
        "type": "sig",
        "string": "def valid_grid (n : Nat) (grid : PizzaGrid) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_pizza_balance (n : Nat) (grid : PizzaGrid) : Nat := sorry\n\ndef count_ones (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.countP (\u00b7 = '1')"
      },
      {
        "type": "sig",
        "string": "def left_side (n : Nat) (row : String) : String :="
      },
      {
        "type": "impl",
        "string": "  row.take (n/2)"
      },
      {
        "type": "sig",
        "string": "def right_side (n : Nat) (row : String) : String :="
      },
      {
        "type": "impl",
        "string": "  row.drop (n/2)"
      },
      {
        "type": "cond",
        "string": "theorem valid_output {n : Nat} {grid : PizzaGrid}\n  (h : valid_grid n grid = true) :\n  \u2203 result : Nat, solve_pizza_balance n grid = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_grid {n : Nat} {grid : PizzaGrid}\n  (h1 : valid_grid n grid = true)\n  (h2 : n % 2 = 0)\n  (h3 : (List.foldl (\u03bb acc row => acc + count_ones (left_side n row)) 0 grid) =\n        (List.foldl (\u03bb acc row => acc + count_ones (right_side n row)) 0 grid)) :\n  solve_pizza_balance n grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_difference {n : Nat} {grid : PizzaGrid}\n  (h1 : valid_grid n grid = true)\n  (h2 : n % 2 = 0) :\n  solve_pizza_balance n grid \u2264\n    (List.foldl\n      (\u03bb acc row =>\n        let l := count_ones (left_side n row)\n        let r := count_ones (right_side n row)\n        acc + if l \u2265 r then l - r else r - l)\n      0 grid) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_pizza_balance 6 [\"100000\", \"100000\", \"100000\", \"100000\", \"010010\", \"001100\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_pizza_balance 4 [\"0011\", \"1100\", \"1110\", \"0001\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_pizza_balance 2 [\"10\", \"01\"]"
      }
    ]
  },
  "fvapps_001437.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maximizeStockPrice (n k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximize_stock_price_properties (n k : Nat) (h1 : n \u2264 999999) (h2 : k \u2264 10) :\n  let result := maximizeStockPrice n k;\n  -- Result should be greater than or equal to input\n  result \u2265 n\n  -- Result should have same number of digits as input\n  \u2227 numDigits result = numDigits n\n  -- Result changes should not exceed k\n  \u2227 \u2203 changes, changes \u2264 k\n  -- k=0 means unchanged\n  \u2227 (k = 0 \u2192 result = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximize_stock_price_saturated (n k : Nat) (h1 : k \u2265 numDigits n) :\n  let result := maximizeStockPrice n k;\n  -- With enough k, all digits become 9\n  result = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximize_stock_price_edge_cases :\n  maximizeStockPrice 0 0 = 0\n  \u2227 maximizeStockPrice 1 1 = 9\n  \u2227 maximizeStockPrice 9 1 = 9\n  \u2227 maximizeStockPrice 99 1 = 99 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 9983\n-/\n#guard_msgs in\n#eval maximize_stock_price 4483 2\n\n/-\ninfo: 9234\n-/\n#guard_msgs in\n#eval maximize_stock_price 1234 1\n\n/-\ninfo: 9999\n-/\n#guard_msgs in\n#eval maximize_stock_price 9999 4"
      }
    ]
  },
  "fvapps_001440.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_bad_luck (strings : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_bad_luck_non_negative (strings : List String) :\n  find_min_bad_luck strings \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_bad_luck_leq_min_len (strings : List String) :\n  strings \u2260 [] \u2192 find_min_bad_luck strings \u2264 List.foldr (fun s acc => min s.length acc) (strings[0]!.length) strings.tail :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"ab\", \"ba\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aa\", \"bb\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_bad_luck [\"aabb\", \"abab\", \"baab\"]"
      }
    ]
  },
  "fvapps_001443.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_path_number : String \u2192 Nat\n  | s => sorry"
      },
      {
        "type": "sig",
        "string": "def MOD : Nat := 1000000007\n\ndef mkString (c : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_positive (s : String) :\n  find_path_number s > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_within_bounds (s : String) :\n  find_path_number s < MOD := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_empty :\n  find_path_number \"\" = 1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_single_char :\n  find_path_number \"l\" = 2 \u2227 find_path_number \"r\" = 4 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_concat_bounds (s : String) :\n  find_path_number (s ++ s) < MOD := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_lr_distinct (n : Nat) (h : n > 0) (h2 : n \u2264 100) :\n  find_path_number (mkString \"l\" n) \u2260\n  find_path_number (mkString \"r\" n) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_modulo (s : String) :\n  find_path_number s = find_path_number s % MOD := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_number_concat_distinct (s1 s2 : String)\n  (h1 : s1 \u2260 \"\") (h2 : s2 \u2260 \"\") :\n  find_path_number (s1 ++ s2) \u2260 find_path_number s1 \u2227\n  find_path_number (s1 ++ s2) \u2260 find_path_number s2 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval find_path_number \"lrl\"\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval find_path_number \"rll\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_path_number \"r\""
      }
    ]
  },
  "fvapps_001450.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_yalalovichik_substrings (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def longest_run (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_always_nonnegative (s: String) (h: s.length > 0):\n  count_yalalovichik_substrings s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_count (c: Char):\n  count_yalalovichik_substrings (String.singleton c) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_single_char (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"a\")\n  count_yalalovichik_substrings s = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alternating_chars (n: Nat) (h: n > 0):\n  let s := String.join (List.replicate n \"ab\")\n  count_yalalovichik_substrings s = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"xxx\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aa\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_yalalovichik_substrings \"aaa\""
      }
    ]
  },
  "fvapps_001451.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_valid_bracket_sequence (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def analyze_brackets (n : Nat) (brackets : List Nat) : Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_valid_case :\n  analyze_brackets 2 [1,2] = (1,1,2,1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nested_depth_increases :\n  (analyze_brackets 4 [1,1,2,2]).1 = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (2, 4, 6, 9)\n-/\n#guard_msgs in\n#eval analyze_brackets 20 [1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2]\n\n/-\ninfo: (1, 1, 2, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 2 [1, 2]\n\n/-\ninfo: (2, 2, 6, 1)\n-/\n#guard_msgs in\n#eval analyze_brackets 8 [1, 1, 2, 1, 2, 2, 1, 2]"
      }
    ]
  },
  "fvapps_001452.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.replicate (n : Nat) (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper for String operations -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def List.modifyNth {\u03b1 : Type} (idx : Nat) (f : \u03b1 \u2192 \u03b1) (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def process_matrix_queries (n m : Nat) (matrix : List String) (queries : List (List Nat)) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def make_zero_matrix (n m : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  List.replicate n (String.mk (List.replicate m '0'))"
      },
      {
        "type": "sig",
        "string": "def make_one_matrix (n m : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  List.replicate n (String.mk (List.replicate m '1'))"
      },
      {
        "type": "cond",
        "string": "theorem empty_queries_preserves_matrix (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n \u2264 10) (h4 : m \u2264 10)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [] = matrix :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_query_sets_one (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n \u2264 5) (h4 : m \u2264 5)\n    (h5 : matrix = make_zero_matrix n m)\n    (i j : Nat) (h6 : i \u2264 n) (h7 : j \u2264 m) :\n    process_matrix_queries n m matrix [[i, j, i, j]] =\n    List.modifyNth (i - 1)\n      (fun s => s.take (j - 1) ++ \"1\" ++ s.drop j)\n      matrix :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem full_matrix_query_sets_all_ones (n m : Nat) (matrix : List String)\n    (h1 : n > 0) (h2 : m > 0) (h3 : n \u2264 5) (h4 : m \u2264 5)\n    (h5 : matrix = make_zero_matrix n m) :\n    process_matrix_queries n m matrix [[1, 1, n, m]] =\n    make_one_matrix n m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001456.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_magnet_attract (n k : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.atN (s : String) (n : Nat) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_magnet_blocked_by_x {n k : Nat} {s : String} :\n  (\u2200 i j, 0 \u2264 i \u2192 i < n \u2192 0 \u2264 j \u2192 j < n \u2192\n    s.atN i = 'M' \u2192 s.atN j = 'I' \u2192\n    \u2203 x, min i j \u2264 x \u2227 x \u2264 max i j \u2227 s.atN x = 'X') \u2192\n  max_magnet_attract n k s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countAdjacentPairs (n : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_magnet_distance_zero {n : Nat} {s : String} :\n  max_magnet_attract n 0 s \u2264 countAdjacentPairs n s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_magnet_output_nonNeg {n k : Nat} {s : String} :\n  max_magnet_attract n k s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_magnet_output_bounded {n k : Nat} {s : String} :\n  max_magnet_attract n k s \u2264 min (countChar s 'M') (countChar s 'I') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_magnet_attract 4 5 \"I::M\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 9 10 \"MIM_XII:M\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_magnet_attract 5 3 \"MI:IM\""
      }
    ]
  },
  "fvapps_001458.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_max_profit_path (n : Nat) (edges : List (Nat \u00d7 Nat \u00d7 Int)) (queries : List (Nat \u00d7 Nat)) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isConnectedTree (edges : List (Nat \u00d7 Nat \u00d7 Int)) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidPath (edges : List (Nat \u00d7 Nat \u00d7 Int)) (start finish : Nat) (path : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem singleton_tree_zero (u v : Nat)\n  (h : u = 1 \u2227 v = 1) :\n  solve_max_profit_path 1 [] [(u, v)] = [0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_graph_max_profit (edges : List (Nat \u00d7 Nat \u00d7 Int))\n  (h_edges : edges = [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) :\n  solve_max_profit_path 4 edges [(1, 4)] = [3] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001469.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_zombie_cars (n k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD : Nat := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem solve_zombie_cars_output_range (n k : Nat) :\n  n \u2265 1 \u2192 k \u2265 1 \u2192 solve_zombie_cars n k < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_zombie_cars_k_one (n k : Nat) :\n  n \u2265 1 \u2192 k = 1 \u2192 solve_zombie_cars n k = if n = 1 then 1 else 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_zombie_cars_formula (n k : Nat) :\n  n \u2265 1 \u2192 k \u2265 1 \u2192\n  solve_zombie_cars n k = (k * (k-1)^(n-1)) % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_zombie_cars_known_values :\n  solve_zombie_cars 2 2 = 2 \u2227\n  solve_zombie_cars 3 3 = 12 \u2227\n  solve_zombie_cars 4 3 = 24 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001476.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_parrot_hunt (n : Nat) (init_parrots : List Nat) (num_shots : Nat) (shots : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_shot (n : Nat) (shot : Nat \u00d7 Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  1 \u2264 shot.1 \u2227 shot.1 \u2264 n \u2227 shot.2 \u2265 1"
      },
      {
        "type": "cond",
        "string": "theorem solve_parrot_hunt_no_shots_preserves_input\n  (n : Nat) (init_parrots : List Nat) (h : init_parrots.length = n) :\n  solve_parrot_hunt n init_parrots 0 [] = init_parrots :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001477.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef calculate_offense_ways (n : Nat) (numbers : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def natLeBool (a b : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  if a \u2264 b then true else false"
      },
      {
        "type": "cond",
        "string": "theorem result_range {n : Nat} {numbers : List Nat} :\n  let result := calculate_offense_ways n numbers\n  0 \u2264 result \u2227 result < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_number {x : Nat} :\n  x > 0 \u2192\n  calculate_offense_ways 1 [x] = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_combinations_zero :\n  calculate_offense_ways 2 [1, 1] = 0 \u2227\n  calculate_offense_ways 3 [2, 2, 2] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval calculate_offense_ways 1 [4]\n\n/-\ninfo: 45\n-/\n#guard_msgs in\n#eval calculate_offense_ways 2 [10, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_offense_ways 4 [2, 3, 1, 3]"
      }
    ]
  },
  "fvapps_001480.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidTree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findOptimalAttack (n : Nat) (edges : List (Nat \u00d7 Nat)) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def getAdjList (n : Nat) (edges : List (Nat \u00d7 Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def componentSize (adj : List (List Nat)) (start visited : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_optimal_attack_output_bounds {n : Nat} {edges : List (Nat \u00d7 Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges\n  1 \u2264 attack_node \u2227 attack_node \u2264 n \u2227\n  1 \u2264 max_subgraph \u2227 max_subgraph \u2264 n-1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem breaking_point_subgraph_sizes {n : Nat} {edges : List (Nat \u00d7 Nat)}\n  (h_valid : isValidTree n edges = true) :\n  let (attack_node, max_subgraph) := findOptimalAttack n edges;\n  let adj := getAdjList n edges;\n  \u2200 node neighbors, neighbors = (adj.get? (attack_node-1)).getD [] \u2192\n  node \u2208 neighbors \u2192\n  componentSize adj [node] [attack_node] \u2264 max_subgraph :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001482.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD : Nat := 10^9 + 7\n\ndef solve_prime_sum (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Output is always within valid mod range -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_prime_sum_output_range (n: Nat) :\n  solve_prime_sum n < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- Function is deterministic for same input -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_prime_sum_deterministic (n: Nat) :\n  solve_prime_sum n = solve_prime_sum n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- First values are monotonically increasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_prime_sum_monotone_init :\n  solve_prime_sum 1 < solve_prime_sum 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_prime_sum 1\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_prime_sum 2\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval solve_prime_sum 3"
      }
    ]
  },
  "fvapps_001483.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def lcm (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_gcd_lcm_pairs (pairs : List (Nat \u00d7 Nat)) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_divides {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let g := gcd x y\n  x % g = 0 \u2227 y % g = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_dividedby {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  let l := lcm x y\n  l % x = 0 \u2227 l % y = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_lcm_product {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y * lcm x y = x * y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_upper_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  gcd x y \u2264 min x y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_lower_bound {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  lcm x y \u2265 max x y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_number_gcd_lcm {n : Nat} (h : n > 0) :\n  gcd n n = n \u2227 lcm n n = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_gcd_lcm_pairs_preserves_length {pairs : List (Nat \u00d7 Nat)} :\n  pairs.length = (find_gcd_lcm_pairs pairs).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001484.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_jewels (jewels stones : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_jewels_properties_non_negative (jewels stones : String) :\n  count_jewels jewels stones \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_jewels_bounded_by_stones (jewels stones : String) :\n  count_jewels jewels stones \u2264 stones.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_jewels_empty_jewels (stones : String) :\n  count_jewels \"\" stones = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_jewels_empty_stones (jewels : String) :\n  count_jewels jewels \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_jewels_duplicates (jewels stones : String) :\n  count_jewels (jewels ++ jewels) stones = count_jewels jewels stones :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_jewels \"abc\" \"abcdef\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_jewels \"aA\" \"abAZ\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_jewels \"what\" \"none\""
      }
    ]
  },
  "fvapps_001488.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_atoms (input : List (Nat \u00d7 Nat) \u00d7 List Nat) : List Nat := sorry\n\nvariable (n : Nat)\n\ndef empty_case (n : Nat) : List (Nat \u00d7 Nat) \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "  ([(n, 1)], [0])"
      },
      {
        "type": "sig",
        "string": "def all_case (n : Nat) : List (Nat \u00d7 Nat) \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "  ([(n, 1)], n :: List.range n)"
      },
      {
        "type": "cond",
        "string": "theorem solve_atoms_empty_groups (h : n > 0) :\n  solve_atoms (empty_case n) = List.replicate n 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_atoms_all_groups (h : n > 0) :\n  solve_atoms (all_case n) = List.replicate n 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [3]\n-/\n#guard_msgs in\n#eval solve_atoms [case1]\n\n/-\ninfo: [4]\n-/\n#guard_msgs in\n#eval solve_atoms [case2]\n\n/-\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval solve_atoms [case1, case2]"
      }
    ]
  },
  "fvapps_001495.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_sequence (a b n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitXor (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitNot (a : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitLength (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_nonnegative (a b n : Nat) :\n  n > 0 \u2192 n \u2264 3 \u2192 solve_sequence a b n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_first (a b : Nat) :\n  solve_sequence a b 1 = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_second (a b : Nat) :\n  solve_sequence a b 2 = b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_symmetric (a b : Nat) :\n  solve_sequence a b 3 = solve_sequence b a 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_sequence 3 4 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval solve_sequence 10 12 2"
      }
    ]
  },
  "fvapps_001500.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_series (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem solve_series_increases (n : Nat) (h : n > 0) (h2 : n \u2264 100) :\n  solve_series (n+1) > solve_series n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_series_one :\n  solve_series 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_series_large_bound (n : Nat) (h : n = 1000000) :\n  solve_series n < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 561\n-/\n#guard_msgs in\n#eval solve_series 8\n\n/-\ninfo: 1081\n-/\n#guard_msgs in\n#eval solve_series 10\n\n/-\ninfo: 31\n-/\n#guard_msgs in\n#eval solve_series 3"
      }
    ]
  },
  "fvapps_001502.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_transform_string (s r : String) : String := sorry\n\ndef count_ones (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter (\u00b7 = '1') |>.length"
      },
      {
        "type": "sig",
        "string": "def extract (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk (s.data.take n)"
      },
      {
        "type": "sig",
        "string": "def create_string (c : Char) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk (List.replicate n c)"
      },
      {
        "type": "sig",
        "string": "def min_extract (s r : String) : String \u00d7 String :="
      },
      {
        "type": "impl",
        "string": "  let n := min s.length r.length\n  (extract s n, extract r n)"
      },
      {
        "type": "cond",
        "string": "theorem transform_result_valid {s r : String} :\n  let (s', r') := min_extract s r\n  can_transform_string s' r' = \"YES\" \u2228 can_transform_string s' r' = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_based_on_ones_count {s r : String} :\n  let (s', r') := min_extract s r\n  (count_ones s' = count_ones r' \u2192 can_transform_string s' r' = \"YES\") \u2227\n  (count_ones s' \u2260 count_ones r' \u2192 can_transform_string s' r' = \"NO\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identity_transformation (s : String) :\n  can_transform_string s s = \"YES\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_transform {s : String} (h : s.length > 0) :\n  let zeros := create_string '0' s.length\n  can_transform_string zeros s = if s = zeros then \"YES\" else \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_transform {s : String} (h : s.length > 0) :\n  let ones := create_string '1' s.length\n  can_transform_string ones s = if s = ones then \"YES\" else \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_transform_string \"11000\" \"01001\"\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval can_transform_string \"110\" \"001\"\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval can_transform_string \"1100\" \"0011\""
      }
    ]
  },
  "fvapps_001503.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n m : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def cell_advance_hero1 (row col n m k : Nat) : (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def cell_advance_hero2 (row col n m k : Nat) : (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_destroyed_cells (advance : Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 (Nat \u00d7 Nat)) (n m k : Nat) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_range {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.length result = n * m \u2227\n  \u2200 x, x \u2208 result \u2192 1 \u2264 x \u2227 x \u2264 n * m * 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_first_last {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := solve n m;\n  List.head! result \u2265 List.getLast! result \u2227\n  List.getLast! result \u2265 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem cell_advance_hero1_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero1 row col n m k;\n  1 \u2264 result.2 \u2227 result.2 \u2264 m := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem cell_advance_hero2_bounds {row col n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let result := cell_advance_hero2 row col n m k;\n  1 \u2264 result.1 \u2227 result.1 \u2264 n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem destroyed_cells_bounds {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (\u2200 p \u2208 cells1, 1 \u2264 p.1 \u2227 p.1 \u2264 n \u2227 1 \u2264 p.2 \u2227 p.2 \u2264 m) \u2227\n  (\u2200 p \u2208 cells2, 1 \u2264 p.1 \u2227 p.1 \u2264 n \u2227 1 \u2264 p.2 \u2227 p.2 \u2264 m) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem destroyed_cells_start {n m k : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let cells1 := find_destroyed_cells cell_advance_hero1 n m k;\n  let cells2 := find_destroyed_cells cell_advance_hero2 n m k;\n  (1, 1) \u2208 cells1 \u2227 (1, 1) \u2208 cells2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001504.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef calculate_possible_schedules (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pow (base n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_possible_schedules_mod_bounds (n : Nat) :\n  0 \u2264 calculate_possible_schedules n \u2227 calculate_possible_schedules n < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_possible_schedules_odd_even_match (n : Nat) :\n  calculate_possible_schedules n =\n    if n % 2 = 0\n    then ((pow 3 n) + 3) % MOD\n    else ((pow 3 n) - 3) % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 2\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 3\n\n/-\ninfo: 240\n-/\n#guard_msgs in\n#eval calculate_possible_schedules 5"
      }
    ]
  },
  "fvapps_001507.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_m (n : Nat) (nums : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasAllOnes (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasPowerOfTwo (n : Int) (pos : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_returns_negative_one (nums : List Nat) :\n  (\u2203 n \u2208 nums, hasAllOnes n = true) \u2192\n  find_min_m 1 nums = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_nonnegative_when_valid (nums : List Nat) :\n  (\u00ac\u2203 n \u2208 nums, hasAllOnes n = true) \u2192\n  find_min_m 1 nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_power_of_two_sum (nums : List Nat) (i : Nat) :\n  let result := find_min_m 1 nums\n  result \u2260 -1 \u2192\n  hasPowerOfTwo result i = true \u2192\n  \u2203 k, result = 2^k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_m 1 [5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_min_m 1 [7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_min_m 1 [10]"
      }
    ]
  },
  "fvapps_001513.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isSubstring (sub : String) (orig : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasAllChars (sub : String) (orig : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def substr (s : String) (i j : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def findSubString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sub_string_is_substring\n  (s : String) (h : s.length > 0) :\n  isSubstring (findSubString s) s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sub_string_has_all_chars\n  (s : String) (h : s.length > 0) :\n  hasAllChars (findSubString s) s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_sub_string_is_minimal\n  (s : String) (h : s.length > 0)\n  (i j : Nat) (h1 : i < s.length) (h2 : j \u2264 s.length) (h3 : i < j) :\n  let sub := substr s i j\n  let result := findSubString s\n  sub.length < result.length \u2192 \u00ac(hasAllChars sub s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001534.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def modInv (a n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_factorial_spell (input : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_factorial_spell_output_length\n  (input : List Nat)\n  : List.length (solve_factorial_spell input) = List.length input :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_factorial_spell_modulo_bounds\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length (solve_factorial_spell input))\n  : (List.get! (solve_factorial_spell input) i) < 1589540031 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_factorial_spell_zero_case\n  (input : List Nat)\n  (i : Nat)\n  (h : i < List.length input)\n  (h2 : List.get! input i = 0)\n  : List.get! (solve_factorial_spell input) i = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_factorial_spell_consecutive_ratio\n  (input : List Nat)\n  (i : Nat)\n  (h1 : i + 1 < List.length input)\n  (h2 : List.get! input (i + 1) = List.get! input i + 1)\n  (h3 : List.get! input i > 0)\n  : (List.get! (solve_factorial_spell input) (i + 1) *\n     (modInv (List.get! (solve_factorial_spell input) i) 1589540031)) % 1589540031 =\n    List.get! input (i + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_factorial_spell_input_bound\n  (input : List Nat)\n  (h : \u2203 i, i < List.length input \u2227 List.get! input i > 100000)\n  : solve_factorial_spell input = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_factorial_spell [1, 2, 3, 4]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_factorial_spell [5]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_factorial_spell [6, 7]"
      }
    ]
  },
  "fvapps_001538.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def valid_filter_pattern : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def valid_photo_pattern : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def process_chefgram_filters : String \u2192 List String \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem size_threshold_consistency\n  (n : Nat)\n  (h1 : n \u2208 [1000, 1024, 1048]) :\n  let photo := String.mk (List.replicate 10 'w')\n  let filter := \"+-+-+-+-+-\"\n  let filters := List.replicate n filter\n  let result := process_chefgram_filters photo filters\n  0 \u2264 result \u2227 result < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wwwwwwwwww\" [\"+-+-+-+-+-\", \"----------\", \"+---------\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"wbwbwbwbwb\" [\"+-+-+-+-+-\", \"+-+-------\", \"----+-+-+-\"]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval process_chefgram_filters \"bbbbbbbbbb\" [\"----------\", \"----------\"]"
      }
    ]
  },
  "fvapps_001550.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix (\u03b1 : Type u) (n : Nat) := Array (Array \u03b1)"
      },
      {
        "type": "sig",
        "string": "def standardDeterminant {n : Nat} (M : Matrix Int n) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def identityMatrix (n : Nat) : Matrix Int n :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def zeroMatrix (n : Nat) : Matrix Int n :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def scaleMatrix {n : Nat} (c : Int) (M : Matrix Int n) : Matrix Int n :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def determinant {n : Nat} (M : Matrix Int n) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem determinant_matches_standard_implementation {n : Nat} (M : Matrix Int n) :\n  determinant M = standardDeterminant M :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem determinant_identity {n : Nat} :\n  determinant (identityMatrix n) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem determinant_zero {n : Nat} :\n  determinant (zeroMatrix n) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem determinant_scaling {n : Nat} (M : Matrix Int n) (c : Int) :\n  determinant (scaleMatrix c M) = c^n * determinant M :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval determinant #[[5]]\n\n/-\ninfo: -2\n-/\n#guard_msgs in\n#eval determinant #[[1, 2], [3, 4]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval determinant #[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
      }
    ]
  },
  "fvapps_001554.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def primeFactors (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_spec_prod_part (n : Nat) (mode : String) : String \u2295 (List Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_find_spec_prod_part (n : Nat) (h : n \u2265 2) :\n  is_prime n = true \u2192\n  find_spec_prod_part n \"max\" = Sum.inl \"It is a prime number\" \u2227\n  find_spec_prod_part n \"min\" = Sum.inl \"It is a prime number\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem partition_product_equals_input (n : Nat) (h1 : n \u2265 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (max_parts, _), Sum.inr (min_parts, _) =>\n    (max_parts.foldl Nat.mul 1 = n) \u2227\n    (min_parts.foldl Nat.mul 1 = n)\n  | _, _ => False\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_max_relationship (n : Nat) (h1 : n \u2265 4) (h2 : is_prime n = false) :\n  match find_spec_prod_part n \"max\", find_spec_prod_part n \"min\" with\n  | Sum.inr (_, max_score), Sum.inr (_, min_score) => max_score \u2265 min_score\n  | _, _ => False\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001556.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def who_is_winner (moves : List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def columnHeight (moves : List String) (col : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_result_states (moves : List String) :\n  let result := who_is_winner moves\n  result = \"Red\" \u2228 result = \"Yellow\" \u2228 result = \"Draw\" := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem column_height_bound (moves : List String) (col : String) :\n  columnHeight moves col \u2264 6 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"A_Red\", \"B_Yellow\", \"G_Red\", \"B_Yellow\"]\n\n/-\ninfo: 'Red'\n-/\n#guard_msgs in\n#eval who_is_winner [\"A_Yellow\", \"B_Red\", \"B_Yellow\", \"C_Red\", \"G_Yellow\", \"C_Red\", \"C_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"G_Yellow\", \"D_Red\", \"F_Yellow\", \"E_Red\", \"D_Yellow\"]\n\n/-\ninfo: 'Yellow'\n-/\n#guard_msgs in\n#eval who_is_winner [\"C_Yellow\", \"E_Red\", \"G_Yellow\", \"B_Red\", \"D_Yellow\", \"B_Red\", \"B_Yellow\", \"G_Red\", \"C_Yellow\", \"C_Red\", \"D_Yellow\", \"F_Red\", \"E_Yellow\", \"A_Red\", \"A_Yellow\", \"G_Red\", \"A_Yellow\", \"F_Red\", \"F_Yellow\", \"D_Red\", \"B_Yellow\", \"E_Red\", \"D_Yellow\", \"A_Red\", \"G_Yellow\", \"D_Red\", \"D_Yellow\", \"C_Red\"]"
      }
    ]
  },
  "fvapps_001558.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def parse_int (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def normalize_text (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def int_to_english (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Main theorems based on property tests"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem parse_int_inverse (n : Nat) (h : n \u2264 999) :\n  parse_int (int_to_english n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem parse_int_specific_example :\n  parse_int \"one hundred twenty three\" = 123 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval parse_int \"zero\"\n\n/-\ninfo: 123\n-/\n#guard_msgs in\n#eval parse_int \"one hundred twenty-three\"\n\n/-\ninfo: 200003\n-/\n#guard_msgs in\n#eval parse_int \"two hundred thousand three\""
      }
    ]
  },
  "fvapps_001561.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def decompose (n : Nat) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | (h::t) => h + list_sum t"
      },
      {
        "type": "sig",
        "string": "def list_sorted : List Nat \u2192 Bool\n  | [] => true\n  | [_] => true\n  | (a::b::rest) => a \u2264 b && list_sorted (b::rest)\n\ndef list_all (l : List Nat) (p : Nat \u2192 Bool) : Bool :="
      },
      {
        "type": "impl",
        "string": "  List.all l p"
      },
      {
        "type": "sig",
        "string": "def square (n : Nat) : Nat := n * n"
      },
      {
        "type": "cond",
        "string": "theorem decompose_valid (n : Nat) (result : List Nat) :\n  decompose n = some result \u2192\n  (list_sum (List.map square result) = n * n) \u2227\n  list_sorted result = true \u2227\n  list_all result (\u03bb x => x > 0) = true \u2227\n  list_all result (\u03bb x => x < n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decompose_2_impossible :\n  decompose 2 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decompose_3_impossible :\n  decompose 3 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 4, 10]\n-/\n#guard_msgs in\n#eval decompose 11\n\n/-\ninfo: [1, 3, 5, 8, 49]\n-/\n#guard_msgs in\n#eval decompose 50\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval decompose 4"
      }
    ]
  },
  "fvapps_001566.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse_num (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sq_cub_rev_prime (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_basic_cases :\n  \u00acis_prime 1 \u2227 is_prime 2 \u2227 \u00acis_prime 4 \u2227 is_prime 5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_nonpositive (n : Int) :\n  n \u2264 0 \u2192 \u00acis_prime n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_no_small_divisors {n : Int} (h1 : 2 \u2264 n) (h2 : n \u2264 1000) :\n  is_prime n \u2192 \u2200 i : Int, 2 \u2264 i \u2227 i * i \u2264 n \u2192 \u00ac(i \u2223 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sq_cub_rev_prime_properties (n : Int) (h : 1 \u2264 n \u2227 n \u2264 39) :\n  sq_cub_rev_prime n > 0 \u2227\n  sq_cub_rev_prime n = sq_cub_rev_prime n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 89\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 1\n\n/-\ninfo: 271\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 2\n\n/-\ninfo: 325\n-/\n#guard_msgs in\n#eval sq_cub_rev_prime 3"
      }
    ]
  },
  "fvapps_001567.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pawnMoveTracker (moves : List String) : List (List Char) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_moves_initial_position (moves : List String) :\n  moves = [] \u2192\n  let board := pawnMoveTracker moves\n  (board.length = 8 \u2227\n   (\u2200 row \u2208 board, row.length = 8) \u2227\n   (\u2200 i, i < 8 \u2192 (board.get! 1).get! i = 'p') \u2227\n   (\u2200 i, i < 8 \u2192 (board.get! 6).get! i = 'P')) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (l : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem valid_moves_invariants (moves : List String) :\n  let board := pawnMoveTracker moves\n  (board.length = 8 \u2227\n   (\u2200 row \u2208 board, row.length = 8) \u2227\n   let whitePawns := (board.foldl (fun acc row => acc + countChar 'P' row) 0)\n   let blackPawns := (board.foldl (fun acc row => acc + countChar 'p' row) 0)\n   0 \u2264 whitePawns \u2227 whitePawns \u2264 8 \u2227\n   0 \u2264 blackPawns \u2227 blackPawns \u2264 8) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_first_white_move (file : Char) (rank : Char) :\n  file \u2208 ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] \u2192\n  rank = '4' \u2192\n  let move := String.mk [file, rank]\n  let board := pawnMoveTracker [move]\n  ((board.get! 6).get! (file.toNat - 'a'.toNat) = '.' \u2227\n   (board.get! 4).get! (file.toNat - 'a'.toNat) = 'P') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_001568.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any natural number n, solve returns a single digit (0-9) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_single_digit (n : Nat) :\n  solve n \u2264 9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- solve is idempotent: calling it twice gives same result as once -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_idempotent (n : Nat) :\n  solve n = solve (solve n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- solve returns single digit for boundary values -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_boundaries_single_digit :\n  solve 1 \u2264 9 \u2227\n  solve (10^9) \u2264 9 \u2227\n  solve (10^18) \u2264 9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 100\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 55\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 123456\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 999999999999999999\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 1000000000000000000"
      }
    ]
  },
  "fvapps_001569.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def CHARS := ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n\ndef int_to_base_n (num : Nat) (base : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_polydivisible (s : String) (base : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_polydivisible {base : Nat} (h1 : base \u2265 2) (h2 : base \u2264 CHARS.length) :\n  \u2200 (digit : Char), digit \u2208 CHARS.take base \u2192 is_polydivisible digit.toString base :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_conversion_result_bool {base : Nat} (h1 : base \u2265 2) (h2 : base \u2264 CHARS.length)\n  (decimal_num : Nat) :\n  let base_n := int_to_base_n decimal_num base\n  \u2203 (b : Bool), is_polydivisible base_n base = b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_polydivisible {base : Nat} (h1 : base \u2265 2) (h2 : base \u2264 CHARS.length) :\n  is_polydivisible \"0\" base = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123\" 10\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_polydivisible \"1234\" 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_polydivisible \"123220\" 6"
      }
    ]
  },
  "fvapps_001574.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countOnes (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toBinary (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countBinaryOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countOnes_non_negative\n  (a b : Nat)\n  (h1 : 0 < a) (h2 : a \u2264 10^6)\n  (h3 : 0 < b) (h4 : b \u2264 10^6) :\n  0 \u2264 countOnes a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval countOnes 4 7\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval countOnes 5 5\n\n/-\ninfo: 14846928141\n-/\n#guard_msgs in\n#eval countOnes 1 1000000000"
      }
    ]
  },
  "fvapps_001575.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def to_chinese_numeral (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def DIGS : List String := [\"\u96f6\", \"\u4e00\", \"\u4e8c\", \"\u4e09\", \"\u56db\", \"\u4e94\", \"\u516d\", \"\u4e03\", \"\u516b\", \"\u4e5d\"]"
      },
      {
        "type": "sig",
        "string": "def POWS : List String := [\"\", \"\u5341\", \"\u767e\", \"\u5343\", \"\u4e07\"]"
      },
      {
        "type": "sig",
        "string": "def NEG : String := \"\u8d1f\""
      },
      {
        "type": "cond",
        "string": "theorem sign_property {n : Int} :\n  n < 0 \u2192 (to_chinese_numeral n).startsWith NEG \u2227\n  n \u2265 0 \u2192 \u00ac(to_chinese_numeral n).startsWith NEG :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem char_validation {n : Int} :\n  \u2200 c : Char, c \u2208 (to_chinese_numeral n).data \u2192\n    c \u2208 (NEG.data ++ (String.join DIGS).data ++ (String.join POWS).data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit {n : Int} (h1 : 1 \u2264 n) (h2 : n \u2264 9) :\n  to_chinese_numeral n = DIGS[n.toNat - 1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem teen_numbers {n : Int} (h1 : 10 \u2264 n) (h2 : n \u2264 19) :\n  (to_chinese_numeral n).startsWith \"\u5341\" \u2227\n  (n > 10 \u2192 \u2203 c : Char, c \u2208 (String.join DIGS).data \u2227\n    (to_chinese_numeral n).data[1]? = some c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '\u4e00\u767e\u4e8c\u5341\u4e09\u70b9\u56db\u4e94'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 123.45\n\n/-\ninfo: '\u8d1f\u4e00\u5343\u96f6\u56db'\n-/\n#guard_msgs in\n#eval to_chinese_numeral -1004\n\n/-\ninfo: '\u4e00\u4e07\u96f6\u56db\u70b9\u96f6\u96f6\u4e94'\n-/\n#guard_msgs in\n#eval to_chinese_numeral 10004.005"
      }
    ]
  },
  "fvapps_001576.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def total_inc_dec (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def xCy (n m : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_inc_dec_non_negative (x : Int) :\n  x \u2265 0 \u2192 total_inc_dec x \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_inc_dec_negative (x : Int) :\n  x < 0 \u2192 total_inc_dec x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_inc_dec_monotonic (x : Int) :\n  x > 0 \u2192 total_inc_dec x > total_inc_dec (x-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem xCy_non_negative (x y : Int) :\n  y \u2264 x \u2192 xCy x y \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem xCy_int_valued (x y : Int) :\n  y \u2264 x \u2192 \u2203 n : Int, xCy x y = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem xCy_symmetry (x y : Int) :\n  y \u2264 x \u2227 y > 0 \u2192 xCy x y = xCy x (x-y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem xCy_invalid (x y : Int) :\n  y > x \u2192 xCy x y = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval total_inc_dec 0\n\n/-\ninfo: 475\n-/\n#guard_msgs in\n#eval total_inc_dec 3\n\n/-\ninfo: 4954\n-/\n#guard_msgs in\n#eval total_inc_dec 5"
      }
    ]
  },
  "fvapps_001577.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def middle_permutation (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem middle_permutation_symmetric (s : String) :\n  middle_permutation s = middle_permutation s := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def char_list_eq (l1 l2 : List Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 c : Char, c \u2208 l1 \u2194 c \u2208 l2"
      },
      {
        "type": "cond",
        "string": "theorem middle_permutation_length (s : String) :\n  (middle_permutation s).length = s.length := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem middle_permutation_chars (s : String) :\n  char_list_eq s.data (middle_permutation s).data := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem middle_permutation_valid (s : String) :\n  \u2203 perm : List Char, middle_permutation s = String.mk perm \u2227\n    \u2203 (\u03c0 : List Char \u2192 List Char),\n      perm = \u03c0 s.data \u2227\n      (\u2200 (l : List Char), (\u03c0 l).length = l.length) \u2227\n      (\u2200 (l : List Char), char_list_eq (\u03c0 l) l) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bac'\n-/\n#guard_msgs in\n#eval middle_permutation \"abc\"\n\n/-\ninfo: 'bdca'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcd\"\n\n/-\ninfo: 'cbxda'\n-/\n#guard_msgs in\n#eval middle_permutation \"abcdx\""
      }
    ]
  },
  "fvapps_001580.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstring (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def longest_palindrome (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def substring (s : String) (i j : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_palindrome {s : String} :\n  let result := longest_palindrome s\n  result = \"\" \u2228 (result = reverseString result \u2227 isSubstring result s)\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_maximum_length {s : String} :\n  let result := longest_palindrome s\n  \u2200 (i j : Nat), i \u2264 s.length \u2192 j \u2264 s.length \u2192\n    let substr := substring s i j\n    substr = reverseString substr \u2192\n    substr.length \u2264 result.length\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_and_single_char_inputs {s : String} :\n  (s = \"\" \u2192 longest_palindrome s = \"\") \u2227\n  (s.length = 1 \u2192 longest_palindrome s = s)\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_input_returns_itself {s : String} :\n  s \u2260 \"\" \u2192\n  s = reverseString s \u2192\n  longest_palindrome s = s\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'bab'\n-/\n#guard_msgs in\n#eval longest_palindrome \"babad\"\n\n/-\ninfo: 'abababa'\n-/\n#guard_msgs in\n#eval longest_palindrome \"abababa\"\n\n/-\ninfo: 'bb'\n-/\n#guard_msgs in\n#eval longest_palindrome \"cbbd\""
      }
    ]
  },
  "fvapps_001584.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def multiply (n k: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiply_positive (n k: Nat)\n  (h1: n > 0) (h2: k > 0) : multiply n k > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiply_one (k: Nat)\n  (h: k > 0) : multiply 1 k = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiply_k1_is_one (n: Nat)\n  (h: n > 0) : multiply n 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiply_monotone_k (n k: Nat)\n  (h1: n > 0) (h2: k > 1) :\n  multiply n k \u2265 multiply n (k-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval multiply 24 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval multiply 100 1\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval multiply 20 3"
      }
    ]
  },
  "fvapps_001585.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def almost_everywhere_zero (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def comb (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def num_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem aez_valid_inputs (n : Nat) (k : Nat) :\n  let result := almost_everywhere_zero n k\n  result \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aez_zero_k (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 0 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aez_k_greater_than_digits (n : Nat) (k : Nat) (h1 : n > 0) (h2 : k > num_digits n) :\n  almost_everywhere_zero n k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem comb_properties (n k : Nat) :\n  let result := comb n k\n  (k > n \u2192 result = 0) \u2227\n  ((k = 0 \u2228 k = n) \u2192 result \u2264 1) \u2227\n  (k \u2264 n \u2192 comb n k = comb n (n-k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aez_single_nonzero (n : Nat) (h : n > 0) :\n  almost_everywhere_zero n 1 \u2265 num_digits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 100 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 11 2\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval almost_everywhere_zero 20 2"
      }
    ]
  },
  "fvapps_001587.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_of_squares (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def one_square (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def two_squares (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def three_squares (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_of_squares_range (n : Nat) (h : n \u2265 1) :\n  1 \u2264 sum_of_squares n \u2227 sum_of_squares n \u2264 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_squares 15\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 16\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sum_of_squares 17\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_squares 999887641\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_squares 999950886"
      }
    ]
  },
  "fvapps_001588.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def green (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def first_5_green_numbers (n : Nat) (h : n > 0 \u2227 n \u2264 5) :\n  green n = match n with\n    | 1 => 1\n    | 2 => 5\n    | 3 => 6\n    | 4 => 25\n    | 5 => 76\n    | _ => 0 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def green_number_positive (n : Nat) (h : n > 0) :\n  green n > 0 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def green_numbers_ordered (n : Nat) (h : n > 1) :\n  green n > green (n-1) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def green_numbers_unique (n m : Nat) (h1 : n > 0) (h2 : m > 0) (h3 : n \u2260 m) :\n  green n \u2260 green m :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval green 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval green 2\n\n/-\ninfo: 76\n-/\n#guard_msgs in\n#eval green 5"
      }
    ]
  },
  "fvapps_001589.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits_sorted (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits_sorted_desc (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def next_bigger (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_larger (n : Nat) :\n  let result := next_bigger n\n  result \u2260 -1 \u2192 result > n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_same_digits (n : Nat) :\n  let result := next_bigger n\n  result \u2260 -1 \u2192\n  \u2200 (r : Nat), result = r \u2192 (digits_sorted n = digits_sorted r) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_minimal (n : Nat) :\n  let result := next_bigger n\n  result \u2260 -1 \u2192\n  \u2200 x, n < x \u2192 x < result \u2192 digits_sorted x \u2260 digits_sorted n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_none_exists (n : Nat) :\n  next_bigger n = -1 \u2194 digits n = digits_sorted_desc n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_single_digit (n : Nat) :\n  n < 10 \u2192 next_bigger n = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_bigger_output_type (n : Nat) :\n  \u2203 i : Int, next_bigger n = i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval next_bigger 12\n\n/-\ninfo: 531\n-/\n#guard_msgs in\n#eval next_bigger 513\n\n/-\ninfo: 2071\n-/\n#guard_msgs in\n#eval next_bigger 2017\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval next_bigger 9876543210"
      }
    ]
  },
  "fvapps_001592.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAscending (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_all (sumDig digs : Nat) : Option (Nat \u00d7 Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_for_impossible_sums (sumDig digs : Nat) :\n  (sumDig > 9 * digs \u2228 sumDig < digs) \u2192 find_all sumDig digs = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_output_format {sumDig digs : Nat} (res : Nat \u00d7 Nat \u00d7 Nat) :\n  find_all sumDig digs = some res \u2192\n  let (count, first, last) := res\n  count > 0 \u2227\n  numDigits first = digs \u2227\n  numDigits last = digs \u2227\n  first \u2264 last :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solutions_have_correct_sum {sumDig digs : Nat} (res : Nat \u00d7 Nat \u00d7 Nat) :\n  find_all sumDig digs = some res \u2192\n  let (_, first, last) := res\n  sumDigits first = sumDig \u2227\n  sumDigits last = sumDig :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solutions_are_ascending {sumDig digs : Nat} (res : Nat \u00d7 Nat \u00d7 Nat) :\n  find_all sumDig digs = some res \u2192\n  let (_, first, last) := res\n  isAscending first \u2227\n  isAscending last :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [8, 118, 334]\n-/\n#guard_msgs in\n#eval find_all 10 3\n\n/-\ninfo: [1, 999, 999]\n-/\n#guard_msgs in\n#eval find_all 27 3\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval find_all 84 4"
      }
    ]
  },
  "fvapps_001593.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solution (xs : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_empty_list : solution [] = \"\" := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def parseAsInt (s : String) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "inductive ValidPart : Type where\n  | empty : ValidPart\n  | single (n : Int) : ValidPart\n  | range (s e : Int) (h : s < e) : ValidPart"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isValidPart (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_valid_parts (xs : List Int) :\n  \u2200 p \u2208 (solution xs).splitOn \",\", isValidPart p = true := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_nonempty_input (xs : List Int) (h : xs \u2260 []) :\n  solution xs \u2260 \"\" := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '-6,-3-1,3-5,7-11,14,15,17-20'\n-/\n#guard_msgs in\n#eval solution [-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]\n\n/-\ninfo: '-3--1,2,10,15,16,18-20'\n-/\n#guard_msgs in\n#eval solution [-3, -2, -1, 2, 10, 15, 16, 18, 19, 20]\n\n/-\ninfo: '1-5'\n-/\n#guard_msgs in\n#eval solution [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_001607.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def next_smaller (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_smaller_result_positive (n : Nat) (h: n \u2265 10) :\n  next_smaller n = -1 \u2228 next_smaller n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_same_digits (n m : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_returns_negative_one (n : Nat) (h: n < 10) :\n  next_smaller n = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_returns_negative_one :\n  next_smaller 0 = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_preserves_number_of_digits (n : Nat) (h: n \u2265 10) :\n  next_smaller n \u2260 -1 \u2192\n  (String.length (toString (next_smaller n).natAbs) = String.length (toString n)) \u2227\n  next_smaller n < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval next_smaller 21\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval next_smaller 1027\n\n/-\ninfo: 123456789\n-/\n#guard_msgs in\n#eval next_smaller 123456798"
      }
    ]
  },
  "fvapps_001608.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isNStraightHand (hand : List Int) (w : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isConsecutive (xs : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem div_by_w_necessary {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w \u2264 10000) (hh : List.length hand > 0) :\n  isNStraightHand hand w \u2192 List.length hand % w = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem w_one_always_true {hand : List Int} (hh : List.length hand > 0) :\n  isNStraightHand hand 1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_w {hand : List Int} {w : Int}\n  (hw : 0 < w) (hw' : w < List.length hand) (hh : List.length hand > 0) :\n  isNStraightHand hand w \u2192 \u00acisNStraightHand hand (w + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_numbers_possible {hand : List Int}\n  (hh : List.length hand > 0)\n  (h_len : List.length hand \u2265 2)\n  (h_consec : isConsecutive hand)\n  (h_div : List.length hand % 3 = 0) :\n  isNStraightHand hand 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 6, 2, 3, 4, 7, 8] 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 2, 3, 4, 5] 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isNStraightHand [1, 1, 2, 2, 3, 3] 3"
      }
    ]
  },
  "fvapps_001611.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculateSequences : List Int \u2192 List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure FormatResult where\n  isStartF : Bool\n  containsAssign : Bool"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def checkFormat (s : String) : FormatResult :="
      },
      {
        "type": "impl",
        "string": "  { isStartF := s.data.head? = some 'f',\n    containsAssign := s.data.contains '=' }"
      },
      {
        "type": "sig",
        "string": "def extractValue (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def extractNumber (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  \u2200 x \u2208 result,\n    let fmt := checkFormat x\n    fmt.isStartF \u2227 fmt.containsAssign :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem value_format_properties {inputs : List Int} :\n  let result := calculateSequences inputs\n  \u2200 x \u2208 result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n \u2265 5 \u2228 n \u2264 -51 \u2192 val = \"MAGNA NIMIS!\") \u2227\n    (n \u2264 3 \u2192 val.data.contains '.') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_matches_reversed {inputs : List Int} :\n  let result := calculateSequences inputs\n  let nums := result.map extractNumber\n  nums = inputs.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_values {inputs : List Int} (h : inputs.length > 0) :\n  let result := calculateSequences inputs\n  \u2200 x \u2208 result,\n    let n := extractNumber x\n    let val := extractValue x\n    (n = 0 \u2192 val = \"0.00\") \u2227\n    (n = 1 \u2192 val = \"6.00\") \u2227\n    (n = -1 \u2192 val = \"-4.00\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval calculate_sequences [0, 1, -2, -3, -4, -5, -6, -7, -8, -9, 10]"
      }
    ]
  },
  "fvapps_001621.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_cube_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_perfect_square (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Cube sum matches formula"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cube_sum_matches_formula (n : Nat) :\n  calculate_cube_sum n = ((n * (n + 1)) / 2) ^ 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Perfect squares are identified correctly"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem perfect_square_properties (n : Nat) (h : n > 1) :\n  (is_perfect_square (n * n) = true) \u2227\n  (is_perfect_square (n * n + 1) = false) \u2227\n  (is_perfect_square (n * n - 1) = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Product of perfect squares is perfect square"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem perfect_square_product (n : Nat) :\n  is_perfect_square n = true \u2192 is_perfect_square (n * n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_001622.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Graph := List (List Nat)"
      },
      {
        "type": "sig",
        "string": "def is_valid_graph (g : Graph) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_most_popular_friend (friend_lists : List String) : Nat \u00d7 Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem most_popular_friend_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  1 \u2264 popular \u2227 popular \u2264 friend_lists.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem notoriety_bounds (friend_lists : List String)\n  (h : friend_lists.length > 0) :\n  let (popular, notoriety) := find_most_popular_friend friend_lists\n  0 \u2264 notoriety \u2227 notoriety \u2264 Float.ofNat friend_lists.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001628.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_matrix_guessing (n m K : Nat) (queryFunc : Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Query function is consistent for matrices with small values (1-25) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_query_consistency_small {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  \u2200 i j, i < n \u2192 j < m \u2192\n  1 \u2264 ((result.get! i).get! j) \u2227 ((result.get! i).get! j) \u2264 25 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Query function is consistent for matrices with large values (26-50) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_query_consistency_large {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  \u2200 i j, i < n \u2192 j < m \u2192\n  26 \u2264 ((result.get! i).get! j) \u2227 ((result.get! i).get! j) \u2264 50 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Result matrix has correct dimensions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem basic_dimensions {n m : Nat} {K : Nat} (hn : 0 < n) (hm : 0 < m) (hK : K = 50)\n  (queryFunc : Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Nat) :\n  let result := solve_matrix_guessing n m K queryFunc\n  result.length = n \u2227 \u2200 row \u2208 result, row.length = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: n\n-/\n#guard_msgs in\n#eval len solve_matrix_guessing(n, m, c, mock_query_func)\n\n/-\ninfo: m\n-/\n#guard_msgs in\n#eval len result[0]"
      }
    ]
  },
  "fvapps_001633.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def identify_distribution (samples : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDistribution (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s = \"uniform\" || s = \"poisson\""
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_valid (samples : List Int)\n  (h : samples.length \u2265 2) :\n  isValidDistribution (identify_distribution samples) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_deterministic (samples : List Int) :\n  identify_distribution samples = identify_distribution samples :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_uniform (samples : List Int) :\n  samples.length \u2265 2 \u2192 identify_distribution samples = \"uniform\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_poisson (samples : List Int) :\n  samples.length \u2265 2 \u2192 identify_distribution samples = \"poisson\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_scale_invariant (samples : List Int)\n  (scale : Int) (h : scale \u2260 0) :\n  identify_distribution samples =\n  identify_distribution (samples.map (\u00b7 * scale)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identify_distribution_order_invariant (samples\u2081 samples\u2082 : List Int)\n  (h : samples\u2081.length = samples\u2082.length)\n  (h2 : \u2200 x, x \u2208 samples\u2081 \u2194 x \u2208 samples\u2082) :\n  identify_distribution samples\u2081 = identify_distribution samples\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [1, 2, 3, 2, 1]\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [10, 8, 9, 8, 12]\n\n/-\ninfo: 'poisson'\n-/\n#guard_msgs in\n#eval identify_distribution [-5, -4, -3, -4, -5]"
      }
    ]
  },
  "fvapps_001634.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_index (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_index (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def find_second_max (lst : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (lst : List Int) : Option Int := lst.foldl (fun min x => match min with\n  | none => some x\n  | some m => if x < m then some x else some m) none"
      },
      {
        "type": "sig",
        "string": "def maximum (lst : List Int) : Option Int := lst.foldl (fun max x => match max with\n  | none => some x\n  | some m => if x > m then some x else some m) none"
      },
      {
        "type": "cond",
        "string": "theorem min_index_empty (lst : List Int) :\n  lst = [] \u2192 find_min_index lst = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_index_valid (lst : List Int) (result : Int) :\n  result = find_min_index lst \u2192\n  result \u2260 -1 \u2192\n  (\u2203 min : Int, minimum lst = some min \u2227\n   0 \u2264 result \u2227 result < lst.length \u2227\n   lst.get \u27e8result.toNat, sorry\u27e9 = min \u2227\n   lst.count min = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_index_duplicate (lst : List Int) :\n  find_min_index lst = -1 \u2192\n  lst \u2260 [] \u2192\n  (\u2203 min : Int, minimum lst = some min \u2227 lst.count min > 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_index_empty (lst : List Int) :\n  lst = [] \u2192 find_max_index lst = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_index_valid (lst : List Int) (result : Int) :\n  result = find_max_index lst \u2192\n  result \u2260 -1 \u2192\n  (\u2203 max : Int, maximum lst = some max \u2227\n   0 \u2264 result \u2227 result < lst.length \u2227\n   lst.get \u27e8result.toNat, sorry\u27e9 = max \u2227\n   lst.count max = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_index_duplicate (lst : List Int) :\n  find_max_index lst = -1 \u2192\n  lst \u2260 [] \u2192\n  (\u2203 max : Int, maximum lst = some max \u2227 lst.count max > 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem second_max_short (lst : List Int) :\n  lst.length < 2 \u2192 find_second_max lst = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem second_max_valid (lst : List Int) (result : Int) :\n  find_second_max lst = some result \u2192\n  (\u2203 max : Int, maximum lst = some max \u2227\n   result < max \u2227\n   (\u2200 x, x \u2208 lst \u2192 \u00ac(result < x \u2227 x < max)) \u2227\n   result \u2208 lst) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem second_max_none (lst : List Int) :\n  find_second_max lst = none \u2192\n  lst.length \u2265 2 \u2192\n  (\u2203 x : Int, \u2200 y \u2208 lst, y = x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem results_from_input (lst : List Int) :\n  let min_idx := find_min_index lst\n  let max_idx := find_max_index lst\n  let second := find_second_max lst\n  (min_idx \u2260 -1 \u2192 (\u2203 x, lst.get \u27e8min_idx.toNat, sorry\u27e9 = x \u2227 x \u2208 lst)) \u2227\n  (max_idx \u2260 -1 \u2192 (\u2203 x, lst.get \u27e8max_idx.toNat, sorry\u27e9 = x \u2227 x \u2208 lst)) \u2227\n  (second.isSome \u2192 (Option.get! second) \u2208 lst) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_second_max [4, 1, 2, 3, 5]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval find_second_max [1, 1, 1, 1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_second_max [1, 2, 3, 3]"
      }
    ]
  },
  "fvapps_001639.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPerfectSquare (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def generateValidBoard (size : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def validateSudoku (board : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_size_board {n : Nat} :\n  n > 0 \u2192 \u00ac(isPerfectSquare n) \u2192\n  validateSudoku (List.replicate n (List.replicate n 1)) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_size_board {n : Nat} :\n  n > 0 \u2192 n \u2264 3 \u2192\n  validateSudoku (generateValidBoard (n * n)) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_in_row {n : Nat} (board : List (List Nat)) :\n  n > 0 \u2192 n \u2264 3 \u2192\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 \u2227 board.length > 0 \u2227 (board.head!).length > 1\n    then board.set 0 ((board.get! 0).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_in_column {n : Nat} (board : List (List Nat)) :\n  n > 0 \u2192 n \u2264 3 \u2192\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 \u2227 board.length > 1\n    then board.set 1 ((board.get! 1).set 0 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_in_square {n : Nat} (board : List (List Nat)) :\n  n > 0 \u2192 n \u2264 3 \u2192\n  let size := n * n\n  let modifiedBoard :=\n    if size > 0 \u2227 board.length > 1\n    then board.set 1 ((board.get! 1).set 1 ((board.get! 0).get! 0))\n    else board\n  validateSudoku modifiedBoard = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku [[7, 8, 4, 1, 5, 9, 3, 2, 6], [5, 3, 9, 6, 7, 2, 8, 4, 1], [6, 1, 2, 4, 3, 8, 7, 5, 9], [9, 2, 8, 7, 1, 5, 4, 6, 3], [3, 5, 7, 8, 4, 6, 1, 9, 2], [4, 6, 1, 9, 2, 3, 5, 8, 7], [8, 7, 6, 3, 9, 4, 2, 1, 5], [2, 4, 3, 5, 6, 1, 9, 7, 8], [1, 9, 5, 2, 8, 7, 6, 3, 4]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validate_sudoku invalid_board\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validate_sudoku valid_small"
      }
    ]
  },
  "fvapps_001646.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def primeFactor (n: Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumForList (lst : List Int) : List (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (lst : List Int) : Int := lst.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem results_are_prime_factors {lst : List Int} (h : \u2200 x, x \u2208 lst \u2192 x \u2260 0) :\n  \u2200 pt, pt \u2208 sumForList lst \u2192\n    isPrime pt.1 = true \u2227\n    \u2203 x, x \u2208 lst \u2227 x % pt.1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sums_are_correct {lst : List Int} (h : \u2200 x, x \u2208 lst \u2192 x \u2260 0) :\n  \u2200 pt, pt \u2208 sumForList lst \u2192\n    pt.2 = listSum (lst.filter (fun x => x % pt.1 = 0)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem factors_ordered {lst : List Int} (h : \u2200 x, x \u2208 lst \u2192 x \u2260 0) :\n  List.Pairwise (\u00b7 \u2264 \u00b7) (List.map Prod.fst (sumForList lst)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_prime_factors_included {lst : List Int} (h : \u2200 x, x \u2208 lst \u2192 x \u2260 0) :\n  (\u2200 p, p \u2208 List.map Prod.fst (sumForList lst) \u2192\n    (\u2203 x, x \u2208 lst \u2227 x % p = 0 \u2227 isPrime p = true)) \u2227\n  (\u2200 x, x \u2208 lst \u2192 \u2200 p, p \u2208 primeFactor x \u2192\n    p \u2208 List.map Prod.fst (sumForList lst)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [[2, 12], [3, 27], [5, 15]]\n-/\n#guard_msgs in\n#eval sum_for_list [12, 15]\n\n/-\ninfo: [[2, 30], [3, 0], [5, 0]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 30, -45]\n\n/-\ninfo: [[2, 54], [3, 135], [5, 90], [7, 21]]\n-/\n#guard_msgs in\n#eval sum_for_list [15, 21, 24, 30, 45]"
      }
    ]
  },
  "fvapps_001653.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidMaze (maze : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasExit (maze : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isKateAt (maze : List String) (i j : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maze_properties (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1) :\n  hasExit maze = true \u2228 hasExit maze = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_maze_no_kate (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 0) :\n  \u2203 e, hasExit maze = e \u2192 False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_escape (maze : List String)\n  (h1 : isValidMaze maze = true)\n  (kateCount : Nat)\n  (h2 : kateCount = 1)\n  (h3 : \u2203 (i j : Nat),\n    (i = 0 \u2228 i = maze.length - 1 \u2228 j = 0 \u2228 j = (maze.get! 0).length - 1) \u2227\n    isKateAt maze i j = true) :\n  hasExit maze = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_exit [\"# ##\", \"# k#\", \"####\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval has_exit [\"####\", \"# k#\", \"####\"]"
      }
    ]
  },
  "fvapps_001659.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def path_finder (maze : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringReplicate (n : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringJoin (l : List String) (sep : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def makeList (n : Nat) (c : Char) : List Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listToString (l : List Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def make_maze (cells : List Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_maze_always_solvable (n : Nat) (h : n \u2265 2) (h2 : n \u2264 10) :\n  let row := stringReplicate n \".\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem border_wall_maze_unsolvable (n : Nat) (h : n \u2265 2) (h2 : n \u2264 10) :\n  let row := stringReplicate n \"W\"\n  let rows := List.replicate n row\n  path_finder (stringJoin rows \"\\n\") = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem random_valid_maze_returns_bool (cells : List Char)\n  (h1 : cells.length \u2265 4) (h2 : cells.length \u2264 100)\n  (h3 : \u2200 c \u2208 cells, c = '.' \u2228 c = 'W')\n  (h4 : \u2203 n : Nat, n * n = cells.length)\n  (h5 : cells \u2260 [] \u2192 cells[0] = '.')\n  (h6 : cells \u2260 [] \u2192 cells[cells.length - 1] = '.') :\n  (path_finder (make_maze cells)) = true \u2228 (path_finder (make_maze cells)) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_path_solvable :\n  path_finder \"..W\\nW.W\\n...\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_to_self_exists (n : Nat) (h : n \u2265 2) (h2 : n \u2264 10) :\n  let cells := makeList (n*n) '.'\n  path_finder (make_maze cells) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval path_finder \"\\n\".join([\".W.\", \".W.\", \"...\"])\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder maze2"
      }
    ]
  },
  "fvapps_001663.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Term := String"
      },
      {
        "type": "sig",
        "string": "def Equation := String"
      },
      {
        "type": "sig",
        "string": "def Solution := List (String \u00d7 Int)"
      },
      {
        "type": "sig",
        "string": "def solve_equations : List Equation \u2192 Option Solution\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def equation_vars : Equation \u2192 List String\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def solution_vars : Solution \u2192 List String\n  | _ => sorry\n\ndef verify_solution (equations : List Equation) (solution : Option Solution) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_variables_match_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  \u2200 v, (\u2203 eq \u2208 equations, v \u2208 equation_vars eq) \u2194 v \u2208 solution_vars s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem underdetermined_system_no_solution :\n  solve_equations [\"x + y = 1\"] = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_satisfies_equations (equations : List Equation)\n  (s : Solution)\n  (h : solve_equations equations = some s) :\n  verify_solution equations (some s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve_equations [\"2x + 4y + 6z = 18\", \"3y + 3z = 6\", \"x + 2y = z - 3\"]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval solve_equations [\"x + y = 2\", \"x + y = 3\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve_equations [\"x = 1\"]"
      }
    ]
  },
  "fvapps_001664.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidPos (pos : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def knight (s e : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem knight_valid_range {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e) :\n  let m := knight s e\n  0 \u2264 m \u2227 m \u2264 6 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knight_same_position {p : String}\n  (h : isValidPos p) :\n  knight p p = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knight_diagonal_adjacent {s e : String}\n  (h1 : isValidPos s) (h2 : isValidPos e)\n  (h3 : abs ((s.get! \u27e80\u27e9).toNat - (e.get! \u27e80\u27e9).toNat) = 1)\n  (h4 : abs ((s.get! \u27e81\u27e9).toNat - (e.get! \u27e81\u27e9).toNat) = 1) :\n  knight s e = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knight_symmetric {p t : String}\n  (h1 : isValidPos p) (h2 : isValidPos t) :\n  knight p t = knight t p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval knight \"a3\" \"b5\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval knight \"a1\" \"c5\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval knight \"d5\" \"d5\""
      }
    ]
  },
  "fvapps_001667.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_interesting (number : Nat) (awesome_phrases : Array Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isRoundNumber (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_interesting_result_valid (n : Nat) (phrases : Array Nat) :\n  let result := is_interesting n phrases\n  result = 0 \u2228 result = 1 \u2228 result = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_numbers_boring (n : Nat) (h : n < 98) :\n  is_interesting n #[] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem awesome_phrases_direct_match (n : Nat) (phrases : Array Nat)\n  (h1 : n \u2265 100) (h2 : phrases.contains n = true) :\n  is_interesting n phrases = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem awesome_phrases_nearby_match (n : Nat) (phrases : Array Nat)\n  (h1 : n \u2265 98) (h2 : phrases.contains (n + 1) = true \u2228 phrases.contains (n + 2) = true) :\n  is_interesting n phrases \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_direct_match (n : Nat) (h1 : n \u2265 100)\n  (h2 : isPalindrome n = true) :\n  is_interesting n #[] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_nearby_match (n : Nat) (h1 : n \u2265 98)\n  (h2 : isPalindrome (n + 1) = true \u2228 isPalindrome (n + 2) = true)\n  (h3 : n + 1 \u2265 100 \u2228 n + 2 \u2265 100) :\n  is_interesting n #[] \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem incrementing_sequences (n : Nat)\n  (h : n = 123 \u2228 n = 234 \u2228 n = 345 \u2228 n = 456 \u2228 n = 567 \u2228 n = 678 \u2228 n = 789 \u2228 n = 890) :\n  is_interesting n #[] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decrementing_sequences (n : Nat)\n  (h : n = 987 \u2228 n = 876 \u2228 n = 765 \u2228 n = 654 \u2228 n = 543 \u2228 n = 432 \u2228 n = 321) :\n  is_interesting n #[] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval is_interesting 3 #[1337, 256]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval is_interesting 1336 #[1337, 256]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval is_interesting 1000 #[1337, 256]"
      }
    ]
  },
  "fvapps_001670.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def decodeBits (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def decodeMorse (s : String) : String := sorry\n\ndef stringRepeat (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => \"\"\n  | n+1 => s ++ stringRepeat s n"
      },
      {
        "type": "cond",
        "string": "theorem dot_timing {unit_time : Nat} (h : 0 < unit_time) (h2 : unit_time \u2264 10) :\n  let dot := stringRepeat \"1\" unit_time\n  decodeMorse (decodeBits dot) = \"E\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem leading_trailing_zeros {zeros : Nat} (h : zeros \u2264 10) :\n  let zeros_str := stringRepeat \"0\" zeros\n  decodeMorse (decodeBits (zeros_str ++ \"1\" ++ zeros_str)) = \"E\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spacing {unit_time : Nat} (h : 0 < unit_time) (h2 : unit_time \u2264 5) :\n  let dot := stringRepeat \"1\" unit_time\n  let letter_gap := stringRepeat \"0\" (3 * unit_time)\n  let word_gap := stringRepeat \"0\" (7 * unit_time)\n  (decodeMorse (decodeBits (dot ++ letter_gap ++ dot)) = \"EE\") \u2227\n  (decodeMorse (decodeBits (dot ++ word_gap ++ dot)) = \"E E\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_input :\n  (decodeBits \"\" = \"\") \u2227\n  (decodeBits \"0\" = \"\") \u2227\n  (decodeBits \"000\" = \"\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'E'\n-/\n#guard_msgs in\n#eval decodeMorse decodeBits(\"1\")\n\n/-\ninfo: 'E'\n-/\n#guard_msgs in\n#eval decodeMorse decodeBits(\"111\")\n\n/-\ninfo: 'E'\n-/\n#guard_msgs in\n#eval decodeMorse decodeBits(\"111111\")"
      }
    ]
  },
  "fvapps_001674.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def collatz_steps (n : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def get_steps (n : Nat) (len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Base case properties -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem collatz_steps_D : collatz_steps 1 \"D\" = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem collatz_steps_U : collatz_steps 1 \"U\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Main invariant properties for any input -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem collatz_steps_geq_input {n : Nat} {s : String} (h : n > 0) :\n  collatz_steps n s \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Minimal result property -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem collatz_steps_minimal {n : Nat} {s : String} (h : n > 0) (h2 : collatz_steps n s > 1) :\n  \u2200 m, m < collatz_steps n s \u2192 \u00ac(get_steps m (String.length s)).startsWith s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper lemma to relate get_steps to collatz_steps -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem get_steps_matches {n : Nat} {s : String} (h : n > 0) :\n  (get_steps (collatz_steps n s) (String.length s)).startsWith s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001680.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (p : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure PrimeFactor where\n  prime : Nat\n  power : Nat"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def factorize (n : Nat) : List PrimeFactor :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isqrt_upper_bound (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  r * r \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isqrt_next_exceeds (n : Nat) (h : n > 0) :\n  let r := isqrt n\n  (r + 1) * (r + 1) > n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval trailing_zeros 15 10\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval trailing_zeros 7 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval trailing_zeros 30 10"
      }
    ]
  },
  "fvapps_001681.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mystery (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def mystery_inv (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def name_of_mystery : String :="
      },
      {
        "type": "impl",
        "string": "  \"Gray code\""
      },
      {
        "type": "cond",
        "string": "theorem mystery_inverse : \u2200 n : Nat, n < 2^32 \u2192\n  mystery (mystery_inv n) = n \u2227 mystery_inv (mystery n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mystery_preserves_non_negative : \u2200 n : Nat,\n  mystery n \u2265 0 \u2227 mystery_inv n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mystery_bit_length : \u2200 n : Nat, n < 2^16 \u2192\n  n.log2 - (mystery n).log2 \u2264 1 \u2227\n  n.log2 - (mystery_inv n).log2 \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mystery_name_is_gray_code :\n  name_of_mystery = \"Gray code\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval mystery 6\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval mystery_inv 5\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval mystery mystery_inv(10)\n\n/-\ninfo: 'Gray code'\n-/\n#guard_msgs in\n#eval name_of_mystery"
      }
    ]
  },
  "fvapps_001689.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def permutations (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat := sorry\n\ndef noDups {\u03b1} [BEq \u03b1] (as : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  as.foldl (fun acc a => if acc.contains a then acc else a::acc) []"
      },
      {
        "type": "sig",
        "string": "def countUnique (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (noDups s.data).length"
      },
      {
        "type": "cond",
        "string": "theorem permutation_length_factorial_bound\n  (s : String) (hs : s.length > 0) :\n  let perms := permutations s\n  let n_unique := countUnique s\n  (n_unique = s.length \u2192 perms.length = factorial s.length) \u2227\n  (n_unique < s.length \u2192 perms.length \u2264 factorial s.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutations_same_length\n  (s : String) (hs : s.length > 0) :\n  let perms := permutations s\n  \u2200 p \u2208 perms, p.length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutations_use_original_chars\n  (s : String) (hs : s.length > 0) :\n  let perms := permutations s\n  \u2200 p \u2208 perms, p.data.toArray.qsort (\u00b7 \u2264 \u00b7) = s.data.toArray.qsort (\u00b7 \u2264 \u00b7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutations_are_unique\n  (s : String) (hs : s.length > 0) :\n  let perms := permutations s\n  perms.length = (noDups perms).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: sorted(['a'])\n-/\n#guard_msgs in\n#eval sorted permutations(\"a\")\n\n/-\ninfo: sorted(['ab', 'ba'])\n-/\n#guard_msgs in\n#eval sorted permutations(\"ab\")\n\n/-\ninfo: sorted(['aabb', 'abab', 'abba', 'baab', 'baba', 'bbaa'])\n-/\n#guard_msgs in\n#eval sorted permutations(\"aabb\")"
      }
    ]
  },
  "fvapps_001693.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mouse_path (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_corner (orientations : List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_intersect (rectas : List ((Int \u00d7 Int) \u00d7 (Int \u00d7 Int))) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calc_area (points : List (Int \u00d7 Int)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def add_point (direction : Char) (distance : Nat) (points : List (Int \u00d7 Int)) : List (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mouse_path_returns_none_or_natural (s : String) :\n  match mouse_path s with\n  | none => True\n  | some n => n \u2265 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_corner_single_orientation {o : Char} (orientations : List Char) :\n  (\u2200 x \u2208 orientations, x = o) \u2192 check_corner orientations = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_intersect_symmetry (rectas : List ((Int \u00d7 Int) \u00d7 (Int \u00d7 Int))) :\n  check_intersect rectas = check_intersect rectas.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_area_nonnegative (points : List (Int \u00d7 Int)) :\n  calc_area points \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_point_preserves_coordinate (direction : Char) (distance : Nat) (points : List (Int \u00d7 Int)) :\n  let newPoints := add_point direction distance [(0,0)]\n  (direction = 'N' \u2228 direction = 'S') \u2192\n    (newPoints.get! 0).1 = (newPoints.get! 1).1 \u2227\n  (direction = 'E' \u2228 direction = 'O') \u2192\n    (newPoints.get! 0).2 = (newPoints.get! 1).2\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 49\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5R9R4R4L3\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"4R2L1R5\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval mouse_path \"2R2R2L2L\""
      }
    ]
  },
  "fvapps_001694.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def height (n m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def TestEmulator := Nat \u00d7 Nat \u00d7 Nat"
      },
      {
        "type": "sig",
        "string": "def solve (e : TestEmulator) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem height_nonnegative (n m : Nat) :\n  height n m \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem height_when_n_geq_m (n m : Nat) :\n  n \u2265 m \u2192 height n m = 2^m - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_bounded_by_break_floor (eggs drops break_floor : Nat) :\n  eggs > 0 \u2192 drops > 0 \u2192 break_floor > 0 \u2192\n  solve (eggs, drops, break_floor) \u2264 break_floor :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_positive (eggs drops break_floor : Nat) :\n  eggs > 0 \u2192 drops > 0 \u2192 break_floor > 0 \u2192\n  solve (eggs, drops, break_floor) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_respects_constraints (eggs drops break_floor : Nat) :\n  eggs > 0 \u2192 drops > 0 \u2192 break_floor > 0 \u2192\n  let e := (eggs, drops, break_floor)\n  solve e \u2264 eggs \u2227 solve e \u2264 drops :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem emulator_below_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 \u2192 drops > 0 \u2192 break_floor > 1 \u2192\n  solve (eggs, drops - 1, break_floor - 1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem emulator_at_break_point (eggs drops break_floor : Nat) :\n  eggs > 0 \u2192 drops > 1 \u2192 break_floor > 0 \u2192\n  solve (eggs - 1, drops - 2, break_floor) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solve TestEmulator(1, 10, 5)\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval solve TestEmulator(2, 10, 20)\n\n/-\ninfo: 55\n-/\n#guard_msgs in\n#eval solve TestEmulator(3, 14, 55)"
      }
    ]
  },
  "fvapps_001696.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def b (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def d (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def skrzat (mode : String) (input : Int \u2295 String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_binary (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bidirectional_conversion : \u2200 (n : Int),\n  let bin := b n; d bin = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_valid : \u2200 (n : Int),\n  is_valid_binary (b n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem skrzat_binary_format : \u2200 (binary : String),\n  is_valid_binary binary = true \u2192\n  \u2203 n : Int, skrzat \"b\" (Sum.inr binary) = s!\"From binary: {binary} is {n}\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem skrzat_decimal_format : \u2200 (decimal : Int),\n  \u2203 binary : String,\n    skrzat \"d\" (Sum.inl decimal) = s!\"From decimal: {decimal} is {binary}\" \u2227\n    is_valid_binary binary = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem skrzat_invalid_base : \u2200 (input : Int \u2295 String),\n  skrzat \"x\" input \u2260 skrzat \"d\" input \u2227 skrzat \"x\" input \u2260 skrzat \"b\" input :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_conversion : \u2200 (n : Int),\n  n \u2265 0 \u2192\n  let bin := b n\n  \u00acbin.startsWith \"-\" \u2227 d bin = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_negative_conversion : \u2200 (n : Int),\n  n \u2264 0 \u2192\n  let bin := b n\n  d bin = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'From binary: 1001101 is 61'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"1001101\"\n\n/-\ninfo: 'From binary: 0111111 is -21'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"0111111\"\n\n/-\ninfo: 'From binary: 101001000100001 is 19937'\n-/\n#guard_msgs in\n#eval skrzat \"b\" \"101001000100001\"\n\n/-\ninfo: 'From decimal: -137 is 10001011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" -137\n\n/-\ninfo: 'From decimal: 137 is 110011001'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 137\n\n/-\ninfo: 'From decimal: 8191 is 110000000000011'\n-/\n#guard_msgs in\n#eval skrzat \"d\" 8191"
      }
    ]
  },
  "fvapps_001699.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.noDuplicates (path : List Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 (x : Char), (List.count x path) \u2264 1"
      },
      {
        "type": "sig",
        "string": "def List.isSorted (xs : List (List Char)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < xs.length \u2192 (xs.get \u27e8i, by sorry\u27e9) \u2264 (xs.get \u27e8j, by sorry\u27e9)"
      },
      {
        "type": "sig",
        "string": "def Topology := Char \u2192 Char \u2192 Option Nat\n\ndef shortestPath (G : Topology) (s e : Char) : List (List Char) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortestPath_valid_paths {G : Topology} {s e : Char}\n  (path : List Char) (h : path \u2208 shortestPath G s e) :\n    path.head? = some s \u2227\n    path.getLast? = some e \u2227\n    path.noDuplicates :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortestPath_equal_length {G : Topology} {s e : Char}\n  (p1 p2 : List Char) (h1 : p1 \u2208 shortestPath G s e) (h2 : p2 \u2208 shortestPath G s e) :\n    p1.length = p2.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortestPath_sorted {G : Topology} {s e : Char} :\n  (shortestPath G s e).isSorted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortestPath_connected {G : Topology} {s e : Char}\n  (path : List Char) (h : path \u2208 shortestPath G s e) :\n  \u2200 i, i < path.length - 1 \u2192\n    \u2203 h : i < path.length, \u2203 h' : i + 1 < path.length,\n      (G (path.get \u27e8i, h\u27e9) (path.get \u27e8i+1, h'\u27e9)).isSome :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortestPath_disconnected {G : Topology} {s e : Char}\n  (h_disconnected : \u2200 c, (G s c).isNone) :\n  shortestPath G s e = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [['a', 'c', 'f'], ['a', 'e', 'f']]\n-/\n#guard_msgs in\n#eval shortestPath {\"a\": {\"b\": 10, \"c\": 20, \"e\": 20}, \"b\": {\"a\": 10, \"d\": 20}, \"c\": {\"a\": 10, \"f\": 20}, \"d\": {\"b\": 10, \"e\": 20, \"g\": 20}, \"e\": {\"a\": 10, \"d\": 20, \"f\": 20}, \"f\": {\"c\": 10, \"e\": 20, \"h\": 20}, \"g\": {\"d\": 10, \"h\": 20}, \"h\": {\"g\": 10, \"f\": 20}} \"a\" \"f\"\n\n/-\ninfo: [['a', 'e']]\n-/\n#guard_msgs in\n#eval shortestPath topology1 \"a\" \"e\"\n\n/-\ninfo: [['a', 'c']]\n-/\n#guard_msgs in\n#eval shortestPath {\"a\": {\"b\": 10, \"c\": 20}, \"b\": {\"a\": 10, \"c\": 20}, \"c\": {\"a\": 10, \"b\": 20}} \"a\" \"c\""
      }
    ]
  },
  "fvapps_001700.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pathFinder (maze : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_finder_result_exists (maze : String) :\n  \u2203 (result : Option Nat), pathFinder maze = result := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_finder_empty_path :\n  pathFinder \"...\\n...\\n...\" \u2260 none := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_finder_blocked_two_by_two :\n  pathFinder \"W.\\n.W\" = none := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_finder_all_blocked_except_ends :\n  pathFinder \".WW\\nWWW\\nWW.\" = none := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Any valid path length must be non-negative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem path_finder_positive_length (maze : String) (n : Nat) :\n  pathFinder maze = some n \u2192 n > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    ...\".replace(\"    \", \"\")\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval path_finder \".W.\\n    .W.\\n    .W.\".replace(\"    \", \"\")\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval path_finder \"...\\n    ...\\n    ...\".replace(\"    \", \"\")"
      }
    ]
  },
  "fvapps_001703.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def valid_solution (board : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_unique_1_to_9 (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_box_elements (board : List (List Nat)) (box_i box_j : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_column (board : List (List Nat)) (j : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_grid_properties (board : List (List Nat)) :\n  (\u2200 row \u2208 board, check_unique_1_to_9 row) \u2227\n  (\u2200 j, 0 \u2264 j \u2227 j < 9 \u2192 check_unique_1_to_9 (get_column board j)) \u2227\n  (\u2200 i j, 0 \u2264 i \u2227 i < 3 \u2227 0 \u2264 j \u2227 j < 3 \u2192\n    check_unique_1_to_9 (get_box_elements board (3*i) (3*j)))\n  \u2192 valid_solution board :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_numbers (board : List (List Nat)) :\n  (\u2203 row \u2208 board, \u2203 x \u2208 row, x < 1 \u2228 x > 9) \u2192\n  \u00ac valid_solution board :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_solution [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 0, 3, 4, 8], [1, 0, 0, 3, 4, 2, 5, 6, 0], [8, 5, 9, 7, 6, 1, 0, 2, 0], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 0, 1, 5, 3, 7, 2, 1, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 0, 0, 4, 8, 1, 1, 7, 9]]"
      }
    ]
  },
  "fvapps_001704.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_single_digit_addition (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_single_digit (n : Nat) :\n  solve_single_digit_addition n \u2264 9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def compute_running_sum : Nat \u2192 Nat\n  | x => if x < 10 then x\n         else compute_running_sum (solve_single_digit_addition x)\ntermination_by x => x\ndecreasing_by simp_wf; sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_equals_sum_of_digits (n : Nat) :\n  let result := solve_single_digit_addition n\n  let digit_sum := solve_single_digit_addition result\n  result = digit_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent (n : Nat) :\n  let first_result := solve_single_digit_addition n\n  let second_result := solve_single_digit_addition first_result\n  first_result = second_result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equals_recursive_digit_sum (n : Nat) :\n  solve_single_digit_addition n = compute_running_sum n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001709.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isBalanced (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def balancedParens (n : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def catalan (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_output_is_balanced (n : Nat) (h : n \u2264 5) :\n  \u2200 s \u2208 balancedParens n, isBalanced s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_length (n : Nat) (h : n \u2264 5) :\n  \u2200 s \u2208 balancedParens n, s.length = 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_unique (n : Nat) (h : n \u2264 5) :\n  (balancedParens n).Nodup :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_only_parens (n : Nat) (h : n \u2264 5) :\n  \u2200 s \u2208 balancedParens n, \u2200 c \u2208 s.toList, c = '(' \u2228 c = ')' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_catalan (n : Nat) (h : n \u2264 5) :\n  (balancedParens n).length = catalan n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem balanced_parens_non_negative (n : Int) :\n  n \u2265 0 \u2192 \u2203 (l : List String), l = balancedParens n.toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['']\n-/\n#guard_msgs in\n#eval balanced_parens 0\n\n/-\ninfo: ['()']\n-/\n#guard_msgs in\n#eval balanced_parens 1\n\n/-\ninfo: ['(())', '()()']\n-/\n#guard_msgs in\n#eval balanced_parens 2\n\n/-\ninfo: ['((()))', '(()())', '(())()', '()(())', '()()()']\n-/\n#guard_msgs in\n#eval balanced_parens 3"
      }
    ]
  },
  "fvapps_001713.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def VALID_VALUES := ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']"
      },
      {
        "type": "sig",
        "string": "def VALID_SUITS := ['S', 'H', 'D', 'C']"
      },
      {
        "type": "constr",
        "string": "structure Card where\n  value : Char\n  suit : Char\n  deriving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "structure Hand where\n  cards : List Card\n  deriving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def Hand.maxCount (h : Hand) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Hand.maxCard (h : Hand) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Hand.remaining (h : Hand) : List Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Hand.isFlush (h : Hand) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Hand.isStraight (h : Hand) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Hand.gt (h1 h2 : Hand) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hand_initialization (cards : List Card) (h : Hand) :\n  cards.length = 5 \u2227\n  \u2200 c \u2208 cards, c.value \u2208 VALID_VALUES \u2227 c.suit \u2208 VALID_SUITS :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hand_properties (h : Hand) :\n  1 \u2264 h.maxCount \u2227 h.maxCount \u2264 4 \u2227\n  h.maxCard \u2208 VALID_VALUES \u2227\n  \u2200 r \u2208 h.remaining, r \u2208 VALID_VALUES :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hand_comparison_reflexive (h : Hand) :\n  \u00ac(Hand.gt h h) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hand_comparison_antisymmetric (h1 h2 : Hand) :\n  Hand.gt h1 h2 \u2192 \u00ac(Hand.gt h2 h1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hand_comparison_transitive (h1 h2 : Hand) :\n  h1 = h2 \u2192 \u00ac(Hand.gt h1 h2) \u2227 \u00ac(Hand.gt h2 h1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem straight_flush_beats_others (h : Hand) :\n  \u00ac(h.isStraight \u2227 h.isFlush) \u2192\n  Hand.gt (Hand.mk [\n    {value := 'A', suit := 'S'},\n    {value := 'K', suit := 'S'},\n    {value := 'Q', suit := 'S'},\n    {value := 'J', suit := 'S'},\n    {value := 'T', suit := 'S'}\n  ]) h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flush_consistency (h : Hand) :\n  h.isFlush \u2192 List.length (List.map Card.suit h.cards) = 5 \u2227\n  \u2200 (c1 c2 : Card), c1 \u2208 h.cards \u2192 c2 \u2208 h.cards \u2192 c1.suit = c2.suit :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001716.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Point := Float \u00d7 Float\n\ndef convex_hull_area (points : List Point) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_internal_point (p : Point) (points : List Point) : Prop :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem convex_hull_area_non_negative (points : List Point) :\n  convex_hull_area points \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem convex_hull_area_less_than_three_points (points : List Point) :\n  points.length < 3 \u2192 convex_hull_area points = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem convex_hull_area_permutation_invariant {points perm : List Point} :\n  points.length > 0 \u2192\n  points.Perm perm \u2192\n  convex_hull_area points = convex_hull_area perm :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem convex_hull_area_internal_points {points : List Point} {p : Point} :\n  points.length \u2265 3 \u2192\n  is_internal_point p points \u2192\n  convex_hull_area (p::points) = convex_hull_area points :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0)]\n\n/-\ninfo: 4.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 2), (2, 2), (2, 0)]\n\n/-\ninfo: 6.0\n-/\n#guard_msgs in\n#eval convex_hull_area [(0, 0), (0, 3), (4, 0), (1, 1), (2, 1)]"
      }
    ]
  },
  "fvapps_001718.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def choose_move (gameState : List Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def nimSum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem choose_move_valid {gameState : List Nat} (h : gameState \u2260 []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  pileIdx < gameState.length \u2227\n  0 < straws \u2227\n  straws \u2264 gameState[pileIdx]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem winning_move_reduces_nim_sum {gameState : List Nat} (h : gameState \u2260 []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  let initialNimSum := nimSum gameState\n  let newState := gameState.set pileIdx (gameState[pileIdx]! - straws)\n  let newNimSum := nimSum newState\n  initialNimSum > 0 \u2192 newNimSum < initialNimSum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem modify_nonempty_pile {gameState : List Nat} (h : gameState \u2260 []) :\n  let move := choose_move gameState\n  let (pileIdx, straws) := move\n  gameState[pileIdx]! > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001719.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def generate_bc (url : String) (separator : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsStr (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findStr (s : String) (sub : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_bc_structure (paths : List String) (separator : String)\n  (h1 : paths.length \u2265 1) (h2 : paths.length \u2264 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url separator;\n  (result.startsWith \"<a href=\\\"/\\\">HOME</a>\" \u2228\n   result.startsWith \"<span class=\\\"active\\\">HOME</span>\") \u2227\n  result.endsWith \"</span>\" \u2227\n  (containsStr result \"<span class=\\\"active\\\">\") \u2227\n  ((result.split (\u00b7 == separator.get! 0)).length \u2265 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_bc_protocol_stripping (url : String)\n  (h : containsStr url \"http://\" \u2228 containsStr url \"https://\") :\n  let result := generate_bc url \"/\";\n  \u00accontainsStr result \"http://\" \u2227\n  \u00accontainsStr result \"https://\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_bc_long_segments (path : String)\n  (h : path.length > 30) :\n  let url := \"mysite.com/\" ++ path\n  let result := generate_bc url \" > \"\n  let spans := result.split (\u00b7 == '>')\n  let lastSpan := spans[spans.length - 1]'(by sorry)\n  let content := (lastSpan.split (\u00b7 == '>')).getLast!;\n  content.length < path.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_bc_href_validity (paths : List String)\n  (h1 : paths.length \u2265 2) (h2 : paths.length \u2264 5) :\n  let url := \"mysite.com/\" ++ String.intercalate \"/\" paths\n  let result := generate_bc url \" : \"\n  let segments := (result.split (\u00b7 == ':')).dropLast;\n  \u2200 s \u2208 segments,\n    s.startsWith \"<a href=\\\"/\\\"\" \u2227\n    s.endsWith \"</a>\" \u2227\n    (findStr s \"\\\">\").isSome :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/pictures/holidays.html\" \" : \"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval generate_bc \"www.microsoft.com/docs/index.htm\" \" * \"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval generate_bc \"mysite.com/very-long-url-to-make-a-silly-yet-meaningful-example/example.htm\" \" > \""
      }
    ]
  },
  "fvapps_001722.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validCharSet : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidMessage (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidCard (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDeck (d : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure PlayingCards where\n  cards : List String\n  chars : List Char\n  encode : String \u2192 Option (List String)\n  decode : List String \u2192 Option String"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def defaultPlayingCards : PlayingCards :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encode_decode_roundtrip\n  {pc : PlayingCards} {msg : String} (h : isValidMessage msg) :\n  match (pc.encode msg) with\n  | none => True\n  | some encoded =>\n    (pc.decode encoded = some msg) \u2227\n    (encoded.length = 52) \u2227\n    (encoded.eraseDups = encoded) \u2227\n    (\u2200 c, c \u2208 encoded \u2192 c \u2208 pc.cards)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decode_encode_roundtrip\n  {pc : PlayingCards} {deck : List String} (h : isValidDeck deck) :\n  match (pc.decode deck) with\n  | none => True\n  | some decoded => pc.encode decoded = some deck\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_message_returns_none\n  {pc : PlayingCards} {msg : String} :\n  (\u00ac msg.all (fun c => c \u2208 pc.chars)) \u2192\n  pc.encode msg = none\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_deck_returns_none\n  {pc : PlayingCards} {deck : List String} :\n  (deck.length \u2260 52 \u2228 deck.eraseDups.length \u2260 52) \u2192\n  pc.decode deck = none\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_message_valid\n  (pc : PlayingCards) :\n  pc.encode \"\" \u2260 none \u2227\n  pc.decode (Option.get! (pc.encode \"\")) = some \"\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001723.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def statement1 (s : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def statement2 (p : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def statement3 (s : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_solution (a b : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_numbers_not_prime {n : Nat} (h : n \u2264 1) :\n  is_prime n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_divisibility {n : Nat} (h\u2081 : n \u2265 2) (h\u2082 : n \u2264 1000) :\n  is_prime n = true \u2192 \u2200 i : Nat, 2 \u2264 i \u2227 i \u2264 n^(1/2) \u2192 n % i \u2260 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement1_even {s : Nat} (h : s % 2 = 0) :\n  statement1 s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement1_prime_diff {s : Nat} (h : is_prime (s - 2)) :\n  statement1 s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement2_type {p : Nat} (h\u2081 : p \u2265 4) (h\u2082 : p \u2264 100) :\n  statement2 p = true \u2228 statement2 p = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement2_composite {p : Nat} (h\u2081 : p \u2265 4) (h\u2082 : p \u2264 100) :\n  statement2 p = true \u2192 \u2203 i : Nat, 2 \u2264 i \u2227 i \u2264 p^(1/2) \u2227 p % i = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement3_type {s : Nat} (h\u2081 : s \u2265 4) (h\u2082 : s \u2264 100) :\n  statement3 s = true \u2228 statement3 s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem statement3_small {s : Nat} (h : s \u2264 3) :\n  statement3 s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_solution_type {a b : Nat} (h\u2081 : a \u2265 2) (h\u2082 : a \u2264 50) (h\u2083 : b \u2265 2) (h\u2084 : b \u2264 50) :\n  is_solution a b = true \u2228 is_solution a b = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_solution_constraints {a b : Nat} (h\u2081 : (a + b) % 2 = 0 \u2228 is_prime (a * b)) :\n  is_solution a b = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval statement1 6\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval statement2 15\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solution 5 4"
      }
    ]
  },
  "fvapps_001725.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toPostfix (expr : String) : String := sorry\n\ndef isOperator (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = '+' \u2228 c = '-' \u2228 c = '*' \u2228 c = '/' \u2228 c = '^'"
      },
      {
        "type": "sig",
        "string": "def evalStackSize (s : List Char) : Int :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc c =>\n    if isDigit c then acc + 1\n    else if isOperator c then acc - 1\n    else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_only_valid_chars {expr : String} :\n  \u2200 c, c \u2208 (toPostfix expr).data \u2192\n    c \u2208 expr.data \u2228 c.isDigit \u2228 c = '+' \u2228 c = '-' \u2228 c = '*' \u2228 c = '/' \u2228 c = '^' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_no_parens {expr : String} :\n  \u2200 c, c \u2208 (toPostfix expr).data \u2192 c \u2260 '(' \u2227 c \u2260 ')' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_preserves_operators {expr : String} :\n  List.length (List.filter isOperator expr.data) =\n  List.length (List.filter isOperator (toPostfix expr).data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_preserves_operands {expr : String} :\n  List.length (List.filter isDigit expr.data) =\n  List.length (List.filter isDigit (toPostfix expr).data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_final_stack {expr : String} :\n  evalStackSize (toPostfix expr).data = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem toPostfix_stack_invariant {expr : String} :\n  \u2200 (n : Nat), n \u2264 (toPostfix expr).data.length \u2192\n    evalStackSize ((toPostfix expr).data.take n) \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '275*+'\n-/\n#guard_msgs in\n#eval to_postfix \"2+7*5\"\n\n/-\ninfo: '33*71+/'\n-/\n#guard_msgs in\n#eval to_postfix \"3*3/(7+1)\"\n\n/-\ninfo: '562-9*+371-^+'\n-/\n#guard_msgs in\n#eval to_postfix \"5+(6-2)*9+3^(7-1)\""
      }
    ]
  },
  "fvapps_001727.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def trim : List (List Nat) \u2192 List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def next_gen : List (List Nat) \u2192 List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_generation : List (List Nat) \u2192 Nat \u2192 List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem static_block_pattern :\n  next_gen [[1,1], [1,1]] = [[1,1], [1,1]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_grid_static :\n  next_gen [[]] = [[]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_001729.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def interpreter (code: String) (iterations width height: Nat) : String := sorry\n\ndef countChar (s: String) (c: Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "sig",
        "string": "def makeZeroLine (width: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk (List.replicate width '0')"
      },
      {
        "type": "sig",
        "string": "def makeZeroGrid (width height: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.intercalate \"\\r\\n\" (List.replicate height (makeZeroLine width))"
      },
      {
        "type": "cond",
        "string": "theorem valid_dimensions (code: String) (iterations width height: Nat) :\n  let result := interpreter code iterations width height\n  let lines := result.splitOn \"\\r\\n\"\n  lines.length = height \u2227\n  lines.all (fun line => line.length = width)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_output_chars (code: String) (iterations width height: Nat) :\n  let result := interpreter code iterations width height\n  let lines := result.splitOn \"\\r\\n\"\n  lines.all (fun line => line.all (fun c => c = '0' \u2228 c = '1'))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_code (width height: Nat) :\n  let result := interpreter \"\" 0 width height\n  result = makeZeroGrid width height\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_iterations (code: String) (width height: Nat) :\n  let result := interpreter code 0 width height\n  result = makeZeroGrid width height\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_brackets (code: String) (iterations width height: Nat) :\n  (countChar code '[' = countChar code ']') \u2192\n  \u2203 x, x = interpreter code iterations width height\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '000000\\r\\n000000\\r\\n000000\\r\\n000000\\r\\n000000\\r\\n000000\\r\\n000000\\r\\n000000\\r\\n000000'\n-/\n#guard_msgs in\n#eval interpreter \"*e*e*e*es*es*ws*ws*w*w*w*n*n*n*ssss*s*s*s*\" 0 6 9\n\n/-\ninfo: '100\\r\\n100\\r\\n100'\n-/\n#guard_msgs in\n#eval interpreter \"*[s*]\" 10 3 3\n\n/-\ninfo: '00\\r\\n00'\n-/\n#guard_msgs in\n#eval interpreter \"\" 0 2 2"
      }
    ]
  },
  "fvapps_001730.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_price (coins : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_int (a b : Int) : Int := if a \u2264 b then a else b\n\ndef list_minimum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x :: xs => match xs with\n    | [] => x\n    | y :: ys => min_int x (list_minimum xs)"
      },
      {
        "type": "comment",
        "string": "-- First coin must be minimum of input list"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_price_first_coin_min {coins : List Int} (h : coins.length \u2265 2) :\n  coins \u2260 [] \u2192 coins.head! = list_minimum coins :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result must be either -1 or >= first coin"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_price_result_bounds {coins : List Int} (h : coins.length \u2265 2) :\n  let result := min_price coins\n  result \u2260 -1 \u2192 result \u2265 coins.head! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Input list should not be modified after operation"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_price_preserves_input {coins : List Int} (h : coins.length \u2265 2) :\n  let original := coins\n  let _ := min_price coins\n  coins = original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Two coprime numbers should always have a solution"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem coprime_has_solution {coins : List Int} (h : coins.length \u2265 2) :\n  Nat.gcd (coins.head!.toNat) (coins.get! 1).toNat = 1 \u2192\n  min_price coins \u2260 -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval min_price [3, 5]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval min_price [4, 6]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_price [2, 3]"
      }
    ]
  },
  "fvapps_001731.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def largest_palindrom_from (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numeric_palindrome (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_palindrom_from_is_palindrome (n : Nat)\n  (h1 : 1 \u2264 n) (h2 : n \u2264 10^6) :\n  let result := toString (largest_palindrom_from n)\n  result = reverseString result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_palindrom_from_uses_input_digits (n : Nat)\n  (h1 : 1 \u2264 n) (h2 : n \u2264 10^6) :\n  let result := toString (largest_palindrom_from n)\n  \u2200 d : Char, d \u2208 result.data \u2192 d \u2208 (toString n).data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numeric_palindrome_is_palindrome (nums : List Nat)\n  (h1 : nums.length \u2265 2) (h2 : nums.length \u2264 5)\n  (h3 : \u2200 x \u2208 nums, 2 \u2264 x \u2227 x \u2264 1000) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numeric_palindrome_bound (nums : List Nat)\n  (h1 : nums.length \u2265 2) (h2 : nums.length \u2264 5)\n  (h3 : \u2200 x \u2208 nums, 2 \u2264 x \u2227 x \u2264 1000) :\n  numeric_palindrome nums \u2264 nums.foldr (\u00b7*\u00b7) 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numeric_palindrome_with_ones (nums : List Nat)\n  (h1 : nums.length \u2265 3) (h2 : nums.length \u2264 6)\n  (h3 : \u2200 i, i < nums.length - 1 \u2192 nums.get \u27e8i, sorry\u27e9 = 1)\n  (h4 : nums.getLast? = some 2) :\n  let result := toString (numeric_palindrome nums)\n  result = reverseString result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_001732.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def recoverSecret (triplets : List (List Char)) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isConsistentWithTriplets (result : String) (triplets : List (List Char)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsAllChars (result : String) (triplets : List (List Char)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem recoverSecret_produces_string (triplets : List (List Char)) :\n  String.length (recoverSecret triplets) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem recoverSecret_contains_all_chars (triplets : List (List Char)) :\n  containsAllChars (recoverSecret triplets) triplets = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem recoverSecret_consistent_with_triplets (triplets : List (List Char)) :\n  isConsistentWithTriplets (recoverSecret triplets) triplets = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem recoverSecret_basic_case :\n  recoverSecret [['a', 'b', 'c'], ['a', 'c', 'd']] = \"abcd\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem recoverSecret_complex_case :\n  recoverSecret [\n    ['t','u','p'],\n    ['w','h','i'],\n    ['t','s','u'],\n    ['a','t','s'],\n    ['h','a','p'],\n    ['t','i','s'],\n    ['w','h','s']\n  ] = \"whatisup\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'whatisup'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"t\", \"u\", \"p\"], [\"w\", \"h\", \"i\"], [\"t\", \"s\", \"u\"], [\"a\", \"t\", \"s\"], [\"h\", \"a\", \"p\"], [\"t\", \"i\", \"s\"], [\"w\", \"h\", \"s\"]]\n\n/-\ninfo: 'abcd'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"a\", \"b\", \"c\"], [\"a\", \"c\", \"d\"]]\n\n/-\ninfo: 'great'\n-/\n#guard_msgs in\n#eval recoverSecret [[\"g\", \"r\", \"t\"], [\"e\", \"a\", \"t\"]]"
      }
    ]
  },
  "fvapps_001735.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def simplifiedFractions (n : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure Fraction where\n  num : Nat\n  denom : Nat"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def stringToFraction (s : String) : Fraction :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem fractions_are_valid {n : Nat} (h : n > 0) :\n  \u2200 frac, frac \u2208 simplifiedFractions n \u2192\n    let f := stringToFraction frac\n    0 < f.num \u2227 f.num < f.denom \u2227 f.denom \u2264 n \u2227 gcd f.num f.denom = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem fractions_are_unique {n : Nat} (h : n > 0) :\n  \u2200 x y, x \u2208 simplifiedFractions n \u2192 y \u2208 simplifiedFractions n \u2192\n    x = y \u2192 stringToFraction x = stringToFraction y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_simplified_fractions_included {n : Nat} (h : n > 0) :\n  \u2200 i j : Nat, 1 \u2264 i \u2192 i < j \u2192 j \u2264 n \u2192 gcd i j = 1 \u2192\n    \u2203 frac, frac \u2208 simplifiedFractions n \u2227 stringToFraction frac = \u27e8i, j\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_for_n_less_than_2 :\n  simplifiedFractions 1 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['1/2']\n-/\n#guard_msgs in\n#eval simplifiedFractions 2\n\n/-\ninfo: ['1/2', '1/3', '2/3']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(3)\n\n/-\ninfo: ['1/2', '1/3', '1/4', '2/3', '3/4']\n-/\n#guard_msgs in\n#eval sorted simplifiedFractions(4)"
      }
    ]
  },
  "fvapps_001743.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Time := String\nderiving Inhabited\n\ndef alertNames (names : List String) (times : List Time) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def parseTime (t : Time) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem alertNames_output_ordered (names : List String) (times : List Time) :\n  let result := alertNames names times\n  \u2200 i j, i < j \u2192 j < result.length \u2192 result[i]! \u2264 result[j]! := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alertNames_subset_of_input (names : List String) (times : List Time) :\n  let result := alertNames names times\n  \u2200 x \u2208 result, x \u2208 names := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alertNames_unique (names : List String) (times : List Time) :\n  let result := alertNames names times\n  List.Nodup result := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alertNames_violation_exists (names : List String) (times : List Time) :\n  let result := alertNames names times\n  \u2200 name \u2208 result,\n    let personTimes := (List.zip names times).filterMap\n      (fun p => if p.1 = name then some (parseTime p.2) else none)\n    List.length personTimes \u2265 3 \u2227\n    \u2203 t0 t1 t2,\n      t0 \u2208 personTimes \u2227\n      t1 \u2208 personTimes \u2227\n      t2 \u2208 personTimes \u2227\n      t0 < t1 \u2227 t1 < t2 \u2227\n      t2 - t0 \u2264 100 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alertNames_short_inputs (names : List String) (times : List Time) :\n  List.length names \u2264 2 \u2192 alertNames names times = [] := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: ['daniel']\n-/\n#guard_msgs in\n#eval alert_names [\"daniel\", \"daniel\", \"daniel\", \"luis\", \"luis\", \"luis\", \"luis\"] [\"10:00\", \"10:40\", \"11:00\", \"09:00\", \"11:00\", \"13:00\", \"15:00\"]\n\n/-\ninfo: ['bob']\n-/\n#guard_msgs in\n#eval alert_names [\"alice\", \"alice\", \"alice\", \"bob\", \"bob\", \"bob\", \"bob\"] [\"12:01\", \"12:00\", \"18:00\", \"21:00\", \"21:20\", \"21:30\", \"23:00\"]\n\n/-\ninfo: ['clare', 'leslie']\n-/\n#guard_msgs in\n#eval alert_names [\"leslie\", \"leslie\", \"leslie\", \"clare\", \"clare\", \"clare\", \"clare\"] [\"13:00\", \"13:20\", \"14:00\", \"18:00\", \"18:51\", \"19:30\", \"19:49\"]"
      }
    ]
  },
  "fvapps_001744.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix (\u03b1 : Type) := List (List \u03b1)"
      },
      {
        "type": "sig",
        "string": "def swim_time (grid : Matrix Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def can_reach (t : Nat) (grid : Matrix Nat) (i j : Nat) (visited : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swim_time_non_negative (grid : Matrix Nat) :\n  swim_time grid \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swim_time_bounds {grid : Matrix Nat} (h : grid.length > 0) :\n  swim_time grid \u2265 (grid.head!.head!) \u2227\n  swim_time grid \u2265 (grid.getLast!.getLast!) \u2227\n  swim_time grid \u2264 grid.length * grid.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swim_time_monotonic {grid grid2 : Matrix Nat} {i j : Nat}\n  (h1 : i < grid.length)\n  (h2 : j < grid.length)\n  (h3 : \u2200 x y, x \u2260 i \u2228 y \u2260 j \u2192\n    (grid.get! x).get! y = (grid2.get! x).get! y)\n  (h4 : (grid2.get! i).get! j = (grid.get! i).get! j + 1) :\n  swim_time grid2 \u2265 swim_time grid :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swim_time_path_exists (grid : Matrix Nat) :\n  can_reach (swim_time grid) grid 0 0 [] = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 2], [1, 3]]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval swim_time [[0, 1, 2, 3, 4], [24, 23, 22, 21, 5], [12, 13, 14, 15, 16], [11, 17, 18, 19, 20], [10, 9, 8, 7, 6]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval swim_time [[0, 1], [2, 3]]"
      }
    ]
  },
  "fvapps_001751.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_number_of_lis (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! < l[j]!"
      },
      {
        "type": "cond",
        "string": "theorem number_of_lis_properties (nums : List Int) :\n  let result := find_number_of_lis nums\n  result \u2265 0 \u2227\n  (nums = [] \u2192 result = 0)\n:= by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem constant_list_property {n : Nat} (x : Int) :\n  find_number_of_lis (List.replicate n x) = n\n:= by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strictly_increasing_property (nums : List Int) (h : nums \u2260 []) :\n  isSorted nums \u2192\n  find_number_of_lis nums = 1\n:= by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 3, 5, 4, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_number_of_lis [2, 2, 2, 2, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_number_of_lis [1, 2, 4, 3, 5, 4, 7, 2]"
      }
    ]
  },
  "fvapps_001764.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validTicTacToe (board : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasWin (board : List String) (player : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (board : List String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem board_dimensions {board : List String} (h : validTicTacToe board) :\n  board.length = 3 \u2227\n  (\u2200 row \u2208 board, row.length = 3) \u2227\n  (\u2200 row \u2208 board, \u2200 c \u2208 row.data, c = 'X' \u2228 c = 'O' \u2228 c = ' ') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  o_count \u2264 x_count \u2227 x_count - o_count \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem winner_invariants {board : List String} (h : validTicTacToe board) :\n  let x_count := countChar board 'X'\n  let o_count := countChar board 'O'\n  let x_wins := hasWin board 'X'\n  let o_wins := hasWin board 'O'\n  \u00ac(x_wins \u2227 o_wins) \u2227\n  \u00ac(x_wins \u2227 x_count \u2264 o_count) \u2227\n  \u00ac(o_wins \u2227 x_count \u2260 o_count) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"O  \", \"   \", \"   \"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \" X \", \"   \"]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval validTicTacToe [\"XOX\", \"O O\", \"XOX\"]"
      }
    ]
  },
  "fvapps_001766.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidTree (n : Nat) (edges : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Function that computes probability of frog being at target vertex after t steps -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def frogPosition (n : Nat) (edges : List (List Nat)) (t : Nat) (target : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_position_probability (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob := frogPosition n edges t target\n  0 \u2264 prob \u2227 prob \u2264 1 \u2227 1 \u2264 target \u2227 target \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_position_deterministic (n : Nat) (edges : List (List Nat))\n    (t : Nat) (target : Nat)\n    (h : isValidTree n edges = true) :\n  let prob1 := frogPosition n edges t target\n  let prob2 := frogPosition n edges t target\n  prob1 = prob2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_position_impossible_start (n : Nat) (edges : List (List Nat))\n    (target : Nat)\n    (h1 : isValidTree n edges = true)\n    (h2 : target \u2260 1) :\n  frogPosition n edges 0 target = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001772.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def HashMap := List"
      },
      {
        "type": "constr",
        "string": "structure RandomizedCollection where\n  idx : List (Int \u00d7 List Nat)\n  val : List Int\nderiving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def RandomizedCollection.insert : RandomizedCollection \u2192 Int \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def RandomizedCollection.remove : RandomizedCollection \u2192 Int \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def RandomizedCollection.getRandom : RandomizedCollection \u2192 Int := sorry\n\ndef find? (l : List (Int \u00d7 List Nat)) (k : Int) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  (l.find? (fun p => p.1 = k)).map (\u00b7.2)"
      },
      {
        "type": "sig",
        "string": "def sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x :: rest => x + sum rest"
      },
      {
        "type": "cond",
        "string": "theorem insert_property (rc : RandomizedCollection) (v : Int) :\n  let inserted := RandomizedCollection.insert rc v\n  (find? rc.idx v).isSome \u2192 inserted = false \u2227\n  (find? rc.idx v).isNone \u2192 inserted = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_property (rc : RandomizedCollection) (v : Int) :\n  let removed := RandomizedCollection.remove rc v\n  (find? rc.idx v).isSome \u2192 removed = true \u2227\n  (find? rc.idx v).isNone \u2192 removed = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem getRandom_property (rc : RandomizedCollection) :\n  rc.val.length > 0 \u2192\n  let randVal := RandomizedCollection.getRandom rc\n  (find? rc.idx randVal).isSome :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem internal_consistency (rc : RandomizedCollection) :\n  rc.val.length = sum (rc.idx.map (\u00b7.2.length)) \u2227\n  (\u2200 pair \u2208 rc.idx, \u2200 idx \u2208 pair.2, idx < rc.val.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_point_to_values (rc : RandomizedCollection) :\n  \u2200 v indices, find? rc.idx v = some indices \u2192\n  \u2200 idx \u2208 indices, rc.val.get? idx = some v :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem random_distribution (rc : RandomizedCollection) (samples : List Int)\n  (h : \u2200 s \u2208 samples, s = RandomizedCollection.getRandom rc) :\n  (\u2200 s \u2208 samples, (find? rc.idx s).isSome) \u2227\n  \u2203 subset : List Int, subset \u2260 [] \u2227 \u2200 x \u2208 subset, x \u2208 rc.val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_001774.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Tree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfDistancesInTree (n : Nat) (edges : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def degree (node : Nat) (edges : List (Nat \u00d7 Nat)) : Nat := sorry\n\ndef isLeafNode (node : Nat) (edges : List (Nat \u00d7 Nat)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  degree node edges = 1"
      },
      {
        "type": "cond",
        "string": "theorem sumOfDistances_output_length\n  (n : Nat) (edges : List (Nat \u00d7 Nat)) :\n  Tree n edges \u2192\n  List.length (sumOfDistancesInTree n edges) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumOfDistances_nonnegative\n  (n : Nat) (edges : List (Nat \u00d7 Nat))\n  (i : Nat) (h : i < List.length (sumOfDistancesInTree n edges)) :\n  Tree n edges \u2192\n  List.get! (sumOfDistancesInTree n edges) i \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumOfDistances_leaf_nodes_max\n  (n : Nat) (edges : List (Nat \u00d7 Nat))\n  (node : Nat) (h : node < n) :\n  Tree n edges \u2192\n  isLeafNode node edges \u2192\n  List.get! (sumOfDistancesInTree n edges) node \u2264\n    List.foldr max 0 (sumOfDistancesInTree n edges) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [8, 12, 6, 10, 10, 10]\n-/\n#guard_msgs in\n#eval sum_of_distances_in_tree 6 [[0, 1], [0, 2], [2, 3], [2, 4], [2, 5]]\n\n/-\ninfo: [2, 3, 3]\n-/\n#guard_msgs in\n#eval sum_of_distances_in_tree 3 [[0, 1], [0, 2]]\n\n/-\ninfo: [6, 4, 4, 6]\n-/\n#guard_msgs in\n#eval sum_of_distances_in_tree 4 [[0, 1], [1, 2], [2, 3]]"
      }
    ]
  },
  "fvapps_001780.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minimum_moves (grid : Array (Array Nat)) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any non-empty n\u00d7n grid with all zeros, there exists a valid path to reach bottom right -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_moves_empty_grid_reaches {n : Nat} (h : n \u2265 3) :\n  let grid := Array.mk (List.replicate n (Array.mk (List.replicate n (0:Nat))))\n  minimum_moves grid > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- For any n\u00d7n grid that is blocked except start position, no valid path exists -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_moves_blocked_grid_unreachable {n : Nat} (h : n \u2265 3) :\n  let blockedGrid := Array.mk (List.replicate n (Array.mk (List.replicate n (1:Nat))))\n  let grid := blockedGrid.set! 0 (blockedGrid[0]!.set! 0 0) |>.set! 0 (blockedGrid[0]!.set! 1 0)\n  minimum_moves grid = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For minimal 3\u00d73 grid of all zeros, there exists a valid path -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem min_moves_minimal_grid_reaches :\n  let grid := Array.mk [Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)]]\n  minimum_moves grid > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 11\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0]]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0]]"
      }
    ]
  },
  "fvapps_001783.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix (\u03b1 : Type) := List (List \u03b1)\n\ndef count_squares (matrix : Matrix Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h::t => h + listSum t"
      },
      {
        "type": "cond",
        "string": "theorem all_ones_matrix_squares {m n : Nat} (h1 : m > 0) (h2 : n > 0) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_squares matrix = m * n  -- simplified expected result for type checking\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_matrix_bounds (matrix : Matrix Int)\n  (h1 : matrix \u2260 []) :\n  let result := count_squares matrix\n  let m := matrix.length\n  let n := (List.head! matrix).length\n  result \u2265 0 \u2227\n  result \u2264 m * n * (min m n)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_all_ones {n : Nat} (h : n > 0) :\n  let matrix := List.replicate n (List.replicate n 1)\n  count_squares matrix = n * (n + 1) * (2 * n + 1) / 6\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_and_edge_cases :\n  count_squares [[0]] = 0 \u2227\n  count_squares [[1]] = 1 \u2227\n  count_squares [[0, 0], [0, 0]] = 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval count_squares [[0, 1, 1, 1], [1, 1, 1, 1], [0, 1, 1, 1]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_squares [[1, 0, 1], [1, 1, 0], [1, 1, 0]]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_squares [[1, 1], [1, 1]]"
      }
    ]
  },
  "fvapps_001784.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def fallingSquares (positions: List (List Int)) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry\n\nvariable (positions : List (List Int))\nvariable (result : List Int := fallingSquares positions)"
      },
      {
        "type": "other",
        "string": "/- Result length should match input length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_length :\n  result.length = positions.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/- Heights are monotonically non-decreasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem heights_monotonic {i : Nat} (h : i + 1 < result.length) :\n  match result[i]?, result[i+1]? with\n  | some x, some y => x \u2265 0 \u2227 y \u2265 x\n  | _, _ => False\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Each height is at least as tall as corresponding square -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem heights_geq_sides :\n  \u2200 (i : Nat) (h : i < positions.length),\n  match positions[i]?, result[i]? with\n  | some pos, some height =>\n    match pos.get? 1 with\n    | some side => height \u2265 side\n    | none => True\n  | _, _ => True\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Maximum height is bounded by sum of all side lengths -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_height_bound (sides : List Int) :\n  (\u2200 i < positions.length,\n    match positions[i]?, sides.get? i with\n    | some pos, some side => pos.get? 1 = some side\n    | _, _ => False) \u2192\n  result.length > 0 \u2192\n  \u2200 h \u2208 result, h \u2264 sides.foldl (\u00b7+\u00b7) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Results are non-negative integers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem results_nonneg :\n  \u2200 x \u2208 result, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [2, 5, 5]\n-/\n#guard_msgs in\n#eval fallingSquares [[1, 2], [2, 3], [6, 1]]\n\n/-\ninfo: [100, 100]\n-/\n#guard_msgs in\n#eval fallingSquares [[100, 100], [200, 100]]\n\n/-\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval fallingSquares [[1, 2], [3, 1]]"
      }
    ]
  },
  "fvapps_001786.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.sorted : List Nat \u2192 Bool\n| [] => true\n| [_] => true\n| x :: y :: xs => x \u2264 y \u2227 sorted (y :: xs)"
      },
      {
        "type": "sig",
        "string": "def pancakeSort : List Nat \u2192 List Nat\n| xs => sorry"
      },
      {
        "type": "sig",
        "string": "def applyFlips : List Nat \u2192 List Nat \u2192 List Nat\n| xs, [] => xs\n| xs, k::ks => applyFlips ((xs.take k).reverse ++ xs.drop k) ks"
      },
      {
        "type": "cond",
        "string": "theorem pancakeSort_produces_valid_flips (arr : List Nat) :\n  \u2200 k \u2208 pancakeSort arr, 1 \u2264 k \u2227 k \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pancakeSort_sorts (arr : List Nat) :\n  (applyFlips arr (pancakeSort arr)).sorted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pancakeSort_on_sorted_is_empty (arr : List Nat) :\n  arr.sorted \u2192 pancakeSort arr = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pancakeSort_reverses_reversed (arr : List Nat) :\n  arr = arr.reverse \u2192\n  (applyFlips arr (pancakeSort arr)).sorted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len pancake_sort(arr2)"
      }
    ]
  },
  "fvapps_001792.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def beautiful_array (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_permutation (arr : List Nat) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_beautiful_property (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem beautiful_array_correct (n : Nat) :\n  let arr := beautiful_array n\n  n > 0 \u2192 (\n    -- Length is correct\n    arr.length = n \u2227\n    -- Is permutation of 1..n\n    is_permutation arr n = true \u2227\n    -- Beautiful property holds\n    check_beautiful_property arr = true\n  ) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem beautiful_array_small_cases :\n  \u2200 n : Nat, n \u2264 5 \u2192 n > 0 \u2192\n    let arr := beautiful_array n\n    arr.length = n \u2227\n    is_permutation arr n = true \u2227\n    check_beautiful_property arr = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 4\n\n/-\ninfo: [1, 5, 3, 2, 4]\n-/\n#guard_msgs in\n#eval beautiful_array 5\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval beautiful_array 1"
      }
    ]
  },
  "fvapps_001797.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Graph := List (List Nat)"
      },
      {
        "type": "sig",
        "string": "def find_all_paths (g: Graph) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_dag (g: Graph) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def verify_paths (g: Graph) (paths: List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paths_start_end_valid (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  \u2200 p \u2208 paths, p.head? = some 0 \u2227\n               p.getLast? = some (g.length - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paths_follow_edges (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  \u2200 p \u2208 paths, \u2200 i < p.length - 1,\n    (p.get! (i+1)) \u2208 (g.get! (p.get! i)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paths_are_unique (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  \u2200 p\u2081 \u2208 paths, \u2200 p\u2082 \u2208 paths, p\u2081 = p\u2082 \u2228 p\u2081 \u2260 p\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem linear_graph_single_path (n: Nat) (h: n \u2265 2) :\n  let g : Graph := List.map (fun i => if i < n-1 then [i+1] else []) (List.range n)\n  let paths := find_all_paths g\n  paths.length = 1 \u2227 paths.head? = some (List.range n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem complete_dag_valid_paths (n: Nat) (h: n \u2265 3) :\n  let g : Graph := List.map (fun i => List.filter (fun j => j > i \u2227 j < n) (List.range n)) (List.range n)\n  let paths := find_all_paths g\n  verify_paths g paths = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: sorted(expected1)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph1)\n\n/-\ninfo: sorted(expected3)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph3)"
      }
    ]
  },
  "fvapps_001801.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def kthSymbol (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_row_is_zero (k : Nat) (h : k > 0) :\n  kthSymbol 1 k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_binary (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = 0 \u2228 kthSymbol n k = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_position_zero (n : Nat) (h : n > 1) :\n  kthSymbol n 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem kth_symbol_property (n k : Nat) (h1 : n > 0) (h2 : k > 0) :\n  kthSymbol n k = if n > 1 then countOnes (k-1) % 2 else 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 1 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval kth_symbol 2 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval kth_symbol 4 5"
      }
    ]
  },
  "fvapps_001807.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_bits (n : Nat) : Array Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat := sorry\n\ndef isPowerOfTwo (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  n > 0 \u2227 \u2203 k, n = 2^k"
      },
      {
        "type": "cond",
        "string": "theorem count_bits_length (n : Nat) (h : n \u2264 1000) :\n  (count_bits n).size = n + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_bits_value (n : Nat) (h : n \u2264 1000) (i : Nat) (h2 : i \u2264 n)\n  (h3 : i < (count_bits n).size) :\n  (count_bits n)[i]'h3 = countOnes i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_bits_power_of_two (n : Nat) (h : n \u2264 1000) (i : Nat) (h2 : i \u2264 n)\n  (h3 : i < (count_bits n).size) :\n  i > 0 \u2192 isPowerOfTwo i \u2192 (count_bits n)[i]'h3 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [0, 1, 1, 2, 1, 2]\n-/\n#guard_msgs in\n#eval count_bits 5\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval count_bits 0\n\n/-\ninfo: [0, 1, 1]\n-/\n#guard_msgs in\n#eval count_bits 2"
      }
    ]
  },
  "fvapps_001816.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def k_smallest_pairs (nums1 nums2 : List Int) (k : Nat) : List (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_smallest_pairs_size (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result \u2264 k \u2227 List.length result \u2264 List.length nums1 * List.length nums2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_smallest_pairs_elements (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  \u2200 pair \u2208 result, (List.elem pair.1 nums1 \u2227 List.elem pair.2 nums2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_smallest_pairs_ordered (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  \u2200 i, i + 1 < result.length \u2192\n    (result.get! i).1 + (result.get! i).2 \u2264 (result.get! (i+1)).1 + (result.get! (i+1)).2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_smallest_pairs_min_sum (nums1 nums2 : List Int) (k : Nat)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let result := k_smallest_pairs nums1 nums2 k\n  result \u2260 [] \u2192\n    (result.get! 0).1 + (result.get! 0).2 = nums1.get! 0 + nums2.get! 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_smallest_pairs_all_combinations (nums1 nums2 : List Int)\n  (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 \u2260 []) (h4 : nums2 \u2260 []) :\n  let k := List.length nums1 * List.length nums2\n  let result := k_smallest_pairs nums1 nums2 k\n  List.length result = k \u2227\n  \u2200 x \u2208 nums1, \u2200 y \u2208 nums2, \u2203 pair \u2208 result, pair = (x, y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001819.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Grid := List (List Nat)\n\ndef shortest_bridge (grid: Grid) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_grid (grid: Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_two_islands (grid: Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_bridge_non_negative\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_bridge_less_than_dimensions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  shortest_bridge grid < grid.length * (grid.head!).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_bridge_assumptions\n  (grid: Grid)\n  (h1: is_valid_grid grid = true)\n  (h2: has_two_islands grid = true) :\n  0 \u2264 shortest_bridge grid \u2227 shortest_bridge grid < grid.length * (grid.head!).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1], [1, 0]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval shortest_bridge [[0, 1, 0], [0, 0, 0], [0, 0, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval shortest_bridge [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]"
      }
    ]
  },
  "fvapps_001824.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def kClosest (points : List (List Int)) (k : Nat) : List (List Int) := sorry\n\ndef euclDistance (point : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match point with\n  | [x, y] => x*x + y*y\n  | _ => 0"
      },
      {
        "type": "other",
        "string": "/- For valid inputs, kClosest returns k points -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_correct_length {points : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k \u2264 points.length)\n  (h3 : \u2200 p \u2208 points, p.length = 2) :\n  (kClosest points k).length = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/- All points in the result were in the original list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_subset {points : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k \u2264 points.length)\n  (h3 : \u2200 p \u2208 points, p.length = 2) :\n  \u2200 p \u2208 kClosest points k, p \u2208 points :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The distances in the result are non-decreasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_distances_ordered {points : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k \u2264 points.length)\n  (h3 : \u2200 p \u2208 points, p.length = 2) :\n  \u2200 i j, i < j \u2192 j < (kClosest points k).length \u2192\n  euclDistance ((kClosest points k)[i]!) \u2264 euclDistance ((kClosest points k)[j]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The result contains the k closest points -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_optimal {points : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k \u2264 points.length)\n  (h3 : \u2200 p \u2208 points, p.length = 2) :\n  \u2200 p \u2208 kClosest points k, \u2200 q \u2208 points, q \u2209 kClosest points k \u2192\n  euclDistance p \u2264 euclDistance q :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- When k equals length, returns all points -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_full_list {points : List (List Int)}\n  (h : \u2200 p \u2208 points, p.length = 2) :\n  kClosest points points.length = points :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- When k = 1, returns point with minimum distance -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kClosest_k_one {points : List (List Int)}\n  (h1 : points.length > 0)\n  (h2 : \u2200 p \u2208 points, p.length = 2) :\n  \u2200 p \u2208 points,\n  euclDistance (List.head! (kClosest points 1)) \u2264 euclDistance p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [[-2, 2]]\n-/\n#guard_msgs in\n#eval kClosest [[1, 3], [-2, 2]] 1\n\n/-\ninfo: [[1, 1], [2, 2]]\n-/\n#guard_msgs in\n#eval kClosest [[1, 1], [2, 2], [3, 3]] 2"
      }
    ]
  },
  "fvapps_001832.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def prev_perm_opt1 (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_length_preserved {arr : List Int} (h : arr \u2260 []) :\n  (prev_perm_opt1 arr).length = arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sortFn : List Int \u2192 List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_same_elements {arr : List Int} (h : arr \u2260 []) :\n  list_sortFn (prev_perm_opt1 arr) = list_sortFn arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_sorted_unchanged {arr : List Int} (h : arr \u2260 []) :\n  arr = list_sortFn arr \u2192 prev_perm_opt1 arr = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_lexicographically_smaller {arr : List Int} (h : arr \u2260 []) :\n  prev_perm_opt1 arr \u2264 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_idempotent {arr : List Int} (h : arr \u2260 []) :\n  prev_perm_opt1 (prev_perm_opt1 arr) \u2264 prev_perm_opt1 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prev_perm_singleton_unchanged {arr : List Int} (h : arr.length = 1) :\n  prev_perm_opt1 arr = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 2, 1]\n\n/-\ninfo: [1, 7, 4, 6, 9]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [1, 9, 4, 6, 7]\n\n/-\ninfo: [1, 3, 1, 3]\n-/\n#guard_msgs in\n#eval prev_perm_opt1 [3, 1, 1, 3]"
      }
    ]
  },
  "fvapps_001861.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.isSubsetOf (l1 l2 : List \u03b1) [BEq \u03b1] : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def people_indexes (favorite_companies : List (List String)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem people_indexes_valid_indices\n  (favorite_companies : List (List String)) :\n  let result := people_indexes favorite_companies\n  \u2200 i \u2208 result, i < favorite_companies.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem people_indexes_empty :\n  people_indexes [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [0, 1, 4]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"google\", \"microsoft\"], [\"google\", \"facebook\"], [\"google\"], [\"amazon\"]]\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\", \"google\", \"facebook\"], [\"leetcode\", \"amazon\"], [\"facebook\", \"google\"]]\n\n/-\ninfo: [0, 1, 2, 3]\n-/\n#guard_msgs in\n#eval people_indexes [[\"leetcode\"], [\"google\"], [\"facebook\"], [\"amazon\"]]"
      }
    ]
  },
  "fvapps_001879.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shortestCompletingWord (licensePlate : String) (words : List String) : Option String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper functions"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsAllLetters (word : String) (plate : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_completing_word_in_wordlist (plate : String) (words : List String) :\n  \u2200 result, shortestCompletingWord plate words = some result \u2192\n  \u2203 w \u2208 words, w.toLower = result.toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem completes_license_plate (plate : String) (words : List String) :\n  \u2200 result, shortestCompletingWord plate words = some result \u2192\n  \u2200 c \u2208 plate.toList, isAlpha c \u2192 c.toLower \u2208 result.toLower.toList :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_shortest_valid_word (plate : String) (words : List String) :\n  \u2200 result, shortestCompletingWord plate words = some result \u2192\n  \u2200 w \u2208 words, containsAllLetters w plate \u2192 result.length \u2264 w.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem case_insensitive (plate : String) (words : List String) :\n  shortestCompletingWord plate.toLower words = shortestCompletingWord plate.toUpper words :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ignore_non_alpha (words : List String) :\n  shortestCompletingWord \"A1B2C3\" words = shortestCompletingWord \"ABC\" words :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'steps'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 PSt\" [\"step\", \"steps\", \"stripe\", \"stepple\"]\n\n/-\ninfo: 'pest'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"1s3 456\" [\"looks\", \"pest\", \"stew\", \"show\"]\n\n/-\ninfo: 'supper'\n-/\n#guard_msgs in\n#eval shortestCompletingWord \"PP\" [\"pair\", \"supper\"]"
      }
    ]
  },
  "fvapps_001880.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shoppingOffers (price : List Int) (special : List (List Int)) (needs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidInput (price : List Int) (special : List (List Int)) (needs : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shoppingOffers_result_nonnegative\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : \u2200 p \u2208 price, 1 \u2264 p \u2227 p \u2264 10)\n  (h_special : \u2200 s \u2208 special, \u2200 x \u2208 s, 0 \u2264 x \u2227 x \u2264 10)\n  (h_needs : \u2200 n \u2208 needs, 0 \u2264 n \u2227 n \u2264 10)\n  (h_valid : isValidInput price special needs) :\n  0 \u2264 shoppingOffers price special needs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shoppingOffers_not_exceed_list_price\n  (price : List Int) (special : List (List Int)) (needs : List Int)\n  (h_price : \u2200 p \u2208 price, 1 \u2264 p \u2227 p \u2264 10)\n  (h_special : \u2200 s \u2208 special, \u2200 x \u2208 s, 0 \u2264 x \u2227 x \u2264 10)\n  (h_needs : \u2200 n \u2208 needs, 0 \u2264 n \u2227 n \u2264 10)\n  (h_valid : isValidInput price special needs) :\n  shoppingOffers price special needs \u2264 (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shoppingOffers_no_special_equals_list_price\n  (price : List Int) (needs : List Int)\n  (h_price : \u2200 p \u2208 price, 1 \u2264 p \u2227 p \u2264 5)\n  (h_needs : \u2200 n \u2208 needs, 0 \u2264 n \u2227 n \u2264 5)\n  (h_valid : isValidInput price [] needs) :\n  shoppingOffers price [] needs = (List.zip price needs).foldl (fun acc (p, n) => acc + p * n) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 5] [[3, 0, 5], [1, 2, 10]] [3, 2]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval shoppingOffers [2, 3, 4] [[1, 1, 0, 4], [2, 2, 1, 9]] [1, 2, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval shoppingOffers [1, 1, 1] [[1, 1, 0, 3], [2, 2, 1, 5]] [1, 1, 1]"
      }
    ]
  },
  "fvapps_001887.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_closest_palindrome (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allCharsNumeric (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toString! (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Basic type constraints"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_outputs_nonempty {n : String}\n  (h : isPalindrome n = false)\n  : String.length (find_closest_palindrome n) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result should be numeric"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_is_numeric {n : String}\n  (h : isPalindrome n = false)\n  : allCharsNumeric (find_closest_palindrome n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result differs from input"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_different {n : String}\n  (h : isPalindrome n = false)\n  : find_closest_palindrome n \u2260 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result length within \u00b11 of input length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_length {n : String}\n  (h : isPalindrome n = false)\n  : (String.length (find_closest_palindrome n)).sub (String.length n) \u2264 1 \u2227\n    (String.length n).sub (String.length (find_closest_palindrome n)) \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is palindromic"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_is_palindrome {n : String}\n  (h : isPalindrome n = false)\n  : isPalindrome (find_closest_palindrome n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result doesn't start with '0'"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_no_leading_zero {n : String}\n  (h : isPalindrome n = false)\n  : String.get! (find_closest_palindrome n) 0 \u2260 '0' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is closest palindrome (minimality)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_closest_palindrome_is_minimal {n : String}\n  (h : isPalindrome n = false)\n  (h2 : String.length n \u2265 1)\n  : let result := find_closest_palindrome n\n    let diff := (toNat result).sub (toNat n)\n    \u2200 k : Nat,\n      k \u2260 toNat n \u2192\n      isPalindrome (toString! k) = true \u2192\n      (k.sub (toNat n)).min ((toNat n).sub k) \u2265 diff :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '121'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"123\"\n\n/-\ninfo: '999'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"1000\"\n\n/-\ninfo: '1001'\n-/\n#guard_msgs in\n#eval find_closest_palindrome \"999\""
      }
    ]
  },
  "fvapps_001888.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximalSquare (matrix : List (List String)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValid (matrix : List (List String)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  match matrix with\n  | [] => True\n  | h::t => \u2200 row \u2208 t, row.length = h.length"
      },
      {
        "type": "cond",
        "string": "theorem maximal_square_is_perfect_square (matrix : List (List String)) :\n  \u2203 n : Nat, maximalSquare matrix = n * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximal_square_bounded (matrix : List (List String)) :\n  match matrix with\n  | [] => maximalSquare matrix = 0\n  | h::t =>\n    let result := maximalSquare matrix\n    let maxDim := min matrix.length h.length\n    0 \u2264 result \u2227 result \u2264 maxDim * maxDim :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximal_square_all_zeros (matrix : List (List String))\n  (h\u2081 : matrix.length > 0)\n  (h\u2082 : \u2200 (i : Nat) (j : Nat), i < matrix.length \u2192\n        j < matrix.head!.length \u2192\n        (matrix.get! i).get! j = \"0\") :\n  maximalSquare matrix = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximal_square_all_ones (matrix : List (List String))\n  (h\u2081 : matrix.length > 0)\n  (h\u2082 : \u2200 (i : Nat) (j : Nat), i < matrix.length \u2192\n        j < matrix.head!.length \u2192\n        (matrix.get! i).get! j = \"1\") :\n  maximalSquare matrix = (min matrix.length matrix.head!.length) *\n                        (min matrix.length matrix.head!.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximal_square_padding (matrix : List (List String))\n  (h : matrix.length > 0) :\n  let padRow := fun (row : List String) => \"0\" :: (row ++ [\"0\"])\n  let paddedMatrix := (List.replicate (matrix.head!.length + 2) \"0\") ::\n                      (matrix.map padRow) ++\n                      [List.replicate (matrix.head!.length + 2) \"0\"]\n  maximalSquare matrix = maximalSquare paddedMatrix :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"0\", \"1\", \"0\", \"0\"], [\"1\", \"0\", \"1\", \"1\", \"1\"], [\"1\", \"1\", \"1\", \"1\", \"1\"], [\"1\", \"0\", \"0\", \"1\", \"0\"]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maximal_square [[\"1\", \"1\"], [\"1\", \"1\"]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maximal_square [[\"0\"]]"
      }
    ]
  },
  "fvapps_001889.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.sort (l : List \u03b1) (f : \u03b1 \u2192 \u03b1 \u2192 Bool) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def custom_sort_string (s t : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_preserved {s t : String} (h : s.length > 0) :\n  (custom_sort_string s t).length = t.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chars_preserved {s t : String} (h : s.length > 0) :\n  List.sort (custom_sort_string s t).data (\u00b7 \u2264 \u00b7) = List.sort t.data (\u00b7 \u2264 \u00b7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_pattern {s t : String} (h1 : s.length = 1) (h2 : t.length > 0) :\n  s.get 0 \u2208 t.data \u2192\n  (custom_sort_string s t).startsWith (String.mk (List.replicate (t.data.count (s.get 0)) (s.get 0))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent {s t : String} (h : s.length > 0) :\n  custom_sort_string s (custom_sort_string s t) = custom_sort_string s t :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'kqeep'\n-/\n#guard_msgs in\n#eval custom_sort_string \"kqep\" \"pekeq\"\n\n/-\ninfo: 'zyxw'\n-/\n#guard_msgs in\n#eval custom_sort_string \"abc\" \"zyxw\""
      }
    ]
  },
  "fvapps_001894.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Grid := List (List Nat)\n\ndef closed_island (grid : Grid) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => x + listSum xs"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_non_negative (grid: Grid) :\n  closed_island grid \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_less_than_zeros (grid: Grid) :\n  let countZeros (row: List Nat) := List.length (List.filter (\u03bb x => x = 0) row)\n  closed_island grid \u2264 listSum (List.map countZeros grid) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_small_grid (grid: Grid) (h1: grid.length < 3 \u2228 (List.head! grid).length < 3) :\n  closed_island grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_all_ones (grid: Grid)\n  (h: \u2200 row, List.elem row grid \u2192 \u2200 x, List.elem x row \u2192 x = 1) :\n  closed_island grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_all_zeros (grid: Grid)\n  (h: \u2200 row, List.elem row grid \u2192 \u2200 x, List.elem x row \u2192 x = 0) :\n  closed_island grid = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_simple_case_3x3 (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  closed_island grid = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_simple_case_4x4 (grid: Grid)\n  (h1: grid = [[1,1,1,1], [1,0,0,1], [1,0,0,1], [1,1,1,1]]) :\n  closed_island grid = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closed_island_mutates_to_ones (grid: Grid)\n  (h1: grid = [[1,1,1], [1,0,1], [1,1,1]]) :\n  let _ := closed_island grid\n  \u2200 row, List.elem row grid \u2192 \u2200 x, List.elem x row \u2192 x = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval closed_island [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval closed_island [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]]"
      }
    ]
  },
  "fvapps_001896.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_latest_time (digits: List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_time_str (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def time_to_minutes (time: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_time (hours mins: Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  hours < 24 \u2227 mins < 60"
      },
      {
        "type": "cond",
        "string": "theorem find_latest_time_gives_valid_result {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: \u2200 d \u2208 digits, d \u2264 9) :\n  is_valid_time_str (find_latest_time digits) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_latest_time_invalid_when_all_large {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: (\u2200 d \u2208 digits, d \u2265 6) \u2228 (\u2200 d \u2208 digits, d > 2)) :\n  find_latest_time digits = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_latest_time_zeros {digits: List Nat}\n  (h1: digits.length = 4)\n  (h2: \u2200 d \u2208 digits, d = 0) :\n  find_latest_time digits = \"00:00\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_latest_time_is_maximum {digits: List Nat} {result: String}\n  (h1: digits.length = 4)\n  (h2: \u2200 d \u2208 digits, d \u2264 9)\n  (h3: result = find_latest_time digits)\n  (h4: result \u2260 \"\") :\n  \u2200 (h1 h2 m1 m2: Nat),\n  h1 \u2208 digits \u2192 h2 \u2208 digits \u2192 m1 \u2208 digits \u2192 m2 \u2208 digits \u2192\n  is_valid_time (h1 * 10 + h2) (m1 * 10 + m2) \u2192\n  time_to_minutes result \u2265 (h1 * 10 + h2) * 60 + (m1 * 10 + m2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '23:41'\n-/\n#guard_msgs in\n#eval find_latest_time [1, 2, 3, 4]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval find_latest_time [5, 5, 5, 5]\n\n/-\ninfo: '00:00'\n-/\n#guard_msgs in\n#eval find_latest_time [0, 0, 0, 0]"
      }
    ]
  },
  "fvapps_001898.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef maxSumRangeQuery (nums : List Nat) (requests : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSortDescending (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumRangeQuery_bounded\n  (nums : List Nat)\n  (requests : List (Nat \u00d7 Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : \u2200 r \u2208 requests, r.1 \u2264 r.2 \u2227 r.2 < nums.length) :\n  0 \u2264 maxSumRangeQuery nums requests \u2227 maxSumRangeQuery nums requests < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumRangeQuery_deterministic\n  (nums : List Nat)\n  (requests : List (Nat \u00d7 Nat))\n  (h1 : nums.length > 0)\n  (h2 : requests.length > 0)\n  (h3 : \u2200 r \u2208 requests, r.1 \u2264 r.2 \u2227 r.2 < nums.length) :\n  maxSumRangeQuery nums requests = maxSumRangeQuery nums requests :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumRangeQuery_single_request\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  let requests := [(0, nums.length - 1)]\n  maxSumRangeQuery nums requests = (listSum nums) % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxSumRangeQuery_overlapping_bounds\n  (nums : List Nat)\n  (h1 : nums.length > 1) :\n  let requests := [(0, nums.length / 2), (nums.length / 4, nums.length - 1)]\n  let sorted_prefix := (listSortDescending nums).take nums.length\n  maxSumRangeQuery nums requests \u2264 (listSum sorted_prefix) * 2 % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5] [[1, 3], [0, 1]]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 6] [[0, 1]]\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval max_sum_range_query [1, 2, 3, 4, 5, 10] [[0, 2], [1, 3], [1, 1]]"
      }
    ]
  },
  "fvapps_001902.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def circularPermutation (n : Nat) (start : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listContains (l : List Nat) (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  n \u2208 l"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_length (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).length = 2^n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_starts_with_start (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  (circularPermutation n start).head! = start :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_contains_all_numbers (n : Nat) (start : Nat)\n  (h : start < 2^n) (k : Nat) (hk : k < 2^n):\n  listContains (circularPermutation n start) k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_adjacent_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) (i : Nat) (h2 : i < (circularPermutation n start).length - 1) :\n  countOnes ((circularPermutation n start)[i]! ^^^ (circularPermutation n start)[i+1]!) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_first_last_differ_by_one_bit (n : Nat) (start : Nat)\n  (h : start < 2^n) :\n  countOnes ((circularPermutation n start).head! ^^^ (circularPermutation n start).getLast!) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circularPermutation_invalid_start (n : Nat) (start : Nat)\n  (h : start \u2265 2^n) :\n  circularPermutation n start = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [3, 2, 0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 2 3\n\n/-\ninfo: [2, 6, 7, 5, 4, 0, 1, 3]\n-/\n#guard_msgs in\n#eval circular_permutation 3 2\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval circular_permutation 1 0"
      }
    ]
  },
  "fvapps_001905.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def longest_awesome_substring (s : String) : Nat := sorry\n\ndef is_digit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  '0' \u2264 c \u2227 c \u2264 '9'"
      },
      {
        "type": "sig",
        "string": "def string_reversal (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_length (s : String) (h : s.length > 0) (h2 : \u2200 c \u2208 s.data, is_digit c) :\n  let result := longest_awesome_substring s\n  1 \u2264 result \u2227 result \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_digit_awesome (d : Char) (n : Nat) (h : is_digit d) (h2 : n > 0) :\n  let s := String.mk (List.replicate n d)\n  longest_awesome_substring s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_awesome (s : String) (h : s.length > 0) (h2 : \u2200 c \u2208 s.data, is_digit c) :\n  let palindrome := s ++ string_reversal s\n  longest_awesome_substring palindrome = palindrome.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_odd_count_awesome (d1 d2 : Char) (h1 : is_digit d1) (h2 : is_digit d2) (h3 : d1 \u2260 d2) :\n  let s := String.mk (List.replicate 10 d1 ++ [d2])\n  longest_awesome_substring s \u2265 11 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reversal_invariant (s : String) (h : s.length > 0) (h2 : \u2200 c \u2208 s.data, is_digit c) :\n  longest_awesome_substring s = longest_awesome_substring (string_reversal s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval longest_awesome_substring \"3242415\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longest_awesome_substring \"12345678\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval longest_awesome_substring \"213123\""
      }
    ]
  },
  "fvapps_001920.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_valid_pairs (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def complement (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_valid_pairs_bounds {s : String} (h : s.length \u2265 3) (h2 : s.length \u2264 8) :\n  let n := s.length\n  0 \u2264 count_valid_pairs s \u2227 count_valid_pairs s \u2264 (n-1)*(n-2)/2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"010101\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_pairs \"11001100\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_valid_pairs \"0000\""
      }
    ]
  },
  "fvapps_001923.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_median_smoothing (n : Nat) (seq : List Nat) : Nat \u00d7 Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_sorted_window (arr : List Nat) (i : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 m then n - m else m - n"
      },
      {
        "type": "cond",
        "string": "theorem median_smoothing_properties\n  (n : Nat) (seq : List Nat)\n  (h1 : n \u2265 2)\n  (h2 : \u2200 x \u2208 seq, x \u2264 1)\n  (steps : Nat) (result : Option (List Nat)) :\n  let (steps', result') := solve_median_smoothing n seq\n  match result' with\n  | none => steps' < 0\n  | some res =>\n    steps' \u2265 0 \u2227\n    res.length = n \u2227\n    (\u2200 i, 0 < i \u2192 i < res.length - 1 \u2192 is_sorted_window res i) \u2227\n    (seq.length > 0 \u2192 res.length > 0 \u2192 List.head! res = List.head! seq) \u2227\n    (seq.length > 0 \u2192 res.length > 0 \u2192 List.getLast res (by sorry) = List.getLast seq (by sorry))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem constant_sequence_property\n  (n : Nat) (seq : List Nat)\n  (h1 : n \u2265 2)\n  (h2 : \u2200 x \u2208 seq, x = 0) :\n  let (steps, result) := solve_median_smoothing n seq\n  steps = 0 \u2227 result = some seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alternating_sequence_property\n  (n : Nat)\n  (h : n \u2265 3) :\n  let seq := List.map (fun i => i % 2) (List.range n)\n  let (steps, result) := solve_median_smoothing n seq\n  steps \u2265 0 \u2227\n  match result with\n  | none => False\n  | some res =>\n    \u2200 i, i + 1 < res.length \u2192\n    abs (List.get! res i) (List.get! res (i+1)) \u2264 1\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001924.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_path (n : Nat) (vectors : List (Int \u00d7 Int)) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def compute_final_position (vectors : List (Int \u00d7 Int)) (path : List Int) : Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def verify_path_length (x : Int) (y : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_correct_length {n : Nat} {vectors : List (Int \u00d7 Int)} :\n  let path := find_path n vectors\n  n = vectors.length \u2192 path.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_valid_elements {n : Nat} {vectors : List (Int \u00d7 Int)} :\n  let path := find_path n vectors\n  n = vectors.length \u2192 \u2200 x \u2208 path, x = 1 \u2228 x = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_path_bounded_result {n : Nat} {vectors : List (Int \u00d7 Int)} :\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  n = vectors.length \u2192\n  verify_path_length final_pos.1 final_pos.2 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_vector_axis_bounded {n : Nat} :\n  n > 0 \u2192 n \u2264 50 \u2192\n  let vectors := List.replicate n (1000000, 0)\n  let path := find_path n vectors\n  let final_pos := compute_final_position vectors path\n  verify_path_length final_pos.1 final_pos.2 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001934.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_rounds_needed (n : Nat) (rounds : List Nat) : Nat := sorry\n\ndef list_maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => xs.foldl Nat.max x"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | (x::xs) => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem min_rounds_needed_all_zeros {n : Nat}\n  (h : n \u2265 2) :\n  let rounds := List.replicate n 0\n  min_rounds_needed n rounds = (n-2) / (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_rounds_needed_equal_rounds {n : Nat} {x : Nat}\n  (h1 : n \u2265 2)\n  (h2 : x \u2265 1) :\n  let rounds := List.replicate n x\n  min_rounds_needed n rounds = max x ((n*x + n-2) / (n-1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_rounds_needed 3 [3, 2, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_rounds_needed 4 [2, 2, 2, 2]\n\n/-\ninfo: 1005000000\n-/\n#guard_msgs in\n#eval min_rounds_needed 3 [1000000000, 1000000000, 10000000]"
      }
    ]
  },
  "fvapps_001938.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_sum_permutation (n : Nat) : List Nat := sorry\n\ndef abs (n : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 m then n - m else m - n"
      },
      {
        "type": "sig",
        "string": "def isSortedList : List Nat \u2192 Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => x \u2264 y && isSortedList (y :: xs)"
      },
      {
        "type": "cond",
        "string": "theorem permutation_length {n : Nat} (h : 0 < n) (h2 : n \u2264 1000) :\n  let result := find_min_sum_permutation n\n  List.length result = n \u2227\n  isSortedList result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_property {n : Nat} (h : 0 < n) (h2 : n \u2264 1000) :\n  let result := find_min_sum_permutation n\n  let pairs := List.zip (List.take (List.length result - 1) result) (List.drop 1 result)\n  let cumsum := List.foldl (fun acc (p : Nat \u00d7 Nat) => acc + abs p.1 p.2) 0 pairs\n  let rev := List.reverse result\n  let rev_pairs := List.zip (List.take (List.length rev - 1) rev) (List.drop 1 rev)\n  let rev_sum := List.foldl (fun acc (p : Nat \u00d7 Nat) => acc + abs p.1 p.2) 0 rev_pairs\n  cumsum \u2264 rev_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: [3, 4, 1, 2]\n-/\n#guard_msgs in\n#eval find_min_sum_permutation 4\n\n/-\ninfo: [2, 1]\n-/\n#guard_msgs in\n#eval find_min_sum_permutation 2\n\n/-\ninfo: [3, 2, 1]\n-/\n#guard_msgs in\n#eval find_min_sum_permutation 3"
      }
    ]
  },
  "fvapps_001940.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_min_questions (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrimePower (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_questions_output_type (n : Nat) :\n  \u2200 x \u2208 find_min_questions n, x \u2264 n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_questions_ordering (n : Nat) :\n  \u2200 (l : List Nat), l = find_min_questions n \u2192\n    \u2200 i, i + 1 < l.length \u2192\n      l.get! i > l.get! (i + 1) \u2192\n      isPrime (l.get! (i + 1)) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_questions_empty_for_one :\n  find_min_questions 1 = [] := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_questions_nonempty_for_gt_one (n : Nat) :\n  n > 1 \u2192\n  (find_min_questions n).length > 0 \u2227\n  \u2200 x \u2208 find_min_questions n, x \u2265 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_min_questions_prime_powers (n : Nat) :\n  \u2200 x \u2208 find_min_questions n, isPrimePower x := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval len find_min_questions(4)\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval len find_min_questions(6)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_min_questions(1)"
      }
    ]
  },
  "fvapps_001943.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_palindrome_cuts (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_result_in_valid_range\n  (s : String)\n  (h : s.length > 0) :\n  let result := solve_palindrome_cuts s\n  result = none \u2228 result = some 1 \u2228 result = some 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_gives_impossible\n  (s : String)\n  (h : is_palindrome s = true) :\n  solve_palindrome_cuts s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_one_implies_palindrome_rotation\n  (s : String)\n  (h : solve_palindrome_cuts s = some 1) :\n  \u2203 i : Nat, i \u2264 s.length \u2227\n    is_palindrome (s.drop i ++ s.take i) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_preserves_length\n  (s : String)\n  (h : s.length > 0) :\n  (solve_palindrome_cuts s).isSome \u2192 s.length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_char_impossible\n  (c : Char)\n  (n : Nat)\n  (h : n > 0) :\n  solve_palindrome_cuts (String.mk (List.replicate n c)) = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_strings_impossible\n  (s : String)\n  (h : s.length \u2264 2) :\n  solve_palindrome_cuts s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"nolon\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"otto\"\n\n/-\ninfo: 'Impossible'\n-/\n#guard_msgs in\n#eval solve_palindrome_cuts \"qqqq\""
      }
    ]
  },
  "fvapps_001944.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_circle_arrangement (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def validate_arrangement (n : Nat) (result : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_string {n : Nat} :\n  \u2203 s : String, solve_circle_arrangement n = s\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_starts_with_yes_or_is_no {n : Nat} :\n  let result := solve_circle_arrangement n\n  result.startsWith \"YES\\n\" \u2228 result = \"NO\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_validates {n : Nat} :\n  validate_arrangement n (solve_circle_arrangement n) = true\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem validates_checks_length {n : Nat} {result : String} :\n  result \u2260 \"NO\" \u2192 validate_arrangement n result = true \u2192\n  \u2203 nums : List Nat,\n    -- Parse result into nums\n    nums.length = 2 * n\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem validates_checks_unique_nums {n : Nat} {result : String} :\n  result \u2260 \"NO\" \u2192 validate_arrangement n result = true \u2192\n  \u2203 nums : List Nat,\n    -- Parse result into nums\n    nums = List.range (2 * n)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem validates_checks_consecutive_sums {n : Nat} {result : String} :\n  result \u2260 \"NO\" \u2192 validate_arrangement n result = true \u2192\n  \u2203 nums : List Nat,\n    let doubled := nums ++ nums\n    \u2203 sums : List Nat,\n      \u2203 maxSum minSum : Nat,\n        maxSum - minSum \u2264 1\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'YES\\n2 3 6 1 4 5'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 3\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 4\n\n/-\ninfo: 'YES\\n2 1'\n-/\n#guard_msgs in\n#eval solve_circle_arrangement 1"
      }
    ]
  },
  "fvapps_001957.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unite_linked_lists (n : Nat) (arr : List (List Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_linked_list (n : Nat) (arr : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_lists (n : Nat) (arr : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_connected (n : Nat) (arr : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem unite_linked_lists_preserves_size {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr \u2265 2) :\n    List.length (unite_linked_lists n arr) = List.length arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unite_linked_lists_maintains_validity {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr \u2265 2) :\n    is_valid_linked_list n (unite_linked_lists n arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unite_linked_lists_creates_connection {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr \u2265 2) :\n    is_connected n (unite_linked_lists n arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unite_linked_lists_reduces_count {n : Nat} {arr : List (List Nat)}\n    (h1 : is_valid_linked_list n arr)\n    (h2 : count_lists n arr \u2265 2) :\n    count_lists n (unite_linked_lists n arr) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001959.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_winning_knights (n : Nat) (m : Nat) (fights : List (Nat \u00d7 Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_result (n : Nat) (fights : List (Nat \u00d7 Nat \u00d7 Nat)) (result : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_winning_knights_valid_output (n m : Nat) (fights : List (Nat \u00d7 Nat \u00d7 Nat))\n  (h1 : 1 \u2264 n) (h2 : n \u2264 100) (h3 : 1 \u2264 m) (h4 : m \u2264 100)\n  (h5 : \u2200 (f : Nat \u00d7 Nat \u00d7 Nat), f \u2208 fights \u2192\n    let (l,r,x) := f\n    1 \u2264 l \u2227 l \u2264 x \u2227 x \u2264 r \u2227 r \u2264 n) :\n  let result := find_winning_knights n m fights\n  result.length = n \u2227\n  (\u2200 x \u2208 result, 0 \u2264 x \u2227 x \u2264 n) \u2227\n  is_valid_result n fights result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_fight_winner_pattern (n : Nat) (h : 2 \u2264 n) (h2 : n \u2264 10) :\n  let fights := [(1, n, 1)]\n  let result := find_winning_knights n 1 fights\n  result.length = n \u2227\n  result.head? = some 0 \u2227\n  (\u2200 x \u2208 result.tail, x = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001968.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 10^9 + 7\n\ndef process_queries (s : String) (queries : List (Char \u00d7 String)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_queries_mod (s : String) (queries : List (Char \u00d7 String)) :\n  0 \u2264 process_queries s queries \u2227 process_queries s queries < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_queries_empty (s : String) :\n  process_queries s [] = (stringToNat s % MOD) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem process_queries_replacement (s : String) (d r : Char) :\n  s.length > 0 \u2192\n  s.contains d \u2192\n  process_queries s [(d,r.toString)] \u2260 stringToNat s % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 10031003\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"2\", \"00\"]]\n\n/-\ninfo: 1212\n-/\n#guard_msgs in\n#eval process_queries \"123123\" [[\"3\", \"\"]]\n\n/-\ninfo: 777\n-/\n#guard_msgs in\n#eval process_queries \"222\" [[\"2\", \"0\"], [\"0\", \"7\"]]"
      }
    ]
  },
  "fvapps_001971.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minInversions (n: Nat) (seq: List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countInversions (seq: List Int) : Nat := sorry\n\ndef absInt (i: Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if i < 0 then -i else i"
      },
      {
        "type": "sig",
        "string": "def rangeToInt (n: Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  (List.range n).map Int.ofNat"
      },
      {
        "type": "cond",
        "string": "theorem minInversions_nonnegative (n: Nat) (seq: List Int) :\n  minInversions n seq \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInversions_upper_bound (n: Nat) (seq: List Int) :\n  minInversions n seq \u2264 n * (n-1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minInversions_less_than_original {n: Nat} {seq: List Int} :\n  minInversions n seq \u2264 countInversions (seq.map absInt) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_sequence_bound {n: Nat} {seq: List Int}\n  (h: \u2200 x \u2208 seq, x = 0 \u2228 x = 1) :\n  minInversions n seq \u2264 n * n / 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_sequence_zero {n: Nat} :\n  minInversions n (rangeToInt n) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_inversions 2 [2, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_inversions 9 [-2, 0, -1, 0, -1, 2, 1, 0, -1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval min_inversions 9 [0, 0, 1, 1, 0, 0, 1, 0, 1]"
      }
    ]
  },
  "fvapps_001979.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_tree_edges (n : Nat) (edge_weights : List Nat) : List (Nat \u00d7 Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get maximum of a list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def list_max (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match xs with\n| [] => 0\n| (x::xs) => List.foldl Nat.max x xs"
      },
      {
        "type": "other",
        "string": "/- Main solve function signature -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def solve (n : Nat) (weights : List Nat) (roads : List (Nat \u00d7 Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Result of solve is always a natural number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_produces_nat (n : Nat) (weights : List Nat) (roads : List (Nat \u00d7 Nat \u00d7 Nat)) :\n  solve n weights roads \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- Result is at least the maximum weight in the input weights -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_at_least_max_weight (n : Nat) (weights : List Nat) (roads : List (Nat \u00d7 Nat \u00d7 Nat))\n  (h : weights \u2260 []) :\n  solve n weights roads \u2265 list_max weights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For singleton input, result equals the single weight -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_singleton (w : Nat) :\n  solve 1 [w] [] = w :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Properties for small cases (n \u2264 3) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_small_cases (n : Nat) (weights : List Nat) (h\u2081 : n \u2264 3) (h\u2082 : weights.length = n)\n  (h\u2083 : weights \u2260 []) :\n  let roads := List.map (fun i => (i + 1, i + 2, 1)) (List.range (n-1))\n  solve n weights roads \u2265 list_max weights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve 3 [1, 3, 3] [[1, 2, 2], [1, 3, 2]]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval solve 5 [6, 3, 2, 5, 0] [[1, 2, 10], [2, 3, 3], [2, 4, 1], [1, 5, 1]]\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval solve 1 [42] []"
      }
    ]
  },
  "fvapps_001980.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_array_operations (n : Nat) (arr : List Int) : List (Nat \u00d7 Nat \u00d7 List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def verify_operations (n : Nat) (arr : List Int) (ops : List (Nat \u00d7 Nat \u00d7 List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def valid_operation (n : Nat) (op : Nat \u00d7 Nat \u00d7 List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_array_operations_properties\n  (n : Nat) (arr : List Int) (h : 0 < n) (h2 : n \u2264 100) :\n  let ops := solve_array_operations n arr\n  List.length ops = 3 \u2227\n  (\u2200 op \u2208 ops, valid_operation n op) \u2227\n  verify_operations n arr ops :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_array_single_element\n  (n : Nat) (h : 0 < n) (h2 : n \u2264 100) :\n  let arr := [1]\n  let ops := solve_array_operations 1 arr\n  List.length ops = 3 \u2227\n  ops[0]! = (1, 1, [0]) \u2227\n  ops[1]! = (1, 1, [0]) \u2227\n  ops[2]! = (1, 1, [-1]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001981.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_alternative_math (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem solve_range (nums : List Nat) (h : nums \u2260 []) :\n  solve_alternative_math nums < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_single_elem (n : Nat) :\n  solve_alternative_math [n] = n % MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_deterministic (nums : List Nat) (h : nums.length \u2265 2) :\n  solve_alternative_math nums = solve_alternative_math nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_odd_length {nums : List Nat} (h1 : nums.length \u2265 3) (h2 : nums.length % 2 = 1) :\n  solve_alternative_math nums < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 6, 9, 12, 15]\n\n/-\ninfo: 1000000006\n-/\n#guard_msgs in\n#eval solve_alternative_math [3, 7, 5, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_alternative_math [1]"
      }
    ]
  },
  "fvapps_001984.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_lucky_number (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_non_negative\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  find_max_lucky_number nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < l.length \u2192 j < l.length \u2192 i < j \u2192 l[i]'sorry \u2264 l[j]'sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded_by_max_xor\n  (nums : List Nat)\n  (h : nums.length > 0) :\n  \u2200 max_xor : Nat,\n  (\u2200 i j, i < nums.length \u2192 j < nums.length \u2192 i < j \u2192\n    (nums[i]'sorry) ^^^ (nums[j]'sorry) \u2264 max_xor) \u2192\n  find_max_lucky_number nums \u2264 max_xor :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_zero\n  (x : Nat) :\n  find_max_lucky_number [x] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_invariant_unique\n  (nums : List Nat)\n  (h1 : nums.length \u2265 2)\n  (h2 : \u2200 i j, i < nums.length \u2192 j < nums.length \u2192 i \u2260 j \u2192 nums[i]'sorry \u2260 nums[j]'sorry) :\n  find_max_lucky_number nums = find_max_lucky_number nums.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_sequence_maintains_xor_pair\n  (nums : List Nat)\n  (h : nums.length \u2265 2)\n  (sorted : List Nat)\n  (h_sorted : isSorted sorted) :\n  let result := find_max_lucky_number sorted\n  \u2203 i j, i < sorted.length \u2227 j < sorted.length \u2227 i < j \u2227\n    result = (sorted[i]'sorry) ^^^ (sorted[j]'sorry) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_max_lucky_number [5, 2, 1, 4, 3]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval find_max_lucky_number [9, 8, 3, 5, 7]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_lucky_number [11, 10, 8]"
      }
    ]
  },
  "fvapps_001985.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def min_difference_sum (n k : Nat) (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difference_sum_non_negative\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k \u2264 n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difference_sum_upper_bound\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k \u2264 n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr \u2264 (maximum arr - minimum arr) * k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difference_sum_k_equals_n\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = n)\n  (h3 : n > 0) :\n  min_difference_sum n k arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_difference_sum_k_equals_one\n  {n k : Nat} {arr : List Int}\n  (h1 : n = arr.length)\n  (h2 : k = 1)\n  (h3 : n > 1) :\n  min_difference_sum n k arr = maximum arr - minimum arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_difference_sum 3 2 [1, 2, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_difference_sum 5 2 [3, -5, 3, -5, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_difference_sum 6 3 [4, 3, 4, 3, 2, 5]"
      }
    ]
  },
  "fvapps_001987.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_partition (n : Nat) (a b : Int) (xs : List Int) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_partition (n : Nat) (a b : Int) (xs : List Int) (result : Option (List Nat)) : Bool := sorry\n\ndef list_sum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::rest => x + list_sum rest"
      },
      {
        "type": "cond",
        "string": "theorem solve_partition_correct (n : Nat) (a b : Int) (xs : List Int) :\n  let result := solve_partition n a b xs\n  match result with\n  | none => True\n  | some partition =>\n    -- Partition has correct length\n    partition.length = n \u2227\n    -- Partition only contains 0s and 1s\n    (\u2200 x \u2208 partition, x = 0 \u2228 x = 1) \u2227\n    -- Partitioned groups sum to either a or b\n    let groups := List.zipWith (\u03bb (x : Int) (g : Nat) => if g = 0 then some x else none) xs partition\n    let sum0 := list_sum (groups.filterMap id)\n    let groups1 := List.zipWith (\u03bb (x : Int) (g : Nat) => if g = 1 then some x else none) xs partition\n    let sum1 := list_sum (groups1.filterMap id)\n    (sum0 = a \u2228 sum0 = b) \u2227 (sum1 = a \u2228 sum1 = b) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_partition_same_sum (n : Nat) (a : Int) (xs : List Int)\n  (h1 : n \u2265 2)\n  (h2 : a \u2265 3)\n  (h3 : xs.length = n)\n  (h4 : \u2200 x \u2208 xs, 1 \u2264 x \u2227 x \u2264 5)\n  (h5 : \u2200 x \u2208 xs, \u2203 y \u2208 xs, x + y = a) :\n  match solve_partition n a a xs with\n  | none => True\n  | some partition => \u2200 g \u2208 partition, g = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_001990.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_discount_shopping (n_discounts : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h :: t => h + list_sum t"
      },
      {
        "type": "sig",
        "string": "def list_sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_take (n : Nat) (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  match n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take n t"
      },
      {
        "type": "sig",
        "string": "def list_replicate (n : Nat) (v : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => []\n  | n+1 => v :: list_replicate n v"
      },
      {
        "type": "cond",
        "string": "theorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : \u2200 x \u2208 discount_values, 1 \u2264 x \u2227 x \u2264 10)\n  (h4 : \u2200 x \u2208 item_values, 1 \u2264 x \u2227 x \u2264 1000)\n  (h5 : 1 \u2264 n_discounts \u2227 n_discounts \u2264 5)\n  (h6 : 1 \u2264 n_items \u2227 n_items \u2264 20) :\n  0 \u2264 solve_discount_shopping n_discounts discount_values n_items item_values :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discount_shopping_upper_bound\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : \u2200 x \u2208 discount_values, 1 \u2264 x \u2227 x \u2264 10)\n  (h4 : \u2200 x \u2208 item_values, 1 \u2264 x \u2227 x \u2264 1000)\n  (h5 : 1 \u2264 n_discounts \u2227 n_discounts \u2264 5)\n  (h6 : 1 \u2264 n_items \u2227 n_items \u2264 20) :\n  solve_discount_shopping n_discounts discount_values n_items item_values \u2264 list_sum item_values :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discount_shopping_min_items\n  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : \u2200 x \u2208 discount_values, 1 \u2264 x \u2227 x \u2264 10)\n  (h4 : \u2200 x \u2208 item_values, 1 \u2264 x \u2227 x \u2264 1000)\n  (h5 : 1 \u2264 n_discounts \u2227 n_discounts \u2264 5)\n  (h6 : 1 \u2264 n_items \u2227 n_items \u2264 20) :\n  let sorted_items := list_sort item_values\n  let min_disc := match discount_values with\n                  | [] => n_items\n                  | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values \u2265 min_items_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_items_result\n  (n_discounts : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 \u2264 n_discounts \u2227 n_discounts \u2264 5)\n  (h2 : 1 \u2264 n_items \u2227 n_items \u2264 5)\n  (h3 : 1 \u2264 item_value \u2227 item_value \u2264 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values := list_replicate n_items item_value\n  let result := solve_discount_shopping n_discounts discount_values n_items item_values\n  result % item_value = 0 \u2227 result \u2264 item_value * n_items :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 200\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [2] 4 [50, 50, 100, 100]\n\n/-\ninfo: 150\n-/\n#guard_msgs in\n#eval solve_discount_shopping 2 [2, 3] 5 [50, 50, 50, 50, 50]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [1] 7 [1, 1, 1, 1, 1, 1, 1]"
      }
    ]
  },
  "fvapps_001992.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_biscuit_game (n : Nat) (biscuits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD : Nat := 998244353"
      },
      {
        "type": "cond",
        "string": "theorem output_range (n : Nat) (biscuits : List Nat) :\n  n > 0 \u2192 0 \u2264 solve_biscuit_game n biscuits \u2227 solve_biscuit_game n biscuits < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_biscuits (n : Nat) (len : Nat) :\n  n > 0 \u2192 solve_biscuit_game n (List.replicate len 0) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_distribution (n : Nat) (biscuits : List Nat) :\n  n > 0 \u2192 biscuits \u2260 [] \u2192\n  0 \u2264 solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) \u2227\n  solve_biscuit_game n (List.replicate biscuits.length (List.head! biscuits)) < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_player (n : Nat) (biscuits : List Nat) :\n  n = 1 \u2192 biscuits \u2260 [] \u2192 solve_biscuit_game n biscuits = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 1]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_biscuit_game 2 [1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_biscuit_game 5 [0, 0, 0, 0, 35]"
      }
    ]
  },
  "fvapps_002001.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def next_pow_2 (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_pow_2_properties (n: Nat) (h: n \u2265 1) :\n  let result := next_pow_2 n\n  result \u2265 n \u2227\n  result &&& (result - 1) = 0 \u2227\n  (result / 2 < n \u2228 n = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure SegTree where\n  size : Nat\n  answer : Array Nat\n  opened : Array Nat\n  closed : Array Nat\nderiving Inhabited"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def SegTree.build (self : SegTree) (s : String) : SegTree :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem segtree_build_properties (s : String) (h: s.length > 0) :\n  let tree := SegTree.build (SegTree.mk s.length #[] #[] #[]) s\n  tree.answer.size = 2 * tree.size \u2227\n  tree.opened.size = 2 * tree.size \u2227\n  tree.closed.size = 2 * tree.size \u2227\n  \u2200 i < s.length,\n    let idx := tree.size + i\n    (tree.opened.get! idx = 0 \u2228 tree.opened.get! idx = 1) \u2227\n    (tree.closed.get! idx = 0 \u2228 tree.closed.get! idx = 1) \u2227\n    tree.opened.get! idx + tree.closed.get! idx \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_brackets (s: String) (queries: List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_brackets_properties (s: String) (queries: List (Nat \u00d7 Nat))\n  (h\u2081: s.length > 0)\n  (h\u2082: \u2200 q, q \u2208 queries \u2192\n    q.1 > 0 \u2227 q.2 > 0 \u2227 q.1 \u2264 q.2 \u2227 q.2 \u2264 s.length) :\n  let results := solve_brackets s queries\n  (\u2200 r, r \u2208 results \u2192 r \u2265 0) \u2227\n  (\u2200 r, r \u2208 results \u2192 r % 2 = 0) \u2227\n  (\u2200 q r, q \u2208 queries \u2192 r \u2208 results \u2192\n    r \u2264 2 * (q.2 - q.1 + 1) \u2227\n    (r > 0 \u2192 q.2 - q.1 \u2265 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002008.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_min_bytecoins (n : Nat) (m : Nat) (votes : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_votes_for_party (votes : List (Nat \u00d7 Nat)) (party : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def max_list (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def increase_first_vote_cost (votes : List (Nat \u00d7 Nat)) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_min_bytecoins_non_negative (n m : Nat) (votes : List (Nat \u00d7 Nat))\n  (hn : n > 0) (hm : m \u2265 2)\n  (hvotes : \u2200 v \u2208 votes, v.1 \u2265 1 \u2227 v.1 \u2264 m \u2227 v.2 \u2264 1000) :\n  calculate_min_bytecoins n m votes \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_min_bytecoins_upper_bound (n m : Nat) (votes : List (Nat \u00d7 Nat))\n  (hn : n > 0) (hm : m \u2265 2)\n  (hvotes : \u2200 v \u2208 votes, v.1 \u2265 1 \u2227 v.1 \u2264 m \u2227 v.2 \u2264 1000) :\n  calculate_min_bytecoins n m votes \u2264 list_sum (votes.map (\u03bb v => v.2)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_min_bytecoins_party1_winning (n m : Nat) (votes : List (Nat \u00d7 Nat))\n  (hn : n > 0) (hm : m \u2265 2)\n  (hvotes : \u2200 v \u2208 votes, v.1 \u2265 1 \u2227 v.1 \u2264 m \u2227 v.2 \u2264 1000)\n  (party1_votes := count_votes_for_party votes 1)\n  (other_parties_max := max_list (List.range m |>.map (\u03bb i => count_votes_for_party votes (i + 2))))\n  (h_winning : party1_votes > other_parties_max) :\n  calculate_min_bytecoins n m votes = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_min_bytecoins_monotone (n m : Nat) (votes : List (Nat \u00d7 Nat))\n  (hn : n > 0) (hm : m \u2265 2)\n  (hvotes : \u2200 v \u2208 votes, v.1 \u2265 1 \u2227 v.1 \u2264 m \u2227 v.2 \u2264 1000)\n  (increased_votes := increase_first_vote_cost votes) :\n  calculate_min_bytecoins n m increased_votes \u2265 calculate_min_bytecoins n m votes :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 1 2 [[1, 100]]\n\n/-\ninfo: 500\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 400], [5, 900]]\n\n/-\ninfo: 600\n-/\n#guard_msgs in\n#eval calculate_min_bytecoins 5 5 [[2, 100], [3, 200], [4, 300], [5, 800], [5, 900]]"
      }
    ]
  },
  "fvapps_002012.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_bridge_problem (n m : Nat) (islands : List (List Int)) (bridges : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def verify_bridge_placement (bridges : List Int) (gaps : List (Int \u00d7 Int)) (result : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_to_nat_array (s : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure BridgeProblemInputs where\n  n : Nat\n  m : Nat\n  islands : List (List Int)\n  bridges : List Int"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def get_indices (result : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  if result = \"No\" then []\n  else string_to_nat_array (result.splitOn \"\\n\").head!"
      },
      {
        "type": "cond",
        "string": "theorem result_format_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  (result = \"No\") \u2228\n  (\u2203 nums : List Nat, result = s!\"Yes\\n{nums}\" \u2227 nums.length = n - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bridge_placement_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let gaps := List.range (n-1) |>.map (\u03bb i => (1, 1))  -- Simplified gaps for type checking\n  verify_bridge_placement bridges gaps result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bridge_indices_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :\n  let result := solve_bridge_problem n m islands bridges\n  let indices := get_indices result\n  result = \"No\" \u2228\n  (\u2200 i \u2208 indices, 1 \u2264 i \u2227 i \u2264 m) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'Yes\\n2 3 1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 4 4 [[1, 4], [7, 8], [9, 10], [12, 14]] [4, 5, 3, 8]\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 2 [[11, 14], [17, 18]] [2, 9]\n\n/-\ninfo: 'Yes\\n1'\n-/\n#guard_msgs in\n#eval solve_bridge_problem 2 1 [[1, 1], [1000000000000000000, 1000000000000000000]] [999999999999999999]"
      }
    ]
  },
  "fvapps_002014.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def color_jewelry (n : Nat) : Nat \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_bounds (n : Nat) (h : n \u2265 1) :\n  let (k, colors) := color_jewelry n\n  k = 1 \u2228 k = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem large_n_coloring (n : Nat) (h1 : n > 2) :\n  let (k, colors) := color_jewelry n\n  k = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002015.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Card := Nat"
      },
      {
        "type": "sig",
        "string": "def Pile := List Card"
      },
      {
        "type": "sig",
        "string": "def Game := List (Nat \u00d7 Pile)\n\ndef listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_card_game (g : Game) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_card_game_returns_tuple (g : Game) :\n  let (a, b) := solve_card_game g\n  a \u2265 0 \u2227 b \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_scores_equals_input (g : Game) :\n  let (a, b) := solve_card_game g\n  let total := g.map (fun p => listSum p.2) |> listSum\n  a + b = total :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_pile_split_correctly (g : Game) (h : g \u2260 []) :\n  let first := g.head h\n  let k := first.1 / 2 + 1\n  let first_sum := listSum first.2\n  let rest_sum := g.tail.map (fun p => listSum p.2) |> listSum\n  let (a, b) := solve_card_game g\n  a + b = first_sum + rest_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: (101, 10)\n-/\n#guard_msgs in\n#eval solve_card_game [[1, 100], [2, 1, 10]]\n\n/-\ninfo: (30, 15)\n-/\n#guard_msgs in\n#eval solve_card_game [[9, 2, 8, 6, 5, 9, 4, 7, 1, 3]]\n\n/-\ninfo: (18, 18)\n-/\n#guard_msgs in\n#eval solve_card_game [[3, 1, 3, 2], [3, 5, 4, 6], [2, 8, 7]]"
      }
    ]
  },
  "fvapps_002018.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (points : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_length {points : List (Nat \u00d7 Nat)} :\n  points.length = (solve points).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_bound {points : List (Nat \u00d7 Nat)} (i : Fin points.length) :\n  let (a, b) := points.get i\n  let sqrt_ab := sqrt (a * b)\n  \u2203 j : Fin (solve points).length, (solve points).get j \u2264 2 * sqrt_ab :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_nonneg {points : List (Nat \u00d7 Nat)} (i : Fin (solve points).length) :\n  0 \u2264 (solve points).get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_one_input :\n  solve [(1, 1)] = [0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve [(1, 4)]\n\n/-\ninfo: [12, 4]\n-/\n#guard_msgs in\n#eval solve [(10, 5), (3, 3)]\n\n/-\ninfo: [0, 0, 1, 1, 2]\n-/\n#guard_msgs in\n#eval solve [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]"
      }
    ]
  },
  "fvapps_002019.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_steps_to_lift (n : Nat) (weights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_steps_nonneg (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_odd_frequencies (weights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let freqs := weights.foldl (fun acc x =>\n    match acc.find? (fun p => p.1 = x) with\n    | some p => acc.erase p ++ [(p.1, p.2 + 1)]\n    | none => acc ++ [(x, 1)]\n    ) []\n  (freqs.filter (fun p => p.2 % 2 = 1)).length"
      },
      {
        "type": "cond",
        "string": "theorem min_steps_upper_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_steps_odd_freq_bound (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights \u2265 count_odd_frequencies weights :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_steps_to_lift 5 [1, 1, 2, 3, 3]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval min_steps_to_lift 4 [0, 1, 2, 3]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval min_steps_to_lift 13 [92, 194, 580495, 0, 10855, 41704, 13, 96429, 33, 213, 0, 92, 140599]"
      }
    ]
  },
  "fvapps_002020.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_hacknet (n A cf cm m : Nat) (skills : List Nat) : Nat \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_count {\u03b1} [BEq \u03b1] (p : \u03b1 \u2192 Bool) (l : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => (if p x then 1 else 0) + list_count p xs"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem solution_invariants {n A cf cm m : Nat} {skills ans : List Nat} {max_level : Nat}\n  (h : solve_hacknet n A cf cm m skills = (max_level, ans)) :\n  (ans.length = n) \u2227\n  (\u2200 x \u2208 ans, x \u2264 A) \u2227\n  (list_sum (List.map (\u03bb i => max 0 ((ans.get! i) - (skills.get! i)))\n    (List.range n)) \u2264 m) \u2227\n  (max_level = cf * (list_count (\u03bb x => x == A) ans) + cm * (List.foldl min A ans)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_money {n A cf : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A cf 1 0 skills = (0, skills) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem infinite_money {n A : Nat} {skills : List Nat}\n  (h : skills.length = n) :\n  solve_hacknet n A 1 1 (Nat.max A 0) skills =\n    (n + A, List.replicate n A) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002025.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findSmallestSubstring (m : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_substring_lowercase (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  \u2200 c \u2208 r.data, c.isLower \u2228 r = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_substring_sorted (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  isSorted r.data \u2228 r = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_substring_length (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  r.length \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_substring_chars_subset (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  \u2200 c \u2208 r.data, c \u2208 s.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_smallest_substring_alternating (m : Nat) :\n  let s := \"ababab\"\n  let r := findSmallestSubstring m s\n  \u2200 c \u2208 r.data, c = 'a' \u2228 c = 'b' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"cbabc\"\n\n/-\ninfo: 'aab'\n-/\n#guard_msgs in\n#eval find_smallest_substring 2 \"abcab\"\n\n/-\ninfo: 'aaabb'\n-/\n#guard_msgs in\n#eval find_smallest_substring 3 \"bcabcbaccba\""
      }
    ]
  },
  "fvapps_002027.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def stones_game (n : Nat) (stones : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stones_game_output_valid (n : Nat) (stones : List Nat) :\n  stones_game n stones = \"YES\" \u2228 stones_game n stones = \"NO\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stones_game_consistent (stones : List Nat) :\n  let n := stones.length\n  stones_game n stones = stones_game n stones :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- We can represent permutation invariance by showing that if we have\n    two lists with the same elements (possibly in different order),\n    they produce the same result -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem stones_game_permutation_invariant (stones stones_permuted : List Nat) :\n  stones.length = stones_permuted.length \u2192\n  stones_game stones.length stones = stones_game stones_permuted.length stones_permuted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stones_game_identical_stones (n : Nat) :\n  let stones := List.replicate n 1\n  stones_game n stones = stones_game n stones :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 1 [5]\n\n/-\ninfo: 'YES'\n-/\n#guard_msgs in\n#eval stones_game 2 [1, 2]\n\n/-\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval stones_game 3 [34, 44, 21]"
      }
    ]
  },
  "fvapps_002029.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Operation := List Int\n\ndef solve_sequence_ops (ops: List Operation) : List Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def running_sum (xs: List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => []\n  | x::xs' => x :: (running_sum xs').map (\u03bb s => s + x)"
      },
      {
        "type": "cond",
        "string": "theorem sequence_ops_result_properties (ops: List Operation) :\n  let result := solve_sequence_ops ops\n  (result.length = ops.length) \u2227\n  (\u2200 x \u2208 result, -1000000 \u2264 x \u2227 x \u2264 1000000) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_maintains_min_size (ops: List Operation) :\n  let remove_count := (ops.filter (\u03bb op => op.head! = 3)).length\n  remove_count \u2264 ops.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem append_only_averages (values: List Int)\n  (h1: \u2200 x \u2208 values, 1 \u2264 x \u2227 x \u2264 1000)\n  (h2: values.length \u2265 1 \u2227 values.length \u2264 10) :\n  let ops := values.map (\u03bb x => [2, x])\n  let result := solve_sequence_ops ops\n  \u2200 i: Nat, i < values.length \u2192\n    let sum := (running_sum values)[i]!\n    Float.abs (result[i]! - Float.ofInt (sum + 0) / Float.ofNat (i + 2)) < 0.000001 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002031.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def scheduleRepairs (requests : List (Nat \u00d7 Nat)) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isNonOverlapping (intervals : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def totalDurationPreserved (requests : List (Nat \u00d7 Nat)) (result : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allPositive (intervals : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem schedule_repairs_non_overlapping (requests : List (Nat \u00d7 Nat)) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem schedule_repairs_preserves_duration (requests : List (Nat \u00d7 Nat)) :\n  let result := scheduleRepairs requests\n  totalDurationPreserved requests result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem schedule_repairs_all_positive (requests : List (Nat \u00d7 Nat)) :\n  let result := scheduleRepairs requests\n  allPositive result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem schedule_repairs_preserves_length (requests : List (Nat \u00d7 Nat)) :\n  let result := scheduleRepairs requests\n  result.length = requests.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem schedule_repairs_handles_same_start (requests : List (Nat \u00d7 Nat))\n  (h : \u2200 p \u2208 requests, p.fst = 1) :\n  let result := scheduleRepairs requests\n  isNonOverlapping result = true \u2227 totalDurationPreserved requests result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [(9, 10), (1, 3), (4, 7)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(9, 2), (7, 3), (2, 4)]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval schedule_repairs [(1000000000, 1000000), (1000000000, 1000000), (100000000, 1000000), (1000000000, 1000000)]\n\n/-\ninfo: [(1, 5000000)]\n-/\n#guard_msgs in\n#eval schedule_repairs [(1, 5000000)]"
      }
    ]
  },
  "fvapps_002032.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_carrot_game (n : Nat) (A : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "abbrev min' (a b : Nat) : Nat := if a \u2264 b then a else b"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| x::xs => List.foldl Nat.max x xs"
      },
      {
        "type": "cond",
        "string": "theorem carrot_game_output_length {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  (solve_carrot_game n A).length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem carrot_game_max_preserved {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  list_maximum (solve_carrot_game n A) = list_maximum A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem carrot_game_elements_valid {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  \u2200 x \u2208 (solve_carrot_game n A),\n    x \u2208 A \u2228 \u2203 (i : Fin (A.length - 1)),\n      x = min' (A[i]) (A[i.val + 1]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem carrot_game_identical_elements {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n)\n  (h3 : \u2200 x \u2208 A, x = 5) :\n  \u2200 x \u2208 (solve_carrot_game n A), x = 5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem carrot_game_last_element_is_max {n : Nat} {A : List Nat}\n  (h : A.length > 0) (h2 : A.length = n) :\n  List.getLast! (solve_carrot_game n A) = list_maximum A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 3, 5, 5]\n-/\n#guard_msgs in\n#eval solve_carrot_game 4 [1, 2, 3, 5]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve_carrot_game 5 [1000000000, 1000000000, 1000000000, 1000000000, 1]\n\n/-\ninfo: [2, 8, 8]\n-/\n#guard_msgs in\n#eval solve_carrot_game 3 [2, 8, 2]"
      }
    ]
  },
  "fvapps_002035.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_valid_relationship (n : Nat) (relationships : List (Nat \u00d7 Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_love_triangles (n : Nat) (relationships : List (Nat \u00d7 Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def DisjointSet := Nat \u2192 Nat"
      },
      {
        "type": "sig",
        "string": "def DisjointSet.find_set (ds : DisjointSet) (x : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def DisjointSet.union (ds : DisjointSet) (x y : Nat) : DisjointSet :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_relationships_power_two (n : Nat) (h : n > 0) :\n  solve_love_triangles n [] = (2^(n-1)) % (10^9 + 7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_within_modulo_bounds (n : Nat) (relationships : List (Nat \u00d7 Nat \u00d7 Nat)) :\n  0 \u2264 solve_love_triangles n relationships \u2227\n  solve_love_triangles n relationships < 10^9 + 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contradictory_relationships_zero (n : Nat) (h : n \u2265 2) :\n  solve_love_triangles n [(1,2,1), (2,1,0)] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_modularity (n : Nat) (relationships : List (Nat \u00d7 Nat \u00d7 Nat)) :\n  solve_love_triangles n relationships % (10^9 + 7) =\n  solve_love_triangles n relationships :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_love_triangles 3 []\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 0)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_love_triangles 4 [(1, 2, 1), (2, 3, 1), (3, 4, 0), (4, 1, 1)]"
      }
    ]
  },
  "fvapps_002036.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_lost_milk (n: Nat) (cows: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_facing (cows: List Nat) (dir: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_lost_milk_non_negative (n: Nat) (cows: List Nat) :\n  min_lost_milk n cows \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_lost_milk_length (n: Nat) (cows: List Nat) :\n  cows.length = n \u2192 True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 4 [0, 0, 1, 0]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_lost_milk 5 [1, 0, 1, 0, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_lost_milk 2 [1, 0]"
      }
    ]
  },
  "fvapps_002039.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_startups (n : Nat) (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pow (base : Nat) (exp : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_in_valid_range (n : Nat) (arr : List Int) (h\u2081 : n > 0) (h\u2082 : arr.length = n) :\n  let result := solve_startups n arr\n  0 \u2264 result \u2227 result < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_length_matches_n (n : Nat) (arr : List Int)\n  (h\u2081 : n > 0) (h\u2082 : arr.length \u2265 1) :\n  let truncated := (List.replicate n arr.head!).take n\n  let result := solve_startups n truncated\n  0 \u2264 result \u2227 result < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_startups 3 [-1, -1, -1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_startups 2 [2, -1]\n\n/-\ninfo: 755808950\n-/\n#guard_msgs in\n#eval solve_startups 40 [3, 3, -1, -1, 4, 4, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 4, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3]"
      }
    ]
  },
  "fvapps_002040.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_valid_permutations (n : Nat) (edges : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial : Nat \u2192 Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n"
      },
      {
        "type": "cond",
        "string": "theorem valid_tree_construction (n : Nat) (edges : List (Nat \u00d7 Nat))\n  (h1 : is_valid_tree n edges) :\n  let result := count_valid_permutations n edges\n  \u2203 (k : Nat), result = k \u2227\n    k > 0 \u2227\n    k \u2264 n * factorial n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mod_result (n : Nat) (edges : List (Nat \u00d7 Nat)) :\n  let result := count_valid_permutations n edges\n  result < 998244353 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval count_valid_permutations 4 [(1, 2), (1, 3), (2, 4)]\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval count_valid_permutations n [(1, 2), (1, 3), (1, 4)]\n\n/-\ninfo: 144\n-/\n#guard_msgs in\n#eval count_valid_permutations 6 [(2, 1), (3, 2), (4, 1), (5, 4), (1, 6)]"
      }
    ]
  },
  "fvapps_002042.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (parents : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_tree_values (n : Nat) (parents : List Nat) (sums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_node_tree (n : Int) (h : n > 0) :\n  solve_tree_values 1 [] [n] = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem star_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n \u2265 2)\n  (h2 : parents.length = n - 1)\n  (h3 : \u2200 p \u2208 parents, p = 1)\n  (h4 : values.length = n)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if \u2203 v \u2208 values, v < 0\n  then result \u2265 -1\n  else result \u2265 values.get! 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem path_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n  (h1 : n \u2265 2)\n  (h2 : parents.length = n - 1)\n  (h3 : values.length = n)\n  (h4 : \u2200 (i : Nat), i < parents.length \u2192 parents.get! i \u2264 i + 1)\n  (h5 : is_valid_tree n parents = true) :\n  let result := solve_tree_values n parents values\n  if \u2203 v \u2208 values, v < 0\n  then result \u2265 -1\n  else result \u2265 values.get! 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 1, 1, 1] [1, -1, -1, -1, -1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 2, 3, 1] [1, -1, 2, -1, -1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_tree_values 3 [1, 2] [2, -1, 1]"
      }
    ]
  },
  "fvapps_002044.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_dominos (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | (h :: t) => h + list_sum t"
      },
      {
        "type": "cond",
        "string": "theorem solve_dominos_non_negative (n : Nat) (arr : List Nat) :\n  solve_dominos n arr \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_dominos_max_bound (n : Nat) (arr : List Nat) :\n  solve_dominos n arr \u2264 (list_sum arr / 2) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_dominos_single_column (h : Nat) :\n  solve_dominos 1 [h] = h / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_dominos_unit_heights (n : Nat) (arr : List Nat)\n  (h : \u2200 x \u2208 arr, x = 1) :\n  solve_dominos n arr = arr.length / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 5 [3, 2, 2, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_dominos 5 [1, 1, 1, 1, 1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_dominos 3 [3, 3, 3]"
      }
    ]
  },
  "fvapps_002045.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_max_beauty (n k : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => True\n| x::xs => match xs with\n  | [] => True\n  | y::_ => x \u2264 y \u2227 isSorted xs"
      },
      {
        "type": "cond",
        "string": "theorem get_max_beauty_properties\n  (n k : Nat) (arr : List Nat)\n  (h\u2081 : n > 0)\n  (h\u2082 : n \u2264 100)\n  (h\u2083 : k \u2264 100)\n  (h\u2084 : arr.length > 0)\n  (h\u2085 : arr.length \u2264 100)\n  (h\u2086 : \u2200 x \u2208 arr, x > 0 \u2227 x \u2264 1000)\n  (h\u2087 : isSorted arr)\n  (h\u2088 : arr.Nodup) :\n  let result := get_max_beauty n k arr\n  -- Result is positive\n  result > 0 \u2227\n  -- Result not larger than min value\n  result \u2264 arr.head! \u2227\n  -- Remainder property\n  (\u2200 x \u2208 arr, x % result \u2264 k) \u2227\n  -- Maximum value property\n  \u2200 i \u2208 List.range 10,\n    i < arr.head! - result + 1 \u2192\n    \u2203 x \u2208 arr, x % (result + i + 1) > k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_k_different_n\n  (arr : List Nat)\n  (h\u2081 : arr.length \u2265 2)\n  (h\u2082 : \u2200 x \u2208 arr, x > 0 \u2227 x \u2264 1000)\n  (h\u2083 : isSorted arr)\n  (h\u2084 : arr.Nodup) :\n  get_max_beauty arr.length 1 arr = get_max_beauty (arr.length - 1) 1 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_zero_case\n  (n : Nat)\n  (arr : List Nat)\n  (h\u2081 : n > 0 \u2227 n \u2264 10)\n  (h\u2082 : arr.length > 0 \u2227 arr.length \u2264 10)\n  (h\u2083 : \u2200 x \u2208 arr, x > 0 \u2227 x \u2264 1000) :\n  let result := get_max_beauty n 0 arr\n  \u2200 x \u2208 arr, x % result = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_beauty 6 1 [3, 6, 10, 12, 13, 16]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_beauty 5 3 [8, 21, 52, 15, 77]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval get_max_beauty 13 11 [55, 16, 26, 40, 84, 80, 48, 52, 25, 43, 75, 21, 58]"
      }
    ]
  },
  "fvapps_002046.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_possible (a b : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_ones (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem ones_diff_bounds (a b : String) :\n  is_possible a b \u2192\n  count_ones b \u2264 ((count_ones a + 1) / 2) * 2\n  \u2227\n  \u00acis_possible a b \u2192\n  count_ones b > ((count_ones a + 1) / 2) * 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_string_always_possible (s : String) :\n  is_possible s s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_possible (s zeros : String) :\n  (\u2200 c \u2208 zeros.data, c = '0') \u2192\n  s.length = zeros.length \u2192\n  is_possible s zeros :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_invariant (s ones : String) :\n  (\u2200 c \u2208 ones.data, c = '1') \u2192\n  is_possible s ones \u2194\n  ones.length \u2264 ((count_ones s + 1) / 2) * 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"01011\" \"0110\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_possible \"0011\" \"1110\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_possible \"1\" \"0\""
      }
    ]
  },
  "fvapps_002050.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_bitwise_and (n : Nat) (matrix : List (List Int)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitwiseOr (x y : Nat) : Nat := sorry\n\ndef intToNat (i : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if i < 0 then 0 else i.natAbs"
      },
      {
        "type": "cond",
        "string": "theorem solve_bitwise_and_zero_matrix\n  (n : Nat) :\n  let matrix := List.map (fun i => List.map (fun j => if i = j then -1 else 0) (List.range n)) (List.range n)\n  solve_bitwise_and n matrix = List.replicate n 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve_bitwise_and 1 [[-1]]\n\n/-\ninfo: [18, 18, 0]\n-/\n#guard_msgs in\n#eval solve_bitwise_and 3 [[-1, 18, 0], [18, -1, 0], [0, 0, -1]]\n\n/-\ninfo: [128, 180, 148, 160]\n-/\n#guard_msgs in\n#eval solve_bitwise_and 4 [[-1, 128, 128, 128], [128, -1, 148, 160], [128, 148, -1, 128], [128, 160, 128, -1]]"
      }
    ]
  },
  "fvapps_002053.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_substring_ways (s t : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_substring (s t : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_substring_ways_nonnegative (s t : String) :\n  0 \u2264 count_substring_ways s t \u2227 count_substring_ways s t < 1000000007 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem substring_gives_nonzero (s t : String)\n  (h : t.length > 0)\n  (h2 : is_substring s t = true) :\n  0 < count_substring_ways s t :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_substring_ways \"ababa\" \"aba\"\n\n/-\ninfo: 274201\n-/\n#guard_msgs in\n#eval count_substring_ways \"welcometoroundtwohundredandeightytwo\" \"d\"\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval count_substring_ways \"ddd\" \"d\""
      }
    ]
  },
  "fvapps_002054.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_fun_factor (n d m : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sum_list xs\n\ndef list_sum_of_largest (arr : List Nat) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sum_list ((List.toArray arr |>.qsort (\u00b7 \u2265 \u00b7) |>.toList).take n)"
      },
      {
        "type": "cond",
        "string": "theorem empty_above_m (n d : Nat) (arr : List Nat)\n  (h1 : 0 < n \u2227 n \u2264 100)\n  (h2 : 0 < d \u2227 d \u2264 10)\n  (h3 : arr.length = n)\n  (h4 : \u2200 x \u2208 arr, x < 1000) :\n  find_max_fun_factor n d 1000 arr = list_sum_of_largest arr n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element (n d m : Nat) (arr : List Nat)\n  (h1 : 0 < n \u2227 n \u2264 100)\n  (h2 : 0 < d \u2227 d \u2264 10)\n  (h3 : 0 \u2264 m \u2227 m \u2264 100)\n  (h4 : arr.length = n)\n  (h5 : \u2200 x \u2208 arr, x = 0) :\n  find_max_fun_factor n d m arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 48\n-/\n#guard_msgs in\n#eval find_max_fun_factor 5 2 11 #[8, 10, 15, 23, 5]\n\n/-\ninfo: 195\n-/\n#guard_msgs in\n#eval find_max_fun_factor 20 2 16 #[20, 5, 8, 2, 18, 16, 2, 16, 16, 1, 5, 16, 2, 13, 6, 16, 4, 17, 21, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_max_fun_factor 1 1 0 #[0]"
      }
    ]
  },
  "fvapps_002065.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_permutation_with_prefix_products (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_prefix_products (result : List Nat) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_permutation (result : List Nat) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_properties (n : Nat) (h : n \u2265 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length > 0 \u2192\n    result.length = n \u2227\n    result.head? = some 1 \u2227\n    result.getLast? = some n \u2227\n    is_valid_permutation result n \u2227\n    check_prefix_products result n \u2227\n    (is_prime n \u2228 n = 4) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_properties_empty (n : Nat) (h : n \u2265 2) :\n  let result := find_permutation_with_prefix_products n\n  result.length = 0 \u2192\n    \u00acis_prime n \u2227 n \u2260 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_numbers_have_solution (n : Nat) (h : is_prime n) :\n  let result := find_permutation_with_prefix_products n\n  result.length = n \u2227\n  check_prefix_products result n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem composite_numbers_have_no_solution (n : Nat) (h1 : n \u2265 6) (h2 : \u00acis_prime n) (h3 : n \u2260 4) :\n  (find_permutation_with_prefix_products n).length = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem special_case_four :\n  find_permutation_with_prefix_products 4 = [1, 3, 2, 4] \u2227\n  check_prefix_products [1, 3, 2, 4] 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: list(range(7))\n-/\n#guard_msgs in\n#eval sorted [1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len find_permutation_with_prefix_products(6)"
      }
    ]
  },
  "fvapps_002067.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_possible_partition (n k : Nat) (arr : List Nat) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getPrefixSums (arr : List Nat) (sizes : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sumList xs"
      },
      {
        "type": "cond",
        "string": "theorem validate_partition_properties {n k : Nat} {arr : List Nat}\n  (h1 : k \u2264 n)\n  (h2 : 0 < sumList arr) :\n  match check_possible_partition n k arr with\n  | none => True\n  | some result =>\n    -- Length matches k\n    result.length = k \u2227\n    -- Sizes sum to n\n    sumList result = n \u2227\n    -- All partitions have same sum\n    let partitions := getPrefixSums arr result;\n    match partitions with\n    | [] => True\n    | hd::_ => List.all partitions (fun x => x = hd) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_partition {arr : List Nat}\n  (h : 0 < arr.length) :\n  check_possible_partition arr.length (arr.length + 1) arr = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002070.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_binary_string (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_binary_string (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def MOD : Nat := 1000000007"
      },
      {
        "type": "cond",
        "string": "theorem solve_binary_string_properties {s : String} (h : is_binary_string s = true) :\n  let result := solve_binary_string s\n  0 \u2264 result \u2227 result \u2264 MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros {s : String} (h : \u2200 c \u2208 s.data, c = '0') :\n  solve_binary_string s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mod_property {s : String} (h : is_binary_string s = true) :\n  solve_binary_string s < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem split_ones {s : String} (h : is_binary_string s = true)\n  (h2 : s.data.filter (\u00b7 = '1') = []) :\n  solve_binary_string s = String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_binary_string \"000\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_binary_string \"0101\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_binary_string \"0001111\""
      }
    ]
  },
  "fvapps_002072.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def compute_lipschitz_sums (arr : List Nat) (queries : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_properties {arr : List Nat} (h: arr.length \u2265 2)\n  (hb: \u2200 x, x \u2208 arr \u2192 x \u2264 10^8) :\n  let result := compute_lipschitz_sums arr [(1, arr.length)]\n  result.length = 1 \u2227\n  \u2200 x, x \u2208 result \u2192 x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem constant_array_sums {arr : List Nat} {queries : List (Nat \u00d7 Nat)}\n  (h: arr.length \u2265 2)\n  (hconst: \u2200 (i j : Fin arr.length), arr[i] = arr[j])\n  (hq: \u2200 p, p \u2208 queries \u2192 p.1 \u2264 p.2 \u2227 p.2 \u2264 arr.length) :\n  \u2200 x, x \u2208 compute_lipschitz_sums arr queries \u2192 x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem query_bounds_valid {arr : List Nat} {queries : List (Nat \u00d7 Nat)}\n  (h: arr.length \u2265 2)\n  (hq: \u2200 p, p \u2208 queries \u2192 p.1 \u2264 p.2 \u2227 p.2 \u2264 arr.length) :\n  let results := compute_lipschitz_sums arr queries\n  results.length = queries.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonic_increasing_minimal {arr : List Nat}\n  (h: arr.length \u2265 2)\n  (hb: \u2200 x, x \u2208 arr \u2192 x \u2264 10) :\n  let sorted := sort arr\n  let orig_sum := (compute_lipschitz_sums arr [(1, arr.length)]).head!\n  let sorted_sum := (compute_lipschitz_sums sorted [(1, arr.length)]).head!\n  sorted_sum \u2264 orig_sum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: [17, 82, 23, 210]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [1, 5, 2, 9, 1, 3, 4, 2, 1, 7] [(2, 4), (3, 8), (7, 10), (1, 9)]\n\n/-\ninfo: [2, 0, 22, 59, 16, 8]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [5, 7, 7, 4, 6, 6, 2] [(1, 2), (2, 3), (2, 6), (1, 7), (4, 7), (3, 5)]\n\n/-\ninfo: [100000000, 100000000]\n-/\n#guard_msgs in\n#eval compute_lipschitz_sums [100000000, 0] [(1, 2), (1, 2)]"
      }
    ]
  },
  "fvapps_002076.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_xor_tree (n : Nat) (edges : List (Nat \u00d7 Nat)) (init : List Nat) (goal : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem basic_properties {n : Nat} {xor_values : List Nat}\n  (h1 : n \u2265 2) (h2 : n \u2264 20) (h3 : \u2200 x \u2208 xor_values, x = 0 \u2228 x = 1)\n  (h4 : xor_values.length = n) :\n  let edges := List.map (fun i => (i + 2, (i + 2)/2)) (List.range (n-1))\n  let goal := xor_values\n  let init := List.replicate n 0\n  let result := solve_xor_tree n edges init goal\n  (\u2200 x \u2208 result, x \u2265 1 \u2227 x \u2264 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_node_zero {init goal : List Nat}\n  (h1 : init.length = 1) (h2 : goal.length = 1)\n  (h3 : init = [0]) (h4 : goal = [0]) :\n  solve_xor_tree 1 [] init goal = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len solve_xor_tree(n, edges, init, goal)"
      }
    ]
  },
  "fvapps_002077.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calc_fraction (n : Int) : Int \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def fraction_to_str (frac : Int \u00d7 Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_fraction_valid_output {n : Int} (h : n \u2265 2) :\n  let (num, den) := calc_fraction n\n  den > 0 \u2227 gcd num.natAbs den.natAbs = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem fraction_to_str_format {n : Int} (h : n \u2265 2) :\n  let frac := calc_fraction n\n  let str := fraction_to_str frac\n  \u2203 num den : String,\n    str = num ++ \"/\" ++ den \u2227\n    (frac.1 = String.toInt! num) \u2227\n    (frac.2 = String.toInt! den) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_properties {a b : Int} (ha : a > 0) (hb : b > 0) :\n  let g := gcd a b\n  g > 0 \u2227 a % g = 0 \u2227 b % g = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_fraction_two :\n  calc_fraction 2 = (1, 6) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: '1/6'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(2)\n\n/-\ninfo: '7/30'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(3)\n\n/-\ninfo: '5/14'\n-/\n#guard_msgs in\n#eval fraction_to_str calc_fraction(6)"
      }
    ]
  },
  "fvapps_002090.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_max_chain_length (n m : Nat) (edges : List (Nat \u00d7 Nat)) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def to_adj_matrix (n : Nat) (edges : List (Nat \u00d7 Nat)) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_bipartite (adj : List (List Nat)) (colors : List Int) (start n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bipartite_property (n m : Nat) (edges : List (Nat \u00d7 Nat)) :\n  let result := solve_max_chain_length n m edges\n  let adj := to_adj_matrix n edges\n  \u2200 colors : List Int,\n  result \u2260 -1 \u2192\n  colors.length = n \u2192\n  (\u2200 i < n, colors[i]! = -1 \u2228 colors[i]! = 0 \u2228 colors[i]! = 1) \u2192\n  \u2200 start < n,\n  is_bipartite adj colors start n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_graph_property (n m : Nat) (edges : List (Nat \u00d7 Nat)) :\n  m = 0 \u2192\n  solve_max_chain_length n m edges = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_max_chain_length 5 4 [(1, 2), (2, 3), (3, 4), (3, 5)]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 6 [(1, 2), (2, 3), (1, 3), (3, 4), (2, 4), (1, 4)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_max_chain_length 4 2 [(1, 3), (2, 4)]"
      }
    ]
  },
  "fvapps_002095.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_psychos (n : Nat) (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_sorted_desc (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_strictly_sorted_asc (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_single_array :\n  solve_psychos 0 [] = 0 \u2227\n  \u2200 x : Nat, solve_psychos 1 [x] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_psychos_bounds :\n  \u2200 (n : Nat) (arr : List Nat),\n  arr.length = n \u2192\n  0 \u2264 solve_psychos n arr \u2227\n  solve_psychos n arr \u2264 n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_psychos 10 [10, 9, 7, 8, 6, 5, 3, 4, 2, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_psychos 6 [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_psychos 6 [6, 5, 4, 3, 2, 1]"
      }
    ]
  },
  "fvapps_002096.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_max_remainder (nums : List Nat) : Nat := sorry\n\ndef list_maximum (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match nums with\n  | [] => 0\n  | (x::xs) => List.foldl Nat.max x xs"
      },
      {
        "type": "sig",
        "string": "def list_sort (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_remainder_nonnegative (nums : List Nat) (h : nums \u2260 []) :\n  find_max_remainder nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_remainder_less_than_max (nums : List Nat) (h : nums \u2260 []) :\n  find_max_remainder nums < list_maximum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_remainder_order_independent (nums : List Nat) (h : nums \u2260 []) :\n  find_max_remainder nums = find_max_remainder (list_sort nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_remainder_duplicates_independent (nums : List Nat) (h : nums \u2260 []) :\n  find_max_remainder nums = find_max_remainder (nums.eraseDups) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_remainder_all_same (n : Nat) (nums : List Nat)\n  (h : nums = List.replicate (List.length nums) n) :\n  find_max_remainder nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_remainder [3, 4, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_max_remainder [1, 2, 4]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval find_max_remainder [4, 4, 10, 13, 28, 30, 41, 43, 58, 61, 70, 88]"
      }
    ]
  },
  "fvapps_002098.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tree_dfs (n : Nat) (parents : List Nat := []) : List Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (parents : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_node_properties (n : Nat) (h : n = 1) :\n  let result := solve_tree_dfs n\n  (result.length = 1) \u2227\n  (abs (result[0]! - 1.0) < 0.000001) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_tree_properties {n : Nat} {parents : List Nat}\n  (h : is_valid_tree parents = true) :\n  let result := solve_tree_dfs (n + 1) parents\n  (result.length = n + 1) \u2227\n  (abs (result[0]! - 1.0) < 0.000001) \u2227\n  (\u2200 i p, i < parents.length \u2192 p = parents[i]! \u2192 result[i+1]! > result[p-1]!) \u2227\n  (\u2200 x, x \u2208 result \u2192 x \u2265 1.0) \u2227\n  (\u2200 x, x \u2208 result \u2192 x \u2264 Float.ofNat (n + 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002102.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_distinct_names (words: List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_names_bounded (words: List String) (h: words \u2260 []) :\n  let result := count_distinct_names words\n  result \u2264 words.length \u2227 result \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to process a string by replacing kh sequences -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def processKh (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to process a string by replacing u with oo -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def processU (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to fully process a string with all replacements -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def processString (s: String) : String := processKh (processU s)\n\ndef unique {\u03b1} [BEq \u03b1] (l: List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (fun acc x => if acc.elem x then acc else x :: acc) []"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_distinct_names [\"mihail\", \"oolyana\", \"kooooper\", \"hoon\", \"ulyana\", \"koouper\", \"mikhail\", \"khun\", \"kuooper\", \"kkkhoon\"]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_names [\"hariton\", \"hkariton\", \"buoi\", \"kkkhariton\", \"boooi\", \"bui\", \"khariton\", \"boui\", \"boi\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_names [\"alex\", \"alex\"]"
      }
    ]
  },
  "fvapps_002103.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidTree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maxHappiness (n k : Nat) (edges : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxHappiness_valid_tree (n : Nat) (k : Nat)\n  (edges : List (Nat \u00d7 Nat)) :\n  isValidTree n edges \u2192 True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxHappiness_nonnegative (n : Nat) (k : Nat)\n  (edges : List (Nat \u00d7 Nat)) :\n  isValidTree n edges \u2192 maxHappiness n k edges \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxHappiness_zero_when_k_geq_n (n : Nat) (k : Nat)\n  (edges : List (Nat \u00d7 Nat)) :\n  isValidTree n edges \u2192\n  k \u2265 n \u2192\n  maxHappiness n k edges = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval max_happiness 7 4 [(1, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_happiness 4 1 [(1, 2), (1, 3), (2, 4)]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval max_happiness 8 5 [(7, 5), (1, 7), (6, 1), (3, 7), (8, 3), (2, 1), (4, 5)]"
      }
    ]
  },
  "fvapps_002126.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countValidBitSwaps (n : Nat) (a : String) (b : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringRepeat (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def makeAlternatingString (n : Nat) (startBit : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countValidBitSwaps_returns_natural (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  \u2203 (m : Nat), countValidBitSwaps n a b = m := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countValidBitSwaps_nonnegative (n : Nat) (a : String) (b : String)\n  (h1 : a.length = n) (h2 : b.length = n) :\n  countValidBitSwaps n a b \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countValidBitSwaps_all_zeros (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"0\" n) (stringRepeat \"0\" n) = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countValidBitSwaps_all_ones (n : Nat) :\n  countValidBitSwaps n (stringRepeat \"1\" n) (stringRepeat \"1\" n) = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countValidBitSwaps_alternating (n : Nat) :\n  let alt1 := makeAlternatingString n \"0\"\n  let alt2 := makeAlternatingString n \"1\"\n  \u2203 (m : Nat), countValidBitSwaps n alt1 alt2 = m := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 5 \"01011\" \"11001\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 6 \"011000\" \"010011\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_valid_bit_swaps 2 \"00\" \"00\""
      }
    ]
  },
  "fvapps_002129.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isRegular (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findRegularSubsequence (s : String) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_regular_subsequence_properties\n  (input : String)\n  (k : Nat)\n  (h1 : isRegular input = true)\n  (h2 : k % 2 = 0)\n  (h3 : k \u2264 input.length)\n  : let result := findRegularSubsequence input k\n    (result.length = k) \u2227\n    (isRegular result = true) \u2227\n    (\u2200 c, c \u2208 result.data \u2192 c = '(' \u2228 c = ')') \u2227\n    (result.data.count '(' = result.data.count ')') \u2227\n    (\u2200 c, c \u2208 result.data \u2192 c \u2208 input.data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_regular_subsequence_minimal_case :\n  (findRegularSubsequence \"()\" 2 = \"()\") \u2227\n  (findRegularSubsequence \"()\" 0 = \"\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002131.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sub (a b : List \u03b1) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sub_string (a b : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def subword (t : List Int) (ord_ar : List Int) (n : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bin_s (l r : Int) (f : Int \u2192 Bool) : Int := sorry\n\n@[simp] theorem sub_empty (a : List \u03b1) :\n  sub a [] = true := sorry\n\n@[simp] theorem sub_longer (a s : List \u03b1) :\n  List.length s > List.length a \u2192 sub a s = false := sorry\n\n@[simp] theorem sub_refl (a : List \u03b1) :\n  sub a a = true := sorry\n\n@[simp] theorem sub_string_empty (a b : String) :\n  sub_string a \"\" = true := sorry\n\n@[simp] theorem sub_string_longer (a b : String) :\n  String.length b > String.length a \u2192 sub_string a b = false := sorry\n\n@[simp] theorem sub_string_refl (a : String) :\n  sub_string a a = true :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem subword_length (t : List Int) (ord_ar : List Int) (n : Int) :\n  List.length t = List.length ord_ar \u2192\n  List.length (subword t ord_ar n) \u2264 List.length t :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bin_search_bounds (l r : Int) (f : Int \u2192 Bool) :\n  r > l + 1 \u2192\n  let res := bin_s l r f\n  l \u2264 res \u2227 res \u2264 r :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"ababcba\" \"abb\" [5, 3, 4, 1, 7, 6, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve \"bbbabb\" \"bb\" [1, 6, 3, 4, 2, 5]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve \"cacaccccccacccc\" \"cacc\" [10, 9, 14, 5, 1, 7, 15, 3, 6, 12, 4, 8, 11, 13, 2]"
      }
    ]
  },
  "fvapps_002137.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def BinaryIndexedTree : Type := Unit"
      },
      {
        "type": "sig",
        "string": "def BinaryIndexedTree.mk (n : Nat) : BinaryIndexedTree :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BinaryIndexedTree.add (self : BinaryIndexedTree) (i : Nat) (x : Int) : Unit :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BinaryIndexedTree.sum (self : BinaryIndexedTree) (i : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BinaryIndexedTree.sum_range (self : BinaryIndexedTree) (l r : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BinaryIndexedTree.data (self : BinaryIndexedTree) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve (n : Nat) (perm : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_init_properties (n : Nat) (h : n > 0) :\n  let bit := BinaryIndexedTree.mk n\n  List.length (BinaryIndexedTree.data bit) = n + 1 \u2227\n  List.all (BinaryIndexedTree.data bit) (\u03bb x => x = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_add_sum_properties (n i : Nat) (x : Int) (h1 : n > 0) (h2 : i > 0) (h3 : i \u2264 n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := BinaryIndexedTree.add bit i x\n  BinaryIndexedTree.sum bit i = x \u2227 BinaryIndexedTree.sum bit n = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_range_sum_property (n l r : Nat) (h1 : n > 0) (h2 : l > 0) (h3 : r > 0)\n  (h4 : l \u2264 r) (h5 : r \u2264 n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' := List.foldl (\u03bb b i => BinaryIndexedTree.add b (i + l) 1) bit (List.range (r - l + 1))\n  BinaryIndexedTree.sum_range bit' l r = r - l + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_properties (n : Nat) (perm : List Nat) (h1 : n > 0)\n  (h2 : List.length perm = n)\n  (h3 : \u2200 i j, i < j \u2192 perm.get! i < perm.get! j)\n  (h4 : List.Nodup perm) :\n  let result := solve n perm\n  List.length result = n \u2227\n  List.all result (\u03bb x => x \u2265 0) \u2227\n  result.head? = some 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1, 3, 6, 10]\n-/\n#guard_msgs in\n#eval solve 5 [5, 4, 3, 2, 1]\n\n/-\ninfo: [0, 0, 0]\n-/\n#guard_msgs in\n#eval solve 3 [1, 2, 3]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve 1 [1]"
      }
    ]
  },
  "fvapps_002138.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_max_popcount (l r : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def popcount (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_in_range (l r : Nat) :\n  let ordered_l := min l r\n  let ordered_r := max l r\n  let result := get_max_popcount ordered_l ordered_r\n  ordered_l \u2264 result \u2227 result \u2264 ordered_r :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_number (x : Nat) :\n  get_max_popcount x x = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_numbers (x : Nat) :\n  popcount (get_max_popcount x (x + 1)) \u2265 popcount x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval get_max_popcount 1 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_max_popcount 2 4\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval get_max_popcount 1 10"
      }
    ]
  },
  "fvapps_002140.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_tree_zeros (n : Nat) (edges : List (Nat \u00d7 Nat)) (values : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (list_max xs)"
      },
      {
        "type": "cond",
        "string": "theorem solve_tree_zeros_nonnegative (n : Nat) (edges : List (Nat \u00d7 Nat)) (values : List Int) :\n  solve_tree_zeros n edges values \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tree_zeros_finite (n : Nat) (edges : List (Nat \u00d7 Nat)) (values : List Int) :\n  \u2203 (k : Nat), solve_tree_zeros n edges values = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tree_zeros_bounds (n : Nat) (edges : List (Nat \u00d7 Nat)) (values : List Int) :\n  solve_tree_zeros n edges values \u2265 list_max (values.map Int.natAbs) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_zeros 3 [(1, 2), (1, 3)] [1, -1, 1]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_tree_zeros 5 [(2, 3), (4, 5), (2, 5), (1, 3)] [0, 2, 1, 4, 3]\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval solve_tree_zeros 10 [(5, 6), (8, 2), (9, 3), (4, 1), (6, 10), (9, 8), (7, 10), (7, 4), (5, 2)] [0, -6, -9, -1, -5, -4, -2, -7, -8, -3]"
      }
    ]
  },
  "fvapps_002153.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def create_maze (T : Nat) : Nat \u00d7 Nat \u00d7 Nat \u00d7 List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_door (door : Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat) (n m : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def are_doors_unique (doors : List (Nat \u00d7 Nat \u00d7 Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_maze_properties (T : Nat) (h : T > 0) (h2 : T \u2264 5) :\n  let (n, m, k, doors) := create_maze T\n  n = 4 \u2227\n  m = 4 \u2227\n  k \u2265 3 \u2227\n  k \u2264 6 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem large_maze_properties (T : Nat) (h : T \u2265 6^4) (h2 : T < 6^5) :\n  let (n, m, k, doors) := create_maze T\n  n = 12 \u2227\n  m = 12 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002159.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bitadd (idx : Nat) (val : Int) (bit : Array Int) : Array Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def bitsum (idx : Nat) (bit : Array Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem bitadd_inverse (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx (-val) (bitadd idx val bit)) = bitsum idx bit :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bitadd_retrieval (idx : Nat) (val : Int) (bit : Array Int) :\n  bitsum idx (bitadd idx val bit) = bitsum idx bit + val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002160.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def allocate_stadium_games (n m k : Nat) (games : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- For a valid allocation, the number of games per stadium for each team differs by at most 2 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem stadium_balance {n k : Nat} {games : List (Nat \u00d7 Nat)} {allocation : List Nat}\n  (h1 : n \u2265 2)\n  (h2 : k \u2265 1)\n  (h3 : allocation = allocate_stadium_games n games.length k games)\n  (h4 : \u2200 g, g \u2208 games \u2192 g.1 \u2264 n \u2227 g.2 \u2264 n \u2227 g.1 < g.2)\n  (h5 : \u2200 s, s \u2208 allocation \u2192 s \u2265 1 \u2227 s \u2264 k) :\n  \u2200 t, t \u2264 n \u2192\n    \u2200 s1 s2, s1 \u2264 k \u2192 s2 \u2264 k \u2192\n      Nat.sub ((games.zip allocation).filter (\u03bb p => (p.1.1 = t \u2228 p.1.2 = t) \u2227 p.2 = s1) |>.length)\n              ((games.zip allocation).filter (\u03bb p => (p.1.1 = t \u2228 p.1.2 = t) \u2227 p.2 = s2) |>.length) \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The allocation list has the same length as the input game list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem allocation_length_eq_games {n k : Nat} {games : List (Nat \u00d7 Nat)}\n  (h1 : n \u2265 2)\n  (h2 : k \u2265 1) :\n  (allocate_stadium_games n games.length k games).length = games.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Empty game list produces empty allocation -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_games_empty_allocation {n k : Nat}\n  (h1 : n \u2265 2)\n  (h2 : k \u2265 1) :\n  allocate_stadium_games n 0 k [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Basic case works: two teams, one game, one stadium -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem minimum_viable_case :\n  allocate_stadium_games 2 1 1 [(1, 2)] = [1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: m\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval len allocate_stadium_games(n, m, k, games)"
      }
    ]
  },
  "fvapps_002161.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_fireworks (n m d : Nat) (fireworks : List (Nat \u00d7 Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 m then n - m else m - n"
      },
      {
        "type": "cond",
        "string": "theorem fireworks_total_balls_bound {n m d : Nat} {fireworks : List (Nat \u00d7 Nat \u00d7 Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  solve_fireworks n m d fireworks \u2264 (fireworks.foldl (fun acc p => acc + p.2.1) 0) + n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem fireworks_timestamps_increasing {n m d : Nat} {fireworks : List (Nat \u00d7 Nat \u00d7 Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  \u2200 i, i < fireworks.length - 1 \u2192\n    (fireworks.get \u27e8i, sorry\u27e9).2.2 < (fireworks.get \u27e8i+1, sorry\u27e9).2.2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem fireworks_positions_valid {n m d : Nat} {fireworks : List (Nat \u00d7 Nat \u00d7 Nat)}\n  (h1 : m > 0) (h2 : n > 0) (h3 : d > 0) :\n  \u2200 f \u2208 fireworks, 1 \u2264 f.1 \u2227 f.1 \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_firework_result {n balls d : Nat} {pos : Nat}\n  (h1 : n > 0) (h2 : balls > 0) (h3 : d > 0) (h4 : pos = n/2) :\n  solve_fireworks n 1 d [(pos, balls, 1)] =\n    balls - (List.range n).foldl (fun m i => min m (abs pos (i + 1))) (abs pos 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: -31\n-/\n#guard_msgs in\n#eval solve_fireworks 50 3 1 [(49, 1, 1), (26, 1, 4), (6, 1, 10)]\n\n/-\ninfo: 1992\n-/\n#guard_msgs in\n#eval solve_fireworks 10 2 1 [(1, 1000, 4), (9, 1000, 4)]\n\n/-\ninfo: 418\n-/\n#guard_msgs in\n#eval solve_fireworks 30 8 2 [(15, 97, 3), (18, 64, 10), (20, 14, 20), (16, 18, 36), (10, 23, 45), (12, 60, 53), (17, 93, 71), (11, 49, 85)]"
      }
    ]
  },
  "fvapps_002172.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def compute_xor_sum (N : Nat) (A B : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- For any valid input arrays A and B of length N, the output is non-negative and less than 2^30 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_bounds (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) (h3 : \u2200 x \u2208 A, x \u2264 1000000) (h4 : \u2200 x \u2208 B, x \u2264 1000000) :\n  compute_xor_sum N A B \u2265 0 \u2227 compute_xor_sum N A B < 2^30 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/- The result is symmetric with respect to input arrays -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem symmetry (N : Nat) (A B : List Nat) (h1 : A.length = N) (h2 : B.length = N) :\n  compute_xor_sum N A B = compute_xor_sum N B A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- When both input arrays are identical, the result is even -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem identical_arrays (N : Nat) (A : List Nat) (h : A.length = N) :\n  2 \u2223 compute_xor_sum N A A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- When both input arrays contain only zeros, the result is zero -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem zero_arrays (N : Nat) :\n  compute_xor_sum N (List.replicate N 0) (List.replicate N 0) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 2 [1, 2] [3, 4]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval compute_xor_sum 6 [4, 6, 0, 0, 3, 3] [0, 5, 6, 5, 0, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval compute_xor_sum 5 [1, 2, 3, 4, 5] [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_002174.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_game (n : Nat) (r : Nat) (initial : List Int) (changes : List (Nat \u00d7 Int)) : List Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_average (l : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_update (l : List Int) (idx : Nat) (val : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def float_close (a b : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_game_result_length {n r : Nat} {initial : List Int} {changes : List (Nat \u00d7 Int)} :\n  initial.length = 2^n \u2192\n  (\u2200 change, change \u2208 changes \u2192 change.1 < 2^n) \u2192\n  (solve_game n r initial changes).length = r + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_game_averages {n r : Nat} {initial : List Int} {changes : List (Nat \u00d7 Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : \u2200 change, change \u2208 changes \u2192 change.1 < 2^n)\n  (i : Fin r)\n  (h_changes_length : changes.length > i.val)\n  (h_result_length : (solve_game n r initial changes).length > i.val) :\n  let updated := list_update initial ((changes.get \u27e8i.val, h_changes_length\u27e9).1) ((changes.get \u27e8i.val, h_changes_length\u27e9).2)\n  float_close ((solve_game n r initial changes).get \u27e8i.val, h_result_length\u27e9) (list_average updated) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_game_final_average {n r : Nat} {initial : List Int} {changes : List (Nat \u00d7 Int)}\n  (h_init : initial.length = 2^n)\n  (h_changes : \u2200 change, change \u2208 changes \u2192 change.1 < 2^n)\n  (h_r : r > 0)\n  (h_changes_length : changes.length \u2265 r)\n  (h_idx : r - 1 < changes.length)\n  (h_result_length : r < (solve_game n r initial changes).length) :\n  let final_update := list_update initial ((changes.get \u27e8r-1, h_idx\u27e9).1) ((changes.get \u27e8r-1, h_idx\u27e9).2)\n  float_close ((solve_game n r initial changes).get \u27e8r, h_result_length\u27e9) (list_average final_update) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_game_no_changes {n : Nat} {initial : List Int}\n  (h_init : initial.length = 2^n)\n  (h_all_ones : \u2200 x, x \u2208 initial \u2192 x = 1)\n  (h_length : 0 < (solve_game n 0 initial []).length) :\n  (solve_game n 0 initial []).length = 1 \u2227\n  float_close ((solve_game n 0 initial []).get \u27e80, h_length\u27e9) 1.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002175.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def MOD := 1000000007\n\ndef List.sort (l: List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve_minimized_workload (n: Nat) (p: Nat) (workloads: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem workload_result_bounds (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n \u2264 100) (h3: p > 0) (h4: p \u2264 10)\n  (h5: \u2200 w \u2208 workloads, w \u2265 0 \u2227 w \u2264 1000)\n  (h6: workloads.length > 0) (h7: workloads.length \u2264 100) :\n  let result := solve_minimized_workload n p workloads\n  0 \u2264 result \u2227 result < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem workload_p_one_special_case (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n \u2264 100) (h3: p = 1)\n  (h4: \u2200 w \u2208 workloads, w \u2265 0 \u2227 w \u2264 1000)\n  (h5: workloads.length > 0) (h6: workloads.length \u2264 100) :\n  let result := solve_minimized_workload n p workloads\n  result = n % 2 \u2227 (result = 0 \u2228 result = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem workload_sort_invariant (n p: Nat) (workloads: List Nat)\n  (h1: n > 0) (h2: n \u2264 100) (h3: p > 0) (h4: p \u2264 10)\n  (h5: \u2200 w \u2208 workloads, w \u2265 0 \u2227 w \u2264 1000)\n  (h6: workloads.length > 0) (h7: workloads.length \u2264 100) :\n  solve_minimized_workload n p workloads =\n  solve_minimized_workload n p (List.sort workloads) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem workload_length_matches_n (p: Nat) (workloads: List Nat)\n  (h1: p > 0) (h2: p \u2264 10)\n  (h3: \u2200 w \u2208 workloads, w \u2265 0 \u2227 w \u2264 1000)\n  (h4: workloads.length > 0) (h5: workloads.length \u2264 100) :\n  let n := workloads.length\n  let result := solve_minimized_workload n p workloads\n  0 \u2264 result \u2227 result < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_minimized_workload 5 2 [2, 3, 4, 4, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_minimized_workload 3 1 [2, 10, 1000]\n\n/-\ninfo: 146981438\n-/\n#guard_msgs in\n#eval solve_minimized_workload 4 5 [0, 1, 1, 100]"
      }
    ]
  },
  "fvapps_002177.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_cyclic_permutation (n m q : Nat) (p : List Nat) (a : List Nat) (queries : List (Nat \u00d7 Nat)) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid_binary_string {n m q : Nat} {p a : List Nat} {queries : List (Nat \u00d7 Nat)}\n  (h\u2081 : n > 0) (h\u2082 : m > 0) (h\u2083 : q > 0)\n  (h\u2084 : p.length = n) (h\u2085 : a.length = m)\n  (h\u2086 : queries.length = q)\n  (h\u2087 : \u2200 x \u2208 p, 1 \u2264 x \u2227 x \u2264 n)\n  (h\u2088 : \u2200 x \u2208 a, 1 \u2264 x \u2227 x \u2264 n)\n  (h\u2089 : \u2200 q \u2208 queries, 1 \u2264 q.1 \u2227 q.1 \u2264 m \u2227 1 \u2264 q.2 \u2227 q.2 \u2264 m \u2227 q.1 \u2264 q.2) :\n  let result := solve_cyclic_permutation n m q p a queries\n  result.length = q \u2227 \u2200 c \u2208 result.data, c = '0' \u2228 c = '1' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem query_ordering_invariant {n m q : Nat} {p a : List Nat} {queries : List (Nat \u00d7 Nat)}\n  (h\u2081 : n > 0) (h\u2082 : m > 0) (h\u2083 : q > 0)\n  (h\u2084 : p.length = n) (h\u2085 : a.length = m)\n  (h\u2086 : queries.length = q)\n  (h\u2087 : \u2200 x \u2208 p, 1 \u2264 x \u2227 x \u2264 n)\n  (h\u2088 : \u2200 x \u2208 a, 1 \u2264 x \u2227 x \u2264 n)\n  (h\u2089 : \u2200 q \u2208 queries, 1 \u2264 q.1 \u2227 q.1 \u2264 m \u2227 1 \u2264 q.2 \u2227 q.2 \u2264 m \u2227 q.1 \u2264 q.2) :\n  solve_cyclic_permutation n m q p a queries =\n  String.reverse (solve_cyclic_permutation n m q p a (List.reverse queries)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: '110'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 3 6 3 [2, 1, 3] [1, 2, 3, 1, 2, 3] [[1, 5], [2, 6], [3, 5]]\n\n/-\ninfo: '010'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 2 4 3 [2, 1] [1, 1, 2, 2] [[1, 2], [2, 3], [3, 4]]\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval solve_cyclic_permutation 1 1 1 [1] [1] [[1, 1]]"
      }
    ]
  },
  "fvapps_002178.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countEmptyParabolas (points : List (Int \u00d7 Int)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def makeParabolaPoints (a h k : Int) (n : Nat) : List (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countEmptyParabolas_nonnegative (points : List (Int \u00d7 Int)) :\n  countEmptyParabolas points \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countEmptyParabolas_single_point (point : Int \u00d7 Int) :\n  countEmptyParabolas [point] = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countEmptyParabolas_through_parabola_points (a h k : Int) :\n  a \u2260 0 \u2192\n  countEmptyParabolas (makeParabolaPoints a h k 5) \u2265 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countEmptyParabolas_duplicate_x_values (points : List (Int \u00d7 Int)) :\n  let deduped := points.foldl (fun acc (x, y) =>\n    match acc.find? (fun (x', _) => x' = x) with\n    | none => acc ++ [(x, y)]\n    | some (x', y') =>\n      if y > y'\n      then acc.map (fun (x'', y'') => if x'' = x then (x, y) else (x'', y''))\n      else acc\n    ) []\n  countEmptyParabolas points = countEmptyParabolas deduped := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-1, 0), (0, 2), (1, 0)]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, -1)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_empty_parabolas [(-751115, -925948)]"
      }
    ]
  },
  "fvapps_002179.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_positive (a b : Nat) : a > 0 \u2192 b > 0 \u2192 gcd a b > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def checkNumbersFriends (a b : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem not_self_friends (a : Nat) : a > 0 \u2192\n  checkNumbersFriends a a = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countLonelyNumbers (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lonely_numbers_bounds (n : Nat) : n > 0 \u2192\n  countLonelyNumbers n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_divides (a b : Nat) : a > 0 \u2192 b > 0 \u2192\n  a % (gcd a b) = 0 \u2227 b % (gcd a b) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_symmetric (a b : Nat) : a > 0 \u2192 b > 0 \u2192 gcd a b = gcd b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isTriangle (a b c : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_inequality (a b c : Nat) : a > 0 \u2192 b > 0 \u2192 c > 0 \u2192\n  isTriangle a b c = true \u2192\n    a + b > c \u2227 b + c > a \u2227 a + c > b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_symmetric (a b c : Nat) : a > 0 \u2192 b > 0 \u2192 c > 0 \u2192\n  isTriangle a b c = isTriangle b c a \u2227\n  isTriangle b c a = isTriangle c a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem friends_symmetric (a b : Nat) : a > 0 \u2192 b > 0 \u2192\n  checkNumbersFriends a b = checkNumbersFriends b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_is_lonely : countLonelyNumbers 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solveTestCases (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 3, 3]\n-/\n#guard_msgs in\n#eval solve_test_cases [1, 5, 10]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_test_cases [1]\n\n/-\ninfo: [3, 7]\n-/\n#guard_msgs in\n#eval solve_test_cases [10, 20]"
      }
    ]
  },
  "fvapps_002180.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def BIT (n : Nat) : Type := Unit"
      },
      {
        "type": "sig",
        "string": "def BIT.add (bit : BIT n) (i j v : Nat) : Unit :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BIT.get_val (bit : BIT n) (i : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BIT.mk (n : Nat) : BIT n :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve_tree_queries (n : Nat) (costs : List Nat) (edges : List (List Nat)) (queries : List (List Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_get_after_add (n i : Nat) (h : i < n) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_accumulate_adds (n i : Nat) (h : i < n - 1) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n  let _ := bit.add i (i+1) 1\n  bit.get_val i = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tree_queries_initial_cost\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (h : n \u2265 2) :\n  let queries := [[2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_tree_queries_update\n  (n : Nat) (costs : List Nat) (edges : List (List Nat)) (val : Nat) (h : n \u2265 2) :\n  let queries := [[1,1,val], [2,1]]\n  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result 0 = List.get! costs 0 + val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002181.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_rectangle_pairs (n : Nat) (rectangles : List (Nat \u00d7 Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_negative_result (n : Nat) (rectangles : List (Nat \u00d7 Nat \u00d7 Nat)) :\n  count_rectangle_pairs n rectangles \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_rect_count (rect : Nat \u00d7 Nat \u00d7 Nat) (count : Nat)\n    (h : rect.2.2 = count) :\n  let factors := (List.range (sqrt count)).filter (fun i => count % i = 0)\n  count_rectangle_pairs 1 [rect] = if sqrt count * sqrt count = count\n    then 2 * factors.length - 1\n    else 2 * factors.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded_by_min_count (n : Nat) (rectangles : List (Nat \u00d7 Nat \u00d7 Nat))\n    (h : rectangles \u2260 []) :\n  count_rectangle_pairs n rectangles \u2264\n    List.foldl Nat.min ((List.head! rectangles).2.2)\n      (List.tail! rectangles |>.map (fun r => r.2.2)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 1 [(1, 1, 9)]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(2, 3, 20), (2, 4, 40)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_rectangle_pairs 2 [(1, 2, 5), (2, 3, 5)]"
      }
    ]
  },
  "fvapps_002188.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_shortest_non_subsequence (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_subsequence (needle haystack : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def generate_strings (length : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def all_chars_in_range (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def all_lower (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid_string (s : String) :\n  let result := find_shortest_non_subsequence s\n  (result.length > 0) \u2227 (all_lower result) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_minimal (s : String) :\n  let result := find_shortest_non_subsequence s\n  \u2200 n : Nat, n < result.length \u2192\n  \u2200 possible : String, possible.length = n \u2192\n  is_subsequence possible s := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_for_all_letters {s : String} :\n  s.length = 26 \u2192\n  (\u2200 c : Char, c.isLower \u2192 s.contains c) \u2192\n  find_shortest_non_subsequence s = \"aa\" := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'b'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"atcoderregularcontest\"\n\n/-\ninfo: 'aa'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"abcdefghijklmnopqrstuvwxyz\"\n\n/-\ninfo: 'aca'\n-/\n#guard_msgs in\n#eval find_shortest_non_subsequence \"frqnvhydscshfcgdemurlfrutcpzhopfotpifgepnqjxupnskapziurswqazdwnwbgdhyktfyhqqxpoidfhjdakoxraiedxskywuepzfniuyskxiyjpjlxuqnfgmnjcvtlpnclfkpervxmdbvrbrdn\""
      }
    ]
  },
  "fvapps_002190.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def checkTreeWithDistances (N : Nat) (distances : List Nat) : List (Nat \u00d7 Nat) \u2295 Unit :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidTree (N : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem arbitrary_inputs_valid {N : Nat} {distances : List Nat}\n  (h1 : N \u2265 2) (h2 : N \u2264 20) (h3 : distances.length = N) :\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_distances_invalid {N : Nat} (h : N \u2265 2) :\n  let distances := List.replicate N N\n  checkTreeWithDistances N distances = .inr () :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequential_distances_valid {N : Nat} (h1 : N \u2265 2) (h2 : N \u2264 20) :\n  let distances := List.range N\n  let result := checkTreeWithDistances N distances\n  match result with\n  | .inl edges => isValidTree N edges = true\n  | .inr _ => True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases :\n  (checkTreeWithDistances 2 [1,1] = .inr ()) \u2227\n  (checkTreeWithDistances 2 [0,0] = .inr ()) \u2227\n  (match checkTreeWithDistances 3 [3,4,5] with\n   | .inl edges => isValidTree 3 edges = true\n   | .inr _ => False) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: N1 - 1\n-/\n#guard_msgs in\n#eval len result\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval check_tree_with_distances 2 [1, 2]\n\n/-\ninfo: N3 - 1\n-/\n#guard_msgs in\n#eval len result"
      }
    ]
  },
  "fvapps_002191.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_good_substrings : String \u2192 Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString : String \u2192 String :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry\n\n#check solve_good_substrings"
      },
      {
        "type": "cond",
        "string": "theorem solve_good_substrings_result_structure\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.1 > 0 \u2227 result.2 > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_good_substrings_first_element_values\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.1 = 1 \u2228 result.1 = 2 \u2228 result.1 = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_good_substrings_count_bound\n    {s : String}\n    (h : s.length > 0) :\n    let result := solve_good_substrings s\n    result.2 \u2264 s.length - 1 \u2228 result.2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"aab\"\n\n/-\ninfo: (2, 3)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"bcbc\"\n\n/-\ninfo: (3, 1)\n-/\n#guard_msgs in\n#eval solve_good_substrings \"ddd\""
      }
    ]
  },
  "fvapps_002208.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Grid := List (List Char)"
      },
      {
        "type": "sig",
        "string": "def solve_rock_puzzle (n m : Nat) : Grid \u00d7 (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_arrows (grid : Grid) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_square_grid (grid : Grid) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def valid_start_pos (pos : Nat \u00d7 Nat) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_rock_puzzle_dimensions {n : Nat} (h : n > 0) :\n  let (grid, start_pos) := solve_rock_puzzle n n\n  List.length grid = n \u2227\n  is_square_grid grid = true \u2227\n  valid_start_pos start_pos n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_characters {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  \u2200 (i : Nat), i < List.length grid \u2192\n  \u2200 (j : Nat), j < List.length (List.get! grid i) \u2192\n  let c := List.get! (List.get! grid i) j\n  c = '^' \u2228 c = 'v' \u2228 c = '<' \u2228 c = '>' \u2228 c = '.' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem has_arrows {n : Nat} (h : n > 0) :\n  let (grid, _) := solve_rock_puzzle n n\n  count_arrows grid > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002209.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def getSpecialValue : Nat \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "  fun n => sorry"
      },
      {
        "type": "sig",
        "string": "def countNumbersWithSpecialValue : List (Nat \u00d7 Nat \u00d7 Nat) \u2192 List Nat :="
      },
      {
        "type": "impl",
        "string": "  fun queries => sorry"
      },
      {
        "type": "cond",
        "string": "theorem special_value_counts_correct {l r k : Nat} (h1 : l > 0) (h2 : r > l) (h3 : k > 0) (h4 : k \u2264 9) :\n  let count := (countNumbersWithSpecialValue [(l,r,k)]).head!;\n  count = ((List.range (r-l+1)).filter (fun x => getSpecialValue (x + l) = k)).length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_list_length_matches_queries {queries : List (Nat \u00d7 Nat \u00d7 Nat)} (h : queries.length > 0) :\n  (countNumbersWithSpecialValue queries).length = queries.length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem results_are_nonnegative {queries : List (Nat \u00d7 Nat \u00d7 Nat)} (h : queries.length > 0) :\n  List.all (countNumbersWithSpecialValue queries) (fun x => x \u2265 0) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 4, 0, 8]\n-/\n#guard_msgs in\n#eval count_numbers_with_special_value [(22, 73, 9), (45, 64, 6), (47, 55, 7), (2, 62, 4)]\n\n/-\ninfo: [3, 1, 1, 5]\n-/\n#guard_msgs in\n#eval count_numbers_with_special_value [(82, 94, 6), (56, 67, 4), (28, 59, 9), (39, 74, 4)]"
      }
    ]
  },
  "fvapps_002211.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_cost_to_cut_trees (n : Nat) (heights : List Nat) (costs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | h::t => h + sum_list t"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n \u2265 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : \u2200 h \u2208 heights, h \u2265 1 \u2227 h \u2264 1000)\n  (h5 : \u2200 c \u2208 costs, c \u2264 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_upper_bound (n : Nat) (heights : List Nat) (costs : List Nat)\n  (h1 : n \u2265 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length = n)\n  (h4 : \u2200 h \u2208 heights, h \u2265 1 \u2227 h \u2264 1000)\n  (h5 : \u2200 c \u2208 costs, c \u2264 1000)\n  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs \u2264 sum_list (heights.map (\u00b7 * costs.head!)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_last_worker_bound (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length \u2265 2)\n  (h2 : \u2200 h \u2208 heights, h \u2265 1 \u2227 h \u2264 100)\n  (h3 : costs.length = heights.length)\n  (h4 : \u2200 c \u2208 costs, c \u2264 100)\n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees heights.length heights costs \u2265 heights.getLast! * costs.getLast! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 0]\n\n/-\ninfo: 138\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 6 [1, 2, 3, 10, 20, 30] [6, 5, 4, 3, 2, 0]"
      }
    ]
  },
  "fvapps_002213.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidPermutation (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solveNextPermutation (n : Nat) (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_case {n : Nat} (h : n > 0) (h2 : n \u2264 100) :\n  solveNextPermutation 1 [-1] = [1] := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_minus_ones {n : Nat} (h : n > 0) (h2 : n \u2264 20) :\n  let result := solveNextPermutation n (List.replicate n (-1))\n  isValidPermutation result \u2227\n  result = (List.range n).map (fun x => Int.ofNat (x + 1)) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequential_pointers {n : Nat} (h : n > 1) (h2 : n \u2264 20) :\n  let nextVals := (List.range n).map (fun x => Int.ofNat (x + 2))\n  let result := solveNextPermutation n nextVals\n  isValidPermutation result := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval solve_next_permutation 3 [2, 3, 4]\n\n/-\ninfo: [2, 1]\n-/\n#guard_msgs in\n#eval solve_next_permutation 2 [3, 3]\n\n/-\ninfo: [3, 1, 2, 4]\n-/\n#guard_msgs in\n#eval solve_next_permutation 4 [4, -1, 4, 5]"
      }
    ]
  },
  "fvapps_002235.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n m k : Nat) (arr : List Nat) : Nat := sorry\n\ndef listMin (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl min x xs"
      },
      {
        "type": "sig",
        "string": "def listMax (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs"
      },
      {
        "type": "cond",
        "string": "theorem solve_result_in_bounds {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length \u2265 m) (h2 : m \u2264 n) (h3 : arr \u2260 []) :\n  let result := solve n m k arr\n  listMin arr \u2264 result \u2227 result \u2264 listMax arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_k_zero {n m : Nat} {arr : List Nat}\n  (h1 : arr.length \u2265 m) (h2 : m \u2264 n) :\n  solve n m 0 arr =\n    listMin (List.map\n      (fun i => max (arr[i]!) (arr[arr.length - i - 1]!))\n      (List.range m)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_k_large {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length \u2265 m) (h2 : m \u2264 n) (h3 : k \u2265 m-1) (h4 : m > 0) :\n  solve n m k arr =\n    listMax (List.map\n      (fun i => max (arr[i]!) (arr[arr.length - i - 1]!))\n      (List.range m)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty_error {n m : Nat} :\n  solve n m 0 [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_negative_k {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length \u2265 m) (h2 : m \u2264 n) :\n  solve n m 0 arr = solve n m k arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_very_large_k {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length \u2265 m) (h2 : m \u2264 n) (h3 : k \u2265 m-1) :\n  solve n m k arr = solve n m (m-1) arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve 6 4 2 [2, 9, 2, 3, 8, 5]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 4 4 1 [2, 13, 60, 4]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 4 1 3 [1, 2, 2, 1]"
      }
    ]
  },
  "fvapps_002239.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_test (n : Nat) (numbers : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def MOD := 998244353"
      },
      {
        "type": "cond",
        "string": "theorem solve_test_within_mod_bounds\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n \u2265 1) (h3 : n \u2264 9)\n  (h4 : \u2200 x \u2208 numbers, 1 \u2264 x \u2227 x \u2264 10^9) :\n  0 \u2264 solve_test n numbers \u2227 solve_test n numbers < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_test_order_independent\n  (n : Nat) (numbers : List Nat) (h1 : numbers.length = n) (h2 : n \u2265 1) (h3 : n \u2264 9)\n  (h4 : \u2200 x \u2208 numbers, 1 \u2264 x \u2227 x \u2264 10^9) :\n  solve_test n numbers = solve_test n numbers.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_test_large_identical_numbers\n  (n : Nat) (v : Nat) (h1 : n \u2265 2) (h2 : n \u2264 9) (h3 : v = 10^9)\n  (numbers : List Nat) (h4 : numbers = List.replicate n v) :\n  0 \u2264 solve_test n numbers \u2227 solve_test n numbers < MOD :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 2 [1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [1, 31, 12]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_test 3 [12345, 67, 84]\n\n/-\ninfo: 31680\n-/\n#guard_msgs in\n#eval solve_test 9 [1, 2, 3, 4, 5, 6, 7, 8, 9]"
      }
    ]
  },
  "fvapps_002240.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_haystack (n : Nat) (d : Nat) (haybales : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | h :: t => h + list_sum t"
      },
      {
        "type": "sig",
        "string": "def calculate_movable_sum (n d : Nat) (haybales : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let rec aux : Nat \u2192 Nat \u2192 Nat\n    | 0, acc => acc\n    | i+1, acc =>\n      let moves := d / (i+1)\n      let val := match haybales.get? i with\n        | none => 0\n        | some x => min moves x\n      aux i (acc + val)\n  aux (n-1) 0"
      },
      {
        "type": "cond",
        "string": "theorem solve_haystack_within_first_pile_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales \u2265 (haybales.get \u27e80, sorry\u27e9) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_haystack_within_total_sum {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales \u2264 list_sum haybales := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_haystack_within_movable_limit {n d : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n d haybales \u2264\n    (haybales.get \u27e80, sorry\u27e9) + calculate_movable_sum n d haybales := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_haystack_single_pile {d : Nat} {hay : Nat} :\n  solve_haystack 1 d [hay] = hay := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_haystack_zero_days {n : Nat} {haybales : List Nat}\n  (hn : n > 0) (h_len : haybales.length = n) :\n  solve_haystack n 0 haybales = haybales.get \u27e80, sorry\u27e9 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_haystack 4 5 [1, 0, 3, 2]\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval solve_haystack 2 2 [100, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_haystack 1 8 [0]"
      }
    ]
  },
  "fvapps_002246.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ValidProtocol (s : String) : Prop := s = \"http\" \u2228 s = \"ftp\""
      },
      {
        "type": "sig",
        "string": "def IsValidDomainChar (c : Char) : Prop := c.isUpper \u2228 c.isLower \u2228 c.isDigit"
      },
      {
        "type": "sig",
        "string": "def IsValidPathChar (c : Char) : Prop := c.isUpper \u2228 c.isLower \u2228 c.isDigit"
      },
      {
        "type": "sig",
        "string": "def format_internet_address (s : String) : String := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_starts_with_protocol (s : String) :\n  (s.startsWith \"http\" \u2228 s.startsWith \"ftp\") \u2192\n  (format_internet_address s).startsWith \"http://\" \u2228\n  (format_internet_address s).startsWith \"ftp://\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_preserves_protocol (s : String) :\n  s.startsWith \"http\" \u2192 (format_internet_address s).startsWith \"http://\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_preserves_ftp (s : String) :\n  s.startsWith \"ftp\" \u2192 (format_internet_address s).startsWith \"ftp://\" := sorry\n\npartial def containsSubstr (haystack needle : String) : Bool :=\n  if needle.length = 0 then true\n  else if haystack.length < needle.length then false\n  else if haystack.take needle.length = needle then true\n  else containsSubstr (haystack.drop 1) needle"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_contains_ru (s : String) :\n  containsSubstr (format_internet_address s) \".ru\" = true := sorry\n\npartial def countSubstr (haystack needle : String) : Nat :=\n  if needle.length = 0 then 0\n  else if haystack.length < needle.length then 0\n  else if haystack.take needle.length = needle\n    then 1 + countSubstr (haystack.drop needle.length) needle\n    else countSubstr (haystack.drop 1) needle"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_single_ru (s : String) :\n  countSubstr (format_internet_address s) \".ru\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_internet_address_path_slashes (s : String) :\n  containsSubstr s \"ru\" = true \u2192\n  s.length > (s.length - (s.takeRight (s.length - 2)).length) + 2 \u2192\n  countChar (format_internet_address s) '/' = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002250.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_sequence_sum (n m : Nat) (sequence : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "constr",
        "string": "abbrev M : Nat := 1000000007"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_sum_nonneg (n m : Nat) (sequence : List Nat) :\n  solve_sequence_sum n m sequence \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_sequence_sum_special_case :\n  solve_sequence_sum 1 1 [0] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_sequence_sum 3 5 [1, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_sequence_sum 1 1 [0]"
      }
    ]
  },
  "fvapps_002252.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := List (List Char)\n\ndef is_valid_adjacency_matrix (m: Matrix) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_symmetric (m: Matrix) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def generate_graph (k: Nat) : Nat \u00d7 Matrix :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generated_graph_is_valid (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_valid_adjacency_matrix matrix = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generated_graph_is_symmetric (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  is_symmetric matrix = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem size_properties (k: Nat) :\n  let (n, matrix) := generate_graph k;\n  n \u2264 4 * k \u2227\n  matrix.length = n \u2227\n  List.all matrix (fun row => row.length = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: competition\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002253.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Position := Int \u00d7 Int \u00d7 Bool \u00d7 Bool \u00d7 Bool \u00d7 Bool\n\ndef find_robot_gather_point (robots : List Position) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def in_bounds (x y : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "-100000 \u2264 x \u2227 x \u2264 100000 \u2227 -100000 \u2264 y \u2227 y \u2264 100000"
      },
      {
        "type": "cond",
        "string": "theorem gather_point_valid (robots : List Position) :\n  let result := find_robot_gather_point robots\n  (result.length = 1 \u2227 result = [0]) \u2228\n  (result.length = 3 \u2227\n   result.get! 0 = 1 \u2227\n   let x := result.get! 1\n   let y := result.get! 2\n   in_bounds x y \u2227\n   \u2200 (robot : Position),\n   robot \u2208 robots \u2192\n   let (rx, ry, can_left, can_up, can_right, can_down) := robot\n   (\u00accan_left \u2192 x \u2265 rx) \u2227\n   (\u00accan_right \u2192 x \u2264 rx) \u2227\n   (\u00accan_up \u2192 y \u2264 ry) \u2227\n   (\u00accan_down \u2192 y \u2265 ry)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, -1, -2]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[-1, -2, 0, 0, 0, 0], [-1, -2, 0, 0, 0, 0]]\n\n/-\ninfo: [1, 2, 5]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1, 5, 1, 1, 1, 1], [2, 5, 0, 1, 0, 1], [3, 5, 1, 0, 0, 0]]\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval find_robot_gather_point [[1337, 1337, 0, 1, 1, 1], [1336, 1337, 1, 1, 0, 1]]"
      }
    ]
  },
  "fvapps_002259.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_moves_to_equalize (n : Nat) (candies : List Nat) (oranges : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_non_negative (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_lower_bound (n : Nat) (candies : List Nat) (oranges : List Nat) :\n  min_moves_to_equalize n candies oranges \u2265\n    max\n      (list_max candies - list_min candies)\n      (list_max oranges - list_min oranges) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_upper_bound (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges \u2264\n    (list_sum (candies.map (\u03bb x => x - list_min candies))) +\n    (list_sum (oranges.map (\u03bb x => x - list_min oranges))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_lists_zero_moves (n : Nat) (v : Nat) :\n  min_moves_to_equalize n (List.replicate n v) (List.replicate n v) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_symmetric (n : Nat) (candies oranges : List Nat) :\n  min_moves_to_equalize n candies oranges = min_moves_to_equalize n oranges candies :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [3, 5, 6] [3, 2, 3]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 5 [1, 2, 3, 4, 5] [5, 4, 3, 2, 1]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval min_moves_to_equalize 3 [10, 12, 8] [7, 5, 4]"
      }
    ]
  },
  "fvapps_002262.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findShortestPrefix (n : Nat) (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Theorem stating that result is always a valid index or 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_shortest_prefix_bounds {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0) :\n  let result := findShortestPrefix n arr\n  0 \u2264 result \u2227 result < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Theorem stating that sorted ascending arrays return 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_shortest_prefix_sorted_asc {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : \u2200 i j, i < j \u2192 j < arr.length \u2192 arr[i]! \u2264 arr[j]!) :\n  findShortestPrefix n arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Theorem stating that single element arrays return 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_shortest_prefix_single {arr : List Int}\n  (h : arr.length = 1) :\n  findShortestPrefix 1 arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Theorem stating that constant arrays return 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_shortest_prefix_constant {n : Nat} {arr : List Int}\n  (h : arr.length = n) (h1 : n > 0)\n  (h2 : \u2200 i j, i < arr.length \u2192 j < arr.length \u2192 arr[i]! = arr[j]!) :\n  findShortestPrefix n arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 4 [1, 2, 3, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_shortest_prefix 7 [4, 3, 3, 8, 4, 5, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_shortest_prefix 3 [1, 1, 1]"
      }
    ]
  },
  "fvapps_002263.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_moves_required (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def nat_sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_non_negative (n : Nat) (h : n > 0) :\n  min_moves_required n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_less_than_input (n : Nat) (h : n > 0) :\n  min_moves_required n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_monotonic (n : Nat) (h : n > 1) :\n  min_moves_required n \u2265 min_moves_required (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_base_case :\n  min_moves_required 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_required 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves_required 5\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval min_moves_required 42"
      }
    ]
  },
  "fvapps_002266.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_leaf_removal (n k : Nat) (edges : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tree (n : Nat) (edges : List (Nat \u00d7 Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem leaf_removal_basic_properties {n k : Nat} {edges : List (Nat \u00d7 Nat)}\n    (h1 : n \u2265 2)\n    (h2 : k \u2265 1)\n    (h3 : k \u2264 5)\n    (h4 : is_valid_tree n edges = true) :\n    let result := solve_leaf_removal n k edges\n    result \u2265 0 \u2227 result \u2264 (n + k - 1) / k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem leaf_removal_single_node {k : Nat}\n    (h : k \u2265 1) :\n    solve_leaf_removal 1 k [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_leaf_removal 8 3 [(1, 2), (1, 5), (7, 6), (6, 8), (3, 1), (6, 4), (6, 1)]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_leaf_removal 10 3 [(1, 2), (1, 10), (2, 3), (1, 5), (1, 6), (2, 4), (7, 10), (10, 9), (8, 10)]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_leaf_removal 5 1 [(1, 2), (2, 3), (4, 3), (5, 3)]"
      }
    ]
  },
  "fvapps_002267.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minimum_operations (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (arr : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < arr.length \u2192 arr[i]! \u2264 arr[j]!"
      },
      {
        "type": "sig",
        "string": "def isStrictlySorted (arr : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < arr.length \u2192 arr[i]! < arr[j]!"
      },
      {
        "type": "cond",
        "string": "theorem output_bounds (arr : List Int) (h : arr \u2260 []) :\n  0 \u2264 minimum_operations arr \u2227 minimum_operations arr \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_unique_needs_zero {arr : List Int} (h1 : arr \u2260 [])\n  (h2 : isStrictlySorted arr) :\n  minimum_operations arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [4, 7, 2, 3, 9]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum_operations [3, 5, 8, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum_operations [1, 4, 5, 7, 12]"
      }
    ]
  },
  "fvapps_002269.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_garland (n k : Nat) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_garland (n k : Nat) (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_zeros (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_ones (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_zeros (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_garland_nonnegative (n k : Nat) (s : String) :\n  is_valid_garland n k s \u2192\n  solve_garland n k s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_garland_bounded_by_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s \u2192\n  solve_garland n k s \u2264 count_zeros s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_garland_all_ones (n k : Nat) (s : String) :\n  is_valid_garland n k s \u2192\n  all_ones s \u2192\n  solve_garland n k s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_garland_all_zeros (n k : Nat) (s : String) :\n  is_valid_garland n k s \u2192\n  all_zeros s \u2192\n  solve_garland n k s \u2264 (n + k - 1) / k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_garland 9 2 \"010001010\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_garland 9 3 \"111100000\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_garland 1 1 \"0\""
      }
    ]
  },
  "fvapps_002270.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_frog_jumps (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_jumps_positive_bound (s : String) :\n  solve_frog_jumps s \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_jumps_upper_bound (s : String) :\n  solve_frog_jumps s \u2264 s.length + 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem frog_jumps_consecutive_r (s : String) :\n  solve_frog_jumps s = solve_frog_jumps (s.replace \"R\" \"RR\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LRLRRLL\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"L\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_frog_jumps \"LLR\""
      }
    ]
  },
  "fvapps_002271.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hammingDistance (s1 s2 : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def verifyResult (result : String) (strings : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findSimilarString (strings : List String) (n m : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_similar_string_properties {strings : List String} {n m : Nat}\n  (h1 : n = strings.length)\n  (h2 : m > 0)\n  (h3 : \u2200 s \u2208 strings, s.length = m)\n  (result := findSimilarString strings n m) :\n    (result = \"-1\" \u2228 result.length = m) \u2227\n    (result = \"-1\" \u2228 \u2200 c \u2208 result.data, isLower c) \u2227\n    verifyResult result strings\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_strings_property {strings : List String} {n m : Nat}\n  (h1 : strings.length = 2)\n  (h2 : strings.head!.length = strings.tail!.head!.length)\n  (h3 : \u2200 s \u2208 strings, \u2200 c \u2208 s.data, c = 'a' \u2228 c = 'b')\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_inputs_property {strings : List String} {n m : Nat}\n  (h1 : strings.length \u2264 3)\n  (h2 : strings.length > 0)\n  (h3 : \u2200 s \u2208 strings, s.length = strings.head!.length)\n  (result := findSimilarString strings n m) :\n    verifyResult result strings\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '-1'\n-/\n#guard_msgs in\n#eval find_similar_string [\"aaaa\", \"bbbb\"] 2 4\n\n/-\ninfo: 'aaa'\n-/\n#guard_msgs in\n#eval find_similar_string [\"baa\", \"aaa\", \"aab\"] 3 3"
      }
    ]
  },
  "fvapps_002273.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_ops_to_sort {\u03b1 : Type u} [Ord \u03b1] (arr : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted {\u03b1 : Type u} [Ord \u03b1] [LE \u03b1] (xs : List \u03b1) : Prop :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => True\n  | [_] => True\n  | x :: y :: rest => x \u2264 y \u2227 isSorted (y :: rest)"
      },
      {
        "type": "cond",
        "string": "theorem translation_invariant (arr : List Int) (k : Int) :\n  min_ops_to_sort arr = min_ops_to_sort (arr.map (fun x => x + k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [4, 7, 2, 2, 9]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_ops_to_sort [3, 5, 8, 1, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_ops_to_sort [1, 2, 2, 4, 5]"
      }
    ]
  },
  "fvapps_002279.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_candy_gift (n : Nat) (candies : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_occurrences (a : Nat) (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def frequency_list (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_candy_gift_bounded\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : \u2200 x \u2208 candies, 1 \u2264 x \u2227 x \u2264 1000) :\n  solve_candy_gift n candies \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_candy_gift_nonnegative\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : \u2200 x \u2208 candies, 1 \u2264 x \u2227 x \u2264 1000) :\n  0 \u2264 solve_candy_gift n candies :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_candy_gift_monotonic_frequencies\n  (n : Nat) (candies : List Nat)\n  (h1 : n = candies.length)\n  (h2 : \u2200 x \u2208 candies, 1 \u2264 x \u2227 x \u2264 1000) :\n  let freqs := frequency_list candies\n  let result := solve_candy_gift n candies\n  \u2200 i j, i < j \u2192 i < freqs.length \u2192 j < freqs.length \u2192\n  let take_i := if i = 0 then result else min ((freqs.get! (i-1))-1) (freqs.get! i)\n  let take_j := if j = 0 then result else min ((freqs.get! (j-1))-1) (freqs.get! j)\n  take_i \u2265 take_j :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_candy_gift 8 [1, 4, 8, 4, 5, 6, 3, 8]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval solve_candy_gift 16 [2, 1, 3, 3, 4, 3, 4, 4, 1, 3, 2, 2, 2, 4, 1, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve_candy_gift 9 [2, 2, 4, 4, 4, 7, 7, 7, 7]"
      }
    ]
  },
  "fvapps_002280.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve_array_sort (n : Nat) (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.swap3 (l : List \u03b1) (pos : Nat) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_already_sorted {n : Nat} {arr : List Nat} (h1 : n \u2265 3)\n  (h2 : arr = List.range' 1 n) :\n  solve_array_sort n arr = [0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_result_correctness {n : Nat} {arr : List Nat} (h1 : n \u2265 3)\n  (h2 : arr.length = n)\n  (result : List Nat) (h3 : result = solve_array_sort n arr) :\n  result = [0] \u2228 result = [Nat.zero] \u2228\n  (match result with\n  | [] => False\n  | num_moves :: moves =>\n    moves.length = num_moves \u2227\n    let final := moves.foldl\n      (\u03bb acc pos => acc.swap3 (pos-1)) arr;\n    final.sort = List.range' 1 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [1, 2, 3, 4, 5]\n\n/-\ninfo: [6, 3, 1, 3, 2, 2, 3]\n-/\n#guard_msgs in\n#eval solve_array_sort 5 [5, 4, 3, 2, 1]\n\n/-\ninfo: [4, 3, 3, 4, 4]\n-/\n#guard_msgs in\n#eval solve_array_sort 6 [1, 2, 3, 3, 6, 4]"
      }
    ]
  },
  "fvapps_002286.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_median_binary_string (n m : Nat) (removed : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAllZeros (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringInList (s : String) (l : List String) : Bool := sorry\n\ndef isBinaryChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = '0' || c = '1'"
      },
      {
        "type": "other",
        "string": "/- The length of the output string matches the input length m -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_median_binary_string_length_matches_input\n  {n m : Nat} {removed : List String}\n  (h\u2081 : n < 2^m)\n  (h\u2082 : n = removed.length) :\n  (find_median_binary_string n m removed).length = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The output string only contains '0' and '1' characters -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_median_binary_string_binary_chars\n  {n m : Nat} {removed : List String}\n  (h\u2081 : n < 2^m)\n  (h\u2082 : n = removed.length) :\n  \u2200 c, c \u2208 (find_median_binary_string n m removed).data \u2192 isBinaryChar c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The output string is not in the list of removed strings -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_median_binary_string_not_in_removed\n  {n m : Nat} {removed : List String}\n  (h\u2081 : n < 2^m)\n  (h\u2082 : n = removed.length) :\n  stringInList (find_median_binary_string n m removed) removed = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For the minimal case with a single all-zeros string removed,\n    the output string has correct length and is not all zeros -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_median_binary_string_minimal_case\n  {m : Nat} (h : m > 0) :\n  let zeros := String.mk (List.replicate m '0')\n  let result := find_median_binary_string 1 m [zeros]\n  (result.length = m) \u2227 (isAllZeros result = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: '100'\n-/\n#guard_msgs in\n#eval find_median_binary_string 3 3 [\"010\", \"001\", \"111\"]\n\n/-\ninfo: '010'\n-/\n#guard_msgs in\n#eval find_median_binary_string 4 3 [\"000\", \"111\", \"100\", \"011\"]\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval find_median_binary_string 1 1 [\"1\"]"
      }
    ]
  },
  "fvapps_002292.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_perfect_number (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def perfect_numbers : List Int := [6, 28, 496, 8128, 33550336, 8589869056]"
      },
      {
        "type": "cond",
        "string": "theorem known_perfect_numbers (n : Int) (h : n \u2208 perfect_numbers) :\n  check_perfect_number n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def small_perfect_numbers : List Int := [6, 28, 496, 8128]"
      },
      {
        "type": "cond",
        "string": "theorem most_numbers_not_perfect {n : Int} (h\u2081 : n \u2265 1) (h\u2082 : n \u2264 1000000)\n  (h\u2083 : n \u2209 small_perfect_numbers) :\n  check_perfect_number n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_positive_not_perfect {n : Int} (h : n \u2264 0) :\n  check_perfect_number n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_perfect_number 28\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 12\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_perfect_number 1"
      }
    ]
  },
  "fvapps_002295.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def subtract_product_and_sum (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def product_of_list (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_of_list (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_zero (n : Nat) (h : n > 0 \u2227 n < 10) :\n  subtract_product_and_sum n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem three_digit_bounds (n : Nat) (h : n \u2265 100 \u2227 n \u2264 999) :\n  subtract_product_and_sum n \u2264 729 \u2227 subtract_product_and_sum n \u2265 -27 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 234\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 4421\n\n/-\ninfo: -2\n-/\n#guard_msgs in\n#eval subtract_product_and_sum 111"
      }
    ]
  },
  "fvapps_002299.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def third_max (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def uniqueSorted (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem third_max_is_in_list {nums : List Int} (h : nums \u2260 []) :\n  third_max nums \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval third_max [1, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval third_max [2, 2, 3, 1]"
      }
    ]
  },
  "fvapps_002302.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidTriplet (arr : List Int) (i j k a b c : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countTripletsBruteforce (arr : List Int) (a b c : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countGoodTriplets (arr : List Int) (a b c : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countGoodTriplets_matches_bruteforce\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length \u2265 3)\n    (h2 : arr.length \u2264 20)\n    (h3 : \u2200 x \u2208 arr, -100 \u2264 x \u2227 x \u2264 100)\n    (h4 : a \u2264 50 \u2227 b \u2264 50 \u2227 c \u2264 50) :\n    countGoodTriplets arr a b c = countTripletsBruteforce arr a b c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countGoodTriplets_nonnegative\n    (arr : List Int) (a b c : Nat)\n    (h : arr.length \u2265 3)\n    (h2 : arr.length \u2264 20) :\n    0 \u2264 countGoodTriplets arr a b c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_good_triplets [3, 0, 1, 1, 9, 7] 7 2 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 1, 2, 2, 3] 0 0 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_good_triplets [1, 2, 3, 4, 5] 1 1 1"
      }
    ]
  },
  "fvapps_002303.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def searchInsert (nums : List Int) (target : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "cond",
        "string": "theorem searchInsert_valid_index\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    0 \u2264 result \u2227 result \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem searchInsert_left_smaller\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    \u2200 i, i < result \u2192 nums[i]! < target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem searchInsert_right_greater_eq\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    \u2200 i, result \u2264 i \u2192 i < nums.length \u2192 nums[i]! \u2265 target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem searchInsert_maintains_order\n    {nums : List Int} {target : Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums) :\n    let result := searchInsert nums target\n    let inserted := (nums.take result).append (target :: nums.drop result)\n    isSorted inserted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem searchInsert_identity\n    {nums : List Int}\n    (h1 : List.length nums > 0)\n    (h2 : isSorted nums)\n    {i : Nat} (h3 : i < nums.length) :\n    searchInsert nums nums[i]! = List.findIdx (\u00b7 = nums[i]!) nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 5\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval search_insert [1, 3, 5, 6] 7"
      }
    ]
  },
  "fvapps_002306.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def contains_duplicate (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def eraseDups (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_duplicate_matches_set_size {nums : List Int} :\n  contains_duplicate nums = (nums.length \u2260 (eraseDups nums).length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem contains_duplicate_set_membership {nums : List Int} :\n  contains_duplicate nums = \u2203 i j, i < j \u2227 j < nums.length \u2227 nums[i]! = nums[j]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_list_returns_false {nums : List Int}\n  (h : \u2200 i j, i < j \u2192 j < nums.length \u2192 nums[i]! \u2260 nums[j]!) :\n  \u00accontains_duplicate nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_element_returns_true {nums : List Int} (h : nums \u2260 []) :\n  contains_duplicate (nums ++ nums.take 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 1]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 2, 3, 4]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_duplicate [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]"
      }
    ]
  },
  "fvapps_002308.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_anagram (s t : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPermutation (s t : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_is_anagram_of_itself (s : String) :\n  is_anagram s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_length_strings_not_anagrams {s t : String}\n  (h : s.length \u2260 t.length) :\n  is_anagram s t = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reversed_string_is_anagram (s : String) :\n  is_anagram s (reverse s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permuted_string_is_anagram (s t : String)\n  (h : isPermutation s t) :\n  is_anagram s t = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"anagram\" \"nagaram\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_anagram \"rat\" \"car\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_anagram \"hello\" \"hello\""
      }
    ]
  },
  "fvapps_002312.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def add_strings (a b : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def int_to_str (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_strings_matches_int_addition\n  (a b : Nat) (h1 : a \u2264 10^6) (h2 : b \u2264 10^6) :\n  add_strings (int_to_str a) (int_to_str b) = int_to_str (a + b) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_zero_right (n : Nat) (h : n \u2264 10^6) :\n  add_strings (int_to_str n) \"0\" = int_to_str n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_zero_left (n : Nat) (h : n \u2264 10^6) :\n  add_strings \"0\" (int_to_str n) = int_to_str n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_strings_commutative (n : Nat) (h : n \u2264 10^6) :\n  add_strings (int_to_str n) (int_to_str 42) =\n  add_strings (int_to_str 42) (int_to_str n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '172'\n-/\n#guard_msgs in\n#eval add_strings \"123\" \"49\"\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval add_strings \"0\" \"0\"\n\n/-\ninfo: '1000'\n-/\n#guard_msgs in\n#eval add_strings \"999\" \"1\""
      }
    ]
  },
  "fvapps_002319.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_k_diff_pairs (nums : List Int) (k : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOccurrences (nums : List Int) (x : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def dedup (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_diff_pairs_property :\n  \u2200 (nums : List Int) (k : Int),\n  let result := find_k_diff_pairs nums k\n  result \u2265 0 \u2227 (k < 0 \u2192 result = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_k_pairs_symmetric :\n  \u2200 (nums : List Int) (k : Int),\n  k > 0 \u2192\n  find_k_diff_pairs nums (-k) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem k_diff_pairs_subset :\n  \u2200 (nums : List Int) (k : Int),\n  k > 0 \u2192\n  nums.length > 0 \u2192\n  let subset := nums.take (nums.length / 2)\n  find_k_diff_pairs subset k \u2264 find_k_diff_pairs nums k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [3, 1, 4, 1, 5] 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 2, 3, 4, 5] 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_k_diff_pairs [1, 3, 1, 5, 4] 0"
      }
    ]
  },
  "fvapps_002321.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isUppercase (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toCharList (s : String) : List Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def removeDashes (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def licenseKeyFormatting (s : String) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_uppercase (s : String) (k : Nat) :\n  \u2200 c \u2208 toCharList (licenseKeyFormatting s k), isUppercase c = true\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_same_length (s : String) (k : Nat) :\n  String.length (removeDashes (licenseKeyFormatting s k)) =\n  String.length (removeDashes s)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_group_sizes (s : String) (k : Nat) :\n  let result := licenseKeyFormatting s k\n  let groups := String.splitOn result \"-\"\n  groups.length \u2264 1 \u2228\n  (\u2200 g \u2208 groups.tail, String.length g = k) \u2227 String.length groups.head! \u2264 k\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_empty (k : Nat) :\n  licenseKeyFormatting \"\" k = \"\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_single_dash (k : Nat) :\n  licenseKeyFormatting \"-\" k = \"\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem license_key_no_dashes (s : String) (k : Nat) :\n  (\u2200 c \u2208 toCharList s, c \u2260 '-') \u2192\n  removeDashes (licenseKeyFormatting s k) = String.mk (List.map Char.toUpper (toCharList s))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5F3Z-2E9W'\n-/\n#guard_msgs in\n#eval license_key_formatting \"5F3Z-2e-9-w\" 4\n\n/-\ninfo: '2-5G-3J'\n-/\n#guard_msgs in\n#eval license_key_formatting \"2-5g-3-J\" 2\n\n/-\ninfo: 'A-B-C'\n-/\n#guard_msgs in\n#eval license_key_formatting \"a-b-c\" 1"
      }
    ]
  },
  "fvapps_002322.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countTrailingOnes : List Nat \u2192 Nat\n  | [] => 0\n  | xs => sorry\n\ndef is_one_bit_character (bits : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem ends_with_zero {bits : List Nat} (h : bits \u2260 []) :\n  bits.getLast (by exact h) = 0 \u2192\n  is_one_bit_character bits = true \u2228 is_one_bit_character bits = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_zeros_is_true {bits : List Nat} (h : bits \u2260 []) :\n  (bits.all (fun x => x = 0)) \u2192\n  is_one_bit_character bits = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trailing_ones_parity {bits : List Nat} (h : bits.length \u2265 2) :\n  is_one_bit_character bits = (countTrailingOnes (bits.dropLast) % 2 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases_hold :\n  (is_one_bit_character [0] = true) \u2227\n  (is_one_bit_character [0, 0] = true) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 0, 0]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_one_bit_character [1, 1, 1, 0]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_one_bit_character [0, 0]"
      }
    ]
  },
  "fvapps_002324.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_is_palindrome :\n  is_palindrome \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_plus_reverse_is_palindrome {s : String} :\n  is_palindrome (s ++ reverseString s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem case_insensitive {s : String} :\n  is_palindrome s = is_palindrome (s.toUpper) \u2227\n  is_palindrome s = is_palindrome (s.toLower) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem punctuation_invariant {s p c : Char} :\n  is_palindrome (String.mk [c]) = is_palindrome (String.mk [c, p]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_is_palindrome {c : Char} :\n  is_palindrome (String.mk [c]) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"A man, a plan, a canal: Panama\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"race a car\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"\""
      }
    ]
  },
  "fvapps_002326.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def splitString (s: String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def lengthOfLastWord (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_of_last_word_nonnegative (s: String) :\n  lengthOfLastWord s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_of_last_word_matches_split (s: String) :\n  lengthOfLastWord s > 0 \u2192\n  match splitString s with\n  | [] => True\n  | xs => lengthOfLastWord s = xs.getLast!.length\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_of_last_word_empty_for_blank (s: String) :\n  s.trim.isEmpty \u2192 lengthOfLastWord s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_of_last_word_ignores_trailing_spaces (s: String) :\n  lengthOfLastWord s = lengthOfLastWord s.trim :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello World\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval length_of_last_word \"   \"\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval length_of_last_word \"Hello   World   Program\""
      }
    ]
  },
  "fvapps_002327.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_str (haystack : String) (needle : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsString (haystack needle : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringSlice (s : String) (start : Int) (last : Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringRepeat (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_needle_returns_zero {haystack : String} :\n  find_str haystack \"\" = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_haystack_nonempty_needle_returns_minus_one {needle : String} (h : needle \u2260 \"\") :\n  find_str \"\" needle = -1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem needle_not_found_returns_minus_one {haystack needle : String}\n  (h : containsString haystack needle = false) :\n  find_str haystack needle = -1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid_index {haystack needle : String}\n  (h1 : needle \u2260 \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  0 \u2264 r \u2227 r < String.length haystack := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_points_to_needle {haystack needle : String}\n  (h1 : needle \u2260 \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  (stringSlice haystack r (r + String.length needle)) = needle := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_earlier_occurrence {haystack needle : String}\n  (h1 : needle \u2260 \"\") (h2 : containsString haystack needle = true) :\n  let r := find_str haystack needle;\n  containsString (stringSlice haystack 0 r) needle = false := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_needle_returns_zero {s : String} {n : Nat}\n  (h1 : s \u2260 \"\") (h2 : n > 0) :\n  find_str (stringRepeat s n) s = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_str \"hello\" \"ll\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_str \"aaaaa\" \"bba\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_str \"\" \"\""
      }
    ]
  },
  "fvapps_002329.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_balloons (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def makeBalloonsString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.join (List.replicate n \"balloon\")"
      },
      {
        "type": "cond",
        "string": "theorem max_balloons_nonnegative (text : String) :\n  max_balloons text \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_balloons_upper_bound (text : String) :\n  max_balloons text \u2264 text.length / 7 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_balloons_has_needed_chars (text : String) (c : Char) :\n  let result := max_balloons text\n  let needed := match c with\n    | 'b' => result\n    | 'a' => result\n    | 'l' => 2 * result\n    | 'o' => 2 * result\n    | 'n' => result\n    | _ => 0\n  (text.toList.filter (\u00b7 = c)).length \u2265 needed :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_balloons_exact (n : Nat) :\n  max_balloons (makeBalloonsString n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_balloons_no_relevant_chars (text : String)\n  (h : \u2200 c \u2208 text.toList, c \u2209 ['b', 'a', 'l', 'o', 'n']) :\n  max_balloons text = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_balloons \"nlaebolko\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_balloons \"loonbalxballpoon\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_balloons \"leetcode\""
      }
    ]
  },
  "fvapps_002332.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse_vowels (s : String) : String := sorry\n\ndef isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'"
      },
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.filter (\u00b7 == c) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem reverse_vowels_length_unchanged (s : String) :\n  (reverse_vowels s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_vowels_consonants_unchanged (s : String) (i : String.Pos) :\n  \u00acisVowel (s.get i) \u2192 (reverse_vowels s).get i = s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_vowels_idempotent (s : String) :\n  reverse_vowels (reverse_vowels s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_vowels_preserves_count (s : String) (c : Char) :\n  isVowel c \u2192 count_char (reverse_vowels s) c = count_char s c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_vowels_no_vowels (s : String) :\n  (\u2200 i : String.Pos, \u00acisVowel (s.get i)) \u2192 reverse_vowels s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'holle'\n-/\n#guard_msgs in\n#eval reverse_vowels \"hello\"\n\n/-\ninfo: 'leotcede'\n-/\n#guard_msgs in\n#eval reverse_vowels \"leetcode\"\n\n/-\ninfo: 'Aa'\n-/\n#guard_msgs in\n#eval reverse_vowels \"aA\""
      }
    ]
  },
  "fvapps_002334.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def remove_palindrome_subseq (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounds (s : String) :\n  0 \u2264 remove_palindrome_subseq s \u2227 remove_palindrome_subseq s \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  remove_palindrome_subseq \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_type (s : String) :\n  s.length = 1 \u2192 remove_palindrome_subseq s = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_valid_results (s : String) :\n  remove_palindrome_subseq s = 0 \u2228\n  remove_palindrome_subseq s = 1 \u2228\n  remove_palindrome_subseq s = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"ababa\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"abb\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"baabb\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval remove_palindrome_subseq \"\""
      }
    ]
  },
  "fvapps_002341.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def backspace_compare (s1: String) (s2: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def normalize_backspace (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem backspace_compare_matches_naive (s1 s2: String) :\n  backspace_compare s1 s2 = (normalize_backspace s1 = normalize_backspace s2) :=\nby"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem self_compare (s: String) :\n  backspace_compare s s = true :=\nby"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem symmetric (s1 s2: String) :\n  backspace_compare s1 s2 = backspace_compare s2 s1 :=\nby"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab#c\" \"ad#c\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval backspace_compare \"ab##\" \"c#d#\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval backspace_compare \"a#c\" \"b\""
      }
    ]
  },
  "fvapps_002344.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def to_hex (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to convert hex string to number (just for theorem statements) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def hexToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_hex_positive_integers (n : Nat) (h : n < 2^32) :\n  let result := to_hex n\n  (hexToNat result = n) \u2227\n  (result.length \u2264 8) \u2227\n  (\u2200 c \u2208 result.data, c \u2208 ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_hex_negative_integers (n : Int) (h1 : -(2^31) \u2264 n) (h2 : n < 0) :\n  let result := to_hex n\n  (result.length = 8) \u2227\n  (\u2200 c \u2208 result.data, c \u2208 ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']) \u2227\n  (let value := hexToNat result\n   if value \u2265 2^31 then\n     value - 2^32 = n\n   else\n     value = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_hex_zero :\n  to_hex 0 = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_hex_length (n : Int) :\n  let result := to_hex n\n  1 \u2264 result.length \u2227 result.length \u2264 8 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1a'\n-/\n#guard_msgs in\n#eval to_hex 26\n\n/-\ninfo: 'ffffffff'\n-/\n#guard_msgs in\n#eval to_hex -1\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval to_hex 0"
      }
    ]
  },
  "fvapps_002347.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def title_to_number (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def number_to_title (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem title_to_number_positive (title : String) :\n  title_to_number title > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem title_to_number_monotone (title : String) :\n  (title.length > 1) \u2192\n  title_to_number title > title_to_number (String.dropRight title 1) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem title_to_number_roundtrip (n : Nat) :\n  n > 0 \u2192 n \u2264 2^20 \u2192\n  title_to_number (number_to_title n) = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval title_to_number \"A\"\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval title_to_number \"AB\"\n\n/-\ninfo: 701\n-/\n#guard_msgs in\n#eval title_to_number \"ZY\""
      }
    ]
  },
  "fvapps_002356.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def rob (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def elementsAtEvenIndices (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def elementsAtOddIndices (nums : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  List.foldl Nat.add 0 nums"
      },
      {
        "type": "cond",
        "string": "theorem rob_nonnegative (nums : List Nat) :\n  rob nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_even_indices_bound (nums : List Nat) (h : nums \u2260 []) :\n  rob nums \u2265 List.foldl Nat.max 0 (elementsAtEvenIndices nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_odd_indices_bound (nums : List Nat) (h : nums \u2260 []) :\n  rob nums \u2265 List.foldl Nat.max 0 (elementsAtOddIndices nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_minimum_of_first_two (nums : List Nat) (h : nums.length \u2265 2) :\n  rob nums \u2265 Nat.max (nums.get \u27e80, sorry\u27e9) (nums.get \u27e81, sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_subset_sum (nums : List Nat) :\n  rob nums \u2264 list_sum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_empty :\n  rob [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_singleton (n : Nat) :\n  rob [n] = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rob_pair (n m : Nat) :\n  rob [n, m] = Nat.max n m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval rob [1, 2, 3, 1]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval rob [2, 7, 9, 3, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval rob [2, 1]"
      }
    ]
  },
  "fvapps_002362.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numSpecialEquivGroups (strings : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSpecialEquivalent (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def belongsToGroup (s : String) (g : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: Number of groups is bounded by list size"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem num_groups_bounded (strings : List String) :\n  1 \u2264 numSpecialEquivGroups strings \u2227 numSpecialEquivGroups strings \u2264 strings.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: Special equivalent strings belong to same group"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem special_equiv_same_group (s1 s2 : String) :\n  isSpecialEquivalent s1 s2 = true \u2192\n  \u2203 g, belongsToGroup s1 g = true \u2227 belongsToGroup s2 g = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: Upper bound for unique strings"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem unique_strings_bound (strings : List String) (h : strings.Nodup) :\n  numSpecialEquivGroups strings \u2264 strings.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: Function is permutation invariant"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem permutation_invariant (strings : List String) :\n  numSpecialEquivGroups strings = numSpecialEquivGroups strings.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abcd\", \"cdab\", \"cbad\", \"xyzz\", \"zzxy\", \"zzyx\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval numSpecialEquivGroups [\"aa\", \"bb\", \"ab\", \"ba\"]"
      }
    ]
  },
  "fvapps_002365.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_cost_to_move_chips (positions: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_even (positions: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_upper_bound (positions: List Nat) (h: positions \u2260 []) :\n  min_cost_to_move_chips positions \u2264 positions.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_cost_non_negative (positions: List Nat) :\n  min_cost_to_move_chips positions \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [2, 2, 2, 3, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_move_chips [1, 1000000000]"
      }
    ]
  },
  "fvapps_002366.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def array_pair_sum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.sorted (xs : List Int) : List Int := xs -- placeholder for sorting\n\ndef evenIndexSum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  let rec loop : List Int \u2192 Int \u2192 Int \u2192 Int\n    | [], _, acc => acc\n    | (x::xs), i, acc => loop xs (i+1) (if i % 2 = 0 then acc + x else acc)\n  loop xs 0 0"
      },
      {
        "type": "sig",
        "string": "def halfListSum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  let rec loop : List Int \u2192 Nat \u2192 Int \u2192 Int\n    | [], _, acc => acc\n    | _, 0, acc => acc\n    | (x::xs), n+1, acc => loop xs n (acc + x)\n  loop xs (xs.length / 2) 0"
      },
      {
        "type": "cond",
        "string": "theorem array_pair_sum_equals_even_indexed_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums = evenIndexSum (nums.sorted) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_pair_sum_geq_smallest_half_sum {nums : List Int}\n  (h : nums.length % 2 = 0) :\n  array_pair_sum nums \u2265 halfListSum (nums.sorted) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_pair_sum_positive {nums : List Int}\n  (h1 : nums.length % 2 = 0)\n  (h2 : \u2200 x \u2208 nums, x > 0) :\n  array_pair_sum nums > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 4, 3, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 2, 3, 4]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval array_pair_sum [1, 1, 2, 2]"
      }
    ]
  },
  "fvapps_002370.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def number_of_steps (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_power_of_two (n: Nat) : Bool := sorry\n\ndef simulation_loop (n steps: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => steps\n  | n+1 => if n % 2 = 0\n           then simulation_loop (n / 2) (steps + 1)\n           else simulation_loop (n - 1) (steps + 1)"
      },
      {
        "type": "cond",
        "string": "theorem number_of_steps_nonneg (n: Nat) :\n  number_of_steps n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_steps :\n  number_of_steps 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval number_of_steps 14\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval number_of_steps 8\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval number_of_steps 123"
      }
    ]
  },
  "fvapps_002371.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def repeatedSubstringPattern (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeatedSubstringPattern_single_char {s: String} :\n  s.length = 1 \u2192 \u00acrepeatedSubstringPattern s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rotateString (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeatedSubstringPattern_rotation {s: String} (h: s.length \u2265 2) :\n  repeatedSubstringPattern s \u2192\n  repeatedSubstringPattern (rotateString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allCharsSame (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeatedSubstringPattern_doubled {s: String} (h: s.length > 0) :\n  repeatedSubstringPattern (s ++ s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeatedSubstringPattern_n_times {s: String} (n: Nat)\n    (h1: s.length > 0) (h2: n \u2265 3) (h3: n \u2264 10) :\n  repeatedSubstringPattern (String.append s (String.append s s)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeatedSubstringPattern_prime_length {s: String} (h1: s.length > 1) :\n  isPrime s.length \u2192\n  \u00acallCharsSame s \u2192\n  \u00acrepeatedSubstringPattern s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abab\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"aba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval repeatedSubstringPattern \"abcabcabcabc\""
      }
    ]
  },
  "fvapps_002378.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def defang_ip_addr (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem defang_valid_ip_length {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : \u2200 x \u2208 octets, x \u2264 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  defanged.length = ip.length + 6 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.filter (\u00b7 = c) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem defang_valid_ip_reversible {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : \u2200 x \u2208 octets, x \u2264 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  String.replace \"[.]\" \".\" defanged = ip :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem defang_valid_ip_count_dots {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : \u2200 x \u2208 octets, x \u2264 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  countChar defanged '[' = countChar ip '.' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem defang_valid_ip_chars_match {octets : List Nat}\n  (h1 : octets.length = 4)\n  (h2 : \u2200 x \u2208 octets, x \u2264 255) :\n  let ip := String.intercalate \".\" (octets.map toString)\n  let defanged := defang_ip_addr ip\n  let original_chars := ip.toList.filter (\u00b7 \u2260 '.')\n  let defanged_chars := defanged.toList.filter (fun c => c \u2260 '[' \u2227 c \u2260 ']' \u2227 c \u2260 '.')\n  original_chars = defanged_chars :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem defang_generic_string_length (s : String) :\n  let defanged := defang_ip_addr s\n  defanged.length = s.length + (2 * countChar s '.') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem defang_generic_string_reversible (s : String) :\n  let defanged := defang_ip_addr s\n  String.replace \"[.]\" \".\" defanged = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1[.]1[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"1.1.1.1\"\n\n/-\ninfo: '255[.]100[.]50[.]0'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"255.100.50.0\"\n\n/-\ninfo: '192[.]168[.]1[.]1'\n-/\n#guard_msgs in\n#eval defang_ip_addr \"192.168.1.1\""
      }
    ]
  },
  "fvapps_002379.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def can_be_equal (xs ys : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPerm (xs ys : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function for list sum -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listSum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get nth element -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def getNth (xs : List Int) (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_lists_are_equal (xs : List Int) :\n  can_be_equal xs xs = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Helper function to check if one list is a permutation of another -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem permuted_lists_are_equal {xs ys : List Int} :\n  isPerm xs ys \u2192 can_be_equal xs ys = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_value_not_equal {xs ys : List Int} (h1 : xs \u2260 []) (h2 : ys \u2260 []) :\n  (\u2203 i : Nat, getNth ys i = getNth xs i + (listSum xs + 1)) \u2192\n  can_be_equal xs ys = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_length_not_equal {xs : List Int} (y : Int) :\n  can_be_equal xs (xs ++ [y]) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [1, 2, 3, 4] [2, 4, 1, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval can_be_equal [7] [7]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval can_be_equal [3, 7, 9] [3, 7, 11]"
      }
    ]
  },
  "fvapps_002384.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_power (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def max_run (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_power_lower_bound (s : List Char) (h : s.length > 0) :\n  max_power s \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_power_upper_bound (s : List Char) :\n  max_power s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_power_equals_longest_run (s : List Char) (h : s.length > 0) :\n  max_power s = max_run s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_power_single_char (s : List Char) (h : s.length > 0)\n  (h' : \u2200 (i j : Fin s.length), s.get i = s.get j) :\n  max_power s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_power_alternating (s : List Char) (h : s.length \u2265 2)\n  (h' : \u2200 (i : Fin s.length),\n    if i.val % 2 = 0\n    then s.get i = 'a'\n    else s.get i = 'b') :\n  max_power s = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval max_power \"leetcode\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_power \"abbcccddddeeeeedcba\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_power \"tourist\""
      }
    ]
  },
  "fvapps_002386.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxProfit (prices: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def maxPairwiseDiff (prices: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match prices with\n  | [] => 0\n  | x::xs => match xs with\n    | [] => 0\n    | _ => sorry"
      },
      {
        "type": "cond",
        "string": "theorem maxprofit_bounds_pair (a b: Nat) :\n  maxProfit [a, b] = max 0 (b - a) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval maxProfit [7, 1, 5, 3, 6, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval maxProfit [1, 2, 3, 4, 5]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval maxProfit [7, 6, 4, 3, 1]"
      }
    ]
  },
  "fvapps_002390.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_isomorphic (s1 s2 : List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def unique_chars (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem isomorphic_same_length {s1 s2 : List Char} :\n  s1.length \u2260 s2.length \u2192 \u00acis_isomorphic s1 s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isomorphic_identical_strings {s : List Char} :\n  is_isomorphic s s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isomorphic_reversible {s1 s2 : List Char} :\n  s1.length = s2.length \u2192\n  is_isomorphic s1 s2 = is_isomorphic s2 s1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isomorphic_preserves_uniqueness {s1 s2 : List Char} :\n  s1.length = s2.length \u2192\n  is_isomorphic s1 s2 \u2192\n  unique_chars s1 = unique_chars s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem isomorphic_repeated_chars {s1 s2 : List Char} :\n  s1.length = s2.length \u2192\n  s1.length \u2265 2 \u2192\n  unique_chars s1 = 1 \u2192\n  (is_isomorphic s1 s2 \u2194 unique_chars s2 = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"egg\" \"add\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_isomorphic \"foo\" \"bar\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_isomorphic \"paper\" \"title\""
      }
    ]
  },
  "fvapps_002391.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countCharacters : List String \u2192 String \u2192 Nat\n  | words, chars => sorry\n\ndef canForm (w : String) (chars : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  let check (c : Char) := w.count c \u2264 chars.count c\n  w.data.all check"
      },
      {
        "type": "cond",
        "string": "theorem count_characters_nonnegative (words : List String) (chars : String) :\n  countCharacters words chars \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_characters_bounded_by_total_length (words : List String) (chars : String) :\n  countCharacters words chars \u2264 (words.map String.length).foldl (\u00b7 + \u00b7) 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_characters_empty_chars (words : List String) :\n  countCharacters words \"\" = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_characters_monotone (words : List String) (chars s : String) :\n  countCharacters words (chars ++ s) \u2265 countCharacters words chars := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_characters_substring_property (words : List String) (chars : String) :\n  countCharacters words chars =\n    (List.map String.length\n      (List.filter (fun w => canForm w chars) words)).foldl (\u00b7 + \u00b7) 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval countCharacters [\"cat\", \"bt\", \"hat\", \"tree\"] \"atach\"\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval countCharacters [\"hello\", \"world\", \"leetcode\"] \"welldonehoneyr\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval countCharacters [\"good\", \"best\", \"word\"] \"bestword\""
      }
    ]
  },
  "fvapps_002392.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort (as : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countMismatches (xs ys : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def height_checker (heights : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem height_checker_singleton (x : Nat) :\n  height_checker [x] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem height_checker_uniform (x n : Nat) :\n  n > 0 \u2192\n  height_checker (List.replicate n x) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval height_checker [1, 1, 4, 2, 1, 3]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval height_checker [5, 1, 2, 3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval height_checker [1, 2, 3, 4, 5]"
      }
    ]
  },
  "fvapps_002393.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_moves (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_minimum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_non_negative (nums : List Int) (h : nums \u2260 []) :\n  min_moves nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_equal_elements (n : Int) (len : Nat) (h : len \u2265 1) :\n  min_moves (List.replicate len n) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_upper_bound (nums : List Int) (h : nums \u2260 []) :\n  let min_val := list_minimum nums\n  min_moves nums \u2264 list_sum (nums.map (\u03bb x => x - min_val)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_moves_monotonic (nums : List Int) (h : nums.length \u2265 2) :\n  let new_nums := nums ++ [list_maximum nums]\n  min_moves new_nums \u2265 min_moves nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves [1, 1, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_moves [1, 2, 3, 4]"
      }
    ]
  },
  "fvapps_002396.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidEmail (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def numUniqueEmails (emails : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem numUniqueEmails_bounds (emails : List String) :\n  let result := numUniqueEmails emails\n  0 \u2264 result \u2227 result \u2264 emails.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numUniqueEmails_idempotent (emails : List String) :\n  emails \u2260 [] \u2192\n  numUniqueEmails (emails ++ emails) = numUniqueEmails emails :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numUniqueEmails_dot_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let dotted := String.join [local_domain.get! 0, \"@\", local_domain.get! 1]\n  numUniqueEmails [email, dotted] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numUniqueEmails_plus_invariant (email : String) (h : isValidEmail email) :\n  let local_domain := email.splitOn \"@\"\n  let plusAdded := String.join [local_domain.get! 0, \"+anything@\", local_domain.get! 1]\n  numUniqueEmails [email, plusAdded] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.e.mail+bob.cathy@leetcode.com\", \"testemail+david@lee.tcode.com\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval num_unique_emails [\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval num_unique_emails [\"test.email+alex@leetcode.com\", \"test.email@leetcode.com\"]"
      }
    ]
  },
  "fvapps_002398.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_distance_value (arr1 arr2 : List Int) (d : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_distance_value_non_negative\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 \u2260 []) (h2 : arr2 \u2260 []) :\n  find_distance_value arr1 arr2 d \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if x \u2265 0 then x else -x"
      },
      {
        "type": "cond",
        "string": "theorem find_distance_value_bounded\n  (arr1 arr2 : List Int) (d : Nat)\n  (h1 : arr1 \u2260 []) (h2 : arr2 \u2260 []) :\n  find_distance_value arr1 arr2 d \u2264 arr1.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_distance_value_empty_arr2\n  (arr1 : List Int) (d : Nat)\n  (h : arr1 \u2260 []) :\n  find_distance_value arr1 [] d = arr1.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_distance_value_zero_distance\n  (arr1 arr2 : List Int)\n  (h1 : arr1 \u2260 []) (h2 : arr2 \u2260 []) :\n  find_distance_value arr1 arr2 0 =\n    (arr1.filter (fun x => x \u2209 arr2)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [4, 5, 8] [10, 9, 1, 8] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_distance_value [1, 4, 2, 3] [-4, -3, 6, 10, 20, 30] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_distance_value [2, 1, 100, 3] [-5, -2, 10, -3, 7] 6"
      }
    ]
  },
  "fvapps_002399.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def to_goat_latin (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getStringAt (words : List String) (i : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def endsWith (s : String) (suffix : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def dropRight (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def firstChar (s : String) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def dropFirst (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_goat_latin_vowel_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let orig := splitString s\n  let result := splitString (to_goat_latin s)\n  let orig_word := getStringAt orig i\n  let transformed := dropRight (getStringAt result i) (2 + (i+1))\n  if (firstChar orig_word).toLower \u2208 ['a', 'e', 'i', 'o', 'u'] then\n    transformed = orig_word\n  else\n    transformed = dropFirst orig_word ++ String.mk [firstChar orig_word] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_goat_latin_trailing_a_count {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  countChar (getStringAt result i) 'a' \u2265 i + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_goat_latin_preserves_word_count {s : String} :\n  (splitString s).length = (splitString (to_goat_latin s)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_goat_latin_ma_suffix_rule {s : String} (i : Nat) (h : i < (splitString s).length) :\n  let result := splitString (to_goat_latin s)\n  let suffix := \"ma\" ++ String.mk (List.replicate (i+1) 'a')\n  endsWith (getStringAt result i) suffix :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval to_goat_latin \"I speak Goat Latin\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval to_goat_latin \"The quick brown fox\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval to_goat_latin \"Each word\""
      }
    ]
  },
  "fvapps_002403.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prefix_of_word (sentence search : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def startsWith (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def words (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_search_property {sentence : String} :\n  is_prefix_of_word sentence \"\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i love eating burger\" \"burg\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"this problem is an easy problem\" \"pro\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval is_prefix_of_word \"i am tired\" \"you\""
      }
    ]
  },
  "fvapps_002404.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse_integer (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- 32-bit integer bounds"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def INT32_MAX : Int := 2^31 - 1"
      },
      {
        "type": "sig",
        "string": "def INT32_MIN : Int := -(2^31)"
      },
      {
        "type": "cond",
        "string": "theorem reverse_integer_sign (x : Int) :\n  let result := reverse_integer x\n  (result = 0) \u2228 (result > 0 \u2227 x > 0) \u2228 (result < 0 \u2227 x < 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_integer_bounds (x : Int) :\n  let result := reverse_integer x\n  INT32_MIN \u2264 result \u2227 result \u2264 INT32_MAX :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_numbers (x : Int) :\n  0 \u2264 x \u2227 x \u2264 9 \u2192\n  reverse_integer x = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trailing_zeros (x : Int) :\n  x > 0 \u2192\n  x % 10 = 0 \u2192\n  reverse_integer x < x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem int32_bounds (x : Int) :\n  INT32_MIN \u2264 x \u2227 x \u2264 INT32_MAX \u2192\n  let result := reverse_integer x\n  INT32_MIN \u2264 result \u2227 result \u2264 INT32_MAX :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem overflow_cases :\n  reverse_integer 1534236469 = 0 \u2227\n  reverse_integer (-2147483648) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 321\n-/\n#guard_msgs in\n#eval reverse_integer 123\n\n/-\ninfo: -321\n-/\n#guard_msgs in\n#eval reverse_integer -123\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval reverse_integer 120"
      }
    ]
  },
  "fvapps_002405.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reformat (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reformat_empty_string (s : String) :\n  let letters := s.data.filter isAlpha |>.length\n  let digits := s.data.filter isDigit |>.length\n  letters - digits > 1 \u2228 digits - letters > 1 \u2192\n  reformat s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countLetters (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter isAlpha |>.length"
      },
      {
        "type": "sig",
        "string": "def countDigits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter isDigit |>.length"
      },
      {
        "type": "cond",
        "string": "theorem reformat_preserves_length (s : String) :\n  reformat s \u2260 \"\" \u2192\n  (reformat s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reformat_preserves_chars (s : String) :\n  reformat s \u2260 \"\" \u2192\n  (reformat s).data = s.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reformat_alternates (s : String) :\n  reformat s \u2260 \"\" \u2192\n  \u2200 i < (reformat s).length - 1,\n    (isAlpha ((reformat s).data[i]!) = !isAlpha ((reformat s).data[i+1]!)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reformat_preserves_letter_count (s : String) :\n  reformat s \u2260 \"\" \u2192\n  countLetters (reformat s) = countLetters s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reformat_preserves_digit_count (s : String) :\n  reformat s \u2260 \"\" \u2192\n  countDigits (reformat s) = countDigits s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval reformat \"leetcode\""
      }
    ]
  },
  "fvapps_002406.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countAndSay (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem countAndSay_one : countAndSay 1 = \"1\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Every output is a string of nonzero length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem countAndSay_nonempty (n: Nat) (h: n > 0) :\n  (countAndSay n).length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The output only contains ASCII digits -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem countAndSay_digits_only (n: Nat) (h: n > 0) :\n  \u2200 p: String.Pos,\n    '0' \u2264 (countAndSay n).get p \u2227 (countAndSay n).get p \u2264 '9' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Each count-and-say result follows from the previous number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem countAndSay_inductive_step (n: Nat) (h: n > 1) :\n  \u2203 counts digits: List Nat,\n    counts.length = digits.length \u2227\n    (\u2200 d \u2208 digits, d \u2264 9) \u2227\n    (\u2200 c \u2208 counts, c > 0) \u2227\n    countAndSay n = String.join (List.map (\u03bb (p: Nat \u00d7 Nat) => toString p.1 ++ toString p.2)\n                                        (List.zip counts digits)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval count_and_say 1\n\n/-\ninfo: '1211'\n-/\n#guard_msgs in\n#eval count_and_say 4\n\n/-\ninfo: '111221'\n-/\n#guard_msgs in\n#eval count_and_say 5"
      }
    ]
  },
  "fvapps_002407.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_freq (l: List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_shortest_subarray (l : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_subarray_bounds {l : List Int} (h: l \u2260 []) :\n  1 \u2264 find_shortest_subarray l \u2227 find_shortest_subarray l \u2264 l.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_list {l : List Int} (h: l.length = 1) :\n  find_shortest_subarray l = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 2, 2, 3, 1, 4, 2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_shortest_subarray [1, 1, 2, 2, 2, 1]"
      }
    ]
  },
  "fvapps_002408.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_length_of_lcis (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcis_length_properties (nums : List Int) :\n  let result := find_length_of_lcis nums\n  result \u2265 0 \u2227\n  result \u2264 nums.length \u2227\n  (nums.length = 0 \u2192 result = 0) \u2227\n  (nums.length > 0 \u2192 result \u2265 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_strictly_increasing (nums : List Int) (i : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  i > 0 && i < nums.length && nums[i]! > nums[i-1]!"
      },
      {
        "type": "sig",
        "string": "def count_max_increasing (nums : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 4, 7]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_length_of_lcis [2, 2, 2, 2, 2]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_length_of_lcis [1, 3, 5, 7]"
      }
    ]
  },
  "fvapps_002409.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hammingDistance (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def bitLength (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_symmetry (x y : Nat) :\n  hammingDistance x y = hammingDistance y x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_self (x : Nat) :\n  hammingDistance x x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_nonnegative (x y : Nat) :\n  hammingDistance x y \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_upper_bound (x y : Nat) :\n  hammingDistance x y \u2264 max (bitLength x) (bitLength y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_distance 1 4\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_distance 3 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_distance 0 7"
      }
    ]
  },
  "fvapps_002410.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countTrailingZeroes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countActualZeros (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_matches_actual {n : Nat} (h : n \u2264 1000) :\n  countTrailingZeroes n = countActualZeros (factorial n) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_non_negative (n : Nat) :\n  countTrailingZeroes n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_less_than_five {n : Nat} (h : n < 5) :\n  countTrailingZeroes n = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_zero :\n  countTrailingZeroes 0 = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_one :\n  countTrailingZeroes 1 = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 5\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_trailing_zeroes 10"
      }
    ]
  },
  "fvapps_002417.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def valid_palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool := s == reverse s"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_basic (s : String) :\n  isPalindrome s \u2192 valid_palindrome s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_palindrome (s : String) :\n  s.length \u2264 1 \u2192 valid_palindrome s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_remove_char (s : String) :\n  s.length > 1 \u2192 isPalindrome s \u2192\n  valid_palindrome (s.take (s.length - 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nearly_palindrome (s : String) (x : Char) :\n  s.length \u2265 3 \u2192\n  let palindrome := s ++ reverse s\n  let middle := palindrome.length / 2\n  let nearly_pal := palindrome.take middle ++ String.mk [x] ++ palindrome.drop middle\n  valid_palindrome nearly_pal :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_palindrome (s : String) :\n  s.length \u2265 2 \u2192\n  \u00ac(isPalindrome s) \u2192\n  (let count := (List.zip s.data (reverse s).data).filter (fun p => p.1 \u2260 p.2) |>.length\n   count > 2) \u2192\n  \u00ac(valid_palindrome s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"aba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"abca\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_palindrome \"abc\""
      }
    ]
  },
  "fvapps_002421.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def largest_triangle_perimeter (xs: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n| [] => 0\n| x::xs => x + list_sum xs\n\ndef list_get (l: List Nat) (i: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "match l with\n| [] => 0\n| x::xs => if i = 0 then x else list_get xs (i-1)"
      },
      {
        "type": "cond",
        "string": "theorem perimeter_bounds {nums : List Nat} (h : nums.length \u2265 3) :\n  let result := largest_triangle_perimeter nums\n  (result = 0 \u2228 (result > 0 \u2227 result \u2264 list_sum nums)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_inequality {nums : List Nat} (h : nums.length \u2265 3) :\n  let result := largest_triangle_perimeter nums\n  result > 0 \u2192\n  \u2203 i j k, i < nums.length \u2227 j < nums.length \u2227 k < nums.length \u2227\n          i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n          list_get nums i < list_get nums j + list_get nums k \u2227\n          result \u2265 list_get nums i + list_get nums j + list_get nums k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_independent {nums nums' : List Nat} (h : nums.length \u2265 3)\n  (h2 : nums.length = nums'.length)\n  (h3 : \u2200 x, x \u2208 nums \u2194 x \u2208 nums') :\n  largest_triangle_perimeter nums = largest_triangle_perimeter nums' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_positive_result {nums : List Nat} (h : nums.length \u2265 3)\n  (h\u2082 : \u2200 x \u2208 nums, x = 0) :\n  largest_triangle_perimeter nums = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_cases_unit :\n  largest_triangle_perimeter [1,1,1] = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimal_cases_invalid :\n  largest_triangle_perimeter [1,1,2] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [2, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [1, 2, 1]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval largest_triangle_perimeter [3, 2, 3, 4]"
      }
    ]
  },
  "fvapps_002423.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_monotonic (nums: List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_or_single_element_lists_monotonic (nums: List Int) :\n  nums.length \u2264 1 \u2192 is_monotonic nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (nums: List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match nums with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x \u2264 y && isSorted (y::rest)"
      },
      {
        "type": "cond",
        "string": "theorem identical_elements_monotonic (nums: List Int) (x: Int) (h: nums.length \u2265 2) :\n  (\u2200 i: Fin nums.length, nums.get i = x) \u2192 is_monotonic nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_lists_monotonic (nums: List Int) (h: nums.length \u2265 2) :\n  isSorted nums \u2192 is_monotonic nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_monotonic_lists_false (nums: List Int) (h: nums.length \u2265 3) :\n  (\u2200 i: Fin nums.length, \u2200 j: Fin nums.length,\n    i.val + 1 = j.val \u2192 \u00ac(nums.get i \u2264 nums.get j)) \u2227\n  (\u2200 i: Fin nums.length, \u2200 j: Fin nums.length,\n    i.val + 1 = j.val \u2192 \u00ac(nums.get i \u2265 nums.get j)) \u2192\n  \u00acis_monotonic nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [1, 2, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_monotonic [6, 5, 4, 4]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_monotonic [1, 3, 2]"
      }
    ]
  },
  "fvapps_002430.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countSpaces (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def split (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def startsWith (s : String) (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reorderSpaces (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reorderSpaces_preserves_spaces (s : String) :\n  countSpaces s = countSpaces (reorderSpaces s) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reorderSpaces_preserves_words (s : String) :\n  split s = split (reorderSpaces s) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reorderSpaces_no_leading_spaces (s : String) :\n  \u00acstartsWith (reorderSpaces s) ' ' := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'this   is   a   sentence'\n-/\n#guard_msgs in\n#eval reorder_spaces \"  this   is  a sentence \"\n\n/-\ninfo: 'practice   makes   perfect '\n-/\n#guard_msgs in\n#eval reorder_spaces \" practice   makes   perfect\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval reorder_spaces \"a\""
      }
    ]
  },
  "fvapps_002442.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_shoe_shop_earnings (num_shoes : Nat) (shoe_sizes : List Nat)\n    (customer_requests : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_successful_sales (shoe_sizes : List Nat) (customer_requests : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_request_prices (requests : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Earnings cannot be negative (this is implied by Nat return type)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem earnings_nonnegative\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat \u00d7 Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Earnings cannot exceed sum of requested prices"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem earnings_upper_bound\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat \u00d7 Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes customer_requests \u2264\n    sum_request_prices customer_requests :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Cannot sell more shoes than inventory"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sales_limited_by_inventory\n    (num_shoes : Nat) (shoe_sizes : List Nat) (customer_requests : List (Nat \u00d7 Nat)) :\n    count_successful_sales shoe_sizes customer_requests \u2264 shoe_sizes.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty inventory yields zero earnings"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_inventory_zero_earnings (requests : List (Nat \u00d7 Nat)) :\n    calculate_shoe_shop_earnings 0 [] requests = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Order of inventory doesn't affect earnings"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem inventory_order_invariant\n    (num_shoes : Nat) (shoe_sizes : List Nat) (requests : List (Nat \u00d7 Nat)) :\n    calculate_shoe_shop_earnings num_shoes shoe_sizes requests =\n    calculate_shoe_shop_earnings num_shoes shoe_sizes.reverse requests :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 200\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 10 [2, 3, 4, 5, 6, 8, 7, 6, 5, 18] [(6, 55), (6, 45), (6, 55), (4, 40), (18, 60), (10, 50)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 0 [] [(6, 55)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_shoe_shop_earnings 1 [2] [(3, 50)]"
      }
    ]
  },
  "fvapps_002444.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Email := String"
      },
      {
        "type": "sig",
        "string": "def validate_emails (emails : List Email) : List Email :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidEmailFormat (e : Email) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For a list of valid email addresses, all should be returned unchanged -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_valid_emails (emails : List Email)\n  (h : \u2200 e \u2208 emails, isValidEmailFormat e) :\n  validate_emails emails = emails :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of invalid email addresses, an empty list should be returned -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_invalid_emails (emails : List Email)\n  (h : \u2200 e \u2208 emails, \u00ac isValidEmailFormat e) :\n  validate_emails emails = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For a mixed list of valid and invalid emails, only valid ones should be returned -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_mixed_emails (emails : List Email)\n  (valid : List Email := emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Function should not crash on arbitrary string input -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_arbitrary_input (inputs : List String) :\n  \u2203 result, validate_emails inputs = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: ['DEXTER <dexter@hotmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"DEXTER <dexter@hotmail.com>\", \"VIRUS <virus!@variable.:p>\"]\n\n/-\ninfo: ['ALICE <alice123@gmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"ALICE <alice123@gmail.com>\"]\n\n/-\ninfo: ['CAROL <carol@xyz.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"INVALID <inv@k.>\", \"CAROL <carol@xyz.com>\"]"
      }
    ]
  },
  "fvapps_002445.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def generateLogo (thickness : Nat) : String := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter (\u00b7 = c) |>.length"
      },
      {
        "type": "sig",
        "string": "def splitLines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  s.splitOn \"\\n\""
      },
      {
        "type": "sig",
        "string": "def makeHString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk (List.replicate n 'H')"
      },
      {
        "type": "cond",
        "string": "theorem logo_lines_count (thickness : Nat) (h : thickness > 0) :\n  let result := generateLogo thickness\n  let lines := splitLines result\n  lines.length = thickness + (thickness + 1) + ((thickness + 1)/2) + (thickness + 1) + thickness :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem logo_valid_chars (thickness : Nat) (h : thickness > 0) :\n  let result := generateLogo thickness\n  let lines := splitLines result\n  \u2200 line \u2208 lines, \u2200 c \u2208 line.data, c = 'H' \u2228 c = ' ' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem logo_first_last_line_H_count (thickness : Nat) (h : thickness > 0) :\n  let result := generateLogo thickness\n  let lines := splitLines result\n  (countChar lines[0]! 'H' = 1) \u2227\n  (countChar lines[lines.length - 1]! 'H' = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem logo_middle_section_solid (thickness : Nat) (h : thickness > 0) :\n  let result := generateLogo thickness\n  let lines := splitLines result\n  let middleStart := thickness + (thickness + 1)\n  let middleSection := lines.drop middleStart |>.take ((thickness + 1)/2)\n  \u2200 line \u2208 middleSection, \u2200 i \u2208 line.data.take (5 * thickness), i = 'H' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002446.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_weekday_name (month : Nat) (day : Nat) (year : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure Date where\n  month : Nat\n  day : Nat\n  year : Nat"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def IsValidDate (d : Date) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def weekday (d : Date) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calendar_day_name (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def IsUppercase (s : String) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def IsValidWeekdayName (s : String) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_weekday_name_matches_calendar\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 \u2264 m \u2227 m \u2264 12)\n    (h2 : 1 \u2264 d \u2227 d \u2264 31)\n    (h3 : 1900 \u2264 y \u2227 y \u2264 2100)\n    (h4 : IsValidDate \u27e8m, d, y\u27e9) :\n    get_weekday_name m d y = calendar_day_name (weekday \u27e8m, d, y\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_weekday_name_returns_uppercase\n    (m : Nat) (d : Nat) (y : Nat)\n    (h1 : 1 \u2264 m \u2227 m \u2264 12)\n    (h2 : 1 \u2264 d \u2227 d \u2264 31)\n    (h3 : 1900 \u2264 y \u2227 y \u2264 2100) :\n    IsValidDate \u27e8m, d, y\u27e9 \u2192\n    (IsUppercase (get_weekday_name m d y) \u2227\n     IsValidWeekdayName (get_weekday_name m d y)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'WEDNESDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 8 5 2015\n\n/-\ninfo: 'SUNDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 1 1 2023\n\n/-\ninfo: 'MONDAY'\n-/\n#guard_msgs in\n#eval get_weekday_name 12 25 2023"
      }
    ]
  },
  "fvapps_002447.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPalindrome (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def check_palindromic_positives (nums : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindromic_positives_negative_number\n  {nums : List Int}\n  (h : \u2203 x \u2208 nums, x \u2264 0) :\n  check_palindromic_positives nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindromic_positives_all_positive\n  {nums : List Int}\n  (h : \u2200 x \u2208 nums, x > 0) :\n  check_palindromic_positives nums =\n    nums.any (fun x => isPalindrome x.toNat) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digits_palindromic\n  {nums : List Int}\n  (h1 : \u2200 x \u2208 nums, x > 0)\n  (h2 : \u2200 x \u2208 nums, x < 10) :\n  check_palindromic_positives nums = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_positive_false\n  {nums : List Int}\n  (h : \u2200 x \u2208 nums, x \u2264 0)\n  (h_nonempty : nums \u2260 []) :\n  check_palindromic_positives nums = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 9, 61, 5, 14]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [-1, 9, 61, 5, 14]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_palindromic_positives [12, 34, 56, 78]"
      }
    ]
  },
  "fvapps_002448.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_distinct_stamps (stamps : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_stamps_bounded (stamps : List String) :\n  count_distinct_stamps stamps \u2264 stamps.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_unique (l : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_stamps_deterministic (stamps : List String) :\n  count_distinct_stamps stamps = count_distinct_stamps stamps :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_stamps_nonnegative (stamps : List String) :\n  count_distinct_stamps stamps \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_stamps_with_duplicates (stamps : List String) :\n  count_distinct_stamps (stamps ++ stamps) = count_distinct_stamps stamps :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_distinct_stamps_empty :\n  count_distinct_stamps [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"UK\", \"China\", \"USA\", \"France\", \"New Zealand\", \"UK\", \"France\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"India\", \"India\", \"India\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_distinct_stamps [\"Japan\", \"Korea\", \"China\"]"
      }
    ]
  },
  "fvapps_002449.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def toString (s : List Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def capitalize_name (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitOn (s : String) (p : Char \u2192 Bool) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def front (s : String) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def drop (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toLower (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def length (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem capitalize_name_preserves_word_count (s : String) :\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem words_start_with_uppercase (s : String) (word : String) :\n  word \u2208 splitOn (capitalize_name s) (fun x => x = ' ') \u2192\n  word.length > 0 \u2192\n  isAlpha (word.front) \u2192\n  isUpper (word.front) \u2227 word.drop 1 = toLower (word.drop 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_only_preserves_length (s : String) :\n  (\u2200 c \u2208 s.data, c = ' ') \u2192\n  (splitOn (capitalize_name s) (fun x => x = ' ')).length =\n  (splitOn s (fun x => x = ' ')).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_alpha_preserved (s : String) :\n  (\u2200 c \u2208 s.data, !isAlpha c) \u2192\n  s.length > 0 \u2192\n  capitalize_name s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002454.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def parse_html (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_lowercase_letter (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def split_lines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  s.splitOn \"\\n\""
      },
      {
        "type": "cond",
        "string": "theorem single_tag_parse {tag : String}\n  (h : \u2200 c, c \u2208 tag.data \u2192 is_lowercase_letter c) :\n  parse_html s!\"<{tag}>\" = tag :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tag_with_attrs_parse {tag : String} {attrs : List (String \u00d7 String)}\n  (h1 : \u2200 c, c \u2208 tag.data \u2192 is_lowercase_letter c)\n  (h2 : \u2200 (k v : String), (k, v) \u2208 attrs \u2192 \u2200 c, c \u2208 k.data \u2192 is_lowercase_letter c) :\n  let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n  let html := s!\"<{tag} {attr_str}>\"\n  let result := split_lines (parse_html html)\n  result[0]! = tag \u2227\n  (\u2200 i k v, attrs[i]! = (k,v) \u2192 result[i+1]! = s!\"-> {k} > {v}\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_tags_parse {tags : List String} {attrs_list : List (List (String \u00d7 String))}\n  (h1 : tags.length > 0)\n  (h2 : attrs_list.length = tags.length)\n  (h3 : \u2200 tag, tag \u2208 tags \u2192 \u2200 c, c \u2208 tag.data \u2192 is_lowercase_letter c)\n  (h4 : \u2200 attrs, attrs \u2208 attrs_list \u2192 \u2200 k v, (k,v) \u2208 attrs \u2192 \u2200 c, c \u2208 k.data \u2192 is_lowercase_letter c) :\n  let html_parts := tags.zip attrs_list |>.map (fun (tag, attrs) =>\n    let attr_str := String.join (attrs.map (fun (k,v) => s!\"{k}=\\\"{v}\\\"\"))\n    s!\"<{tag} {attr_str}>\"\n  )\n  let html := String.intercalate \"\\n\" html_parts\n  let result := split_lines (parse_html html)\n  \u2200 i : Nat, i < tags.length \u2192\n    result[i]! = tags[i]! \u2227\n    \u2200 j k v, attrs_list[i]![j]! = (k,v) \u2192\n      result[i + j + 1]! = s!\"-> {k} > {v}\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem self_closing_tag_parse {tag : String}\n  (h : \u2200 c, c \u2208 tag.data \u2192 is_lowercase_letter c) :\n  parse_html s!\"<{tag}/>\" = tag :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002459.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort_str_special (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_str_preserves_length (s : String) :\n  String.length (sort_str_special s) = String.length s := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_str_preserves_chars (s : String) :\n  String.toList (sort_str_special s) = String.toList s := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digits_ordered_by_parity_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hd1 : isDigit ((sort_str_special s).get i))\n    (hd2 : isDigit ((sort_str_special s).get j)) :\n    let d1 := (sort_str_special s).get i\n    let d2 := (sort_str_special s).get j\n    (d1.toNat % 2 = 0 \u2192 d2.toNat % 2 \u2260 1) \u2227\n    (d1.toNat % 2 = d2.toNat % 2 \u2192 d1.toNat \u2264 d2.toNat) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem letters_ordered_by_case_and_value (s : String) (i j : String.Pos)\n    (h1 : i.1 < String.length (sort_str_special s))\n    (h2 : j.1 < String.length (sort_str_special s))\n    (h3 : i.1 < j.1)\n    (hl1 : (isLower ((sort_str_special s).get i) \u2228 isUpper ((sort_str_special s).get i)))\n    (hl2 : (isLower ((sort_str_special s).get j) \u2228 isUpper ((sort_str_special s).get j))) :\n    let c1 := (sort_str_special s).get i\n    let c2 := (sort_str_special s).get j\n    (isUpper c1 \u2192 \u00acisLower c2) \u2227\n    ((isUpper c1 = isUpper c2) \u2192 c1 \u2264 c2) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002460.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Array.shape (a : Array (Array \u03b1)) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def concatenate_arrays {\u03b1 : Type} (n m p : Nat) (array1 array2 : Array (Array \u03b1)) :\n  Array (Array \u03b1) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenate_arrays_shape (n m p : Nat) (array1 array2 : Array (Array \u03b1)) :\n  (concatenate_arrays n m p array1 array2).shape = (n + m, p) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenate_arrays_preserves_first (n m p : Nat) (array1 array2 : Array (Array \u03b1)) :\n  \u2200 i < n, (concatenate_arrays n m p array1 array2)[i]! = array1[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenate_arrays_preserves_second (n m p : Nat) (array1 array2 : Array (Array \u03b1)) :\n  \u2200 i < m, (concatenate_arrays n m p array1 array2)[n + i]! = array2[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenate_arrays_singleton (n p : Nat) (value : \u03b1)\n  (array1 : Array (Array \u03b1)) (array2 : Array (Array \u03b1)) :\n  array2.size = 1 \u2192\n  (\u2200 i < n, (array1[i]!).size = p) \u2192\n  (array2[0]!).size = p \u2192\n  (concatenate_arrays n 1 p array1 array2).shape = (n + 1, p) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002469.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def array_transforms (input : String) : Array Float \u00d7 Array Float \u00d7 Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def transform_list (numbers : List Float) : Array Float \u00d7 Array Float \u00d7 Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def int_to_float (n : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_transforms_properties {numbers : List Float} (h : numbers.length > 0) :\n  let (floor_arr, ceil_arr, rint_arr) := transform_list numbers\n  let h_sizes : floor_arr.size = numbers.length \u2227 ceil_arr.size = numbers.length \u2227 rint_arr.size = numbers.length := by sorry\n\n  \u2200 i : Fin numbers.length,\n    let idx : Nat := i.val\n    let h_floor : idx < floor_arr.size := by sorry\n    let h_ceil : idx < ceil_arr.size := by sorry\n    let h_rint : idx < rint_arr.size := by sorry\n\n    -- Properties for each element\n    floor_arr[idx]'h_floor \u2264 numbers[idx] \u2227\n    ceil_arr[idx]'h_ceil \u2265 numbers[idx] \u2227\n    floor_arr[idx]'h_floor \u2264 rint_arr[idx]'h_rint \u2227\n    rint_arr[idx]'h_rint \u2264 ceil_arr[idx]'h_ceil \u2227\n    ceil_arr[idx]'h_ceil - floor_arr[idx]'h_floor \u2264 1 \u2227\n    (rint_arr[idx]'h_rint - numbers[idx]).abs \u2264 0.5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_transforms_integers (n : Int) :\n  let res := array_transforms (toString n)\n  let floor_arr := res.1\n  let ceil_arr := res.2.1\n  let rint_arr := res.2.2\n  let h_size : 0 < floor_arr.size := by sorry\n\n  floor_arr = ceil_arr \u2227\n  floor_arr = rint_arr \u2227\n  floor_arr[0]'h_size = int_to_float n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_002470.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minion_game (s : String) : String := sorry\n\ndef is_vowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'"
      },
      {
        "type": "sig",
        "string": "def score_from_result (result : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if result == \"Draw\" then 0\n  else String.toNat! (result.splitOn \" \" |>.get! 1)"
      },
      {
        "type": "cond",
        "string": "theorem minion_game_result_format (s : String) (h : s.all (fun c => c.isUpper)) :\n  let result := minion_game s\n  result.startsWith \"Kevin \" \u2228 result.startsWith \"Stuart \" \u2228 result = \"Draw\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minion_game_score_bounds (s : String) (h : s.all (fun c => c.isUpper)) :\n  let result := minion_game s\n  let score := score_from_result result\n  result \u2260 \"Draw\" \u2192\n  score > 0 \u2227 score \u2264 (s.length * (s.length + 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minion_game_scores_sum (s : String) (h : s.all (fun c => c.isUpper)) :\n  let result := minion_game s\n  let total := (s.length * (s.length + 1)) / 2\n  result \u2260 \"Draw\" \u2192\n  score_from_result result + (total - score_from_result result) = total :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minion_game_all_vowels (s : String)\n  (h\u2081 : s.length > 0)\n  (h\u2082 : s.all (fun c => is_vowel c)) :\n  (minion_game s).startsWith \"Kevin \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minion_game_all_consonants (s : String)\n  (h\u2081 : s.length > 0)\n  (h\u2082 : s.all (fun c => c.isUpper \u2227 !is_vowel c)) :\n  (minion_game s).startsWith \"Stuart \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Stuart 12'\n-/\n#guard_msgs in\n#eval minion_game \"BANANA\"\n\n/-\ninfo: 'Stuart 6'\n-/\n#guard_msgs in\n#eval minion_game \"MINE\"\n\n/-\ninfo: 'Kevin 3'\n-/\n#guard_msgs in\n#eval minion_game \"AE\""
      }
    ]
  },
  "fvapps_002472.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def \u2102 := Float \u00d7 Float  -- Simplified complex number representation"
      },
      {
        "type": "sig",
        "string": "def magnitude : \u2102 \u2192 Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def phase : \u2102 \u2192 Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mkComplex (r i : Float) : \u2102 := (r, i)"
      },
      {
        "type": "cond",
        "string": "theorem get_polar_coords_zero :\n  let z := mkComplex 0 0\n  magnitude z = 0 \u2227 phase z = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_polar_coords_real_positive :\n  let z := mkComplex 1 0\n  magnitude z = 1 \u2227 phase z = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_polar_coords_real_negative :\n  let z := mkComplex (-1) 0\n  magnitude z = 1 \u2227 phase z = 3.141592653589793 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_polar_coords_complex :\n  let z := mkComplex 1 2\n  Float.abs (magnitude z - 2.23606797749979) < 1e-10 \u2227\n  Float.abs (phase z - 1.1071487177940904) < 1e-10 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002475.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numerical_triangle (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.splitLines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.allDigits (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.toNat (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numerical_triangle_increasing_length (n: Nat)\n    (h: 1 \u2264 n \u2227 n \u2264 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines \u2260 [] \u2192\n    \u2200 i, 1 \u2264 i \u2192 i < lines.length \u2192\n    (lines.get! i).length > (lines.get! (i-1)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numerical_triangle_line_count (n: Nat)\n    (h: 1 \u2264 n \u2227 n \u2264 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines \u2260 [] \u2192\n    lines.length = n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numerical_triangle_valid_integers (n: Nat)\n    (h: 1 \u2264 n \u2227 n \u2264 20) :\n    let lines := (numerical_triangle n).splitLines\n    lines \u2260 [] \u2192\n    \u2200 line, line \u2208 lines \u2192\n    line.allDigits \u2227\n    (\u2203 num, line.toNat = some num \u2227 num > 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1\\n22\\n333\\n4444'\n-/\n#guard_msgs in\n#eval numerical_triangle 5\n\n/-\ninfo: '1\\n22'\n-/\n#guard_msgs in\n#eval numerical_triangle 3\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval numerical_triangle 2"
      }
    ]
  },
  "fvapps_002479.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := Array (Array Float)"
      },
      {
        "type": "sig",
        "string": "def getRow (A : Matrix) (i : Nat) : Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getCol (A : Matrix) (j : Nat) : Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mean (A : Matrix) : Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def var (A : Matrix) : Array Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def std (A : Matrix) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def compute_stats (A : Matrix) : Array Float \u00d7 Array Float \u00d7 Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_stats_mean_property (A : Matrix) :\n  let (means, _, _) := compute_stats A\n  means = mean A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_stats_var_property (A : Matrix) :\n  let (_, vars, _) := compute_stats A\n  vars = var A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_stats_std_property (A : Matrix) :\n  let (_, _, stdev) := compute_stats A\n  stdev = std A :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_stats_output_shape (A : Matrix) (h1 : A.size > 0) :\n  let (means, vars, _) := compute_stats A\n  means.size = A.size \u2227 vars.size = (getRow A 0).size :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_stats_empty (A : Matrix) (h : A.size = 0) :\n  compute_stats A = default :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002481.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_runner_up_score (scores: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def all_lt (x : Int) (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 y, y \u2208 l \u2192 y < x"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_max_case :\n  find_runner_up_score [1, 2, 2] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 3, 6, 6, 5]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_runner_up_score [2, 2, 3, 4, 4]\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval find_runner_up_score [-100, 0, 50, 100, 100]"
      }
    ]
  },
  "fvapps_002482.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def evaluatePolynomial (coeffs : List Float) (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def directPolynomial (coeffs : List Float) (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem polynomial_evaluation_matches_direct\n  (coeffs : List Float) (x : Float)\n  (h1 : coeffs.length \u2265 1)\n  (h2 : coeffs.length \u2264 10)\n  (h3 : \u2200 c \u2208 coeffs, -1000000 \u2264 c \u2227 c \u2264 1000000)\n  (h4 : -100 \u2264 x \u2227 x \u2264 100) :\n  evaluatePolynomial coeffs x - directPolynomial coeffs x \u2264 1e-10 * directPolynomial coeffs x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem polynomial_at_zero\n  (coeffs : List Float)\n  (h1 : coeffs \u2260 [])\n  (h2 : coeffs.length \u2264 10)\n  (h3 : \u2200 c \u2208 coeffs, -1000000 \u2264 c \u2227 c \u2264 1000000) :\n  evaluatePolynomial coeffs 0 = coeffs.getLast h1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002483.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_top_three_chars (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_top_three_chars_valid_format (s : String)\n  (h : s.length > 0)\n  (h2 : \u2200 c \u2208 s.data, c.isLower) :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  1 \u2264 lines.length \u2227 lines.length \u2264 3 \u2227\n  (\u2200 line \u2208 lines, \u2203 (char : String) (count : Nat),\n    line = s!\"{char} {count}\" \u2227\n    char.length = 1 \u2227\n    s.count char = count) \u2227\n  (\u2200 i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    (parts1.get! 1).toNat! \u2265 (parts2.get! 1).toNat!) \u2227\n  (let chars := lines.map (\u03bb l => (l.splitOn \" \").get! 0);\n   chars.eraseDups = chars) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_top_three_chars_alphabetical_tiebreak (s : String)\n  (h : s.length \u2265 2)\n  (h2 : \u2200 c \u2208 s.data, c = 'a' \u2228 c = 'b') :\n  let result := get_top_three_chars s;\n  let lines := result.splitOn \"\\n\";\n  \u2200 i < lines.length - 1,\n    let parts1 := (lines.get! i).splitOn \" \";\n    let parts2 := (lines.get! (i+1)).splitOn \" \";\n    let count1 := (parts1.get! 1).toNat!;\n    let count2 := (parts2.get! 1).toNat!;\n    let char1 := parts1.get! 0;\n    let char2 := parts2.get! 0;\n    count1 = count2 \u2192 char1 > char2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002488.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def student_union (n1 : Nat) (eng : String) (n2 : Nat) (fre : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToList (s : String) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def removeDuplicates (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem student_union_leq_sum_lengths {n1 n2 : Nat} {eng fre : String} :\n  student_union n1 eng n2 fre \u2264 n1 + n2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem student_union_equals_union_length {n1 n2 : Nat} {eng fre : String} :\n  \u2203 l1 l2 : List Int,\n    l1 = stringToList eng \u2227\n    l2 = stringToList fre \u2227\n    student_union n1 eng n2 fre = (removeDuplicates (l1 ++ l2)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem student_union_identical_lists {n : Nat} {nums : String} :\n  student_union n nums n nums = (removeDuplicates (stringToList nums)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval student_union 9 \"1 2 3 4 5 6 7 8 9\" 9 \"10 1 2 3 11 21 55 6 8\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"4 5 6\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval student_union 3 \"1 2 3\" 3 \"1 2 3\""
      }
    ]
  },
  "fvapps_002495.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Operation := String \u00d7 Int"
      },
      {
        "type": "sig",
        "string": "def DequeOp := List Operation\n\ndef splitString (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def process_deque_operations (ops : List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem append_only_operations_preserves_length\n  (ops : List String)\n  (h1 : \u2200 op \u2208 ops, (splitString op).get! 0 = \"append\" \u2228 (splitString op).get! 0 = \"appendleft\") :\n  (splitString (process_deque_operations ops)).length = ops.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem append_only_operations_preserves_elements\n  (ops : List String)\n  (h1 : \u2200 op \u2208 ops, (splitString op).get! 0 = \"append\" \u2228 (splitString op).get! 0 = \"appendleft\") :\n  \u2203 perm : List String \u2192 List String,\n    perm (ops.map (\u03bb op => (splitString op).get! 1)) =\n    splitString (process_deque_operations ops) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem append_maintains_order\n  (ops : List String)\n  (h1 : \u2200 op \u2208 ops, (splitString op).get! 0 = \"append\") :\n  (splitString (process_deque_operations ops)) =\n  ops.map (\u03bb op => (splitString op).get! 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 2'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"append 2\", \"append 3\", \"appendleft 4\", \"pop\", \"popleft\"]\n\n/-\ninfo: '10 15'\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 5\", \"appendleft 10\", \"pop\", \"append 15\"]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval process_deque_operations [\"append 1\", \"appendleft 2\", \"popleft\", \"pop\"]"
      }
    ]
  },
  "fvapps_002503.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_palindrome_triangle (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def split_lines (s: String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_line_count {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_lines_are_palindromes {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  \u2200 line \u2208 lines, line.data = (line.data.reverse) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_lines_increase {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  \u2200 i, 0 < i \u2192 i < lines.length \u2192 (lines.get! i).length > (lines.get! (i-1)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_first_line {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  lines.head! = \"1\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_only_digits {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  \u2200 line \u2208 lines, \u2200 c \u2208 line.data, '0' \u2264 c \u2227 c \u2264 '9' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_triangle_middle_increment {n: Nat} (h: 0 < n) (h2: n \u2264 9):\n  let lines := split_lines (make_palindrome_triangle n)\n  \u2200 i, 0 < i \u2192 i < lines.length \u2192\n    let line := lines.get! i\n    let mid := line.length / 2\n    \u2200 j, j < mid \u2192 line.data[j]! = Char.ofNat ((j + 1) + '0'.toNat) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1\\n121\\n12321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 3\n\n/-\ninfo: '1\\n121\\n12321\\n1234321\\n123454321'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 5\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval make_palindrome_triangle 1"
      }
    ]
  },
  "fvapps_002504.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.product : List (List \u03b1) \u2192 List (List \u03b1)\n  | [] => [[]]\n  | (h :: t) => sorry\n\ndef sum [Add \u03b1] (l : List \u03b1) : \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_max_modular_sum (m : Nat) (lists : List (List Int)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_modular_sum_bounds (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists \u2260 [])\n    (h3 : \u2200 l \u2208 lists, l \u2260 []) :\n  let result := find_max_modular_sum m lists\n  0 \u2264 result \u2227 result < m := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_modular_sum_matches_some_combo (m : Nat) (lists : List (List Int))\n    (h1 : m > 0) (h2 : lists \u2260 [])\n    (h3 : \u2200 l \u2208 lists, l \u2260 []) :\n  let result := find_max_modular_sum m lists\n  \u2203 combo \u2208 List.product lists,\n    sum (combo.map (\u03bb x => x * x)) % m = result := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_modular_sum_mod_one (lists : List (List Int))\n    (h1 : lists \u2260 [])\n    (h2 : \u2200 l \u2208 lists, l \u2260 []) :\n  find_max_modular_sum 1 lists = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_max_modular_sum_zeros (m : Nat) (lists : List (List Int))\n    (h1 : m > 1)\n    (h2 : lists \u2260 [])\n    (h3 : \u2200 l \u2208 lists, l \u2260 [])\n    (h4 : \u2200 l \u2208 lists, \u2200 x \u2208 l, x = 0) :\n  find_max_modular_sum m lists = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 206\n-/\n#guard_msgs in\n#eval find_max_modular_sum 1000 [[5, 4], [7, 8, 9], [5, 7, 8, 9, 10]]\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval find_max_modular_sum 100 [[1, 2], [3, 4]]"
      }
    ]
  },
  "fvapps_002515.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isAlnum (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_string_properties (s : String) : List Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_string_properties_bool (s : String) :\n  \u2200 x \u2208 check_string_properties s, x = true \u2228 x = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alpha_implies_alnum (s : String) :\n  (check_string_properties s).get! 1 = true \u2192 (check_string_properties s).get! 0 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem digit_implies_alnum (s : String) :\n  (check_string_properties s).get! 2 = true \u2192 (check_string_properties s).get! 0 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem case_implies_alpha (s : String) :\n  ((check_string_properties s).get! 3 = true \u2228 (check_string_properties s).get! 4 = true) \u2192\n  (check_string_properties s).get! 1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002516.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_combinations_with_replacement (s : String) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_sorted (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_chars_from (s : String) (chars : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_length (s : String) (k : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def no_duplicates (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_sorted (s : String) (k : Nat) :\n  is_sorted (get_combinations_with_replacement s k) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_length (s : String) (k : Nat) :\n  all_length (get_combinations_with_replacement s k) k = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_chars (s : String) (k : Nat) :\n  all_chars_from (get_combinations_with_replacement s k) s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_unique (s : String) (k : Nat) :\n  no_duplicates (get_combinations_with_replacement s k) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_example1 :\n  get_combinations_with_replacement \"HACK\" 2 = \"AA\\nAC\\nAH\\nAK\\nCC\\nCH\\nCK\\nHH\\nHK\\nKK\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_combinations_example2 :\n  get_combinations_with_replacement \"XYZ\" 2 = \"XX\\nXY\\nXZ\\nYY\\nYZ\\nZZ\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002532.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def addsup (a1 a2 a3 : List Int) : List (Int \u00d7 Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def compare_arrays (arr1 arr2 : List (List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem addsup_empty_input\n  (a1 a2 a3 : List Int)\n  : (a1 = [] \u2228 a2 = []) \u2192 addsup a1 a2 a3 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002533.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringReverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getMismatches (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_distance_property (s : String)\n    (h : s.length > 0)\n    (h2 : \u2200 c \u2208 s.data, c = 'a' \u2228 c = 'b' \u2228 c = 'c') :\n  let mismatches := getMismatches s\n  solve s = (mismatches = 1 \u2228 (mismatches = 0 \u2227 s.length % 2 = 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_symmetry_property (s : String) (h : s.length > 0) :\n  solve s = solve (stringReverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbx\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"aa\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"ab\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abcba\""
      }
    ]
  },
  "fvapps_002541.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def two_sort (strings : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countSubstring (haystack : String) (needle : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (xs : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) (sep : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_sort_separator_count (strings : List String)\n  (h : strings.length > 0) :\n  (countSubstring (two_sort strings) \"***\") = (minimum strings).length - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_sort_recovers_min (strings : List String)\n  (h : strings.length > 0) :\n  let result := two_sort strings\n  let parts := splitString result \"***\"\n  (String.join parts) = minimum strings :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'b***i***t***c***o***i***n'\n-/\n#guard_msgs in\n#eval two_sort [\"bitcoin\", \"take\", \"over\", \"the\", \"world\", \"maybe\", \"who\", \"knows\", \"perhaps\"]\n\n/-\ninfo: 'a***r***e'\n-/\n#guard_msgs in\n#eval two_sort [\"turns\", \"out\", \"random\", \"test\", \"cases\", \"are\", \"easier\", \"than\", \"writing\", \"out\", \"basic\", \"ones\"]\n\n/-\ninfo: 'L***e***t***s'\n-/\n#guard_msgs in\n#eval two_sort [\"Lets\", \"all\", \"go\", \"on\", \"holiday\", \"somewhere\", \"very\", \"cold\"]"
      }
    ]
  },
  "fvapps_002549.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def est_subsets {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_unique_count {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem est_subsets_count_prop {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem est_subsets_nonneg {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) :\n  est_subsets arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem est_subsets_empty {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] :\n  est_subsets ([] : List \u03b1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem est_subsets_duplicates {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) :\n  est_subsets arr = est_subsets (arr ++ arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem est_subsets_is_nat {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (arr : List \u03b1) :\n  est_subsets arr = 2^(list_unique_count arr) - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 3, 4]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [\"a\", \"b\", \"c\", \"d\", \"d\"]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval est_subsets [1, 2, 2, 3, 3, 3, 4]"
      }
    ]
  },
  "fvapps_002553.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.isAlpha : Char \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def changer : String \u2192 String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem changer_length (s : String) :\n  s.length = (changer s).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem changer_nonalpha_unchanged {s : String} {i : String.Pos} {c : Char} :\n  c = s.get i \u2192 \u00ac(String.isAlpha c) \u2192 (changer s).get i = c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem changer_empty :\n  changer \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem changer_boundary_case :\n  changer \"abcxyz\" = \"bcdyzA\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'dbU30'\n-/\n#guard_msgs in\n#eval changer \"Cat30\"\n\n/-\ninfo: 'Ifmmp xpsmE'\n-/\n#guard_msgs in\n#eval changer \"Hello World\"\n\n/-\ninfo: 'A'\n-/\n#guard_msgs in\n#eval changer \"z\""
      }
    ]
  },
  "fvapps_002554.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def format_words (words : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.countSubstr (s1 s2 : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def substringExists (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_words_empty_filtered :\n  \u2200 (words : List String),\n  (words.filter (fun w => w \u2260 \"\")).isEmpty \u2192\n  format_words words = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_words_contains_filtered :\n  \u2200 (words : List String) (word : String),\n  word \u2260 \"\" \u2192\n  word \u2208 words \u2192\n  substringExists (format_words words) word = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_words_single_and :\n  \u2200 (words : List String),\n  (words.filter (fun w => w \u2260 \"\")).length > 1 \u2192\n  substringExists (format_words words) \" and \" = true \u2227\n  String.countSubstr (format_words words) \" and \" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_words_no_and :\n  \u2200 (words : List String),\n  (words.filter (fun w => w \u2260 \"\")).length \u2264 1 \u2192\n  substringExists (format_words words) \"and\" = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_words_maintains_order :\n  \u2200 (words : List String),\n  \u00ac(words.filter (fun w => w \u2260 \"\")).isEmpty \u2192\n  let filtered := words.filter (fun w => w \u2260 \"\")\n  substringExists (format_words words) filtered.head! \u2227\n  substringExists (format_words words) filtered.getLast! \u2227\n  format_words words = filtered.head! \u2228\n  format_words words = filtered.head! ++ \", \" ++ filtered.getLast! \u2228\n  format_words words = filtered.head! ++ \" and \" ++ filtered.getLast! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ninja, samurai and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"samurai\", \"ronin\"]\n\n/-\ninfo: 'ninja'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\"]\n\n/-\ninfo: 'ninja and ronin'\n-/\n#guard_msgs in\n#eval format_words [\"ninja\", \"\", \"ronin\"]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval format_words []"
      }
    ]
  },
  "fvapps_002556.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_employees_role (name : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def valid_roles : List String :="
      },
      {
        "type": "impl",
        "string": "  [\"Boss\", \"Truck Driver\", \"Warehouse Manager\", \"Sales Assistant\",\n   \"Admin\", \"Sales Manager\", \"Warehouse Picker\", \"Receptionist\", \"Trainee\"]"
      },
      {
        "type": "cond",
        "string": "theorem known_employee_roles_are_valid (name : String) (h : name.length > 0) :\n  let role := find_employees_role name\n  role = \"Does not work here!\" \u2228 role \u2208 valid_roles :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem returns_string (name : String) (h : name.length > 0) :\n  String.length (find_employees_role name) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unknown_single_name_returns_not_found (name : String) (h1 : name.length > 0)\n    (h2 : \u00ac(name.contains ' ')) :\n  find_employees_role name = \"Does not work here!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem name_order_matters (first last : String)\n    (h1 : first.length > 0) (h2 : last.length > 0) :\n  let role1 := find_employees_role (first ++ \" \" ++ last)\n  let role2 := find_employees_role (last ++ \" \" ++ first)\n  (role1 \u2260 \"Does not work here!\" \u2227 role2 \u2260 \"Does not work here!\") \u2192\n  role1 \u2260 role2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Truck Driver'\n-/\n#guard_msgs in\n#eval find_employees_role \"Morty Smith\"\n\n/-\ninfo: 'Admin'\n-/\n#guard_msgs in\n#eval find_employees_role \"Anna Bell\"\n\n/-\ninfo: 'Does not work here!'\n-/\n#guard_msgs in\n#eval find_employees_role \"Bell Jewel\""
      }
    ]
  },
  "fvapps_002559.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bubble (lst : List Int) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (lst : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countInversions (lst : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 1: Each step should be a valid permutation of original list"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_steps_are_permutations {lst : List Int} {step : List Int} :\n  step \u2208 bubble lst \u2192 step.length = lst.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 2: Each step should have one or more swaps from previous"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_steps_have_swaps {lst : List Int} {i : Nat} (h1 : i < (bubble lst).length) (h2 : i + 1 < (bubble lst).length) :\n  \u2203 pos : Nat, pos < lst.length \u2227\n    ((bubble lst).get \u27e8i, h1\u27e9).get! pos \u2260 ((bubble lst).get \u27e8i+1, h2\u27e9).get! pos :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 3: Final state should be sorted"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_final_step_sorted {lst : List Int} (h : bubble lst \u2260 []) :\n  isSorted ((bubble lst).getLast h) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 4: Number of steps should not exceed inversions"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_steps_bounded_by_inversions {lst : List Int} :\n  (bubble lst).length \u2264 countInversions lst :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Already sorted lists produce empty steps"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_sorted_empty {lst : List Int} :\n  isSorted lst \u2192 bubble lst = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty list produces empty steps"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem bubble_empty :\n  bubble [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval bubble []\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval bubble [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n/-\ninfo: [[1, 3, 3, 4, 7, 2], [1, 3, 3, 4, 2, 7], [1, 3, 3, 2, 4, 7], [1, 3, 2, 3, 4, 7], [1, 2, 3, 3, 4, 7]]\n-/\n#guard_msgs in\n#eval bubble [1, 3, 3, 7, 4, 2]"
      }
    ]
  },
  "fvapps_002571.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def almostIncreasingSequence (seq : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countDescendingPairs (seq : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isStrictlyIncreasing (seq : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strictly_increasing_always_true {seq : List Int} :\n  isStrictlyIncreasing seq \u2192 almostIncreasingSequence seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countDuplicates (seq : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem duplicate_elements_property {seq : List Int} :\n  countDuplicates seq > 1 \u2192 \u00acalmostIncreasingSequence seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem too_many_drops_always_false {seq : List Int} :\n  countDescendingPairs seq > 1 \u2192 \u00acalmostIncreasingSequence seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_removal_property {seq : List Int} (i : Nat) (h : i < seq.length) :\n  isStrictlyIncreasing (seq.take i ++ seq.drop (i+1)) \u2192\n  almostIncreasingSequence seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element_always_true {seq : List Int} :\n  seq.length = 1 \u2192 almostIncreasingSequence seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2, 1]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 3, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval almost_increasing_sequence [1, 2, 3]"
      }
    ]
  },
  "fvapps_002579.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digits (n: Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def visible_sum (n i: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_visible_sum (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def loneliest (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem loneliest_returns_bool (n: Nat) :\n  loneliest n = true \u2228 loneliest n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem loneliest_zero_one :\n  \u2200 n: Nat, (\u2200 d: Nat, d \u2208 (digits n) \u2192 d = 0 \u2228 d = 1) \u2192\n  loneliest n = true \u2194 \u2203 i, (digits n).get? i = some 1 \u2227\n  (\u2200 j, j \u2260 i \u2192 (digits n).get? j = some 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem loneliest_same_digit :\n  \u2200 n: Nat, (\u2200 i j: Nat, i < (digits n).length \u2192 j < (digits n).length \u2192\n    (digits n).get \u27e8i, sorry\u27e9 = (digits n).get \u27e8j, sorry\u27e9) \u2192\n  loneliest n = true \u2194 (digits n).get \u27e80, sorry\u27e9 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem loneliest_no_ones :\n  \u2200 n: Nat, (\u2200 i: Nat, i < (digits n).length \u2192 (digits n).get \u27e8i, sorry\u27e9 \u2260 1) \u2192\n  loneliest n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem loneliest_min_loneliness :\n  \u2200 n: Nat, loneliest n = true \u2194\n  (\u2203 i: Nat, (digits n).get? i = some 1 \u2227\n   visible_sum n i = min_visible_sum n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 34315\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval loneliest 8854778\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval loneliest 11111"
      }
    ]
  },
  "fvapps_002584.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def scf (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h::t => t.foldl min h\n\npartial def minFactor (n : Nat) : Nat :=\n  if n \u2264 1 then 1 else\n  let rec find (k : Nat) : Nat :=\n    if k * k > n then n\n    else if n % k = 0 then k\n    else find (k + 1)\n  find 2"
      },
      {
        "type": "cond",
        "string": "theorem scf_basic_properties (nums : List Nat) :\n  let result := scf nums\n  (nums \u2260 [] \u2192 1 \u2264 result \u2227 result \u2264 listMin nums) \u2227\n  (nums = [] \u2192 result = 1) \u2227\n  (\u2200 n \u2208 nums, n % result = 0) \u2227\n  (result > 1 \u2192 \u00ac \u2203 k, 2 \u2264 k \u2227 k < result \u2227 \u2200 n \u2208 nums, n % k = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scf_identical_numbers (n : Nat) (h : n \u2265 2) :\n  let nums := List.replicate 5 n\n  scf nums = minFactor n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scf_nonpositive_inputs (nums : List Nat) (h : \u2200 n \u2208 nums, n = 0) :\n  scf nums = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval scf [200, 30, 18, 8, 64, 34]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval scf [21, 45, 51, 27, 33]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval scf []"
      }
    ]
  },
  "fvapps_002586.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def add (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure WeightedSum where\n  index : Nat\n  value : Int\n  deriving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def makeWeightedSum (xs : List Int) : Int := match xs with\n  | [] => 0\n  | x::xs => x + makeWeightedSum xs"
      },
      {
        "type": "cond",
        "string": "theorem add_weighted_sum (xs : List Int) (h : xs \u2260 []) :\n  \u2203 n, add xs = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_single_number (x : Int) :\n  add [x] = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002587.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_largest_sequence (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstring (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def substring (s : String) (start len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_strings (s : String) :\n  s.length < 5 \u2192 find_largest_sequence s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 98765\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567898765\"\n\n/-\ninfo: 67890\n-/\n#guard_msgs in\n#eval find_largest_sequence \"1234567890\"\n\n/-\ninfo: 12345\n-/\n#guard_msgs in\n#eval find_largest_sequence \"12345\""
      }
    ]
  },
  "fvapps_002590.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def numToWord (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def wordToNum (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def average_string (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numWordsList := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Nat) : Nat := l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem average_string_valid_nums (words : List String)\n  (h : \u2200 w \u2208 words, w \u2208 numWordsList) (h2 : words \u2260 []) :\n  let nums := words.filterMap wordToNum\n  let avg := sum nums / nums.length\n  average_string (String.intercalate \" \" words) = numToWord avg :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_string_empty :\n  average_string \"\" = \"n/a\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_string_invalid (s : String)\n  (h : \u2203 w \u2208 s.split (\u00b7 = ' '), w \u2209 numWordsList) :\n  average_string s = \"n/a\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'four'\n-/\n#guard_msgs in\n#eval average_string \"zero nine five two\"\n\n/-\ninfo: 'three'\n-/\n#guard_msgs in\n#eval average_string \"four six two three\"\n\n/-\ninfo: 'n/a'\n-/\n#guard_msgs in\n#eval average_string \"\""
      }
    ]
  },
  "fvapps_002592.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gimme (arr : List Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sort (xs : List Float) : List Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sortInt (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gimmeInt (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gimme_in_range {arr : List Float} (h : arr.length = 3) :\n  let res := gimme arr\n  0 \u2264 res \u2227 res \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gimme_gives_middle {arr : List Float} (h : arr.length = 3) :\n  let sorted := sort arr\n  let res := gimme arr\n  arr[res]! = sorted[1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gimme_integers_in_range {arr : List Int} (h : arr.length = 3) :\n  let res := gimmeInt arr\n  0 \u2264 res \u2227 res \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gimme_integers_middle {arr : List Int} (h : arr.length = 3) :\n  let sorted := sortInt arr\n  let res := gimmeInt arr\n  arr[res]! = sorted[1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gimme_preserves_input {arr : List Float} (h : arr.length = 3) :\n  let original := arr\n  let _ := gimme arr\n  arr = original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [2, 3, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval gimme [5, 10, 14]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval gimme [-0.41, -23, 4]"
      }
    ]
  },
  "fvapps_002593.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def squareIt (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPerfectSquare (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasEqualRows (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isqrt (n : Nat) : Nat := sorry\n\ndef splitLines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  String.splitOn s \"\\n\""
      },
      {
        "type": "cond",
        "string": "theorem square_it_properties (n : Nat) :\n  n \u2264 10^12 \u2192\n  let digits := toString n\n  if isPerfectSquare (digits.length) then\n    let result := squareIt n\n    result \u2260 \"Not a perfect square!\" \u2227\n    hasEqualRows result \u2227\n    let sideLength := isqrt (digits.length)\n    (splitLines result).length = sideLength \u2227\n    (\u2200 row \u2208 splitLines result, row.length = sideLength) \u2227\n    String.join (splitLines result) = digits\n  else\n    squareIt n = \"Not a perfect square!\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_it_repeating_ones (n : Nat) (k : Nat) :\n  k \u2265 1 \u2192\n  k \u2264 4 \u2192\n  n = (10^(k*k) - 1)/9 \u2192  -- represents number with k*k ones\n  let result := squareIt n\n  result \u2260 \"Not a perfect square!\" \u2227\n  let rows := splitLines result\n  \u2200 row \u2208 rows, match rows.head? with\n                | none => True\n                | some first => row = first\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '12\\n12'\n-/\n#guard_msgs in\n#eval square_it 1212\n\n/-\ninfo: '123\\n123\\n123'\n-/\n#guard_msgs in\n#eval square_it 123123123\n\n/-\ninfo: 'Not a perfect square!'\n-/\n#guard_msgs in\n#eval square_it 12345"
      }
    ]
  },
  "fvapps_002598.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def day_and_time (mins : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any integer minutes, the output matches expected day/time format -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem day_and_time_valid_format (mins : Int) :\n  let result := day_and_time mins\n  let parts := result.splitOn \" \"\n  let day := parts[0]!\n  let time := parts[1]!\n  let hours_mins := time.splitOn \":\"\n  let hours := hours_mins[0]!.toInt!\n  let minutes := hours_mins[1]!.toInt!\n  parts.length = 2 \u2227\n  (day = \"Monday\" \u2228 day = \"Tuesday\" \u2228 day = \"Wednesday\" \u2228\n   day = \"Thursday\" \u2228 day = \"Friday\" \u2228 day = \"Saturday\" \u2228 day = \"Sunday\") \u2227\n  0 \u2264 hours \u2227 hours \u2264 23 \u2227\n  0 \u2264 minutes \u2227 minutes \u2264 59 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Output repeats on weekly cycle -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem day_and_time_weekly_cycle (mins : Int) :\n  day_and_time mins = day_and_time (mins + 7*24*60) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'Sunday 00:00'\n-/\n#guard_msgs in\n#eval day_and_time 0\n\n/-\ninfo: 'Saturday 23:57'\n-/\n#guard_msgs in\n#eval day_and_time -3\n\n/-\ninfo: 'Monday 00:07'\n-/\n#guard_msgs in\n#eval day_and_time 1447"
      }
    ]
  },
  "fvapps_002601.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def peaceful_yard (yard : List String) (distance : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def mkRow (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def updateRow (s : String) (pos : Nat) (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def distance (p1 p2 : Nat \u00d7 Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def replaceNth {\u03b1 : Type} (xs : List \u03b1) (n : Nat) (v : \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_yard_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size \u2265 1) (h2 : size \u2264 20)\n  (h3 : distance \u2265 0.1) (h4 : distance \u2264 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  peaceful_yard yard distance = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_cat_is_peaceful {size : Nat} {distance : Float}\n  (h1 : size \u2265 1) (h2 : size \u2264 20)\n  (h3 : distance \u2265 0.1) (h4 : distance \u2264 30) :\n  let emptyRow := mkRow size\n  let yard := List.replicate size emptyRow\n  let midPos := size / 2\n  let catRow := updateRow (List.get! yard midPos) midPos 'L'\n  let yard' := replaceNth yard midPos catRow\n  peaceful_yard yard' distance = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cats_distance_property\n  {size : Nat} {distance : Float} {catPositions : List (Nat \u00d7 Nat \u00d7 Char)}\n  (h1 : size \u2265 2) (h2 : size \u2264 20)\n  (h3 : distance \u2265 0.1) (h4 : distance \u2264 30)\n  (h5 : catPositions.length \u2264 3)\n  (h6 : \u2200 p \u2208 catPositions, p.fst < size \u2227 (p.snd.fst) < size \u2227 (p.snd.snd) \u2208 ['L', 'M', 'R']) :\n  let validPositions := catPositions.filter (\u03bb p => p.fst < size \u2227 (p.snd.fst) < size)\n  let emptyRow := mkRow size\n  let emptyYard := List.replicate size emptyRow\n  let yard := validPositions.foldl\n    (\u03bb y p => replaceNth y p.fst (updateRow (List.get! y p.fst) (p.snd.fst) (p.snd.snd)))\n    emptyYard\n  peaceful_yard yard distance =\n    if validPositions.length \u2264 1\n    then true\n    else let positions := validPositions.map (\u03bb p => (p.fst, p.snd.fst))\n         let minDist : Float := sorry -- minimum distance computation\n         minDist \u2265 distance :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"------------\", \"-L----------\", \"------------\", \"------------\", \"------------\"] 10\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval peaceful_yard [\"------------\", \"---M--------\", \"------------\", \"------------\", \"-------R----\", \"------------\"] 6\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval peaceful_yard [\"-----------L\", \"--R---------\", \"------------\", \"------------\", \"------------\", \"--M---------\"] 4"
      }
    ]
  },
  "fvapps_002615.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def namelist (names : List (String \u00d7 String)) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstr (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem namelist_empty_list :\n  namelist [] = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem namelist_single_name (name : String) :\n  namelist [(name, \"name\")] = name :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem namelist_multiple_names {n : \u2115} (names : List (String \u00d7 String))\n  (h1 : names.length > 1)\n  (h2 : \u2200 p \u2208 names, p.2 = \"name\") :\n  let result := namelist names;\n  let all_names := names.map Prod.fst;\n  -- Result contains all original names\n  (\u2200 name \u2208 all_names, containsSubstr result name)\n  -- Has & separator\n  \u2227 containsSubstr result \" & \"\n  -- Has correct number of commas\n  \u2227 (String.count result ',' = names.length - 2)\n  -- Last name appears after &\n  \u2227 (result.splitOn \" & \").get! 1 = names.getLast?.get!.1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bart, Lisa & Maggie'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}, {\"name\": \"Maggie\"}]\n\n/-\ninfo: 'Bart & Lisa'\n-/\n#guard_msgs in\n#eval namelist [{\"name\": \"Bart\"}, {\"name\": \"Lisa\"}]\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval namelist []"
      }
    ]
  },
  "fvapps_002618.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.containsString (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def word_search (query : String) (seq : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_returns_nonempty (query : String) (seq : List String) :\n  word_search query seq \u2260 [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_none_means_no_matches (query : String) (seq : List String) :\n  word_search query seq = [\"None\"] \u2192\n  \u2200 x \u2208 seq, \u00ac(String.containsString (String.toLower x) (String.toLower query)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_results_contain_query (query : String) (seq : List String) :\n  \u2200 x \u2208 word_search query seq,\n  word_search query seq \u2260 [\"None\"] \u2192\n  String.containsString (String.toLower x) (String.toLower query) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_results_subset (query : String) (seq : List String) :\n  \u2200 x \u2208 word_search query seq,\n  word_search query seq \u2260 [\"None\"] \u2192\n  x \u2208 seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_finds_all_matches (query : String) (seq : List String) :\n  word_search query seq \u2260 [\"None\"] \u2192\n  List.length (word_search query seq) =\n  List.length (List.filter (fun x => String.containsString (String.toLower x) (String.toLower query)) seq) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_search_empty_seq (query : String) :\n  word_search query [] = [\"None\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"ab\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/-\ninfo: ['ab', 'abc', 'zab']\n-/\n#guard_msgs in\n#eval word_search \"aB\" [\"za\", \"ab\", \"abc\", \"zab\", \"zbc\"]\n\n/-\ninfo: ['None']\n-/\n#guard_msgs in\n#eval word_search \"abcd\" [\"za\", \"aB\", \"Abc\", \"zAB\", \"zbc\"]"
      }
    ]
  },
  "fvapps_002619.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def summary_ranges (nums : List Int) : List String := sorry\n\ndef stringContainsArrow (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.any (\u00b7 = '-') && s.any (\u00b7 = '>')"
      },
      {
        "type": "sig",
        "string": "def stringToRange (s : String) : Option (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "  if !stringContainsArrow s then none\n  else\n    let parts := s.splitOn \"->\"\n    match parts with\n    | [start, stop] => some (start.toInt!, stop.toInt!)\n    | _ => none"
      },
      {
        "type": "cond",
        "string": "theorem summary_ranges_empty (nums : List Int) :\n  nums = [] \u2192 summary_ranges nums = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summary_ranges_singleton (n : Int) :\n  summary_ranges [n] = [toString n] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summary_ranges_valid_ranges (nums : List Int) (range_str : String) :\n  range_str \u2208 summary_ranges nums \u2192\n  match stringContainsArrow range_str with\n  | true =>\n      let range := stringToRange range_str\n      match range with\n      | some (start, stop) =>\n          start \u2264 stop \u2227\n          \u2200 x, start \u2264 x \u2227 x \u2264 stop \u2192 x \u2208 nums\n      | none => True\n  | false => range_str.toInt! \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summary_ranges_consecutive (nums : List Int) :\n  nums \u2260 [] \u2192\n  nums.length \u2265 2 \u2192\n  (\u2200 i, i + 1 < nums.length \u2192 nums[i+1]! = nums[i]! + 1) \u2192\n  summary_ranges nums = [s!\"{nums.get! 0}->{nums.get! (nums.length - 1)}\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['1->4']\n-/\n#guard_msgs in\n#eval summary_ranges [1, 2, 3, 4]\n\n/-\ninfo: ['0->2', '5->6', '9']\n-/\n#guard_msgs in\n#eval summary_ranges [0, 1, 2, 5, 6, 9]\n\n/-\ninfo: ['-2', '0->7', '9->10', '12']\n-/\n#guard_msgs in\n#eval summary_ranges [-2, 0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 12]"
      }
    ]
  },
  "fvapps_002624.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_password (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_special_char (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_lowercase (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_uppercase (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_digit (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def has_special (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem password_too_short {s : String} (h : s.length < 8) :\n  check_password s = \"not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem password_too_long {s : String} (h : s.length > 20) :\n  check_password s = \"not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem password_invalid_chars {s : String} (h : \u2203 c \u2208 s.data,\n  \u00ac(c.isLower \u2228 c.isUpper \u2228 c.isDigit \u2228 is_special_char c)) :\n  check_password s = \"not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem password_missing_required_chars {s : String}\n  (h1 : s.length \u2265 8)\n  (h2 : s.length \u2264 20)\n  (h3 : \u2200 c \u2208 s.data, (c.isLower \u2228 c.isUpper \u2228 c.isDigit \u2228 is_special_char c))\n  (h4 : \u00ac(has_lowercase s \u2227 has_uppercase s \u2227 has_digit s \u2227 has_special s)) :\n  check_password s = \"not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"\"\n\n/-\ninfo: 'not valid'\n-/\n#guard_msgs in\n#eval check_password \"Password123\"\n\n/-\ninfo: 'valid'\n-/\n#guard_msgs in\n#eval check_password \"P@ssw0rd123\""
      }
    ]
  },
  "fvapps_002628.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def length_of_line (coords : List (List Int)) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def string_to_float (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def int_to_float (i : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_matches_pythagorean\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let result := string_to_float (length_of_line coords)\n  let expected := Float.sqrt (int_to_float ((x2 - x1) ^ 2 + (y2 - y1) ^ 2))\n  Float.abs (result - expected) < 0.01 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_commutative\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2) :\n  length_of_line coords = length_of_line [coords[1]!, coords[0]!] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_point_zero\n  (coords : List (List Int))\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2) :\n  length_of_line [coords[0]!, coords[0]!] = \"0.00\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_inequality\n  (coords : List (List Int))\n  (x1 y1 x2 y2 : Int)\n  (h1 : coords.length = 2)\n  (h2 : coords[0]!.length = 2)\n  (h3 : coords[1]!.length = 2)\n  (h4 : coords[0]![0]! = x1)\n  (h5 : coords[0]![1]! = y1)\n  (h6 : coords[1]![0]! = x2)\n  (h7 : coords[1]![1]! = y2) :\n  let mx := (x1 + x2) / 2\n  let my := (y1 + y2) / 2\n  let midpoint := [mx, my]\n  let result := string_to_float (length_of_line coords)\n  let via_mid := string_to_float (length_of_line [coords[0]!, midpoint]) +\n                 string_to_float (length_of_line [midpoint, coords[1]!])\n  result \u2264 via_mid + 0.01 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1.41'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [1, 1]]\n\n/-\ninfo: '0.00'\n-/\n#guard_msgs in\n#eval length_of_line [[0, 0], [0, 0]]\n\n/-\ninfo: '13.04'\n-/\n#guard_msgs in\n#eval length_of_line [[-3, 4], [10, 5]]"
      }
    ]
  },
  "fvapps_002630.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sol_equa (n : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The solutions to x\u00b2 - 4y\u00b2 = n are well-formed lists of pairs of natural numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_well_formed (n : Nat) :\n  \u2200 result : List (List Nat),\n    result = sol_equa n \u2192\n    (\u2200 pair \u2208 result, pair.length = 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Each solution pair satisfies the equation x\u00b2 - 4y\u00b2 = n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_satisfies_equation (n : Nat) :\n  \u2200 result : List (List Nat),\n    result = sol_equa n \u2192\n    \u2200 pair \u2208 result,\n      pair.get! 0 * pair.get! 0 - 4 * pair.get! 1 * pair.get! 1 = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Solutions contain only positive x values and nonnegative y values -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_positive_values (n : Nat) :\n  \u2200 result : List (List Nat),\n    result = sol_equa n \u2192\n    \u2200 pair \u2208 result,\n      pair.get! 0 > 0 \u2227 pair.get! 1 \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Solutions are ordered by descending x values -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_ordered (n : Nat) :\n  \u2200 result : List (List Nat),\n    result = sol_equa n \u2192\n    \u2200 i < result.length - 1,\n      (result.get! i).get! 0 > (result.get! (i+1)).get! 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For n = 90002, there are no solutions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_90002_empty :\n  sol_equa 90002 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For n = 5, there is exactly one solution: [[3,1]] -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sol_equa_5_single :\n  sol_equa 5 = [[3,1]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [[3, 1]]\n-/\n#guard_msgs in\n#eval sol_equa 5\n\n/-\ninfo: [[45003, 22501], [9003, 4499], [981, 467], [309, 37]]\n-/\n#guard_msgs in\n#eval sol_equa 90005\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval sol_equa 90002"
      }
    ]
  },
  "fvapps_002641.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_char (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def take_prefix (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_balanced (s : String) (caps : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_caps_balance\n  (s : String)\n  (h : s.length > 0) :\n  is_balanced s \"xx\" = ((count_char s 'x') % 2 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_caps_always_balanced\n  (s : String) :\n  is_balanced s \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem standard_parens_properties\n  (s : String)\n  (h : is_balanced s \"()\") :\n  (count_char s '(' = count_char s ')') \u2227\n  \u2200 (p : Nat), p \u2264 s.length \u2192\n    count_char (take_prefix s p) '(' \u2265 count_char (take_prefix s p) ')' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says yes!)\" \"()\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_balanced \"(Sensei says no!\" \"()\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_balanced \"-Hello Mother can you hear me?-\" \"--\""
      }
    ]
  },
  "fvapps_002643.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def commas (n : Float) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.toFloat! (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "instance : ToString Int where toString := sorry"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def Int.abs (n : Int) : Int := if n < 0 then -n else n"
      },
      {
        "type": "cond",
        "string": "theorem integers_format_correctly (n : Int)\n  (h : -999999999999999 \u2264 n \u2227 n \u2264 999999999999999) :\n  let result : String := commas (Float.ofInt n);\n  (Int.abs n \u2265 1000 \u2192 result.contains ',' ) \u2227\n  (\u00acresult.contains '.') \u2227\n  ((result.replace \",\" \"\").toInt? = some n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem floats_format_correctly (n : Float)\n  (h1 : \u00acn.isNaN)\n  (h2 : \u00acn.isInf)\n  (h3 : -1e10 \u2264 n \u2227 n \u2264 1e10) :\n  let result : String := commas n;\n  (result.contains '.' \u2192 (result.splitOn \".\" |>.get! 1).length \u2264 3) \u2227\n  Float.abs ((result.replace \",\" \"\").toFloat! - n) < 1e-2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_cases :\n  commas 0 = \"0\" \u2227 commas (-0.0) = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1,000'\n-/\n#guard_msgs in\n#eval commas 1000\n\n/-\ninfo: '100.235'\n-/\n#guard_msgs in\n#eval commas 100.2346\n\n/-\ninfo: '-1,000,000.123'\n-/\n#guard_msgs in\n#eval commas -1000000.123"
      }
    ]
  },
  "fvapps_002645.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def faro_cycles (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Minimum number of cards (2) requires only one faro cycle -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem faro_cycles_min : faro_cycles 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Faro cycles for even number of cards is always positive -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem faro_cycles_positive_small (n : Nat) :\n  n = 4 \u2228 n = 8 \u2192 faro_cycles n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Standard deck of 52 cards requires exactly 8 faro cycles -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem faro_cycles_standard_deck : faro_cycles 52 = 8 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 1\n-/\n#guard_msgs in\n#eval faro_cycles 2\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval faro_cycles 52\n\n/-\ninfo: 540\n-/\n#guard_msgs in\n#eval faro_cycles 542"
      }
    ]
  },
  "fvapps_002648.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def collatzLength (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def longestCollatz (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem longest_collatz_is_member {nums : List Nat} (h : nums \u2260 []) :\n  \u2200 n, n = longestCollatz nums \u2192 n \u2208 nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longest_collatz_is_longest {nums : List Nat} (h : nums.length \u2265 2) :\n  \u2200 n \u2208 nums, n \u2260 longestCollatz nums \u2192\n    collatzLength (longestCollatz nums) \u2265 collatzLength n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_numbers_gives_first (n : Nat) (l : List Nat)\n  (h : \u2200 x \u2208 l, x = n) :\n  longestCollatz l = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [1, 5, 27, 4]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval longest_collatz [64, 64, 27, 64]\n\n/-\ninfo: 75\n-/\n#guard_msgs in\n#eval longest_collatz [75, 226, 113, 340]"
      }
    ]
  },
  "fvapps_002651.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.replicate (n : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def spam (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem spam_multiplication (n : Nat) : n \u2264 1000 \u2192 spam n = String.replicate n \"hue\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'hue'\n-/\n#guard_msgs in\n#eval spam 1\n\n/-\ninfo: 'huehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 6\n\n/-\ninfo: 'huehuehuehuehuehuehuehuehuehuehuehuehuehue'\n-/\n#guard_msgs in\n#eval spam 14"
      }
    ]
  },
  "fvapps_002652.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def parameter (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def fromDigits (ds : List Nat) : Nat := sorry\n\ndef listSum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x :: xs => x + listSum xs"
      },
      {
        "type": "sig",
        "string": "def listProd (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 1\n  | x :: xs => x * listProd xs"
      },
      {
        "type": "cond",
        "string": "theorem parameter_single_digit (d : Nat)\n  (h : d > 0)\n  (h2 : d \u2264 9) :\n  parameter d = d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval parameter 22\n\n/-\ninfo: 120\n-/\n#guard_msgs in\n#eval parameter 1234\n\n/-\ninfo: 378\n-/\n#guard_msgs in\n#eval parameter 239"
      }
    ]
  },
  "fvapps_002657.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unusual_lex_order (words: List String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_length_matches_input (words: List String) (h: words.length > 0) :\n  (unusual_lex_order words).length = words.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_contains_same_elements (words: List String) (h: words.length > 0) :\n  \u2200 x, (x \u2208 unusual_lex_order words \u2194 x \u2208 words) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_sorted_by_reversed_strings (words: List String) (h: words.length > 0) :\n  \u2200 (i: Nat) (h': i + 1 < (unusual_lex_order words).length),\n    let result := unusual_lex_order words\n    Option.isSome (result[i]?) \u2227 Option.isSome (result[i+1]?) \u2192\n    reverse (Option.get! result[i]?) \u2264 reverse (Option.get! result[i+1]?) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent (words: List String) (h: words.length > 0) :\n  unusual_lex_order (unusual_lex_order words) = unusual_lex_order words :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002661.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.hasSubstring (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def areYouPlayingBanjo (name : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem banjo_output_format (name : String) (h : name.length > 0) :\n  let result := areYouPlayingBanjo name\n  result.startsWith name \u2227\n  result.endsWith \"banjo\" \u2227\n  (result.hasSubstring \" plays banjo\" \u2228 result.hasSubstring \" does not play banjo\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem starts_with_r_plays_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front = 'r' \u2228 name.front = 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" plays banjo\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem not_r_does_not_play_banjo (name : String) (h1 : name.length > 0)\n    (h2 : name.front \u2260 'r' \u2227 name.front \u2260 'R') :\n  (areYouPlayingBanjo name).hasSubstring \" does not play banjo\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Adam\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"Ringo\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval areYouPlayingBanjo \"rolf\""
      }
    ]
  },
  "fvapps_002665.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def per (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def productOfDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digitsOfNat (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem per_empty_for_single_digit (n : Nat) :\n  n < 10 \u2192 per n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem per_decreasing {n : Nat} {result : List Nat} :\n  result = per n \u2192\n  \u2200 i, \u2200 h : i < result.length - 1,\n  result.get \u27e8i, sorry\u27e9 \u2265 result.get \u27e8i+1, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem per_bounded_length (n : Nat) :\n  (per n).length \u2264 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval per 1\n\n/-\ninfo: [54, 20, 0]\n-/\n#guard_msgs in\n#eval per 69\n\n/-\ninfo: [4996238671872, 438939648, 4478976, 338688, 27648, 2688, 768, 336, 54, 20, 0]\n-/\n#guard_msgs in\n#eval per 277777788888899"
      }
    ]
  },
  "fvapps_002666.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasDPCProperties (n : Nat) (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def dpcSequence (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem dpc_satisfies_properties (s : String) (h : s.length > 0 \u2227 s.length \u2264 30) :\n  let result := dpcSequence s\n  result = -1 \u2228 (\u2203 n : Nat, result = n \u2227 hasDPCProperties n s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dpc_is_minimal (s : String) (h : s.length > 0 \u2227 s.length \u2264 30) :\n  let result := dpcSequence s\n  result \u2260 -1 \u2192 \u2200 n : Nat, n < result.toNat \u2192 \u00achasDPCProperties n s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dpc_result_bounds (s : String) (h : s.length > 0 \u2227 s.length \u2264 30) :\n  let result := dpcSequence s\n  result = -1 \u2228 (1 \u2264 result \u2227 result \u2264 1000000000) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_divisible_has_solution (s : String)\n  (h1 : s.length > 0 \u2227 s.length \u2264 10)\n  (h2 : \u2200 c \u2208 s.data, c = 'D') :\n  dpcSequence s \u2260 -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDPDD\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval dpc_sequence \"DPCPDPPPDCPDPDPC\"\n\n/-\ninfo: 15782844\n-/\n#guard_msgs in\n#eval dpc_sequence \"DDDDPDDCCCDDPDCCPCDCDDPCPCCDDCD\""
      }
    ]
  },
  "fvapps_002667.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def custom_christmas_tree (chars: String) (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitLines (s: String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringLength (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringTrim (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_structure_width (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  \u2200 line \u2208 splitLines tree, stringLength line \u2264 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trunk_structure (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let trunk_lines := (splitLines tree).drop n\n  (\u2200 line \u2208 trunk_lines, stringTrim line = \"|\") \u2227\n  trunk_lines.length = (n-1) / 3 + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_height (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  (splitLines tree).length = n + ((n-1) / 3 + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tree_part_nonempty (chars: String) (n: Nat) :\n  let tree := custom_christmas_tree chars n\n  let tree_part := (splitLines tree).take n\n  \u2200 line \u2208 tree_part, stringTrim line \u2260 \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002672.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digitize (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def digitsToNat (digits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digitize_single_digits {n : Nat} :\n  \u2200 d \u2208 digitize n, d \u2264 9 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digitize_length_matches_input {n : Nat} :\n  (List.length (digitize n)) = String.length (toString n) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digitize_reconstruction {n : Nat} :\n  n = digitsToNat (List.reverse (digitize n)) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digitize_preserves_digits {n : Nat} :\n  List.map (fun d => toString d) (digitize n) =\n  (toString n).toList.map toString := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digitize_zero :\n  digitize 0 = [0] := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1, 3, 2, 5, 3]\n-/\n#guard_msgs in\n#eval digitize 35231\n\n/-\ninfo: [7, 5, 3, 2, 8, 5, 3, 2]\n-/\n#guard_msgs in\n#eval digitize 23582357\n\n/-\ninfo: [8, 3, 7, 4, 6, 7, 4, 8, 9]\n-/\n#guard_msgs in\n#eval digitize 984764738"
      }
    ]
  },
  "fvapps_002675.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pattern (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.lines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toString (n : Int) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_positive_returns_empty\n  (n : Int)\n  (h : n \u2264 0) :\n  pattern n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_format_empty\n  (n : Int)\n  (h : n = 1) :\n  pattern n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_format_content\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n \u2264 100)\n  (i : Nat)\n  (h3 : i > 0)\n  (h4 : i \u2264 n/2) :\n  (pattern n).lines.get! (i-1) = String.mk (List.replicate (2*i) (toString (2*i))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_even_equivalence\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n \u2264 100)\n  (h3 : n % 2 = 1) :\n  pattern n = pattern (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem line_count\n  (n : Int)\n  (h1 : n > 1)\n  (h2 : n \u2264 100) :\n  (pattern n).lines.length = n/2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0\n\n/-\ninfo: '22\\n4444'\n-/\n#guard_msgs in\n#eval pattern 5"
      }
    ]
  },
  "fvapps_002676.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def switcher (arr : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_input (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_output (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def expected_map (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem switcher_properties (arr : List Nat) :\n  is_valid_input arr \u2192\n  let result := switcher arr\n  (is_valid_output result) \u2227\n  (result.length = (arr.filter (\u00b7 \u2260 0)).length) \u2227\n  (result = String.join (arr.map expected_map)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem switcher_all_zeros (arr : List Nat) :\n  arr.all (\u00b7 = 0) \u2192\n  switcher arr = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'codewars'\n-/\n#guard_msgs in\n#eval switcher [\"24\", \"12\", \"23\", \"22\", \"4\", \"26\", \"9\", \"8\"]\n\n/-\ninfo: 'btswmdsbd kkw'\n-/\n#guard_msgs in\n#eval switcher [\"25\", \"7\", \"8\", \"4\", \"14\", \"23\", \"8\", \"25\", \"23\", \"29\", \"16\", \"16\", \"4\"]\n\n/-\ninfo: 'o?bfbtpel'\n-/\n#guard_msgs in\n#eval switcher [\"12\", \"28\", \"25\", \"21\", \"25\", \"7\", \"11\", \"22\", \"15\"]"
      }
    ]
  },
  "fvapps_002691.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfSquares (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfCubes (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def array_madness (a b : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_madness_correct (a b : List Int) (h1 : a.length > 0) (h2 : b.length > 0) :\n  array_madness a b = (sumOfSquares a > sumOfCubes b) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_numbers_property\n    (a b : List Int)\n    (h1 : a.length > 0)\n    (h2 : b.length > 0)\n    (ha : \u2200 x \u2208 a, 0 \u2264 x \u2227 x \u2264 10)\n    (hb : \u2200 x \u2208 b, 1 \u2264 x \u2227 x \u2264 10)\n    (h : sumOfSquares a \u2264 sumOfCubes b) :\n  array_madness a b = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [4, 5, 6] [1, 2, 3]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval array_madness [1, 2] [2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval array_madness [5, 6, 7] [1, 1, 1]"
      }
    ]
  },
  "fvapps_002699.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def what_is_the_time (time : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_time (time : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem mirror_time_format (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  (result.length = 5) \u2227\n  (result.data.get \u27e82, by sorry\u27e9 = ':') \u2227\n  (is_valid_time result = true) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mirror_time_symmetry (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  what_is_the_time (what_is_the_time time) = time :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mirror_time_bounds (time : String)\n  (h : time.contains ':')\n  (len : time.length = 5)\n  (valid : is_valid_time time = true) :\n  let result := what_is_the_time time\n  let hour := result.take 2\n  let minute := result.drop 3\n  (1 \u2264 String.toNat! hour \u2227 String.toNat! hour \u2264 12) \u2227\n  (0 \u2264 String.toNat! minute \u2227 String.toNat! minute \u2264 59) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '05:25'\n-/\n#guard_msgs in\n#eval what_is_the_time \"06:35\"\n\n/-\ninfo: '12:01'\n-/\n#guard_msgs in\n#eval what_is_the_time \"11:59\"\n\n/-\ninfo: '11:58'\n-/\n#guard_msgs in\n#eval what_is_the_time \"12:02\""
      }
    ]
  },
  "fvapps_002702.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def withdraw (n : Int) : (Int \u00d7 Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The withdraw function returns a valid solution for multiples of 10 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem withdraw_valid (amount : Int) (h : amount \u2265 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  hundreds \u2265 0 \u2227 fifties \u2265 0 \u2227 twenties \u2265 0 \u2227\n  hundreds * 100 + fifties * 50 + twenties * 20 = amount :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The withdraw function returns optimal solutions with limited 20s -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem withdraw_optimal (amount : Int) (h : amount \u2265 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  twenties \u2264 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The withdraw function uses fifties efficiently -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem withdraw_fifty_efficient (amount : Int) (h : amount \u2265 20) (h2 : amount % 10 = 0) :\n  let (hundreds, fifties, twenties) := withdraw amount\n  fifties > 0 \u2192\n  let remainder := amount - (hundreds * 100 + fifties * 50)\n  remainder \u2265 0 \u2227 remainder % 20 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [0, 0, 2]\n-/\n#guard_msgs in\n#eval withdraw 40\n\n/-\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval withdraw 250\n\n/-\ninfo: [2, 0, 3]\n-/\n#guard_msgs in\n#eval withdraw 260"
      }
    ]
  },
  "fvapps_002706.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def chessboard (n: Nat) (m: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.lines (s: String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.characterAt (s: String) (i: Nat) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chessboard_empty_for_zero_dims {n m: Nat} :\n  (n = 0 \u2228 m = 0) \u2192 chessboard n m = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chessboard_dimensions {n m: Nat} (h1 : n \u2260 0) (h2 : m \u2260 0) :\n  let lines := (chessboard n m).lines\n  lines.length = n \u2227\n  \u2200 l \u2208 lines, l.length = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chessboard_alternating_pattern {n m : Nat} (h1 : n > 0) (h2 : m > 0) :\n  let lines := (chessboard n m).lines\n  \u2200 i j, i < n \u2192 j < m \u2192\n    let line := lines[i]'(by sorry)\n    let char := line.characterAt j\n    ((i + j) % 2 = 0 \u2192 char = '*') \u2227\n    ((i + j) % 2 \u2260 0 \u2192 char = '.') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval chessboard 0 0\n\n/-\ninfo: '*.\\n.*'\n-/\n#guard_msgs in\n#eval chessboard 2 2\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval chessboard 8 8"
      }
    ]
  },
  "fvapps_002707.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_DNA (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The function check_DNA is symmetric: gives same result regardless of argument order -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_DNA_symmetric (s1 s2 : String) :\n  check_DNA s1 s2 = check_DNA s2 s1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Empty sequence matches any sequence -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_DNA_empty (s : String) :\n  check_DNA s \"\" = true \u2227 check_DNA \"\" s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Known complementary sequences match -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem check_DNA_basic_complement :\n  check_DNA \"ATGCTACG\" \"CGTAGCAT\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAT\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_DNA \"GCTAGCACCCATTAGGAGATAC\" \"CTCCTAATGGGTG\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_DNA \"ATGCTACG\" \"CGTAGCAA\""
      }
    ]
  },
  "fvapps_002708.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def modified_sum (lst : List Int) (p : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem modified_sum_p_one {lst : List Int} (h : lst \u2260 []) :\n  modified_sum lst 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2, 3] 3\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval modified_sum [1, 2] 5\n\n/-\ninfo: 68\n-/\n#guard_msgs in\n#eval modified_sum [3, 5, 7] 2"
      }
    ]
  },
  "fvapps_002711.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def peak (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem peak_equal_sums (arr : List Int) (h_size : arr.length > 0) :\n  let p := peak arr;\n  p \u2260 -1 \u2192\n  sum (arr.take (Int.toNat p)) = sum (arr.drop (Int.toNat (p + 1))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem peak_bounds (arr : List Int) :\n  let p := peak arr;\n  -1 \u2264 p \u2227 p < arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem peak_single_element (arr : List Int) (h : arr.length = 1) :\n  peak arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem peak_empty :\n  peak [] = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval peak [1, 2, 3, 5, 3, 2, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval peak [1, 12, 3, 3, 6, 3, 1]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval peak [10, 20, 30, 40]"
      }
    ]
  },
  "fvapps_002714.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findLongest (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidParens (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def substringFromTo (s : String) (i j : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem findLongest_valid (s : String) :\n  let result := findLongest s\n  result \u2264 s.length \u2227\n  result % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findLongest_optimal (s : String) :\n  let result := findLongest s\n  \u2200 i j, i < s.length \u2192 j \u2264 s.length \u2192 j > i \u2192\n    let substr := substringFromTo s i j\n    isValidParens substr \u2192 substr.length \u2264 result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findLongest_exists (s : String) :\n  let result := findLongest s\n  result > 0 \u2192\n  \u2203 i j, i < s.length \u2227 j \u2264 s.length \u2227 j > i \u2227\n    let substr := substringFromTo s i j\n    substr.length = result \u2227\n    isValidParens substr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findLongest_matched_pairs (n : Nat) :\n  let s := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  findLongest s = 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem findLongest_unmatched_surround (n : Nat) :\n  n > 0 \u2192\n  let balanced := String.mk (List.replicate n '(' ++ List.replicate n ')')\n  let s := \")\" ++ balanced ++ \"(\"\n  findLongest s = 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \")()\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_longest \"((()\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_longest \"())(()))\""
      }
    ]
  },
  "fvapps_002720.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def CombString := String -- represents strings of only * and ."
      },
      {
        "type": "sig",
        "string": "def combs (a b : CombString) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The result length is at least as long as the longest input -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem combs_min_length {a b : CombString} :\n  combs a b \u2265 max a.length b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The result length is at most the sum of input lengths -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem combs_max_length {a b : CombString} :\n  combs a b \u2264 a.length + b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The function is symmetric -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem combs_symmetric {a b : CombString} :\n  combs a b = combs b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Strings of all dots combine to max length -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem combs_all_dots {a b : CombString}\n  (ha : \u2200 c, c \u2208 a.data \u2192 c = '.')\n  (hb : \u2200 c, c \u2208 b.data \u2192 c = '.') :\n  combs a b = max a.length b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Strings of all stars combine to sum of lengths -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem combs_all_stars {a b : CombString}\n  (ha : \u2200 c, c \u2208 a.data \u2192 c = '*')\n  (hb : \u2200 c, c \u2208 b.data \u2192 c = '*') :\n  combs a b = a.length + b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*..*\" \"*.*\"\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval combs \"*...*\" \"*.*\"\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval combs \"*..*.*\" \"*.***\""
      }
    ]
  },
  "fvapps_002721.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def largest_sum (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem largest_sum_nonnegative (arr : List Int) :\n  largest_sum arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_positives (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  (arr.filter (fun x => x > 0)).foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "sig",
        "string": "def is_contiguous_subsequence_sum (arr : List Int) (target : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  let n := arr.length\n  let indices := List.range n\n  indices.any fun i =>\n    let subSeqLengths := List.range (n - i)\n    subSeqLengths.any fun len =>\n      let subseqSum := (List.range len).foldl (fun sum j =>\n        match arr.get? (i + j) with\n        | none => sum\n        | some v => sum + v\n      ) 0\n      subseqSum = target"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum [-1, -2, -3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval largest_sum []\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval largest_sum [1, 2, 3]\n\n/-\ninfo: 187\n-/\n#guard_msgs in\n#eval largest_sum [31, -41, 59, 26, -53, 58, 97, -93, -23, 84]"
      }
    ]
  },
  "fvapps_002725.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.substringExists (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def alan_annoying_kid (phrase : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.getWords (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alan_preserves_verb (phrase : String) (verb : String)\n  (h\u2081 : phrase.startsWith \"Today I\")\n  (h\u2082 : verb \u2208 phrase.getWords) :\n  verb \u2208 (alan_annoying_kid phrase).getWords :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alan_response_structure (phrase : String) (h\u2081 : phrase.startsWith \"Today I\") :\n  let response := alan_annoying_kid phrase\n  response.startsWith \"I don't think you\" \u2227\n  response.endsWith \"!\" \u2227\n  response.substringExists \"today\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alan_response_negation_negative (phrase : String) (h\u2081 : phrase.startsWith \"Today I didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you did\" \u2227\n  response.substringExists \"it!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alan_response_negation_positive (phrase : String)\n  (h\u2081 : phrase.startsWith \"Today I\")\n  (h\u2082 : \u00acphrase.substringExists \"didn't\") :\n  let response := alan_annoying_kid phrase\n  response.substringExists \"I think you didn't\" \u2227\n  response.substringExists \"at all!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I played football.\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I didn\"t play football.\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval alan_annoying_kid \"Today I cleaned the kitchen.\""
      }
    ]
  },
  "fvapps_002732.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.sort (l : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def same (a b : List (List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_reflexive (arr : List (List Int)) : same arr arr = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_symmetric (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort \u2192\n  same arr_a arr_b = true \u2227 same arr_b arr_a = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_single_array (nums : List Int) :\n  same [nums] [nums.reverse] = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_order_invariant (arr_a arr_b : List (List Int)) :\n  (List.map List.sort arr_a).sort = (List.map List.sort arr_b).sort \u2192\n  same arr_a arr_b = true := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval same [[2, 5], [3, 6]] [[5, 2], [3, 6]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval same [] []\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval same [[2, 3], [3, 2]] [[2, 3]]"
      }
    ]
  },
  "fvapps_002737.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Photo := String"
      },
      {
        "type": "sig",
        "string": "def Year := Nat"
      },
      {
        "type": "sig",
        "string": "def ImgNum := Nat"
      },
      {
        "type": "constr",
        "string": "instance : Inhabited Photo := \u27e8\"\"\u27e9"
      },
      {
        "type": "constr",
        "string": "instance : LT Year := \u27e8Nat.lt\u27e9"
      },
      {
        "type": "constr",
        "string": "instance : LT ImgNum := \u27e8Nat.lt\u27e9"
      },
      {
        "type": "constr",
        "string": "instance : HAdd ImgNum Nat ImgNum := \u27e8Nat.add\u27e9"
      },
      {
        "type": "constr",
        "string": "instance : LT (Year \u00d7 ImgNum) := \u27e8\u03bb a b => a.1 < b.1 \u2228 (a.1 = b.1 \u2227 a.2 < b.2)\u27e9"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def sort_photos (photos : List Photo) : List Photo :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to parse year from photo string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def parse_year (photo : Photo) : Year :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to parse image number from photo string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def parse_imgnum (photo : Photo) : ImgNum :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_photos_length (photos : List Photo) :\n  photos \u2260 [] \u2192\n  photos.length > 0 \u2192\n  let result := sort_photos photos\n  result.length = min photos.length 5 + 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_photos_contains_originals (photos : List Photo) :\n  photos \u2260 [] \u2192\n  let result := sort_photos photos\n  \u2200 i, i < result.length - 1 \u2192 result[i]! \u2208 photos := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_photos_sorted (photos : List Photo) :\n  photos \u2260 [] \u2192\n  let result := sort_photos photos\n  \u2200 i j, i < j \u2192 j < result.length - 1 \u2192\n    (parse_year result[i]!, parse_imgnum result[i]!) <\n    (parse_year result[j]!, parse_imgnum result[j]!) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_photos_last_increments (photos : List Photo) :\n  photos \u2260 [] \u2192\n  let result := sort_photos photos\n  parse_year result[result.length-1]! = parse_year result[result.length-2]! \u2227\n  parse_imgnum result[result.length-1]! = parse_imgnum result[result.length-2]! + 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_photos_format_valid (photos : List Photo) :\n  photos \u2260 [] \u2192\n  let result := sort_photos photos\n  \u2200 p \u2208 result, \u2203 y n : Nat,\n    y \u2265 1000 \u2227 y \u2264 9999 \u2227 -- Year between 1000-9999\n    n > 0 \u2227 -- Positive image number\n    parse_year p = y \u2227\n    parse_imgnum p = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\", \"2016.img2\", \"2015.img3\", \"2016.img4\", \"2013.img5\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img1\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_photos [\"2016.img4\", \"2016.img5\", \"2016.img1\", \"2016.img3\", \"2016.img2\"]"
      }
    ]
  },
  "fvapps_002749.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def remove (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- If a word in the input string doesn't contain exclamation marks,\n    it remains unchanged in the output -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem words_preserved (s : String) :\n  \u2200 w, w \u2208 (s.split (\u00b7 = ' ')) \u2192\n  (\u00ac ('!' \u2208 w.data)) \u2192\n  w \u2208 (remove s).split (\u00b7 = ' ') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- No word in the output string ends with an exclamation mark -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem no_trailing_exclamations (s : String) :\n  \u2200 w, w \u2208 (remove s).split (\u00b7 = ' ') \u2192\n  \u00ac w.endsWith \"!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- If a word starts with exclamation marks in the input,\n    it starts with the same exclamation marks in the output -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem leading_exclamations_preserved (s : String) :\n  \u2200 w w', w \u2208 s.split (\u00b7 = ' ') \u2192\n  w' \u2208 (remove s).split (\u00b7 = ' ') \u2192\n  w.startsWith \"!\" \u2192 w' = w \u2228 w'.startsWith \"!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!\"\n\n/-\ninfo: 'Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi!!!\"\n\n/-\ninfo: '!Hi'\n-/\n#guard_msgs in\n#eval remove \"!Hi!\"\n\n/-\ninfo: 'Hi Hi'\n-/\n#guard_msgs in\n#eval remove \"Hi! Hi!\"\n\n/-\ninfo: '!!!Hi !!hi !hi'\n-/\n#guard_msgs in\n#eval remove \"!!!Hi !!hi!!! !hi\""
      }
    ]
  },
  "fvapps_002755.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ka_co_ka_de_ka_me (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper functions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isVowel (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def removeKa (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getConsonants (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ka_prefix (word: String) :\n  String.isPrefixOf \"ka\" (ka_co_ka_de_ka_me word) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_increases (word: String) :\n  word.length > 0 \u2192 (ka_co_ka_de_ka_me word).length > word.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_vowels (word: String) :\n  (\u2200 c \u2208 word.data, isVowel c) \u2192\n  ka_co_ka_de_ka_me word = \"ka\" ++ word :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consonants_unchanged (word: String) :\n  getConsonants word = getConsonants (removeKa (ka_co_ka_de_ka_me word)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'kaa'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"a\"\n\n/-\ninfo: 'kamaikantekanakance'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"maintenance\"\n\n/-\ninfo: 'kaIkancokamprekahekansikabikalikatiekas'\n-/\n#guard_msgs in\n#eval ka_co_ka_de_ka_me \"Incomprehensibilities\""
      }
    ]
  },
  "fvapps_002760.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def string_transformer (s : String) : String := sorry\n\ndef countSpaces (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.foldl (fun count c => if c = ' ' then count + 1 else count) 0"
      },
      {
        "type": "sig",
        "string": "def swapcase (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_preservation (s : String) :\n  countSpaces s = countSpaces (string_transformer s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_order_reversal (words : List String) (h : words \u2260 []) :\n  let s := String.intercalate \" \" words\n  let result := string_transformer s\n  let original_words := s.split (\u00b7 = ' ')\n  let result_words := result.split (\u00b7 = ' ')\n  original_words.length = result_words.length \u2227\n  \u2200 (i : Nat), i < original_words.length \u2192\n    swapcase (original_words[i]!) = result_words[result_words.length - 1 - i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval string_transformer \"Example string\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval string_transformer \"To be OR not to be That is the Question\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval string_transformer \" A b C d E f G \""
      }
    ]
  },
  "fvapps_002762.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def opposite (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem double_negative_int (x : Int) :\n  opposite (opposite x) = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def opposite_real (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem double_negative_real (x : Float) :\n  opposite_real (opposite_real x) = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_is_self_opposite :\n  opposite 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nonzero_not_self_opposite (x : Int) :\n  x \u2260 0 \u2192 opposite x \u2260 x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_with_opposite_int (x : Int) :\n  x + opposite x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Same theorems for real numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_with_opposite_real (x : Float) :\n  x + opposite_real x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: -1\n-/\n#guard_msgs in\n#eval opposite 1\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval opposite -34\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval opposite 0"
      }
    ]
  },
  "fvapps_002763.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def volume (radius height : Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pi : Float := 3.14159"
      },
      {
        "type": "cond",
        "string": "theorem volume_zero :\n  volume 0 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- \u03c0 is approximated as 3.14159 -/\n\n/-\ninfo: 153\n-/\n#guard_msgs in\n#eval volume 7 3\n\n/-\ninfo: 98520\n-/\n#guard_msgs in\n#eval volume 56 30\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval volume 0 0"
      }
    ]
  },
  "fvapps_002766.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def generate_number (squad : List Nat) (target : Nat) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_number_bounds {squad : List Nat} {n : Nat} :\n  1 \u2264 n \u2192 n \u2264 99 \u2192\n  \u2200 result, generate_number squad n = some result \u2192\n  1 \u2264 result \u2227 result \u2264 99 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_number_not_in_squad {squad : List Nat} {n : Nat} :\n  \u2200 result, generate_number squad n = some result \u2192\n  result \u2209 squad :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem generate_number_digits_sum {squad : List Nat} {n : Nat} :\n  \u2200 result, generate_number squad n = some result \u2192\n  result \u2260 n \u2192 sumOfDigits result = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 15, 69] 34\n\n/-\ninfo: 29\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 69] 11\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval generate_number [1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 38, 47, 56, 65, 69, 74, 83, 92] 11"
      }
    ]
  },
  "fvapps_002770.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def small_enough (numbers : List Int) (limit : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (fun acc x => match acc with\n    | none => some x\n    | some m => some (max m x)) none"
      },
      {
        "type": "cond",
        "string": "theorem small_enough_characterization (numbers : List Int) (limit : Int)\n    (h : numbers \u2260 []) :\n  small_enough numbers limit = ((list_maximum numbers).getD 0 \u2264 limit) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_enough_at_maximum (numbers : List Int) (h : numbers \u2260 []) :\n  let max_val := (list_maximum numbers).getD 0\n  small_enough numbers max_val = true \u2227\n  small_enough numbers (max_val - 1) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_enough_scaling (numbers : List Int) (factor : Int)\n    (h : numbers \u2260 []) (h_pos : factor > 0) :\n  let max_val := (list_maximum numbers).getD 0\n  let scaled_numbers := numbers.map (\u00b7 * factor)\n  small_enough scaled_numbers (max_val * factor) = small_enough numbers max_val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [66, 101] 200\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval small_enough [78, 117, 110, 99, 104, 117, 107, 115] 100\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval small_enough [101, 45, 75, 105, 99, 107] 107"
      }
    ]
  },
  "fvapps_002777.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def toString (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def distinctDigitYear (year : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasDistinctDigits (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distinct_digit_year_greater_than_input (year : Nat)\n  (h : year \u2265 1000 \u2227 year \u2264 9000) :\n  distinctDigitYear year > year :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distinct_digit_year_has_four_digits (year : Nat)\n  (h : year \u2265 1000 \u2227 year \u2264 9000) :\n  distinctDigitYear year \u2265 1000 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distinct_digit_year_has_distinct_digits (year : Nat)\n  (h : year \u2265 1000 \u2227 year \u2264 9000) :\n  hasDistinctDigits (distinctDigitYear year) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem distinct_digit_year_is_minimal (year : Nat)\n  (h : year \u2265 1000 \u2227 year \u2264 9000) :\n  \u2200 y, year < y \u2192 y < distinctDigitYear year \u2192\n    hasDistinctDigits y = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2013\n-/\n#guard_msgs in\n#eval distinct_digit_year 1987\n\n/-\ninfo: 2014\n-/\n#guard_msgs in\n#eval distinct_digit_year 2013"
      }
    ]
  },
  "fvapps_002785.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse_strings (arr : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x :: xs => x + listSum xs"
      },
      {
        "type": "cond",
        "string": "theorem reverse_strings_length_preserved (arr : List String)\n  (h : \u2200 s \u2208 arr, s.length > 0) :\n  let result := reverse_strings arr\n  (result.length = arr.length) \u2227\n  (\u2200 i, i < arr.length \u2192 (result.get \u27e8i, sorry\u27e9).length = (arr.get \u27e8i, sorry\u27e9).length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_strings_is_reversible (arr : List String)\n  (h : \u2200 s \u2208 arr, s.length > 0) :\n  reverse_strings (reverse_strings arr) = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_strings_total_chars_preserved (arr : List String)\n  (h : \u2200 s \u2208 arr, s.length > 0) :\n  let result := reverse_strings arr\n  (listSum (arr.map String.length)) = (listSum (result.map String.length)) \u2227\n  String.reverse (String.join arr) = String.join result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_strings_single_char (arr : List String)\n  (h : \u2200 s \u2208 arr, s.length = 1) :\n  String.join (reverse_strings arr) = String.reverse (String.join arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_strings [\"I\", \"like\", \"big\", \"butts\", \"and\", \"I\", \"cannot\", \"lie!\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_strings [\"?kn\", \"ipnr\", \"utotst\", \"ra\", \"tsn\", \"iksr\", \"uo\", \"yer\", \"ofebta\", \"eote\", \"vahu\", \"oyodpm\", \"ir\", \"hsyn\", \"amwoH\"]"
      }
    ]
  },
  "fvapps_002787.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def alphabet_war (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def valid_letters := ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']\n\ndef score_map (c : Char) : Int :="
      },
      {
        "type": "impl",
        "string": "  match c with\n  | 'w' => 4\n  | 'p' => 3\n  | 'b' => 2\n  | 's' => 1\n  | 'm' => -4\n  | 'q' => -3\n  | 'd' => -2\n  | 'z' => -1\n  | _ => 0"
      },
      {
        "type": "cond",
        "string": "theorem alphabet_war_valid_output (s : String) :\n  alphabet_war s = \"Left side wins!\" \u2228\n  alphabet_war s = \"Right side wins!\" \u2228\n  alphabet_war s = \"Let's fight again!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabet_war_invalid_chars (s : String) :\n  alphabet_war s = \"Left side wins!\" \u2228\n  alphabet_war s = \"Right side wins!\" \u2228\n  alphabet_war s = \"Let's fight again!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabet_war_scoring (s : String) (h : s.all (\u03bb c => c \u2208 valid_letters)) :\n  let score := s.foldr (\u03bb c acc => acc + score_map c) 0\n  if score > 0 then\n    alphabet_war s = \"Left side wins!\"\n  else if score < 0 then\n    alphabet_war s = \"Right side wins!\"\n  else\n    alphabet_war s = \"Let's fight again!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabet_war_opposing_sides (left right : String)\n  (h1 : left.all (\u03bb c => c \u2208 ['w', 'p', 'b', 's']))\n  (h2 : right.all (\u03bb c => c \u2208 ['m', 'q', 'd', 'z'])) :\n  alphabet_war (left ++ right) = \"Left side wins!\" \u2228\n  alphabet_war (left ++ right) = \"Right side wins!\" \u2228\n  alphabet_war (left ++ right) = \"Let's fight again!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/-\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"wq\"\n\n/-\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"zdqmwpbs\""
      }
    ]
  },
  "fvapps_002793.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isConsonant (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_nonnegative (s : String) :\n  solve s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 26\n-/\n#guard_msgs in\n#eval solve \"zodiac\"\n\n/-\ninfo: 57\n-/\n#guard_msgs in\n#eval solve \"strength\"\n\n/-\ninfo: 73\n-/\n#guard_msgs in\n#eval solve \"catchphrase\""
      }
    ]
  },
  "fvapps_002795.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def num_of_open_lockers (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_is_floor_sqrt (n : Nat) :\n  num_of_open_lockers n = sqrt n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_nonnegative (n : Nat) :\n  num_of_open_lockers n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_squared_bound (n : Nat) :\n  (num_of_open_lockers n) * (num_of_open_lockers n) \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_next_squared_bound (n : Nat) :\n  (num_of_open_lockers n + 1) * (num_of_open_lockers n + 1) > n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_zero :\n  num_of_open_lockers 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_open_lockers_one :\n  num_of_open_lockers 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval num_of_open_lockers 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval num_of_open_lockers 4\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval num_of_open_lockers 500"
      }
    ]
  },
  "fvapps_002798.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def repeats (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList : List Int \u2192 Int\n  | [] => 0\n  | (h::t) => h + sumList t"
      },
      {
        "type": "sig",
        "string": "def countList (x : Int) : List Int \u2192 Nat\n  | [] => 0\n  | (h::t) => (if h = x then 1 else 0) + countList x t"
      },
      {
        "type": "constr",
        "string": "inductive Perm : List Int \u2192 List Int \u2192 Prop where\n  | nil : Perm [] []\n  | cons : (x : Int) \u2192 {l\u2081 l\u2082 : List Int} \u2192 Perm l\u2081 l\u2082 \u2192 Perm (x::l\u2081) (x::l\u2082)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem repeats_singles {arr : List Int} (h : arr.length \u2265 1) :\n  repeats arr = sumList (arr.filter (fun x => countList x arr = 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeats_duplicate_array {arr : List Int} (h : arr.length \u2265 1) :\n  repeats (arr ++ arr) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeats_permutation {arr\u2081 arr\u2082 : List Int}\n  (h\u2081 : arr\u2081.length \u2265 2)\n  (h\u2082 : Perm arr\u2081 arr\u2082) :\n  repeats arr\u2081 = repeats arr\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval repeats [4, 5, 7, 5, 4, 8]\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval repeats [9, 10, 19, 13, 19, 13]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval repeats [16, 0, 11, 4, 8, 16, 0, 11]"
      }
    ]
  },
  "fvapps_002804.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def split (s : String) (sep : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse_sentence (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_count_preserved (words : List String) :\n  let sentence := \" \".intercalate words\n  let reversed := reverse_sentence sentence\n  (split sentence \" \").length = (split reversed \" \").length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  reverse_sentence \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem each_word_reversed (s : String) :\n  let original_words := split s \" \"\n  let result_words := split (reverse_sentence s) \" \"\n  \u2200 i, i < original_words.length \u2192\n    result_words[i]! = String.reverse original_words[i]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_sentence \"Hello !Nhoj Want to have lunch?\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_sentence \"CodeWars rules!\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval reverse_sentence \"\""
      }
    ]
  },
  "fvapps_002809.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def how_many_measurements (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def log3ceil (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem measurements_non_negative (n : Nat) (h : n > 0) :\n  how_many_measurements n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem measurements_sufficient (n : Nat) (h : n > 0) :\n  3^(how_many_measurements n) \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_case_one :\n  how_many_measurements 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_case_two :\n  how_many_measurements 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_case_three :\n  how_many_measurements 3 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval how_many_measurements 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_many_measurements 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval how_many_measurements 8\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval how_many_measurements 100"
      }
    ]
  },
  "fvapps_002810.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def dropzone (fire : List Int) (dropzones : List (List Int)) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hypot (x y : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isClosestToFire (point fire : List Int) (points : List (List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isClosestToOrigin (point fire : List Int) (points : List (List Int)) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dropzone_is_valid_point (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 \u2192 dropzones.length > 0 \u2192 dropzone fire dropzones \u2208 dropzones :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dropzone_is_closest_to_fire (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 \u2192 dropzones.length > 0 \u2192\n  isClosestToFire (dropzone fire dropzones) fire dropzones = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dropzone_is_closest_to_origin (fire : List Int) (dropzones : List (List Int)) :\n  fire.length = 2 \u2192 dropzones.length > 0 \u2192\n  isClosestToOrigin (dropzone fire dropzones) fire dropzones = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_dropzone (fire dropzone_single : List Int) :\n  fire.length = 2 \u2192 dropzone_single.length = 2 \u2192\n  dropzone fire [dropzone_single] = dropzone_single :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [7, 9]\n-/\n#guard_msgs in\n#eval dropzone [6, 8] [[3, 2], [6, 1], [7, 9]]\n\n/-\ninfo: [5, 5]\n-/\n#guard_msgs in\n#eval dropzone [9, 2] [[1, 4], [9, 9], [5, 5]]\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval dropzone [1, 1] [[0, 1], [1, 0], [2, 2]]"
      }
    ]
  },
  "fvapps_002812.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def riders (stations : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def calc_min_riders (stations: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem riders_positive (stations: List Nat) :\n  stations.all (fun x => x > 0 \u2227 x \u2264 100) \u2192\n  riders stations > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem riders_bounded (stations: List Nat) :\n  stations.all (fun x => x > 0 \u2227 x \u2264 100) \u2192\n  riders stations \u2264 stations.length + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem riders_short_distances (stations: List Nat) :\n  stations.all (fun x => x \u2264 1) \u2192\n  riders stations = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem riders_long_distances (stations: List Nat) :\n  stations.all (fun x => x \u2265 99 \u2227 x \u2264 100) \u2192\n  (riders stations = stations.length \u2228 riders stations = stations.length + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval riders [18, 15]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval riders [43, 23, 40, 13]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval riders [33, 8, 16, 47, 30, 30, 46]"
      }
    ]
  },
  "fvapps_002823.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bin_to_hex (b : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hex_to_bin (h : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_hex_digit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper for theorem statement"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def is_hex_string (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.all is_hex_digit"
      },
      {
        "type": "cond",
        "string": "theorem hex_to_bin_roundtrip (h : String) :\n  is_hex_string h \u2192\n  bin_to_hex (hex_to_bin h) =\n    if h = \"\" then \"0\"\n    else if h = \"0\" then \"0\"\n    else h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_and_zero_bin_to_hex :\n  bin_to_hex \"\" = \"0\" \u2227\n  bin_to_hex \"0\" = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_and_zero_hex_to_bin :\n  hex_to_bin \"\" = \"0\" \u2227\n  hex_to_bin \"0\" = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000101\"\n\n/-\ninfo: '4d2'\n-/\n#guard_msgs in\n#eval bin_to_hex \"10011010010\"\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval bin_to_hex \"000\"\n\n/-\ninfo: '1111'\n-/\n#guard_msgs in\n#eval hex_to_bin \"00F\"\n\n/-\ninfo: '101'\n-/\n#guard_msgs in\n#eval hex_to_bin \"5\"\n\n/-\ninfo: '10011010010'\n-/\n#guard_msgs in\n#eval hex_to_bin \"04D2\""
      }
    ]
  },
  "fvapps_002826.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def prod_int_part (n: Nat) (min: Nat := 2) : Nat \u00d7 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prod_int_part_output_structure (n: Nat) (h: n \u2265 2) :\n  let result := prod_int_part n\n  result.1 \u2265 0 \u2227 result.2.all (\u03bb x => x \u2265 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_numbers_return_empty (n: Nat) (h: n \u2265 2) :\n  isPrime n \u2192 prod_int_part n = (0, []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem factors_multiply_to_input (n: Nat) (h: n \u2265 2) :\n  let result := prod_int_part n\n  result.2 \u2260 [] \u2192 result.2.foldl (\u00b7*\u00b7) 1 = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem factors_are_ordered (n: Nat) (h: n \u2265 2) :\n  let result := prod_int_part n\n  result.2.length > 1 \u2192\n  \u2200 i, i < result.2.length - 1 \u2192\n  result.2[i]! \u2264 result.2[i+1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_parameter_respects_boundary (n min: Nat) (h1: n \u2265 2) (h2: min \u2265 2) :\n  let result := prod_int_part n min\n  result.2.all (\u03bb x => x \u2265 min) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, [2, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 18\n\n/-\ninfo: [10, [2, 2, 3, 5]]\n-/\n#guard_msgs in\n#eval prod_int_part 60\n\n/-\ninfo: [6, [2, 3, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 54\n\n/-\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 37\n\n/-\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 61"
      }
    ]
  },
  "fvapps_002827.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def watch_pyramid_from_the_side (chars : Option String) : Option String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def watch_pyramid_from_above (chars : Option String) : Option String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_visible_characters_of_the_pyramid (chars : Option String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_all_characters_of_the_pyramid (chars : Option String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty inputs theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_inputs {chars : Option String} :\n  chars = none \u2228 chars = some \"\" \u2192\n  watch_pyramid_from_the_side chars = chars \u2227\n  watch_pyramid_from_above chars = chars \u2227\n  count_visible_characters_of_the_pyramid chars = -1 \u2227\n  count_all_characters_of_the_pyramid chars = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Visible characters theorem"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem count_visible_chars {s : String} (h : s.length > 0) :\n  count_visible_characters_of_the_pyramid (some s) =\n    (2 * s.length - 1) * (2 * s.length - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side None\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid None\n\n/-\ninfo: expected_side\n-/\n#guard_msgs in\n#eval watch_pyramid_from_the_side \"abc\"\n\n/-\ninfo: expected_above\n-/\n#guard_msgs in\n#eval watch_pyramid_from_above test_str\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval count_visible_characters_of_the_pyramid test_str\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval count_all_characters_of_the_pyramid test_str"
      }
    ]
  },
  "fvapps_002828.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def multiple_split (s : String) (delims : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsString (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_split_nonempty_parts\n  (s : String) (delims : List String)\n  : \u2200 (x : String), x \u2208 multiple_split s delims \u2192 x.length > 0\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_split_no_delims_in_result\n  (s : String) (delims : List String)\n  : \u2200 (x : String) (d : String),\n    x \u2208 multiple_split s delims \u2192\n    d \u2208 delims \u2192\n    \u00ac containsString x d\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_split_empty_string\n  (delims : List String)\n  : multiple_split \"\" delims = []\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_split_empty_delims\n  (s : String)\n  : multiple_split s [] = if s = \"\" then [] else [s]\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_split_single_delim\n  (s : String) (delim : String)\n  (h : delim.length > 0)\n  : multiple_split s [delim] = (s.split (\u00b7 == '.')).filter (fun x => x \u2260 \"\") -- placeholder split\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['Hi', 'everybody']\n-/\n#guard_msgs in\n#eval multiple_split \"Hi everybody!\" [\" \", \"!\"]\n\n/-\ninfo: ['1', '2', '3']\n-/\n#guard_msgs in\n#eval multiple_split \"1+2-3\" [\"+\", \"-\"]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval multiple_split \"\" []"
      }
    ]
  },
  "fvapps_002829.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPowerOfTwo (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def arrayConversion (arr : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_conversion_power_of_two_length\n  {n : Nat} {arr : List Nat}\n  (h1 : n \u2265 1) (h2 : n \u2264 5)\n  (h3 : arr.length = 2^n) :\n  isPowerOfTwo arr.length = true \u2227\n  arrayConversion arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_conversion_deterministic\n  {arr : List Nat}\n  (h : isPowerOfTwo arr.length = true) :\n  arrayConversion arr = arrayConversion arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_conversion_monotonic\n  {arr : List Nat} {i : Nat}\n  (h1 : isPowerOfTwo arr.length = true)\n  (h2 : i < arr.length) :\n  let arr' := arr.set i (arr[i] + 1)\n  arrayConversion arr' \u2265 arrayConversion arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 186\n-/\n#guard_msgs in\n#eval array_conversion [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 64\n-/\n#guard_msgs in\n#eval array_conversion [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval array_conversion [3, 3, 5, 5]"
      }
    ]
  },
  "fvapps_002831.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def songDecoder (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstring (sub str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_wub_in_output (s : String) :\n  \u00acisSubstring \"WUB\" (songDecoder s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_leading_trailing_spaces (s : String) :\n  \u00ac(songDecoder s).startsWith \" \" \u2227 \u00ac(songDecoder s).endsWith \" \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_multiple_spaces (s : String) :\n  \u00acisSubstring \"  \" (songDecoder s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent (s : String) :\n  songDecoder (songDecoder s) = songDecoder s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_properties (s : String) :\n  let result := songDecoder s\n  String.length result \u2265 0 \u2227\n  \u00acisSubstring \"  \" result \u2227\n  \u00acresult.startsWith \" \" \u2227\n  \u00acresult.endsWith \" \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'WE ARE THE CHAMPIONS MY FRIEND'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\"\n\n/-\ninfo: 'A B C'\n-/\n#guard_msgs in\n#eval song_decoder \"AWUBBWUBC\"\n\n/-\ninfo: 'O IPVCQAFWY Q XHDKCPYKCTWWY V FZ'\n-/\n#guard_msgs in\n#eval song_decoder \"WUBWUBOWUBWUBWUBIPVCQAFWYWUBWUBWUBQWUBWUBWUBXHDKCPYKCTWWYWUBWUBWUBVWUBWUBWUBFZWUBWUB\""
      }
    ]
  },
  "fvapps_002832.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def prime_factors_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def divisors_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ds_multof_pfs (nMin nMax : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure IsSorted (xs : List Nat) : Prop where\n  sorted : \u2200 i j, i < xs.length \u2192 j < xs.length \u2192 i \u2264 j \u2192 xs[i]! \u2264 xs[j]!"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem is_prime_properties {n : Nat} :\n  (n < 2 \u2192 is_prime n = false) \u2227\n  (is_prime n = true \u2192 n \u2265 2) \u2227\n  (is_prime n = true \u2192 \u2200 i : Nat, 2 \u2264 i \u2227 i \u2264 sqrt n \u2192 n % i \u2260 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_factors_sum_properties {n : Nat} (h : n \u2265 2) :\n  prime_factors_sum n > 0 \u2227\n  prime_factors_sum n \u2264 n * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ds_multof_pfs_properties {nMin nMax : Nat} (h : nMin \u2264 nMax) :\n  let result := ds_multof_pfs nMin nMax\n  IsSorted result \u2227\n  (\u2200 x \u2208 result, nMin \u2264 x \u2227 x \u2264 nMax) \u2227\n  (\u2200 n \u2208 result, prime_factors_sum n > 0 \u2227 (divisors_sum n) % (prime_factors_sum n) = 0) \u2227\n  (\u2200 i j, i < result.length \u2192 j < result.length \u2192 i \u2260 j \u2192 result[i]! \u2260 result[j]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002835.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def last_digits (n : Nat) (d : Int) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_to_string (l : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def nat_to_string (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem last_digits_empty_for_nonpositive (n : Nat) (d : Int) :\n  d <= 0 \u2192 last_digits n d = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem last_digits_length_bound (n : Nat) (d : Int) :\n  d > 0 \u2192 List.length (last_digits n d) = min d.toNat (nat_to_string n).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem last_digits_are_digits (n : Nat) (d : Int) (x : Nat) :\n  x \u2208 last_digits n d \u2192 x \u2264 9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem last_digits_match_string_suffix (n : Nat) (d : Int) :\n  d > 0 \u2192 list_to_string (last_digits n d) = (nat_to_string n).takeRight d.toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem last_digits_full_number (n : Nat) :\n  list_to_string (last_digits n ((nat_to_string n).length + 1)) = nat_to_string n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval last_digits 1 1\n\n/-\ninfo: [3, 7, 6, 7]\n-/\n#guard_msgs in\n#eval last_digits 123767 4\n\n/-\ninfo: [1, 3, 4, 3]\n-/\n#guard_msgs in\n#eval last_digits 1343 5"
      }
    ]
  },
  "fvapps_002841.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverseAndCombineText (text : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result length should match total chars across merged words"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (s.toList.filter (\u00b7 = c)).length"
      },
      {
        "type": "cond",
        "string": "theorem output_length_matches_input_chars (text : String) :\n  String.length (reverseAndCombineText text) =\n  String.length (String.replace text \" \" \"\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- All input chars should appear in output in same quantities"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem chars_preserved (text : String) (c : Char) :\n  countChar c (String.replace text \" \" \"\") =\n  countChar c (reverseAndCombineText text) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Number of words should roughly halve each iteration"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem halves_words_per_iteration (text : String) :\n  let wordCount := (text.split (\u00b7 = ' ')).length\n  let maxIterations := if wordCount \u2264 1 then 0\n                       else (wordCount - 1).log2 + 1\n  \u2200 result : String, result = reverseAndCombineText text \u2192\n  (result.split (\u00b7 = ' ')).length \u2264\n    if wordCount \u2264 1 then 1 else wordCount / (2 ^ maxIterations) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'cbafed'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def\"\n\n/-\ninfo: 'defabcjklghi'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"abc def ghi jkl\"\n\n/-\ninfo: 'trzwqfdstrteettr45hh4325543544hjhjh21lllll'\n-/\n#guard_msgs in\n#eval reverse_and_combine_text \"234hh54 53455 sdfqwzrt rtteetrt hjhjh lllll12  44\""
      }
    ]
  },
  "fvapps_002848.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ValidEvent : Type := String\n\ndef VALID_EVENTS : List ValidEvent :="
      },
      {
        "type": "impl",
        "string": "  [\"cw\", \"CW\", \"cat\", \"CAT\", \"dog\", \"DOG\", \"movie\", \"MOVIE\"]"
      },
      {
        "type": "sig",
        "string": "def isValidEvent (event : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def howMuchCoffee (events : List String) : Nat \u2295 String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_events_ignored (events : List String) :\n  (\u2200 e \u2208 events, e \u2209 VALID_EVENTS) \u2192\n  howMuchCoffee events = .inl 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_events (events : List String) :\n  (\u2200 e \u2208 events, e \u2208 VALID_EVENTS) \u2192\n  let total := events.foldl (fun acc e => acc + if e.all Char.isUpper then 2 else 1) 0\n  if total > 3\n  then howMuchCoffee events = .inr \"You need extra sleep\"\n  else howMuchCoffee events = .inl total :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_event_empty :\n  howMuchCoffee [] = .inl 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_valid_event (event : String) :\n  event \u2208 VALID_EVENTS \u2192\n  howMuchCoffee [event] = .inl (if event.all Char.isUpper then 2 else 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval how_much_coffee []\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\"]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval how_much_coffee [\"CW\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\"]\n\n/-\ninfo: 'You need extra sleep'\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"DOG\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval how_much_coffee [\"cw\", \"CAT\", \"cw=others\"]"
      }
    ]
  },
  "fvapps_002849.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isHexDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rgb (r g b : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hexStringToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rgb_output_format (r g b : Int) :\n  let result := rgb r g b\n  (result.length = 6) \u2227\n  (result.data.all isHexDigit)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rgb_valid_inputs (r g b : Int)\n  (hr : 0 \u2264 r \u2227 r \u2264 255)\n  (hg : 0 \u2264 g \u2227 g \u2264 255)\n  (hb : 0 \u2264 b \u2227 b \u2264 255) :\n  let result := rgb r g b\n  let r_hex := result.take 2\n  let g_hex := result.drop 2 |>.take 2\n  let b_hex := result.drop 4 |>.take 2\n  (hexStringToNat r_hex = r) \u2227\n  (hexStringToNat g_hex = g) \u2227\n  (hexStringToNat b_hex = b)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rgb_negative_inputs (r g b : Int)\n  (hr : r < 0)\n  (hg : g < 0)\n  (hb : b < 0) :\n  rgb r g b = \"000000\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rgb_large_inputs (r g b : Int)\n  (hr : r > 255)\n  (hg : g > 255)\n  (hb : b > 255) :\n  rgb r g b = \"FFFFFF\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '000000'\n-/\n#guard_msgs in\n#eval rgb 0 0 0\n\n/-\ninfo: '010203'\n-/\n#guard_msgs in\n#eval rgb 1 2 3\n\n/-\ninfo: '00FF7D'\n-/\n#guard_msgs in\n#eval rgb -20 275 125"
      }
    ]
  },
  "fvapps_002853.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validate (username password : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def validUsers : List String := [\"Timmy\", \"Alice\", \"Johny\", \"Roger\", \"Simon\", \"Admin\"]"
      },
      {
        "type": "cond",
        "string": "theorem invalid_username {username password : String}\n  (h : username \u2209 validUsers) :\n  validate username password = \"Wrong username or password!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem injection_attempt {username password1 password2 : String}\n  (h : username \u2208 validUsers) :\n  validate username (password1 ++ \"||\" ++ password2) = \"Wrong username or password!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem injection_attempt_slash {username password1 password2 : String}\n  (h : username \u2208 validUsers) :\n  validate username (password1 ++ \"//\" ++ password2) = \"Wrong username or password!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_login_timmy :\n  validate \"Timmy\" \"password\" = \"Successfully Logged in!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_login_alice :\n  validate \"Alice\" \"alice\" = \"Successfully Logged in!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_user_response {username password : String}\n  (h : username \u2208 validUsers) :\n  validate username password = \"Successfully Logged in!\" \u2228\n  validate username password = \"Wrong username or password!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"h4x0r\"\n\n/-\ninfo: 'Successfully Logged in!'\n-/\n#guard_msgs in\n#eval validate \"Alice\" \"alice\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Timmy\" \"password\"||\"\"==\"\"\n\n/-\ninfo: 'Wrong username or password!'\n-/\n#guard_msgs in\n#eval validate \"Admin\" \"gs5bw\"||1==1//\""
      }
    ]
  },
  "fvapps_002864.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def shared_bits (a b : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shared_bits_symmetric\n  {a b : Nat} : shared_bits a b = shared_bits b a := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shared_bits_self\n  {x : Nat} : shared_bits x x = (countOnes x > 1) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shared_bits_and\n  {a b : Nat} : shared_bits a b = (countOnes (a &&& b) > 1) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shared_bits_single_bit\n  {x : Nat} (h : x \u2264 1) : shared_bits x x = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shared_bits_powers_two\n  {p1 p2 : Nat} (h1 : \u2203 k1, p1 = 2^k1) (h2 : \u2203 k2, p2 = 2^k2) :\n  shared_bits p1 p2 = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 1 2\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval shared_bits 7 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval shared_bits 7 15"
      }
    ]
  },
  "fvapps_002865.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def delete_digit (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem delete_digit_length (n : Nat) (h : n \u2265 10) :\n  (toString (delete_digit n)).length = (toString n).length - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem delete_digit_smaller (n : Nat) (h : n \u2265 10) :\n  delete_digit n < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem delete_digit_natural (n : Nat) (h : n \u2265 10) :\n  delete_digit n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 52\n-/\n#guard_msgs in\n#eval delete_digit 152\n\n/-\ninfo: 101\n-/\n#guard_msgs in\n#eval delete_digit 1001\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval delete_digit 10"
      }
    ]
  },
  "fvapps_002866.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def simple_transposition (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse_transposition (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringTakeEveryNth (s : String) (start : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_preserved (s : String) :\n  (simple_transposition s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_and_single_char (s : String) :\n  s.length \u2264 1 \u2192 simple_transposition s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002867.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_issuer (number : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "inductive CardIssuer where\n  | AMEX : CardIssuer\n  | Discover : CardIssuer\n  | Mastercard : CardIssuer\n  | VISA : CardIssuer\n  | Unknown : CardIssuer\nderiving BEq"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def CardIssuer.toString : CardIssuer \u2192 String\n  | AMEX => \"AMEX\"\n  | Discover => \"Discover\"\n  | Mastercard => \"Mastercard\"\n  | VISA => \"VISA\"\n  | Unknown => \"Unknown\""
      },
      {
        "type": "cond",
        "string": "theorem issuer_is_valid (n : Nat) :\n  let result := get_issuer n\n  result = \"AMEX\" \u2228 result = \"Discover\" \u2228 result = \"Mastercard\" \u2228 result = \"VISA\" \u2228 result = \"Unknown\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem amex_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"34\" \u2228 digits.take 2 = \"37\") \u2192 get_issuer n = \"AMEX\" \u2227\n  (digits.take 2 = \"35\" \u2228 digits.take 2 = \"36\") \u2192 get_issuer n = \"Unknown\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem visa_length_rules (n : Nat) :\n  let digits := n.repr\n  (digits.get! 0 = '4' \u2227 (digits.length = 13 \u2228 digits.length = 16)) \u2192\n    get_issuer n = \"VISA\" \u2227\n  (digits.get! 0 = '4' \u2227 \u00ac(digits.length = 13 \u2228 digits.length = 16)) \u2192\n    get_issuer n = \"Unknown\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mastercard_rules (n : Nat) :\n  let digits := n.repr\n  (digits.take 2 = \"51\" \u2228 digits.take 2 = \"52\" \u2228 digits.take 2 = \"53\" \u2228 digits.take 2 = \"54\" \u2228 digits.take 2 = \"55\") \u2192\n  digits.length = 16 \u2192\n  get_issuer n = \"Mastercard\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discover_rules (n : Nat) :\n  let digits := n.repr\n  digits.startsWith \"6011\" \u2227 digits.length = 16 \u2192\n    get_issuer n = \"Discover\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111111\n\n/-\ninfo: 'VISA'\n-/\n#guard_msgs in\n#eval get_issuer 4111111111111\n\n/-\ninfo: 'AMEX'\n-/\n#guard_msgs in\n#eval get_issuer 378282246310005\n\n/-\ninfo: 'Mastercard'\n-/\n#guard_msgs in\n#eval get_issuer 5105105105105100\n\n/-\ninfo: 'Discover'\n-/\n#guard_msgs in\n#eval get_issuer 6011111111111117\n\n/-\ninfo: 'Unknown'\n-/\n#guard_msgs in\n#eval get_issuer 9111111111111111"
      }
    ]
  },
  "fvapps_002868.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def NoteNames : List String := [\"C\", \"C#\", \"Db\", \"D\", \"D#\", \"Eb\", \"E\", \"F\", \"F#\", \"Gb\", \"G\", \"G#\", \"Ab\", \"A\", \"A#\", \"Bb\", \"B\"]\n/- The main function that determines if a chord is major, minor, or invalid -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def minor_or_major (input : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Returns the list of words in a string -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Invalid input types should return \"Not a chord\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem invalid_input_numeric (n : Nat) :\n  minor_or_major (toString n) = \"Not a chord\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Wrong number of notes (not equal to 3) should return \"Not a chord\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem wrong_note_count (notes : String) :\n  (splitString notes).length \u2260 3 \u2192 minor_or_major notes = \"Not a chord\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Invalid note names should return \"Not a chord\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem invalid_note_names (notes : String) :\n  (\u2203 note, note \u2208 splitString notes \u2227 note \u2209 NoteNames) \u2192\n  minor_or_major notes = \"Not a chord\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Known major chords should return \"Major\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem known_major_chords :\n  minor_or_major \"C E G\" = \"Major\" \u2227\n  minor_or_major \"F# A# C#\" = \"Major\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Known minor chords should return \"Minor\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem known_minor_chords :\n  minor_or_major \"C Eb G\" = \"Minor\" \u2227\n  minor_or_major \"F# A C#\" = \"Minor\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Enharmonic equivalents should produce the same result -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem enharmonic_equivalence (n1 n2 : String) (other1 other2 : String) :\n  ((n1 = \"C#\" \u2227 n2 = \"Db\") \u2228\n   (n1 = \"D#\" \u2227 n2 = \"Eb\") \u2228\n   (n1 = \"F#\" \u2227 n2 = \"Gb\") \u2228\n   (n1 = \"G#\" \u2227 n2 = \"Ab\") \u2228\n   (n1 = \"A#\" \u2227 n2 = \"Bb\")) \u2192\n  minor_or_major (s!\"{n1} {other1} {other2}\") =\n  minor_or_major (s!\"{n2} {other1} {other2}\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'Major'\n-/\n#guard_msgs in\n#eval minor_or_major \"C E G\"\n\n/-\ninfo: 'Minor'\n-/\n#guard_msgs in\n#eval minor_or_major \"C Eb G\"\n\n/-\ninfo: 'Not a chord'\n-/\n#guard_msgs in\n#eval minor_or_major \"C D G\""
      }
    ]
  },
  "fvapps_002878.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isSolved (board : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSequential (board : List (List Nat)) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solved_board_generated {n : Nat} (h : n > 0) (h2 : n \u2264 5) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  isSolved board = isSequential board :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arbitrary_boards_match_sequential (board : List (List Nat))\n  (h : board.length > 0)\n  (h2 : board.length \u2264 5)\n  (h3 : \u2200 row \u2208 board, row.length = board.length) :\n  isSolved board = isSequential board :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_swap_breaks_solution\n  {n : Nat} (h : n > 0) (h2 : n \u2264 5)\n  (pos1 pos2 : Nat) (h3 : pos1 \u2260 pos2) :\n  let board := List.map (fun i => List.map (fun j => n * i + j) (List.range n)) (List.range n)\n  let total_size := n * n\n  let pos1' := pos1 % total_size\n  let pos2' := pos2 % total_size\n  let row1 := pos1' / n\n  let col1 := pos1' % n\n  let row2 := pos2' / n\n  let col2 := pos2' % n\n  let swapped_board := sorry -- actual swapping implementation would go here\n  \u00ac(isSolved swapped_board) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0], [3, 2]]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_solved [[1, 0, 4], [3, 2, 7], [8, 5, 6]]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_solved [[0, 1], [2, 3]]"
      }
    ]
  },
  "fvapps_002880.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def levenshtein (s1 s2 : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Non-negativity"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def repeatChar (c : Char) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_nonneg (s1 s2 : String) :\n  levenshtein s1 s2 \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Identity"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_identity (s : String) :\n  levenshtein s s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Symmetry"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_symm (s1 s2 : String) :\n  levenshtein s1 s2 = levenshtein s2 s1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Triangle inequality"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_triangle (s1 s2 s3 : String) :\n  levenshtein s1 s2 \u2264 levenshtein s1 s3 + levenshtein s3 s2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_empty_string (s : String) :\n  levenshtein s \"\" = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem levenshtein_empty_string_rev (s : String) :\n  levenshtein \"\" s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Repeated char prepending\n\n-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval levenshtein \"kitten\" \"sitting\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval levenshtein \"book\" \"back\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval levenshtein \"peter\" \"peter\""
      }
    ]
  },
  "fvapps_002882.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def alphabetic (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_alphabetic :\n  alphabetic \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (cs : List Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < cs.length \u2192 cs[i]! \u2264 cs[j]!"
      },
      {
        "type": "cond",
        "string": "theorem single_char_alphabetic (c : Char) :\n  alphabetic (String.singleton c) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetic_iff_sorted (s : String) :\n  alphabetic s = true \u2194 isSorted s.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetic_monotonic (s : String) :\n  alphabetic s = true \u2192\n  \u2200 i : Nat, i + 1 < s.length \u2192\n  s.data[i]! \u2264 s.data[i+1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concat_nonalpha_equiv_sorted (ss : List String) (h : ss \u2260 []) :\n  (\u2200 s \u2208 ss, alphabetic s = false) \u2192\n  alphabetic (String.join ss) = true \u2194 isSorted (String.join ss).data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"door\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval alphabetic \"cell\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval alphabetic \"kata\""
      }
    ]
  },
  "fvapps_002888.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def firstIndex (s: String) (c: Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def lastIndex (s: String) (c: Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve (s: String) : Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_char_from_input (s: String) (h: s.length > 0) :\n  \u2203 p: String.Pos, solve s = s.get p :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_char_with_minimal_first_last_diff (s: String) (h: s.length > 0) :\n  \u2200 c: Char,\n  firstIndex s (solve s) - lastIndex s (solve s)\n  \u2264 firstIndex s c - lastIndex s c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_lexicographically_first_when_tied (s: String) (h: s.length > 0) :\n  \u2200 c: Char,\n  (firstIndex s c - lastIndex s c = firstIndex s (solve s) - lastIndex s (solve s))\n  \u2192 solve s \u2264 c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"a\"\n\n/-\ninfo: 'x'\n-/\n#guard_msgs in\n#eval solve \"axyzxyz\"\n\n/-\ninfo: 'a'\n-/\n#guard_msgs in\n#eval solve \"dcbadcba\""
      }
    ]
  },
  "fvapps_002889.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def rthn_between (a b : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rthn_between_ordered_bounds {a b : Int} (h : a \u2264 b) (h\u2081 : 0 \u2264 a) (h\u2082 : b \u2264 10000) :\n  let result := rthn_between a b\n  -- Result is sorted\n  (\u2200 i j, i < j \u2192 i < List.length result \u2192 j < List.length result \u2192\n    result[i]! \u2264 result[j]!) \u2227\n  -- All numbers within bounds\n  (\u2200 x \u2208 result, a \u2264 x \u2227 x \u2264 b) \u2227\n  -- Each number divisible by sum of its digits\n  (\u2200 x \u2208 result, x % sumOfDigits (Int.toNat x) = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rthn_between_same_bounds {n : Int} (h : 0 \u2264 n) (h\u2081 : n \u2264 10000) :\n  let result := rthn_between n n\n  (result \u2260 [] \u2192\n    List.length result = 1 \u2227\n    result[0]! = n \u2227\n    n % sumOfDigits (Int.toNat n) = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rthn_between_inverted_bounds {n : Int} (h : 0 \u2264 n) (h\u2081 : n \u2264 10000) :\n  rthn_between n (n-1) = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rthn_between_edge_cases :\n  (rthn_between 0 0 = []) \u2227\n  (rthn_between (-1) 10 = [10]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [10, 12, 18, 20]\n-/\n#guard_msgs in\n#eval rthn_between 0 20\n\n/-\ninfo: [200, 201, 204, 207, 209, 210]\n-/\n#guard_msgs in\n#eval rthn_between 200 210\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval rthn_between 2200 2300"
      }
    ]
  },
  "fvapps_002892.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.max (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def intToStr (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def strLen (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def splitLines (s: String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringToNat (s: String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def print_nums (nums: List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem print_nums_empty (nums: List Nat) :\n  nums = [] \u2192 print_nums nums = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002895.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def thue_morse (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The length of thue_morse(n) equals n and contains only 0's and 1's -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem thue_morse_length (n : Nat) :\n  (thue_morse n).length = n \u2227\n  \u2200 p : String.Pos,\n    String.contains \"01\" ((thue_morse n).get p) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any longer sequence starts with the shorter sequence -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem thue_morse_prefix_consistency (n : Nat) :\n  (thue_morse (n + 1)).take n = thue_morse n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- If n > 0, the sequence starts with 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem thue_morse_starts_correct (n : Nat) (h : n > 0) :\n  \u2203 p : String.Pos, (thue_morse n).get p = '0' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval thue_morse 1\n\n/-\ninfo: '01'\n-/\n#guard_msgs in\n#eval thue_morse 2\n\n/-\ninfo: '01101'\n-/\n#guard_msgs in\n#eval thue_morse 5\n\n/-\ninfo: '0110100110'\n-/\n#guard_msgs in\n#eval thue_morse 10"
      }
    ]
  },
  "fvapps_002897.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def textin (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstr (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_string (s : String) :\n  textin s = textin s\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_length_leq_input (s : String) :\n  (textin s).length \u2264 s.length\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_target_words (s : String) :\n  \u00accontainsSubstr (String.toLower (textin s)) \"two\" \u2227\n  \u00accontainsSubstr (String.toLower (textin s)) \"too\" \u2227\n  \u00accontainsSubstr (String.toLower (textin s)) \"to\"\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent (s : String) :\n  textin (textin s) = textin s\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002900.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def remove (s : String) : String := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter (\u00b7 = c) |>.length"
      },
      {
        "type": "sig",
        "string": "def trimRight (s : String) (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "  let rec dropRightWhile (xs : List Char) : List Char :=\n    match xs with\n    | [] => []\n    | _::xs' =>\n      match dropRightWhile xs' with\n      | [] => if xs.getLast! = c then [] else xs\n      | ys => xs.head! :: ys\n  String.mk (dropRightWhile s.data)"
      },
      {
        "type": "cond",
        "string": "theorem remove_preserves_length_of_end_exclamations (s : String) :\n  let originalEndExclamations := s.length - (trimRight s '!').length\n  countChar (remove s) '!' = originalEndExclamations :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_no_interior_exclamations (s : String) :\n  let resultWithoutEnd := trimRight (remove s) '!'\n  (resultWithoutEnd.data.filter (\u00b7 = '!')).length = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_preserves_other_chars (s : String) :\n  (s.replace \"!\" \"\").data = ((remove s).replace \"!\" \"\").data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Hi!'\n-/\n#guard_msgs in\n#eval remove \"Hi!\"\n\n/-\ninfo: 'Hi!!!'\n-/\n#guard_msgs in\n#eval remove \"Hi!!!\"\n\n/-\ninfo: 'Hi!'\n-/\n#guard_msgs in\n#eval remove \"!Hi!\""
      }
    ]
  },
  "fvapps_002905.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_bouncy (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits_sorted (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits_sorted_reverse (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_numbers_not_bouncy (n : Nat) (h : n < 100) :\n  \u00ac is_bouncy n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_002909.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palindrome (x : Int) : Bool \u2295 String := sorry\n\ndef isDigitPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s = s.push '0' -- dummy definition to make type checker happy"
      },
      {
        "type": "sig",
        "string": "def reverseInt (n : Int) : Int := 0 -- dummy definition"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_output_type (x : Int) :\n  x > 0 \u2192 Sum.casesOn (palindrome x) (fun _ => True) (fun _ => True) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_correctness (x : Int) :\n  x > 0 \u2192 match palindrome x with\n  | .inl true => isDigitPalindrome (toString x) = true\n  | .inl false => isDigitPalindrome (toString x) = false\n  | .inr _ => False\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_negative_invalid (x : Int) :\n  x \u2264 0 \u2192 palindrome x = .inr \"Not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_palindrome (x : Int) :\n  x > 0 \u2192 x < 10 \u2192 (palindrome x) = .inl true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_concat_property (x : Int) :\n  x > 0 \u2192\n  let xStr := toString x\n  let palindromeNum := x * (10 ^ (String.length xStr)) + reverseInt x\n  palindrome palindromeNum = .inl true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome 1221\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome 123456\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome \"1221\"\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome -450"
      }
    ]
  },
  "fvapps_002913.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (expr : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isBalanced (expr : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def validateResult (result : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_variables_theorem (vars : List Char)\n  (h1 : \u2200 c \u2208 vars, 'a' \u2264 c \u2227 c \u2264 'z')\n  (h2 : vars.length \u2265 1)\n  (h3 : vars.length \u2264 10) :\n  let expr := String.mk vars\n  let result := solve expr\n  validateResult result \u2227\n  (\u2200 v \u2208 vars, result.data.contains v) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nested_parens_theorem (vars : List Char)\n  (h1 : \u2200 c \u2208 vars, c = 'x' \u2228 c = 'y' \u2228 c = 'z')\n  (h2 : vars.length \u2265 1)\n  (h3 : vars.length \u2264 5) :\n  let expr := vars.foldl (fun acc v => acc ++ \"-(\" ++ String.mk [v] ++ \")\") (String.mk [vars.head!])\n  let result := solve expr\n  validateResult result \u2227\n  (\u2200 v \u2208 vars, result.data.contains v) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arbitrary_expressions_theorem (expr : String)\n  (h1 : expr.length \u2265 1)\n  (h2 : expr.length \u2264 20)\n  (h3 : \u2200 c \u2208 expr.data, c = 'x' \u2228 c = 'y' \u2228 c = 'z' \u2228 c = '(' \u2228 c = ')' \u2228 c = '+' \u2228 c = '-')\n  (h4 : isBalanced expr) :\n  let result := solve expr\n  validateResult result \u2227\n  (\u2200 c \u2208 result.data, c.isAlpha \u2192 c \u2208 expr.data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'x-y-z'\n-/\n#guard_msgs in\n#eval solve \"x-(y+z)\"\n\n/-\ninfo: 'x-y+z'\n-/\n#guard_msgs in\n#eval solve \"x-(y-z)\"\n\n/-\ninfo: 'u-v+w+x+y-z'\n-/\n#guard_msgs in\n#eval solve \"u-(v-w-(x+y))-z\""
      }
    ]
  },
  "fvapps_002917.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unique_sum (lst: List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listToSet (lst: List Int) : List Int := sorry\n\ndef listSum (lst: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  lst.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem unique_sum_properties (lst : List Int) :\n  match lst with\n  | [] => unique_sum lst = none\n  | _  => unique_sum lst = some (listSum (listToSet lst))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_sum_nonempty {lst : List Int} (h : lst \u2260 []) :\n  \u2203 n : Int, unique_sum lst = some n \u2227 n = listSum (listToSet lst) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unique_sum_duplicates {lst : List Int} (h : lst \u2260 [])\n  (h2 : \u2200 x \u2208 lst, x \u2260 0) :\n  unique_sum (lst ++ lst) = unique_sum lst :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval unique_sum []\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval unique_sum [1, 2, 3]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval unique_sum [1, 3, 8, 1, 8]"
      }
    ]
  },
  "fvapps_002919.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_narc (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_narcissistic : List String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_digits_correct (n : Nat) :\n  get_digits n = (toString n).toList.map (fun c => c.toString.toNat!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_narc_sum_pow_digits (n : Nat) :\n  is_narc n = (n = ((get_digits n).map (fun d => d ^ (get_digits n).length)).foldl (\u00b7 + \u00b7) 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_narcissistic_all (values : List String) :\n  is_narcissistic values = values.all (fun x =>\n    if let some n := x.toNat? then\n      is_narc n\n    else\n      false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_numeric_returns_false (s : String) :\n  \u00acs.all Char.isDigit \u2192 \u00acis_narcissistic [s] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_narcissistic 11\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic \"4\" 7 \"9\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_narcissistic 407 8208"
      }
    ]
  },
  "fvapps_002922.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_inversions (lst : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "sig",
        "string": "def swap (l : List Int) (i j : Nat) (h1 : i < l.length) (h2 : j < l.length) : List Int :="
      },
      {
        "type": "impl",
        "string": "  let arr := l.toArray\n  let tmp := arr[i]!\n  let arr := arr.set! i arr[j]!\n  let arr := arr.set! j tmp\n  arr.toList"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_zero_inversions :\n  count_inversions [] = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_list_zero_inversions {lst : List Int} :\n  isSorted lst \u2192 count_inversions lst = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reversed_sorted_unique_inversions {lst : List Int} (h1 : List.Nodup lst) (h2 : isSorted lst) :\n  count_inversions (List.reverse lst) = (lst.length * (lst.length - 1)) / 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_swap_one_inversion {lst : List Int} (h1 : isSorted lst) (h2 : lst.length \u2265 2)\n  (h3 : lst[0]! \u2260 lst[1]!)\n  (h4 : 0 < lst.length) (h5 : 1 < lst.length) :\n  count_inversions (swap lst 0 1 h4 h5) = 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_always_non_negative (lst : List Int) :\n  count_inversions lst \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversions #[1, 2, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_inversions #[2, 1, 3]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 2, 1]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval count_inversions #[6, 5, 4, 3, 3, 3, 3, 2, 1]"
      }
    ]
  },
  "fvapps_002925.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 0 then n else -n"
      },
      {
        "type": "sig",
        "string": "def list_minimum (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def array_center (lst : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mean (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_center_is_subset {lst : List Int} (h : lst \u2260 []) :\n  \u2200 x, x \u2208 array_center lst \u2192 x \u2208 lst :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_index_of (lst : List Int) (x : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [4, 5]\n-/\n#guard_msgs in\n#eval array_center [8, 3, 4, 5, 2, 8]\n\n/-\ninfo: [1, 2, 1]\n-/\n#guard_msgs in\n#eval array_center [1, 3, 2, 1]\n\n/-\ninfo: [10, 11, 12, 13, 14]\n-/\n#guard_msgs in\n#eval array_center [10, 11, 12, 13, 14]"
      }
    ]
  },
  "fvapps_002926.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def big_primefac_div (n : Int) : Option (Int \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isInteger (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem big_primefac_div_int_valid {n : Int}\n  (h : 2 \u2264 n) (h2 : n \u2264 10^6) :\n  if isInteger n then\n    match big_primefac_div n with\n    | none => True\n    | some (p, d) => p > 0 \u2227 d > 0\n  else\n    big_primefac_div n = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem big_primefac_div_valid_pos_int {n : Int}\n  (h : 2 \u2264 n) (h2 : n \u2264 10^6) :\n  match big_primefac_div n with\n  | none => \u2200 i, 2 \u2264 i \u2192 i \u2264 sqrt n \u2192 \u00ac(n % i = 0)\n  | some (p, d) =>\n    1 < p \u2227 1 < d \u2227\n    n % p = 0 \u2227 n % d = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem big_primefac_div_neg {n : Int}\n  (h : -10^6 \u2264 n) (h2 : n \u2264 -2) :\n  big_primefac_div n = big_primefac_div (abs n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [5, 50]\n-/\n#guard_msgs in\n#eval big_primefac_div 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval big_primefac_div 997\n\n/-\ninfo: [5, 900]\n-/\n#guard_msgs in\n#eval big_primefac_div -1800.0"
      }
    ]
  },
  "fvapps_002928.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def squares : Nat \u2192 List Nat\n| n => sorry"
      },
      {
        "type": "sig",
        "string": "def num_range : Nat \u2192 Int \u2192 Int \u2192 List Int\n| n, start, step => sorry"
      },
      {
        "type": "sig",
        "string": "def rand_range : Nat \u2192 Int \u2192 Int \u2192 List Int\n| n, mn, mx => sorry"
      },
      {
        "type": "sig",
        "string": "def primes : Nat \u2192 List Nat\n| n => sorry"
      },
      {
        "type": "cond",
        "string": "theorem squares_length (n : Nat) : (squares n).length = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem squares_values (n : Nat) (i : Nat) :\n  i < n \u2192 (squares n).get \u27e8i, sorry\u27e9 = (i + 1) * (i + 1) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_range_length (n : Nat) (start step : Int) :\n  (num_range n start step).length = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_range_start (n : Nat) (start step : Int) :\n  n > 0 \u2192 (num_range n start step).get \u27e80, sorry\u27e9 = start := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem num_range_step (n : Nat) (start step : Int) :\n  n > 1 \u2192 (num_range n start step).get \u27e81, sorry\u27e9 - (num_range n start step).get \u27e80, sorry\u27e9 = step := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rand_range_length (n : Nat) (mn mx : Int) :\n  mn \u2264 mx \u2192 (rand_range n mn mx).length = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rand_range_bounds (n : Nat) (mn mx : Int) (i : Nat) :\n  mn \u2264 mx \u2192 i < n \u2192\n  mn \u2264 (rand_range n mn mx).get \u27e8i, sorry\u27e9 \u2227 (rand_range n mn mx).get \u27e8i, sorry\u27e9 \u2264 mx := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_length (n : Nat) :\n  (primes n).length = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_ordered (n : Nat) (i : Nat) :\n  n > 0 \u2192 i < n - 1 \u2192\n  (primes n).get \u27e8i, sorry\u27e9 < (primes n).get \u27e8i + 1, sorry\u27e9 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [1, 4, 9, 16, 25]\n-/\n#guard_msgs in\n#eval squares 5\n\n/-\ninfo: [1, 4, 9]\n-/\n#guard_msgs in\n#eval squares 3\n\n/-\ninfo: [0, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval num_range 5 0 1\n\n/-\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval num_range 3 2 2\n\n/-\ninfo: [2, 3, 5, 7, 11]\n-/\n#guard_msgs in\n#eval primes 5"
      }
    ]
  },
  "fvapps_002930.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def polydivisible (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def take_prefix (n : Nat) (len : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem polydivisible_characterization {n : Nat} :\n  polydivisible n \u2194\n  (\u2200 i : Nat, i > 0 \u2227 i \u2264 (digits n).length \u2192\n    take_prefix n i % i = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_polydivisible {n : Nat} :\n  n > 0 \u2227 n < 10 \u2192 polydivisible n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem polydivisible_positive {n : Int} :\n  n \u2264 0 \u2192 polydivisible n.toNat = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 1232\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval polydivisible 123220\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval polydivisible 987654"
      }
    ]
  },
  "fvapps_002932.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def aks_test : Nat \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry"
      },
      {
        "type": "sig",
        "string": "def small_primes : List Nat := [2, 3, 5, 7, 11, 13, 17, 19]"
      },
      {
        "type": "cond",
        "string": "theorem known_small_primes_correct (n : Nat) (h : 2 \u2264 n \u2227 n < 20) :\n  aks_test n = true \u2194 n \u2208 small_primes := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numbers_less_than_2_not_prime {n : Nat} (h : n \u2264 1) :\n  aks_test n = false := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_divisibility {n : Nat} (h : n \u2265 2) :\n  aks_test n = true \u2192 \u2200 d : Nat, 2 \u2264 d \u2192 d < n \u2192 \u00ac(n % d = 0) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem composite_has_divisor {n : Nat} (h\u2081 : n \u2265 2) (h\u2082 : aks_test n = false) :\n  \u2203 d : Nat, 2 \u2264 d \u2227 d < n \u2227 n % d = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem product_not_prime {n m : Nat} (h\u2081 : n > 1) (h\u2082 : m > 1) (h\u2083 : n * m \u2264 10000) :\n  aks_test (n * m) = false := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aks_consistency (n : Nat) (h : n \u2265 2) :\n  aks_test n = aks_test n := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval aks_test 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval aks_test 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval aks_test 5"
      }
    ]
  },
  "fvapps_002934.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def canBePalindromeWithOneRemoval (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_result_valid (s : String) :\n  solve s = \"OK\" \u2228 solve s = \"remove one\" \u2228 solve s = \"not possible\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ok_means_palindrome (s : String) :\n  solve s = \"OK\" \u2192 isPalindrome s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_one_means_possible_palindrome (s : String) :\n  solve s = \"remove one\" \u2192 canBePalindromeWithOneRemoval s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem not_possible_means_neither (s : String) :\n  solve s = \"not possible\" \u2192 \u00acisPalindrome s \u2227 \u00accanBePalindromeWithOneRemoval s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_symmetric (s : String) :\n  solve s = solve (reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_ok (s : String) :\n  s.length = 1 \u2192 solve s = \"OK\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_chars_property (s : String) (h : s.length = 2) :\n  (s.front = s.back \u2192 solve s = \"OK\") \u2227\n  (s.front \u2260 s.back \u2192 solve s = \"remove one\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'OK'\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: 'remove one'\n-/\n#guard_msgs in\n#eval solve \"abbaa\"\n\n/-\ninfo: 'not possible'\n-/\n#guard_msgs in\n#eval solve \"abbaab\""
      }
    ]
  },
  "fvapps_002938.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def omit_hashtag (message : String) (hashtag : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s t : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.containsSubstring (s t : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_hashtag_length (message hashtag : String) :\n  String.length (omit_hashtag message hashtag) \u2264 String.length message :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_hashtag_unchanged (message hashtag : String) :\n  \u00ac(String.containsSubstring message hashtag) \u2192 omit_hashtag message hashtag = message :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_hashtag_count (message hashtag : String) (h1 : hashtag \u2260 \"\")\n  (h2 : String.count message hashtag > 1) :\n  String.count (omit_hashtag message hashtag) hashtag = String.count message hashtag - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_empty_hashtag (message : String) :\n  omit_hashtag message \"\" = message :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_from_empty_message (hashtag : String) (h1 : hashtag \u2260 \"\") :\n  omit_hashtag \"\" hashtag = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem omit_hashtag_not_found (message hashtag : String)\n  (h1 : message \u2260 \"\") (h2 : hashtag \u2260 \"\") :\n  \u00ac(String.containsSubstring message hashtag) \u2192 omit_hashtag message hashtag = message :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sunny day!  #vvv'\n-/\n#guard_msgs in\n#eval omit_hashtag \"Sunny day! #lta #vvv\" \"#lta\"\n\n/-\ninfo: ' #picture_contest'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest\" \"#lta\"\n\n/-\ninfo: ' #picture_contest #lta'\n-/\n#guard_msgs in\n#eval omit_hashtag \"#lta #picture_contest #lta\" \"#lta\""
      }
    ]
  },
  "fvapps_002944.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def compute_depth (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_depth_positive (n : Nat) (h : n > 0) :\n  compute_depth n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_digit (n : Nat) (d : Nat) : Prop := sorry\n\ndef has_all_digits (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 d, d < 10 \u2192 has_digit n d"
      },
      {
        "type": "sig",
        "string": "def list_product (nums : List Nat) (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_depth_contains_all_digits (n : Nat) (h : n > 0) :\n  \u2203 nums : List Nat,\n    nums.length = compute_depth n \u2227\n    has_all_digits (list_product nums n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_depth_is_minimal (n : Nat) (h : n > 0) :\n  \u2200 k < compute_depth n,\n    \u00ac\u2203 nums : List Nat,\n      nums.length = k \u2227\n      has_all_digits (list_product nums n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_depth_upper_bound (n : Nat) (h : n > 0) (h2 : n \u2264 100) :\n  compute_depth n \u2264 n * 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem powers_of_ten_depth_positive :\n  \u2200 i : Nat, compute_depth (10^i) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval compute_depth 42\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval compute_depth 13\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval compute_depth 25"
      }
    ]
  },
  "fvapps_002947.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palindrome (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPalindromePair (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def palindromePairs (words : List String) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_pairs_valid_indices\n  (words : List String) (result : List (Nat \u00d7 Nat))\n  (h : result = palindromePairs words) :\n  \u2200 pair, pair \u2208 result \u2192\n    pair.1 < words.length \u2227\n    pair.2 < words.length \u2227\n    pair.1 \u2260 pair.2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_pairs_forms_palindrome\n  (words : List String) (result : List (Nat \u00d7 Nat))\n  (h : result = palindromePairs words) :\n  \u2200 pair, pair \u2208 result \u2192\n    palindrome (words[pair.1]! ++ words[pair.2]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_pairs_complete\n  (words : List String) (result : List (Nat \u00d7 Nat))\n  (h : result = palindromePairs words) :\n  \u2200 i j, i < words.length \u2192 j < words.length \u2192 i \u2260 j \u2192\n    palindrome (words[i]! ++ words[j]!) \u2192\n    (i,j) \u2208 result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_pairs_unique\n  (words : List String) (result : List (Nat \u00d7 Nat))\n  (h : result = palindromePairs words) :\n  \u2200 p1 p2, p1 \u2208 result \u2192 p2 \u2208 result \u2192 p1 = p2 \u2228 p1.1 \u2260 p2.1 \u2228 p1.2 \u2260 p2.2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [[0, 1], [1, 0]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"bat\", \"tab\", \"cat\"]\n\n/-\ninfo: [[0, 3], [2, 4], [3, 0], [4, 2]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [\"dog\", \"cow\", \"tap\", \"god\", \"pat\"]\n\n/-\ninfo: [[0, 4], [1, 2], [2, 1]]\n-/\n#guard_msgs in\n#eval palindrome_pairs [5777, \"dog\", \"god\", True, 75]"
      }
    ]
  },
  "fvapps_002954.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def multiTable (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure MultiTableOutput where\n  lines : List String\n  deriving Inhabited"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def String.count_spaces (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def parseMultiTable (s : String) : MultiTableOutput :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_table_length (n : Nat) (h : n > 0) :\n  (parseMultiTable (multiTable n)).lines.length = 10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_table_format (n : Nat) (h : n > 0) (i : Nat) (h2 : i > 0 \u2227 i \u2264 10) :\n  let output := parseMultiTable (multiTable n)\n  let line := output.lines[i-1]!\n  \u2203 num1 num2 result : String,\n    line = num1 ++ \" * \" ++ num2 ++ \" = \" ++ result \u2227\n    String.toNat! num1 = i \u2227\n    String.toNat! num2 = n \u2227\n    String.toNat! result = i * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_table_no_trailing_newline (n : Nat) (h : n > 0) :\n  let s := multiTable n\n  s.length > 0 \u2227 s.data[s.length - 1]! \u2260 '\\n' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_table_spacing (n : Nat) (h : n > 0) (line : String)\n  (h2 : line \u2208 (parseMultiTable (multiTable n)).lines) :\n  line.count_spaces = 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 * 5 = 5\\n2 * 5 = 10\\n3 * 5 = 15\\n4 * 5 = 20\\n5 * 5 = 25\\n6 * 5 = 30\\n7 * 5 = 35\\n8 * 5 = 40\\n9 * 5 = 45\\n10 * 5 = 50'\n-/\n#guard_msgs in\n#eval multi_table 5\n\n/-\ninfo: '1 * 1 = 1\\n2 * 1 = 2\\n3 * 1 = 3\\n4 * 1 = 4\\n5 * 1 = 5\\n6 * 1 = 6\\n7 * 1 = 7\\n8 * 1 = 8\\n9 * 1 = 9\\n10 * 1 = 10'\n-/\n#guard_msgs in\n#eval multi_table 1\n\n/-\ninfo: '1 * 3 = 3\\n2 * 3 = 6\\n3 * 3 = 9\\n4 * 3 = 12\\n5 * 3 = 15\\n6 * 3 = 18\\n7 * 3 = 21\\n8 * 3 = 24\\n9 * 3 = 27\\n10 * 3 = 30'\n-/\n#guard_msgs in\n#eval multi_table 3"
      }
    ]
  },
  "fvapps_002955.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def scramble_words (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_alpha (c : Char) : Bool := sorry\n\ndef isOrdered (s : List Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < s.length \u2192 s[i]! \u2264 s[j]!"
      },
      {
        "type": "cond",
        "string": "theorem scramble_length_preserved (s : String) :\n  String.length (scramble_words s) = String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_last_letters_preserved (s : String) (word : String) (h : word.length > 1)\n    (pos_start : String.Pos) (pos_end : String.Pos) :\n  is_alpha (word.get pos_start) \u2192\n  is_alpha (word.get pos_end) \u2192\n  (scramble_words word).get pos_start = word.get pos_start \u2227\n  (scramble_words word).get pos_end = word.get pos_end :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem middle_chars_sorted (s : String) (h : s.length > 2)\n    (pos_start : String.Pos) (pos_end : String.Pos) :\n  is_alpha (s.get pos_start) \u2192\n  is_alpha (s.get pos_end) \u2192\n  let middle := (scramble_words s).data.drop 1 |>.take (s.length - 2)\n  isOrdered middle :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_alpha_chars_preserved (s : String) :\n  s.data.filter (fun c => \u00ac(is_alpha c)) =\n  (scramble_words s).data.filter (fun c => \u00ac(is_alpha c)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'paefilnoorsss'\n-/\n#guard_msgs in\n#eval scramble_words \"professionals\"\n\n/-\ninfo: 'caac-dinrrryg'\n-/\n#guard_msgs in\n#eval scramble_words \"card-carrying\"\n\n/-\ninfo: \"you've gotta dacne\"\n-/\n#guard_msgs in\n#eval scramble_words \"you\"ve gotta dance\""
      }
    ]
  },
  "fvapps_002963.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def vowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def solve (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_all_vowels (s : String)\n  (h\u2081 : s.length > 0)\n  (h\u2082 : \u2200 c \u2208 s.data, vowel c = true) :\n  solve s = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_interspersed\n  (vowels : List String)\n  (consonants : List String)\n  (h\u2081 : vowels.length > 0)\n  (h\u2082 : \u2200 s \u2208 vowels, s.length > 0)\n  (h\u2083 : \u2200 s \u2208 vowels, \u2200 c \u2208 s.data, vowel c = true)\n  (h\u2084 : \u2200 s \u2208 consonants, \u2200 c \u2208 s.data, vowel c = false) :\n  let combined := List.zip vowels consonants\n  let s := String.join (combined.map (fun p => p.1 ++ p.2))\n  solve s \u2265 (List.foldl (fun acc x => max acc x.length) 0 vowels) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_002964.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_lucky (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_of_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def concat_digits (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_digit_sum_property (n : Nat) :\n  is_lucky n = (sum_of_digits n = 0 \u2228 sum_of_digits n % 9 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_concatenation (n : Nat) :\n  is_lucky n \u2192 (\n    is_lucky (concat_digits n 9) \u2227\n    is_lucky (concat_digits n 99)\n  ) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lucky_edge_cases :\n  is_lucky 0 \u2227 is_lucky 9 \u2227 is_lucky 99 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 1892376\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_lucky 189237\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_lucky 0"
      }
    ]
  },
  "fvapps_002966.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Room := (String \u00d7 Nat)"
      },
      {
        "type": "sig",
        "string": "def meeting (rooms : List Room) (need : Nat) : String \u2295 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + listSum xs"
      },
      {
        "type": "sig",
        "string": "def listAll : List Nat \u2192 (Nat \u2192 Bool) \u2192 Bool\n  | [], _ => true\n  | x::xs, p => p x && listAll xs p"
      },
      {
        "type": "cond",
        "string": "theorem meeting_zero_need {rooms : List Room} :\n  meeting rooms 0 = Sum.inl \"Game On\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem meeting_huge_need {rooms : List Room} {need : Nat} :\n  (need > listSum (rooms.map (fun r => max (r.2 - r.1.length) 0))) \u2192\n  meeting rooms need = Sum.inl \"Not enough!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem meeting_valid_solution {rooms : List Room} {need : Nat} {result : List Nat} :\n  meeting rooms need = Sum.inr result \u2192\n  (\n    (result.length \u2264 rooms.length) \u2227\n    (listAll result (fun x => x \u2265 0)) \u2227\n    (listSum result = need) \u2227\n    (rooms.zip result).all (fun p =>\n      let room := p.1\n      let taken := p.2\n      taken \u2264 max (room.2 - room.1.length) 0\n    )\n  ) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1, 3]\n-/\n#guard_msgs in\n#eval meeting [[\"XXX\", 3], [\"XXXXX\", 6], [\"XXXXXX\", 9]] 4\n\n/-\ninfo: 'Game On'\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 0\n\n/-\ninfo: [0, 2]\n-/\n#guard_msgs in\n#eval meeting [[\"XX\", 2], [\"XXXX\", 6], [\"XXXXX\", 4]] 2"
      }
    ]
  },
  "fvapps_002967.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (arr : List Int) : Int := sorry\n\ndef getUnique (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  arr.foldl (fun acc x => if acc.contains x then acc else x::acc) []"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x :: xs => x + sumList xs"
      },
      {
        "type": "sig",
        "string": "def filterPositive (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  l.filter (fun x => x > 0)"
      },
      {
        "type": "sig",
        "string": "def filterNegative (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  l.filter (fun x => x < 0)"
      },
      {
        "type": "cond",
        "string": "theorem solve_invariant_under_duplication : \u2200 (arr : List Int),\n  arr \u2260 [] \u2192 solve (arr ++ arr) = solve arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_positive_result_implies_positive_element : \u2200 (arr : List Int),\n  arr \u2260 [] \u2192 solve arr > 0 \u2192 \u2203 x \u2208 arr, x > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_negative_result_implies_negative_element : \u2200 (arr : List Int),\n  arr \u2260 [] \u2192 solve arr < 0 \u2192 \u2203 x \u2208 arr, x < 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [1, -1, 2, -2, 3]\n\n/-\ninfo: -4\n-/\n#guard_msgs in\n#eval solve [-3, 1, 2, 3, -1, -4, -2]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [1, -1, 2, -2, 3, 3]"
      }
    ]
  },
  "fvapps_002970.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_exponent (n p : Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pow (x y : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_exponent_divides {n p : Int} (h1 : n \u2265 2) (h2 : p \u2265 2) :\n  match get_exponent n p with\n  | none => False\n  | some k =>\n    (k = 0 \u2192 n % p \u2260 0) \u2227\n    (k > 0 \u2192 n % (pow p k) = 0 \u2227 n % (pow p (k + 1)) \u2260 0)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_exponent_nonnegative {n p : Int} (h1 : n \u2265 2) (h2 : p \u2265 2) :\n  match get_exponent n p with\n  | none => False\n  | some k => k \u2265 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_exponent_invalid_divisor {n p : Int} (h : p \u2264 1) :\n  get_exponent n p = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_exponent_prime_power {n p : Int} (h1 : n \u2265 2) (h2 : p = 2) :\n  get_exponent (n * (pow p 5)) p = Option.some ((get_exponent n p).getD 0 + 5) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_exponent 27 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_exponent 28 2\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval get_exponent 10 0"
      }
    ]
  },
  "fvapps_002972.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palindrome_rearranging (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.repeating (c : Char) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def odd_char_count (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_rearranging_symmetry (s : String) :\n  palindrome_rearranging s = palindrome_rearranging (String.reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_rearranging_duplicates (s : String) (h : s.length > 0) :\n  palindrome_rearranging (s ++ s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_rearranging_single_char (s : String) (h : s.length > 0) (c : Char) :\n  palindrome_rearranging (String.repeating c s.length) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_rearranging_empty_and_single (s : String) (h : s.length \u2264 1) :\n  palindrome_rearranging s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Count of chars with odd occurrences -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem palindrome_rearranging_odd_counts (s : String) :\n  palindrome_rearranging s = (odd_char_count s \u2264 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aabb\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"abbcabb\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome_rearranging \"aaabbb\""
      }
    ]
  },
  "fvapps_002975.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def divisible_by_three (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def digit_sum (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem divisible_by_three_matches_mod (n : Nat) :\n  divisible_by_three (toString n) = (n % 3 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem divisible_by_three_digit_sum (n : Nat) :\n  divisible_by_three (toString n) = (digit_sum (toString n) % 3 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem append_zeros_preserves_divisibility (n : Nat) (k : Nat) (h : 0 < k \u2227 k \u2264 10) :\n  divisible_by_three (toString n ++ String.mk (List.replicate k '0')) =\n  divisible_by_three (toString n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"123\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval divisible_by_three \"88\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval divisible_by_three \"963210456\""
      }
    ]
  },
  "fvapps_002977.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def uniqueDigitProducts (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.toSet (l : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniqueDigitProducts_bounds_nat {nums : List Nat} (h : nums.length > 0) :\n  1 \u2264 uniqueDigitProducts nums \u2227 uniqueDigitProducts nums \u2264 nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniqueDigitProducts_single_digits {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : \u2200 n \u2208 nums, n \u2264 9) :\n  uniqueDigitProducts nums \u2264 (List.toSet nums).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniqueDigitProducts_all_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : \u2200 n \u2208 nums, n = 0) :\n  uniqueDigitProducts nums = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniqueDigitProducts_three_digit_no_zeros {nums : List Nat}\n  (h1 : nums.length > 0)\n  (h2 : \u2200 n \u2208 nums, 100 \u2264 n \u2227 n \u2264 999)\n  (h3 : \u2200 n \u2208 nums, \u00ac toString n = \"0\") :\n  uniqueDigitProducts nums > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniqueDigitProducts_permutation {nums : List Nat}\n  (h : nums.length > 1) :\n  let n := nums[0]\n  let nums_with_perm := n :: nums\n  uniqueDigitProducts nums_with_perm \u2265 uniqueDigitProducts nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval unique_digit_products [2, 8, 121, 42, 222, 23]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval unique_digit_products [239]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval unique_digit_products [100, 101, 111]"
      }
    ]
  },
  "fvapps_002983.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def roundIt (x : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def floor (x : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ceil (x : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def floatToStr (x : Float) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem round_it_decimals (x : Float)\n  (h\u2081 : Float.floor x \u2260 x)\n  (h\u2082 : String.length (floatToStr (Float.floor (Float.abs x))) <\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = ceil x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem round_it_decimals_floor (x : Float)\n  (h\u2081 : Float.floor x \u2260 x)\n  (h\u2082 : String.length (floatToStr (Float.floor (Float.abs x))) >\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = floor x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem round_it_decimals_equal_length (x : Float)\n  (h\u2081 : Float.floor x \u2260 x)\n  (h\u2082 : String.length (floatToStr (Float.floor (Float.abs x))) =\n        String.length (floatToStr (Float.abs x - Float.floor (Float.abs x)))) :\n  roundIt x = if x > 0 then ceil x else floor x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem round_it_integers (n : Int) :\n  roundIt (Float.ofInt n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval round_it 3.45\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval round_it 34.5\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval round_it 34.56"
      }
    ]
  },
  "fvapps_002988.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def seven_ate9 (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countSubstr (s : String) (sub : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstr (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def iterativeReplace (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => s\n  | n + 1 =>\n    if containsSubstr s \"797\"\n    then iterativeReplace (s.replace \"797\" \"77\") n\n    else s"
      },
      {
        "type": "cond",
        "string": "theorem output_is_string {s : String} :\n  s.all (fun c => c.isDigit) \u2192\n  (seven_ate9 s).all (fun c => c.isDigit) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_length_correct {s : String} :\n  s.all (fun c => c.isDigit) \u2192\n  (seven_ate9 s).length = s.length - (countSubstr s \"797\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_797_in_result {s : String} :\n  s.all (fun c => c.isDigit) \u2192\n  \u00ac(containsSubstr (seven_ate9 s) \"797\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_797_modified {s : String} :\n  s.all (fun c => c.isDigit) \u2192\n  seven_ate9 s = iterativeReplace s s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '7712312'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79712312\"\n\n/-\ninfo: '777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"79797\"\n\n/-\ninfo: '7777'\n-/\n#guard_msgs in\n#eval seven_ate9 \"7979797\""
      }
    ]
  },
  "fvapps_003000.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Nat.toString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_even (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort {\u03b1 : Type} [Ord \u03b1] (as : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def even_digit_squares (start : Nat) (stop : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_even_matches_digit_check (x : Nat) :\n  is_even x = (Nat.toString x |>.data |>.all (fun d => (Char.toNat d - 48) % 2 = 0)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem even_digit_squares_properties {a b : Nat}\n  (h : a \u2264 1000000 \u2227 b \u2264 1000000) :\n  let start := min a b\n  let stop := max a b\n  let result := even_digit_squares start stop\n  (\u2200 x \u2208 result, x \u2265 start \u2227 x \u2264 stop) \u2227\n  (\u2200 x \u2208 result, is_even x = true) \u2227\n  (\u2200 x \u2208 result, \u2203 y:Nat, y * y = x) \u2227\n  (result = List.sort result) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_point_range {x : Nat} (h : x \u2264 1000000) :\n  let result := even_digit_squares x x\n  result \u2260 [] \u2192\n  (result.length = 1 \u2227\n   result.head! = x \u2227\n   is_even x = true \u2227\n   \u2203 y:Nat, y * y = x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003002.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Char.ascii? (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Char.alpha? (c : Char) : Bool := sorry\n\ndef String.containsAsciiLetter (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.data.any (fun c => c.ascii? && c.alpha?)"
      },
      {
        "type": "sig",
        "string": "def one_down (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_down_maintains_string_type {s : String} :\n  let res := one_down s\n  \u2203 s', res = s' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_down_differs_if_contains_ascii_letter {s : String} :\n  s.containsAsciiLetter \u2192\n  one_down s \u2260 s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_down_preserves_length {s : String} :\n  (one_down s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_down_preserves_non_letters {s : String} {i : Fin s.length} :\n  \u00ac(s.data[i.val]?.map (\u00b7.alpha?) |>.getD false) \u2192\n  (one_down s).data[i.val]? = s.data[i.val]? :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem one_down_non_string_input {\u03b1 : Type} [ToString \u03b1] (x : \u03b1) :\n  one_down (toString x) = \"Input is not a string\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval one_down \"Ifmmp\"\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval one_down 45\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval one_down \"BMM DBQT NBZCF\""
      }
    ]
  },
  "fvapps_003004.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def multi (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def add (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_neutral (l : List Int) (h : l.length \u2265 1) :\n  multi (l ++ [1]) = multi l :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multi_order_indep (l : List Int) (h : l.length \u2265 1) :\n  multi l = multi l.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_neutral (l : List Int) :\n  add (l ++ [0]) = add l :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_order_indep (l : List Int) :\n  add l = add l.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_recursive (l : List Int) (h : l \u2260 []) :\n  add l = add (l.take (l.length - 1)) + l.getLast h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_involution (s : String) :\n  reverse (reverse s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_first_last_char (s : String) (h\u2081 : s.length > 0) :\n  let n := s.length\n  let rs := reverse s\n  rs.front = s.back \u2227 rs.back = s.front :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 80\n-/\n#guard_msgs in\n#eval multi [8, 2, 5]\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval add [1, 2, 3]\n\n/-\ninfo: 'olleh'\n-/\n#guard_msgs in\n#eval reverse \"hello\""
      }
    ]
  },
  "fvapps_003009.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def circle_slash (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/-\n  Main property theorems\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem circle_slash_range (n : Nat) (h : n > 0) :\n  1 \u2264 circle_slash n \u2227 circle_slash n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circle_slash_odd_unless_power_of_two (n : Nat) (h : n > 0)\n  (h_not_power_2 : \u00ac\u2203k, n = 2^k) :\n  circle_slash n % 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circle_slash_power_of_two (k : Nat) :\n  circle_slash (2^k) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  Pattern theorems\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem circle_slash_binary_pattern (n : Nat) (h : n > 1) :\n  -- For n > 1, removing leading '1' from binary representation and appending '1'\n  circle_slash n = (n % (2^(Nat.log2 n))) * 2 + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circle_slash_one :\n  circle_slash 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval circle_slash 5\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval circle_slash 11\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval circle_slash 16"
      }
    ]
  },
  "fvapps_003019.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palindrome (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isNumericPalindrome (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def contains (haystack : String) (needle : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToInt (s : String) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_input_negative (n : Int) :\n  n < 0 \u2192 palindrome n = \"Not valid\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_input_contains_palindromes (n : Int) :\n  n \u2265 0 \u2192 palindrome n \u2260 \"Not valid\" \u2192\n  let result := palindrome n\n  let numStr := toString n\n  \u2200 p \u2208 result.split (\u00b7 = ','),\n    (\u2203 s : String, s = p \u2227 contains numStr s \u2227\n      match stringToInt s with\n      | some i => isNumericPalindrome i\n      | none => false)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_input_sorted_results (n : Int) :\n  n \u2265 0 \u2192 palindrome n \u2260 \"Not valid\" \u2192\n  let result := palindrome n\n  let nums := result.split (\u00b7 = ',')\n  \u2200 i j, i < j \u2192 j < nums.length \u2192\n    match stringToInt (nums.get! i), stringToInt (nums.get! j) with\n    | some x, some y => x \u2264 y\n    | _, _ => true\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_palindromes_when_none_exist (n : Int) (numStr : String := toString n) :\n  n \u2265 0 \u2192\n  (\u2200 s : String, contains numStr s \u2192\n    match stringToInt s with\n    | some i => \u00acisNumericPalindrome i\n    | none => true) \u2192\n  palindrome n = \"No palindromes found\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_input_float (f : Float) :\n  palindrome 0 = \"Not valid\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [22, 212, 343, 22122]\n-/\n#guard_msgs in\n#eval palindrome 34322122\n\n/-\ninfo: 'No palindromes found'\n-/\n#guard_msgs in\n#eval palindrome 1294\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome -123"
      }
    ]
  },
  "fvapps_003021.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_and_max (l d x : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_of_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_and_max_properties {l d x : Nat}\n  (h1: l \u2264 d)\n  (h2: l > 0)\n  (h3: d \u2264 1000)\n  (h4: x \u2264 27)\n  (h5: \u2203 n, l \u2264 n \u2227 n \u2264 d \u2227 sum_of_digits n = x) :\n  let result := min_and_max l d x\n  List.length result = 2 \u2227\n  result[0]! \u2264 result[1]! \u2227\n  l \u2264 result[0]! \u2227 result[0]! \u2264 d \u2227\n  l \u2264 result[1]! \u2227 result[1]! \u2264 d \u2227\n  sum_of_digits result[0]! = x \u2227\n  sum_of_digits result[1]! = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_and_max_identical_bounds {n : Nat}\n  (h1: n > 0)\n  (h2: n \u2264 1000) :\n  let x := sum_of_digits n\n  let result := min_and_max n n x\n  result[0]! = n \u2227 result[1]! = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [109, 190]\n-/\n#guard_msgs in\n#eval min_and_max 100 200 10\n\n/-\ninfo: [505, 505]\n-/\n#guard_msgs in\n#eval min_and_max 500 505 10\n\n/-\ninfo: [104, 500]\n-/\n#guard_msgs in\n#eval min_and_max 99 501 5"
      }
    ]
  },
  "fvapps_003022.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def trotter (n: Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Define the special case"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isInsomnia (n: Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trotter_positive_multiple {n : Int} (h : n > 0) :\n  \u2203 k : Int, trotter n = n * k \u2227 k > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trotter_zero :\n  isInsomnia (trotter 0) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trotter_nonzero {n : Int} (h : n > 0) :\n  trotter n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem trotter_grows {n : Int} (h : n > 0) :\n  trotter n \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5076\n-/\n#guard_msgs in\n#eval trotter 1692\n\n/-\ninfo: 90\n-/\n#guard_msgs in\n#eval trotter 2\n\n/-\ninfo: 'INSOMNIA'\n-/\n#guard_msgs in\n#eval trotter 0"
      }
    ]
  },
  "fvapps_003024.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digits_of (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digit_sequence_of_powers (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def last_digit_to_appear (n : Nat) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem stating result is a single digit if not None"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem result_is_single_digit {n d : Nat} (h : n \u2265 2)\n  (res : last_digit_to_appear n = some d) :\n  0 \u2264 d \u2227 d \u2264 9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem stating if result exists, it must appear last in sequence"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem appears_last {n d : Nat} (h : n \u2265 2)\n  (res : last_digit_to_appear n = some d)\n  (digits : List Nat)\n  (nonempty : digits \u2260 [])\n  (valid_digits : \u2200 x, x \u2208 digits \u2192 x \u2264 9)\n  (is_sequence : digits = digit_sequence_of_powers n)\n  (h_len : digits.length > 0) :\n  d = digits[digits.length - 1]'(Nat.sub_lt h_len (by exact Nat.zero_lt_one)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem for None case - either powers stabilize or never complete"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem none_result_characterization {n : Nat} (h : n \u2265 2)\n  (res : last_digit_to_appear n = none) :\n  (\u2200 k : Nat, k > 1 \u2192 digits_of (n^k) = digits_of n) \u2228\n  (\u2203 x : Nat, x \u2264 9 \u2227 \u2200 k : Nat, k \u2264 100 \u2192 x \u2209 digits_of (n^k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 2\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval last_digit_to_appear 8\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval last_digit_to_appear 100"
      }
    ]
  },
  "fvapps_003026.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def total_bill (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_bill_nonnegative (s : String) :\n  total_bill s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_bill_even (s : String) :\n  total_bill s % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_bill_spaces (s : String) :\n  total_bill s = total_bill (s.replace \" \" \"\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem total_bill_repeated (n : Nat) (s : String) :\n  s = String.mk (List.replicate n 'r') \u2192\n  total_bill s = 2 * (n - n/5) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval total_bill \"rr\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval total_bill \"rr rrr\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval total_bill \"rrrrr rrrrr\""
      }
    ]
  },
  "fvapps_003027.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix (\u03b1 : Type) [BEq \u03b1] := List (List \u03b1)"
      },
      {
        "type": "sig",
        "string": "def is_valid_matrix {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rotate_against_clockwise {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) (times : Nat) : Matrix \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_matrix_dimensions {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dimensions_preserved {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) :\n  is_valid_matrix m \u2192\n  let dims := get_matrix_dimensions m\n  get_matrix_dimensions (rotate_against_clockwise m 1) = dims :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rotation_modulo {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) (times : Nat) :\n  is_valid_matrix m \u2192\n  rotate_against_clockwise m times = rotate_against_clockwise m (times % 4) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem four_rotations_identity {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) :\n  is_valid_matrix m \u2192\n  rotate_against_clockwise m 4 = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_column_dimensions {\u03b1 : Type} [BEq \u03b1] (m : Matrix \u03b1) :\n  is_valid_matrix m \u2192\n  (\u2200 (row : List \u03b1), List.elem row m \u2192 List.length row = 1) \u2192\n  let rotated := rotate_against_clockwise m 1\n  List.length rotated = List.length (List.head! m) \u2227\n  \u2200 (row : List \u03b1), List.elem row rotated \u2192 List.length row = List.length m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2], [3, 4]] 1\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval rotate_against_clockwise [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] 1\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval rotate_against_clockwise matrix2 2"
      }
    ]
  },
  "fvapps_003029.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumNested : List (List Int) \u2192 Int\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def flatten : List (List Int) \u2192 List Int\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def listSum : List Int \u2192 Int\n  | [] => 0\n  | h :: t => h + listSum t\n/- Sum of nested lists equals the sum of flattened list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_nested_equals_flatten_sum (l : List (List Int)) :\n  sumNested l = listSum (flatten l) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Sum of empty nested lists is zero -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_nested_empty_lists (l : List (List Int)) (h : \u2200 x \u2208 l, x = []) :\n  sumNested l = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Sum of singleton list equals its element -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sum_nested_singleton (n : Int) :\n  sumNested [[n]] = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 10\n-/\n#guard_msgs in\n#eval sum_nested [1, [2, [3, [4]]]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_nested [[[], []]]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval sum_nested [1, [1], [1, [1]], [1, [1], [1, [1]]]]"
      }
    ]
  },
  "fvapps_003034.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def stairs (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def step (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitLines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rightJustify (s : String) (width : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listToString (l : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringContains (s : String) (c : Char) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Properties for stairs function"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem stairs_empty_for_invalid_input (n : Int) :\n  n < 1 \u2192 stairs n = \" \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stairs_line_count (n : Int) :\n  n \u2265 1 \u2192 (splitLines (stairs n)).length = n.toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stairs_line_width (n : Int) (line : String) :\n  n \u2265 1 \u2192 line \u2208 splitLines (stairs n) \u2192 line.length \u2264 (4 * n - 1).toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem stairs_right_justified (n : Int) (line : String) :\n  n \u2265 1 \u2192 line \u2208 splitLines (stairs n) \u2192\n  line = rightJustify line (4 * n - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Properties for step function"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem step_length_correct (n : Int) :\n  n \u2265 1 \u2192 (splitLines (step n)).length = (2 * n - 1).toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem step_digits_only (n : Int) (c : Char) :\n  n \u2265 1 \u2192 stringContains (step n) c \u2192 isDigit c \u2228 c = ' ' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem step_sequence (n : Int) (i : Nat) :\n  n \u2265 1 \u2192 i < n.toNat \u2192\n  let nums := splitLines (step n);\n  let expected := toString ((i + 1) % 10);\n  nums.get? i = some expected :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003035.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def berserk_rater (synopsis : List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def score (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.hasSubstring (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem berserk_rater_output_format (synopsis : List String) :\n  let result := berserk_rater synopsis\n  (result = \"worstest episode ever\" \u2228 result = \"bestest episode ever\" \u2228 String.all result Char.isDigit) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem berserk_rater_score_boundaries (synopsis : List String) :\n  let result := berserk_rater synopsis\n  let score_sum := List.foldl (\u00b7 + \u00b7) 0 (List.map (fun s => score s.toUpper) synopsis)\n  (result = \"worstest episode ever\" \u2192 score_sum < 0) \u2227\n  (result = \"bestest episode ever\" \u2192 score_sum > 10) \u2227\n  (result \u2260 \"worstest episode ever\" \u2227 result \u2260 \"bestest episode ever\" \u2192\n    0 \u2264 result.toNat! \u2227 result.toNat! \u2264 10) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem score_function_output (s : String) :\n  let result := score s.toUpper\n  (result = 5 \u2228 result = -2 \u2228 result = -1) \u2227\n  (s.toUpper.hasSubstring \"CLANG\" \u2192 result = 5) \u2227\n  (s.toUpper.hasSubstring \"CG\" \u2192 (\u00acs.toUpper.hasSubstring \"CLANG\" \u2192 result = -2)) \u2227\n  (\u00acs.toUpper.hasSubstring \"CLANG\" \u2227 \u00acs.toUpper.hasSubstring \"CG\" \u2192 result = -1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem score_precedence_clang_over_cg :\n  score \"CLANGCG\" = 5 \u2227 score \"CGCLANG\" = 5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'worstest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"is this the CG from a P2 game?\", \"Hell, no! Even the CG in the Dreamcast game was more fluid than this!\", \"Well, at least Gatsu does his clang even against a mere rabbit\", \"Hey, Cosette was not in this part of the story!\", \"Ops, everybody dead again! Well, how boring...\"]\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Farnese unable to shut the fuck up\", \"awful CG dogs assaulting everybody\", \"Gatsu clanging the pig apostle!\"]\n\n/-\ninfo: 'bestest episode ever'\n-/\n#guard_msgs in\n#eval berserk_rater [\"Holy chain knights being dicks\", \"Serpico almost getting clanged by Gatsu, but without losing his composure\", \"lame CG\", \"Luka getting kicked\", \"Gatsu going clang against the angels\", \"Gatsu clanging vs Mozgus, big time!\"]"
      }
    ]
  },
  "fvapps_003051.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_strings (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_alpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def to_lower (c : Char) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure SegmentInfo where\n  letter : Char\n  stars : String"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def parse_segment (s : String) : Option SegmentInfo :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_strings_format_valid (s : String) (h : s \u2260 \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\"\n  \u2200 part \u2208 segments,\n  part \u2260 \"\" \u2192\n  match parse_segment part with\n  | some info =>\n    is_alpha info.letter \u2227\n    \u2200 c \u2208 info.stars.data, c = '*'\n  | none => False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_strings_count_matches_freq (s : String) (h : s \u2260 \"\") :\n  let result := get_strings s\n  let segments := result.splitOn \",\" |>.filter (\u00b7\u2260 \"\")\n  \u2200 seg \u2208 segments,\n  match parse_segment seg with\n  | some info =>\n    let count := s.data.filter (fun c => to_lower c = to_lower info.letter) |>.length\n    info.stars.length = count\n  | none => False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_strings_empty :\n  get_strings \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_strings_example :\n  get_strings \"Chicago\" = \"c:**,h:*,i:*,a:*,g:*,o:*\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'c:**,h:*,i:*,a:*,g:*,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Chicago\"\n\n/-\ninfo: 'b:*,a:*,n:*,g:*,k:**,o:*'\n-/\n#guard_msgs in\n#eval get_strings \"Bangkok\"\n\n/-\ninfo: 'l:*,a:**,s:**,v:*,e:*,g:*'\n-/\n#guard_msgs in\n#eval get_strings \"Las Vegas\""
      }
    ]
  },
  "fvapps_003054.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfABeach (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def substringExists (s : String) (substr : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: If a string has no beach words, sum is 0"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem no_beach_words (s : String) :\n  (\u00ac substringExists s \"sand\" \u2227 \u00ac substringExists s \"SAND\") \u2192\n  (\u00ac substringExists s \"water\" \u2227 \u00ac substringExists s \"WATER\") \u2192\n  (\u00ac substringExists s \"fish\" \u2227 \u00ac substringExists s \"FISH\") \u2192\n  (\u00ac substringExists s \"sun\" \u2227 \u00ac substringExists s \"SUN\") \u2192\n  sumOfABeach s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Theorem: Output is always non-negative and bounded by string length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_range (s : String) :\n  sumOfABeach s \u2265 0 \u2227 sumOfABeach s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"WAtErSlIde\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"GolDeNSanDyWateRyBeaChSuNN\"\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sum_of_a_beach \"gOfIshsunesunFiSh\""
      }
    ]
  },
  "fvapps_003056.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reducePyramid (base : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def referencePyramidReduce (base : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_reference_implementation {base : List Int}\n  (h : base.length > 0 \u2227 base.length \u2264 10) :\n  reducePyramid base = referencePyramidReduce base :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element {base : List Int}\n  (h : base.length = 1) :\n  reducePyramid base = base.get \u27e80, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_elements {base : List Int}\n  (h : base.length = 2) :\n  reducePyramid base = base.get \u27e80, sorry\u27e9 + base.get \u27e81, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem singleton_list (x : Int) :\n  reducePyramid [x] = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval reduce_pyramid [1]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 5]\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval reduce_pyramid [3, 9, 4]"
      }
    ]
  },
  "fvapps_003059.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def SJF (jobs : List Nat) (index : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "constr",
        "string": "abbrev sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def filterWithIndex (l : List Nat) (p : Nat \u2192 Nat \u2192 Bool) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  let rec helper : List Nat \u2192 Nat \u2192 List Nat\n    | [], _ => []\n    | (x :: xs), i => if p i x then x :: helper xs (i+1) else helper xs (i+1)\n  helper l 0"
      },
      {
        "type": "cond",
        "string": "theorem single_job_returns_itself {jobs : List Nat} {job : Nat} (h : jobs = [job]) :\n  SJF jobs 0 = job :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval SJF [100] 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval SJF [3, 10, 20, 1, 2] 0\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval SJF [3, 10, 10, 20, 1, 2] 1"
      }
    ]
  },
  "fvapps_003060.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findPrimesSextuplet (limit : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_sextuplet_length (limit : Nat) (h : limit \u2265 1000) :\n  (findPrimesSextuplet limit).length = 6 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_sextuplet_monotone (limit : Nat) (h : limit \u2265 1000) :\n  let result := findPrimesSextuplet limit\n  \u2200 i j, i < j \u2192 i < result.length \u2192 j < result.length \u2192\n  result[i]! < result[j]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_sextuplet_all_prime (limit : Nat) (h : limit \u2265 1000) :\n  \u2200 x \u2208 findPrimesSextuplet limit, isPrime x = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem primes_sextuplet_diffs (limit : Nat) (h : limit \u2265 1000) :\n  let result := findPrimesSextuplet limit\n  let diffs := List.map (fun p => p.2 - p.1) (List.zip result result.tail)\n  diffs = [4,2,4,2,4] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [7, 11, 13, 17, 19, 23]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 70\n\n/-\ninfo: [97, 101, 103, 107, 109, 113]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 600\n\n/-\ninfo: [1091257, 1091261, 1091263, 1091267, 1091269, 1091273]\n-/\n#guard_msgs in\n#eval find_primes_sextuplet 2000000"
      }
    ]
  },
  "fvapps_003064.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def generate_sierpinski_sequence (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_closest_value (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_is_strictly_increasing {n : Nat} (h : 0 < n) (h2 : n \u2264 10000) :\n  let seq := generate_sierpinski_sequence n\n  \u2200 i, i + 1 < seq.length \u2192 seq.get! i < seq.get! (i + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_first_values {n : Nat} (h : 0 < n) (h2 : n \u2264 10000) :\n  let seq := generate_sierpinski_sequence n\n  seq.length \u2265 4 \u2192 seq.take 4 = [4, 13, 69, 130] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem closest_value_properties {m : Nat} (h : 0 < m) (h2 : m \u2264 10000) :\n  let closest := find_closest_value m\n  let seq := generate_sierpinski_sequence (m * 2)\n  (closest \u2208 seq) \u2227\n  (\u2200 x \u2208 seq, abs (closest - m) \u2264 abs (x - m)) \u2227\n  (\u2200 x \u2208 seq, abs (x - m) = abs (closest - m) \u2192 x > m \u2192 closest \u2265 x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_closest_value 1\n\n/-\ninfo: 5074\n-/\n#guard_msgs in\n#eval find_closest_value 5000\n\n/-\ninfo: 14313\n-/\n#guard_msgs in\n#eval find_closest_value 14313\n\n/-\ninfo: 18720\n-/\n#guard_msgs in\n#eval find_closest_value 18332"
      }
    ]
  },
  "fvapps_003074.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def select_subarray (arr : List Int) : Nat \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def get_ratio (arr : List Int) (idx : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem select_subarray_index_bounds {arr : List Int}\n  (h_size : arr.length \u2265 2)\n  (h_nonzero : \u2200 x \u2208 arr, x \u2260 0) :\n  (select_subarray arr).1 < arr.length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem select_subarray_matches_input {arr : List Int}\n  (h_size : arr.length \u2265 2)\n  (h_nonzero : \u2200 x \u2208 arr, x \u2260 0) :\n  (select_subarray arr).2 = arr[(select_subarray arr).1]! := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem select_subarray_minimum_ratio {arr : List Int}\n  (h_size : arr.length \u2265 2)\n  (h_nonzero : \u2200 x \u2208 arr, x \u2260 0) :\n  \u2200 i < arr.length,\n    get_ratio arr (select_subarray arr).1 \u2264 get_ratio arr i := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, -8]\n-/\n#guard_msgs in\n#eval select_subarray [1, 23, 2, -8, 5]\n\n/-\ninfo: [2, 23]\n-/\n#guard_msgs in\n#eval select_subarray [1, 3, 23, 4, 2, -8, 5, 18]\n\n/-\ninfo: [[3, 100], [4, 200]]\n-/\n#guard_msgs in\n#eval select_subarray [10, 20, -30, 100, 200]"
      }
    ]
  },
  "fvapps_003075.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def my_crib (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def splitLines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem crib_width_consistency {n : Nat} (h : 1 \u2264 n \u2227 n \u2264 10) :\n  let width := 4 + 3 + 6 * (n - 1)\n  let lines := splitLines (my_crib n)\n  \u2200 line \u2208 lines, line.length = width :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crib_roof_top {n : Nat} (h : 1 \u2264 n \u2227 n \u2264 10) :\n  let lines := splitLines (my_crib n)\n  let first_line := lines.head?\n  \u2200 line, first_line = some line \u2192 line.replace \" \" \"\" = line.replace \"_\" \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crib_sloping_roof {n : Nat} (h : 1 \u2264 n \u2227 n \u2264 10) :\n  let lines := splitLines (my_crib n)\n  let roof_lines := lines.take (3 + 2*(n-1))\n  \u2200 line \u2208 roof_lines, (line.contains '/') \u2227 (line.contains '\\\\') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crib_wall_structure {n : Nat} (h : 1 \u2264 n \u2227 n \u2264 10) :\n  let lines := splitLines (my_crib n)\n  let wall_lines := lines.drop (3 + 2*(n-1))\n  \u2200 line \u2208 wall_lines, line.startsWith \"|\" \u2227 line.endsWith \"|\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crib_bottom_line {n : Nat} (h : 1 \u2264 n \u2227 n \u2264 10) :\n  let lines := splitLines (my_crib n)\n  \u2200 last_line, lines.getLast? = some last_line \u2192 last_line.contains '_' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval my_crib 1\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval my_crib 2\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval my_crib 3"
      }
    ]
  },
  "fvapps_003081.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minimum (l : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum (l : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum_product (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_product_in_array (arr : List Int) (h : arr \u2260 []) :\n  \u2203 x \u2208 arr, maximum_product arr = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_product_even_negatives (arr : List Int) (h : arr \u2260 [])\n  (h_even : (arr.filter (\u03bb x => x < 0)).length % 2 = 0) :\n  let pos := arr.filter (\u03bb x => x \u2265 0)\n  let neg := arr.filter (\u03bb x => x < 0)\n  pos \u2260 [] \u2192 (\u2203 m, minimum pos = some m \u2227 maximum_product arr = m) \u2228\n  pos = [] \u2192 (\u2203 m, minimum neg = some m \u2227 maximum_product arr = m) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_product_odd_negatives (arr : List Int) (h : arr \u2260 [])\n  (h_odd : (arr.filter (\u03bb x => x < 0)).length % 2 = 1) :\n  let neg := arr.filter (\u03bb x => x < 0)\n  (\u00ac arr.contains 0 \u2192 (\u2203 m, maximum neg = some m \u2227 maximum_product arr = m)) \u2227\n  (arr.contains 0 \u2192 (\u2203 m, minimum neg = some m \u2227 maximum_product arr = m)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_product_multiple_zeros (arr : List Int) (h : arr \u2260 [])\n  (h_zeros : (arr.filter (\u03bb x => x = 0)).length > 1) :\n  \u2203 m, minimum arr = some m \u2227 maximum_product arr = m :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem maximum_product_single_element (x : Int) :\n  maximum_product [x] = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval maximum_product [1, 2, 3]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval maximum_product [-1, 2, -3]\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval maximum_product [-1, -2, -3]"
      }
    ]
  },
  "fvapps_003083.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def cheapest_quote (n : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Ensures cheapest_quote returns a non-negative float -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cheapest_quote_non_negative (n : Nat) :\n  let result := cheapest_quote n\n  result \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Ensures cheapest_quote is strictly monotonically increasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem cheapest_quote_monotonic (n : Nat) : n > 0 \u2192\n  cheapest_quote n > cheapest_quote (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3.95\n-/\n#guard_msgs in\n#eval cheapest_quote 41\n\n/-\ninfo: 2.52\n-/\n#guard_msgs in\n#eval cheapest_quote 26\n\n/-\ninfo: 48.06\n-/\n#guard_msgs in\n#eval cheapest_quote 499"
      }
    ]
  },
  "fvapps_003089.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def short_form (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isConsonant (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c \u2208 ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c.toLower \u2208 ['a', 'e', 'i', 'o', 'u']"
      },
      {
        "type": "cond",
        "string": "theorem short_form_length {s : String} :\n  String.length (short_form s) \u2264 String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_form_first_last {s : String} (h: String.length s > 0) :\n  (s.get! 0 = (short_form s).get! 0) \u2227\n  (String.length s > 1 \u2192 s.get! (String.Pos.mk (s.length - 1)) = (short_form s).get! (String.Pos.mk ((short_form s).length - 1))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_form_consonants {s : String} (h : \u2200 c, c \u2208 s.data \u2192 isConsonant c) :\n  short_form s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_form_case_preservation {s : String} :\n  \u2200 c, c \u2208 (short_form s).data \u2192 c \u2208 s.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_form_middle_vowels_removed {s : String} :\n  \u2200 i, 1 \u2264 i \u2192 i < String.length (short_form s) - 1 \u2192\n    \u00ac(isVowel ((short_form s).get! (String.Pos.mk i))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'asslt'\n-/\n#guard_msgs in\n#eval short_form \"assault\"\n\n/-\ninfo: 'rhythm'\n-/\n#guard_msgs in\n#eval short_form \"rhythm\"\n\n/-\ninfo: 'InSNe'\n-/\n#guard_msgs in\n#eval short_form \"InSaNe\""
      }
    ]
  },
  "fvapps_003090.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_factors (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def prime_factors (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_factors_valid_format (n : Nat) (h : n \u2265 2) :\n  let result := prime_factors n\n  \u2200 part : String,\n  part \u2208 (String.split (prime_factors n) (\u00b7 == ')')).filter (\u03bb x => x \u2260 \"\") \u2192\n  (\u2203 base power : Nat,\n   ((String.contains part '*') \u2192\n    part = s!\"{base}**{power}\" \u2227\n    is_prime base \u2227\n    power > 1) \u2227\n   (\u00acString.contains part '*' \u2192\n    part.toNat?.isSome \u2227\n    is_prime part.toNat!)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_factors_preserves_value (n : Nat) (h : n \u2265 2) :\n  let result := prime_factors n\n  let parts := (String.split result (\u00b7 == ')')).filter (\u03bb x => x \u2260 \"\")\n  let reconstructed := parts.foldl\n    (\u03bb acc part =>\n      if String.contains part '*'\n      then\n        let nums := String.split part (\u00b7 == '*')\n        let base := (nums.get! 0).trim.toNat!\n        let power := (nums.get! 2).trim.toNat!\n        acc * (base ^ power)\n      else acc * part.trim.toNat!)\n    1\n  reconstructed = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_number_input (p : Nat) (h\u2081 : p \u2265 2) (h\u2082 : is_prime p) :\n  prime_factors p = s!\"({p})\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem powers_of_two (n : Nat) (h : n \u2265 1) :\n  prime_factors (2^n) = s!\"(2**{n})\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003096.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.factorial : Nat \u2192 Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n"
      },
      {
        "type": "sig",
        "string": "def List.unique {\u03b1} [BEq \u03b1] (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def slogan_maker (words: List String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsString (s1 s2: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem slogan_maker_returns_string_list (words : List String) :\n  \u2200 s, s \u2208 slogan_maker words \u2192 s.length \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem slogan_maker_contains_all_words (words : List String) :\n  \u2200 slogan, slogan \u2208 slogan_maker words \u2192\n  \u2200 word, word \u2208 List.unique words \u2192\n  containsString slogan word = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem slogan_maker_length (words : List String) :\n  (slogan_maker words).length = List.factorial (List.unique words).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem slogan_maker_order_independent (words\u2081 words\u2082 : List String) :\n  List.unique words\u2081 = List.unique words\u2082 \u2192\n  slogan_maker words\u2081 = slogan_maker words\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem slogan_maker_unique_results (words : List String) :\n  \u2200 s\u2081 s\u2082, s\u2081 \u2208 slogan_maker words \u2192 s\u2082 \u2208 slogan_maker words \u2192\n  s\u2081 = s\u2082 \u2228 s\u2081 \u2260 s\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['super']\n-/\n#guard_msgs in\n#eval slogan_maker [\"super\"]\n\n/-\ninfo: set(['super hot', 'hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\"])\n\n/-\ninfo: set(['super hot guacamole', 'super guacamole hot', 'hot super guacamole', 'hot guacamole super', 'guacamole super hot', 'guacamole hot super'])\n-/\n#guard_msgs in\n#eval set slogan_maker([\"super\", \"hot\", \"guacamole\"])"
      }
    ]
  },
  "fvapps_003098.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def tv_remote (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tv_remote_basic_properties (s : String) : tv_remote s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tv_remote_empty_string : tv_remote \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tv_remote_case_sensitivity (s : String) :\n  s \u2260 \"\" \u2192 tv_remote (s.map Char.toUpper) \u2265 tv_remote (s.map Char.toLower) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 69\n-/\n#guard_msgs in\n#eval tv_remote \"Code Wars\"\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval tv_remote \"A\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval tv_remote \"does\""
      }
    ]
  },
  "fvapps_003099.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def rearranger (k : Nat) (nums : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) (sep : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def trim (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toNat! (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getFirst (l : List \u03b1) : \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def replace (s : String) (target : String) (replacement : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sortString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def joinStrings (l : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rearranger_divisible (k : Nat) (nums : List Nat) :\n  k > 0 \u2192 nums.length > 0 \u2192\n  let result := rearranger k nums\n  result \u2260 \"There is no possible rearrangement\" \u2192\n  let parts := splitString result \"generates:\"\n  let numberStr := getFirst (splitString (getFirst (parts.tail)) \"divisible by\")\n  let number := toNat! (trim numberStr)\n  number % k = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rearranger_preserves_digits (k : Nat) (nums : List Nat) :\n  k > 0 \u2192 nums.length > 0 \u2192\n  let result := rearranger k nums\n  result \u2260 \"There is no possible rearrangement\" \u2192\n  let input_digits := nums.map toString |> joinStrings |> sortString\n  let parts := splitString result \"generates:\"\n  let first_part := trim (replace (getFirst parts) \"Rearrangement:\" \"\")\n  let result_digits := splitString first_part \", \" |> joinStrings |> sortString\n  input_digits = result_digits :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003111.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_average [Add \u03b1] [Div \u03b1] [OfNat \u03b1 0] : List \u03b1 \u2192 \u03b1\n  | [] => 0\n  | xs => sorry"
      },
      {
        "type": "sig",
        "string": "def list_min : List Float \u2192 Float\n  | [] => 0\n  | (x::xs) => sorry"
      },
      {
        "type": "sig",
        "string": "def list_max : List Float \u2192 Float\n  | [] => 0\n  | (x::xs) => sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Float \u2192 Float\n  | [] => 0\n  | (x::xs) => sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toFloat (n : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_empty {\u03b1} [Add \u03b1] [Div \u03b1] [OfNat \u03b1 0] (nums : List \u03b1) :\n  nums = [] \u2192 find_average nums = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_bounds (nums : List Float) (h : nums \u2260 []) :\n  list_min nums \u2264 find_average nums \u2227\n  find_average nums \u2264 list_max nums := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-10 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_float_empty (nums : List Float) :\n  nums = [] \u2192 find_average nums = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_float_type (nums : List Float) (h : nums \u2260 []) :\n  find_average nums + 0 = find_average nums := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_average_float_sum (nums : List Float) :\n  abs (find_average nums * toFloat nums.length - list_sum nums) < 1e-6 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_average [1]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval find_average [1, 3, 5, 7]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []"
      }
    ]
  },
  "fvapps_003112.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s1 s2 : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_valid_output (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0) :\n  solve s1 s2 = 1 \u2228 solve s1 s2 = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_identical_chars (s1 s2 : String)\n    (h1 : s1.length > 0) (h2 : s2.length > 0)\n    (h3 : \u2200 (c : Char), s1.data.contains c \u2192 c = 'a')\n    (h4 : \u2200 (c : Char), s2.data.contains c \u2192 c = 'a') :\n  solve s1 s2 = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_with_duplicates (s : String)\n    (h1 : s.length \u2265 2) :\n  (\u2203 (c : Char), s.data.contains c \u2227 countChar s c \u2265 2) \u2192 solve s \"\" = 1 \u2227\n  (\u2200 (c : Char), s.data.contains c \u2192 countChar s c < 2) \u2192 solve s \"\" = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"abc\" \"xyz\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"eyfjy\" \"ooigv\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \"qtkxttl\" \"utvohqk\""
      }
    ]
  },
  "fvapps_003118.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sursurungal (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsDigit (s : String) (d : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsWordAfterNumber (s : String) (n : Nat) (w : String) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Numbers remain unchanged in output"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sursurungal_preserves_numbers {s : String} :\n  \u2200 n : Nat, containsDigit s n \u2192 containsDigit (sursurungal s) n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Word transformation rules for different numbers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem word_transformation_rules {s : String} (n : Nat) (w : String) :\n  containsWordAfterNumber (sursurungal s) n w \u2192\n  match n with\n  | 1 => \u00ac(w.startsWith \"bu\") \u2227 \u00ac(w.startsWith \"ga\") \u2227 \u00ac(w.endsWith \"zo\")\n  | 2 => w.startsWith \"bu\" \u2227 \u00ac(w.startsWith \"ga\") \u2227 \u00ac(w.endsWith \"zo\")\n  | n => if n \u2264 9\n        then \u00ac(w.startsWith \"bu\") \u2227 \u00ac(w.startsWith \"ga\") \u2227 w.endsWith \"zo\"\n        else w.startsWith \"ga\" \u2227 w.endsWith \"ga\" \u2227 \u00ac(w.endsWith \"zo\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Text without number-word pairs remains unchanged"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem unchanged_text_without_numbers (s : String) :\n  (\u2200 n : Nat, \u00accontainsDigit s n) \u2192\n  sursurungal s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1 tomato'\n-/\n#guard_msgs in\n#eval sursurungal \"1 tomato\"\n\n/-\ninfo: '2 bubanana'\n-/\n#guard_msgs in\n#eval sursurungal \"2 bananas\"\n\n/-\ninfo: '3 bananazo'\n-/\n#guard_msgs in\n#eval sursurungal \"3 bananas\"\n\n/-\ninfo: '10 gabananaga'\n-/\n#guard_msgs in\n#eval sursurungal \"10 bananas\"\n\n/-\ninfo: '6 birdzo with 2 buwing each'\n-/\n#guard_msgs in\n#eval sursurungal \"6 birds with 2 wings each\"\n\n/-\ninfo: '\\n3 pigzo\\nmet 1 wolf\\n2 buday ago'\n-/\n#guard_msgs in\n#eval sursurungal \"\\n3 pigs\\nmet 1 wolf\\n2 days ago\""
      }
    ]
  },
  "fvapps_003127.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def DnaBases : List Char := ['A', 'C', 'G', 'T']\n\ndef isValidDnaChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match DnaBases.find? (\u00b7 == c) with\n  | some _ => true\n  | none => false"
      },
      {
        "type": "sig",
        "string": "def isValidDnaString (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match s.data.find? (fun c => !isValidDnaChar c) with\n  | some _ => false\n  | none => true"
      },
      {
        "type": "sig",
        "string": "def motif_locator (sequence motif : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def substring (s : String) (start len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem motif_positions_valid (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (\u2200 p \u2208 positions, 0 < p \u2227 p \u2264 sequence.length) \u2227\n  (\u2200 p \u2208 positions, substring sequence (p-1) motif.length = motif) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positions_ordered_nonoverlap (sequence motif : String)\n  (h1 : isValidDnaString sequence)\n  (h2 : isValidDnaString motif) :\n  let positions := motif_locator sequence motif\n  (\u2200 i j, i < j \u2192 j < positions.length \u2192 positions[i]! \u2264 positions[j]!) \u2227\n  (\u2200 i, i < positions.length - 1 \u2192 positions[i+1]! - positions[i]! \u2265 motif.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_sequence (motif : String)\n  (h : isValidDnaString motif) :\n  motif_locator \"\" motif = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem motif_longer_than_seq :\n  motif_locator \"ACG\" \"ACGT\" = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"TTCCGGAACC\" \"CC\"\n\n/-\ninfo: [1, 9]\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTTACAACGTTAG\" \"ACGT\"\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval motif_locator \"ACGTACGTACGT\" \"AAA\""
      }
    ]
  },
  "fvapps_003136.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate : List Nat \u2192 Nat\n| xs => sorry\n/- Helper function to sum a list of naturals -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n| [] => 0\n| (x::xs) => x + listSum xs"
      },
      {
        "type": "cond",
        "string": "theorem calc_is_positive (cards : List Nat) :\n  cards \u2260 [] \u2192 calculate cards \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_single_element (cards : List Nat) (x : Nat) :\n  cards = [x] \u2192 calculate cards = 2 * x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_increases_monotonic (cards : List Nat) (i : Nat) (hi : i < cards.length) :\n  let cards' := cards.set i (cards[i]! + 1);\n  calculate cards' \u2265 calculate cards :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calc_bounded_by_double (cards : List Nat) :\n  cards \u2260 [] \u2192 calculate cards \u2264 listSum cards * (2 ^ cards.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003137.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def transform_word (s : String) : String := sorry\n\ndef isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'"
      },
      {
        "type": "sig",
        "string": "def isLowerAscii (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  97 \u2264 c.toNat \u2227 c.toNat \u2264 122"
      },
      {
        "type": "cond",
        "string": "theorem transform_word_preserves_length (s : String) :\n  s.length = (transform_word s).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_word_chars_are_ascii_lower (s : String) :\n  \u2200 c \u2208 (transform_word s).data, isLowerAscii c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_word_vowel_consonant_mapping (s : String) :\n  \u2200 i, i < s.length \u2192\n    let pos : String.Pos := \u27e8i\u27e9\n    (isVowel (s.get pos) \u2192 \u00acisVowel ((transform_word s).get pos)) \u2227\n    (\u00acisVowel (s.get pos) \u2192 isVowel ((transform_word s).get pos)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_word_deterministic (s : String) :\n  transform_word s = transform_word s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ezu'\n-/\n#guard_msgs in\n#eval transform_word \"cat\"\n\n/-\ninfo: 'enedazuu'\n-/\n#guard_msgs in\n#eval transform_word \"codewars\"\n\n/-\ninfo: 'zeeeutaaaaa'\n-/\n#guard_msgs in\n#eval transform_word \"abcdtuvwxyz\""
      }
    ]
  },
  "fvapps_003141.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isInertial (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum? : List Int \u2192 Option Int\n  | [] => none\n  | x::xs => some (xs.foldl max x)"
      },
      {
        "type": "sig",
        "string": "def minimum? : List Int \u2192 Option Int\n  | [] => none\n  | x::xs => some (xs.foldl min x)"
      },
      {
        "type": "cond",
        "string": "theorem empty_array\n  : \u2200 (arr : List Int), arr = [] \u2192 isInertial arr = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_odds\n  : \u2200 (arr : List Int),\n    arr \u2260 [] \u2192\n    (\u2200 x \u2208 arr, x % 2 = 0) \u2192\n    isInertial arr = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_must_be_even\n  : \u2200 (arr : List Int),\n    arr \u2260 [] \u2192\n    match maximum? arr with\n    | none => True\n    | some max => max % 2 = 1 \u2192 isInertial arr = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem odds_vs_evens\n  : \u2200 (arr : List Int),\n    arr \u2260 [] \u2192\n    (\u2203 x \u2208 arr, x % 2 = 1) \u2192\n    match maximum? arr with\n    | none => True\n    | some max =>\n      max % 2 = 0 \u2192\n      let odds := arr.filter (fun x => x % 2 = 1)\n      let evens := arr.filter (fun x => x % 2 = 0 && x \u2260 max)\n      odds \u2260 [] \u2192\n      evens \u2260 [] \u2192\n      match minimum? odds, maximum? evens with\n      | some min_odd, some max_even => isInertial arr = (min_odd > max_even)\n      | _, _ => True := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_element\n  : \u2200 (n : Int), isInertial [n] = false := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial []\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_inertial [581, -384, 140, -287]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_inertial [11, 4, 20, 9, 2, 8]"
      }
    ]
  },
  "fvapps_003143.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (pattern: String) (target: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_strings_match\n  (s: String)\n  (h: s.data.all (fun c => c \u2260 '*')) :\n  solve s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringAppend (s1 s2: String) : String := String.append s1 s2"
      },
      {
        "type": "cond",
        "string": "theorem wildcard_match\n  (p s m: String)\n  (h1: p.data.all (fun c => c \u2260 '*'))\n  (h2: s.data.all (fun c => c \u2260 '*'))\n  (h3: m.data.all (fun c => c \u2260 '*')) :\n  solve (stringAppend (stringAppend p \"*\") s) (stringAppend (stringAppend p m) s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_strings_no_match\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c \u2260 '*'))\n  (h2: s2.data.all (fun c => c \u2260 '*'))\n  (h3: s1 \u2260 s2) :\n  solve s1 s2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_wildcards_invalid\n  (s1 s2: String)\n  (h1: s1.data.all (fun c => c \u2260 '*'))\n  (h2: s2.data.all (fun c => c \u2260 '*')) :\n  solve (stringAppend (stringAppend (stringAppend s1 \"*\") s2) \"*\") \"anything\" = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_requirement\n  (p s m: String)\n  (h1: p.data.all (fun c => c \u2260 '*'))\n  (h2: s.data.all (fun c => c \u2260 '*')) :\n  (stringAppend (stringAppend p m) s).length \u2265 (stringAppend (stringAppend p \"*\") s).length - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"code*s\" \"codewars\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"codewar*s\" \"codewars\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"code*warrior\" \"codewars\""
      }
    ]
  },
  "fvapps_003145.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encode_resistor_colors (ohm_str : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.toNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem resistor_colors_format {ohm_str : String}\n  (h : 10 \u2264 ohm_str.toNat \u2227 ohm_str.toNat \u2264 99000000) :\n  let result := encode_resistor_colors ohm_str\n  let colors := (result.split fun c => c = ' ')\n  (colors.length = 4) \u2227\n  (colors[3]! = \"gold\") \u2227\n  (\u2200 c \u2208 colors, c \u2208 [\"black\", \"brown\", \"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\", \"gray\", \"white\", \"gold\"]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem resistor_colors_value {ohm_str : String}\n  (h1 : ohm_str.contains 'k' \u2192\n        1000 * (ohm_str.replace \"k\" \" \").toNat = ohm_str.toNat)\n  (h2 : ohm_str.contains 'M' \u2192\n        1000000 * (ohm_str.replace \"M\" \" \").toNat = ohm_str.toNat)\n  (h3 : \u00acohm_str.contains 'k' \u2227 \u00acohm_str.contains 'M' \u2192\n        ohm_str.toNat = ohm_str.toNat)\n  (h4 : 10 \u2264 ohm_str.toNat \u2227 ohm_str.toNat \u2264 99000000) :\n  let result := encode_resistor_colors ohm_str\n  ohm_str.toNat = result.toNat :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003147.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverseInvert (lst : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverseInvert_returns_list_of_ints {lst : List Int} :\n  \u2200 x, x \u2208 reverseInvert lst \u2192 x \u2208 lst := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numReverse (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverseInvert_bounded {lst : List Int}\n    (h : \u2200 x \u2208 lst, -999 \u2264 x \u2227 x \u2264 999) :\n    \u2200 (i : Fin lst.length),\n      let orig := lst.get i\n      let revNum := numReverse (Int.natAbs orig)\n      (reverseInvert lst).get \u27e8i, by sorry\u27e9 = if orig > 0 then -revNum else revNum := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverseInvert_single_digits {lst : List Int} (h : \u2200 x \u2208 lst, 0 \u2264 x \u2227 x \u2264 9) :\n  \u2200 (i : Fin lst.length),\n    (reverseInvert lst).get \u27e8i, by sorry\u27e9 = -(lst.get i) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverseInvert_length_preservation {lst : List Int} :\n  (reverseInvert lst).length = lst.length := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [-1, -2, -3, -4, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 2, 3, 4, 5]\n\n/-\ninfo: [-1, -21, -78, 24, -5]\n-/\n#guard_msgs in\n#eval reverse_invert [1, 12, \"a\", 3.4, 87, 99.9, -42, 50, 5.6]\n\n/-\ninfo: [9, 81, -99]\n-/\n#guard_msgs in\n#eval reverse_invert [-9, -18, 99]"
      }
    ]
  },
  "fvapps_003149.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def highlight (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def colorFor (c : Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s : String) (sub : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem letter_get_correct_colors (c : Char) (h: c \u2208 ['F', 'L', 'R']):\n  let color :=\n    match c with\n    | 'F' => \"pink\"\n    | 'L' => \"red\"\n    | 'R' => \"green\"\n    | _ => \"\"\n  colorFor c = color\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem numbers_get_orange (c : Char) (h : c.isDigit) :\n  colorFor c = \"orange\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_chars_single_span (s : String) (h: s.all (\u00b7 = s.get! 0)) :\n  (highlight s).count \"<span\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highlight_maintains_content (s : String) :\n  let stripped := (highlight s).replace \"<span\" \"\" |>.replace \"</span\" \"\" |>.replace \"style=\\\"color: pink\\\"\" \"\"\n                   |>.replace \"style=\\\"color: red\\\"\" \"\" |>.replace \"style=\\\"color: green\\\"\" \"\"\n                   |>.replace \"style=\\\"color: orange\\\"\" \"\"\n  stripped = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval highlight \"F3RF5LF7\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval highlight \"FFFR345F2LL\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval highlight \"FF(LF6(RF3)2)3\""
      }
    ]
  },
  "fvapps_003157.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def evil (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem evil_result_valid (n : Nat) :\n  (evil n = \"It's Evil!\") \u2228 (evil n = \"It's Odious!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n = 0 then 0\n  else if n % 2 = 1\n  then countOnes (n / 2) + 1\n  else countOnes (n / 2)"
      },
      {
        "type": "cond",
        "string": "theorem evil_xor_property (n m : Nat) :\n  let n_evil := evil n = \"It's Evil!\"\n  let m_evil := evil m = \"It's Evil!\"\n  let xor_evil := evil (n ^^^ m) = \"It's Evil!\"\n  (n_evil = m_evil) = xor_evil :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 1\n\n/-\ninfo: \"It's Odious!\"\n-/\n#guard_msgs in\n#eval evil 2\n\n/-\ninfo: \"It's Evil!\"\n-/\n#guard_msgs in\n#eval evil 3"
      }
    ]
  },
  "fvapps_003165.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def make_triangle (m n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDigitChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  '0' \u2264 c \u2227 c \u2264 '9'"
      },
      {
        "type": "cond",
        "string": "theorem make_triangle_valid_output_type {m n : Nat} :\n  \u2200 r : String, r = make_triangle m n \u2192 (r = \"\" \u2228 String.contains r '\\n') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem make_triangle_digits_only {m n : Nat} (h : m \u2264 n) (h2 : n - m + 1 \u2264 45) :\n  \u2200 c : Char, c \u2208 (make_triangle m n).toList \u2192\n    (c = ' ' \u2228 c = '\\n' \u2228 isDigitChar c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem make_triangle_row_growth {m n : Nat} (h : m \u2264 n) (h2 : n - m + 1 \u2264 45) :\n  let lines := String.split (make_triangle m n) (\u00b7 = '\\n')\n  \u2200 i : Nat, i < lines.length \u2192\n    \u2200 h : i < lines.length,\n    (String.split (String.trim (lines[i]'h)) (\u00b7 = ' ')).length = i + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem make_triangle_total_elements {m n : Nat} (h : m \u2264 n) :\n  let size := n - m + 1\n  let result := make_triangle m n\n  let lines := String.split result (\u00b7 = '\\n')\n  result \u2260 \"\" \u2192\n  (lines.foldl (fun acc line =>\n    acc + (String.split (String.trim line) (\u00b7 = ' ')).length) 0) = size :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem make_triangle_invalid_empty {m n : Nat} :\n  (m > n \u2228 n - m + 1 > 45) \u2192 make_triangle m n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003166.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (arr : List Char) (reach : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def numChar (c : Char) (arr : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty {reach : Nat} :\n  solve [] reach = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"D\", \"C\", \"C\", \"D\", \"C\"] 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"D\", \"C\", \"D\"] 1"
      }
    ]
  },
  "fvapps_003172.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ones_counter (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Int \u2192 Int\n  | [] => 0\n  | x::xs => x + sum_list xs"
      },
      {
        "type": "cond",
        "string": "theorem ones_counter_positive (nums : List Int) :\n  \u2200 x \u2208 ones_counter nums, x > 0\n:="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ones_counter_sum (nums : List Int) :\n  sum_list (ones_counter nums) = sum_list nums\n:="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ones_counter_grouped (nums : List Int) :\n  ones_counter nums =\n    let rec group_ones (ns : List Int) (acc : Int) (result : List Int) : List Int :=\n      match ns with\n      | [] => if acc > 0 then result ++ [acc] else result\n      | x::xs => if x = 1\n                 then group_ones xs (acc + 1) result\n                 else if acc > 0\n                      then group_ones xs 0 (result ++ [acc])\n                      else group_ones xs 0 result\n    group_ones nums 0 []\n:="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ones_counter_all_zeros {nums : List Int} (h : \u2200 x \u2208 nums, x = 0) :\n  ones_counter nums = []\n:="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ones_counter_all_ones {nums : List Int} (h : \u2200 x \u2208 nums, x = 1) (h' : nums \u2260 []) :\n  ones_counter nums = [((List.length nums) : Int)]\n:="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval ones_counter [0, 0, 0, 0, 0, 0, 0, 0]\n\n/-\ninfo: [3, 1, 2]\n-/\n#guard_msgs in\n#eval ones_counter [1, 1, 1, 0, 0, 1, 0, 1, 1, 0]\n\n/-\ninfo: [1, 2, 4, 1]\n-/\n#guard_msgs in\n#eval ones_counter [1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1]"
      }
    ]
  },
  "fvapps_003176.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def memorysize_conversion (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def binary_units := [\"KiB\", \"MiB\", \"GiB\", \"TiB\"]"
      },
      {
        "type": "sig",
        "string": "def metric_units := [\"kB\", \"MB\", \"GB\", \"TB\"]\n\ndef isValidIndex (i : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  i < 4"
      },
      {
        "type": "cond",
        "string": "theorem binary_units_length : binary_units.length = 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem metric_units_length : metric_units.length = 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_to_metric_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 \u2264 value) (h2 : value \u2264 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {binary_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith metric_units[unit_idx] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem metric_to_binary_unit_preservation {value : Float} {unit_idx : Nat}\n  (h1 : 0.000001 \u2264 value) (h2 : value \u2264 1000000)\n  (h3 : isValidIndex unit_idx) :\n  let input := s!\"{value} {metric_units[unit_idx]}\"\n  let result := memorysize_conversion input\n  result.endsWith binary_units[unit_idx] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1.024 kB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"1 KiB\"\n\n/-\ninfo: '9.095 TiB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"10 TB\"\n\n/-\ninfo: '4.402 GB'\n-/\n#guard_msgs in\n#eval memorysize_conversion \"4.1 GiB\""
      }
    ]
  },
  "fvapps_003179.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gap (g m n : Nat) : Option (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_divisibility {n : Nat} (h : n \u2265 2) :\n  isPrime n = true \u2192\n  \u2200 i : Nat, 2 \u2264 i \u2192 i \u2264 sqrt n \u2192 n % i \u2260 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem composite_divisibility {n : Nat} (h : n \u2265 2) :\n  isPrime n = false \u2192\n  (\u2203 i : Nat, 2 \u2264 i \u2227 i \u2264 sqrt n \u2227 n % i = 0) \u2228 n < 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gap_result_valid {g m n : Nat} (hm : m \u2265 2) (hn : n \u2265 2) :\n  \u2200 result : Nat \u00d7 Nat,\n  gap g m n = some result \u2192\n  let (p\u2081, p\u2082) := result\n  (isPrime p\u2081 = true \u2227 isPrime p\u2082 = true) \u2227\n  p\u2082 - p\u2081 = g \u2227\n  m \u2264 p\u2081 \u2227 p\u2081 \u2264 p\u2082 \u2227 p\u2082 \u2264 n \u2227\n  \u2200 x : Nat, p\u2081 < x \u2192 x < p\u2082 \u2192 isPrime x = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 5]\n-/\n#guard_msgs in\n#eval gap 2 3 10\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval gap 6 100 110\n\n/-\ninfo: [163, 167]\n-/\n#guard_msgs in\n#eval gap 4 130 200"
      }
    ]
  },
  "fvapps_003180.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (a x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_makes_number_divisible (a x : Int) (h : x \u2260 0) :\n  (a + minimum a x) % x = 0 \u2228 (a - minimum a x) % x = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum 9 4\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval minimum 10 6\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval minimum 15 5"
      }
    ]
  },
  "fvapps_003189.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def threeAmigos (nums : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem threeAmigos_valid_size {nums : List Int} :\n  let result := threeAmigos nums\n  List.length result = 0 \u2228 List.length result = 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem threeAmigos_consecutive {nums : List Int} (h : 3 \u2264 List.length nums) :\n  let result := threeAmigos nums\n  result = [] \u2228 \u2203 i, i + 2 < List.length nums \u2227\n    result = [nums[i]!, nums[i+1]!, nums[i+2]!] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem threeAmigos_same_parity {nums : List Int} (h : 3 \u2264 List.length nums) :\n  let result := threeAmigos nums\n  result = [] \u2228 (\u2200 x \u2208 result, x % 2 = result[0]! % 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem threeAmigos_minimal_range {nums : List Int} (h : 3 \u2264 List.length nums) :\n  let result := threeAmigos nums\n  result = [] \u2228\n  (\u2200 i, i + 2 < List.length nums \u2192\n    (\u2200 j, j \u2208 [nums[i]!, nums[i+1]!, nums[i+2]!] \u2192 j % 2 = nums[i]! % 2) \u2192\n    (list_max result - list_min result) \u2264 (nums[i+2]! - nums[i]!)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [5, 3, 5]\n-/\n#guard_msgs in\n#eval three_amigos [1, 2, 34, 2, 1, 5, 3, 5, 7, 234, 2, 1]\n\n/-\ninfo: [2, 2, 2]\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 6, 8, 10, 2, 2, 2, 1, 1, 1, 5, 3]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval three_amigos [2, 4, 5, 3, 6, 3, 1, 56, 7, 6, 3, 12]"
      }
    ]
  },
  "fvapps_003196.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def predict_age (ages : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem predict_age_non_negative (ages : List Nat) :\n  0 \u2264 predict_age ages :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem predict_age_is_nat (ages : List Nat) :\n  predict_age ages = predict_age ages :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem predict_age_order_independent (ages : List Nat) :\n  predict_age ages = predict_age ages.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem predict_age_zero :\n  predict_age [0] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem predict_age_single (age : Nat) :\n  predict_age [age] = age / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003200.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def circular_permutations (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def circular_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem circular_perms_length (n : Nat) (h : n > 0) :\n  List.length (circular_permutations n) = String.length (toString n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circular_perms_digit_count (n : Nat) (h : n > 0) :\n  \u2200 p \u2208 circular_permutations n,\n    List.length (toString p).data = List.length (toString n).data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_basic_properties (n : Nat) :\n  is_prime n = true \u2192\n    (n > 1 \u2227\n     \u2200 i, 2 \u2264 i \u2192 i \u2264 sqrt n \u2192 n % i \u2260 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circular_prime_properties (n : Nat) :\n  circular_prime n = true \u2192\n    \u2200 x \u2208 circular_permutations n, is_prime x = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circular_prime_symmetry (n : Nat) :\n  circular_prime n = true \u2192\n    \u2200 p \u2208 circular_permutations n, circular_prime p = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 197\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circular_prime 179\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circular_prime 7"
      }
    ]
  },
  "fvapps_003207.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def going (n : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem going_range (n : Nat) :\n  1 \u2264 going n \u2227 going n \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calc_series (n : Nat) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem going_matches_calc_series (n : Nat) :\n  n \u2265 1 \u2192 n \u2264 100 \u2192 Float.abs (going n - calc_series n) < 0.000001 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem going_decimal_places (n : Nat) :\n  \u2203 k : Nat, k \u2264 6 \u2227 going n * Float.ofNat (10^k) = Float.floor (going n * Float.ofNat (10^k)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem going_specific_values :\n  going 1 = 1.0 \u2227 going 5 = 1.275 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1.275\n-/\n#guard_msgs in\n#eval going 5\n\n/-\ninfo: 1.2125\n-/\n#guard_msgs in\n#eval going 6\n\n/-\ninfo: 1.173214\n-/\n#guard_msgs in\n#eval going 7"
      }
    ]
  },
  "fvapps_003209.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def timeToWords (time: String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasSubstring (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def endsWithStr (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_basic_format (hours : Nat) (minutes : Nat)\n  (h_hours : hours \u2264 23) (h_minutes : minutes \u2264 59) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  (hasSubstring result \"o'clock\" \u2228 hasSubstring result \"past\" \u2228\n   hasSubstring result \"to\" \u2228 result = \"midnight\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_oclock (hours : Nat) (h_hours : hours \u2264 23) :\n  let result := timeToWords s!\"#{hours}:00\"\n  (hours = 0 \u2192 result = \"midnight\") \u2227\n  (hours \u2260 0 \u2192 endsWithStr result \"o'clock\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_quarter_past (hours : Nat) (h_hours : hours \u2264 23) :\n  let result := timeToWords s!\"#{hours}:15\"\n  (hours = 0 \u2192 hasSubstring result \"quarter past midnight\") \u2227\n  (hours \u2260 0 \u2192 hasSubstring result \"quarter past\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_half_past (hours : Nat) (h_hours : hours \u2264 23) :\n  let result := timeToWords s!\"#{hours}:30\"\n  (hours = 0 \u2192 hasSubstring result \"half past midnight\") \u2227\n  (hours \u2260 0 \u2192 hasSubstring result \"half past\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_past_minutes (hours minutes : Nat)\n  (h_hours : hours \u2264 23) (h_minutes : minutes \u2264 29) (h_minutes_pos : minutes \u2265 1)\n  (h_not_quarter : minutes \u2260 15) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"past\" \u2227 hasSubstring result \"minute\" \u2227\n  (hasSubstring result \"minutes\" \u2194 minutes \u2260 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_to_words_to_minutes (hours minutes : Nat)\n  (h_hours : hours \u2264 23) (h_minutes : minutes \u2264 59) (h_minutes_low : minutes \u2265 31)\n  (h_not_quarter : minutes \u2260 45) :\n  let result := timeToWords s!\"#{hours}:#{minutes}\"\n  hasSubstring result \"to\" \u2227 hasSubstring result \"minute\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: \"one o'clock\"\n-/\n#guard_msgs in\n#eval time_to_words \"13:00\"\n\n/-\ninfo: 'quarter past one'\n-/\n#guard_msgs in\n#eval time_to_words \"13:15\"\n\n/-\ninfo: 'midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"00:00\"\n\n/-\ninfo: 'quarter to midnight'\n-/\n#guard_msgs in\n#eval time_to_words \"23:45\""
      }
    ]
  },
  "fvapps_003210.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encrypt (text : Option String) (n : Int) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def decrypt (text : Option String) (n : Int) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypt_decrypt_roundtrip {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n \u2264 10) :\n  decrypt (encrypt (some text) n) n = some text :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypt_edge_cases {text : Option String} {n : Int} (h1 : text = none \u2228 text = some \"\") (h2 : n > 0) (h3 : n \u2264 10) :\n  encrypt text n = text :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypt_invalid_n {text : String} {n : Int} (h1 : text.length > 0) (h2 : n \u2264 0) :\n  encrypt (some text) n = some text :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypt_length_preserved {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n \u2264 10) :\n  (encrypt (some text) n).map String.length = some text.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypt_char_preservation {text : String} {n : Int} (h1 : text.length > 0) (h2 : n > 0) (h3 : n \u2264 10) :\n  (encrypt (some text) n).map (fun s => s.data.toArray.qsort (\u00b7 \u2264 \u00b7)) = some (text.data.toArray.qsort (\u00b7 \u2264 \u00b7)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'hsi  etTi sats!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 1\n\n/-\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"hsi  etTi sats!\" 1\n\n/-\ninfo: 's eT ashi tist!'\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\" 2\n\n/-\ninfo: 'This is a test!'\n-/\n#guard_msgs in\n#eval decrypt \"s eT ashi tist!\" 2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\" 1\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval decrypt None 1"
      }
    ]
  },
  "fvapps_003212.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isNonZeroDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def look_and_say_sequence (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_preserves_digits (s : String) (n : Nat)\n  (h : \u2200 c \u2208 s.data, isNonZeroDigit c) :\n  \u2200 c \u2208 (look_and_say_sequence s n).data, isDigit c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_length_monotonic (s : String) (n : Nat)\n  (h : \u2200 c \u2208 s.data, isNonZeroDigit c) :\n  (look_and_say_sequence s n).length \u2264 (look_and_say_sequence s (n+1)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_element_unchanged (s : String)\n  (h : \u2200 c \u2208 s.data, isNonZeroDigit c) :\n  look_and_say_sequence s 1 = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeating_digits_pattern (s : String)\n  (h : \u2200 c \u2208 s.data, isNonZeroDigit c) :\n  let result := look_and_say_sequence s 2\n  \u2200 i < result.length / 2,\n    \u2203 (p1 p2 : String.Pos),\n    isNonZeroDigit (result.get p1) \u2227\n    isDigit (result.get p2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_repeating_sequence :\n  look_and_say_sequence \"22\" 9 = look_and_say_sequence \"22\" 10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 1\n\n/-\ninfo: '21'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 3\n\n/-\ninfo: '111221'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"1\" 5\n\n/-\ninfo: '22'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"22\" 10\n\n/-\ninfo: '1114'\n-/\n#guard_msgs in\n#eval look_and_say_sequence \"14\" 2"
      }
    ]
  },
  "fvapps_003222.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def narcissistic (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def digit_power_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- For any natural number, narcissistic returns a boolean"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem narcissistic_returns_bool (n : Nat) :\n  \u2203 (b : Bool), narcissistic n = b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- The narcissistic function returns true when the sum of each digit raised to\n-- the power of number of digits equals the original number"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem narcissistic_digit_power_sum (n : Nat) :\n  narcissistic n = (n = digit_power_sum n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Known narcissistic numbers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem known_narcissistic_numbers :\n  narcissistic 0 = true \u2227\n  narcissistic 1 = true \u2227\n  narcissistic 2 = true \u2227\n  narcissistic 3 = true \u2227\n  narcissistic 4 = true \u2227\n  narcissistic 5 = true \u2227\n  narcissistic 6 = true \u2227\n  narcissistic 7 = true \u2227\n  narcissistic 8 = true \u2227\n  narcissistic 9 = true \u2227\n  narcissistic 153 = true \u2227\n  narcissistic 370 = true \u2227\n  narcissistic 371 = true \u2227\n  narcissistic 407 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 153\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval narcissistic 1634\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval narcissistic 123"
      }
    ]
  },
  "fvapps_003223.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def flatten {\u03b1 : Type} : List (List \u03b1) \u2192 List \u03b1\n  | [] => sorry\n  | x :: xs => sorry"
      },
      {
        "type": "sig",
        "string": "def isNestedList {\u03b1 : Type} : List (List \u03b1) \u2192 Bool\n  | [] => sorry\n  | x :: xs => sorry"
      },
      {
        "type": "cond",
        "string": "theorem flatten_preserves_elements {\u03b1 : Type} (lst : List (List \u03b1)) (inner : List \u03b1) :\n  inner \u2208 lst \u2192\n  \u2200 x \u2208 inner, x \u2208 (flatten lst) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flatten_identity_on_simple_list {\u03b1 : Type} (lst : List \u03b1) :\n  flatten [lst] = lst :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flatten_length_simple {\u03b1 : Type} (lst : List \u03b1) :\n  List.length (flatten [lst]) = List.length lst :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flatten_nested_ints (lst : List (List Int)) (n : Int) :\n  n \u2208 (flatten lst) \u2192\n  \u2203 inner : List Int, inner \u2208 lst \u2227 n \u2208 inner :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003224.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.lines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sierpinski (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sierpinski_base : sierpinski 0 = \"*\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003225.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def list_squared (m n : Nat) : List (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_result_valid (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  \u2200 pair \u2208 result,\n    \u2203 (a b : Nat), pair = (a, b) \u2227\n    m \u2264 a \u2227 a \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfSquaredDivisors (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_divisors_sum (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  \u2200 pair \u2208 result, pair.2 = sumOfSquaredDivisors pair.1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPerfectSquare (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2203 k : Nat, k * k = n"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_is_sorted (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  \u2200 i, i + 1 < result.length \u2192\n    (result[i]'sorry).1 < (result[i+1]'sorry).1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_perfect_squares (m n : Nat) (h : 0 < m) (h2 : 0 < n) :\n  let result := list_squared m n\n  \u2200 pair \u2208 result, isPerfectSquare pair.2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_single_point (n : Nat) (h : 0 < n) :\n  let result := list_squared n n\n  result = [] \u2228 result = [(n, sumOfSquaredDivisors n)] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem list_squared_empty (m n : Nat) :\n  m > n \u2192 list_squared m n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [[1, 1], [42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 1 250\n\n/-\ninfo: [[42, 2500], [246, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 42 250\n\n/-\ninfo: [[287, 84100]]\n-/\n#guard_msgs in\n#eval list_squared 250 500"
      }
    ]
  },
  "fvapps_003232.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def products (n : Nat) (k m : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def eq_dice (dice : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.prod (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem eq_dice_single_die (n : Nat)\n  (h : 3 \u2264 n \u2227 n \u2264 20) :\n  eq_dice [n] = (products n 3 (min (n-1) 20)).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem eq_dice_small_pairs (d1 d2 : Nat)\n  (h1 : 3 \u2264 d1 \u2227 d1 \u2264 6)\n  (h2 : 3 \u2264 d2 \u2227 d2 \u2264 6) :\n  eq_dice [d1, d2] \u2264 5 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem eq_dice_threes :\n  eq_dice [3, 3] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem eq_dice_four :\n  eq_dice [4] = (products 4 3 3).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval eq_dice [6, 6]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval eq_dice [5, 6, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval eq_dice [3, 3]"
      }
    ]
  },
  "fvapps_003235.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) (a b : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def length (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def substring (s : String) (start : Nat) (len : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_length_preserved (s : String) (a b : Nat) (h : length s > 0) :\n  length (solve s a b) = length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_preserves_outside_bounds (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) 0 start = substring s 0 start \u2227\n  substring (solve s a b) finish (length s - finish) = substring s finish (length s - finish) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_reverses_middle (s : String) (a b : Nat) (h : length s > 0)\n  (start := min a (length s))\n  (finish := min (b + 1) (length s)) :\n  substring (solve s a b) start (finish - start) = reverse (substring s start (finish - start)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_identity_empty_range (s : String) (h : length s > 0) :\n  solve s 0 0 = s \u2227\n  solve s (length s) (length s + 10) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_full_reversal (s : String) (h : length s > 0) :\n  solve s 0 (length s - 1) = reverse s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_single_char_identity (s : String) (idx : Nat) (h : length s > 0)\n  (limited_idx := min idx (length s - 1)) :\n  solve s limited_idx limited_idx = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003241.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def split (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toNat (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def scratch (tickets : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem scratch_non_negative (tickets : List String) :\n  scratch tickets \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1100\n-/\n#guard_msgs in\n#eval scratch [\"tiger tiger tiger 100\", \"rabbit dragon snake 100\", \"rat ox pig 1000\", \"dog cock sheep 10\", \"horse monkey rat 5\", \"dog dog dog 1000\"]\n\n/-\ninfo: 350\n-/\n#guard_msgs in\n#eval scratch [\"cat cat cat 50\", \"dog dog dog 100\", \"pig pig pig 200\"]\n\n/-\ninfo: 500\n-/\n#guard_msgs in\n#eval scratch [\"owl eagle hawk 100\", \"cat mouse dog 200\", \"fish fish fish 500\"]"
      }
    ]
  },
  "fvapps_003242.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def amort (rate : Float) (bal : Int) (term : Int) (num_payments : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "structure AmortValues where\n  num_payment : Int\n  payment : Int\n  principal : Int\n  interest : Int\n  balance : Float\n\n/- Helper function to extract numeric values from amortization string output -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def extractValuesFromString (s : String) : AmortValues :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to check if string matches expected pattern -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def matchesPattern (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem amort_output_format (rate : Float) (bal : Int) (term : Int) (num_payments : Int)\n  (h1 : rate \u2265 0.1) (h2 : rate \u2264 30.0)\n  (h3 : bal \u2265 1000) (h4 : bal \u2264 1000000)\n  (h5 : term \u2265 12) (h6 : term \u2264 360)\n  (h7 : num_payments \u2265 1) (h8 : num_payments \u2264 term) :\n  let result := amort rate bal term num_payments\n  let values := extractValuesFromString result\n  (matchesPattern result) \u2227\n  (values.num_payment = num_payments) \u2227\n  (values.payment \u2265 0) \u2227\n  (values.principal \u2265 0) \u2227\n  (values.interest \u2265 0) \u2227\n  (Int.natAbs (values.principal + values.interest - values.payment) \u2264 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003248.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validMorseChar (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def encryption (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem encryption_morse_chars\n  (s : String)\n  (h : \u2200 c, c \u2208 s.data \u2192 c.isUpper)\n  : \u2200 c, c \u2208 (encryption s).data \u2192 (c = '.' \u2228 c = '-' \u2228 c = ' ') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encryption_word_separation\n  (s : String)\n  (h : \u2200 c, c \u2208 s.data \u2192 c.isUpper)\n  : ((encryption s).splitOn \"   \").length = (s.splitOn \" \").length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encryption_letter_separation\n  (s : String)\n  (h : \u2200 c, c \u2208 s.data \u2192 c.isUpper)\n  : \u2200 word, word \u2208 ((encryption s).splitOn \"   \") \u2192\n    \u2200 letter, letter \u2208 (word.splitOn \" \") \u2192\n    letter.length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encryption_case_insensitive\n  (s : String)\n  (h : \u2200 c, c \u2208 s.data \u2192 c.isUpper)\n  : encryption s = encryption s.toLower \u2227\n    encryption s = encryption s.toUpper :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n-/\n#guard_msgs in\n#eval encryption \"HELLO WORLD\"\n\n/-\ninfo: '... --- ...'\n-/\n#guard_msgs in\n#eval encryption \"SOS\"\n\n/-\ninfo: '- .... .   --.- ..- .. -.-. -.-   -... .-. --- .-- -.   ..-. --- -..-'\n-/\n#guard_msgs in\n#eval encryption \"THE QUICK BROWN FOX\""
      }
    ]
  },
  "fvapps_003253.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def word_square (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_square_length_strings_are_false {s : String}\n  (h : \u2203 n : Nat, n * n \u2260 s.length) :\n  word_square s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countChar (c : Char) (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (s.filter (fun x => x = c)).length"
      },
      {
        "type": "sig",
        "string": "def count_odd_occurrences (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let chars := s.toList\n  let counts := chars.map (fun c => countChar c chars)\n  (counts.filter (fun n => n % 2 = 1)).length"
      },
      {
        "type": "cond",
        "string": "theorem all_same_letter_square_strings_are_valid (n : Nat) :\n  word_square (String.mk (List.replicate (n*n) 'A')) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alternating_letters_within_bounds (n : Nat) (h : n \u2265 2) :\n  let letters := List.replicate (n*n) 'A'\n  word_square (String.mk letters) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_count_characters_within_bounds (s : String) :\n  let n := s.length\n  if n*n \u2260 s.length then\n    word_square s = false\n  else\n    word_square s = (count_odd_occurrences s \u2264 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"SATORAREPOTENETOPERAROTAS\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval word_square \"NOTSQUARE\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval word_square \"CARDAREAREARDART\""
      }
    ]
  },
  "fvapps_003256.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def circle_area (radius : Float) : Option Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pi : Float := 3.14159"
      },
      {
        "type": "cond",
        "string": "theorem circle_area_invalid_inputs {x : Float} (h : x \u2264 0) :\n  circle_area x = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circle_area_positive_inputs {x : Float} (h : x > 0) :\n  match circle_area x with\n  | some result =>\n    result > 0\n  | none => False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem circle_area_zero :\n  circle_area 0 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area 0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circle_area \"An integer\"\n\n/-\ninfo: 12.57\n-/\n#guard_msgs in\n#eval circle_area 2"
      }
    ]
  },
  "fvapps_003262.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Result := String\nderiving Repr, BEq"
      },
      {
        "type": "sig",
        "string": "def alphabet_war (s : String) : Result :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def alphabet_war_valid_result (s : String) :\n  let result := alphabet_war s\n  result = \"Left side wins!\" \u2228 result = \"Right side wins!\" \u2228 result = \"Let's fight again!\" :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def only_left_letters_never_right (s : String) :\n  (\u2200 c \u2208 s.data, c \u2208 ['w', 'p', 'b', 's']) \u2192\n  s.length > 0 \u2192\n  alphabet_war s \u2260 \"Right side wins!\" :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def only_right_letters_never_left (s : String) :\n  (\u2200 c \u2208 s.data, c \u2208 ['m', 'q', 'd', 'z']) \u2192\n  s.length > 0 \u2192\n  alphabet_war s \u2260 \"Left side wins!\" :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def only_bombs_is_draw (s : String) :\n  (\u2200 c \u2208 s.data, c = '*') \u2192\n  s.length > 0 \u2192\n  alphabet_war s = \"Let's fight again!\" :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def adjacent_bomb_nullifies (c : Char) :\n  c \u2208 ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z'] \u2192\n  alphabet_war (String.mk ['*', c]) = \"Let's fight again!\" \u2227\n  alphabet_war (String.mk [c, '*']) = \"Let's fight again!\" :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def repeated_string_same_winner (s : String) :\n  (\u2200 c \u2208 s.data, c \u2208 ['w', 'p', 'b', 's', 'm', 'q', 'd', 'z']) \u2192\n  s.length > 0 \u2192\n  alphabet_war s = alphabet_war (s ++ s) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Right side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"z\"\n\n/-\ninfo: \"Let's fight again!\"\n-/\n#guard_msgs in\n#eval alphabet_war \"z*dq*mw*pb*s\"\n\n/-\ninfo: 'Left side wins!'\n-/\n#guard_msgs in\n#eval alphabet_war \"sz**z**zs\""
      }
    ]
  },
  "fvapps_003264.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def next_higher (start_value k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_part (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def qualified : Nat \u2192 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_part_properties {n : Nat} (hn : n > 0 \u2227 n \u2264 1000) :\n  sum_part n \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003267.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_average (marks: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_minimum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_in_bounds {marks: List Nat} (h: marks \u2260 []) :\n  let avg := get_average marks\n  avg \u2264 list_maximum marks \u2227 avg \u2265 list_minimum marks :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_equals_div_sum {marks: List Nat} (h: marks \u2260 []) :\n  get_average marks = list_sum marks / marks.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_error :\n  get_average [] = get_average [] \u2192 False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_average [2, 2, 2, 2]\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval get_average [1, 5, 87, 45, 8, 8]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval get_average [2, 5, 13, 20, 16, 16, 10]"
      }
    ]
  },
  "fvapps_003268.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def code_for_same_protein (seq1 : String) (seq2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_sequences_match\n  (seq : String) :\n  code_for_same_protein seq seq = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def repeat_str (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "match n with\n| 0 => \"\"\n| n+1 => s ++ repeat_str s n"
      },
      {
        "type": "cond",
        "string": "theorem different_length_no_match\n  (n : Nat) :\n  code_for_same_protein (repeat_str \"ATG\" n) (repeat_str \"ATG\" (n + 1)) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_length_sequences_no_match\n  (seq1 seq2 : String) :\n  seq1.length \u2260 seq2.length \u2192\n  code_for_same_protein seq1 seq2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem code_for_same_protein_reflexive\n  (seq : String) :\n  code_for_same_protein seq seq = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem code_for_same_protein_symmetric\n  (seq1 seq2 : String) :\n  code_for_same_protein seq1 seq2 = true \u2192\n  code_for_same_protein seq2 seq1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTCGTCAATTTAA\" \"ATGTCGTCAATTTAA\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGTTCTAA\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval code_for_same_protein \"ATGTTTTAA\" \"ATGATATAA\""
      }
    ]
  },
  "fvapps_003270.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (sum gcd : Nat) : Option (Nat \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- For any x,y > 0:\n-- If solve returns None, then sum not divisible by gcd\n-- If solve returns Some (a,b), then:\n--   a + b = sum, gcd(a,b) = gcd, a \u2264 b"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_properties (x y : Nat) (h1: x > 0) (h2: y > 0) :\n  let s := x + y\n  let g := gcd x y\n  match solve s g with\n  | none => s % g \u2260 0\n  | some (a, b) => a + b = s \u2227 gcd a b = g \u2227 a \u2264 b\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For any x > 0:\n-- solve(2x, x) = (x,x)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_same_number (x : Nat) (h: x > 0) :\n  solve (2*x) x = some (x, x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 3]\n-/\n#guard_msgs in\n#eval solve 6 3\n\n/-\ninfo: [2, 6]\n-/\n#guard_msgs in\n#eval solve 8 2\n\n/-\ninfo: [4, 8]\n-/\n#guard_msgs in\n#eval solve 12 4"
      }
    ]
  },
  "fvapps_003273.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def f (x : \u03b1) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For positive integers, f(n) equals the sum of numbers from 1 to n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem positive_integers_sum {n : Nat} (h : n > 0) :\n  f n = some (n * (n + 1) / 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For non-positive integers, f returns none -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem non_positive_returns_none {n : Int} (h : n \u2264 0) :\n  f n = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For non-integer numeric inputs, f returns none -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem non_integer_returns_none (x : Float) :\n  f x = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any non-numeric type \u03b1, f returns none -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem non_numeric_returns_none (\u03b1 : Type) (x : \u03b1) :\n  f x = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- f handles large inputs without overflow -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem handles_large_inputs (n : Nat) :\n  f n \u2260 none \u2192 \u2203 m : Nat, f n = some m \u2227 m > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 5050\n-/\n#guard_msgs in\n#eval f 100\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval f 0\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval f 3.14"
      }
    ]
  },
  "fvapps_003275.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.strip (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def array (s : String) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper functions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def joinWithSpaces (xs : List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Main theorems that match property tests -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem array_none_when_not_enough_commas (s : String) :\n  s.count ',' < 2 \u2192\n  array s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_processes_middle_elements (s : String) :\n  s.count ',' \u2265 2 \u2192\n  array s = some (joinWithSpaces (List.map String.strip (List.drop 1 (List.take (List.length (String.splitOn \",\" s) - 1) (String.splitOn \",\" s))))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval array \"1,2\"\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval array \"1,2,3\"\n\n/-\ninfo: '2 3'\n-/\n#guard_msgs in\n#eval array \"1,2,3,4\""
      }
    ]
  },
  "fvapps_003277.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def snail (column : Int) (day : Int) (night : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to simulate ceiling division"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def ceilDiv (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem snail_result_positive {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night \u2265 0) :\n  snail column day night \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem snail_reaches_top {column day night : Int}\n  (h1 : column > 0)\n  (h2 : day > night)\n  (h3 : day > 0)\n  (h4 : night \u2265 0) :\n  let result := snail column day night\n  (result * day) - ((result-1) * night) \u2265 column :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval snail 3 2 1\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval snail 10 3 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval snail 5 10 3"
      }
    ]
  },
  "fvapps_003283.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isSubsequence (smaller larger : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve (n : Nat) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_properties {n k : Nat} (h : k < (ToString.toString n).length) :\n  let result := solve n k\n  (result.length = (ToString.toString n).length - k) \u2227\n  (isSubsequence result (ToString.toString n) = true) \u2227\n  (result.toNat! \u2264 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_zero_digits (n : Nat) :\n  solve n 0 = ToString.toString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_minimal {n k : Nat} (h1 : n \u2265 10) (h2 : k \u2265 1) (h3 : k < (ToString.toString n).length) :\n  let result := solve n k\n  \u2200 (s : String),\n    isSubsequence s (ToString.toString n) = true \u2192\n    s.length = (ToString.toString n).length - k \u2192\n    result.toNat! \u2264 s.toNat! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '05'\n-/\n#guard_msgs in\n#eval solve 123056 4\n\n/-\ninfo: '12456'\n-/\n#guard_msgs in\n#eval solve 1284569 2\n\n/-\ninfo: '12056'\n-/\n#guard_msgs in\n#eval solve 123056 1"
      }
    ]
  },
  "fvapps_003284.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def factorial : Nat \u2192 Nat\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n"
      },
      {
        "type": "sig",
        "string": "def List.prod : List Nat \u2192 Nat\n  | [] => 1\n  | x :: xs => x * prod xs\n\ndef isAscii (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def uniq_count (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_count_positive (s : String) :\n  uniq_count s > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_count_empty :\n  uniq_count \"\" = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_count_factorial_bound (s : String) :\n  uniq_count s \u2264 factorial s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_count_unique_chars {s : String} (h\u2081 : s \u2260 \"\")\n  (h\u2082 : (s.toLower.data.eraseDups).length = s.length) :\n  uniq_count s = factorial s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval uniq_count \"ABC\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval uniq_count \"ABA\"\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval uniq_count \"AbcD\""
      }
    ]
  },
  "fvapps_003285.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def common_ground (s1 s2 : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def split (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem common_ground_subset (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result \u2260 \"death\" \u2192\n  (\u2200 w, w \u2208 split result \u2192\n    w \u2208 split s1 \u2227 w \u2208 split s2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem common_ground_order (s1 s2 : String) :\n  let result := common_ground s1 s2\n  result \u2260 \"death\" \u2192\n  \u2200 i j, i < j \u2192 i < (split result).length \u2192 j < (split result).length \u2192\n    let s2_words := split s2\n    let result_words := split result\n    s2_words.findIdx (\u00b7 = result_words[i]!) <\n    s2_words.findIdx (\u00b7 = result_words[j]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem common_ground_no_overlap (s1 s2 : String) :\n  (\u2200 w1 w2, w1 \u2208 split s1 \u2192 w2 \u2208 split s2 \u2192 w1 \u2260 w2) \u2192\n  common_ground s1 s2 = \"death\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'eat chicken'\n-/\n#guard_msgs in\n#eval common_ground \"eat chicken\" \"eat chicken and rice\"\n\n/-\ninfo: 'drink a coke'\n-/\n#guard_msgs in\n#eval common_ground \"eat a burger and drink a coke\" \"drink a coke\"\n\n/-\ninfo: 'death'\n-/\n#guard_msgs in\n#eval common_ground \"i like turtles\" \"what are you talking about\""
      }
    ]
  },
  "fvapps_003292.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def scramble (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to count char occurrences in string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- If scramble returns true, first string is at least as long as second"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_length_property (s1 s2 : String) :\n  s1.length > 0 \u2192 s2.length > 0 \u2192 scramble s1 s2 = true \u2192 s1.length \u2265 s2.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- A string can always be scrambled to form itself"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_identical_strings (s : String) :\n  s.length > 0 \u2192 scramble s s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- If scramble is true, all chars in s2 appear at least as many times in s1"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_subset_property (s1 s2 : String) (c : Char) :\n  s1.length > 0 \u2192 s2.length > 0 \u2192 scramble s1 s2 = true \u2192\n  (countChar s2 c) \u2264 (countChar s1 c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Any non-empty string can be scrambled to form empty string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_empty_second_string (s : String) :\n  s.length > 0 \u2192 scramble s \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty string cannot form non-empty string"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_empty_first_string (c : Char) :\n  scramble \"\" (String.singleton c) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Strings with disjoint character sets cannot be scrambled"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem scramble_disjoint_alphabets (s1 s2 : String) :\n  s1.length > 0 \u2192 s2.length > 0 \u2192\n  (\u2200 c, s1.contains c \u2192 \u00acs2.contains c) \u2192\n  scramble s1 s2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"rkqodlw\" \"world\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval scramble \"cedewaraaossoqqyt\" \"codewars\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval scramble \"katas\" \"steak\""
      }
    ]
  },
  "fvapps_003293.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_consonants (s : List Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isConsonant (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def toLower (c : Char) : Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def toCharList (s : String) : List Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_consonants_bounds {s : List Char} :\n  0 \u2264 count_consonants s \u2227 count_consonants s \u2264 21 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_consonants_case_insensitive {s : List Char} :\n  count_consonants s = count_consonants (List.map toLower s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_consonants_letters_only {s s' : List Char}\n  (h : s' = List.filter Char.isAlpha s) :\n  count_consonants s = count_consonants s' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_consonants_vowels_only {s : List Char}\n  (h : \u2200 c, c \u2208 s \u2192 isVowel c) :\n  count_consonants s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_consonants_consonants_only {s : List Char} {n : Nat}\n  (h1 : \u2200 c, c \u2208 s \u2192 isConsonant c)\n  (h2 : n = (List.map toLower s).eraseDups.length) :\n  count_consonants s = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_consonants \"sillystring\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_consonants \"aeiou\"\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval count_consonants \"abcdefghijklmnopqrstuvwxyz\""
      }
    ]
  },
  "fvapps_003294.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def to_twos_complement (binary : String) (bits : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def from_twos_complement (n : Int) (bits : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def removeWhitespace (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem twos_complement_roundtrip (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits \u2264 64)\n  (h3 : n \u2265 -(2^(bits-1))) (h4 : n \u2264 2^(bits-1) - 1) :\n  to_twos_complement (from_twos_complement n bits) bits = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_roundtrip (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits \u2264 64)\n  (h3 : String.length binary = bits)\n  (h4 : \u2200 c \u2208 binary.data, c = '0' \u2228 c = '1') :\n  from_twos_complement (to_twos_complement binary bits) bits = binary :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bit_length (n : Int) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits \u2264 64) :\n  String.length (from_twos_complement n bits) = bits \u2227\n  (\u2200 c \u2208 (from_twos_complement n bits).data, c = '0' \u2228 c = '1') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_handling (binary : String) (bits : Nat)\n  (h1 : bits > 0) (h2 : bits \u2264 64)\n  (h3 : String.length (removeWhitespace binary) = bits)\n  (h4 : \u2200 c \u2208 (removeWhitespace binary).data, c = '0' \u2228 c = '1') :\n  to_twos_complement binary bits = to_twos_complement (removeWhitespace binary) bits :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval to_twos_complement \"00000001\" 8\n\n/-\ninfo: '00000001'\n-/\n#guard_msgs in\n#eval from_twos_complement 1 8\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval to_twos_complement \"11111111\" 8\n\n/-\ninfo: '11111111'\n-/\n#guard_msgs in\n#eval from_twos_complement -1 8\n\n/-\ninfo: -1440552402\n-/\n#guard_msgs in\n#eval to_twos_complement \"1010 1010 0010 0010 1110 1010 0010 1110\" 32\n\n/-\ninfo: '10101010001000101110101000101110'\n-/\n#guard_msgs in\n#eval from_twos_complement -1440552402 32"
      }
    ]
  },
  "fvapps_003300.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unlucky_number (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsChar (s : String) (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.any (fun x => x == c)"
      },
      {
        "type": "sig",
        "string": "def isDivisibleBy13AndNoUnluckyDigits (i : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  i % 13 == 0 &&\n  !containsChar (toString i) '4' &&\n  !containsChar (toString i) '7'"
      },
      {
        "type": "cond",
        "string": "theorem unlucky_number_non_negative (n : Nat) :\n  unlucky_number n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unlucky_number_zero :\n  unlucky_number 0 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unlucky_number_twelve :\n  unlucky_number 12 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unlucky_number_thirteen :\n  unlucky_number 13 = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval unlucky_number 20\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval unlucky_number 100\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval unlucky_number 1000"
      }
    ]
  },
  "fvapps_003305.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def extra_perfect (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (xs : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < List.length xs \u2192 xs[i]! < xs[j]!"
      },
      {
        "type": "cond",
        "string": "theorem extra_perfect_only_odd {n : Nat} :\n  \u2200 x, x \u2208 extra_perfect n \u2192 x % 2 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem extra_perfect_bounded {n : Nat} :\n  \u2200 x, x \u2208 extra_perfect n \u2192 x \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem extra_perfect_length {n : Nat} :\n  List.length (extra_perfect n) = (n + 1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem extra_perfect_binary_ones {n : Nat} :\n  \u2200 x, x \u2208 extra_perfect n \u2192\n    ((x &&& 1) = 1) \u2227\n    ((x &&& (1 <<< (Nat.log2 x))) = (1 <<< (Nat.log2 x))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003319.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def COLOR_MAP : List (String \u00d7 Nat) := [\n  (\"black\", 0), (\"brown\", 1), (\"red\", 2), (\"orange\", 3), (\"yellow\", 4),\n  (\"green\", 5), (\"blue\", 6), (\"violet\", 7), (\"gray\", 8), (\"white\", 9)\n]"
      },
      {
        "type": "sig",
        "string": "def decode_resistor_colors (bands : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.toFloat (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.containsString (s : String) (substr : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem resistor_color_format\n  (first_band second_band multiplier : String)\n  (tolerance : Option String)\n  (h1 : first_band \u2208 (COLOR_MAP.map (\u00b7.1)))\n  (h2 : second_band \u2208 (COLOR_MAP.map (\u00b7.1)))\n  (h3 : multiplier \u2208 (COLOR_MAP.map (\u00b7.1)))\n  (h4 : tolerance.getD \"\" \u2208 [\"\", \"gold\", \"silver\"]) :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier} {tolerance.getD \"\"}\".trim)\n  (result.containsString \" ohms, \") \u2227\n  (result.endsWith \"%\") \u2227\n  (result.containsString \"\" \u2228 result.containsString \"k\" \u2228 result.containsString \"M\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_value_calculation\n  (first_band second_band multiplier : String)\n  (h1 : first_band \u2208 [\"black\", \"brown\"])\n  (h2 : second_band \u2208 [\"black\", \"brown\"])\n  (h3 : multiplier = \"black\") :\n  let result := decode_resistor_colors (s!\"{first_band} {second_band} {multiplier}\")\n  let value := String.toFloat ((result.splitOn \" \").head!)\n  let expected :=\n    match COLOR_MAP.find? (\u00b7.1 = first_band), COLOR_MAP.find? (\u00b7.1 = second_band) with\n    | some (_, n1), some (_, n2) => Float.ofNat (n1 * 10 + n2)\n    | _, _ => 0.0\n  value = expected :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '47 ohms, 20%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet black\"\n\n/-\ninfo: '4.7k ohms, 5%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"yellow violet red gold\"\n\n/-\ninfo: '1M ohms, 10%'\n-/\n#guard_msgs in\n#eval decode_resistor_colors \"brown black green silver\""
      }
    ]
  },
  "fvapps_003321.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countChars (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def remove_exclamation_marks (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_exclamation_in_result (s : String) :\n  \u00ac(remove_exclamation_marks s).contains '!' := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_after_removal (s : String) :\n  (remove_exclamation_marks s).length = s.length - (countChars s '!') := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_equals_remove_exclamation (s : String) :\n  (remove_exclamation_marks s).replace \"!\" \"\" = remove_exclamation_marks s := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unchanged_without_exclamation (s : String) (h : \u00acs.contains '!') :\n  remove_exclamation_marks s = s := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem concatenation_property (s\u2081 s\u2082 : String) :\n  remove_exclamation_marks s\u2081 ++ remove_exclamation_marks s\u2082 =\n  remove_exclamation_marks (s\u2081 ++ s\u2082) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Hello World'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hello World!\"\n\n/-\ninfo: 'Hi Hello'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Hi! Hello!\"\n\n/-\ninfo: 'Oh, no'\n-/\n#guard_msgs in\n#eval remove_exclamation_marks \"Oh, no!!!\""
      }
    ]
  },
  "fvapps_003329.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def halving_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any positive n, halving_sum(n) is at least n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem halving_sum_lower_bound (n : Nat) (h : n > 0) :\n  halving_sum n \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any positive n, halving_sum(n) is less than 2*n -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem halving_sum_upper_bound (n : Nat) (h : n > 0) :\n  halving_sum n < 2*n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For powers of 2, halving_sum(n) equals 2*n - 1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem halving_sum_power_of_two (n : Nat) (h : n > 0)\n  (h_pow : \u2203 k, n = 2^k) :\n  halving_sum n = 2*n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Base cases for n=1 and n=2 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem halving_sum_base_cases :\n  (halving_sum 1 = 1) \u2227 (halving_sum 2 = 3) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 47\n-/\n#guard_msgs in\n#eval halving_sum 25\n\n/-\ninfo: 247\n-/\n#guard_msgs in\n#eval halving_sum 127\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval halving_sum 1"
      }
    ]
  },
  "fvapps_003332.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_key (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_key_edge_cases :\n  find_key \"0\" = 0 \u2227 find_key \"1\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1080\n-/\n#guard_msgs in\n#eval find_key \"47b\"\n\n/-\ninfo: 9328\n-/\n#guard_msgs in\n#eval find_key \"2533\"\n\n/-\ninfo: 6912\n-/\n#guard_msgs in\n#eval find_key \"1ba9\""
      }
    ]
  },
  "fvapps_003335.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidKey (k : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def encode (text key : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem encode_preserves_non_letters (text key : String) :\n  isValidKey key \u2192 \u2200 i, \u00ac(text.get! i).isAlpha \u2192\n  (encode text key).get! i = text.get! i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encode_preserves_case (text key : String) :\n  isValidKey key \u2192 \u2200 i,\n  let c := text.get! i\n  let e := (encode text key).get! i\n  c.isAlpha \u2192 (c.isUpper = e.isUpper) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encode_duplicate_key_chars (text key : String) :\n  isValidKey key \u2192\n  encode text key = encode text (String.mk (key.data.eraseDups)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cipher\"\n\n/-\ninfo: 'ihrbfj'\n-/\n#guard_msgs in\n#eval encode \"cipher\" \"cccciiiiippphheeeeerrrrr\""
      }
    ]
  },
  "fvapps_003336.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def present (x : String) (y : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem present_goodpresent_length (y : Int) :\n  String.length (present \"goodpresent\" y) = String.length \"goodpresent\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidInput (x : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  x = \"goodpresent\" \u2228 x = \"crap\" \u2228 x = \"empty\" \u2228 x = \"bang\" \u2228 x = \"badpresent\" \u2228 x = \"dog\""
      },
      {
        "type": "cond",
        "string": "theorem present_crap_fixed (y : Int) :\n  present \"crap\" y = \"acpr\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem present_empty_fixed (y : Int) :\n  present \"empty\" y = \"empty\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem present_badpresent_fixed (y : Int) :\n  present \"badpresent\" y = \"Take this back!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem present_dog_contains_number (y : Int) :\n  \u2203 s : String, s = toString y \u2227 present \"dog\" y = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem present_invalid_input (x : String) (h : \u00acisValidInput x) :\n  \u2203 err, present x 0 = err :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Take this back!'\n-/\n#guard_msgs in\n#eval present \"badpresent\" 3\n\n/-\ninfo: 'pxxmy{n|nw}'\n-/\n#guard_msgs in\n#eval present \"goodpresent\" 9\n\n/-\ninfo: 'pass out from excitement 23 times'\n-/\n#guard_msgs in\n#eval present \"dog\" 23"
      }
    ]
  },
  "fvapps_003342.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maximum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sorted (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max_gap (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_positive (xs : List Int) (h : xs.length \u2265 2) :\n  max_gap xs \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_bounded_by_range (xs : List Int) (h : xs.length \u2265 2) :\n  max_gap xs \u2264 maximum xs - minimum xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_in_consecutive_diffs (xs : List Int) (h : xs.length \u2265 2) :\n  \u2203 i : Nat, i < xs.length - 1 \u2227\n    max_gap xs = (sorted xs).get \u27e8i+1, sorry\u27e9 - (sorted xs).get \u27e8i, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_reversal_invariant (xs : List Int) (h : xs.length \u2265 2) :\n  max_gap xs = max_gap xs.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_nonnegative_bounded (xs : List Int) (h : xs.length \u2265 2)\n  (h2 : \u2200 x \u2208 xs, x \u2265 0) :\n  max_gap xs \u2264 maximum xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_gap_translation_invariant (xs : List Int) (c : Int) (h : xs.length \u2265 2) :\n  max_gap xs = max_gap (xs.map (\u00b7 + c)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval max_gap [13, 10, 2, 9, 5]\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval max_gap [-3, -27, -4, -2]\n\n/-\ninfo: 576\n-/\n#guard_msgs in\n#eval max_gap [-54, 37, 0, 64, -15, 640, 0]"
      }
    ]
  },
  "fvapps_003343.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_password (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_password_conditions (s : String) :\n  (s.length \u2265 8) \u2192\n  (\u2203 c, c \u2208 s.data \u2227 isLower c) \u2192\n  (\u2203 c, c \u2208 s.data \u2227 isUpper c) \u2192\n  (\u2203 c, c \u2208 s.data \u2227 isDigit c) \u2192\n  is_valid_password s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_password_too_short (s : String) :\n  s.length < 8 \u2192\n  is_valid_password s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_password_no_upper (s : String) :\n  s.length \u2265 8 \u2192\n  (\u00ac\u2203 c, c \u2208 s.data \u2227 isUpper c) \u2192\n  is_valid_password s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_password_no_lower (s : String) :\n  s.length \u2265 8 \u2192\n  (\u00ac\u2203 c, c \u2208 s.data \u2227 isLower c) \u2192\n  is_valid_password s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_password_no_digit (s : String) :\n  s.length \u2265 8 \u2192\n  (\u00ac\u2203 c, c \u2208 s.data \u2227 isDigit c) \u2192\n  is_valid_password s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_password_invalid :\n  is_valid_password \"\" = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem short_password_invalid :\n  is_valid_password \"aA1\" = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_min_length_password :\n  is_valid_password \"aaaaA111\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd1234\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"Abcd123\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_password \"abcd1234\""
      }
    ]
  },
  "fvapps_003347.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def quotable (name : String) (quote : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Property: Output contains both inputs and format is consistent -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem quotable_format (name quote : String)\n  (h1 : \u00ac String.contains name '\"')\n  (h2 : \u00ac String.contains quote '\"') :\n  (quotable name quote).startsWith name \u2227\n  (quotable name quote).endsWith ('\"'.toString ++ quote ++ '\"'.toString) \u2227\n  String.contains (quotable name quote) ' ' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Property: Quotes appear in correct places only -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem quotable_quotes_placement (name quote : String)\n  (h1 : \u00ac String.contains name '\"')\n  (h2 : \u00ac String.contains quote '\"') :\n  ((quotable name quote).data.filter (\u00b7 = '\"')).length = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Property: Function is deterministic -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem quotable_deterministic (name quote : String) :\n  quotable name quote = quotable name quote :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'Grae said: \"Practice makes perfect\"'\n-/\n#guard_msgs in\n#eval quotable \"Grae\" \"Practice makes perfect\"\n\n/-\ninfo: 'Alex said: \"Python is great fun\"'\n-/\n#guard_msgs in\n#eval quotable \"Alex\" \"Python is great fun\"\n\n/-\ninfo: 'Bethany said: \"Yes, way more fun than R\"'\n-/\n#guard_msgs in\n#eval quotable \"Bethany\" \"Yes, way more fun than R\""
      }
    ]
  },
  "fvapps_003349.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_seconds (time_str : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def longest_possible (seconds : Int) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def song_durations : List String :="
      },
      {
        "type": "impl",
        "string": "  [\"03:36\", \"06:48\", \"04:27\", \"03:50\", \"04:32\", \"04:22\", \"03:30\", \"03:25\", \"04:34\"]"
      },
      {
        "type": "cond",
        "string": "theorem calculate_seconds_basic_properties {minutes seconds : Nat}\n  (h1 : minutes \u2264 59) (h2 : seconds \u2264 59) :\n  (calculate_seconds s!\"{minutes}:{seconds}\" = minutes * 60 + seconds) \u2227\n  (calculate_seconds s!\"{minutes}:{seconds}\" \u2265 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem longest_possible_properties (seconds : Int) :\n  match longest_possible seconds with\n  | some result =>\n    result \u2208 song_durations \u2227\n    calculate_seconds result \u2264 seconds \u2227\n    \u2200 s \u2208 song_durations,\n      calculate_seconds s \u2264 seconds \u2192\n      calculate_seconds s \u2264 calculate_seconds result\n  | none =>\n    \u2200 duration \u2208 song_durations,\n      calculate_seconds duration > seconds :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'For Reasons Unknown'\n-/\n#guard_msgs in\n#eval longest_possible 215\n\n/-\ninfo: 'YYZ'\n-/\n#guard_msgs in\n#eval longest_possible 270\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval longest_possible 13\n\n/-\ninfo: 'Surfing With The Alien'\n-/\n#guard_msgs in\n#eval longest_possible 300"
      }
    ]
  },
  "fvapps_003350.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def valid_mersenne (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_mersenne_returns_bool (n : Int) :\n  valid_mersenne n = true \u2228 valid_mersenne n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def valid_mersenne_numbers : List Int :="
      },
      {
        "type": "impl",
        "string": "  [2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279]"
      },
      {
        "type": "cond",
        "string": "theorem valid_mersenne_outside_range {n : Int} :\n  (n < 1 \u2228 n > 1279) \u2192 valid_mersenne n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_mersenne_deterministic (n : Int) :\n  valid_mersenne n = valid_mersenne n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_mersenne_in_set {n : Int} :\n  1 \u2264 n \u2227 n \u2264 1279 \u2192\n  valid_mersenne n = true \u2194 n \u2208 valid_mersenne_numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 3\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval valid_mersenne 11\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval valid_mersenne 127"
      }
    ]
  },
  "fvapps_003355.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def cog_RPM (cogs: List Nat) (n: Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For accessing array elements safely -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def get? {\u03b1 : Type} (xs : List \u03b1) (i : Nat) : Option \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  if h : i < xs.length then some (xs.get \u27e8i, h\u27e9) else none"
      },
      {
        "type": "cond",
        "string": "theorem single_cog_property {cogs : List Nat} {n : Nat} (h : cogs.length = 1) :\n  cog_RPM cogs 0 = [1, 1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cog_direction_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length) :\n  \u2203 x y : Int, cog_RPM cogs n = [x, y] \u2227\n  ((x > 0) \u2194 (n % 2 = 0)) \u2227\n  ((y > 0) \u2194 ((cogs.length - n) % 2 = 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cog_ratio_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : \u2200 i, get? cogs i \u2260 none) :\n  match get? cogs n, get? cogs 0, get? cogs (cogs.length - 1) with\n  | some cn, some c0, some cl =>\n    \u2203 x y : Int, cog_RPM cogs n = [x, y] \u2227\n    x.natAbs = cn / c0 \u2227\n    y.natAbs = cn / cl\n  | _, _, _ => True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_cogs_property {cogs : List Nat} {n : Nat}\n  (h1 : cogs.length > 1) (h2 : n < cogs.length)\n  (h3 : \u2200 i j, i < cogs.length \u2192 j < cogs.length \u2192 get? cogs i = get? cogs j) :\n  \u2203 x y : Int, cog_RPM cogs n = [x, y] \u2227\n  x.natAbs = 1 \u2227 y.natAbs = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100] 0\n\n/-\ninfo: [1, -1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 0\n\n/-\ninfo: [-1, 1]\n-/\n#guard_msgs in\n#eval cog_RPM [100, 100, 100, 100] 1"
      }
    ]
  },
  "fvapps_003356.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isEven (x : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isFloat (x : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isEvenFloat (x : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem even_plus_two (x : Int) :\n  isEven x = isEven (x + 2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem even_plus_one_diff (x : Int) :\n  isEven x \u2260 isEven (x + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem times_two_even (x : Int) :\n  isEven (x * 2) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_integer_float_not_even (x : Float) :\n  \u00acisFloat x \u2192 isEvenFloat x = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_even 2\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_even 0.5"
      }
    ]
  },
  "fvapps_003361.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def morse_converter (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def convertToMorse (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem morse_converter_output_valid (s : String) :\n  let result := morse_converter s\n  result \u2265 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 11111\n-/\n#guard_msgs in\n#eval morse_converter \".----.----.----.----.----\"\n\n/-\ninfo: 207600\n-/\n#guard_msgs in\n#eval morse_converter \"..----------...-....----------\"\n\n/-\ninfo: 1234567890\n-/\n#guard_msgs in\n#eval morse_converter \".----..---...--....-.....-....--...---..----.-----\""
      }
    ]
  },
  "fvapps_003376.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ski_jump (mountain: List String) : String := sorry\n\ndef isValidMessage (msg: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  msg = \"He's crap!\" || msg = \"He's ok!\" || msg = \"He's flying!\" || msg = \"Gold!!\""
      },
      {
        "type": "sig",
        "string": "def stringToFloat (s: String) : Float := sorry -- helper function"
      },
      {
        "type": "cond",
        "string": "theorem ski_jump_output_format {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let parts := result.splitOn \" metres: \"\n  parts.length = 2 \u2227\n  (let number := parts[0]!\n   let message := parts[1]!\n   stringToFloat number \u2265 0 \u2227\n   isValidMessage message) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem jump_length_proportional_to_height {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let jumpLength := stringToFloat (result.splitOn \" metres: \")[0]!\n  jumpLength = Float.ofNat mountain.length * (Float.ofNat mountain.length * 1.5) * 0.9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem message_thresholds {mountain : List String} (h : mountain.length > 0) :\n  let result := ski_jump mountain\n  let length := stringToFloat (result.splitOn \" metres: \")[0]!\n  let message := (result.splitOn \"metres: \")[1]!\n  (length < 10 \u2192 message = \"He's crap!\") \u2227\n  (length \u2265 10 \u2227 length < 25 \u2192 message = \"He's ok!\") \u2227\n  (length \u2265 25 \u2227 length < 50 \u2192 message = \"He's flying!\") \u2227\n  (length \u2265 50 \u2192 message = \"Gold!!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: \"1.35 metres: He's crap!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\"]\n\n/-\ninfo: \"12.15 metres: He's ok!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\", \"**\", \"***\"]\n\n/-\ninfo: \"48.60 metres: He's flying!\"\n-/\n#guard_msgs in\n#eval ski_jump [\"*\", \"**\", \"***\", \"****\", \"*****\", \"******\"]"
      }
    ]
  },
  "fvapps_003378.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countInversion (s : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (s : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAntiSorted (s : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countInversion_nonnegative (s : List Int) :\n  countInversion s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countInversion_sorted_zero (s : List Int) :\n  isSorted s = true \u2192 countInversion s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countInversion_reverse_sorted_max (s : List Int) :\n  let maxInv := s.length * (s.length - 1) / 2\n  isAntiSorted s = true \u2192 countInversion s \u2264 maxInv :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem countInversion_small_seq (s : List Int) :\n  s.length \u2264 1 \u2192 countInversion s = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_inversion (1, 2, 5, 3, 4, 7, 6)\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_inversion (0, 1, 2, 3)\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval count_inversion (3, 2, 1, 0)"
      }
    ]
  },
  "fvapps_003381.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (text : String) (k : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_char_indices (s : String) (c : Char) : List Nat := sorry\n\ndef List.sorted (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192\n  match l.get? i, l.get? j with\n  | some vi, some vj => vi \u2264 vj\n  | _, _ => True"
      },
      {
        "type": "cond",
        "string": "theorem solve_result_length (text : String) (k : Nat) (h : text.length > 0) :\n  (solve text k).length = max 0 (text.length - min k text.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_chars_from_original (text : String) (k : Nat) (h : text.length > 0) :\n  \u2200 c, c \u2208 (solve text k).data \u2192 c \u2208 text.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_maintains_order (text : String) (k : Nat) (h : text.length > 0) :\n  \u2200 c, c \u2208 (solve text k).data \u2192\n    let result_indices := get_char_indices (solve text k) c\n    let orig_indices := get_char_indices text c\n    List.sorted result_indices :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_k_zero (text : String) (h : text.length > 0) :\n  solve text 0 = text :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_k_length (text : String) (h : text.length > 0) :\n  solve text text.length = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'bracadabra'\n-/\n#guard_msgs in\n#eval solve \"abracadabra\" 1\n\n/-\ninfo: 'rcdbr'\n-/\n#guard_msgs in\n#eval solve \"abracadabra\" 6\n\n/-\ninfo: 'cccbbabaccbc'\n-/\n#guard_msgs in\n#eval solve \"cccaabababaccbc\" 3"
      }
    ]
  },
  "fvapps_003386.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_positive (nums : List Nat)\n  (h : \u2200 x \u2208 nums, x > 0 \u2227 x \u2264 1000)\n  : solve nums > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sums (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def findMin (s : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sortList (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_order_invariant (nums : List Nat)\n  (h : \u2200 x \u2208 nums, x > 0 \u2227 x \u2264 100)\n  : solve nums = solve (sortList nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_is_min_missing_sum {nums : List Nat}\n  (h : \u2200 x \u2208 nums, x > 0 \u2227 x \u2264 10)\n  (h2 : nums.length \u2264 5)\n  : solve nums = findMin (sums nums) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003389.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (chips : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n| [] => 0\n| x::xs => x + listSum xs"
      },
      {
        "type": "sig",
        "string": "def listMin : List Nat \u2192 Nat\n| [] => 0\n| [x] => x\n| x::xs => min x (listMin xs)"
      },
      {
        "type": "sig",
        "string": "def secondMin : List Nat \u2192 Nat\n| [] => 0\n| [_] => 0\n| l =>\n  let m := listMin l\n  listMin (l.filter (fun x => x \u2260 m))"
      },
      {
        "type": "cond",
        "string": "theorem solve_two_identical_bounded (a b : Nat)\n  (h\u2081 : a > 0)\n  (h\u2082 : b > 0) :\n  solve [a, a, b] \u2264 (a + a + b) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve [1, 1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [1, 2, 1]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve [8, 2, 8]"
      }
    ]
  },
  "fvapps_003400.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def proc_seq : List Nat \u2192 List Nat\n  | xs => sorry\n\ndef countPermNoLeadingZero (n : Nat) (m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem proc_seq_valid_output (nums : List Nat) :\n  let result := proc_seq nums\n  (result.length = 2 \u2228 result.length = 4) \u2227\n  (\u2200 x \u2208 result, x \u2265 0) \u2227\n  (result.length = 2 \u2192 result.head! = 1) \u2227\n  (result.length = 4 \u2192\n    result[1]! \u2264 result[2]! \u2227 result[1]! \u2264 result[3]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem proc_seq_leading_zeros (n : Nat) (h : n \u2265 100 \u2227 n \u2264 999) :\n  let result := proc_seq [n, 0]\n  result.head! = countPermNoLeadingZero n 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem proc_seq_small_nums {nums : List Nat} (h : 2 \u2264 nums.length \u2227 nums.length \u2264 3)\n  (h' : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 9) :\n  let result := proc_seq nums\n  (result.length = 2 \u2228 result.length = 4) \u2227\n  (\u2200 x \u2208 result, x \u2265 0) \u2227\n  (result.length = 2 \u2192 result.head! = 1) \u2227\n  (result.length = 4 \u2192\n    result[1]! \u2264 result[2]! \u2227 result[1]! \u2264 result[3]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [8, 218, 379, 2388]\n-/\n#guard_msgs in\n#eval proc_seq 23 17 89\n\n/-\ninfo: [1, 2222]\n-/\n#guard_msgs in\n#eval proc_seq 22 22 22 22\n\n/-\ninfo: [4, 218, 358, 1152]\n-/\n#guard_msgs in\n#eval proc_seq 230 15 8"
      }
    ]
  },
  "fvapps_003405.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count {\u03b1} [BEq \u03b1] (a : \u03b1) (xs : List \u03b1) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve {\u03b1} [BEq \u03b1] (array1 array2 : List \u03b1) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_properties {\u03b1} [BEq \u03b1] (array1 array2 : List \u03b1)\n  (h1 : array1 \u2260 []) (h2 : array2 \u2260 []) :\n  let result := solve array1 array2;\n  -- Length matches\n  result.length = array2.length\n  -- All counts are non-negative (satisfied by Nat type)\n  -- Each count matches actual occurrences\n  \u2227 (\u2200 i elem, i < array2.length \u2192 array2.get \u27e8i, by sorry\u27e9 = elem \u2192\n      result.get \u27e8i, by sorry\u27e9 = count elem array1)\n  -- Count cannot exceed length of array1\n  \u2227 \u2200 x \u2208 result, x \u2264 array1.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_identical_arrays {\u03b1} [BEq \u03b1] (array : List \u03b1)\n  (h : array \u2260 []) :\n  let result := solve array array;\n  \u2200 i c x, i < array.length \u2192\n    result.get \u27e8i, by sorry\u27e9 = c \u2192\n    array.get \u27e8i, by sorry\u27e9 = x \u2192\n    c = count x array :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_unique_array2 {\u03b1} [BEq \u03b1] (array1 array2 : List \u03b1)\n  (h1 : array1 \u2260 []) (h2 : array2 \u2260 [])\n  (unique : \u2200 i j, i < array2.length \u2192 j < array2.length \u2192 i \u2260 j \u2192\n    array2.get \u27e8i, by sorry\u27e9 \u2260 array2.get \u27e8j, by sorry\u27e9) :\n  solve array1 array2 = array2.map (\u03bb x => count x array1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [2, 1, 0]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"abc\", \"xyz\", \"abcd\", \"cde\"] [\"abc\", \"cde\", \"uap\"]\n\n/-\ninfo: [2, 1, 2]\n-/\n#guard_msgs in\n#eval solve [\"abc\", \"xyz\", \"abc\", \"xyz\", \"cde\"] [\"abc\", \"cde\", \"xyz\"]\n\n/-\ninfo: [2, 0, 1]\n-/\n#guard_msgs in\n#eval solve [\"quick\", \"brown\", \"fox\", \"is\", \"quick\"] [\"quick\", \"abc\", \"fox\"]"
      }
    ]
  },
  "fvapps_003406.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def doors (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem doors_non_negative (n : Nat) :\n  doors n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem doors_squared_leq (n : Nat) :\n  (doors n) * (doors n) \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem doors_plus_one_squared_gt (n : Nat) :\n  (doors n + 1) * (doors n + 1) > n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem doors_perfect_squares (n : Nat) :\n  doors (n * n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval doors 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval doors 10\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval doors 100"
      }
    ]
  },
  "fvapps_003407.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def greatest (x y n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def smallest (x y n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem divisible_by_inputs {x y n : Nat} (hx : x > 0) (hy : y > 0) :\n  let g := greatest x y (max x y * 2)\n  let s := smallest x y (max x y * 2)\n  g % x = 0 \u2227 g % y = 0 \u2227 s % x = 0 \u2227 s % y = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bounds {x y n : Nat} (hx : x > 0) (hy : y > 0) (hn : n > 0) :\n  let g := greatest x y n\n  let s := smallest x y n\n  g < n \u2227 s > n \u2227 s > g :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval greatest 2 3 20\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval smallest 2 3 20\n\n/-\ninfo: 90\n-/\n#guard_msgs in\n#eval greatest 5 15 100\n\n/-\ninfo: 105\n-/\n#guard_msgs in\n#eval smallest 5 15 100\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval greatest 123 456 789\n\n/-\ninfo: 18696\n-/\n#guard_msgs in\n#eval smallest 123 456 789"
      }
    ]
  },
  "fvapps_003409.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.lower : String \u2192 String :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry"
      },
      {
        "type": "sig",
        "string": "def String.swapcase : String \u2192 String :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry"
      },
      {
        "type": "sig",
        "string": "def Char.swapcase : Char \u2192 Char :="
      },
      {
        "type": "impl",
        "string": "  fun _ => sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s\u2081 s\u2082 : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def work_on_strings (s\u2081 s\u2082 : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_length (a b : String) :\n  (work_on_strings a b).length = a.length + b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_substring_lengths (a b : String) :\n  let result := work_on_strings a b\n  (result.take a.length).length = a.length \u2227\n  (result.drop a.length).length = b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_case_swap_first (a b : String) (i : String.Pos) :\n  let result := work_on_strings a b\n  let base := result.get i\n  (b.lower.count (toString base).lower) % 2 = 1 \u2192\n  result = result.set i (base.swapcase) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_case_swap_second (a b : String) (i : String.Pos) :\n  let result := work_on_strings a b\n  let base := result.get i\n  (a.lower.count (toString base).lower) % 2 = 1 \u2192\n  result = result.set i (base.swapcase) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_empty (s : String) :\n  work_on_strings \"\" s = s \u2227\n  work_on_strings s \"\" = s \u2227\n  work_on_strings \"\" \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem work_on_strings_idempotent (s : String) :\n  let result := work_on_strings s s\n  work_on_strings s s = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abCCde'\n-/\n#guard_msgs in\n#eval work_on_strings \"abc\" \"cde\"\n\n/-\ninfo: 'ABABbababa'\n-/\n#guard_msgs in\n#eval work_on_strings \"abab\" \"bababa\"\n\n/-\ninfo: 'abcDEfgDEFGg'\n-/\n#guard_msgs in\n#eval work_on_strings \"abcdeFg\" \"defgG\""
      }
    ]
  },
  "fvapps_003413.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_f1_eq_f2 (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_f1_eq_f2_basic_case_1 :\n  find_f1_eq_f2 542 5 = 547 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def appears_in (d : Nat) (n : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_f1_eq_f2_generates_digits (n k : Nat) (testn := find_f1_eq_f2 n k) :\n  \u2203 m : Nat, \u2200 d : Nat, d < k \u2192 \u2203 i : Nat, i \u2264 m \u2227 appears_in d (testn * i) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_f1_eq_f2_basic_case_2 :\n  find_f1_eq_f2 1750 6 = 1799 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_f1_eq_f2_greater_than_input (n k : Nat) :\n  find_f1_eq_f2 n k \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 547\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 542 5\n\n/-\ninfo: 1799\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 1750 6\n\n/-\ninfo: 14996\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 14990 7"
      }
    ]
  },
  "fvapps_003414.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def move_vowels (s : String) : String := sorry\n\ndef is_vowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'"
      },
      {
        "type": "sig",
        "string": "def count_chars (s : String) : Nat := s.length"
      },
      {
        "type": "cond",
        "string": "theorem move_vowels_length_preserved (s : String) :\n  count_chars (move_vowels s) = count_chars s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem move_vowels_preserves_characters (s : String) :\n  (s.data : List Char) = ((move_vowels s).data : List Char) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem move_vowels_splits_correctly (s : String) :\n  let result := move_vowels s\n  \u2203 i : Nat, i \u2264 result.length \u2227\n    (\u2200 j : String.Pos, j.1 < i \u2192 \u00acis_vowel (result.get j)) \u2227\n    (\u2200 j : String.Pos, i \u2264 j.1 \u2227 j.1 < result.length \u2192 is_vowel (result.get j)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem move_vowels_empty :\n  move_vowels \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'dya'\n-/\n#guard_msgs in\n#eval move_vowels \"day\"\n\n/-\ninfo: 'pplae'\n-/\n#guard_msgs in\n#eval move_vowels \"apple\"\n\n/-\ninfo: 'pceae'\n-/\n#guard_msgs in\n#eval move_vowels \"peace\""
      }
    ]
  },
  "fvapps_003415.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_nb (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_cubes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For small perfect cubes (n \u2264 10), find_nb correctly returns n when given sum of first n cubes -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nb_small_perfect_cubes (n : Nat) (h : n \u2264 10) :\n  find_nb (sum_cubes n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For any volume that isn't sum of consecutive cubes, find_nb returns -1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nb_invalid_volumes {n : Int} (h : n > 0) :\n  find_nb n = -1 \u2228 sum_cubes (find_nb n).toNat = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- find_nb returns -1 for non-positive inputs -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nb_nonpositive {n : Int} (h : n \u2264 0) :\n  find_nb n = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For valid inputs, find_nb returns a positive number that produces the input volume -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nb_valid_result (n : Nat) :\n  let volume := sum_cubes n\n  let result := find_nb volume\n  result > 0 \u2227 sum_cubes result.toNat = volume :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Any positive result from find_nb produces the claimed volume -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem find_nb_produces_volume {n : Int} (h : find_nb n > 0) :\n  sum_cubes (find_nb n).toNat = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 45\n-/\n#guard_msgs in\n#eval find_nb 1071225\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval find_nb 91716553919377\n\n/-\ninfo: 2022\n-/\n#guard_msgs in\n#eval find_nb 4183059834009"
      }
    ]
  },
  "fvapps_003418.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_dig (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_happy (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def performant_numbers (n: Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_dig_nonnegative (n: Nat) :\n  sum_dig n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_dig_upper_bound (n: Nat) (k: Nat) :\n  sum_dig n \u2264 k * 81 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_happy_bool_result (n: Nat) :\n  is_happy n = true \u2228 is_happy n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_happy_numbers (n: Nat) :\n  n = 1 \u2228 n = 7 \u2228 n = 10 \u2228 n = 13 \u2228 n = 19 \u2228 n = 23 \u2228 n = 28 \u2228 n = 31 \u2192\n  is_happy n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_unhappy_numbers (n: Nat) :\n  n = 2 \u2228 n = 3 \u2228 n = 4 \u2228 n = 5 \u2228 n = 6 \u2228 n = 8 \u2228 n = 9 \u2192\n  is_happy n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem performant_numbers_sorted (n: Nat) :\n  let result := performant_numbers n\n  \u2200 i < result.length - 1,\n    result[i]! \u2264 result[i+1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem performant_numbers_bounded (n: Nat) :\n  \u2200 x \u2208 performant_numbers n, x \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem performant_numbers_contains_happy (n: Nat) :\n  \u2200 x \u2208 [1, 7, 10, 13, 19, 23, 28, 31],\n    x \u2264 n \u2192 x \u2208 performant_numbers n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 7, 10]\n-/\n#guard_msgs in\n#eval performant_numbers 10\n\n/-\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49]\n-/\n#guard_msgs in\n#eval performant_numbers 50\n\n/-\ninfo: [1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97, 100]\n-/\n#guard_msgs in\n#eval performant_numbers 100"
      }
    ]
  },
  "fvapps_003426.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def looseChange (coins: List Nat) (amount: Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem looseChange_result_bound (coins: List Nat) (amount: Nat) :\n  coins.length > 0 \u2192 let result := looseChange coins amount\n  result \u2265 -1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem looseChange_zero (coins: List Nat) :\n  coins.length > 0 \u2192 looseChange coins 0 = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem looseChange_small_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 \u2192\n  amount > 0 \u2192\n  amount < listMin coins \u2192\n  looseChange coins amount = -1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem looseChange_bounded_by_amount (coins: List Nat) (amount: Nat) :\n  coins.length > 0 \u2192\n  looseChange coins amount \u2260 -1 \u2192\n  looseChange coins amount \u2264 amount := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem looseChange_optimal (coins: List Nat) (amount: Nat) :\n  coins.length > 0 \u2192\n  let result := looseChange coins amount\n  result \u2260 -1 \u2192\n  \u2200 (c : Nat),\n  c \u2208 coins \u2192\n  \u00ac\u2203 (n : Nat), n > result \u2227 n * c = amount := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval loose_change [1, 5, 10, 25] 37\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval loose_change [1, 3, 4] 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval loose_change [25, 5, 10, 1, 21] 63"
      }
    ]
  },
  "fvapps_003429.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sieve (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def prime_primes (n : Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sieve_sorted (n : Nat) (h : n \u2265 2) :\n  let primes := sieve n\n  \u2200 i h1 h2, primes.get \u27e8i, h1\u27e9 < primes.get \u27e8i+1, h2\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_primes_nonneg (n : Nat) (h : n \u2265 2) :\n  let (count, total) := prime_primes n\n  count \u2265 0 \u2227 total \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_primes_small_bound (n : Nat) (h : n \u2265 2) (h2 : n \u2264 10) :\n  let (count, _) := prime_primes n\n  count \u2264 n * n / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003432.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_dd (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countDigit (n : Nat) (d : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dd_characterization (n : Nat) :\n  is_dd n = (\u2203 d : Nat, 1 \u2264 d \u2227 d \u2264 9 \u2227 countDigit n d = d) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_not_counted (n : Nat) :\n  (\u2200 d : Nat, d \u2260 0 \u2192 countDigit n d \u2260 d) \u2192\n  is_dd n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_digit_bounds (n d : Nat) :\n  countDigit n d \u2264 (digits n).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 664444309\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 122\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_dd 30313\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_dd 5023011"
      }
    ]
  },
  "fvapps_003434.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def primeMaxLengthChain (n : Nat) : List Nat := sorry\n\ndef isSorted (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => x \u2264 y && isSorted (y :: rest)"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  List.foldl (\u00b7+\u00b7) 0 l"
      },
      {
        "type": "cond",
        "string": "theorem output_list (n : Nat) (h : n \u2265 1) (h2 : n \u2264 1000) :\n  let result := primeMaxLengthChain n\n  isSorted result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_inputs (n : Nat) (h : n \u2265 1) (h2 : n \u2264 4) :\n  primeMaxLengthChain n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_are_primes (n : Nat) (h : n \u2265 5) (h2 : n \u2264 1000) :\n  let result := primeMaxLengthChain n\n  \u2200 x, x \u2208 result \u2192 isPrime x \u2227 x < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem results_are_sums_of_consecutive_primes (n : Nat) (h : n \u2265 5) (h2 : n \u2264 1000) :\n  let result := primeMaxLengthChain n\n  \u2200 x, x \u2208 result \u2192 \u2203 start length,\n    let primes := List.filter isPrime (List.range n)\n    let slice := (primes.drop start).take length\n    length \u2265 2 \u2227\n    listSum slice = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [41]\n-/\n#guard_msgs in\n#eval prime_maxlength_chain 100\n\n/-\ninfo: [197]\n-/\n#guard_msgs in\n#eval prime_maxlength_chain 200\n\n/-\ninfo: [499]\n-/\n#guard_msgs in\n#eval prime_maxlength_chain 500"
      }
    ]
  },
  "fvapps_003438.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isArithmeticSequence (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfRegularNumbers (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem regular_numbers_properties {arr : List Int} (h : arr.length \u2265 3) :\n  let result := sumOfRegularNumbers arr\n  (result \u2265 0 \u2228 (result < 0 \u2227 \u2203 x \u2208 arr, x < 0)) \u2227\n  (result \u2260 0 \u2192 \u2203 i, i + 2 < arr.length \u2227\n    isArithmeticSequence (arr.take 3))\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem three_element_sequence {arr : List Int} (h : arr.length = 3) :\n  let d\u2081 := arr[0]! - arr[1]!\n  let d\u2082 := arr[1]! - arr[2]!\n  d\u2081 = d\u2082 \u2192 sumOfRegularNumbers arr = sum arr \u2227\n  d\u2081 \u2260 d\u2082 \u2192 sumOfRegularNumbers arr = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_overlapping_sequences {arr : List Int} (h : arr.length \u2265 4) :\n  let result := sumOfRegularNumbers arr\n  result > 0 \u2192\n  \u2203 i, i + 2 < arr.length \u2227\n  (arr[i]! - arr[i+1]! = arr[i+1]! - arr[i+2]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 639\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]\n\n/-\ninfo: 1200\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [7, 2, 3, 2, -2, 400, 802]\n\n/-\ninfo: -13994\n-/\n#guard_msgs in\n#eval sum_of_regular_numbers [-1, 7000, 1, -6998, -13997]"
      }
    ]
  },
  "fvapps_003445.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hammingWeight (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitLength (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPowerOfTwo (n: Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_weight_nonnegative_and_bounded (x: Nat) :\n  hammingWeight x \u2265 0 \u2227 hammingWeight x \u2264 bitLength x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_weight_power_of_two (x: Nat) :\n  x > 0 \u2192 isPowerOfTwo x \u2192 hammingWeight x = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hamming_weight_zero_and_nonzero (x: Nat) :\n  hammingWeight 0 = 0 \u2227 (x > 0 \u2192 hammingWeight x > 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval hamming_weight 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 1\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval hamming_weight 10\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval hamming_weight 21\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming_weight 2048"
      }
    ]
  },
  "fvapps_003446.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shuffleIt {\u03b1 : Type} : List \u03b1 \u2192 List (Nat \u00d7 Nat) \u2192 List \u03b1\n  | xs, swaps => sorry\n\ndef swapAt {\u03b1 : Type} (xs : List \u03b1) (i j : Nat) (h\u2081 : i < xs.length) (h\u2082 : j < xs.length) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shuffleIt_preserves_length {\u03b1 : Type} (xs : List \u03b1) (swaps : List (Nat \u00d7 Nat))\n  (h : \u2200 p \u2208 swaps, p.1 < xs.length \u2227 p.2 < xs.length) :\n  (shuffleIt xs swaps).length = xs.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shuffleIt_preserves_elements {\u03b1 : Type} [BEq \u03b1] (xs : List \u03b1) (swaps : List (Nat \u00d7 Nat))\n  (h : \u2200 p \u2208 swaps, p.1 < xs.length \u2227 p.2 < xs.length) :\n  \u2200 x, x \u2208 xs \u2194 x \u2208 shuffleIt xs swaps :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shuffleIt_no_swaps {\u03b1 : Type} (xs : List \u03b1) :\n  shuffleIt xs [] = xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shuffleIt_single_swap {\u03b1 : Type} (xs : List \u03b1) (i j : Nat)\n  (h\u2081 : i < xs.length) (h\u2082 : j < xs.length) :\n  shuffleIt xs [(i,j)] = swapAt xs i j h\u2081 h\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 3, 2, 4, 5]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2]\n\n/-\ninfo: [1, 3, 2, 5, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4]\n\n/-\ninfo: [1, 3, 5, 2, 4]\n-/\n#guard_msgs in\n#eval shuffle_it [1, 2, 3, 4, 5] [1, 2] [3, 4] [2, 3]"
      }
    ]
  },
  "fvapps_003447.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse_it {\u03b1 : Type} (x : \u03b1) : \u03b1 :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_it_string_length {s : String} :\n  String.length (reverse_it s) = String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to get nth char of string -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def getNth (s : String) (n : Nat) : Char := s.data.get! n"
      },
      {
        "type": "cond",
        "string": "theorem reverse_it_string_reverses {s : String} {i : Nat} (h : i < String.length s) :\n  getNth (reverse_it s) i = getNth s (String.length s - 1 - i) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Type class for types that shouldn't be reversed -/"
      },
      {
        "type": "constr",
        "string": "class NonString (\u03b1 : Type)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_it_non_string_identity {\u03b1 : Type} [NonString \u03b1] (x : \u03b1) :\n  reverse_it x = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'olleH'\n-/\n#guard_msgs in\n#eval reverse_it \"Hello\"\n\n/-\ninfo: 951413\n-/\n#guard_msgs in\n#eval reverse_it 314159\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval reverse_it [1, 2, 3]"
      }
    ]
  },
  "fvapps_003449.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isBouncyStr (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bouncyRatio (n : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bouncy_sequence_property {n : Nat} (h : n \u2265 100) (h2 : n \u2264 100000) :\n  isBouncyStr (toString n) = true \u2192\n  \u2203 i j : String.Pos, i < j \u2227\n  ((toString n).get i < (toString n).get j) \u2227\n  \u2203 k l : String.Pos, k < l \u2227\n  ((toString n).get k > (toString n).get l) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bouncy_ratio_validation_zero :\n  \u00ac \u2203 x : Float, x = bouncyRatio 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bouncy_ratio_validation_one :\n  \u00ac \u2203 x : Float, x = bouncyRatio 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bouncy_ratio_validation_negative (n : Float) :\n  n < 0 \u2192\n  \u00ac \u2203 x : Float, x = bouncyRatio n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bouncy_ratio_validation_above_one (n : Float) :\n  n > 1 \u2192\n  \u00ac \u2203 x : Float, x = bouncyRatio n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 538\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.5\n\n/-\ninfo: 21780\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.9\n\n/-\ninfo: 3088\n-/\n#guard_msgs in\n#eval bouncy_ratio 0.75"
      }
    ]
  },
  "fvapps_003450.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def getFirstNPrimes (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def numPrimorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem primorial_equals_product_of_first_n_primes (n : Nat)\n  (h : n \u2265 1 \u2227 n \u2264 10) :\n  numPrimorial n = (getFirstNPrimes n).foldl (\u00b7*\u00b7) 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem primorial_is_strictly_increasing {n : Nat}\n  (h1 : n \u2265 1 \u2227 n \u2264 10) (h2 : n > 1) :\n  numPrimorial n > numPrimorial (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem primorial_is_divisible_by_smaller_primorials {n : Nat}\n  (h1 : n \u2265 1 \u2227 n \u2264 10) (h2 : n > 1) :\n  numPrimorial n % numPrimorial (n-1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval num_primorial 3\n\n/-\ninfo: 2310\n-/\n#guard_msgs in\n#eval num_primorial 5\n\n/-\ninfo: 9699690\n-/\n#guard_msgs in\n#eval num_primorial 8"
      }
    ]
  },
  "fvapps_003456.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def distribute (nodes : Nat) (workload : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMaximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMinimum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem distribute_length {nodes workload : Nat}\n  (h : nodes \u2264 workload \u2228 workload = 0) :\n  (distribute nodes workload).length = nodes :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [[0, 1], [2, 3]]\n-/\n#guard_msgs in\n#eval distribute 2 4\n\n/-\ninfo: [[0], [1], [2]]\n-/\n#guard_msgs in\n#eval distribute 3 3\n\n/-\ninfo: [[0, 1, 2], [3, 4, 5], [6, 7], [8, 9]]\n-/\n#guard_msgs in\n#eval distribute 4 10"
      }
    ]
  },
  "fvapps_003460.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_maintains_elements {arr : List Int} (h : arr \u2260 []) :\n  let result := solve arr\n  result.length = arr.length \u2227\n  \u2200 x, (result.count x = arr.count x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_alternates_high_low {arr : List Int} (h : arr.length \u2265 2) :\n  let result := solve arr\n  \u2200 i, i + 1 < result.length \u2192 i % 2 = 0 \u2192\n  (result.get \u27e8i, sorry\u27e9) \u2265 (result.get \u27e8i+1, sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_first_element_is_max {arr : List Int} (h : arr \u2260 []) :\n  let result := solve arr\n  \u2200 i, i < result.length \u2192\n  (result.get \u27e80, sorry\u27e9) \u2265 (result.get \u27e8i, sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty_and_single {arr : List Int} :\n  arr.length \u2264 1 \u2192 solve arr = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [15, 11, 10, 7, 12]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [91, 75, 86, 14, 82]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [1, 6, 9, 4, 3, 7, 8, 2]"
      }
    ]
  },
  "fvapps_003461.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def summy (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToList (s : String) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summy_matches_direct_sum (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \" \" (List.map toString l)) = sum l :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summy_handles_whitespace (l : List Int) (h : l.length > 0) :\n  summy (String.intercalate \"   \" (List.map toString l)) = sum l :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval summy \"1 2 3\"\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval summy \"10 10\"\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval summy \"0 0\""
      }
    ]
  },
  "fvapps_003462.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def aa_percentage (seq : String) (residues : List Char := ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V']) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem default_residues_in_bounds (seq : String)\n  (h : \u2200 c \u2208 seq.data, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  0 \u2264 aa_percentage seq \u2227 aa_percentage seq \u2264 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + sum_list xs"
      },
      {
        "type": "cond",
        "string": "theorem custom_residues_in_bounds (seq : String) (residues : List Char)\n  (h1 : \u2200 c \u2208 seq.data, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : \u2200 c \u2208 residues, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  0 \u2264 aa_percentage seq residues \u2227 aa_percentage seq residues \u2264 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_residues_gives_zero (seq : String)\n  (h : \u2200 c \u2208 seq.data, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem residue_count_matches (seq : String) (residues : List Char)\n  (h1 : \u2200 c \u2208 seq.data, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h2 : \u2200 c \u2208 residues, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y'])\n  (h3 : residues.Nodup) :\n  aa_percentage seq residues =\n    ((sum_list (residues.map (\u03bb r => seq.data.count r))) * 100 + seq.length / 2) / seq.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem default_residues_consistent (seq : String)\n  (h : \u2200 c \u2208 seq.data, c \u2208 ['A','C','D','E','F','G','H','I','K','L','M','N','P','Q','R','S','T','V','W','Y']) :\n  aa_percentage seq = aa_percentage seq ['A', 'I', 'L', 'M', 'F', 'W', 'Y', 'V'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval aa_percentage \"MSRSLLLRFLLFLLLLPPLP\" [\"M\"]\n\n/-\ninfo: 29\n-/\n#guard_msgs in\n#eval aa_percentage \"RLMADDFFGQTLMAAAAAAQERRR\" [\"A\"]\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval aa_percentage \"PLPPLPLLEELELRPFFMAAGGTPLAMMGG\""
      }
    ]
  },
  "fvapps_003465.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def seqR : String \u2192 Bool\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def seqB : String \u2192 Bool\n  | _ => sorry\n\ndef button_sequences (r : String) (b : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem button_sequences_valid_chars (r b : String) (h : r.length > 0 \u2227 b.length > 0) :\n  \u2200 c, c \u2208 (button_sequences r b).toList \u2192 c = 'R' \u2228 c = 'B' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem button_sequences_length (r b : String) (h : r.length > 0 \u2227 b.length > 0) :\n  (button_sequences r b).length \u2264 min r.length b.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem button_sequences_all_zeros_red (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  \u2200 c, c \u2208 (button_sequences s zeros).toList \u2192 c = 'R' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem button_sequences_all_zeros_blue (s : String) (h : s.length > 0) :\n  let zeros := String.mk (List.replicate s.length '0')\n  \u2200 c, c \u2208 (button_sequences zeros s).toList \u2192 c = 'B' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'RBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10011010\" \"10110111\"\n\n/-\ninfo: 'RB'\n-/\n#guard_msgs in\n#eval button_sequences \"01001000\" \"01011100\"\n\n/-\ninfo: 'RBRBRBRB'\n-/\n#guard_msgs in\n#eval button_sequences \"10101010\" \"01010101\""
      }
    ]
  },
  "fvapps_003471.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def swap (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def swapcase (c : Char) : Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_length_preserved (s : String) (n : Nat) :\n  (swap s n).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_nonalpha_preserved (s : String) (n : Nat) (pos : String.Pos) :\n  \u00acisAlpha (s.get pos) \u2192 (swap s n).get pos = s.get pos :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_alpha_case (s : String) (n : Nat) (pos : String.Pos) :\n  isAlpha (s.get pos) \u2192\n  (s.get pos).toLower = ((swap s n).get pos).toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_zero_identity (s : String) :\n  swap s 0 = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_pattern_matches_binary (s : String) (n : Nat) (pos : String.Pos)\n    (binPattern : String) (idx : String.Pos) :\n  isAlpha (s.get pos) \u2192\n  binPattern = (toString n).dropWhile (\u00b7 = '0') \u2192\n  (binPattern.get idx = '1' \u2192\n    (swap s n).get pos = swapcase (s.get pos)) \u2227\n  (binPattern.get idx = '0' \u2192\n    (swap s n).get pos = s.get pos) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'heLLO wORLd!'\n-/\n#guard_msgs in\n#eval swap \"Hello world!\" 11\n\n/-\ninfo: 'GooD MorNIng'\n-/\n#guard_msgs in\n#eval swap \"gOOd MOrniNg\" 7864\n\n/-\ninfo: 'the lord of the rings'\n-/\n#guard_msgs in\n#eval swap \"the lord of the rings\" 0"
      }
    ]
  },
  "fvapps_003472.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pvariance (xs : List String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Our variance function -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def variance (xs : List String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Our variance matches statistics.pvariance -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem variance_matches_pvariance (words : List String) (h : words \u2260 []) :\n  variance words = pvariance words :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Words of same length have variance 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem same_length_zero_variance (words : List String) (h1 : words \u2260 [])\n  (h2 : \u2200 w \u2208 words, w.length = 5) : variance words = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Variance is always nonnegative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem variance_nonnegative (words : List String) (h : words.length \u2265 2) :\n  variance words \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Empty list raises error -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_list_error :\n  variance [] = 0/0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 0\n-/\n#guard_msgs in\n#eval variance [\"Hello\", \"world\"]\n\n/-\ninfo: 2.25\n-/\n#guard_msgs in\n#eval variance [\"Hi\", \"world\"]\n\n/-\ninfo: 7.5556\n-/\n#guard_msgs in\n#eval variance [\"Variance\", \"is\", \"not\", \"a\", \"good\", \"stimator\"]"
      }
    ]
  },
  "fvapps_003473.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def choose (n m : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_paths (n: Nat) (start_pos: Nat \u00d7 Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_paths_one_by_one {n: Nat} (h: n = 1) :\n  count_paths n (0, 0) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_paths_non_negative {n row col: Nat} (h1: row < n) (h2: col < n) (h3: n > 0) :\n  count_paths n (row, col) \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_paths_only_vertical {n row col: Nat} (h1: col = n - 1) (h2: row > 0) (h3: row < n) (h4: n > 0) :\n  count_paths n (row, col) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_paths_only_horizontal {n row col: Nat} (h1: row = 0) (h2: col < n - 1) (h3: n > 0) :\n  count_paths n (row, col) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_paths_start_equals_target {n: Nat} (h: n \u2265 2) :\n  count_paths n (0, n-1) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_paths 1 (0, 0)\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_paths 2 (1, 0)\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_paths 3 (1, 0)\n\n/-\ninfo: 70\n-/\n#guard_msgs in\n#eval count_paths 5 (4, 0)"
      }
    ]
  },
  "fvapps_003476.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def four_piles (n : Nat) (y : Nat) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Nat \u2192 Nat\n  | [] => 0\n  | (h :: t) => h + sum_list t"
      },
      {
        "type": "sig",
        "string": "def nth : List Nat \u2192 Nat \u2192 Option Nat\n  | [], _ => none\n  | (h :: t), 0 => some h\n  | (h :: t), n+1 => nth t n"
      },
      {
        "type": "cond",
        "string": "theorem four_piles_properties_solution (n y : Nat) (h1 : n > 0) (h2 : y > 0) (h3 : y \u2264 100) :\n  match four_piles n y with\n  | some result =>\n    -- Result has length 4\n    result.length = 4 \u2227\n    -- Elements follow x+y, x-y, x*y, x/y pattern for some x\n    \u2203 x : Nat,\n      (nth result 0 = some (x + y)) \u2227\n      (nth result 1 = some (x - y)) \u2227\n      (nth result 2 = some (x * y)) \u2227\n      (nth result 3 = some (x / y)) \u2227\n    -- Elements are positive\n    (\u2200 i \u2208 result, i > 0) \u2227\n    -- Sum equals input n\n    sum_list result = n\n  | none =>\n    -- If no solution, divmod has remainder\n    let prod := n * y\n    let denom := (y + 1) * (y + 1)\n    prod % denom \u2260 0 \u2228 (prod / denom = y)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem four_piles_properties_positive (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => \u2200 x \u2208 result, x > 0\n  | none => True\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem four_piles_properties_sum (n y : Nat) (h1 : n > 0) (h2 : y > 0) :\n  match four_piles n y with\n  | some result => sum_list result = n\n  | none => True\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [12, 6, 27, 3]\n-/\n#guard_msgs in\n#eval four_piles 48 3\n\n/-\ninfo: [20, 12, 64, 4]\n-/\n#guard_msgs in\n#eval four_piles 100 4\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval four_piles 25 4"
      }
    ]
  },
  "fvapps_003478.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_dig_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def not_primes (start finish : Nat) : List Nat := sorry\n\ndef List.sorted (l : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192\n  match l.get? i, l.get? j with\n  | some x, some y => x \u2264 y\n  | _, _ => true"
      },
      {
        "type": "cond",
        "string": "theorem not_primes_empty_for_equal_bounds (n : Nat) :\n  not_primes n n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem not_primes_empty_for_invalid_range (start finish : Nat)\n  (h : finish < start) :\n  not_primes start finish = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [22, 25, 27, 32, 33, 35, 52, 55, 57, 72, 75]\n-/\n#guard_msgs in\n#eval not_primes 2 77\n\n/-\ninfo: [522, 525, 527, 532, 533, 535, 537, 552, 553, 555, 572, 573, 575]\n-/\n#guard_msgs in\n#eval not_primes 500 600\n\n/-\ninfo: [2722, 2723, 2725, 2727, 2732, 2733, 2735, 2737]\n-/\n#guard_msgs in\n#eval not_primes 2700 2750"
      }
    ]
  },
  "fvapps_003480.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mid_endian (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def natToHexString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitInPairs (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_idempotent_bytes (n : Nat) :\n  let result := mid_endian n\n  let pairs := splitInPairs result\n  String.join pairs = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_valid_hex (n : Nat) :\n  \u2203 h, (mid_endian n).toNat? = some h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_even_length (n : Nat) :\n  (mid_endian n).length % 2 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_sufficient_length (n : Nat) :\n  (mid_endian n).length \u2265 (natToHexString n).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_hex_chars (n : Nat) :\n  \u2200 i : Fin (mid_endian n).length,\n    (mid_endian n).data.get i \u2208 ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mid_endian_single_byte (n : Nat) (h : n \u2264 0xFF) :\n  mid_endian n = natToHexString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '96987F'\n-/\n#guard_msgs in\n#eval mid_endian 9999999\n\n/-\ninfo: '00'\n-/\n#guard_msgs in\n#eval mid_endian 0\n\n/-\ninfo: '0B0A0C'\n-/\n#guard_msgs in\n#eval mid_endian 658188"
      }
    ]
  },
  "fvapps_003486.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def totient (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isPrime (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isInt (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countCoprimes (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem totient_matches_coprime_count (n : Int) (h : n > 0) :\n  totient n = countCoprimes n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem totient_invalid_inputs (n : Int) (h : n \u2264 0) :\n  totient n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem totient_multiplicative (n\u2081 n\u2082 : Int) (h\u2081 : gcd n\u2081 n\u2082 = 1) (h\u2082 : n\u2081 > 0) (h\u2083 : n\u2082 > 0) :\n  totient (n\u2081 * n\u2082) = totient n\u2081 * totient n\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem totient_prime (p : Int) (h\u2081 : p > 1) (h\u2082 : isPrime p) :\n  totient p = p - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003489.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def toBase (num base : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumItUp (nums : List (String \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x :: xs => x + sumList xs"
      },
      {
        "type": "cond",
        "string": "theorem sum_it_up_equals_decimal_sum {nums : List (Nat \u00d7 Nat)} :\n  \u2200 pairs : List (String \u00d7 Nat),\n  (\u2200 p : String \u00d7 Nat, p \u2208 pairs \u2192\n    \u2203 n \u2208 nums, p.1 = toBase n.1 p.2) \u2192\n  sumItUp pairs = sumList (nums.map Prod.fst) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_it_up_empty : sumItUp [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_it_up_single {n : String} {b : Nat} :\n  b \u2265 2 \u2192 b \u2264 36 \u2192\n  \u2203 k : Nat, sumItUp [(n, b)] = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_conversion_roundtrip {n : Nat} {b : Nat} :\n  n \u2264 1000000 \u2192 b \u2265 2 \u2192 b \u2264 36 \u2192\n  \u2203 k : Nat, k = n \u2227 String.toNat! (toBase n b) = k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 2], [\"10\", 8]]\n\n/-\ninfo: 2751\n-/\n#guard_msgs in\n#eval sum_it_up [[\"ABC\", 16], [\"11\", 2]]\n\n/-\ninfo: 4258\n-/\n#guard_msgs in\n#eval sum_it_up [[\"101\", 16], [\"7640\", 8], [\"1\", 9]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_it_up []"
      }
    ]
  },
  "fvapps_003492.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_string (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.filter (s : String) (p : Char \u2192 Bool) : String := sorry\n\ndef isValidDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match c with\n  | '0' => true | '1' => true | '2' => true | '3' => true | '4' => true\n  | '5' => true | '6' => true | '7' => true | '8' => true | '9' => true\n  | '.' => true | '+' => true | '-' => true | '*' => true | '/' => true\n  | _ => false"
      },
      {
        "type": "cond",
        "string": "theorem calculate_string_evaluates_expressions\n  (n\u2081 n\u2082 : Float) (op : Char)\n  (h_op : op \u2208 ['+', '-', '*', '/'])\n  (h_div : op = '/' \u2192 n\u2082 \u2260 0)\n  : let expr := s!\"{n\u2081}{op}{n\u2082}\"\n    let noisy_expr := s!\"abc{expr}xyz!@#\"\n    let result := calculate_string noisy_expr\n    let clean_expr := String.filter expr isValidDigit\n    let expected := toString (Float.round (match op with\n      | '+' => n\u2081 + n\u2082\n      | '-' => n\u2081 - n\u2082\n      | '*' => n\u2081 * n\u2082\n      | '/' => n\u2081 / n\u2082\n      | _ => 0))\n    result = expected :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem calculate_string_preserves_single_number\n  (n : Int) (h : -1000000 \u2264 n \u2227 n \u2264 1000000)\n  : toString (String.toInt! (calculate_string (toString n))) = toString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '47'\n-/\n#guard_msgs in\n#eval calculate_string \";$%\u00a7fsdfsd235??df/sdfgf5gh.000kk0000\"\n\n/-\ninfo: '54929268'\n-/\n#guard_msgs in\n#eval calculate_string \"sdfsd23454sdf*2342\"\n\n/-\ninfo: '234676'\n-/\n#guard_msgs in\n#eval calculate_string \"fsdfsd234.4554s4234df+sf234442\""
      }
    ]
  },
  "fvapps_003503.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) (idx : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_matching_parens (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_idx (s : String) (idx : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_invalid_index {s : String} {idx : Nat} :\n  \u00ac(is_valid_idx s idx) \u2192 solve s idx = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_unmatched_parens {s : String} {idx : Nat} :\n  \u00ac(has_matching_parens s) \u2192 solve s idx = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_valid_result {s : String} {idx : Nat} :\n  (solve s idx \u2260 -1) \u2192\n  is_valid_idx s idx \u2227\n  (\u2203 result : Nat, solve s idx = result \u2227\n    idx < s.length \u2227 result < s.length \u2227\n    s.data[idx]! = '(' \u2227\n    s.data[result]! = ')' \u2227\n    has_matching_parens (String.mk (List.take (result + 1 - idx) (List.drop idx s.data)))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_all_open_parens {s : String} :\n  (\u2200 c \u2208 s.data, c = '(') \u2192\n  \u2200 i : Nat, i < s.length \u2192\n  solve s i = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_all_close_parens {s : String} :\n  (\u2200 c \u2208 s.data, c = ')') \u2192\n  \u2200 i : Nat, i < s.length \u2192\n  solve s i = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 0\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve \"((1)23(45))(aB)\" 1\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval solve \"(g(At)IO(f)(tM(qk)YF(n)Nr(E)))\" 11"
      }
    ]
  },
  "fvapps_003504.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_a_down_arrow_of (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.lines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.padLeft (n : Nat) (c : Char) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def charToNat (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arrow_length (n : Nat) (h : 0 < n \u2227 n \u2264 9) :\n  (get_a_down_arrow_of n).lines.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arrow_leading_spaces (n : Nat) (h : 0 < n \u2227 n \u2264 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let line := lines[i]!\n  (\u2203 rest : String, line = String.padLeft i ' ' rest) \u2227\n  line.trim \u2260 \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arrow_decreasing_widths (n : Nat) (h : 0 < n \u2227 n \u2264 9) (i : Nat) (h2 : i < n - 1) :\n  let lines := (get_a_down_arrow_of n).lines\n  lines[i]!.length > lines[i+1]!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arrow_line_symmetry (n : Nat) (h : 0 < n \u2227 n \u2264 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let stripped := lines[i]!.trim\n  let mid := stripped.length / 2\n  stripped.take mid = stripped.drop (mid+1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arrow_sequential_digits (n : Nat) (h : 0 < n \u2227 n \u2264 9) (i : Nat) (h2 : i < n) :\n  let lines := (get_a_down_arrow_of n).lines\n  let digits := lines[i]!.data.filter Char.isDigit\n  (\u2200 d \u2208 digits, 0 < charToNat d \u2227 charToNat d < 10) \u2227\n  (digits.length > 1 \u2192\n    \u2200 j < digits.length/2 - 1,\n      charToNat digits[j+1]! - charToNat digits[j]! = 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003515.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def CHARS_WITH_RINGS := \"abdegopqABBDOPQR\""
      },
      {
        "type": "sig",
        "string": "def olympic_ring (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def POSSIBLE_OUTPUTS := [\"Not even a medal!\", \"Bronze!\", \"Silver!\", \"Gold!\"]"
      },
      {
        "type": "cond",
        "string": "theorem output_in_possible_values (s : String) :\n  olympic_ring s \u2208 POSSIBLE_OUTPUTS :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_not_medal (s : String) :\n  (\u2200 c, c \u2208 s.data \u2192 c \u2209 CHARS_WITH_RINGS.data) \u2192\n  olympic_ring s = \"Not even a medal!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_ring_chars_not_medal (s : String) :\n  (\u2200 c, c \u2208 s.data \u2192 c \u2209 CHARS_WITH_RINGS.data) \u2192\n  olympic_ring s = \"Not even a medal!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bronze!'\n-/\n#guard_msgs in\n#eval olympic_ring \"wHjMudLwtoPGocnJ\"\n\n/-\ninfo: 'Not even a medal!'\n-/\n#guard_msgs in\n#eval olympic_ring \"JKniLfLW\"\n\n/-\ninfo: 'Gold!'\n-/\n#guard_msgs in\n#eval olympic_ring \"IMBAWejlGRTDWetPS\""
      }
    ]
  },
  "fvapps_003526.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encoder (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def decoder (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to check if character is uppercase"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to check if character is digit"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to check if string starts with 0 and uppercase letter"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def startsWithZeroUpper (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encoder_output_format (s : String) (h : s \u2260 \"\") :\n  (\u2200 c, c \u2208 s.toList \u2192 isDigit c \u2228 isUpper c) \u2227\n  startsWithZeroUpper (encoder s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encoder_length_bounds (s : String) (h : s \u2260 \"\") :\n  String.length (encoder s) \u2264 3 * String.length s \u2227\n  String.length (encoder s) \u2265 String.length s / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encoder_decoder_inverse (s : String) (h : s \u2260 \"\") :\n  decoder (encoder s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_003534.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def average (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_min (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_max (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_in_range (l : List Int) (h : l \u2260 []) :\n  let result := average l\n  let min_val := list_min l\n  let max_val := list_max l\n  min_val \u2264 result \u2227 result \u2264 max_val := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_close_to_mean (l : List Int) (h : l \u2260 []) :\n  let result := average l\n  let mean := (list_sum l) / (List.length l)\n  (result - mean) < 1 \u2227 (mean - result) < 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_shift (l : List Int) (shift : Int) (h : l \u2260 []) :\n  average (List.map (\u00b7 + shift) l) = average l + shift := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_empty :\n  average [] = 0 \u2227 False := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003535.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def array_change (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem array_change_returns_nonnegative (arr : List Int) (h : arr.length \u2265 1) :\n  array_change arr \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval array_change [1, 1, 1]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval array_change [-1000, 0, -2, 0]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval array_change [2, 1, 10, 1]"
      }
    ]
  },
  "fvapps_003542.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_perfect_square (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def square_sums_row (n : Nat) : Option (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_sums_row_length {n : Nat} {result : List Nat} :\n  square_sums_row n = some result \u2192 result.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_sums_row_elements {n : Nat} {result : List Nat} :\n  square_sums_row n = some result \u2192\n  result = (List.map (\u03bb x => x + 1) (List.range n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_sums_row_adjacent_pairs {n : Nat} {result : List Nat} :\n  square_sums_row n = some result \u2192\n  \u2200 i, i < result.length - 1 \u2192\n  is_perfect_square (result[i]! + result[i+1]!) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_sums_row_impossible_cases :\n  (square_sums_row 2 = none) \u2227\n  (square_sums_row 3 = none) \u2227\n  (square_sums_row 5 = none) \u2227\n  (square_sums_row 24 = none) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval square_sums_row 24\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval len square_sums_row(15)\n\n/-\ninfo: list(range(1, 16))\n-/\n#guard_msgs in\n#eval sorted result"
      }
    ]
  },
  "fvapps_003545.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isInt (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDiceList (l : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDiceDesc : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def extractSides : String \u2192 Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def roll (desc : String) (verbose : Bool := false) : Bool \u2295 (List Nat \u00d7 Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_roll_structure {desc : String} {result : List Nat \u00d7 Int}\n  (h : roll desc true = Sum.inr result) :\n  \u2203 (dice : List Nat) (modifier : Int), result = (dice, modifier) \u2227\n  \u2200 d \u2208 dice, isInt d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_roll {desc : String} (h : \u00acisValidDiceDesc desc) :\n  roll desc false = Sum.inl false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_string_input {\u03b1 : Type} {x : \u03b1} [ToString \u03b1] :\n  roll (toString x) false = Sum.inl false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem roll_range_properties {desc : String} {result : List Nat \u00d7 Int} {sides : Nat}\n  (h\u2081 : roll desc true = Sum.inr result)\n  (h\u2082 : extractSides desc = some sides) :\n  \u2200 die \u2208 result.1, 1 \u2264 die \u2227 die \u2264 sides :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll {}\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval roll \"abc\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval len result1[\"dice\"]"
      }
    ]
  },
  "fvapps_003549.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sim (k n : Nat) (p : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def compute (k n m x : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sim_monotonic (k n : Nat)\n  (h1 : k \u2265 1) (h2 : n \u2265 2) :\n  sim k n 0 \u2264 sim k n 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem compute_result_valid (k n x m : Nat)\n  (h1 : k \u2265 1) (h2 : n \u2265 2) (h3 : x \u2265 1)\n  (h4 : m \u2265 0)\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Simplified bounds since we can't easily convert Float to Nat -/\n  (h5 : sim k (n-1) 1 > sim k (n-1) 0) :\n  compute k n m x \u2265 0 :=\nsorry\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval calc 5 7 32 4\n\n/-\ninfo: 252\n-/\n#guard_msgs in\n#eval calc 12 23 212532 8"
      }
    ]
  },
  "fvapps_003555.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encode (message : String) (key : String) (shift : Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def decode (message : String) (key : String) (shift : Int) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def LOWER : String :="
      },
      {
        "type": "impl",
        "string": "  \"abcdefghijklmnopqrstuvwxyz\""
      },
      {
        "type": "cond",
        "string": "theorem encode_decode_roundtrip\n  {message key : String} {shift : Int}\n  (h1 : \u2200 c \u2208 message.data, c.toString \u2208 LOWER.data.map toString)\n  (h2 : key.length > 0)\n  (h3 : \u2200 c \u2208 key.data, c.toString \u2208 LOWER.data.map toString) :\n  decode (encode message key shift) key shift = message :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_alphabet_chars_unchanged\n  {message key : String} {shift : Int}\n  (h1 : key.length > 0)\n  (h2 : \u2200 c \u2208 key.data, c.toString \u2208 LOWER.data.map toString) :\n  \u2200 (i : Nat) (h3 : i < message.length),\n    (message.data.get \u27e8i, h3\u27e9) \u2209 LOWER.data \u2192\n    (encode message key shift).data.get \u27e8i, sorry\u27e9 = message.data.get \u27e8i, h3\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'jx'\n-/\n#guard_msgs in\n#eval encode \"on\" \"cryptogram\" 10\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode \"jx\" key shift\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"keyword\" 5\n\n/-\ninfo: msg\n-/\n#guard_msgs in\n#eval decode encode(msg, key, shift) \"secret\" 7"
      }
    ]
  },
  "fvapps_003559.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def expanded_form (n : Nat) : String := sorry\n\ndef list_sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x :: rest => x + list_sum rest"
      },
      {
        "type": "sig",
        "string": "def string_to_nat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sorted_desc (xs : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem expanded_form_sum_equals_input (n : Nat) (h : 0 < n) (h2 : n \u2264 1000000) :\n  let parts := (expanded_form n).split (\u00b7 = '+')\n  list_sum (parts.map string_to_nat) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem expanded_form_divisible_by_powers_of_ten (n : Nat) (h : 0 < n) (h2 : n \u2264 1000000) :\n  let parts := (expanded_form n).split (\u00b7 = '+')\n  \u2200 (i : Nat) (p : String), i < parts.length \u2192 p \u2208 parts \u2192\n  string_to_nat p % (10^i) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem expanded_form_no_leading_zeros (n : Nat) (h : 0 < n) :\n  let parts := (expanded_form n).split (\u00b7 = '+')\n  \u2200 p \u2208 parts, \u00ac(p.get? 0 = some '0') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem expanded_form_descending_order (n : Nat) (h : 0 < n) :\n  let parts := (expanded_form n).split (\u00b7 = '+')\n  let nums := parts.map string_to_nat\n  list_sorted_desc nums = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem expanded_form_single_digit (n : Nat) (h : 0 < n) (h2 : n < 10) :\n  expanded_form n = toString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval expanded_form 2\n\n/-\ninfo: '40 + 2'\n-/\n#guard_msgs in\n#eval expanded_form 42\n\n/-\ninfo: '70000 + 300 + 4'\n-/\n#guard_msgs in\n#eval expanded_form 70304"
      }
    ]
  },
  "fvapps_003562.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def value_at (poly: List Int) (x: Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def aCb (a: Float) (b: Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def intToFloat (i: Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem value_at_results_finite (poly: List Int) (x: Float) (h1: poly.length > 0)\n  (h2: -10 \u2264 x \u2227 x \u2264 10) : \u2203 (y: Float), value_at poly x = y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aCb_matches_binomial (a b: Int) (h1: 0 \u2264 a \u2227 a \u2264 10) (h2: 0 \u2264 b \u2227 b \u2264 10)\n  (h3: b \u2264 a) : \u2203 (y: Float), aCb (intToFloat a) b = y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem aCb_results_finite (a: Float) (b: Int) (h1: -10 \u2264 a \u2227 a \u2264 10)\n  (h2: 0 \u2264 b \u2227 b \u2264 5) : \u2203 (y: Float), aCb a b = y :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem value_at_constant (c: Int) (h1: -10 \u2264 c \u2227 c \u2264 10) :\n  (value_at [c] 123 - intToFloat c) < 0.01 \u2227 (intToFloat c - value_at [c] 123) < 0.01 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7] 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 2\n\n/-\ninfo: 4.24\n-/\n#guard_msgs in\n#eval value_at [1, 2, 7, 0, 5] 0.6"
      }
    ]
  },
  "fvapps_003566.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def goldbach_partitions : Nat \u2192 List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime : Nat \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Nat.is_even (n : Nat) : Bool := n % 2 == 0"
      },
      {
        "type": "cond",
        "string": "theorem goldbach_odd_numbers_empty (n : Nat) :\n  n % 2 = 1 \u2192 goldbach_partitions n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003568.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def word_mesh (words : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isResult (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasOverlap (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isLowerAlpha (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_mesh_output_format\n  (words : List String)\n  (h1 : words.length \u2265 2)\n  (h2 : words.length \u2264 10)\n  (h3 : \u2200 w \u2208 words, w.length > 0) :\n  let result := word_mesh words\n  (result = \"failed to mesh\" \u2228 isLowerAlpha result) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem word_mesh_successful_overlap\n  (words : List String)\n  (h1 : words.length \u2265 2)\n  (h2 : words.length \u2264 5)\n  (h3 : \u2200 w \u2208 words, w.length > 0)\n  (h4 : \u2200 i, i < words.length - 1 \u2192\n    hasOverlap (words.get \u27e8i, by sorry\u27e9) (words.get \u27e8i+1, by sorry\u27e9)) :\n  let result := word_mesh words\n  result \u2260 \"failed to mesh\" \u2192\n  \u2200 i, i < words.length - 1 \u2192\n    hasOverlap (words.get \u27e8i, by sorry\u27e9) (words.get \u27e8i+1, by sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'lowringter'\n-/\n#guard_msgs in\n#eval word_mesh [\"allow\", \"lowering\", \"ringmaster\", \"terror\"]\n\n/-\ninfo: 'failed to mesh'\n-/\n#guard_msgs in\n#eval word_mesh [\"kingdom\", \"dominator\", \"notorious\", \"usual\", \"allegory\"]\n\n/-\ninfo: 'conumcal'\n-/\n#guard_msgs in\n#eval word_mesh [\"beacon\", \"condominium\", \"umbilical\", \"california\"]"
      }
    ]
  },
  "fvapps_003576.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def getAllPrimeFactors (n : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getUniquePrimeFactorsWithCount (n : Int) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getUniquePrimeFactorsWithProducts (n : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_factors_product_equals_input {n : Int} (h : 0 \u2264 n) :\n  let factors := getAllPrimeFactors n\n  factors \u2260 [] \u2192 factors.foldl (\u00b7*\u00b7) 1 = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_factors_are_ordered {n : Int} (h : 0 \u2264 n) :\n  let factors := getAllPrimeFactors n\n  factors.length > 1 \u2192\n  \u2200 i : Fin (factors.length - 1), factors[i] \u2264 factors[i.val + 1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_inputs {n : Int} (h : n < 0) :\n  getAllPrimeFactors n = [] \u2227\n  getUniquePrimeFactorsWithCount n = [[], []] \u2227\n  getUniquePrimeFactorsWithProducts n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_matches_occurrences {n : Int} (h : 0 \u2264 n) :\n  let factors := getAllPrimeFactors n\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  factors \u2260 [] \u2192\n  \u2200 (p c : Int),\n  List.zip uniqueWithCount[0]! uniqueWithCount[1]! |>.contains (p, c) \u2192\n  (factors.filter (\u00b7= p)).length = c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem products_match_prime_power {n : Int} (h : 0 \u2264 n) :\n  let uniqueWithCount := getUniquePrimeFactorsWithCount n\n  let products := getUniquePrimeFactorsWithProducts n\n  uniqueWithCount[0]! \u2260 [] \u2192\n  products.length = uniqueWithCount[0]!.length \u2227\n  \u2200 (p c prod : Int),\n  List.zip (List.zip uniqueWithCount[0]! uniqueWithCount[1]!) products |>.contains ((p, c), prod) \u2192\n  prod = p * c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases :\n  getAllPrimeFactors 0 = [] \u2227\n  getUniquePrimeFactorsWithCount 0 = [[], []] \u2227\n  getUniquePrimeFactorsWithProducts 0 = [] \u2227\n  getAllPrimeFactors 1 = [1] \u2227\n  getUniquePrimeFactorsWithCount 1 = [[1], [1]] \u2227\n  getUniquePrimeFactorsWithProducts 1 = [1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [2, 2, 5, 5]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 0\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval getAllPrimeFactors 1\n\n/-\ninfo: [[2, 5], [2, 2]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 100\n\n/-\ninfo: [[], []]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 0\n\n/-\ninfo: [[1], [1]]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithCount 1\n\n/-\ninfo: [4, 25]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 100\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 0\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval getUniquePrimeFactorsWithProducts 1"
      }
    ]
  },
  "fvapps_003577.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def name_file (fmt: String) (nbr: Int) (start: Int) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsIndexNo (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def containsNumber (s: String) (n: Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem name_file_length\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr \u2264 1000) (h3: start \u2265 -1000) (h4: start \u2264 1000) :\n  (name_file fmt nbr start).length = nbr := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem name_file_index_numbers\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr \u2264 1000) (h3: start \u2265 -1000) (h4: start \u2264 1000)\n  (h5: containsIndexNo fmt = true) :\n  \u2200 (i: Nat), i < nbr \u2192\n    containsNumber (List.get! (name_file fmt nbr start) i) (start + i) = true := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem name_file_no_index\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr > 0) (h2: nbr \u2264 1000) (h3: start \u2265 -1000) (h4: start \u2264 1000)\n  (h5: containsIndexNo fmt = false) :\n  \u2200 (x: String), x \u2208 name_file fmt nbr start \u2192 x = fmt := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem name_file_invalid_number\n  (fmt: String) (nbr: Int) (start: Int)\n  (h1: nbr \u2264 0) :\n  name_file fmt nbr start = [] := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003578.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def execute (cmd : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidOutput (result : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_format_valid (cmd : String) :\n  isValidOutput (execute cmd) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_input_yields_asterisk (cmd : String) :\n  cmd = \"\" \u2192 execute cmd = \"*\" := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rotation_only_yields_single_point (cmd : String)\n  (h : \u2200 c \u2208 cmd.data, c = 'R') :\n  execute cmd = \"*\" := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_contains_origin (cmd : String) :\n  let result := execute cmd\n  result \u2260 \"*\" \u2192\n  \u2203 line, line \u2208 result.splitOn \"\\r\\n\" \u2227 ('*' \u2208 line.data) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem straight_line_is_continuous (cmd : String)\n  (h : \u2200 c \u2208 cmd.data, c = 'F') :\n  let result := execute cmd\n  (result.data.filter (\u00b7 = '*')).length = cmd.length + 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '*'\n-/\n#guard_msgs in\n#eval execute \"\"\n\n/-\ninfo: '******'\n-/\n#guard_msgs in\n#eval execute \"FFFFF\"\n\n/-\ninfo: '    ****\\r\\n    *  *\\r\\n    *  *\\r\\n********\\r\\n    *   \\r\\n    *   '\n-/\n#guard_msgs in\n#eval execute \"LFFFFFRFFFRFFFRFFFFFFF\""
      }
    ]
  },
  "fvapps_003579.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def to_1D (x y : Nat) (size : Nat \u00d7 Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def to_2D (idx : Nat) (size : Nat \u00d7 Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_1D_to_2D_roundtrip (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let (x2, y2) := to_2D (to_1D x' y' size) size\n  x2 = x' \u2227 y2 = y' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_2D_to_1D_roundtrip (idx width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let idx' := idx % (width * height)\n  let (x, y) := to_2D idx' size\n  to_1D x y size = idx' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem to_1D_bounds (x y width height : Nat) (h1 : width > 0) (h2 : height > 0) :\n  let size := (width, height)\n  let x' := x % width\n  let y' := y % height\n  let idx := to_1D x' y' size\n  0 \u2264 idx \u2227 idx < width * height :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval to_1D 0 0 (3, 3)\n\n/-\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval to_2D 0 (3, 3)\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval to_1D 1 1 (3, 3)\n\n/-\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval to_2D 4 (3, 3)\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval to_1D 2 3 (4, 6)\n\n/-\ninfo: (2, 3)\n-/\n#guard_msgs in\n#eval to_2D 14 (4, 6)"
      }
    ]
  },
  "fvapps_003580.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validateNumber (phone : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def YES : String := \"In with a chance\""
      },
      {
        "type": "sig",
        "string": "def NO : String := \"Plenty more fish in the sea\""
      },
      {
        "type": "cond",
        "string": "theorem valid_number_format (phone : String) (h1 : String.length phone > 0) :\n  validateNumber phone = YES \u2228 validateNumber phone = NO :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_uk_mobile (phone : String) (h1 : String.startsWith phone \"+44\" \u2228 String.startsWith phone \"0\")\n    (h2 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_number_wrong_prefix (phone : String)\n    (h1 : \u00acString.startsWith phone \"+44\" \u2227 \u00acString.startsWith phone \"0\") :\n  validateNumber phone = NO :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_number_wrong_length (phone : String)\n    (h1 : String.length (String.replace phone \"[^0-9]\" \"\") \u2260 11) :\n  validateNumber phone = NO :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem validates_with_dashes (phone : String)\n    (h1 : String.contains phone '-')\n    (h2 : String.startsWith (String.replace phone \"-\" \"\") \"+44\" \u2228\n          String.startsWith (String.replace phone \"-\" \"\") \"0\")\n    (h3 : String.length (String.replace phone \"[^0-9]\" \"\") = 11) :\n  validateNumber phone = YES :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"07454876120\"\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"0745--487-61-20\"\n\n/-\ninfo: 'In with a chance'\n-/\n#guard_msgs in\n#eval validate_number \"+447535514555\"\n\n/-\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"0754876120\"\n\n/-\ninfo: 'Plenty more fish in the sea'\n-/\n#guard_msgs in\n#eval validate_number \"+337535512555\""
      }
    ]
  },
  "fvapps_003595.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def p_num (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def g_p_num (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def s_p_num (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function for pentagonal numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def pen (n : Int) : Int := (3*n*n - n) / 2\n/- Helper function for generalized pentagonal numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def gen_pen (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if n >= 0 then (3*n*n - n) / 2 else (3*n*n + n) / 2"
      },
      {
        "type": "cond",
        "string": "theorem g_p_num_for_gen_pen (n : Int) : g_p_num (gen_pen n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem s_p_num_is_square_of_pentagonal_number {n : Int} (h : s_p_num n = true) :\n  \u2203 k : Int,\n    k * k = n \u2227\n    p_num k = true \u2227\n    g_p_num n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_square_not_s_p_num {n : Int} (h : \u00ac\u2203 k : Int, k * k = n) :\n  s_p_num n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 0\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval p_num 5\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval p_num 100\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 0\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval g_p_num 5\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 1\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval s_p_num 9801\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval s_p_num 100"
      }
    ]
  },
  "fvapps_003596.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def score_throws (radiuses : List Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem score_throws_empty :\n  score_throws [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def throw_points (r : Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if r < 5 then 10\n  else if r \u2264 10 then 5\n  else 0"
      },
      {
        "type": "sig",
        "string": "def bonus_points (radiuses : List Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match radiuses with\n  | [] => 0\n  | xs => if (\u2200 r \u2208 xs, r < 5) then 100 else 0"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval score_throws [1, 5, 11]\n\n/-\ninfo: 140\n-/\n#guard_msgs in\n#eval score_throws [1, 2, 3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval score_throws []"
      }
    ]
  },
  "fvapps_003598.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def moment_of_time_in_space (s : String) : List Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_digits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_non_digits (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_three_bools (s : String) :\n  let result := moment_of_time_in_space s\n  List.length result = 3 \u2227\n  List.all result (fun x => x = true \u2228 x = false) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exactly_one_true (s : String) :\n  let result := moment_of_time_in_space s\n  let count := List.foldl (fun acc b => acc + if b then 1 else 0) 0 result\n  count = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_space_comparison (s : String) :\n  let time := sum_digits s\n  let space := count_non_digits s\n  let result := moment_of_time_in_space s\n  (time < space \u2192 result = [true, false, false]) \u2227\n  (time = space \u2192 result = [false, true, false]) \u2227\n  (time > space \u2192 result = [false, false, true]) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutation_invariant {s\u2081 s\u2082 : String} :\n  s\u2081.length = s\u2082.length \u2192\n  (\u2200 c, s\u2081.find (\u00b7 = c) = s\u2082.find (\u00b7 = c)) \u2192\n  moment_of_time_in_space s\u2081 = moment_of_time_in_space s\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [True, False, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"01:00 pm\"\n\n/-\ninfo: [False, True, False]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:02 pm\"\n\n/-\ninfo: [False, False, True]\n-/\n#guard_msgs in\n#eval moment_of_time_in_space \"12:30 pm\""
      }
    ]
  },
  "fvapps_003601.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def nth_smallest (arr : List Int) (n : Nat) : Option Int := sorry\n\ndef contains (xs : List Int) (x : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc y => acc || y == x) false"
      },
      {
        "type": "sig",
        "string": "def countLessThan (xs : List Int) (x : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc y => if y < x then acc + 1 else acc) 0"
      },
      {
        "type": "sig",
        "string": "def uniqueList (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc x => if contains acc x then acc else x::acc) []"
      },
      {
        "type": "sig",
        "string": "def minimum (xs : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc x => match acc with\n    | none => some x\n    | some m => some (min x m)) none"
      },
      {
        "type": "sig",
        "string": "def maximum (xs : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (fun acc x => match acc with\n    | none => some x\n    | some m => some (max x m)) none"
      },
      {
        "type": "cond",
        "string": "theorem nth_smallest_properties {arr : List Int} {n : Nat} (h : n \u2265 1) :\n  match nth_smallest arr n with\n  | none => n > (uniqueList arr).length\n  | some result =>\n    (n \u2264 (uniqueList arr).length) \u2227\n    contains arr result \u2227\n    countLessThan (uniqueList arr) result = n-1\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nth_smallest_first {arr : List Int} (h : arr \u2260 []) :\n  nth_smallest arr 1 = minimum (uniqueList arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nth_smallest_last_valid {arr : List Int} (h : arr \u2260 []) :\n  nth_smallest arr (uniqueList arr).length = maximum (uniqueList arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nth_smallest_empty :\n  nth_smallest [] 1 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval nth_smallest [14, 12, 46, 34, 334] 3\n\n/-\ninfo: 4000\n-/\n#guard_msgs in\n#eval nth_smallest [4000] 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval nth_smallest [14, 12, 46, 0, 334] 1"
      }
    ]
  },
  "fvapps_003604.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_the_ball (start : Nat) (swaps : List (Nat \u00d7 Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def iterateN (f : Nat \u2192 Nat) : Nat \u2192 Nat \u2192 Nat\n  | 0, x => x\n  | n+1, x => iterateN f n (f x)"
      },
      {
        "type": "cond",
        "string": "theorem find_the_ball_no_swaps (start : Nat) :\n  find_the_ball start [] = start :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_the_ball 5 []\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2)]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_the_ball 0 [(0, 1), (1, 2), (2, 3)]"
      }
    ]
  },
  "fvapps_003607.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def spreadsheet (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_a1 (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_r1c1 (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem a1_conversion {s : String} (h : is_valid_a1 s = true) :\n  is_valid_r1c1 (spreadsheet s) = true \u2227\n  spreadsheet (spreadsheet s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem r1c1_conversion {s : String} (h : is_valid_r1c1 s = true) :\n  is_valid_a1 (spreadsheet s) = true \u2227\n  spreadsheet (spreadsheet s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem conversion_idempotent_a1 {s : String} (h : is_valid_a1 s = true) :\n  spreadsheet (spreadsheet s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem conversion_idempotent_r1c1 {s : String} (h : is_valid_r1c1 s = true) :\n  spreadsheet (spreadsheet s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'R1C1'\n-/\n#guard_msgs in\n#eval spreadsheet \"A1\"\n\n/-\ninfo: 'AA48'\n-/\n#guard_msgs in\n#eval spreadsheet \"R48C27\"\n\n/-\ninfo: 'R12C63'\n-/\n#guard_msgs in\n#eval spreadsheet \"BK12\""
      }
    ]
  },
  "fvapps_003619.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Real := Int -- Simplified for demo\n\ndef does_fred_need_houseboat (x y : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def pi : Int := 3 -- Simplified for demo\n\ndef ceil (r : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem does_fred_need_houseboat_nonnegative {x y : Int} (h : y \u2265 0) :\n  does_fred_need_houseboat x y \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem does_fred_need_houseboat_symmetric {x y : Int} (h : y \u2265 0) :\n  does_fred_need_houseboat x y = does_fred_need_houseboat (-x) y := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem does_fred_need_houseboat_increases {x y cx cy : Int}\n  (h1 : y \u2265 0)\n  (h2 : x.natAbs > 0 \u2228 y > 0)\n  (h3 : cx = x / 2)\n  (h4 : cy = y / 2) :\n  does_fred_need_houseboat x y \u2265 does_fred_need_houseboat cx cy := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem does_fred_need_houseboat_formula {x y : Int} (h : y \u2265 0) :\n  does_fred_need_houseboat x y = ceil (pi * ((x * x) + (y * y)) / 100) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 1 1\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 25 0\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval does_fred_need_houseboat 10 10"
      }
    ]
  },
  "fvapps_003621.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def coprimes (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat := sorry\n\ndef countCoprimes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  (List.range n).filter (fun x => gcd x n = 1) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem coprimes_all_less (n : Nat) (h : n \u2265 2) :\n  \u2200 x \u2208 coprimes n, x > 0 \u2227 x < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval coprimes 2\n\n/-\ninfo: [1, 2]\n-/\n#guard_msgs in\n#eval coprimes 3\n\n/-\ninfo: [1, 3, 7, 9]\n-/\n#guard_msgs in\n#eval coprimes 10"
      }
    ]
  },
  "fvapps_003627.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def chinese_zodiac (year : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Elements := [\"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\"]"
      },
      {
        "type": "sig",
        "string": "def Animals := [\"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\",\n               \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\"]\n\ndef String.splitToList (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  s.split (\u00b7 = ' ')"
      },
      {
        "type": "cond",
        "string": "theorem cycle_12_years {y : Int} (h : y \u2265 1900 \u2227 y \u2264 2100) :\n  (chinese_zodiac y).splitToList[1]! = (chinese_zodiac (y + 12)).splitToList[1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cycle_10_years {y : Int} (h : y \u2265 1900 \u2227 y \u2264 2100) :\n  (chinese_zodiac y).splitToList[0]! = (chinese_zodiac (y + 10)).splitToList[0]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_format {year : Int} (h : year \u2265 1900 \u2227 year \u2264 2100) :\n  let result := chinese_zodiac year\n  let parts := result.splitToList\n  parts[0]! \u2208 Elements \u2227 parts[1]! \u2208 Animals :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem deterministic {year : Int} (h : year \u2265 1900 \u2227 year \u2264 2100) :\n  chinese_zodiac year = chinese_zodiac year :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Wood Snake'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1965\n\n/-\ninfo: 'Earth Tiger'\n-/\n#guard_msgs in\n#eval chinese_zodiac 1998\n\n/-\ninfo: 'Fire Monkey'\n-/\n#guard_msgs in\n#eval chinese_zodiac 2016"
      }
    ]
  },
  "fvapps_003631.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def filter_words (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem filter_words_output_is_string (s : String) :\n  filter_words s = filter_words s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to count occurrences of a substring -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def countSubstr (s : String) (sub : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to check if a string contains a substring -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def containsSubstr (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem filter_words_idempotent (s : String) :\n  filter_words (filter_words s) = filter_words s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem filter_words_preserves_other_content (s : String) :\n  let banned_pattern := \"bad|mean|ugly|horrible|hideous\"\n  let remove_banned (str : String) := str.replace banned_pattern \"\"\n  remove_banned s = remove_banned (filter_words s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003633.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Float.toDegrees (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def Int.toFloat (x : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def missing_angle (h a o : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_output_range (h a o : Float) :\n  h > 0 \u2228 a > 0 \u2228 o > 0 \u2192\n  let angle := missing_angle h a o\n  0 \u2264 angle \u2227 angle \u2264 90 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_with_missing_hyp (a o : Float) :\n  a > 0 \u2227 o > 0 \u2192\n  let angle := missing_angle 0 a o\n  (Int.toFloat angle - Float.toDegrees ((o/a).atan)).abs \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_with_missing_adj (h o : Float) :\n  h > 0 \u2227 o > 0 \u2192\n  let angle := missing_angle h 0 o\n  (Int.toFloat angle - Float.toDegrees ((o/h).asin)).abs \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_with_missing_opp (h a : Float) :\n  h > 0 \u2227 a > 0 \u2192\n  let angle := missing_angle h a 0\n  (Int.toFloat angle - Float.toDegrees ((a/h).acos)).abs \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_two_zeros (o : Float) :\n  o > 0 \u2192\n  \u00ac\u2203angle, missing_angle 0 0 o = angle :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_angle_invalid_triangle (h a : Float) :\n  h > 0 \u2227 a > 0 \u2192\n  a > h \u2192\n  \u00ac\u2203angle, missing_angle h a 0 = angle :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 0 400 300\n\n/-\ninfo: 37\n-/\n#guard_msgs in\n#eval missing_angle 5 4 0\n\n/-\ninfo: 39\n-/\n#guard_msgs in\n#eval missing_angle 8 0 5"
      }
    ]
  },
  "fvapps_003635.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def build_square (blocks: List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem sum_16_if_buildable {blocks : List Nat} :\n  build_square blocks = true \u2192\n  list_sum blocks \u2265 16 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem input_unchanged {blocks : List Nat} :\n  build_square blocks = b \u2192\n  blocks = blocks :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_pieces {blocks : List Nat} :\n  (\u2200 x \u2208 blocks, x < 1 \u2228 x > 4) \u2192\n  build_square blocks = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [1, 1, 1, 1, 1, 1, 1, 2, 3, 4]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval build_square [1, 3, 2, 4, 3, 3, 2]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval build_square [4, 2, 2, 1, 1, 1, 1, 3, 3, 3, 1]"
      }
    ]
  },
  "fvapps_003640.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palin (length pos : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_palindrome (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def num_length (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_palindromes (pos : Nat) (h : 0 < pos \u2227 pos < 10) :\n  let result := palin 1 pos\n  result = pos \u2227 result < 10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval palin 2 2\n\n/-\ninfo: 1441\n-/\n#guard_msgs in\n#eval palin 4 5\n\n/-\ninfo: 102201\n-/\n#guard_msgs in\n#eval palin 6 3"
      }
    ]
  },
  "fvapps_003649.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def REGION : String := \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\""
      },
      {
        "type": "sig",
        "string": "def encrypt (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def decrypt (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidText (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def charAtPos (s : String) (pos : Nat) : Char := s.data[pos]!"
      },
      {
        "type": "cond",
        "string": "theorem encryption_decryption_roundtrip (s : String) (h : isValidText s = true) :\n  decrypt (encrypt s) = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem encrypted_uses_valid_chars (s : String) (h : isValidText s = true) (h2 : s \u2260 \"\") :\n  isValidText (encrypt s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_chars_raise_exception (s : String) (h : isValidText s = false) :\n  encrypt s = \"\" \u2227 decrypt s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  encrypt \"\" = \"\" \u2227 decrypt \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem second_chars_different (s : String) (h : isValidText s = true) (h2 : s.length \u2265 2) :\n  encrypt s \u2260 s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem first_char_mirrored (s : String) (h : isValidText s = true) (h2 : s \u2260 \"\") :\n  (charAtPos (encrypt s) 0) = (charAtPos REGION (REGION.length - 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: encrypted1\n-/\n#guard_msgs in\n#eval encrypt \"Business\"\n\n/-\ninfo: text1\n-/\n#guard_msgs in\n#eval decrypt encrypted1\n\n/-\ninfo: encrypted2\n-/\n#guard_msgs in\n#eval encrypt \"This is a test!\"\n\n/-\ninfo: text2\n-/\n#guard_msgs in\n#eval decrypt encrypted2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval encrypt \"\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval decrypt \"\""
      }
    ]
  },
  "fvapps_003663.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def unscramble_eggs (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsEgg (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countSpaces (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_eggs_in_result (s : String) :\n  containsEgg (unscramble_eggs s) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem preserves_space_count (s : String) :\n  countSpaces s = countSpaces (unscramble_eggs s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'code here'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"ceggodegge heggeregge\"\n\n/-\ninfo: 'FUN KATA'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"FeggUNegg KeggATeggA\"\n\n/-\ninfo: 'vegymite on toast'\n-/\n#guard_msgs in\n#eval unscramble_eggs \"veggegeggyeggmeggitegge onegg teggoaseggtegg\""
      }
    ]
  },
  "fvapps_003669.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def int32_to_ip (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toOctets (n : Nat) : List Nat := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.data.filter (\u00b7 = c) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem int32_to_ip_has_three_dots (n : Nat)\n    (h : n < 2^32) :\n    let result := int32_to_ip n\n    (countChar result '.' = 3) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem int32_to_ip_octets_valid (n : Nat)\n    (h : n < 2^32) :\n    let octets := toOctets n\n    (octets.length = 4 \u2227\n     octets.all (fun x => x \u2264 255)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem int32_to_ip_preserves_value (n : Nat)\n    (h : n < 2^32) :\n    let octets := toOctets n\n    let reconstructed := (octets.get! 0) * 256^3 +\n                        (octets.get! 1) * 256^2 +\n                        (octets.get! 2) * 256^1 +\n                        (octets.get! 3) * 256^0\n    (reconstructed = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem int32_to_ip_format (octets : List Nat)\n    (h1 : octets.length = 4)\n    (h2 : octets.all (fun x => x \u2264 255)) :\n    let n := (octets.get! 0) * 256^3 +\n             (octets.get! 1) * 256^2 +\n             (octets.get! 2) * 256^1 +\n             (octets.get! 3) * 256^0\n    (int32_to_ip n = String.intercalate \".\" (octets.map toString)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '128.114.17.104'\n-/\n#guard_msgs in\n#eval int32_to_ip 2154959208\n\n/-\ninfo: '0.0.0.0'\n-/\n#guard_msgs in\n#eval int32_to_ip 0\n\n/-\ninfo: '128.32.10.1'\n-/\n#guard_msgs in\n#eval int32_to_ip 2149583361"
      }
    ]
  },
  "fvapps_003677.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort_it (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isCharNSorted (words : List String) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sameSets (s1 : List String) (s2 : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def wordsFromString (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_it_preserves_words (s : String) (n : Nat) :\n  n > 0 \u2192 sameSets (wordsFromString s) (wordsFromString (sort_it s n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_it_is_n_sorted (s : String) (n : Nat) (h : n > 0) :\n  isCharNSorted (wordsFromString (sort_it s n)) n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_it_first_char_is_normal_sort (s : String) :\n  sort_it s 1 = String.intercalate \", \" (wordsFromString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003678.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.product (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def product_sans_n (nums : List Int) : List Int := sorry\n\ndef count_zeros (l : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.filter (\u00b7 = 0) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem product_sans_n_length {nums : List Int} (h : nums \u2260 []) :\n  (product_sans_n nums).length = nums.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [24, 12, 8, 6]\n-/\n#guard_msgs in\n#eval product_sans_n [1, 2, 3, 4]\n\n/-\ninfo: [0, -18, 0]\n-/\n#guard_msgs in\n#eval product_sans_n [9, 0, -2]\n\n/-\ninfo: [0, 0, 0]\n-/\n#guard_msgs in\n#eval product_sans_n [0, -99, 0]"
      }
    ]
  },
  "fvapps_003681.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def translateTableNum (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def t9_predict (words : List String) (seq : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem t9_predict_never_empty (words : List String) (seq : String) :\n  seq \u2260 \"\" \u2192 \u2203 result, t9_predict words seq = result \u2227 result.length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem t9_predict_fallback_on_no_matches (words : List String) (seq : String) :\n  seq \u2260 \"\" \u2192\n  (\u2200 w \u2208 words, translateTableNum w.toLower \u2260 seq) \u2192\n  \u2203 result, t9_predict words seq = [result] \u2227 result.length = seq.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem t9_predict_all_matches_sequence (words : List String) (seq : String) :\n  seq \u2260 \"\" \u2192\n  \u2200 w \u2208 t9_predict words seq, translateTableNum w.toLower = seq :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem t9_predict_empty_dict (seq : String) :\n  seq \u2260 \"\" \u2192\n  \u2203 result, t9_predict [] seq = [result] \u2227 result.length = seq.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['hello']\n-/\n#guard_msgs in\n#eval t9_predict [\"hello\", \"world\"] \"43556\"\n\n/-\ninfo: ['good', 'home']\n-/\n#guard_msgs in\n#eval t9_predict [\"good\", \"home\", \"new\"] \"4663\"\n\n/-\ninfo: ['gdjjm']\n-/\n#guard_msgs in\n#eval t9_predict [] \"43556\""
      }
    ]
  },
  "fvapps_003683.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.toFloat (s : String) : Option Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Float) (lt : Float \u2192 Float \u2192 Bool) : List Float := sorry\n\ndef search (budget : Float) (prices : List Float) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem search_sorted (budget : Float) (prices : List Float)\n  (h1 : budget \u2265 0) (h2 : budget \u2264 1000)\n  (h3 : \u2200 x \u2208 prices, x \u2265 0 \u2227 x \u2264 1000)\n  (h4 : prices \u2260 []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  \u2200 i, i < nums.length - 1 \u2192 nums[i]! \u2264 nums[i+1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem search_within_budget (budget : Float) (prices : List Float)\n  (h1 : budget \u2265 0) (h2 : budget \u2264 1000)\n  (h3 : \u2200 x \u2208 prices, x \u2265 0 \u2227 x \u2264 1000)\n  (h4 : prices \u2260 []) :\n  let result := search budget prices\n  let nums := (result.splitOn \",\").filterMap String.toFloat\n  \u2200 x \u2208 nums, x \u2264 budget :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem search_includes_all_eligible (budget : Float) (prices : List Float)\n  (h1 : budget \u2265 0) (h2 : budget \u2264 1000)\n  (h3 : \u2200 x \u2208 prices, x \u2265 0 \u2227 x \u2264 1000)\n  (h4 : prices \u2260 []) :\n  let eligible := List.sort (prices.filter (\u00b7 \u2264 budget)) (\u00b7\u2264\u00b7)\n  let result := search budget prices\n  result = String.intercalate \",\" (eligible.map toString) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem search_zero_budget (prices : List Float)\n  (h1 : \u2200 x \u2208 prices, x \u2265 0)\n  (h2 : prices \u2260 []) :\n  let eligible := List.sort (prices.filter (\u00b7\u2264 0)) (\u00b7\u2264\u00b7)\n  search 0 prices = String.intercalate \",\" (eligible.map toString) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1,2,2'\n-/\n#guard_msgs in\n#eval search 3 [6, 1, 2, 9, 2]\n\n/-\ninfo: '3,7,7,9,14'\n-/\n#guard_msgs in\n#eval search 14 [7, 3, 23, 9, 14, 20, 7]\n\n/-\ninfo: '0,1,2.7,5.5'\n-/\n#guard_msgs in\n#eval search 24 [2.7, 0, 100.9, 1, 5.5]"
      }
    ]
  },
  "fvapps_003685.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def validCodon (c : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def protein (rna : String) : String := sorry\n\ndef isStopCodon (codon : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  codon = \"UAA\" || codon = \"UAG\" || codon = \"UGA\""
      },
      {
        "type": "sig",
        "string": "def charsToCodon (chars : List Char) : String :="
      },
      {
        "type": "impl",
        "string": "  String.mk chars"
      },
      {
        "type": "sig",
        "string": "def groupsOf3 (xs : List \u03b1) : List (List \u03b1) :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => []\n  | x\u2081::xs\u2081 => match xs\u2081 with\n    | [] => [[x\u2081]]\n    | x\u2082::xs\u2082 => match xs\u2082 with\n      | [] => [[x\u2081, x\u2082]]\n      | x\u2083::xs\u2083 => [x\u2081, x\u2082, x\u2083]::(groupsOf3 xs\u2083)"
      },
      {
        "type": "cond",
        "string": "theorem protein_length_le_input_div_3 {rna : String} (h : protein rna \u2260 \"\") :\n  (protein rna).length \u2264 rna.length / 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem protein_valid_acids {rna : String} (h : protein rna \u2260 \"\") :\n  \u2200 c, c \u2208 (protein rna).data \u2192\n    c \u2208 ['F', 'L', 'I', 'M', 'V', 'S', 'P', 'T', 'A', 'G', 'Y', 'C', 'H', 'N', 'K', 'D', 'E', 'Q', 'W', 'R', 'G'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem protein_stops_at_first_stop {rna : String} (h : protein rna \u2260 \"\") :\n  let codons := (rna.data.take (rna.length / 3 * 3)) |> groupsOf3 |>.map charsToCodon\n  let firstStop := match List.findIdx? isStopCodon codons with\n    | none => codons.length\n    | some n => n\n  (protein rna).length \u2264 firstStop :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem protein_returns_string_length {rna : String} (h : \u2200 c, c \u2208 rna.data \u2192 c \u2208 ['A', 'U', 'G', 'C']) :\n  protein rna \u2260 \"\" \u2192 (protein rna).length \u2264 rna.length / 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'M'\n-/\n#guard_msgs in\n#eval protein \"AUGUGA\"\n\n/-\ninfo: 'CDEWARS'\n-/\n#guard_msgs in\n#eval protein \"UGCGAUGAAUGGGCUCGCUCC\"\n\n/-\ninfo: 'MLQVHWKRRGKTS'\n-/\n#guard_msgs in\n#eval protein \"AUGCUUCAAGUGCACUGGAAAAGGAGAGGGAAAACCAGUUGA\""
      }
    ]
  },
  "fvapps_003688.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.findSubstr? (pattern : String) (s : String) : Option String.Pos :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gym_slang (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gym_slang_length (s : String) :\n  String.length (gym_slang s) \u2264 String.length s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gym_slang_case_preserving_prob (s : String) :\n  (String.findSubstr? \"Probably\" s).isSome \u2192 (String.findSubstr? \"Prolly\" (gym_slang s)).isSome :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gym_slang_case_preserving_prob_lower (s : String) :\n  (String.findSubstr? \"probably\" s).isSome \u2192 (String.findSubstr? \"prolly\" (gym_slang s)).isSome :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gym_slang_all_transformations (s : String) :\n  let sLower := s.toLower\n  let resultLower := (gym_slang s).toLower\n  (Option.isSome (String.findSubstr? \"probably\" sLower) \u2194 Option.isSome (String.findSubstr? \"prolly\" resultLower)) \u2227\n  (Option.isSome (String.findSubstr? \"combination\" sLower) \u2194 Option.isSome (String.findSubstr? \"combo\" resultLower)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gym_slang_identity (s : String) :\n  (Option.isNone (String.findSubstr? \"probably\" s.toLower)) \u2192\n  (Option.isNone (String.findSubstr? \"i am\" s.toLower)) \u2192\n  (Option.isNone (String.findSubstr? \"instagram\" s.toLower)) \u2192\n  (Option.isNone (String.findSubstr? \"do not\" s.toLower)) \u2192\n  (Option.isNone (String.findSubstr? \"going to\" s.toLower)) \u2192\n  (Option.isNone (String.findSubstr? \"combination\" s.toLower)) \u2192\n  gym_slang s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003691.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pattern (n : Nat) : String := sorry\n\ndef isSingleDigit (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  '0' \u2264 c \u2227 c \u2264 '9'"
      },
      {
        "type": "sig",
        "string": "def stringContainsSubstr (s : String) (substr : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringContainsChar (s : String) (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringRepeat (n : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_positive_input_returns_empty_string {n : Int} (h : n \u2264 0) :\n  pattern n.toNat = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_correct {n : Nat} (h1 : n \u2265 1) (h2 : n \u2264 9) :\n  let lines := (pattern n).splitOn \"\\n\"\n  let middle := lines.get! (n-1)\n  (\u2200 i : Nat, 1 \u2264 i \u2227 i < n \u2192 stringContainsSubstr middle (toString i)) \u2227\n  stringContainsSubstr middle (stringRepeat n (toString n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem double_digit_wrapping {n : Nat} (h1 : n \u2265 10) (h2 : n \u2264 100) :\n  let lines := (pattern n).splitOn \"\\n\"\n  let middle := lines.get! (n-1)\n  \u2200 c \u2208 middle.data, isSingleDigit c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval pattern 3\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval pattern 5\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern -3"
      }
    ]
  },
  "fvapps_003698.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_returns_either_upper_or_lower (s : String) :\n  (solve s = s.toUpper) \u2228 (solve s = s.toLower) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_preserves_uppercase (s : String) :\n  isUpper s = true \u2192 solve s = s.toUpper :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_preserves_lowercase (s : String) :\n  isLower s = true \u2192 solve s = s.toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_preserves_length (s : String) :\n  (solve s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDe\"\n\n/-\ninfo: 'CODE'\n-/\n#guard_msgs in\n#eval solve \"CODe\"\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval solve \"coDE\""
      }
    ]
  },
  "fvapps_003700.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solution (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_nonnegative (n : Int) :\n  solution n \u2265 0 \u2227 (n \u2264 0 \u2192 solution n = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumMultiples (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  (List.range n).map Int.ofNat\n  |>.filter (fun x => x % 3 = 0 \u2228 x % 5 = 0)\n  |>.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem multiples_property {n : Nat} :\n  0 < n \u2192\n  solution (Int.ofNat n) = sumMultiples n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_smaller_than_input_squared {n : Int} :\n  n > 0 \u2192 solution n < n * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_inputs :\n  \u2200 n : Int, n < 0 \u2192 solution n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval solution 10\n\n/-\ninfo: 78\n-/\n#guard_msgs in\n#eval solution 20\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solution 0"
      }
    ]
  },
  "fvapps_003707.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.isDigit : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def missing : String \u2192 Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSequence : String \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- For a sequence with one number removed, missing finds the removed number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem missing_finds_gap {start : Nat} (h : start \u2265 1 \u2227 start \u2264 99) :\n  \u2200 seq target,\n  (\u2203 curr, curr = start \u2227\n    seq = String.join (List.map toString (List.range curr)) \u2227\n    target = curr + 1 \u2227\n    isSequence (seq.replace (toString target) \"\")) \u2192\n  missing (seq.replace (toString target) \"\") = target :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- For a complete sequence with no gaps, missing returns -1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem missing_complete_sequence {start : Nat} (h : start \u2265 1 \u2227 start \u2264 999) :\n  \u2200 seq,\n  (\u2203 curr, curr = start \u2227\n    seq = String.join (List.map toString (List.range curr)) \u2227\n    isSequence seq) \u2192\n  missing seq = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval missing \"123567\"\n\n/-\ninfo: 92\n-/\n#guard_msgs in\n#eval missing \"899091939495\"\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval missing \"9899101102\""
      }
    ]
  },
  "fvapps_003710.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.isPermutationOf (l1 l2 : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 x, (l1.filter (\u00b7 = x)).length = (l2.filter (\u00b7 = x)).length"
      },
      {
        "type": "cond",
        "string": "theorem solve_output_length {arr : List Int} (h : arr \u2260 []) :\n  (solve arr).length = arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_contains_same_elements {arr : List Int} (h : arr \u2260 []) :\n  (solve arr).isPermutationOf arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_maintains_frequency_order {arr : List Int} (h : arr \u2260 []) :\n  let freq := fun x => (arr.filter (\u00b7 = x)).length\n  \u2200 i, i + 1 < (solve arr).length \u2192\n    let curr := (solve arr).get! i\n    let next := (solve arr).get! (i+1)\n    freq curr > freq next \u2228\n    (freq curr = freq next \u2227 curr \u2264 next) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_idempotent {arr : List Int} (h : arr \u2260 []) :\n  solve (solve arr) = solve arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval solve [2, 3, 5, 3, 7, 9, 5, 3, 7]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval solve [1, 2, 3, 0, 5, 0, 1, 6, 8, 8, 6, 9, 1]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval solve [5, 9, 6, 9, 6, 5, 9, 9, 4, 4]"
      }
    ]
  },
  "fvapps_003712.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def operator_insertor (n : Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem operator_insertor_output_range (n : Int) :\n  match operator_insertor n with\n  | none => True\n  | some result => 0 \u2264 result \u2227 result \u2264 8\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def expr_evaluates_to : Int \u2192 String \u2192 Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to check if expression uses given operators -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def expr_uses_ops : List String \u2192 String \u2192 Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem operator_insertor_result_exists (n : Int) (result : Int) :\n  operator_insertor n = some result \u2192\n  \u2203 ops : List String,\n    (ops.length = result) \u2227\n    (\u2200 op \u2208 ops, op = \"+\" \u2228 op = \"-\" \u2228 op = \"\") \u2227\n    (\u2203 expr : String, expr_evaluates_to n expr \u2227 expr_uses_ops ops expr)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem operator_insertor_impossible_large (n : Int) :\n  n \u2265 10^10 \u2192 operator_insertor n = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem operator_insertor_impossible_small (n : Int) :\n  n \u2264 -(10^10) \u2192 operator_insertor n = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Helper function to check if a string expression evaluates to a number -/\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval operator_insertor 11\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval operator_insertor 100\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval operator_insertor 160"
      }
    ]
  },
  "fvapps_003714.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def arr2bin (arr : List \u03b1) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toBinaryString (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arr2bin_all_ints {arr : List Int} :\n  arr2bin arr = toBinaryString (sumList arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allBinary (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAllInts (arr : List \u03b1) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listToInts (arr : List \u03b1) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arr2bin_empty :\n  arr2bin ([] : List \u03b1) = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arr2bin_positive_ints {arr : List Nat} :\n  let result := arr2bin arr\n  allBinary result \u2227\n  stringToNat result = arr.foldl (init := 0) (\u00b7+\u00b7) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arr2bin_mixed_types {\u03b1} {arr : List \u03b1} :\n  (\u00acisAllInts arr \u2192 arr2bin arr = \"\") \u2227\n  (isAllInts arr \u2192 arr2bin arr = toBinaryString (sumList (listToInts arr))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '11'\n-/\n#guard_msgs in\n#eval arr2bin [1, 2]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval arr2bin [1, 2, \"a\"]\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval arr2bin []"
      }
    ]
  },
  "fvapps_003717.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countCarries (input : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def carry_count (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def split (s : String) : List String := String.splitOn s \"\\n\""
      },
      {
        "type": "cond",
        "string": "theorem single_line_carries_correct\n  (a b : Nat)\n  (h1 : a \u2264 999999)\n  (h2 : b \u2264 999999) :\n  let result := countCarries s!\"{a} {b}\"\n  let expected :=\n    let carry := carry_count a b\n    if carry = 0 then \"No carry operation\"\n    else s!\"{carry} carry operations\"\n  result = expected :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_lines_carries_length\n  {n : Nat}\n  (pairs : List (Nat \u00d7 Nat))\n  (h1 : \u2200 p : Nat \u00d7 Nat, p \u2208 pairs \u2192 (Prod.fst p) \u2264 9999 \u2227 (Prod.snd p) \u2264 9999)\n  (h2 : pairs.length > 0)\n  (h3 : pairs.length \u2264 10) :\n  let input := String.intercalate \"\\n\" (pairs.map (\u03bb p => s!\"{Prod.fst p} {Prod.snd p}\"))\n  (split (countCarries input)).length = pairs.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_carries_correct\n  (a b : Nat)\n  (h1 : a \u2264 9)\n  (h2 : b \u2264 9) :\n  countCarries s!\"{a} {b}\" =\n    if a + b > 9 then \"1 carry operations\"\n    else \"No carry operation\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval count_carries \"123 456\\n555 555\\n123 594\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval count_carries \"99 99\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval count_carries \"1 9\\n123456789 111111101\""
      }
    ]
  },
  "fvapps_003718.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mean_vs_median (l : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def statistical_mean (l : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def statistical_median (l : List Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mean_vs_median_matches_statistics (l : List Int) (h : l \u2260 []) :\n  let mean := statistical_mean l\n  let median := statistical_median l\n  mean_vs_median l = (if mean > median then \"mean\"\n                     else if median > mean then \"median\"\n                     else \"same\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_numbers_return_same (l : List Int) (h1 : l \u2260 [])\n  (h2 : \u2200 x \u2208 l, x = 1) :\n  mean_vs_median l = \"same\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'same'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 1, 1]\n\n/-\ninfo: 'mean'\n-/\n#guard_msgs in\n#eval mean_vs_median [1, 2, 37]\n\n/-\ninfo: 'median'\n-/\n#guard_msgs in\n#eval mean_vs_median [7, 14, -70]"
      }
    ]
  },
  "fvapps_003722.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hamming_distance : Int \u2192 Int \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Hamming distance is symmetric -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_symmetric (a b : Int) :\n  hamming_distance a b = hamming_distance b a := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- Hamming distance between a number and itself is zero -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_self_zero (a : Int) :\n  hamming_distance a a = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Hamming distance satisfies the triangle inequality -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_triangle_inequality (a b c : Int) :\n  hamming_distance a c \u2264 hamming_distance a b + hamming_distance b c := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Hamming distance is always nonnegative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hamming_distance_nonnegative (a b : Int) :\n  hamming_distance a b \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 25 87\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 256 302\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming_distance 543 634"
      }
    ]
  },
  "fvapps_003726.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def check_root (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sqrt (n : Nat) : Nat := sorry\n\ndef is_consecutive (a b c d : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  b = a + 1 \u2227 c = b + 1 \u2227 d = c + 1"
      },
      {
        "type": "sig",
        "string": "def countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_input (s : String)\n  (h : s.isEmpty \u2228\n       (countChar s ',' \u2260 3) \u2228\n       \u00ac(s.split (fun x => x = ',') |>.all (fun n => n.all (fun c => c.isDigit \u2228 c = '-')))) :\n  check_root s = \"incorrect input\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_valid {a b c d : Int} (h : is_consecutive a b c d) :\n  check_root s!\"{a},{b},{c},{d}\" =\n    let prod := a * b * c * d + 1\n    s!\"{prod}, {sqrt prod.toNat}\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_consecutive {a b c d : Int} (h : \u00acis_consecutive a b c d) :\n  check_root s!\"{a},{b},{c},{d}\" = \"not consecutive\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '25, 5'\n-/\n#guard_msgs in\n#eval check_root \"1,2,3,4\"\n\n/-\ninfo: '25, 5'\n-/\n#guard_msgs in\n#eval check_root \"-4,-3,-2,-1\"\n\n/-\ninfo: 'incorrect input'\n-/\n#guard_msgs in\n#eval check_root \"1,2,3\"\n\n/-\ninfo: 'not consecutive'\n-/\n#guard_msgs in\n#eval check_root \"1,3,5,7\""
      }
    ]
  },
  "fvapps_003727.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digSum (n : Nat) (p : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def digPow (n : Nat) (p : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_valid_result {n p : Nat} (h : digPow n p \u2260 -1) :\n  digSum n p = (digPow n p).toNat * n \u2227 digPow n p > 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_is_int (n p : Nat) :\n  \u2203 k : Int, digPow n p = k := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_power_one (n : Nat) :\n  digSum n 1 % n = 0 \u2192\n  digPow n 1 = (digSum n 1) / n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_power_one_neg (n : Nat) :\n  digSum n 1 % n \u2260 0 \u2192\n  digPow n 1 = -1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_single_digit_power_one (n : Nat) :\n  n > 0 \u2192 n < 10 \u2192\n  digPow n 1 = 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem digPow_large_power_is_int (n p : Nat) :\n  \u2203 k : Int, digPow n p = k := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval dig_pow 89 1\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval dig_pow 92 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval dig_pow 695 2"
      }
    ]
  },
  "fvapps_003730.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def dollar_to_speech (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.containsStr (s\u2081 s\u2082 : String) : Bool := sorry\n\ndef formatDollarString (d c : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  s!\"${d}.{c}\""
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_ends_with_period (d c : Nat) (h : c < 100) :\n  (dollar_to_speech (formatDollarString d c)).endsWith \".\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_single_dollar (d c : Nat) (h : c < 100)\n    (s := formatDollarString d c) (h\u2082 : d = 1) :\n  (dollar_to_speech s).containsStr \"1 dollar\" \u2227\n  \u00ac(dollar_to_speech s).containsStr \"dollars\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_multiple_dollars (d c : Nat) (h : c < 100)\n    (s := formatDollarString d c) (h\u2082 : d > 1) :\n  (dollar_to_speech s).containsStr s!\"{d} dollars\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_single_cent (d c : Nat) (h : c < 100)\n    (s := formatDollarString d c) (h\u2082 : c = 1) :\n  (dollar_to_speech s).containsStr \"1 cent\" \u2227\n  \u00ac(dollar_to_speech s).containsStr \"cents\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_multiple_cents (d c : Nat) (h : c < 100)\n    (s := formatDollarString d c) (h\u2082 : c > 1) :\n  (dollar_to_speech s).containsStr s!\"{c} cents\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dollar_to_speech_and_connector (d c : Nat) (h : c < 100)\n    (s := formatDollarString d c) :\n  (d > 0 \u2227 c > 0) \u2194 (dollar_to_speech s).containsStr \" and \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '0 dollars.'\n-/\n#guard_msgs in\n#eval dollar_to_speech \"$0.00\"\n\n/-\ninfo: '1 dollar.'\n-/\n#guard_msgs in\n#eval dollar_to_speech \"$1.00\"\n\n/-\ninfo: '20 dollars and 18 cents.'\n-/\n#guard_msgs in\n#eval dollar_to_speech \"$20.18\"\n\n/-\ninfo: 'No negative numbers are allowed!'\n-/\n#guard_msgs in\n#eval dollar_to_speech \"$-5.00\""
      }
    ]
  },
  "fvapps_003731.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def build_or_buy (hand : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ValidResources := \"bwsog\"\n\ndef countChar (s : List Char) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.filter (\u00b7 = c) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem build_or_buy_returns_list (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  build_or_buy hand \u2260 [] \u2228 build_or_buy hand = [] := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem build_or_buy_valid_items (hand : String) (result : List String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  result = build_or_buy hand \u2192\n  result.all (\u00b7 \u2208 [\"road\", \"settlement\", \"city\", \"development\"]) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_build_road (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  \"road\" \u2208 build_or_buy hand \u2192\n  countChar hand.data 'b' \u2265 1 \u2227 countChar hand.data 'w' \u2265 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_build_settlement (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  \"settlement\" \u2208 build_or_buy hand \u2192\n  countChar hand.data 'b' \u2265 1 \u2227 countChar hand.data 'w' \u2265 1 \u2227\n  countChar hand.data 's' \u2265 1 \u2227 countChar hand.data 'g' \u2265 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_build_city (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  \"city\" \u2208 build_or_buy hand \u2192\n  countChar hand.data 'o' \u2265 3 \u2227 countChar hand.data 'g' \u2265 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem can_build_development (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  \"development\" \u2208 build_or_buy hand \u2192\n  countChar hand.data 'o' \u2265 1 \u2227 countChar hand.data 's' \u2265 1 \u2227\n  countChar hand.data 'g' \u2265 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_hand_empty_result :\n  build_or_buy \"\" = [] := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_consistency (hand : String) :\n  hand.data.all (\u00b7 \u2208 ValidResources.data) \u2192\n  build_or_buy hand = build_or_buy hand := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['road']\n-/\n#guard_msgs in\n#eval build_or_buy \"bwoo\"\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval build_or_buy \"\"\n\n/-\ninfo: ['city']\n-/\n#guard_msgs in\n#eval build_or_buy \"ogogoogogo\""
      }
    ]
  },
  "fvapps_003733.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hydrate (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For a single digit input, the function hydrate returns a string with the\n    same number of glasses of water, and uses \"glass\" for 1 and \"glasses\" otherwise -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hydrate_single_digit {n : Nat} (h : n \u2264 9) :\n  hydrate s!\"{n} drinks\" =\n    s!\"{n} {if n = 1 then \"glass\" else \"glasses\"} of water\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For a list of single digit numbers, hydrate returns a string with the sum of\n    the numbers as glasses of water -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hydrate_multiple_digits {nums : List Nat} (h : \u2200 n \u2208 nums, n \u2264 9) :\n  let sum := nums.foldl (\u00b7 + \u00b7) 0\n  hydrate (String.intercalate \" \" (nums.map toString)) =\n    s!\"{sum} {if sum = 1 then \"glass\" else \"glasses\"} of water\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any string containing only letters and spaces, hydrate returns \"0 glasses of water\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hydrate_no_numbers {s : String}\n  (h : \u2200 c \u2208 s.data, c = ' ' \u2228 ('a' \u2264 c \u2227 c \u2264 'z')) :\n  hydrate s = \"0 glasses of water\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For an empty string, hydrate returns \"0 glasses of water\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem hydrate_empty : hydrate \"\" = \"0 glasses of water\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: '1 glass of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 beer\"\n\n/-\ninfo: '3 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"2 glasses of wine and 1 shot\"\n\n/-\ninfo: '10 glasses of water'\n-/\n#guard_msgs in\n#eval hydrate \"1 shot, 5 beers, 2 shots, 1 glass of wine, 1 beer\""
      }
    ]
  },
  "fvapps_003734.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pattern (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_non_positive (n : Nat) (h : n = 0) :\n  pattern n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_lines (n : Nat) : List String :="
      },
      {
        "type": "impl",
        "string": "  (pattern n).split (\u00b7 = '\\n')"
      },
      {
        "type": "cond",
        "string": "theorem pattern_first_line (n : Nat) (h : n > 0) :\n  (get_lines n)[0]! = String.join (List.map toString (List.range n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_line_count (n : Nat) (h : n > 0) :\n  (get_lines n).length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_line_length (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.length = n - i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_line_starts_with_n (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  (get_lines n)[i]!.front.toString = toString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_descending_numbers (n : Nat) (h : n > 0) (i : Nat) (h2 : i < n) :\n  let nums := (get_lines n)[i]!.data.map (\u03bb c => c.toString.toNat!);\n  nums == (List.range (n - i)).map (\u03bb x => n - x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '4321\\n432\\n43\\n4'\n-/\n#guard_msgs in\n#eval pattern 4\n\n/-\ninfo: '21\\n2'\n-/\n#guard_msgs in\n#eval pattern 2\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"
      }
    ]
  },
  "fvapps_003737.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digitsList (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check (n : Nat) (maxSum : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def max_sumDig (nmax : Nat) (maxSum : Nat) : Nat \u00d7 Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_type (n : Nat) (maxSum : Nat) : check n maxSum = true \u2228 check n maxSum = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_max_sum (n : Nat) (maxSum : Nat)\n    (h1 : n \u2265 1000) (h2 : n < 10000) (h3 : maxSum \u2264 36) :\n  check n maxSum = true \u2194\n    \u2200 i, i + 4 \u2264 (digitsList n).length \u2192\n      sumList (List.drop i (List.take (i+4) (digitsList n))) \u2264 maxSum :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_sumDig_constraints (nmax maxSum : Nat)\n    (h1 : nmax \u2265 2000) (h2 : nmax < 10000) (h3 : maxSum \u2265 3) (h4 : maxSum \u2264 36) :\n  let (count, closest, sum) := max_sumDig nmax maxSum\n  count \u2265 0 \u2227\n  closest \u2265 1000 \u2227\n  closest \u2264 nmax \u2227\n  check closest maxSum = true \u2227\n  sum \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [11, 1110, 12555]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 3\n\n/-\ninfo: [21, 1120, 23665]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 4\n\n/-\ninfo: [85, 1200, 99986]\n-/\n#guard_msgs in\n#eval max_sumDig 2000 7"
      }
    ]
  },
  "fvapps_003746.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def square_digits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digits_to_nat (digits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def nat_to_digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def square_len (n : Nat) : Nat := toString (n * n) |>.length"
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n| [] => 0\n| x :: xs => x + listSum xs"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_square {d : Nat} (h : d \u2264 9) :\n  square_digits d = d * d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9414\n-/\n#guard_msgs in\n#eval square_digits 3212\n\n/-\ninfo: 4114\n-/\n#guard_msgs in\n#eval square_digits 2112\n\n/-\ninfo: 811181\n-/\n#guard_msgs in\n#eval square_digits 9119"
      }
    ]
  },
  "fvapps_003747.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sel_reverse (arr : List \u03b1) (length : Nat) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_preservation {\u03b1 : Type} (arr : List \u03b1) (length : Nat) :\n  List.length (sel_reverse arr length) = List.length arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For element preservation, we can state that any element in the original list\n   exists in the result list and vice versa -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem elem_preservation {\u03b1 : Type} (arr : List \u03b1) (length : Nat) (a : \u03b1) :\n  (a \u2208 sel_reverse arr length) \u2194 (a \u2208 arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_length {\u03b1 : Type} (arr : List \u03b1) :\n  sel_reverse arr 0 = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem chunk_reversal {\u03b1 : Type} (arr : List \u03b1) (length : Nat) (h : length > 0) :\n  \u2200 i, i < List.length arr \u2192\n  (sel_reverse arr length).get? i =\n    arr.get? (i/length * length + (length - 1 - i%length)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_one {\u03b1 : Type} (arr : List \u03b1) :\n  sel_reverse arr 1 = arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem full_length {\u03b1 : Type} (arr : List \u03b1) (h : arr \u2260 []) :\n  sel_reverse arr (List.length arr) = arr.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [6, 4, 2, 12, 10, 8, 16, 14]\n-/\n#guard_msgs in\n#eval sel_reverse [2, 4, 6, 8, 10, 12, 14, 16] 3\n\n/-\ninfo: [2, 1, 4, 3, 6, 5]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 2\n\n/-\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval sel_reverse [1, 2, 3, 4, 5, 6] 0"
      }
    ]
  },
  "fvapps_003753.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Pos2Nat (p : String.Pos) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Nat2Pos (n : Nat) : String.Pos :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bracket_pairs (s : String) : Option (List (String.Pos \u00d7 String.Pos)) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bracket_pairs_valid_indices {s : String} {pairs : List (String.Pos \u00d7 String.Pos)}\n    (h1 : bracket_pairs s = some pairs)\n    (open_pos close_pos : String.Pos)\n    (h2 : (open_pos, close_pos) \u2208 pairs) :\n    s.get open_pos = '(' \u2227\n    s.get close_pos = ')' \u2227\n    Pos2Nat open_pos < Pos2Nat close_pos :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_brackets_empty_result {s : String} :\n  (\u2200 c, c \u2208 s.data \u2192 c \u2260 '(' \u2227 c \u2260 ')') \u2192\n  bracket_pairs s = some [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_closing_brackets_false {s : String} :\n  (\u2200 c, c \u2208 s.data \u2192 c = ')') \u2192\n  s \u2260 \"\" \u2192\n  bracket_pairs s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_opening_brackets_false {s : String} :\n  (\u2200 c, c \u2208 s.data \u2192 c = '(') \u2192\n  s \u2260 \"\" \u2192\n  bracket_pairs s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: {3: 8}\n-/\n#guard_msgs in\n#eval bracket_pairs \"len(list)\"\n\n/-\ninfo: {}\n-/\n#guard_msgs in\n#eval bracket_pairs \"string\"\n\n/-\ninfo: {0: 9, 2: 4, 6: 7}\n-/\n#guard_msgs in\n#eval bracket_pairs \"(a(b)c()d)\""
      }
    ]
  },
  "fvapps_003754.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sortString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_string_preserves_length (s : String) :\n  (sortString s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_string_preserves_non_alpha (s : String) (i : String.Pos) :\n  \u00ac(isAlpha (s.get i)) \u2192\n  (sortString s).get i = s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_string_sorts_alpha (s : String) :\n  let result := sortString s\n  let alphaChars := result.data.filter isAlpha\n  \u2200 i j, i < j \u2192 j < alphaChars.length \u2192\n    (alphaChars.get \u27e8i, by sorry\u27e9).toLower \u2264 (alphaChars.get \u27e8j, by sorry\u27e9).toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_string_preserves_case_counts (s : String) :\n  let result := sortString s\n  (result.data.filter isUpper).length = (s.data.filter isUpper).length \u2227\n  (result.data.filter isLower).length = (s.data.filter isLower).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_string_idempotent (s : String) :\n  sortString (sortString s) = sortString s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval sort_string \"cba\"\n\n/-\ninfo: 'abC'\n-/\n#guard_msgs in\n#eval sort_string \"Cba\"\n\n/-\ninfo: 'a b c'\n-/\n#guard_msgs in\n#eval sort_string \"c b a\""
      }
    ]
  },
  "fvapps_003755.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def uniq_c {\u03b1 : Type u} (xs : List \u03b1) : List (\u03b1 \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => h + sum t"
      },
      {
        "type": "cond",
        "string": "theorem uniq_c_length_invariants {\u03b1 : Type u} (xs : List \u03b1) :\n  let result := uniq_c xs\n  (\u2200 p \u2208 result, (Prod.snd p) > 0) \u2227\n  sum (result.map Prod.snd) = xs.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_c_groups_consecutive {\u03b1 : Type u} [BEq \u03b1] (xs : List \u03b1) :\n  let result := uniq_c xs\n  let indices := List.range xs.length\n  \u2200 (i j : Nat), i < xs.length \u2192 j < xs.length \u2192\n    \u2200 p \u2208 result,\n      (i < j) \u2192\n      (j - i < Prod.snd p) \u2192\n      xs[i]? = some (Prod.fst p) \u2192\n      xs[j]? = some (Prod.fst p) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uniq_c_single_element {\u03b1 : Type u} [BEq \u03b1] (x : \u03b1) (n : Nat) :\n  uniq_c (List.replicate n x) = [(x, n)] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"b\", \"b\", \"c\", \"a\", \"b\", \"c\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval uniq_c [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval uniq_c [None, \"a\", \"a\"]"
      }
    ]
  },
  "fvapps_003761.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_divs (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def amicable_numbers (n1 n2 : Nat) : Bool := sorry\n\n@[reducible]"
      },
      {
        "type": "sig",
        "string": "def list_sum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + list_sum xs"
      },
      {
        "type": "cond",
        "string": "theorem get_divs_properties (n : Nat) (h : n > 0) :\n  let divs := get_divs n\n  (\u2200 d \u2208 divs, n % d = 0) \u2227\n  (\u2200 d \u2208 divs, d > 0) \u2227\n  (1 \u2208 divs) \u2227\n  (n = 1 \u2192 n \u2208 divs) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem amicable_symmetric_property (n : Nat) (h : n > 0) :\n  let divs_sum := list_sum (get_divs n)\n  (divs_sum > 0 \u2227 divs_sum \u2260 n) \u2192\n  amicable_numbers n divs_sum = amicable_numbers divs_sum n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_amicable_with_self (n : Nat) (h : n > 0) :\n  \u00acamicable_numbers n n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem amicable_commutative (n1 n2 : Nat) (h1 : n1 > 0) (h2 : n2 > 0) :\n  amicable_numbers n1 n2 = amicable_numbers n2 n1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval amicable_numbers 220 284\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval amicable_numbers 220 280\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval amicable_numbers 1184 1210"
      }
    ]
  },
  "fvapps_003769.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def tidyNumber (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem tidy_number_returns_boolean (n : Nat) :\n  tidyNumber n = true \u2228 tidyNumber n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_numbers_tidy (n : Nat) :\n  n < 10 \u2192 tidyNumber n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tidy_implies_non_decreasing_digits {n : Nat} {ds : List Nat} :\n  tidyNumber n = true \u2192\n  ds = digits n \u2192\n  \u2200 i j, i < j \u2192 j < ds.length \u2192 ds[i]! \u2264 ds[j]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_decreasing_digits_iff_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n \u2192\n  (\u2200 i j, i < j \u2192 j < ds.length \u2192 ds[i]! \u2264 ds[j]!) \u2194 tidyNumber n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decreasing_digits_not_tidy {n : Nat} {ds : List Nat} :\n  ds = digits n \u2192\n  ds.length \u2265 2 \u2192\n  (\u2203 i j, i < j \u2227 j < ds.length \u2227 ds[i]! > ds[j]!) \u2192\n  tidyNumber n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval tidyNumber 12\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 32\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval tidyNumber 1024"
      }
    ]
  },
  "fvapps_003771.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def two_count (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_count_non_negative (n : Nat) (h : n > 0) :\n  two_count n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calc_divisions (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_count_matches_divisions (n : Nat) (h : n > 0) :\n  two_count n = calc_divisions n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_count_odd (n : Nat) (h\u2081 : n > 0) (h\u2082 : n % 2 = 1) :\n  two_count n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_count_power_of_two (n : Nat) (h\u2081 : n > 0) (h\u2082 : n.isPowerOfTwo) :\n  two_count n = Nat.log2 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem two_count_multiplication (n k : Nat) (h : n > 0) :\n  two_count (n * 2^k) = two_count n + k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval two_count 24\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval two_count 17280\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval two_count 256"
      }
    ]
  },
  "fvapps_003776.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_preserves_length (s : String) :\n  (reverse s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def IsRepeatStart (s : String) (i : String.Pos) : Prop :="
      },
      {
        "type": "impl",
        "string": "  i = \u27e80\u27e9 \u2228 s.get (String.Pos.mk (i.1 - 1)) = s.get i"
      },
      {
        "type": "sig",
        "string": "def IsRepeatEnd (s : String) (i : String.Pos) : Prop :="
      },
      {
        "type": "impl",
        "string": "  i.1 < s.length - 1 \u2192 s.get i = s.get (String.Pos.mk (i.1 + 1))"
      },
      {
        "type": "cond",
        "string": "theorem reverse_preserves_non_repeats (s : String) (i : String.Pos) :\n  \u00acIsRepeatStart s i \u2192 \u00acIsRepeatEnd s i \u2192\n  (reverse s).get i = s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_swaps_case_on_repeats (s : String) (i : String.Pos) :\n  IsRepeatStart s i \u2228 IsRepeatEnd s i \u2192\n  (reverse s).get i \u2260 s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_idempotent_no_repeats (s : String)\n  (h : \u2200 i : String.Pos, i.1 < s.length \u2192 \u00acIsRepeatStart s i \u2227 \u00acIsRepeatEnd s i) :\n  reverse s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_preserves_non_letters (s : String) (i : String.Pos)\n  (h : \u00ac(s.get i).isAlpha) :\n  (reverse s).get i = s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'heLLo world'\n-/\n#guard_msgs in\n#eval reverse \"hello world\"\n\n/-\ninfo: 'www'\n-/\n#guard_msgs in\n#eval reverse \"WWW\"\n\n/-\ninfo: 'bOOKKEEper'\n-/\n#guard_msgs in\n#eval reverse \"bookkeeper\""
      }
    ]
  },
  "fvapps_003777.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_ints (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def range (n : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def arithmetic_sequence_sum (a r n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem arithmetic_sequence_properties\n  (a r n : Int)\n  (h : n > 0) :\n  let sum := arithmetic_sequence_sum a r n\n  let manual_sum := sum_ints (range n |>.map (fun i => a + r * i))\n  (sum = manual_sum) \u2227\n  (arithmetic_sequence_sum a r 1 = a) \u2227\n  (n > 1 \u2192 sum = arithmetic_sequence_sum a r (n-1) + (a + (n-1)*r)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_symmetry\n  (a r n : Int)\n  (h : n > 0) :\n  let last := a + (n-1)*r\n  arithmetic_sequence_sum a r n = arithmetic_sequence_sum last (-r) n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 440\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 3 2 20\n\n/-\ninfo: 110\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 2 2 10\n\n/-\ninfo: -80\n-/\n#guard_msgs in\n#eval arithmetic_sequence_sum 1 -2 10"
      }
    ]
  },
  "fvapps_003780.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_even_index (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_even_index_centered {n : Nat} :\n  let arr := List.replicate n 1 ++ [0] ++ List.replicate n 1\n  find_even_index arr = n\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_even_index_single_element :\n  find_even_index [0] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_even_index_single_nonzero :\n  find_even_index [1] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_even_index_all_zeros :\n  find_even_index [0, 0, 0] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_even_index [1, 2, 3, 4, 3, 2, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_even_index [1, 100, 50, -51, 1, 1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_even_index [20, 10, -80, 10, 10, 15, 35]"
      }
    ]
  },
  "fvapps_003781.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def discover_original_price (price : Float) (percentage : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discover_original_price_geq_discounted (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  discover_original_price price percentage \u2265 price :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discover_original_price_positive (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  0 < discover_original_price price percentage :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discover_original_price_accurate (price : Float) (percentage : Float)\n  (h1 : 0 < price) (h2 : 0 < percentage) (h3 : percentage < 100) :\n  let original := discover_original_price price percentage\n  let discounted := original * (1 - percentage/100)\n  Float.abs (discounted - price) \u2264 0.02 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem discover_original_price_100_dollars (percentage : Float)\n  (h1 : 0 < percentage) (h2 : percentage < 100) :\n  let discounted := 100 * (1 - percentage/100)\n  Float.abs (discover_original_price discounted percentage - 100) < 0.01 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 75 25\n\n/-\ninfo: Decimal('100.00')\n-/\n#guard_msgs in\n#eval discover_original_price 25 75\n\n/-\ninfo: Decimal('421.00')\n-/\n#guard_msgs in\n#eval discover_original_price 373.85 11.2"
      }
    ]
  },
  "fvapps_003794.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def strong_num (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumDigitFactorials (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digitsOfNat (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strong_num_outputs_valid_string (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" \u2228 strong_num n = \"Not Strong !!\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strong_num_correctness (n : Nat) :\n  (strong_num n = \"STRONG!!!!\" \u2194 sumDigitFactorials n = n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit_strong_nums (n : Nat) :\n  n \u2264 9 \u2192\n  (strong_num n = \"STRONG!!!!\" \u2194 (n = 1 \u2228 n = 2)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem digit_composition_property (digits : List Nat) :\n  (\u2200 d \u2208 digits, d \u2264 9) \u2192\n  let n := sorry -- conversion of digits to number\n  (strong_num n = \"STRONG!!!!\" \u2194 (sumDigitFactorials n = n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 145\n\n/-\ninfo: 'Not Strong !!'\n-/\n#guard_msgs in\n#eval strong_num 123\n\n/-\ninfo: 'STRONG!!!!'\n-/\n#guard_msgs in\n#eval strong_num 40585"
      }
    ]
  },
  "fvapps_003799.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def reverse_bits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result is non-negative (trivial in Lean since Nat is used)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def count_ones (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Number of 1 bits is preserved"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_bits_nonneg (n : Nat) :\n  reverse_bits n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to count ones"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_bits_preserves_ones (n : Nat) (h : n < 2^32) :\n  count_ones n = count_ones (reverse_bits n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Power of 2 input results in power of 2 output"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_bits_preserves_power_of_two (n : Nat) (h : n < 2^32)\n  (h\u2081 : n \u2260 0) (h\u2082 : n &&& (n - 1) = 0) :\n  (reverse_bits n) &&& ((reverse_bits n) - 1) = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Edge cases"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem reverse_bits_zero :\n  reverse_bits 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_bits_one :\n  reverse_bits 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 267\n-/\n#guard_msgs in\n#eval reverse_bits 417\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval reverse_bits 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval reverse_bits 1024"
      }
    ]
  },
  "fvapps_003804.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def choose (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def counting_triangles (sticks : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_count_properties {sticks : List Nat}\n  (h1 : sticks.length \u2265 3)\n  (h2 : \u2200 x \u2208 sticks, x > 0 \u2227 x \u2264 1000) :\n  let result := counting_triangles sticks\n  result \u2265 0 \u2227 result \u2264 choose sticks.length 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_lengths_make_triangles {n : Nat} (h : n > 0) :\n  counting_triangles [n, n, n] = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem triangle_inequality {sticks : List Nat}\n  (h1 : sticks.length \u2265 3)\n  (h2 : \u2200 x \u2208 sticks, x > 0 \u2227 x \u2264 1000) :\n  \u2203 a b c, (a \u2208 sticks \u2227 b \u2208 sticks \u2227 c \u2208 sticks) \u2227\n           (a + b > c \u2192 counting_triangles sticks > 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_invariance {sticks sticksSorted : List Nat}\n  (h1 : sticks.length \u2265 3)\n  (h2 : \u2200 x \u2208 sticks, x > 0 \u2227 x \u2264 100)\n  (h3 : \u2200 x, (x \u2208 sticks \u2194 x \u2208 sticksSorted)) :\n  counting_triangles sticks = counting_triangles sticksSorted :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval counting_triangles [2, 3, 7, 4]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [5, 6, 7, 8]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval counting_triangles [2, 2, 2, 2]"
      }
    ]
  },
  "fvapps_003805.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_free_urinals (s : String) : Int := sorry\n\ndef hasConsecutiveOnes (chars : List Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match chars with\n  | '1' :: '1' :: _ => true\n  | _ :: rest => hasConsecutiveOnes rest\n  | [] => false"
      },
      {
        "type": "sig",
        "string": "def containsAdjacentOnes (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  hasConsecutiveOnes s.data"
      },
      {
        "type": "cond",
        "string": "theorem invalid_adjacent_urinals :\n  \u2200 s: String, containsAdjacentOnes s \u2192 get_free_urinals s = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_nonnegative_if_valid :\n  \u2200 s: String, \u00accontainsAdjacentOnes s \u2192 get_free_urinals s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_bounded_by_half_length :\n  \u2200 s: String, \u00accontainsAdjacentOnes s \u2192\n    get_free_urinals s \u2264 (s.length + 1) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alternating_pattern_valid :\n  \u2200 gaps: List Nat,\n  let s := String.join (List.intersperse \"0\" (List.replicate gaps.length \"1\"))\n  \u00accontainsAdjacentOnes s \u2192\n  get_free_urinals s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval get_free_urinals \"10001\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_free_urinals \"00000\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval get_free_urinals \"110\""
      }
    ]
  },
  "fvapps_003808.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def combine_strings : List String \u2192 String\n  | _ => sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem combine_strings_length (strings : List String) :\n  (combine_strings strings).length = List.foldl (\u00b7 + \u00b7) 0 (strings.map String.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem combine_strings_freq (strings : List String) (s : String) (c : Char)\n  (h : s \u2208 strings) :\n  (countChar (combine_strings strings) c) \u2265\n  (countChar s c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem combine_strings_empty :\n  combine_strings [] = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem combine_strings_singleton (s : String) :\n  combine_strings [s] = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\"\n\n/-\ninfo: 'a1b2c3'\n-/\n#guard_msgs in\n#eval combine_strings \"abc\" \"123\"\n\n/-\ninfo: 'a1$b2%c3^d&'\n-/\n#guard_msgs in\n#eval combine_strings \"abcd\" \"123\" \"$%^&\""
      }
    ]
  },
  "fvapps_003809.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def paint_letterboxes (start: Nat) (finish: Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def str_count_digits (n: Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toString (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list (l: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paint_letterboxes_range {start finish : Nat} (h: start \u2264 finish) :\n  let result := paint_letterboxes start finish\n  List.length result = 10 \u2227\n  (\u2200 x \u2208 result, x \u2265 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paint_letterboxes_single_number (n: Nat) :\n  paint_letterboxes n n = str_count_digits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paint_letterboxes_zero :\n  paint_letterboxes 0 0 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem paint_letterboxes_non_negative {a b : Nat} :\n  \u2200 x \u2208 paint_letterboxes a b, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 9, 6, 3, 0, 1, 1, 1, 1, 1]\n-/\n#guard_msgs in\n#eval paint_letterboxes 125 132\n\n/-\ninfo: [2, 2, 0, 0, 0, 0, 0, 0, 0, 0]\n-/\n#guard_msgs in\n#eval paint_letterboxes 1001 1001"
      }
    ]
  },
  "fvapps_003811.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def add (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def multiply (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def divide (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mod (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def exponent (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def subt (a b : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Addition properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem add_commutative (a b : Int) : add a b = add b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_identity (a : Int) : add a 0 = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_associative (a b : Int) : add (add a b) 0 = add a (add b 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Multiplication properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem mult_commutative (a b : Int) : multiply a b = multiply b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mult_identity (a : Int) : multiply a 1 = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mult_zero (a : Int) : multiply a 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Division properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem div_self {a : Int} (h : a \u2260 0) : divide a a = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem div_mult_cancel (a b : Int) (h : b \u2260 0) :\n  multiply (divide a b) b = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Modulo properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem mod_bounds (a b : Int) (h : b > 0) :\n  0 \u2264 mod a b \u2227 mod a b < b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mod_reconstruction (a b : Int) (h : b \u2260 0) :\n  a = multiply (divide a b) b + mod a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Exponentiation properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem exp_zero (a : Int) (h : a > 0) : exponent a 0 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exp_one (a : Int) : exponent a 1 = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exp_growth (a b : Int) (h1 : a > 0) (h2 : b > 0) :\n  exponent a b \u2265 a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Subtraction properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem subt_as_add (a b : Int) : subt a b = add a (-b) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem subt_self (a : Int) : subt a a = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval add 1 2\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval add 5 7\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval add 0 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval multiply 2 3\n\n/-\ninfo: 25\n-/\n#guard_msgs in\n#eval multiply 5 5\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval divide 6 2\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval divide 5 2\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 7 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mod 10 3\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval exponent 2 3\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval exponent 3 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval subt 5 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval subt 10 7"
      }
    ]
  },
  "fvapps_003812.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isDigit (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.toFloat? (s : String) : Option Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_float_strings (f : Float) :\n  isDigit (toString f) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem arbitrary_text (s : String) :\n  match s.toFloat? with\n  | some _ => isDigit s = true\n  | none => isDigit s = false\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whitespace_padding (s : String) (f : Float) :\n  isDigit (s ++ toString f ++ s) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem edge_cases :\n  isDigit \"\" = false \u2227\n  isDigit \" \" = false \u2227\n  isDigit \"-0\" = true \u2227\n  isDigit \"+0\" = true \u2227\n  isDigit \"-.1\" = true \u2227\n  isDigit \"+.1\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"-234.4\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval isDigit \"3 4\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval isDigit \"0.0\""
      }
    ]
  },
  "fvapps_003815.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def elections_winners (votes: List Nat) (k: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_maximum (l: List Nat) (h: l.length > 0) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_minimum (l: List Nat) (h: l.length > 0) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem elections_winners_properties_result_bounds\n  (votes: List Nat) (k: Nat) (h: votes.length > 0) :\n  let result := elections_winners votes k\n  0 \u2264 result \u2227 result \u2264 votes.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem elections_winners_k_zero_result\n  (votes: List Nat) (h: votes.length > 0) :\n  let result := elections_winners votes 0\n  result = 0 \u2228 result = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [2, 3, 5, 2] 3\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval elections_winners [1, 3, 3, 1, 1] 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval elections_winners [3, 1, 1, 3, 1] 2"
      }
    ]
  },
  "fvapps_003837.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def strLen (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def stringSuffix (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isRepeatedChar (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_positive (s : String) :\n  stringSuffix s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_ge_len (s : String) :\n  stringSuffix s \u2265 strLen s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_le_square (s : String) :\n  stringSuffix s \u2264 strLen s * strLen s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_repeated_char (s : String) :\n  isRepeatedChar s \u2192 stringSuffix s = (strLen s * (strLen s + 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_empty :\n  stringSuffix \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_suffix_slice (s : String) (i : Nat) :\n  i < strLen s \u2192 stringSuffix (s.drop i) \u2264 stringSuffix s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval string_suffix \"abc\"\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval string_suffix \"ababaa\"\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval string_suffix \"aaaa\""
      }
    ]
  },
  "fvapps_003845.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_num (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (l : List Nat) (h : l.length > 0) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def product (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_num_basic_properties {arr : List Nat} (h1 : arr.length > 0)\n  (h2 : \u2200 x \u2208 arr, 2 \u2264 x \u2227 x \u2264 20) :\n  let result := get_num arr\n  result.length = 4 \u2227\n  result[0]! = product arr \u2227\n  result[2]! = minimum arr h1 \u2227\n  result[3]! = result[0]! / result[2]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_num_small_factors {arr : List Nat}\n  (h1 : 2 \u2264 arr.length \u2227 arr.length \u2264 3)\n  (h2 : \u2200 x \u2208 arr, 2 \u2264 x \u2227 x \u2264 7) :\n  let result := get_num arr\n  result[0]! > 0 \u2227\n  result[1]! \u2265 0 \u2227\n  result[2]! \u2264 minimum arr (by exact Nat.zero_lt_of_lt h1.left) \u2227\n  result[0]! % result[2]! = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [150, 11, 2, 75]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 5, 5]\n\n/-\ninfo: [378, 15, 2, 189]\n-/\n#guard_msgs in\n#eval get_num [2, 3, 3, 3, 7]\n\n/-\ninfo: [23400, 71, 2, 11700]\n-/\n#guard_msgs in\n#eval get_num [2, 13, 2, 5, 2, 5, 3, 3]"
      }
    ]
  },
  "fvapps_003851.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_ones (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def max_pn (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def an_over (n : Nat) : List Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def an_over_average (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_bounds {n : Nat} (h : n > 0) :\n  count_ones n \u2264 n \u2227 count_ones n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_ones_nat {n : Nat} (h : n > 0) :\n  count_ones n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pn_gt_one {n : Nat} (h : n > 0) :\n  max_pn n > 1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_pn_nat {n : Nat} (h : n > 0) :\n  max_pn n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem an_over_length {n : Nat} (h : n > 0) :\n  (an_over n).length = n := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem an_over_all_positive {n : Nat} (h : n > 0) :\n  \u2200 x \u2208 an_over n, x > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem an_over_average_positive {n : Nat} (h : n > 0) :\n  an_over_average n > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem an_over_average_nat {n : Nat} (h : n > 0) :\n  an_over_average n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_ones 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_ones 5\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval max_pn 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval an_over_average 1"
      }
    ]
  },
  "fvapps_003859.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def containsThree (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def magicSum (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (nums : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_filtering_contributing (nums : List Int) :\n  let contributing := nums.filter (fun x => x % 2 = 1 \u2227 containsThree x)\n  contributing \u2260 [] \u2192 magicSum nums = magicSum contributing := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_filtering_non_contributing (nums : List Int) :\n  let non_contributing := nums.filter (fun x => x % 2 = 0 \u2228 \u00accontainsThree x)\n  magicSum non_contributing = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_order_invariant (nums : List Int) :\n  magicSum nums = magicSum nums.reverse := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_duplicates (nums : List Int) :\n  magicSum (nums ++ nums) = 2 * magicSum nums := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_empty :\n  magicSum [] = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_valid_sum (nums : List Int) :\n  let valid := nums.filter (fun x => x % 2 = 1 \u2227 containsThree x)\n  valid \u2260 [] \u2192 magicSum nums = sumList valid := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem magic_sum_all_invalid (nums : List Int) :\n  (\u2200 x \u2208 nums, x % 2 = 0 \u2228 \u00accontainsThree x) \u2192 magicSum nums = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval magic_sum [3]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 13]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval magic_sum [3, 12, 5, 8, 30, 13]"
      }
    ]
  },
  "fvapps_003860.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def next_happy_year (year : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper functions"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def number_to_digits (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_unique (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_happy_year_increases (year : Nat)\n  (h : year \u2265 1000 \u2227 year \u2264 8999) :\n  next_happy_year year > year :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1023\n-/\n#guard_msgs in\n#eval next_happy_year 1001\n\n/-\ninfo: 7801\n-/\n#guard_msgs in\n#eval next_happy_year 7712\n\n/-\ninfo: 9012\n-/\n#guard_msgs in\n#eval next_happy_year 8999"
      }
    ]
  },
  "fvapps_003875.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def firstNonConsecutive (arr : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  if x < 0 then -x else x"
      },
      {
        "type": "cond",
        "string": "theorem empty_or_single_returns_none (arr : List Int) :\n  arr.length \u2264 1 \u2192 firstNonConsecutive arr = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_returns_none (arr : List Int) (h : arr.length \u2265 2) :\n  (\u2200 i j, i + 1 = j \u2192 arr[i]? = some x \u2192 arr[j]? = some y \u2192 y = x + 1) \u2192\n  firstNonConsecutive arr = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_consecutive_returns_first_break (arr : List Int) (gap : Int)\n    (h1 : arr.length \u2265 3) (h2 : (abs gap) > 1) :\n  let pos := arr.length / 2\n  let val := arr[pos]?\n  match val with\n  | none => True\n  | some x =>\n    let next := arr[pos+1]?\n    match next with\n    | none => True\n    | some y => x + gap = y \u2192 firstNonConsecutive arr = some y\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_in_input (arr : List Int) :\n  match firstNonConsecutive arr with\n  | none => True\n  | some x => x \u2208 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 6, 7, 8]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval first_non_consecutive [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval first_non_consecutive [-3, -2, 0, 1]"
      }
    ]
  },
  "fvapps_003877.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Position := String"
      },
      {
        "type": "sig",
        "string": "def Command := String\n\ndef tetris (commands : List Command) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumHeights (commands : List Command) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem tetris_output_natural (commands : List Command) :\n  tetris commands \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tetris_height_limit (commands : List Command) (h : commands \u2260 []) :\n  tetris commands < 30 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tetris_cleared_lines (commands : List Command) (h : commands \u2260 []) :\n  tetris commands \u2264 sumHeights commands :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem tetris_idempotent_empty_moves (commands : List Command) (h : commands \u2260 []) :\n  let emptyMoves : List Command := [\"1L0\", \"1R0\"]\n  tetris commands = tetris (commands ++ emptyMoves) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval tetris [\"1R4\", \"2L3\", \"3L2\", \"4L1\", \"1L0\", \"2R1\", \"3R2\", \"4R3\", \"1L4\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval tetris [\"1L2\", \"4R2\", \"3L3\", \"3L1\", \"1L4\", \"1R4\"]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval tetris [\"4R4\", \"4L3\", \"4L2\", \"4L1\", \"4L0\", \"4R1\", \"4R2\", \"4R3\", \"3L4\"]"
      }
    ]
  },
  "fvapps_003884.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def added_char (base modified : String) : Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem added_char_correct (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  added_char base modified = c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_difference (base : String) (c : Char) :\n  let modified := base ++ String.mk (List.replicate 3 c)\n  modified.length = base.length + 3 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"hello\" \"checlclo\"\n\n/-\ninfo: 'c'\n-/\n#guard_msgs in\n#eval added_char \"aabbcc\" \"aacccbbcc\"\n\n/-\ninfo: '2'\n-/\n#guard_msgs in\n#eval added_char \"abcde\" \"2db2a2ec\""
      }
    ]
  },
  "fvapps_003887.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isUpperCase (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def toLetterIndex (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def new_numeral_system (letter : Char) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem correct_format {letter : Char} :\n  \u2200 s \u2208 new_numeral_system letter,\n    s.length = 5 \u2227 s.data.get \u27e81, sorry\u27e9 = ' ' \u2227\n    s.data.get \u27e82, sorry\u27e9 = '+' \u2227\n    s.data.get \u27e83, sorry\u27e9 = ' ' := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_letters {letter : Char} :\n  \u2200 s \u2208 new_numeral_system letter,\n    let first := s.data.get \u27e80, sorry\u27e9\n    let last := s.data.get \u27e84, sorry\u27e9\n    isUpperCase first \u2227\n    isUpperCase last \u2227\n    first \u2264 letter \u2227\n    last \u2264 letter := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem correct_sum {letter : Char} :\n  \u2200 s \u2208 new_numeral_system letter,\n    let first := s.data.get \u27e80, sorry\u27e9\n    let last := s.data.get \u27e84, sorry\u27e9\n    toLetterIndex first + toLetterIndex last = toLetterIndex letter := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem left_side_sorted {letter : Char} :\n  let leftSide := (new_numeral_system letter).map (fun s => s.data.get \u27e80, sorry\u27e9)\n  \u2200 i j, i < j \u2192 j < leftSide.length \u2192 leftSide[i]! \u2264 leftSide[j]! := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem middle_pair_equal {letter : Char} :\n  toLetterIndex letter % 2 = 0 \u2192\n    let result := new_numeral_system letter\n    let midIdx := toLetterIndex letter / 2\n    let middle := result[midIdx]!\n    middle.data.get \u27e80, sorry\u27e9 = middle.data.get \u27e84, sorry\u27e9 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003888.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def flip_bit (value : Int) (bit_index : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def band (x y : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def shiftLeft (x : Int) (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- States that flipping a bit twice returns the original value"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem flip_bit_reversible\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 \u2264 bit_index) (h2 : bit_index \u2264 32) :\n  flip_bit (flip_bit value bit_index) bit_index = value :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- States that only the target bit changes"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem flip_bit_changes_target_bit\n  (value : Int) (bit_index : Nat)\n  (h1 : 1 \u2264 bit_index) (h2 : bit_index \u2264 32) :\n  \u2203 bit_mask : Int,\n    bit_mask = shiftLeft 1 (bit_index - 1) \u2227\n    band value bit_mask \u2260 band (flip_bit value bit_index) bit_mask \u2227\n    band value (bit_mask - 1) = band (flip_bit value bit_index) (bit_mask - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 32768\n-/\n#guard_msgs in\n#eval flip_bit 0 16\n\n/-\ninfo: 1073741823\n-/\n#guard_msgs in\n#eval flip_bit 2147483647 31\n\n/-\ninfo: 255\n-/\n#guard_msgs in\n#eval flip_bit 127 8"
      }
    ]
  },
  "fvapps_003889.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isScientificNotation (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumProd (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToFloat (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumProd_format {nums : List Float}\n  (h1 : \u2200 n \u2208 nums, 0.1 \u2264 n \u2227 n \u2264 100)\n  (h2 : 2 \u2264 nums.length \u2227 nums.length \u2264 4) :\n  isScientificNotation (sumProd (\"+\".intercalate (nums.map toString))) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumProd_multiply (x y : Nat)\n  (h1 : 1 \u2264 x \u2227 x \u2264 100)\n  (h2 : 1 \u2264 y \u2227 y \u2264 100) :\n  (stringToFloat (sumProd (s!\"{x}*{y}\"))) = Float.ofNat (x * y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumProd_add (x y : Nat)\n  (h1 : 1 \u2264 x \u2227 x \u2264 100)\n  (h2 : 1 \u2264 y \u2227 y \u2264 100) :\n  (stringToFloat (sumProd (s!\"{x}+{y}\"))) = Float.ofNat (x + y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '2.60000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5*4+6\"\n\n/-\ninfo: '2.90000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5+4*6\"\n\n/-\ninfo: '3.58000e+01'\n-/\n#guard_msgs in\n#eval sum_prod \"5.4*4.0+6.2+8.0\""
      }
    ]
  },
  "fvapps_003893.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumDig_nthTerm (initVal : Nat) (patternL : List Nat) (nthTerm : Nat) : Nat := sorry\n\ndef numDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n < 10 then 1\n  else 1 + numDigits (n / 10)"
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n  | [] => 0\n  | (h::t) => h + listSum t"
      },
      {
        "type": "cond",
        "string": "theorem sumDig_nthTerm_bounds {initVal : Nat} {patternL : List Nat} {nthTerm : Nat}\n  (h1 : initVal \u2264 50)\n  (h2 : \u2200 x \u2208 patternL, x \u2264 5)\n  (h3 : 1 \u2264 patternL.length)\n  (h4 : patternL.length \u2264 3)\n  (h5 : 2 \u2264 nthTerm)\n  (h6 : nthTerm \u2264 10) :\n  0 \u2264 sumDig_nthTerm initVal patternL nthTerm \u2227\n  sumDig_nthTerm initVal patternL nthTerm \u2264 9 * numDigits (initVal + (listSum patternL * nthTerm)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumDig_nthTerm_deterministic {initVal : Nat} {patternL : List Nat} {nthTerm : Nat} :\n  sumDig_nthTerm initVal patternL nthTerm = sumDig_nthTerm initVal patternL nthTerm :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003895.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumEvenNumbers (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem sum_even_numbers_sums_evens (l : List Int) :\n  sumEvenNumbers l = listSum (l.filter (fun n => n % 2 = 0)) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_even_numbers_is_even (l : List Int) :\n  sumEvenNumbers l % 2 = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_even_numbers_idempotent (l : List Int) :\n  let result := sumEvenNumbers l\n  result \u2260 0 \u2192 sumEvenNumbers [result] = result := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_even_numbers_empty :\n  sumEvenNumbers [] = 0 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval sum_even_numbers [4, 3, 1, 2, 5, 10, 6, 7, 9, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_even_numbers []\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval sum_even_numbers [-16, -32, 20, 21, 41, 42]"
      }
    ]
  },
  "fvapps_003900.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solution (n : Nat) : Array Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isMultipleOf3 (x : Nat) : Bool := x % 3 == 0"
      },
      {
        "type": "sig",
        "string": "def isMultipleOf5 (x : Nat) : Bool := x % 5 == 0\n-- Output format properties"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solution_output_format (n : Nat) (h : n > 0) :\n  (solution n).size = 3 \u2227\n  \u2200 i < 3, (solution n)[i]! \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Sum matches total multiples"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solution_sum_matches_multiples (n : Nat) (h : n > 0) :\n  let result := solution n\n  let total := result[0]! + result[1]! + result[2]!\n  let multiples := (List.range n).filter (fun x => isMultipleOf3 x || isMultipleOf5 x)\n  total = multiples.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Components match exclusive counts"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solution_component_counts (n : Nat) (h : n > 0) :\n  let result := solution n\n  let only3 := (List.range n).filter (fun x => isMultipleOf3 x && !isMultipleOf5 x)\n  let only5 := (List.range n).filter (fun x => isMultipleOf5 x && !isMultipleOf3 x)\n  let both := (List.range n).filter (fun x => isMultipleOf3 x && isMultipleOf5 x)\n  result[0]! = only3.length \u2227\n  result[1]! = only5.length \u2227\n  result[2]! = both.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Edge cases"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solution_edge_cases :\n  solution 1 = #[0, 0, 0] \u2227\n  solution 3 = #[0, 0, 0] \u2227\n  solution 4 = #[1, 0, 0] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003909.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def IsUpper (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def IsLower (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def swapcase (c : Char) : Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sc (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_subset (s : String) :\n  \u2200 (c : Char), c \u2208 (sc s).data \u2192 c \u2208 s.data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_length (s : String) :\n  (sc s).length \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_swapcase_pairs (s : String) :\n  \u2200 (c : Char), c \u2208 (sc s).data \u2192 swapcase c \u2208 (sc s).data :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_all_upper (s : String) :\n  (\u2200 (c : Char), c \u2208 s.data \u2192 IsUpper c) \u2192 sc s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_all_lower (s : String) :\n  (\u2200 (c : Char), c \u2208 s.data \u2192 IsLower c) \u2192 sc s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_empty :\n  sc \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sc_idempotent (s : String) :\n  sc (sc s) = sc s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Aa'\n-/\n#guard_msgs in\n#eval sc \"Aab\"\n\n/-\ninfo: 'AabB'\n-/\n#guard_msgs in\n#eval sc \"AabBc\"\n\n/-\ninfo: 'SONson'\n-/\n#guard_msgs in\n#eval sc \"SONson\""
      }
    ]
  },
  "fvapps_003910.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def lcm_cardinality (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def lcm (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def divisors (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_cardinality_positive (n : Nat) (h : n \u2265 1) :\n  lcm_cardinality n \u2265 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_cardinality_upper_bound (n : Nat) (h : n \u2265 1) :\n  let divs := List.length (divisors n)\n  lcm_cardinality n \u2264 1 + (divs * (divs - 1)) / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_cardinality_monotonic_powers_two (i : Nat) (h : i > 0) :\n  lcm_cardinality (2^i) \u2265 lcm_cardinality (2^(i-1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_factors_bound (n : Nat) (h : n \u2265 1) :\n  \u2200 (a b : Nat), a \u2208 divisors n \u2192 b \u2208 divisors n \u2192 lcm a b \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003912.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_weight (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def swapcase (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_weight_nonnegative (s : String) :\n  get_weight s \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 254\n-/\n#guard_msgs in\n#eval get_weight \"Joe\"\n\n/-\ninfo: 1275\n-/\n#guard_msgs in\n#eval get_weight \"George Washington\"\n\n/-\ninfo: 214\n-/\n#guard_msgs in\n#eval get_weight \"R2D2\""
      }
    ]
  },
  "fvapps_003913.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def what_time_is_it (angle : Float) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def str_to_hours_mins (s : String) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def angle_to_total_mins (angle : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_format_valid {angle : Float} (h : 0 \u2264 angle \u2227 angle \u2264 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  result.length = 5 \u2227\n  hours \u2265 1 \u2227 hours \u2264 12 \u2227\n  mins \u2265 0 \u2227 mins \u2264 59 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem time_calculation_consistent {angle : Float} (h : 0 \u2264 angle \u2227 angle \u2264 360) :\n  let result := what_time_is_it angle\n  let (hours, mins) := str_to_hours_mins result\n  let expected_total_mins := angle / 360 * 12 * 60\n  let actual_total_mins := (hours % 12) * 60 + mins\n  (expected_total_mins - actual_total_mins.toFloat).abs < 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hour_boundaries_correct (angle : Nat) (h : angle < 360) :\n  let result := what_time_is_it angle.toFloat\n  let (hours, _) := str_to_hours_mins result\n  if angle < 30 then hours = 12\n  else hours = angle / 30 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem specific_angles_correct :\n  (str_to_hours_mins (what_time_is_it 0)).1 = 12 \u2227\n  (str_to_hours_mins (what_time_is_it 30)).1 = 1 \u2227\n  (str_to_hours_mins (what_time_is_it 330)).1 = 11 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '12:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 0\n\n/-\ninfo: '03:00'\n-/\n#guard_msgs in\n#eval what_time_is_it 90\n\n/-\ninfo: '01:30'\n-/\n#guard_msgs in\n#eval what_time_is_it 45"
      }
    ]
  },
  "fvapps_003917.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidHKPhoneNumber (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hasValidHKPhoneNumber (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDigitStr (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_number_is_accepted {d1 d2 : String} :\n  isValidDigitStr d1 \u2192 isValidDigitStr d2 \u2192\n  isValidHKPhoneNumber (d1 ++ \" \" ++ d2) \u2227\n  hasValidHKPhoneNumber (d1 ++ \" \" ++ d2) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_numbers_are_rejected {s : String} :\n  (\u2203 i, String.get? s i = some ' ') \u2192\n  (\u2203 i n, String.get? s i = some n \u2227 (n < '0' \u2228 n > '9')) \u2192\n  \u00acisValidHKPhoneNumber s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem has_valid_number_with_text {d1 d2 pre suf : String} :\n  isValidDigitStr d1 \u2192 isValidDigitStr d2 \u2192\n  hasValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) \u2227\n  \u00acisValidHKPhoneNumber (pre ++ d1 ++ \" \" ++ d2 ++ suf) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"1234 5678\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"abcd efgh\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_valid_HK_phone_number \"836g 2986\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"Call 1234 5678 now\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"No number here\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval has_valid_HK_phone_number \"8365 2986 is my number\""
      }
    ]
  },
  "fvapps_003922.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOccurrences (c : Char) (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allCountsEqual (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_exists_char_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length \u2265 2) :\n  \u2203 c : Char, c \u2208 s.data \u2227\n  allCountsEqual (s.replace (String.mk [c]) \"\") = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_equal_counts_after_removal\n  {s : String}\n  (h1 : solve s = true)\n  (h2 : s.length \u2265 2) :\n  \u2203 c : Char, c \u2208 s.data \u2227\n  let s' := s.replace (String.mk [c]) \"\"\n  (\u2200 c\u2081 c\u2082, c\u2081 \u2208 s'.data \u2192 c\u2082 \u2208 s'.data \u2192\n    countOccurrences c\u2081 s' = countOccurrences c\u2082 s') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"aaaa\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abba\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abbba\""
      }
    ]
  },
  "fvapps_003924.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_square (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Int.sqrt (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_square_properties_1 {n : Int} :\n  is_square n = true \u2192 n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_square_properties_3 {n : Nat} :\n  is_square (n * n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_003927.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bubblesortOnce (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (xs : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_same_length {xs : List Int} (h : xs \u2260 []) :\n  List.length (bubblesortOnce xs) = List.length xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem input_unchanged {xs : List Int} (h : xs \u2260 []) :\n  let original := xs\n  bubblesortOnce xs = bubblesortOnce original :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem at_least_one_swap_if_unsorted {xs : List Int} (h : xs \u2260 []) :\n  List.length xs > 1 \u2192\n  \u00acisSorted xs \u2192\n  bubblesortOnce xs \u2260 xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem moves_max_element_right {xs : List Int} (h : xs \u2260 []) :\n  List.length xs > 1 \u2192\n  let result := bubblesortOnce xs\n  \u2200 y \u2208 List.take (List.length result - 1) result,\n  y \u2264 List.get! result (List.length result - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval bubblesort_once [9, 7, 5, 3, 1, 2, 4, 6, 8]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval bubblesort_once [6, 3, 4, 9, 1, 2, 7, 8, 5]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval bubblesort_once [2, 4, 1]"
      }
    ]
  },
  "fvapps_003931.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfDivisors (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abundant (n : Int) : Option (List (List Int)) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem abundant_output_structure\n  (h : Int)\n  (h_ge : h \u2265 12)  -- 12 is smallest abundant number\n  (h_le : h \u2264 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result) :\n  result.length = 2 \u2227\n  \u2200 sublist \u2208 result, sublist.length = 1 \u2227\n  \u2200 sublist \u2208 result, \u2200 x \u2208 sublist, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem abundant_properties\n  (h : Int)\n  (h_ge : h \u2265 12)\n  (h_le : h \u2264 1000)\n  (result : List (List Int))\n  (h_result : abundant h = some result)\n  (n : Int := (result.get! 0).get! 0)\n  (diff : Int := (result.get! 1).get! 0) :\n  n \u2264 h \u2227\n  n > 0 \u2227\n  sumOfDivisors n > n \u2227\n  sumOfDivisors n - n = diff :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003933.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_sorted_and_how (arr : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSortedDesc (arr : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_properties (arr : List Int) (h : arr.length > 0) :\n  match is_sorted_and_how arr with\n  | \"yes, ascending\" => isSorted arr = true\n  | \"yes, descending\" => isSortedDesc arr = true\n  | _ => \u00ac(isSorted arr) \u2227 \u00ac(isSortedDesc arr)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_valid (arr : List Int) (h : arr.length > 0) :\n  is_sorted_and_how arr = \"yes, ascending\" \u2228\n  is_sorted_and_how arr = \"yes, descending\" \u2228\n  is_sorted_and_how arr = \"no\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ascending_lists (arr : List Int) (h : arr.length > 0) (h2 : isSorted arr) :\n  is_sorted_and_how arr = \"yes, ascending\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'yes, ascending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [1, 2]\n\n/-\ninfo: 'yes, descending'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [15, 7, 3, -8]\n\n/-\ninfo: 'no'\n-/\n#guard_msgs in\n#eval is_sorted_and_how [4, 2, 30]"
      }
    ]
  },
  "fvapps_003934.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_digits (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_of_digits_string (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_digits_nonnegative (x : Int) :\n  sum_digits x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_digits_symmetric (x : Int) :\n  sum_digits x = sum_digits (-x) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_digits_less_than_input (x : Int) (h : x.natAbs > 9) :\n  sum_digits x < x.natAbs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_digits_single_digit (x : Int)\n  (h : 0 \u2264 x.natAbs \u2227 x.natAbs \u2264 9) :\n  sum_digits x = x.natAbs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_digits_matches_string_sum (x : Int) :\n  x \u2265 0 \u2192 sum_digits x = sum_of_digits_string x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_digits 10\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval sum_digits 99\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_digits -32"
      }
    ]
  },
  "fvapps_003937.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mygcd (x y : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (x : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_positive_integers {x y : Int} (hx : x > 0) (hy : y > 0) :\n  let g := mygcd x y\n  g > 0 \u2227 x % g = 0 \u2227 y % g = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_identity {x : Int} :\n  mygcd x x = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gcd_associative {x y : Int} (hx : x > 0) (hy : y > 0) :\n  mygcd (x * y) x = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval mygcd 1 3\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval mygcd 60 12\n\n/-\ninfo: 334\n-/\n#guard_msgs in\n#eval mygcd 2672 5678"
      }
    ]
  },
  "fvapps_003940.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "constr",
        "string": "instance : ToString Nat where\n  toString := sorry\n\n/- For any valid range, the count is non-negative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_nonneg {x y : Nat} (h : x \u2264 y) :\n  solve x y \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The count is always less than or equal to the range size -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_le_range {x y : Nat} (h : x \u2264 y) :\n  solve x y \u2264 y - x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Empty range returns 0 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_empty_range (n : Nat) :\n  solve n n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Splitting range property - count over split ranges sums to total -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem solve_split_range {x y z : Nat}\n  (h1 : x \u2264 y) (h2 : y \u2264 z) :\n  solve x z = solve x y + solve y z :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For valid rotation numbers, all digits must be from valid set -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem valid_rotation_digits (n : Nat) :\n  solve n (n+1) = 1 \u2192 \u2200 c, c \u2208 (ToString.toString n).data \u2192 c \u2208 ['0', '1', '8', '6', '9'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For odd length valid rotation numbers, middle digit has restrictions -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem odd_len_middle_digit (n : Nat) (h1 : solve n (n+1) = 1)\n  (h2 : (ToString.toString n).length % 2 = 1) :\n  let mid := (ToString.toString n).length / 2\n  let c := ((ToString.toString n).data.get! mid)\n  c \u2260 '6' \u2227 c \u2260 '9' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval solve 0 10\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 10 100\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval solve 100 1000"
      }
    ]
  },
  "fvapps_003941.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def findSquares (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result should be non-negative"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def sum_squares (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  Nat.rec 0 (fun k res => res + k*k) n"
      },
      {
        "type": "cond",
        "string": "theorem findSquares_nonneg (x y : Nat) :\n  findSquares x y \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For 0 dimensions, result should be 0"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem findSquares_zero (x y : Nat) :\n  x = 0 \u2228 y = 0 \u2192 findSquares x y = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Result should be x*y for 1xN rectangles"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem findSquares_stripe (x y : Nat) :\n  y = 1 \u2192 findSquares x y = x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- For a square, result should be sum of squares from 1 to side length"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem findSquares_square (n : Nat) :\n  findSquares n n = sum_squares n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval findSquares 3 2\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval findSquares 4 3\n\n/-\ninfo: 100\n-/\n#guard_msgs in\n#eval findSquares 11 4"
      }
    ]
  },
  "fvapps_003942.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def group_check (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isOpening (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isClosing (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def matching (o c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOpening (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countClosing (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_valid :\n  group_check \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simple_pair_valid (o c : Char) :\n  isOpening o \u2192 matching o c \u2192\n  group_check (String.mk [o, c]) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_brackets_equal_counts {s : String} :\n  group_check s = true \u2192\n  countOpening s = countClosing s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_opening_invalid {s : String} :\n  s \u2260 \"\" \u2192\n  (\u2200 c \u2208 s.data, isOpening c) \u2192\n  group_check s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_closing_invalid {s : String} :\n  s \u2260 \"\" \u2192\n  (\u2200 c \u2208 s.data, isClosing c) \u2192\n  group_check s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nested_brackets_valid {opens : List Char} :\n  opens \u2260 [] \u2192\n  (\u2200 c \u2208 opens, isOpening c) \u2192\n  let closes := (opens.map (\u03bb o => match o with\n    | '(' => ')'\n    | '{' => '}'\n    | '[' => ']'\n    | _ => ' ')).reverse\n  group_check (String.mk (opens ++ closes)) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"({})\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval group_check \"[[]()]\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval group_check \"{(})\""
      }
    ]
  },
  "fvapps_003946.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gcd (x y : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def coprime (x y : Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  gcd x y = 1"
      },
      {
        "type": "sig",
        "string": "def rat_at (n : Nat) : Nat \u00d7 Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def index_of (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem rat_at_index_inverse (n : Nat) :\n  let (a, b) := rat_at n\n  index_of a b = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem base_cases :\n  rat_at 0 = (1, 1) \u2227\n  index_of 1 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: (1, 1)\n-/\n#guard_msgs in\n#eval rat_at 0\n\n/-\ninfo: (1, 3)\n-/\n#guard_msgs in\n#eval rat_at 3\n\n/-\ninfo: (3, 2)\n-/\n#guard_msgs in\n#eval rat_at 4\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval index_of 1 1"
      }
    ]
  },
  "fvapps_003952.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_range_collapses (arr : List Int) : Nat := sorry\n\ndef is_power_of_two (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  (n &&& (n - 1) = 0) && n > 0"
      },
      {
        "type": "sig",
        "string": "def count_consecutive_pairs (l : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let pairs := l.zip (l.drop 1)\n  pairs.foldl (fun acc p => if p.2 - p.1 = 1 then acc + 1 else acc) 0"
      },
      {
        "type": "sig",
        "string": "def sort_list (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  l.mergeSort (fun a b => a \u2264 b)"
      },
      {
        "type": "cond",
        "string": "theorem non_consecutive_array_returns_one\n  {arr : List Int} (h : arr.length > 0) :\n  (\u2200 i, i + 1 < arr.length \u2192 arr[i]! + 1 < arr[i+1]!) \u2192\n  count_range_collapses arr = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_is_power_of_two\n  {arr : List Int} (h : arr.length > 1) :\n  is_power_of_two (count_range_collapses arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_pairs_determine_result\n  {arr : List Int} (h : arr.length > 1) :\n  let sorted := sort_list arr\n  let consec_count := count_consecutive_pairs sorted\n  count_range_collapses arr = 2 ^ consec_count :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval count_range_collapses [1, 3, 4, 5, 6, 8]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval count_range_collapses [1, 2, 3]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_range_collapses [11, 43, 66, 123]"
      }
    ]
  },
  "fvapps_003956.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isBalanced (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def repeated_parens (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_odd_length_returns_minus_one {s : String} :\n  (s.length % 2 = 1) \u2192 solve s = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_valid_solution_bound {s : String} :\n  solve s \u2265 0 \u2192 solve s \u2264 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty_string :\n  solve \"\" = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_single_paren_left :\n  solve \"(\" = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_single_paren_right :\n  solve \")\" = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_reversed_pair :\n  solve \")(\" = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve \")(\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve \"(((())\"\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve \"(((\""
      }
    ]
  },
  "fvapps_003957.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def ant (grid : List (List Int)) (col : Int) (row : Int) (steps : Int)\n  (direction : Int := 0) : List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def BLACK : Int := 1"
      },
      {
        "type": "sig",
        "string": "def WHITE : Int := 0"
      },
      {
        "type": "cond",
        "string": "theorem ant_result_rectangular {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 \u2264 col) (h2: 0 \u2264 row) (h3: 0 \u2264 steps) (h4: 0 \u2264 dir) (h5: dir \u2264 3)\n  (h6: grid.length > 0) (h7 : \u2200 r \u2208 grid, r.length = grid.head!.length) :\n  let result := ant grid col row steps dir\n  \u2200 r \u2208 result, r.length = result.head!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ant_result_valid_colors {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 \u2264 col) (h2: 0 \u2264 row) (h3: 0 \u2264 steps) (h4: 0 \u2264 dir) (h5: dir \u2264 3) :\n  let result := ant grid col row steps dir\n  \u2200 r \u2208 result, \u2200 cell \u2208 r, cell = BLACK \u2228 cell = WHITE :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ant_result_size {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 \u2264 col) (h2: 0 \u2264 row) (h3: 0 \u2264 steps) (h4: 0 \u2264 dir) (h5: dir \u2264 3) :\n  let result := ant grid col row steps dir\n  result.length \u2265 grid.length \u2227 result.head!.length \u2265 grid.head!.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ant_preserves_input {grid : List (List Int)} {col row steps dir : Int}\n  (h1: 0 \u2264 col) (h2: 0 \u2264 row) (h3: 0 \u2264 steps) (h4: 0 \u2264 dir) (h5: dir \u2264 3) :\n  let result := ant grid col row steps dir\n  grid = grid :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ant_zero_steps {grid : List (List Int)} {col row : Int}\n  (h1: 0 \u2264 col) (h2: 0 \u2264 row) :\n  ant grid col row 0 = grid :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003959.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def repeater (s : String) (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeater_length (s : String) (n : Nat) :\n  (repeater s n).length = s.length * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeater_eq_concat (s : String) (n : Nat) :\n  repeater s n = String.join (List.replicate n s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For any non-empty repeater output, we can verify it consists of the original string repeated -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem repeater_validity (s : String) (n : Nat) (h : n > 0) :\n  \u2200 k : Nat, k < n \u2192 String.isPrefixOf s (repeater s n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeater_zero (s : String) :\n  repeater s 0 = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeater_one (s : String) :\n  repeater s 1 = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'aaaaa'\n-/\n#guard_msgs in\n#eval repeater \"a\" 5\n\n/-\ninfo: 'NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaNa'\n-/\n#guard_msgs in\n#eval repeater \"Na\" 16\n\n/-\ninfo: 'Wub Wub Wub Wub Wub Wub '\n-/\n#guard_msgs in\n#eval repeater \"Wub \" 6"
      }
    ]
  },
  "fvapps_003962.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum : List Nat \u2192 Nat\n| [] => 0\n| (x::xs) => x + sum xs"
      },
      {
        "type": "sig",
        "string": "def maxList : List Nat \u2192 Nat\n| [] => 0\n| [x] => x\n| (x::xs) => max x (maxList xs)"
      },
      {
        "type": "sig",
        "string": "def zipWith (f : Nat \u2192 Nat \u2192 Nat) : List Nat \u2192 List Nat \u2192 List Nat\n| [], _ => []\n| _, [] => []\n| (x::xs), (y::ys) => f x y :: zipWith f xs ys"
      },
      {
        "type": "sig",
        "string": "def min_sum (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_sum_non_negative (nums : List Nat)\n  (h : nums.length \u2265 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def pairwiseProduct (nums : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  let n := nums.length\n  let firstHalf := nums.take (n/2)\n  let secondHalf := (nums.drop (n/2)).reverse\n  sum (zipWith (fun x y => x * y) firstHalf secondHalf)"
      },
      {
        "type": "cond",
        "string": "theorem min_sum_upper_bound (nums : List Nat)\n  (h : nums.length \u2265 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums \u2264 sum nums * maxList nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_sum_reverse_invariant (nums : List Nat)\n  (h : nums.length \u2265 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums = min_sum nums.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_sum_permutation_invariant (nums\u2081 nums\u2082 : List Nat)\n  (h1 : nums\u2081.length \u2265 2)\n  (h2 : nums\u2081.length % 2 = 0)\n  (h3 : nums\u2081.length = nums\u2082.length)\n  (h4 : \u2200 x, nums\u2081.count x = nums\u2082.count x) :\n  min_sum nums\u2081 = min_sum nums\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_sum_minimality (nums : List Nat)\n  (h : nums.length \u2265 2)\n  (h2 : nums.length % 2 = 0) :\n  min_sum nums \u2264 pairwiseProduct nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003967.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime : Nat \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def factors_up_to (n : Nat) (k : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem not_prime_if_less_than_2 (n : Nat) (h : n \u2264 1) : \u00ac(is_prime n = true) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_iff_no_factors (n : Nat) (h : n \u2265 2) :\n  is_prime n = true \u2194 \u00ac(factors_up_to n (n/2) = true) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem wilson_prime_property (n : Nat) (h1 : n \u2265 2) (h2 : n \u2264 20) :\n  is_prime n = true \u2192 (factorial (n-1) + 1) % n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_prime 29\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_prime 143"
      }
    ]
  },
  "fvapps_003971.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.sumAscii (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def highest_value (a b : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highest_value_is_input (a b : String) :\n  let result := highest_value a b\n  result = a \u2228 result = b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highest_value_maximizes_sum (a b : String) :\n  let result := highest_value a b\n  String.sumAscii result \u2265 String.sumAscii (if result = a then b else a) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highest_value_equal_sums (a b : String) :\n  String.sumAscii a = String.sumAscii b \u2192\n  highest_value a b = a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highest_value_identical (s : String) :\n  highest_value s s = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem highest_value_nonempty (a b : String) :\n  a.length > 0 \u2192\n  b.length > 0 \u2192\n  (highest_value a b).length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'KkLlMmNnOoPp4567'\n-/\n#guard_msgs in\n#eval highest_value \"AaBbCcXxYyZz0189\" \"KkLlMmNnOoPp4567\"\n\n/-\ninfo: 'ABcd'\n-/\n#guard_msgs in\n#eval highest_value \"ABcd\" \"0123\"\n\n/-\ninfo: \"{}[]@~'#:;\"\n-/\n#guard_msgs in\n#eval highest_value \"!\"?$%^&*()\" \"{}[]@~\"#:;\""
      }
    ]
  },
  "fvapps_003974.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pairwise_pairs : List Int \u2192 Int \u2192 List (Int \u00d7 Int)\n| xs, n => sorry"
      },
      {
        "type": "sig",
        "string": "def pairwise : List Int \u2192 Int \u2192 Int\n| xs, n => sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairwise_nonnegative {arr : List Int} {n : Int} :\n  pairwise arr n \u2265 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairwise_less_than_triangular {arr : List Int} {n : Int} :\n  let max_triangular := (arr.length * (arr.length - 1)) / 2\n  pairwise arr n \u2264 max_triangular := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairwise_indices_sum_correctly {arr : List Int} {n : Int} :\n  let used_indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.foldr (\u00b7 + \u00b7) 0 used_indices = pairwise arr n := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairwise_indices_unique {arr : List Int} {n : Int} :\n  let indices := List.map Prod.fst (pairwise_pairs arr n) ++ List.map Prod.snd (pairwise_pairs arr n)\n  List.Nodup indices := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairwise_empty_zero {n : Int} :\n  pairwise [] n = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_003975.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def odd_dig_cubic (a b : Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to check if a number's digits are all odd"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def hasAllOddDigits (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to check if a number is a perfect cube"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isPerfectCube (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_sorted (a b : Int) :\n  let result := odd_dig_cubic a b\n  \u2200 i, i + 1 < result.length \u2192 result[i]! \u2264 result[i+1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_all_cubes (a b : Int) :\n  let result := odd_dig_cubic a b\n  \u2200 n \u2208 result, isPerfectCube n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_all_odd_digits (a b : Int) :\n  let result := odd_dig_cubic a b\n  \u2200 n \u2208 result, hasAllOddDigits n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_in_range (a b : Int) :\n  let result := odd_dig_cubic a b\n  \u2200 n \u2208 result, min a b \u2264 n \u2227 n \u2264 max a b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_zero : odd_dig_cubic 0 0 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_one : odd_dig_cubic 1 1 = [1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_neg_one : odd_dig_cubic (-1) (-1) = [-1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem odd_dig_cubic_single_point (n : Int) :\n  let result := odd_dig_cubic n n\n  result \u2260 [] \u2192 result.length = 1 \u2227 result[0]! = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [-3375, -1331, -1, 1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 5000\n\n/-\ninfo: [1, 1331, 3375]\n-/\n#guard_msgs in\n#eval odd_dig_cubic 0 5000\n\n/-\ninfo: [-3375, -1331]\n-/\n#guard_msgs in\n#eval odd_dig_cubic -5000 -2"
      }
    ]
  },
  "fvapps_003979.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def simplify (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def desimplify (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsSqrt (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countSqrt (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isNumeric (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def splitByWhitespace (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Desimplifying a simplified number returns the original number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem simplify_desimplify_roundtrip (n : Nat) (h : n > 0) :\n  desimplify (simplify n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- A simplified expression contains at most one sqrt -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem simplify_sqrt_count (n : Nat) (h : n > 0) :\n  countSqrt (simplify n) \u2264 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- A simplified expression with no sqrt is a single number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem simplify_no_sqrt (n : Nat) (h : n > 0) :\n  \u00accontainsSqrt (simplify n) \u2192 isNumeric (simplify n).trim :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- A simplified expression with sqrt is in format \"a sqrt b\" or \"sqrt b\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem simplify_with_sqrt (n : Nat) (h : n > 0) :\n  let s := simplify n\n  let parts := splitByWhitespace s\n  containsSqrt s \u2192\n    (parts.length = 2 \u2227 parts.get! 0 = \"sqrt\" \u2227 isNumeric (parts.get! 1)) \u2228\n    (parts.length = 3 \u2227 isNumeric (parts.get! 0) \u2227 parts.get! 1 = \"sqrt\" \u2227 isNumeric (parts.get! 2)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Desimplifying returns a positive integer -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem desimplify_range (n : Nat) (h : n > 0) :\n  desimplify (simplify n) > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval simplify 1\n\n/-\ninfo: '2 sqrt 2'\n-/\n#guard_msgs in\n#eval simplify 8\n\n/-\ninfo: '2 sqrt 5'\n-/\n#guard_msgs in\n#eval simplify 20\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval desimplify \"1\"\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 2\"\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval desimplify \"2 sqrt 5\""
      }
    ]
  },
  "fvapps_003982.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_missing (seq : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_range_int (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  (List.range n).map Int.ofNat"
      },
      {
        "type": "sig",
        "string": "def is_arithmetic_seq (seq : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_missing_complete_sequence\n  (start step : Int)\n  (length : Nat)\n  (h1 : length \u2265 3)\n  (h2 : length \u2264 10)\n  (h3 : -100 \u2264 start)\n  (h4 : start \u2264 100)\n  (h5 : 1 \u2264 step)\n  (h6 : step \u2264 20) :\n  let full_seq := (list_range_int length).map (fun i => start + i * step)\n  let i := length / 2\n  let seq_with_missing := (full_seq.take i) ++ (full_seq.drop (i+1))\n  find_missing seq_with_missing = (full_seq.get! i) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_missing_existing_arithmetic\n  {seq : List Int}\n  (h1 : seq.length \u2265 3)\n  (h2 : seq.length \u2264 20)\n  (h3 : is_arithmetic_seq seq = true) :\n  let diff := seq.get! 1 - seq.get! 0\n  \u2203 i, i < seq.length - 1 \u2227\n       seq.get! (i+1) - seq.get! i \u2260 diff \u2192\n       find_missing seq = seq.get! i + diff :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_missing [1, 2, 3, 4, 6, 7, 8, 9]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 5, 9, 11]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_missing [1, 3, 4]"
      }
    ]
  },
  "fvapps_003995.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def spin_solve (s : String) : String := sorry\n\ndef countChar (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc x => if x = c then acc + 1 else acc) 0"
      },
      {
        "type": "other",
        "string": "/- The output of spin_solve is always a string -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_is_string (s : String) :\n  \u2203 (result : String), spin_solve s = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Properties of single word transformations -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem single_word_properties (word : String) :\n  word \u2260 \"\" \u2192\n  (word.length > 6 \u2228 (countChar word.toLower 't' > 1) \u2192\n    spin_solve word = String.join (word.data.reverse.map toString)) \u2227\n  (word.length = 2 \u2192 spin_solve word = word.toUpper) \u2227\n  (word.length = 1 \u2192 spin_solve word = \"0\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Punctuation is preserved at the end of words -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem punctuation_preservation (word : String) (punct : Char) :\n  word \u2260 \"\" \u2192\n  punct \u2208 ['.', '!', '?', ',', ':', ';'] \u2192\n  (spin_solve (word.push punct)).back = punct :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The number of spaces is preserved in the output -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem space_preservation (sentence : String) :\n  countChar sentence ' ' = countChar (spin_solve sentence) ' ' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'emocleW.'\n-/\n#guard_msgs in\n#eval spin_solve \"Welcome.\"\n\n/-\ninfo: 'MOTHER, PLEASE, HELP, ME.'\n-/\n#guard_msgs in\n#eval spin_solve \"Mother, please, help, me.\"\n\n/-\ninfo: 'IF 0 man does not keep pace with his snoinapmoc, spahrep IT IS esuaceb HE hears 0 tnereffid remmurd.'\n-/\n#guard_msgs in\n#eval spin_solve \"If a man does not keep pace with his companions, perhaps it is because he hears a different drummer.\""
      }
    ]
  },
  "fvapps_004001.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidTriangle (a b c : Float) : Prop :="
      },
      {
        "type": "impl",
        "string": "  (a + b > c) \u2227 (b + c > a) \u2227 (a + c > b)"
      },
      {
        "type": "sig",
        "string": "def calculateArea (a b c : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  let s := (a + b + c) / 2\n  Float.sqrt (s * (s - a) * (s - b) * (s - c))"
      },
      {
        "type": "sig",
        "string": "def equableTriangle (a b c : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isClose (x y : Float) (tol : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem equable_triangle_isosceles {x : Float} (h : x > 0)\n  (hvalid : isValidTriangle x x x) :\n  equableTriangle x x x = isClose (calculateArea x x x) (3 * x) 0.0001 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem equable_triangle_general {a b c : Float} (ha : a > 0) (hb : b > 0) (hc : c > 0)\n  (hvalid : isValidTriangle a b c) :\n  equableTriangle a b c = isClose (calculateArea a b c) (a + b + c) 0.0001 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 5 12 13\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval equable_triangle 2 3 4\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval equable_triangle 6 25 29"
      }
    ]
  },
  "fvapps_004007.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def remove_smallest (list : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (list : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_eq (l1 l2 : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem remove_smallest_length (list : List Int) :\n  list = [] \u2192 remove_smallest list = [] \u2227\n  list \u2260 [] \u2192 List.length (remove_smallest list) = List.length list - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2, 3, 4, 5]\n-/\n#guard_msgs in\n#eval remove_smallest [1, 2, 3, 4, 5]\n\n/-\ninfo: [2, 2, 2, 1]\n-/\n#guard_msgs in\n#eval remove_smallest [2, 2, 1, 2, 1]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval remove_smallest []"
      }
    ]
  },
  "fvapps_004008.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def complex_sum (arr : List String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def complex_str (real imag : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def real_part (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def imag_part (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Sum of complex numbers is equal to sum of separate numbers"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem complex_sum_equals_separate_sums {arr : List String} :\n  \u2200 (real_sum imag_sum : Int),\n  complex_sum arr = complex_str real_sum imag_sum \u2192\n  real_sum = list_sum (arr.map real_part) \u2227\n  imag_sum = list_sum (arr.map imag_part) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Sum of pure imaginary numbers has no real part"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem pure_imaginary_sum {arr : List String} :\n  arr.all (\u03bb s => s = \"i\") \u2192\n  complex_sum arr = complex_str 0 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Empty list sums to zero"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_list_sums_to_zero :\n  complex_sum [] = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- List of zeros sums to zero"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem zeros_sum_to_zero {arr : List String} :\n  arr.all (\u03bb s => s = \"0\") \u2192\n  complex_sum arr = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5+2i'\n-/\n#guard_msgs in\n#eval complex_sum [\"2+3i\", \"3-i\"]\n\n/-\ninfo: '6i'\n-/\n#guard_msgs in\n#eval complex_sum [\"i\", \"2i\", \"3i\"]\n\n/-\ninfo: '0'\n-/\n#guard_msgs in\n#eval complex_sum []"
      }
    ]
  },
  "fvapps_004010.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bits_war (numbers : List Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitsToCount (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list_nat : List Nat \u2192 Nat\n  | [] => 0\n  | x :: xs => x + sum_list_nat xs"
      },
      {
        "type": "cond",
        "string": "theorem bits_war_returns_valid_result (numbers : List Int) (h : numbers.length > 0) :\n  (bits_war numbers = \"odds win\") \u2228\n  (bits_war numbers = \"evens win\") \u2228\n  (bits_war numbers = \"tie\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bits_war_all_zeros (numbers : List Int) :\n  (\u2200 n \u2208 numbers, n = 0) \u2192\n  bits_war numbers = \"tie\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bits_war_all_positive (numbers : List Int) (h : numbers.length > 0) :\n  (\u2200 n \u2208 numbers, n \u2265 0) \u2192\n  let odd_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 1)).map bitsToCount)\n  let even_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 0)).map bitsToCount)\n  bits_war numbers = if odd_bits > even_bits then \"odds win\"\n                     else if even_bits > odd_bits then \"evens win\"\n                     else \"tie\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'odds win'\n-/\n#guard_msgs in\n#eval bits_war [1, 5, 12]\n\n/-\ninfo: 'evens win'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, 20]\n\n/-\ninfo: 'tie'\n-/\n#guard_msgs in\n#eval bits_war [7, -3, -2, 6]"
      }
    ]
  },
  "fvapps_004011.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverse_letter (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_letter_only_letters (s : String) :\n  \u2200 (c : Char), c \u2208 (reverse_letter s).data \u2192 isAlpha c := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_letter_length (s : String) :\n  (reverse_letter s).length = (s.toList.filter isAlpha).length := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_letter_idempotent (s : String) :\n  reverse_letter (reverse_letter s) = String.mk (s.toList.filter isAlpha) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_letter_preserves_case (s : String) :\n  \u2203 (perm : List Char \u2192 List Char),\n    (reverse_letter s).data.map Char.toLower =\n    (String.mk (s.toList.filter isAlpha)).data.map Char.toLower := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem reverse_letter_empty_no_letters (s : String) :\n  (\u2200 c \u2208 s.data, \u00acisAlpha c) \u2192\n  reverse_letter s = \"\" := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004013.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isPrime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def goldbach (n : Nat) : List (List Nat) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem goldbach_valid_sums {n : Nat} (h : n \u2265 4) (h2 : n % 2 = 0) :\n  let result := goldbach n\n  (\u2200 x \u2208 result, x.length = 2) \u2227\n  (\u2200 x \u2208 result, x[0]! + x[1]! = n) \u2227\n  (\u2200 x \u2208 result, x[0]! \u2264 x[1]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem goldbach_small_inputs {n : Nat} (h : n \u2264 3) :\n  goldbach n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem goldbach_four :\n  goldbach 4 = [[2, 2]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [[3, 7], [5, 5]]\n-/\n#guard_msgs in\n#eval goldbach 10\n\n/-\ninfo: [[5, 47], [11, 41], [23, 29]]\n-/\n#guard_msgs in\n#eval goldbach 52\n\n/-\ninfo: [[5, 53], [11, 47], [17, 41], [29, 29]]\n-/\n#guard_msgs in\n#eval goldbach 58"
      }
    ]
  },
  "fvapps_004017.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (f: Nat \u2192 Nat) (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def squares_needed (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem squares_needed_zero :\n  squares_needed 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem squares_needed_one :\n  squares_needed 1 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem squares_needed_power_two :\n  squares_needed (2^10) = 11 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval squares_needed 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval squares_needed 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval squares_needed 3\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval squares_needed 4"
      }
    ]
  },
  "fvapps_004021.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_average (numbers : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum (l : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum? (l : List Float) : Option Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum? (l : List Float) : Option Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumInt (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem integer_list_average (numbers : List Int) :\n  find_average (numbers.map Float.ofInt) =\n    match numbers with\n    | [] => 0\n    | _  => Float.ofInt (sumInt numbers) / Float.ofInt numbers.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_average :\n  find_average [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_between_min_max (numbers : List Float) (h : numbers \u2260 []) :\n  match minimum? numbers, maximum? numbers with\n  | some min, some max => min \u2264 find_average numbers \u2227 find_average numbers \u2264 max\n  | _, _ => True :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem average_times_length_equals_sum (numbers : List Float) :\n  match numbers with\n  | [] => find_average numbers = 0\n  | _  => find_average numbers * (Float.ofNat numbers.length) = sum numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_average [1, 2, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_average []\n\n/-\ninfo: 2.5\n-/\n#guard_msgs in\n#eval find_average [1.5, 2.5, 3.5]"
      }
    ]
  },
  "fvapps_004022.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def palindrome : (n : Int) \u2192 String \u2295 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem negative_numbers {n : Int} (h : n < 0) : palindrome n = Sum.inl \"Not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countOddDigits (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_digits_odd_count {n : Int} (h1 : n \u2265 100) (h2 : n \u2264 9999)\n  (h3 : countOddDigits n > 1) : palindrome n = Sum.inr false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_integers_text (s : String) : palindrome 0 = Sum.inl \"Not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_integers_dec (d : Float) : palindrome 0 = Sum.inl \"Not valid\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digits {n : Int} (h1 : n \u2265 0) (h2 : n \u2264 9) :\n  palindrome n = Sum.inr false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeated_digits {n : Int} (h1 : n \u2265 1) (h2 : n \u2264 9) :\n  palindrome (n * 11) = Sum.inr true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval palindrome 5\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval palindrome 1331\n\n/-\ninfo: 'Not valid'\n-/\n#guard_msgs in\n#eval palindrome \"ololo\""
      }
    ]
  },
  "fvapps_004028.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sha256_cracker (h: String) (chars: String) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sha256 (s: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem found_string_matches_hash\n  {s h chars result: String} :\n  (h = sha256 s) \u2192\n  (chars = s.toList.toString) \u2192\n  (sha256_cracker h chars = some result) \u2192\n  (sha256 result = h) \u2227\n  (\u2200 c, c \u2208 result.data \u2192 c \u2208 chars.data) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_chars_return_none\n  {s h invalid_chars chars: String} :\n  (h = sha256 s) \u2192\n  (chars = (invalid_chars.toList.filter (fun c => !s.data.contains c)).toString) \u2192\n  (chars \u2260 \"\") \u2192\n  sha256_cracker h chars = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_chars_returns_none\n  {s h: String} :\n  (h = sha256 s) \u2192\n  sha256_cracker h \"\" = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'GoOutside'\n-/\n#guard_msgs in\n#eval sha256_cracker \"b8c49d81cb795985c007d78379e98613a4dfc824381be472238dbd2f974e37ae\" \"deGioOstu\"\n\n/-\ninfo: 'code'\n-/\n#guard_msgs in\n#eval sha256_cracker \"5694d08a2e53ffcae0c3103e5ad6f6076abd960eb1f8a56577040bc1028f702b\" \"cdeo\""
      }
    ]
  },
  "fvapps_004029.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def difference_of_squares (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_up_to (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_squares_up_to (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem difference_non_negative {n : Nat} :\n  difference_of_squares n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_and_one_cases :\n  difference_of_squares 0 = 0 \u2227 difference_of_squares 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strictly_increasing {n : Nat} (h : n \u2265 2) :\n  difference_of_squares n > difference_of_squares (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 170\n-/\n#guard_msgs in\n#eval difference_of_squares 5\n\n/-\ninfo: 2640\n-/\n#guard_msgs in\n#eval difference_of_squares 10\n\n/-\ninfo: 25164150\n-/\n#guard_msgs in\n#eval difference_of_squares 100"
      }
    ]
  },
  "fvapps_004031.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n k : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isStrictlyIncreasing (lst : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def checkSum (n : Nat) (lst : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_large_k (n k : Nat) (h1 : n > 0) (h2 : k > n) :\n  (solve n k).length = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_k_equals_one (n : Nat) (h : n > 0) :\n  let result := solve n 1\n  result.length > 0 \u2192 result = [n] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2, 4, 6]\n-/\n#guard_msgs in\n#eval solve 12 3\n\n/-\ninfo: [3, 6, 9]\n-/\n#guard_msgs in\n#eval solve 18 3\n\n/-\ninfo: [2, 4, 6, 12]\n-/\n#guard_msgs in\n#eval solve 24 4"
      }
    ]
  },
  "fvapps_004037.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pattern (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Nat.toString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_invalid_n (n : Int) (h : n \u2264 0) :\n  pattern n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_valid_num_lines {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  lines.length = 2 * n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_valid_sequence {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  \u2200 i, i \u2264 mid \u2192\n    \u2203 c, c \u2208 String.toList (lines[i]!) \u2227\n    c = ((i + 1).toString.toList[0]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_reverse {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  let mid := lines.length / 2\n  (lines.take mid).reverse = lines.drop (mid + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_symmetric {n : Int} (h : n > 0) :\n  let lines := String.splitOn (pattern n) \"\\n\"\n  \u2200 line \u2208 lines, line = line.reverse :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 3\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern 4 2\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval pattern -5 3"
      }
    ]
  },
  "fvapps_004045.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def souls (character : String) (build : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidCharacter (c : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match c with\n  | \"warrior\" | \"knight\" | \"wanderer\" | \"thief\" | \"bandit\"\n  | \"hunter\" | \"sorcerer\" | \"pyromancer\" | \"cleric\" | \"deprived\" => true\n  | _ => false"
      },
      {
        "type": "sig",
        "string": "def isValidBuild (b : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  b.length = 8 && b.all (fun x => x \u2265 1 && x \u2264 99)"
      },
      {
        "type": "sig",
        "string": "def baseStats (c : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  match c with\n  | \"warrior\" => [11, 8, 12, 13, 13, 11, 9, 9]\n  | \"knight\" => [14, 10, 10, 11, 11, 10, 9, 11]\n  | \"wanderer\" => [10, 11, 10, 10, 14, 12, 11, 8]\n  | \"thief\" => [9, 11, 9, 9, 15, 10, 12, 11]\n  | \"bandit\" => [12, 8, 14, 14, 9, 11, 8, 10]\n  | \"hunter\" => [11, 9, 11, 12, 14, 11, 9, 9]\n  | \"sorcerer\" => [8, 15, 8, 9, 11, 8, 15, 8]\n  | \"pyromancer\" => [10, 12, 11, 12, 9, 12, 10, 8]\n  | \"cleric\" => [11, 11, 9, 12, 8, 11, 8, 14]\n  | \"deprived\" => [11, 11, 11, 11, 11, 11, 11, 11]\n  | _ => []"
      },
      {
        "type": "cond",
        "string": "theorem souls_returns_valid_string\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    result.startsWith s!\"Starting as a {c}\" \u2227\n    (\"level\" \u2208 result.splitOn \" \") \u2227\n    (\"will require\" \u2208 result.splitOn \" \") \u2227\n    result.endsWith \"souls.\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem souls_returns_non_negative_souls\n    {c : String} {b : List Nat}\n    (hc : isValidCharacter c = true)\n    (hb : isValidBuild b = true) :\n    let result := souls c b\n    let soulsNeeded := result.splitOn \"require \" |>.get! 1 |>.splitOn \" souls\" |>.get! 0 |>.toNat!\n    soulsNeeded \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_change_requires_zero_souls\n    {c : String}\n    (hc : isValidCharacter c = true) :\n    let result := souls c (baseStats c)\n    result.endsWith \"will require 0 souls.\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Starting as a deprived, level 6 will require 0 souls.'\n-/\n#guard_msgs in\n#eval souls \"deprived\" [11, 11, 11, 11, 11, 11, 11, 11]\n\n/-\ninfo: 'Starting as a pyromancer, level 2 will require 673 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [10, 12, 11, 12, 9, 12, 11, 8]\n\n/-\ninfo: 'Starting as a pyromancer, level 12 will require 8348 souls.'\n-/\n#guard_msgs in\n#eval souls \"pyromancer\" [16, 12, 11, 12, 9, 12, 13, 10]"
      }
    ]
  },
  "fvapps_004050.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def StringMatches (pattern str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def shorten_to_date (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shorten_to_date_property (dateString : String) :\n  (dateString.contains ',' : Bool) \u2227\n  (StringMatches \"[A-Za-z]+ [A-Za-z]+ \\\\d+, \\\\d+(?:am|pm)\" dateString) \u2192\n  let result := shorten_to_date dateString\n  \u00ac(result.contains ',' : Bool) \u2227\n  result = (dateString.splitOn \",\").get! 0 \u2227\n  result.length < dateString.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shorten_to_date_requires_comma (s : String) :\n  \u00ac((s.contains ',' : Bool) \u2227 (s.splitOn \",\").length = 2) \u2192\n  False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Friday May 2'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Friday May 2, 7pm\"\n\n/-\ninfo: 'Tuesday January 29'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Tuesday January 29, 10pm\"\n\n/-\ninfo: 'Wed September 1'\n-/\n#guard_msgs in\n#eval shorten_to_date \"Wed September 1, 3am\""
      }
    ]
  },
  "fvapps_004051.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def do_math (input : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def make_alpha_num (nums : List Int) (letters : List String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem do_math_returns_int {nums : List Int} {letters : List String}\n  (h_nums_size : nums.length \u2265 2 \u2227 nums.length \u2264 10)\n  (h_letters_size : letters.length \u2265 2 \u2227 letters.length \u2264 10)\n  (h_nums_bound : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 1000)\n  (h_letters_single : \u2200 l \u2208 letters, l.length = 1)\n  : \u2203 n : Int, do_math (make_alpha_num nums letters) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem letter_position_invariant {letter : String}\n  (h_letter_single : letter.length = 1) :\n  do_math (\"123\" ++ letter ++ \" 456\" ++ letter) =\n  do_math (letter ++ \"123 \" ++ letter ++ \"456\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1414\n-/\n#guard_msgs in\n#eval do_math \"24z6 1z23 y369 89z 900b\"\n\n/-\ninfo: 1299\n-/\n#guard_msgs in\n#eval do_math \"24z6 1x23 y369 89a 900b\"\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval do_math \"10a 90x 14b 78u 45a 7b 34y\""
      }
    ]
  },
  "fvapps_004053.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solution (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def floor (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ceil (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_output_options (x : Float) :\n  let floorX := floor x\n  solution x = floorX \u2228 solution x = floorX + 0.5 \u2228 solution x = ceil x\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_within_half (x : Float) :\n  (solution x - x) \u2264 0.5 \u2227 (x - solution x) \u2264 0.5\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solution_cases (x : Float) :\n  let floorX := floor x\n  (x - floorX < 0.25 \u2192 solution x = floorX) \u2227\n  (x - floorX < 0.75 \u2227 x - floorX \u2265 0.25 \u2192 solution x = floorX + 0.5) \u2227\n  (x - floorX \u2265 0.75 \u2192 solution x = ceil x)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solution 4.2\n\n/-\ninfo: 4.5\n-/\n#guard_msgs in\n#eval solution 4.6\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval solution 4.75"
      }
    ]
  },
  "fvapps_004059.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hungry_seven (arr : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_result (input : List Nat) (result : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_89_pattern (arr : List Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_seven (arr : List Nat) : Bool := sorry\n\ndef count_val (n : Nat) (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  List.length (List.filter (\u00b7 = n) xs)"
      },
      {
        "type": "cond",
        "string": "theorem hungry_seven_properties (arr : List Nat)\n  (h1 : \u2200 x \u2208 arr, x = 7 \u2228 x = 8 \u2228 x = 9)\n  : let result := hungry_seven arr\n    -- Result maintains same length\n    (result.length = arr.length) \u2227\n    -- Result only contains 7,8,9\n    (\u2200 x \u2208 result, x = 7 \u2228 x = 8 \u2228 x = 9) \u2227\n    -- Counts are preserved\n    (count_val 7 arr = count_val 7 result) \u2227\n    (count_val 8 arr = count_val 8 result) \u2227\n    (count_val 9 arr = count_val 9 result) \u2227\n    -- Result is stable\n    (hungry_seven result = result) \u2227\n    -- If no 7s or no 89 pattern, result unchanged\n    ((!has_seven arr \u2228 !has_89_pattern arr) \u2192 result = arr) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_seven_before_89_pattern (arr : List Nat)\n  (h1 : arr.length \u2265 2)\n  (h2 : \u2200 x \u2208 arr, x \u2265 7 \u2227 x \u2264 9) :\n  let result := hungry_seven arr\n  \u2200 i < result.length - 1,\n    result[i]? = some 7 \u2192\n    \u00ac(result[i+1]? = some 8 \u2227 result[i+2]? = some 9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004064.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def getParticipants (h : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def choose (n k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem handshakes_bounds (h : Nat) :\n  let n := getParticipants h\n  let possibleHandshakes := if n \u2265 2 then choose n 2 else 0\n  n \u2265 1 \u2227 possibleHandshakes \u2265 h :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem basic_cases :\n  getParticipants 0 = 1 \u2227\n  getParticipants 1 = 2 \u2227\n  getParticipants 6 = 4 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval get_participants 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_participants 1\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval get_participants 6"
      }
    ]
  },
  "fvapps_004067.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def types (x : \u03b1) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any given value, the types function returns a string that should be consistent -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem types_matches_type_name {\u03b1 : Type} (x : \u03b1) :\n  types x = types x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The types function is reflexive -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem types_preserves_equality {\u03b1 : Type} (x : \u03b1) :\n  types x = types x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'int'\n-/\n#guard_msgs in\n#eval types 23\n\n/-\ninfo: 'float'\n-/\n#guard_msgs in\n#eval types 2.3\n\n/-\ninfo: 'str'\n-/\n#guard_msgs in\n#eval types \"Hello\"\n\n/-\ninfo: 'bool'\n-/\n#guard_msgs in\n#eval types True"
      }
    ]
  },
  "fvapps_004074.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Array.getSum (arr : Array Int) (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def Array.getMean (arr : Array Int) (x y : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_x_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 \u2192 x \u2264 0 \u2192 Array.getMean arr x y = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_y_returns_negative_one {arr : Array Int} {x y : Int} :\n  arr.size > 0 \u2192 y \u2264 0 \u2192 Array.getMean arr x y = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_larger_than_array {arr : Array Int} {x y : Int} :\n  x > arr.size \u2228 y > arr.size \u2192\n  Array.getMean arr x y = -1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mean_properties {arr : Array Int} {x y : Int} :\n  arr.size \u2265 2 \u2192\n  1 < x \u2227 x \u2264 arr.size \u2192\n  1 < y \u2227 y \u2264 arr.size \u2192\n  let firstMean := Float.ofInt (Array.getSum arr x.toNat) / Float.ofInt x;\n  let secondMean := Float.ofInt (Array.getSum (arr.extract (arr.size - y.toNat) arr.size) y.toNat) / Float.ofInt y;\n  let expected := (firstMean + secondMean) / 2;\n  (Array.getMean arr x y - expected).abs < 1e-10 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004079.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_arrangements (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem deterministic (n : Nat) :\n  sum_arrangements n = sum_arrangements n := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digit_sum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_of_digit_sum (n : Nat) (h : n > 0) :\n  sum_arrangements n % digit_sum n = 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_digit (n : Nat) (h : n > 0) (h\u2082 : n < 10) :\n  sum_arrangements n = n := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem positive_output (n : Nat) (h : n > 0) :\n  sum_arrangements n > 0 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 187\n-/\n#guard_msgs in\n#eval sum_arrangements 98\n\n/-\ninfo: 1332\n-/\n#guard_msgs in\n#eval sum_arrangements 123\n\n/-\ninfo: 99990\n-/\n#guard_msgs in\n#eval sum_arrangements 1185"
      }
    ]
  },
  "fvapps_004086.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.swap : String \u2192 String\n  | _ => sorry\n\ndef Char.isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  let vowels := ['a', 'e', 'i', 'o', 'u']\n  sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_preserves_length (s : String) :\n  (String.swap s).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_idempotent (s : String) :\n  String.swap (String.swap s) = String.swap s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_preserves_non_vowels (s : String) (i : String.Pos) :\n  \u00ac(Char.isVowel (s.get i)) \u2192\n  (String.swap s).get i = s.get i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem swap_capitalizes_vowels (s : String) (i : String.Pos) :\n  (Char.isVowel (s.get i)) \u2192\n  ((String.swap s).get i).isUpper = true \u2227\n  ((String.swap s).get i).toLower = (s.get i).toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'HEllOWOrld!'\n-/\n#guard_msgs in\n#eval swap \"HelloWorld!\"\n\n/-\ninfo: 'SUndAy'\n-/\n#guard_msgs in\n#eval swap \"Sunday\"\n\n/-\ninfo: 'AbrAcAdAbrA'\n-/\n#guard_msgs in\n#eval swap \"abracadabra\""
      }
    ]
  },
  "fvapps_004090.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def chessBishopDream (boardSize: List Int) (initPos: List Int) (initDir: List Int) (k: Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def inRange (x: Int) (lower: Int) (upper: Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  lower \u2264 x \u2227 x < upper"
      },
      {
        "type": "cond",
        "string": "theorem bishop_within_boundaries\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: \u2200 x \u2208 boardSize, 1 \u2264 x \u2227 x \u2264 100)\n  (h5: \u2200 x \u2208 initPos, 0 \u2264 x \u2227 x \u2264 100)\n  (h6: \u2200 x \u2208 initDir, x = -1 \u2228 x = 1)\n  (h7: 0 \u2264 k \u2227 k \u2264 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 \u2227\n  (\u2200 i < 2, inRange (result[i]!) 0 (boardSize[i]!)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bishop_periodic\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: \u2200 x \u2208 boardSize, 1 \u2264 x \u2227 x \u2264 100)\n  (h5: \u2200 x \u2208 initPos, 0 \u2264 x \u2227 x \u2264 100)\n  (h6: \u2200 x \u2208 initDir, x = -1 \u2228 x = 1) :\n  let period := (4 * boardSize[0]! * boardSize[1]!).toNat\n  chessBishopDream boardSize initPos initDir period =\n  chessBishopDream boardSize initPos initDir 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bishop_reflection\n  (boardSize: List Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: \u2200 x \u2208 boardSize, 1 \u2264 x \u2227 x \u2264 100)\n  (h5: \u2200 x \u2208 initPos, 0 \u2264 x \u2227 x \u2264 100)\n  (h6: \u2200 x \u2208 initDir, x = -1 \u2228 x = 1)\n  (h7: 0 \u2264 k \u2227 k \u2264 1000) :\n  let result := chessBishopDream boardSize initPos initDir k\n  List.length result = 2 \u2227\n  (\u2200 i < 2, result[i]! \u2264 boardSize[i]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [3, 7] [1, 2] [-1, 1] 13\n\n/-\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [1, 2] [0, 0] [1, 1] 6\n\n/-\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval chess_bishop_dream [2, 2] [1, 0] [1, 1] 12"
      }
    ]
  },
  "fvapps_004098.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def body_count (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Any string matching the pattern [A-Z][0-9] repeated 5 times, followed by\n    .-[A-Z]%[0-9].[0-9][0-9]. should return true -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem valid_code_returns_true {code : String}\n  (h : \u2203 (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 : Char) (n\u2081 n\u2082 n\u2083 n\u2084 n\u2085 : Nat) (last_letter : Char)\n        (last_num dec\u2081 dec\u2082 : Nat),\n    'A' \u2264 a\u2081 \u2227 a\u2081 \u2264 'Z' \u2227\n    'A' \u2264 a\u2082 \u2227 a\u2082 \u2264 'Z' \u2227\n    'A' \u2264 a\u2083 \u2227 a\u2083 \u2264 'Z' \u2227\n    'A' \u2264 a\u2084 \u2227 a\u2084 \u2264 'Z' \u2227\n    'A' \u2264 a\u2085 \u2227 a\u2085 \u2264 'Z' \u2227\n    'A' \u2264 last_letter \u2227 last_letter \u2264 'Z' \u2227\n    n\u2081 \u2264 9 \u2227 n\u2082 \u2264 9 \u2227 n\u2083 \u2264 9 \u2227 n\u2084 \u2264 9 \u2227 n\u2085 \u2264 9 \u2227\n    last_num \u2264 9 \u2227\n    dec\u2081 \u2264 9 \u2227 dec\u2082 \u2264 9 \u2227\n    code = String.mk [a\u2081, Char.ofNat (n\u2081 + 48),\n                     a\u2082, Char.ofNat (n\u2082 + 48),\n                     a\u2083, Char.ofNat (n\u2083 + 48),\n                     a\u2084, Char.ofNat (n\u2084 + 48),\n                     a\u2085, Char.ofNat (n\u2085 + 48),\n                     '.', '-', last_letter, '%',\n                     Char.ofNat (last_num + 48), '.',\n                     Char.ofNat (dec\u2081 + 48), Char.ofNat (dec\u2082 + 48), '.']) :\n  body_count code = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Any string not matching the pattern should return false -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem invalid_code_returns_false {s : String}\n  (h : \u00ac\u2203 (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 : Char) (n\u2081 n\u2082 n\u2083 n\u2084 n\u2085 : Nat) (last_letter : Char)\n        (last_num dec\u2081 dec\u2082 : Nat),\n    'A' \u2264 a\u2081 \u2227 a\u2081 \u2264 'Z' \u2227\n    'A' \u2264 a\u2082 \u2227 a\u2082 \u2264 'Z' \u2227\n    'A' \u2264 a\u2083 \u2227 a\u2083 \u2264 'Z' \u2227\n    'A' \u2264 a\u2084 \u2227 a\u2084 \u2264 'Z' \u2227\n    'A' \u2264 a\u2085 \u2227 a\u2085 \u2264 'Z' \u2227\n    'A' \u2264 last_letter \u2227 last_letter \u2264 'Z' \u2227\n    n\u2081 \u2264 9 \u2227 n\u2082 \u2264 9 \u2227 n\u2083 \u2264 9 \u2227 n\u2084 \u2264 9 \u2227 n\u2085 \u2264 9 \u2227\n    last_num \u2264 9 \u2227\n    dec\u2081 \u2264 9 \u2227 dec\u2082 \u2264 9 \u2227\n    s = String.mk [a\u2081, Char.ofNat (n\u2081 + 48),\n                  a\u2082, Char.ofNat (n\u2082 + 48),\n                  a\u2083, Char.ofNat (n\u2083 + 48),\n                  a\u2084, Char.ofNat (n\u2084 + 48),\n                  a\u2085, Char.ofNat (n\u2085 + 48),\n                  '.', '-', last_letter, '%',\n                  Char.ofNat (last_num + 48), '.',\n                  Char.ofNat (dec\u2081 + 48), Char.ofNat (dec\u2082 + 48), '.']) :\n  body_count s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"A6C2E5Z9A4.-F%8.08.\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval body_count \"PP P6A6T5F5S3.-Z%1.11.hgr\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval body_count \"b4A1D1I8B4.-E%8.76.\""
      }
    ]
  },
  "fvapps_004107.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def langtons_ant (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  n"
      },
      {
        "type": "cond",
        "string": "theorem langtons_ant_non_negative (n : Nat) :\n  langtons_ant n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem langtons_ant_first_moves (n : Nat) :\n  (n = 0 \u2192 langtons_ant n = 0) \u2227\n  (n = 1 \u2192 langtons_ant n = 1) \u2227\n  (n \u2265 2 \u2192 langtons_ant n \u2264 n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem langtons_ant_periodic (n1 n2 : Nat) :\n  n1 \u2265 9977 \u2192 n2 \u2265 9977 \u2192\n  (n1 - n2) % 104 = 0 \u2192\n  (if langtons_ant n1 \u2265 langtons_ant n2\n   then langtons_ant n1 - langtons_ant n2\n   else langtons_ant n2 - langtons_ant n1) =\n    12 * (if (n1 - 9977) / 104 \u2265 (n2 - 9977) / 104\n          then (n1 - 9977) / 104 - (n2 - 9977) / 104\n          else (n2 - 9977) / 104 - (n1 - 9977) / 104) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval langtons_ant 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval langtons_ant 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval langtons_ant 2\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval langtons_ant 10\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval langtons_ant 100"
      }
    ]
  },
  "fvapps_004108.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort_number (l : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_number_length {l : List Int} (h : l \u2260 []) :\n  (sort_number l).length = l.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (l : List Int) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 l[i]! \u2264 l[j]!"
      },
      {
        "type": "cond",
        "string": "theorem sort_number_first {l : List Int} (h : l \u2260 []) :\n  (sort_number l).head! = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_number_deterministic {l : List Int} (h : l \u2260 []) :\n  sort_number l = sort_number l :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1, 1, 2, 3, 4]\n-/\n#guard_msgs in\n#eval sort_number [1, 2, 3, 4, 5]\n\n/-\ninfo: [1, 2, 2]\n-/\n#guard_msgs in\n#eval sort_number [2, 2, 2]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval sort_number [42]"
      }
    ]
  },
  "fvapps_004110.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def anagrams (word : String) (words : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sameLetters (word1 word2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem anagram_properties (word : String) (words : List String) :\n  let result := anagrams word words\n  -- Result is subset of input\n  (\u2200 w \u2208 result, w \u2208 words) \u2227\n  -- Each result same length as input\n  (\u2200 w \u2208 result, String.length w = String.length word) \u2227\n  -- Each result has same letters\n  (\u2200 w \u2208 result, sameLetters w word) \u2227\n  -- Contains all valid anagrams\n  (\u2200 w \u2208 words, sameLetters w word \u2192 w \u2208 result) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list (word : String) :\n  anagrams word [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_word (word : String) :\n  anagrams word [word] = [word] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem reversed_word (word : String) :\n  let reversed := reverseString word\n  anagrams word [reversed] = [reversed] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['aabb', 'bbaa']\n-/\n#guard_msgs in\n#eval anagrams \"abba\" [\"aabb\", \"abcd\", \"bbaa\", \"dada\"]\n\n/-\ninfo: ['carer', 'racer']\n-/\n#guard_msgs in\n#eval anagrams \"racer\" [\"crazer\", \"carer\", \"racar\", \"caers\", \"racer\"]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval anagrams \"laser\" [\"lazing\", \"lazy\", \"lacer\"]"
      }
    ]
  },
  "fvapps_004111.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def mem_alloc (banks : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mem_alloc_positive (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  xs.foldl (\u00b7 + \u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem mem_alloc_preserves_input (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mem_alloc_deterministic (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 70\n-/\n#guard_msgs in\n#eval mem_alloc [5, 1, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 600]\n\n/-\ninfo: 316\n-/\n#guard_msgs in\n#eval mem_alloc [53, 21, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 60]\n\n/-\ninfo: 826\n-/\n#guard_msgs in\n#eval mem_alloc [14, 21, 10, 0, 1, 7, 0, 14, 3, 12, 8, 10, 17, 12, 0, 19]"
      }
    ]
  },
  "fvapps_004115.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def shortest_time (speeds: List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sorted (l: List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPermutation (l1 l2: List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_time_positive (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: \u2200 x \u2208 speeds, x \u2265 1) :\n  shortest_time speeds > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_time_min_bound (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: \u2200 x \u2208 speeds, x \u2265 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds \u2265 sorted[0]! + sorted[1]! + sorted[3]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_time_two_crossings (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: \u2200 x \u2208 speeds, x \u2265 1) :\n  let sorted := speeds.sorted\n  shortest_time speeds \u2265 2 * (sorted[0]! + sorted[1]!) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_time_order_invariant (speeds1 speeds2: List Int)\n  (h1: speeds1.length = 4)\n  (h2: speeds2.length = 4)\n  (h3: \u2200 x \u2208 speeds1, x \u2265 1)\n  (h4: \u2200 x \u2208 speeds2, x \u2265 1)\n  (h5: isPermutation speeds1 speeds2) :\n  shortest_time speeds1 = shortest_time speeds2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem shortest_time_monotonic (speeds: List Int)\n  (h: speeds.length = 4)\n  (h2: \u2200 x \u2208 speeds, x \u2265 1)\n  (i: Nat)\n  (h3: i < speeds.length) :\n  let increased := speeds.set i (speeds[i]! + 1)\n  shortest_time increased \u2265 shortest_time speeds :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval shortest_time [3, 4, 5, 6]\n\n/-\ninfo: 41\n-/\n#guard_msgs in\n#eval shortest_time [3, 7, 10, 18]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval shortest_time [5, 5, 6, 7]"
      }
    ]
  },
  "fvapps_004121.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def hidden (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hidden_length_matches_input {n : Nat} :\n  (toString n).length = (hidden n).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hidden_withInt (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hidden_rejects_negative (n : Int) :\n  n < 0 \u2192 hidden_withInt n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hidden_valid_chars {n : Nat} {c : Char} :\n  c \u2208 (hidden n).data \u2192 c \u2208 ['o', 'b', 'l', 'i', 'e', 'a', 't', 'd', 'n', 'm'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem hidden_consistent_mapping {n\u2081 n\u2082 : Nat} {i : Nat} {pos1 : String.Pos} {pos2 : String.Pos} :\n  i < min (toString n\u2081).length (toString n\u2082).length \u2192\n  (toString n\u2081).get pos1 = (toString n\u2082).get pos2 \u2192\n  (hidden n\u2081).get pos1 = (hidden n\u2082).get pos2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'aid'\n-/\n#guard_msgs in\n#eval hidden 637\n\n/-\ninfo: 'dean'\n-/\n#guard_msgs in\n#eval hidden 7468\n\n/-\ninfo: 'email'\n-/\n#guard_msgs in\n#eval hidden 49632"
      }
    ]
  },
  "fvapps_004134.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def cubeTimes (times: List Float) : Float \u00d7 Float := sorry\n\ndef List.minimum (xs : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | x::rest => rest.foldl min x"
      },
      {
        "type": "sig",
        "string": "def List.sort (xs : List Float) : List Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cubeTimes_avg_is_middle_three (times : List Float)\n  (h : times.length = 5)\n  (h2 : \u2200 x \u2208 times, 0.01 \u2264 x \u2227 x \u2264 1000) :\n  let sorted := times.sort\n  let middle_avg := (sorted[1]! + sorted[2]! + sorted[3]!) / 3\n  (cubeTimes times).1 = Float.floor ((middle_avg * 100) + 0.5) / 100 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def Float.decimalPlaces (x : Float) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cubeTimes_avg_decimal_places (times : List Float)\n  (h : times.length = 5)\n  (h2 : \u2200 x \u2208 times, 0.01 \u2264 x \u2227 x \u2264 1000) :\n  let avg := (cubeTimes times).1\n  Float.decimalPlaces avg \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem cubeTimes_fastest_is_min (times : List Float)\n  (h : times.length = 5)\n  (h2 : \u2200 x \u2208 times, 0.01 \u2264 x \u2227 x \u2264 1000) :\n  (cubeTimes times).2 = List.minimum times :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004142.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_negative_zero (x : Float) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to emulate sign behavior -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def getSign (x : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_negative_zero_main (x : Float) :\n  is_negative_zero x = true \u2194 (getSign x < 0 \u2227 x = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def posInf : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def negInf : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def nanFloat : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_negative_zero_special_cases :\n  is_negative_zero posInf = false \u2227\n  is_negative_zero negInf = false \u2227\n  is_negative_zero nanFloat = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_negative_zero_integers (n : Int) :\n  is_negative_zero (Float.ofInt n) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Constants for special float values -/\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_negative_zero -0.0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero 0.0\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_negative_zero -5.0"
      }
    ]
  },
  "fvapps_004143.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def indices (n d : Nat) : List (List (List Nat)) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumIndices (idx : List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def starsAndBars (n k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_valid (n d : Nat) (h1: 0 < n) (h2: n \u2264 10) (h3: d \u2264 10) :\n  \u2200 idx, idx \u2208 indices n d \u2192\n    idx.length = 1 \u2227\n    idx.head!.length = n \u2227\n    (\u2200 x, x \u2208 idx.head! \u2192 x \u2264 d) \u2227\n    sumIndices idx = d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_unique (n d : Nat) (h1: 0 < n) (h2: n \u2264 10) (h3: d \u2264 10) :\n  \u2200 i j, i \u2208 indices n d \u2192 j \u2208 indices n d \u2192 i \u2260 j \u2192 i.head! \u2260 j.head! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_zero (n : Nat) (h1: 0 < n) (h2: n \u2264 10) :\n  indices n 0 = [List.replicate 1 (List.replicate n 0)] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_singleton (d : Nat) (h: d \u2264 10) :\n  indices 1 d = [[[d]]] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_count (n d : Nat) (h1: 0 < n) (h2: n \u2264 5) (h3: d \u2264 5) :\n  (indices n d).length = starsAndBars n d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval len indices(3, 2)\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval len idx[0]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sum idx[0]"
      }
    ]
  },
  "fvapps_004152.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_unfairness (arr : List Int) (k : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMax (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listMin (xs : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sortList (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_unfairness_non_negative {arr : List Int} {k : Nat}\n  (h : arr.length > 0) (h2 : k > 0) (h3 : k \u2264 arr.length) :\n  min_unfairness arr k \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_unfairness_k_one {arr : List Int}\n  (h : arr.length > 0) :\n  min_unfairness arr 1 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_unfairness_max_difference {arr : List Int} {k : Nat}\n  (h1 : arr.length > 1) (h2 : k > 0) (h3 : k \u2264 arr.length) :\n  min_unfairness arr k \u2264 listMax arr - listMin arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem min_unfairness_sort_invariant {arr : List Int} {k : Nat}\n  (h1 : k > 1) (h2 : arr.length \u2265 k) :\n  min_unfairness arr k = min_unfairness (sortList arr) k :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval min_unfairness [30, 100, 1000, 150, 60, 250, 10, 120, 20] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_unfairness [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2] 10\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_unfairness [] 0"
      }
    ]
  },
  "fvapps_004153.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def NUMBER_WORDS : List String := [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef uncollapse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstring (pattern : String) (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem uncollapse_random_combinations (numbers : List String)\n  (h : numbers \u2260 [] \u2227 \u2200 n \u2208 numbers, n \u2208 NUMBER_WORDS) :\n  uncollapse (String.join numbers) = String.join (List.intersperse \" \" numbers) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uncollapse_preserves_order (numbers : List String)\n  (h : numbers.length \u2265 2 \u2227 \u2200 n \u2208 numbers, n \u2208 NUMBER_WORDS) :\n  (uncollapse (String.join numbers)).split (. == ' ') = numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uncollapse_single_number (num : String)\n  (h : num \u2208 NUMBER_WORDS) :\n  uncollapse num = num :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem uncollapse_invalid_input (s : String)\n  (h : \u2200 word \u2208 NUMBER_WORDS, isSubstring word s = false) :\n  uncollapse s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'three'\n-/\n#guard_msgs in\n#eval uncollapse \"three\"\n\n/-\ninfo: 'eight six'\n-/\n#guard_msgs in\n#eval uncollapse \"eightsix\"\n\n/-\ninfo: 'five four seven'\n-/\n#guard_msgs in\n#eval uncollapse \"fivefourseven\""
      }
    ]
  },
  "fvapps_004157.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_in_middle (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_or_short_string (s : String) :\n  s.length \u2264 3 \u2192 is_in_middle s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstring (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem without_abc (s : String) :\n  containsSubstring s \"abc\" = false \u2192 is_in_middle s = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_padding (n : Nat) :\n  let s := String.mk (List.replicate n 'A') ++ \"abc\" ++ String.mk (List.replicate n 'A')\n  is_in_middle s = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_in_middle \"AAabcBB\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"AabcBBB\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_in_middle \"\""
      }
    ]
  },
  "fvapps_004165.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def next_higher (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countOnes (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_higher_preserves_bit_count (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  countOnes n = countOnes (next_higher n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_higher_is_higher (n : Nat) (h : n > 0) (h2 : n < 2^16) :\n  next_higher n > n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_higher_power_two (i : Nat) (h : i < 8) :\n  next_higher (2^i) = 2^(i+1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 256\n-/\n#guard_msgs in\n#eval next_higher 128\n\n/-\ninfo: 191\n-/\n#guard_msgs in\n#eval next_higher 127\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval next_higher 1"
      }
    ]
  },
  "fvapps_004170.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def minimum_steps (arr : List Nat) (n : Nat) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  l.foldl (\u00b7+\u00b7) 0"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_nonnegative (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n \u2260 none) :\n  \u2200 result, minimum_steps arr n = some result \u2192 result \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_less_than_length (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n \u2260 none) :\n  \u2200 result, minimum_steps arr n = some result \u2192 result < arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_sum_sufficient (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n \u2260 none) :\n  \u2200 result, minimum_steps arr n = some result \u2192\n  sumList (List.take (result + 1) (arr.sort)) \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_sum_necessary (arr : List Nat) (n : Nat)\n  (h : minimum_steps arr n \u2260 none) :\n  \u2200 result, minimum_steps arr n = some result \u2192\n  result > 0 \u2192 sumList (List.take result (arr.sort)) < n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_sort_invariant (arr : List Nat) (n : Nat) :\n  minimum_steps (arr.sort) n = minimum_steps arr n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_single_element_target_le (x : Nat) (n : Nat) :\n  n \u2264 x \u2192 minimum_steps [x] n = some 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem minimum_steps_first_element_sufficient (x y z : Nat) :\n  minimum_steps [x, y, z] y = some 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [4, 6, 3] 7\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval minimum_steps [10, 9, 9, 8] 17\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval minimum_steps [8, 9, 10, 4, 2] 23"
      }
    ]
  },
  "fvapps_004172.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def eraseDuplicates (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sortList (xs : List \u03b1) : List \u03b1 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_valid_string_properties (s : String) :\n  solve s \u2192\n  (s.length : Nat) = (eraseDuplicates s.toList).length \u2227\n  sortList (s.toList.map Char.toLower) = s.toList := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_invalid_chars (s : String) :\n  s.toList.all (\u03bb c => \u00acc.isLower) \u2192\n  \u00ac(solve s) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_duplicates (s : String) :\n  s.length > 0 \u2192\n  \u00ac(solve (s ++ s)) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_empty :\n  \u00ac(solve \"\") := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"abc\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval solve \"abd\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval solve \"dabc\""
      }
    ]
  },
  "fvapps_004175.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_palindrome (\u03b1 : Type) [ToString \u03b1] (x : \u03b1) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reverse (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_palindrome_property (s : String) :\n  is_palindrome String s = (s = reverse s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem integer_palindrome_property (n : Int) :\n  is_palindrome Int n = (toString n = reverse (toString n)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem palindrome_type_invariant (s : String) :\n  is_palindrome String s = is_palindrome String (toString s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_is_palindrome :\n  is_palindrome String \"\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome \"anna\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_palindrome \"walter\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_palindrome 12321"
      }
    ]
  },
  "fvapps_004182.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isOdd (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def split_odd_and_even (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def charToNat (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem split_returns_list (n : Nat) (h : n > 0) :\n  \u2203 (l : List Nat), split_odd_and_even n = l\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem digits_have_same_parity (n : Nat) (h : n > 0) :\n  \u2200 x, x \u2208 split_odd_and_even n \u2192\n    let digits := (toString x).data\n    \u2200 d, d \u2208 digits \u2192\n      \u2200 h : 0 < digits.length,\n        isOdd (charToNat d) = isOdd (charToNat (digits[0]'h))\n  := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004186.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def end_one (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def solve (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_not_small (n : Nat) :\n  n \u2264 1 \u2192 is_prime n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem is_prime_no_factors (n : Nat) :\n  is_prime n = true \u2192\n  \u2200 i : Nat, 2 \u2264 i \u2192 i \u2264 n^(1/2) \u2192 n % i \u2260 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem prime_multiplication (n : Nat) :\n  2 < n \u2192 is_prime (2*n) = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem end_one_is_bool (n : Nat) :\n  end_one n = true \u2228 end_one n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem end_one_for_one :\n  end_one 1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem end_one_special_cases (n : Nat) :\n  (n = 1 \u2228 n = 10) \u2192 end_one n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_bounded (a b : Nat) :\n  a \u2264 b \u2192\n  0 \u2264 solve a b \u2227 solve a b \u2264 b - a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_wrong_order (a b : Nat) :\n  b < a \u2192 solve a b = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_unit_range (n : Nat) :\n  solve n (n+1) = 0 \u2228 solve n (n+1) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve 1 25\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval solve 100 1000\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval solve 100 2000"
      }
    ]
  },
  "fvapps_004190.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def toString (h : String) (m : String) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigit (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toSeconds (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def fromNat (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidTimeFormat (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_time_conversion\n  {h : Nat} {m : Nat} {s : Nat}\n  (h_bound : h \u2264 99)\n  (m_bound : m \u2264 59)\n  (s_bound : s \u2264 59) :\n  toSeconds (toString (fromNat h) (fromNat m) (fromNat s)) = some (h * 3600 + m * 60 + s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_format_returns_none\n  (s : String)\n  (h_invalid : \u00ac(isValidTimeFormat s)) :\n  toSeconds s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_hours\n  (h m s : String)\n  (h_invalid : h.toNat? = some (Nat.succ 99)) :\n  toSeconds (toString h m s) = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_minutes\n  (h m s : String)\n  (m_invalid : m.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_seconds\n  (h m s : String)\n  (s_invalid : s.toNat? = some (Nat.succ 59)) :\n  toSeconds (toString h m s) = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem missing_components_none\n  (s : String)\n  (h_missing : \u00ac(isValidTimeFormat s)) :\n  toSeconds s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval to_seconds \"00:00:00\"\n\n/-\ninfo: 3723\n-/\n#guard_msgs in\n#eval to_seconds \"01:02:03\"\n\n/-\ninfo: 359999\n-/\n#guard_msgs in\n#eval to_seconds \"99:59:59\""
      }
    ]
  },
  "fvapps_004191.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def jumbledString (s : String) (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem jumbledString_length_preserved (s : String) (n : Int) (h : s.length > 0) :\n  (jumbledString s n).length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSameChars (s\u2081 s\u2082 : String) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 c : Char, (s\u2081.data.countP (\u00b7 = c)) = (s\u2082.data.countP (\u00b7 = c))"
      },
      {
        "type": "cond",
        "string": "theorem jumbledString_same_chars (s : String) (n : Int) (h : s.length > 0) :\n  isSameChars s (jumbledString s n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem jumbledString_periodic (s : String) (n : Int) (h : s.length > 0) :\n  \u2203 k : Nat, k > 0 \u2227\n  jumbledString s n = jumbledString s (n % k) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem jumbledString_empty_or_singleton (s : String) (n : Int) :\n  s.length \u2264 1 \u2192 jumbledString s n = s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sc o!uhWw'\n-/\n#guard_msgs in\n#eval jumbled_string \"Such Wow!\" 1\n\n/-\ninfo: 'bexltept merae'\n-/\n#guard_msgs in\n#eval jumbled_string \"better example\" 2\n\n/-\ninfo: 'qtorieuwy'\n-/\n#guard_msgs in\n#eval jumbled_string \"qwertyuio\" 2"
      }
    ]
  },
  "fvapps_004196.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumGroups (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def getNextArr (arr : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countAlternatingParity (arr : List Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_groups_returns_positive :\n  \u2200 (arr : List Int), arr \u2260 [] \u2192 0 < sumGroups arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_groups_alternating_parity_bound :\n  \u2200 (arr : List Int), arr \u2260 [] \u2192\n  sumGroups arr \u2264 countAlternatingParity arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_groups_monotonic_reduction :\n  \u2200 (arr : List Int), arr \u2260 [] \u2192\n  \u2200 (next : List Int), next = getNextArr arr \u2192\n  next \u2260 arr \u2192\n  List.length next \u2264 List.length arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 5, 5, 7, 7, 4, 3, 3, 9]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval sum_groups [2, 1, 2, 2, 6, 5, 0, 2, 0, 3, 3, 3, 9, 2]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sum_groups [1, 1, 2, 2]"
      }
    ]
  },
  "fvapps_004204.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def has_subpattern (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def gcd (a b : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def reduce (f : Nat \u2192 Nat \u2192 Nat) (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_char_string_property (s : String) :\n  (s.length > 1 \u2227 s.data.eraseDups.length = 1) \u2192 has_subpattern s\n  \u2227\n  (s.length = 1) \u2192 \u00achas_subpattern s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem repeat_property (s : String) :\n  s.length \u2265 2 \u2192\n  has_subpattern s \u2192\n  has_subpattern (s ++ s) \u2227 has_subpattern (s ++ s ++ s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_004208.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def countDivisors (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def divNum (a b : Nat) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem divNum_invalid_range {a b : Nat} (h : a > b) :\n  divNum a b = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem divNum_result_in_range {a b : Nat} (h : a \u2264 b) (result : Nat) :\n  divNum a b = some result \u2192 a \u2264 result \u2227 result \u2264 b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem divNum_max_divisors {a b result : Nat} (h : a \u2264 b) :\n  divNum a b = some result \u2192\n  \u2200 x, a \u2264 x \u2227 x \u2264 b \u2192 countDivisors x \u2264 countDivisors result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem divNum_equal_inputs (x : Nat) :\n  divNum x x = some x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval div_num 15 30\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval div_num 1 2\n\n/-\ninfo: 'Error'\n-/\n#guard_msgs in\n#eval div_num 159 4"
      }
    ]
  },
  "fvapps_004215.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def revamp (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumChars (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sortString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_has_same_word_count (s : String) :\n  (String.split (revamp s) (\u00b7 = ' ')).length = (String.split s (\u00b7 = ' ')).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem words_internally_sorted (s : String) :\n  let result := String.split (revamp s) (\u00b7 = ' ')\n  \u2200 word, word \u2208 result \u2192\n    word = sortString word :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string :\n  revamp \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_004218.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def consecutive (lst : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Helper function to find maximum in list"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listMax : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => max x (listMax xs)\n-- Helper function to find minimum in list"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def listMin : List Int \u2192 Int\n  | [] => 0\n  | (x::xs) => min x (listMin xs)"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_empty : consecutive [] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_property {lst : List Int} (h : lst \u2260 []) :\n  consecutive lst = listMax lst - listMin lst + 1 - lst.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004221.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def BUTTONS : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def presses (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any string made up of valid keypad characters, the number of presses\n    should be at least the length of the string, and each character should\n    be present in one of the buttons -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem keypad_chars_valid (s : String) :\n  (\u2200 c \u2208 s.data, \u2203 button \u2208 BUTTONS, c \u2208 button.data) \u2192\n  presses s \u2265 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/- The number of presses required should be the same regardless of case -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem case_insensitive (button : String) :\n  button \u2208 BUTTONS \u2192\n  presses button.toUpper = presses button.toLower :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For strings containing only numbers and spaces, the number of presses\n    should be at least the length of the string -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem numeric_and_space_presses (s : String) :\n  (\u2200 c \u2208 s.data, c \u2208 [' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']) \u2192\n  presses s \u2265 s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 9\n-/\n#guard_msgs in\n#eval presses \"LOL\"\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval presses \"HOW R U\"\n\n/-\ninfo: 47\n-/\n#guard_msgs in\n#eval presses \"WHERE DO U WANT 2 MEET L8R\""
      }
    ]
  },
  "fvapps_004222.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumin (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumax (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumsum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfMins (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfMaxs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumax_positive (n : Nat) (h : n > 0) :\n  sumax n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfSums (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumsum_equals_sumin_plus_sumax (n : Nat) :\n  sumsum n = sumin n + sumax n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumin_positive (n : Nat) (h : n > 0) :\n  sumin n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumin_le_sumax (n : Nat) :\n  sumin n \u2264 sumax n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumax_ge_sumin (n : Nat) :\n  sumax n \u2265 sumin n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sumsum_positive (n : Nat) (h : n > 0) :\n  sumsum n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 55\n-/\n#guard_msgs in\n#eval sumin 5\n\n/-\ninfo: 91\n-/\n#guard_msgs in\n#eval sumin 6\n\n/-\ninfo: 1240\n-/\n#guard_msgs in\n#eval sumin 15\n\n/-\ninfo: 161\n-/\n#guard_msgs in\n#eval sumax 6\n\n/-\ninfo: 61755\n-/\n#guard_msgs in\n#eval sumax 45\n\n/-\ninfo: 671650\n-/\n#guard_msgs in\n#eval sumax 100\n\n/-\ninfo: 252\n-/\n#guard_msgs in\n#eval sumsum 6\n\n/-\ninfo: 93150\n-/\n#guard_msgs in\n#eval sumsum 45\n\n/-\ninfo: 1010000\n-/\n#guard_msgs in\n#eval sumsum 100"
      }
    ]
  },
  "fvapps_004227.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def WEEKDAY : Nat \u2192 String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ERROR : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def whatday (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem whatday_spec (n : Int) :\n  (1 \u2264 n \u2227 n \u2264 7 \u2192 \u2203 (i : Nat), whatday n = WEEKDAY i) \u2227\n  (\u00ac(1 \u2264 n \u2227 n \u2264 7) \u2192 whatday n = ERROR) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_weekday (n : Int) (h : 1 \u2264 n \u2227 n \u2264 7) :\n  \u2203 (i : Nat), whatday n = WEEKDAY i :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_weekday (n : Int) (h : \u00ac(1 \u2264 n \u2227 n \u2264 7)) :\n  whatday n = ERROR :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Sunday'\n-/\n#guard_msgs in\n#eval whatday 1\n\n/-\ninfo: 'Saturday'\n-/\n#guard_msgs in\n#eval whatday 7\n\n/-\ninfo: ERROR\n-/\n#guard_msgs in\n#eval whatday 0"
      }
    ]
  },
  "fvapps_004235.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def splitString (s : String) (sep : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsString (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def startsWithString (s : String) (pre : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def simplify (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simplify_zero :\n  simplify 0 = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simplify_format_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  terms.length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simplify_terms_valid (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  \u2200 t \u2208 terms,\n    (containsString t \"*\" \u2227\n     let parts := splitString t \"*\"\n     parts.length = 2 \u2227\n     let digit := parts[0]!\n     let power := parts[1]!\n     startsWithString power \"10\" \u2227\n     let digitNum := digit.toNat!\n     1 \u2264 digitNum \u2227 digitNum \u2264 9)\n    \u2228\n    (\u00accontainsString t \"*\" \u2227\n     t.all Char.isDigit \u2227\n     let termNum := t.toNat!\n     1 \u2264 termNum \u2227 termNum \u2264 9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simplify_sums_to_input (n : Nat) :\n  let terms := splitString (simplify n) \"+\"\n  terms.foldl\n    (fun acc t =>\n      if containsString t \"*\" then\n        let parts := splitString t \"*\"\n        acc + parts[0]!.toNat! * parts[1]!.toNat!\n      else\n        acc + t.toNat!)\n    0\n  = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simplify_no_leading_zeros (n : Nat) (h : n > 0) :\n  let terms := splitString (simplify n) \"+\"\n  \u2200 t \u2208 terms, \u00acstartsWithString t \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '5*10+6'\n-/\n#guard_msgs in\n#eval simplify 56\n\n/-\ninfo: '9*100+9*10+9'\n-/\n#guard_msgs in\n#eval simplify 999\n\n/-\ninfo: '1*10000+4'\n-/\n#guard_msgs in\n#eval simplify 10004"
      }
    ]
  },
  "fvapps_004242.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def f (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_prime (n : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count_even_digits (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_result_is_prime (n : Int) (h : n \u2265 2) :\n  is_prime (f n) = true \u2228 f n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_result_less_than_input (n : Int) (h : n \u2265 2) :\n  f n \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_result_has_max_even_digits (n : Int) (h : n \u2265 2) :\n  f n \u2260 0 \u2192\n  \u2200 i : Int, 2 \u2264 i \u2192 i \u2264 n \u2192 is_prime i = true \u2192\n  count_even_digits i \u2264 count_even_digits (f n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_result_largest_for_same_even_digits (n : Int) (h : n \u2265 2) :\n  f n \u2260 0 \u2192\n  \u2200 i : Int, f n < i \u2192 i \u2264 n \u2192 is_prime i = true \u2192\n  count_even_digits i = count_even_digits (f n) \u2192 False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_small_inputs (n : Int) (h : n \u2264 1) :\n  f n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 887\n-/\n#guard_msgs in\n#eval f 1000\n\n/-\ninfo: 8887\n-/\n#guard_msgs in\n#eval f 10000\n\n/-\ninfo: 487\n-/\n#guard_msgs in\n#eval f 500"
      }
    ]
  },
  "fvapps_004251.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def HQ9 (s : String) : Option String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def contains (haystack needle : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def count (haystack needle : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem hq9_invalid_none :\n  HQ9 \"\" = none \u2227 HQ9 \" \" = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem h_returns_hello :\n  HQ9 \"H\" = some \"Hello World!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem q_returns_q :\n  HQ9 \"Q\" = some \"Q\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nine_returns_song (result : String) :\n  HQ9 \"9\" = some result \u2192\n  contains result \"99 bottles of beer\" = true \u2227\n  contains result \"1 bottle of beer\" = true \u2227\n  contains (String.toLower result) \"no more bottles of beer\" = true \u2227\n  count result \"of beer\" \u2265 190 \u2227\n  count result \"\\n\" \u2265 99 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_hq9_returns_none (s : String) :\n  s \u2260 \"H\" \u2192 s \u2260 \"Q\" \u2192 s \u2260 \"9\" \u2192\n  HQ9 s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval HQ9 \"X\"\n\n/-\ninfo: 'Hello World!'\n-/\n#guard_msgs in\n#eval HQ9 \"H\"\n\n/-\ninfo: 'Q'\n-/\n#guard_msgs in\n#eval HQ9 \"Q\""
      }
    ]
  },
  "fvapps_004253.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def lengthOf (\u03b1 : Type) : \u03b1 \u2192 Nat\n  | _ => sorry"
      },
      {
        "type": "sig",
        "string": "def order_type {\u03b1 : Type} (arr : List \u03b1) : String := sorry\n\ndef is_sorted_increasing (xs : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < xs.length \u2192 xs[i]! \u2264 xs[j]!"
      },
      {
        "type": "sig",
        "string": "def is_sorted_decreasing (xs : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < xs.length \u2192 xs[i]! \u2265 xs[j]!"
      },
      {
        "type": "cond",
        "string": "theorem constant_length_elements {\u03b1 : Type} [Inhabited \u03b1] (arr : List \u03b1) :\n  arr.length > 0 \u2192\n  (\u2200 i j, i < arr.length \u2192 j < arr.length \u2192 lengthOf \u03b1 (arr[i]!) = lengthOf \u03b1 (arr[j]!)) \u2192\n  order_type arr = \"Constant\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem increasing_length_numbers (arr : List Nat) :\n  arr.length > 0 \u2192\n  is_sorted_increasing (arr.map (\u03bb x => lengthOf Nat x)) \u2192\n  (\u2203 i j, i < arr.length \u2192 j < arr.length \u2192 lengthOf Nat (arr[i]!) \u2260 lengthOf Nat (arr[j]!)) \u2192\n  order_type arr = \"Increasing\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decreasing_length_lists (arr : List (List Nat)) :\n  arr.length > 0 \u2192\n  is_sorted_decreasing (arr.map List.length) \u2192\n  (\u2203 i j, i < arr.length \u2192 j < arr.length \u2192 (arr[i]!).length \u2260 (arr[j]!).length) \u2192\n  order_type arr = \"Decreasing\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unsorted_mixed_types {\u03b1 : Type} [Inhabited \u03b1] (arr : List \u03b1) :\n  arr.length > 0 \u2192\n  \u00ac is_sorted_increasing (arr.map (lengthOf \u03b1)) \u2192\n  \u00ac is_sorted_decreasing (arr.map (lengthOf \u03b1)) \u2192\n  (\u2203 i j, i < arr.length \u2192 j < arr.length \u2192 lengthOf \u03b1 (arr[i]!) \u2260 lengthOf \u03b1 (arr[j]!)) \u2192\n  order_type arr = \"Unsorted\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list {\u03b1 : Type} :\n  order_type ([] : List \u03b1) = \"Constant\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Constant'\n-/\n#guard_msgs in\n#eval order_type [[1, \"b\", [\"p\"], 2]]\n\n/-\ninfo: 'Increasing'\n-/\n#guard_msgs in\n#eval order_type [123, 1234, 12345, 123456]\n\n/-\ninfo: 'Decreasing'\n-/\n#guard_msgs in\n#eval order_type [[1, 2, 3, 4], [5, 6, 7], [8, 9]]"
      }
    ]
  },
  "fvapps_004270.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def share_price (invested : Float) (changes : List Float) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def parseFloat? (s : String) : Option Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem share_price_valid_format {invested : Float} {changes : List Float}\n  (h1 : invested > 0)\n  (h2 : \u2200 c \u2208 changes, c \u2265 -99.99 \u2227 c \u2264 1000) :\n  \u2203 p d,\n    share_price invested changes = p ++ \".\" ++ d \u2227\n    d.length = 2 \u2227\n    (parseFloat? (share_price invested changes)).isSome \u2227\n    \u2203 x, parseFloat? (share_price invested changes) = some x \u2227 x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem share_price_empty_changes {invested : Float}\n  (h : invested > 0) :\n  share_price invested [] = toString invested ++ \".\" ++ \"00\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '100.00'\n-/\n#guard_msgs in\n#eval share_price 100 []\n\n/-\ninfo: '75.00'\n-/\n#guard_msgs in\n#eval share_price 100 [-50, 50]\n\n/-\ninfo: '1113.64'\n-/\n#guard_msgs in\n#eval share_price 1000 [0, 2, 3, 6]"
      }
    ]
  },
  "fvapps_004275.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def IsPowerOfTwo (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def validateRhythm (meter : List Nat) (score : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem validate_rhythm_result_options (meter : List Nat) (score : String) :\n  let result := validateRhythm meter score;\n  result = \"Valid rhythm\" \u2228 result = \"Valid rhythm with anacrusis\" \u2228 result = \"Invalid rhythm\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- For valid rhythms, internal bars should sum to the correct total -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_rhythm_valid_bars_sum (meter : List Nat) (score : String)\n  (h1 : meter.length = 2) (h2 : meter[0]! > 0) (h3 : meter[1]! > 0)\n  (h4 : let result := validateRhythm meter score;\n        result = \"Valid rhythm\" \u2228 result = \"Valid rhythm with anacrusis\") :\n  let bars := score.splitOn \"|\";\n  \u2200 bar \u2208 bars.tail.dropLast, bar \u2260 \"\" \u2192\n  \u2203 barSum target : Nat,\n    barSum = target \u2227 target = meter[0]! / meter[1]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Invalid meter denominators result in invalid rhythms -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem validate_rhythm_invalid_meter_denom (meter : List Nat)\n  (h1 : meter.length = 2)\n  (h2 : meter[1]! > 0)\n  (h3 : \u00ac(IsPowerOfTwo meter[1]!)) :\n  validateRhythm meter \"4|4\" = \"Invalid rhythm\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'Invalid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [4, 4] \"4444|8484842|888\"\n\n/-\ninfo: 'Valid rhythm with anacrusis'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 4] \"4|44|88\"\n\n/-\ninfo: 'Valid rhythm'\n-/\n#guard_msgs in\n#eval validate_rhythm [2, 2] \"22|22|22\""
      }
    ]
  },
  "fvapps_004279.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def int_to_negabinary (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def negabinary_to_int (s : String) : Int := sorry\n\ndef isValidBinaryStr (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.length > 0 && s.all (fun c => c = '0' || c = '1')"
      },
      {
        "type": "cond",
        "string": "theorem round_trip (n : Int) :\n  negabinary_to_int (int_to_negabinary n) = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_binary_string (n : Int) :\n  isValidBinaryStr (int_to_negabinary n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem neg_bin_str_converts (s : String) (h : isValidBinaryStr s) :\n  \u2203 n : Int, negabinary_to_int s = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem zero_special_case :\n  int_to_negabinary 0 = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '11010'\n-/\n#guard_msgs in\n#eval int_to_negabinary 6\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval negabinary_to_int \"11010\"\n\n/-\ninfo: '1110'\n-/\n#guard_msgs in\n#eval int_to_negabinary -6\n\n/-\ninfo: -6\n-/\n#guard_msgs in\n#eval negabinary_to_int \"1110\"\n\n/-\ninfo: '100'\n-/\n#guard_msgs in\n#eval int_to_negabinary 4\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval negabinary_to_int \"100\""
      }
    ]
  },
  "fvapps_004288.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumOfDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isPowerOfTen (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_result_bounded (n : Nat) (h : n > 0) :\n  let result := solve n\n  result \u2265 0 \u2227 result \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 99\n-/\n#guard_msgs in\n#eval solve 100\n\n/-\ninfo: 48\n-/\n#guard_msgs in\n#eval solve 48\n\n/-\ninfo: 999\n-/\n#guard_msgs in\n#eval solve 1000"
      }
    ]
  },
  "fvapps_004289.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def permutation_average (n : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def permutation_average_str (s : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem permutation_average_returns_integer (n : Int)\n  (h : 0 \u2264 n \u2227 n \u2264 999) :\n  \u2203 i : Int, permutation_average n = i := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_int_equivalent (n : Int)\n  (h : 0 \u2264 n \u2227 n \u2264 999) :\n  permutation_average n = permutation_average_str (toString n) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem leading_zeros_valid (n : Int)\n  (h : 0 \u2264 n \u2227 n \u2264 99) :\n  \u2203 i : Int, permutation_average_str (\"0\" ++ toString n) = i := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem result_within_bounds (n : Int)\n  (h : 10 \u2264 n \u2227 n \u2264 999) :\n  permutation_average n \u2265 0 \u2227 permutation_average n \u2264 n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval permutation_average 2\n\n/-\ninfo: 38\n-/\n#guard_msgs in\n#eval permutation_average 25\n\n/-\ninfo: 629\n-/\n#guard_msgs in\n#eval permutation_average 737"
      }
    ]
  },
  "fvapps_004300.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def bin2gray (bits : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def gray2bin (bits : List Nat) : List Nat := sorry\n\ndef isBinary (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  n == 0 || n == 1"
      },
      {
        "type": "cond",
        "string": "theorem gray_code_roundtrip (bits : List Nat) (h : \u2200 x \u2208 bits, isBinary x = true) :\n  gray2bin (bin2gray bits) = bits :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gray_code_length (bits : List Nat) (h\u2081 : List.length bits > 0) (h\u2082 : \u2200 x \u2208 bits, isBinary x = true) :\n  List.length (bin2gray bits) = List.length bits :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gray_code_first_bit (bits : List Nat) (h\u2081 : List.length bits > 0) (h\u2082 : \u2200 x \u2208 bits, isBinary x = true) :\n  List.head! (bin2gray bits) = List.head! bits :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gray_code_values_binary (bits : List Nat) (h\u2081 : List.length bits > 0) (h\u2082 : \u2200 x \u2208 bits, isBinary x = true) :\n  \u2200 x \u2208 bin2gray bits, isBinary x = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1, 1]\n-/\n#guard_msgs in\n#eval bin2gray [1, 0, 1]\n\n/-\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval bin2gray [1, 1]\n\n/-\ninfo: test3_input\n-/\n#guard_msgs in\n#eval gray2bin bin2gray(test3_input)"
      }
    ]
  },
  "fvapps_004306.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isValidHexColor (color : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def shadesOfGrey (n : Int) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Each output is a valid list of strings where each string is a valid hex color -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem shadesOfGrey_outputs_valid_list (n : Int) :\n  \u2200 x \u2208 shadesOfGrey n, isValidHexColor x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Non-positive inputs return empty list -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem nonpositive_input_returns_empty {n : Int} (h : n \u2264 0) :\n  shadesOfGrey n = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Output length is constrained between 0 and min(n, 254) -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_length_constraints (n : Int) :\n  List.length (shadesOfGrey n) = min (max 0 n) 254 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Values are monotonically increasing -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem values_monotonic_increasing {n : Int} (h1 : 1 \u2264 n) (h2 : n \u2264 254) :\n  let result := shadesOfGrey n\n  let values := result.map (fun color => (color.take 3).toNat!)\n  \u2200 i j, i < j \u2192 j < values.length \u2192 values[i]! < values[j]! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- RGB components are equal for each color -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem rgb_components_equal {n : Int} (h1 : 1 \u2264 n) (h2 : n \u2264 254) :\n  let result := shadesOfGrey n\n  \u2200 color \u2208 result,\n    color.get! \u27e81\u27e9 = color.get! \u27e83\u27e9 \u2227\n    color.get! \u27e83\u27e9 = color.get! \u27e85\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: []\n-/\n#guard_msgs in\n#eval shades_of_grey -1\n\n/-\ninfo: ['#010101']\n-/\n#guard_msgs in\n#eval shades_of_grey 1\n\n/-\ninfo: ['#010101', '#020202', '#030303']\n-/\n#guard_msgs in\n#eval shades_of_grey 3"
      }
    ]
  },
  "fvapps_004308.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def distance (x y : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def angle (x y : Float) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def get_score (x y : Float) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def ValidScores : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_score_returns_valid : \u2200 x y : Float, x \u2265 -200 \u2227 x \u2264 200 \u2227 y \u2265 -200 \u2227 y \u2264 200 \u2192\n  get_score x y \u2208 ValidScores :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem same_distance_angle_same_score : \u2200 x y x2 y2 : Float,\n  x \u2265 -200 \u2227 x \u2264 200 \u2227 y \u2265 -200 \u2227 y \u2264 200 \u2227\n  x2 \u2265 -200 \u2227 x2 \u2264 200 \u2227 y2 \u2265 -200 \u2227 y2 \u2264 200 \u2192\n  distance x y = distance x2 y2 \u2227 angle x y = angle x2 y2 \u2192\n  get_score x y = get_score x2 y2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem outside_board_is_X : \u2200 x y : Float,\n  x > 170.1 \u2227 x \u2264 200 \u2227 y \u2265 -200 \u2227 y \u2264 200 \u2192\n  get_score x y = \"X\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem bulls_eye_region : \u2200 x y : Float,\n  x \u2265 -6.35 \u2227 x \u2264 6.35 \u2227 y \u2265 -6.35 \u2227 y \u2264 6.35 \u2227\n  distance x y \u2264 6.35 \u2192\n  get_score x y = \"DB\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'X'\n-/\n#guard_msgs in\n#eval get_score -133.69 -147.38\n\n/-\ninfo: 'DB'\n-/\n#guard_msgs in\n#eval get_score 4.06 0.71\n\n/-\ninfo: 'T2'\n-/\n#guard_msgs in\n#eval get_score 55.53 -87.95"
      }
    ]
  },
  "fvapps_004310.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def binary_zeros_count (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def binary_ones_count (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def more_zeros (s : String) : List Char :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem more_zeros_results_unique (s : String) :\n  let result := more_zeros s\n  (List.length result = List.length (List.eraseDups result)) \u2227\n  (\u2200 c \u2208 result, s.data.contains c) := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem more_zeros_binary_property (s : String) :\n  let result := more_zeros s\n  \u2200 c \u2208 result, binary_zeros_count c > binary_ones_count c := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem more_zeros_inclusion_complete (s : String) :\n  let result := more_zeros s\n  \u2200 c \u2208 s.data,\n    binary_zeros_count c > binary_ones_count c \u2192\n    c \u2209 result \u2192\n    (s.data.filter (\u00b7 = c)).length > 1 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem more_zeros_ascii_printable (s : String) :\n  let result := more_zeros s\n  \u2200 c \u2208 result, 32 \u2264 c.toNat \u2227 c.toNat \u2264 127 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004317.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def play_if_enough (hand play : String) : Bool \u00d7 String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_success_length {hand play : String} :\n  let res := play_if_enough hand play\n  res.1 \u2192 res.2.length = hand.length - play.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_success_subset {hand play : String} {c : Char} :\n  let res := play_if_enough hand play\n  res.1 \u2192 res.2.count c \u2264 hand.count c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_failure_preserves {hand play : String} :\n  let res := play_if_enough hand play\n  \u00acres.1 \u2192 res.2 = hand :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_empty_succeeds {hand : String} :\n  (play_if_enough hand \"\").1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_too_long_fails {hand play : String} :\n  play.length > hand.length \u2192\n  \u00ac(play_if_enough hand play).1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem play_if_enough_impossible_preserves {hand : String} :\n  let impossible := String.mk (List.replicate (hand.length + 1) 'z')\n  let res := play_if_enough hand impossible\n  \u00acres.1 \u2227 res.2 = hand :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: (False, '')\n-/\n#guard_msgs in\n#eval play_if_enough \"\" \"bw\"\n\n/-\ninfo: (True, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"ooooogggssbbb\" \"ooogg\"\n\n/-\ninfo: (False, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"oogssbbb\" \"bwsg\""
      }
    ]
  },
  "fvapps_004318.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def string_color (s : String) : Option String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_color_short_strings {s : String} (h : s.length \u2264 1) :\n  string_color s = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hexToNat (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_color_valid_ranges {s : String} (h : s.length \u2265 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    let r := hexToNat result\n    let g := hexToNat result\n    let b := hexToNat result\n    r \u2264 255 \u2227 g \u2264 255 \u2227 b \u2264 255 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_color_longer_strings {s : String} (h : s.length \u2265 2) :\n  match string_color s with\n  | none => False\n  | some result =>\n    result.length = 6 \u2227\n    (\u2200 c \u2208 result.data, c \u2208 ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_color_deterministic {s : String} :\n  string_color s = string_color s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"A\"\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval string_color \"\"\n\n/-\ninfo: '79CAE5'\n-/\n#guard_msgs in\n#eval string_color \"Jack\""
      }
    ]
  },
  "fvapps_004320.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def penaltyShots (shots: Nat) (scores: List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def abs (n: Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_shots_score_range {shots score1 score2: Nat}\n  (h1: score1 \u2264 shots) (h2: score2 \u2264 shots)\n  (h3: shots \u2264 20) (h4: score1 \u2264 20) (h5: score2 \u2264 20)\n  (h6: abs (Int.subNatNat score1 score2) \u2264 (if shots > 4 then 2 else 5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 \u2264 result \u2227 result \u2264 (if shots > 4 then 2 else 5 - shots + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_shots_sudden_death {shots score1 score2: Nat}\n  (h1: shots > 4) (h2: score1 \u2264 shots) (h3: score2 \u2264 shots)\n  (h4: abs (Int.subNatNat score1 score2) \u2264 2) :\n  let result := penaltyShots shots [score1, score2]\n  0 \u2264 result \u2227 result \u2264 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_shots_regular_rounds {shots score1 score2: Nat}\n  (h1: shots \u2264 4) (h2: score1 \u2264 shots) (h3: score2 \u2264 shots)\n  (h4: abs (Int.subNatNat score1 score2) \u2264 (5 - shots + 1)) :\n  let result := penaltyShots shots [score1, score2]\n  0 \u2264 result \u2227 result \u2264 (5 - shots + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval penaltyShots 2 [1, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 10 [10, 10]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval penaltyShots 5 [5, 5]"
      }
    ]
  },
  "fvapps_004330.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def clean_string (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_string_idempotent (s : String) :\n  clean_string (clean_string s) = clean_string s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count_hashtags (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.foldl (fun acc c => if c = '#' then acc + 1 else acc) 0"
      },
      {
        "type": "cond",
        "string": "theorem clean_string_no_hashtags (s : String) :\n  \u00ac(String.contains (clean_string s) '#') :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_string_append {s\u2081 s\u2082 : String}\n  (h\u2081 : \u00ac(String.contains s\u2081 '#'))\n  (h\u2082 : \u00ac(String.contains s\u2082 '#')) :\n  clean_string (s\u2081 ++ s\u2082) = clean_string s\u2081 ++ clean_string s\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_string_length (s : String) :\n  String.length (clean_string s) \u2264 String.length s - count_hashtags s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem clean_string_empty :\n  clean_string \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ac'\n-/\n#guard_msgs in\n#eval clean_string \"abc#d##c\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval clean_string \"#######\"\n\n/-\ninfo: 'jf'\n-/\n#guard_msgs in\n#eval clean_string \"abjd####jfk#\""
      }
    ]
  },
  "fvapps_004331.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def decompose : Int \u2192 List Nat \u00d7 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Decompose function's list result contains only numbers greater than 1 -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem decompose_result_gt_one (n : Int) :\n  let (result, _) := decompose n\n  \u2200 k \u2208 result, k > 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Decompose function's remainder is non-negative -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem decompose_remainder_nonneg (n : Int) :\n  let (_, remainder) := decompose n\n  remainder \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The decomposition recomposes back to the original number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem decompose_recompose (n : Int) :\n  let (result, remainder) := decompose n\n  let recomposed := remainder + (List.foldl (fun acc (i, k) => acc + (i + 2)^k) 0\n    (List.zip (List.range result.length) result))\n  recomposed = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Negative inputs return empty list and same number as remainder -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem decompose_negative (n : Int) :\n  n < 0 \u2192\n  decompose n = ([], n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Small inputs (0,1) return empty list and same number -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem decompose_small_inputs (n : Int) :\n  n = 0 \u2228 n = 1 \u2192\n  decompose n = ([], n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: [[], 3]\n-/\n#guard_msgs in\n#eval decompose 3\n\n/-\ninfo: [[4, 2], 1]\n-/\n#guard_msgs in\n#eval decompose 26\n\n/-\ninfo: [[], 0]\n-/\n#guard_msgs in\n#eval decompose 0"
      }
    ]
  },
  "fvapps_004332.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_consec_zeros (n: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def toWord (n: Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 1: Function should work for any valid positive integer string input"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem max_consec_zeros_valid_input {n: String} (h: \u2203 (k: Nat), k > 0 \u2227 k \u2264 10^6 \u2227 n = toString k) :\n  let result := max_consec_zeros n\n  \u2203 word, word \u2208 [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n                  \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\"] \u2227 result = word :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 2: Powers of 2 should have n-1 consecutive zeros"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem powers_of_two_zeros {n: Nat} (h: n > 0 \u2227 n \u2264 12) :\n  max_consec_zeros (toString (2^n)) = toWord (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Property 3: Result should be same for equivalent decimal values"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem equivalent_decimal_values {n: Nat} (h: n > 0 \u2227 n \u2264 10000) :\n  max_consec_zeros (toString n) = max_consec_zeros (toString (n : Nat)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Two'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"9\"\n\n/-\ninfo: 'Three'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"550\"\n\n/-\ninfo: 'Eight'\n-/\n#guard_msgs in\n#eval max_consec_zeros \"256\""
      }
    ]
  },
  "fvapps_004337.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def debug (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.containsSubstr (s str : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.countOccurrences (s str : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem debug_basic_properties (s : String) :\n  let result := debug s\n  (\u00ac result.containsSubstr \"bug\" \u2228 result.containsSubstr \"bugs\") \u2227\n  result.length \u2264 s.length \u2227\n  result = s.replace \"bug\" \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem debug_preserves_bugs (s : String) (h : \u2200 c \u2208 s.data, c = 'b' \u2228 c = 'u' \u2228 c = 'g' \u2228 c = 's') :\n  (debug s).countOccurrences \"bugs\" = s.countOccurrences \"bugs\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem debug_idempotent (s : String) :\n  debug (debug s) = debug s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ooobuoobugsoo'\n-/\n#guard_msgs in\n#eval debug \"obugobugobuoobugsoo\"\n\n/-\ninfo: 'bugs gy'\n-/\n#guard_msgs in\n#eval debug \"bugs buggy\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval debug \"bugbugbugbug\""
      }
    ]
  },
  "fvapps_004340.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def are_similar (xs ys : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identical_lists_are_similar {xs : List Int} (h : xs \u2260 []) :\n  are_similar xs xs :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def insertSort (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem different_contents_not_similar {xs ys : List Int} :\n  insertSort xs \u2260 insertSort ys \u2192\n  \u00ac(are_similar xs ys) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_swap_makes_similar {xs : List Int} (h : xs.length \u2265 2) :\n  let ys := xs.set 0 (xs.get! 1) |>.set 1 (xs.get! 0)\n  are_similar xs ys :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_swaps_not_similar {xs : List Int} (h : xs.length \u2265 3) :\n  let ys := xs.set 0 (xs.get! 1)\n            |>.set 1 (xs.get! 2)\n            |>.set 2 (xs.get! 0)\n  (List.length (List.filter (fun p => p.1 \u2260 p.2) (List.zip xs ys))) > 2 \u2192\n  \u00ac(are_similar xs ys) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [1, 2, 3]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 3] [2, 1, 3]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval are_similar [1, 2, 2] [2, 1, 1]"
      }
    ]
  },
  "fvapps_004354.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def perms (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listPerms (l : List \u03b1) : List (List \u03b1) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def listToString (l : List Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def numUnique (xs : List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perms_matches_unique_perms_int {n : Nat} :\n  perms (toString n) = numUnique ((listPerms (toString n).data).map listToString) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perms_matches_unique_perms_str {s : String} :\n  perms s = numUnique ((listPerms s.data).map listToString) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perms_order_invariant {n : Nat} :\n  perms (toString n) = perms (toString n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perms_positive_int {s : String} (h : s.length > 0) :\n  perms s > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perms_single_char {c : Char} :\n  perms (String.mk [c]) = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval perms 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval perms 25\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval perms \"abc\""
      }
    ]
  },
  "fvapps_004362.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def replace_dashes_as_one (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def remove_dashes (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def containsSubstring (s : String) (sub : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_consecutive_dashes\n  (s : String) :\n  \u00ac (containsSubstring (replace_dashes_as_one s) \"--\") \u2227\n  \u00ac (containsSubstring (replace_dashes_as_one s) \"- -\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem preserves_non_dash_chars\n  (s : String) :\n  remove_dashes s = remove_dashes (replace_dashes_as_one s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent\n  (s : String) :\n  replace_dashes_as_one (replace_dashes_as_one s) = replace_dashes_as_one s :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem dash_only_strings\n  (s : String)\n  (h : \u2200 c, String.contains s c \u2192 (c = '-' \u2228 c = ' ')) :\n  (\u2200 c, String.contains (replace_dashes_as_one s) c \u2192 (c = '-' \u2228 c = ' ')) \u2227\n  \u00ac (containsSubstring (replace_dashes_as_one s) \"--\") \u2227\n  \u00ac (containsSubstring (replace_dashes_as_one s) \"- -\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'we-are- code-warriors.-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"we-are- - - code----warriors.-\"\n\n/-\ninfo: 'a-b-c'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a---b- - -c\"\n\n/-\ninfo: 'a-'\n-/\n#guard_msgs in\n#eval replace_dashes_as_one \"a------\""
      }
    ]
  },
  "fvapps_004366.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def number_increasing (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_2 : number_increasing 2 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def bitLength (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n = 0 then 0 else Nat.log2 n + 1"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_4 : number_increasing 4 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_7 : number_increasing 7 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_12 : number_increasing 12 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_17 : number_increasing 17 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem impossible_values_22 : number_increasing 22 = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiples_of_five (n : Nat) (h\u2081 : n > 1) (h\u2082 : n % 5 = 0) :\n  number_increasing n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem start_point :\n  number_increasing 1 = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiples_of_three_reachable (n : Nat) (h\u2081 : n > 1)\n  (h\u2082 : n = 3^(bitLength (bitLength (n - 1)))) :\n  number_increasing n = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 1\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval number_increasing 2\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 6\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 18\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval number_increasing 32"
      }
    ]
  },
  "fvapps_004369.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def add (a b : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def binary_to_int (s : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_binary (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem strips_leading_zeros (binary : String) :\n  let result := add binary \"0\"\n  (result.startsWith \"0\" \u2192 result = \"0\") \u2227\n  binary_to_int result = binary_to_int binary :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem add_commutative (a b : String) :\n  add a b = add b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_integer_addition (a b : String) :\n  let result := add a b\n  is_valid_binary result \u2227\n  binary_to_int result = binary_to_int a + binary_to_int b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem identity (binary : String) :\n  binary_to_int (add binary \"0\") = binary_to_int binary :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_strings_zero :\n  add \"\" \"\" = \"0\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_one :\n  add \"\" \"1\" = \"1\" \u2227 add \"1\" \"\" = \"1\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1001'\n-/\n#guard_msgs in\n#eval add \"111\" \"10\"\n\n/-\ninfo: '10010'\n-/\n#guard_msgs in\n#eval add \"1101\" \"101\"\n\n/-\ninfo: '100100'\n-/\n#guard_msgs in\n#eval add \"1101\" \"10111\""
      }
    ]
  },
  "fvapps_004380.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def gc_content (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem gc_content_bounded (s : String) :\n  0.0 \u2264 gc_content s \u2227 gc_content s \u2264 100.0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def count (s : String) (c : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_004384.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def penalty (nums : List Nat) : String := sorry\n\ndef stringIsAllDigits (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  s.all Char.isDigit"
      },
      {
        "type": "sig",
        "string": "def listToSortedString (l : List Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  let strList := l.map toString\n  String.join strList"
      },
      {
        "type": "cond",
        "string": "theorem penalty_output_is_numeric (nums : List Nat) (h : nums \u2260 []) :\n  let result := penalty nums\n  stringIsAllDigits result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_preserves_digits (nums : List Nat) (h : nums \u2260 []) :\n  let input_digits := String.join (List.map toString nums)\n  let result := penalty nums\n  input_digits.length = result.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_single_digits (nums : List Nat) (h\u2081 : nums \u2260 [])\n  (h\u2082 : \u2200 n \u2208 nums, n \u2264 9) :\n  penalty nums = listToSortedString nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem penalty_self_consistent (nums\u2081 nums\u2082 : List Nat)\n  (h\u2081 : nums\u2081 \u2260 []) (h\u2082 : nums\u2082 \u2260 [])\n  (h\u2083 : nums\u2081 = nums\u2082) :\n  penalty nums\u2081 = penalty nums\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1304550'\n-/\n#guard_msgs in\n#eval penalty [\"45\", \"30\", \"50\", \"1\"]\n\n/-\ninfo: '100101'\n-/\n#guard_msgs in\n#eval penalty [\"100\", \"10\", \"1\"]\n\n/-\ninfo: '323'\n-/\n#guard_msgs in\n#eval penalty [\"32\", \"3\"]"
      }
    ]
  },
  "fvapps_004388.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pac_man (size : Nat) (pacman : List Nat) (enemies : List (List Nat)) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Theorem ensuring result is an integer bounded by board size -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem pac_man_result_bounds\n  (size : Nat)\n  (px py : Nat)\n  (enemies : List (List Nat))\n  (h : size \u2265 2) :\n  let normalizedPx := px % size\n  let normalizedPy := py % size\n  let result := pac_man size [normalizedPx, normalizedPy] enemies\n  result \u2265 -1 \u2227 result \u2264 size * size - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- Theorem for specific cases -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem pac_man_specific_cases :\n  /- Empty board -/\n  pac_man 3 [0, 0] [] = 8 \u2227\n  /- Single enemy -/\n  pac_man 4 [3, 0] [[1, 2]] = 3 \u2227\n  /- Multiple enemies -/\n  pac_man 2 [0, 0] [[0, 1], [1, 0], [1, 1]] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 3\n-/\n#guard_msgs in\n#eval pac_man 4 [3, 0] [[1, 2]]\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval pac_man 3 [0, 0] []\n\n/-\ninfo: 19\n-/\n#guard_msgs in\n#eval pac_man 8 [1, 1] [[5, 4]]"
      }
    ]
  },
  "fvapps_004391.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def fizz_buzz_cuckoo_clock (time : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def splitOnSpace (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  s.split (fun c => c = ' ')"
      },
      {
        "type": "cond",
        "string": "theorem output_is_nonempty (time : String) :\n  time.length = 5 \u2192 (fizz_buzz_cuckoo_clock time).length > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem half_hour_single_cuckoo (hour : Nat) (h : hour \u2264 23) :\n  let time := (if hour < 10 then \"0\" else \"\") ++ toString hour ++ \":30\"\n  fizz_buzz_cuckoo_clock time = \"Cuckoo\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  },
  "fvapps_004399.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def automorphic (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def length (s : String) : Nat := s.data.length"
      },
      {
        "type": "sig",
        "string": "def endsWith (s1 s2 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem automorphic_returns_valid_string (n : Nat) :\n  automorphic n = \"Automorphic\" \u2228 automorphic n = \"Not!!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem automorphic_definition (n : Nat) :\n  automorphic n = \"Automorphic\" \u2194 endsWith (ToString.toString (n * n)) (ToString.toString n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem automorphic_zero_property (n : Nat) :\n  n = 0 \u2192 automorphic n = \"Automorphic\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem automorphic_length_property (n : Nat) :\n  n > 0 \u2192\n  automorphic n = \"Automorphic\" \u2192\n  length (ToString.toString (n * n)) \u2265 length (ToString.toString n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 6\n\n/-\ninfo: 'Automorphic'\n-/\n#guard_msgs in\n#eval automorphic 25\n\n/-\ninfo: 'Not!!'\n-/\n#guard_msgs in\n#eval automorphic 53"
      }
    ]
  },
  "fvapps_004410.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solve (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_composite (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isDigitIn (d : Char) (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_positive (n : Nat) :\n  solve n > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_monotonic {n : Nat} (h : n > 0) :\n  solve n > solve (n-1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_deterministic (n : Nat) :\n  solve n = solve n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_zero :\n  solve 0 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve 2\n\n/-\ninfo: 44\n-/\n#guard_msgs in\n#eval solve 10"
      }
    ]
  },
  "fvapps_004411.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def order (sentence : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def splitString (s : String) (sep : Char) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def findNumber (s : String) : Option Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (as : List Nat) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < as.length \u2192 as[i]! \u2264 as[j]!"
      },
      {
        "type": "cond",
        "string": "theorem order_preserves_empty_string :\n  order \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_sorts_by_numbers {sentence : String} {words : List String} :\n  words = splitString sentence ' ' \u2192\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_preserves_words {sentence : String} {words : List String} :\n  words = splitString sentence ' ' \u2192\n  let resultWords := splitString (order sentence) ' '\n  words.eraseDups = resultWords.eraseDups \u2227\n  words.length = resultWords.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem order_all_properties {sentence : String} {words : List String} :\n  words = splitString sentence ' ' \u2192\n  (sentence = \"\" \u2192 order sentence = \"\") \u2227\n  let resultWords := splitString (order sentence) ' '\n  let numbers := resultWords.filterMap findNumber\n  isSorted numbers \u2227\n  words.eraseDups = resultWords.eraseDups \u2227\n  words.length = resultWords.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval order \"is2 Thi1s T4est 3a\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval order \"4of Fo1r pe6ople g3ood th5e the2\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval order \"\""
      }
    ]
  },
  "fvapps_004421.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def convert_hash_to_array (d: List (String \u00d7 (String \u2295 Int))) : List (String \u00d7 (String \u2295 Int)) :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def LePair (p1 p2: String \u00d7 (String \u2295 Int)) : Prop :="
      },
      {
        "type": "impl",
        "string": "  p1.1 \u2264 p2.1"
      },
      {
        "type": "cond",
        "string": "theorem convert_hash_output_is_sorted (d: List (String \u00d7 (String \u2295 Int))) :\n  let result := convert_hash_to_array d\n  List.Pairwise LePair result \u2227\n  (\u2200 x \u2208 result, \u2203 k v, x = (k, v)) \u2227\n  result = d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem convert_hash_empty_dict :\n  convert_hash_to_array [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\"}\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval convert_hash_to_array {\"name\": \"Jeremy\", \"age\": 24, \"role\": \"Software Engineer\"}\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval convert_hash_to_array {}"
      }
    ]
  },
  "fvapps_004425.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isDigit (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def allDigits (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def md5hash (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def crack (hash : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crack_roundtrip {num : Nat} (h : num \u2264 99999) :\n  let numStr := toString num\n  let paddedStr := if numStr.length < 5 then String.mk (List.replicate (5 - numStr.length) '0') ++ numStr else numStr\n  crack (md5hash paddedStr) = paddedStr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crack_invalid_hash (s : String)\n  (h1 : s = \"invalid_hash\" \u2228 s = \"\") :\n  crack s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem crack_random_hash (hash : String)\n  (h1 : hash.length = 32) :\n  let result := crack hash\n  (result = \"\") \u2228\n  (result.length = 5 \u2227\n   allDigits result = true \u2227\n   md5hash result = hash) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '12345'\n-/\n#guard_msgs in\n#eval crack \"827ccb0eea8a706c4c34a16891f84e7b\"\n\n/-\ninfo: '00078'\n-/\n#guard_msgs in\n#eval crack \"86aa400b65433b608a9db30070ec60cd\""
      }
    ]
  },
  "fvapps_004427.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def split (s : String) (sep : Char \u2192 Bool) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def trim (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def to_freud (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_returns_empty :\n  to_freud \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem only_whitespace_returns_empty (s : String) :\n  trim s = \"\" \u2192 to_freud s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_empty_only_contains_sex (s : String) :\n  trim s \u2260 \"\" \u2192\n  List.all (split (to_freud s) (\u00b7 = ' ')) (\u00b7 = \"sex\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem preserves_word_count (s : String) :\n  trim s \u2260 \"\" \u2192\n  (split (to_freud s) (\u00b7 = ' ')).length = (split (trim s) (\u00b7 = ' ')).length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'sex'\n-/\n#guard_msgs in\n#eval to_freud \"test\"\n\n/-\ninfo: 'sex sex sex sex'\n-/\n#guard_msgs in\n#eval to_freud \"This is a test\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval to_freud \"\""
      }
    ]
  },
  "fvapps_004428.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def alphabetized (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sorted_list (l : List Char) : List Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAlpha (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetized_is_sorted (s : String) :\n  let result := alphabetized s\n  result = String.mk (sorted_list (result.data)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetized_only_letters (s : String) :\n  let result := alphabetized s\n  \u2200 c \u2208 result.data, isAlpha c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetized_preserves_count (s : String) :\n  let result := alphabetized s\n  let original_letters := s.data.filter isAlpha\n  result.length = original_letters.length \u2227\n  sorted_list (result.data.map Char.toLower) = sorted_list (original_letters.map Char.toLower) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetized_empty_string :\n  alphabetized \"\" = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem alphabetized_no_letters (s : String) :\n  (\u2200 c \u2208 s.data, \u00acisAlpha c) \u2192\n  alphabetized s = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval alphabetized \"\"\n\n/-\ninfo: 'BbeehHilloTy'\n-/\n#guard_msgs in\n#eval alphabetized \"The Holy Bible\"\n\n/-\ninfo: 'aaaaCcdddeLnooorstTWy'\n-/\n#guard_msgs in\n#eval alphabetized \"CodeWars can\"t Load Today\""
      }
    ]
  },
  "fvapps_004438.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def max_profit (prices : List Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def minimum (l : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem max_profit_bounds {prices : List Nat} (h : prices.length \u2265 2) :\n  max_profit prices \u2264 (maximum prices) - (minimum prices) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem ascending_max_profit {prices : List Nat} (h : prices.length \u2265 2)\n  (ascending : \u2200 (i : Nat), i + 1 < prices.length \u2192 prices[i]! \u2264 prices[i + 1]!) :\n  max_profit prices = prices.getLast! - prices.head! :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval max_profit [10, 7, 5, 8, 11, 9]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval max_profit [3, 4]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_profit [9, 9]"
      }
    ]
  },
  "fvapps_004439.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def calculate_tenth_digit (digits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def calculate_last_digit (digits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def check_valid_tr_number (n : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_length_returns_false (n : String) :\n  n.length \u2260 11 \u2192 check_valid_tr_number n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_number_is_accepted {digits : List Nat} (h1 : digits.length = 9)\n  (h2 : digits.head! \u2260 0) :\n  let tenth := calculate_tenth_digit digits\n  let full_digits := digits ++ [tenth]\n  let last := calculate_last_digit full_digits\n  check_valid_tr_number (toString (full_digits ++ [last])) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_check_digits_returns_false {n : String} (h1 : n.length = 11) :\n  let digits := n.toList.map (\u00b7.toString.toNat!)\n  digits[9]! \u2260 calculate_tenth_digit (digits.take 9) \u2228\n  digits[10]! \u2260 calculate_last_digit (digits.take 10) \u2192\n  check_valid_tr_number n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_type_returns_false (n : String) :\n  \u00ac(\u2200 c : Char, c \u2208 n.data \u2192 c.isDigit) \u2192\n  check_valid_tr_number n = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 36637640050\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval check_valid_tr_number 12762438338\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval check_valid_tr_number 10167994524"
      }
    ]
  },
  "fvapps_004455.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sequence (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_nonnegative (n : Nat) :\n  sequence n \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toBinaryString (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def fromBase3 (digits : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_monotonic {n : Nat} (h : n > 0) :\n  sequence n > sequence (n - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- Helper functions for binary/base-3 conversion -/\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sequence 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval sequence 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval sequence 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval sequence 3\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval sequence 4\n\n/-\ninfo: 7329\n-/\n#guard_msgs in\n#eval sequence 334"
      }
    ]
  },
  "fvapps_004463.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def pattern (n : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def lines (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverseString (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_negative_or_zero (n : Int) :\n  n \u2264 0 \u2192 pattern n = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_num_lines (n : Int) :\n  n > 0 \u2192 (lines (pattern n)).length = 2*n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_symmetric_lines (n : Int) (i : Nat) :\n  n > 0 \u2192 i < n-1 \u2192\n  (lines (pattern n)).get \u27e8i, sorry\u27e9 = (lines (pattern n)).get \u27e8n.toNat * 2 - 2 - i, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_middle_line_palindrome (n : Int) :\n  n > 0 \u2192\n  let middle := (lines (pattern n)).get \u27e8(n-1).toNat, sorry\u27e9\n  middle = reverseString middle :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_middle_line_length (n : Int) :\n  n > 0 \u2192\n  let middle := (lines (pattern n)).get \u27e8(n-1).toNat, sorry\u27e9\n  middle.length = 2*n-1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_line_length (n : Int) (i : Nat) :\n  n > 0 \u2192 i < n \u2192\n  let line := (lines (pattern n)).get \u27e8i, sorry\u27e9\n  line.length = 2*(i+1)-1 + 2*(n.toNat-(i+1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pattern_line_palindrome (n : Int) (i : Nat) :\n  n > 0 \u2192 i < n \u2192\n  let line := (lines (pattern n)).get \u27e8i, sorry\u27e9\n  line.trim = reverseString (line.trim) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '1'\n-/\n#guard_msgs in\n#eval pattern 1\n\n/-\ninfo: '  1  \\n 121 \\n12321\\n 121 \\n  1  '\n-/\n#guard_msgs in\n#eval pattern 3\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval pattern 0"
      }
    ]
  },
  "fvapps_004467.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def convert_temp (temp : Float) (from_scale : String) (to_scale : String) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def round (x : Float) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def int_to_float (n : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem convert_temp_identity {temp : Float} {scale : String}\n  (h1 : -1000 \u2264 temp) (h2 : temp \u2264 1000) :\n  convert_temp temp scale scale = round temp := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem convert_temp_returns_int {temp : Float} {from_scale to_scale : String}\n  (h1 : -1000 \u2264 temp) (h2 : temp \u2264 1000) :\n  \u2203 n : Int, convert_temp temp from_scale to_scale = n := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem convert_temp_kelvin_roundtrip {temp : Float} {scale : String}\n  (h1 : -1000 \u2264 temp) (h2 : temp \u2264 1000) (h3 : scale \u2260 \"K\") :\n  let kelvin := int_to_float (convert_temp temp scale \"K\")\n  let back := convert_temp kelvin \"K\" scale\n  (back - round temp) \u2264 2 \u2227 (round temp - back) \u2264 2 := by"
      },
      {
        "type": "proof",
        "string": "  sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 212\n-/\n#guard_msgs in\n#eval convert_temp 100 \"C\" \"F\"\n\n/-\ninfo: 50\n-/\n#guard_msgs in\n#eval convert_temp 40 \"Re\" \"C\"\n\n/-\ninfo: 140\n-/\n#guard_msgs in\n#eval convert_temp 60 \"De\" \"F\"\n\n/-\ninfo: 33\n-/\n#guard_msgs in\n#eval convert_temp 373.15 \"K\" \"N\"\n\n/-\ninfo: 666\n-/\n#guard_msgs in\n#eval convert_temp 666 \"K\" \"K\""
      }
    ]
  },
  "fvapps_004481.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def keep_order (arr : List Int) (val : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem keep_order_bounds {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  0 \u2264 idx \u2227 idx \u2264 arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def min_of_list (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match arr with\n  | [] => 0\n  | x::xs => xs.foldl min x"
      },
      {
        "type": "sig",
        "string": "def max_of_list (arr : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  match arr with\n  | [] => 0\n  | x::xs => xs.foldl max x"
      },
      {
        "type": "cond",
        "string": "theorem keep_order_before {arr : List Int} {val : Int} :\n  let idx := keep_order arr val\n  \u2200 i, i < idx \u2192 arr[i]! < val :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 5\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval keep_order [1, 2, 3, 4, 7] 0\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval keep_order [1, 1, 2, 2, 2] 2"
      }
    ]
  },
  "fvapps_004489.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def maximum? (l : List Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def filterWithIndex (l : List Int) (f : Nat \u2192 Int \u2192 Bool) : List Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def target_game (vals : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem target_game_nonneg (vals : List Int)\n  (h : vals \u2260 []) :\n  target_game vals \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval target_game [1, 2, 3, 4]\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval target_game [5, 5, 5, 5, 5]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval target_game [5, -2, -9, -4]"
      }
    ]
  },
  "fvapps_004491.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def group_groceries (input : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "constr",
        "string": "inductive Category where\n  | fruit : Category\n  | meat : Category\n  | vegetable : Category\n  | other : Category\nderiving BEq, Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "structure GroceryItem where\n  category : Category\n  name : String\nderiving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def isValidCategoryName (name : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def length4 (s : List \u03b1) : Prop := s.length = 4"
      },
      {
        "type": "constr",
        "string": "inductive isSorted : List String \u2192 Prop where\n  | nil : isSorted []\n  | single : (x : String) \u2192 isSorted [x]\n  | cons : (x y : String) \u2192 (rest : List String) \u2192\n          x <= y \u2192 isSorted (y::rest) \u2192 isSorted (x::y::rest)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem group_groceries_produces_four_lines (input : String) :\n  length4 ((group_groceries input).splitOn \"\\n\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem group_groceries_uses_expected_categories (input : String) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  lines[0]!.startsWith \"fruit:\" \u2227\n  lines[1]!.startsWith \"meat:\" \u2227\n  lines[2]!.startsWith \"other:\" \u2227\n  lines[3]!.startsWith \"vegetable:\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem group_groceries_items_sorted (input : String) (i : Nat) :\n  let lines := (group_groceries input).splitOn \"\\n\"\n  let items := (lines[i]!.splitOn \":\")[1]!.splitOn \",\"\n  items.length > 0 \u2192 isSorted items :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,meat_chicken,drink_juice\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_banana,vegetable_carrot,fruit_apple,canned_sardines,drink_juice,fruit_orange\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval group_groceries \"fruit_orange\""
      }
    ]
  },
  "fvapps_004496.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sumOfDivs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def kind (n : Nat) (sum : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def deficientlyAbundantAmicableNumbers (n1 n2 : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The kind function only outputs \"abundant\", \"deficient\", or \"perfect\" -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem kind_outputs {n : Nat} (h : n > 0) :\n  let sum := sumOfDivs n\n  let k := kind n sum\n  (k = \"abundant\" \u2228 k = \"deficient\" \u2228 k = \"perfect\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Properties of deficiently abundant amicable numbers output -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem deficientlyabundant_properties {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result := deficientlyAbundantAmicableNumbers n1 n2\n  let sum1 := sumOfDivs n1\n  let sum2 := sumOfDivs n2\n  let is_amicable := sum1 = n2 \u2227 sum2 = n1 \u2227 n1 \u2260 n2\n  result.contains 'n' = !is_amicable :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Symmetric property of amicable numbers -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem symmetric_property {n1 n2 : Nat} (h1 : n1 > 0) (h2 : n2 > 0) :\n  let result1 := deficientlyAbundantAmicableNumbers n1 n2\n  let result2 := deficientlyAbundantAmicableNumbers n2 n1\n  result1.contains 'n' = result2.contains 'n' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004497.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def String.count (s : String) (c : Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.toCharArray (s : String) : Array Char :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.fromCharArray (arr : Array Char) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def has_subpattern (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_is_substring (s : String) (h : s.length > 0) :\n  let result := has_subpattern s\n  -- Result length less than input length\n  result.length \u2264 s.length \u2227\n  -- Result chars are sorted\n  (\u2200 i j, i < j \u2192 i < result.length \u2192 j < result.length \u2192\n    result.toCharArray[i]! \u2264 result.toCharArray[j]!) \u2227\n  -- Result chars come from input\n  (\u2200 c, c \u2208 result.toCharArray.toList \u2192 c \u2208 s.toCharArray.toList) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem output_pattern_reconstruction (s : String) (h : s.length > 0) :\n  let pattern := has_subpattern s\n  let counts_s := s.toCharArray.toList.map (fun c => (c, s.count c))\n  let counts_p := pattern.toCharArray.toList.map (fun c => (c, pattern.count c))\n  pattern.length > 0 \u2192\n  \u2203 ratio : Nat, \u2200 (s_c p_c : Char) (s_count p_count : Nat),\n    (s_c, s_count) \u2208 counts_s \u2192\n    (p_c, p_count) \u2208 counts_p \u2192\n    s_count = p_count * ratio :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem idempotent (s : String) (h : s.length > 0) :\n  has_subpattern s = has_subpattern (has_subpattern s) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_004501.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def find_vowel_substrings (s : String) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_vowel_substrings_valid_input {s : String}\n  (h : \u2203 pre mid post : String,\n    (\u2200 c, c \u2208 pre.data \u2192 !isVowel c) \u2227\n    (\u2200 c, c \u2208 mid.data \u2192 isVowel c) \u2227\n    (\u2200 c, c \u2208 post.data \u2192 !isVowel c) \u2227\n    mid.length \u2265 2 \u2227\n    s = pre ++ mid ++ post) :\n  \u2203 result : List String,\n    find_vowel_substrings s = result \u2227\n    result \u2260 [\"-1\"] \u2227\n    \u2200 substr \u2208 result,\n      substr.length \u2265 2 \u2227\n      \u2200 c, c \u2208 substr.data \u2192 isVowel c :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_vowel_substrings_invalid_input {s : String}\n  (h : \u2200 c, c \u2208 s.data \u2192 !isVowel c) :\n  find_vowel_substrings s = [\"-1\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_vowel_substrings_general {s : String} :\n  let result := find_vowel_substrings s\n  result = [\"-1\"] \u2228\n  (\u2200 substr \u2208 result,\n    substr.length \u2265 2 \u2227\n    \u2200 c, c \u2208 substr.data \u2192 isVowel c) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004502.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := List (List Bool)\n\ndef solveMatrix (m n a b : Nat) : Option Matrix :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def matrixToStr (m : Matrix) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_valid_2_2_1_1 :\n  \u2203 (result : Matrix),\n    solveMatrix 2 2 1 1 = some result \u2227\n    matrixToStr result = \"10\\n01\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_valid_2_2_2_2 :\n  \u2203 (result : Matrix),\n    solveMatrix 2 2 2 2 = some result \u2227\n    matrixToStr result = \"11\\n11\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_valid_3_6_2_1 :\n  \u2203 (result : Matrix),\n    solveMatrix 3 6 2 1 = some result \u2227\n    matrixToStr result = \"110000\\n001100\\n000011\"\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_impossible_2_2_2_1 :\n  solveMatrix 2 2 2 1 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_impossible_3_3_3_1 :\n  solveMatrix 3 3 3 1 = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem solve_matrix_impossible_greater_dimensions :\n  (\u2200 m n : Nat, m > 0 \u2192 n > 0 \u2192\n    (\u2200 a b : Nat, (a > m \u2228 b > n) \u2192\n      solveMatrix m n a b = none)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result\n\n/-\ninfo: expected\n-/\n#guard_msgs in\n#eval matrix_to_str result"
      }
    ]
  },
  "fvapps_004507.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.sumLength (l: List (List \u03b1)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => 0\n  | x::xs => x.length + xs.sumLength"
      },
      {
        "type": "sig",
        "string": "def String.hasPattern (s pattern: String) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def String.hasSuffix (s suffix: String) : Prop :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def nkotb_vs_homie (reqs: List (List String)) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem response_count (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: \u2200 cat \u2208 reqs, cat.length > 0 \u2227 cat.length \u2264 5)\n  : (nkotb_vs_homie reqs).length = (reqs.sumLength + 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem responses_end_with_homie (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: \u2200 cat \u2208 reqs, cat.length > 0 \u2227 cat.length \u2264 5)\n  (result := nkotb_vs_homie reqs)\n  (i: Fin result.length)\n  (h3: i.val < reqs.sumLength)\n  : (result.get \u27e8i.val, i.isLt\u27e9).hasSuffix \"! Homie dont play that!\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem summary_contains_sections (reqs: List (List String))\n  (h1: reqs.length = 5)\n  (h2: \u2200 cat \u2208 reqs, cat.length > 0 \u2227 cat.length \u2264 5)\n  (result := nkotb_vs_homie reqs)\n  (h3: reqs.sumLength < result.length)\n  : let summary := result.get \u27e8reqs.sumLength, h3\u27e9\n    summary.hasPattern \"monitoring objections\" \u2227\n    summary.hasPattern \"automation\" \u2227\n    summary.hasPattern \"deployment pipeline\" \u2227\n    summary.hasPattern \"cloud\" \u2227\n    summary.hasPattern \"microservices\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_categories_response\n  (empty_reqs: List (List String))\n  (h1: empty_reqs = [[], [], [], [], []])\n  : nkotb_vs_homie empty_reqs = [\"0 monitoring objections, 0 automation, 0 deployment pipeline, 0 cloud, and 0 microservices.\"] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval nkotb_vs_homie [[\"We need Monitoring now!\"], [\"We need Automation now!\"], [\"We need Deployment now!\"], [\"We need Cloud now!\"], [\"We need Microservices now!\"]]"
      }
    ]
  },
  "fvapps_004519.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def length_sup_u_k (n : Nat) (k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def comp (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def u1 : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_sup_u_k_bounds (n k : Nat) (h : n > 0) :\n  0 \u2264 length_sup_u_k n k \u2227 length_sup_u_k n k \u2264 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem comp_bounds (n : Nat) (h : n > 1) :\n  0 \u2264 comp n \u2227 comp n \u2264 n - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem comp_deterministic (n : Nat) :\n  comp n = comp n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval length_sup_u_k 23 12\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval length_sup_u_k 50 10\n\n/-\ninfo: 304\n-/\n#guard_msgs in\n#eval length_sup_u_k 500 100\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval comp 23\n\n/-\ninfo: 22\n-/\n#guard_msgs in\n#eval comp 100\n\n/-\ninfo: 63\n-/\n#guard_msgs in\n#eval comp 200"
      }
    ]
  },
  "fvapps_004522.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def maxLen : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_squares (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def square_pi (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem square_pi_monotone {n\u2081 n\u2082 : Nat} (h : n\u2081 \u2264 n\u2082) (h2 : n\u2082 \u2264 maxLen) :\n  square_pi n\u2081 \u2264 square_pi n\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval square_pi 1\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval square_pi 3\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval square_pi 5"
      }
    ]
  },
  "fvapps_004524.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def x : List Int \u2192 Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def add : Int \u2192 Int \u2192 Int := fun a b => a + b"
      },
      {
        "type": "sig",
        "string": "def sub : Int \u2192 Int \u2192 Int := fun a b => a - b"
      },
      {
        "type": "sig",
        "string": "def mul : Int \u2192 Int \u2192 Int := fun a b => a * b"
      },
      {
        "type": "sig",
        "string": "def div : Int \u2192 Int \u2192 Int := fun a b => a / b"
      },
      {
        "type": "constr",
        "string": "axiom placeholder_identity (args : List Int) (h : args.length > 0) :\n  x args = args.head!"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_binary_ops_forward (a b : Int) :\n  (add (x [a]) b) = add a b \u2227\n  (sub (x [a]) b) = sub a b \u2227\n  (mul (x [a]) b) = mul a b"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_binary_ops_reverse (a b : Int) :\n  add b (x [a]) = add b a \u2227\n  sub b (x [a]) = sub b a \u2227\n  mul b (x [a]) = mul b a"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_binary_ops_div (a b : Int) :\n  b \u2260 0 \u2192 div (x [a]) b = div a b"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_binary_ops_div_reverse (a b : Int) :\n  a \u2260 0 \u2192 div b (x [a]) = div b a"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_chaining (args : List Int) (h : args.length > 1) :\n  add (x [args.head!]) (x [args.tail.head!]) = add args.head! args.tail.head! \u2227\n  mul (x [args.head!]) (x [args.tail.head!]) = mul args.head! args.tail.head! \u2227\n  add (x [args.head!]) (mul 2 (x [args.tail.head!])) = add args.head! (mul 2 args.tail.head!)"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom placeholder_constant_folding (a : Int) :\n  add (add 2 3) (x [a]) = add 5 a \u2227\n  add (mul 2 3) (x [a]) = add 6 a\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_004527.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def poly_derivative (p : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def scaleList (k : Int) (xs : List Int) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def zeroList (n : Nat) : List Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem derivative_length {p : List Int} (h : p \u2260 []) :\n  (poly_derivative p).length = p.length - 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem derivative_constant {p : List Int} (h : p.length = 1) :\n  poly_derivative p = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem derivative_linear {p : List Int} (h : p.length \u2265 2) :\n  (poly_derivative p).get! 0 = p.get! 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [2]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2]\n\n/-\ninfo: [1, 6]\n-/\n#guard_msgs in\n#eval poly_derivative [9, 1, 3]\n\n/-\ninfo: [2, 6, 12]\n-/\n#guard_msgs in\n#eval poly_derivative [1, 2, 3, 4]"
      }
    ]
  },
  "fvapps_004529.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def GradeString : Type := String\nderiving Inhabited\n\ndef grade_val (v : GradeString) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sort_grades (grades : List GradeString) : List GradeString :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_preserves_size (grades : List GradeString) :\n  List.length (sort_grades grades) = List.length grades :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_preserves_elements (grades : List GradeString) (g : GradeString) :\n  g \u2208 grades \u2194 g \u2208 sort_grades grades :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_is_ordered (grades : List GradeString) :\n  \u2200 i : Nat, i + 1 < List.length (sort_grades grades) \u2192\n  grade_val (List.get! (sort_grades grades) i) \u2264\n  grade_val (List.get! (sort_grades grades) (i + 1)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_list_sort :\n  sort_grades [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_idempotent (grades : List GradeString) :\n  sort_grades (sort_grades grades) = sort_grades grades :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval sort_grades []\n\n/-\ninfo: ['VB', 'V0', 'V1', 'V3']\n-/\n#guard_msgs in\n#eval sort_grades [\"V1\", \"VB\", \"V3\", \"V0\"]\n\n/-\ninfo: ['V0+', 'V1', 'V2']\n-/\n#guard_msgs in\n#eval sort_grades [\"V0+\", \"V2\", \"V1\"]"
      }
    ]
  },
  "fvapps_004534.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digitSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def countComfortablePairs (l r : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem window_size (start : Nat) (window : Nat)\n  (h1 : start \u2265 1) (h2 : start \u2264 100) (h3 : window \u2265 0) (h4 : window \u2264 10) :\n  let result := countComfortablePairs start (start + window)\n  result \u2265 0 \u2227 result \u2264 (window + 1) * window / 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem single_number (n : Nat) (h1 : n \u2265 1) (h2 : n \u2264 1000) :\n  countComfortablePairs n n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem pairs_symmetry (n : Nat) (h1 : n \u2265 1) (h2 : n \u2264 100) :\n  let allPairs := countComfortablePairs 1 n\n  allPairs \u2265 0 \u2227 allPairs \u2264 n * 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem small_ranges :\n  countComfortablePairs 1 1 = 0 \u2227\n  countComfortablePairs 1 2 \u2265 0 \u2227\n  countComfortablePairs 9 10 \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 10 12\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 1 9\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval count_comfortable_pairs 13 13"
      }
    ]
  },
  "fvapps_004535.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count (s : String) (pattern : String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def SENTENCE : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def SYLLABLE : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def flesch_kincaid (text : String) : Float :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem flesch_kincaid_result_is_float (text : String) (h : text.length > 0) :\n  \u2203 (f : Float), flesch_kincaid text = f :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flesch_kincaid_count_properties (text : String)\n  (h\u2081 : text.length > 0)\n  (h\u2082 : count text SENTENCE = 1) :\n  let words := count text \" \" + 1\n  let sentences := count text SENTENCE\n  let syllables := count text SYLLABLE\n  words \u2265 1 \u2227\n  sentences = 1 \u2227\n  syllables \u2265 0 \u2227\n  syllables \u2264 text.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem syllable_counting_vowels_only (text : String)\n  (h\u2081 : text.length > 0)\n  (h\u2082 : \u2200 c \u2208 text.data, c \u2208 ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']) :\n  let syllables := count text SYLLABLE\n  syllables \u2265 1 \u2227 syllables \u2264 text.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem flesch_kincaid_is_finite (words : List String)\n  (h : words.length > 0)\n  (h\u2082 : \u2200 w \u2208 words, w.length > 0)\n  (h\u2083 : \u2200 w \u2208 words, \u2200 c \u2208 w.data, c.isLower) :\n  let sentence := String.intercalate \" \" words ++ \".\"\n  \u2203 (result : Float), flesch_kincaid sentence = result :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3.67\n-/\n#guard_msgs in\n#eval flesch_kincaid \"The turtle is leaving.\"\n\n/-\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Hi there.\"\n\n/-\ninfo: 2.89\n-/\n#guard_msgs in\n#eval flesch_kincaid \"Go home.\""
      }
    ]
  },
  "fvapps_004553.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_num (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def countDigits (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def natToString (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_num_zero : get_num 0 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval get_num 123\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval get_num 6609\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval get_num 8888"
      }
    ]
  },
  "fvapps_004555.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_very_even_number (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def digitSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def singleDigitSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem very_even_single_digit (n : Nat) :\n  n < 10 \u2192 is_very_even_number n = (n % 2 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem very_even_digit_sum (n : Nat) :\n  is_very_even_number n = (singleDigitSum n % 2 = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_very_even_number 88\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 222\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_very_even_number 841"
      }
    ]
  },
  "fvapps_004557.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def spread {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (args : List \u03b1) : \u03b2 :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => h + sum t"
      },
      {
        "type": "cond",
        "string": "theorem spread_matches_direct_call {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n  spread f [x] = f x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spread_list_sum (nums : List Nat) :\n  spread (fun xs => sum xs) [nums] = sum nums :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spread_concat_strings (strings : List String) :\n  spread (fun args => String.join args) [strings] = String.join strings :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spread_empty_unit (f : Unit \u2192 Option \u03b1) :\n  spread f [] = f () :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spread_single_identity :\n  spread (fun x:Nat => x) [42] = 42 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem spread_too_many_args_fails :\n  \u00ac(\u2203 (res:Nat), spread (fun x:Nat => x) [1, 2] = res) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval spread lambda x, y: x + y [2, 3]\n\n/-\ninfo: 'abc'\n-/\n#guard_msgs in\n#eval spread lambda x, y, z: x + y + z [\"a\", \"b\", \"c\"]\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval spread lambda: 42 []"
      }
    ]
  },
  "fvapps_004562.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def VALID_COLORS := [\"Red\", \"Blue\", \"Green\", \"Orange\", \"Purple\", \"Yellow\"]"
      },
      {
        "type": "constr",
        "string": "structure Game where\n  solution : List String := []\n  tries : Nat := 0\n  deriving Repr"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def Game.check (g : Game) (guess : List String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def matches_result (code guess result : List String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def mastermind (g : Game) : Unit :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem mastermind_always_solves {solution : List String}\n  (h1 : solution.length = 4)\n  (h2 : \u2200 x \u2208 solution, x \u2208 VALID_COLORS) :\n  \u2200 g : Game, g.solution = solution \u2192 g.tries \u2264 60 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_result_symmetric {code guess : List String}\n  (h1 : code.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : \u2200 x \u2208 code, x \u2208 VALID_COLORS)\n  (h4 : \u2200 x \u2208 guess, x \u2208 VALID_COLORS) :\n  matches_result code guess (List.replicate 4 \"Black\") =\n  matches_result guess code (List.replicate 4 \"Black\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem matches_result_self {guess : List String}\n  (h1 : guess.length = 4)\n  (h2 : \u2200 x \u2208 guess, x \u2208 VALID_COLORS) :\n  matches_result guess guess (List.replicate 4 \"Black\") = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem game_check_invalid_inputs (g : Game) :\n  (\u2200 guess : List String, guess.length \u2260 4 \u2192 g.check guess = []) \u2227\n  (\u2200 guess : List String, (\u2203 x \u2208 guess, x \u2209 VALID_COLORS) \u2192 g.check guess = []) \u2227\n  (g.tries \u2265 60 \u2192 \u2200 guess : List String, g.check guess = []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem check_result_length {solution guess : List String}\n  (h1 : solution.length = 4)\n  (h2 : guess.length = 4)\n  (h3 : \u2200 x \u2208 solution, x \u2208 VALID_COLORS)\n  (h4 : \u2200 x \u2208 guess, x \u2208 VALID_COLORS)\n  (g : Game)\n  (h5 : g.solution = solution) :\n  let result := g.check guess\n  (result.length \u2264 4 \u2227 \u2200 x \u2208 result, x = \"Black\" \u2228 x = \"White\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004571.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def List.Sorted {\u03b1 : Type} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (l : List \u03b1) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i j, i < j \u2192 j < l.length \u2192 r (l.get \u27e8i, sorry\u27e9) (l.get \u27e8j, sorry\u27e9)"
      },
      {
        "type": "constr",
        "string": "structure Result where\n  i : Nat\n  n : Int"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def all_non_consecutive (arr : List Int) : List Result :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem consecutive_not_in_result (arr : List Int) (h : arr.length \u2265 2) :\n  \u2200 i, i < arr.length - 1 \u2192\n  arr.get \u27e8i+1, sorry\u27e9 = arr.get \u27e8i, sorry\u27e9 + 1 \u2192\n  \u00ac\u2203 r \u2208 all_non_consecutive arr, r.i = i + 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem non_consecutive_in_result (arr : List Int) (h : arr.length \u2265 2) :\n  \u2200 i, i < arr.length - 1 \u2192\n  arr.get \u27e8i+1, sorry\u27e9 \u2260 arr.get \u27e8i, sorry\u27e9 + 1 \u2192\n  \u2203 r \u2208 all_non_consecutive arr, r.i = i + 1 \u2227 r.n = arr.get \u27e8i+1, sorry\u27e9 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem indices_ascending (arr : List Int) (h : arr.length \u2265 2) :\n  let result := all_non_consecutive arr\n  result.length > 1 \u2192\n  List.Sorted (\u00b7\u2264\u00b7) (result.map Result.i) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_indices (arr : List Int) (h : arr.length \u2265 2) :\n  \u2200 r \u2208 all_non_consecutive arr,\n  1 \u2264 r.i \u2227 r.i < arr.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval all_non_consecutive [1, 2, 3, 4, 6, 7, 8, 15, 16]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval all_non_consecutive [1, 2, 3, 4, 5]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval all_non_consecutive [-3, -2, -1, 1, 2, 4, 5]"
      }
    ]
  },
  "fvapps_004572.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def is_prime : Nat \u2192 Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse : Nat \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def backwards_prime : Nat \u2192 Nat \u2192 List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem backwards_prime_empty_range :\n  backwards_prime 1 0 = [] \u2227\n  backwards_prime 0 1 = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [13, 17, 31, 37, 71, 73, 79, 97]\n-/\n#guard_msgs in\n#eval backwards_prime 2 100\n\n/-\ninfo: [9923, 9931, 9941, 9967]\n-/\n#guard_msgs in\n#eval backwards_prime 9900 10000\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval backwards_prime 501 599"
      }
    ]
  },
  "fvapps_004573.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def okkOokOo (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- The function correctly encodes basic ASCII characters -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem basic_ascii_encoding (input : String) :\n  okkOokOo \"Ok, Ook, Ooo!\" = \"H\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The function handles multiple characters correctly -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem multiple_char_encoding :\n  okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\" = \"He\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The length of output matches the number of separators plus one -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem length_matches_separators :\n  String.length (okkOokOo \"Ok, Ook, Ooo?Okk, Ook, Ok\") = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- The output only contains printable ASCII characters -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem output_is_printable_ascii (s : String) (c : Char) :\n  c \u2208 (okkOokOo s).data \u2192\n  32 \u2264 c.toNat \u2227 c.toNat \u2264 126 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 'H'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo!\"\n\n/-\ninfo: 'Hello'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ook, Ooo?  Okk, Ook, Ok?  Okk, Okk, Oo?  Okk, Okk, Oo?  Okk, Okkkk!\"\n\n/-\ninfo: 'World!'\n-/\n#guard_msgs in\n#eval okkOokOo \"Ok, Ok, Okkk?  Okk, Okkkk?  Okkk, Ook, O?  Okk, Okk, Oo?  Okk, Ook, Oo?  Ook, Ooook!\""
      }
    ]
  },
  "fvapps_004576.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def new_avg (donations : List Int) (targetAvg : Int) : Option Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def list_sum (l : List Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem new_avg_type_and_positive (donations : List Int) (targetAvg : Int) :\n  donations \u2260 [] \u2192\n  \u2200 r : Int, new_avg donations targetAvg = some r \u2192\n  r > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem new_avg_achieves_target (donations : List Int) (targetAvg : Int) :\n  donations \u2260 [] \u2192\n  \u2200 r : Int, new_avg donations targetAvg = some r \u2192\n  ((list_sum donations + r) / (donations.length + 1) - targetAvg).natAbs < 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem new_avg_none_when_negative (donations : List Int) (targetAvg : Int) :\n  donations \u2260 [] \u2192\n  (donations.length + 1) * targetAvg - list_sum donations \u2264 0 \u2192\n  new_avg donations targetAvg = none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem new_avg_positive_large_target (donations : List Int) (maxDonation : Int) :\n  donations \u2260 [] \u2192\n  (\u2200 d \u2208 donations, d \u2265 0 \u2227 d \u2264 maxDonation) \u2192\n  let targetAvg := maxDonation + 100\n  \u2200 r : Int, new_avg donations targetAvg = some r \u2192\n  r > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 149\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 30\n\n/-\ninfo: 645\n-/\n#guard_msgs in\n#eval new_avg [14, 30, 5, 7, 9, 11, 15] 92"
      }
    ]
  },
  "fvapps_004577.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def f : List (List Int) \u2192 List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def g : List (List Int) \u2192 List (List Int) :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def perform : String \u2192 String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem f_g_inverse {matrix : List (List Int)} (h1 : matrix.length > 0)\n  (h2 : \u2200 row \u2208 matrix, row.length > 0)\n  (h3 : \u2200 row \u2208 matrix, row.length = matrix.head!.length) :\n  f (g matrix) = matrix :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perform_maintains_valid_colors (sequence : String) :\n  \u2200 c, c.toString \u2208 (perform sequence).data.map toString \u2192\n  c = 'y' \u2228 c = 'g' \u2228 c = 'b' \u2228 c = 'o' \u2228 c = 'r' \u2228 c = 'w' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perform_F_move :\n  perform \"F\" = \"yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perform_F2_move :\n  perform \"F2\" = \"yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem perform_F_prime_move :\n  perform \"F'\" = \"yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'yyyyybbbbbbrbbrbbrrrrrrrrrrgggggggggooooooooowwwwwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\n\n/-\ninfo: 'yyyyyywwwbbgbbgbbgrrrrrrrrrbggbggbggoooooooooyyywwwwww'\n-/\n#guard_msgs in\n#eval perform \"F2\"\n\n/-\ninfo: 'yyyyyooobbwbbwbbwrrrrrrrrrwggwggwggooooooooobbbrwwwww'\n-/\n#guard_msgs in\n#eval perform \"F\"\""
      }
    ]
  },
  "fvapps_004587.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sort_ranks (ranks: List String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_version (s: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def loose_version_le (v1 v2: String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_ranks_maintains_elements (ranks: List String)\n  (h: \u2200 x \u2208 ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  \u2200 x, (x \u2208 ranks \u2194 x \u2208 sorted) \u2227\n  sorted.length = ranks.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_ranks_ordering (ranks: List String)\n  (h1: ranks.length \u2265 2)\n  (h2: \u2200 x \u2208 ranks, is_valid_version x) :\n  let sorted := sort_ranks ranks\n  \u2200 (i: Nat) (h: i + 1 < sorted.length),\n    loose_version_le (sorted[i]'(Nat.lt_of_lt_of_le (Nat.lt_succ_self i) (Nat.le_of_lt h)))\n                    (sorted[i+1]'h) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sort_ranks_idempotent (ranks: List String)\n  (h: \u2200 x \u2208 ranks, is_valid_version x) :\n  sort_ranks (sort_ranks ranks) = sort_ranks ranks :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval sort_ranks [\"2\", \"1\", \"1.1\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval sort_ranks [\"3.1\", \"1\", \"1.1\", \"2\", \"3\", \"1.2\", \"3.2\", \"1.2.1\", \"3.1.1\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval sort_ranks [\"3\", \"2\", \"1\"]"
      }
    ]
  },
  "fvapps_004589.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def split (s : String) (c : Char) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def vert_mirror (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def hor_mirror (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def oper (f : String \u2192 String) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def reverse_string (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def all_lines_reversed (orig result : List String) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i, i < orig.length \u2192 result.get! i = reverse_string (orig.get! i)"
      },
      {
        "type": "sig",
        "string": "def line_lengths_preserved (orig result : List String) : Prop :="
      },
      {
        "type": "impl",
        "string": "  \u2200 i, i < orig.length \u2192 (orig.get! i).length = (result.get! i).length"
      },
      {
        "type": "constr",
        "string": "axiom vert_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper vert_mirror s) '\\n'\n  lines.length = result_lines.length \u2227\n  all_lines_reversed lines result_lines \u2227\n  line_lengths_preserved lines result_lines"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom hor_mirror_properties (s : String) :\n  let lines := split s '\\n'\n  let result_lines := split (oper hor_mirror s) '\\n'\n  lines.length = result_lines.length \u2227\n  result_lines = List.reverse lines"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom vert_mirror_involution (s : String) :\n  oper vert_mirror (oper vert_mirror s) = s"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "constr",
        "string": "axiom hor_mirror_involution (s : String) :\n  oper hor_mirror (oper hor_mirror s) = s\n\n-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'dcba\\nhgfe\\nlkji\\nponm'\n-/\n#guard_msgs in\n#eval oper vert_mirror \"abcd\\nefgh\\nijkl\\nmnop\"\n\n/-\ninfo: 'mnop\\nijkl\\nefgh\\nabcd'\n-/\n#guard_msgs in\n#eval oper hor_mirror s1\n\n/-\ninfo: 'ba\\ndc'\n-/\n#guard_msgs in\n#eval oper vert_mirror \"ab\\ncd\"\n\n/-\ninfo: 'cd\\nab'\n-/\n#guard_msgs in\n#eval oper hor_mirror s2"
      }
    ]
  },
  "fvapps_004592.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def john (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def ann (n : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_john (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_ann (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequences_start_correctly {n : Nat} (h : n > 0) :\n  (john n).get \u27e80, sorry\u27e9 = 0 \u2227 (ann n).get \u27e80, sorry\u27e9 = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_lengths {n : Nat} (h : n > 0) :\n  (john n).length = n \u2227 (ann n).length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequences_nonnegative {n : Nat} (h : n > 0) :\n  (\u2200 x \u2208 john n, x \u2265 0) \u2227 (\u2200 x \u2208 ann n, x \u2265 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_functions_match {n : Nat} (h : n > 0) :\n  sum_john n = ((john n).foldl (\u00b7 + \u00b7) 0) \u2227\n  sum_ann n = ((ann n).foldl (\u00b7 + \u00b7) 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sequence_relationship {n : Nat} (h : n > 0) :\n  \u2200 i : Nat, i < n \u2192 i > 0 \u2192\n    ((john n).get \u27e8i, sorry\u27e9 = i - (ann n).get \u27e8(john n).get \u27e8i-1, sorry\u27e9, sorry\u27e9) \u2227\n    ((ann n).get \u27e8i, sorry\u27e9 = i - (john n).get \u27e8(ann n).get \u27e8i-1, sorry\u27e9, sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]\n-/\n#guard_msgs in\n#eval john 11\n\n/-\ninfo: [1, 1, 2, 2, 3, 3]\n-/\n#guard_msgs in\n#eval ann 6\n\n/-\ninfo: 1720\n-/\n#guard_msgs in\n#eval sum_john 75\n\n/-\ninfo: 6930\n-/\n#guard_msgs in\n#eval sum_ann 150"
      }
    ]
  },
  "fvapps_004595.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def get_number_of_squares (n : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sum_squares (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def next_square (n : Nat) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem known_sequence_values :\n  (get_number_of_squares 1 = 0) \u2227\n  (get_number_of_squares 2 = 1) \u2227\n  (get_number_of_squares 6 = 2) \u2227\n  (get_number_of_squares 15 = 3) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_number_of_squares 6\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval get_number_of_squares 15\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval get_number_of_squares 100"
      }
    ]
  },
  "fvapps_004596.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def circularly_sorted (xs : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isSorted (xs : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sorted_is_circular {xs : List Int} (h : xs.length > 0) :\n  isSorted xs \u2192 circularly_sorted xs = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem rotated_sorted_is_circular {xs : List Int} (h : xs.length > 0) (distinct : List.Nodup xs) :\n  \u2200 i, i < xs.length \u2192 circularly_sorted (List.drop i xs ++ List.take i xs) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem singleton_is_circular {x : Int} :\n  circularly_sorted [x] = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_raises {xs : List Int} (h : xs.length = 0) :\n  circularly_sorted xs = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem unsorted_not_circular {xs : List Int} (h : xs.length > 1)\n  (not_sorted : \u2200 i, i < xs.length \u2192 \u00ac(isSorted (List.drop i xs ++ List.take i xs))) :\n  circularly_sorted xs = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [2, 3, 4, 5, 0, 1]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval circularly_sorted [1, 2, 3, 4, 5]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval circularly_sorted [4, 1, 2, 5]"
      }
    ]
  },
  "fvapps_004612.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def count_perms (matrix: List (List Nat)) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def factorial (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n"
      },
      {
        "type": "cond",
        "string": "theorem count_perms_single_element :\n  count_perms [[1]] = 1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_perms_dimensions_preserved {m n: Nat} (matrix: List (List Nat))\n  (h1: matrix.length = m)\n  (h2: \u2200 row \u2208 matrix, row.length = n) :\n  let result := count_perms matrix\n  -- Result is a natural number\n  0 < result \u2227\n  -- Result is bounded by factorial of total elements\n  result \u2264 factorial (m * n) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_perms_all_same {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.replicate m (List.replicate n 1)\n  count_perms matrix = 1 := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem count_perms_all_different {m n: Nat}\n  (h1: 0 < m) (h2: 0 < n) :\n  let matrix := List.map (fun i =>\n    List.map (fun j => i * n + j + 1) (List.range n)\n  ) (List.range m)\n  count_perms matrix = factorial (m * n) := by"
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 360\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [3, 4, 5]]\n\n/-\ninfo: 1260\n-/\n#guard_msgs in\n#eval count_perms [[1, 1, 1], [2, 2, 3], [3, 3, 3]]\n\n/-\ninfo: 362880\n-/\n#guard_msgs in\n#eval count_perms [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
      }
    ]
  },
  "fvapps_004618.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def days_until (date month year : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isValidDate (date month year : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def dateCompare (d1 m1 y1 d2 m2 y2 : Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  if y1 \u2260 y2 then y1 > y2\n  else if m1 \u2260 m2 then m1 > m2\n  else d1 > d2"
      },
      {
        "type": "sig",
        "string": "def dateDiffDays (d1 m1 y1 d2 m2 y2 : Int) : Int :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem days_until_is_int {date month year : Int}\n  (h : isValidDate date month year = true) :\n  \u2203 n : Int, days_until date month year = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem days_until_target_date {date month year : Int}\n  (h1 : date = 24)\n  (h2 : month = 3)\n  (h3 : year = 2437) :\n  days_until date month year = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem days_until_future_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare date month year 24 3 2437 = true) :\n  days_until date month year < 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem days_until_past_dates {date month year : Int}\n  (h1 : isValidDate date month year = true)\n  (h2 : dateCompare 24 3 2437 date month year = true) :\n  days_until date month year > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem days_until_symmetry {date month year : Int}\n  (h : isValidDate date month year = true) :\n  days_until date month year = dateDiffDays year month date 2437 3 24 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval days_until 21 3 2437\n\n/-\ninfo: 365\n-/\n#guard_msgs in\n#eval days_until 24 3 2436\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval days_until 24 2 2437"
      }
    ]
  },
  "fvapps_004621.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_difference (a b : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def list_prod (l : List Nat) : Nat := sorry\n\ndef abs (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  if n \u2265 0 then n else 0"
      },
      {
        "type": "cond",
        "string": "theorem find_difference_non_negative (a b : List Nat) (h\u2081 : a \u2260 []) (h\u2082 : b \u2260 []) :\n  find_difference a b \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_difference_symmetry (a b : List Nat) (h\u2081 : a \u2260 []) (h\u2082 : b \u2260 []) :\n  find_difference a b = find_difference b a :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem find_difference_identity (a : List Nat) (h : a \u2260 []) :\n  find_difference a a = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval find_difference [2, 2, 3] [5, 4, 1]\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval find_difference [3, 2, 5] [1, 4, 4]\n\n/-\ninfo: 106\n-/\n#guard_msgs in\n#eval find_difference [9, 7, 2] [5, 2, 2]"
      }
    ]
  },
  "fvapps_004627.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def binary_gcd (x y : Int) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def popCount (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_gcd_matches_gcd (x y : Int) :\n  binary_gcd x y = popCount (Int.gcd x y) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_gcd_symmetric_same (n : Int) :\n  binary_gcd n n = binary_gcd n (-n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_gcd_symmetric_zero (n : Int) :\n  binary_gcd n 0 = binary_gcd 0 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem binary_gcd_positive_bounds (x y : Int) (hx : x > 0) (hy : y > 0) :\n  let result := binary_gcd x y\n  0 \u2264 result \u2227 result \u2264 max x.natAbs.log2 y.natAbs.log2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval binary_gcd 300 45\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval binary_gcd 0 0\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval binary_gcd -8 12"
      }
    ]
  },
  "fvapps_004636.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def toString (n : Int) (d : Int) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def toDecimal (n : Int) (d : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def intToFloat (i : Int) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def stringToFloat (s : String) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sign_property (n d : Int) (h : d \u2260 0) :\n  let s := toString n d\n  (n * d < 0 \u2192 s.startsWith \"-\") \u2227\n  (n * d > 0 \u2192 \u00acs.startsWith \"-\") :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem format_property (n d : Int) (h : d \u2260 0) :\n  let s := toString n d\n  let parts := (s.dropWhile (\u00b7=='-')).splitOn \" \"\n  match parts with\n  | [p] =>\n    if p.any (\u00b7=='/') then\n      let nums := p.splitOn \"/\"\n      nums.length = 2 \u2227\n      nums[0]!.all Char.isDigit \u2227\n      nums[1]!.all Char.isDigit\n    else\n      p.all Char.isDigit\n  | [whole, frac] =>\n    whole.all Char.isDigit \u2227\n    let fracParts := frac.splitOn \"/\"\n    fracParts.length = 2 \u2227\n    fracParts[0]!.all Char.isDigit \u2227\n    fracParts[1]!.all Char.isDigit \u2227\n    fracParts[0]!.toNat! < fracParts[1]!.toNat!\n  | _ => False :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem decimal_conversion (n d : Int) (h : d \u2260 0) :\n  toDecimal n d = (intToFloat n / intToFloat d) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem string_matches_value (n d : Int) (h : d \u2260 0) :\n  let s := toString n d\n  let val :=\n    if s.any (\u00b7==' ') then\n      let parts := (s.dropWhile (\u00b7=='-')).splitOn \" \"\n      let whole := intToFloat parts[0]!.toInt!\n      let fracParts := (parts[1]!.splitOn \"/\")\n      let num := intToFloat fracParts[0]!.toInt!\n      let den := intToFloat fracParts[1]!.toInt!\n      whole + (num / den)\n    else if s.any (\u00b7=='/') then\n      let parts := (s.dropWhile (\u00b7=='-')).splitOn \"/\"\n      (intToFloat parts[0]!.toInt!) / (intToFloat parts[1]!.toInt!)\n    else\n      stringToFloat s\n  toDecimal n d = (if s.startsWith \"-\" then -val else val) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_004638.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def html_end_tag_by_start_tag (start_tag: String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tag_char (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_tag_first_char (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_attr_name_char (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid_attr_value_char (c: Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem html_end_tag_starts_with_close : \u2200 (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).startsWith \"</\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem html_end_tag_ends_with_angle : \u2200 (start_tag : String),\n  (html_end_tag_by_start_tag start_tag).endsWith \">\" = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem html_end_tag_matches_start : \u2200 (start_tag : String),\n  let start_name := (start_tag.drop 1).splitOn \" \" |>.head!.dropRight 1\n  let end_name := (html_end_tag_by_start_tag start_tag).drop 2 |>.dropRight 1\n  start_name = end_name :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem html_end_tag_no_attributes : \u2200 (start_tag : String),\n  \u00ac(html_end_tag_by_start_tag start_tag).contains ' ' :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '</i>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<i>\"\n\n/-\ninfo: '</button>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<button type=\"button\" disabled>\"\n\n/-\ninfo: '</div>'\n-/\n#guard_msgs in\n#eval html_end_tag_by_start_tag \"<div class=\"main\" id=\"content\" style=\"width:100px\">\""
      }
    ]
  },
  "fvapps_004644.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def min_special_mult (numbers : List Int) : Int \u2295 String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_numbers_only (numbers : List Int)\n  (h : \u2200 n \u2208 numbers, n > 0)\n  : \u2203 result, (min_special_mult numbers = Sum.inl result \u2227 result > 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to convert strings to a list containing each character -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def stringToList (s : String) : List Char := s.data"
      },
      {
        "type": "sig",
        "string": "def stringContains (s\u2081 s\u2082 : String) : Prop := \u2203 pre post : String, s\u2081 = pre ++ s\u2082 ++ post"
      },
      {
        "type": "sig",
        "string": "def parseAsInt (s : String) : Option Int :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem invalid_entries (valid_nums invalid_nums : List String)\n  (h1 : invalid_nums.length > 0)\n  (h2 : invalid_nums.length \u2264 5)\n  (h3 : \u2200 n \u2208 invalid_nums, \u2203 c \u2208 (stringToList n), c.isAlpha \u2228 c \u2208 ['&', '$', '#', '@'])\n  (h4 : \u2200 n \u2208 valid_nums, (parseAsInt n).isSome)\n  : let valid_int_nums := valid_nums.filterMap parseAsInt\n    \u2203 result : String,\n    (min_special_mult valid_int_nums = Sum.inr result)\n    \u2227 (stringContains result (toString invalid_nums.length))\n    \u2227 (\u2200 inv \u2208 invalid_nums, stringContains result inv) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem lcm_properties (numbers : List Int)\n  (h1 : numbers.length \u2265 2)\n  (h2 : numbers.length \u2264 5)\n  (h3 : \u2200 n \u2208 numbers, n > 0)\n  : \u2203 result, min_special_mult numbers = Sum.inl result\n      \u2227 \u2200 n \u2208 numbers, result % n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 420\n-/\n#guard_msgs in\n#eval min_special_mult [2, 3, 4, 5, 6, 7]\n\n/-\ninfo: \"There are 2 invalid entries: ['a', '&']\"\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"a\", \"&\", \"12\"]\n\n/-\ninfo: 5520\n-/\n#guard_msgs in\n#eval min_special_mult [16, 15, 23, \"-012\"]"
      }
    ]
  },
  "fvapps_004645.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def isAlpha (s : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def nato (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem nato_output_format {s : String}\n  (h : s.all (fun c => c.isAlpha)) :\n  let result := nato s\n  let words := result.split (\u00b7 = ' ')\n  (\u2200 w \u2208 words, isAlpha w \u2228 w.contains '-') \u2227\n  words.length = s.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nato_case_insensitive {s : String}\n  (h : s.all (fun c => 'A' \u2264 c \u2227 c \u2264 'Z')) :\n  nato s = nato s.toUpper :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem nato_valid_codes {s : String}\n  (h : s.all (fun c => 'A' \u2264 c \u2227 c \u2264 'Z')) :\n  let natoWords := [\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\",\n                   \"Foxtrot\", \"Golf\", \"Hotel\", \"India\", \"Juliett\",\n                   \"Kilo\", \"Lima\", \"Mike\", \"November\", \"Oscar\",\n                   \"Papa\", \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\",\n                   \"Uniform\", \"Victor\", \"Whiskey\", \"X-ray\",\n                   \"Yankee\", \"Zulu\"]\n  let result := nato s\n  \u2200 w \u2208 result.split (\u00b7 = ' '), w \u2208 natoWords :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Bravo Alpha November Alpha November Alpha'\n-/\n#guard_msgs in\n#eval nato \"Banana\"\n\n/-\ninfo: 'Hotel India'\n-/\n#guard_msgs in\n#eval nato \"Hi\"\n\n/-\ninfo: 'Alpha Bravo Charlie'\n-/\n#guard_msgs in\n#eval nato \"ABC\""
      }
    ]
  },
  "fvapps_004650.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Nat.choose (n k : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def List.sort (l : List Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def transform (arr : List Nat) (x : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_single_element (n x : Nat) (h : x \u2264 n) :\n  transform [n] x = (List.range (n - x + 1)).foldl (fun acc i => acc + Nat.choose (i + x) x) 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_shuffle (arr : List Nat) (x : Nat) (h : \u2200 n \u2208 arr, n \u2265 x) :\n  transform arr x = transform (List.sort arr) x :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem transform_zero_x (arr : List Nat) :\n  transform arr 0 = List.foldl (fun acc n => acc + (n + 1)) 0 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 384\n-/\n#guard_msgs in\n#eval transform [7, 4, 11, 6, 5] 3\n\n/-\ninfo: 15\n-/\n#guard_msgs in\n#eval transform [5, 6, 7] 2\n\n/-\ninfo: 462\n-/\n#guard_msgs in\n#eval transform [10] 5"
      }
    ]
  },
  "fvapps_004651.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def find_zero_sum_groups (arr : List Int) (n : Nat) : String \u2295 List Int \u2295 List (List Int) := sorry\n\ndef isSorted (l : List Int) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | x :: xs => match xs with\n    | [] => true\n    | y :: _ => x \u2264 y && isSorted xs"
      },
      {
        "type": "sig",
        "string": "def isSortedBy {\u03b1 : Type} (l : List \u03b1) (f : \u03b1 \u2192 \u03b1 \u2192 Bool) : Bool :="
      },
      {
        "type": "impl",
        "string": "  match l with\n  | [] => true\n  | x :: xs => match xs with\n    | [] => true\n    | y :: _ => f x y && isSortedBy xs f"
      },
      {
        "type": "cond",
        "string": "theorem empty_array_returns_no_elements {n : Nat} (h : n > 0) :\n  find_zero_sum_groups [] n = Sum.inl \"No elements to combine\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution_has_correct_length {arr : List Int} {n : Nat} {result : List Int}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inl result)) :\n  result.length = n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution_sums_to_zero {arr : List Int} {n : Nat} {result : List Int}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inl result)) :\n  result.foldl (\u00b7 + \u00b7) 0 = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution_elements_in_input {arr : List Int} {n : Nat} {result : List Int}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inl result)) :\n  \u2200 x \u2208 result, x \u2208 arr :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_solution_is_sorted {arr : List Int} {n : Nat} {result : List Int}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inl result)) :\n  isSorted result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_solutions_all_valid {arr : List Int} {n : Nat} {results : List (List Int)}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inr results)) :\n  \u2200 result \u2208 results,\n    result.length = n \u2227\n    result.foldl (\u00b7 + \u00b7) 0 = 0 \u2227\n    (\u2200 x \u2208 result, x \u2208 arr) \u2227\n    isSorted result = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem multiple_solutions_are_sorted {arr : List Int} {n : Nat} {results : List (List Int)}\n  (h : find_zero_sum_groups arr n = Sum.inr (Sum.inr results)) :\n  isSortedBy results (fun x y => x.foldl (\u00b7 + \u00b7) 0 \u2264 y.foldl (\u00b7 + \u00b7) 0) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_positive_has_no_solution {arr : List Int} {n : Nat}\n  (h1 : \u2200 x \u2208 arr, x > 0)\n  (h2 : n > 0)\n  (h3 : n \u2264 arr.length) :\n  find_zero_sum_groups arr n = Sum.inl \"No combinations\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem size_larger_than_array_no_solution {arr : List Int} {n : Nat}\n  (h : n > arr.length) :\n  find_zero_sum_groups arr n = Sum.inl \"No combinations\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [-2, -1, 3]\n-/\n#guard_msgs in\n#eval find_zero_sum_groups [1, -1, 2, 3, -2] 3\n\n/-\ninfo: [[-3, -2, 5], [-3, -1, 4], [-3, 1, 2], [-2, -1, 3]]\n-/\n#guard_msgs in\n#eval find_zero_sum_groups [1, -1, 2, 3, -2, 4, 5, -3] 3\n\n/-\ninfo: 'No combinations'\n-/\n#guard_msgs in\n#eval find_zero_sum_groups [1, 1, 2, 3] 2"
      }
    ]
  },
  "fvapps_004652.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Matrix := List (List Nat)"
      },
      {
        "type": "sig",
        "string": "def different_squares : Matrix \u2192 Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def rotateMatrix (m : Matrix) : Matrix :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isValidMatrix (m : Matrix) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isAllValue (m : Matrix) (v : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Number of different squares is always positive and has an upper bound"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem different_squares_bounds (m : Matrix) :\n  isValidMatrix m \u2192\n  1 \u2264 different_squares m \u2227\n  different_squares m \u2264 (m.length - 1) * ((m.head!).length - 1) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- A matrix filled with same value has exactly 1 unique square"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem same_value_matrix_one_square (m : Matrix) (v : Nat) :\n  isValidMatrix m \u2192\n  isAllValue m v \u2192\n  different_squares m = 1 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Rotating a matrix preserves number of unique squares"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem different_squares_rotation_invariant (m : Matrix) :\n  isValidMatrix m \u2192\n  different_squares m = different_squares (rotateMatrix m) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval different_squares [[1, 2, 1], [2, 2, 2], [2, 2, 2], [1, 2, 3], [2, 2, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[1, 1], [1, 1]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval different_squares [[9, 9, 9], [9, 9, 9], [9, 9, 9]]"
      }
    ]
  },
  "fvapps_004662.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def lineup_students (input : String) : List String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\n  lineupStudentsLengthPreserved:\n  For any list of students, the length of the output list\n  equals the length of the input list\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lineupStudentsLengthPreserved (input : String) (names : List String) :\n  names = lineup_students input \u2192\n  (lineup_students input).length = names.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\n  lineupStudentsSorted:\n  For any two adjacent elements in the result,\n  if they have equal length then they are reverse alphabetically sorted,\n  otherwise the first is longer than the second\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lineupStudentsSorted {result : List String} (i : Nat) (h : i + 1 < result.length) :\n  let a := result[i]!\n  let b := result[i+1]!\n  (a.length = b.length \u2192 a \u2265 b) \u2227\n  (a.length \u2260 b.length \u2192 a.length > b.length) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\n  lineupStudentsPreservesElements:\n  The output list contains exactly the same elements as the input\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lineupStudentsPreservesElements (input : String) (names : List String) :\n  names = lineup_students input \u2192\n  \u2200 x, (x \u2208 names \u2194 x \u2208 lineup_students input) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\n  lineupStudentsSingleElement:\n  A single name returns a singleton list with that name\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lineupStudentsSingleElement (name : String) :\n  lineup_students name = [name] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\n  lineupStudentsEmpty:\n  An empty string input returns an empty list\n-/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem lineupStudentsEmpty :\n  lineup_students \"\" = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval lineup_students \"Tadashi Takahiro Takao Takashi Takayuki Takehiko Takeo Takeshi Takeshi\"\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval lineup_students \"xxa xxb xxc xxd xa xb xc xd\"\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval lineup_students \"aaa bbb ccc\""
      }
    ]
  },
  "fvapps_004668.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sel_number (n : Nat) (d : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def hasAscendingUniqueDigits (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "other",
        "string": "/- Helper function to count numbers with ascending unique digits -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def countAscendingUnique (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sel_number_non_negative (n d : Nat) :\n  sel_number n d \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sel_number_under_twelve (n d : Nat) :\n  n < 12 \u2192 sel_number n d = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sel_number_unique_bound (n : Nat) :\n  sel_number n 0 \u2264 String.length (toString n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/- Helper function to check if digits are ascending and unique -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem sel_number_monotonic_d (n : Nat) :\n  \u2200 d\u2081 d\u2082 : Nat, d\u2081 \u2264 d\u2082 \u2192 d\u2082 < 10 \u2192 n \u2265 12 \u2192\n    sel_number n d\u2081 \u2264 sel_number n d\u2082 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sel_number_monotonic_n (d n\u2081 n\u2082 : Nat) :\n  n\u2081 \u2264 n\u2082 \u2192 n\u2081 \u2265 12 \u2192 d < 10 \u2192\n    sel_number n\u2081 d \u2264 sel_number n\u2082 d :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: 2\n-/\n#guard_msgs in\n#eval sel_number 20 2\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sel_number 0 1\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval sel_number 50 3"
      }
    ]
  },
  "fvapps_004669.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def resistor_parallel (r : List Float) : Float :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem parallel_resistance_positive {r : List Float} (h : \u2200 x \u2208 r, x > 0) :\n  resistor_parallel r > 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def sum_list : List Float \u2192 Float\n  | [] => 0\n  | x::xs => x + sum_list xs"
      },
      {
        "type": "cond",
        "string": "theorem single_resistor_identity {r : Float} (h : r > 0) :\n  resistor_parallel [r] = r :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem parallel_symmetric {r1 r2 : Float} (h1 : r1 > 0) (h2 : r2 > 0) :\n  resistor_parallel [r1, r2] = resistor_parallel [r2, r1] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem inverse_sum_relationship {r : List Float} (h : \u2200 x \u2208 r, x > 0) :\n  1 / (resistor_parallel r) = sum_list (r.map (\u03bb x => 1/x)) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
      }
    ]
  },
  "fvapps_004680.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def digitsSum (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def is_valid (n : Nat) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_next (n : Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def get_series (count start : Nat) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem harshad_property {n : Nat} (h : n > 0) (valid : is_valid n = true) :\n  n % digitsSum n = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_next_properties {n : Nat} :\n  let next := get_next n\n  next > n \u2227\n  is_valid next = true \u2227\n  \u2200 x, n < x \u2192 x < next \u2192 is_valid x = false :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem get_series_properties {count start : Nat} (h : count > 0) :\n  let series := get_series count start\n  List.length series = count \u2227\n  (\u2200 i, i + 1 < List.length series \u2192\n    series[i]'(by sorry) < series[i+1]'(by sorry)) \u2227\n  (\u2200 x \u2208 series, x > start) \u2227\n  (\u2200 x \u2208 series, is_valid x = true) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem next_harshad_valid {n : Nat} :\n  is_valid (get_next n) = true :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
      }
    ]
  },
  "fvapps_004687.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def knapsack (capacity : Nat) (items : List (Nat \u00d7 Nat)) : List Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def sumList (xs : List Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  match xs with\n  | [] => 0\n  | h :: t => h + sumList t"
      },
      {
        "type": "sig",
        "string": "def zipWithIndex {\u03b1 : Type} (l : List \u03b1) : List (Nat \u00d7 \u03b1) :="
      },
      {
        "type": "impl",
        "string": "  let rec aux (i : Nat) (xs : List \u03b1) : List (Nat \u00d7 \u03b1) :=\n    match xs with\n    | [] => []\n    | h :: t => (i, h) :: aux (i+1) t\n  aux 0 l"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_result_length_matches_input\n    (capacity : Nat) (items : List (Nat \u00d7 Nat)) :\n    (knapsack capacity items).length = items.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_result_nonnegative\n    (capacity : Nat) (items : List (Nat \u00d7 Nat)) :\n    \u2200 x \u2208 knapsack capacity items, x \u2265 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_total_size_within_capacity\n    (capacity : Nat) (items : List (Nat \u00d7 Nat)) :\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    sumList sizes \u2264 capacity :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_optimal_ratio\n    (capacity : Nat) (items : List (Nat \u00d7 Nat)) (i : Nat) :\n    i < items.length \u2192\n    let result := knapsack capacity items\n    let sizes := List.map (fun p => (items[p.1]!).1 * p.2) (zipWithIndex result)\n    let total_size := sumList sizes\n    let ratio := items[i]!.2 / items[i]!.1\n    items[i]!.1 + total_size \u2264 capacity \u2192\n    \u2200 j < items.length,\n      items[j]!.2 / items[j]!.1 = 0 \u2228 items[j]!.2 / items[j]!.1 < ratio :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_zero_capacity\n    (items : List (Nat \u00d7 Nat)) :\n    knapsack 0 items = List.replicate items.length 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem knapsack_empty_items\n    (capacity : Nat) :\n    knapsack capacity [] = [] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[6, 9], [5, 5]]\n\n/-\ninfo: [5, 0, 0]\n-/\n#guard_msgs in\n#eval knapsack 10 [[2, 3], [3, 4], [4, 5]]\n\n/-\ninfo: [0, 0]\n-/\n#guard_msgs in\n#eval knapsack 5 [[10, 2], [12, 4]]"
      }
    ]
  },
  "fvapps_004693.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def solution (n : Nat) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def isSubstring (s\u2081 s\u2082 : String) : Bool :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Map Roman numerals to their decimal values -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "sig",
        "string": "def romanValues : List (Char \u00d7 Nat) :="
      },
      {
        "type": "impl",
        "string": "  [('I', 1), ('V', 5), ('X', 10), ('L', 50), ('C', 100), ('D', 500), ('M', 1000)]"
      },
      {
        "type": "sig",
        "string": "def convertToNums (s : String) : List Nat :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem monotonically_decreasing_values (n : Nat) (h : 1 \u2264 n \u2227 n \u2264 3999) :\n  let numericValues := convertToNums (solution n)\n  \u2200 i j, i < j \u2192 j < numericValues.length \u2192\n    (numericValues.get \u27e8i, sorry\u27e9) \u2265 (numericValues.get \u27e8j, sorry\u27e9) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_roman_chars (n : Nat) (h : 1 \u2264 n \u2227 n \u2264 3999) :\n  \u2200 c, String.contains (solution n) c \u2192 c \u2208 ['M', 'D', 'C', 'L', 'X', 'V', 'I'] :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem length_constraints (n : Nat) (h : 1 \u2264 n \u2227 n \u2264 3999) :\n  (n \u2264 3 \u2192 (solution n).length \u2264 3) \u2227\n  (n \u2264 8 \u2192 (solution n).length \u2264 4) \u2227\n  (n \u2264 39 \u2192 (solution n).length \u2264 6) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_four_consecutive_chars (n : Nat) (h : 1 \u2264 n \u2227 n \u2264 3999) :\n  \u00acisSubstring \"IIII\" (solution n) \u2227\n  \u00acisSubstring \"XXXX\" (solution n) \u2227\n  \u00acisSubstring \"CCCC\" (solution n) \u2227\n  \u00acisSubstring \"MMMM\" (solution n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem valid_subtractive_pairs (n : Nat) (h : 1 \u2264 n \u2227 n \u2264 3999) :\n  \u00acisSubstring \"IL\" (solution n) \u2227\n  \u00acisSubstring \"IC\" (solution n) \u2227\n  \u00acisSubstring \"ID\" (solution n) \u2227\n  \u00acisSubstring \"IM\" (solution n) \u2227\n  \u00acisSubstring \"XD\" (solution n) \u2227\n  \u00acisSubstring \"XM\" (solution n) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'I'\n-/\n#guard_msgs in\n#eval solution 1\n\n/-\ninfo: 'MCMXC'\n-/\n#guard_msgs in\n#eval solution 1990\n\n/-\ninfo: 'MMVIII'\n-/\n#guard_msgs in\n#eval solution 2008"
      }
    ]
  },
  "fvapps_004696.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def encode (n : Nat) (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "sig",
        "string": "def decode (s : String) : String :="
      },
      {
        "type": "impl",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- For any number n and text, decoding after encoding returns original text -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem encode_decode_roundtrip (n : Nat) (text : String) :\n  decode (encode n text) = text :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/- The first word of encoded text equals the input number n as string -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem encode_starts_with_n (n : Nat) (text : String) :\n  List.get! (String.splitOn (encode n text) \" \") 0 = toString n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/- Empty string cases -/"
      },
      {
        "type": "empty",
        "string": ""
      },
      {
        "type": "cond",
        "string": "theorem empty_string_case1 : decode (encode 5 \"\") = \"\" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_string_case2 : encode 0 \"\" = \"0 \" :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "other",
        "string": "/-\ninfo: solution\n-/\n#guard_msgs in\n#eval encode 10 \"If you wish to make an apple pie from scratch, you must first invent the universe.\"\n\n/-\ninfo: quote\n-/\n#guard_msgs in\n#eval decode encode(10, quote)\n\n/-\ninfo: test2\n-/\n#guard_msgs in\n#eval decode encode(3, test2)\n\n/-\ninfo: test3\n-/\n#guard_msgs in\n#eval decode encode(5, test3)"
      }
    ]
  },
  "fvapps_004697.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def DIRS := [('\u2190', (0,-1)), ('\u2191', (-1,0)), ('\u2192', (0,1)), ('\u2193', (1,0)),\n            ('\u2196', (-1,-1)), ('\u2197', (-1,1)), ('\u2198', (1,1)), ('\u2199', (1,-1))]\n\ndef count_deaf_rats (town: List String) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def listSum : List Nat \u2192 Nat\n  | [] => 0\n  | x::xs => x + listSum xs\n\ndef countChar (s: String) (c: Char) : Nat :="
      },
      {
        "type": "impl",
        "string": "  s.toList.filter (\u00b7 == c) |>.length"
      },
      {
        "type": "cond",
        "string": "theorem valid_output_range (town: List String)\n  (h1: town.length > 0)\n  (h2: listSum (town.map (fun row => countChar row 'P')) = 1)\n  : let total_rats := listSum (town.map (fun row =>\n      listSum ((DIRS.map Prod.fst).map (fun c => countChar row c))))\n    let result := count_deaf_rats town\n    0 \u2264 result \u2227 result \u2264 total_rats :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_town :\n  count_deaf_rats [\" P \"] = 0 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem simple_case :\n  count_deaf_rats [\"P \u2192\", \"\u2190 \u2190\"] = 2 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_directions :\n  let dirChars := DIRS.map Prod.fst\n  let town := [\"P \" ++ String.mk dirChars]\n  let result := count_deaf_rats town\n  0 \u2264 result \u2227 result \u2264 DIRS.length :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"\u2197 P     \", \"  \u2198   \u2196\", \"  \u2191     \", \"\u2197       \"]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval count_deaf_rats [\"    \u2197    \", \"P \u2193   \u2196 \u2191\", \"    \u2190   \u2193\", \"  \u2196 \u2199   \u2199\", \"\u2193 \u2193 \u2193    \"]"
      }
    ]
  },
  "fvapps_004708.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def Card := List (List (Option Nat))"
      },
      {
        "type": "sig",
        "string": "def CalledNumber := String\n\ndef bingo (card : Card) (numbers : List CalledNumber) : Bool :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def cardNumberToString (n : Option Nat) : CalledNumber :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem bingo_returns_boolean (card : Card) (numbers : List CalledNumber) :\n  \u2203 b : Bool, bingo card numbers = b :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem free_space_is_center (card : Card) :\n  card.get? 2 >>= (\u00b7.get? 2) = some none :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem empty_calls_no_bingo (card : Card) :\n  \u00ac(bingo card []) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem all_numbers_called_is_bingo (card : Card) (numbers : List CalledNumber)\n  (h : \u2200 (i j : Nat), i < card.length \u2192 j < (card.get! i).length \u2192\n       (card.get! i).get! j \u2260 none \u2192\n       cardNumberToString ((card.get! i).get! j) \u2208 numbers) :\n  bingo card numbers :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\", \"O61\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"B1\", \"I16\", \"N31\", \"G46\"]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval bingo [[\"B\", \"I\", \"N\", \"G\", \"O\"], [1, 16, 31, 46, 61], [3, 18, 33, 48, 63], [5, 20, \"FREE SPACE\", 50, 65], [7, 22, 37, 52, 67], [9, 24, 39, 54, 69]] [\"N31\", \"N33\", \"N37\", \"N39\"]"
      }
    ]
  },
  "fvapps_004713.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def sum_divisors (n: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def equal_sigma1 (nmax: Nat) : Nat :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_divisors_positive (n: Nat) (h: n \u2265 1) :\n  let result := sum_divisors n\n  result \u2265 1 \u2227 result \u2265 n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_sigma1_properties (nmax: Nat) (h: nmax \u2265 1) :\n  let result := equal_sigma1 nmax\n  result \u2265 0 \u2227 (nmax < 528 \u2192 result = 0) :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem sum_divisors_multiplication_property (n: Nat) (h: n \u2265 1) :\n  \u2200 k : Nat,\n  let divisors := (List.range n).filterMap (fun i =>\n    if n % (i+1) = 0 then some (i+1) else none)\n  k * k = n \u2192\n  sum_divisors n \u2264 2 * n :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem equal_sigma1_symmetry (nmax: Nat) :\n  let result := equal_sigma1 nmax\n  \u2200 n, n \u2265 528 \u2192 n \u2264 nmax \u2192\n  n = 528 \u2228 n = 1561 :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval equal_sigma1 100\n\n/-\ninfo: 1353\n-/\n#guard_msgs in\n#eval equal_sigma1 1000\n\n/-\ninfo: 4565\n-/\n#guard_msgs in\n#eval equal_sigma1 2000"
      }
    ]
  },
  "fvapps_004714.lean": {
    "status": "ok",
    "results": [
      {
        "type": "sig",
        "string": "def wanted_words (vowel_count : Nat) (consonant_count : Nat) (forbidden : List Char) : List String :="
      },
      {
        "type": "impl",
        "string": "  sorry"
      },
      {
        "type": "sig",
        "string": "def isVowel (c : Char) : Bool :="
      },
      {
        "type": "impl",
        "string": "  c = 'a' || c = 'e' || c = 'i' || c = 'o' || c = 'u'"
      },
      {
        "type": "sig",
        "string": "def WORD_LIST : List String :="
      },
      {
        "type": "impl",
        "string": "  [\"strength\", \"afterwards\", \"background\", \"photograph\", \"successful\", \"understand\"]"
      },
      {
        "type": "cond",
        "string": "theorem result_are_strings (v c : Nat) (f : List Char) :\n  \u2200 (w : String), w \u2208 wanted_words v c f \u2192 w.length \u2265 0\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exact_vowel_count (v c : Nat) (f : List Char) :\n  \u2200 (w : String), w \u2208 wanted_words v c f \u2192\n  (List.filter isVowel w.data).length = v\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem exact_total_length (v c : Nat) (f : List Char) :\n  \u2200 (w : String), w \u2208 wanted_words v c f \u2192\n  w.length = v + c\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "cond",
        "string": "theorem no_forbidden_chars (v c : Nat) (f : List Char) :\n  \u2200 (w : String), w \u2208 wanted_words v c f \u2192\n  \u2200 (x : Char), x \u2208 f \u2192 \u00ac(x \u2208 w.data)\n  :="
      },
      {
        "type": "proof",
        "string": "sorry"
      },
      {
        "type": "comment",
        "string": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
      }
    ]
  }
}