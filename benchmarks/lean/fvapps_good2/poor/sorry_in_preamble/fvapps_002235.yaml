vc-description: |-

vc-preamble: |-
  def solve (n m k : Nat) (arr : List Nat) : Nat := sorry
  
  def listMin (l : List Nat) : Nat :=
    match l with
    | [] => 0
    | x::xs => List.foldl min x xs
  
  def listMax (l : List Nat) : Nat :=
    match l with
    | [] => 0
    | x::xs => List.foldl max x xs

vc-helpers: |-

vc-definitions: |-

vc-theorems: |-
  theorem solve_result_in_bounds {n m k : Nat} {arr : List Nat}
    (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : arr ≠ []) :
    let result := solve n m k arr
    listMin arr ≤ result ∧ result ≤ listMax arr :=
  sorry
  
  theorem solve_k_zero {n m : Nat} {arr : List Nat}
    (h1 : arr.length ≥ m) (h2 : m ≤ n) :
    solve n m 0 arr =
      listMin (List.map
        (fun i => max (arr[i]!) (arr[arr.length - i - 1]!))
        (List.range m)) :=
  sorry
  
  theorem solve_k_large {n m k : Nat} {arr : List Nat}
    (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : k ≥ m-1) (h4 : m > 0) :
    solve n m k arr =
      listMax (List.map
        (fun i => max (arr[i]!) (arr[arr.length - i - 1]!))
        (List.range m)) :=
  sorry
  
  theorem solve_empty_error {n m : Nat} :
    solve n m 0 [] = 0 :=
  sorry
  
  theorem solve_negative_k {n m k : Nat} {arr : List Nat}
    (h1 : arr.length ≥ m) (h2 : m ≤ n) :
    solve n m 0 arr = solve n m k arr :=
  sorry
  
  theorem solve_very_large_k {n m k : Nat} {arr : List Nat}
    (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : k ≥ m-1) :
    solve n m k arr = solve n m (m-1) arr :=
  sorry

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: guarded
  
  /-
  info: 8
  -/
  #guard_msgs in
  #eval solve 6 4 2 [2, 9, 2, 3, 8, 5]
  
  /-
  info: 4
  -/
  #guard_msgs in
  #eval solve 4 4 1 [2, 13, 60, 4]
  
  /-
  info: 1
  -/
  #guard_msgs in
  #eval solve 4 1 3 [1, 2, 2, 1]

