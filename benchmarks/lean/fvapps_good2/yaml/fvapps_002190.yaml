vc-description: |-

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def checkTreeWithDistances (N : Nat) (distances : List Nat) : List (Nat × Nat) ⊕ Unit :=
    sorry
  
  def isValidTree (N : Nat) (edges : List (Nat × Nat)) : Bool :=
    sorry

vc-theorems: |-
  theorem arbitrary_inputs_valid {N : Nat} {distances : List Nat}
    (h1 : N ≥ 2) (h2 : N ≤ 20) (h3 : distances.length = N) :
    let result := checkTreeWithDistances N distances
    match result with
    | .inl edges => isValidTree N edges = true
    | .inr _ => True :=
  sorry
  
  theorem identical_distances_invalid {N : Nat} (h : N ≥ 2) :
    let distances := List.replicate N N
    checkTreeWithDistances N distances = .inr () :=
  sorry
  
  theorem sequential_distances_valid {N : Nat} (h1 : N ≥ 2) (h2 : N ≤ 20) :
    let distances := List.range N
    let result := checkTreeWithDistances N distances
    match result with
    | .inl edges => isValidTree N edges = true
    | .inr _ => True :=
  sorry
  
  theorem edge_cases :
    (checkTreeWithDistances 2 [1,1] = .inr ()) ∧
    (checkTreeWithDistances 2 [0,0] = .inr ()) ∧
    (match checkTreeWithDistances 3 [3,4,5] with
     | .inl edges => isValidTree 3 edges = true
     | .inr _ => False) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: unguarded
  
  /-
  info: N1 - 1
  -/
  #guard_msgs in
  #eval len result
  
  /-
  info: -1
  -/
  #guard_msgs in
  #eval check_tree_with_distances 2 [1, 2]
  
  /-
  info: N3 - 1
  -/
  #guard_msgs in
  #eval len result

