vc-description: |-

vc-preamble: |-
  def sum (l : List Nat) : Nat :=
    l.foldl (· + ·) 0
  
  def allEqual (l : List Nat) : Prop :=
    ∀ x y, x ∈ l → y ∈ l → x = y
  
  def uniqueCount (l : List Nat) : Nat :=
    (l.eraseDups).length

vc-helpers: |-

vc-definitions: |-
  def find_max_distinct_subarray_sum (n k : Nat) (arr : List Nat) : Int :=
    sorry

vc-theorems: |-
  theorem max_distinct_subarray_sum_within_bounds
    {n k : Nat} {arr : List Nat} (h1 : k ≤ n) (h2 : n = arr.length)
    (h3 : ∀ x, x ∈ arr → 1 ≤ x ∧ x ≤ 100) :
    let result := find_max_distinct_subarray_sum n k arr
    result = -1 ∨
    result ≤ (List.range (n - k + 1)).foldl (fun acc i =>
      max acc (sum ((arr.take (i + k)).drop i))) 0 :=
  sorry
  
  theorem identical_elements_sum_first_k
    {n k : Nat} {arr : List Nat}
    (h1 : k ≤ n) (h2 : n = arr.length)
    (h3 : allEqual arr) (h4 : ∀ x, x ∈ arr → x > 0) :
    find_max_distinct_subarray_sum n k arr = sum (arr.take k) :=
  sorry
  
  theorem distinct_count_consistent
    {n k : Nat} {arr : List Nat}
    (h1 : k ≤ n) (h2 : n = arr.length) :
    let result := find_max_distinct_subarray_sum n k arr
    result = -1 ∨
    ∀ i, i + k ≤ n →
      sum ((arr.take (i + k)).drop i) = result →
      uniqueCount ((arr.take (i + k)).drop i) = uniqueCount arr :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
  
  /-
  info: 37
  -/
  #guard_msgs in
  #eval find_max_distinct_subarray_sum 10 6 [8, 8, 3, 5, 3, 8, 5, 7, 7, 7]
  
  /-
  info: 6
  -/
  #guard_msgs in
  #eval find_max_distinct_subarray_sum 5 3 [1, 2, 1, 2, 3]
  
  /-
  info: 10
  -/
  #guard_msgs in
  #eval find_max_distinct_subarray_sum 4 2 [5, 5, 5, 5]

