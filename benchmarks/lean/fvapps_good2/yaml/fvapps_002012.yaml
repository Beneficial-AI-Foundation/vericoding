vc-description: |-
  -- Simplified gaps for type checking

vc-preamble: |-
  structure BridgeProblemInputs where
    n : Nat
    m : Nat
    islands : List (List Int)
    bridges : List Int
  
  def get_indices (result : String) : List Nat :=
    if result = "No" then []
    else string_to_nat_array (result.splitOn "\n").head!

vc-helpers: |-

vc-definitions: |-
  def solve_bridge_problem (n m : Nat) (islands : List (List Int)) (bridges : List Int) : String :=
  sorry
  
  def verify_bridge_placement (bridges : List Int) (gaps : List (Int × Int)) (result : String) : Bool :=
  sorry
  
  def string_to_nat_array (s : String) : List Nat :=
  sorry

vc-theorems: |-
  theorem result_format_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :
    let result := solve_bridge_problem n m islands bridges
    (result = "No") ∨
    (∃ nums : List Nat, result = s!"Yes\n{nums}" ∧ nums.length = n - 1) :=
  sorry
  
  theorem bridge_placement_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :
    let result := solve_bridge_problem n m islands bridges
    let gaps := List.range (n-1) |>.map (λ i => (1, 1))
    verify_bridge_placement bridges gaps result = true :=
  sorry
  
  theorem bridge_indices_valid (n m : Nat) (islands : List (List Int)) (bridges : List Int) :
    let result := solve_bridge_problem n m islands bridges
    let indices := get_indices result
    result = "No" ∨
    (∀ i ∈ indices, 1 ≤ i ∧ i ≤ m) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: unguarded
  
  /--
  info: 'Yes\n2 3 1'
  -/
  #guard_msgs in
  #eval solve_bridge_problem 4 4 [[1, 4], [7, 8], [9, 10], [12, 14]] [4, 5, 3, 8]
  
  /--
  info: 'No'
  -/
  #guard_msgs in
  #eval solve_bridge_problem 2 2 [[11, 14], [17, 18]] [2, 9]
  
  /--
  info: 'Yes\n1'
  -/
  #guard_msgs in
  #eval solve_bridge_problem 2 1 [[1, 1], [1000000000000000000, 1000000000000000000]] [999999999999999999]

