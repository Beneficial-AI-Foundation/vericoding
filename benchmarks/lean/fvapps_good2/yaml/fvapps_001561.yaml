vc-description: |-

vc-preamble: |-
  def list_sum : List Nat → Nat
    | [] => 0
    | (h::t) => h + list_sum t
  
  def list_sorted : List Nat → Bool
    | [] => true
    | [_] => true
    | (a::b::rest) => a ≤ b && list_sorted (b::rest)
  
  def list_all (l : List Nat) (p : Nat → Bool) : Bool :=
    List.all l p
  
  def square (n : Nat) : Nat := n * n

vc-helpers: |-

vc-definitions: |-
  def decompose (n : Nat) : Option (List Nat) :=
  sorry

vc-theorems: |-
  theorem decompose_valid (n : Nat) (result : List Nat) :
    decompose n = some result →
    (list_sum (List.map square result) = n * n) ∧
    list_sorted result = true ∧
    list_all result (λ x => x > 0) = true ∧
    list_all result (λ x => x < n) = true :=
  sorry
  
  theorem decompose_2_impossible :
    decompose 2 = none :=
  sorry
  
  theorem decompose_3_impossible :
    decompose 3 = none :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
  
  /-
  info: [1, 2, 4, 10]
  -/
  #guard_msgs in
  #eval decompose 11
  
  /-
  info: [1, 3, 5, 8, 49]
  -/
  #guard_msgs in
  #eval decompose 50
  
  /-
  info: None
  -/
  #guard_msgs in
  #eval decompose 4

