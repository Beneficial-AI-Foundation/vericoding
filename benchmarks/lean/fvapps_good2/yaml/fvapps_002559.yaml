vc-description: |-
  -- Property 1: Each step should be a valid permutation of original list
  
  -- Property 2: Each step should have one or more swaps from previous
  
  -- Property 3: Final state should be sorted
  
  -- Property 4: Number of steps should not exceed inversions
  
  -- Already sorted lists produce empty steps
  
  -- Empty list produces empty steps

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def bubble (lst : List Int) : List (List Int) :=
  sorry
  
  def isSorted (lst : List Int) : Bool :=
  sorry
  
  def countInversions (lst : List Int) : Nat :=
  sorry

vc-theorems: |-
  theorem bubble_steps_are_permutations {lst : List Int} {step : List Int} :
    step ∈ bubble lst → step.length = lst.length :=
  sorry
  
  theorem bubble_steps_have_swaps {lst : List Int} {i : Nat} (h1 : i < (bubble lst).length) (h2 : i + 1 < (bubble lst).length) :
    ∃ pos : Nat, pos < lst.length ∧
      ((bubble lst).get ⟨i, h1⟩).get! pos ≠ ((bubble lst).get ⟨i+1, h2⟩).get! pos :=
  sorry
  
  theorem bubble_final_step_sorted {lst : List Int} (h : bubble lst ≠ []) :
    isSorted ((bubble lst).getLast h) :=
  sorry
  
  theorem bubble_steps_bounded_by_inversions {lst : List Int} :
    (bubble lst).length ≤ countInversions lst :=
  sorry
  
  theorem bubble_sorted_empty {lst : List Int} :
    isSorted lst → bubble lst = [] :=
  sorry
  
  theorem bubble_empty :
    bubble [] = [] :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval bubble []
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval bubble [1, 2, 3, 4, 5, 6, 7, 8, 9]
  
  /--
  info: [[1, 3, 3, 4, 7, 2], [1, 3, 3, 4, 2, 7], [1, 3, 3, 2, 4, 7], [1, 3, 2, 3, 4, 7], [1, 2, 3, 3, 4, 7]]
  -/
  #guard_msgs in
  #eval bubble [1, 3, 3, 7, 4, 2]

