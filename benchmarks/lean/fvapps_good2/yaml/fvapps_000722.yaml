vc-description: |-
  /-
  Given a positive integer K > 2, with prime
  factorization:
  
  K = p1^a1 * p2^a2 ... * pn^an
  
  Compute the following:
  
  S = a1*p1 + a2*p2 ... + an*pn.
  
  -----Input-----
  A list of <100 integers, one on each line,
  all less than $2*10^{18}$.
  
  -----Output-----
  For each integer compute the super factor
  sum and output it on a single line.
  
  -----Example-----
  Input:
  6
  7
  Output:
  5
  7
  -/

vc-preamble: |-
  def list_product : List Nat → Nat
    | [] => 1
    | x :: xs => x * list_product xs
  
  def list_sum : List Nat → Nat
    | [] => 0
    | x :: xs => x + list_sum xs

vc-helpers: |-

vc-definitions: |-
  def compute_super_factor_sum (n : Nat) : Nat :=
  sorry
  
  def is_prime (n : Nat) : Bool :=
  sorry

vc-theorems: |-
  theorem compute_super_factor_sum_positive (n : Nat) (h : n ≥ 2) :
    compute_super_factor_sum n > 0 :=
  sorry
  
  theorem compute_super_factor_sum_primes (n : Nat) (h1 : n ≥ 2) (h2 : is_prime n = true) :
    compute_super_factor_sum n = n :=
  sorry
  
  theorem compute_super_factor_sum_multiplicative (a b : Nat) (h1 : a ≥ 1) (h2 : b ≥ 1) :
    compute_super_factor_sum (a * b) ≥ min (compute_super_factor_sum a) (compute_super_factor_sum b) :=
  sorry
  
  theorem compute_super_factor_sum_product_relation (factors : List Nat)
    (h1 : ∀ x ∈ factors, x ≥ 2) (h2 : factors.length > 0) :
    compute_super_factor_sum (list_product factors) ≥
    list_sum (List.map compute_super_factor_sum (List.filter (fun x => x > 1) factors)) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
  
  /--
  info: 5
  -/
  #guard_msgs in
  #eval compute_super_factor_sum 6
  
  /--
  info: 7
  -/
  #guard_msgs in
  #eval compute_super_factor_sum 7
  
  /--
  info: 7
  -/
  #guard_msgs in
  #eval compute_super_factor_sum 12

