vc-description: |-
  /-
  Create a function that finds the largest palindromic number made from the product of **at least 2** of the given arguments.
  
  ### Notes
  
  * Only non-negative numbers will be given in the argument
  * You don't need to use all the digits of the products
  * Single digit numbers are considered palindromes
  * Optimization is needed: dealing with ones and zeros in a smart way will help a lot
  
  ## Examples
  
  ```
  [937, 113] --> 81518
  ```
  As `937 * 113 = 105881` and the largest palindromic number that can be arranged from the digits of result is: `81518`
  
  Another one:
  
  ```
  [57, 62, 23] --> 82128
  
               product     palindrome
  57 * 62      = 3534   -->  353
  57 * 23      = 1311   -->  131
  62 * 23      = 1426   -->  6
  57 * 62 * 23 = 81282  -->  82128
  ```
  
  One more:
  ```
  [15, 125, 8] --> 8
  
               product     palindrome
  15 * 125     = 1875   -->  8
  15 * 8       = 120    -->  2
  125 * 8      = 1000   -->  1
  15 * 125 * 8 = 15000  -->  5
  ```
  -/
  
  -- Apps difficulty: interview
  -- Assurance level: unguarded

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def largest_palindrom_from (n : Nat) : Nat :=
  sorry
  
  def numeric_palindrome (arr : List Nat) : Nat :=
  sorry
  
  def reverseString (s : String) : String :=
  sorry

vc-theorems: |-
  theorem largest_palindrom_from_is_palindrome (n : Nat)
    (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :
    let result := toString (largest_palindrom_from n)
    result = reverseString result :=
  sorry
  
  theorem largest_palindrom_from_uses_input_digits (n : Nat)
    (h1 : 1 ≤ n) (h2 : n ≤ 10^6) :
    let result := toString (largest_palindrom_from n)
    ∀ d : Char, d ∈ result.data → d ∈ (toString n).data :=
  sorry
  
  theorem numeric_palindrome_is_palindrome (nums : List Nat)
    (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)
    (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :
    let result := toString (numeric_palindrome nums)
    result = reverseString result :=
  sorry
  
  theorem numeric_palindrome_bound (nums : List Nat)
    (h1 : nums.length ≥ 2) (h2 : nums.length ≤ 5)
    (h3 : ∀ x ∈ nums, 2 ≤ x ∧ x ≤ 1000) :
    numeric_palindrome nums ≤ nums.foldr (·*·) 1 :=
  sorry
  
  theorem numeric_palindrome_with_ones (nums : List Nat)
    (h1 : nums.length ≥ 3) (h2 : nums.length ≤ 6)
    (h3 : ∀ i, i < nums.length - 1 → nums.get ⟨i, sorry⟩ = 1)
    (h4 : nums.getLast? = some 2) :
    let result := toString (numeric_palindrome nums)
    result = reverseString result :=
  sorry

vc-postamble: |-

