vc-description: |-
  /-
  Variation of this nice kata, the war has expanded and become dirtier and meaner; both even and odd numbers will fight with their pointy `1`s. And negative integers are coming into play as well, with, ça va sans dire, a negative contribution (think of them as spies or saboteurs).
  
  Again, three possible outcomes: `odds win`, `evens win` and `tie`.
  
  Examples:
  
  ```python
  bits_war([1,5,12]) => "odds win" #1+101 vs 1100, 3 vs 2
  bits_war([7,-3,20]) => "evens win" #111-11 vs 10100, 3-2 vs 2
  bits_war([7,-3,-2,6]) => "tie" #111-11 vs -1+110, 3-2 vs -1+2
  ```
  -/

vc-preamble: |-
  def sum_list_nat : List Nat → Nat
    | [] => 0
    | x :: xs => x + sum_list_nat xs

vc-helpers: |-

vc-definitions: |-
  def bits_war (numbers : List Int) : String :=
  sorry
  
  def bitsToCount (n : Int) : Nat :=
  sorry

vc-theorems: |-
  theorem bits_war_returns_valid_result (numbers : List Int) (h : numbers.length > 0) :
    (bits_war numbers = "odds win") ∨
    (bits_war numbers = "evens win") ∨
    (bits_war numbers = "tie") :=
  sorry
  
  theorem bits_war_all_zeros (numbers : List Int) :
    (∀ n ∈ numbers, n = 0) →
    bits_war numbers = "tie" :=
  sorry
  
  theorem bits_war_all_positive (numbers : List Int) (h : numbers.length > 0) :
    (∀ n ∈ numbers, n ≥ 0) →
    let odd_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 1)).map bitsToCount)
    let even_bits := sum_list_nat ((numbers.filter (fun n => n % 2 = 0)).map bitsToCount)
    bits_war numbers = if odd_bits > even_bits then "odds win"
                       else if even_bits > odd_bits then "evens win"
                       else "tie" :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
  
  /--
  info: 'odds win'
  -/
  #guard_msgs in
  #eval bits_war [1, 5, 12]
  
  /--
  info: 'evens win'
  -/
  #guard_msgs in
  #eval bits_war [7, -3, 20]
  
  /--
  info: 'tie'
  -/
  #guard_msgs in
  #eval bits_war [7, -3, -2, 6]

