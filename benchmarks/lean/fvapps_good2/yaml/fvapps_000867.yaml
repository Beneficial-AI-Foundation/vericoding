vc-description: |-

vc-preamble: |-
  def list_max : List Nat → Nat
  | [] => 0
  | [x] => x
  | (x::xs) => Nat.max x (list_max xs)
  
  def iterate_steps (i j steps : Nat) : Nat × Nat :=
    match steps with
    | 0 => (i, j)
    | n+1 =>
      let (cur_i, cur_j) := iterate_steps i j n
      if cur_i ≤ cur_j then
        (cur_i + cur_j, cur_j)
      else
        (cur_i, cur_j + cur_i)

vc-helpers: |-

vc-definitions: |-
  def find_min_steps (i j : Nat) (nums : List Nat) : Nat :=
  sorry

vc-theorems: |-
  theorem find_min_steps_nonnegative {i j : Nat} {nums : List Nat} :
    find_min_steps i j nums ≥ 0 :=
  sorry
  
  theorem find_min_steps_monotonic {i j target : Nat} (hi : i > 1) (hj : j > 1) :
    find_min_steps i j [target] ≤ find_min_steps (i-1) (j-1) [target] :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval find_min_steps 1 2 [5]
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval find_min_steps 2 2 [3, 4]
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval find_min_steps 1 1 [3, 4, 5]
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval find_min_steps 2 1 [5]

