vc-description: |-
  /-
  The Fair Nut is going to travel to the Tree Country, in which there are $n$ cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city $u$ and go by a simple path to city $v$. He hasn't determined the path, so it's time to do it. Note that chosen path can consist of only one vertex.
  
  A filling station is located in every city. Because of strange law, Nut can buy only $w_i$ liters of gasoline in the $i$-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can't choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last.
  
  He also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it.
  
  -----Input-----
  
  The first line contains a single integer $n$ ($1 \leq n \leq 3 \cdot 10^5$) — the number of cities.
  
  The second line contains $n$ integers $w_1, w_2, \ldots, w_n$ ($0 \leq w_{i} \leq 10^9$) — the maximum amounts of liters of gasoline that Nut can buy in cities.
  
  Each of the next $n - 1$ lines describes road and contains three integers $u$, $v$, $c$ ($1 \leq u, v \leq n$, $1 \leq c \leq 10^9$, $u \ne v$), where $u$ and $v$ — cities that are connected by this road and $c$ — its length.
  
  It is guaranteed that graph of road connectivity is a tree.
  
  -----Output-----
  
  Print one number — the maximum amount of gasoline that he can have at the end of the path.
  
  -----Examples-----
  Input
  3
  1 3 3
  1 2 2
  1 3 2
  
  Output
  3
  
  Input
  5
  6 3 2 5 0
  1 2 10
  2 3 3
  2 4 1
  1 5 1
  
  Output
  7
  
  -----Note-----
  
  The optimal way in the first example is $2 \to 1 \to 3$.  [Image] 
  
  The optimal way in the second example is $2 \to 4$.  [Image]
  -/
  
  /- Helper function to get maximum of a list -/
  
  /- Main solve function signature -/
  
  /- Result of solve is always a natural number -/
  
  -- Apps difficulty: competition
  -- Assurance level: unguarded
  
  /- Result is at least the maximum weight in the input weights -/
  
  /- For singleton input, result equals the single weight -/
  
  /- Properties for small cases (n ≤ 3) -/

vc-preamble: |-
  def list_max (xs : List Nat) : Nat :=
  match xs with
  | [] => 0
  | (x::xs) => List.foldl Nat.max x xs

vc-helpers: |-

vc-definitions: |-
  def make_tree_edges (n : Nat) (edge_weights : List Nat) : List (Nat × Nat × Nat) :=
  sorry
  
  def solve (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) : Nat :=
  sorry

vc-theorems: |-
  theorem solve_produces_nat (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) :
    solve n weights roads ≥ 0 :=
  sorry
  
  theorem solve_at_least_max_weight (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat))
    (h : weights ≠ []) :
    solve n weights roads ≥ list_max weights :=
  sorry
  
  theorem solve_singleton (w : Nat) :
    solve 1 [w] [] = w :=
  sorry
  
  theorem solve_small_cases (n : Nat) (weights : List Nat) (h₁ : n ≤ 3) (h₂ : weights.length = n)
    (h₃ : weights ≠ []) :
    let roads := List.map (fun i => (i + 1, i + 2, 1)) (List.range (n-1))
    solve n weights roads ≥ list_max weights :=
  sorry

vc-postamble: |-
  /--
  info: 3
  -/
  #guard_msgs in
  #eval solve 3 [1, 3, 3] [[1, 2, 2], [1, 3, 2]]
  
  /--
  info: 7
  -/
  #guard_msgs in
  #eval solve 5 [6, 3, 2, 5, 0] [[1, 2, 10], [2, 3, 3], [2, 4, 1], [1, 5, 1]]
  
  /--
  info: 42
  -/
  #guard_msgs in
  #eval solve 1 [42] []

