vc-description: |-
  /-
  Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.
  Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].
  
  Example 1:
  Input: [1,17,8]
  Output: 2
  Explanation: 
  [1,8,17] and [17,8,1] are the valid permutations.
  
  Example 2:
  Input: [2,2,2]
  Output: 1
  
  Note:
  
  1 <= A.length <= 12
  0 <= A[i] <= 1e9
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def sqrt (n: Nat) : Nat :=
  sorry
  
  def numSquarefulPerms (A: List Nat) : Nat :=
  sorry
  
  def factorial (n: Nat) : Nat :=
  sorry

vc-theorems: |-
  def isPerfectSquare (n: Nat) : Bool :=
    match n with
    | 0 => true
    | n + 1 =>
      let sq := sqrt n
      sq * sq = n
  
  theorem output_bounds
    (A: List Nat)
    (h1: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :
    let result := numSquarefulPerms A
    0 ≤ result ∧ result ≤ factorial A.length :=
  sorry
  
  theorem valid_permutations
    (A: List Nat)
    (h1: A.length ≥ 2)
    (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)
    (h3: numSquarefulPerms A > 0) :
    ∃ i, i < A.length - 1 ∧ isPerfectSquare (A[i]! + A[i+1]!) :=
  sorry
  
  theorem identical_elements
    (A: List Nat)
    (h1: A.length > 0)
    (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)
    (x: Nat)
    (h3: x = A[0]!) :
    numSquarefulPerms (List.replicate A.length x) = 0 ∨
    numSquarefulPerms (List.replicate A.length x) = 1 :=
  sorry
  
  theorem sorting_invariance
    (A: List Nat)
    (h1: A.length > 0)
    (h2: ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :
    numSquarefulPerms A = numSquarefulPerms (List.reverse A) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval numSquarefulPerms [1, 17, 8]
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval numSquarefulPerms [2, 2, 2]
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval numSquarefulPerms [1, 1]

