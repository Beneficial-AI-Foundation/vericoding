vc-description: |-

vc-preamble: |-
  def list_max (l : List Nat) : Nat :=
    match l with
    | [] => 0
    | [x] => x
    | x::xs => Nat.max x (list_max xs)

vc-helpers: |-

vc-definitions: |-
  def solve_tree_zeros (n : Nat) (edges : List (Nat × Nat)) (values : List Int) : Nat :=
    sorry

vc-theorems: |-
  theorem solve_tree_zeros_nonnegative (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :
    solve_tree_zeros n edges values ≥ 0 :=
  sorry
  
  theorem solve_tree_zeros_finite (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :
    ∃ (k : Nat), solve_tree_zeros n edges values = k :=
  sorry
  
  theorem solve_tree_zeros_bounds (n : Nat) (edges : List (Nat × Nat)) (values : List Int) :
    solve_tree_zeros n edges values ≥ list_max (values.map Int.natAbs) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: guarded
  
  /-
  info: 3
  -/
  #guard_msgs in
  #eval solve_tree_zeros 3 [(1, 2), (1, 3)] [1, -1, 1]
  
  /-
  info: 8
  -/
  #guard_msgs in
  #eval solve_tree_zeros 5 [(2, 3), (4, 5), (2, 5), (1, 3)] [0, 2, 1, 4, 3]
  
  /-
  info: 18
  -/
  #guard_msgs in
  #eval solve_tree_zeros 10 [(5, 6), (8, 2), (9, 3), (4, 1), (6, 10), (9, 8), (7, 10), (7, 4), (5, 2)] [0, -6, -9, -1, -5, -4, -2, -7, -8, -3]

