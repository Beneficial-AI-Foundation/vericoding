vc-description: |-

vc-preamble: |-
  def sumList (l : List Nat) : Nat :=
    l.foldl (·+·) 0

vc-helpers: |-

vc-definitions: |-
  def minimum_steps (arr : List Nat) (n : Nat) : Option Nat :=
    sorry
  
  def List.sort (l : List Nat) : List Nat :=
    sorry

vc-theorems: |-
  theorem minimum_steps_nonnegative (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result → result ≥ 0 :=
  sorry
  
  theorem minimum_steps_less_than_length (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result → result < arr.length :=
  sorry
  
  theorem minimum_steps_sum_sufficient (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result →
    sumList (List.take (result + 1) (arr.sort)) ≥ n :=
  sorry
  
  theorem minimum_steps_sum_necessary (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result →
    result > 0 → sumList (List.take result (arr.sort)) < n :=
  sorry
  
  theorem minimum_steps_sort_invariant (arr : List Nat) (n : Nat) :
    minimum_steps (arr.sort) n = minimum_steps arr n :=
  sorry
  
  theorem minimum_steps_single_element_target_le (x : Nat) (n : Nat) :
    n ≤ x → minimum_steps [x] n = some 0 :=
  sorry
  
  theorem minimum_steps_first_element_sufficient (x y z : Nat) :
    minimum_steps [x, y, z] y = some 0 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
  
  /-
  info: 1
  -/
  #guard_msgs in
  #eval minimum_steps [4, 6, 3] 7
  
  /-
  info: 1
  -/
  #guard_msgs in
  #eval minimum_steps [10, 9, 9, 8] 17
  
  /-
  info: 3
  -/
  #guard_msgs in
  #eval minimum_steps [8, 9, 10, 4, 2] 23

