vc-description: |-
  /-
  We have two integer sequences A and B of the same non-zero length.
  We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.
  At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].)
  Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.
  Example:
  Input: A = [1,3,5,4], B = [1,2,3,7]
  Output: 1
  Explanation: 
  Swap A[3] and B[3].  Then the sequences are:
  A = [1, 3, 5, 7] and B = [1, 2, 3, 4]
  which are both strictly increasing.

  Note:

  A, B are arrays with the same length, and that length will be in the range [1, 1000].
  A[i], B[i] are integer values in the range [0, 2000].
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def minSwapsToIncreasing (A B : List Int) : Nat := sorry 

  def isIncreasing (arr : List Int) : Bool := sorry

vc-theorems: |-
  theorem result_makes_increasing 
    (A B : List Int) 
    (h : A.length = B.length)
    (h2 : minSwapsToIncreasing A B < Nat.max A.length B.length) :
    ∃ possibleA possibleB : List Int,
    (possibleA.length = A.length) ∧ 
    (possibleB.length = B.length) ∧
    (isIncreasing possibleA ∨ isIncreasing possibleB) := sorry

  theorem length_one_arrays
    (x : Int) :
    minSwapsToIncreasing [x] [x] = 0 := sorry

  theorem result_is_non_negative
    (A B : List Int) 
    (h : A.length = B.length) :
    minSwapsToIncreasing A B ≥ 0 := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 1
  -/
  #guard_msgs in
  #eval min_swaps_to_increasing [1, 3, 5, 4] [1, 2, 3, 7]

  /-
  info: 0
  -/
  #guard_msgs in
  #eval min_swaps_to_increasing [1, 2, 3] [4, 5, 6]

  /-
  info: 0
  -/
  #guard_msgs in
  #eval min_swaps_to_increasing [2] [1]

