vc-description: |-
  /-
  You are given a set of `n` segments on the axis `Ox`, each segment has integer endpoints between `0` and `m` inclusive.
   Segments may intersect, overlap or even coincide with each other. Each segment is characterized by two integers li and ri — coordinates of the left and of the right endpoints.

   Consider all integer points between `0` and `m` inclusive. Your task is to print all such points that don't belong to any segment. The point x belongs to the segment `[l;r]` if and only if `l ≤ x ≤ r`.

  **Input:**
   `m` — the upper bound for coordinates;
   array of coordinates li and ri `0 ≤ li ≤ ri ≤ m` — the endpoints of the `i`-th segment. Segments may intersect, overlap or even coincide with each other.

  **Output:**
   All points from `0` to `m` that don't belong to any segment.

  **Examples:**
  ```python
  segments(5, [(2,2),(1,2),(5,5)]) => [0,3,4]
  segments(7, [(0,7)]) => []
  ```
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def segments (m: Nat) (segs: List (Nat × Nat)) : List Nat :=
    sorry

vc-theorems: |-
  theorem empty_segments {m : Nat} (h : m ≤ 100) :
    segments m [] = List.range (m + 1) :=
  sorry

  theorem result_in_bounds {m : Nat} {segs : List (Nat × Nat)} (h : m ≤ 100) :
    ∀ x ∈ segments m segs, 0 ≤ x ∧ x ≤ m :=
  sorry

  theorem result_ordered {m : Nat} {segs : List (Nat × Nat)} (h : m ≤ 100) :
    List.Pairwise (· ≤ ·) (segments m segs) :=
  sorry

  theorem not_covered_by_segments {m : Nat} {segs : List (Nat × Nat)} (h : m ≤ 100) :
    ∀ x ∈ segments m segs,
      ∀ seg ∈ segs, ¬(seg.1 ≤ x ∧ x ≤ seg.2) :=
  sorry

  theorem missing_covered_by_segments {m : Nat} {segs : List (Nat × Nat)} (h : m ≤ 100) :
    ∀ x ≤ m, x ∉ segments m segs →
      ∃ seg ∈ segs, seg.1 ≤ x ∧ x ≤ seg.2 :=
  sorry

  theorem full_coverage {m : Nat} (h : m ≤ 100) :
    segments m [(0,m)] = [] :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: []
  -/
  #guard_msgs in
  #eval segments 7 [[0, 7]]

  /--
  info: [0, 1, 2]
  -/
  #guard_msgs in
  #eval segments 2 []

  /--
  info: [0, 3, 4]
  -/
  #guard_msgs in
  #eval segments 5 [[2, 2], [1, 2], [5, 5]]

