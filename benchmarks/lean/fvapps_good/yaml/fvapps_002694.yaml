vc-description: |-
  /-
  # Task

  You are given an array `a` of positive integers a. You may choose some integer `X` and update `a` several times, where to update means to perform the following operations:
  ```
  pick a contiguous subarray of length not greater than the given k;
  replace all elements in the picked subarray with the chosen X.
  ```
  What is the minimum number of updates required to make all the elements of the array the same?

  # Example

  For `a = [1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] and k = 2`, the output should be `4`.

  Here's how a will look like after each update:
  ```
  [1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] ->
  [1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1] ->
  [1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1] ->
  [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1] ->
  [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  ```

  # Input/Output

   - `[input]` integer array `a`

    An array of positive integers.

    Constraints:

    `10 ≤ a.length ≤ 50,`

    `1 ≤ a[i] ≤ 10.`

   - `[input]` integer `k`

    A positive integer, the maximum length of a subarray.

    Constraints: `2 ≤ k ≤ 9.`

   - `[output]` an integer

    The minimum number of updates.
  -/

vc-preamble: |-
  def countOccurrences (arr : List Nat) (x : Nat) : Nat :=
    (arr.filter (· == x)).length

  def getMode (arr : List Nat) : Nat :=
    match arr with
    | [] => 0
    | x::xs => (arr.foldl 
      (fun acc y => if countOccurrences arr y > countOccurrences arr acc then y else acc) 
      x)

vc-helpers: |

vc-definitions: |-
  def arrayEqualization (arr : List Nat) (k : Nat) : Nat := sorry

  theorem equals_one_theorem (arr : List Nat) (h1 : arr.length > 0)
      (h2 : ∀ x ∈ arr, x ≥ 1 ∧ x ≤ 3) : 
    arrayEqualization arr 1 = (arr.filter (· ≠ getMode arr)).length := sorry

vc-theorems: |-
  theorem identical_elements_theorem (arr : List Nat) (k : Nat)
      (h1 : arr.length > 0)
      (h2 : k ≥ 1)
      (h3 : k ≤ 10)
      (h4 : ∀ x ∈ arr, x = 1) :
    arrayEqualization arr k = 0 := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 4
  -/
  #guard_msgs in
  #eval array_equalization [1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] 2

  /-
  info: 2
  -/
  #guard_msgs in
  #eval array_equalization [5, 2, 3, 5, 2, 2, 3, 5, 1, 2, 5, 1, 2, 5, 3] 7

  /-
  info: 1
  -/
  #guard_msgs in
  #eval array_equalization [1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1] 9

