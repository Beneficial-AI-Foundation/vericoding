vc-description: |-
  /-
  A simple string contains a large repetition of letters within it. This problem is related to string handling and manipulation.  An original message is sent from planet Earth to planet Cybertron in form of a string. However, the letter position and string size is not important. The number of time each letter has occurred in the string is important. So the original string which is sent to Cybertron is encrypted in the new string which comprises the letters followed by each time it has occurred in the original string. Eg- original message is- abcdabf. Then the encrypted string is- a2b2c1d1f1

  -----Input-----
  The input consists of a single line string without any space or numeric or special characters.

  -----Output-----
  It will consist of in the encrypted string which comprises the letters followed by each time it has occurred in the original string in order.

  -----Example-----
  Input:
  information

  Output:
  i2n2f1o2r1m1a1t1
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def encrypt_message (s : String) : String :=
    sorry

vc-theorems: |-
  theorem encrypt_message_alternating_pattern (s : String) (h : ∀ c ∈ s.data, 97 ≤ c.val ∧ c.val ≤ 122) :
    let result := encrypt_message s
    ∀ i < result.length - 1, i % 2 = 0 →
      Option.isSome (result.data[i]?) ∧ 
      (result.data[i]?.get!).isAlpha = true ∧
      Option.isSome (result.data[i+1]?) ∧
      (result.data[i+1]?.get!).isDigit = true
    := sorry

  theorem encrypt_message_accurate_counts (s : String) (h : ∀ c ∈ s.data, 97 ≤ c.val ∧ c.val ≤ 122) :
    let result := encrypt_message s
    ∀ c ∈ s.data,
      let count := (s.data.filter (· = c)).length
      ∃ i < result.length,
        Option.isSome (result.data[i]?) ∧
        result.data[i]?.get! = c ∧
        Option.isSome (result.data[i+1]?) ∧
        String.toNat? (toString (result.data[i+1]?.get!)) = some count
    := sorry

  theorem encrypt_message_preserves_order (s : String) (h : ∀ c ∈ s.data, 97 ≤ c.val ∧ c.val ≤ 122) :
    let result := encrypt_message s
    let input_first_occurrences := s.data.foldl (λ acc c => if c ∈ acc then acc else acc ++ [c]) []
    let result_chars := List.filter (λ c => c.isAlpha) result.data
    input_first_occurrences = result_chars
    := sorry

  theorem encrypt_message_length (s : String) (h : s.length > 0) (h₂ : ∀ c ∈ s.data, 97 ≤ c.val ∧ c.val ≤ 122) :
    (encrypt_message s).length = 2 * (s.data.eraseDups).length
    := sorry

  theorem encrypt_message_empty :
    encrypt_message "" = ""
    := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 'i2n2f1o2r1m1a1t1'
  -/
  #guard_msgs in
  #eval encrypt_message "information"

  /-
  info: 'a2b2c1d1f1'
  -/
  #guard_msgs in
  #eval encrypt_message "abcdabf"

  /-
  info: 'a3'
  -/
  #guard_msgs in
  #eval encrypt_message "aaa"

