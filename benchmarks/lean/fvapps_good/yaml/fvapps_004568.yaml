vc-description: |-
  /-
  __Function composition__ is a mathematical operation that mainly presents itself in lambda calculus and computability. It is explained well [here](http://www.mathsisfun.com/sets/functions-composition.html), but this is my explanation, in simple mathematical notation:

  ```
  f3 = compose( f1 f2 )
     Is equivalent to...
  f3(a) = f1( f2( a ) )
  ```

  Your task is to create a `compose` function to carry out this task, which will be passed two functions or lambdas. Ruby functions will be passed, and should return, either a proc or a lambda. Remember that the resulting composed function may be passed multiple arguments!

  ```python
  compose(f , g)(x)
  => f( g( x ) )
  ```

  This kata is not available in haskell; that would be too easy!
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def compose (f : β → γ) (g : α → β) : α → γ := sorry

  theorem numeric_composition (x : Int) :
    let f := (fun x => x + 1)
    let g := (fun x => x * 2)
    compose f g x = f (g x) := sorry

vc-theorems: |-
  theorem string_composition (s : String) :
    let f := (fun x => x ++ "!")
    let g := String.toUpper
    compose f g s = f (g s) := sorry

  -- Simplified version without List.sum

  theorem multiple_args (x : Int) :
    let f := (fun x => x + 1)
    let g := (fun x => x)
    compose f g x = f (g x) := sorry

  theorem type_preservation (x : Int) :
    let f := (fun _ => Type)
    let g := toString
    compose f g x = f (g x) := sorry

  theorem identity_composition (x : Int) :
    let f := (fun x => x)
    let g := (fun x => x)
    compose f g x = x := sorry

  theorem nested_composition (x : Int) :
    let f := (fun x => x + 1)
    let g := (fun x => x * 2)
    let h := (fun x => x - 3)
    compose (compose f g) h x = f (g (h x)) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 7
  -/
  #guard_msgs in
  #eval fn 3

  /-
  info: 'HELLO!'
  -/
  #guard_msgs in
  #eval fn "hello"

  /-
  info: 6
  -/
  #guard_msgs in
  #eval fn 1 2 3

