vc-description: |-
  /-
  ```if:python 
  Note: Python may currently have some performance issues. If you find them, please let me know and provide suggestions to improve the Python version! It's my weakest language... any help is much appreciated :)
  ```

  Artlessly stolen and adapted from Hackerrank.

  Kara Danvers is new to CodeWars, and eager to climb up in the ranks. We want to determine Kara's rank as she progresses up the leaderboard. 

  This kata uses Dense Ranking, so any identical scores count as the same rank (e.g, a scoreboard of `[100, 97, 97, 90, 82, 80, 72, 72, 60]` corresponds with rankings of `[1, 2, 2, 3, 4, 5, 6, 6, 7]`

  You are given an array, `scores`, of leaderboard scores, descending, and another array, `kara`, representing Kara's Codewars score over time, ascending. Your function should return an array with each item corresponding to the rank of Kara's current score on the leaderboard.

  **Note:** This kata's performance requirements are significantly steeper than the Hackerrank version. Some arrays will contain millions of elements; optimize your code so you don't time out. If you're timing out before 200 tests are completed, you've likely got the wrong code complexity. If you're timing out around 274 tests (there are 278), you likely need to make some tweaks to how you're handling the arrays.

  Examples:

  (For the uninitiated, Kara Danvers is Supergirl. This is important, because Kara thinks and moves so fast that she can complete a kata within microseconds. Naturally, latency being what it is, she's already opened many kata across many, many tabs, and solves them one by one on a special keyboard so she doesn't have to wait hundreds of milliseconds in between solving them. As a result, the only person's rank changing on the leaderboard is Kara's, so we don't have to worry about shifting values of other codewarriors. Thanks, Supergirl.)

  Good luck! Please upvote if you enjoyed it :)
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def leaderboard_climb (scores: List Nat) (kara: List Nat) : List (List Nat) := sorry 

  theorem leaderboard_climb_rank_count 
    (scores: List Nat) (kara: List Nat) (h: scores.length > 0) (h2: kara.length > 0) :
    let result := leaderboard_climb scores kara
    result.length = 1 ∧ 
    result.head!.length = kara.length := sorry

vc-theorems: |-
  theorem leaderboard_climb_ranks_positive
    (scores: List Nat) (kara: List Nat) (h: scores.length > 0) (h2: kara.length > 0) :
    let result := leaderboard_climb scores kara
    ∀ x ∈ result.head!, x > 0 := sorry

  theorem leaderboard_climb_max_rank
    (scores: List Nat) (kara: List Nat) (h: scores.length > 0) (h2: kara.length > 0) :
    let result := leaderboard_climb scores kara
    let unique_scores := List.eraseDups scores
    let max_rank := unique_scores.length + 1
    ∀ x ∈ result.head!, x ≤ max_rank := sorry

  theorem leaderboard_climb_monotonic
    (scores: List Nat) (kara: List Nat) (h: scores.length > 0) (h2: kara.length > 0) :
    let result := leaderboard_climb scores kara
    ∀ i < kara.length - 1,
      kara[i]! ≤ kara[i+1]! → result.head![i]! ≥ result.head![i+1]! := sorry

  theorem leaderboard_climb_duplicate_invariant
    (scores: List Nat) (kara: List Nat) (h: scores.length > 0) (h2: kara.length > 0) :
    leaderboard_climb scores kara = leaderboard_climb (scores ++ scores) kara := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: [[4, 3, 1]]
  -/
  #guard_msgs in
  #eval leaderboard_climb [100, 90, 90, 80] [70, 80, 105]

  /--
  info: [[4, 4, 2, 1]]
  -/
  #guard_msgs in
  #eval leaderboard_climb [982, 490, 339, 180] [180, 250, 721, 2500]

  /--
  info: [[4, 4, 1, 1]]
  -/
  #guard_msgs in
  #eval leaderboard_climb [1079, 490, 339, 180] [180, 250, 1200, 1980]

