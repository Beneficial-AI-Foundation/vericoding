vc-description: |-
  /-
  Our AAA company is in need of some software to help with logistics: you will be given the width and height of a map, a list of x coordinates and a list of y coordinates of the supply points, starting to count from the top left corner of the map as 0.

  Your goal is to return a two dimensional array/list with every item having the value of the distance of the square itself from the closest supply point expressed as a simple integer.

  Quick examples:

  ```python
  logistic_map(3,3,[0],[0])
  #returns
  #[[0,1,2],
  # [1,2,3],
  # [2,3,4]]
  logistic_map(5,2,[0,4],[0,0])
  #returns
  #[[0,1,2,1,0],
  # [1,2,3,2,1]]
  ```

  Remember that our company is operating with trucks, not drones, so you can simply use Manhattan distance. If supply points are present, they are going to be within the boundaries of the map; if no supply point is present on the map, just return `None`/`nil`/`null` in every cell.

  ```python
  logistic_map(2,2,[],[])
  #returns
  #[[None,None],
  # [None,None]]
  ```

  **Note:** this one is taken (and a bit complicated) from a problem a real world AAA company [whose name I won't tell here] used in their interview. It was done by a friend of mine. It is nothing that difficult and I assume it is their own version of the FizzBuzz problem, but consider candidates were given about 30 mins to solve it.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def logistic_map (width height : Nat) (xs ys : List Nat) : List (List (Option Nat)) := sorry

  theorem logistic_map_dimensions (width height : Nat) (xs ys : List Nat) :
    let result := logistic_map width height xs ys
    result.length = height ∧ 
    ∀ row ∈ result, row.length = width := sorry

vc-theorems: |-
  theorem logistic_map_empty_input (width height : Nat) :
    let result := logistic_map width height [] []
    ∀ row ∈ result, ∀ cell ∈ row, cell = none := sorry

  theorem logistic_map_supply_points (width height : Nat) (xs ys : List Nat) :
    ∀ (x y : Nat), x ∈ xs → y ∈ ys → x < width → y < height →
    (logistic_map width height xs ys).get? y >>= (·.get? x) = some (some 0) := sorry

  theorem logistic_map_triangle_inequality (width height : Nat) (xs ys : List Nat) :
    let result := logistic_map width height xs ys
    (∀ y < height, ∀ x < width - 1,
      ∀ v1 v2, result.get? y >>= (·.get? x) = some (some v1) → 
      result.get? y >>= (·.get? (x+1)) = some (some v2) → 
      v1 ≤ v2 + 1 ∧ v2 ≤ v1 + 1) ∧
    (∀ y < height - 1, ∀ x < width,
      ∀ v1 v2, result.get? y >>= (·.get? x) = some (some v1) → 
      result.get? (y+1) >>= (·.get? x) = some (some v2) →
      v1 ≤ v2 + 1 ∧ v2 ≤ v1 + 1) := sorry

  theorem logistic_map_single_point (width height : Nat) :
    let result := logistic_map width height [0] [0]
    width > 0 → height > 0 →
    result.get? 0 >>= (·.get? 0) = some (some 0) ∧
    ∀ y < height, ∀ x < width,
      result.get? y >>= (·.get? x) = some (some (x + y)) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: expected1
  -/
  #guard_msgs in
  #eval logistic_map 3 3 [0] [0]

  /--
  info: expected2
  -/
  #guard_msgs in
  #eval logistic_map 5 2 [0, 4] [0, 0]

  /--
  info: expected3
  -/
  #guard_msgs in
  #eval logistic_map 2 2 [] []

