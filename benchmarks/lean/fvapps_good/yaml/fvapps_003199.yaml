vc-description: |-
  /-
  Given a side length `n`, traveling only right and down how many ways are there to get from the top left corner to the bottom right corner of an `n by n` grid?

  Your mission is to write a program to do just that!

  Add code to `route(n)` that returns the number of routes for a grid `n by n` (if n is less than 1 return 0).

  Examples:

      -100 -> 0

      1 -> 2

      2 -> 6

      20 -> 137846528820

  Note: 
  you're traveling on the edges of the squares in the grid not the squares themselves.

  PS.If anyone has any suggestions of how to improve this kata please let me know.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def routes (n : Int) : Int := sorry

  def factorial (n : Int) : Int := sorry

vc-theorems: |-
  theorem routes_formula {n : Int} (h : n > 0) : 
    routes n = factorial (2*n) / (factorial n * factorial n) := sorry

  theorem routes_non_positive {n : Int} (h : n ≤ 0) :
    routes n = 0 := sorry

  theorem routes_monotonic {n : Int} (h1 : n > 1) :
    routes n > routes (n-1) := sorry 

  theorem routes_initial_values :
    routes 1 = 2 ∧ routes 2 = 6 ∧ routes 3 = 20 := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: 2
  -/
  #guard_msgs in
  #eval routes 1

  /--
  info: 6
  -/
  #guard_msgs in
  #eval routes 2

  /--
  info: 0
  -/
  #guard_msgs in
  #eval routes -100

