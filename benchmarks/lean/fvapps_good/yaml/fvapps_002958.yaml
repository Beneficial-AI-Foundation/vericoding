vc-description: |-
  /-
  # Task
   You are given an array of integers `arr` that representing coordinates of obstacles situated on a straight line.

   Assume that you are jumping from the point with coordinate 0 to the right. You are allowed only to make jumps of the same length represented by some integer.

   Find the minimal length of the jump enough to avoid all the obstacles.

  # Example

   For `arr = [5, 3, 6, 7, 9]`, the output should be `4`.

   Check out the image below for better understanding:

  # Input/Output

   - `[input]` integer array `arr`

      Non-empty array of positive integers.

      Constraints: `1 ≤ inputArray[i] ≤ 100.`

   - `[output]` an integer

      The desired length.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def avoid_obstacles (obstacles : List Nat) : Nat := sorry

  theorem avoid_obstacles_jumps_over_all (obstacles : List Nat)
    (h1 : ∀ x ∈ obstacles, 1 ≤ x ∧ x ≤ 1000)
    (h2 : obstacles.length ≥ 1 ∧ obstacles.length ≤ 100) :
    let jump := avoid_obstacles obstacles
    2 ≤ jump ∧ ∀ pos ∈ obstacles, pos % jump ≠ 0 := sorry

vc-theorems: |-
  theorem avoid_obstacles_monotonic_with_subset (obstacles : List Nat)
    (h1 : ∀ x ∈ obstacles, 1 ≤ x ∧ x ≤ 50)
    (h2 : obstacles.length ≥ 2 ∧ obstacles.length ≤ 10) :
    avoid_obstacles obstacles ≥ avoid_obstacles (obstacles.take (obstacles.length / 2)) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /--
  info: 4
  -/
  #guard_msgs in
  #eval avoid_obstacles [5, 3, 6, 7, 9]

  /--
  info: 4
  -/
  #guard_msgs in
  #eval avoid_obstacles [2, 3]

  /--
  info: 7
  -/
  #guard_msgs in
  #eval avoid_obstacles [1, 4, 10, 6, 2]

