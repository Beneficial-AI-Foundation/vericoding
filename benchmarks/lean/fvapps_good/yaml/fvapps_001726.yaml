vc-description: |-
  /-
  A *[Hamming number][1]* is a positive integer of the form 2*i*3*j*5*k*, for some non-negative integers *i*, *j*, and *k*.

  Write a function that computes the *n*th smallest Hamming number. 

  Specifically:

    - The first smallest Hamming number is 1 = 2^(0)3^(0)5^(0)
    - The second smallest Hamming number is 2 = 2^(1)3^(0)5^(0)
    - The third smallest Hamming number is 3 = 2^(0)3^(1)5^(0)
    - The fourth smallest Hamming number is 4 = 2^(2)3^(0)5^(0)
    - The fifth smallest Hamming number is 5 = 2^(0)3^(0)5^(1)

  The 20 smallest Hamming numbers are given in example test fixture.

  Your code should be able to compute all of the smallest 5,000 (Clojure: 2000, NASM: 13282) Hamming numbers without timing out.

  [1]:https://en.wikipedia.org/wiki/Regular_number
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def hamming (n : Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem hamming_positive (n : Nat) (h : n > 0) :
    hamming n > 0 :=
  sorry

  theorem hamming_strictly_increasing (n : Nat) (h : n > 1) :
    hamming n > hamming (n-1) :=
  sorry

  theorem hamming_monotone (n1 n2 : Nat) (h1 : n1 > 0) (h2 : n2 > 0) :
    n1 ≤ n2 → hamming n1 ≤ hamming n2 :=
  sorry

  theorem hamming_first_values :
    hamming 1 = 1 ∧ hamming 2 = 2 ∧ hamming 3 = 3 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

  /--
  info: 1
  -/
  #guard_msgs in
  #eval hamming 1

  /--
  info: 2
  -/
  #guard_msgs in
  #eval hamming 2

  /--
  info: 3
  -/
  #guard_msgs in
  #eval hamming 3

  /--
  info: 4
  -/
  #guard_msgs in
  #eval hamming 4

  /--
  info: 5
  -/
  #guard_msgs in
  #eval hamming 5

  /--
  info: 36
  -/
  #guard_msgs in
  #eval hamming 20

