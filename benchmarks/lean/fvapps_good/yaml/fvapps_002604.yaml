vc-description: |-
  /-
  You are given an array that of arbitrary depth that needs to be nearly flattened into a 2 dimensional array. The given array's depth is also non-uniform, so some parts may be deeper than others.

  All of lowest level arrays (most deeply nested) will contain only integers and none of the higher level arrays will contain anything but other arrays. All arrays given will be at least 2 dimensional. All lowest level arrays will contain at least one element.

  Your solution should be an array containing all of the lowest level arrays and only these. The sub-arrays should be ordered by the smallest element within each, so `[1,2]` should preceed `[3,4,5]`. Note: integers will not be repeated.

  For example:

  If you receive `[[[1,2,3],[4,5]],[6,7]]`, your answer should be `[[1,2,3],[4,5],[6,7]]`.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def near_flatten (arr: List (List (List Int))) : List (List Int) := sorry

  def list_min (l: List Int) : Int :=
    match l with
    | [] => 0
    | x::xs => xs.foldl min x

vc-theorems: |-
  theorem near_flatten_keeps_list_structure (arr: List (List (List Int))) : 
    let result := near_flatten arr
    -- Result is a list of lists of integers
    ∀ x ∈ result, x.all (fun i => true)
    := sorry

  theorem near_flatten_sorted (arr: List (List (List Int))) :
    let result := near_flatten arr
    ∀ i, i + 1 < result.length →
      list_min (result.get ⟨i, by sorry⟩) ≤ list_min (result.get ⟨i+1, by sorry⟩)
    := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: [[1]]
  -/
  #guard_msgs in
  #eval near_flatten [[[1]]]

  /-
  info: [[1, 2, 3], [4, 5, 6]]
  -/
  #guard_msgs in
  #eval near_flatten [[[1, 2, 3], [4, 5, 6]]]

  /-
  info: [[1, 2, 3], [4, 5], [6], [7, 8]]
  -/
  #guard_msgs in
  #eval near_flatten [[[1, 2, 3], [[4, 5], [[6], [7, 8]]]]]

