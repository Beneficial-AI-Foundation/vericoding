vc-description: |-
  /-
  Assume we take a number `x` and perform any one of the following operations:
  ```Pearl
  a) Divide x by 3 (if it is divisible by 3), or
  b) Multiply x by 2
  ```
  After each operation, we write down the result. If we start with `9`, we can get a sequence such as:
  ```
  [9,3,6,12,4,8] -- 9/3=3 -> 3*2=6 -> 6*2=12 -> 12/3=4 -> 4*2=8
  ```
  You will be given a shuffled sequence of integers and your task is to reorder them so that they conform to the above sequence. There will always be an answer. 
  ```
  For the above example:
  solve([12,3,9,4,6,8]) = [9,3,6,12,4,8].
  ```

  More examples in the test cases. Good luck!
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def solve (arr : List Nat) : Option (List Nat) := sorry

  theorem solve_preserves_length {arr : List Nat} {result : List Nat} :
    solve arr = some result → result.length = arr.length := sorry

vc-theorems: |-
  theorem solve_preserves_elements {arr : List Nat} {result : List Nat} :
    solve arr = some result → 
    ∀ x, x ∈ arr ↔ x ∈ result := sorry

  theorem solve_adjacent_pairs_rule {arr : List Nat} {result : List Nat} :
    solve arr = some result →
    ∀ i, i < result.length - 1 → 
      (result[i]! * 2 = result[i+1]! ∨ result[i]! = result[i+1]! * 3) := sorry

  theorem solve_duplicates {arr : List Nat} :
    ¬arr.Nodup → solve arr = none := sorry 

  theorem solve_empty :
    solve [] = none := sorry

  theorem solve_single (n : Nat) :
    solve [n] = some [n] := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: [9, 3, 6, 12, 4, 8]
  -/
  #guard_msgs in
  #eval solve [12, 3, 9, 4, 6, 8]

  /-
  info: [2, 4]
  -/
  #guard_msgs in
  #eval solve test2

  /-
  info: [279, 558, 1116, 2232, 744, 1488]
  -/
  #guard_msgs in
  #eval solve test3

