vc-description: |-
  /-
  Take the following IPv4 address:  128.32.10.1
  This address has 4 octets where each octet is a single byte (or 8 bits).

  * 1st octet 128 has the binary representation: 10000000
  * 2nd octet 32 has the binary representation: 00100000
  * 3rd octet 10 has the binary representation: 00001010
  * 4th octet 1 has the binary representation: 00000001

  So 128.32.10.1 == 10000000.00100000.00001010.00000001

  Because the above IP address has 32 bits, we can represent it as the 32
  bit number: 2149583361.

  Write a function ip_to_int32(ip) ( **JS**: `ipToInt32(ip)` ) that takes an IPv4 address and returns
  a 32 bit number.

  ```python
    ip_to_int32("128.32.10.1") => 2149583361
  ```
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def ipToInt32 (ip: String) : Nat :=
    sorry

vc-theorems: |-
  theorem ipToInt32_in_range (a b c d: Nat)
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    let result := ipToInt32 ip
    0 ≤ result ∧ result ≤ 4294967295 :=
  sorry

  theorem ipToInt32_bitwise_composition (a b c d: Nat) 
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    ipToInt32 ip = (a <<< 24) + (b <<< 16) + (c <<< 8) + d :=
  sorry

  theorem ipToInt32_roundtrip_a (a b c d: Nat)
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    let result := ipToInt32 ip
    a = (result >>> 24) &&& 255 :=
  sorry

  theorem ipToInt32_roundtrip_b (a b c d: Nat)
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    let result := ipToInt32 ip
    b = (result >>> 16) &&& 255 :=
  sorry

  theorem ipToInt32_roundtrip_c (a b c d: Nat)
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    let result := ipToInt32 ip
    c = (result >>> 8) &&& 255 :=
  sorry

  theorem ipToInt32_roundtrip_d (a b c d: Nat)
    (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :
    let ip := s!"{a}.{b}.{c}.{d}"
    let result := ipToInt32 ip
    d = result &&& 255 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /--
  info: 2149583361
  -/
  #guard_msgs in
  #eval ip_to_int32 "128.32.10.1"

  /--
  info: 0
  -/
  #guard_msgs in
  #eval ip_to_int32 "0.0.0.0"

  /--
  info: 4294967295
  -/
  #guard_msgs in
  #eval ip_to_int32 "255.255.255.255"

