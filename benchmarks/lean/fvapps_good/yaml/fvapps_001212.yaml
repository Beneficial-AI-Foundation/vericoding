vc-description: |-
  /-
  You are teaching students to generate strings consisting of unique lowercase latin characters (a-z). You give an example reference string $s$ to the students.
  You notice that your students just copy paste the reference string instead of creating their own string. So, you tweak the requirements for strings submitted by the students.
  Let us define a function F(s, t) where s and t are strings as the number of characters that are same in both the strings. Note that the position doesn't matter. Here are a few examples of F(s, t):
  F("abc", "def") = 0
  F("abc", "acb") = 3
  F("back", "abcd") = 3
  Now you ask your students to output a string t with lowercase unique characters of the same length as $s$, such that F(s, t) $\leq k$ where you are also given the value of $k$. If there are multiple such strings, you ask them to output the lexicographically smallest possible string. If no such string is possible, output the string "NOPE" without quotes.

  -----Input:-----
  - The first line will contain $T$, the number of testcases. Then the testcases follow. 
  - Each testcase contains of a single line of input, which contains a string $s$ and an integer $k$.

  -----Output:-----
  For each testcase, output in a single line the lexicographically smallest string t such that F(s, t) <= k or "NOPE" without quotes if no such string exists.

  -----Constraints-----
  - $1 \leq T \leq 10000$
  - $1 \leq $length of string s $(|s|) \leq 26$
  - $s$ only consists of characters $a$ to $z$
  - There are no repeating characters in s
  - $0 \leq k \leq |s|$

  -----Sample Input:-----
  4
  helowrd 0
  background 0
  abcdefghijklmnopqrstuvwxyz 0
  b 1

  -----Sample Output:-----
  abcfgij
  efhijlmpqs
  NOPE
  a
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def solve_unique_string (s : List Char) (k : Nat) : List Char := sorry

  theorem solve_unique_string_properties 
    (s : List Char) (k : Nat) (result : List Char)
    (h : result = solve_unique_string s k)
    (h₁ : result ≠ []) :
    List.length result = List.length s ∧ 
    (∀ i j, i < j → j < List.length result → List.get! result i ≤ List.get! result j) ∧
    List.length (List.filter (fun c => c ∈ s) result) ≤ k ∧
    (∀ c ∈ result, c.isLower) ∧
    List.length result = List.length (List.eraseDups result) := sorry

vc-theorems: |-
  theorem solve_zero_k_property
    (s : List Char) (result : List Char) 
    (h : result = solve_unique_string s 0)
    (h₁ : result ≠ []) :
    ∀ c ∈ result, c ∉ s := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 'abcfgij'
  -/
  #guard_msgs in
  #eval solve_unique_string "helowrd" 0

  /-
  info: 'efhijlmpqs'
  -/
  #guard_msgs in
  #eval solve_unique_string "background" 0

  /-
  info: 'a'
  -/
  #guard_msgs in
  #eval solve_unique_string "b" 1

