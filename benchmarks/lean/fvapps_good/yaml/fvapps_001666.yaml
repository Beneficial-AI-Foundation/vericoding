vc-description: |-
  /-
  Ever heard about Dijkstra's shallowest path algorithm? Me neither. But I can imagine what it would be.

  You're hiking in the wilderness of Northern Canada and you must cross a large river. You have a map of one of the safer places to cross the river showing the depths of the water on a rectangular grid. When crossing the river you can only move from a cell to one of the (up to 8) neighboring cells. You can start anywhere along the left river bank, but you have to stay on the map.

  An example of the depths provided on the map is 

  ```
  [[2, 3, 2],
   [1, 1, 4],
   [9, 5, 2],
   [1, 4, 4],
   [1, 5, 4],
   [2, 1, 4],
   [5, 1, 2],
   [5, 5, 5],
   [8, 1, 9]]
  ```
  If you study these numbers, you'll see that there is a path accross the river (from left to right) where the depth never exceeds 2. This path can be described by the list of pairs `[(1, 0), (1, 1), (2, 2)]`. There are also other paths of equal maximum depth, e.g., `[(1, 0), (1, 1), (0, 2)]`. The pairs denote the cells on the path where the first element in each pair is the row and the second element is the column of a cell on the path.

  Your job is to write a function `shallowest_path(river)` that takes a list of lists of positive ints (or array of arrays, depending on language) showing the depths of the river as shown in the example above and returns a shallowest path (i.e., the maximum depth is minimal) as a list of coordinate pairs (represented as tuples, Pairs, or arrays, depending on language) as described above. If there are several paths that are equally shallow, the function shall return a shortest such path. All depths are given as positive integers.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def shallowest_path (river : List (List Int)) : List (Int × Int) := sorry

  def abs (n : Int) : Int := 
    if n < 0 then -n else n

  -- Given any valid river array:
  -- 1. Path starts at first column
  -- 2. Path ends at last column  
  -- 3. Path is contiguous with only adjacent moves allowed
  -- 4. All coordinates are valid

vc-theorems: |-
  theorem path_properties {river : List (List Int)} (h : river.length > 0) (h2 : ∀ (row : List Int), row ∈ river → row.length = (List.head! river).length) :
    let path := shallowest_path river
    -- Path starts at first column
    (∀ p ∈ path, (List.head! path).2 = 0) ∧ 
    -- Path ends at last column
    ((List.head! river).length - 1 = (List.get! path (path.length - 1)).2) ∧
    -- Path is contiguous
    (∀ i < path.length - 1, 
      let p1 := List.get! path i
      let p2 := List.get! path (i+1)
      abs (p2.1 - p1.1) ≤ 1 ∧ 
      abs (p2.2 - p1.2) ≤ 1 ∧
      (p2.1 ≠ p1.1 ∨ p2.2 ≠ p1.2)) ∧
    -- All coordinates are valid
    (∀ p ∈ path, p.1 ≥ 0 ∧ p.1 < river.length ∧ p.2 ≥ 0 ∧ p.2 < (List.head! river).length) :=
    sorry

  -- For a single column river:
  -- Path has length 1 and is at first column

  theorem single_column_path {river : List (List Int)} (h : ∀ row ∈ river, row.length = 1) :
    let path := shallowest_path river
    path.length = 1 ∧ (List.head! path).2 = 0 :=
    sorry

  -- For a single row river:
  -- All x coordinates are 0 and ends at first column 

  theorem single_row_path {river : List (List Int)} (h : river.length = 1) :
    let path := shallowest_path river
    (∀ p ∈ path, p.1 = 0) ∧ (List.get! path (path.length - 1)).2 = 0 :=
    sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: [(1, 0), (1, 1), (0, 2)]
  -/
  #guard_msgs in
  #eval shallowest_path [[2, 3, 2], [1, 1, 4], [9, 5, 2], [1, 4, 4], [1, 5, 4], [2, 1, 4], [5, 1, 2], [5, 5, 5], [8, 1, 9]]

  /-
  info: [(0, 0), (0, 1), (0, 2)]
  -/
  #guard_msgs in
  #eval shallowest_path [[1, 2, 1]]

  /-
  info: [(0, 0)]
  -/
  #guard_msgs in
  #eval shallowest_path [[1], [2], [3]]

