{"id": "fvapps_000006", "vc-description": "/-\nArthur owns a ski resort on a mountain. There are $n$ landing spots on the mountain numbered from $1$ to $n$ from the top to the foot of the mountain. The spots are connected with one-directional ski tracks. All tracks go towards the foot of the mountain, so there are no directed cycles formed by the tracks. There are at most two tracks leaving each spot, but many tracks may enter the same spot.\n\nA skier can start skiing from one spot and stop in another spot if there is a sequence of tracks that lead from the starting spot and end in the ending spot. Unfortunately, recently there were many accidents, because the structure of the resort allows a skier to go through dangerous paths, by reaching high speed and endangering himself and the other customers. Here, a path is called dangerous, if it consists of at least two tracks.\n\nArthur wants to secure his customers by closing some of the spots in a way that there are no dangerous paths in the resort. When a spot is closed, all tracks entering and leaving that spot become unusable. \n\nFormally, after closing some of the spots, there should not be a path that consists of two or more tracks.\n\nArthur doesn't want to close too many spots. He will be happy to find any way to close at most $\\frac{4}{7}n$ spots so that the remaining part is safe. Help him find any suitable way to do so.\n\n-----Input-----\n\nThe first line contains a single positive integer $T$ — the number of test cases. $T$ test case description follows.\n\nThe first line of each description contains two integers $n$ and $m$ ($1 \\leq n \\leq 2 \\cdot 10^5$) — the number of landing spots and tracks respectively.\n\nThe following $m$ lines describe the tracks. Each of these lines contains two integers $x$ and $y$ ($1 \\leq x < y \\leq n$) — indices of the starting and finishing spots for the respective track. It is guaranteed that at most two tracks start at each spot. There may be tracks in which starting and finishing spots both coincide.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, print a single integer $k$ ($0 \\leq k \\leq \\frac{4}{7}n$) — the number of spots to be closed. In the next line, print $k$ distinct integers — indices of all spots to be closed, in any order.\n\nIf there are several answers, you may output any of them. Note that you don't have to minimize $k$. It can be shown that a suitable answer always exists.\n\n-----Example-----\nInput\n2\n4 6\n1 2\n1 3\n2 3\n2 4\n3 4\n3 4\n7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\nOutput\n2\n3 4 \n4\n4 5 6 7 \n\n-----Note-----\n\nIn the first sample case, closing any two spots is suitable.\n\nIn the second sample case, closing only the spot $1$ is also suitable.\n-/", "vc-preamble": "def valid_track (n : Nat) (track : Nat × Nat) : Prop :=\n  let (u, v) := track\n  1 ≤ u ∧ u ≤ n ∧ 1 ≤ v ∧ v ≤ n ∧ u ≠ v", "vc-helpers": "", "vc-definitions": "def solve_ski_resort : List (Nat × Nat × List (Nat × Nat)) → List (Nat × List Nat) := sorry\n\ntheorem ski_resort_result_valid \n  (test_cases : List (Nat × Nat × List (Nat × Nat)))\n  (h_nonempty : test_cases ≠ []) :\n  let results := solve_ski_resort test_cases\n  -- Results length matches input length\n  results.length = test_cases.length ∧\n  -- For each test case and result\n  (∀ (tc : Nat × Nat × List (Nat × Nat)) (res : Nat × List Nat),\n    tc ∈ test_cases → res ∈ results →\n    let (n, m, tracks) := tc\n    let (count, closed) := res\n    -- Count equals length of closed list\n    count = closed.length ∧\n    -- All closed points are valid station numbers\n    (∀ x ∈ closed, 1 ≤ x ∧ x ≤ n) ∧\n    -- Closed points are unique\n    closed.Nodup) := by sorry", "vc-theorems": "theorem ski_resort_input_bounds\n  (test_cases : List (Nat × Nat × List (Nat × Nat)))\n  (h_nonempty : test_cases ≠ []) :\n  ∀ (n m : Nat) (tracks : List (Nat × Nat)),\n  (n, m, tracks) ∈ test_cases →\n  -- n is between 2 and 10\n  2 ≤ n ∧ n ≤ 10 ∧\n  -- m is between 0 and min(20, n*(n-1))\n  0 ≤ m ∧ m ≤ min 20 (n*(n-1)) ∧\n  -- tracks length equals m\n  tracks.length = m ∧\n  -- all tracks are valid\n  (∀ t ∈ tracks, valid_track n t) := by sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval sorted res1[0][1]\n\n/-\ninfo: [4, 5, 6, 7]\n-/\n#guard_msgs in\n#eval sorted res2[0][1]"}
{"id": "fvapps_000047", "vc-description": "/-\nThis is the easy version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.\n\nPikachu is a cute and friendly pokémon living in the wild pikachu herd.\n\nBut it has become known recently that infamous team R wanted to steal all these pokémon! Pokémon trainer Andrew decided to help Pikachu to build a pokémon army to resist.\n\nFirst, Andrew counted all the pokémon — there were exactly $n$ pikachu. The strength of the $i$-th pokémon is equal to $a_i$, and all these numbers are distinct.\n\nAs an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array $b$ from $k$ indices such that $1 \\le b_1 < b_2 < \\dots < b_k \\le n$, and his army will consist of pokémons with forces $a_{b_1}, a_{b_2}, \\dots, a_{b_k}$.\n\nThe strength of the army is equal to the alternating sum of elements of the subsequence; that is, $a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + \\dots$.\n\nAndrew is experimenting with pokémon order. He performs $q$ operations. In $i$-th operation Andrew swaps $l_i$-th and $r_i$-th pokémon.\n\nNote: $q=0$ in this version of the task.\n\nAndrew wants to know the maximal stregth of the army he can achieve with the initial pokémon placement. He also needs to know the maximal strength after each operation.\n\nHelp Andrew and the pokémon, or team R will realize their tricky plan!\n\n-----Input-----\n\nEach test contains multiple test cases.\n\nThe first line contains one positive integer $t$ ($1 \\le t \\le 10^3$) denoting the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains two integers $n$ and $q$ ($1 \\le n \\le 3 \\cdot 10^5, q = 0$) denoting the number of pokémon and number of operations respectively.\n\nThe second line contains $n$ distinct positive integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) denoting the strengths of the pokémon.\n\n$i$-th of the last $q$ lines contains two positive integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) denoting the indices of pokémon that were swapped in the $i$-th operation.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3 \\cdot 10^5$, and the sum of $q$ over all test cases does not exceed $3 \\cdot 10^5$. \n\n-----Output-----\n\nFor each test case, print $q+1$ integers: the maximal strength of army before the swaps and after each swap.\n\n-----Example-----\nInput\n3\n3 0\n1 3 2\n2 0\n1 2\n7 0\n1 2 5 4 3 6 7\n\nOutput\n3\n2\n9\n\n-----Note-----\n\nIn third test case we can build an army in such way: [1 2 5 4 3 6 7], its strength will be $5−3+7=9$.\n-/", "vc-preamble": "def List.maximum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | (h::t) => t.foldl max h", "vc-helpers": "", "vc-definitions": "def find_max_army_strength (n : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_at_least_max_element {arr : List Nat} (h : arr ≠ []) : \n  find_max_army_strength arr.length arr ≥ List.maximum arr := by\n  sorry\n\ntheorem non_negative_result {arr : List Nat} (h : arr ≠ []) :\n  find_max_army_strength arr.length arr ≥ 0 := by\n  sorry\n\ntheorem single_element (x : Nat) :\n  find_max_army_strength 1 [x] = x := by\n  sorry\n\ntheorem two_elements (x y : Nat) :\n  find_max_army_strength 2 [x, y] ≥ max x y := by\n  sorry\n\ntheorem reverse_invariant {arr : List Nat} (h : arr ≠ []) :\n  find_max_army_strength arr.length arr = \n  find_max_army_strength arr.length arr.reverse := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_army_strength 3 [1, 3, 2]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_army_strength 2 [1, 2]\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval find_max_army_strength 7 [1, 2, 5, 4, 3, 6, 7]"}
{"id": "fvapps_000100", "vc-description": "/-\nPolycarp lives on the coordinate axis $Ox$ and travels from the point $x=a$ to $x=b$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis $Ox$ at the point $x=c$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $r$. Thus, if Polycarp is at a distance less than or equal to $r$ from the point $x=c$, then he is in the network coverage area, otherwise — no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $x=a$ to $x=b$. His speed — one unit of distance per minute.\n\n-----Input-----\n\nThe first line contains a positive integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. In the following lines are written $t$ test cases.\n\nThe description of each test case is one line, which contains four integers $a$, $b$, $c$ and $r$ ($-10^8 \\le a,b,c \\le 10^8$, $0 \\le r \\le 10^8$) — the coordinates of the starting and ending points of the path, the base station, and its coverage radius, respectively.\n\nAny of the numbers $a$, $b$ and $c$ can be equal (either any pair or all three numbers). The base station can be located both on the route of Polycarp and outside it.\n\n-----Output-----\n\nPrint $t$ numbers — answers to given test cases in the order they are written in the test. Each answer is an integer — the number of minutes during which Polycarp will be unavailable during his movement.\n\n-----Example-----\nInput\n9\n1 10 7 1\n3 3 3 0\n8 2 10 4\n8 2 10 100\n-10 20 -17 2\n-3 2 2 0\n-3 1 2 0\n2 3 2 3\n-1 3 -2 2\n\nOutput\n7\n0\n4\n0\n30\n5\n4\n0\n3\n\n-----Note-----\n\nThe following picture illustrates the first test case.  [Image] Polycarp goes from $1$ to $10$. The yellow area shows the coverage area of the station with a radius of coverage of $1$, which is located at the point of $7$. The green area shows a part of the path when Polycarp is out of coverage area.\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x\n\ndef maximum (x y : Int) : Int :=\n  if x ≥ y then x else y", "vc-helpers": "", "vc-definitions": "def time_without_coverage (a b c r : Int) : Int :=\n  sorry", "vc-theorems": "theorem time_without_coverage_nonneg \n  (a b c : Int) (r : Nat) :\n  time_without_coverage a b c r ≥ 0 := \n  sorry\n\ntheorem time_without_coverage_symmetric\n  (a b c : Int) (r : Nat) :\n  time_without_coverage a b c r = time_without_coverage b a c r :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval time_without_coverage 1 10 7 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval time_without_coverage 3 3 3 0\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval time_without_coverage 8 2 10 4"}
{"id": "fvapps_000206", "vc-description": "/-\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n\nExample 1:\n\nInput: nums = [1,2,3,1], k = 3, t = 0\nOutput: true\n\nExample 2:\n\nInput: nums = [1,0,1,1], k = 1, t = 2\nOutput: true\n\nExample 3:\n\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3\nOutput: false\n-/", "vc-preamble": "def abs (i : Int) : Int :=\n  if i ≥ 0 then i else -i", "vc-helpers": "", "vc-definitions": "def containsNearbyAlmostDuplicate (nums : List Int) (k : Int) (t : Int) : Bool :=\n  sorry", "vc-theorems": "theorem invalid_inputs_property (nums : List Int) (k : Int) (t : Int) :\n  k ≤ 0 → t < 0 → ¬containsNearbyAlmostDuplicate nums k t :=\n  sorry\n\ntheorem sliding_window_symmetry (nums : List Int) (k : Int) (t : Int) :\n  k > 0 → t ≥ 0 → nums.length ≥ 2 → nums.length ≤ 100 →\n  containsNearbyAlmostDuplicate nums k t = containsNearbyAlmostDuplicate nums.reverse k t :=\n  sorry\n\ntheorem zero_threshold_property (nums : List Int) (k : Int) :\n  k > 0 → nums.length ≥ 2 → nums.length ≤ 100 →\n  containsNearbyAlmostDuplicate nums k 0 = \n    (∃ i j, 0 ≤ i ∧ i < nums.length ∧ \n            0 ≤ j ∧ j < nums.length ∧\n            i ≠ j ∧ abs (i - j) ≤ k ∧\n            nums[i]! = nums[j]!) :=\n  sorry\n\ntheorem scaling_invariance (nums : List Int) (k t scale : Int) :\n  k > 0 → t ≥ 0 → scale > 0 → nums.length ≥ 2 → nums.length ≤ 100 →\n  containsNearbyAlmostDuplicate nums k t = \n  containsNearbyAlmostDuplicate (nums.map (· * scale)) k (t * scale) :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_nearby_almost_duplicate [1, 2, 3, 1] 3 0\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval contains_nearby_almost_duplicate [1, 0, 1, 1] 1 2\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval contains_nearby_almost_duplicate [1, 5, 9, 1, 5, 9] 2 3"}
{"id": "fvapps_000216", "vc-description": "/-\nToday, the bookstore owner has a store open for customers.length minutes.  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.\n\nExample 1:\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nNote:\n\n1 <= X <= customers.length == grumpy.length <= 20000\n0 <= customers[i] <= 1000\n0 <= grumpy[i] <= 1\n-/", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  l.foldr (· + ·) 0\n\ndef minimum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => xs.foldr min x", "vc-helpers": "", "vc-definitions": "def maxSatisfied (customers : List Nat) (grumpy : List Nat) (X : Nat) : Nat := \n  sorry", "vc-theorems": "theorem maxSatisfied_properties {customers grumpy : List Nat} {X : Nat}\n  (h1 : customers.length > 0)\n  (h2 : grumpy.length = customers.length)\n  (h3 : X > 0)\n  (h4 : ∀ x ∈ customers, x ≤ 1000)\n  (h5 : ∀ x ∈ grumpy, x ≤ 1) :\n  let result := maxSatisfied customers grumpy X\n  let base_satisfied := (List.zip customers grumpy).foldr (fun (p : Nat × Nat) acc => \n    if p.2 = 0 then acc + p.1 else acc) 0\n  (result ≥ base_satisfied \n  ∧ result ≤ sum customers\n  ∧ (grumpy.all (· = 0) → result = sum customers)) := by\n  sorry\n\ntheorem maxSatisfied_single_element {customers : List Nat} \n  (h1 : customers.length > 0) :\n  let grumpy_zeros := List.replicate customers.length 0\n  let grumpy_ones := List.replicate customers.length 1\n  (maxSatisfied customers grumpy_zeros 1 = sum customers\n  ∧ maxSatisfied customers grumpy_ones 1 ≥ minimum customers) := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval maxSatisfied [1, 0, 1, 2, 1, 1, 7, 5] [0, 1, 0, 1, 0, 1, 0, 1] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval maxSatisfied [1] [0] 1\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval maxSatisfied [2, 4, 1, 4, 1] [1, 1, 1, 1, 1] 2"}
{"id": "fvapps_000218", "vc-description": "/-\nA sequence X_1, X_2, ..., X_n is fibonacci-like if:\n\nn >= 3\nX_i + X_{i+1} = X_{i+2} for all i + 2 <= n\n\nGiven a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0.\n(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)\n\nExample 1:\nInput: [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation:\nThe longest subsequence that is fibonacci-like: [1,2,3,5,8].\n\nExample 2:\nInput: [1,3,7,11,12,14,18]\nOutput: 3\nExplanation:\nThe longest subsequence that is fibonacci-like:\n[1,11,12], [3,11,14] or [7,11,18].\n\nNote:\n\n3 <= A.length <= 1000\n1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9\n(The time limit has been reduced by 50% for submissions in Java, C, and C++.)\n-/", "vc-preamble": "def List.isSorted (xs : List Nat) : Bool :=\n  match xs with\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => (x < y) && isSorted (y::xs)\n\ndef listGet (xs : List Nat) (i : Nat) : Option Nat :=\n  xs.get? i\n\ndef isFibonacciSeq (seq : List Nat) : Bool :=\n  if seq.length ≤ 2 then true\n  else\n    let rec checkFib (i : Nat) (fuel : Nat) : Bool :=\n      if fuel = 0 then false\n      else if i ≥ seq.length then true\n      else if i < 2 then checkFib (i+1) (fuel-1)\n      else match listGet seq i, listGet seq (i-1), listGet seq (i-2) with\n        | some x, some y, some z => x == y + z && checkFib (i+1) (fuel-1)\n        | _, _, _ => false\n    checkFib 0 seq.length", "vc-helpers": "", "vc-definitions": "def lenLongestFibSubseq (A : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem result_bounds {A : List Nat} : \n  let result := lenLongestFibSubseq A\n  result = 0 ∨ (result ≥ 3 ∧ result ≤ A.length) :=\n  sorry\n\ntheorem input_strictly_increasing {A : List Nat} :\n  A.isSorted = true → ∀ i, i > 0 → i < A.length → \n  match listGet A i, listGet A (i-1) with\n  | some x, some y => x > y\n  | _, _ => true :=\n  sorry\n\ntheorem fibonacci_subsequence_exists {A : List Nat} :\n  let result := lenLongestFibSubseq A\n  A.isSorted = true →\n  result ≥ 3 →\n  ∃ subseq : List Nat,\n    subseq.length = result ∧ \n    isFibonacciSeq subseq = true ∧\n    ∀ x, x ∈ subseq → x ∈ A :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval lenLongestFibSubseq [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval lenLongestFibSubseq [1, 3, 7, 11, 12, 14, 18]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval lenLongestFibSubseq [1, 2, 4, 8]"}
{"id": "fvapps_000247", "vc-description": "/-\nNormally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\nWe instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.\nFor example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\nAdditionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.\nImplement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.\n\nExample 1:\nInput: 4\nOutput: 7\nExplanation: 7 = 4 * 3 / 2 + 1\n\nExample 2:\nInput: 10\nOutput: 12\nExplanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n\nNote:\n\n1 <= N <= 10000\n-2^31 <= answer <= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)\n-/", "vc-preamble": "def abs (n : Int) : Int := \n  if n < 0 then -n else n", "vc-helpers": "", "vc-definitions": "def clumsy (n : Nat) : Int := sorry\n\ntheorem clumsy_one :\n  clumsy 1 = 1 := sorry", "vc-theorems": "theorem clumsy_two :\n  clumsy 2 = 2 := sorry\n\ntheorem clumsy_bounds_larger (n : Nat) (h : n ≥ 3) (h2 : n ≤ 100) :\n  n - 1 ≤ clumsy n ∧ clumsy n ≤ n + 3 := sorry\n\ntheorem clumsy_monotonic_small (n : Nat) (h : n ≤ 4) (h2 : n ≥ 1) :\n  ∀ i, 1 ≤ i → i < n → clumsy i ≤ clumsy (i+1) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval clumsy 4\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval clumsy 10\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval clumsy 1"}
{"id": "fvapps_000272", "vc-description": "/-\nThe set [1,2,3,...,n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n       \"123\"\n       \"132\"\n       \"213\"\n       \"231\"\n       \"312\"\n       \"321\"\n\nGiven n and k, return the kth permutation sequence.\n\nNote:\n\n       Given n will be between 1 and 9 inclusive.\n       Given k will be between 1 and n! inclusive.\n\nExample 1:\n\nInput: n = 3, k = 3\nOutput: \"213\"\n\nExample 2:\n\nInput: n = 4, k = 9\nOutput: \"2314\"\n-/", "vc-preamble": "def factorial (n : Nat) : Nat :=\n  match n with\n  | 0 => 1\n  | n + 1 => (n + 1) * factorial n", "vc-helpers": "", "vc-definitions": "def get_permutation (n : Nat) (k : Nat) : String := sorry\n\ntheorem permutation_length (n : Nat) (k : Nat) (h1 : n ≥ 1) (h2 : n ≤ 9) \n    (h3 : k ≥ 1) (h4 : k ≤ factorial n) :\n  (get_permutation n k).length = n := sorry", "vc-theorems": "theorem permutation_digits_valid (n : Nat) (k : Nat) (h1 : n ≥ 1) (h2 : n ≤ 9)\n    (h3 : k ≥ 1) (h4 : k ≤ factorial n) :\n  ∀ (c : Char), c ∈ (get_permutation n k).data → \n    ∃ d : Nat, d < 10 ∧ d > 0 ∧ c = Char.ofNat (d + 48) := sorry\n\ntheorem permutation_unique_chars (n : Nat) (k : Nat) (h1 : n ≥ 1) (h2 : n ≤ 9)\n    (h3 : k ≥ 1) (h4 : k ≤ factorial n) :\n  ∀ c, (get_permutation n k).data.count c ≤ 1 := sorry\n\ntheorem first_permutation (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 9) :\n  get_permutation n 1 = String.mk (List.range n |>.map (fun i => Char.ofNat (i + 49))) := sorry\n\ntheorem last_permutation (n : Nat) (h1 : n ≥ 1) (h2 : n ≤ 9) :\n  get_permutation n (factorial n) = \n    String.mk (List.range n |>.map (fun i => Char.ofNat (n - i + 48))) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: '213'\n-/\n#guard_msgs in\n#eval get_permutation 3 3\n\n/-\ninfo: '2314'\n-/\n#guard_msgs in\n#eval get_permutation 4 9\n\n/-\ninfo: '21'\n-/\n#guard_msgs in\n#eval get_permutation 2 2"}
{"id": "fvapps_000278", "vc-description": "/-\nGiven an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of B and the minimum value of B.\n\nExample 1:\nInput: A = [1], K = 0\nOutput: 0\nExplanation: B = [1]\n\nExample 2:\nInput: A = [0,10], K = 2\nOutput: 6\nExplanation: B = [2,8]\n\nExample 3:\nInput: A = [1,3,6], K = 3\nOutput: 3\nExplanation: B = [4,6,3]\n\nNote:\n\n1 <= A.length <= 10000\n0 <= A[i] <= 10000\n0 <= K <= 10000\n-/", "vc-preamble": "def maximum (xs: List Int) : Int := match xs with\n  | [] => 0\n  | h::t => t.foldl max h\n\ndef minimum (xs: List Int) : Int := match xs with\n  | [] => 0\n  | h::t => t.foldl min h", "vc-helpers": "", "vc-definitions": "def smallestRangeII (nums: List Int) (k: Int) : Int := sorry\n\ntheorem result_nonnegative (nums: List Int) (k: Int) (h: k ≥ 0) :\n  smallestRangeII nums k ≥ 0 := sorry", "vc-theorems": "theorem single_element_gives_zero (x: Int) (k: Int) :\n  smallestRangeII [x] k = 0 := sorry\n\ntheorem empty_list_gives_zero (k: Int) :\n  smallestRangeII [] k = 0 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval smallestRangeII [1] 0\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval smallestRangeII [0, 10] 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval smallestRangeII [1, 3, 6] 3"}
{"id": "fvapps_000341", "vc-description": "/-\nGiven an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\n(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\nReturn the number of good subarrays of A.\n\nExample 1:\nInput: A = [1,2,1,2,3], K = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n\nExample 2:\nInput: A = [1,2,1,3,4], K = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= A.length\n1 <= K <= A.length\n-/", "vc-preamble": "def List.unique {α} [BEq α] : List α → List α \n  | [] => []\n  | h::t => if t.contains h then unique t else h :: unique t", "vc-helpers": "", "vc-definitions": "def subarraysWithKDistinct (A : List Nat) (K : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem k_validity {A : List Nat} {K : Nat}\n  (hA : A.length > 0)\n  (hAelems : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100)\n  (hK : 1 ≤ K ∧ K ≤ 50)\n  (hKvalid : K ≤ (A.unique).length) :\n  0 ≤ subarraysWithKDistinct A K :=\n  sorry\n\ntheorem k_one {A : List Nat}\n  (hA : A.length > 0) \n  (hAelems : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 10) :\n  subarraysWithKDistinct A 1 ≥ A.length :=\n  sorry\n\ntheorem k_equals_distinct {A : List Nat}\n  (hA : A.length > 0)\n  (hAelems : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 100) :\n  subarraysWithKDistinct A (A.unique).length ≥ 1 :=\n  sorry\n\ntheorem edge_cases :\n  subarraysWithKDistinct [1] 1 = 1 ∧ \n  subarraysWithKDistinct [1, 1] 1 = 3 ∧\n  subarraysWithKDistinct [1, 2, 3] 3 = 1 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval subarraysWithKDistinct [1, 2, 1, 2, 3] 2\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval subarraysWithKDistinct [1, 2, 1, 3, 4] 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval subarraysWithKDistinct [1, 2, 3] 2"}
{"id": "fvapps_000415", "vc-description": "/-\nGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\n\nReturn the quotient after dividing dividend by divisor.\n\nThe integer division should truncate toward zero.\n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\n\nNote:\n\n       Both dividend and divisor will be 32-bit signed integers.\n       The divisor will never be 0.\n       Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.\n-/", "vc-preamble": "def MAX_INT : Int := 2147483647\ndef MIN_INT : Int := -2147483648", "vc-helpers": "", "vc-definitions": "def divide (dividend : Int) (divisor : Int) : Int := sorry\n\ntheorem divide_bounds (dividend divisor : Int) (h : divisor ≠ 0) :\n  MIN_INT ≤ divide dividend divisor ∧ divide dividend divisor ≤ MAX_INT := sorry", "vc-theorems": "theorem divide_accuracy (dividend divisor : Int) (h1 : divisor ≠ 0) \n  (h2 : divide dividend divisor ≠ MAX_INT) :\n  (divide dividend divisor * divisor - dividend).natAbs < divisor.natAbs := sorry\n\ntheorem divide_by_zero (dividend : Int) :\n  divide dividend 0 = MAX_INT := sorry \n\ntheorem min_int_overflow :\n  divide MIN_INT (-1) = MAX_INT := sorry\n\ntheorem divide_sign_positive (dividend divisor : Int) (h : dividend * divisor > 0) :\n  divide dividend divisor ≥ 0 := sorry\n\ntheorem divide_sign_negative (dividend divisor : Int) \n  (h1 : dividend * divisor < 0) (h2 : divide dividend divisor ≠ MAX_INT) :\n  divide dividend divisor ≤ 0 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval divide 10 3\n\n/-\ninfo: -2\n-/\n#guard_msgs in\n#eval divide 7 -3\n\n/-\ninfo: 2147483647\n-/\n#guard_msgs in\n#eval divide -2147483648 -1"}
{"id": "fvapps_000464", "vc-description": "/-\nGiven a list of words, list of  single letters (might be repeating) and score of every character.\nReturn the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\nIt is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\n\nExample 1:\nInput: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\nOutput: 23\nExplanation:\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\nWords \"dad\" and \"dog\" only get a score of 21.\nExample 2:\nInput: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\nOutput: 27\nExplanation:\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\nWord \"xxxz\" only get a score of 25.\nExample 3:\nInput: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\nOutput: 0\nExplanation:\nLetter \"e\" can only be used once.\n\nConstraints:\n\n1 <= words.length <= 14\n1 <= words[i].length <= 15\n1 <= letters.length <= 100\nletters[i].length == 1\nscore.length == 26\n0 <= score[i] <= 10\nwords[i], letters[i] contains only lower case English letters.\n-/", "vc-preamble": "def Word := String \ndef Letter := Char\n\ndef Score := Nat\n\ninstance : OfNat Score n where\n  ofNat := n\n\ninstance : Add Score := ⟨Nat.add⟩\ninstance : Mul Score := ⟨Nat.mul⟩\ninstance : LE Score := ⟨Nat.le⟩\ninstance : Inhabited Score := ⟨(0 : Score)⟩\n\ninstance : HMul Nat Score Score where\n  hMul := fun n s => Nat.mul n s", "vc-helpers": "", "vc-definitions": "def max_score_words (words: List Word) (letters: List Letter) (scores: List Score) : Score :=\n  sorry", "vc-theorems": "theorem max_score_words_non_negative (words: List Word) (letters: List Letter) (scores: List Score) :\n  0 ≤ max_score_words words letters scores := sorry\n\ntheorem max_score_words_empty (letters: List Letter) (scores: List Score) : \n  max_score_words [] letters scores = 0 := sorry\n\ntheorem max_score_words_no_letters (words: List Word) (scores: List Score) :\n  max_score_words words [] scores = 0 := sorry\n\ntheorem max_score_words_bounded (words: List Word) (letters: List Letter) (scores: List Score)\n  (h: scores.length = 26) :\n  max_score_words words letters scores ≤ letters.foldr (fun c acc => scores[Char.toNat c - Char.toNat 'a']! + acc) 0 := sorry\n\ntheorem single_letter_words_bounded (words: List Word) (letters: List Letter) (scores: List Score) \n  (h1: ∀ w ∈ words, w = \"a\") \n  (h2: ∀ l ∈ letters, l = 'a')\n  (h3: scores.length = 26) :\n  max_score_words words letters scores ≤ (min words.length letters.length) * (scores[0]!) := sorry\n\ntheorem impossible_words_zero_score (words: List Word) (letters: List Letter) (scores: List Score)\n  (h1: ∀ letter ∈ letters, letter = 'x')\n  (h2: ∃ w ∈ words, ∃ c ∈ w.data, c ≠ 'x')\n  (h3: scores.length = 26) :\n  max_score_words words letters scores = 0 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 23\n-/\n#guard_msgs in\n#eval max_score_words [\"dog\", \"cat\", \"dad\", \"good\"] [\"a\", \"a\", \"c\", \"d\", \"d\", \"d\", \"g\", \"o\", \"o\"] [1, 0, 9, 5, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval max_score_words [\"xxxz\", \"ax\", \"bx\", \"cx\"] [\"z\", \"a\", \"b\", \"c\", \"x\", \"x\", \"x\"] [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval max_score_words [\"leetcode\"] [\"l\", \"e\", \"t\", \"c\", \"o\", \"d\"] [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"}
{"id": "fvapps_000471", "vc-description": "/-\nGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\nExample:\n\nGiven array nums = [-1, 2, 1, -4], and target = 1.\n\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def threeSumClosest (nums : List Int) (target : Int) : Int :=\n  sorry", "vc-theorems": "theorem threeSumClosest_is_sum_of_three {nums : List Int} {target : Int}\n  (h : nums.length ≥ 3) :\n  ∃ i j k, i < j ∧ j < k ∧ k < nums.length ∧ \n    threeSumClosest nums target = nums[i]! + nums[j]! + nums[k]! :=\n  sorry\n\ntheorem threeSumClosest_is_closest {nums : List Int} {target : Int} \n  (h : nums.length ≥ 3) :\n  ∀ i j k, i < j → j < k → k < nums.length →\n    (abs (threeSumClosest nums target - target)) ≤ \n    (abs (nums[i]! + nums[j]! + nums[k]! - target)) :=\n  sorry\n\ntheorem threeSumClosest_all_ones : \n  threeSumClosest [1,1,1] 0 = 3 :=\n  sorry\n\ntheorem threeSumClosest_all_neg_ones :\n  threeSumClosest [-1,-1,-1] 0 = -3 :=\n  sorry\n\ntheorem threeSumClosest_all_zeros :\n  threeSumClosest [0,0,0] 1 = 0 :=\n  sorry\n\ntheorem threeSumClosest_insufficient_nums {nums : List Int} \n  (h : nums.length < 3) :\n  threeSumClosest nums 0 = 0 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval three_sum_closest [-4, -1, 1, 2] 1\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval three_sum_closest [1, 1, 1, 0] 100\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval three_sum_closest [0, 2, 1, -3] 1"}
{"id": "fvapps_000557", "vc-description": "/-\nToday is Chef's birthday. His mom has surprised him with truly fruity gifts: 2 fruit baskets. The first basket contains N apples, and the second one contains M oranges. Chef likes apples and oranges very much but he likes them equally, and therefore, wants to have the minimum possible difference between the number of apples and oranges he has. To do so, he can purchase 1 apple or 1 orange by paying exactly 1 gold coin (that's some expensive fruit, eh?). Chef can purchase fruits at most K times (as he has only K gold coins in his pocket) to make the difference the minimum possible.\nOur little Chef is busy in celebrating his birthday to the fullest, and therefore, he has handed this job to his best friend — you. Can you help him by finding the minimum possible difference he can achieve between the number of apples and orange he owns?\n\n-----Input-----\nThe first line of input contains a single integer T denoting the number of test cases. The first and only line of each test case contains 3 space separated integers — N, M and K — denoting the number of apples, number of oranges, and number of gold coins our little Chef has.\n\n-----Output-----\nFor each test case, output the minimum possible difference between the number of apples and oranges that Chef can achieve.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M, K ≤ 100\n\n-----Example-----Input\n3\n3 4 1\n5 2 1\n3 4 3\n\nOutput\n0\n2\n0\n\n-----Explanation-----\n- Test 1: Chef will buy 1 apple by paying 1 gold coin and will have equal number of apples and oranges. \n- Test 2: Chef will buy 1 orange by paying 1 gold coin and will have 5 apples and 3 oranges.\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def min_fruit_diff (apples oranges gold : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_fruit_diff_nonnegative (apples oranges gold : Nat) :\n  min_fruit_diff apples oranges gold ≥ 0 :=\n  sorry\n\ntheorem min_fruit_diff_bounded (apples oranges gold : Nat) : \n  min_fruit_diff apples oranges gold ≤ (if apples ≥ oranges then apples - oranges else oranges - apples) :=\n  sorry\n\ntheorem min_fruit_diff_with_enough_gold (apples oranges gold : Nat) :\n  gold ≥ (if apples ≥ oranges then apples - oranges else oranges - apples) → \n  min_fruit_diff apples oranges gold ≤ 1 :=\n  sorry\n\ntheorem min_fruit_diff_equal_fruits (fruit gold : Nat) :\n  min_fruit_diff fruit fruit gold = 0 :=\n  sorry\n\ntheorem min_fruit_diff_no_gold (apples oranges : Nat) :\n  min_fruit_diff apples oranges 0 = (if apples ≥ oranges then apples - oranges else oranges - apples) :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_fruit_diff 3 4 1\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_fruit_diff 5 2 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_fruit_diff 3 4 3"}
{"id": "fvapps_000586", "vc-description": "/-\n----- Statement -----\n\nYou need to find a string which has exactly K positions in it such that the character at that position comes alphabetically later than the character immediately after it. If there are many such strings, print the one which has the shortest length. If there is still a tie, print the string which comes the lexicographically earliest (would occur earlier in a dictionary).\n\n-----Input-----\nThe first line contains the number of test cases T. Each test case contains an integer K (≤ 100).\n\n-----Output-----\nOutput T lines, one for each test case, containing the required string.  Use only lower-case letters a-z.\n\n-----Sample Input -----\n2\n1\n2\n\n-----Sample Output-----\nba\ncba\n-/", "vc-preamble": "def isLowercaseLetter (c : Char) : Bool := \n  let n := c.toNat\n  97 ≤ n && n ≤ 122\n\ndef countDescendingPairs (s : List Char) : Nat :=\n  match s with\n  | [] => 0\n  | [_] => 0 \n  | x::y::xs => (if x > y then 1 else 0) + countDescendingPairs (y::xs)", "vc-helpers": "", "vc-definitions": "def findKDescendingPairs (k : Nat) : List Char :=\n  sorry", "vc-theorems": "theorem count_is_k (k : Nat) (k_pos : k > 0) :\n  let result := findKDescendingPairs k\n  countDescendingPairs result = k :=\nsorry\n\ntheorem all_lowercase (k : Nat) (k_pos : k > 0) :\n  let result := findKDescendingPairs k\n  ∀ c ∈ result, isLowercaseLetter c :=\nsorry\n\ntheorem minimal_length (k : Nat) (k_pos : k > 0) :\n  let result := findKDescendingPairs k\n  let expected_len := k + 1 + if k > 25 then ((k - 26) / 25) + 1 else 0\n  result.length = expected_len :=\nsorry\n\ntheorem valid_chars (k : Nat) (k_pos : k > 0) :\n  let result := findKDescendingPairs k\n  ∀ c ∈ result, 97 ≤ c.toNat ∧ c.toNat ≤ 122 := \nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'ba'\n-/\n#guard_msgs in\n#eval find_k_descending_pairs 1\n\n/-\ninfo: 'cba'\n-/\n#guard_msgs in\n#eval find_k_descending_pairs 2\n\n/-\ninfo: 'dcba'\n-/\n#guard_msgs in\n#eval find_k_descending_pairs 3"}
{"id": "fvapps_000597", "vc-description": "/-\nChef would like go shopping to buy ingredients for his special dish. The local grocery store has some special discount offers. If you want to buy some set of ingredients you will pay for all ingredients except the cheapest one. Chef would like to spend as little money as possible. You have to help him. :)\n\nThe store is pretty small and stocks only one unit of each ingredients. Opposite each ingredient is a hanging price tag corresponding to it. The salesman walked away for a minute, giving Chef an opportunity to swap some price tags. He would like to swap some tags to minimize his purchase cost.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a single integer N denoting the number of ingredients Chef needs to buy. The second line contains N space-separated integers A1, A2, ... , AN denoting the value  written on the price tags opposite the needed ingredients. The third line contains a single integer M denoting the number of special offers. The following M lines lists inventory of special offers, one offer per line. Each line contains an integer Ci followed by Ci integers denoting the indices of ingredients constituting the ith discount offer.\n\n-----Output-----\nFor each test case, output a single line containing the minimal purchase cost.\n\n-----Constraints-----\n- T ≤ 5\n- 1 ≤ N ≤ 15\n- 1 ≤ Ai ≤ 106\n- 0 ≤ M ≤ 2N-1\n- 2 ≤ Ci ≤ N\n- Subtask 1 (15 points):  1 ≤ N ≤  5\n- Subtask 2 (25 points):  1 ≤ N ≤ 10\n- Subtask 3 (60 points):  1 ≤ N ≤ 15\n\n-----Example-----\nInput:\n1\n4 \n1 2 3 4\n3\n2 1 2\n2 3 4\n3 1 2 3\n\nOutput:\n6\n-/", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h::t => h + sum t\n\ndef minimum (l : List Nat) : Nat := \n  match l with\n  | [] => 0\n  | h::t => min h (minimum t)\n\ndef maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h::t => max h (maximum t)", "vc-helpers": "", "vc-definitions": "def calculate_min_cost (n : Nat) (arr : List Nat) (m : Nat) (offers : List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem calculate_min_cost_bounded_by_sum \n  (n : Nat) (arr : List Nat) (m : Nat) (offers : List (List Nat)) :\n  calculate_min_cost n arr m offers ≤ sum arr :=\n  sorry\n\ntheorem calculate_min_cost_nonnegative \n  (n : Nat) (arr : List Nat) (m : Nat) (offers : List (List Nat)) :\n  calculate_min_cost n arr m offers ≥ 0 :=\n  sorry\n\ntheorem calculate_min_cost_singleton \n  (arr : List Nat) (m : Nat) (offers : List (List Nat)) :\n  arr.length = 1 → calculate_min_cost 1 arr m offers = arr.head! :=\n  sorry\n\ntheorem calculate_min_cost_pair_with_offer\n  (arr : List Nat) (m : Nat) (offers : List (List Nat)) :\n  arr.length = 2 → \n  (∃ o ∈ offers, o.head! = 2) → \n  calculate_min_cost 2 arr m offers ≤ sum arr ∧ \n  calculate_min_cost 2 arr m offers ≥ maximum arr :=\n  sorry\n\ntheorem calculate_min_cost_four_items_with_max_discounts\n  (arr : List Nat) :\n  arr.length = 4 →\n  let offers := [[2,1,2], [2,3,4], [3,1,2,3], [4,1,2,3,4]]\n  let m := offers.length\n  calculate_min_cost 4 arr m offers ≤ sum arr - minimum arr :=\n  sorry\n\ntheorem calculate_min_cost_monotonicity\n  (arr : List Nat) :\n  let n := arr.length\n  let offers := [[n] ++ (List.range n).map (fun x => x + 1)]\n  let m := 1\n  calculate_min_cost n arr m offers ≤ sum arr :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calculate_min_cost 4 [1, 2, 3, 4] 3 [[2, 1, 2], [2, 3, 4], [3, 1, 2, 3]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval calculate_min_cost 3 [1, 2, 3] 1 [[2, 1, 2]]\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval calculate_min_cost 2 [5, 10] 1 [[2, 1, 2]]"}
{"id": "fvapps_000649", "vc-description": "/-\nYou are given an array A with size N (indexed from 0) and an integer K. Let's define another array B with size N · K as the array that's formed by concatenating K copies of array A.\nFor example, if A = {1, 2} and K = 3, then B = {1, 2, 1, 2, 1, 2}.\nYou have to find the maximum subarray sum of the array B. Fomally, you should compute the maximum value of Bi + Bi+1 + Bi+2 + ... + Bj, where 0 ≤ i ≤ j < N · K.\n\n-----Input-----\n\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers N and K.\n- The second line contains N space-separated integers A0, A1, ..., AN-1.\n\n-----Output-----\nFor each test case, print a single line containing the maximum subarray sum of B.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ K ≤ 105\n- -106 ≤ Ai ≤ 106 for each valid i\n\n-----Subtasks-----\nSubtask #1 (18 points): N · K ≤ 105\nSubtask #2 (82 points): original constraints\n\n-----Example-----\nInput:\n\n2\n2 3\n1 2\n3 2\n1 -2 1\n\nOutput:\n\n9\n2\n\n-----Explanation-----\nExample case 1: B = {1, 2, 1, 2, 1, 2} and the subarray with maximum sum is the whole {1, 2, 1, 2, 1, 2}. Hence, the answer is 9.\nExample case 2: B = {1, -2, 1, 1, -2, 1} and the subarray with maximum sum is {1, 1}. Hence, the answer is 2.\n-/", "vc-preamble": "def maximum (xs : List Int) : Int := xs.foldl max 0\n\ndef sum (xs : List Int) : Int := xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def max_sum (arr : List Int) : Int := sorry\n\ndef solve (arr : List Int) (k : Nat) : Int := sorry", "vc-theorems": "theorem solve_vs_max_sum (arr : List Int) (k : Nat) (h : arr ≠ []) (hk : k > 0) :\n  solve arr k ≥ max_sum arr := sorry\n\ntheorem solve_monotonic_k (arr : List Int) (k : Nat) (h : arr ≠ []) (hk : k > 1) :\n  solve arr k ≥ solve arr 1 := sorry\n\ntheorem solve_k1_equals_maxsum (arr : List Int) (h : arr ≠ []) :\n  solve arr 1 = max_sum arr := sorry\n\ntheorem solve_concatenation (arr : List Int) (h : arr ≠ []) :\n  solve arr 2 ≥ max_sum (arr ++ arr) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval solve [1, 2] 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [1, -2, 1] 2\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval solve [-1, -2, -3] 4"}
{"id": "fvapps_000720", "vc-description": "/-\nMr. X stays in a mansion whose door opens in the North. He travels every morning to meet his friend Ms. Y walking a predefined path.\n\nTo cut the distance short, one day he decides to construct a skywalk from his place to his friend’s place. Help him to find the shortest distance between the two residences.\n\n-----Input-----\n\nThe first line contains a single positive integer T <= 100, the number of test cases. T test cases follow. The only line of each test case contains a string which is the path from X to Y. The integer value represents the distance. The character R or L represents a Right or a Left respectively.\n\n-----Output-----\n\nFor each test case, output a single line containing the minimum distance and the direction(N,S,W,E,NE,NW,SE,SW) of Y’s residence with respect to X’s residence. The output distance should have only 1 decimal place with no approximation. Print “0.0” if X’s and Y’s residence coincide.\n\n-----Example-----\nInput:\n1\n2 L 2 R 2 L 1\n\nOutput:\n5.0NW\n\nExplanation\nMr. X travels 2units and then takes a Left, and then he travels 2units and takes a Right, then after travelling 2units he takes a Left and finally travels 1unit to reach Y’s residence.\n(Unlike Input, Output does not have spaces between the distance and direction)\n-/", "vc-preamble": "def Point := Nat × Nat -- Position representation\ndef Direction := String -- Direction representation", "vc-helpers": "", "vc-definitions": "def process : List String → String \n  | lst => sorry", "vc-theorems": "theorem direction_valid (moves : List String) :\n  let result := process moves\n  ∃ d, d ∈ [\"\", \"N\", \"S\", \"E\", \"W\", \"NE\", \"NW\", \"SE\", \"SW\"] ∧ \n  (result.endsWith d ∨ result = \"0.0\") := by\n  sorry\n\ntheorem distance_nonneg (moves : List String) :\n  let result := process moves\n  let numStr := result.take (result.length - 2)  -- Take all but direction\n  (String.toNat! numStr) ≥ 0 := by\n  sorry\n\ntheorem origin_return :\n  process [\"1\", \"R\", \"1\", \"R\", \"1\", \"R\", \"1\"] = \"0.0\" := by\n  sorry\n\ntheorem single_move (n : Nat) (h : 0 < n ∧ n ≤ 100) :\n  process [toString n] = s!\"{toString n}.0N\" := by\n  sorry\n\ntheorem distance_triangle_inequality (moves : List String) :\n  let total_distance := moves.foldl (fun acc x => \n    if x ∉ [\"L\", \"R\"] then acc + (String.toNat! x) else acc) 0\n  let result := process moves\n  let resultNum := String.toNat! (result.take (result.length - 2))\n  resultNum ≤ total_distance := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_000748", "vc-description": "/-\nIndian National Olympiad in Informatics 2012\nThe Republic of Tutaria is celebrating its 37th year of independence. To mark the occasion, the nation is organising a contest where all its N citizens take part. The event has three tracks, a COBOL programming competition, pole vault, and a doughnut-eating competition. Each citizen takes part in these three tracks in the same order—a citizen starts with the programming competition, continues with the pole vault as soon as his or her COBOL masterpiece is ready, and then starts gorging on doughnuts as soon as the pole vault is done.\nThe Supreme Leader of Tutaria closely monitors all citizens and knows the exact amount of time each citizen will take in each of the three tracks. She wants to schedule the event so that it will finish as early as possible. However, the Republic of Tutaria has only one computer, and, as a result, only one person can participate in the COBOL programming event at a time. However, any number of people may simultaneously participate in the pole vault and doughnut-eating competitions.\nThe event works as follows. The Supreme Leader fixes the order in which contestants get access to the computer. At time 0, the first citizen in the list starts writing his or her COBOL program, while the remaining citizens wait for the computer to be free. As soon as the first citizen is done, he or she proceeds to the pole vault, and the second citizen gets the computer for the programming round. In general whenever the computer becomes free, the next citizen gets to use it. Whenever a citizen is done using the computer, he or she proceeds to the pole vault immediately, regardless of what the other citizens are doing. Similarly, whenever a citizen is done with the pole vault, he or she proceeds to the doughnut- eating track immediately, independently of the others. The event ends as soon as all the citizens have finished all the three tracks of the event.\nFor example, suppose N = 3, and the time they need for the three tracks are as follows:\nCitizen id\nCOBOL\nPole vault\nDoughnut-eating\n1\n18\n7\n6\n2\n23\n10\n27\n3\n20\n9\n14\n\nIf the citizens start at time 0 and proceed in the order 1,2,3, then citizen 1 will finish at time 18+7+6 = 31, citizen 2 will finish at time 18+23+10+27 = 78, and citizen 3 will finishattime18+23+20+9+14=84. Theeventendsattimemax(31,78,84)=84.\nOn the other hand, if the citizens proceed in the order 2,3,1, you can check that the event ends at max(60, 66, 74) = 74. The Supreme Leader of Tutaria wants to fix the order in which the citizens proceed so that the event ends as early as possible. You can check that in this case 74 is the earliest time at which the event can end.\n\n-----Input format-----\nThe first line of input has a single integer, N, the number of citizens of the Republic of Tutaria. The next N lines contain 3 space-separated integers each: line i gives the time taken by the citizen i for COBOL programming, pole vault, and doughnut-eating respectively.\n\n-----Output format-----\nThe output should have a single line with a single integer, the earliest time at which the event can end.\n\n-----Test Data-----\nThe testdata is grouped into two subtasks with the following constraints on the inputs.\n• Subtask 1 [30 points] : 1 ≤ N ≤ 3000.\n• Subtask 2 [70 points] : 1 ≤ N ≤ 200000.\nIn both the subtasks, all the numbers in the input (except possibly N) are in the range 1 to 10000, inclusive.\n\n-----Example-----\nHere is the sample input and output corresponding to the example above.\n\n-----Sample input-----\n3\n18 7 6 \n23 10 27\n20 9 14\n\n-----Sample output-----\n74\n\n-----Note:----- Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n-/", "vc-preamble": "def sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def find_min_event_time (n : Nat) (times : List (List Nat)) : Nat := sorry\n\ntheorem min_event_time_single (times : List (List Nat))\n  (h1 : times = [[1,1,1]]) :\n  find_min_event_time 1 times = 3 :=\nsorry", "vc-theorems": "theorem min_event_time_equal (times : List (List Nat))\n  (h1 : times = [[5,5,5], [5,5,5]]) :\n  find_min_event_time 2 times = 20 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 74\n-/\n#guard_msgs in\n#eval find_min_event_time 3 [[18, 7, 6], [23, 10, 27], [20, 9, 14]]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval find_min_event_time 2 [[5, 2, 1], [3, 2, 1]]\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval find_min_event_time 1 [[10, 5, 5]]"}
{"id": "fvapps_000760", "vc-description": "/-\nTanish is the president of the chemistry club at his school. He considers everyone who doesn't like chemistry as his enemy. After years of research, he has invented a lethal poison, which he named success. Now Tanish plans to kill all his enemies with his success. Success is extremely deadly and is untraceable in small concentrations.\nTanish has $\\text{N}$ flasks lying on the shelf of his lab. All of these flasks contain the same volume of poison solution. The concentration of poison in the $\\text{ith}$ flask is $\\mathbf{a_i}$. In one move - Tanish picks up any two flasks, pours half of the contents of each of these flasks into a third initially empty flask, discards the two flasks and places the third flask (which now has the same volume of solution as all other flasks) on the shelf. He performs N-1 such moves to end up with only one flask of poison on the shelf. He wishes to perform these moves such that the concentration of poison in this flask is the minimum possible. What is the minimum concentration of poison that he can achieve?\n\n-----Input-----\nFirst line of the input contains a single integer $\\text{T}$ - the number of test cases. \nFor each test case,\nThe first line contains a single integer $\\text{N}$, the number of bottles. \nThe second line contains N space-separated integers, the concentrations. \n\n-----Output-----\nFor each test case, print one line containing the lowest final concentration. The output will be accepted if the absolute error is $\\leq 10^{-6}$.\n\n-----Constraints-----\n$1 \\leq \\text{T} \\leq 10$\n$2 \\leq \\text{N} \\leq 10^4$\n$0 \\leq \\mathbf{a_i} \\leq 10^9$\n\n-----Sample Input-----\n2\n2\n9 3\n3\n3 2 9\n\n-----Sample Output-----\n6.00000000\n4.00000000\n\n-----Explanation-----\nIn test 1, Tanish mixes flasks 1 and 2. In test 2, he first mixes flasks 1 and 3 to get a flask of concentration 6 and then mixes this flask with flask 2 to get a flask of poison concentration 4.    \n\n-----Note-----\nThe concentration is given in the unit ppb i.e. parts per billion.\n1 gram poison in $10^9$ ml solution is 1 ppb.\nConcentration in ppb = (Number of grams of poison / Volume of solution in ml) x $10^9$\n-/", "vc-preamble": "def minimum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (xs.foldl min x)\n\ndef maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => (xs.foldl max x)", "vc-helpers": "", "vc-definitions": "def min_poison_concentration (n : Nat) (concentrations : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_poison_concentration_bounds\n  (n : Nat)\n  (concentrations : List Nat)\n  (h : 1 ≤ n)\n  (h' : n ≤ concentrations.length)\n  : min_poison_concentration n concentrations ≥ minimum concentrations ∧\n    min_poison_concentration n concentrations ≤ maximum concentrations := by\n  sorry\n\ntheorem min_poison_concentration_deterministic\n  (n : Nat)\n  (concentrations : List Nat)\n  (h : 1 ≤ n)\n  (h' : n ≤ concentrations.length)\n  : min_poison_concentration n concentrations = min_poison_concentration n concentrations := by\n  sorry\n\ntheorem min_poison_concentration_orderless\n  (n : Nat)\n  (concentrations : List Nat)\n  (h : 1 ≤ n)\n  (h' : n ≤ concentrations.length)\n  : min_poison_concentration n concentrations = min_poison_concentration n concentrations.reverse := by\n  sorry\n\ntheorem single_concentration_is_max\n  (concentrations : List Nat)\n  (h : 0 < concentrations.length)\n  : min_poison_concentration 1 concentrations = maximum concentrations := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_000764", "vc-description": "/-\nSpring is interesting season of year. Chef is thinking about different things, but last time he thinks about interesting game - \"Strange Matrix\". \nChef has a matrix that consists of n rows, each contains m elements. Initially, the element aij of matrix equals j. (1 ≤ i ≤ n, 1 ≤ j ≤ m). \nThen p times some element aij is increased by 1. \nThen Chef needs to calculate the following: \n\n- For each row he tries to move from the last element (with number m) to the first one (with the number 1). \n- While staying in aij Chef can only move to aij - 1 only if aij - 1 ≤ aij. \n- The cost of such a movement is aij - aij - 1.\n- Otherwise Chef can't move and lose (in this row).\n- If Chef can move from the last element of the row to the first one, then the answer is the total cost of all the movements. \n- If Chef can't move from the last element of the row to the first one, then the answer is -1. \n\nHelp Chef to find answers for all the rows after P commands of increasing. \n\n-----Input-----\n\n- The first line contains three integers n, m and p denoting the number of rows, the number of elements a single row and the number of increasing commands. \n- Each of next p lines contains two integers i and j denoting that the element aij  is increased by one. \n\n-----Output-----\n- For each row in a single line print the answer after the P increasing commands.\n\n-----Constraints-----\n- 1 ≤ n, m, p ≤ 10 ^ 5\n- 1 ≤ i ≤ n\n- 1 ≤ j ≤ m\n\n-----Example-----\nInput:\n4 4 6\n2 2\n3 2 \n3 2 \n4 3\n4 4\n4 3\n\nOutput:\n3\n3\n-1\n4\n\n-----Explanation-----\n\nHere is the whole matrix after P commands:\n1 2 3 4\n1 3 3 4\n1 4 3 4\n1 2 5 5\n\nExplanations to the answer: \n- The first line is without changes: 4-3=1, 3-2=1, 2-1=1. answer = 3. \n- The second line: 4-3=1, 3-3=0, 3-1=2. The answer is 3. \n- The third line: 4-3=1, 3-4=-1, Chef can't move to the first number here. Therefore, the answer is -1. \n- The fourth line: 5-5=0, 5-2=3, 2-1=1. The answer is 4.\n-/", "vc-preamble": "def Command := Nat × Nat\n\n/- Given commands are valid if they are within matrix bounds n×m -/\n\ndef valid_commands : Nat → Nat → List Command → Bool\n  | n, m, cmds => cmds.all fun c => c.1 ≤ n && c.2 ≤ m\n\n/- Solve strange matrix takes dimensions n,m and list of commands, returns list of sums -/", "vc-helpers": "", "vc-definitions": "def solve_strange_matrix (n m k : Nat) (cmds : List Command) : List Int :=\n  sorry", "vc-theorems": "theorem single_column\n  (n : Nat)\n  (h : n > 0) :\n  let result := solve_strange_matrix n 1 0 []\n  -- All entries are 0 for single column\n  ∀ i : Nat, i < n → result.get! i = 0 :=\nsorry\n\ntheorem single_row\n  (m : Nat)\n  (h : m > 0) :\n  let result := solve_strange_matrix 1 m 0 []\n  -- Single row has length 1\n  result.length = 1 ∧\n  -- Result is m-1\n  result.get! 0 = m - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"}
{"id": "fvapps_000841", "vc-description": "/-\nThe government has invited bids from contractors to run canteens at all railway stations. Contractors will be allowed to bid for the catering contract at more than one station. However, to avoid monopolistic price-fixing, the government has declared that no contractor may bid for a pair of neighbouring stations.\nThe railway network has exactly one route between any pair of stations. Each station is directly connected by a railway line to at most $50$ neighbouring stations.\nTo help contractors plan their bids, the government has provided data on the number of passengers who pass through each station each year. Contractors would like to bid for stations with a higher volume of passenger traffic to increase their turnover.\nFor instance, suppose the railway network is as follows, where the volume of passenger traffic is indicated by the side of each station.\n\nIn this network, the best option for the contractor is to bid for stations $1, 2, 5$ and $6$, for a total passenger volume of $90$.\nYour task is to choose a set of stations that the contractor should bid for so that the total volume of traffic across all the stations in the bid is maximized.\n\n-----Input:-----\nThe first line of the input contains one integer $N$ indicating the number of railways stations in the network. The stations are numbered $1,2,...,N$. This is followed by $N$ lines of input, lines $2, 3,..., N+1$, indicating the volume of traffic at each station. The volume of traffic at station $i, 1 \\leq i \\leq N$, is given by a single integer in line $i+1$. The next $N-1$ lines of input, lines $N+2, N+3, ..., 2N$, describe the railway network. Each of these lines contains two integers, denoting a pair of stations that are neighbours.\n\n-----Output:-----\nThe output should be a single integer, corresponding to the total volume of traffic across the set of stations in the optimal bid made by the contractor.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 100000$. \n- Each railway station has at most $50$ neighbours.\n\n-----Sample Input-----\n6\n10\n20\n25\n40\n30\n30\n4 5\n1 3\n3 4\n2 3\n6 4\n\n-----Sample Output-----\n90\n-/", "vc-preamble": "def sum (list : List Nat) : Nat :=\n  match list with\n  | [] => 0\n  | x::xs => x + sum xs\n\ndef maximum (list : List Nat) : Nat :=\n  match list with\n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.max x (maximum xs)", "vc-helpers": "", "vc-definitions": "def solve_max_railway_bids (n : Nat) (traffic : List Nat) (connections : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem output_properties\n  {n : Nat} {traffic : List Nat} {connections : List (Nat × Nat)}\n  (hvalid : n > 0)\n  (hlen : traffic.length = n) :\n  let result := solve_max_railway_bids n traffic connections\n  -- Result should be non-negative (automatically true for Nat)\n  -- Result cannot exceed sum of traffic values\n  result ≤ sum traffic ∧\n  -- Result should be at least max traffic value\n  result ≥ maximum traffic :=\nsorry\n\ntheorem tree_structure_invariant\n  {n : Nat} {traffic : List Nat} {connections : List (Nat × Nat)} \n  (hvalid : n > 0)\n  (hlen : traffic.length = n) :\n  n > 1 →\n  -- Should be n-1 edges\n  connections.length = n - 1 ∧\n  -- All nodes should be in valid range \n  (∀ (edge : Nat × Nat), edge ∈ connections →\n    1 ≤ edge.1 ∧ edge.1 ≤ n ∧\n    1 ≤ edge.2 ∧ edge.2 ≤ n) :=\nsorry\n\ntheorem minimal_cases :\n  -- Single node\n  solve_max_railway_bids 1 [5] [] = 5 ∧\n  -- Two nodes \n  solve_max_railway_bids 2 [5,10] [(1,2)] = 10 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 90\n-/\n#guard_msgs in\n#eval solve_max_railway_bids 6 [10, 20, 25, 40, 30, 30] [(4, 5), (1, 3), (3, 4), (2, 3), (6, 4)]\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval solve_max_railway_bids 3 [10, 20, 30] [(1, 2), (2, 3)]\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval solve_max_railway_bids 4 [5, 10, 15, 20] [(1, 2), (2, 3), (3, 4)]"}
{"id": "fvapps_000853", "vc-description": "/-\nA policeman wants to catch a thief. Both the policeman and the thief can only move on a line on integer coordinates between $0$ and $N$ (inclusive).\nInitially, the policeman is at a coordinate $x$ and the thief is at a coordinate $y$. During each second, each of them must move to the left or right (not necessarily both in the same direction) by distance $\\textbf{exactly}$ equal to $K$. No one may go to the left of the coordinate $0$ or to the right of $N$. Both the policeman and the thief move simultaneously and they cannot meet while moving, only at the end of each second.\nWill the policeman be able to catch the thief if they both move optimally? The thief is caught as soon as the policeman and thief meet at the same position at the same time.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains four space-separated integers $x$, $y$, $K$ and $N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Yes\" if the thief can be caught or \"No\" if the thief cannot be caught (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^9$\n- $1 \\le K \\le N$\n- $0 \\le x, y \\le N$\n- $x \\neq y$\n\n-----Example Input-----\n5\n0 1 1 1\n1 4 1 5\n4 2 1 7\n3 7 2 10\n8 2 3 15\n\n-----Example Output-----\nNo\nNo\nYes\nYes\nYes\n\n-----Explanation-----\nExample case 1: The policeman is at $0$ and the thief is at $1$. After the $1$-st second, the policeman is at $1$ and the thief is at $0$. After the next second, the policeman is again at $0$ and the thief at $1$. They cannot end up at the same coordinate.\n-/", "vc-preamble": "def abs (n : Nat) : Nat := \n  if n ≥ 0 then n else 0", "vc-helpers": "", "vc-definitions": "def can_catch_thief (x y k n : Nat) : String := sorry\n\ntheorem catch_thief_output_validity (x y k n : Nat) (h : k > 0) (h' : n > 0) :\n  can_catch_thief x y k n = \"Yes\" ∨ can_catch_thief x y k n = \"No\" := sorry", "vc-theorems": "theorem catch_thief_distance_divisible (x y k n : Nat) (h : k > 0) (h' : n > 0) :\n  let distance := if x ≥ y then x - y else y - x\n  can_catch_thief x y k n = \"Yes\" ↔ distance % (2 * k) = 0 := sorry\n\ntheorem catch_thief_symmetric (x y k n : Nat) (h : k > 0) (h' : n > 0) :\n  can_catch_thief x y k n = can_catch_thief y x k n := sorry\n\ntheorem catch_thief_translation_invariant (x y k n offset : Nat) (h : k > 0) (h' : n > 0) :\n  can_catch_thief (x + offset) (y + offset) k n = can_catch_thief x y k n := sorry\n\ntheorem catch_thief_same_position (x k n : Nat) (h : k > 0) (h' : n > 0) :\n  can_catch_thief x x k n = \"Yes\" := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval can_catch_thief 0 1 1 1\n\n/-\ninfo: 'No'\n-/\n#guard_msgs in\n#eval can_catch_thief 1 4 1 5\n\n/-\ninfo: 'Yes'\n-/\n#guard_msgs in\n#eval can_catch_thief 4 2 1 7"}
{"id": "fvapps_000869", "vc-description": "/-\nChef recently developed an affinity for undirected graphs.\nHe likes pairs of graphs that are similar in structure.\nHowever, Chef discovered that when the vertices of a graph are reorganized, it's often the case that the resulting graph,\nalthough still structurally similar to the original, can look completely different.\nChef wants you to help him find similarities in pairs of graphs.\n\nChef only considers pairs of graphs where each graph has the same number of vertices (say N).\nChef then labels each vertex of each graph with an integer between 1 and N (inclusive),\nusing each integer exactly once per graph.\nChef then defines the similarity of the graphs as 2*COMMON/TOTAL, where COMMON is the number of\nedges appearing in both graphs \n(that is, the number of unordered pairs {A, B} such that in both graphs there exists an edge between the vertex labelled A\nand the vertex labelled B), and TOTAL is the total number of edges in both graphs.\n\nChef's measure of similarity depends on how the vertices are labelled.\nChef wants you to help him find a labelling that maximizes the similarity.\nOptimal solutions are not required, but better solutions will earn more points.\n\n-----Input-----\n\nInput will begin with an integer T, the number of test cases.\nEach test case will begin with an integer N, the number of vertices in both graphs.\n2*N lines follow.  The first N lines describe the first graph, and the next N lines the second graph.\nEach graph description consists of N lines of N integers each.\nThe i-th integer on the j-th line will be 1 if there is an edge between vertices i and j, and 0 otherwise.\nThe i-th integer on the j-th line will always be equal to the j-th integer on the i-th line,\nand the i-th integer on the i-th line will always be 0.\n\n-----Output-----\n\nFor each test case, output 2 lines with N integers each.\nEach line must contain a permutation of the integers 1 through N, and indicates how Chef should label the corresponding graph.\n\n-----Scoring-----\n\nYour score for each test case is the similarity of the 2 graphs using the labelling you provide.\nYour overall score is the average of your scores on the individual test cases.\n\n-----Sample Input-----\n2\n3\n0 1 0\n1 0 0\n0 0 0\n0 0 1\n0 0 1\n1 1 0\n4\n0 0 1 0\n0 0 0 0\n1 0 0 1\n0 0 1 0\n0 0 1 1\n0 0 0 0\n1 0 0 0\n1 0 0 0\n\n-----Sample Output-----\n1 2 3\n1 2 3\n1 4 2 3\n2 4 1 3\n\nThis output would score 2*0/3 = 0.0 on the first test case, and 2*2/4 = 1.0 on the second test case, for an overall score of 0.5.\nNote that better scores are possible.\n\n-----Test case generation-----\n\nFor each official test file, T is 5.\nFor each test case, N is randomly chosen between 30 and 75.\nA real number D is randomly chosen between 0.05 and 0.5.\nFor each pair of vertices, an edge is added with probability D.\nThis graph is output as the first graph.\nAn integer C is randomly chosen between 0 and N*(N-1)/2.\nC distinct pairs of vertices are chosen.\nFor each pair, if an edge currently exists between them, the edge is removed with probability (1-D).\nIf no edge exists between them, one is added with probability D.\nThen, a random permutation is applied to the vertices of the graph, and it is output as the second graph.\nYou may safely assume there will be no test cases where TOTAL is 0.\n-/", "vc-preamble": "def Matrix (α : Type) := List (List α)\ndef LabelList := List Nat", "vc-helpers": "", "vc-definitions": "def solve_graph_similarity (n : Nat) (g1 : Matrix Nat) (g2 : Matrix Nat) : LabelList × LabelList :=\n  sorry", "vc-theorems": "theorem solve_graph_similarity_output_length {n : Nat} {g1 g2 : Matrix Nat}:\n  let (r1, r2) := solve_graph_similarity n g1 g2\n  r1.length = n ∧ r2.length = n :=\n  sorry\n\ntheorem solve_graph_similarity_output_values {n : Nat} {g1 g2 : Matrix Nat}:\n  let (r1, r2) := solve_graph_similarity n g1 g2\n  r1.foldl (fun acc x => x::acc) [] = List.range n ∧ \n  r2.foldl (fun acc x => x::acc) [] = List.range n :=\n  sorry\n\ntheorem solve_graph_similarity_r1_equals_range {n : Nat} {g1 g2 : Matrix Nat}:\n  let (r1, _) := solve_graph_similarity n g1 g2\n  r1 = List.range n :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: n1\n-/\n#guard_msgs in\n#eval len r1\n\n/-\ninfo: n1\n-/\n#guard_msgs in\n#eval len r2\n\n/-\ninfo: list(range(1, n1 + 1))\n-/\n#guard_msgs in\n#eval sorted r1\n\n/-\ninfo: list(range(1, n1 + 1))\n-/\n#guard_msgs in\n#eval sorted r2\n\n/-\ninfo: n2\n-/\n#guard_msgs in\n#eval len r3\n\n/-\ninfo: n2\n-/\n#guard_msgs in\n#eval len r4\n\n/-\ninfo: list(range(1, n2 + 1))\n-/\n#guard_msgs in\n#eval sorted r3\n\n/-\ninfo: list(range(1, n2 + 1))\n-/\n#guard_msgs in\n#eval sorted r4"}
{"id": "fvapps_000871", "vc-description": "/-\n-----Problem Statement-----\nChef has a sequence of N segments: [L1, R1], [L2, R2], ..., [LN, RN]. He wants to transform the first segment to the last one (with index N). His plan is to do this big deal with a number of transformations: firstly he will transform\n\nthe first segment to the second one, then to the third one, then to the fourth one, and so on till N-th one.\n\nChef can use operation of a single type: shift one segment border by one unit. So, if he has segment [L, R], he can transform it into one of the following segments: [L + 1, R] (we will denote such operation with string L+), [L, R + 1] (will be denoted as R+), [L - 1, R] (L-), [L, R - 1] (R-). Chef doesn't like empty segments, therefore he cannot use any operation that makes a segment empty (L = R).\n\nChef really wants to transform his segment as fast as possible. Please, help him. Find the sequence with minimal number of operations that transforms his segment. If there are multiple such sequences pick the lexicographically minimal one.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a single integer N denoting the number of segments Chef has. \n\nThe following N lines contain pairs of integers. The i-th line contains integers Li, Ri, denoting i-th Chef's segment.\n\n-----Output-----\nFor each test case print an answer - two lines. The first line should contain the minimal number of operations. The second line should contain the sequence of operations\n\nwithout any whitespaces.\n\n-----Constraints-----\n- 1 ≤ T, N ≤ 1000.\n- -1000 ≤ Li < Ri ≤ 1000.\nThe total sum of N values for all test cases doesn't exceed 1000.\n\n-----Example-----\nInput:\n4\n3\n-1 0\n0 1\n3 5\n1\n0 1\n3\n-2 -1\n-2 -1\n-2 0\n4\n4 6\n3 5\n-1 1\n1 2\n\nOutput:\n9\nR+L+R+L+R+L+R+L+R+\n0\n\n1\nR+\n13\nL-R-L-L-L-L-R-R-R-R-L+R+L+\n-/", "vc-preamble": "def Segment := Int × Int \n\ninductive Operation\n  | L_plus\n  | L_minus\n  | R_plus \n  | R_minus\n\ndef apply_operation (s : Segment) (op : Operation) : Segment :=\n  match op with\n  | Operation.L_plus => (s.1 + 1, s.2)\n  | Operation.L_minus => (s.1 - 1, s.2) \n  | Operation.R_plus => (s.1, s.2 + 1)\n  | Operation.R_minus => (s.1, s.2 - 1)\n\ndef is_valid_segment (s : Segment) : Bool :=\n  s.1 < s.2", "vc-helpers": "", "vc-definitions": "def solve (segments : List Segment) : List Operation := sorry\n\ntheorem operations_preserve_validity \n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ i, i ≤ ops.length →\n  let curr := List.foldl apply_operation (List.head segments h₁) (ops.take i)\n  is_valid_segment curr = true :=\nsorry", "vc-theorems": "theorem reaches_target_segments\n  (segments : List Segment)\n  (h₁ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve segments\n  ∀ target ∈ segments.tail,\n  ∃ i ≤ ops.length,\n  List.foldl apply_operation (List.head segments h₁) (ops.take i) = target :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [9, 'R+L+R+L+R+L+R+L+R+']\n-/\n#guard_msgs in\n#eval solve [[-1, 0], [0, 1], [3, 5]]\n\n/-\ninfo: [0, '']\n-/\n#guard_msgs in\n#eval solve [[0, 1]]\n\n/-\ninfo: [1, 'R+']\n-/\n#guard_msgs in\n#eval solve [[-2, -1], [-2, -1], [-2, 0]]"}
{"id": "fvapps_000885", "vc-description": "/-\nRecently, Chef got obsessed with piano. He is a just a rookie in this stuff and can not move his fingers from one key to other fast enough. He discovered that the best way to train finger speed is to play scales.\n\nThere are different kinds of scales which are divided on the basis of their interval patterns. For instance, major scale is defined by pattern T-T-S-T-T-T-S, where ‘T’ stands for a whole tone whereas ‘S’ stands for a semitone. Two semitones make one tone. To understand how they are being played, please refer to the below image of piano’s octave – two consecutive keys differ by one semitone.\n\nIf we start playing from first key (note C), then we’ll play all white keys in a row (notes C-D-E-F-G-A-B-C – as you can see C and D differ for a tone as in pattern, and E and F differ for a semitone).\n\nThis pattern could be played some number of times (in cycle).\n\nEach time Chef takes some type of a scale and plays using some number of octaves. Sometimes Chef can make up some scales, so please don’t blame him if you find some scale that does not exist in real world.\n\nFormally, you have a set of 12 keys (i.e. one octave) and you have N such sets in a row. So in total, you have 12*N keys. You also have a pattern that consists of letters 'T' and 'S', where 'T' means move forward for two keys (from key x to key x + 2, and 'S' means move forward for one key (from key x to key x + 1).\n\nNow, you can start playing from any of the 12*N keys. In one play, you can repeat the pattern as many times as you want, but you cannot go outside the keyboard.\n\nRepeating pattern means that if, for example, you have pattern STTST, you can play STTST as well as STTSTSTTST, as well as STTSTSTTSTSTTST, as well as any number of repeating. For this pattern, if you choose to repeat it once, if you start at some key x, you'll press keys: x (letter 'S')-> x + 1 (letter 'T')-> x + 3 (letter 'T')-> x + 5 (letter 'S') -> x + 6 (letter 'T')-> x + 8. Also 1 ≤ x, x + 8 ≤ 12*N so as to avoid going off the keyboard.\n\nYou are asked to calculate number of different plays that can be performed. Two plays differ if and only if they start at different keys or patterns are repeated different number of times.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nFirst line of each test case contains scale’s pattern – string s consisting of letters ‘T’ and ‘S’ only.\n\nSecond line contains one integer N – number of octaves he’ll be using.\n\n-----Output-----\nFor each test case output a single number in a line corresponding to number of different scales he’ll play. \n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ |S| ≤ 100\n- 1 ≤ n ≤ 7\n\n-----Subtasks-----\nSubtask 1: T < 10 4, N = 1 \nSubtask 2: No additional constraints.\n\n-----Example-----\nInput:\n2 \nTTTT\n1\nTTSTTTS\n3\n\nOutput:\n4\n36\n\n-----Explanation-----\nExample case 1. In the first case there is only one octave and Chef can play scale (not in cycle each time) starting with notes C, C#, D, D# - four together.\n-/", "vc-preamble": "def Scale := String\ndef C : Scale := \"C\"\n\ndef TS : Scale := \"TS\"\n\ninstance : DecidableEq Scale := \n  fun x y => match x, y with\n  | s1, s2 => String.decEq s1 s2", "vc-helpers": "", "vc-definitions": "def calculate_scale_plays (scale_type : Scale) (octaves : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem calculate_scale_plays_positive \n  (scale_type : Scale)\n  (octaves : Nat)\n  (h1 : scale_type = C ∨ scale_type = TS)\n  (h2 : octaves ≥ 1)\n  (h3 : octaves ≤ 100) :\n  calculate_scale_plays scale_type octaves > 0 :=\nsorry\n\ntheorem calculate_scale_plays_formula \n  (scale_type : Scale)\n  (octaves : Nat)\n  (h1 : scale_type = C ∨ scale_type = TS)\n  (h2 : octaves ≥ 1)\n  (h3 : octaves ≤ 100) :\n  calculate_scale_plays scale_type octaves = \n    (if scale_type = C then 7 else 11) * octaves - 1 :=\nsorry\n\ntheorem calculate_scale_plays_invalid\n  (scale_type : Scale)\n  (octaves : Nat)  \n  (h : scale_type ≠ C ∧ scale_type ≠ TS) :\n  ¬∃ (result : Nat), calculate_scale_plays scale_type octaves = result :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval calculate_scale_plays \"C\" 2\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval calculate_scale_plays \"TS\" 2"}
{"id": "fvapps_000905", "vc-description": "/-\nOne day, Delta, the dog, got very angry. He has $N$ items with different values, and he decided to destroy a few of them. However, Delta loves his hooman as well. So he only destroyed those items whose Least Significant Bit in binary representation is 0. \nCan you help Delta to find the total damage he did so he could make an equally sorry face?\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of Each test case a single integer $N$.\n- Next line contains $N$ integers denoting values of items.\n\n-----Output:-----\nFor each testcase, output in a single line the total damage caused by Delta.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N \\leq 10^3$\n- $1 \\leq value \\leq 10^3$\n\n-----Sample Input:-----\n1\n5\n\n1 2 3 4 5\n\n-----Sample Output:-----\n6\n\n-----EXPLANATION:-----\nTotal Damage: $2  + 4 = 6$.\n-/", "vc-preamble": "def sum_list : List Nat → Nat \n  | [] => 0\n  | (h :: t) => h + sum_list t", "vc-helpers": "", "vc-definitions": "def calculate_damage (n : Nat) (items : List Nat) : Nat := sorry\n\ntheorem damage_non_negative {n : Nat} {items : List Nat} \n  (h : items.length > 0) :\n  calculate_damage n items ≥ 0 := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval calculate_damage 5 [1, 2, 3, 4, 5]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval calculate_damage 3 [2, 4, 6]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval calculate_damage 4 [1, 3, 5, 7]"}
{"id": "fvapps_000910", "vc-description": "/-\nChef Ada has a matrix with $N$ rows (numbered $1$ through $N$ from top to bottom) and $N$ columns (numbered $1$ through $N$ from left to right) containing all integers between $1$ and $N^2$ inclusive. For each valid $i$ and $j$, let's denote the cell in the $i$-th row and $j$-th column by $(i,j)$.\nAda wants to sort the matrix in row-major order ― for each valid $i$ and $j$, she wants the cell $(i, j)$ to contain the value $(i-1) \\cdot N + j$.\nIn one operation, Ada should choose an integer $L$ and transpose the submatrix between rows $1$ and $L$ and columns $1$ and $L$ (inclusive). Formally, for each $i$ and $j$ ($1 \\le i, j \\le L$), the value in the cell $(i, j)$ after this operation is equal to the value in $(j, i)$ before it.\nThe initial state of the matrix is chosen in such a way that it is possible to sort it using a finite number of operations (possibly zero). Find the smallest number of operations required to sort the matrix.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The next $N$ lines describe the matrix. For each valid $i$, the $i$-th of these lines contains $N$ space-separated integers ― the initial values in cells $(i, 1), (i, 2), \\ldots, (i, N)$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the smallest number of operations required to sort the matrix.\n\n-----Constraints-----\n- $4 \\le N \\le 64$\n- the sum of $N^2$ over all test files does not exceed $3 \\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (10 points):\n- $T \\le 50$\n- $N = 4$\nSubtask #2 (90 points): original constraints\n\n-----Example Input-----\n1\n4\n1 2 9 13\n5 6 10 14\n3 7 11 15\n4 8 12 16\n\n-----Example Output-----\n2\n\n-----Explanation-----\nExample case 1: After the first operation, with $L = 2$, the resulting matrix is\n1 5 9 13\n2 6 10 14\n3 7 11 15\n4 8 12 16\n\nAfter the second operation, with $L = 4$, the matrix becomes sorted\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n-/", "vc-preamble": "def Array2D (α : Type) := Array (Array α)\n\ndef Grid := Array2D Int\n\ndef isValidGrid (g : Grid) : Bool :=\n  let n := g.size\n  n > 0 ∧\n  (g.all (fun row => row.size = n)) ∧\n  true -- skipping int check since Lean types handle this", "vc-helpers": "", "vc-definitions": "def minTransposeOps (g : Grid) : Nat := sorry\n\ntheorem already_sorted_needs_zero_ops (n : Nat) (h : n > 0):\n  let grid := sorry -- construction of sorted grid\n  minTransposeOps grid = 0 := sorry", "vc-theorems": "theorem transposed_sorted_needs_at_most_n_ops (n : Nat) (h : n > 1):  \n  let grid := sorry -- construction of transposed sorted grid\n  minTransposeOps grid ≤ n := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_transpose_ops #[[1, 2, 9, 13], [5, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_transpose_ops #[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval min_transpose_ops #[[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]"}
{"id": "fvapps_000911", "vc-description": "/-\nChef has an array A consisting of N elements. He wants to find number of pairs of non-intersecting segments [a, b] and [c, d] (1 ≤ a ≤ b < c ≤ d ≤ N) such there is no number that occurs in the subarray {Aa, Aa+1, ... , Ab} and   {Ac, Ac+1, ... , Ad} simultaneously. \nHelp Chef to find this number.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N denoting the number of elements in the array.\n- The second line contains N space-separated integers A1, A2, ..., AN. \n\n-----Output-----\n- For each test case, output a single line containing one integer - number of pairs of non-intersecting segments. \n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 1000\n- 1 ≤ Ai ≤ 109\n\n-----Subtasks-----Subtask 1 (7 points)\n- 1 ≤ N ≤ 20Subtask 2 (34 points)\n- 1 ≤ N ≤ 300Subtask 3 (59 points)\n- Original constraints\n\n-----Example-----\nInput:\n2\n3\n1 2 3\n4\n1 2 1 2\n\nOutput:\n5\n4\n\n-----Explanation-----\nExample case 1.\nAll possible variants are correct: {[1, 1], [2, 2]}, {[1, 1], [2, 3]}, {[1, 2], [3, 3]}, {[2, 2], [3, 3]}, {[1,1], [3, 3]}.\n\nExample case 2.\nCorrect segments: {[1, 1], [2, 2]}, {[1, 1], [4, 4]}, {[2, 2], [3, 3]}, {[3, 3], [4, 4]}.\n-/", "vc-preamble": "def Segment := List Int\ndef SegmentList := List Segment", "vc-helpers": "", "vc-definitions": "def count_non_intersecting_segments (segments : SegmentList) : Nat :=\n  sorry", "vc-theorems": "theorem count_is_non_negative (segments : SegmentList) :\n  count_non_intersecting_segments segments ≥ 0 :=\n  sorry\n\ntheorem count_less_than_input_size (segments : SegmentList) :\n  segments ≠ [] → count_non_intersecting_segments segments ≤ segments.length :=\n  sorry \n\ntheorem empty_list_returns_zero :\n  count_non_intersecting_segments [] = 0 :=\n  sorry\n\ntheorem single_segment_returns_one (segment : Segment) :\n  segment.length = 2 → count_non_intersecting_segments [segment] = 1 :=\n  sorry\n\ntheorem identical_segments_count_as_one (segments : SegmentList) (h : segments ≠ []) :\n  count_non_intersecting_segments (List.append segments segments) = count_non_intersecting_segments segments :=\n  sorry\n\ntheorem function_is_deterministic (segments : SegmentList) :\n  count_non_intersecting_segments segments = count_non_intersecting_segments segments :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_non_intersecting_segments [[1, 5], [2, 3], [3, 6], [4, 6], [5, 6], [5, 7], [7, 9], [8, 10]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval count_non_intersecting_segments arr2"}
{"id": "fvapps_000924", "vc-description": "/-\nChef has a string of size $N$ which consists only lowercase English alphabet. The chef doesn't like the consonant alphabet at all. So he is thinking of changing every single consonant alphabet to any vowel alphabet. There is some cost for performing this operation.\n- Number all alphabet [a,b,c,……,z] as [1,2,3,…..,26]\n- So if you want to change c to e then cost will be |e-c| = |5-3| = 2\nYou need the answer at what minimum cost chef can change every single consonant alphabet to any vowel alphabet. \n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains of a single line of input, a string of lowercase alphabet. \n\n-----Output:-----\nFor each test case, output in a single line answer.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq |s| \\leq 10^2$\n\n-----Sample Input:-----\n2\naeiou\ndbcc  \n\n-----Sample Output:-----\n0\n6\n\n-----EXPLANATION:-----\nIn the first test case, all characters are already vowel so we don't need to change.\nIn the second tect case\n|e-d|=|5-4|=1\n|a-b|=|1-2|=1\n|a-c|=|1-3|=2\n|a-c|=|1-3|=2\n1+1+2+2=6\n-/", "vc-preamble": "def isVowel (c : Char) : Bool := \n  c = 'a' ∨ c = 'e' ∨ c = 'i' ∨ c = 'o' ∨ c = 'u'", "vc-helpers": "", "vc-definitions": "def minCostVowelTransform (s : String) : Nat :=\nsorry", "vc-theorems": "theorem min_cost_non_negative (s : String) :\n  minCostVowelTransform s ≥ 0 :=\nsorry\n\ntheorem vowels_zero_cost (s : String) :\n  (∀ c ∈ s.data, isVowel c) → minCostVowelTransform s = 0 :=\nsorry\n\ntheorem cost_is_sum_of_min_distances (s : String) :\n  minCostVowelTransform s = \n    s.data.foldl (fun acc c =>\n      if isVowel c then \n        acc\n      else\n        acc + ['a', 'e', 'i', 'o', 'u'].foldl (fun min_dist v =>\n          min min_dist (if c.toNat ≥ v.toNat then c.toNat - v.toNat else v.toNat - c.toNat)\n        ) 1000000\n    ) 0 :=\nsorry\n\ntheorem non_vowels_positive_cost (s : String) :\n  s ≠ \"\" →\n  (∀ c ∈ s.data, ¬isVowel c) →\n  minCostVowelTransform s > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_cost_vowel_transform \"aeiou\"\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval min_cost_vowel_transform \"dbcc\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_cost_vowel_transform \"bc\""}
{"id": "fvapps_000959", "vc-description": "/-\nYou are given a sequence of non-negative integers $A_1, A_2, \\ldots, A_N$. At most once, you may choose a non-negative integer $X$ and for each valid $i$, change $A_i$ to $A_i \\oplus X$ ($\\oplus$ denotes bitwise XOR).\nFind the minimum possible value of the sum of all elements of the resulting sequence.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of the input contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the minimum possible sum.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- $1 \\le N \\le 10^3$\n- $1 \\le A_i \\le 10^3$ for each valid $i$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n3\n5\n2 3 4 5 6\n4\n7 7 7 7\n3\n1 1 3\n\n-----Example Output-----\n14\n0\n2\n\n-----Explanation-----\nExample case 1: If we choose $X = 6$, the sequence becomes $(4, 5, 2, 3, 0)$.\nExample case 2: We can choose $X = 7$ to make all elements of the resulting sequence equal to $0$.\nExample case 3: We can choose $X = 1$. The sequence becomes $(0, 0, 2)$, with sum $2$.\n-/", "vc-preamble": "def sum_list : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def min_sequence_sum (n : Nat) (a : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem min_sequence_sum_non_negative\n  (n : Nat) (a : List Nat) (h : a.length = n)\n  : min_sequence_sum n a ≥ 0 :=\nsorry\n\ntheorem min_sequence_sum_upper_bound\n  (n : Nat) (a : List Nat) (h : a.length = n)\n  : min_sequence_sum n a ≤ sum_list a :=\nsorry \n\ntheorem min_sequence_sum_all_equal\n  (n : Nat) (a : List Nat) (h : a.length = n)\n  (h' : ∀ i j, i < n → j < n → a[i]? = a[j]?)\n  : min_sequence_sum n a = 0 :=\nsorry\n\ntheorem min_sequence_sum_all_zeros\n  (n : Nat) (a : List Nat) (h : a.length = n)\n  (h' : ∀ i, i < n → a[i]? = some 0)\n  : min_sequence_sum n a = 0 :=\nsorry\n\ntheorem min_sequence_sum_all_ones \n  (n : Nat) (a : List Nat) (h : a.length = n)\n  (h' : ∀ i, i < n → a[i]? = some 1)\n  : min_sequence_sum n a = 0 :=\nsorry\n\ntheorem min_sequence_sum_single_zero \n  : min_sequence_sum 1 [0] = 0 :=\nsorry\n\ntheorem min_sequence_sum_equal_large_nums\n  {x : Nat} (h : x = 2^31)\n  : min_sequence_sum 2 [x, x] = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 14\n-/\n#guard_msgs in\n#eval min_sequence_sum 5 [2, 3, 4, 5, 6]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_sequence_sum 4 [7, 7, 7, 7]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_sequence_sum 3 [1, 1, 3]"}
{"id": "fvapps_001044", "vc-description": "/-\nChef recently printed directions from his home to a hot new restaurant across the town, but forgot to print the directions to get back home. Help Chef to transform the directions to get home from the restaurant.\nA set of directions consists of several instructions. The first instruction is of the form \"Begin on XXX\", indicating the street that the route begins on. Each subsequent instruction is of the form \"Left on XXX\" or \"Right on XXX\", indicating a turn onto the specified road.\nWhen reversing directions, all left turns become right turns and vice versa, and the order of roads and turns is reversed. See the sample input for examples.\n\n-----Input-----\nInput will begin with an integer T, the number of test cases that follow. Each test case begins with an integer N, the number of instructions in the route. N lines follow, each with exactly one instruction in the format described above.\n\n-----Output-----\nFor each test case, print the directions of the reversed route, one instruction per line. Print a blank line after each test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 15\n- 2 ≤ N ≤ 40\n- Each line in the input will contain at most 50 characters, will contain only alphanumeric characters and spaces and will not contain consecutive spaces nor trailing spaces. By alphanumeric characters we mean digits and letters of the English alphabet (lowercase and uppercase).\n\n-----Sample Input-----\n2\n4\nBegin on Road A\nRight on Road B\nRight on Road C\nLeft on Road D\n6\nBegin on Old Madras Road\nLeft on Domlur Flyover\nLeft on 100 Feet Road\nRight on Sarjapur Road\nRight on Hosur Road\nRight on Ganapathi Temple Road\n\n-----Sample Output-----\nBegin on Road D\nRight on Road C\nLeft on Road B\nLeft on Road A\n\nBegin on Ganapathi Temple Road\nLeft on Hosur Road\nLeft on Sarjapur Road\nLeft on 100 Feet Road\nRight on Domlur Flyover\nRight on Old Madras Road\n\n-----Explanation-----\nIn the first test case, the destination lies on Road D, hence the reversed route begins on Road D. The final turn in the original route is turning left from Road C onto Road D. The reverse of this, turning right from Road D onto Road C, is the first turn in the reversed route.\n-/", "vc-preamble": "def Road : Type := String\ndef Direction : Type := String", "vc-helpers": "", "vc-definitions": "def reverse_directions (directions : List Direction) : List Direction := sorry\n\ntheorem reverse_directions_length {directions : List Direction} :\n  directions ≠ [] →\n  (reverse_directions directions).length = directions.length\n  := sorry", "vc-theorems": "theorem reverse_directions_begin {directions : List Direction} :\n  directions ≠ [] →\n  (reverse_directions directions).head?.map (String.startsWith · \"Begin\") = some true\n  := sorry\n\ntheorem reverse_directions_contains_substring {directions : List Direction} :\n  directions ≠ [] →\n  ∀ d ∈ reverse_directions directions, ∃ p, d.get ⟨p⟩ = 'o' ∧ d.get ⟨p+1⟩ = 'n'\n  := sorry\n\ntheorem reverse_directions_involution {directions : List Direction} :\n  directions ≠ [] →\n  reverse_directions (reverse_directions directions) = directions\n  := sorry\n\ntheorem reverse_directions_flips_turns {directions : List Direction} {d : Direction} :\n  directions ≠ [] →\n  d ∈ directions.tail →\n  String.startsWith d \"Left\" →\n  ∃ d' ∈ (reverse_directions directions).tail,\n    String.startsWith d' \"Right\"\n  := sorry\n\ntheorem reverse_directions_single :\n  reverse_directions [\"Begin on Road A\"] = [\"Begin on Road A\"]\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval reverse_directions [\"Begin on Road A\", \"Right on Road B\", \"Right on Road C\", \"Left on Road D\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval reverse_directions [\"Begin on Old Madras Road\", \"Left on Domlur Flyover\", \"Left on 100 Feet Road\", \"Right on Sarjapur Road\", \"Right on Hosur Road\", \"Right on Ganapathi Temple Road\"]"}
{"id": "fvapps_001061", "vc-description": "/-\nIndraneel has to sort the books in his library. His library has one long shelf. His books are numbered $1$ through $N$ and he wants to rearrange the books so that they appear in the sequence $1,2, ..., N$.\nHe intends to do this by a sequence of moves. In each move he can pick up any book from the shelf and insert it at a different place in the shelf. Suppose Indraneel has $5$ books and they are initially arranged in the order\n21453214532 \\quad 1 \\quad 4 \\quad 5 \\quad 3\nIndraneel will rearrange this in ascending order by first moving book $1$ to the beginning of the shelf to get\n12453124531 \\quad 2 \\quad 4 \\quad 5 \\quad 3\nThen, moving book $3$ to position $3$, he gets\n12345123451 \\quad 2 \\quad 3 \\quad 4 \\quad 5\nYour task is to write a program to help Indraneel determine the minimum number of moves that are necessary to sort his book shelf.\n\n-----Input:-----\nThe first line of the input will contain a single integer $N$ indicating the number of books in Indraneel's library. This is followed by a line containing a permutation of $1, 2, ..., N$ indicating the intial state of Indraneel's book-shelf.\n\n-----Output:-----\nA single integer indicating the minimum number of moves necessary to sort Indraneel's book-shelf.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 200000$.\n- You may also assume that in $50 \\%$ of the inputs, $1 \\leq N \\leq 5000$.\n\n-----Sample Input-----\n5\n2 1 4 5 3 \n\n-----Sample Output-----\n2\n-/", "vc-preamble": "def IsSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\ndef IsReverseSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≥ l[j]!\n\ndef Nodup (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≠ l[j]!", "vc-helpers": "", "vc-definitions": "def min_moves_to_sort (n : Nat) (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem moves_less_than_length {n : Nat} {arr : List Int} (h : n = arr.length) :\n  min_moves_to_sort n arr ≤ n :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval min_moves_to_sort 5 [2, 1, 4, 5, 3]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_to_sort 3 [1, 2, 3]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval min_moves_to_sort 4 [4, 3, 2, 1]"}
{"id": "fvapps_001183", "vc-description": "/-\nTomya is a girl. She loves Chef Ciel very much.\n\nToday, too, Tomya is going to Ciel's restaurant.\nOf course, Tomya would like to go to Ciel's restaurant as soon as possible.\nTherefore Tomya uses one of the shortest paths from Tomya's house to Ciel's restaurant.\nOn the other hand, Tomya is boring now to use the same path many times.\nSo Tomya wants to know the number of shortest paths from Tomya's house to Ciel's restaurant.\nYour task is to calculate the number under the following assumptions.\n\nThis town has N intersections and M two way roads.\nThe i-th road connects from the Ai-th intersection to the Bi-th intersection, and its length is \n\nCi.\nTomya's house is in the 1st intersection, and Ciel's restaurant is in the N-th intersection.\n\n-----Input-----\n\nThe first line contains an integer T, the number of test cases.\nThen T test cases follow.\nThe first line of each test case contains 2 integers N, M.\nThen next M lines contains 3 integers denoting Ai, Bi and Ci.\n\n-----Output-----\n\nFor each test case, print the number of shortest paths from Tomya's house to Ciel's restaurant.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n2 ≤ N ≤ 10\n\n1 ≤ M ≤ N ∙ (N – 1) / 2\n\n1 ≤ Ai, Bi ≤ N\n\n1 ≤ Ci ≤ 10\nAi ≠ Bi\n\nIf i ≠ j and Ai = Aj, then Bi ≠ Bj\n\nThere is at least one path from Tomya's house to Ciel's restaurant.\n\n-----Sample Input-----\n2\n3 3\n1 2 3\n2 3 6\n1 3 7\n3 3\n1 2 3\n2 3 6\n1 3 9\n\n-----Sample Output-----\n1\n2\n\n-----Explanations-----\n\nIn the first sample, only one shortest path exists, which is 1-3.\n\nIn the second sample, both paths 1-2-3 and 1-3 are the shortest paths.\n-/", "vc-preamble": "def Edge := Nat × Nat × Nat\ndef Graph := List Edge", "vc-helpers": "", "vc-definitions": "def count_shortest_paths (n : Nat) (edges : Graph) : Nat :=\n  sorry", "vc-theorems": "theorem count_paths_positive \n  (n : Nat) (edges : Graph) \n  (h1 : n ≥ 2)\n  (h2 : edges.length > 0) :\n  count_shortest_paths n edges > 0 := \n  sorry\n\ntheorem count_paths_permutation_invariant\n  (n : Nat) (edges1 edges2 : Graph)\n  (h : edges2 = edges1) :\n  count_shortest_paths n edges1 = count_shortest_paths n edges2 :=\n  sorry\n\ntheorem count_paths_weight_order_invariant\n  (n : Nat) (edges edges_rev : Graph)\n  (h : edges_rev = edges) :\n  count_shortest_paths n edges = count_shortest_paths n edges_rev :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval count_shortest_paths 3 [(1, 2, 3), (2, 3, 6), (1, 3, 7)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_shortest_paths 3 [(1, 2, 3), (2, 3, 6), (1, 3, 9)]"}
{"id": "fvapps_001241", "vc-description": "/-\nChef is learning linear algebra. Recently, he learnt that for a square matrix $M$, $\\mathop{\\rm trace}(M)$ is defined as the sum of all elements on the main diagonal of $M$ (an element lies on the main diagonal if its row index and column index are equal).\nNow, Chef wants to solve some excercises related to this new quantity, so he wrote down a square matrix $A$ with size $N\\times N$. A square submatrix of $A$ with size $l\\times l$ is a contiguous block of $l\\times l$ elements of $A$. Formally, if $B$ is a submatrix of $A$ with size $l\\times l$, then there must be integers $r$ and $c$ ($1\\le r, c \\le N+1-l$) such that $B_{i,j} = A_{r+i-1, c+j-1}$ for each $1 \\le i, j \\le l$.\nHelp Chef find the maximum trace of a square submatrix of $A$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the $i$-th of these lines contains $N$ space-separated integers $A_{i,1}, A_{i,2}, \\dots, A_{i, N}$ denoting the $i$-th row of the matrix $A$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the maximum possible trace.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $2 \\le N \\le 100$\n- $1 \\le A_{i,j} \\le 100$ for each valid $i, j$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n1\n3\n1 2 5\n6 3 4\n2 7 1\n\n-----Example Output-----\n13\n\n-----Explanation-----\nExample case 1: The submatrix with the largest trace is \n6 3\n2 7\n\nwhich has trace equal to $6 + 7 = 13$. (This submatrix is obtained for $r=2, c=1, l=2$.)\n-/", "vc-preamble": "def isValidMatrix (matrix : List (List Int)) : Bool :=\n  match matrix with\n  | [] => false\n  | x::xs => let n := x.length\n             matrix.length = n && matrix.all (fun row => row.length = n)", "vc-helpers": "", "vc-definitions": "def findMaxTrace (matrix : List (List Int)) : Int :=\n  sorry", "vc-theorems": "theorem max_trace_geq_main_diagonal (matrix : List (List Int)) \n  (h : isValidMatrix matrix = true) : \n  findMaxTrace matrix ≥ \n    (List.range matrix.length).foldl \n      (fun acc i => acc + (matrix.get! i).get! i) 0 :=\nsorry\n\ntheorem max_trace_geq_max_element (matrix : List (List Int)) \n  (h : isValidMatrix matrix = true) :\n  findMaxTrace matrix ≥ \n    (matrix.map (List.foldl max 0)).foldl max 0 :=\nsorry\n\ntheorem constant_matrix_trace (n : Nat) (h : n > 0) :\n  let matrix := List.replicate n (List.replicate n 1)\n  findMaxTrace matrix = n :=\nsorry\n\ntheorem identity_matrix_trace (n : Nat) (h : n > 0) :\n  let matrix := List.range n |> List.map (fun i => \n    List.range n |> List.map (fun j => if i = j then 1 else 0))\n  findMaxTrace matrix = n :=\nsorry\n\ntheorem empty_matrix_error : \n  isValidMatrix [] = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 13\n-/\n#guard_msgs in\n#eval find_max_trace [[1, 2, 5], [6, 3, 4], [2, 7, 1]]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval find_max_trace [[1, 2], [3, 4]]\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_trace [[1, 1, 1], [1, 1, 1], [1, 1, 1]]"}
{"id": "fvapps_001314", "vc-description": "/-\nYou are given a sequence of integers $A_1, A_2, \\dots, A_N$.\nYou should choose an arbitrary (possibly empty) subsequence of $A$ and multiply each element of this subsequence by $-1$. The resulting sequence should satisfy the following condition: the sum of elements of any contiguous subsequence with length greater than 1 is strictly positive.\nYou should minimise the sum of elements of the resulting sequence. Find one such sequence with the minimum possible sum.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing $N$ space-separated integers $B_1, B_2, \\dots, B_N$. For each valid $i$, $B_i$ must be equal to either $A_i$ (the sign of this element did not change) or $-A_i$ (the sign of this element changed).\nIf there is more than one answer, you may output any one.\n\n-----Constraints-----\n- $1 \\le T \\le 10^5$\n- $2 \\le N \\le 10^5$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n- the sum of $N$ for all test cases does not exceed $5 \\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (20 points):\n- $1 \\le T \\le 200$\n- $2 \\le N \\le 10$\nSubtask #2 (30 points):\n- $1 \\le T \\le 1,000$\n- $N \\le 2,000$\nSubtask #3 (50 points): original constraints\n\n-----Example Input-----\n4\n4\n4 3 1 2\n6\n1 2 2 1 3 1\n5\n10 1 2 10 5\n4\n1 2 1 2\n\n-----Example Output-----\n4 3 -1 2\n-1 2 2 -1 3 -1\n10 -1 2 10 -5\n1 2 -1 2\n\n-----Explanation-----\nExample case 1: If we change only the sign of $A_3$, we get a sequence $\\{4, 3, -1, 2\\}$ with sum $8$. This sequence is valid because the sums of all its contiguous subsequences with length $> 1$ are positive. (For example, the sum of elements of the contiguous subsequence $\\{A_3, A_4\\}$ equals $-1 + 2 = 1 > 0$.)\nThere are only two valid sequences $\\{4, 3, -1, 2\\}$ and $\\{4, 3, 1, 2\\}$ with sums $8$ and $10$ respectively, so this sequence has the smallest possible sum.\nFor instance, the sequence $\\{4, -3, 1, 2\\}$ isn't valid, because the sum of $\\{A_2, A_3, A_4\\}$ equals $-3 + 1 + 2 = 0 \\le 0$.\n-/", "vc-preamble": "def abs (n : Int) : Int := \n  if n < 0 then -n else n", "vc-helpers": "", "vc-definitions": "def solve_sequence (n : Nat) (arr : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem solve_sequence_output_sign_flips {n : Nat} {arr : List Int} :\n  let result := solve_sequence n arr\n  ∀ i, i < result.length → abs (result.get ⟨i, sorry⟩) = abs (arr.get ⟨i, sorry⟩) :=\nsorry\n\ntheorem solve_sequence_maintains_length {n : Nat} {arr : List Int} :\n  (solve_sequence n arr).length = arr.length :=\nsorry\n\ntheorem solve_sequence_input_preserved {n : Nat} {arr : List Int} :\n  solve_sequence n arr = solve_sequence n arr ∧ arr = arr :=\nsorry\n\ntheorem solve_sequence_case1 :\n  solve_sequence 4 [4, 3, 1, 2] = [4, 3, -1, 2] :=\nsorry\n\ntheorem solve_sequence_case2 :\n  solve_sequence 6 [1, 2, 2, 1, 3, 1] = [-1, 2, 2, -1, 3, -1] :=\nsorry\n\ntheorem solve_sequence_case3 :\n  solve_sequence 4 [1, 2, 1, 2] = [1, 2, -1, 2] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [4, 3, -1, 2]\n-/\n#guard_msgs in\n#eval solve_sequence 4 [4, 3, 1, 2]\n\n/-\ninfo: [-1, 2, 2, -1, 3, -1]\n-/\n#guard_msgs in\n#eval solve_sequence 6 [1, 2, 2, 1, 3, 1]\n\n/-\ninfo: [1, 2, -1, 2]\n-/\n#guard_msgs in\n#eval solve_sequence 4 [1, 2, 1, 2]"}
{"id": "fvapps_001376", "vc-description": "/-\nToday, puppy Tuzik is going to a new dog cinema. He has already left his home and just realised that he forgot his dog-collar! This is a real problem because the city is filled with catchers looking for stray dogs.\nA city where Tuzik lives in can be considered as an infinite grid, where each cell has exactly four neighbouring cells: those sharing a common side with the cell. Such a property of the city leads to the fact, that the distance between cells (xA, yA) and (xB, yB) equals |xA - xB| + |yA - yB|.\nInitially, the puppy started at the cell with coordinates (0, 0). There are N dog-catchers located at the cells with the coordinates (xi, yi), where 1 ≤ i ≤ N. Tuzik's path can be described as a string S of M characters, each of which belongs to the set {'D', 'U', 'L', 'R'} (corresponding to it moving down, up, left, and right, respectively). To estimate his level of safety, Tuzik wants to know the sum of the distances from each cell on his path to all the dog-catchers. You don't need to output this sum for the staring cell of the path (i.e. the cell with the coordinates (0, 0)).\n\n-----Input-----\nThe first line of the input contains two integers N and M.\nThe following N lines contain two integers xi and yi each, describing coordinates of the dog-catchers.\nThe last line of the input contains string S of M characters on the set {'D', 'U', 'L', 'R'}.\n- 'D' - decrease y by 1\n- 'U' - increase y by 1\n- 'L' - decrease x by 1\n- 'R' - increase x by 1\n\n-----Output-----\nOutput M lines: for each cell of the path (except the starting cell), output the required sum of the distances.\n\n-----Constraints-----\n- 1 ≤ N ≤ 3 ✕ 105\n- 1 ≤ M ≤ 3 ✕ 105\n- -106 ≤ xi, yi ≤ 106\n\n-----Example-----\nInput:\n2 3\n1 2\n0 1\nRDL\n\nOutput:\n4\n6\n6\n\n-----Explanation-----\n\nInitially Tuzik stays at cell (0, 0). Let's consider his path:\n\n- Move 'R' to the cell (1, 0). Distance to the catcher (1, 2) equals 2, distance to the catcher (0, 1) equals 2, so the total distance equals 4\n- Move 'D' to the cell (1, -1). Distance to the catcher (1, 2) equals 3, distance to the catcher (0, 1) equals 3, so the total distance equals 6\n- Move 'L' to the cell (0, -1). Distance to the catcher (1, 2) equals 4, distance to the catcher (0, 1) equals 2, so the total distance equals 6\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def solve_puppy_path (N M : Nat) (coords : List (Nat × Nat)) (path : List Char) : List Int := \n  sorry", "vc-theorems": "theorem result_length_matches_path_length {N M : Nat} {coords : List (Nat × Nat)} {path : List Char} :\n  List.length (solve_puppy_path N M coords path) = List.length path := by\n  sorry\n\ntheorem result_changes_bounded {N M : Nat} {coords : List (Nat × Nat)} {path : List Char} :\n  ∀ i, i + 1 < List.length (solve_puppy_path N M coords path) → \n    let result := solve_puppy_path N M coords path;\n    abs (result[i]! - result[i+1]!) ≤ 2 * N := by\n  sorry\n\ntheorem empty_path {N M : Nat} :\n  solve_puppy_path N M [(0,0)] [] = [] := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: [4, 6, 6]\n-/\n#guard_msgs in\n#eval solve_puppy_path 2 3 [(1, 2), (0, 1)] \"RDL\"\n\n/-\ninfo: [1, 2]\n-/\n#guard_msgs in\n#eval solve_puppy_path 1 2 [(1, 1)] \"RD\""}
{"id": "fvapps_001411", "vc-description": "/-\nThe name of our college is \"Government College of Engineering and Textile Technology Berhampore\". There is another college named \"Government College of Engineering and Textile Technology Serampore\". As the names are quite similar, those who are unaware of existence of both the colleges, often get confused. And mistake one with other.\n\nGiven a string, if it contains the word berhampore (case insensitive), print GCETTB or if it contains serampore(case-insensitive), print GCETTS . If the string contains neither print Others. If it contains both Berhampore and Serampore print Both \nInput \n- First line contains single integer T, No. of test case  \n- Next line for every test contain case a string S \nOutput\n\nPrint GCETTB or GCETTS or Others or Both on a new line\nConstraints \n- 1 <= T <= 10 \n- 0 <= len(S) <= 100  \n- S contain a-z and A-Z and space only\nSample Input\n3\nGovernment clg Berhampore\nSeRaMporE textile college \nGirls college Kolkata\n\nSample Output\n\nGCETTB\n\nGCETTS\n\nOthers       \nExplanation\n\nSelf-Explanatory\n-/", "vc-preamble": "def College := String\nderiving Repr", "vc-helpers": "", "vc-definitions": "def determine_college (s: String) : College := sorry\ndef process_test_cases (cases: List String) : List College := sorry", "vc-theorems": "theorem determine_college_case_insensitive (s: String) :\n  determine_college s = determine_college (s.toUpper) ∧\n  determine_college s = determine_college (s.toLower) := sorry\n\ntheorem process_test_cases_preserves_length (cases: List String) :\n  (process_test_cases cases).length = cases.length := sorry\n\ntheorem determine_college_valid_output (s: String) :\n  determine_college s = \"Both\" ∨ \n  determine_college s = \"GCETTB\" ∨\n  determine_college s = \"GCETTS\" ∨ \n  determine_college s = \"Others\" := sorry\n\ntheorem determine_college_substring_behavior (s1 s2: String) : \n  determine_college (s1 ++ \"berhampore\" ++ s2 ++ \"serampore\") = \"Both\" ∧\n  determine_college (s1 ++ \"berhampore\" ++ s2) = \"GCETTB\" ∧\n  determine_college (s1 ++ \"serampore\" ++ s2) = \"GCETTS\" := sorry\n\ntheorem process_test_cases_valid_output (cases: List String) :\n  ∀ r ∈ process_test_cases cases,\n    r = \"Both\" ∨ r = \"GCETTB\" ∨ r = \"GCETTS\" ∨ r = \"Others\" := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: expected1\n-/\n#guard_msgs in\n#eval process_test_cases [\"Government clg Berhampore\", \"SeRaMporE textile college\", \"Girls college Kolkata\"]\n\n/-\ninfo: expected2\n-/\n#guard_msgs in\n#eval process_test_cases [\"Berhampore Serampore\"]\n\n/-\ninfo: expected3\n-/\n#guard_msgs in\n#eval process_test_cases [\"random college\"]"}
{"id": "fvapps_001498", "vc-description": "/-\nThe GoC Timber Mafia is notorious for its deforestation\nactivities in the forests near Siruseri. These activities have\nincreased multifold after the death of the bandit who used to\nlord over these jungles.  Having lost the battle to prevent the\nMafia from illegally felling the teak trees in this forest, the\ngovernment of Siruseri came up with a novel idea.  Why not\nlegalise the deforestation activity and at least make some money\nin the process? So the Government decided to lease out parts of\nthe forest to the Timber Mafia.\nMost of the teak trees in the forests of Siruseri were planted\nduring the colonial times, after the native trees had been cut.\nLike everything European, the forest is very regular and\norderly. It is rectangular in shape and the trees are arranged in\nuniformly spaced rows and coloumns.\nSince the trees differ in height and girth, the timber value\ndiffers from tree to tree.  The forest department has collected\ndata on each tree and knows the volume of wood (in cubic feet)\navailable in each tree in the forest.\nThe forest department maintains this information in the form of\nan $M \\times N$ array of integers, where the\n$(i, j)$th entry is the volume, in cubic feet, of the\n$i^{th}$ tree on the $i^{th}$ row (or, equivalently, the\n$i^{th}$ tree on the $i^{th}$ column).  We assume that\nour rows are numbered top to bottom and the columns are numbered\nfrom left to right.  For example, such an array could look like\n\nThis array tells us that  the volume of the tree at position $(3,4)$ is $15$\ncubic feet and so on.\nAny rectangular piece of land with trees at each corner can be\nleased out.  In order to fix the lease price for any rectangular\nplot of the forest the forest department needs to know the amount\nof wood available inside the plot.\nA rectangular plot is described by the positions of the trees in\nits top left corner and the bottom right corner. For example the\npositions $(2,2)$ and $(3,4)$ describes the following part\nrectangular part of the above forest.\n\nThe total amount of wood available in this rectangular plot is $76$\ncubic feet.  Similarly $(4,2)$ and $(4,2)$ describes the rectangle\nwith just one tree and its volume is $20$ cubic feet.\nYour task is to write a program that helps the forest department\nto compute the total volume of the trees insides any specfied\nrectangular plot.\n\n-----Input:-----\n- The first line of the input contains two integers $M$ and $N$ indicating the number of rows and columns of trees in the forest. \n- The following $M$ lines have $N$ integers each. The $j^{th}$ integer on line $i+1$ denotes the volume (in cubic feet) of the $j^{th}$  tree on the $i^{th}$  row. \n- Line $M+2$ contains a single integer $C$ indicating the number of rectangles for which the total volume is to be computed. \n- Each of the following $C$ lines (line $M+2+1 ... M+2+C$) contain four integers $x_1, y_1, x_2$ and $y_2$ (with $x_1 \\leq x_2$ and $y_1 \\leq y_2$) and describes a rectangle. The rectangle has its top left corner at the tree in position $(x_1,y_1)$ and its bottom right corner at the tree at position $(x_2,y_2)$.\n\n-----Output:-----\nYour output must contain $C$ lines with one integer on each line. Line $i$ must contain the total volume of wood in the rectangle described on line $M+2+i$ in the input.\n\n-----Constraints-----\n- In $30 \\%$ of inputs, $1 \\leq C \\leq 100$.\n- In all inputs, $2 \\leq N, M \\leq 1000$ and $1 \\leq C \\leq 1000000$\n- $0 \\leq$ volume of wood in each tree $\\leq 1000$\n- $1 \\leq x_1 \\leq x_2 \\leq M$\n- $1 \\leq y_1 \\leq y_2 \\leq N$\n\n-----Sample Input-----\n4 4 \n3 4 15 23 \n14 20 12 9\n3 8 12 15\n12 20 7 5\n2\n2 2 3 4 \n4 2 4 2\n\n-----Sample Output-----\n76\n20\n-/", "vc-preamble": "def sumList (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + sumList t", "vc-helpers": "", "vc-definitions": "def calc_forest_volume (rows cols : Nat) (grid : List (List Nat)) (rectangles : List (List Nat)) : List Nat := sorry\n\ntheorem grid_volumes_sum (rows cols : Nat) (grid : List (List Nat)) (h : rows > 0 ∧ cols > 0) :\n  let normalized_grid := \n    let truncated := grid.take rows\n    let padded := truncated.map (fun row => (row.take cols).append (List.replicate (cols - row.length) 0))\n    padded ++ List.replicate (rows - padded.length) (List.replicate cols 0)\n\n  let rect := [[1,1,rows,cols]]\n  let result := calc_forest_volume rows cols normalized_grid rect\n\n  result.length > 0 ∧ \n  result[0]! = (normalized_grid.map sumList |> sumList) := sorry", "vc-theorems": "theorem rectangle_volumes (rows cols : Nat) (grid : List (List Nat)) (rectangles : List (List Nat)) \n    (h : rows > 0 ∧ cols > 0) :\n  let normalized_grid := \n    let truncated := grid.take rows  \n    let padded := truncated.map (fun row => (row.take cols).append (List.replicate (cols - row.length) 0))\n    padded ++ List.replicate (rows - padded.length) (List.replicate cols 0)\n\n  let valid_rects := rectangles.filter (fun r => \n    r.length = 4 ∧ \n    r.all (fun x => x > 0) ∧\n    r[0]! ≤ r[2]! ∧ r[1]! ≤ r[3]! ∧\n    r[2]! ≤ rows ∧ r[3]! ≤ cols)\n\n  let result := calc_forest_volume rows cols normalized_grid valid_rects\n\n  ∀ (i : Nat) (h_valid : i < valid_rects.length),\n    have h_length : valid_rects[i]!.length = 4 := sorry\n    have h_bounds : valid_rects[i]![0]! > 0 ∧ valid_rects[i]![1]! > 0 ∧ \n                   valid_rects[i]![2]! ≤ rows ∧ valid_rects[i]![3]! ≤ cols := sorry\n\n    let subrect := normalized_grid.take (valid_rects[i]![2]! - valid_rects[i]![0]! + 1)\n                                      |>.drop (valid_rects[i]![0]! - 1)\n                                      |>.map (fun row => row.take (valid_rects[i]![3]! - valid_rects[i]![1]! + 1)\n                                                          |>.drop (valid_rects[i]![1]! - 1))\n    result[i]! = (subrect.map sumList |> sumList) := sorry\n\ntheorem single_cell_volumes (rows cols : Nat) (grid : List (List Nat)) (h : rows > 0 ∧ cols > 0) :\n  let normalized_grid := \n    let truncated := grid.take rows\n    let padded := truncated.map (fun row => (row.take cols).append (List.replicate (cols - row.length) 0))\n    padded ++ List.replicate (rows - padded.length) (List.replicate cols 0)\n\n  ∀ (i : Nat) (h_i : i < rows), ∀ (j : Nat) (h_j : j < cols),\n    let rect := [[i+1, j+1, i+1, j+1]]\n    let result := calc_forest_volume rows cols normalized_grid rect\n    result.length > 0 ∧\n    result[0]! = normalized_grid[i]![j]! := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_001529", "vc-description": "/-\nIndian National Olympiad in Informatics 2012\nYou are given a table with 2 rows and N columns. Each cell has an integer in it. The score of such a table is defined as follows: for each column, consider the sum of the two numbers in the column; the maximum of the N numbers so obtained is the score. For example, for the table\n7162\n1234\n\nthe score is max(7 + 1, 1 + 2, 6 + 3, 2 + 4) = 9.\n\nThe first row of the table is fixed, and given as input. N possible ways to fill the second row are considered:\n1,2,...,N\n2,3,...,N,1\n3,4,...,N,1,2\n···\nN, 1, ... , ,N − 1\n\nFor instance, for the example above, we would consider each of the following as possibilities for the second row.\n1234\n2341\n3412\n4123\n\nYour task is to find the score for each of the above choices of the second row. In the example above, you would evaluate the following four tables,\n7162 7162 7162 7162\n1234 2341 3412 4123\n\nand compute scores 9, 10, 10 and 11, respectively.\n\n-----Input format -----\nThe first line of the input has a single integer, N. The second line of the input has N integers, representing the first row, from left to right.\n\n-----Output format -----\nThe output should consist of a single line with N integers. For 1 ² k ² N, the kth number in the output should be the score when the second row of the table is taken to be k,k+1,...,N,1,...,k−1.\n\n-----Test Data -----\nThe testdata is grouped into two subtasks with the following constraints on the inputs.\n• Subtask 1 [30 points] : 1 ≤ N ≤ 3000.\n• Subtask 2 [70 points] : 1 ≤ N ≤ 200000.\nIn both the subtasks, all the integers in the first row of the table are between 1 and 100000, inclusive.\n\n-----Example -----\nHere is the sample input and output corresponding to the example above.\n\n-----Sample input -----\n4\n7 1 6 2\n\n-----Sample output-----\n9 10 10 11\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n-/", "vc-preamble": "def max_list (l: List Int) : Int :=\n  match l with\n  | [] => 0\n  | h::t => (List.foldl max h t)", "vc-helpers": "", "vc-definitions": "def compute_table_scores (n: Nat) (first_row: List Int) : List Int := sorry\n\ntheorem compute_table_scores_length {n: Nat} {first_row: List Int} :\n  List.length (compute_table_scores n first_row) = n := sorry", "vc-theorems": "theorem compute_table_scores_min_bound {n: Nat} {first_row: List Int} (h: n > 0):\n  ∀ x ∈ compute_table_scores n first_row, x ≥ max_list first_row + 1 := sorry\n\ntheorem compute_table_scores_max_bound {n: Nat} {first_row: List Int} (h: n > 0):\n  ∀ x ∈ compute_table_scores n first_row, x ≤ max_list first_row + n := sorry\n\ntheorem compute_table_scores_min_element {n: Nat} {first_row: List Int} (h: n > 0):\n  List.foldl min (max_list first_row + n) (compute_table_scores n first_row) ≥ max_list first_row + 1 := sorry\n\ntheorem compute_table_scores_max_element {n: Nat} {first_row: List Int} (h: n > 0):\n  List.foldl max 0 (compute_table_scores n first_row) ≤ max_list first_row + n := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_001535", "vc-description": "/-\nChef is in need of money, so he decided to play a game with Ramsay. In this game, there are $N$ rows of coins (numbered $1$ through $N$). For each valid $i$, the $i$-th row contains $C_i$ coins with values $A_{i, 1}, A_{i, 2}, \\ldots, A_{i, C_i}$.\nChef and Ramsay alternate turns; Chef plays first. In each turns, the current player can choose one row that still contains coins and take one of the coins remaining in this row. Chef may only take the the first (leftmost) remaining coin in the chosen row, while Ramsay may only take the last (rightmost) remaining coin in the chosen row. The game ends when there are no coins left.\nEach player wants to maximise the sum of values of the coins he took. Assuming that both Chef and Ramsay play optimally, what is the maximum amount of money (sum of values of coins) Chef can earn through this game?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains an integer $C_i$, followed by a space and $C_i$ space-separated integers $A_{i, 1}, A_{i, 2}, \\ldots, A_{i, C_i}$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum amount of money Chef can earn.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $1 \\le N \\le 10^4$\n- $1 \\le C_i \\le 10$ for each valid $i$\n- $1 \\le A_{i, j} \\le 10^5$ for each valid $i$ and $j$\n\n-----Subtasks-----\nSubtask #1 (20 points): $N = 1$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n1\n2\n4 5 2 3 4\n2 1 6\n\n-----Example Output-----\n8\n\n-----Explanation-----\nExample case 1: One optimal sequence of moves is: Chef takes the coin with value $5$, Ramsay takes $4$, Chef takes $2$, Ramsay takes $3$, Chef takes $1$ and Ramsay takes $6$. At the end, Chef has $5+2+1 = 8$ units of money.\n-/", "vc-preamble": "def sum_list : List Nat → Nat \n  | [] => 0\n  | x :: xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def calculate_chef_money (rows: List (List Nat)) : Nat := sorry\n\ntheorem chef_money_nonnegative (rows: List (List Nat)) :\n  calculate_chef_money rows ≥ 0 := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval calculate_chef_money [[4, 5, 2, 3, 4], [2, 1, 6]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval calculate_chef_money [[2, 1, 2]]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval calculate_chef_money [[3, 5, 2, 3], [4, 1, 6, 4, 2]]"}
{"id": "fvapps_001564", "vc-description": "/-\n# Ten-Pin Bowling\n\nIn the game of ten-pin bowling, a player rolls a bowling ball down a lane to knock over pins. There are ten pins set at the end of the bowling lane. Each player has 10 frames to roll a bowling ball down a lane and knock over as many pins as possible. The first nine frames are ended after two rolls or when the player knocks down all the pins. The last frame a player will receive an extra roll every time they knock down all ten pins; up to a maximum of three total rolls. \n\n## The Challenge\n\nIn this challenge you will be given a string representing a player's ten frames. It will look something like this: `'X X 9/ 80 X X 90 8/ 7/ 44'` (in Java: `\"X X 9/ 80 X X 90 8/ 7/ 44\"`), where each frame is space-delimited, `'X'` represents strikes, and `'/'` represents spares. Your goal is take in this string of frames into a function called `bowlingScore` and return the players total score.\n\n## Scoring\n\nThe scoring for ten-pin bowling can be difficult to understand, and if you're like most people, easily forgotten if you don't play often. Here is a quick breakdown:\n\n### Frames\n\nIn Ten-Pin Bowling there are ten frames per game. Frames are the players turn to bowl, which can be multiple rolls. The first 9 frames you get 2 rolls maximum to try to get all 10 pins down. **On the 10th or last frame a player will receive an extra roll each time they get all ten pins down to a maximum of three total rolls. Also on the last frame bonuses are not awarded for strikes and spares moving forward.**\n\nIn this challenge, three frames might be represented like this: `54 72 44`. In this case, the player has had three frames. On their first frame they scored 9 points (5 + 4), on their second frame they scored 9 points (7 + 2) and on their third frame they scored 8 points (4 + 4). This is a very simple example of bowling scoring. It gets more complicated when we introduce strikes and spares.\n\n### Strikes \nRepresented in this challenge as `'X'`\n\nA strike is scored when a player knocks all ten pins down in one roll. In the first 9 frames this will conclude the players turn and it will be scored as 10 points plus the points received from the next two rolls. So if a player were to have two frames `X 54`, the total score of those two frames would be 28. The first frame would be worth 19 (10 + 5 + 4) and the second frame would be worth 9 (5 + 4).\n\nA perfect game in bowling is 12 strikes in a row and would be represented like this `'X X X X X X X X X XXX'` (in Java: `\"X X X X X X X X X XXX\"`). This adds up to a total score of 300.\n\n### Spares\nRepresented in this challenge as `'/'`\n\nA spare is scored when a player knocks down all ten pins in two rolls. In the first 9 frames this will be scored as 10 points plus the next roll. So if a player were to have two frames `9/ 54`, the total score of the two frames would be 24. The first frame would be worth 15 (10 + 5) and the second frame would be worth 9 (5 + 4).\n\nFor a more detailed explanation see Wikipedia: \n\nhttp://en.wikipedia.org/wiki/Ten-pin_bowling#Scoring\n-/", "vc-preamble": "def BowlingFrame := String\ndef BowlingGame := String", "vc-helpers": "", "vc-definitions": "def bowling_score (game : BowlingGame) : Nat :=\n  sorry", "vc-theorems": "theorem score_zero_game :\n  bowling_score \"00 00 00 00 00 00 00 00 00 00\" = 0 :=\n  sorry\n\ntheorem score_perfect_game :\n  bowling_score \"X X X X X X X X X XXX\" = 300 :=\n  sorry\n\ntheorem score_all_ones :\n  bowling_score \"11 11 11 11 11 11 11 11 11 11\" = 20 :=\n  sorry\n\ntheorem score_mixed_game :\n  bowling_score \"X X 9/ 80 X X 90 8/ 7/ 44\" = 171 :=\n  sorry\n\ntheorem score_all_spares :\n  bowling_score \"5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/5\" = 150 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval bowling_score \"11 11 11 11 11 11 11 11 11 11\"\n\n/-\ninfo: 300\n-/\n#guard_msgs in\n#eval bowling_score \"X X X X X X X X X XXX\"\n\n/-\ninfo: 171\n-/\n#guard_msgs in\n#eval bowling_score \"X X 9/ 80 X X 90 8/ 7/ 44\""}
{"id": "fvapps_001603", "vc-description": "/-\n# Task\n An `amazon` (also known as a queen+knight compound) is an imaginary chess piece that can move like a `queen` or a `knight` (or, equivalently, like a `rook`, `bishop`, or `knight`). The diagram below shows all squares which the amazon attacks from e4 (circles represent knight-like moves while crosses correspond to queen-like moves).\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/amazon.png?_tm=1473934566013)\n\n Recently you've come across a diagram with only three pieces left on the board: a `white amazon`, `white king` and `black king`. \n\n It's black's move. You don't have time to determine whether the game is over or not, but you'd like to figure it out in your head. \n\n Unfortunately, the diagram is smudged and you can't see the position of the `black king`, so it looks like you'll have to check them all.\n\n Given the positions of white pieces on a standard chessboard, determine the number of possible black king's positions such that: \n\n* It's a checkmate (i.e. black's king is under amazon's \n attack and it cannot make a valid move);\n\n* It's a check (i.e. black's king is under amazon's attack \n but it can reach a safe square in one move);\n\n* It's a stalemate (i.e. black's king is on a safe square \n but it cannot make a valid move);\n\n* Black's king is on a safe square and it can make a valid move.\n\nNote that two kings cannot be placed on two adjacent squares (including two diagonally adjacent ones).\n\n# Example\n\n For `king = \"d3\" and amazon = \"e4\"`, the output should be `[5, 21, 0, 29]`.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/example1.png?_tm=1473934566299)\n\n `Red crosses` correspond to the `checkmate` positions, `orange pluses` refer to `checks` and `green circles` denote `safe squares`.\n\n For `king = \"a1\" and amazon = \"g5\"`, the output should be `[0, 29, 1, 29]`.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/amazonCheckmate/img/example2.png?_tm=1473934566670)\n\n `Stalemate` position is marked by a `blue square`.\n\n# Input\n\n - String `king`\n\nPosition of white's king in chess notation.\n\n - String `amazon`\n\nPosition of white's amazon in the same notation.\n\nConstraints: `amazon ≠ king.`\n\n# Output\n\nAn array of four integers, each equal to the number of black's king positions corresponding to a specific situation. The integers should be presented in the same order as the situations were described, `i.e. 0 for checkmates, 1 for checks, etc`.\n-/", "vc-preamble": "def ChessPos := String\ndef AmazonResult := List Int", "vc-helpers": "", "vc-definitions": "def amazon_check_mate (king : ChessPos) (amazon : ChessPos) : AmazonResult :=\n  sorry", "vc-theorems": "theorem amazon_check_mate_list_len\n  (king amazon : ChessPos)\n  (h : king ≠ amazon) :\n  (amazon_check_mate king amazon).length = 4 :=\n  sorry\n\ntheorem amazon_check_mate_non_negative\n  (king amazon : ChessPos)\n  (h : king ≠ amazon)\n  (i : Nat)\n  (h2 : i < (amazon_check_mate king amazon).length) :\n  (amazon_check_mate king amazon).get ⟨i, h2⟩ ≥ 0 :=\n  sorry\n\ntheorem amazon_check_mate_sum_bound\n  (king amazon : ChessPos)\n  (h : king ≠ amazon) :\n  (amazon_check_mate king amazon).foldl (·+·) 0 ≤ 62 :=\n  sorry\n\ntheorem amazon_check_mate_bounds\n  (king amazon : ChessPos)\n  (h : king ≠ amazon) :\n  let result := amazon_check_mate king amazon\n  ∀ i : Nat, ∀ h2 : i < result.length,\n    0 ≤ result.get ⟨i, h2⟩ ∧\n    result.get ⟨i, h2⟩ ≤ 64 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [5, 21, 0, 29]\n-/\n#guard_msgs in\n#eval amazon_check_mate \"d3\" \"e4\"\n\n/-\ninfo: [0, 29, 1, 29]\n-/\n#guard_msgs in\n#eval amazon_check_mate \"a1\" \"g5\"\n\n/-\ninfo: [1, 32, 1, 23]\n-/\n#guard_msgs in\n#eval amazon_check_mate \"a3\" \"e4\""}
{"id": "fvapps_001616", "vc-description": "/-\nIndian National Olympiad in Informatics 2015\nIn this problem you are given two lists of N integers, a1, a2, ..., aN and b1, b2, ... bN. For any pair (i, j) with i, j ϵ {1, 2, ..., N} we define the segment from i to j, written as [i, j], to be i, i + 1, ..., j if i ≤ j and i, i + 1, ..., N, 1, 2, ...,j if i > j. Thus if N = 5 then the [2, 4] = {2, 3, 4} and [4, 2] = {4, 5, 1, 2}.\nWith each segment [i, j] we associate a special sum SSum[i, j] as follows:\n- SSum[i, i] = ai.\n- If i ≠ j then, \n\nThe positions i and j contribute ai and aj, respectively, to the sum while every other position k in [i, j] contributes bk.\nSuppose N = 5 and that the two given sequences are as follows:\ni\n1\n2\n3\n4\n5\nai\n2\n3\n2\n3\n1\nbi\n3\n4\n4\n6\n3\n\nThen, SSum[1, 1] = 2, SSum[2, 4] = 3 + 4 + 3 = 10 and SSum[4, 2] = 3 + 3 + 3 + 3 = 12. Your aim is to compute the maximum value of SSum[i, j] over all segments [i, j]. In this example you can verify that this value is 18 (SSum[2, 1] = 18).\n\n-----Input format-----\n- The first line contains a single positive integer N.\n- This is followed by a line containing N integers giving the values of the ais and this is followed by a line containing N integers giving the values of the bis.\n\n-----Output format-----\nA single integer in a single line giving the maximum possible special segment sum.\nNote: The final value may not fit in a 32 bit integer. Use variables of an appropriate type to store and manipulate this value (long long in C/C++, long in Java).\n\n-----Test Data-----\nYou may assume that -109 ≤ ai, bi ≤ 109.\nSubtask 1 (10 Marks) 1 ≤ N ≤ 3000.\nSubtask 2 (20 Marks) 1 ≤ N ≤ 106 and ai = bi for all 1 ≤ i ≤ N.\nSubtask 3 (30 Marks) 3 ≤ N ≤106. Further a1 = b1 = aN = bN = -109 and for each\n1 < k < N we have -999 ≤ ak, bk ≤ 999.\nSubtask 4 (40 Marks) 1 ≤ N ≤ 106.\n\n-----Example-----\nHere is the sample input and output corresponding to the example above:\n\n-----Sample input-----\n5\n2 3 2 3 1\n3 4 4 6 3\n\n-----Sample output-----\n18\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n-/", "vc-preamble": "def max (a b : Int) : Int :=\nif a ≥ b then a else b", "vc-helpers": "", "vc-definitions": "def max_special_segment_sum (n: Nat) (a b: List Int) : Int :=\nsorry", "vc-theorems": "theorem max_special_segment_sum_geq_max_a {n: Nat} {a b: List Int} \n  (hn: n ≥ 2) (ha: a.length = n) (hb: b.length = n) :\n  max_special_segment_sum n a b ≥ a.foldl max 0 :=\nsorry\n\ntheorem max_special_segment_sum_monotonic {n: Nat} {a b: List Int} \n  (hn: n ≥ 2) (ha: a.length = n) (hb: b.length = n)\n  (hb_nonneg: ∀ x ∈ b, x ≥ 0) :\n  let a_increased := a.map (· + 1)\n  max_special_segment_sum n a_increased b ≥ max_special_segment_sum n a b :=\nsorry\n\ntheorem zero_b_equals_max_a {n: Nat} {a: List Int} \n  (hn: n ≥ 2) (ha: a.length = n)\n  (h_pos: ∀ x ∈ a, x > 0) :\n  let b := List.replicate n (0:Int)\n  max_special_segment_sum n a b ≥ a.foldl max 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_001631", "vc-description": "/-\nGood job! Now that Heidi is able to distinguish between Poisson and uniform distributions, she is in a good position to actually estimate the populations.\n\nCan you help Heidi estimate each village's population?\n\n-----Input-----\n\nSame as the easy version.\n\n-----Output-----\n\nOutput one line per village, in the same order as provided in the input, containing your (integer) population estimate.\n\nYour answer is considered correct if it is an integer that falls into the interval $[ \\lfloor 0.95 \\cdot P \\rfloor, \\lceil 1.05 \\cdot P \\rceil ]$, where P is the real population of the village, used to create the distribution (either Poisson or uniform) from which the marmots drew their answers.\n-/", "vc-preamble": "def minimum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | (x::xs) => xs.foldl min x\n\ndef maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | (x::xs) => xs.foldl max x", "vc-helpers": "", "vc-definitions": "def isSorted (l : List Nat) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => x ≤ y && isSorted (y :: xs)", "vc-theorems": "theorem estimate_population_returns_in_range \n  {surveys : List Nat} (h1 : surveys ≠ [])\n  {estimate_population : List Nat → Nat}\n  : estimate_population surveys ≥ minimum surveys ∧ \n    estimate_population surveys ≤ maximum surveys := by\n  sorry\n\ntheorem estimate_population_returns_nat\n  {surveys : List Nat}\n  {estimate_population : List Nat → Nat}\n  : ∃ n : Nat, estimate_population surveys = n := by\n  sorry\n\ntheorem estimate_population_preserves_input \n  {surveys : List Nat}\n  {estimate_population : List Nat → Nat}\n  : estimate_population surveys = estimate_population surveys := by\n  sorry\n\ntheorem estimate_population_handles_duplicates \n  {surveys : List Nat} (h1 : surveys ≠ [])\n  {estimate_population : List Nat → Nat}\n  : estimate_population (surveys ++ surveys) ≥ minimum surveys ∧ \n    estimate_population (surveys ++ surveys) ≤ maximum surveys := by\n  sorry\n\ntheorem estimate_population_sort_independent\n  {surveys : List Nat}\n  {estimate_population : List Nat → Nat}\n  {sorted_surveys : List Nat}\n  (h : surveys.length = sorted_surveys.length)\n  (h2 : isSorted sorted_surveys = true)\n  : estimate_population surveys = estimate_population sorted_surveys := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval estimate_population [4, 5, 5, 5, 6, 6]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval estimate_population [2, 3, 4, 5, 6, 7]\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval estimate_population [3, 4, 4, 5, 5, 5, 5, 6, 6, 7]"}
{"id": "fvapps_001632", "vc-description": "/-\nThere was a big bank robbery in Tablecity. In order to catch the thief, the President called none other than Albert – Tablecity’s Chief of Police. Albert does not know where the thief is located, but he does know how he moves.\n\nTablecity can be represented as 1000 × 2 grid, where every cell represents one district. Each district has its own unique name “(X, Y)”, where X and Y are the coordinates of the district in the grid. The thief’s movement is as \n\nEvery hour the thief will leave the district (X, Y) he is currently hiding in, and move to one of the districts: (X - 1, Y), (X + 1, Y), (X - 1, Y - 1), (X - 1, Y + 1), (X + 1, Y - 1), (X + 1, Y + 1) as long as it exists in Tablecity. \n\nBelow is an example of thief’s possible movements if he is located in district (7,1):\n\n[Image]\n\nAlbert has enough people so that every hour he can pick any two districts in Tablecity and fully investigate them, making sure that if the thief is located in one of them, he will get caught. Albert promised the President that the thief will be caught in no more than 2015 hours and needs your help in order to achieve that.\n\n-----Input-----\n\nThere is no input for this problem. \n\n-----Output-----\n\nThe first line of output contains integer N – duration of police search in hours. Each of the following N lines contains exactly 4 integers X_{i}1, Y_{i}1, X_{i}2, Y_{i}2 separated by spaces, that represent 2 districts (X_{i}1, Y_{i}1), (X_{i}2, Y_{i}2) which got investigated during i-th hour. Output is given in chronological order (i-th line contains districts investigated during i-th hour) and should guarantee that the thief is caught in no more than 2015 hours, regardless of thief’s initial position and movement.  N ≤ 2015  1 ≤ X ≤ 1000  1 ≤ Y ≤ 2 \n\n-----Examples-----\nInput\nВ этой задаче нет примеров ввода-вывода.\nThis problem doesn't have sample input and output.\nOutput\nСмотрите замечание ниже.\nSee the note below.\n\n-----Note-----\n\nLet's consider the following output:\n\n2\n\n5 1 50 2\n\n8 1 80 2\n\nThis output is not guaranteed to catch the thief and is not correct. It is given to you only to show the expected output format. There exists a combination of an initial position and a movement strategy such that the police will not catch the thief.\n\nConsider the following initial position and thief’s movement:\n\nIn the first hour, the thief is located in district (1,1). Police officers will search districts (5,1) and (50,2) and will not find him.\n\nAt the start of the second hour, the thief moves to district (2,2). Police officers will search districts (8,1) and (80,2) and will not find him.\n\nSince there is no further investigation by the police, the thief escaped!\n-/", "vc-preamble": "def Coordinates := (Nat × Nat × Nat × Nat)\ndef SearchPlan := (Nat × List Coordinates)", "vc-helpers": "", "vc-definitions": "def generate_police_search_plan : SearchPlan :=\nsorry\n\n-- Output format theorem", "vc-theorems": "theorem search_plan_output_format (plan : SearchPlan) : \n  let (N, coords) := plan\n  ∀ c ∈ coords, ∃ x1 y1 x2 y2 : Nat, c = (x1, y1, x2, y2) :=\nsorry\n\n-- Length consistency theorem\n\ntheorem search_plan_length_consistency (plan : SearchPlan) :\n  let (N, coords) := plan\n  List.length coords = N ∧\n  N ≤ 2015 :=\nsorry\n\n-- Coordinate bounds theorem\n\ntheorem search_plan_coordinate_bounds (plan : SearchPlan) :\n  let (N, coords) := plan\n  ∀ c ∈ coords,\n    let (x1, y1, x2, y2) := c\n    1 ≤ x1 ∧ x1 ≤ 1000 ∧\n    1 ≤ y1 ∧ y1 ≤ 2 ∧\n    1 ≤ x2 ∧ x2 ≤ 1000 ∧\n    1 ≤ y2 ∧ y2 ≤ 2 :=\nsorry\n\n-- Search plan validity theorem\n\ntheorem search_plan_validity (coords : List Coordinates) (h : coords.length ≥ 1) :\n  ∀ c ∈ coords,\n    let (x1, y1, x2, y2) := c\n    1 ≤ x1 ∧ x1 ≤ 1000 ∧\n    1 ≤ y1 ∧ y1 ≤ 2 ∧ \n    1 ≤ x2 ∧ x2 ≤ 1000 ∧\n    1 ≤ y2 ∧ y2 ≤ 2 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: N\n-/\n#guard_msgs in\n#eval len []\n\n/-\ninfo: N\n-/\n#guard_msgs in\n#eval len coords"}
{"id": "fvapps_001673", "vc-description": "/-\nJon and Joe have received equal marks in the school examination. But, they won't reconcile in peace when equated with each other. To prove his might, Jon challenges Joe to write a program to find all possible number combos that sum to a given number. While unsure whether he would be able to accomplish this feat or not, Joe accpets the challenge. Being Joe's friend, your task is to help him out.\n\n# Task\n\nCreate a function `combos`, that accepts a single positive integer `num` (30 > `num` > 0) and returns an array of arrays of positive integers that sum to `num`.\n\n# Notes\n1. Sub-arrays may or may not have their elements sorted.\n2. The order of sub-arrays inside the main array does not matter.\n3. For an optimal solution, the following operation should complete within 6000ms.\n\n# Sample\n-/", "vc-preamble": "def sumList (l : List Int) : Int := match l with\n  | [] => 0\n  | h::t => h + sumList t", "vc-helpers": "", "vc-definitions": "def combos (n : Int) (m : Int := 1) : List (List Int) := sorry\n\ndef isSorted (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)", "vc-theorems": "theorem sum_equals_input (n : Int) (h : n > 0) (h' : n ≤ 10) :\n  ∀ combo ∈ combos n, sumList combo = n := sorry\n\ntheorem all_positive (n : Int) (h : n > 0) (h' : n ≤ 10) :\n  ∀ combo ∈ combos n, ∀ x ∈ combo, x > 0 := sorry\n\ntheorem minimum_value (n m : Int) (h1 : n > 0) (h2 : n ≤ 10) (h3 : m > 0) (h4 : m ≤ 10) :\n  ∀ combo ∈ combos n m, ∀ x ∈ combo, x ≥ m := sorry\n\ntheorem empty_for_invalid :\n  (combos 0 = []) ∧ \n  (combos (-1) = []) ∧\n  (combos 5 6 = []) := sorry\n\ntheorem output_sorted (n : Int) (h : n > 0) (h' : n ≤ 10) :\n  ∀ combo ∈ combos n, isSorted combo = true := sorry\n\ntheorem result_uniqueness (n : Int) (h : n > 0) (h' : n ≤ 10) :\n  List.Nodup (combos n) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: [[1]]\n-/\n#guard_msgs in\n#eval combos 1\n\n/-\ninfo: sorted([[1, 1], [2]])\n-/\n#guard_msgs in\n#eval sorted combos(2)\n\n/-\ninfo: sorted([[1, 1, 1], [1, 2], [3]])\n-/\n#guard_msgs in\n#eval sorted combos(3)"}
{"id": "fvapps_001686", "vc-description": "/-\nThis is the second part of a two-part challenge. See [part I](https://www.codewars.com/kata/587387d169b6fddc16000002) if you haven't done so already.\nThe problem is the same, only with longer lists and larger values.\n\nImagine you have a number of jobs to execute. Your workers are not permanently connected to your network, so you have to distribute all your jobs in the beginning. Luckily, you know exactly how long each job is going to take. \n\nLet \n```\nx = [2,3,4,6,8,2]\n```\nbe the amount of time each of your jobs is going to take.\n\nYour task is to write a function ```splitlist(x)```, that will return two lists ```a``` and ```b```, such that ```abs(sum(a)-sum(b))``` is minimised.\n\nOne possible solution to this example would be \n```\na=[2, 4, 6]\nb=[3, 8, 2]\n```\nwith  ```abs(sum(a)-sum(b)) == 1```.\n\nThe order of the elements is not tested, just make sure that you minimise ```abs(sum(a)-sum(b))``` and that ```sorted(a+b)==sorted(x)```.\n\nYou may assume that ```len(x)<=40``` and ```0<=x[i]<=1000```.\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x\n\ndef listSum : List Int → Int \n  | [] => 0\n  | x::xs => x + listSum xs", "vc-helpers": "", "vc-definitions": "def splitlist (nums : List Int) : Option (List Int × List Int) :=\n  sorry", "vc-theorems": "theorem splitlist_length (nums : List Int) :\n  match splitlist nums with\n  | none => true\n  | some (a, b) => List.length a + List.length b = List.length nums\n  := by sorry\n\ntheorem splitlist_elements (nums : List Int) :\n  match splitlist nums with\n  | none => true\n  | some (a, b) => ∀ x : Int, \n    ((x ∈ a ∨ x ∈ b) ↔ x ∈ nums)\n  := by sorry\n\ntheorem splitlist_minimal_difference (nums : List Int) :\n  match splitlist nums with\n  | none => true\n  | some (a, b) => ∀ split : List Int × List Int,\n    (∀ x, (x ∈ split.1 ∨ x ∈ split.2) ↔ x ∈ nums) →\n    abs (listSum a - listSum b) ≤ abs (listSum split.1 - listSum split.2)\n  := by sorry\n\ntheorem splitlist_equal_elements (nums : List Int)\n  (h_even : nums.length % 2 = 0)\n  (h_equal : ∀ x ∈ nums, ∀ y ∈ nums, x = y) :\n  match splitlist nums with\n  | none => true\n  | some (a, b) => listSum a = listSum b\n  := by sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: sorted(test1)\n-/\n#guard_msgs in\n#eval sorted a + b\n\n/-\ninfo: sorted(test2)\n-/\n#guard_msgs in\n#eval sorted a + b\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval abs sum(a) - sum(b)\n\n/-\ninfo: sorted(test3)\n-/\n#guard_msgs in\n#eval sorted a + b"}
{"id": "fvapps_001711", "vc-description": "/-\n## Description\n\nBeggar Thy Neighbour is a card game taught to me by my parents when I was a small child, and is a game I like to play with my young kids today.\n\nIn this kata you will be given two player hands to be played.  And must return the index of the player who will win.\n\n## Rules of the game\n\n- Special cards are: Jacks, Queens, Kings and Aces\n- The object of the game is to win all the cards.\n- Any player that cannot play a card is out of the game.\n\nTo start:\n\n- The 52 cards in a standard deck are shuffled.\n- The cards are dealt equally between all players.\n\nTo play:\n\n- The first player turns over and plays the top card from their hand into a common pile.\n- If the card is not special - then the second player plays their next card onto the pile, and play continues back to the first player.\n- If the card is a Jack, Queen, King or Ace, the other player must play 1, 2, 3 or 4 penalty cards respectively.\n- If no special cards are played during a penalty, then the player that played the special card, takes the common pile.\n- If a special card is played during a penalty, then the penalty moves back to the previous player immediately with the size of the new penalty defined by the new special card.  It is possible for this process to repeat several times in one play.  Whoever played the last special card, wins the common pile.\n- The winner of the common pile, places it on the bottom of their hand, and then starts the next common pile.\n\nIt is theorised that an initial deal may never end, though so far all of my games have ended!  For that reason, if 10,000 cards are played and no one has won, return `None`.\n\n## Card Encoding\n\nCards are represented with a two character code.  The first characater will be one of A23456789TJQK representing Ace, 2 though 9, Ten, Jack, Queen, King respectively.  The second character is the suit, 'S', 'H', 'C', or 'D' representing Spades, Hearts, Clubs and Diamonds respectively.  \n\nFor example a hand of `[\"TD\", \"AC\", \"5H\"]` would represent 10 of Diamonds, Ace of Clubs, and 5 of hearts.\n\n## Mini Example Game\n\nGiven the following hands:\n\n`Player 1: [9C, JC, 2H, QC], Player 2: [TD, JH, 6H, 9S]`\n\nPlay would flow as follows:\n\n```\nStart   - P1: [9C, JC, 2H, QC],   P2: [TD, JH, 6H, 9S],           Common: []\nTurn  1 - P1: [JC, 2H, QC],       P2: [TD, JH, 6H, 9S],           Common: [9C]\nTurn  2 - P1: [JC, 2H, QC],       P2: [JH, 6H, 9S],               Common: [9C, TD]\nTurn  3 - P1: [2H, QC],           P2: [JH, 6H, 9S],               Common: [9C, TD, JC]\n```\nPlayer 1 plays a Jack, player 2 pays 1 penalty\n```\nTurn  4 - P1: [2H, QC],           P2: [6H, 9S],                   Common: [9C, TD, JC, JH]\n```\nPlayer 2 plays a Jack, player 1 pays 1 penalty\n```\nTurn  5 - P1: [QC],               P2: [6H, 9S],                   Common: [9C, TD, JC, JH, 2H]\n```\nPlayer 2 wins the common pool and starts the next game\n```\nTurn  6 - P1: [QC],               P2: [9S, 9C, TD, JC, JH, 2H],   Common: [6H]\nTurn  7 - P1: [],                 P2: [9S, 9C, TD, JC, JH, 2H],   Common: [6H, QC]\n```\nPlayer 1 plays a Queen, player 2 pays 2 penalties\n```\nTurn  8 - P1: [],                 P2: [9C, TD, JC, JH, 2H],       Common: [6H, QC, 9S]\nTurn  9 - P1: [],                 P2: [TD, JC, JH, 2H],           Common: [6H, QC, 9S, 9C]\n```\nPlayer 1 wins the common pool and starts the next game\n```\nTurn 10 - P1: [QC, 9S, 9C],       P2: [TD, JC, JH, 2H],           Common: [6H]\n\n```\nAnd so on... with player 2 eventually winning.\n\nGood luck!\n-/", "vc-preamble": "def Suit := Char\ndef Card := String", "vc-helpers": "", "vc-definitions": "def Hand := List Card\n\ndef who_wins_beggar_thy_neighbour (hands : List Hand) (special_cards : String := \"JQKA\") : Option Nat :=\n  sorry", "vc-theorems": "theorem game_always_terminates\n  (hands : List Hand) \n  (h1 : hands.length ≥ 2)\n  (h2 : hands.length ≤ 4) :\n  match who_wins_beggar_thy_neighbour hands with\n  | none => True\n  | some n => n ≥ 0 ∧ n < hands.length\n  := by sorry\n\ntheorem winner_validity \n  (hands : List Hand)\n  (special_cards : String)\n  (h1 : hands.length ≥ 2)\n  (h2 : hands.length ≤ 4) \n  (h3 : ∀ h ∈ hands, h.length > 0)\n  (h4 : ∀ c ∈ special_cards.toList, c ∈ ['J', 'Q', 'K', 'A']) :\n  match who_wins_beggar_thy_neighbour hands special_cards with\n  | none => True\n  | some n => n < hands.length\n  := by sorry\n\ntheorem custom_special_cards\n  (hands : List Hand)\n  (special_cards : String)\n  (h1 : hands.length ≥ 2)\n  (h2 : hands.length ≤ 4)\n  (h3 : special_cards.length > 0)\n  (h4 : special_cards.length ≤ 13)\n  (h5 : ∀ c ∈ special_cards.toList, c ∈ ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']) :\n  match who_wins_beggar_thy_neighbour hands special_cards with\n  | none => True\n  | some n => n ≥ 0 ∧ n < hands.length\n  := by sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval who_wins_beggar_thy_neighbour [\"9C\", \"JC\", \"2H\", \"QC\"] [\"TD\", \"JH\", \"6H\", \"9S\"]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval who_wins_beggar_thy_neighbour [\"KC\", \"2H\"] [\"AC\", \"3H\"]"}
{"id": "fvapps_001717", "vc-description": "/-\nYour task is to build a model^(1) which can predict y-coordinate.\nYou can pass tests if predicted y-coordinates are inside error margin.\n\nYou will receive train set which should be used to build a model. \nAfter you build a model tests will call function ```predict``` and pass x to it. \n\nError is going to be calculated with RMSE.\n\nSide note: Points in test cases are from different polynomials (up to 5th degree).\n\nEasier version: Data mining #1\n\nBlocked libraries: sklearn, pandas, tensorflow, numpy, scipy\n\nExplanation\n[1] A mining model is created by applying an algorithm to data, but it is more than an algorithm or a metadata container: it is a set of data, statistics, and patterns that can be applied to new data to generate predictions and make inferences about relationships.\n-/", "vc-preamble": "def Point := Float × Float \n\nstructure Datamining where\n  points : List Point", "vc-helpers": "", "vc-definitions": "def predict (m : Datamining) (x : Float) : Float := sorry\n\ndef abs (x : Float) : Float := sorry", "vc-theorems": "theorem predict_exact_points \n  {points : List Point}\n  {x0 y0 : Float}\n  (h_len : points.length = 5) \n  (h_unique : ∀ i j, i < j → i < points.length → j < points.length → \n    (points.get ⟨i, by sorry⟩).1 ≠ (points.get ⟨j, by sorry⟩).1) \n  (h_bounds : ∀ p ∈ points, -5 ≤ p.1 ∧ p.1 ≤ 5 ∧ -5 ≤ p.2 ∧ p.2 ≤ 5)\n  (h_spacing : ∀ i, i < points.length - 1 → \n    (points.get ⟨i+1, by sorry⟩).1 - (points.get ⟨i, by sorry⟩).1 > 0.1)\n  (h_point : (x0, y0) = points.get ⟨2, by sorry⟩) :\n  let m : Datamining := {points := points}\n  abs (predict m x0 - y0) < 0.000001 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"}
{"id": "fvapps_001742", "vc-description": "/-\nGiven the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions. \n\nEach function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.\n\nA log is a string has this format : function_id:start_or_end:timestamp. For example, \"0:start:0\" means function 0 starts from the very beginning of time 0. \"0:end:0\" means function 0 ends to the very end of time 0. \n\nExclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.\n\nExample 1:\n\nInput:\nn = 2\nlogs = \n[\"0:start:0\",\n \"1:start:2\",\n \"1:end:5\",\n \"0:end:6\"]\nOutput:[3, 4]\nExplanation:\nFunction 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. \nNow function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.\nFunction 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. \nSo function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.\n\nNote:\n\nInput logs will be sorted by timestamp, NOT log id.\nYour output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.\nTwo functions won't start or end at the same time.\nFunctions could be called recursively, and will always end.\n1\n-/", "vc-preamble": "def sum_nat_list : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum_nat_list xs", "vc-helpers": "", "vc-definitions": "def exclusive_time (n : Nat) (logs : List String) : List Nat := sorry\n\ntheorem exclusive_time_nonnegative {n : Nat} {logs : List String} :\n  ∀ t, t ∈ exclusive_time n logs → t ≥ 0\n  := sorry", "vc-theorems": "theorem exclusive_time_edge_cases :\n  exclusive_time 0 [] = [] ∧\n  exclusive_time 1 [] = [] ∧ \n  exclusive_time 0 [\"0:start:0\"] = []\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [3, 4]\n-/\n#guard_msgs in\n#eval exclusive_time 2 [\"0:start:0\", \"1:start:2\", \"1:end:5\", \"0:end:6\"]\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval exclusive_time 1 [\"0:start:0\", \"0:end:0\"]\n\n/-\ninfo: [2, 2]\n-/\n#guard_msgs in\n#eval exclusive_time 2 [\"0:start:0\", \"1:start:1\", \"1:end:2\", \"0:end:3\"]"}
{"id": "fvapps_001866", "vc-description": "/-\nIn a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\n\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position you can walk one step to the left, right, up or down.\nYou can't visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.\n\nExample 1:\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n [5,8,7],\n [0,9,0]]\nPath to get the maximum gold, 9 -> 8 -> 7.\n\nExample 2:\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n [2,0,6],\n [3,4,5],\n [0,3,0],\n [9,0,20]]\nPath to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n\nConstraints:\n\n1 <= grid.length, grid[i].length <= 15\n0 <= grid[i][j] <= 100\nThere are at most 25 cells containing gold.\n-/", "vc-preamble": "def sum (xs : List Nat) : Nat := \n  match xs with\n  | [] => 0\n  | h :: t => h + sum t\n\ndef sumOfLists (xss : List (List Nat)) : Nat :=\n  sum (xss.map sum)", "vc-helpers": "", "vc-definitions": "def get_maximum_gold (grid : List (List Nat)) : Nat := sorry \n\ntheorem result_less_than_total (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry", "vc-theorems": "theorem empty_grid_is_zero {w h : Nat} (grid : List (List Nat)) \n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w ∧ ∀ x ∈ row, x = 0) :\n  get_maximum_gold grid = 0 := sorry\n\ntheorem result_is_non_negative (grid : List (List Nat)) :\n  get_maximum_gold grid ≥ 0 := sorry\n\ntheorem grid_unchanged (grid original : List (List Nat)) :\n  original = grid →\n  get_maximum_gold grid = get_maximum_gold grid ∧ grid = original := sorry\n\ntheorem single_value {w h val : Nat} (grid : List (List Nat))\n  (h1 : grid.length = h)\n  (h2 : ∀ row ∈ grid, row.length = w)\n  (h3 : grid.head!.head! = val)\n  (h4 : ∀ (i j : Nat), (i,j) ≠ (0,0) → \n    i < h → j < w → (grid.get! i).get! j = 0) :\n  get_maximum_gold grid = val := sorry\n\ntheorem max_path_viable (grid : List (List Nat)) :\n  get_maximum_gold grid ≤ sumOfLists grid := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded\n\n/-\ninfo: 24\n-/\n#guard_msgs in\n#eval get_maximum_gold [[0, 6, 0], [5, 8, 7], [0, 9, 0]]\n\n/-\ninfo: 28\n-/\n#guard_msgs in\n#eval get_maximum_gold [[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]]\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval get_maximum_gold [[1, 1], [1, 1]]"}
{"id": "fvapps_001922", "vc-description": "/-\nMad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but n different heads that can read data in parallel.\n\nWhen viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the i-th reading head is above the track number h_{i}. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered h_1, h_2, ..., h_{n} have been read at the beginning of the operation. [Image] \n\nMike needs to read the data on m distinct tracks with numbers p_1, p_2, ..., p_{m}. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n, m (1 ≤ n, m ≤ 10^5) — the number of disk heads and the number of tracks to read, accordingly. The second line contains n distinct integers h_{i} in ascending order (1 ≤ h_{i} ≤ 10^10, h_{i} < h_{i} + 1) — the initial positions of the heads. The third line contains m distinct integers p_{i} in ascending order (1 ≤ p_{i} ≤ 10^10, p_{i} < p_{i} + 1) - the numbers of tracks to read.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.\n\n-----Output-----\n\nPrint a single number — the minimum time required, in seconds, to read all the needed tracks.\n\n-----Examples-----\nInput\n3 4\n2 5 6\n1 3 6 8\n\nOutput\n2\n\nInput\n3 3\n1 2 3\n1 2 3\n\nOutput\n0\n\nInput\n1 2\n165\n142 200\n\nOutput\n81\n\n-----Note-----\n\nThe first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way:   during the first second move the 1-st head to the left and let it stay there;  move the second head to the left twice;  move the third head to the right twice (note that the 6-th track has already been read at the beginning). \n\nOne cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.\n-/", "vc-preamble": "def Sorted (as : List Nat) : Prop :=\n  ∀ i j, i < j → j < as.length → as[i]! < as[j]!", "vc-helpers": "", "vc-definitions": "def find_min_time (n m : Nat) (heads tracks : List Nat) : Nat := sorry\n\ntheorem find_min_time_non_negative (n m : Nat) (heads tracks : List Nat)\n  (h1 : heads.length = n)\n  (h2 : tracks.length = m)\n  (h3 : Sorted heads)\n  (h4 : Sorted tracks) :\n  find_min_time n m heads tracks ≥ 0 := sorry", "vc-theorems": "theorem find_min_time_perfect_alignment (n m : Nat) (heads tracks : List Nat)\n  (h1 : heads.length = n)\n  (h2 : tracks.length = m)\n  (h3 : Sorted heads)\n  (h4 : Sorted tracks)\n  (h5 : ∀ t ∈ tracks, t ∈ heads) :\n  find_min_time n m heads tracks = 0 := sorry\n\ntheorem find_min_time_monotonic_heads (n m : Nat) (heads tracks : List Nat) \n  (new_head : Nat)\n  (h1 : heads.length = n)\n  (h2 : tracks.length = m)\n  (h3 : Sorted heads)\n  (h4 : Sorted tracks)\n  (h5 : ∀ h ∈ heads, h < new_head) :\n  find_min_time (n+1) m (heads ++ [new_head]) tracks ≤ \n  find_min_time n m heads tracks := sorry\n\ntheorem find_min_time_monotonic_tracks (n m : Nat) (heads tracks : List Nat)\n  (new_track : Nat)\n  (h1 : heads.length = n)\n  (h2 : tracks.length = m)\n  (h3 : Sorted heads)\n  (h4 : Sorted tracks)\n  (h5 : ∀ t ∈ tracks, t < new_track) :\n  find_min_time n (m+1) heads (tracks ++ [new_track]) ≥\n  find_min_time n m heads tracks := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_time 3 4 [2, 5, 6] [1, 3, 6, 8]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval find_min_time 3 3 [1, 2, 3] [1, 2, 3]\n\n/-\ninfo: 81\n-/\n#guard_msgs in\n#eval find_min_time 1 2 [165] [142, 200]"}
{"id": "fvapps_001982", "vc-description": "/-\nWatchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are n watchmen on a plane, the i-th watchman is located at point (x_{i}, y_{i}).\n\nThey need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen i and j to be |x_{i} - x_{j}| + |y_{i} - y_{j}|. Daniel, as an ordinary person, calculates the distance using the formula $\\sqrt{(x_{i} - x_{j})^{2} +(y_{i} - y_{j})^{2}}$.\n\nThe success of the operation relies on the number of pairs (i, j) (1 ≤ i < j ≤ n), such that the distance between watchman i and watchmen j calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.\n\n-----Input-----\n\nThe first line of the input contains the single integer n (1 ≤ n ≤ 200 000) — the number of watchmen.\n\nEach of the following n lines contains two integers x_{i} and y_{i} (|x_{i}|, |y_{i}| ≤ 10^9).\n\nSome positions may coincide.\n\n-----Output-----\n\nPrint the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.\n\n-----Examples-----\nInput\n3\n1 1\n7 5\n1 5\n\nOutput\n2\n\nInput\n6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n\nOutput\n11\n\n-----Note-----\n\nIn the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and $\\sqrt{(1 - 7)^{2} +(1 - 5)^{2}} = 2 \\cdot \\sqrt{13}$ for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.\n-/", "vc-preamble": "def Point := List Int\ndef Points := List Point\n\ninstance : BEq Point where\n  beq a b := a.zip b |>.all (fun (x, y) => x == y)", "vc-helpers": "", "vc-definitions": "def countEqualDistances (points : Points) : Nat :=\n  sorry", "vc-theorems": "theorem count_always_nonnegative (points : Points) :\n  countEqualDistances points ≥ 0 := sorry\n\ntheorem single_point_returns_zero (p : Point) :\n  let points : Points := [p]\n  countEqualDistances points = 0 := sorry\n\ntheorem points_on_line (x : Int) :\n  let points : Points := [[x, 0], [x, 1], [x, 2], [x, 3], [x, 4]]\n  countEqualDistances points = 10 := sorry\n\ntheorem permutation_invariant (points points' : Points) :\n  points.length = points'.length →\n  (∀ p, List.elem p points ↔ List.elem p points') →\n  countEqualDistances points = countEqualDistances points' := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval count_equal_distances [[1, 1], [7, 5], [1, 5]]\n\n/-\ninfo: 11\n-/\n#guard_msgs in\n#eval count_equal_distances [[0, 0], [0, 1], [0, 2], [-1, 1], [0, 1], [1, 1]]\n\n/-\ninfo: 33\n-/\n#guard_msgs in\n#eval count_equal_distances [[46, -55], [46, 45], [46, 45], [83, -55], [46, 45], [83, -55], [46, 45], [83, 45], [83, 45], [46, -55]]"}
{"id": "fvapps_001997", "vc-description": "/-\nVasya has n items lying in a line. The items are consecutively numbered by numbers from 1 to n in such a way that the leftmost item has number 1, the rightmost item has number n. Each item has a weight, the i-th item weights w_{i} kilograms.\n\nVasya needs to collect all these items, however he won't do it by himself. He uses his brand new robot. The robot has two different arms — the left one and the right one. The robot can consecutively perform the following actions:   Take the leftmost item with the left hand and spend w_{i} · l energy units (w_{i} is a weight of the leftmost item, l is some parameter). If the previous action was the same (left-hand), then the robot spends extra Q_{l} energy units;  Take the rightmost item with the right hand and spend w_{j} · r energy units (w_{j} is a weight of the rightmost item, r is some parameter). If the previous action was the same (right-hand), then the robot spends extra Q_{r} energy units; \n\nNaturally, Vasya wants to program the robot in a way that the robot spends as little energy as possible. He asked you to solve this problem. Your task is to find the minimum number of energy units robot spends to collect all items.\n\n-----Input-----\n\nThe first line contains five integers n, l, r, Q_{l}, Q_{r} (1 ≤ n ≤ 10^5; 1 ≤ l, r ≤ 100; 1 ≤ Q_{l}, Q_{r} ≤ 10^4).\n\nThe second line contains n integers w_1, w_2, ..., w_{n} (1 ≤ w_{i} ≤ 100).\n\n-----Output-----\n\nIn the single line print a single number — the answer to the problem.\n\n-----Examples-----\nInput\n3 4 4 19 1\n42 3 99\n\nOutput\n576\n\nInput\n4 7 2 3 9\n1 2 3 4\n\nOutput\n34\n\n-----Note-----\n\nConsider the first sample. As l = r, we can take an item in turns: first from the left side, then from the right one and last item from the left. In total the robot spends 4·42 + 4·99 + 4·3 = 576 energy units.\n\nThe second sample. The optimal solution is to take one item from the right, then one item from the left and two items from the right. In total the robot spends (2·4) + (7·1) + (2·3) + (2·2 + 9) = 34 energy units.\n-/", "vc-preamble": "def sum_list : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def min_robot_energy (n : Nat) (l r ql qr : Nat) (weights : List Nat) : Nat :=\n  sorry\n\n-- Result should be non-negative and within bounds", "vc-theorems": "theorem min_robot_energy_bounds (n : Nat) (l r ql qr : Nat) (weights : List Nat)\n    (h1 : n > 0) (h2 : l > 0) (h3 : r > 0) (h4 : weights.length = n) :\n    let result := min_robot_energy n l r ql qr weights\n    let total_weight := sum_list weights\n    result ≥ 0 ∧ \n    result ≥ min l r * total_weight ∧\n    result ≤ max l r * total_weight + max ql qr * n :=\n  sorry\n\n-- When no penalties, result equals minimum cost times weight sum\n\ntheorem min_robot_energy_no_penalties (n : Nat) (l r : Nat) (weights : List Nat)\n    (h1 : n > 0) (h2 : l > 0) (h3 : r > 0) (h4 : weights.length = n) :\n    min_robot_energy n l r 0 0 weights = min (l * sum_list weights) (r * sum_list weights) :=\n  sorry\n\n-- When costs are equal, result is at least sum of weights\n\ntheorem min_robot_energy_equal_costs (n : Nat) (ql qr : Nat) (weights : List Nat) \n    (h1 : n > 0) (h2 : weights.length = n) :\n    min_robot_energy n 1 1 ql qr weights ≥ sum_list weights :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded\n\n/-\ninfo: 576\n-/\n#guard_msgs in\n#eval min_robot_energy 3 4 4 19 1 [42, 3, 99]\n\n/-\ninfo: 34\n-/\n#guard_msgs in\n#eval min_robot_energy 4 7 2 3 9 [1, 2, 3, 4]\n\n/-\ninfo: 20000\n-/\n#guard_msgs in\n#eval min_robot_energy 2 100 100 10000 10000 [100, 100]"}
{"id": "fvapps_002026", "vc-description": "/-\nMike is the president of country What-The-Fatherland. There are n bears living in this country besides Mike. All of them are standing in a line and they are numbered from 1 to n from left to right. i-th bear is exactly a_{i} feet high. \n\n [Image] \n\nA group of bears is a non-empty contiguous segment of the line. The size of a group is the number of bears in that group. The strength of a group is the minimum height of the bear in that group.\n\nMike is a curious to know for each x such that 1 ≤ x ≤ n the maximum strength among all groups of size x.\n\n-----Input-----\n\nThe first line of input contains integer n (1 ≤ n ≤ 2 × 10^5), the number of bears.\n\nThe second line contains n integers separated by space, a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9), heights of bears.\n\n-----Output-----\n\nPrint n integers in one line. For each x from 1 to n, print the maximum strength among all groups of size x.\n\n-----Examples-----\nInput\n10\n1 2 3 4 5 4 3 2 1 6\n\nOutput\n6 4 4 3 3 2 2 1 1 1\n-/", "vc-preamble": "def maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h::t => List.foldl max h t", "vc-helpers": "", "vc-definitions": "def find_max_group_strengths (n : Nat) (heights : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem length_matches_input \n  {n : Nat} {heights : List Nat} \n  (h1 : heights.length > 0) (h2 : heights.length = n) \n  (h3 : ∀ x ∈ heights, x > 0 ∧ x ≤ 10^9) :\n  (find_max_group_strengths n heights).length = n :=\nsorry\n\ntheorem monotonically_decreasing\n  {n : Nat} {heights : List Nat}\n  (h1 : heights.length > 0) (h2 : heights.length = n)\n  (h3 : ∀ x ∈ heights, x > 0 ∧ x ≤ 10^9) :\n  ∀ i, i + 1 < n → \n    (find_max_group_strengths n heights)[i]! ≥ (find_max_group_strengths n heights)[i+1]! :=\nsorry\n\ntheorem first_value_is_max\n  {n : Nat} {heights : List Nat}\n  (h1 : heights.length > 0) (h2 : heights.length = n)\n  (h3 : ∀ x ∈ heights, x > 0 ∧ x ≤ 10^9) :\n  (find_max_group_strengths n heights)[0]! ≤ maximum heights :=\nsorry\n\ntheorem preserves_input\n  {n : Nat} {heights heights_copy : List Nat}\n  (h1 : heights.length > 0) (h2 : heights.length = n)\n  (h3 : heights = heights_copy)\n  (h4 : ∀ x ∈ heights, x > 0) :\n  let _ := find_max_group_strengths n heights_copy\n  heights = heights_copy :=\nsorry\n\ntheorem last_value_positive\n  {n : Nat} {heights : List Nat}\n  (h1 : heights.length > 0) (h2 : heights.length = n)\n  (h3 : ∀ x ∈ heights, x > 0 ∧ x ≤ 10^9) :\n  (find_max_group_strengths n heights)[heights.length - 1]! > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: [6, 4, 4, 3, 3, 2, 2, 1, 1, 1]\n-/\n#guard_msgs in\n#eval find_max_group_strengths 10 heights1.copy()\n\n/-\ninfo: [923264237, 524125987, 374288891]\n-/\n#guard_msgs in\n#eval find_max_group_strengths 3 heights2.copy()\n\n/-\ninfo: [585325539, 365329221, 365329221, 291882089, 291882089]\n-/\n#guard_msgs in\n#eval find_max_group_strengths 5 heights3.copy()"}
{"id": "fvapps_002064", "vc-description": "/-\nYou are given a set Y of n distinct positive integers y_1, y_2, ..., y_{n}.\n\nSet X of n distinct positive integers x_1, x_2, ..., x_{n} is said to generate set Y if one can transform X to Y by applying some number of the following two operation to integers in X:  Take any integer x_{i} and multiply it by two, i.e. replace x_{i} with 2·x_{i}.  Take any integer x_{i}, multiply it by two and add one, i.e. replace x_{i} with 2·x_{i} + 1. \n\nNote that integers in X are not required to be distinct after each operation.\n\nTwo sets of distinct integers X and Y are equal if they are equal as sets. In other words, if we write elements of the sets in the array in the increasing order, these arrays would be equal.\n\nNote, that any set of integers (or its permutation) generates itself.\n\nYou are given a set Y and have to find a set X that generates Y and the maximum element of X is mininum possible.\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 50 000) — the number of elements in Y.\n\nThe second line contains n integers y_1, ..., y_{n} (1 ≤ y_{i} ≤ 10^9), that are guaranteed to be distinct.\n\n-----Output-----\n\nPrint n integers — set of distinct integers that generate Y and the maximum element of which is minimum possible. If there are several such sets, print any of them.\n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n\nOutput\n4 5 2 3 1 \n\nInput\n6\n15 14 3 13 1 12\n\nOutput\n12 13 14 7 3 1 \n\nInput\n6\n9 7 13 17 5 11\n\nOutput\n4 5 2 6 3 1\n-/", "vc-preamble": "def List.maximum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| (x::xs) => List.foldl Nat.max x xs", "vc-helpers": "", "vc-definitions": "def min_max_generating_set (numbers: List Nat) : List Nat :=\nsorry", "vc-theorems": "theorem one_in_gen_set (numbers: List Nat) (h: numbers ≠ []) : \n  1 ∈ min_max_generating_set numbers :=\nsorry\n\ntheorem max_output_bounded (numbers: List Nat) (h: numbers ≠ []) :\n  ∀ x ∈ min_max_generating_set numbers, x ≤ List.maximum numbers :=\nsorry\n\ntheorem output_size_bounded (numbers: List Nat) :\n  List.length (min_max_generating_set numbers) ≤ List.length numbers :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: {1, 2, 3, 4, 5}\n-/\n#guard_msgs in\n#eval set min_max_generating_set(input1)\n\n/-\ninfo: {1, 3, 7, 12, 13, 14}\n-/\n#guard_msgs in\n#eval set min_max_generating_set(input2)\n\n/-\ninfo: {1, 2, 3, 4, 5, 6}\n-/\n#guard_msgs in\n#eval set min_max_generating_set(input3)"}
{"id": "fvapps_002081", "vc-description": "/-\nLet's consider a simplified version of order book of some stock. The order book is a list of orders (offers) from people that want to buy or sell one unit of the stock, each order is described by direction (BUY or SELL) and price.\n\nAt every moment of time, every SELL offer has higher price than every BUY offer. \n\nIn this problem no two ever existed orders will have the same price.\n\nThe lowest-price SELL order and the highest-price BUY order are called the best offers, marked with black frames on the picture below. [Image] The presented order book says that someone wants to sell the product at price $12$ and it's the best SELL offer because the other two have higher prices. The best BUY offer has price $10$. \n\nThere are two possible actions in this orderbook:  Somebody adds a new order of some direction with some price. Somebody accepts the best possible SELL or BUY offer (makes a deal). It's impossible to accept not the best SELL or BUY offer (to make a deal at worse price). After someone accepts the offer, it is removed from the orderbook forever.\n\nIt is allowed to add new BUY order only with prices less than the best SELL offer (if you want to buy stock for higher price, then instead of adding an order you should accept the best SELL offer). Similarly, one couldn't add a new SELL order with price less or equal to the best BUY offer. For example, you can't add a new offer \"SELL $20$\" if there is already an offer \"BUY $20$\" or \"BUY $25$\" — in this case you just accept the best BUY offer.\n\nYou have a damaged order book log (in the beginning the are no orders in book). Every action has one of the two types: \"ADD $p$\" denotes adding a new order with price $p$ and unknown direction. The order must not contradict with orders still not removed from the order book.  \"ACCEPT $p$\" denotes accepting an existing best offer with price $p$ and unknown direction.\n\nThe directions of all actions are lost. Information from the log isn't always enough to determine these directions. Count the number of ways to correctly restore all ADD action directions so that all the described conditions are satisfied at any moment. Since the answer could be large, output it modulo $10^9 + 7$. If it is impossible to correctly restore directions, then output $0$.\n\n-----Input-----\n\nThe first line contains an integer $n$ ($1 \\le n \\le 363\\,304$) — the number of actions in the log.\n\nEach of the next $n$ lines contains a string \"ACCEPT\" or \"ADD\" and an integer $p$ ($1 \\le p \\le 308\\,983\\,066$), describing an action type and price. \n\nAll ADD actions have different prices. For ACCEPT action it is guaranteed that the order with the same price has already been added but has not been accepted yet.\n\n-----Output-----\n\nOutput the number of ways to restore directions of ADD actions modulo $10^9 + 7$.\n\n-----Examples-----\nInput\n6\nADD 1\nACCEPT 1\nADD 2\nACCEPT 2\nADD 3\nACCEPT 3\n\nOutput\n8\n\nInput\n4\nADD 1\nADD 2\nADD 3\nACCEPT 2\n\nOutput\n2\n\nInput\n7\nADD 1\nADD 2\nADD 3\nADD 4\nADD 5\nACCEPT 3\nACCEPT 5\n\nOutput\n0\n\n-----Note-----\n\nIn the first example each of orders may be BUY or SELL.\n\nIn the second example the order with price $1$ has to be BUY order, the order with the price $3$ has to be SELL order.\n-/", "vc-preamble": "def Action : Type := (String × Nat)\ndef Actions : Type := List Action", "vc-helpers": "", "vc-definitions": "def solve_order_book (actions: Actions) : Nat := sorry\n\ntheorem solve_multiple_possibilities :\n  let test_actions := [(\"ADD\", 5), (\"ADD\", 5), (\"ACCEPT\", 5)]\n  solve_order_book test_actions = 2 := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_order_book [(\"ADD\", 1), (\"ACCEPT\", 1), (\"ADD\", 2), (\"ACCEPT\", 2), (\"ADD\", 3), (\"ACCEPT\", 3)]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_order_book [(\"ADD\", 1), (\"ADD\", 2), (\"ADD\", 3), (\"ACCEPT\", 2)]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_order_book [(\"ADD\", 1), (\"ADD\", 2), (\"ADD\", 3), (\"ADD\", 4), (\"ADD\", 5), (\"ACCEPT\", 3), (\"ACCEPT\", 5)]"}
{"id": "fvapps_002094", "vc-description": "/-\nT is playing a game with his friend, HL.\n\nThere are $n$ piles of stones, the $i$-th pile initially has $a_i$ stones. \n\nT and HL will take alternating turns, with T going first. In each turn, a player chooses a non-empty pile and then removes a single stone from it. However, one cannot choose a pile that has been chosen in the previous turn (the pile that was chosen by the other player, or if the current turn is the first turn then the player can choose any non-empty pile). The player who cannot choose a pile in his turn loses, and the game ends.\n\nAssuming both players play optimally, given the starting configuration of $t$ games, determine the winner of each game.\n\n-----Input-----\n\nThe first line of the input contains a single integer $t$ $(1 \\le t \\le 100)$ — the number of games. The description of the games follows. Each description contains two lines:\n\nThe first line contains a single integer $n$ $(1 \\le n \\le 100)$ — the number of piles.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ $(1 \\le a_i \\le 100)$.\n\n-----Output-----\n\nFor each game, print on a single line the name of the winner, \"T\" or \"HL\" (without quotes)\n\n-----Example-----\nInput\n2\n1\n2\n2\n1 1\n\nOutput\nT\nHL\n\n-----Note-----\n\nIn the first game, T removes a single stone from the only pile in his first turn. After that, although the pile still contains $1$ stone, HL cannot choose from this pile because it has been chosen by T in the previous turn. Therefore, T is the winner.\n-/", "vc-preamble": "def sum (l: List Nat) : Nat := \n  match l with\n  | [] => 0\n  | h::t => h + sum t", "vc-helpers": "", "vc-definitions": "def solve_stone_game (n : Nat) (stones : List Nat) : String := sorry\n\n-- Properties for solve_stone_game", "vc-theorems": "theorem solve_stone_game_valid_output (n : Nat) (stones : List Nat) :\n  let result := solve_stone_game n stones\n  result = \"T\" ∨ result = \"HL\" := sorry\n\ntheorem solve_stone_game_majority_stone (n : Nat) (stones : List Nat) :\n  let total := sum stones\n  (∃ x ∈ stones, x * 2 > total) →\n  solve_stone_game n stones = \"T\" := sorry\n\ntheorem solve_stone_game_odd_sum (n : Nat) (stones : List Nat) :\n  sum stones % 2 ≠ 0 →\n  solve_stone_game n stones = \"T\" := sorry\n\ntheorem solve_stone_game_even_sum_no_majority (n : Nat) (stones : List Nat) :\n  sum stones % 2 = 0 →\n  (∀ x ∈ stones, x * 2 ≤ sum stones) →\n  solve_stone_game n stones = \"HL\" := sorry\n\ntheorem solve_stone_game_single (stone : Nat) :\n  stone > 0 →\n  solve_stone_game 1 [stone] = \"T\" := sorry\n\ntheorem solve_stone_game_equal_stones_even (n : Nat) :\n  n % 2 = 0 →\n  solve_stone_game n (List.replicate n 1) = \"HL\" := sorry\n\ntheorem solve_stone_game_equal_stones_odd (n : Nat) :\n  n % 2 ≠ 0 →\n  solve_stone_game n (List.replicate n 1) = \"T\" := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 'T'\n-/\n#guard_msgs in\n#eval solve_stone_game 1 [2]\n\n/-\ninfo: 'HL'\n-/\n#guard_msgs in\n#eval solve_stone_game 2 [1, 1]\n\n/-\ninfo: 'HL'\n-/\n#guard_msgs in\n#eval solve_stone_game 4 [2, 3, 1, 2]\n\n/-\ninfo: 'HL'\n-/\n#guard_msgs in\n#eval solve_stone_game 3 [2, 1, 1]"}
{"id": "fvapps_002097", "vc-description": "/-\nJohn Smith knows that his son, Thomas Smith, is among the best students in his class and even in his school. After the students of the school took the exams in English, German, Math, and History, a table of results was formed.\n\nThere are $n$ students, each of them has a unique id (from $1$ to $n$). Thomas's id is $1$. Every student has four scores correspond to his or her English, German, Math, and History scores. The students are given in order of increasing of their ids.\n\nIn the table, the students will be sorted by decreasing the sum of their scores. So, a student with the largest sum will get the first place. If two or more students have the same sum, these students will be sorted by increasing their ids. \n\nPlease help John find out the rank of his son. \n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 1000$) — the number of students.\n\nEach of the next $n$ lines contains four integers $a_i$, $b_i$, $c_i$, and $d_i$ ($0\\leq a_i, b_i, c_i, d_i\\leq 100$) — the grades of the $i$-th student on English, German, Math, and History. The id of the $i$-th student is equal to $i$.\n\n-----Output-----\n\nPrint the rank of Thomas Smith. Thomas's id is $1$.\n\n-----Examples-----\nInput\n5\n100 98 100 100\n100 100 100 100\n100 100 99 99\n90 99 90 100\n100 98 60 99\n\nOutput\n2\n\nInput\n6\n100 80 90 99\n60 60 60 60\n90 60 100 60\n60 100 60 80\n100 100 0 100\n0 0 0 0\n\nOutput\n1\n\n-----Note-----\n\nIn the first sample, the students got total scores: $398$, $400$, $398$, $379$, and $357$. Among the $5$ students, Thomas and the third student have the second highest score, but Thomas has a smaller id, so his rank is $2$.\n\nIn the second sample, the students got total scores: $369$, $240$, $310$, $300$, $300$, and $0$. Among the $6$ students, Thomas got the highest score, so his rank is $1$.\n-/", "vc-preamble": "def sumList (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h::t => h + sumList t", "vc-helpers": "", "vc-definitions": "def find_thomas_rank (n : Nat) (scores : List (List Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem thomas_rank_in_range {n : Nat} {scores : List (List Nat)} \n  (h1 : n > 0) \n  (h2 : scores.length = n)\n  (h3 : ∀ s ∈ scores, s.length = 4)\n  (h4 : ∀ s ∈ scores, ∀ x ∈ s, x ≤ 100) :\n  let rank := find_thomas_rank n scores\n  1 ≤ rank ∧ rank ≤ n :=\nsorry\n\ntheorem thomas_rank_counts_better_scores {n : Nat} {scores : List (List Nat)}\n  (h1 : n > 0)\n  (h2 : scores.length = n) \n  (h3 : ∀ s ∈ scores, s.length = 4)\n  (h4 : ∀ s ∈ scores, ∀ x ∈ s, x ≤ 100) :\n  let rank := find_thomas_rank n scores\n  let thomas_total := sumList scores.head!\n  let better_scores := (scores.tail.filter (fun s => sumList s > thomas_total)).length\n  better_scores = rank - 1 :=\nsorry\n\ntheorem equal_scores_gives_first {n : Nat} {score : Nat} {scores : List (List Nat)}\n  (h1 : n > 0)\n  (h2 : score ≤ 100)\n  (h3 : scores = List.replicate n (List.replicate 4 score)) :\n  find_thomas_rank n scores = 1 :=\nsorry\n\ntheorem single_student_first :\n  find_thomas_rank 1 [[0,0,0,0]] = 1 :=\nsorry\n\ntheorem lowest_score_gives_last :\n  find_thomas_rank 3 [[0,0,0,0], [100,100,100,100], [100,100,100,100]] = 3 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_thomas_rank 5 [[100, 98, 100, 100], [100, 100, 100, 100], [100, 100, 99, 99], [90, 99, 90, 100], [100, 98, 60, 99]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_thomas_rank 6 [[100, 80, 90, 99], [60, 60, 60, 60], [90, 60, 100, 60], [60, 100, 60, 80], [100, 100, 0, 100], [0, 0, 0, 0]]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_thomas_rank 1 [[0, 0, 0, 0]]"}
{"id": "fvapps_002149", "vc-description": "/-\nWabbit is trying to move a box containing food for the rest of the zoo in the coordinate plane from the point $(x_1,y_1)$ to the point $(x_2,y_2)$.\n\nHe has a rope, which he can use to pull the box. He can only pull the box if he stands exactly $1$ unit away from the box in the direction of one of two coordinate axes. He will pull the box to where he is standing before moving out of the way in the same direction by $1$ unit.  [Image] \n\nFor example, if the box is at the point $(1,2)$ and Wabbit is standing at the point $(2,2)$, he can pull the box right by $1$ unit, with the box ending up at the point $(2,2)$ and Wabbit ending at the point $(3,2)$.\n\nAlso, Wabbit can move $1$ unit to the right, left, up, or down without pulling the box. In this case, it is not necessary for him to be in exactly $1$ unit away from the box. If he wants to pull the box again, he must return to a point next to the box. Also, Wabbit can't move to the point where the box is located.\n\nWabbit can start at any point. It takes $1$ second to travel $1$ unit right, left, up, or down, regardless of whether he pulls the box while moving.\n\nDetermine the minimum amount of time he needs to move the box from $(x_1,y_1)$ to $(x_2,y_2)$. Note that the point where Wabbit ends up at does not matter.\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains a single integer $t$ $(1 \\leq t \\leq 1000)$: the number of test cases. The description of the test cases follows.\n\nEach of the next $t$ lines contains four space-separated integers $x_1, y_1, x_2, y_2$ $(1 \\leq x_1, y_1, x_2, y_2 \\leq 10^9)$, describing the next test case.\n\n-----Output-----\n\nFor each test case, print a single integer: the minimum time in seconds Wabbit needs to bring the box from $(x_1,y_1)$ to $(x_2,y_2)$.\n\n-----Example-----\nInput\n2\n1 2 2 2\n1 1 2 2\n\nOutput\n1\n4\n\n-----Note-----\n\nIn the first test case, the starting and the ending points of the box are $(1,2)$ and $(2,2)$ respectively. This is the same as the picture in the statement. Wabbit needs only $1$ second to move as shown in the picture in the statement.\n\nIn the second test case, Wabbit can start at the point $(2,1)$. He pulls the box to $(2,1)$ while moving to $(3,1)$. He then moves to $(3,2)$ and then to $(2,2)$ without pulling the box. Then, he pulls the box to $(2,2)$ while moving to $(2,3)$. It takes $4$ seconds.\n-/", "vc-preamble": "def abs (n : Int) : Int := \n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def solve_wabbit (x1 y1 x2 y2 : Int) : Int := sorry\n\ntheorem wabbit_nonnegative (x1 y1 x2 y2 : Int) :\n  solve_wabbit x1 y1 x2 y2 ≥ 0 := sorry", "vc-theorems": "theorem wabbit_same_point (x y : Int) :\n  solve_wabbit x y x y = 0 := sorry\n\ntheorem wabbit_symmetry (x1 y1 x2 y2 : Int) :\n  solve_wabbit x1 y1 x2 y2 = solve_wabbit x2 y2 x1 y1 := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_wabbit 1 2 2 2\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve_wabbit 1 1 2 2\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_wabbit 69 69 69 69\n\n/-\ninfo: 262146\n-/\n#guard_msgs in\n#eval solve_wabbit 1 1 131073 131073"}
{"id": "fvapps_002189", "vc-description": "/-\nWe have a board with an H \\times W grid.\nEach square in the grid is painted in black or white. The square at the i-th row from the top and j-th column from the left is black if the j-th character in S_i is #, and white if that character is ..\nSnuke can perform the following operation on the grid any number of times:\n - Select a row or column in the grid, and invert the color of all the squares in that row or column (that is, black squares become white and vice versa).\nThen, Snuke draws a rectangle along grid lines. Here, all the squares contained in the rectangle must be painted in black.\nFind the maximum possible area of Snuke's rectangle when the operation is performed optimally.\n\n-----Constraints-----\n - 2 \\leq H \\leq 2000\n - 2 \\leq W \\leq 2000\n - |S_i| = W\n - S_i consists of # and ..\n\n-----Input-----\nInput is given from Standard Input in the following format:\nH W\nS_1\nS_2\n:\nS_H\n\n-----Output-----\nPrint the maximum possible area of Snuke's rectangle.\n\n-----Sample Input-----\n3 3\n..#\n##.\n.#.\n\n-----Sample Output-----\n6\n\nIf the first row from the top and the third column from the left are inverted, a 2 \\times 3 rectangle can be drawn, as shown below:\n-/", "vc-preamble": "def toString (c : Char) : String := String.mk [c]\n\ndef mkString (n : Nat) (c : Char) : String := \n  String.mk (List.replicate n c)", "vc-helpers": "", "vc-definitions": "def solve_max_rectangle (h w : Nat) (grid : List String) : Nat := sorry\n\ntheorem solve_max_rectangle_dimensions {h w : Nat} (hge2 : h ≥ 2) (wge2 : w ≥ 2) \n    (grid : List String) (grid_all_dots : ∀ i < h, grid.get? i = some (mkString w '.')) :\n  let result := solve_max_rectangle h w grid\n  result ≥ max h w ∧ result ≤ h * w := sorry", "vc-theorems": "theorem solve_max_rectangle_positive {h w : Nat} (hge2 : h ≥ 2) (wge2 : w ≥ 2)\n    (grid : List String) (grid_valid : grid.length ≥ h ∧ ∀ row ∈ grid, row.length ≥ w) :\n  let grid' := (grid.take h).map (λ row => row.take w)\n  let result := solve_max_rectangle h w grid'\n  result > 0 ∧ (∃ n : Nat, result = n) := sorry\n\ntheorem solve_max_rectangle_identical_rows {n : Nat} (nge2 : n ≥ 2) :\n  let grid := List.replicate n (mkString n '.')\n  solve_max_rectangle n n grid = n * n := sorry\n\ntheorem solve_max_rectangle_alternating_pattern {n : Nat} (nge2 : n ≥ 2) :\n  let grid := List.range n |>.map (λ i =>\n    List.range n |>.map (λ j => if (i + j) % 2 = 0 then '#' else '.') |>.asString)\n  solve_max_rectangle n n grid ≥ n := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval solve_max_rectangle 3 3 [\"..#\", \"##.\", \".#.\"]\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval solve_max_rectangle 4 4 [\"....\", \"....\", \"....\", \"....\"]\n\n/-\ninfo: 27\n-/\n#guard_msgs in\n#eval solve_max_rectangle 10 8 [\"##...#.#\", \"##...#.#\", \"..###.#.\", \"#.##.#.#\", \".#..#.#.\", \"..##.#.#\", \"##.#.#..\", \"...#.#..\", \"###.#.##\", \"###..###\"]"}
{"id": "fvapps_002192", "vc-description": "/-\nThere is an integer sequence of length 2^N: A_0, A_1, ..., A_{2^N-1}. (Note that the sequence is 0-indexed.)\nFor every integer K satisfying 1 \\leq K \\leq 2^N-1, solve the following problem:\n - Let i and j be integers. Find the maximum value of A_i + A_j where 0 \\leq i < j \\leq 2^N-1 and (i or j) \\leq K.\nHere, or denotes the bitwise OR.\n\n-----Constraints-----\n - 1 \\leq N \\leq 18\n - 1 \\leq A_i \\leq 10^9\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nA_0 A_1 ... A_{2^N-1}\n\n-----Output-----\nPrint 2^N-1 lines.\nIn the i-th line, print the answer of the problem above for K=i.\n\n-----Sample Input-----\n2\n1 2 3 1\n\n-----Sample Output-----\n3\n4\n5\n\nFor K=1, the only possible pair of i and j is (i,j)=(0,1), so the answer is A_0+A_1=1+2=3.\nFor K=2, the possible pairs of i and j are (i,j)=(0,1),(0,2).\nWhen (i,j)=(0,2), A_i+A_j=1+3=4. This is the maximum value, so the answer is 4.\nFor K=3, the possible pairs of i and j are (i,j)=(0,1),(0,2),(0,3),(1,2),(1,3),(2,3) .\nWhen (i,j)=(1,2), A_i+A_j=2+3=5. This is the maximum value, so the answer is 5.\n-/", "vc-preamble": "def pow2 (n : Nat) : Nat :=\n  1 <<< n", "vc-helpers": "", "vc-definitions": "def solveSequencePairs (N : Nat) (A : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem result_length (N : Nat) (h : 0 < N) (h2 : N ≤ 4) :\n  let A := List.range (pow2 N)\n  let result := solveSequencePairs N A\n  result.length = pow2 N - 1 :=\nsorry\n\ntheorem result_monotonic (N : Nat) (A : List Nat) (h : 0 < N) (h2 : N ≤ 4) :\n  A.length = pow2 N →\n  let result := solveSequencePairs N A\n  ∀ i, i + 1 < result.length → \n    (result.get? i).isSome → (result.get? (i+1)).isSome →\n    (result.get! i) ≤ (result.get! (i+1)) :=\nsorry\n\ntheorem result_bounded_by_max_sum (N : Nat) (A : List Nat) (h : 0 < N) (h2 : N ≤ 4) :\n  A.length = pow2 N →\n  let result := solveSequencePairs N A\n  let max_elem := List.foldl Nat.max 0 A\n  let second_max := List.foldl (fun acc x => if x < max_elem then Nat.max acc x else acc) 0 A\n  ∀ x ∈ result, x ≤ max_elem + second_max :=\nsorry\n\ntheorem identical_inputs (N : Nat) (h : 0 < N) (h2 : N ≤ 4) :\n  let A := List.replicate (pow2 N) 1\n  let result := solveSequencePairs N A\n  ∀ x ∈ result, x = 2 :=\nsorry\n\ntheorem single_nonzero (N : Nat) (h : 0 < N) (h2 : N ≤ 4) :\n  let A := 1 :: List.replicate (pow2 N - 1) 0\n  let result := solveSequencePairs N A\n  (result.get? 0).isSome → 1 ≤ result.get! 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"}
{"id": "fvapps_002197", "vc-description": "/-\nThere are N towns located in a line, conveniently numbered 1 through N. Takahashi the merchant is going on a travel from town 1 to town N, buying and selling apples.\nTakahashi will begin the travel at town 1, with no apple in his possession. The actions that can be performed during the travel are as follows:\n - Move: When at town i (i < N), move to town i + 1.\n - Merchandise: Buy or sell an arbitrary number of apples at the current town. Here, it is assumed that one apple can always be bought and sold for A_i yen (the currency of Japan) at town i (1 ≦ i ≦ N), where A_i are distinct integers. Also, you can assume that he has an infinite supply of money.\nFor some reason, there is a constraint on merchandising apple during the travel: the sum of the number of apples bought and the number of apples sold during the whole travel, must be at most T. (Note that a single apple can be counted in both.)\nDuring the travel, Takahashi will perform actions so that the profit of the travel is maximized. Here, the profit of the travel is the amount of money that is gained by selling apples, minus the amount of money that is spent on buying apples. Note that we are not interested in apples in his possession at the end of the travel.\nAoki, a business rival of Takahashi, wants to trouble Takahashi by manipulating the market price of apples. Prior to the beginning of Takahashi's travel, Aoki can change A_i into another arbitrary non-negative integer A_i' for any town i, any number of times. The cost of performing this operation is |A_i - A_i'|. After performing this operation, different towns may have equal values of A_i.\nAoki's objective is to decrease Takahashi's expected profit by at least 1 yen. Find the minimum total cost to achieve it. You may assume that Takahashi's expected profit is initially at least 1 yen.\n\n-----Constraints-----\n - 1 ≦ N ≦ 10^5\n - 1 ≦ A_i ≦ 10^9 (1 ≦ i ≦ N)\n - A_i are distinct.\n - 2 ≦ T ≦ 10^9\n - In the initial state, Takahashi's expected profit is at least 1 yen.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN T\nA_1 A_2 ... A_N\n\n-----Output-----\nPrint the minimum total cost to decrease Takahashi's expected profit by at least 1 yen.\n\n-----Sample Input-----\n3 2\n100 50 200\n\n-----Sample Output-----\n1\n\nIn the initial state, Takahashi can achieve the maximum profit of 150 yen as follows:\n - Move from town 1 to town 2.\n - Buy one apple for 50 yen at town 2.\n - Move from town 2 to town 3.\n - Sell one apple for 200 yen at town 3.\nIf, for example, Aoki changes the price of an apple at town 2 from 50 yen to 51 yen, Takahashi will not be able to achieve the profit of 150 yen. The cost of performing this operation is 1, thus the answer is 1.\nThere are other ways to decrease Takahashi's expected profit, such as changing the price of an apple at town 3 from 200 yen to 199 yen.\n-/", "vc-preamble": "def List.maximum' (l : List Nat) : Nat := \n  match l with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs\n\ndef List.isStrictlyIncreasing (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! < l[j]!", "vc-helpers": "", "vc-definitions": "def solve (N : Nat) (T : Nat) (A : List Nat) : Nat := sorry\n\ntheorem output_is_valid_count {N T : Nat} {A : List Nat} \n  (h1 : N = A.length)\n  (h2 : T = A.maximum')\n  (h3 : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 1000)\n  (h4 : 2 ≤ N ∧ N ≤ 100) :\n  0 ≤ solve N T A := sorry", "vc-theorems": "theorem strictly_increasing_has_one_max_gain {N T : Nat} {A : List Nat}\n  (h1 : N = A.length)\n  (h2 : T = A.maximum')\n  (h3 : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 1000)\n  (h4 : 2 ≤ N ∧ N ≤ 100)\n  (h5 : A.isStrictlyIncreasing) :\n  solve N T A = 1 := sorry\n\ntheorem result_bounded_by_input_size {N T : Nat} {A : List Nat}\n  (h1 : N = A.length)\n  (h2 : T = A.maximum')\n  (h3 : ∀ x ∈ A, 1 ≤ x ∧ x ≤ 1000)\n  (h4 : 2 ≤ N ∧ N ≤ 100) :\n  solve N T A ≤ N := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve 3 2 [100, 50, 200]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 5 8 [50, 30, 40, 10, 20]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 10 100 [7, 10, 4, 5, 9, 3, 6, 8, 2, 1]"}
{"id": "fvapps_002297", "vc-description": "/-\nGiven a positive integer num consisting only of digits 6 and 9.\nReturn the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n\nExample 1:\nInput: num = 9669\nOutput: 9969\nExplanation: \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666. \nThe maximum number is 9969.\n\nExample 2:\nInput: num = 9996\nOutput: 9999\nExplanation: Changing the last digit 6 to 9 results in the maximum number.\nExample 3:\nInput: num = 9999\nOutput: 9999\nExplanation: It is better not to apply any change.\n\nConstraints:\n\n1 <= num <= 10^4\nnum's digits are 6 or 9.\n-/", "vc-preamble": "def countChar (s : String) (c : Char) : Nat :=\n  (s.data.filter (· = c)).length", "vc-helpers": "", "vc-definitions": "def maximum69Number (n : Nat) : Nat := sorry\n\ntheorem maximum69Number_result_geq_input {n : Nat} (h : n > 0) :\n  maximum69Number n ≥ n := sorry", "vc-theorems": "theorem maximum69Number_digit_length_preserved {n : Nat} (h : n > 0) :\n  String.length (toString (maximum69Number n)) = String.length (toString n) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9969\n-/\n#guard_msgs in\n#eval maximum69Number 9669\n\n/-\ninfo: 9999\n-/\n#guard_msgs in\n#eval maximum69Number 9996\n\n/-\ninfo: 9999\n-/\n#guard_msgs in\n#eval maximum69Number 9999"}
{"id": "fvapps_002330", "vc-description": "/-\nGiven a word, you need to judge whether the usage of capitals in it is right or not.\n\nWe define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll letters in this word are capitals, like \"USA\".\nAll letters in this word are not capitals, like \"leetcode\".\nOnly the first letter in this word is capital if it has more than one letter, like \"Google\".\n\nOtherwise, we define that this word doesn't use capitals in a right way.\n\nExample 1:\n\nInput: \"USA\"\nOutput: True\n\nExample 2:\n\nInput: \"FlaG\"\nOutput: False\n\nNote:\nThe input will be a non-empty word consisting of uppercase and lowercase latin letters.\n-/", "vc-preamble": "def isLowercase (c : Char) : Bool := 'a' ≤ c ∧ c ≤ 'z'\ndef isUppercase (c : Char) : Bool := 'A' ≤ c ∧ c ≤ 'Z'", "vc-helpers": "", "vc-definitions": "def isTitle (s : String) : Bool := sorry\ndef detect_capital_use (s : String) : Bool := sorry", "vc-theorems": "theorem all_lowercase_valid (s : String) : \n  (∀ c ∈ s.data, isLowercase c) → detect_capital_use s = true := sorry\n\ntheorem all_uppercase_valid (s : String) :\n  (∀ c ∈ s.data, isUppercase c) → detect_capital_use s = true := sorry\n\ntheorem titlecase_valid (s : String) :\n  s.length > 0 → isTitle s → detect_capital_use s = true := sorry\n\ntheorem empty_string_valid :\n  detect_capital_use \"\" = true := sorry\n\ntheorem mixed_case_invalid (s : String) :\n  s.length ≥ 2 → \n  ¬(∀ c ∈ s.data, isLowercase c) →\n  ¬(∀ c ∈ s.data, isUppercase c) →\n  ¬(isTitle s) →\n  detect_capital_use s = false := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval detect_capital_use \"USA\"\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval detect_capital_use \"FlaG\"\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval detect_capital_use \"Google\""}
{"id": "fvapps_002333", "vc-description": "/-\nGiven a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\n\nThis is case sensitive, for example \"Aa\" is not considered a palindrome here.\n\nNote:\nAssume the length of given string will not exceed 1,010.\n\nExample: \n\nInput:\n\"abccccdd\"\n\nOutput:\n7\n\nExplanation:\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.\n-/", "vc-preamble": "def String.freq (s : String) (c : Char) : Nat :=\n  s.toList.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def longest_palindrome (s : String) : Nat := sorry\n\ntheorem longest_palindrome_length_bounds \n  (s : String) (h : s.length > 0) : \n  let res := longest_palindrome s\n  res ≤ s.length ∧ res ≥ 1 := sorry", "vc-theorems": "theorem longest_palindrome_monotonic\n  (s : String) (h : s.length > 0) :\n  let res1 := longest_palindrome s\n  let res2 := longest_palindrome (s.push 'a')\n  res2 ≥ res1 := sorry\n\ntheorem longest_palindrome_repeated_char\n  (s : String) (h : s.length > 0) :\n  let c := s.get 0\n  let repeated := String.mk (List.replicate s.length c)\n  longest_palindrome repeated = s.length := sorry\n\ntheorem longest_palindrome_single_space :\n  longest_palindrome \" \" = 1 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval longest_palindrome \"abccccdd\"\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval longest_palindrome \"ccc\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval longest_palindrome \"Aa\""}
{"id": "fvapps_002337", "vc-description": "/-\nWe have a collection of stones, each stone has a positive integer weight.\nEach turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\n\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\n\nAt the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)\n\nExample 1:\nInput: [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.\n\nNote:\n\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000\n-/", "vc-preamble": "def list_max (l: List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs\n\n/- Function that returns the weight of the last remaining stone after smashing -/", "vc-helpers": "", "vc-definitions": "def last_stone_weight (stones : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_stone_identity (stone : Nat)\n  (h : stone > 0 ∧ stone ≤ 1000) :\n  last_stone_weight [stone] = stone := sorry\n\ntheorem identical_pair_zero (stone : Nat)\n  (h : stone > 0 ∧ stone ≤ 1000) :\n  last_stone_weight [stone, stone] = 0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval last_stone_weight [2, 7, 4, 1, 8, 1]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval last_stone_weight [1]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval last_stone_weight [2, 2]"}
{"id": "fvapps_002381", "vc-description": "/-\nGiven an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.\n\nExample 1:\nInput: arr = [2,6,4,1]\nOutput: false\nExplanation: There are no three consecutive odds.\n\nExample 2:\nInput: arr = [1,2,34,3,4,5,7,23,12]\nOutput: true\nExplanation: [5,7,23] are three consecutive odds.\n\nConstraints:\n\n1 <= arr.length <= 1000\n1 <= arr[i] <= 1000\n-/", "vc-preamble": "def isOdd (n : Int) : Bool :=\n  n % 2 = 1\n\n/- Helper function to test if a number is even -/\n\ndef isEven (n : Int) : Bool :=\n  n % 2 = 0", "vc-helpers": "", "vc-definitions": "def threeConsecutiveOdds (arr : List Int) : Bool := sorry\n\ntheorem threeConsecutiveOdds_returns_bool (arr : List Int) :\n  threeConsecutiveOdds arr = true ∨ threeConsecutiveOdds arr = false :=\nsorry", "vc-theorems": "theorem threeConsecutiveOdds_true_implies_consecutive (arr : List Int) :\n  threeConsecutiveOdds arr = true →\n  ∃ i, i + 2 < arr.length ∧\n       isOdd arr[i]! ∧ isOdd arr[i+1]! ∧ isOdd arr[i+2]! :=\nsorry\n\ntheorem threeConsecutiveOdds_false_implies_no_consecutive (arr : List Int) :\n  threeConsecutiveOdds arr = false →\n  ∀ i, i + 2 < arr.length →\n      ¬(isOdd arr[i]! ∧ isOdd arr[i+1]! ∧ isOdd arr[i+2]!) :=\nsorry\n\ntheorem all_odds_returns_true {arr : List Int} (h : arr.length ≥ 3)\n  (h₂ : ∀ x ∈ arr, isOdd x) :\n  threeConsecutiveOdds arr = true :=\nsorry\n\ntheorem all_evens_returns_false {arr : List Int}\n  (h : ∀ x ∈ arr, isEven x) :\n  threeConsecutiveOdds arr = false :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval three_consecutive_odds [2, 6, 4, 1]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval three_consecutive_odds [1, 2, 34, 3, 4, 5, 7, 23, 12]\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval three_consecutive_odds [1, 3, 5, 2]"}
{"id": "fvapps_002500", "vc-description": "/-\n=====Function Descriptions=====\nWe have seen the applications of union, intersection, difference and symmetric difference operations, but these operations do not make any changes or mutations to the set.\n\nWe can use the following operations to create mutations to a set:\n\n.update() or |=\nUpdate the set by adding elements from an iterable/another set.\n\n>>> H = set(\"Hacker\")\n>>> R = set(\"Rank\")\n>>> H.update(R)\n>>> print H\nset(['a', 'c', 'e', 'H', 'k', 'n', 'r', 'R'])\n\n.intersection_update() or &=\nUpdate the set by keeping only the elements found in it and an iterable/another set.\n\n>>> H = set(\"Hacker\")\n>>> R = set(\"Rank\")\n>>> H.intersection_update(R)\n>>> print H\nset(['a', 'k'])\n\n.difference_update() or -=\nUpdate the set by removing elements found in an iterable/another set.\n\n>>> H = set(\"Hacker\")\n>>> R = set(\"Rank\")\n>>> H.difference_update(R)\n>>> print H\nset(['c', 'e', 'H', 'r'])\n\n.symmetric_difference_update() or ^=\nUpdate the set by only keeping the elements found in either set, but not in both.\n\n>>> H = set(\"Hacker\")\n>>> R = set(\"Rank\")\n>>> H.symmetric_difference_update(R)\n>>> print H\nset(['c', 'e', 'H', 'n', 'r', 'R'])\n\n=====Problem Statement=====\nYou are given a set A and N number of other sets. These N number of sets have to perform some specific mutation operations on set A.\n\nYour task is to execute those operations and print the sum of elements from set A.\n\n=====Input Format=====\nThe first line contains the number of elements in set A.\nThe second line contains the space separated list of elements in set A.\nThe third line contains integer N, the number of other sets.\nThe next 2 * N lines are divided into N parts containing two lines each.\nThe first line of each part contains the space separated entries of the operation name and the length of the other set.\nThe second line of each part contains space separated list of elements in the other set.\n\n=====Constraints=====\n0<len(set(A))<1000\n0<len(otherSets)<100\n0<N<100\n\n=====Output Format=====\nOutput the sum of elements in set A.\n-/", "vc-preamble": "def Operation := String\ndef OperationList := List (Operation × List Nat)", "vc-helpers": "", "vc-definitions": "def process_set_operations (initial : List Nat) (operations : OperationList) : Nat :=\n  sorry", "vc-theorems": "theorem process_set_operations_result {initial : List Nat} {ops : OperationList} :\n  ∃ (n : Nat), process_set_operations initial ops = n :=\n  sorry\n\ntheorem process_set_operations_nonnegative {initial : List Nat} {ops : OperationList} :\n  process_set_operations initial ops ≥ 0 :=\n  sorry\n\ntheorem process_set_operations_empty :\n  process_set_operations [] [] = 0 :=\n  sorry\n\ntheorem update_operations_monotonic {initial : List Nat} :\n  process_set_operations initial [] ≤ process_set_operations initial [(\"update\", [0,1,2,3,4])] :=\n  sorry\n\ntheorem intersection_with_self {initial : List Nat} :\n  process_set_operations initial [] = process_set_operations initial [(\"intersection_update\", initial)] :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_002539", "vc-description": "/-\nYou're playing a game with a friend involving a bag of marbles. In the bag are ten marbles:\n\n* 1 smooth red marble\n* 4 bumpy red marbles\n* 2 bumpy yellow marbles\n* 1 smooth yellow marble\n* 1 bumpy green marble\n* 1 smooth green marble\n\nYou can see that the probability of picking a smooth red marble from the bag is `1 / 10` or `0.10` and the probability of picking a bumpy yellow marble is `2 / 10` or `0.20`.\n\nThe game works like this: your friend puts her hand in the bag, chooses a marble (without looking at it) and tells you whether it's bumpy or smooth. Then you have to guess which color it is before she pulls it out and reveals whether you're correct or not.\n\nYou know that the information about whether the marble is bumpy or smooth changes the probability of what color it is, and you want some help with your guesses.\n\nWrite a function `color_probability()` that takes two arguments: a color (`'red'`, `'yellow'`, or `'green'`) and a texture (`'bumpy'` or `'smooth'`) and returns the probability as a decimal fraction accurate to two places.\n\nThe probability should be a string and should discard any digits after the 100ths place. For example, `2 / 3` or `0.6666666666666666` would become the string `'0.66'`. Note this is different from rounding.\n\nAs a complete example, `color_probability('red', 'bumpy')` should return the string `'0.57'`.\n-/", "vc-preamble": "def validColors := [\"red\", \"yellow\", \"green\"]\ndef validTextures := [\"smooth\", \"bumpy\"]", "vc-helpers": "", "vc-definitions": "def colorProbability (color: String) (texture: String) : Float :=\n  sorry", "vc-theorems": "theorem probability_in_bounds (color: String) (texture: String)\n  (h1: color ∈ validColors) (h2: texture ∈ validTextures) :\n  let p := colorProbability color texture\n  0 ≤ p ∧ p ≤ 1 :=\nsorry\n\ntheorem invalid_color_error (color: String) (texture: String)\n  (h: color ∉ validColors) (h2: texture ∈ validTextures) :\n  (colorProbability color texture).isNaN :=\nsorry\n\ntheorem invalid_texture_error (color: String) (texture: String)\n  (h1: color ∈ validColors) (h: texture ∉ validTextures) :\n  (colorProbability color texture).isNaN :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_002566", "vc-description": "/-\nCreate a function that transforms any positive number to a string representing the number in words.  The function should work for all numbers between 0 and 999999.\n\n### Examples\n\n```\nnumber2words(0)  ==>  \"zero\"\nnumber2words(1)  ==>  \"one\"\nnumber2words(9)  ==>  \"nine\"\nnumber2words(10)  ==>  \"ten\"\nnumber2words(17)  ==>  \"seventeen\"\nnumber2words(20)  ==>  \"twenty\"\nnumber2words(21)  ==>  \"twenty-one\"\nnumber2words(45)  ==>  \"forty-five\"\nnumber2words(80)  ==>  \"eighty\"\nnumber2words(99)  ==>  \"ninety-nine\"\nnumber2words(100)  ==>  \"one hundred\"\nnumber2words(301)  ==>  \"three hundred one\"\nnumber2words(799)  ==>  \"seven hundred ninety-nine\"\nnumber2words(800)  ==>  \"eight hundred\"\nnumber2words(950)  ==>  \"nine hundred fifty\"\nnumber2words(1000)  ==>  \"one thousand\"\nnumber2words(1002)  ==>  \"one thousand two\"\nnumber2words(3051)  ==>  \"three thousand fifty-one\"\nnumber2words(7200)  ==>  \"seven thousand two hundred\"\nnumber2words(7219)  ==>  \"seven thousand two hundred nineteen\"\nnumber2words(8330)  ==>  \"eight thousand three hundred thirty\"\nnumber2words(99999)  ==>  \"ninety-nine thousand nine hundred ninety-nine\"\nnumber2words(888888)  ==>  \"eight hundred eighty-eight thousand eight hundred eighty-eight\"\n```\n-/", "vc-preamble": "def countChar (s : String) (c : Char) : Nat := \n  s.data.filter (·= c) |>.length", "vc-helpers": "", "vc-definitions": "def isSubstring (pattern : String) (s : String) : Bool := sorry\n\ndef number2words (n : Nat) : String := sorry\n\n-- All outputs are strings containing only letters, spaces, and hyphens", "vc-theorems": "theorem number2words_valid_chars (n : Nat) (h : n ≤ 999999) :\n  ∃ s, number2words n = s ∧ \n  (∀ c ∈ s.data, c.isAlpha ∨ c = ' ' ∨ c = '-') := sorry\n\n-- Numbers 0-19 are written as single words without spaces or hyphens \n\ntheorem small_numbers_single_word (n : Nat) (h : n ≤ 19) :\n  ∀ c ∈ (number2words n).data, c.isAlpha := sorry\n\n-- Numbers 20-99: if multiple of 10 then no hyphen, else exactly one hyphen\n\ntheorem two_digit_numbers (n : Nat) (h1 : 20 ≤ n) (h2 : n ≤ 99) :\n  if n % 10 = 0 \n  then ∀ c ∈ (number2words n).data, c ≠ '-'\n  else countChar (number2words n) '-' = 1 := sorry\n\n-- Numbers 100-999 contain \"hundred\" and have one space if multiple of 100\n\ntheorem hundreds (n : Nat) (h1 : 100 ≤ n) (h2 : n ≤ 999) :\n  isSubstring \"hundred\" (number2words n) ∧\n  (if n % 100 = 0 \n   then countChar (number2words n) ' ' = 1\n   else True) := sorry\n\n-- Numbers 1000-999999 contain exactly one \"thousand\"\n\ntheorem thousands (n : Nat) (h1 : 1000 ≤ n) (h2 : n ≤ 999999) :\n  isSubstring \"thousand\" (number2words n) ∧\n  countChar (number2words n) 't' = 1 := sorry\n\n-- Zero is written as \"zero\"\n\ntheorem zero : number2words 0 = \"zero\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_002605", "vc-description": "/-\nAn Ironman Triathlon is one of a series of long-distance triathlon races organized by the World Triathlon Corporaion (WTC).\nIt consists of a 2.4-mile swim, a 112-mile bicycle ride and a marathon (26.2-mile) (run, raced in that order and without a break. It hurts... trust me.\n\nYour task is to take a distance that an athlete is through the race, and return one of the following:\n\nIf the distance is zero, return `'Starting Line... Good Luck!'`.\n\nIf the athlete will be swimming, return an object with `'Swim'` as the key, and the remaining race distance as the value.\n\nIf the athlete will be riding their bike, return an object with `'Bike'` as the key, and the remaining race distance as the value.\n\nIf the athlete will be running, and has more than 10 miles to go, return an object with `'Run'` as the key, and the remaining race distance as the value.\n\nIf the athlete has 10 miles or less to go, return return an object with `'Run'` as the key, and `'Nearly there!'` as the value.\n\nFinally, if the athlete has completed te distance, return `\"You're done! Stop running!\"`.\n\nAll distance should be calculated to two decimal places.\n-/", "vc-preamble": "def SWIM_DIST : Float := 2.4\ndef BIKE_DIST : Float := 112\n\ndef RUN_DIST : Float := 26.2\ndef TOTAL_DIST : Float := SWIM_DIST + BIKE_DIST + RUN_DIST", "vc-helpers": "", "vc-definitions": "def i_tri (distance : Float) : String ⊕ (String × String) := sorry\n\ntheorem i_tri_result_type (distance : Float) :\n  match i_tri distance with\n  | Sum.inl _ => True\n  | Sum.inr _ => True := sorry", "vc-theorems": "theorem i_tri_at_start :\n  i_tri 0 = Sum.inl \"Starting Line... Good Luck!\" := sorry\n\ntheorem i_tri_at_finish (distance : Float) :\n  distance ≥ TOTAL_DIST →\n  i_tri distance = Sum.inl \"You're done! Stop running!\" := sorry\n\ntheorem i_tri_swim_phase (distance : Float) :\n  0 < distance → distance < SWIM_DIST → \n  ∃ msg, i_tri distance = Sum.inr (\"Swim\", msg) := sorry\n\ntheorem i_tri_bike_phase (distance : Float) :\n  SWIM_DIST ≤ distance → distance < SWIM_DIST + BIKE_DIST →\n  ∃ msg, i_tri distance = Sum.inr (\"Bike\", msg) := sorry\n\ntheorem i_tri_run_phase_normal (distance : Float) :\n  SWIM_DIST + BIKE_DIST ≤ distance → distance < TOTAL_DIST - 10 →\n  ∃ msg, i_tri distance = Sum.inr (\"Run\", msg) ∧ msg.endsWith \" to go!\" := sorry\n\ntheorem i_tri_run_phase_near_end (distance : Float) :\n  TOTAL_DIST - 10 ≤ distance → distance < TOTAL_DIST →\n  i_tri distance = Sum.inr (\"Run\", \"Nearly there!\") := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: {'Bike': '104.60 to go!'}\n-/\n#guard_msgs in\n#eval i_tri 36\n\n/-\ninfo: {'Swim': '138.60 to go!'}\n-/\n#guard_msgs in\n#eval i_tri 2\n\n/-\ninfo: \"You're done! Stop running!\"\n-/\n#guard_msgs in\n#eval i_tri 151"}
{"id": "fvapps_002621", "vc-description": "/-\nOh no!  You have stumbled upon a mysterious signal consisting of beeps of various lengths, and it is of utmost importance that you find out the secret message hidden in the beeps.  There are long and short beeps, the longer ones roughly three times as long as the shorter ones.  Hmm... that sounds familiar.\n\nThat's right: your job is to implement a decoder for the Morse alphabet.  Rather than dealing with actual beeps, we will use a common string encoding of Morse.  A long beep is represened by a dash (`-`) and a short beep by a dot (`.`).  A series of long and short beeps make up a letter, and letters are separated by spaces (` `).  Words are separated by double spaces.\n\nYou should implement the International Morse Alphabet.  You need to support letters a-z and digits 0-9 as follows:\n\n    a .-      h ....    o ---     u ..-      1 .----     6 -....\n    b -...    i ..      p .--.    v ...-     2 ..---     7 --...\n    c -.-.    j .---    q --.-    w .--      3 ...--     8 ---..\n    d -..     k -.-     r .-.     x -..-     4 ....-     9 ----.\n    e .       l .-..    s ...     y -.--     5 .....     0 -----\n    f ..-.    m --      t -       z --..\n    g --.     n -.\n\n## Examples\n\n    .... . .-.. .-.. ---  .-- --- .-. .-.. -..   → \"hello world\"\n    .---- ... -  .- -. -..  ..--- -. -..         → \"1st and 2nd\"\n\n```if:python\nA dictionnary `TOME` is preloaded for you, with the information above to convert morse code to letters.\n```\n```if:javascrip\nAn object `TOME` is preloaded for you, with the information above to convert morse code to letters.\n```\n```if:ruby\nA Hashmap `$dict` is preloaded for you, with the information above to convert morse code to letters.\n```\n-/", "vc-preamble": "def MORSE_CHARS := [\n  \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \n  \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \n  \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\", \"-----\",\n  \".----\", \"..---\", \"...--\", \"....-\", \".....\", \"-....\", \"--...\", \n  \"---..\", \"----.\"\n]", "vc-helpers": "", "vc-definitions": "def decode (s : String) : String := sorry\n\ndef splitString (s : String) (sep : Char) : List String := sorry", "vc-theorems": "theorem decode_preserves_word_count (morse_words : List (List String))\n  (h_valid : ∀ w ∈ morse_words, ∀ c ∈ w, c ∈ MORSE_CHARS)\n  (morse_string := String.intercalate \"  \" (morse_words.map (String.intercalate \" \"))) :\n  (splitString (decode morse_string) ' ').length = morse_words.length := sorry\n\ntheorem decode_returns_alphanumeric (morse_words : List (List String))\n  (h_valid : ∀ w ∈ morse_words, ∀ c ∈ w, c ∈ MORSE_CHARS)\n  (morse_string := String.intercalate \"  \" (morse_words.map (String.intercalate \" \"))) :\n  ∀ c ∈ (decode morse_string).data, c.isAlphanum ∨ c = ' ' := sorry\n\ntheorem decode_empty_string :\n  decode \"\" = \"\" := sorry\n\ntheorem decode_singleton_space :\n  decode \" \" = \" \" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'hello world'\n-/\n#guard_msgs in\n#eval decode \".... . .-.. .-.. ---  .-- --- .-. .-.. -..\"\n\n/-\ninfo: '1st and 2nd'\n-/\n#guard_msgs in\n#eval decode \".---- ... -  .- -. -..  ..--- -. -..\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval decode \"\""}
{"id": "fvapps_002629", "vc-description": "/-\nYou are working at a lower league football stadium and you've been tasked with automating the scoreboard.\n\nThe referee will shout out the score, you have already set up the voice recognition module which turns the ref's voice into a string, but the spoken score needs to be converted into a pair for the scoreboard!\n\ne.g. `\"The score is four nil\"` should return `[4,0]`\n\nEither teams score has a range of 0-9, and the ref won't say the same string every time e.g. \n\n    \"new score: two three\"\n\n    \"two two\"\n\n    \"Arsenal just conceded another goal, two nil\"\n\nNote:\n```python\nPlease return an array\n```\n\nPlease rate and enjoy!\n-/", "vc-preamble": "def ValidWords := [\"nil\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n\ndef WordToNum : String → Nat\n  | \"nil\" => 0\n  | \"one\" => 1 \n  | \"two\" => 2\n  | \"three\" => 3\n  | \"four\" => 4\n  | \"five\" => 5\n  | \"six\" => 6\n  | \"seven\" => 7\n  | \"eight\" => 8\n  | \"nine\" => 9\n  | _ => 0", "vc-helpers": "", "vc-definitions": "def scoreboard (s : String) : List Nat :=\n  sorry", "vc-theorems": "theorem scoreboard_output_valid (s : String) :\n  let result := scoreboard s\n  ∀ x ∈ result, 0 ≤ x ∧ x ≤ 9 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [4, 0]\n-/\n#guard_msgs in\n#eval scoreboard \"The score is four nil\"\n\n/-\ninfo: [2, 3]\n-/\n#guard_msgs in\n#eval scoreboard \"new score: two three\"\n\n/-\ninfo: [2, 0]\n-/\n#guard_msgs in\n#eval scoreboard \"Arsenal just conceded another goal, two nil\""}
{"id": "fvapps_002637", "vc-description": "/-\nOne suggestion to build a satisfactory password is to start with a memorable phrase or sentence and make a password by extracting the first letter of each word. \n\nEven better is to replace some of those letters with numbers (e.g., the letter `O` can be replaced with the number `0`):\n\n* instead of including `i` or `I` put the number `1` in the password;\n* instead of including `o` or `O` put the number `0` in the password;\n* instead of including `s` or `S` put the number `5` in the password.\n\n## Examples:\n```\n\"Give me liberty or give me death\"  --> \"Gml0gmd\"\n\"Keep Calm and Carry On\"            --> \"KCaC0\"\n```\n-/", "vc-preamble": "def SWAP : Char → Char\n  | 'a' => '@'\n  | 'i' => '1'\n  | 'e' => '3'\n  | 'o' => '0'\n  | c => c", "vc-helpers": "", "vc-definitions": "def make_password (phrase : String) : String :=\n  sorry", "vc-theorems": "theorem password_length_matches_words (words : List String) :\n  (make_password (String.intercalate \" \" words)).length = words.length :=\n  sorry\n\ntheorem first_letters_property (words : List String) (h : ∀ w ∈ words, w.length > 0) :\n  let pass := make_password (String.intercalate \" \" words)\n  ∀ i < pass.length, ∀ j < words.length, i = j →\n    pass.data[i]! = SWAP (words[j]!.data[0]!) :=\n  sorry\n\ntheorem empty_words_filtered (phrase : String) :\n  let clean := String.intercalate \" \" (phrase.split (· = ' ') |>.filter (·.length > 0))\n  make_password phrase = make_password clean :=\n  sorry\n\ntheorem swap_chars_applied (words : List String) (h : ∀ w ∈ words, w.length > 0) :\n  let pass := make_password (String.intercalate \" \" words)\n  ∀ i < pass.length, ∀ j < words.length, i = j →\n    let firstChar := words[j]!.data[0]!\n    firstChar ∈ ['a', 'i', 'e', 'o'] →\n    pass.data[i]! = SWAP firstChar :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Gml0gmd'\n-/\n#guard_msgs in\n#eval make_password \"Give me liberty or give me death\"\n\n/-\ninfo: 'KCaC0'\n-/\n#guard_msgs in\n#eval make_password \"Keep Calm and Carry On\"\n\n/-\ninfo: '505'\n-/\n#guard_msgs in\n#eval make_password \"Save Our Souls\""}
{"id": "fvapps_002694", "vc-description": "/-\n# Task\n\nYou are given an array `a` of positive integers a. You may choose some integer `X` and update `a` several times, where to update means to perform the following operations:\n```\npick a contiguous subarray of length not greater than the given k;\nreplace all elements in the picked subarray with the chosen X.\n```\nWhat is the minimum number of updates required to make all the elements of the array the same?\n\n# Example\n\nFor `a = [1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] and k = 2`, the output should be `4`.\n\nHere's how a will look like after each update:\n```\n[1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] ->\n[1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 1, 1] ->\n[1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1] ->\n[1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1] ->\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n```\n\n# Input/Output\n\n - `[input]` integer array `a`\n\n  An array of positive integers.\n\n  Constraints:\n\n  `10 ≤ a.length ≤ 50,`\n\n  `1 ≤ a[i] ≤ 10.`\n\n - `[input]` integer `k`\n\n  A positive integer, the maximum length of a subarray.\n\n  Constraints: `2 ≤ k ≤ 9.`\n\n - `[output]` an integer\n\n  The minimum number of updates.\n-/", "vc-preamble": "def countOccurrences (arr : List Nat) (x : Nat) : Nat :=\n  (arr.filter (· == x)).length\n\ndef getMode (arr : List Nat) : Nat :=\n  match arr with\n  | [] => 0\n  | x::xs => (arr.foldl \n    (fun acc y => if countOccurrences arr y > countOccurrences arr acc then y else acc) \n    x)", "vc-helpers": "", "vc-definitions": "def arrayEqualization (arr : List Nat) (k : Nat) : Nat := sorry\n\ntheorem equals_one_theorem (arr : List Nat) (h1 : arr.length > 0)\n    (h2 : ∀ x ∈ arr, x ≥ 1 ∧ x ≤ 3) : \n  arrayEqualization arr 1 = (arr.filter (· ≠ getMode arr)).length := sorry", "vc-theorems": "theorem identical_elements_theorem (arr : List Nat) (k : Nat)\n    (h1 : arr.length > 0)\n    (h2 : k ≥ 1)\n    (h3 : k ≤ 10)\n    (h4 : ∀ x ∈ arr, x = 1) :\n  arrayEqualization arr k = 0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval array_equalization [1, 2, 2, 1, 2, 1, 2, 2, 2, 1, 1, 1] 2\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval array_equalization [5, 2, 3, 5, 2, 2, 3, 5, 1, 2, 5, 1, 2, 5, 3] 7\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval array_equalization [1, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1] 9"}
{"id": "fvapps_002717", "vc-description": "/-\nThe number 81 has a special property, a certain power of the sum of its digits is equal to 81 (nine squared). Eighty one (81), is the first number in having this property (not considering numbers of one digit). \nThe next one, is 512.\nLet's see both cases with the details\n\n8 + 1 = 9 and 9^(2) = 81\n\n512 = 5 + 1 + 2 = 8 and 8^(3) = 512\n\nWe need to make a function, ```power_sumDigTerm()```, that receives a number ```n``` and may output the ```n-th term``` of this sequence of numbers.\nThe cases we presented above means that\n\npower_sumDigTerm(1) == 81\n\npower_sumDigTerm(2) == 512\n\nHappy coding!\n-/", "vc-preamble": "def toDigits (n : Nat) : List Nat :=\n  if n < 10 then [n]\n  else (n % 10) :: toDigits (n / 10)\n\ndef sum_list : List Nat → Nat \n  | [] => 0\n  | (h :: t) => h + sum_list t", "vc-helpers": "", "vc-definitions": "def power_sumDigTerm : Nat → Nat := sorry\n\n-- Property that the sequence is strictly increasing", "vc-theorems": "theorem power_sumDigTerm_increasing {n : Nat} : \n  n > 0 → power_sumDigTerm n < power_sumDigTerm (n + 1) := sorry\n\n-- Property that each term is a perfect power with base equal to the sum of its digits\n\ntheorem power_sumDigTerm_perfect_power {n : Nat} (h : n > 0) :\n  ∃ base power : Nat, \n    base ≥ 2 ∧ \n    power ≥ 2 ∧ \n    power_sumDigTerm n = base ^ power ∧\n    base = sum_list (toDigits (power_sumDigTerm n)) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 81\n-/\n#guard_msgs in\n#eval power_sumDigTerm 1\n\n/-\ninfo: 512\n-/\n#guard_msgs in\n#eval power_sumDigTerm 2\n\n/-\ninfo: 2401\n-/\n#guard_msgs in\n#eval power_sumDigTerm 3"}
{"id": "fvapps_002807", "vc-description": "/-\n*Inspired by the [Fold an Array](https://www.codewars.com/kata/fold-an-array) kata. This one is sort of similar but a little different.*\n\n---\n\n## Task\nYou will receive an array as parameter that contains 1 or more integers and a number `n`.\n\nHere is a little visualization of the process:\n\n* Step 1: Split the array in two:\n```\n  [1, 2, 5, 7, 2, 3, 5, 7, 8]\n        /            \\\n[1, 2, 5, 7]    [2, 3, 5, 7, 8]\n```\n\n* Step 2: Put the arrays on top of each other:\n```\n     [1, 2, 5, 7]\n[2, 3, 5, 7, 8]\n```\n\n* Step 3: Add them together:\n```\n[2, 4, 7, 12, 15]\n```\n\nRepeat the above steps `n` times or until there is only one number left, and then return the array.\n\n## Example\n\n```\nInput: arr=[4, 2, 5, 3, 2, 5, 7], n=2\n\nRound 1\n-------\nstep 1: [4, 2, 5]  [3, 2, 5, 7]\n\nstep 2:    [4, 2, 5]\n        [3, 2, 5, 7]\n\nstep 3: [3, 6, 7, 12]\n\nRound 2\n-------\nstep 1: [3, 6]  [7, 12]\n\nstep 2:  [3,  6]\n         [7, 12]\n\nstep 3: [10, 18]\n\nResult: [10, 18]\n```\n-/", "vc-preamble": "def sum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | x :: rest => x + sum rest", "vc-helpers": "", "vc-definitions": "def split_and_add (numbers : List Int) (n : Nat) : List Int :=\n  sorry", "vc-theorems": "theorem split_and_add_empty (n : Nat) :\n  split_and_add [] n = [] := sorry\n\ntheorem split_and_add_single (x : Int) (n : Nat) :\n  split_and_add [x] n = [x] := sorry\n\ntheorem split_and_add_sum_preserved (numbers : List Int) (n : Nat) :\n  sum numbers = sum (split_and_add numbers n) := sorry\n\ntheorem split_and_add_idempotent (numbers : List Int) (n : Nat) :\n  let result1 := split_and_add numbers n\n  let result2 := split_and_add numbers (n + 1)\n  result1.length = 1 → result1 = result2 := sorry\n\ntheorem split_and_add_length_decreases {numbers : List Int} (n : Nat) :\n  numbers.length ≥ 2 →\n  (split_and_add numbers 1).length ≤ numbers.length := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_002869", "vc-description": "/-\n# Task\n Vanya gets bored one day and decides to enumerate a large pile of rocks. He first counts the rocks and finds out that he has `n` rocks in the pile, then he goes to the store to buy labels for enumeration. \n\n Each of the labels is a digit from 0 to 9 and each of the `n` rocks should be assigned a unique number from `1` to `n`.\n\n If each label costs `$1`, how much money will Vanya spend on this project?\n\n# Input/Output\n\n - `[input]` integer `n`\n\n  The number of rocks in the pile.\n\n  `1  ≤  n  ≤  10^9`\n\n - `[output]` an integer\n\n  the cost of the enumeration.\n\n# Example\n\n For `n = 13`, the result should be `17`.\n ```\n the numbers from 1 to n are:\n 1 2 3 4 5 6 7 8 9 10 11 12 13\n we need 17 single digit labels:\n 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3\n each label cost $1, so the output should be 17.\n ```\n-/", "vc-preamble": "def log10 (n : Nat) : Nat :=\n  if n < 10 then 0\n  else 1 + log10 (n / 10)", "vc-helpers": "", "vc-definitions": "def rocks (n : Nat) : Nat := sorry\n\ntheorem rocks_monotonically_increasing \n  (n : Nat)\n  (h : n > 1) :\n  rocks n ≥ rocks (n-1) := sorry", "vc-theorems": "theorem rocks_minimum_bound\n  (n : Nat)\n  (h : n > 0) : \n  rocks n ≥ n := sorry\n\ntheorem rocks_single_digit \n  (n : Nat)\n  (h1 : n > 0)\n  (h2 : n ≤ 9) :\n  rocks n = n := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval rocks 1\n\n/-\ninfo: 17\n-/\n#guard_msgs in\n#eval rocks 13\n\n/-\ninfo: 192\n-/\n#guard_msgs in\n#eval rocks 100"}
{"id": "fvapps_002887", "vc-description": "/-\n# Task\n CodeBots decided to make a gift for CodeMaster's birthday. They got a pack of candies of various sizes from the store, but instead of giving the whole pack they are trying to make the biggest possible candy from them. On each turn it is possible:\n\n ```\n to pick any two candies of the same size and merge\n them into a candy which will be two times bigger;\n\n to pick a single candy of an even size and split it \n into two equal candies half of this size each.```\nWhat is the size of the biggest candy they can make as a gift?\n\n# Example\n\n For `arr = [2, 4, 8, 1, 1, 15]`, the output should be 16.\n```\n[2, 4, 8, 1, 1, 15] --> [2, 4, 8, 2, 15]\n-->[4, 4, 8, 15] --> [8, 8, 15] --> [16, 15] -->choose 16\n``` \n\n# Input/Output\n\n - [input] integer array `arr`\n\n    Array of positive integers.\n\n    Constraints:\n\n    `5 ≤ inputArray.length ≤ 50,`\n\n    `1 ≤ inputArray[i] ≤ 100.`\n\n - `[output]` an integer\n-/", "vc-preamble": "def List.maximum! : List Nat → Nat \n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (maximum! xs)", "vc-helpers": "", "vc-definitions": "def obtain_max_number (arr : List Nat) : Nat := sorry\n\ndef count_pairs (arr : List Nat) : Nat := sorry", "vc-theorems": "theorem obtain_max_number_twos {n : Nat} (h : n ≥ 1) :\n  let arr := List.replicate n 2\n  let result := obtain_max_number arr\n  result > 0 ∧ result &&& (result - 1) = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval obtain_max_number [2, 4, 8, 1, 1, 15]\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval obtain_max_number [2, 4, 8, 1, 1, 30, 30, 15, 15, 7, 7]\n\n/-\ninfo: 128\n-/\n#guard_msgs in\n#eval obtain_max_number [2, 4, 8, 1, 1, 32, 8, 8, 64, 30, 30, 15, 15, 7, 7]"}
{"id": "fvapps_002916", "vc-description": "/-\nYour start-up's BA has told marketing that your website has a large audience in Scandinavia and surrounding countries. Marketing thinks it would be great to welcome visitors to the site in their own language. Luckily you already use an API that detects the user's location, so this is an easy win. \n\n### The Task\n- Think of a way to store the languages as a database (eg an object). The languages are listed below so you can copy and paste!\n- Write a 'welcome' function that takes a parameter 'language' (always a string), and returns a greeting - if you have it in your database. It should default to English if the language is not in the database, or in the event of an invalid input.\n\n### The Database\n\n```python\n'english': 'Welcome',\n'czech': 'Vitejte',\n'danish': 'Velkomst',\n'dutch': 'Welkom',\n'estonian': 'Tere tulemast',\n'finnish': 'Tervetuloa',\n'flemish': 'Welgekomen',\n'french': 'Bienvenue',\n'german': 'Willkommen',\n'irish': 'Failte',\n'italian': 'Benvenuto',\n'latvian': 'Gaidits',\n'lithuanian': 'Laukiamas',\n'polish': 'Witamy',\n'spanish': 'Bienvenido',\n'swedish': 'Valkommen',\n'welsh': 'Croeso'\n```\n``` java\nenglish: \"Welcome\",\nczech: \"Vitejte\",\ndanish: \"Velkomst\",\ndutch: \"Welkom\",\nestonian: \"Tere tulemast\",\nfinnish: \"Tervetuloa\",\nflemish: \"Welgekomen\",\nfrench: \"Bienvenue\",\ngerman: \"Willkommen\",\nirish: \"Failte\",\nitalian: \"Benvenuto\",\nlatvian: \"Gaidits\",\nlithuanian: \"Laukiamas\",\npolish: \"Witamy\",\nspanish: \"Bienvenido\",\nswedish: \"Valkommen\",\nwelsh: \"Croeso\"\n```\n\nPossible invalid inputs include:\n~~~~\nIP_ADDRESS_INVALID - not a valid ipv4 or ipv6 ip address\nIP_ADDRESS_NOT_FOUND - ip address not in the database\nIP_ADDRESS_REQUIRED - no ip address was supplied\n~~~~\n-/", "vc-preamble": "def VALID_LANGUAGES := [\n    \"czech\", \"danish\", \"dutch\", \"english\", \"estonian\", \"finnish\", \"flemish\",\n    \"french\", \"german\", \"irish\", \"italian\", \"latvian\", \"lithuanian\",\n    \"polish\", \"spanish\", \"swedish\", \"welsh\"\n]", "vc-helpers": "", "vc-definitions": "def greet (language : String) : String :=\n  sorry", "vc-theorems": "theorem valid_language_returns_correct_greeting (language : String)\n  (h : language ∈ VALID_LANGUAGES) :\n  let result := greet language\n  (result ≠ \"\") ∧ \n  (result ≠ \"Welcome\" ∨ language = \"english\") :=\nsorry\n\ntheorem invalid_input_returns_welcome (language : String) \n  (h : language ∉ VALID_LANGUAGES) :\n  greet language = \"Welcome\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Welcome'\n-/\n#guard_msgs in\n#eval greet \"english\"\n\n/-\ninfo: 'Welkom'\n-/\n#guard_msgs in\n#eval greet \"dutch\"\n\n/-\ninfo: 'Welcome'\n-/\n#guard_msgs in\n#eval greet \"IP_ADDRESS_INVALID\"\n\n/-\ninfo: 'Welcome'\n-/\n#guard_msgs in\n#eval greet \"\"\n\n/-\ninfo: 'Welcome'\n-/\n#guard_msgs in\n#eval greet 2"}
{"id": "fvapps_002946", "vc-description": "/-\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n Given two array of integers(`arr1`,`arr2`). Your task is going to find a pair of numbers(an element in arr1, and another element in arr2), their difference is as big as possible(absolute value); Again, you should to find a pair of numbers, their difference is as small as possible. Return the maximum and minimum difference values by an array: `[  max difference,  min difference  ]`\n\n For example:\n ```\n Given arr1 = [3,10,5], arr2 = [20,7,15,8]\n should return [17,2] because 20 - 3 = 17, 10 - 8 = 2\n ```\n\n# Note:\n - arr1 and arr2 contains only integers(positive, negative or 0);\n - arr1 and arr2 may have different lengths, they always has at least one element;\n - All inputs are valid.\n - This is a simple version, if you want some challenges, [try the challenge version](https://www.codewars.com/kata/583c592928a0c0449d000099).\n\n# Some Examples\n ```\n maxAndMin([3,10,5],[20,7,15,8]) === [17,2]\n maxAndMin([3],[20]) === [17,17]\n maxAndMin([3,10,5],[3,10,5]) === [7,0]\n maxAndMin([1,2,3,4,5],[6,7,8,9,10]) === [9,1]\n ```\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def max_and_min (arr1 arr2 : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem max_and_min_output_size {arr1 arr2 : List Int} \n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) : \n  let result := max_and_min arr1 arr2\n  result.length = 2 :=\nsorry\n\ntheorem max_and_min_order {arr1 arr2 : List Int}\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  let result := max_and_min arr1 arr2\n  result[0]! ≥ result[1]! :=\nsorry\n\ntheorem max_and_min_nonneg {arr1 arr2 : List Int}\n  (h1 : arr1 ≠ []) (h2 : arr2 ≠ []) :\n  let result := max_and_min arr1 arr2\n  result[0]! ≥ 0 ∧ result[1]! ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [17, 2]\n-/\n#guard_msgs in\n#eval max_and_min [3, 10, 5] [20, 7, 15, 8]\n\n/-\ninfo: [17, 17]\n-/\n#guard_msgs in\n#eval max_and_min [3] [20]\n\n/-\ninfo: [9, 1]\n-/\n#guard_msgs in\n#eval max_and_min [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]"}
{"id": "fvapps_003063", "vc-description": "/-\nGiven two integers `a` and `b`, which can be positive or negative, find the sum of all the numbers between including them too and return it. If the two numbers are equal return `a` or `b`.\n\n**Note:** `a` and `b` are not ordered!\n\n## Examples\n\n```python\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n```C\nget_sum(1, 0) == 1   // 1 + 0 = 1\nget_sum(1, 2) == 3   // 1 + 2 = 3\nget_sum(0, 1) == 1   // 0 + 1 = 1\nget_sum(1, 1) == 1   // 1 Since both are same\nget_sum(-1, 0) == -1 // -1 + 0 = -1\nget_sum(-1, 2) == 2  // -1 + 0 + 1 + 2 = 2\n```\n-/", "vc-preamble": "def abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def get_sum (a b : Int) : Int := sorry\n\ntheorem get_sum_commutative (a b : Int) : \n  get_sum a b = get_sum b a := sorry", "vc-theorems": "theorem get_sum_same_number (n : Int) :\n  get_sum n n = n := sorry\n\ntheorem get_sum_consecutive (a b : Int) :\n  a ≠ b → get_sum a b = ((a + b) / 2) * (abs (b - a) + 1) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval get_sum 1 3\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval get_sum -1 2\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval get_sum 5 5"}
{"id": "fvapps_003094", "vc-description": "/-\nGiven a string, remove any characters that are unique from the string.\n\nExample: \n\ninput: \"abccdefee\"\n\noutput: \"cceee\"\n-/", "vc-preamble": "def countChar (s : String) (c : Char) : Nat :=\n  s.toList.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def only_duplicates (s : String) : String := sorry\n\ntheorem only_duplicates_contains_multiple_occurrences \n  (s : String) (c : Char) : \n  c ∈ (only_duplicates s).data → \n  countChar s c > 1 := \nsorry", "vc-theorems": "theorem only_duplicates_is_substring\n  (s : String) (c : Char) :\n  c ∈ (only_duplicates s).data →\n  c ∈ s.data := \nsorry\n\ntheorem only_duplicates_length\n  (s : String) :\n  (only_duplicates s).length ≤ s.length :=\nsorry\n\ntheorem only_duplicates_empty\n  (s : String) :\n  s = \"\" → only_duplicates s = \"\" :=\nsorry\n\ntheorem only_duplicates_unique_chars\n  (s : String) :\n  (∀ c, countChar s c ≤ 1) →\n  only_duplicates s = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'cceee'\n-/\n#guard_msgs in\n#eval only_duplicates \"abccdefee\"\n\n/-\ninfo: 'll'\n-/\n#guard_msgs in\n#eval only_duplicates \"hello\"\n\n/-\ninfo: 'ondersndoders'\n-/\n#guard_msgs in\n#eval only_duplicates \"foundersandcoders\""}
{"id": "fvapps_003229", "vc-description": "/-\nIn this Kata, we define an arithmetic progression as a series of integers in which the differences between adjacent numbers are the same. You will be given an array of ints of `length > 2` and your task will be to convert it into an arithmetic progression by the following rule:\n```Haskell\nFor each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1 \nor it can be left unchanged.\n```\nReturn the minimum number of changes needed to convert the array to an arithmetic progression. If not possible, return `-1`.\n```Haskell\nFor example: \nsolve([1,1,3,5,6,5]) == 4 because [1,1,3,5,6,5] can be changed to [1,2,3,4,5,6] by making 4 changes.\nsolve([2,1,2]) == 1 because it can be changed to [2,2,2]\nsolve([1,2,3]) == 0  because it is already a progression, and no changes are needed.\nsolve([1,1,10) == -1 because it's impossible.\nsolve([5,6,5,3,1,1]) == 4. It becomes [6,5,4,3,2,1]\n```\n\nMore examples in the test cases. Good luck!\n-/", "vc-preamble": "def abs (x : Int) : Int := \n  if x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def solve (arr : List Int) : Int := sorry\n\ntheorem solve_sequence_with_small_deviations {arr : List Int} \n  (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)\n  (h3 : ∃ start step : Int, ∀ (i : Fin arr.length), \n    abs (arr.get i - (start + i.val * step)) ≤ 1) :\n  let result := solve arr\n  result ≥ 0 ∧ \n  result ≤ (List.range (arr.length-1)).foldl \n    (fun acc i => acc + abs (arr.get ⟨i+1, sorry⟩ - arr.get ⟨i, sorry⟩)) 0 := \nsorry", "vc-theorems": "theorem solve_arbitrary_sequences {arr : List Int}\n  (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)\n  (h3 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100) :\n  let result := solve arr\n  result ≥ -1 ∧ \n  (result ≠ -1 → result ≥ 0) := \nsorry\n\ntheorem solve_minimum_length_sequence {arr : List Int}\n  (h : arr.length = 3) :\n  let result := solve arr\n  result ≠ -1 → \n  result ≤ abs (arr.get ⟨1, sorry⟩ - arr.get ⟨0, sorry⟩) + \n           abs (arr.get ⟨2, sorry⟩ - arr.get ⟨1, sorry⟩) :=\nsorry\n\ntheorem solve_constant_sequence {arr : List Int}\n  (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)\n  (h3 : ∀ (i j : Fin arr.length), arr.get i = arr.get j) :\n  solve arr = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 4\n-/\n#guard_msgs in\n#eval solve [1, 1, 3, 5, 6, 5]\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval solve [2, 1, 2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval solve [1, 2, 3]"}
{"id": "fvapps_003230", "vc-description": "/-\nIn this kata you will be given a random string of letters and tasked with returning them as a string of comma-separated sequences sorted alphabetically, with each sequence starting with an uppercase character followed by `n-1` lowercase characters, where `n` is the letter's alphabet position `1-26`.\n\n## Example\n\n```python\nalpha_seq(\"ZpglnRxqenU\") -> \"Eeeee,Ggggggg,Llllllllllll,Nnnnnnnnnnnnnn,Nnnnnnnnnnnnnn,Pppppppppppppppp,Qqqqqqqqqqqqqqqqq,Rrrrrrrrrrrrrrrrrr,Uuuuuuuuuuuuuuuuuuuuu,Xxxxxxxxxxxxxxxxxxxxxxxx,Zzzzzzzzzzzzzzzzzzzzzzzzzz\"\n```\n\n## Technical Details\n\n- The string will include only letters.\n- The first letter of each sequence is uppercase followed by `n-1` lowercase.\n- Each sequence is separated with a comma.\n- Return value needs to be a string.\n-/", "vc-preamble": "def isLower (c : Char) : Bool :=\n  97 ≤ c.toNat && c.toNat ≤ 122", "vc-helpers": "", "vc-definitions": "def alpha_seq (s : String) : String :=\n  sorry", "vc-theorems": "theorem alpha_seq_parts_sorted {s : String} (h : s ≠ \"\") : \n  let parts := s.split (· = ',')\n  ∀ i j, i < j → j < parts.length → \n    let p1 := (parts[i]?.getD \"\")\n    let p2 := (parts[j]?.getD \"\")\n    p1.length > 0 → p2.length > 0 →\n    (p1.data[0]?.getD ' ').toLower ≤ (p2.data[0]?.getD ' ').toLower := by\n  sorry \n\ntheorem alpha_seq_parts_capitalized {s : String} (h : s ≠ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts, part.length > 0 → \n    part.data[0]?.getD ' ' = (part.data[0]?.getD ' ').toUpper := by\n  sorry\n\ntheorem alpha_seq_parts_rest_lowercase {s : String} (h : s ≠ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts, ∀ i, 0 < i → i < part.length → \n    part.data[i]?.getD ' ' = (part.data[i]?.getD ' ').toLower := by\n  sorry\n\ntheorem alpha_seq_parts_length {s : String} (h : s ≠ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts, part.length > 0 → \n    part.length = (part.data[0]?.getD ' ').toLower.toNat - 96 := by\n  sorry\n\ntheorem alpha_seq_parts_same_char {s : String} (h : s ≠ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts, ∀ i, i < part.length →\n    (part.data[i]?.getD ' ').toLower = (part.data[0]?.getD ' ').toLower := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'A,Bb,Ccc,Ffffff,Ffffff'\n-/\n#guard_msgs in\n#eval alpha_seq \"BfcFA\"\n\n/-\ninfo: 'Ggggggg,Llllllllllll,Nnnnnnnnnnnnnn,Pppppppppppppppp,Rrrrrrrrrrrrrrrrrr,Zzzzzzzzzzzzzzzzzzzzzzzzzz'\n-/\n#guard_msgs in\n#eval alpha_seq \"ZpglnR\"\n\n/-\ninfo: 'A,Bb,Ccc'\n-/\n#guard_msgs in\n#eval alpha_seq \"Abc\""}
{"id": "fvapps_003266", "vc-description": "/-\n# Description\n\nGiven a number `n`, you should find a set of numbers for which the sum equals `n`. This set must consist exclusively of values that are a power of `2` (eg: `2^0 => 1, 2^1 => 2, 2^2 => 4, ...`).\n\nThe function `powers` takes a single parameter, the number `n`, and should return an array of unique numbers.\n\n## Criteria\n\nThe function will always receive a valid input: any positive integer between `1` and the max integer value for your language (eg: for JavaScript this would be `9007199254740991` otherwise known as `Number.MAX_SAFE_INTEGER`).\n\nThe function should return an array of numbers that are a **power of 2** (`2^x = y`).\n\nEach member of the returned array should be **unique**. (eg: the valid answer for `powers(2)` is `[2]`, not `[1, 1]`)\n\nMembers should be sorted in **ascending order** (small -> large). (eg: the valid answer for `powers(6)` is `[2, 4]`, not `[4, 2]`)\n-/", "vc-preamble": "def sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs\n\ndef isSorted : List Nat → Bool\n  | [] => true\n  | [_] => true\n  | x::y::rest => x ≤ y && isSorted (y::rest)\n\ndef countUnique : List Nat → Nat \n  | [] => 0\n  | x::xs => if xs.contains x then countUnique xs else 1 + countUnique xs", "vc-helpers": "", "vc-definitions": "def powers (n: Nat) : List Nat := sorry\n\ndef isPowerOfTwo (n: Nat) : Bool := \n  n != 0 && n &&& (n - 1) == 0", "vc-theorems": "theorem powers_sum_equals_input (n: Nat) (h: n > 0) : \n  sum (powers n) = n := sorry\n\ntheorem powers_are_powers_of_two (n: Nat) (h: n > 0) :\n  ∀ p ∈ powers n, isPowerOfTwo p = true := sorry\n\ntheorem powers_are_sorted (n: Nat) (h: n > 0) :\n  isSorted (powers n) = true := sorry\n\ntheorem powers_are_unique (n: Nat) (h: n > 0) :\n  (powers n).length = countUnique (powers n) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [4]\n-/\n#guard_msgs in\n#eval powers 4\n\n/-\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval powers 6\n\n/-\ninfo: [2, 4, 8]\n-/\n#guard_msgs in\n#eval powers 14"}
{"id": "fvapps_003287", "vc-description": "/-\nWrite a function `sumTimesTables` which sums the result of the sums of the elements specified in `tables` multiplied by all the numbers in between `min` and `max` including themselves.\n\nFor example, for `sumTimesTables([2,5],1,3)` the result should be the same as\n```\n2*1 + 2*2 + 2*3 +\n5*1 + 5*2 + 5*3\n```\ni.e. the table of two from 1 to 3 plus the table of five from 1 to 3\n\nAll the numbers are integers but you must take in account:\n\n* `tables` could be empty.\n* `min` could be negative.\n* `max` could be really big.\n-/", "vc-preamble": "def sum_list (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def sum_times_tables (tables : List Int) (min_val max_val : Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_times_tables_zero_sum {tables : List Int} {min_val max_val : Int} :\n  (sum_list tables = 0) → sum_times_tables tables min_val max_val = 0 :=\nsorry\n\ntheorem sum_times_tables_equal_bounds {tables : List Int} {val : Int} :\n  sum_times_tables tables val val = sum_list tables * val :=\nsorry\n\ntheorem sum_times_tables_symmetric {tables : List Int} {min_val max_val : Int} :\n  sum_times_tables tables min_val max_val = sum_times_tables tables min_val max_val :=\nsorry\n\ntheorem sum_times_tables_zero_range {tables : List Int} :\n  sum_times_tables tables 0 0 = 0 * sum_list tables :=\nsorry\n\ntheorem sum_times_tables_positive {tables : List Int} {val : Int} :\n  (∀ x ∈ tables, x > 0) → val > 0 → sum_times_tables tables 1 val ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval sum_times_tables [2, 3] 1 3\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval sum_times_tables [1, 3, 5] 1 1\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval sum_times_tables [-2, 2] -1 3"}
{"id": "fvapps_003311", "vc-description": "/-\nYour task is to determine how many files of the copy queue you will be able to save into your Hard Disk Drive. The files must be saved in the order they appear in the queue. \n\n### Input:\n\n* Array of file sizes `(0 <= s <= 100)`\n* Capacity of the HD `(0 <= c <= 500)`\n\n### Output:\n\n* Number of files that can be fully saved in the HD. \n\n### Examples:\n\n```\nsave([4,4,4,3,3], 12) -> 3\n# 4+4+4 <= 12, but 4+4+4+3 > 12\n```\n\n```\nsave([4,4,4,3,3], 11) -> 2\n# 4+4 <= 11, but 4+4+4 > 11\n```\n\nDo not expect any negative or invalid inputs.\n-/", "vc-preamble": "def sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def save (sizes : List Nat) (hd : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem save_valid_result_range (sizes : List Nat) (hd : Nat) (h : sizes.length > 0) :\n  let result := save sizes hd\n  0 ≤ result ∧ result ≤ sizes.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval save [4, 4, 4, 3, 3] 12\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval save [4, 4, 4, 3, 3] 11\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval save [4, 8, 15, 16, 23, 42] 108"}
{"id": "fvapps_003327", "vc-description": "/-\nWe want to know the index of the vowels in a given word, for example, there are two vowels in the word super (the second and fourth letters). \n\nSo given a string \"super\", we should return a list of [2, 4].\n\n        Some examples:\n        Mmmm  => []\n        Super => [2,4]\n        Apple => [1,5]\n        YoMama -> [1,2,4,6]\n\n**NOTES:**\n\n* Vowels in this context refers to: a e i o u y (including upper case)\n* This is indexed from `[1..n]` (not zero indexed!)\n-/", "vc-preamble": "def isVowel (c : Char) : Bool := \n  let lc := c.toLower\n  lc == 'a' ∨ lc == 'e' ∨ lc == 'i' ∨ lc == 'o' ∨ lc == 'u' ∨ lc == 'y'", "vc-helpers": "", "vc-definitions": "def vowel_indices (s : String) : List Nat :=\nsorry", "vc-theorems": "theorem vowel_indices_in_bounds (s : String) :\n  ∀ i ∈ vowel_indices s, 0 < i ∧ i ≤ s.length :=\nsorry\n\ntheorem vowel_indices_ascending (s : String) (i j : Nat) :\n  i < j → \n  i ∈ vowel_indices s →\n  j ∈ vowel_indices s →\n  i < j :=\nsorry\n\ntheorem vowel_indices_points_to_vowels (s : String) (i : Nat) :\n  i ∈ vowel_indices s → \n  i > 0 →\n  i ≤ s.length →\n  isVowel (s.data.get! (i-1)) :=\nsorry\n\ntheorem vowel_indices_finds_all_vowels (s : String) :\n  (vowel_indices s).length = (s.data.filter isVowel).length :=\nsorry\n\ntheorem vowel_indices_unique (s : String) (i j : Nat) :\n  i ∈ vowel_indices s →\n  j ∈ vowel_indices s →\n  i = j ∨ i ≠ j :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval vowel_indices \"mmm\"\n\n/-\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval vowel_indices \"super\"\n\n/-\ninfo: [1, 2, 4, 6]\n-/\n#guard_msgs in\n#eval vowel_indices \"YoMama\""}
{"id": "fvapps_003333", "vc-description": "/-\nJust like in the [\"father\" kata](http://www.codewars.com/kata/find-fibonacci-last-digit/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```\n-/", "vc-preamble": "def fibNaive (n : Nat) : Nat := \n  match n with\n  | 0 => 0\n  | 1 => 1\n  | n + 2 =>\n    let rec fib_iter (i : Nat) (a b : Nat) : Nat :=\n      match i with\n      | 0 => b\n      | i + 1 => fib_iter i b (a + b)\n    fib_iter (n) 0 1", "vc-helpers": "", "vc-definitions": "def lastFibDigit (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem matches_naive_for_small_n (n : Nat) (h : n ≤ 100) :\n  lastFibDigit n = fibNaive n % 10 :=\nsorry\n\ntheorem returns_single_digit (n : Nat) :\n  0 ≤ lastFibDigit n ∧ lastFibDigit n ≤ 9 :=\nsorry\n\ntheorem periodic_behavior_sixty (n : Nat) :\n  lastFibDigit n = lastFibDigit (n + 60) :=\nsorry\n\ntheorem periodic_behavior_mod (n : Nat) :\n  lastFibDigit n = lastFibDigit (n % 60) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval last_fib_digit 1\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval last_fib_digit 21\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval last_fib_digit 1000"}
{"id": "fvapps_003344", "vc-description": "/-\nDeoxyribonucleic acid, DNA is the primary information storage molecule in biological systems. It is composed of four nucleic acid bases Guanine ('G'), Cytosine ('C'), Adenine ('A'), and Thymine ('T'). \n\nRibonucleic acid, RNA, is the primary messenger molecule in cells. RNA differs slightly from DNA its chemical structure and contains no Thymine. In RNA Thymine is replaced by another nucleic acid Uracil ('U').\n\nCreate a function which translates a given DNA string into RNA.\n\nFor example:\n\n```\n\"GCAT\"  =>  \"GCAU\"\n```\n\nThe input string can be of arbitrary length - in particular, it may be empty.  All input is guaranteed to be valid, i.e. each input string will only ever consist of `'G'`, `'C'`, `'A'` and/or `'T'`.\n-/", "vc-preamble": "def DNA := String\ndef RNA := String", "vc-helpers": "", "vc-definitions": "def dna_to_rna (dna: DNA) : RNA := sorry\n\ntheorem length_preserved (dna: DNA) :\n  (dna_to_rna dna).length = dna.length := sorry", "vc-theorems": "theorem only_t_replaced (dna: DNA) (i: String.Pos) :\n  let rna := dna_to_rna dna\n  if dna.get i = 'T' then \n    rna.get i = 'U'\n  else\n    rna.get i = dna.get i := sorry\n\ntheorem valid_rna_chars (dna: DNA) (i: String.Pos) :\n  (dna_to_rna dna).get i ∈ ['G', 'C', 'U', 'A'] := sorry\n\ntheorem idempotent (rna: RNA) (h: ∀ i: String.Pos, rna.get i ∈ ['G','C','U']) :\n  dna_to_rna rna = rna := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'GCAU'\n-/\n#guard_msgs in\n#eval dna_to_rna \"GCAT\"\n\n/-\ninfo: ''\n-/\n#guard_msgs in\n#eval dna_to_rna \"\"\n\n/-\ninfo: 'GACCGCCGCC'\n-/\n#guard_msgs in\n#eval dna_to_rna \"GACCGCCGCC\""}
{"id": "fvapps_003384", "vc-description": "/-\nYour car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.\n\nUnfortunately for you, your drive is very bumpy! Given a string showing either flat road (\"\\_\") or bumps (\"n\"), work out if you make it home safely. 15 bumps or under, return \"Woohoo!\", over 15 bumps return \"Car Dead\".\n-/", "vc-preamble": "def countChar (s : String) (c : Char) : Nat := \n  (s.data.filter (· = c)).length", "vc-helpers": "", "vc-definitions": "def bumps (road : String) : String :=\n  sorry", "vc-theorems": "theorem bumps_returns_valid_output (road : String) :\n  (bumps road = \"Woohoo!\" ∨ bumps road = \"Car Dead\") ∧\n  (bumps road = \"Woohoo!\" ↔ countChar road 'n' ≤ 15) :=\nsorry\n\ntheorem no_bumps_woohoo (road : String) :\n  (∀ c ∈ road.toList, c = '_') →\n  bumps road = \"Woohoo!\" :=\nsorry\n\ntheorem too_many_bumps_dead (road : String) :\n  (∀ c ∈ road.toList, c = 'n') →\n  road.length ≥ 16 →\n  bumps road = \"Car Dead\" :=\nsorry\n\ntheorem empty_road_woohoo :\n  bumps \"\" = \"Woohoo!\" :=\nsorry\n\ntheorem edge_case_fifteen :\n  let nStr15 := String.mk (List.replicate 15 'n')\n  let nStr16 := String.mk (List.replicate 16 'n')\n  bumps nStr15 = \"Woohoo!\" ∧\n  bumps nStr16 = \"Car Dead\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Woohoo!'\n-/\n#guard_msgs in\n#eval bumps \"n\"\n\n/-\ninfo: 'Car Dead'\n-/\n#guard_msgs in\n#eval bumps \"_nnnnnnn_n__n______nn__nn_nnn\"\n\n/-\ninfo: 'Woohoo!'\n-/\n#guard_msgs in\n#eval bumps \"______n___n_\""}
{"id": "fvapps_003422", "vc-description": "/-\n*`This kata is a tribute/fanwork to the TV-show: Supernatural`*\n\nBalls!\n\nThose wayward Winchester boys are in trouble again, hunting something down in New Orleans.\nYou are Bobby Singer, you know how \"idjits\" they can be, so you have to prepare.\nThey will call you any minute with the race of the thing, and you want to answer as soon as possible. By answer, I mean: tell them how to kill, or fight it.\n\nYou have something like a database (more like drunken doodling) to help them:\n\n- werewolf           : Silver knife or bullet to the heart\n- vampire            : Behead it with a machete\n- wendigo            : Burn it to death\n- shapeshifter       : Silver knife or bullet to the heart\n- angel              : Use the angelic blade\n- demon              : Use Ruby's knife, or some Jesus-juice\n- ghost              : Salt and iron, and don't forget to burn the corpse\n- dragon             : You have to find the excalibur for that\n- djinn              : Stab it with silver knife dipped in a lamb's blood \n- pagan god          : It depends on which one it is\n- leviathan          : Use some Borax, then kill Dick\n- ghoul              : Behead it\n- jefferson starship : Behead it with a silver blade\n- reaper             : If it's nasty, you should gank who controls it\n- rugaru             : Burn it alive\n- skinwalker         : A silver bullet will do it\n- phoenix            : Use the colt\n- witch              : They are humans\n- else               : I have friggin no idea yet\n\nYou can access the database as `drunkenDoodling`/`drunken_doodling`/`DrunkenDoodling` depending on your language.\n\n---\n\nSo a call would go down like this:\n\nThe guys call you:\n```bob('rugaru')```\n\n...and you reply (return) with the info, and your signature saying of yours!\n```Burn it alive, idjits!```\n-/", "vc-preamble": "def KnownMonsters := [\n    \"werewolf\", \"vampire\", \"wendigo\", \"shapeshifter\", \"angel\", \"demon\",\n    \"ghost\", \"dragon\", \"djinn\", \"pagan god\", \"leviathan\", \"ghoul\",\n    \"jefferson starship\", \"reaper\", \"rugaru\", \"skinwalker\", \"phoenix\", \"witch\"\n]", "vc-helpers": "", "vc-definitions": "def bob (s : String) : String := sorry\n\ntheorem always_returns_string_with_idjits (s : String) :\n  let result := bob s\n  result.endsWith \", idjits!\" := by sorry", "vc-theorems": "theorem known_monsters_get_specific_response (monster : String) :\n  monster ∈ KnownMonsters →\n  let result := bob monster\n  result ≠ \"I have friggin no idea yet, idjits!\" ∧\n  result.endsWith \", idjits!\" := by sorry\n\ntheorem unknown_monsters_get_default_response (s : String) :\n  s ∉ KnownMonsters →\n  bob s = \"I have friggin no idea yet, idjits!\" := by sorry\n\ntheorem similar_monsters_same_killing_method_werewolf_shapeshifter :\n  let werewolfResult := bob \"werewolf\"\n  let shapeshifterResult := bob \"shapeshifter\"\n  werewolfResult.startsWith \"Silver knife\" ∧\n  shapeshifterResult.startsWith \"Silver knife\" := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Behead it with a machete, idjits!'\n-/\n#guard_msgs in\n#eval bob \"vampire\"\n\n/-\ninfo: 'It depends on which one it is, idjits!'\n-/\n#guard_msgs in\n#eval bob \"pagan god\"\n\n/-\ninfo: 'I have friggin no idea yet, idjits!'\n-/\n#guard_msgs in\n#eval bob \"werepuppy\""}
{"id": "fvapps_003452", "vc-description": "/-\nEver the learned traveller, Alan Partridge has pretty strong views on London:\n\n```\n\"Go to London. I guarantee you'll either be mugged or not appreciated.\nCatch the train to London, stopping at Rejection, Disappointment, Backstabbing Central and Shattered Dreams Parkway.\"\n```\nYour job is to check that the provided list of stations contains all of the stops Alan mentions. There will be other stations in the array.  Example:\n\n```\n['Rejection', 'Disappointment', 'Backstabbing Central', 'Shattered Dreams Parkway']\n```\n\nIf the stations all appear, return 'Smell my cheese you mother!', if not,  return 'No, seriously, run. You will miss it.'.\n\nOther katas in this series:\nAlan Partridge I - Partridge Watch\nAlan Partridge II - Apple Turnover\n-/", "vc-preamble": "def REQUIRED_STATIONS : List String := \n  [\"Rejection\", \"Disappointment\", \"Backstabbing Central\", \"Shattered Dreams Parkway\"]", "vc-helpers": "", "vc-definitions": "def isSubset (l1 l2 : List String) : Bool := sorry\n\ndef alan (stations : List String) : String := sorry", "vc-theorems": "theorem alan_complete {stations : List String} : \n  isSubset REQUIRED_STATIONS stations → \n  alan stations = \"Smell my cheese you mother!\" := sorry\n\ntheorem alan_incomplete {stations : List String} :\n  ¬isSubset REQUIRED_STATIONS stations →\n  alan stations = \"No, seriously, run. You will miss it.\" := sorry\n\ntheorem alan_with_additional \n  {additional : List String} (h : additional.length ≥ 4) :\n  alan (REQUIRED_STATIONS ++ additional) = \"Smell my cheese you mother!\" := sorry\n\ntheorem alan_with_incomplete_subset\n  {subset : List String} (h : subset.length ≤ 3) \n  (h2 : ∀ x ∈ subset, x ∈ REQUIRED_STATIONS) :\n  alan subset = \"No, seriously, run. You will miss it.\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Smell my cheese you mother!'\n-/\n#guard_msgs in\n#eval alan [\"Norwich\", \"Rejection\", \"Disappointment\", \"Backstabbing Central\", \"Shattered Dreams Parkway\", \"London\"]\n\n/-\ninfo: 'No, seriously, run. You will miss it.'\n-/\n#guard_msgs in\n#eval alan [\"London\", \"Norwich\"]\n\n/-\ninfo: 'Smell my cheese you mother!'\n-/\n#guard_msgs in\n#eval alan [\"Norwich\", \"Rejection\", \"Disappointment\", \"Backstabbing Central\", \"Shattered Dreams Parkway\"]"}
{"id": "fvapps_003455", "vc-description": "/-\nEvery now and then people in the office moves teams or departments. Depending what people are doing with their time they can become more or less boring. Time to assess the current team.\n\n```if-not:java\nYou will be provided with an object(staff) containing the staff names as keys, and the department they work in as values.\n```\n\n```if:java\nYou will be provided with an array of `Person` objects with each instance containing the name and department for a staff member.\n~~~java\npublic class Person {\n  public final String name;        // name of the staff member\n  public final String department;  // department they work in\n}\n~~~\n```\n\nEach department has a different boredom assessment score, as follows:\n\naccounts = 1\nfinance = 2 \ncanteen = 10 \nregulation = 3 \ntrading = 6 \nchange = 6\nIS = 8\nretail = 5 \ncleaning = 4\npissing about = 25\n\nDepending on the cumulative score of the team, return the appropriate sentiment:\n\n<=80: 'kill me now'\n< 100 & > 80: 'i can handle this'\n100 or over: 'party time!!'\n\nThe Office I - Outed\nThe Office III - Broken Photocopier\nThe Office IV - Find a Meeting Room\nThe Office V - Find a Chair\n-/", "vc-preamble": "def VALID_DEPTS := [\"accounts\", \"finance\", \"canteen\", \"regulation\", \"trading\", \n                    \"change\", \"IS\", \"retail\", \"cleaning\", \"pissing about\"]\n\ndef scores : List (String × Nat) := [\n  (\"accounts\", 1), (\"finance\", 2), (\"canteen\", 10), (\"regulation\", 3),\n  (\"trading\", 6), (\"change\", 6), (\"IS\", 8), (\"retail\", 5),\n  (\"cleaning\", 4), (\"pissing about\", 25)\n]\n\ndef getScore (dept : String) : Nat :=\n  match scores.find? (fun p => p.1 = dept) with\n  | some p => p.2\n  | none => 0\n\ndef getTotalScore (staff : List (String × String)) : Nat :=\n  staff.foldl (fun acc x => acc + getScore x.2) 0", "vc-helpers": "", "vc-definitions": "def boredom (staff : List (String × String)) : String :=\n  sorry", "vc-theorems": "theorem boredom_output_valid (staff : List (String × String)) :\n  let result := boredom staff\n  result = \"kill me now\" ∨ result = \"i can handle this\" ∨ result = \"party time!!\" := \n  sorry\n\ntheorem boredom_threshold_low (staff : List (String × String)) \n  (h : ∀ x ∈ staff, x.2 ∈ VALID_DEPTS) :\n  let total := getTotalScore staff\n  total ≤ 80 → boredom staff = \"kill me now\" :=\n  sorry\n\ntheorem boredom_threshold_mid (staff : List (String × String))\n  (h : ∀ x ∈ staff, x.2 ∈ VALID_DEPTS) :\n  let total := getTotalScore staff\n  total > 80 ∧ total < 100 → boredom staff = \"i can handle this\" :=\n  sorry\n\ntheorem boredom_threshold_high (staff : List (String × String))\n  (h : ∀ x ∈ staff, x.2 ∈ VALID_DEPTS) :\n  let total := getTotalScore staff\n  total ≥ 100 → boredom staff = \"party time!!\" :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'kill me now'\n-/\n#guard_msgs in\n#eval boredom {\"tim\": \"change\", \"jim\": \"accounts\", \"randy\": \"canteen\", \"sandy\": \"change\", \"andy\": \"change\", \"katie\": \"IS\", \"laura\": \"change\", \"saajid\": \"IS\", \"alex\": \"trading\", \"john\": \"accounts\", \"mr\": \"finance\"}\n\n/-\ninfo: 'i can handle this'\n-/\n#guard_msgs in\n#eval boredom {\"tim\": \"IS\", \"jim\": \"finance\", \"randy\": \"pissing about\", \"sandy\": \"cleaning\", \"andy\": \"cleaning\", \"katie\": \"cleaning\", \"laura\": \"pissing about\", \"saajid\": \"regulation\", \"alex\": \"regulation\", \"john\": \"accounts\", \"mr\": \"canteen\"}\n\n/-\ninfo: 'party time!!'\n-/\n#guard_msgs in\n#eval boredom {\"tim\": \"accounts\", \"jim\": \"accounts\", \"randy\": \"pissing about\", \"sandy\": \"finance\", \"andy\": \"change\", \"katie\": \"IS\", \"laura\": \"IS\", \"saajid\": \"canteen\", \"alex\": \"pissing about\", \"john\": \"retail\", \"mr\": \"pissing about\"}"}
{"id": "fvapps_003470", "vc-description": "/-\nWrite a program that will take a string of digits and give you all the possible consecutive slices of length `n` in that string.\n\nRaise an error if `n` is larger than the length of the string.\n\n## Examples\n\nFor example, the string `\"01234\"` has the following 2-digit slices:\n```\n[0, 1], [1, 2], [2, 3], [3, 4]\n```\n\nThe same string has the following 4-digit slices:\n```\n[0, 1, 2, 3], [1, 2, 3, 4]\n```\n-/", "vc-preamble": "def Digit := Nat\ndef NumStr := List Digit\n\ninstance : OfNat Digit n where\n  ofNat := n\n\ninstance : LE Digit where\n  le := Nat.le", "vc-helpers": "", "vc-definitions": "def series_slices (digits : NumStr) (n : Nat) : List (List Digit) :=\n  sorry", "vc-theorems": "theorem slice_length_bounds \n  (digits : NumStr) (n : Nat) (h : n > 0) :\n  (n > digits.length → (series_slices digits n).isEmpty) ∧ \n  (n ≤ digits.length → \n    ((series_slices digits n).length = digits.length - n + 1) ∧\n    (∀ slice ∈ series_slices digits n, slice.length = n)) :=\n  sorry\n\ntheorem slice_contents\n  (digits : NumStr) (n : Nat) (h₁ : n > 0) (h₂ : n ≤ digits.length) :\n  ∀ i, i < (series_slices digits n).length →\n    (series_slices digits n)[i]! = digits.take (n) :=\n  sorry\n\ntheorem full_slice\n  (digits : NumStr) (h : digits.length > 0) :\n  let n := digits.length\n  (series_slices digits n).length = 1 ∧\n  (series_slices digits n)[0]! = digits :=\n  sorry\n\ntheorem all_integers\n  (digits : NumStr) (n : Nat) (h₁ : n > 0) (h₂ : n ≤ digits.length) :\n  ∀ slice ∈ series_slices digits n,\n    ∀ d ∈ slice, d ≤ 9 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: [[0, 1], [1, 2], [2, 3], [3, 4]]\n-/\n#guard_msgs in\n#eval series_slices \"01234\" 2\n\n/-\ninfo: [[0, 1, 2, 3], [1, 2, 3, 4]]\n-/\n#guard_msgs in\n#eval series_slices \"01234\" 4\n\n/-\ninfo: [[0, 1, 2, 3, 4]]\n-/\n#guard_msgs in\n#eval series_slices \"01234\" 5"}
{"id": "fvapps_003552", "vc-description": "/-\nYou probably know that the \"mode\" of a set of data is the data point that appears most frequently. Looking at the characters that make up the string `\"sarsaparilla\"` we can see that the letter `\"a\"` appears four times, more than any other letter, so the mode of `\"sarsaparilla\"` is `\"a\"`.\n\nBut do you know what happens when two or more data points occur the most? For example, what is the mode of the letters in `\"tomato\"`? Both `\"t\"` and `\"o\"` seem to be tied for appearing most frequently.\n\nTurns out that a set of data can, in fact, have multiple modes, so `\"tomato\"` has two modes: `\"t\"` and `\"o\"`. It's important to note, though, that if *all* data appears the same number of times there is no mode. So `\"cat\"`, `\"redder\"`, and `[1, 2, 3, 4, 5]` do not have a mode.\n\nYour job is to write a function `modes()` that will accept one argument `data` that is a sequence like a string or a list of numbers and return a sorted list containing the mode(s) of the input sequence. If data does not contain a mode you should return an empty list.\n\nFor example:\n\n```python\n>>> modes(\"tomato\")\n[\"o\", \"t\"]\n>>> modes([1, 3, 3, 7])\n[3]\n>>> modes([\"redder\"])\n[]\n```\n\nYou can trust that your input data will always be a sequence and will always contain orderable types (no inputs like `[1, 2, 2, \"a\", \"b\", \"b\"]`).\n-/", "vc-preamble": "def count {α : Type} [BEq α] (x : α) (xs : List α) : Nat :=\n  xs.filter (· == x) |>.length\n\n/- Test if list is sorted -/\n\ndef IsSorted {α : Type} [LE α] : List α → Prop\n  | [] => True\n  | [_] => True\n  | x :: y :: xs => x ≤ y ∧ IsSorted (y :: xs)", "vc-helpers": "", "vc-definitions": "def modes {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) : List α := sorry\n\ntheorem modes_list_sorted {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) (h : xs ≠ []) :\n  IsSorted (modes xs) := sorry", "vc-theorems": "theorem modes_elements_in_input {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) (x : α) :\n  x ∈ modes xs → x ∈ xs := sorry\n\ntheorem modes_counts_equal {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) (h : modes xs ≠ []) :\n  ∀ (x y : α), x ∈ modes xs → y ∈ modes xs → count x xs = count y xs := sorry\n\ntheorem modes_is_max_count {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) (h : modes xs ≠ []) :\n  ∀ (x : α), x ∈ modes xs → ∀ (y : α), y ∈ xs → count x xs ≥ count y xs := sorry\n\ntheorem modes_not_min_count {α : Type} [Ord α] [BEq α] [LE α] (xs : List α) (h₁ : modes xs ≠ []) (h₂ : xs ≠ []) :\n  ∀ (x : α), x ∈ modes xs → ∃ (y : α), y ∈ xs ∧ count x xs > count y xs := sorry\n\ntheorem modes_string_length (s : String) (h : s.length > 0) :\n  ∀ (x : Char), x ∈ modes s.data → true := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['o', 't']\n-/\n#guard_msgs in\n#eval modes \"tomato\"\n\n/-\ninfo: [3]\n-/\n#guard_msgs in\n#eval modes [1, 3, 3, 7]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval modes \"redder\""}
{"id": "fvapps_003647", "vc-description": "/-\nGiven a hash of letters and the number of times they occur, recreate all of the possible anagram combinations that could be created using all of the letters, sorted alphabetically.\n\nThe inputs will never include numbers, spaces or any special characters, only lowercase letters a-z.\n\nE.g. get_words({2=>[\"a\"], 1=>[\"b\", \"c\"]}) => [\"aabc\", \"aacb\", \"abac\", \"abca\", \"acab\", \"acba\", \"baac\", \"baca\", \"bcaa\", \"caab\", \"caba\", \"cbaa\"]\n-/", "vc-preamble": "def HashMap (α β : Type) := List (α × β)\n\nvariable (input: HashMap String (List Char))", "vc-helpers": "", "vc-definitions": "def get_words (input: HashMap String (List Char)) : List String := sorry\n\ndef IsSorted (l: List String) : Prop :=\n  ∀ i j, i < j → j < l.length → (l.get ⟨i, by sorry⟩) ≤ (l.get ⟨j, by sorry⟩)\n\n-- Words returned are sorted", "vc-theorems": "theorem words_are_sorted : IsSorted (get_words input) := sorry\n\n-- All words have the same length\n\ntheorem words_same_length\n  (w1 w2: String)\n  (hw1: w1 ∈ get_words input)\n  (hw2: w2 ∈ get_words input)\n  : w1.length = w2.length := sorry\n\n-- All words are permutations of each other\n\ntheorem words_are_permutations\n  (w1 w2: String)\n  (hw1: w1 ∈ get_words input)\n  (hw2: w2 ∈ get_words input)\n  : ∃ (perm: List Char), w2.data = perm ∧ perm.length = w1.data.length := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_003659", "vc-description": "/-\n## Story\n\nYour company migrated the last 20 years of it's *very important data* to a new platform, in multiple phases. However, something went wrong: some of the essential time-stamps were messed up! It looks like that some servers were set to use the `dd/mm/yyyy` date format, while others were using the `mm/dd/yyyy` format during the migration. Unfortunately, the original database got corrupted in the process and there are no backups available... Now it's up to you to assess the damage.\n\n## Task\n\nYou will receive a list of records as strings in the form of `[start_date, end_date]` given in the ISO `yyyy-mm-dd` format, and your task is to count how many of these records are: \n* **correct**: there can be nothing wrong with the dates, the month/day cannot be mixed up, or it would not make a valid timestamp in any other way; e.g. `[\"2015-04-04\", \"2015-05-13\"]`\n* **recoverable**: invalid in its current form, but the original timestamp can be recovered, because there is only one valid combination possible; e.g. `[\"2011-10-08\", \"2011-08-14\"]`\n* **uncertain**: one or both dates are ambiguous, and they may generate multiple valid timestamps, so the original cannot be retrieved; e.g. `[\"2002-02-07\", \"2002-12-10\"]`\n\n**Note:** the original records always defined a *non-negative* duration\n\nReturn your findings in an array: `[ correct_count, recoverable_count, uncertain_count ]`\n\n## Examples\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n-/", "vc-preamble": "def sum_list : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def check_dates (records : List (String × String)) : List Nat :=\n  sorry", "vc-theorems": "theorem check_dates_output_format {records : List (String × String)} \n  (h : records ≠ []) : \n  let result := check_dates records;\n  (result.length = 3) ∧ \n  (∀ x ∈ result, x ≥ 0) ∧\n  (sum_list result = records.length) :=\nsorry\n\ntheorem check_dates_empty : \n  check_dates [] = [0, 0, 0] :=\nsorry\n\ntheorem check_dates_output_valid (records : List (String × String)) :\n  ∀ x ∈ check_dates records, x ≥ 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [0, 0, 0]\n-/\n#guard_msgs in\n#eval check_dates []\n\n/-\ninfo: [1, 0, 0]\n-/\n#guard_msgs in\n#eval check_dates [[\"2015-04-04\", \"2015-05-13\"]]\n\n/-\ninfo: [0, 1, 0]\n-/\n#guard_msgs in\n#eval check_dates [[\"2011-10-08\", \"2011-08-14\"]]\n\n/-\ninfo: [0, 0, 1]\n-/\n#guard_msgs in\n#eval check_dates [[\"2002-02-07\", \"2002-12-10\"]]"}
{"id": "fvapps_003673", "vc-description": "/-\nGiven an array (ints) of n integers, find three integers in arr such that the sum is closest to a given number (num), target.\n\nReturn the sum of the three integers. \nYou may assume that each input would have exactly one solution.\n\nExample:\n\nNote: your solution should not modify the input array.\n-/", "vc-preamble": "def abs (x : Int) : Int :=\n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def closest_sum (nums : List Int) (target : Int) : Int :=\n  sorry", "vc-theorems": "theorem closest_sum_is_sum_of_three (nums : List Int) (target : Int)\n    (h : nums.length ≥ 3) :\n  ∃ a b c, a ∈ nums ∧ b ∈ nums ∧ c ∈ nums ∧ \n    closest_sum nums target = a + b + c :=\n  sorry\n\ntheorem closest_sum_is_minimal (nums : List Int) (target : Int) \n    (h : nums.length ≥ 3) :\n  ∀ a b c, a ∈ nums → b ∈ nums → c ∈ nums →\n    abs (target - closest_sum nums target) ≤ abs (target - (a + b + c)) :=\n  sorry\n\ntheorem closest_sum_three_elements (a b c target : Int) :\n  closest_sum [a,b,c] target = a + b + c :=\n  sorry\n\ntheorem closest_sum_returns_int (nums : List Int) (target : Int)\n    (h : nums.length ≥ 3) :\n  ∃ n : Int, closest_sum nums target = n :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval closest_sum [-1, 2, 1, -4] 1\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval closest_sum [5, 4, 0, 3] 3\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval closest_sum [-2, 2, -3, 1] 3"}
{"id": "fvapps_003687", "vc-description": "/-\nIf we alternate the vowels and consonants in the string `\"have\"`, we get the following list, arranged alphabetically:\n`['ahev', 'aveh', 'ehav', 'evah', 'vahe', 'veha']`. These are the only possibilities in which vowels and consonants are alternated. The first element, `ahev`, is alphabetically lowest. \n\nGiven a string:\n* alternate the vowels and consonants and return the lexicographically lowest element in the list\n* If any two or more vowels or consonants must follow each other, return `\"failed\"`\n* if the number of vowels and consonants are equal, the first letter of the result must be a vowel.\n\nExamples: \n\n```Haskell\nsolve(\"codewars\") = \"failed\". However you alternate vowels and consonants, two consonants must follow each other\nsolve(\"oruder\") = \"edorur\"\nsolve(\"orudere\") = \"ederoru\". This is the only option that allows you to alternate vowels & consonants.\n```\n\n```if c:\nIn C, return an allocated string even if the response is \"failed\".\n```\n\nVowels will be any of \"aeiou\". Input will be a lowercase string, no spaces. See test cases for more examples. \n\nGood luck!\n\nIf you like this Kata, please try: \n\n[Consonant value](https://www.codewars.com/kata/59c633e7dcc4053512000073)\n\n[Alternate capitalization](https://www.codewars.com/kata/59cfc000aeb2844d16000075)\n-/", "vc-preamble": "def isVowel (c : Char) : Bool :=\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'", "vc-helpers": "", "vc-definitions": "def solve (s : String) : String :=\n  sorry", "vc-theorems": "theorem output_format {s : String} (h : s.length > 0) :\n  let result := solve s\n  (result = \"failed\") ∨ \n  (∀ c, c ∈ result.data → c ∈ s.data) := \n  sorry\n\ntheorem alternating_pattern {s : String} (h : s.length > 0) :\n  let result := solve s\n  result ≠ \"failed\" → result.length > 1 →\n  ∀ i : Fin result.length, i.val + 1 < result.length →\n    ∀ pos pos' : String.Pos, \n      pos.byteIdx = i.val → pos'.byteIdx = i.val + 1 →\n      isVowel (result.get pos) ≠ isVowel (result.get pos') :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'ajav'\n-/\n#guard_msgs in\n#eval solve \"java\"\n\n/-\ninfo: 'edorur'\n-/\n#guard_msgs in\n#eval solve \"oruder\"\n\n/-\ninfo: 'failed'\n-/\n#guard_msgs in\n#eval solve \"codewars\""}
{"id": "fvapps_003693", "vc-description": "/-\nYou've got a bunch of textual data with embedded phone numbers. Write a function `area_code()` that finds and returns just the area code portion of the phone number.\n```python\n>>> message = \"The supplier's phone number is (555) 867-5309\"\n>>> area_code(message)\n'555'\n```\nThe returned area code should be a string, not a number.\nEvery phone number is formatted like in the example, and the only non-alphanumeric characters in the string are apostrophes `'` or the punctuation used in the phone number.\n-/", "vc-preamble": "def phone_number_format (a p l: String) : String :=\n  s!\"({a}) {p}-{l}\"", "vc-helpers": "", "vc-definitions": "def area_code (s: String) : String :=\nsorry", "vc-theorems": "theorem area_code_extracts_area_from_standard_format {a p l : String}\n  (h1: a.length = 3) (h2: p.length = 3) (h3: l.length = 4) :\n  area_code (phone_number_format a p l) = a := by\n  sorry\n\ntheorem area_code_extracts_area_with_surrounding_text {a p l t1 t2 : String}\n  (h1: a.length = 3) (h2: p.length = 3) (h3: l.length = 4) :\n  area_code (t1 ++ phone_number_format a p l ++ t2) = a := by\n  sorry\n\ntheorem area_code_empty_parens :\n  area_code \"()\" = \"\" := by\n  sorry\n\ntheorem area_code_nested_parens :\n  area_code \"(123(456)789)\" = \"123(456\" := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '555'\n-/\n#guard_msgs in\n#eval area_code \"The supplier\"s phone number is (555) 867-5309\"\n\n/-\ninfo: '123'\n-/\n#guard_msgs in\n#eval area_code \"Grae\"s cell number used to be (123) 456-7890\"\n\n/-\ninfo: '124'\n-/\n#guard_msgs in\n#eval area_code \"The 102nd district court\"s fax line is (124) 816-3264\""}
{"id": "fvapps_003721", "vc-description": "/-\n# Task\n A noob programmer was given two simple tasks: sum and sort the elements of the given array `arr` = [a1, a2, ..., an]. \n\n He started with summing and did it easily, but decided to store the sum he found in some random position of the original array which was a bad idea. Now he needs to cope with the second task, sorting the original array arr, and it's giving him trouble since he modified it.\n\n Given the array `shuffled`, consisting of elements a1, a2, ..., an, and their sumvalue in random order, return the sorted array of original elements a1, a2, ..., an.\n\n# Example\n\n For `shuffled = [1, 12, 3, 6, 2]`, the output should be `[1, 2, 3, 6]`.\n\n `1 + 3 + 6 + 2 = 12`, which means that 1, 3, 6 and 2 are original elements of the array.\n\n For `shuffled = [1, -3, -5, 7, 2]`, the output should be `[-5, -3, 2, 7]`.\n\n# Input/Output\n\n - `[input]` integer array `shuffled`\n\n    Array of at least two integers. It is guaranteed that there is an index i such that shuffled[i] = shuffled[0] + ... + shuffled[i - 1] + shuffled[i + 1] + ... + shuffled[n].\n\n    Constraints:\n\n    `2 ≤ shuffled.length ≤ 30,`\n\n    `-300 ≤ shuffled[i] ≤ 300.`\n\n - `[output]` an integer array\n\n    A `sorted` array of shuffled.length - 1 elements.\n-/", "vc-preamble": "def List.insertIntoSorted (x : Int) : List Int → List Int \n  | [] => [x]\n  | y::ys => if x ≤ y then x::y::ys else y::(insertIntoSorted x ys)\n\ndef List.sortList : List Int → List Int \n  | [] => []\n  | x::xs => insertIntoSorted x (sortList xs)", "vc-helpers": "", "vc-definitions": "def shuffled_array (arr : List Int) : List Int := sorry \n\ntheorem shuffled_array_valid_properties {arr : List Int} (h : arr.length ≥ 2) :\n  let orig := (arr.take (arr.length - 1)).sortList\n  let total := arr.take (arr.length - 1) |>.foldl (· + ·) 0\n  let result := shuffled_array (orig ++ [total])\n  result.length = orig.length ∧ result.sortList = orig\n  := sorry", "vc-theorems": "theorem shuffled_array_invalid {arr : List Int} \n  (h : ∀ (i : Nat) (h : i < arr.length), \n    arr.get ⟨i, h⟩ ≠ ((arr.take i ++ arr.drop (i+1)).foldl (· + ·) 0)) :\n  shuffled_array arr = [] := sorry\n\ntheorem shuffled_array_single {x : Int} :\n  shuffled_array [x] = [] := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3, 6]\n-/\n#guard_msgs in\n#eval shuffled_array [1, 12, 3, 6, 2]\n\n/-\ninfo: [-5, -3, 2, 7]\n-/\n#guard_msgs in\n#eval shuffled_array [1, -3, -5, 7, 2]\n\n/-\ninfo: [-3]\n-/\n#guard_msgs in\n#eval shuffled_array [-3, -3]"}
{"id": "fvapps_003725", "vc-description": "/-\n# Task\n\nJohn and Alice have an appointment today. \n\nIn the morning, John starts from (`0,0`) and goes to the place (`a,b`) where he is dating. Unfortunately, John had no sense of direction at all, so he moved 1 step in a random direction(up, down, left or right) each time. For example, if John at (x,y), next step he may move to `(x+1,y), (x-1,y),(x,y+1) or (x,y-1)`. \n\nObviously, when he arrived at the destination, it was already too late and Alice had already left. It's a sadly story :(\n\nThe second day, Alice asked John why he didn't go to the dating place. John said he took `s` steps to his date yesterday.\n\nAlice wants to know whether John is lying. Please help Alice to judge.\n\nGiven two coordinates `a, b` and the step `s`, return `true` if John tells the truth, `false` otherwise.\n\n# Input/Output\n\n`[input]` integer `a`\n\nThe x-coordinates of the dating site.\n\n`-10^7 <= a <= 10^7`\n\n`[input]` integer `b`\n\nThe y-coordinates of the dating site.\n\n`-10^7 <= b <= 10^7`\n\n`[input]` integer `s`\n\nA positive integer.  The steps John using.\n\n`0 < s <= 10^9`\n\n`[output]` a boolean value\n\nreturn `true` if John tells the truth, `false` otherwise.\n\n# Example\n\nFor `a = 3, b = 3, s = 6`, the output should be `true`.\n\nA possible path is: \n\n`(0,0) -> (0,1) -> (0,2) -> (0,3) -> (1,3) -> (2,3) -> (3,3)`\n\nFor `a = 3, b = 3, s = 8`, the output should be `true`.\n\nA possible path is: \n\n`(0,0) -> (0,1) -> (1,1) -> (1,2) -> (2,2) -> (2,1) -> (3,1) -> (3,2) -> (3,3)`\n\nFor `a = 4, b = 5, s = 10`, the output should be `false`.\n\nJohn can't reach coordinates (a, b) using 10 steps, he's lying ;-)\n-/", "vc-preamble": "def abs (x : Int) : Int := \n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def is_john_lying (x y steps : Int) : Bool := sorry\n\ntheorem symmetry_properties {x y steps : Int} (h : steps ≥ 0) :\n  is_john_lying x y steps = is_john_lying (-x) y steps ∧\n  is_john_lying x y steps = is_john_lying x (-y) steps ∧\n  is_john_lying x y steps = is_john_lying y x steps := sorry", "vc-theorems": "theorem min_steps_required {x y : Int} :\n  ¬(is_john_lying x y (abs x + abs y - 1)) := sorry\n\ntheorem parity_constraint {x y extra_steps : Int} (h : extra_steps ≥ 0) :\n  let min_steps := abs x + abs y\n  let steps := min_steps + extra_steps\n  if extra_steps % 2 = 0 then \n    is_john_lying x y steps = (steps ≥ min_steps)\n  else\n    ¬(is_john_lying x y steps) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_john_lying 3 3 6\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_john_lying 4 5 10\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_john_lying -5 -5 10"}
{"id": "fvapps_003863", "vc-description": "/-\nGiven an array of numbers, return the difference between the largest and smallest values. \n\nFor example:\n\n`[23, 3, 19, 21, 16]` should return `20` (i.e., `23 - 3`).\n\n`[1, 434, 555, 34, 112]` should return `554` (i.e., `555 - 1`).\n\nThe array will contain a minimum of two elements. Input data range guarantees that `max-min` will cause no integer overflow.\n-/", "vc-preamble": "def List.maximum : List Int → Option Int \n  | [] => none\n  | (h::t) => some (t.foldl max h)\n\ndef List.minimum : List Int → Option Int\n  | [] => none\n  | (h::t) => some (t.foldl min h)", "vc-helpers": "", "vc-definitions": "def between_extremes (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem between_extremes_nonnegative (nums : List Int) (h : nums ≠ []) :\n  between_extremes nums ≥ 0 := \n  sorry\n\ntheorem between_extremes_singleton (n : Int) :\n  between_extremes [n] = 0 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval between_extremes [1, 1]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval between_extremes [1, -1]\n\n/-\ninfo: 42\n-/\n#guard_msgs in\n#eval between_extremes [21, 34, 54, 43, 26, 12]"}
{"id": "fvapps_003936", "vc-description": "/-\nTo celebrate today's launch of my Hero's new book: Alan Partridge: Nomad, We have a new series of kata arranged around the great man himself.\n\nGiven an array of terms, if any of those terms relate to Alan Partridge, return Mine's a Pint!\n\nThe number of ! after the t should be determined by the number of Alan related terms you find in the provided array (x). The related terms are:\n\nPartridge\nPearTree\nChat\nDan\nToblerone\nLynn\nAlphaPapa\nNomad\n\nIf you don't find any related terms, return 'Lynn, I've pierced my foot on a spike!!'\n\nAll Hail King Partridge\n\nOther katas in this series:\nAlan Partridge II - Apple Turnover\nAlan Partridge III - London\n-/", "vc-preamble": "def ALAN_TERMS : List String := [\"Partridge\", \"PearTree\", \"Chat\", \"Dan\", \"Toblerone\", \"Lynn\", \"AlphaPapa\", \"Nomad\"]\n\ndef isAlanTerm (s : String) : Bool :=\n  ALAN_TERMS.contains s\n\ndef countChar (s : String) (c : Char) : Nat :=\n  s.toList.filter (· = c) |>.length", "vc-helpers": "", "vc-definitions": "def part (arr : List String) : String :=\n  sorry", "vc-theorems": "theorem empty_or_irrelevant_returns_spike_message {arr : List String} :\n  (∀ x ∈ arr, ¬isAlanTerm x) →\n  part arr = \"Lynn, I've pierced my foot on a spike!!\" :=\nsorry\n\ntheorem alan_terms_return_pint_with_exclamations {arr : List String} :\n  (arr ≠ []) →\n  (∀ x ∈ arr, isAlanTerm x) →\n  (part arr).startsWith \"Mine's a Pint\" ∧\n  countChar (part arr) '!' = arr.length :=\nsorry\n\ntheorem mixed_terms_count_only_alan_terms (alan_arr other_arr : List String) :\n  (alan_arr ≠ []) →\n  (∀ x ∈ alan_arr, isAlanTerm x) →\n  (∀ x ∈ other_arr, ¬isAlanTerm x) →\n  countChar (part (alan_arr ++ other_arr)) '!' = alan_arr.length :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: \"Mine's a Pint!\"\n-/\n#guard_msgs in\n#eval part [\"Grouse\", \"Partridge\", \"Pheasant\"]\n\n/-\ninfo: \"Lynn, I've pierced my foot on a spike!!\"\n-/\n#guard_msgs in\n#eval part [\"Pheasant\", \"Goose\", \"Starling\", \"Robin\"]\n\n/-\ninfo: \"Mine's a Pint!!!!!\"\n-/\n#guard_msgs in\n#eval part [\"Partridge\", \"PearTree\", \"Chat\", \"Dan\", \"Toblerone\"]"}
{"id": "fvapps_003948", "vc-description": "/-\nAn array is called `centered-N` if some `consecutive sequence` of elements of the array sum to `N` and this sequence is preceded and followed by the same number of elements. \n\nExample:\n```\n[3,2,10,4,1,6,9] is centered-15\nbecause the sequence 10,4,1 sums to 15 and the sequence \nis preceded by two elements [3,2] and followed by two elements [6,9]\n\n```\n\nWrite a method called `isCenteredN` that returns :\n\n- `true` if its array argument is `not empty` and `centered-N` or empty and centered-0\n- otherwise returns `false`.\n-/", "vc-preamble": "def sum : List Int → Int\n  | [] => 0\n  | (h :: t) => h + sum t", "vc-helpers": "", "vc-definitions": "def is_centered (arr : List Int) (n : Int) : Bool :=\n  sorry", "vc-theorems": "theorem empty_list_property (n : Int) :\n  is_centered [] n = (n = 0) := sorry\n\ntheorem single_element_property {a : Int} :\n  is_centered [a] (sum [a]) := sorry\n\ntheorem symmetric_property (arr : List Int) (n : Int) :\n  is_centered arr n = is_centered arr.reverse n := sorry\n\ntheorem full_sum_property (arr : List Int) :\n  arr ≠ [] → is_centered arr (sum arr) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_centered [3, 2, 10, 4, 1, 6, 9] 15\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval is_centered [1, 1, 8, 3, 1, 1] 11\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval is_centered [2, 10, 4, 1, 6, 9] 15"}
{"id": "fvapps_003990", "vc-description": "/-\n# Largest Rectangle in Background\n\nImagine a photo taken to be used in an advertisement. The background on the left of the motive is whitish and you want to write some text on that background. So you scan the photo with a high resolution scanner and, for each line, count the number of pixels from the left that are sufficiently white and suitable for being written on. Your job is to find the area of the largest text box you can place on those pixels.\n\nExample:\nIn the figure below, the whitish background pixels of the scanned photo are represented by asterisks.\n\n```\n*********************************\n*********\n*******\n******\n******\n******\n**************\n**************\n**************\n***************\n*********************\n\n``` \n\nIf you count the pixels on each line from the left you get the list (or array, depending on which language you are using) `[33, 9, 7, 6, 6, 6, 14, 14, 14, 15, 21]`. The largest reactangle that you can place on these pixels has an area of 70, and is represented by the dots in the figure below.\n\n```\n*********************************\n*********\n*******\n******\n******\n******\n..............\n..............\n..............\n..............*\n..............*******\n``` \n\nWrite a function that, given a list of the number whitish pixels on each line in the background, returns the area of the largest rectangle that fits on that background.\n-/", "vc-preamble": "def maximum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => max x (maximum xs)\n\ndef minimum : List Nat → Nat\n  | [] => 0\n  | (x::xs) => min x (minimum xs)", "vc-helpers": "", "vc-definitions": "def largest_rect (heights : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem largest_rect_empty :\n  largest_rect [] = 0 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval largest_rect [3, 5, 12, 4, 10]\n\n/-\ninfo: 12\n-/\n#guard_msgs in\n#eval largest_rect [6, 2, 5, 4, 5, 1, 6]\n\n/-\ninfo: 70\n-/\n#guard_msgs in\n#eval largest_rect [33, 9, 7, 6, 6, 6, 14, 14, 14, 15, 21]"}
{"id": "fvapps_004018", "vc-description": "/-\nWrite a function called \"filterEvenLengthWords\".\n\nGiven an array of strings, \"filterEvenLengthWords\" returns an array containing only the elements of the given array whose length is an even number.\n\nvar output = filterEvenLengthWords(['word', 'words', 'word', 'words']);\n\nconsole.log(output); // --> ['word', 'word']\n-/", "vc-preamble": "def evenLength (s : String) : Bool :=\n  s.length % 2 = 0", "vc-helpers": "", "vc-definitions": "def filterEvenLengthWords (words : List String) : List String :=\n  sorry", "vc-theorems": "theorem output_elements_have_even_length (words : List String) :\n  ∀ w ∈ filterEvenLengthWords words, evenLength w :=\nsorry\n\ntheorem output_is_subset_of_input (words : List String) :\n  ∀ w ∈ filterEvenLengthWords words, w ∈ words :=\nsorry\n\ntheorem all_even_length_words_included (words : List String) :\n  ∀ w ∈ words, evenLength w → w ∈ filterEvenLengthWords words :=\nsorry\n\ntheorem maintains_order (words : List String) :\n  filterEvenLengthWords words = words.filter evenLength :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['word', 'word']\n-/\n#guard_msgs in\n#eval filter_even_length_words [\"word\", \"words\", \"word\", \"words\"]\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval filter_even_length_words [\"Hello\", \"World\"]\n\n/-\ninfo: ['Four']\n-/\n#guard_msgs in\n#eval filter_even_length_words [\"One\", \"Two\", \"Three\", \"Four\"]"}
{"id": "fvapps_004030", "vc-description": "/-\nWrite a function that merges two sorted arrays into a single one. The arrays only contain integers. Also, the final outcome must be sorted and not have any duplicate.\n-/", "vc-preamble": "def isSorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\ndef noDuplicates (l : List Int) : Prop :=\n  ∀ x i j, i < j → j < l.length → l[i]! = x → l[j]! ≠ x", "vc-helpers": "", "vc-definitions": "def mergeArrays (a b : List Int) : List Int := sorry\n\ntheorem merge_arrays_is_sorted (a b : List Int) (h₁ : isSorted a) (h₂ : isSorted b) : \n  isSorted (mergeArrays a b) := sorry", "vc-theorems": "theorem merge_arrays_no_duplicates (a b : List Int) :\n  noDuplicates (mergeArrays a b) := sorry\n\ntheorem merge_arrays_contains_all (a b : List Int) :\n  ∀ x, (x ∈ a ∨ x ∈ b) ↔ x ∈ mergeArrays a b := sorry\n\ntheorem merge_arrays_length_bound (a b : List Int) :\n  (mergeArrays a b).length ≤ a.length + b.length := sorry\n\ntheorem merge_arrays_self_idempotent (a : List Int) (h : isSorted a) :\n  mergeArrays a a = (a.toArray.qsort (· ≤ ·)).toList := sorry\n\ntheorem merge_arrays_empty_identity (a : List Int) (h : isSorted a) :\n  mergeArrays a [] = (a.toArray.qsort (· ≤ ·)).toList ∧ \n  mergeArrays [] a = (a.toArray.qsort (· ≤ ·)).toList := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval merge_arrays #[1, 3, 5] #[2, 4, 6]\n\n/-\ninfo: [2, 4, 6, 8]\n-/\n#guard_msgs in\n#eval merge_arrays #[2, 4, 8] #[2, 4, 6]\n\n/-\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval merge_arrays #[1, 2, 3] #[]"}
{"id": "fvapps_004054", "vc-description": "/-\nAt the annual family gathering, the family likes to find the oldest living family member’s age and the youngest family member’s age and calculate the difference between them.\n\nYou will be given an array of all the family members' ages, in any order.  The ages will be given in whole numbers, so a baby of 5 months, will have an ascribed ‘age’ of 0.  Return a new array (a tuple in Python) with [youngest age, oldest age, difference between the youngest and oldest age].\n-/", "vc-preamble": "def List.minimum (l : List Nat) (h : l ≠ []) : Nat :=\nmatch l with\n| [] => by contradiction\n| x::xs => xs.foldl min x\n\ndef List.maximum (l : List Nat) (h : l ≠ []) : Nat :=\nmatch l with\n| [] => by contradiction\n| x::xs => xs.foldl max x", "vc-helpers": "", "vc-definitions": "def differenceInAges (ages : List Nat) : Nat × Nat × Nat := sorry\n\ntheorem difference_in_ages_basic_properties\n  (ages : List Nat) (h : ages ≠ []) :\n  let result := differenceInAges ages\n  List.minimum ages h = result.1 ∧\n  List.maximum ages h = result.2.1 ∧\n  result.2.2 = result.2.1 - result.1 :=\nsorry", "vc-theorems": "theorem difference_in_ages_difference_nonnegative\n  (ages : List Nat) (h : ages ≠ []) :\n  let result := differenceInAges ages\n  result.2.2 ≥ 0 :=\nsorry\n\ntheorem difference_in_ages_youngest_leq_oldest\n  (ages : List Nat) (h : ages ≠ []) :\n  let result := differenceInAges ages\n  result.1 ≤ result.2.1 :=\nsorry\n\ntheorem difference_in_ages_same_values\n  (ages : List Nat) (h : ages ≠ []) (x : Nat) \n  (h2 : ∀ n, n ∈ ages → n = x) :\n  let result := differenceInAges ages\n  result.1 = result.2.1 ∧\n  result.2.2 = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_004078", "vc-description": "/-\nThere was a test in your class and you passed it. Congratulations!\nBut you're an ambitious person. You want to know if you're better than the average student in your class.\n\nYou receive an array with your peers' test scores. Now calculate the average and compare your score!\n\n~~~if-not:nasm,racket\nReturn `True` if you're better, else `False`!\n~~~\n\n~~~if:racket\nReturn #t if you're better, else #f.\n~~~\n\n~~~if:nasm\nReturn `1` if you're better, else `0`!\n~~~\n\n### Note:\n\nYour points are not included in the array of your class's points. For calculating the average point you may add your point to the given array!\n-/", "vc-preamble": "def sumList : List Int → Int \n  | [] => 0\n  | (x::xs) => x + sumList xs\n\ndef lengthList : List Int → Int\n  | [] => 0\n  | (_::xs) => 1 + lengthList xs", "vc-helpers": "", "vc-definitions": "def better_than_average (class_points: List Int) (your_points: Int) : Bool :=\n  sorry", "vc-theorems": "theorem better_than_average_spec {class_points: List Int} {your_points: Int}\n  (h: class_points ≠ []) :\n  better_than_average class_points your_points = \n    (your_points > (sumList class_points / lengthList class_points)) :=\n  sorry\n\ntheorem better_than_average_edge_cases1 :\n  better_than_average [0] 0 = false :=\n  sorry\n\ntheorem better_than_average_edge_cases2 :\n  better_than_average [1] 1 = false :=\n  sorry\n\ntheorem better_than_average_edge_cases3 :\n  better_than_average [0] 1 = true :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval better_than_average [2, 3] 5\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval better_than_average [100, 40, 34, 57, 29, 72, 57, 88] 75\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval better_than_average [12, 23, 34, 45, 56, 67, 78, 89, 90] 69"}
{"id": "fvapps_004145", "vc-description": "/-\nEvery Friday and Saturday night, farmer counts amount of sheep returned back to his farm (sheep returned on Friday stay and don't leave for a weekend).\n\nSheep return in groups each of the days -> you will be given two arrays with these numbers (one for Friday and one for Saturday night). Entries are always positive ints, higher than zero.\n\nFarmer knows the total amount of sheep, this is a third parameter. You need to return the amount of sheep lost (not returned to the farm) after final sheep counting on Saturday.\n\nExample 1: Input: {1, 2}, {3, 4}, 15 --> Output: 5\n\nExample 2: Input: {3, 1, 2}, {4, 5}, 21 --> Output: 6\n\nGood luck! :-)\n-/", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum_list xs", "vc-helpers": "", "vc-definitions": "def lost_sheep (friday : List Nat) (saturday : List Nat) (total : Nat) : Nat :=\nsorry", "vc-theorems": "theorem lost_sheep_reverse_invariant (friday : List Nat) (saturday : List Nat) (total : Nat) :\n  lost_sheep friday saturday total = lost_sheep friday.reverse saturday.reverse total :=\nsorry\n\ntheorem lost_sheep_empty_lists (total : Nat) :\n  lost_sheep [] [] total = total :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval lost_sheep [1, 2] [3, 4] 15\n\n/-\ninfo: 6\n-/\n#guard_msgs in\n#eval lost_sheep [3, 1, 2] [4, 5] 21\n\n/-\ninfo: 10\n-/\n#guard_msgs in\n#eval lost_sheep [5, 1, 4] [5, 4] 29"}
{"id": "fvapps_004148", "vc-description": "/-\nThe function is not returning the correct values. Can you figure out why?\n\n```python\nget_planet_name(3) # should return 'Earth'\n```\n-/", "vc-preamble": "def validPlanets : Int → Option String\n| 1 => some \"Mercury\"\n| 2 => some \"Venus\"\n| 3 => some \"Earth\"\n| 4 => some \"Mars\"\n| 5 => some \"Jupiter\"\n| 6 => some \"Saturn\"\n| 7 => some \"Uranus\"\n| 8 => some \"Neptune\"\n| _ => none", "vc-helpers": "", "vc-definitions": "def getPlanetName (id: Int) : Option String := sorry\n\ntheorem get_planet_name_matches_valid : ∀ (id : Int),\n  getPlanetName id = validPlanets id := by sorry", "vc-theorems": "theorem invalid_ids_return_none : ∀ (id : Int),\n  (id < 1 ∨ id > 8) → getPlanetName id = none := by sorry\n\ntheorem valid_ids_return_some : ∀ (id : Int),\n  (1 ≤ id ∧ id ≤ 8) → (∃ (name : String), getPlanetName id = some name) := by sorry\n\ntheorem valid_ids_match_planets : ∀ (id : Int),\n  (1 ≤ id ∧ id ≤ 8) → getPlanetName id = validPlanets id := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Venus'\n-/\n#guard_msgs in\n#eval get_planet_name 2\n\n/-\ninfo: 'Jupiter'\n-/\n#guard_msgs in\n#eval get_planet_name 5\n\n/-\ninfo: 'Earth'\n-/\n#guard_msgs in\n#eval get_planet_name 3"}
{"id": "fvapps_004168", "vc-description": "/-\nImagine you start on the 5th floor of a building, then travel down to the 2nd floor, then back up to the 8th floor. You have travelled a total of 3 + 6 = 9 floors of distance.\n\nGiven an array representing a series of floors you must reach by elevator, return an integer representing the total distance travelled for visiting each floor in the array in order. \n\n```\n// simple examples\nelevatorDistance([5,2,8]) = 9\nelevatorDistance([1,2,3]) = 2\nelevatorDistance([7,1,7,1]) = 18\n\n// if two consecutive floors are the same,\n//distance travelled between them is 0\nelevatorDistance([3,3]) = 0\n```\n\nArray will always contain at least 2 floors. Random tests will contain 2-20 elements in array, and floor values between 0 and 30.\n-/", "vc-preamble": "def abs (n : Int) : Nat := \n  if n ≥ 0 then n.toNat else (-n).toNat\n\ndef sum (l : List Nat) : Nat :=\n  l.foldl (·+·) 0", "vc-helpers": "", "vc-definitions": "def elevator_distance (floors : List Int) : Nat := sorry\n\ntheorem elevator_distance_non_negative (floors : List Int) \n  (h : floors.length ≥ 2) : \n  elevator_distance floors ≥ 0 := sorry", "vc-theorems": "theorem elevator_distance_reversal (floors : List Int)\n  (h : floors.length ≥ 2) :\n  elevator_distance floors = elevator_distance floors.reverse := sorry\n\ntheorem elevator_distance_same_floor (n : Int) :\n  elevator_distance [n, n] = 0 := sorry\n\ntheorem elevator_distance_all_zero (n : Nat) \n  (h : n ≥ 2) :\n  elevator_distance (List.replicate n 0) = 0 := sorry\n\ntheorem elevator_distance_up_down : \n  elevator_distance [1, -1] = 2 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 9\n-/\n#guard_msgs in\n#eval elevator_distance [5, 2, 8]\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval elevator_distance [1, 2, 3]\n\n/-\ninfo: 18\n-/\n#guard_msgs in\n#eval elevator_distance [7, 1, 7, 1]"}
{"id": "fvapps_004217", "vc-description": "/-\nThere are some stones on Bob's table in a row, and each of them can be red, green or blue, indicated by the characters `R`, `G`, and `B`.\n\nHelp Bob find the minimum number of stones he needs to remove from the table so that the stones in each pair of adjacent stones have different colours.\n\nExamples:\n\n```\n\"RGBRGBRGGB\"   => 1\n\"RGGRGBBRGRR\"  => 3\n\"RRRRGGGGBBBB\" => 9\n```\n-/", "vc-preamble": "def Stone := Char \n\ndef isRGBChar (c : Char) : Prop :=\n  c = 'R' ∨ c = 'G' ∨ c = 'B'", "vc-helpers": "", "vc-definitions": "def solution (stones : String) : Nat :=\n  sorry", "vc-theorems": "theorem solution_non_negative (stones : String) \n  (h : ∀ c ∈ stones.data, isRGBChar c) :\n  solution stones ≥ 0 := sorry\n\ntheorem solution_upper_bound (stones : String)\n  (h : ∀ c ∈ stones.data, isRGBChar c) :\n  solution stones ≤ stones.length - 1 := sorry\n\ntheorem solution_counts_adjacents (stones : String)\n  (h : ∀ c ∈ stones.data, isRGBChar c) :\n  let adjacentPairs := List.range (stones.length - 1)\n  let countMatches := (adjacentPairs.filter (fun i => stones.data[i]! = stones.data[i+1]!)).length\n  solution stones = countMatches := sorry\n\ntheorem solution_zero_no_adjacents (stones : String)\n  (h : ∀ c ∈ stones.data, isRGBChar c)\n  (h2 : solution stones = 0) :\n  ∀ i, i > 0 → i < stones.length →\n    stones.data[i]! ≠ stones.data[i-1]! := sorry\n\ntheorem solution_all_same (stones : String)\n  (h : ∀ c ∈ stones.data, isRGBChar c)  \n  (h2 : stones.length > 0)\n  (h3 : ∀ c ∈ stones.data, c = stones.data[0]!) :\n  solution stones = stones.length - 1 := sorry\n\ntheorem solution_alternating (stones : String)\n  (h : ∀ c ∈ stones.data, isRGBChar c)\n  (h2 : stones.length > 1)  \n  (h3 : ∀ i, i > 0 → i < stones.length →\n    stones.data[i]! ≠ stones.data[i-1]!) :\n  solution stones = 0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_004266", "vc-description": "/-\nYou get any card as an argument. Your task is to return a suit of this card.\n\nOur deck (is preloaded):\n```python\nDECK = ['2S','3S','4S','5S','6S','7S','8S','9S','10S','JS','QS','KS','AS',\n        '2D','3D','4D','5D','6D','7D','8D','9D','10D','JD','QD','KD','AD',\n        '2H','3H','4H','5H','6H','7H','8H','9H','10H','JH','QH','KH','AH',\n        '2C','3C','4C','5C','6C','7C','8C','9C','10C','JC','QC','KC','AC']\n```\n\n```python\n('3C') -> return 'clubs'\n('3D') -> return 'diamonds'\n('3H') -> return 'hearts'\n('3S') -> return 'spades'\n```\n-/", "vc-preamble": "def valid_suits := [\"C\", \"S\", \"D\", \"H\"]\ndef valid_ranks := [\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"]", "vc-helpers": "", "vc-definitions": "def suit_map := [(\"C\", \"clubs\"), (\"S\", \"spades\"), (\"D\", \"diamonds\"), (\"H\", \"hearts\")]\n\ndef define_suit (card : String) : String :=\n  sorry", "vc-theorems": "theorem define_suit_valid (rank : String) (suit : String)\n  (h1 : rank ∈ valid_ranks)\n  (h2 : suit ∈ valid_suits) :\n  ∃ result, result ∈ [\"clubs\", \"spades\", \"diamonds\", \"hearts\"] ∧\n  define_suit (rank ++ suit) = result := \n  sorry\n\ntheorem define_suit_invalid (card : String) \n  (h : ∃ rank, rank ∈ valid_ranks ∧ card = rank ++ \"X\") :\n  ¬∃ result, define_suit card = result :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'clubs'\n-/\n#guard_msgs in\n#eval define_suit \"3C\"\n\n/-\ninfo: 'spades'\n-/\n#guard_msgs in\n#eval define_suit \"QS\"\n\n/-\ninfo: 'hearts'\n-/\n#guard_msgs in\n#eval define_suit \"JH\""}
{"id": "fvapps_004280", "vc-description": "/-\nYour task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.\n-/", "vc-preamble": "def abs (n : Int) : Int := \n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def diff (arr : List String) : Option String := sorry\n\ntheorem diff_empty_list :\n  diff [] = none := sorry", "vc-theorems": "theorem diff_equal_pairs (n : Nat) :\n  diff [s!\"{n}-{n}\"] = none := sorry\n\ntheorem diff_result_in_input (arr : List String) :\n  match diff arr with\n  | none => True  \n  | some result => result ∈ arr\n  := sorry\n\ntheorem diff_has_largest_diff (arr : List String) (result : String) :\n  diff arr = some result →\n  let result_nums := (result.splitOn \"-\").map String.toNat!\n  let result_diff := abs (result_nums[0]! - result_nums[1]!)\n  ∀ pair ∈ arr,\n    let nums := (pair.splitOn \"-\").map String.toNat!\n    let diff_val := abs (nums[0]! - nums[1]!)\n    diff_val ≤ result_diff\n  := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: '000-18888'\n-/\n#guard_msgs in\n#eval diff [\"43-45\", \"1021-55\", \"000-18888\", \"92-34\", \"76-32\", \"99-1\", \"1020-54\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval diff [\"33-33\", \"77-77\"]\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval diff []"}
{"id": "fvapps_004287", "vc-description": "/-\n**DESCRIPTION:**\n\n  Your strict math teacher is teaching you about right triangles, and the Pythagorean Theorem --> a^2 + b^2 = c^2 whereas a and b are the legs of the right triangle and c is the hypotenuse of the right triangle. On the test however, the question asks: What are the possible integer lengths for the other side of the triangle, but since you never learned anything about that in class, you realize she meant What are the possible integer lengths for the other side of the right triangle. Because you want to address the fact that she asked the wrong question and the fact that you're smart at math, you've decided to answer all the possible values for the third side EXCLUDING the possibilities for a right triangle in increasing order.\n\n**EXAMPLES:**\n\n```\nside_len(1, 1) --> [1]\nside_len(3, 4) --> [2, 3, 4, 6]\nside_len(4, 6) --> [3, 4, 5, 6, 7, 8, 9]\n```\n**RETURN:**\n\n  Return your answer as a list of all the possible third side lengths of the triangle without the right triangles in increasing order.\n\nBy the way, after finishing this kata, please try some of my other katas: [Here](https://www.codewars.com/collections/tonylicodings-authored-katas)\n\nNOTE:\n\n  When given side_len(x, y), y will always be greater than or equal to x. Also, if a right triangle's legs are passed in, exclude the hypotenuse. If a right triangle's leg and hypotenuse are passed in, exclude the other leg.\n-/", "vc-preamble": "def abs (n : Int) : Nat :=\n  if n ≥ 0 then n.toNat else (-n).toNat", "vc-helpers": "", "vc-definitions": "def side_len (x y : Nat) : List Nat := sorry\n\ndef isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → \n    match l.get? i, l.get? j with\n    | some vi, some vj => vi ≤ vj\n    | _, _ => True", "vc-theorems": "theorem triangle_inequality {x y : Nat} (h1 : x > 0) (h2 : y > 0) (z : Nat) \n  (h3 : z ∈ side_len x y) :\n  z < x + y ∧ \n  x < y + z ∧ \n  y < x + z ∧ \n  z > (if x ≥ y then x - y else y - x) := sorry\n\ntheorem no_pythagorean_triples {x y : Nat} (h1 : x > 0) (h2 : y > 0) (z : Nat) \n  (h3 : z ∈ side_len x y) :\n  z * z ≠ (if x * x ≥ y * y then x * x - y * y else y * y - x * x) ∧\n  z * z ≠ x * x + y * y := sorry\n\ntheorem symmetric {x y : Nat} (h1 : x > 0) (h2 : y > 0) :\n  side_len x y = side_len y x := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval side_len 1 1\n\n/-\ninfo: [2, 3, 4, 6]\n-/\n#guard_msgs in\n#eval side_len 3 4\n\n/-\ninfo: [3, 4, 5, 6, 7, 8, 9]\n-/\n#guard_msgs in\n#eval side_len 4 6"}
{"id": "fvapps_004293", "vc-description": "/-\n## Your task\n\nYou are given a dictionary/hash/object containing some languages and your test results in the given languages. Return the list of languages where your test score is at least `60`, in descending order of the results.\n\nNote: the scores will always be unique (so no duplicate values)\n\n## Examples\n\n```python\n{\"Java\": 10, \"Ruby\": 80, \"Python\": 65}    -->  [\"Ruby\", \"Python\"]\n{\"Hindi\": 60, \"Dutch\" : 93, \"Greek\": 71}  -->  [\"Dutch\", \"Greek\", \"Hindi\"]\n{\"C++\": 50, \"ASM\": 10, \"Haskell\": 20}     -->  []\n```\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n### _Translations are welcome!_\n-/", "vc-preamble": "def List.find (p : α → Bool) : List α → Option α\n  | [] => none\n  | a :: as => if p a then some a else find p as\n\nstructure TestMap (α β : Type) where\n  toList : List (α × β)", "vc-helpers": "", "vc-definitions": "def my_languages (results : TestMap String Nat) : List String := sorry\n\ntheorem my_languages_return_type (results : TestMap String Nat) :\n  my_languages results |>.all (λ x => String.isPrefixOf x x) := sorry", "vc-theorems": "theorem my_languages_scores_above_threshold (results : TestMap String Nat) \n    (lang : String) (h : lang ∈ my_languages results) :\n  ∀ pair ∈ results.toList, pair.1 = lang → pair.2 ≥ 60 := sorry\n\ntheorem my_languages_all_qualifying_included (results : TestMap String Nat) :\n  (my_languages results).length = \n    (results.toList.filter (λ p => p.2 ≥ 60)).length := sorry\n\ntheorem my_languages_sorted (results : TestMap String Nat) \n    (i : Nat) (h : i + 1 < (my_languages results).length) :\n  let output := my_languages results\n  ∀ pair1, ∀ pair2,\n    pair1 ∈ results.toList →\n    pair2 ∈ results.toList →\n    pair1.1 = output[i]! →\n    pair2.1 = output[i+1]! →\n    pair1.2 ≥ pair2.2 := sorry\n\ntheorem my_languages_empty_below_threshold (results : TestMap String Nat)\n    (h : ∀ p ∈ results.toList, p.2 < 60) :\n  my_languages results = [] := sorry\n\ntheorem my_languages_all_included_above_threshold (results : TestMap String Nat)\n    (h : ∀ p ∈ results.toList, p.2 ≥ 60) :\n  (my_languages results).length = results.toList.length := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['Ruby', 'Python']\n-/\n#guard_msgs in\n#eval my_languages {\"Java\": 10, \"Ruby\": 80, \"Python\": 65}\n\n/-\ninfo: ['Dutch', 'Greek', 'Hindi']\n-/\n#guard_msgs in\n#eval my_languages {\"Hindi\": 60, \"Greek\": 71, \"Dutch\": 93}\n\n/-\ninfo: []\n-/\n#guard_msgs in\n#eval my_languages {\"C++\": 50, \"ASM\": 10, \"Haskell\": 20}"}
{"id": "fvapps_004304", "vc-description": "/-\n# Task\n You are given an array of integers `a` and a non-negative number of operations `k`, applied to the array. Each operation consists of two parts:\n```\nfind the maximum element value of the array;\nreplace each element a[i] with (maximum element value - a[i]).```\nHow will the array look like after `k` such operations?\n\n# Example\n\n For `a = [-4, 0, -1, 0]` and `k = 2`, the output should be `[0, 4, 3, 4]`.\n ```\n initial array: [-4, 0, -1, 0]\n 1st operation: \n find the maximum value --> 0\n replace each element:  --> [(0 - -4), (0 - 0), (0 - -1), (0 - 0)]\n                        --> [4, 0, 1, 0]\n 2nd operation: \n find the maximum value --> 4\n replace each element:  --> [(4 - 4), (4 - 0), (4 - 1), (4 - 0)]\n                        --> [0, 4, 3, 4]\n\n ```\n For `a = [0, -1, 0, 0, -1, -1, -1, -1, 1, -1]` and `k = 1`, \n\n the output should be `[1, 2, 1, 1, 2, 2, 2, 2, 0, 2]`.\n ```\n initial array: [0, -1, 0, 0, -1, -1, -1, -1, 1, -1]\n 1st operation: \n find the maximum value --> 1\n replace each element:  -->\n [(1-0),(1- -1),(1-0),(1-0),(1- -1),(1- -1),(1- -1),(1- -1),(1-1),(1- -1)]\n--> [1, 2, 1, 1, 2, 2, 2, 2, 0, 2]\n ```\n\n# Input/Output\n\n - `[input]` integer array a\n\n    The initial array.\n\n    Constraints: \n\n    `1 <= a.length <= 100`\n\n    `-100 <= a[i] <= 100`\n\n - `[input]` integer `k`\n\n    non-negative number of operations.\n\n    Constraints: `0 <= k <= 100000`\n\n - [output] an integer array\n\n    The array after `k` operations.\n-/", "vc-preamble": "def List.maximum' (l : List Int) (h : l ≠ []) : Int :=\n  match l with\n  | [] => by contradiction\n  | x :: xs => xs.foldl max x", "vc-helpers": "", "vc-definitions": "def array_operations (arr : List Int) (k : Nat) : List Int := sorry\n\ntheorem array_operations_length_preserved (arr : List Int) (k : Nat) (h : arr ≠ []) :\n  (array_operations arr k).length = arr.length := sorry", "vc-theorems": "theorem array_operations_zero_identity (arr : List Int) (h : arr ≠ []) :\n  array_operations arr 0 = arr := sorry\n\ntheorem array_operations_input_preservation (arr : List Int) (k : Nat) :\n  let original := arr\n  array_operations arr k = array_operations original k := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"}
{"id": "fvapps_004316", "vc-description": "/-\nSimple, given a string of words, return the length of the shortest word(s).\n\nString will never be empty and you do not need to account for different data types.\n-/", "vc-preamble": "def min_list : List Nat → Nat \n  | [] => 0\n  | (x::xs) => min x (min_list xs)", "vc-helpers": "", "vc-definitions": "def find_short (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem find_short_is_shortest (s : String) :\n  find_short s = min_list ((s.split fun c => c = ' ').map String.length)\n  := by sorry\n\ntheorem find_short_positive (s : String) (h : s ≠ \"\") :\n  find_short s > 0 := by sorry\n\ntheorem find_short_not_longer_than_any_word (s : String) (w : String) \n  (h : w ∈ s.split fun c => c = ' ') :\n  find_short s ≤ w.length := by sorry\n\ntheorem find_short_empty (s : String) :\n  s = \"\" → find_short s = 0 := by sorry  \n\ntheorem find_short_single_word (s : String) (h : ¬ s.contains ' ') : \n  find_short s = s.length := by sorry\n\ntheorem find_short_two_words (s₁ s₂ : String) :\n  find_short (s₁ ++ \" \" ++ s₂) = min s₁.length s₂.length := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 3\n-/\n#guard_msgs in\n#eval find_short \"bitcoin take over the world maybe who knows perhaps\"\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval find_short \"i want to travel the world writing code one day\"\n\n/-\ninfo: 2\n-/\n#guard_msgs in\n#eval find_short \"Lets all go on holiday somewhere very cold\""}
{"id": "fvapps_004319", "vc-description": "/-\n# Scenario\n\n**_Several people_** are standing in *a row divided into two teams*.  \nThe **_first person_** goes into **_team 1_**, **_the second_** goes into **_team 2_**, **_the third_** goes into **_team 1_**, and so on.\n___\n# Task\n\n**_Given_** *an array of positive integers (the weights of the people)*, **_return_** *a new array/tuple of two integers*, **_where_** **_the first_** one is the **_total weight of team 1_**, and **_the second_** one is the **_total weight of team 2_**.\n___\n# Notes \n\n* **_Array size_** is *at least 1*.\n* **_All numbers_** will be **positive**.\n___\n# Input >> Output Examples \n\n```\nrowWeights([13, 27, 49])  ==>  return (62, 27)\n```\n\n## **_Explanation_**:\n\n**_The first element_** `62` is *the total weight of team 1*, and **_the second element_** `27` is *the total weight of team 2*.\n___\n```\nrowWeights([50, 60, 70, 80])  ==>  return (120, 140)\n```\n## **_Explanation_**:\n\n**_The first element_** `120` is *the total weight of team 1*, and **_the second element_** `140` is *the total weight of team 2*.\n___\n```\nrowWeights([80])  ==>  return (80, 0)\n```\n## **_Explanation_**:\n\n**_The first element_** `80` is *the total weight of team 1*, and **_the second element_** `0` is *the total weight of team 2*.\n___\n___\n___\n\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "def sum_list : List Nat → Nat\n  | [] => 0\n  | (x::xs) => x + sum_list xs\n\ndef select_indices : List Nat → (Nat → Bool) → List Nat\n  | [], _ => []\n  | (x::xs), f => if f 0 then x::(select_indices xs (fun n => f (n+1)))\n                  else select_indices xs (fun n => f (n+1))", "vc-helpers": "", "vc-definitions": "def row_weights (numbers : List Nat) : Nat × Nat := sorry\n\ntheorem row_weights_single_element (n : Nat) :\n  let (team1, team2) := row_weights [n]\n  team2 = 0 ∧ team1 = n := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"}
{"id": "fvapps_004345", "vc-description": "/-\n# Background\n\nMy TV remote control has arrow buttons and an `OK` button.\n\nI can use these to move a \"cursor\" on a logical screen keyboard to type \"words\"...\n\nThe screen \"keyboard\" layout looks like this\n\n  #tvkb {\n    width : 300px;\n    border: 5px solid gray; border-collapse: collapse;\n  }\n  #tvkb td {\n    color : orange;\n    background-color : black;\n    text-align : right;\n    border: 3px solid gray; border-collapse: collapse;\n  }\n\nabcde123\nfghij456\nklmno789\npqrst.@0\nuvwxyz_/\n\n# Kata task\n\nHow many button presses on my remote are required to type a given `word`?\n\n## Notes\n\n* The cursor always starts on the letter `a` (top left)\n* Remember to also press `OK` to \"accept\" each character.\n* Take a direct route from one character to the next\n* The cursor does not wrap (e.g. you cannot leave one edge and reappear on the opposite edge)\n* A \"word\" (for the purpose of this Kata) is any sequence of characters available on my virtual \"keyboard\" \n\n# Example\n\nword = `codewars`\n\n* c => `a`-`b`-`c`-OK = 3\n* o => `c`-`d`-`e`-`j`-`o`-OK = 5\n* d => `o`-`j`-`e`-`d`-OK = 4\n* e => `d`-`e`-OK = 2\n* w => `e`-`j`-`o`-`t`-`y`-`x`-`w`-OK = 7\n* a => `w`-`r`-`m`-`h`-`c`-`b`-`a`-OK = 7\n* r => `a`-`f`-`k`-`p`-`q`-`r`-OK = 6\n* s => `r`-`s`-OK = 2\n\nAnswer = 3 + 5 + 4 + 2 + 7 + 7 + 6 + 2 = 36\n\n*Good Luck!\nDM.*\n\nSeries\n* TV Remote\n* TV Remote (shift and space)\n* TV Remote (wrap)\n* TV Remote (symbols)\n-/", "vc-preamble": "def KEYBOARD := \"abcde123fghij456klmno789pqrst.@0uvwxyz_/\"\n\ndef manhattan (p1 p2 : Nat × Nat) : Nat := \n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  Nat.sub (if x2 ≥ x1 then x2 else x1) (if x2 ≥ x1 then x1 else x2) + \n  Nat.sub (if y2 ≥ y1 then y2 else y1) (if y2 ≥ y1 then y1 else y2)", "vc-helpers": "", "vc-definitions": "def tv_remote (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem tv_remote_min_length (s : String) :\n  tv_remote s ≥ s.length := by\n  sorry\n\ntheorem tv_remote_nonnegative (s : String) :\n  tv_remote s ≥ 0 := by\n  sorry\n\ntheorem tv_remote_empty :\n  tv_remote \"\" = 0 := by\n  sorry\n\ntheorem tv_remote_repeat_chars (c : Char) (n : Nat) :\n  tv_remote (String.mk (List.replicate n c)) = \n    n + manhattan (0, 0) (0, 0) := by\n  sorry\n\ntheorem tv_remote_substring_cost (s : String) (h : s.length ≥ 2) :\n  tv_remote (String.dropRight s 1) < tv_remote s := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 36\n-/\n#guard_msgs in\n#eval tv_remote \"codewars\"\n\n/-\ninfo: 16\n-/\n#guard_msgs in\n#eval tv_remote \"does\"\n\n/-\ninfo: 35\n-/\n#guard_msgs in\n#eval tv_remote \"mississippi\""}
{"id": "fvapps_004350", "vc-description": "/-\nThe Spelling Bee bees are back...\n\n# How many bees are in the beehive?\n\n* bees can be facing UP, DOWN, LEFT, RIGHT, and now also _diagonally_ up/down/left/right\n* bees can share parts of other bees\n\n## Examples\n\nEx1\n```\nbee.bee     \n.e..e..\n.b..eeb\n```\n_Answer: 5_\n\nEx2\n```\nbeee..     \neeb.e.\nebee.b\n```\n_Answer: 7_\n-/", "vc-preamble": "def Grid := List String\n\ndef GridList := List (List Char)", "vc-helpers": "", "vc-definitions": "def how_many_bees (grid : Grid) : Nat := sorry\ndef how_many_bees_list (grid : GridList) : Nat := sorry", "vc-theorems": "theorem how_many_bees_nonnegative (grid : Grid) :\n  how_many_bees grid ≥ 0 := sorry\n\ntheorem grid_list_equiv (grid : Grid) :\n  how_many_bees grid = how_many_bees_list (grid.map (·.data)) := sorry\n\ntheorem empty_grid :\n  how_many_bees [] = 0 := sorry\n\ntheorem bees_upper_bound {grid : Grid} (h : grid ≠ []) :\n  how_many_bees grid ≤ grid.length * grid.head!.length * 2 := sorry\n\ntheorem reverse_grid_equiv (grid : Grid) :\n  let reversed := grid.map (fun s => ⟨s.data.reverse⟩)\n  how_many_bees grid = how_many_bees reversed := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 5\n-/\n#guard_msgs in\n#eval how_many_bees [\"bee.bee\", \".e..e..\", \".b..eeb\"]\n\n/-\ninfo: 7\n-/\n#guard_msgs in\n#eval how_many_bees [\"beee..\", \"eeb.e.\", \"ebee.b\"]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval how_many_bees []"}
{"id": "fvapps_004353", "vc-description": "/-\n# Task\n In the Land Of Chess, bishops don't really like each other. In fact, when two bishops happen to stand on the same diagonal, they immediately rush towards the opposite ends of that same diagonal.\n\n Given the initial positions (in chess notation) of two bishops, `bishop1` and `bishop2`, calculate their future positions. Keep in mind that bishops won't move unless they see each other along the same diagonal.\n\n# Example\n\n For `bishop1 = \"d7\" and bishop2 = \"f5\"`, the output should be `[\"c8\", \"h3\"]`.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/bishopDiagonal/img/ex_1.jpg?_tm=1473766087137)\n\n For `bishop1 = \"d8\" and bishop2 = \"b5\"`, the output should be `[\"b5\", \"d8\"]`.\n\n The bishops don't belong to the same diagonal, so they don't move.\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/bishopDiagonal/img/ex_2.jpg?_tm=1473766087425)\n\n# Input/Output\n\n - `[input]` string `bishop1`\n\n    Coordinates of the first bishop in chess notation.\n\n - `[input]` string `bishop2`\n\n    Coordinates of the second bishop in the same notation.\n\n - `[output]` a string array\n\n    Coordinates of the bishops in lexicographical order after they check the diagonals they stand on.\n-/", "vc-preamble": "def chars := ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\ndef digits := ['1', '2', '3', '4', '5', '6', '7', '8']\n\nstructure Square where\n  file : Char\n  rank : Char\n  h_file : file ∈ chars\n  h_rank : rank ∈ digits\n\ninstance : Ord Square where\n  compare a b := \n    match compare a.file b.file with\n    | .eq => compare a.rank b.rank\n    | c => c\n\ninstance : LE Square where\n  le a b := compare a b ≠ .gt", "vc-helpers": "", "vc-definitions": "def bishop_diagonal (sq1 sq2 : Square) : List Square := sorry\n\ntheorem bishop_diagonal_output_format {sq1 sq2 : Square} :\n  let result := bishop_diagonal sq1 sq2\n  List.length result = 2 ∧ \n  (∀ sq ∈ result, sq.file ∈ chars ∧ sq.rank ∈ digits) ∧\n  List.Pairwise (. ≤ .) result := sorry", "vc-theorems": "theorem bishop_diagonal_same_square {sq : Square} :\n  bishop_diagonal sq sq = [sq, sq] := sorry \n\ntheorem bishop_diagonal_symmetry {sq1 sq2 : Square} :\n  bishop_diagonal sq1 sq2 = bishop_diagonal sq2 sq1 := sorry\n\ntheorem bishop_diagonal_bounds {sq1 sq2 : Square} :\n  let result := bishop_diagonal sq1 sq2\n  ∀ sq ∈ result, \n    0 ≤ (Char.toNat sq.file - Char.toNat 'a') ∧ \n    (Char.toNat sq.file - Char.toNat 'a') ≤ 7 ∧\n    0 ≤ (Char.toNat sq.rank - Char.toNat '1') ∧\n    (Char.toNat sq.rank - Char.toNat '1') ≤ 7 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: ['c8', 'h3']\n-/\n#guard_msgs in\n#eval bishop_diagonal \"d7\" \"f5\"\n\n/-\ninfo: ['b5', 'd8']\n-/\n#guard_msgs in\n#eval bishop_diagonal \"d8\" \"b5\"\n\n/-\ninfo: ['a1', 'h8']\n-/\n#guard_msgs in\n#eval bishop_diagonal \"a1\" \"h8\""}
{"id": "fvapps_004382", "vc-description": "/-\nSimply find the closest value to zero from the list. Notice that there are negatives in the list.\n\nList is always not empty and contains only integers. Return ```None``` if it is not possible to define only one of such values. And of course, we are expecting 0 as closest value to zero.\n\nExamples:\n```code\n[2, 4, -1, -3]  => -1\n[5, 2, -2]      => None\n[5, 2, 2]       => 2\n[13, 0, -6]     => 0\n```\n-/", "vc-preamble": "def abs (x : Int) : Int := \n  if x < 0 then -x else x\n\ndef minimum (lst : List Int) : Option Int := \n  lst.foldl (fun min x => match min with\n    | none => some x\n    | some m => some (if x < m then x else m)) none", "vc-helpers": "", "vc-definitions": "def closest (lst : List Int) : Option Int := sorry\n\ntheorem closest_returns_none_or_element (lst : List Int) (h : lst ≠ []) :\n  match closest lst with\n  | none => True\n  | some x => x ∈ lst\n  := sorry", "vc-theorems": "theorem closest_zero (lst : List Int) (h : lst ≠ []) :\n  0 ∈ lst → closest lst = some 0 := sorry\n\ntheorem closest_none_when_equal_absolutes (lst : List Int) (h : lst ≠ []) :\n  match closest lst with\n  | none => ∃ x ∈ lst, -x ∈ lst\n  | some x => (match minimum (lst.map abs) with\n              | none => False\n              | some m => abs x = m) ∧ -x ∉ lst\n  := sorry\n\ntheorem closest_is_minimum_absolute (lst : List Int) (h : lst ≠ []) :\n  match closest lst with\n  | none => True\n  | some x => match minimum (lst.map abs) with\n              | none => False\n              | some m => abs x = m\n  := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: -1\n-/\n#guard_msgs in\n#eval closest [2, 4, -1, -3]\n\n/-\ninfo: None\n-/\n#guard_msgs in\n#eval closest [5, 2, -2]\n\n/-\ninfo: 0\n-/\n#guard_msgs in\n#eval closest [13, 0, -6]"}
{"id": "fvapps_004414", "vc-description": "/-\nI'm new to coding and now I want to get the sum of two arrays...actually the sum of all their elements. I'll appreciate for your help.\n\nP.S. Each array includes only integer numbers. Output is a number too.\n-/", "vc-preamble": "def sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def array_plus_array (arr1 arr2 : List Int) : Int := sorry\n\ntheorem array_plus_array_associative (a b c : List Int) :\n  array_plus_array (a ++ b) c = array_plus_array a (b ++ c) := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible\n\n/-\ninfo: 21\n-/\n#guard_msgs in\n#eval array_plus_array [1, 2, 3] [4, 5, 6]\n\n/-\ninfo: -21\n-/\n#guard_msgs in\n#eval array_plus_array [-1, -2, -3] [-4, -5, -6]\n\n/-\ninfo: 2100\n-/\n#guard_msgs in\n#eval array_plus_array [100, 200, 300] [400, 500, 600]"}
{"id": "fvapps_004431", "vc-description": "/-\nA number is self-descriptive when the n'th digit describes the amount n appears in the number.\n\nE.g. 21200:\n\nThere are two 0's in the number, so the first digit is 2.\n\nThere is one 1 in the number, so the second digit is 1.\n\nThere are two 2's in the number, so the third digit is 2.\n\nThere are no 3's in the number, so the fourth digit is 0.\n\nThere are no 4's in the number, so the fifth digit is 0\n\nNumbers can be of any length up to 9 digits and are only full integers. For a given number derive a function ```selfDescriptive(num)``` that returns; ```true``` if the number is self-descriptive or ```false``` if the number is not.\n-/", "vc-preamble": "def natToDigits (n : Nat) : List Nat :=\n  if n < 10 then\n    [n]\n  else\n    natToDigits (n / 10) ++ [n % 10]\n\ndef listMax (xs : List Nat) : Nat :=\n  xs.foldl Nat.max 0", "vc-helpers": "", "vc-definitions": "def self_descriptive (n : Nat) : Bool := sorry\n\ntheorem self_descriptive_correct_counts\n    {n : Nat}\n    (h : self_descriptive n = true) :\n    ∀ i : Nat,\n    i < (natToDigits n).length →\n    (natToDigits n).count i = (natToDigits n).get! i := sorry", "vc-theorems": "theorem self_descriptive_valid_indices\n    {n : Nat}\n    (h : self_descriptive n = true) :\n    ∀ i : Nat,\n    i < (natToDigits n).length →\n    i ≤ listMax (natToDigits n) := sorry\n\ntheorem self_descriptive_single_digit\n    {n : Nat}\n    (h : n < 10) :\n    self_descriptive n = false := sorry\n\ntheorem self_descriptive_first_digit\n    {n : Nat}\n    (h1 : (natToDigits n).get! 0 ≠ 0)\n    (h2 : (natToDigits n).get! 0 > (natToDigits n).length - 1) :\n    self_descriptive n = false := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval self_descriptive 21200\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval self_descriptive 3211000\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval self_descriptive 21230"}
{"id": "fvapps_004516", "vc-description": "/-\nGiven a list of prime factors, ```primesL```, and an integer, ```limit```, try to generate in order, all the numbers less than the value of ```limit```, that have **all and only** the prime factors of ```primesL```\n\n## Example\n```python\nprimesL = [2, 5, 7]\nlimit = 500\nList of Numbers Under 500          Prime Factorization\n___________________________________________________________\n           70                         [2, 5, 7]\n          140                         [2, 2, 5, 7]\n          280                         [2, 2, 2, 5, 7]\n          350                         [2, 5, 5, 7]\n          490                         [2, 5, 7, 7]\n```\n\nThere are ```5``` of these numbers under ```500``` and the largest one is ```490```.\n\n## Task\n\nFor this kata you have to create the function ```count_find_num()```, that accepts two arguments: ```primesL``` and ```limit```, and returns the amount of numbers that fulfill the requirements, and the largest number under `limit`.\n\nThe example given above will be:\n```python\nprimesL = [2, 5, 7]\nlimit = 500\ncount_find_num(primesL, val) == [5, 490]\n```\n\nIf no numbers can be generated under `limit` then return an empty list:\n```python\nprimesL = [2, 3, 47]\nlimit = 200\nfind_nums(primesL, limit) == []\n```\n\nThe result should consider the limit as inclusive:\n```python\nprimesL = [2, 3, 47]\nlimit = 282\nfind_nums(primesL, limit) == [1, 282]\n```\n\nFeatures of the random tests:\n```\nnumber of tests = 200\n2 <= length_primesL <= 6 // length of the given prime factors array\n5000 <= limit <= 1e17\n2 <= prime <= 499  // for every prime in primesL\n```\n\nEnjoy!\n-/", "vc-preamble": "def List.prod : List Nat → Nat \n  | [] => 1\n  | x :: xs => x * List.prod xs", "vc-helpers": "", "vc-definitions": "def count_find_num (primes: List Nat) (limit: Nat) : Option (Nat × Nat) := sorry\n\ntheorem count_find_num_basic_props {primes: List Nat} {limit: Nat} :\n  match count_find_num primes limit with\n  | none => ∀ p ∈ primes, p ≥ 2 → (List.prod primes > limit) \n  | some (count, max_val) => \n      (∀ p ∈ primes, p ≥ 2) →\n      List.prod primes ≤ limit ∧ \n      max_val ≤ limit ∧\n      count ≥ 1 ∧\n      max_val ≥ List.prod primes\n  := sorry", "vc-theorems": "theorem count_find_num_divisible {primes: List Nat} {limit: Nat} :\n  match count_find_num primes limit with\n  | none => True\n  | some (count, max_val) =>\n      ∀ p ∈ primes, max_val % p = 0\n  := sorry\n\ntheorem count_find_num_edge_cases_1 :\n  count_find_num [2] 1 = none := sorry\n\ntheorem count_find_num_edge_cases_2 :\n  count_find_num [2] 2 = some (1, 2) := sorry\n\ntheorem count_find_num_edge_cases_3 :\n  count_find_num [2, 3] 5 = none := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"}
{"id": "fvapps_004544", "vc-description": "/-\nThis kata provides you with a list of parent-child pairs `family_list`, and from this family description you'll need to find the relationship between two members(what is the relation of latter with former) which is given as `target_pair`.\n\nFor example, the family list may be given as:\n\n`[('Enid', 'Susan'), ('Susan', 'Deborah'), ('Enid', 'Dianne')]`\n\nThis describes the family:\n\n          Enid\n            |\n       |---------|\n     Susan     Dianne\n       |\n    Deborah\n\nThe relationship pair `('Deborah', 'Enid')` should return 'Grandmother' as Enid is Deborah's Grandmother.\n\nThis family tree can cover up to 3 generations, with varying numbers of children for each parent. We only focus on the females in the family, and so children will have only one parent.\n\nThe possible responses are Mother, Daughter, Grandmother, Granddaughter, Sister, Cousin, Aunt, Niece (each matching their 'real life' equivalents). There will always be a valid answer.\n\nEnjoy, and be nice to your Mother!\n-/", "vc-preamble": "def FamilyRelation := String\n\ndef FamilyList := List (String × String)", "vc-helpers": "", "vc-definitions": "def relations (family : FamilyList) (pair : String × String) : Option FamilyRelation := sorry\n\ntheorem relation_returns_valid (family : FamilyList) (pair : String × String) :\n  let result := relations family pair\n  match result with\n  | some rel => rel = \"Mother\" ∨ rel = \"Grandmother\" ∨ rel = \"Daughter\" ∨ \n                rel = \"Granddaughter\" ∨ rel = \"Sister\" ∨ rel = \"Cousin\" ∨ \n                rel = \"Aunt\" ∨ rel = \"Niece\"\n  | none => True\n  := sorry", "vc-theorems": "theorem grandmother_granddaughter_symmetry (family : FamilyList) (a b : String) :\n  relations family (a, b) = some \"Grandmother\" → \n  relations family (b, a) = some \"Granddaughter\" := sorry\n\ntheorem sister_symmetry (family : FamilyList) (a b : String) :\n  relations family (a, b) = some \"Sister\" →\n  relations family (b, a) = some \"Sister\" := sorry\n\ntheorem aunt_niece_symmetry (family : FamilyList) (a b : String) :\n  relations family (a, b) = some \"Aunt\" →\n  relations family (b, a) = some \"Niece\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'Grandmother'\n-/\n#guard_msgs in\n#eval relations [(\"Enid\", \"Susan\"), (\"Susan\", \"Deborah\"), (\"Enid\", \"Dianne\")] (\"Deborah\", \"Enid\")\n\n/-\ninfo: 'Sister'\n-/\n#guard_msgs in\n#eval relations [(\"Sarah\", \"Emily\"), (\"Sarah\", \"Kate\")] (\"Emily\", \"Kate\")\n\n/-\ninfo: 'Aunt'\n-/\n#guard_msgs in\n#eval relations [(\"Mary\", \"Sarah\"), (\"Sarah\", \"Emily\"), (\"Mary\", \"Jane\")] (\"Emily\", \"Jane\")"}
{"id": "fvapps_004570", "vc-description": "/-\nTired of those repetitive javascript challenges? Here's a unique hackish one that should keep you busy for a while ;)\n\nThere's a mystery function which is already available for you to use. It's a simple function called `mystery`. It accepts a string as a parameter and outputs a string. The exercise depends on guessing what this function actually does.\n\nYou can call the mystery function like this:\n\n```python\nmy_output = mystery(\"my_input\")\n```\n\nUsing your own test cases, try to call the mystery function with different input strings and try to analyze its output in order to guess what is does. You are free to call the mystery function in your own test cases however you want.\n\nWhen you think you've understood how my mystery function works, prove it by reimplementing its logic in a function that you should call 'solved(x)'. To validate your code, your function 'solved' should return the same output as my function 'mystery' given the same inputs.\n\nBeware! Passing your own test cases doesn't imply you'll pass mine.\n\nCheaters are welcome :)\n\nHave fun!\n\n---\n\nToo easy? Then this kata will totally blow your mind:\n\nhttp://www.codewars.com/kata/mystery-function-number-2\n-/", "vc-preamble": "def sorted (s : String) : Bool := \n  let chars := s.data\n  chars.zip (chars.drop 1) |>.all (fun (a, b) => a ≤ b)", "vc-helpers": "", "vc-definitions": "def solved (s : String) : String := sorry\n\ntheorem solved_returns_sorted (s : String) :\n  sorted (solved s) = true := sorry", "vc-theorems": "theorem solved_maintains_even_length (s : String) :\n  s.length % 2 = 0 → (solved s).length = s.length := sorry\n\ntheorem solved_reduces_odd_length (s : String) :\n  s.length % 2 = 1 → (solved s).length = s.length - 1 := sorry\n\ntheorem solved_maintains_character_set (s : String) :\n  ∀ c ∈ (solved s).data, c ∈ s.data := sorry\n\ntheorem solved_reduces_char_set_odd (s : String) :\n  s.length % 2 = 1 → (solved s).length = s.length - 1 ∧ \n  (∀ c ∈ (solved s).data, c ∈ s.data) := sorry\n\ntheorem solved_idempotent (s : String) :\n  solved (solved s) = solved s := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 'abcd'\n-/\n#guard_msgs in\n#eval solved \"abcd\"\n\n/-\ninfo: 'abde'\n-/\n#guard_msgs in\n#eval solved \"bacde\"\n\n/-\ninfo: 'abcd'\n-/\n#guard_msgs in\n#eval solved \"dcba\""}
{"id": "fvapps_004574", "vc-description": "/-\nComplete the function so that it returns the number of seconds that have elapsed between the start and end times given.  \n\n##### Tips:\n- The start/end times are given as Date (JS/CoffeeScript), DateTime (C#), Time (Nim), datetime(Python) and Time (Ruby) instances.  \n- The start time will always be before the end time.\n-/", "vc-preamble": "def DateTime := Nat -- simplified representation\ndef TimeDelta := Nat -- simplified representation\n\ninstance : Add DateTime where\n  add := Nat.add\n\ninstance : HAdd DateTime TimeDelta DateTime where\n  hAdd := Nat.add", "vc-helpers": "", "vc-definitions": "def elapsedSeconds (s e : DateTime) : Nat :=\n  sorry", "vc-theorems": "theorem elapsedSeconds_nonnegative\n  (s : DateTime)\n  (e : DateTime)\n  (d : TimeDelta)\n  (h : e = s + d) :\n  elapsedSeconds s e ≥ 0 :=\n  sorry\n\ntheorem elapsedSeconds_matches_delta\n  (s : DateTime)\n  (e : DateTime) \n  (d : TimeDelta)\n  (h : e = s + d) :\n  elapsedSeconds s e = d :=\n  sorry\n\ntheorem elapsedSeconds_identity\n  (dt : DateTime) :\n  elapsedSeconds dt dt = 0 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: 3600\n-/\n#guard_msgs in\n#eval elapsed_seconds datetime(2020, 1, 1, 0, 0, 0) datetime(2020, 1, 1, 1, 0, 0)\n\n/-\ninfo: 60\n-/\n#guard_msgs in\n#eval elapsed_seconds datetime(2020, 1, 1, 0, 0, 0) datetime(2020, 1, 1, 0, 1, 0)\n\n/-\ninfo: 1\n-/\n#guard_msgs in\n#eval elapsed_seconds datetime(2020, 1, 1, 0, 0, 0) datetime(2020, 1, 1, 0, 0, 1)"}
{"id": "fvapps_004623", "vc-description": "/-\nWe need a function that may receive a list  of an unknown amount of points in the same plane, having each of them, cartesian coordinates of the form (x, y) and may find the biggest triangle (the one with the largest area) formed by all of the possible combinations of groups of three points of that given list.\nOf course, we will have some combinations of three points that does not form a triangle, because the three points are aligned.\nThe function find_biggTriang(listOfPoints), will output a list with the following data in the order presented bellow:\n```python\n[(1), (2), (3), (4), 5]\n\n(1) - Number of points received (You may assume that you will not receive duplicates)\n\n(2) - Maximum possible amount of triangles that can be formed with the amount of received \n      points (number in data (1) above). It should be expressed as an integer, (no L for long type \n      variables)\n\n(3) - Real Number of triangles that can be formed with the given points. (The function should have a \n      counter for all the cases of three points aligned). It should be expressedas as an integer.\n\n(4) - The triangles that have maximum area in a sorted list. \n      If there are two triangles with the biggest area, the result will be presented in this way:\n      [[[xA1, yA1], [xB1, yB1], [xC1, yC1]], [[xA2, yA2], [xB2, yB2], [xC2, yC2]]]\n      But if we have only one triangle with max. area, there is no need of a spare level of braces, \n      so it will be as follows: [[xA1, yA1], [xB1, yB1], [xC1, yC1]]\n\n(5) - The value of max. area (absolute value) that was found as a float. As we did not define the \n      units of length for the coordinates, the units for the area will be ignored.\n\n```\n\nIt would be useful to apply the expression for the area of a triangle with vertices A, B, and C, is equal to the half of the determinant of the matrix, using the respective coordinates as follows:\n\n```python\n\n                               | xA    yA    1|\nArea Triangle(A, B, C) = 1/2 . | xB    yB    1|\n                               | xC    yC    1|\n\n```\nThe negative sign for the area should be ignored for the purpose of the exercise, and we will consider the absolute value for all cases.\n\nSee how to calculate the determinant of a matrix 3 x 3, rule of Sarrus.\nhttps://en.wikipedia.org/wiki/Rule_of_Sarrus\n\nUsing this expression, it would be easy to detect the cases when three points are aligned.\n\nLet's see some simple cases.\n```python\nlistOfPoints1 = [(0, 1), (7, 3), (9, 0), (7, 10), (2, 9), (10, 7), (2, 8), (9, 8), (4, 4), (2, 10), (10, 1), (0, 4), (4, 3), (10, 0), (0, 3), (3, 4), (1, 1), (7, 2), (4, 0)] (19 points received)\n\nfind_biggTriang(listOfPoints1) --------> [19, 969, 953, [[0, 1], [7, 10], [10, 0]], 48.5]\n\n/// Combinations (19, 3) = 969 (We do not have repeated points)\n   953 real cases for triangles because the function detected 16 cases when three points are       \n   aligned.\n   The function found one triangle [[0, 1], [7, 10], [10, 0]] with its area equals to 49.5///\n\nlistOfPoints2 = [(7, 4), (0, 0), (9, 10), (5, 0), (8, 1), (7, 6), (9, 3), (2, 4), (6, 3), (5, 6), (3, 6), (10, 0), (9, 7), (3, 10), (10, 2)] (15 points received)\n\nfind_biggTriang(listOfPoints2) --------> [15, 455, 446, [[[0, 0], [9, 10], [10, 0]], [[0, 0], [10, 0], [3, 10]]], 50.0]\n\n/// Combinations(15, 3) = 455 but there were only 446 real triangles\n   We found two triangles: [[0, 0], [9, 10], [10, 0]] and [[0, 0], [10, 0], [3, 10]] (both in a \n   sorted list. Both triangles have an area of 50.0///\n```\nYour code will be tested with lists created randomly up to 70 points.\n\nHave a nice moment and enjoy it!!\n-/", "vc-preamble": "def Point := (Int × Int)\ndef Triangle := (Point × Point × Point)", "vc-helpers": "", "vc-definitions": "def area (t : Triangle) : Float := sorry\ndef find_biggTriang (pts : List Point) : (Nat × Nat × Nat × List Triangle × Float) := sorry", "vc-theorems": "theorem find_biggTriang_result_length \n  (pts : List Point) : \n  let result := find_biggTriang pts\n  List.length [result.1, result.2.1, result.2.2.1, result.2.2.2.1.length, 1] = 5 := sorry\n\ntheorem find_biggTriang_point_count \n  (pts : List Point) :\n  let result := find_biggTriang pts\n  result.1 = pts.length := sorry\n\ntheorem find_biggTriang_triangle_count\n  (pts : List Point) :\n  let result := find_biggTriang pts\n  let n := pts.length\n  result.2.1 = n * (n-1) * (n-2) / 6 := sorry\n\ntheorem find_biggTriang_nonzero_area_count\n  (pts : List Point) :\n  let result := find_biggTriang pts \n  0 ≤ result.2.2.1 ∧ result.2.2.1 ≤ result.2.1 := sorry\n\ntheorem find_biggTriang_max_area_nonneg\n  (pts : List Point) :\n  let result := find_biggTriang pts\n  result.2.2.2.2 ≥ 0 := sorry\n\ntheorem area_cyclic_permutation\n  (p1 p2 p3 : Point) :\n  let t1 := (p1, p2, p3)\n  let t2 := (p2, p3, p1) \n  let t3 := (p3, p1, p2)\n  (area t1 - area t2).abs < 1e-10 ∧ (area t2 - area t3).abs < 1e-10 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [19, 969, 953, [[0, 1], [7, 10], [10, 0]], 48.5]\n-/\n#guard_msgs in\n#eval find_biggTriang [(0, 1), (7, 3), (9, 0), (7, 10), (2, 9), (10, 7), (2, 8), (9, 8), (4, 4), (2, 10), (10, 1), (0, 4), (4, 3), (10, 0), (0, 3), (3, 4), (1, 1), (7, 2), (4, 0)]\n\n/-\ninfo: [15, 455, 446, [[[0, 0], [9, 10], [10, 0]], [[0, 0], [10, 0], [3, 10]]], 50.0]\n-/\n#guard_msgs in\n#eval find_biggTriang [(7, 4), (0, 0), (9, 10), (5, 0), (8, 1), (7, 6), (9, 3), (2, 4), (6, 3), (5, 6), (3, 6), (10, 0), (9, 7), (3, 10), (10, 2)]\n\n/-\ninfo: [3, 1, 1, [[0, 0], [3, 0], [0, 4]], 6.0]\n-/\n#guard_msgs in\n#eval find_biggTriang [(0, 0), (3, 0), (0, 4)]"}
{"id": "fvapps_004683", "vc-description": "/-\nGiven a number return the closest number to it that is divisible by 10.\n\nExample input:\n\n```\n22\n25\n37\n```\n\nExpected output:\n\n```\n20\n30\n40\n```\n-/", "vc-preamble": "def abs (x : Int) : Int := \n  if x ≥ 0 then x else -x", "vc-helpers": "", "vc-definitions": "def closestMultiple10 (x : Int) : Int := sorry\n\ntheorem result_is_multiple_of_10 (x : Int) :\n  (closestMultiple10 x) % 10 = 0 := sorry", "vc-theorems": "theorem closest_multiple_property (x : Int) :\n  abs (x - closestMultiple10 x) ≤ abs (x - (closestMultiple10 x + 10)) ∧ \n  abs (x - closestMultiple10 x) ≤ abs (x - (closestMultiple10 x - 10)) := sorry\n\ntheorem halfway_rounds_up (x : Int) :\n  closestMultiple10 (x * 10 + 5) = ((x * 10 + 5) / 10 + 1) * 10 := sorry\n\ntheorem result_within_5 (x : Int) :\n  abs (x - closestMultiple10 x) ≤ 5 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded\n\n/-\ninfo: 20\n-/\n#guard_msgs in\n#eval closest_multiple_10 22\n\n/-\ninfo: 30\n-/\n#guard_msgs in\n#eval closest_multiple_10 25\n\n/-\ninfo: 40\n-/\n#guard_msgs in\n#eval closest_multiple_10 37"}
{"id": "fvapps_004690", "vc-description": "/-\n----\nVampire Numbers\n----\n\nOur loose definition of [Vampire Numbers](http://en.wikipedia.org/wiki/Vampire_number) can be described as follows:\n\n```python\n6 * 21 = 126\n# 6 and 21 would be valid 'fangs' for a vampire number as the \n# digits 6, 1, and 2 are present in both the product and multiplicands\n\n10 * 11 = 110\n# 110 is not a vampire number since there are three 1's in the\n# multiplicands, but only two 1's in the product\n```\n\nCreate a function that can receive two 'fangs' and determine if the product of the two is a valid vampire number.\n-/", "vc-preamble": "def abs (x : Int) : Int := if x < 0 then -x else x\n\nstructure VampireString where\n  digits : List Char\n  length : Nat", "vc-helpers": "", "vc-definitions": "def vampireToString (x : Int) : VampireString := sorry\n\ndef vampire_test (x y : Int) : Bool := sorry", "vc-theorems": "theorem vampire_commutative (x y : Int) (h₁ : x ≠ 0) (h₂ : y ≠ 0) :\n  vampire_test x y = vampire_test y x := sorry\n\ntheorem vampire_self_multiply (x : Int) (h : x ≠ 0) :  \n  vampire_test x x = vampire_test x x := sorry\n\ntheorem vampire_digit_preservation (x y : Int) (h₁ : x ≠ 0) (h₂ : y ≠ 0) :\n  vampire_test x y → (vampireToString (abs (x * y))).digits = \n    (vampireToString (abs x)).digits ++ (vampireToString (abs y)).digits := sorry\n\ntheorem vampire_positive_length (x y : Int) (h₁ : x > 0) (h₂ : y > 0) :\n  vampire_test x y → (vampireToString (x * y)).length = \n    (vampireToString x).length + (vampireToString y).length := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval vampire_test 6 21\n\n/-\ninfo: False\n-/\n#guard_msgs in\n#eval vampire_test 10 11\n\n/-\ninfo: True\n-/\n#guard_msgs in\n#eval vampire_test 15 93"}
{"id": "fvapps_004712", "vc-description": "/-\n## **Instructions**\n\nThe goal of this kata is two-fold:\n\n1.) You must produce a fibonacci sequence in the form of an array, containing a number of items equal to the input provided.\n\n2.) You must replace all numbers in the sequence `divisible by 3` with `Fizz`, those `divisible by 5` with `Buzz`, and those `divisible by both 3 and 5` with `FizzBuzz`.\n\nFor the sake of this kata, you can assume all input will be a positive integer.\n\n## **Use Cases**\n\nReturn output must be in the form of an array, with the numbers as integers and the replaced numbers (fizzbuzz) as strings.\n\n## **Examples**\n\nInput: \n\n```python\nfibs_fizz_buzz(5)\n```\nOutput:\n~~~~\n[ 1, 1, 2, 'Fizz', 'Buzz' ]\n~~~~\n\nInput:\n\n```python\nfibs_fizz_buzz(1)\n```\nOutput:\n~~~~\n[1]\n~~~~\n\nInput:\n\n```python\nfibs_fizz_buzz(20)\n```\nOutput:\n~~~~\n[1,1,2,\"Fizz\",\"Buzz\",8,13,\"Fizz\",34,\"Buzz\",89,\"Fizz\",233,377,\"Buzz\",\"Fizz\",1597,2584,4181,\"FizzBuzz\"]\n~~~~\n\n##Good Luck!##\n-/", "vc-preamble": "def fib : Nat → Nat \n| 0 => 0\n| 1 => 1\n| n + 2 => fib (n + 1) + fib n", "vc-helpers": "", "vc-definitions": "def fibs_fizz_buzz (n : Nat) : List (String ⊕ Nat) :=\n  sorry", "vc-theorems": "theorem fibs_fizz_buzz_length (n : Nat) :\n  List.length (fibs_fizz_buzz n) = n :=\nsorry\n\ntheorem fibs_fizz_buzz_first_values {n : Nat} (h : n ≥ 1) :\n  match fibs_fizz_buzz n with\n  | [] => False\n  | x::_ => x = Sum.inr 1\n:=\nsorry\n\ntheorem fibs_fizz_buzz_first_two {n : Nat} (h : n ≥ 2) :\n  match fibs_fizz_buzz n with\n  | []      => False \n  | [_]     => False\n  | x::y::_ => x = Sum.inr 1 ∧ y = Sum.inr 1\n:=\nsorry\n\ntheorem fibs_fizz_buzz_rules {n : Nat} (i : Nat) (h : i < n) :\n  let result := (fibs_fizz_buzz n).get ⟨i, by {\n    rw [fibs_fizz_buzz_length n]\n    exact h\n  }⟩\n  let fibonacci := fib i\n  match result with\n  | Sum.inl s => \n    (fibonacci % 15 = 0 ∧ s = \"FizzBuzz\") ∨\n    (fibonacci % 3 = 0 ∧ fibonacci % 5 ≠ 0 ∧ s = \"Fizz\") ∨\n    (fibonacci % 5 = 0 ∧ fibonacci % 3 ≠ 0 ∧ s = \"Buzz\")\n  | Sum.inr k => fibonacci % 3 ≠ 0 ∧ fibonacci % 5 ≠ 0 ∧ k = fibonacci\n:=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded\n\n/-\ninfo: [1, 1, 2, 'Fizz', 'Buzz']\n-/\n#guard_msgs in\n#eval fibs_fizz_buzz 5\n\n/-\ninfo: [1]\n-/\n#guard_msgs in\n#eval fibs_fizz_buzz 1\n\n/-\ninfo: [1, 1, 2, 'Fizz', 'Buzz', 8, 13, 'Fizz', 34, 'Buzz', 89, 'Fizz', 233, 377, 'Buzz', 'Fizz', 1597, 2584, 4181, 'FizzBuzz']\n-/\n#guard_msgs in\n#eval fibs_fizz_buzz 20"}
