{"id": "bignum_Add", "vc-description": "Bignum task: Add.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def Add (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Add_NormalizeBitString", "vc-description": "Bignum task: Add_NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) (h : ValidBitString s) :\n  let t := NormalizeBitString s\n  ValidBitString t ∧\n  t.length > 0 ∧\n  (t.length > 1 → t.get? 0 = some '1') ∧\n  Str2Int s = Str2Int t", "vc-helpers": "", "vc-definitions": "def Add (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Compare", "vc-description": "Bignum task: Compare.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def Compare (s1 s2 : String) : Int :=\n  sorry", "vc-theorems": "theorem Compare_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  (Str2Int s1 < Str2Int s2 → Compare s1 s2 = (-1 : Int)) ∧\n  (Str2Int s1 = Str2Int s2 → Compare s1 s2 = 0) ∧\n  (Str2Int s1 > Str2Int s2 → Compare s1 s2 = 1) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_CompareUnequal", "vc-description": "Bignum task: CompareUnequal.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def CompareUnequal (s1 s2 : String) : Int :=\n  sorry", "vc-theorems": "theorem CompareUnequal_spec\n    (s1 s2 : String)\n    (h1 : ValidBitString s1)\n    (h2 : ValidBitString s2)\n    (h10 : s1.length > 0)\n    (h1nz : s1.length > 1 → s1.get? 0 = some '1')\n    (h20 : s2.length > 0)\n    (h2nz : s2.length > 1 → s2.get? 0 = some '1')\n    (hlen : s1.length > s2.length)\n    :\n    (Str2Int s1 < Str2Int s2 → CompareUnequal s1 s2 = (-1 : Int)) ∧\n    (Str2Int s1 = Str2Int s2 → CompareUnequal s1 s2 = 0) ∧\n    (Str2Int s1 > Str2Int s2 → CompareUnequal s1 s2 = 1) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Compare_CompareUnequal", "vc-description": "Bignum task: Compare_CompareUnequal.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def CompareUnequal (s1 s2 : String) : Int :=\n  sorry", "vc-theorems": "theorem CompareUnequal_spec\n    (s1 s2 : String)\n    (h1 : ValidBitString s1)\n    (h2 : ValidBitString s2)\n    (h10 : s1.length > 0)\n    (h1nz : s1.length > 1 → s1.get? 0 = some '1')\n    (h20 : s2.length > 0)\n    (h2nz : s2.length > 1 → s2.get? 0 = some '1')\n    (hlen : s1.length > s2.length)\n    :\n    (Str2Int s1 < Str2Int s2 → CompareUnequal s1 s2 = (-1 : Int)) ∧\n    (Str2Int s1 = Str2Int s2 → CompareUnequal s1 s2 = 0) ∧\n    (Str2Int s1 > Str2Int s2 → CompareUnequal s1 s2 = 1) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Compare_CompareUnequal_NormalizeBitString", "vc-description": "Bignum task: Compare_CompareUnequal_NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) (h : ValidBitString s) :\n  ValidBitString (NormalizeBitString s) ∧\n  (NormalizeBitString s).length > 0 ∧\n  ((NormalizeBitString s).length > 1 → (NormalizeBitString s).get? 0 = some '1') ∧\n  Str2Int s = Str2Int (NormalizeBitString s)\n\ndef CompareUnequal (s1 s2 : String) : Int :=\n  sorry\n\naxiom CompareUnequal_spec\n    (s1 s2 : String)\n    (h1 : ValidBitString s1)\n    (h2 : ValidBitString s2)\n    (h10 : s1.length > 0)\n    (h1nz : s1.length > 1 → s1.get? 0 = some '1')\n    (h20 : s2.length > 0)\n    (h2nz : s2.length > 1 → s2.get? 0 = some '1')\n    (hlen : s1.length > s2.length)\n    :\n    (Str2Int s1 < Str2Int s2 → CompareUnequal s1 s2 = (-1 : Int)) ∧\n    (Str2Int s1 = Str2Int s2 → CompareUnequal s1 s2 = 0) ∧\n    (Str2Int s1 > Str2Int s2 → CompareUnequal s1 s2 = 1)", "vc-helpers": "", "vc-definitions": "def Compare (s1 s2 : String) : Int :=\n  sorry", "vc-theorems": "theorem Compare_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  (Str2Int s1 < Str2Int s2 → Compare s1 s2 = (-1 : Int)) ∧\n  (Str2Int s1 = Str2Int s2 → Compare s1 s2 = 0) ∧\n  (Str2Int s1 > Str2Int s2 → Compare s1 s2 = 1) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Compare_NormalizeBitString", "vc-description": "Bignum task: Compare_NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) (h : ValidBitString s) :\n  let t := NormalizeBitString s\n  ValidBitString t ∧\n  t.length > 0 ∧\n  (t.length > 1 → t.get? 0 = some '1') ∧\n  Str2Int s = Str2Int t", "vc-helpers": "", "vc-definitions": "def Compare (s1 s2 : String) : Int :=\n  sorry", "vc-theorems": "theorem Compare_spec (s1 s2 : String) :\n  (Str2Int s1 < Str2Int s2 → Compare s1 s2 = (-1 : Int)) ∧\n  (Str2Int s1 = Str2Int s2 → Compare s1 s2 = 0) ∧\n  (Str2Int s1 > Str2Int s2 → Compare s1 s2 = 1) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_DivMod", "vc-description": "Bignum task: DivMod.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def DivMod (s1 s2 : String) : (String × String) :=\n  sorry", "vc-theorems": "theorem DivMod_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2)\n  (h2nz : Str2Int s2 ≠ 0) :\n  let (q, r) := DivMod s1 s2\n  ValidBitString q ∧ ValidBitString r ∧ Str2Int s1 = Str2Int q * Str2Int s2 + Str2Int r := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_DivMod_Compare", "vc-description": "Bignum task: DivMod_Compare.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Compare (s1 s2 : String) : Int :=\n  sorry\n\naxiom Compare_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  (Str2Int s1 < Str2Int s2 → Compare s1 s2 = (-1 : Int)) ∧\n  (Str2Int s1 = Str2Int s2 → Compare s1 s2 = 0) ∧\n  (Str2Int s1 > Str2Int s2 → Compare s1 s2 = 1)", "vc-helpers": "", "vc-definitions": "def DivMod (s1 s2 : String) : (String × String) :=\n  sorry", "vc-theorems": "theorem DivMod_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2)\n  (h2nz : Str2Int s2 ≠ 0) :\n  let (q, r) := DivMod s1 s2\n  ValidBitString q ∧ ValidBitString r ∧ Str2Int s1 = Str2Int q * Str2Int s2 + Str2Int r := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_DivMod_Compare_Sub", "vc-description": "Bignum task: DivMod_Compare_Sub.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Compare (s1 s2 : String) : Int :=\n  sorry\n\naxiom Compare_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  (Str2Int s1 < Str2Int s2 → Compare s1 s2 = (-1 : Int)) ∧\n  (Str2Int s1 = Str2Int s2 → Compare s1 s2 = 0) ∧\n  (Str2Int s1 > Str2Int s2 → Compare s1 s2 = 1)\n\ndef Sub (s1 s2 : String) : String :=\n  sorry\n\naxiom Sub_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Sub s1 s2) ∧ Str2Int (Sub s1 s2) + Str2Int s2 = Str2Int s1", "vc-helpers": "", "vc-definitions": "def DivMod (s1 s2 : String) : (String × String) :=\n  sorry", "vc-theorems": "theorem DivMod_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2)\n  (h2nz : Str2Int s2 ≠ 0) :\n  let (q, r) := DivMod s1 s2\n  ValidBitString q ∧ ValidBitString r ∧ Str2Int s1 = Str2Int q * Str2Int s2 + Str2Int r := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_DivMod_Sub", "vc-description": "Bignum task: DivMod_Sub.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Sub (s1 s2 : String) : String :=\n  sorry\n\naxiom Sub_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) (h_ge : Str2Int s1 ≥ Str2Int s2) :\n  ValidBitString (Sub s1 s2) ∧ Str2Int (Sub s1 s2) = Str2Int s1 - Str2Int s2", "vc-helpers": "", "vc-definitions": "def DivMod (dividend divisor : String) : (String × String) :=\n  sorry", "vc-theorems": "theorem DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp", "vc-description": "Bignum task: ModExp.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2", "vc-description": "Bignum task: ModExpPow2.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_Add", "vc-description": "Bignum task: ModExpPow2_Add.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_Add_DivMod", "vc-description": "Bignum task: ModExpPow2_Add_DivMod.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_Add_DivMod_Mul", "vc-description": "Bignum task: ModExpPow2_Add_DivMod_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_Add_Mul", "vc-description": "Bignum task: ModExpPow2_Add_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_DivMod", "vc-description": "Bignum task: ModExpPow2_DivMod.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_DivMod_Mul", "vc-description": "Bignum task: ModExpPow2_DivMod_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_Mul", "vc-description": "Bignum task: ModExpPow2_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExpPow2_int", "vc-description": "Bignum task: ModExpPow2_int.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)", "vc-helpers": "", "vc-definitions": "def ModExpPow2_int (x y n z : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem ModExpPow2_int_spec (x y n z : Nat) (hy : y = Exp_int 2 n) (hz : z > 0) :\n  ModExpPow2_int x y n z = Exp_int x y % z := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add", "vc-description": "Bignum task: ModExp_Add.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod", "vc-description": "Bignum task: ModExp_Add_DivMod.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2", "vc-description": "Bignum task: ModExp_Add_DivMod_ModExpPow2.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: ModExp_Add_DivMod_ModExpPow2_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: ModExp_Add_DivMod_ModExpPow2_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_Mul", "vc-description": "Bignum task: ModExp_Add_DivMod_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_Mul_Zeroes", "vc-description": "Bignum task: ModExp_Add_DivMod_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_DivMod_Zeroes", "vc-description": "Bignum task: ModExp_Add_DivMod_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_ModExpPow2", "vc-description": "Bignum task: ModExp_Add_ModExpPow2.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul", "vc-description": "Bignum task: ModExp_Add_ModExpPow2_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: ModExp_Add_ModExpPow2_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_ModExpPow2_Zeroes", "vc-description": "Bignum task: ModExp_Add_ModExpPow2_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_Mul", "vc-description": "Bignum task: ModExp_Add_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_Mul_Zeroes", "vc-description": "Bignum task: ModExp_Add_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Add_Zeroes", "vc-description": "Bignum task: ModExp_Add_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod", "vc-description": "Bignum task: ModExp_DivMod.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_ModExpPow2", "vc-description": "Bignum task: ModExp_DivMod_ModExpPow2.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: ModExp_DivMod_ModExpPow2_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: ModExp_DivMod_ModExpPow2_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: ModExp_DivMod_ModExpPow2_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_Mul", "vc-description": "Bignum task: ModExp_DivMod_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_Mul_Zeroes", "vc-description": "Bignum task: ModExp_DivMod_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_DivMod_Zeroes", "vc-description": "Bignum task: ModExp_DivMod_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_ModExpPow2", "vc-description": "Bignum task: ModExp_ModExpPow2.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul", "vc-description": "Bignum task: ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s\n\ndef DivMod (dividend divisor : String) : (String × String) :=\n  sorry\n\naxiom DivMod_spec (dividend divisor : String) (h1 : ValidBitString dividend) (h2 : ValidBitString divisor) (h_pos : Str2Int divisor > 0) :\n  let (quotient, remainder) := DivMod dividend divisor\n  ValidBitString quotient ∧ ValidBitString remainder ∧\n  Str2Int quotient = Str2Int dividend / Str2Int divisor ∧\n  Str2Int remainder = Str2Int dividend % Str2Int divisor\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_ModExpPow2_Mul", "vc-description": "Bignum task: ModExp_ModExpPow2_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: ModExp_ModExpPow2_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_ModExpPow2_Zeroes", "vc-description": "Bignum task: ModExp_ModExpPow2_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef ModExpPow2 (sx sy : String) (n : Nat) (sz : String) : String :=\n  sorry\n\naxiom ModExpPow2_spec (sx sy : String) (n : Nat) (sz : String)\n  (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pow2 : Str2Int sy = Exp_int 2 n ∨ Str2Int sy = 0)\n  (hsy_len : sy.length = n + 1)\n  (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExpPow2 sx sy n sz) ∧\n  Str2Int (ModExpPow2 sx sy n sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Mul", "vc-description": "Bignum task: ModExp_Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Mul_Zeroes", "vc-description": "Bignum task: ModExp_Mul_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Mul (s1 s2 : String) : String :=\n  sorry\n\naxiom Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_Zeroes", "vc-description": "Bignum task: ModExp_Zeroes.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef AllZero (s : String) : Prop :=\n  ∀ i, s.get? i = some '0'\n\ndef Zeros (n : Nat) : String :=\n  sorry\n\naxiom Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s", "vc-helpers": "", "vc-definitions": "def ModExp (sx sy sz : String) : String :=\n  sorry", "vc-theorems": "theorem ModExp_spec (sx sy sz : String) (hx : ValidBitString sx) (hy : ValidBitString sy) (hz : ValidBitString sz)\n  (hsy_pos : sy.length > 0) (hsz_gt1 : Str2Int sz > 1) :\n  ValidBitString (ModExp sx sy sz) ∧\n  Str2Int (ModExp sx sy sz) = Exp_int (Str2Int sx) (Str2Int sy) % Str2Int sz := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_int", "vc-description": "Bignum task: ModExp_int.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)", "vc-helpers": "", "vc-definitions": "def ModExp_int (x y n z : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem ModExp_int_spec (x y n z : Nat) (hy : y < Exp_int 2 (n + 1)) (hz : z > 1) :\n  ModExp_int x y n z = Exp_int x y % z := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_ModExp_int_ModExpPow2_int", "vc-description": "Bignum task: ModExp_int_ModExpPow2_int.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef Exp_int (x y : Nat) : Nat :=\n  if y = 0 then 1 else x * Exp_int x (y - 1)\n\ndef ModExpPow2_int (x y n z : Nat) : Nat :=\n  sorry\n\naxiom ModExpPow2_int_spec (x y n z : Nat) (hy : y = Exp_int 2 n) (hz : z > 0) :\n  ModExpPow2_int x y n z = Exp_int x y % z", "vc-helpers": "", "vc-definitions": "def ModExp_int (x y n z : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem ModExp_int_spec (x y n z : Nat) (hy : y < Exp_int 2 (n + 1)) (hz : z > 1) :\n  ModExp_int x y n z = Exp_int x y % z := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Mul", "vc-description": "Bignum task: Mul.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def Mul (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Mul_Add", "vc-description": "Bignum task: Mul_Add.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2", "vc-helpers": "", "vc-definitions": "def Mul (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Mul_Add_NormalizeBitString", "vc-description": "Bignum task: Mul_Add_NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef Add (s1 s2 : String) : String :=\n  sorry\n\naxiom Add_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Add s1 s2) ∧ Str2Int (Add s1 s2) = Str2Int s1 + Str2Int s2\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) :\n  ValidBitString (NormalizeBitString s) ∧\n  (NormalizeBitString s).length > 0 ∧\n  ((NormalizeBitString s).length > 1 → (NormalizeBitString s).get? 0 = some '1') ∧\n  (ValidBitString s → Str2Int s = Str2Int (NormalizeBitString s))", "vc-helpers": "", "vc-definitions": "def Mul (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Mul_NormalizeBitString", "vc-description": "Bignum task: Mul_NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) :\n  ValidBitString (NormalizeBitString s) ∧\n  (NormalizeBitString s).length > 0 ∧\n  ((NormalizeBitString s).length > 1 → (NormalizeBitString s).get? 0 = some '1') ∧\n  (ValidBitString s → Str2Int s = Str2Int (NormalizeBitString s))", "vc-helpers": "", "vc-definitions": "def Mul (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Mul_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) :\n  ValidBitString (Mul s1 s2) ∧ Str2Int (Mul s1 s2) = Str2Int s1 * Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_NormalizeBitString", "vc-description": "Bignum task: NormalizeBitString.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def NormalizeBitString (s : String) : String :=\n  sorry", "vc-theorems": "theorem NormalizeBitString_spec (s : String) :\n  ValidBitString (NormalizeBitString s) ∧\n  (NormalizeBitString s).length > 0 ∧\n  ((NormalizeBitString s).length > 1 → (NormalizeBitString s).get? 0 = some '1') ∧\n  (ValidBitString s → Str2Int s = Str2Int (NormalizeBitString s)) := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Sub", "vc-description": "Bignum task: Sub.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def Sub (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Sub_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) (h_ge : Str2Int s1 ≥ Str2Int s2) :\n  ValidBitString (Sub s1 s2) ∧ Str2Int (Sub s1 s2) = Str2Int s1 - Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Sub_NormalizeBitstring", "vc-description": "Bignum task: Sub_NormalizeBitstring.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0\n\ndef NormalizeBitString (s : String) : String :=\n  sorry\n\naxiom NormalizeBitString_spec (s : String) :\n  ValidBitString (NormalizeBitString s) ∧\n  (NormalizeBitString s).length > 0 ∧\n  ((NormalizeBitString s).length > 1 → (NormalizeBitString s).get? 0 = some '1') ∧\n  (ValidBitString s → Str2Int s = Str2Int (NormalizeBitString s))", "vc-helpers": "", "vc-definitions": "def Sub (s1 s2 : String) : String :=\n  sorry", "vc-theorems": "theorem Sub_spec (s1 s2 : String) (h1 : ValidBitString s1) (h2 : ValidBitString s2) (h_ge : Str2Int s1 ≥ Str2Int s2) :\n  ValidBitString (Sub s1 s2) ∧ Str2Int (Sub s1 s2) = Str2Int s1 - Str2Int s2 := by\n  sorry", "vc-postamble": "end BignumLean"}
{"id": "bignum_Zeros", "vc-description": "Bignum task: Zeros.\nImplement the function according to the Lean specification.", "vc-preamble": "namespace BignumLean\n\ndef AllZero (s : String) : Prop :=\n  s.length = 0 ∨ ∀ i, s.get? i = some '0'\n\ndef ValidBitString (s : String) : Prop :=\n  ∀ {i c}, s.get? i = some c → (c = '0' ∨ c = '1')\n\ndef Str2Int (s : String) : Nat :=\n  s.data.foldl (fun acc ch => 2 * acc + (if ch = '1' then 1 else 0)) 0", "vc-helpers": "", "vc-definitions": "def Zeros (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem Zeros_spec (n : Nat) :\n  let s := Zeros n\n  s.length = n ∧ ValidBitString s ∧ Str2Int s = 0 ∧ AllZero s := by\n  sorry", "vc-postamble": "end BignumLean"}
