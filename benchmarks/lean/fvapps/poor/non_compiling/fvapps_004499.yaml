vc-description: |-
  /-
  Hi! Welcome to my first kata.
  
  In this kata the task is to take a list of integers (positive and negative) and split them according to a simple rule; those ints greater than or equal to the key, and those ints less than the key (the itself key will always be positive).
  
  However, in this kata the goal is to sort the numbers IN PLACE, so DON'T go messing around with the order in with the numbers appear.
  
  You are to return a nested list. If the list is empty, simply return an empty list.
  
  Confused? Okay, let me walk you through an example...
  
      The input is: [1, 1, 1, 0, 0, 6, 10, 5, 10], the key is: 6
  Okay so the first five numbers are less than the key, 6, so we group them together.
  
      [1, 1, 1, 0, 0]
  The next two numbers, 6 & 10, are both >= 6 to they belong in a seperate group, which we will add to the first group. Like so:
  
      [[1, 1, 1, 0, 0], [6, 10]]
  The next two numbers are 5 & 10. Since the key is 6 these two numbers form seperate groups, which we will add to the previous result. like so:
  
      [[1, 1, 1, 0, 0], [6, 10], [5], [10]]
  And voila! We're done.
  
  Here are a few more basic examples:
  
      group_ints([1, 0], key= 0)  
      --> [[1,0]]
  
      group_ints([1, 0, -1, 5], key= 0) 
      --> [[1, 0], [-1], [5]]
  
      group_ints([1, 0, -1, 5], key= 5) 
      --> [[1, 0, -1], [5]]
  
  Good luck guys/gals!
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def groupInts (lst : List Int) (key : Int) : List (List Int) := sorry
  
  theorem empty_list_any_key (k : Int) : 
    groupInts [] k = [] := sorry

vc-theorems: |-
  theorem group_ints_result_structure {lst : List Int} {k : Int} :
    let result := groupInts lst k
    -- Result is a list of non-empty lists
    ∀ sublist ∈ result, sublist ≠ [] := sorry
  
  theorem group_ints_preserves_elements {lst : List Int} {k : Int} :
    let result := groupInts lst k
    List.join result = lst := sorry
  
  theorem group_ints_homogeneous_groups {lst : List Int} {k : Int} :
    let result := groupInts lst k
    ∀ group ∈ result, 
      let first_less := group.head! < k
      ∀ x ∈ group, (x < k) = first_less := sorry
  
  theorem group_ints_adjacent_groups_differ {lst : List Int} {k : Int} :
    let result := groupInts lst k
    ∀ i < result.length - 1,
      let group1_head := (result.get! i).head!
      let group2_head := (result.get! (i+1)).head!
      (group1_head < k) ≠ (group2_head < k) := sorry
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval group_ints [] 0
  
  /-
  info: [[1]]
  -/
  -- #guard_msgs in
  -- #eval group_ints [1] 1

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

