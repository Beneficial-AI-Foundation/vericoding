vc-description: |-
  /-
  Consider the following process. You have a binary string (a string where each character is either 0 or 1) $w$ of length $n$ and an integer $x$. You build a new binary string $s$ consisting of $n$ characters. The $i$-th character of $s$ is chosen as follows:
  
    if the character $w_{i-x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i > x$ and $w_{i-x} = $ 1, then $s_i = $ 1);  if the character $w_{i+x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i + x \le n$ and $w_{i+x} = $ 1, then $s_i = $ 1);  if both of the aforementioned conditions are false, then $s_i$ is 0. 
  
  You are given the integer $x$ and the resulting string $s$. Reconstruct the original string $w$.
  
  -----Input-----
  
  The first line contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases.
  
  Each test case consists of two lines. The first line contains the resulting string $s$ ($2 \le |s| \le 10^5$, each character of $s$ is either 0 or 1). The second line contains one integer $x$ ($1 \le x \le |s| - 1$).
  
  The total length of all strings $s$ in the input does not exceed $10^5$.
  
  -----Output-----
  
  For each test case, print the answer on a separate line as follows:
  
    if no string $w$ can produce the string $s$ at the end of the process, print $-1$;  otherwise, print the binary string $w$ consisting of $|s|$ characters. If there are multiple answers, print any of them. 
  
  -----Example-----
  Input
  3
  101110
  2
  01
  1
  110
  1
  
  Output
  111011
  10
  -1
  -/

vc-preamble: |-
  def length_eq (s₁ s₂ : BinaryString) : Prop := sorry
  def is_binary (s : BinaryString) : Prop := sorry

vc-helpers: |-

vc-definitions: |-
  def matches_at_index (s₁ s₂ : BinaryString) (x i : Nat) : Prop := sorry
  
  def solve_binary_string (s : BinaryString) (x : Nat) : Option BinaryString :=
  sorry
  
  /- Result is either None or has same structure/length as input -/

vc-theorems: |-
  theorem length_preservation (s : BinaryString) (x : Nat) : 
    match solve_binary_string s x with
    | none => True 
    | some result => length_eq s result
  := sorry
  
  /- Result only contains valid binary digits -/
  
  theorem output_chars_valid (s : BinaryString) (x : Nat) :
    match solve_binary_string s x with
    | none => True
    | some result => is_binary result
  := sorry
  
  /- Main correctness theorem capturing all validity conditions -/
  
  theorem valid_solution (s : BinaryString) (x : Nat) :
    match solve_binary_string s x with
    | none => True
    | some result => 
        length_eq s result ∧ 
        is_binary result ∧ 
        (∀ i, matches_at_index s result x i)
  := sorry
  
  /-
  info: '111011'
  -/
  -- #guard_msgs in
  -- #eval solve_binary_string "101110" 2
  
  /-
  info: '10'
  -/
  -- #guard_msgs in
  -- #eval solve_binary_string "01" 1
  
  /-
  info: '-1'
  -/
  -- #guard_msgs in
  -- #eval solve_binary_string "110" 1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

