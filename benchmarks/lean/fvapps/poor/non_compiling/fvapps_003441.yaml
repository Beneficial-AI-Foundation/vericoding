vc-description: |-
  /-
  > 
  **Note**: This kata is a translation of this (Java) one: http://www.codewars.com/kata/rotate-array. I have not translated this first one as usual because I did not solved it, and I fear not being able to solve it (Java is **not** my cup of... tea). @cjmcgraw, if you want to use my translation on your kata feel free to use it.
  
  Create a function named "rotate" that takes an array and returns a new one with the elements inside rotated n spaces.
  
  If n is greater than 0 it should rotate the array to the right. If n is less than 0 it should rotate the array to the left. If n is 0, then it should return the array unchanged.
  
  Example:
  ```python
  data = [1, 2, 3, 4, 5];
  
  rotate(data, 1) # => [5, 1, 2, 3, 4]
  rotate(data, 2) # => [4, 5, 1, 2, 3]
  rotate(data, 3) # => [3, 4, 5, 1, 2]
  rotate(data, 4) # => [2, 3, 4, 5, 1]
  rotate(data, 5) # => [1, 2, 3, 4, 5]
  
  rotate(data, 0) # => [1, 2, 3, 4, 5]
  
  rotate(data, -1) # => [2, 3, 4, 5, 1]
  rotate(data, -2) # => [3, 4, 5, 1, 2]
  rotate(data, -3) # => [4, 5, 1, 2, 3]
  rotate(data, -4) # => [5, 1, 2, 3, 4]
  rotate(data, -5) # => [1, 2, 3, 4, 5]
  ```
  
  Furthermore the method should take ANY array of objects and perform this operation on them:
  ```python
  rotate(['a', 'b', 'c'], 1)     # => ['c', 'a', 'b']
  rotate([1.0, 2.0, 3.0], 1)     # => [3.0, 1.0, 2.0]
  rotate([True, True, False], 1) # => [False, True, True]
  ```
  
  Finally the rotation shouldn't be limited by the indices available in the array. Meaning that if we exceed the indices of the array it keeps rotating.
  
  Example:
  ```python
  data = [1, 2, 3, 4, 5]
  
  rotate(data, 7)     # => [4, 5, 1, 2, 3]
  rotate(data, 11)    # => [5, 1, 2, 3, 4]
  rotate(data, 12478) # => [3, 4, 5, 1, 2]
  ```
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def rotate {α : Type u} (arr : List α) (n : Int) : List α :=
    sorry

vc-theorems: |-
  theorem rotate_empty {α : Type u} (n : Int) :
    rotate ([] : List α) n = ([] : List α) :=
    sorry
  
  theorem rotate_length {α : Type u} (arr : List α) (n : Int) :
    arr ≠ [] → List.length (rotate arr n) = List.length arr :=
    sorry
  
  theorem rotate_elements_same {α : Type u} (arr : List α) (n : Int) (x : α) :
    arr ≠ [] → (x ∈ arr ↔ x ∈ rotate arr n) :=
    sorry
  
  theorem rotate_period {α : Type u} (arr : List α) :
    arr ≠ [] → rotate arr (List.length arr) = arr :=
    sorry
  
  theorem rotate_split {α : Type u} (arr : List α) (n : Int) :
    arr ≠ [] →
    let normalized := Int.mod n (List.length arr)
    rotate arr n = arr.drop (List.length arr - normalized.toNat) ++ arr.take (List.length arr - normalized.toNat) :=
    sorry
  
  theorem rotate_compose {α : Type u} (arr : List α) (n1 n2 : Int) :
    arr ≠ [] →
    rotate (rotate arr n1) n2 = rotate arr (Int.mod (n1 + n2) (List.length arr)) :=
    sorry
  
  theorem rotate_inverse {α : Type u} (arr : List α) (n : Int) :
    arr ≠ [] →
    rotate (rotate arr n) (-n) = arr :=
    sorry
  
  /-
  info: ['c', 'a', 'b']
  -/
  -- #guard_msgs in
  -- #eval rotate ["a", "b", "c"] 1
  
  /-
  info: [3.0, 1.0, 2.0]
  -/
  -- #guard_msgs in
  -- #eval rotate [1.0, 2.0, 3.0] 1
  
  /-
  info: [False, True, True]
  -/
  -- #guard_msgs in
  -- #eval rotate [True, True, False] 1
  
  /-
  info: [4, 5, 1, 2, 3]
  -/
  -- #guard_msgs in
  -- #eval rotate [1, 2, 3, 4, 5] 7

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

