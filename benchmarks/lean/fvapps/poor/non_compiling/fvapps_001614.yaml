vc-description: |-
  /-
  You are given a set of points in the 2D plane. You start at the point with the least X and greatest Y value, and end at the point with the greatest X and least Y value. The rule for movement is that you can not move to a point with a lesser X value as compared to the X value of the point you are on. Also for points having the same X value, you need to visit the point with the greatest Y value before visiting the next point with the same X value. So, if there are 2 points: (0,4 and 4,0) we would start with (0,4) - i.e. least X takes precedence over greatest Y. You need to visit every point in the plane.
  
  -----Input-----
  You will be given an integer t(1<=t<=20) representing the number of test cases. A new line follows; after which the t test cases are given. Each test case starts with a blank line followed by an integer n(2<=n<=100000), which represents the number of points to follow. This is followed by a new line. Then follow the n points, each being a pair of integers separated by a single space; followed by a new line. The X and Y coordinates of each point will be between 0 and 10000 both inclusive.
  
  -----Output-----
  For each test case, print the total distance traveled by you from start to finish; keeping in mind the rules mentioned above, correct to 2 decimal places. The result for each test case must be on a new line.
  
  -----Example-----
  Input:
  3
  
  2
  0 0
  0 1
  
  3
  0 0
  1 1
  2 2
  
  4
  0 0
  1 10
  1 5
  2 2
  
  Output:
  1.00
  2.83
  18.21
  
  For the third test case above, the following is the path you must take:
  0,0 -> 1,10  
  1,10 -> 1,5
  1,5 -> 2,2
  = 18.21
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def calculatePathDistance (p : Path) : Nat := sorry
  
  theorem pathDistance_nonnegative (p : Path) :
    calculatePathDistance p ≥ 0 := sorry

vc-theorems: |-
  theorem pathDistance_exceeds_y_diff (p : Path) (x : Nat) (yVals : List Nat) :
    yVals = (p.filter (fun pt => pt.1 == x)).map Prod.snd →
    yVals ≠ [] →
    calculatePathDistance p ≥ 0 := sorry
  
  theorem pathDistance_exceeds_x_span (p : Path) :
    p.length > 1 →
    let xVals := p.map Prod.fst
    calculatePathDistance p ≥ 0 := sorry
  
  theorem pathDistance_monotonic_right (p : Path) (newX newY : Nat) :
    p ≠ [] →
    newX > 0 →
    calculatePathDistance (p ++ [(newX, newY)]) ≥ calculatePathDistance p := sorry
  
  theorem pathDistance_triangle_inequality (paths : List Path) :
    paths ≠ [] →
    let combinedPath := List.join paths
    ∀ path ∈ paths, calculatePathDistance combinedPath ≥ calculatePathDistance path := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

