vc-description: |-
  /-
  Your task in this kata is to implement the function `create_number_class` which will take a string parameter `alphabet` and return a class representing a number composed of this alphabet.
  
  The class number will implement the four classical arithmetic operations (`+`, `-`, `*`, `//`), a method to convert itself to string, and a `convert_to` method which will take another class number as parameter and will return the value of the actual class number converted to the equivalent value with tha alphabet of the parameter class (return a new instance of this one).
  
  Example:
  
  ```python
  BinClass = create_number_class('01')
  HexClass = create_number_class('0123456789ABCDEF')
  
  x = BinClass('1010')
  y = BinClass('10')
  
  print(x+y)                   => '1100'
  isinstance(x+y, BinClass)    => True
  print(x.convert_to(HexClass) => 'A'
  ```
  
  ___Notes:___
  
  * Only positives integers will be used (either as parameters or results of calculations).
  * You'll never encounter invalid calculations (divisions by zero or things like that).
  * Alphabets will contain at least 2 characters.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def BinClass : NumberClass := sorry
  def HexClass : NumberClass := sorry

vc-theorems: |-
  theorem bin_str_roundtrip (s : String) : 
    s.any (fun c => c = '0' ∨ c = '1') → 
    BinClass.value (BinClass.toString (BinClass.value s)) = BinClass.value s := sorry
  
  theorem bin_int_str_roundtrip (n : Nat) :
    BinClass.value (BinClass.toString n) = n := sorry 
  
  theorem bin_arithmetic_add (s1 s2 : String) :
    BinClass.value s1 + BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 + BinClass.value s2)) := sorry
  
  theorem bin_arithmetic_mul (s1 s2 : String) :
    BinClass.value s1 * BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 * BinClass.value s2)) := sorry
  
  theorem bin_arithmetic_div (s1 s2 : String) :
    BinClass.value s2 ≠ 0 →
    BinClass.value s1 / BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 / BinClass.value s2)) := sorry
  
  theorem bin_arithmetic_sub (s1 s2 : String) :
    BinClass.value s1 ≥ BinClass.value s2 →
    BinClass.value s1 - BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 - BinClass.value s2)) := sorry
  
  theorem base_conversion (n : Nat) :
    BinClass.value (BinClass.toString n) = HexClass.value (HexClass.toString n) := sorry
  
  theorem arbitrary_base_conversion {α : Type} (s : List α) (n : Nat) [DecidableEq α] :
    s.length > 1 →
    ∃ (NumClass : NumberClass),
    NumClass.value (NumClass.toString n) = n := sorry
  
  /-
  info: '1100'
  -/
  -- #guard_msgs in
  -- #eval str x + y
  
  /-
  info: '1000'
  -/
  -- #guard_msgs in
  -- #eval str x - y
  
  /-
  info: '10100'
  -/
  -- #guard_msgs in
  -- #eval str x * y
  
  /-
  info: '101'
  -/
  -- #guard_msgs in
  -- #eval str x // y
  
  /-
  info: 'A'
  -/
  -- #guard_msgs in
  -- #eval str x.convert_to(HexClass)

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

