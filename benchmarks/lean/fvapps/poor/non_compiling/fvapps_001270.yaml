vc-description: |-
  /-
  -----
  RANJANA QUIZ
  -----
  
  Prof. Ranjana decided to conduct a quiz in her class. She divided all the students of her
  class into groups of three. Consider that no student was left out after the division. She gave
  different sets of questions to every group. A set is said to be unique if there is no other team that
  received the same number of maths, science and english questions. In every set, maximum
  questions for each group were related to maths, then science, and the least number of
  questions were related to English. Total number of questions given to each team can be
  different. 
  
  After the test, the CR of the class asked every team to report the number of questions
  they got on each subject. The CR wants to know the number of unique sets of questions that
  were given to the teams, the problem is that all the students have just submitted the number of
  questions of each subject but in no particular order. Help the CR to find the number of unique
  sets
  
  -----Input Format-----
  
  Line 1 contains the number of teams ‘n’. In the next n lines, each line contains three space separated integers,i.e, the number of questions of each subject(in no particular order).
  employee
  
  -----Output-----
  
  Print the number of unique sets
  
  -----Example Text Case-----
  Input:
  
  5
  6 5 4
  2 3 7
  4 6 5
  7 2 3
  5 3 1
  
  Output:
  1
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def calculate_unique_sets (teams : List Team) : Nat :=
    sorry

vc-theorems: |-
  theorem unique_sets_bounds {teams : List Team} :
    let result := calculate_unique_sets teams
    0 ≤ result ∧ result ≤ teams.length := by sorry
  
  theorem shuffle_invariant {teams : List Team} :
    let shuffled := teams.map (fun t => match t with
      | Team.mk a b c => Team.mk b c a) 
    calculate_unique_sets shuffled = calculate_unique_sets teams := by sorry
  
  theorem dedup_property {teams : List Team} :
    let deduped := teams.eraseDups
    calculate_unique_sets deduped ≤ calculate_unique_sets teams := by sorry
  
  theorem repeat_invariant {teams : List Team} (h : teams ≠ []) :
    calculate_unique_sets (teams ++ teams) = calculate_unique_sets teams := by sorry
  
  theorem single_team_perms {a b c : Nat} :
    let perms := [
      Team.mk a b c,
      Team.mk a c b,
      Team.mk b a c,
      Team.mk b c a, 
      Team.mk c a b,
      Team.mk c b a
    ]
    calculate_unique_sets perms = 1 := by sorry
  
  /-
  info: 3
  -/
  -- #guard_msgs in
  -- #eval calculate_unique_sets [(6, 5, 4), (2, 3, 7), (4, 6, 5), (7, 2, 3), (5, 3, 1)]
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval calculate_unique_sets [(3, 2, 1), (3, 2, 1), (4, 3, 2)]
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval calculate_unique_sets [(5, 4, 3), (5, 4, 3), (6, 5, 4)]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

