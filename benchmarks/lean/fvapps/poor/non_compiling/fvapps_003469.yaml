vc-description: |-
  /-
  Given a rational number n
  
  ``` n >= 0, with denominator strictly positive```  
  
  - as a string (example: "2/3" in Ruby, Python, Clojure, JS, CS, Go) 
  - or as two strings (example: "2" "3" in Haskell, Java, CSharp, C++, Swift) 
  - or as a rational or decimal number (example: 3/4, 0.67 in R) 
  - or two integers (Fortran)
  
  decompose 
  this number as a sum of rationals with numerators equal to one and without repetitions
  (2/3 = 1/2 + 1/6 is correct but not 2/3 = 1/3 + 1/3, 1/3 is repeated).
  
  The algorithm must be "greedy", so at each stage the new rational obtained in the decomposition must have a denominator as small as possible. 
  In this manner the sum of a few fractions in the decomposition gives a rather good approximation of the rational to decompose.
  
  2/3 = 1/3 + 1/3 doesn't fit because of the repetition but also because the first 1/3 has a denominator bigger than the one in 1/2 
  in the decomposition 2/3 = 1/2 + 1/6.
  
  ### Example: 
  (You can see other examples in "Sample Tests:")
  ```
  decompose("21/23") or "21" "23" or 21/23 should return 
  
  ["1/2", "1/3", "1/13", "1/359", "1/644046"] in Ruby, Python, Clojure, JS, CS, Haskell, Go
  
  "[1/2, 1/3, 1/13, 1/359, 1/644046]" in Java, CSharp, C++
  
  "1/2,1/3,1/13,1/359,1/644046" in C, Swift, R
  ```  
  
  ### Notes
  1) The decomposition of 21/23 as
  ```
  21/23 = 1/2 + 1/3 + 1/13 + 1/598 + 1/897
  ```
  is exact but don't fulfill our requirement because 598 is bigger than 359.
  Same for 
  ```
  21/23 = 1/2 + 1/3 + 1/23 + 1/46 + 1/69 (23 is bigger than 13)
  or 
  21/23 = 1/2 + 1/3 + 1/15 + 1/110 + 1/253 (15 is bigger than 13).
  ```
  
  2) The rational given to decompose could be greater than one or equal to one, in which case the first "fraction" will be an integer 
  (with an implicit denominator of 1). 
  
  3) If the numerator parses to zero the function "decompose" returns [] (or "".
  
  4) The number could also be a decimal which can be expressed as a rational. 
  
  examples:
  
  `0.6` in Ruby, Python, Clojure,JS, CS, Julia, Go
  
  `"66" "100"` in Haskell, Java, CSharp, C++, C, Swift, Scala, Kotlin
  
  `0.67` in R.
  
  **Ref:**
  http://en.wikipedia.org/wiki/Egyptian_fraction
  -/

vc-preamble: |-
  def Rat.add (a b : Rat) : Rat := sorry
  def Rat.sub (a b : Rat) : Rat := sorry
  
  def Rat.le (a b : Rat) : Prop := sorry
  def Rat.abs (a : Rat) : Rat := sorry
  
  def Int.toRat (n : Int) : Rat := sorry
  def Nat.toRat (n : Nat) : Rat := sorry
  
  def Float.toRat (f : Float) : Rat := sorry
  
  instance : Add Rat where
    add := Rat.add
  
  instance : Sub Rat where
    sub := Rat.sub
  
  instance : LE Rat where
    le := Rat.le

vc-helpers: |-

vc-definitions: |-
  def decompose (f : Rat) : List Rat := sorry
  
  /- The sum of decomposed unit fractions equals the input rational number -/

vc-theorems: |-
  theorem decompose_sum_equals_input (f : Rat) (h : Rat.le ⟨0, 1, by simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :
    let parts := decompose f
    let sum_parts := parts.foldl Rat.add ⟨0, 1, by simp⟩
    Rat.le (Rat.abs (Rat.sub sum_parts f)) ⟨1, 100000, by simp⟩ := sorry
  
  /- For non-whole numbers, decomposition yields unique descending unit fractions -/
  
  theorem decompose_unique_unit_fractions (f : Rat) (h : Rat.le ⟨0, 1, by simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :
    let parts := decompose f
    (parts.length > 1) →
    let unit_fracs := parts.tail
    (∀ x ∈ unit_fracs, ∃ (n : Nat) (h : n > 0), x = ⟨1, n, h⟩) ∧ 
    List.Pairwise (fun x y => Rat.le y x) unit_fracs ∧
    List.Nodup unit_fracs := sorry
  
  /- Decomposition of whole numbers returns singleton list -/
  
  theorem decompose_whole_numbers (n : Nat) (h : n > 0) (h2 : n ≤ 100) :
    decompose (Nat.toRat n) = [Nat.toRat n] := sorry
  
  /- Decimal inputs are handled properly -/
  
  theorem decompose_decimals (d : Float) (h : d ≥ 0) (h2 : d ≤ 10) :
    let result := decompose (Float.toRat d)
    let sum_parts := result.foldl Rat.add ⟨0, 1, by simp⟩
    Rat.le (Rat.abs (Rat.sub sum_parts (Float.toRat d))) ⟨1, 100000, by simp⟩ := sorry
  
  /-
  info: ['1/2', '1/4']
  -/
  -- #guard_msgs in
  -- #eval decompose "3/4"
  
  /-
  info: ['1/2', '1/7', '1/59', '1/5163', '1/53307975']
  -/
  -- #guard_msgs in
  -- #eval decompose "0.66"
  
  /-
  info: ['1/2', '1/4', '1/20']
  -/
  -- #guard_msgs in
  -- #eval decompose "4/5"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

