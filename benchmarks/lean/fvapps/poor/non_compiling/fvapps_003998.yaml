vc-description: |-
  /-
  If the first day of the month is a Friday, it is likely that the month will have an `Extended Weekend`. That is, it could have five Fridays, five Saturdays and five Sundays. 
  
  In this Kata, you will be given a start year and an end year. Your task will be to find months that have extended weekends and return:
  ```
  - The first and last month in the range that has an extended weekend
  - The number of months that have extended weekends in the range, inclusive of start year and end year.
  ```
  
  For example:
  ```python
  solve(2016,2020) = ("Jan","May",5). #The months are: Jan 2016, Jul 2016, Dec 2017, Mar 2019, May 2020
  ```
  
  More examples in test cases. Good luck!
  
  If you found this Kata easy, please try [myjinxin2015](https://www.codewars.com/users/myjinxin2015) challenge version [here](https://www.codewars.com/kata/extended-weekends-challenge-edition)
  -/

vc-preamble: |-
  def monthAbbr : Month → String
  | Month.Jan => "Jan"
  | Month.Feb => "Feb" 
  | Month.Mar => "Mar"
  | Month.Apr => "Apr"
  | Month.May => "May"
  | Month.Jun => "Jun"
  | Month.Jul => "Jul"
  | Month.Aug => "Aug"
  | Month.Sep => "Sep"
  | Month.Oct => "Oct"
  | Month.Nov => "Nov"
  | Month.Dec => "Dec"

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def solve (startYear endYear : Nat) : String × String × Nat :=
  sorry
  
  -- Theorems based on property tests

vc-theorems: |-
  theorem solve_result_type (startYear endYear : Nat) : 
    let result := solve startYear endYear
    result.1 = result.1 ∧ result.2.1 = result.2.1 ∧ result.2.2 > 0 :=
  sorry 
  
  theorem solve_valid_months (startYear endYear : Nat) :
    let result := solve startYear endYear
    let months31 := [Month.Jan, Month.Mar, Month.May, Month.Jul, Month.Aug, Month.Oct, Month.Dec]
    result.1 ∈ months31.map monthAbbr ∧ 
    result.2.1 ∈ months31.map monthAbbr :=
  sorry
  
  theorem solve_count_bounds (startYear endYear : Nat) (h : endYear ≥ startYear) :
    let result := solve startYear endYear 
    let yearDiff := endYear - startYear + 1
    let maxPossible := yearDiff * 7
    0 < result.2.2 ∧ result.2.2 ≤ maxPossible :=
  sorry
  
  theorem solve_guaranteed_solution (startYear endYear : Nat) 
    (h1 : startYear ≥ 1800) (h2 : endYear ≤ 2500) (h3 : endYear ≥ startYear + 10) :
    let result := solve startYear endYear
    result.2.2 > 0 :=
  sorry
  
  /-
  info: ('Jan', 'May', 5)
  -/
  -- #guard_msgs in
  -- #eval solve 2016 2020
  
  /-
  info: ('Mar', 'Dec', 51)
  -/
  -- #guard_msgs in
  -- #eval solve 1900 1950
  
  /-
  info: ('Aug', 'Oct', 702)
  -/
  -- #guard_msgs in
  -- #eval solve 1800 2500

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

