vc-description: |-
  /-
  You will have a list of rationals in the form
  
  ```
  lst = [ [numer_1, denom_1] , ... , [numer_n, denom_n] ]
  ```
  or
  ```
  lst = [ (numer_1, denom_1) , ... , (numer_n, denom_n) ]
  ```
  
  where all numbers are positive integers. You have to produce their sum `N / D` in an irreducible form: this means that `N` and `D` have only `1` as a common divisor.
  
  Return the result in the form:
  
  - `[N, D]` in Ruby, Crystal, Python, Clojure, JS, CS, PHP, Julia
  - `Just "N D"` in Haskell, PureScript
  - `"[N, D]"` in Java, CSharp, TS, Scala, PowerShell, Kotlin
  - `"N/D"` in Go, Nim
  - `{N, D}` in C++, Elixir
  - `{N, D}` in C
  - `Some((N, D))` in Rust
  - `Some "N D"` in F#, Ocaml
  - `c(N, D)` in R
  - `(N, D)` in Swift
  - `'(N D)` in Racket
  
  If the result is an integer (`D` evenly divides `N`) return:
  
  - an integer in Ruby, Crystal, Elixir, Clojure, Python, JS, CS, PHP, R, Julia
  - `Just "n"` (Haskell, PureScript)
  - `"n"` Java, CSharp, TS, Scala, PowerShell, Go, Nim, Kotlin
  - `{n, 1}` in C++
  - `{n, 1}` in C
  - `Some((n, 1))` in Rust
  - `Some "n"` in F#, Ocaml,
  - `(n, 1)` in Swift
  - `n` in Racket 
  
  If the input list is empty, return 
  
  - `nil/None/null/Nothing` 
  - `{0, 1}` in C++
  - `{0, 1}` in C
  - `"0"` in Scala, PowerShell, Go, Nim
  - `O` in Racket
  - `""` in Kotlin
  
  ### Example:
  
  ```
  [ [1, 2], [1, 3], [1, 4] ]  -->  [13, 12]
  
      1/2  +  1/3  +  1/4     =      13/12
  ```
  
  ### Note
  See sample tests for more examples and the form of results.
  -/

vc-preamble: |-
  def sumFracts (lst : List (Int × Nat)) : Option (Int ⊕ (Int × Nat)) := sorry
  
  theorem sum_fracts_empty : 
    sumFracts [] = none := sorry

vc-helpers: |-

vc-definitions: |-
  def addFractions (f1 f2 : Fraction) : Fraction := sorry
  
  theorem sum_fracts_preserves_value (lst : List (Int × Nat)) (h : ∀ p : Int × Nat, p ∈ lst → p.2 > 0) :
    match sumFracts lst with
    | none => lst = []
    | some (Sum.inl n) => Fraction.mk n 1 = lst.foldr (fun p acc => addFractions acc (Fraction.mk p.1 p.2)) (Fraction.mk 0 1)
    | some (Sum.inr (n,d)) => Fraction.mk n d = lst.foldr (fun p acc => addFractions acc (Fraction.mk p.1 p.2)) (Fraction.mk 0 1)
    := sorry

vc-theorems: |-
  theorem sum_fracts_single (n : Int) (d : Nat) (h : d > 0) :
    sumFracts [(n,d)] = if d = 1 
      then some (Sum.inl n)
      else some (Sum.inr (n,d)) := sorry
  
  theorem sum_fracts_result_form (lst : List (Int × Nat)) (h : ∀ p : Int × Nat, p ∈ lst → p.2 > 0) :
    match lst with
    | [] => sumFracts lst = none
    | _ => ∃ n d, (sumFracts lst = some (Sum.inl n) ∧ d = 1) ∨ 
                  (sumFracts lst = some (Sum.inr (n,d)) ∧ d > 1)
    := sorry
  
  /-
  info: [13, 12]
  -/
  -- #guard_msgs in
  -- #eval sum_fracts [[1, 2], [1, 3], [1, 4]]
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval sum_fracts [[1, 3], [5, 3]]
  
  /-
  info: None
  -/
  -- #guard_msgs in
  -- #eval sum_fracts []

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

