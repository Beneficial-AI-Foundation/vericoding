vc-description: |-
  /-
  Pete and his mate Phil are out in the countryside shooting clay pigeons with a shotgun - amazing fun. 
  
  They decide to have a competition. 3 rounds, 2 shots each. Winner is the one with the most hits.
  
  Some of the clays have something attached to create lots of smoke when hit, guarenteed by the packaging to generate 'real excitement!' (genuinely this happened). None of the explosive things actually worked, but for this kata lets say they did.
  
  For each round you will receive the following format:
  
  [{P1:'XX', P2:'XO'}, true]
  
  That is an array containing an object and a boolean. Pl represents Pete, P2 represents Phil. X represents a hit and O represents a miss. If the boolean is true, any hit is worth 2. If it is false, any hit is worth 1.
  
  Find out who won. If it's Pete, return 'Pete Wins!'. If it is Phil, return 'Phil Wins!'. If the scores are equal, return 'Draw!'.
  
  Note that as there are three rounds, the actual input (x) will look something like this:
  
  [[{P1:'XX', P2:'XO'}, true], [{P1:'OX', P2:'OO'}, false], [{P1:'XX', P2:'OX'}, true]]
  -/

vc-preamble: |-
  def GameResults := List (RoundData × Bool)
  
  def shoot : GameResults → String := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def calculateScore (shots : String) (double : Bool) : Nat :=
    (shots.foldl (fun acc c => if c = 'X' then acc + 1 else acc) 0) * 
    (if double then 2 else 1)

vc-theorems: |-
  theorem shoot_returns_valid_result (results : GameResults) :
    shoot results = "Pete Wins!" ∨ 
    shoot results = "Phil Wins!" ∨
    shoot results = "Draw!" := sorry
  
  theorem shoot_gives_correct_winner (results : GameResults) :
    let peteScore := results.foldl 
      (fun acc (round, double) => acc + calculateScore round.P1 double) 0
    let philScore := results.foldl 
      (fun acc (round, double) => acc + calculateScore round.P2 double) 0
    (peteScore > philScore → shoot results = "Pete Wins!") ∧
    (philScore > peteScore → shoot results = "Phil Wins!") ∧
    (peteScore = philScore → shoot results = "Draw!") := sorry
  
  theorem shoot_symmetrical_draw (results : GameResults) :
    let symmetricalResults := results.map 
      (fun (round, double) => ({P1 := round.P1, P2 := round.P1}, double))
    shoot symmetricalResults = "Draw!" := sorry
  
  /-
  info: 'Pete Wins!'
  -/
  -- #guard_msgs in
  -- #eval shoot [[{"P1": "XX", "P2": "XO"}, True], [{"P1": "OX", "P2": "OO"}, False], [{"P1": "XX", "P2": "OX"}, True]]
  
  /-
  info: 'Draw!'
  -/
  -- #guard_msgs in
  -- #eval shoot [[{"P1": "XX", "P2": "XX"}, True], [{"P1": "OO", "P2": "OO"}, False], [{"P1": "XX", "P2": "XX"}, True]]
  
  /-
  info: 'Phil Wins!'
  -/
  -- #guard_msgs in
  -- #eval shoot [[{"P1": "XX", "P2": "XO"}, False], [{"P1": "OX", "P2": "XX"}, False], [{"P1": "OO", "P2": "XX"}, True]]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

