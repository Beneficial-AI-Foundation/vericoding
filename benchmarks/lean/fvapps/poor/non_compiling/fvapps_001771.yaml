vc-description: |-
  /-
  Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:
  1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
  
  Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
  
  2. getValue(int row, int col)
  
  Returns the current value of the coordinate (row,col) from the rectangle.
  
  Example 1:
  Input
  ["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]
  [[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
  Output
  [null,1,null,5,5,null,10,5]
  Explanation
  SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
  // The initial rectangle (4x3) looks like:
  // 1 2 1
  // 4 3 4
  // 3 2 1
  // 1 1 1
  subrectangleQueries.getValue(0, 2); // return 1
  subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
  // After this update the rectangle looks like:
  // 5 5 5
  // 5 5 5
  // 5 5 5
  // 5 5 5 
  subrectangleQueries.getValue(0, 2); // return 5
  subrectangleQueries.getValue(3, 1); // return 5
  subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
  // After this update the rectangle looks like:
  // 5   5   5
  // 5   5   5
  // 5   5   5
  // 10  10  10 
  subrectangleQueries.getValue(3, 1); // return 10
  subrectangleQueries.getValue(0, 2); // return 5
  
  Example 2:
  Input
  ["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]
  [[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
  Output
  [null,1,null,100,100,null,20]
  Explanation
  SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
  subrectangleQueries.getValue(0, 0); // return 1
  subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
  subrectangleQueries.getValue(0, 0); // return 100
  subrectangleQueries.getValue(2, 2); // return 100
  subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
  subrectangleQueries.getValue(2, 2); // return 20
  
  Constraints:
  
  There will be at most 500 operations considering both methods: updateSubrectangle and getValue.
  1 <= rows, cols <= 100
  rows == rectangle.length
  cols == rectangle[i].length
  0 <= row1 <= row2 < rows
  0 <= col1 <= col2 < cols
  1 <= newValue, rectangle[i][j] <= 10^9
  0 <= row < rows
  0 <= col < cols
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def getValue (s : SubrectangleQueries) (i j : Nat) : Int := sorry
  
  def updateSubrectangle (s : SubrectangleQueries) (row1 col1 row2 col2 : Nat) (newValue : Int) : Unit := sorry

vc-theorems: |-
  theorem initial_rectangle_values (rectangle : List (List Int)) (i j : Nat)
    (h1 : i < rectangle.length)
    (h2 : j < (rectangle.head!).length)
    (h3 : rectangle.length > 0)
    (h4 : (rectangle.head!).length > 0) :
    getValue { rectangle := rectangle } i j = (rectangle.get! i).get! j := sorry
  
  theorem update_covers_entire_rectangle (rectangle : List (List Int)) (testVal : Int)
    (h1 : rectangle.length > 0)
    (h2 : (rectangle.head!).length > 0) :
    let s := { rectangle := rectangle }
    let rows := rectangle.length
    let cols := (rectangle.head!).length
    let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) testVal
    ∀ i j, i < rows → j < cols →
      getValue s i j = testVal := sorry
  
  theorem multiple_updates_overlap (rectangle : List (List Int))
    (h1 : rectangle.length > 0)
    (h2 : (rectangle.head!).length > 0) :
    let s := { rectangle := rectangle }
    let rows := rectangle.length
    let cols := (rectangle.head!).length
    let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) 10
    let _ := updateSubrectangle s 0 0 (rows / 2) (cols / 2) 20
    let _ := updateSubrectangle s (rows / 2) (cols / 2) (rows - 1) (cols - 1) 30
    ∀ i j, i ≥ rows / 2 → i < rows → j ≥ cols / 2 → j < cols →
      getValue s i j = 30 := sorry
  
  theorem sequential_same_region_updates (rectangle : List (List Int)) (updates : List Int)
    (h1 : rectangle.length > 0)
    (h2 : (rectangle.head!).length > 0)
    (h3 : updates.length > 0) :
    let s := { rectangle := rectangle }
    let rows := rectangle.length
    let cols := (rectangle.head!).length
    ∀ val ∈ updates, ∀ i j,
      let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) val
      i < rows → j < cols →
        getValue s i j = val := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

