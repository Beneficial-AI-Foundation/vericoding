vc-description: |-
  /-
  Dexter, being irritated by DD, gave her a lucrative game to play to keep her busy.
  There are $N$ bags numbered $1$ to $N$. The $i_{th}$ bag contains $A_i$ coins. The bags are placed in a circular order such that the $N_{th}$ bag is adjacent to the $1^{st}$ bag. 
  DD can select $K$ consecutive adjacent bags and take all the coins in them.   Help her find the maximum number of coins she can take by making the ideal choice.
  Note that the selected bags must be consecutive. Since they are placed in circular order, bag number $1$ and $N$ are considered to be consecutive.
  
  -----Input:-----
  - First-line will contain $T$, the number of test cases. Then the test cases follow. 
  - First-line contains $N$ and $K$.
  - Second-line contains $N$ numbers $A_1, A_2,...,A_N$,  
  
  -----Output:-----
  For each test case, output in a single line, the maximum money that can be collected by DD.
  
  -----Constraints-----
  - $1 \leq T \leq 100$
  - $5 \leq N \leq 10^5$
  - $1 \leq K < N$
  - $1 \leq A_i \leq 10^5$
  Sum of $N$ over all test cases is less than $10^6$
  
  -----Sample Input:-----
  1
  5 3
  8 6 9 4 10
  
  -----Sample Output:-----
  24
  
  -----EXPLANATION:-----
  The ideal choice would be to take the last bag with $10$ coins and the first $2$ bags with $8$ and $6$ coins.
  -/

vc-preamble: |-
  def List.sum (xs : List Int) : Int :=
  match xs with
  | [] => 0
  | h :: t => h + List.sum t
  
  def max_list (xs : List Int) : Int :=
  match xs with
  | [] => 0
  | [x] => x
  | x::xs => max x (max_list xs)

vc-helpers: |-

vc-definitions: |-
  def find_max_coins (n k : Nat) (arr : List Int) : Int :=
  sorry

vc-theorems: |-
  theorem find_max_coins_k_exceeds_n {n k : Nat} {arr : List Int} 
    (h1 : arr.length = n)
    (h2 : k > n) :
    find_max_coins n k arr = 0 :=
  sorry
  
  theorem find_max_coins_k_equals_n {n k : Nat} {arr : List Int}
    (h1 : arr.length = n)
    (h2 : k = n)
    (h3 : n > 0) :
    find_max_coins n k arr = List.sum arr :=
  sorry
  
  theorem find_max_coins_sliding_window {n k : Nat} {arr : List Int}
    (h1 : arr.length = n)
    (h2 : k > 0)
    (h3 : k ≤ n) :
    find_max_coins n k arr = max_list ((List.range n).map (fun i => 
      List.sum (List.take k (List.drop i (arr ++ arr)))
    )) :=
  sorry
  
  theorem find_max_coins_monotonic {n k : Nat} {arr : List Int}
    (h1 : arr.length = n)
    (h2 : k ≤ n)
    (h3 : k > 1)
    (h4 : ∀x ∈ arr, x ≥ 0) :
    find_max_coins n k arr ≥ find_max_coins n (k-1) arr :=
  sorry
  
  /-
  info: 24
  -/
  -- #guard_msgs in
  -- #eval find_max_coins 5 3 [8, 6, 9, 4, 10]
  
  /-
  info: 18
  -/
  -- #guard_msgs in
  -- #eval find_max_coins 6 4 [1, 2, 3, 4, 5, 6]
  
  /-
  info: 90
  -/
  -- #guard_msgs in
  -- #eval find_max_coins 5 2 [10, 20, 30, 40, 50]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

