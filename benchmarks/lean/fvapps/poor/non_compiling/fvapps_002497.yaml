vc-description: |-
  /-
  =====Problem Statement=====
  There is an array of n integers. There are also 2 disjoint sets, A and B, each containing m integers. You like all the integers in set A and dislike all the integers in set B. Your initial happiness is 0. For each integer i in the array, if i ∈ A, you add 1 to your happiness. If i ∈ B, you add -1 to your happiness. Otherwise, your happiness does not change. Output your final happiness at the end.
  
  Note: Since A and B are sets, they have no repeated elements. However, the array might contain duplicate elements.
  
  =====Constraints=====
  1≤n≤10^5
  1≤m≤10^5
  1≤Any integer in the input≤10^9
  
  =====Input Format=====
  The first line contains integers n and m separated by a space.
  The second line contains n integers, the elements of the array.
  The third and fourth lines contain m integers, A and B, respectively.
  
  =====Output Format=====
  Output a single integer, your total happiness.
  -/

vc-preamble: |-
  def SetInt.contains (s : SetInt) (x : Int) : Bool :=
    match s with
    | mk list => list.contains x

vc-helpers: |-

vc-definitions: |-
  def SetInt.empty : SetInt := SetInt.mk []
  
  def calculate_happiness (arr : List Int) (setA setB : SetInt) : Int :=
    sorry

vc-theorems: |-
  theorem happiness_count_property (arr : List Int) (setA setB : SetInt) 
      (h : arr.length > 0) :
    calculate_happiness arr setA setB = 
      ((arr.filter (λ x => setA.contains x)).length - 
       (arr.filter (λ x => setB.contains x)).length) :=
    sorry
  
  theorem disjoint_set_no_effect (arr : List Int) (setA : SetInt) 
      (h : arr.length > 0) :
    let disjointSet := SetInt.mk [arr.maximum?.get!.add 1]
    (calculate_happiness arr setA disjointSet = calculate_happiness arr setA SetInt.empty) ∧ 
    (calculate_happiness arr disjointSet setA = calculate_happiness arr SetInt.empty setA) :=
    sorry
  
  theorem empty_sets_zero (arr : List Int) (h : arr.length > 0) :
    calculate_happiness arr SetInt.empty SetInt.empty = 0 :=
    sorry
  
  theorem same_set_cancels (arr : List Int) (testSet : SetInt) 
      (h : arr.length > 0) :
    calculate_happiness arr testSet testSet = 0 :=
    sorry
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval calculate_happiness [1, 5, 3] {3, 1} {5, 7}
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval calculate_happiness [1, 2, 3] {4, 5} {6, 7}
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval calculate_happiness [1, 1, 2, 2, 3] {1, 3} {2}

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

