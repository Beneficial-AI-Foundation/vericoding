vc-description: |-
  /-
  ## Introduction
  
  Each chemical element in its neutral state has a specific number of electrons associated with it. This is represented by the **atomic number** which is noted by an integer number next to or above each element of the periodic table (as highlighted in the image above).
  
  As we move from left to right, starting from the top row of the periodic table, each element differs from its predecessor by 1 unit (electron). Electrons fill in different orbitals sets according to a specific order. Each set of orbitals, when full, contains an even number of electrons.
  
  The orbital sets are:
  * The _**s** orbital_ - a single orbital that can hold a maximum of 2 electrons.
  * The _**p** orbital set_ - can hold 6 electrons.
  * The _**d** orbital set_ - can hold 10 electrons.
  * The _**f** orbital set_ - can hold 14 electrons.
  
  The order in which electrons are filling the different set of orbitals is shown in the picture above. First electrons will occupy the **1s** orbital, then the **2s**, then the **2p** set, **3s** and so on.
  
  Electron configurations show how the number of electrons of an element is distributed across each orbital set. Each orbital is written as a sequence that follows the order in the picture, joined by the number of electrons contained in that orbital set. The final electron configuration is a single string of orbital names and number of electrons per orbital set where the first 2 digits of each substring represent the orbital name followed by a number that states the number of electrons that the orbital set contains.
  
  For example, a string that demonstrates an electron configuration of a chemical element that contains 10 electrons is: `1s2 2s2 2p6`. This configuration shows that there are two electrons in the `1s` orbital set, two electrons in the `2s` orbital set, and six electrons in the `2p` orbital set. `2 + 2 + 6 = 10` electrons total.
  
  ___
  
  # Task
  
  Your task is to write a function that displays the electron configuration built according to the Madelung rule of all chemical elements of the periodic table. The argument will be the symbol of a chemical element, as displayed in the periodic table.
  
  **Note**: There will be a preloaded array called `ELEMENTS` with chemical elements sorted by their atomic number.
  
  For example, when the element "O" is fed into the function the output should look like: 
  
  `"O -> 1s2 2s2 2p4"`
  
  However, there are some exceptions! The electron configurations of the elements below should end as:
  
  ```
  Cr -> ...3d5 4s1
  Cu -> ...3d10 4s1
  Nb -> ...4d4 5s1
  Mo -> ...4d5 5s1
  Ru -> ...4d7 5s1
  Rh -> ...4d8 5s1
  Pd -> ...4d10 5s0
  Ag -> ...4d10 5s1
  La -> ...4f0 5d1
  Ce -> ...4f1 5d1
  Gd -> ...4f7 5d1 6s2
  Pt -> ...4f14 5d9 6s1
  Au -> ...4f14 5d10 6s1
  Ac -> ...5f0 6d1 7s2
  Th -> ...5f0 6d2 7s2
  Pa -> ...5f2 6d1 7s2
  U  -> ...5f3 6d1 7s2
  Np -> ...5f4 6d1 7s2
  Cm -> ...5f7 6d1 7s2
  ```
  
  **Note**: for `Ni` the electron configuration should be `3d8 4s2` instead of `3d9 4s1`.
  -/

vc-preamble: |-
  def Element.toNat : Element → Nat 
  | H => 1 | He => 2 | Li => 3 | Be => 4 | B => 5 | C => 6 | N => 7 | O => 8
  | F => 9 | Ne => 10 | Na => 11 | Mg => 12 | Al => 13 | Si => 14 | P => 15
  | S => 16 | Cl => 17 | Ar => 18 | K => 19 | Ca => 20 | Sc => 21 | Ti => 22
  | V => 23 | Cr => 24 | Mn => 25 | Fe => 26 | Co => 27 | Ni => 28 | Cu => 29
  | Zn => 30 | Ga => 31 | Ge => 32 | As => 33 | Se => 34 | Br => 35 | Kr => 36
  | Rb => 37 | Sr => 38 | Y => 39 | Zr => 40 | Nb => 41 | Mo => 42 | Tc => 43
  | Ru => 44 | Rh => 45 | Pd => 46 | Ag => 47 | Cd => 48 | In => 49 | Sn => 50
  | Sb => 51 | Te => 52 | I => 53 | Xe => 54 | Cs => 55 | Ba => 56 | La => 57
  | Ce => 58 | Pr => 59 | Nd => 60 | Pm => 61 | Sm => 62 | Eu => 63 | Gd => 64
  | Tb => 65 | Dy => 66 | Ho => 67 | Er => 68 | Tm => 69 | Yb => 70 | Lu => 71
  | Hf => 72 | Ta => 73 | W => 74 | Re => 75 | Os => 76 | Ir => 77 | Pt => 78
  | Au => 79 | Hg => 80 | Tl => 81 | Pb => 82 | Bi => 83 | Po => 84 | At => 85
  | Rn => 86 | Fr => 87 | Ra => 88 | Ac => 89 | Th => 90 | Pa => 91 | U => 92
  | Np => 93 | Pu => 94 | Am => 95 | Cm => 96 | Bk => 97 | Cf => 98 | Es => 99
  | Fm => 100 | Md => 101 | No => 102 | Lr => 103 | Rf => 104 | Db => 105
  | Sg => 106 | Bh => 107 | Hs => 108 | Mt => 109 | Ds => 110 | Rg => 111
  | Cn => 112 | Nh => 113 | Fl => 114 | Mc => 115 | Lv => 116 | Ts => 117
  | Og => 118
  
  inductive Orbital 
  | s | p | d | f | g
  deriving Repr
  
  structure OrbitalConfig where
    n: Nat 
    l: Orbital
    electrons: Nat
  
  def get_electron_configuration (e: Element) : List OrbitalConfig :=
    sorry

vc-helpers: |-

vc-definitions: |-
  def sumElectrons (config: List OrbitalConfig) : Nat :=
    match config with
    | [] => 0
    | x :: xs => x.electrons + sumElectrons xs

vc-theorems: |-
  theorem electron_config_format (e: Element) (config: List OrbitalConfig):
    get_electron_configuration e = config →
    ∀ oc ∈ config, 
      oc.n > 0 ∧ 
      match oc.l with
      | Orbital.s => oc.electrons ≤ 2
      | Orbital.p => oc.electrons ≤ 6
      | Orbital.d => oc.electrons ≤ 10  
      | Orbital.f => oc.electrons ≤ 14
      | Orbital.g => oc.electrons ≤ 18
  := sorry
  
  theorem electron_count_conservation (e: Element):
    let config := get_electron_configuration e
    sumElectrons config = Element.toNat e := sorry
  
  theorem orbital_order (e: Element):
    let config := get_electron_configuration e
    ∀ i j, i ≤ j → i < config.length → j < config.length →
    (config.get ⟨i, sorry⟩).n ≤ (config.get ⟨j, sorry⟩).n := sorry
  
  theorem first_period (e: Element) :
    (e = Element.H ∨ e = Element.He) →
    let config := get_electron_configuration e
    ∀ oc ∈ config, oc.n = 1 ∧ oc.l = Orbital.s := sorry
  
  /-
  info: 'H -> 1s1'
  -/
  -- #guard_msgs in
  -- #eval get_electron_configuration "H"
  
  /-
  info: 'Cr -> 1s2 2s2 2p6 3s2 3p6 3d5 4s1'
  -/
  -- #guard_msgs in
  -- #eval get_electron_configuration "Cr"
  
  /-
  info: 'C -> 1s2 2s2 2p2'
  -/
  -- #guard_msgs in
  -- #eval get_electron_configuration "C"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

