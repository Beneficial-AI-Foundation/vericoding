vc-description: |-
  /-
  Write a function ```unpack()``` that unpacks a ```list``` of elements that can contain objects(`int`, `str`, `list`, `tuple`, `dict`, `set`) within each other without any predefined depth, meaning that there can be many levels of elements contained in one another.
  
  Example:
  
  ```python
  unpack([None, [1, ({2, 3}, {'foo': 'bar'})]]) == [None, 1, 2, 3, 'foo', 'bar']
  ```
  
  Note: you don't have to bother about the order of the elements, especially when unpacking a `dict` or a `set`. Just unpack all the elements.
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def unpack : NestedType → List (String ⊕ Int) := sorry
  
  def isNested : NestedType → Bool := sorry

vc-theorems: |-
  theorem unpack_flattens_nested : ∀ (x : NestedType),
    let result := unpack x
    -- Result is a list of non-nested values
    result.length > 0 := sorry
  
  theorem unpack_preserves_string : ∀ (s : String),
    unpack (NestedType.str s) = [Sum.inl s] := sorry 
  
  theorem unpack_preserves_list_ints : ∀ (lst : List Int),
    let nested := lst.map NestedType.int
    let result := unpack (NestedType.lst nested)
    -- All elements are preserved and length is preserved
    result.length = lst.length ∧
    ∀ (x : Int), x ∈ lst → Sum.inr x ∈ result := sorry
  
  /-
  info: expected2
  -/
  -- #guard_msgs in
  -- #eval sorted unpack(test2)

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

