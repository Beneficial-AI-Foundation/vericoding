vc-description: |-
  /-
  Given a binary tree, determine if it is a valid binary search tree (BST).
  
  Assume a BST is defined as follows:
  
         The left subtree of a node contains only nodes with keys less than the node's key.
         The right subtree of a node contains only nodes with keys greater than the node's key.
         Both the left and right subtrees must also be binary search trees.
  
  Example 1:
  
  Input:
      2
     / \
    1   3
  Output: true
  
  Example 2:
  
      5
     / \
    1   4
       / \
      3   6
  Output: false
  Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
               is 5 but its right child's value is 4.
  -/

vc-preamble: |-
  def isValidBST : TreeNode → Bool :=
    sorry
  
  def make_valid_bst : List Int → TreeNode :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def insertIntoBST : TreeNode → Int → TreeNode :=
    sorry

vc-theorems: |-
  theorem valid_bst_from_sorted_values (values : List Int) :
    isValidBST (make_valid_bst values) = true :=
    sorry
  
  theorem empty_tree_is_valid :
    isValidBST TreeNode.leaf = true :=
    sorry 
  
  theorem single_node_is_valid (value : Int) :
    isValidBST (TreeNode.node value TreeNode.leaf TreeNode.leaf) = true :=
    sorry
  
  theorem bst_remains_valid_after_insert (tree : TreeNode) (value : Int) :
    isValidBST tree = true →
    isValidBST (insertIntoBST tree value) = true :=
    sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval isValidBST TreeNode(2)
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval isValidBST TreeNode(5)
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval isValidBST TreeNode(1)

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

