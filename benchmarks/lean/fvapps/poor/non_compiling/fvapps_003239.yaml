vc-description: |-
  /-
  ## Check Digits
  
  Some numbers are more important to get right during data entry than others: a common example is product codes.
  
  To reduce the possibility of mistakes, product codes can be crafted in such a way that simple errors are detected. This is done by calculating a single-digit value based on the product number, and then appending that digit to the product number to arrive at the product code.
  
  When the product code is checked, the check digit value is stripped off and recalculated. If the supplied value does not match the recalculated value, the product code is rejected.
  
  A simple scheme for generating self-check digits, described here, is called Modulus 11 Self-Check.
  
  ## Calculation method
  
  Each digit in the product number is assigned a multiplication factor. The factors are assigned ***from right to left***, starting at `2` and counting up. For numbers longer than six digits, the factors restart at `2` after `7` is reached. The product of each digit and its factor is calculated, and the products summed. For example:
  
  ```python
  digit     :  1    6    7    7    0    3    6    2    5
  factor    :  4    3    2    7    6    5    4    3    2
             ---  ---  ---  ---  ---  ---  ---  ---  ---
               4 + 18 + 14 + 49 +  0 + 15 + 24 +  6 + 10 = 140
  ```
  
  Then the sum of the products is divided by the prime number `11`. The remainder is inspected, and:
  
  * if the remainder is `0`, the check digit is also `0`
  * if the remainder is `1`, the check digit is replaced by an uppercase `X`
  * for all others, the remainder is subtracted from `11`
  
  The result is the **check digit**.
  
  ## Your task
  
  Your task is to implement this algorithm and return the input number with the correct check digit appended.
  
  ## Examples
  
  ```python
  input: "036532"
  
  product sum = 2*2 + 3*3 + 5*4 + 6*5 + 3*6 + 0*7 = 81
  remainder   = 81 mod 11 = 4
  check digit = 11 - 4 = 7
  
  output: "0365327"
  ```
  -/

vc-preamble: |-
  def add_check_digit (num : String) : String := sorry
  
  -- Length property: result is one char longer and preserves input

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def mkFactors (n : Nat) : List Nat :=
    let base := [2,3,4,5,6,7]
    let repeats := n / 6 + 1
    List.join (List.replicate repeats base)
  
  -- Calculation property: check digit follows formula

vc-theorems: |-
  theorem check_digit_length
    (num : String)
    (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :
    let result := add_check_digit num
    (result.length = num.length + 1) ∧
    (result.dropRight 1 = num) := sorry
  
  -- Format property: last char is digit or X
  
  theorem check_digit_format
    (num : String)
    (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :
    let result := add_check_digit num
    let last := result.back
    (('0' ≤ last ∧ last ≤ '9') ∨ last = 'X') := sorry
  
  theorem check_digit_calculation
    (num : String)
    (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :
    let result := add_check_digit num
    let factors := mkFactors num.length
    let nums := num.toList.reverse.map (fun c => c.toNat - '0'.toNat)
    let products := List.zipWith (· * ·) nums factors
    let total := products.foldl (· + ·) 0
    let remainder := total % 11
    ((remainder = 0 → result.back = '0') ∧
     (remainder = 1 → result.back = 'X') ∧
     (remainder > 1 → result.back = (Char.ofNat ('0'.toNat + (11 - remainder))))) := sorry
  
  /-
  info: '0365327'
  -/
  -- #guard_msgs in
  -- #eval add_check_digit "036532"
  
  /-
  info: '123888782'
  -/
  -- #guard_msgs in
  -- #eval add_check_digit "12388878"
  
  /-
  info: '6789X'
  -/
  -- #guard_msgs in
  -- #eval add_check_digit "6789"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

