vc-description: |-
  /-
  Chef is given a sequence of prime numbers $A_1, A_2, \ldots, A_N$. This sequence has exactly $2^N$ subsequences. A subsequence of $A$ is good if it does not contain any two identical numbers; in particular, the empty sequence is good.
  Chef has to find the number of good subsequences which contain at most $K$ numbers. Since he does not know much about subsequences, help him find the answer. This number could be very large, so compute it modulo $1,000,000,007$.
  
  -----Input-----
  - The first line of the input contains two space-separated integers $N$ and $K$.
  - The second line contains $N$ space-separated integers $A_1, A_2, \ldots, A_N$.
  
  -----Output-----
  Print a single line containing one integer ― the number of good subsequences with size at most $K$, modulo $1,000,000,007$.
  
  -----Constraints-----
  - $1 \le K \le N \le 10^5$
  - $2 \le A_i \le 8,000$ for each valid $i$
  
  -----Subtasks-----
  Subtask #1 (40 points): $A_1, A_2, \ldots, A_N$ are pairwise distinct
  Subtask #2 (60 points): original constraints
  
  -----Example Input-----
  5 3
  2 2 3 3 5
  
  -----Example Output-----
  18
  
  -----Explanation-----
  There is $1$ good subsequence with length $0$, $5$ good subsequences with length $1$, $8$ good subsequences with length $2$ and $4$ good subsequences with length $3$.
  -/

vc-preamble: |-
  def List.sum : List Nat → Nat
  | [] => 0
  | (h::t) => h + List.sum t
  
  def solve (arr : List Nat) (n k : Nat) : Nat :=
    sorry
  
  def windowSum (arr : List Nat) (start len : Nat) : Nat :=
    (arr.take (start + len)).drop start |>.sum

vc-helpers: |-

vc-definitions: |-
  def countWindows (arr : List Nat) (n k : Nat) : Nat :=
    let windows := List.range (n - k + 1)
    windows.filter (fun i => windowSum arr i k = k) |>.length

vc-theorems: |-
  theorem solve_basic_properties 
    (arr : List Nat) 
    (n k : Nat)
    (h1 : ∀ x ∈ arr, x ≤ 1)
    (h2 : k ≤ n)
    (h3 : n = arr.length) :
    let result := solve arr n k
    -- Result is non-negative
    (result ≥ 0) ∧ 
    -- Result does not exceed max possible windows
    (result ≤ n - k + 1) ∧
    -- For k=1, result equals sum of array
    (k = 1 → result = List.sum arr) ∧
    -- For array of all 1s, result equals n-k+1
    ((∀ x ∈ arr, x = 1) → result = n - k + 1) :=
    sorry
  
  theorem solve_equals_manual_count
    (arr : List Nat)
    (n k : Nat) 
    (h1 : ∀ x ∈ arr, x ≤ 1)
    (h2 : k ≤ n)
    (h3 : n = arr.length)
    (h4 : n > 0) :
    solve arr n k = countWindows arr n k :=
    sorry
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval solve [1, 1, 0, 1] 4 2
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval solve [1, 1, 1] 3 2
  
  /-
  info: 5
  -/
  -- #guard_msgs in
  -- #eval solve [1, 1, 1, 1, 1, 0, 1, 1, 1, 1] 10 3

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

