vc-description: |-
  /-
  It is lunch time for Mole. His friend, Marmot, prepared him a nice game for lunch.
  
  Marmot brought Mole n ordered piles of worms such that i-th pile contains a_{i} worms. He labeled all these worms with consecutive integers: worms in first pile are labeled with numbers 1 to a_1, worms in second pile are labeled with numbers a_1 + 1 to a_1 + a_2 and so on. See the example for a better understanding.
  
  Mole can't eat all the worms (Marmot brought a lot) and, as we all know, Mole is blind, so Marmot tells him the labels of the best juicy worms. Marmot will only give Mole a worm if Mole says correctly in which pile this worm is contained.
  
  Poor Mole asks for your help. For all juicy worms said by Marmot, tell Mole the correct answers.
  
  -----Input-----
  
  The first line contains a single integer n (1 ≤ n ≤ 10^5), the number of piles.
  
  The second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^3, a_1 + a_2 + ... + a_{n} ≤ 10^6), where a_{i} is the number of worms in the i-th pile.
  
  The third line contains single integer m (1 ≤ m ≤ 10^5), the number of juicy worms said by Marmot.
  
  The fourth line contains m integers q_1, q_2, ..., q_{m} (1 ≤ q_{i} ≤ a_1 + a_2 + ... + a_{n}), the labels of the juicy worms.
  
  -----Output-----
  
  Print m lines to the standard output. The i-th line should contain an integer, representing the number of the pile where the worm labeled with the number q_{i} is.
  
  -----Examples-----
  Input
  5
  2 7 3 4 9
  3
  1 25 11
  
  Output
  1
  5
  3
  
  -----Note-----
  
  For the sample input:
  
    The worms with labels from [1, 2] are in the first pile.  The worms with labels from [3, 9] are in the second pile.  The worms with labels from [10, 12] are in the third pile.  The worms with labels from [13, 16] are in the fourth pile.  The worms with labels from [17, 25] are in the fifth pile.
  -/

vc-preamble: |-
  def List.sum (xs : List Nat) : Nat :=
    match xs with
    | [] => 0
    | x :: xs => x + List.sum xs

vc-helpers: |-

vc-definitions: |-
  def find_pile_numbers (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat) : List Nat :=
    sorry
  
  -- Properties about length and valid pile numbers

vc-theorems: |-
  theorem find_pile_nums_length (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)
      (h1 : pile_sizes.length = n)
      (h2 : labels.length = m)
      (h3 : n > 0)
      (h4 : m > 0)
      (h5 : ∀ x ∈ pile_sizes, x > 0)
      (h6 : ∀ x ∈ labels, x > 0) :
      (find_pile_numbers n pile_sizes m labels).length = labels.length :=
    sorry
  
  theorem find_pile_nums_valid_output (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)
      (h1 : pile_sizes.length = n)
      (h2 : labels.length = m)
      (h3 : n > 0)
      (h4 : m > 0)
      (h5 : ∀ x ∈ pile_sizes, x > 0)
      (h6 : ∀ x ∈ labels, x > 0) :
      ∀ x ∈ find_pile_numbers n pile_sizes m labels, 1 ≤ x ∧ x ≤ n :=
    sorry
  
  -- Property about correct pile indices based on prefix sums
  
  theorem find_pile_nums_correct_indices (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)
      (h1 : pile_sizes.length = n)
      (h2 : labels.length = m)
      (h3 : n > 0)
      (h4 : m > 0)
      (h5 : ∀ x ∈ pile_sizes, x > 0)
      (h6 : ∀ x ∈ labels, x > 0) :
      ∀ (i : Nat) (label : Nat) (pile_num : Nat),
        (label ∈ labels) →
        (pile_num ∈ find_pile_numbers n pile_sizes m labels) →
        label ≤ (List.take i pile_sizes).sum →
        pile_num ≤ i :=
    sorry
  
  -- Property about identical labels mapping to same pile
  
  theorem find_pile_nums_identical_labels (n : Nat) (pile_sizes : List Nat) (label : Nat)
      (h1 : pile_sizes.length = n)
      (h2 : n > 0)
      (h3 : ∀ x ∈ pile_sizes, x > 0)
      (h4 : label > 0) :
      let labels := List.replicate 3 label
      let result := find_pile_numbers n pile_sizes 3 labels
      ∀ (x y : Nat), x ∈ result → y ∈ result → x = y :=
    sorry
  
  -- Property about single pile case
  
  theorem find_pile_nums_single_pile (pile_size : Nat)
      (h : pile_size > 0) :
      find_pile_numbers 1 [pile_size] 1 [1] = [1] :=
    sorry
  
  /-
  info: [1, 5, 3]
  -/
  -- #guard_msgs in
  -- #eval find_pile_numbers 5 [2, 7, 3, 4, 9] 3 [1, 25, 11]
  
  /-
  info: [2, 3]
  -/
  -- #guard_msgs in
  -- #eval find_pile_numbers 3 [1, 2, 3] 2 [2, 6]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

