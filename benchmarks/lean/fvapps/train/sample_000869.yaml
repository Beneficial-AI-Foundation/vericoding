"vc-description": "Chef recently developed an affinity for undirected graphs.\nHe\
  \ likes pairs of graphs that are similar in structure.\nHowever, Chef discovered\
  \ that when the vertices of a graph are reorganized, it's often the case that the\
  \ resulting graph,\nalthough still structurally similar to the original, can look\
  \ completely different.\nChef wants you to help him find similarities in pairs of\
  \ graphs.\n\nChef only considers pairs of graphs where each graph has the same number\
  \ of vertices (say N).\nChef then labels each vertex of each graph with an integer\
  \ between 1 and N (inclusive),\nusing each integer exactly once per graph.\nChef\
  \ then defines the similarity of the graphs as 2*COMMON/TOTAL, where COMMON is the\
  \ number of\nedges appearing in both graphs \n(that is, the number of unordered\
  \ pairs {A, B} such that in both graphs there exists an edge between the vertex\
  \ labelled A\nand the vertex labelled B), and TOTAL is the total number of edges\
  \ in both graphs.\n\nChef's measure of similarity depends on how the vertices are\
  \ labelled.\nChef wants you to help him find a labelling that maximizes the similarity.\n\
  Optimal solutions are not required, but better solutions will earn more points.\n\
  \n-----Input-----\n\nInput will begin with an integer T, the number of test cases.\n\
  Each test case will begin with an integer N, the number of vertices in both graphs.\n\
  2*N lines follow.  The first N lines describe the first graph, and the next N lines\
  \ the second graph.\nEach graph description consists of N lines of N integers each.\n\
  The i-th integer on the j-th line will be 1 if there is an edge between vertices\
  \ i and j, and 0 otherwise.\nThe i-th integer on the j-th line will always be equal\
  \ to the j-th integer on the i-th line,\nand the i-th integer on the i-th line will\
  \ always be 0.\n\n-----Output-----\n\nFor each test case, output 2 lines with N\
  \ integers each.\nEach line must contain a permutation of the integers 1 through\
  \ N, and indicates how Chef should label the corresponding graph.\n\n-----Scoring-----\n\
  \nYour score for each test case is the similarity of the 2 graphs using the labelling\
  \ you provide.\nYour overall score is the average of your scores on the individual\
  \ test cases.\n\n-----Sample Input-----\n2\n3\n0 1 0\n1 0 0\n0 0 0\n0 0 1\n0 0 1\n\
  1 1 0\n4\n0 0 1 0\n0 0 0 0\n1 0 0 1\n0 0 1 0\n0 0 1 1\n0 0 0 0\n1 0 0 0\n1 0 0 0\n\
  \n-----Sample Output-----\n1 2 3\n1 2 3\n1 4 2 3\n2 4 1 3\n\nThis output would score\
  \ 2*0/3 = 0.0 on the first test case, and 2*2/4 = 1.0 on the second test case, for\
  \ an overall score of 0.5.\nNote that better scores are possible.\n\n-----Test case\
  \ generation-----\n\nFor each official test file, T is 5.\nFor each test case, N\
  \ is randomly chosen between 30 and 75.\nA real number D is randomly chosen between\
  \ 0.05 and 0.5.\nFor each pair of vertices, an edge is added with probability D.\n\
  This graph is output as the first graph.\nAn integer C is randomly chosen between\
  \ 0 and N*(N-1)/2.\nC distinct pairs of vertices are chosen.\nFor each pair, if\
  \ an edge currently exists between them, the edge is removed with probability (1-D).\n\
  If no edge exists between them, one is added with probability D.\nThen, a random\
  \ permutation is applied to the vertices of the graph, and it is output as the second\
  \ graph.\nYou may safely assume there will be no test cases where TOTAL is 0."
"vc-preamble": "import Imports.AllImports\n\ndef Matrix (α : Type) := List (List α)\n\
  def LabelList := List Nat\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_graph_similarity (n : Nat) (g1 : Matrix Nat) (g2 : Matrix\
  \ Nat) : LabelList × LabelList :=\n  sorry\n"
"vc-theorems": "theorem solve_graph_similarity_output_length {n : Nat} {g1 g2 : Matrix\
  \ Nat}:\n  let (r1, r2) := solve_graph_similarity n g1 g2\n  r1.length = n ∧ r2.length\
  \ = n :=\n  sorry\n\n\ntheorem solve_graph_similarity_output_values {n : Nat} {g1\
  \ g2 : Matrix Nat}:\n  let (r1, r2) := solve_graph_similarity n g1 g2\n  r1.foldl\
  \ (fun acc x => x::acc) [] = List.range n ∧ \n  r2.foldl (fun acc x => x::acc) []\
  \ = List.range n :=\n  sorry\n\n\ntheorem solve_graph_similarity_r1_equals_range\
  \ {n : Nat} {g1 g2 : Matrix Nat}:\n  let (r1, _) := solve_graph_similarity n g1\
  \ g2\n  r1 = List.range n :=\n  sorry\n\n/--\ninfo: n1\n-/\n#guard_msgs in\n#eval\
  \ len r1\n\n/--\ninfo: n1\n-/\n#guard_msgs in\n#eval len r2\n\n/--\ninfo: list(range(1,\
  \ n1 + 1))\n-/\n#guard_msgs in\n#eval sorted r1\n\n/--\ninfo: list(range(1, n1 +\
  \ 1))\n-/\n#guard_msgs in\n#eval sorted r2\n\n/--\ninfo: n2\n-/\n#guard_msgs in\n\
  #eval len r3\n\n/--\ninfo: n2\n-/\n#guard_msgs in\n#eval len r4\n\n/--\ninfo: list(range(1,\
  \ n2 + 1))\n-/\n#guard_msgs in\n#eval sorted r3\n\n/--\ninfo: list(range(1, n2 +\
  \ 1))\n-/\n#guard_msgs in\n#eval sorted r4\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
