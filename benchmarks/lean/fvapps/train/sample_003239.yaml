"vc-description": "## Check Digits\n\nSome numbers are more important to get right\
  \ during data entry than others: a common example is product codes.\n\nTo reduce\
  \ the possibility of mistakes, product codes can be crafted in such a way that simple\
  \ errors are detected. This is done by calculating a single-digit value based on\
  \ the product number, and then appending that digit to the product number to arrive\
  \ at the product code.\n\nWhen the product code is checked, the check digit value\
  \ is stripped off and recalculated. If the supplied value does not match the recalculated\
  \ value, the product code is rejected.\n\nA simple scheme for generating self-check\
  \ digits, described here, is called Modulus 11 Self-Check.\n\n## Calculation method\n\
  \nEach digit in the product number is assigned a multiplication factor. The factors\
  \ are assigned ***from right to left***, starting at `2` and counting up. For numbers\
  \ longer than six digits, the factors restart at `2` after `7` is reached. The product\
  \ of each digit and its factor is calculated, and the products summed. For example:\n\
  \n```python\ndigit     :  1    6    7    7    0    3    6    2    5\nfactor    :\
  \  4    3    2    7    6    5    4    3    2\n           ---  ---  ---  ---  ---\
  \  ---  ---  ---  ---\n             4 + 18 + 14 + 49 +  0 + 15 + 24 +  6 + 10 =\
  \ 140\n```\n\nThen the sum of the products is divided by the prime number `11`.\
  \ The remainder is inspected, and:\n\n* if the remainder is `0`, the check digit\
  \ is also `0`\n* if the remainder is `1`, the check digit is replaced by an uppercase\
  \ `X`\n* for all others, the remainder is subtracted from `11`\n\nThe result is\
  \ the **check digit**.\n\n## Your task\n\nYour task is to implement this algorithm\
  \ and return the input number with the correct check digit appended.\n\n## Examples\n\
  \n```python\ninput: \"036532\"\n\nproduct sum = 2*2 + 3*3 + 5*4 + 6*5 + 3*6 + 0*7\
  \ = 81\nremainder   = 81 mod 11 = 4\ncheck digit = 11 - 4 = 7\n\noutput: \"0365327\"\
  \n```"
"vc-preamble": "import Imports.AllImports\n\ndef add_check_digit (num : String) :\
  \ String := sorry\n\n-- Length property: result is one char longer and preserves\
  \ input"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def mkFactors (n : Nat) : List Nat :=\n  let base := [2,3,4,5,6,7]\n\
  \  let repeats := n / 6 + 1\n  List.join (List.replicate repeats base)\n\n-- Calculation\
  \ property: check digit follows formula"
"vc-theorems": "theorem check_digit_length\n  (num : String)\n  (h : num.all (fun\
  \ c => '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n  (result.length\
  \ = num.length + 1) ∧\n  (result.dropRight 1 = num) := sorry\n\n-- Format property:\
  \ last char is digit or X\n\ntheorem check_digit_format\n  (num : String)\n  (h\
  \ : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n\
  \  let last := result.back\n  (('0' ≤ last ∧ last ≤ '9') ∨ last = 'X') := sorry\n\
  \n\ntheorem check_digit_calculation\n  (num : String)\n  (h : num.all (fun c =>\
  \ '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n  let factors := mkFactors\
  \ num.length\n  let nums := num.toList.reverse.map (fun c => c.toNat - '0'.toNat)\n\
  \  let products := List.zipWith (· * ·) nums factors\n  let total := products.foldl\
  \ (· + ·) 0\n  let remainder := total % 11\n  ((remainder = 0 → result.back = '0')\
  \ ∧\n   (remainder = 1 → result.back = 'X') ∧\n   (remainder > 1 → result.back =\
  \ (Char.ofNat ('0'.toNat + (11 - remainder))))) := sorry\n\n/--\ninfo: '0365327'\n\
  -/\n#guard_msgs in\n#eval add_check_digit \"036532\"\n\n/--\ninfo: '123888782'\n\
  -/\n#guard_msgs in\n#eval add_check_digit \"12388878\"\n\n/--\ninfo: '6789X'\n-/\n\
  #guard_msgs in\n#eval add_check_digit \"6789\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
