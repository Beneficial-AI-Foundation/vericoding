"vc-description": "Write a program to find the remainder when an integer A is divided\
  \ by an integer B.\n\n-----Input-----\n\nThe first line contains an integer T, the\
  \ total number of test cases. Then T lines follow, each line contains two Integers\
  \ A and B. \n\n-----Output-----\nFor each test case, find the remainder when A is\
  \ divided by  B, and display it in a new line.\n\n-----Constraints-----\n- 1 ≤ T\
  \ ≤ 1000\n- 1 ≤ A,B ≤ 10000\n\n-----Example-----\nInput\n3 \n1 2\n100 200\n40 15\n\
  \nOutput\n1\n100\n10"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_remainders (cases : List String) : List Nat := sorry\n\
  \n/-- For any list of test cases, the length of results matches the input length\
  \ -/"
"vc-theorems": "theorem find_remainders_length (cases : List String) : \n  (find_remainders\
  \ cases).length = cases.length := sorry\n\n/-- Each remainder in the result is correctly\
  \ computed -/\n\ntheorem find_remainders_correct (test_case : String) (a b : Nat)\
  \ (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 → \n  find_remainders [test_case]\
  \ = [a % b] := sorry\n\n/-- All remainders are non-negative and less than their\
  \ divisors -/\n\ntheorem find_remainders_bounds (test_case : String) (a b : Nat)\
  \ (h : test_case = s!\"{a} {b}\") :\n  b > 0 → a > 0 →\n  let r := (find_remainders\
  \ [test_case]).head!\n  0 ≤ r ∧ r < b := sorry\n\n/-- Division by one always yields\
  \ zero remainder -/\n\ntheorem find_remainders_div_by_one (a : Nat) (h : a > 0)\
  \ :\n  find_remainders [s!\"{a} 1\"] = [0] := sorry\n\n/--\ninfo: [1, 100, 10]\n\
  -/\n#guard_msgs in\n#eval find_remainders [\"1 2\", \"100 200\", \"40 15\"]\n\n\
  /--\ninfo: [1]\n-/\n#guard_msgs in\n#eval find_remainders [\"7 3\"]\n\n/--\ninfo:\
  \ [0, 3]\n-/\n#guard_msgs in\n#eval find_remainders [\"10 2\", \"15 4\"]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
