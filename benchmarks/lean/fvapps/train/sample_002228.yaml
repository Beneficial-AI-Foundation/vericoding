"vc-description": "Consider the infinite sequence $s$ of positive integers, created\
  \ by repeating the following steps:\n\n  Find the lexicographically smallest triple\
  \ of positive integers $(a, b, c)$ such that   $a \\oplus b \\oplus c = 0$, where\
  \ $\\oplus$ denotes the bitwise XOR operation.  $a$, $b$, $c$ are not in $s$.  Here\
  \ triple of integers $(a_1, b_1, c_1)$ is considered to be lexicographically smaller\
  \ than triple $(a_2, b_2, c_2)$ if sequence $[a_1, b_1, c_1]$ is lexicographically\
  \ smaller than sequence $[a_2, b_2, c_2]$.  Append $a$, $b$, $c$ to $s$ in this\
  \ order.  Go back to the first step. \n\nYou have integer $n$. Find the $n$-th element\
  \ of $s$.\n\nYou have to answer $t$ independent test cases.\n\nA sequence $a$ is\
  \ lexicographically smaller than a sequence $b$ if in the first position where $a$\
  \ and $b$ differ, the sequence $a$ has a smaller element than the corresponding\
  \ element in $b$.\n\n\n-----Input-----\n\nThe first line contains a single integer\
  \ $t$ ($1 \\le t \\le 10^5$) — the number of test cases.\n\nEach of the next $t$\
  \ lines contains a single integer $n$ ($1\\le n \\le 10^{16}$) — the position of\
  \ the element you want to know.\n\n\n-----Output-----\n\nIn each of the $t$ lines,\
  \ output the answer to the corresponding test case.\n\n\n-----Example-----\nInput\n\
  9\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\nOutput\n1\n2\n3\n4\n8\n12\n5\n10\n15\n\n\n\n-----Note-----\n\
  \nThe first elements of $s$ are $1, 2, 3, 4, 8, 12, 5, 10, 15, \\dots $"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_nth_element (n : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem output_is_positive (n : Nat) (h : n > 0) : \n  find_nth_element\
  \ n > 0 := sorry\n\n\ntheorem output_increases_in_groups_of_three (n : Nat) (h :\
  \ n > 0) (h2 : n ≤ 100) :\n  let group_start := ((n-1) / 3) * 3 + 1\n  find_nth_element\
  \ group_start < find_nth_element (group_start + 1) ∧ \n  find_nth_element (group_start\
  \ + 1) < find_nth_element (group_start + 2) := sorry\n\n\ntheorem output_ratio_bounds\
  \ (n : Nat) (h : n > 0) :\n  find_nth_element n ≤ 4 * n ∧ \n  find_nth_element n\
  \ ≥ n / 3 := sorry\n\n\ntheorem binary_length_property (n : Nat) (h : n > 0) :\n\
  \  Nat.log2 (find_nth_element n) + 1 ≥ (Nat.log2 n + 1) / 2 := sorry\n\n\ntheorem\
  \ first_few_values :\n  find_nth_element 1 = 1 ∧\n  find_nth_element 2 = 2 ∧ \n\
  \  find_nth_element 3 = 3 ∧\n  find_nth_element 4 = 4 := sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
