"vc-description": "Your country has an infinite number of lakes. Initially, all the\
  \ lakes are empty, but when it rains over the nth lake, the nth lake becomes full\
  \ of water. If it rains over a lake which is full of water, there will be a flood.\
  \ Your goal is to avoid the flood in any lake.\nGiven an integer array rains where:\n\
  \nrains[i] > 0 means there will be rains over the rains[i] lake.\nrains[i] == 0\
  \ means there are no rains this day and you can choose one lake this day and dry\
  \ it.\n\nReturn an array ans where:\n\nans.length == rains.length\nans[i] == -1\
  \ if rains[i] > 0.\nans[i] is the lake you choose to dry in the ith day if rains[i]\
  \ == 0.\n\nIf there are multiple valid answers return any of them. If it is impossible\
  \ to avoid flood return an empty array.\nNotice that if you chose to dry a full\
  \ lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.\
  \ (see example 4)\n \nExample 1:\nInput: rains = [1,2,3,4]\nOutput: [-1,-1,-1,-1]\n\
  Explanation: After the first day full lakes are [1]\nAfter the second day full lakes\
  \ are [1,2]\nAfter the third day full lakes are [1,2,3]\nAfter the fourth day full\
  \ lakes are [1,2,3,4]\nThere's no day to dry any lake and there is no flood in any\
  \ lake.\n\nExample 2:\nInput: rains = [1,2,0,0,2,1]\nOutput: [-1,-1,2,1,-1,-1]\n\
  Explanation: After the first day full lakes are [1]\nAfter the second day full lakes\
  \ are [1,2]\nAfter the third day, we dry lake 2. Full lakes are [1]\nAfter the fourth\
  \ day, we dry lake 1. There is no full lakes.\nAfter the fifth day, full lakes are\
  \ [2].\nAfter the sixth day, full lakes are [1,2].\nIt is easy that this scenario\
  \ is flood-free. [-1,-1,1,2,-1,-1] is another acceptable scenario.\n\nExample 3:\n\
  Input: rains = [1,2,0,1,2]\nOutput: []\nExplanation: After the second day, full\
  \ lakes are  [1,2]. We have to dry one lake in the third day.\nAfter that, it will\
  \ rain over lakes [1,2]. It's easy to prove that no matter which lake you choose\
  \ to dry in the 3rd day, the other one will flood.\n\nExample 4:\nInput: rains =\
  \ [69,0,0,0,69]\nOutput: [-1,69,1,1,-1]\nExplanation: Any solution on one of the\
  \ forms [-1,69,x,y,-1], [-1,x,69,y,-1] or [-1,x,y,69,-1] is acceptable where 1 <=\
  \ x,y <= 10^9\n\nExample 5:\nInput: rains = [10,20,20]\nOutput: []\nExplanation:\
  \ It will rain over lake 20 two consecutive days. There is no chance to dry any\
  \ lake.\n\n \nConstraints:\n\n1 <= rains.length <= 10^5\n0 <= rains[i] <= 10^9"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def avoid_flood (rains : List Nat) : List Int := sorry\n\ntheorem\
  \ avoid_flood_length {rains : List Nat} {result : List Int}\n  (h : result = avoid_flood\
  \ rains) (h_valid : result ≠ []) :\n  result.length = rains.length := sorry\n"
"vc-theorems": "theorem avoid_flood_rain_days {rains : List Nat} {result : List Int}\n\
  \  (h : result = avoid_flood rains) (h_valid : result ≠ []) (h_len : result.length\
  \ = rains.length) :\n  ∀ i : Fin rains.length, rains[i] > 0 → result[i] = -1 :=\
  \ sorry\n\n\ntheorem avoid_flood_dry_days {rains : List Nat} {result : List Int}\n\
  \  (h : result = avoid_flood rains) (h_valid : result ≠ []) (h_len : result.length\
  \ = rains.length) :\n  ∀ i : Fin rains.length, rains[i] = 0 → result[i] > 0 := sorry\n\
  \n\ntheorem avoid_flood_no_flooding {rains : List Nat} {result : List Int}\n  (h\
  \ : result = avoid_flood rains) (h_valid : result ≠ []) (h_len : result.length =\
  \ rains.length) :\n  ∀ i j : Fin rains.length, i.val < j.val →\n  rains[i] > 0 →\
  \ rains[i] = rains[j] →\n  ∃ k : Fin rains.length, i.val < k.val ∧ k.val < j.val\
  \ ∧ rains[k] = 0 ∧ result[k] = rains[i] := sorry\n\n\ntheorem avoid_flood_no_solution_implies_flooding\
  \ {rains : List Nat} \n  (h : avoid_flood rains = []) :\n  ∃ i j : Fin rains.length,\
  \ i.val < j.val ∧\n  rains[i] > 0 ∧ rains[i] = rains[j] ∧\n  (∀ k : Fin rains.length,\
  \ i.val < k.val → k.val < j.val → rains[k] ≠ 0) := sorry\n\n\ntheorem avoid_flood_all_dry\
  \ {rains : List Nat}\n  (h : ∀ i : Fin rains.length, rains[i] = 0) :\n  ∀ x ∈ avoid_flood\
  \ rains, x > 0 := sorry\n\n\ntheorem avoid_flood_all_rain {rains : List Nat}\n \
  \ (h : ∀ i : Fin rains.length, rains[i] > 0) :\n  (∀ i j : Fin rains.length, i.val\
  \ ≠ j.val → rains[i] ≠ rains[j] → \n    avoid_flood rains = List.replicate rains.length\
  \ (-1)) ∧\n  (∃ i j : Fin rains.length, i.val ≠ j.val ∧ rains[i] = rains[j] → \n\
  \    avoid_flood rains = []) := sorry\n\n/--\ninfo: [-1, -1, -1, -1]\n-/\n#guard_msgs\
  \ in\n#eval avoid_flood [1, 2, 3, 4]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval\
  \ avoid_flood [1, 2, 0, 1, 2]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
