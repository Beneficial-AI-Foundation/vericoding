"vc-description": "You are given a permutation $p=[p_1, p_2, \\ldots, p_n]$ of integers\
  \ from $1$ to $n$. Let's call the number $m$ ($1 \\le m \\le n$) beautiful, if there\
  \ exists two indices $l, r$ ($1 \\le l \\le r \\le n$), such that the numbers $[p_l,\
  \ p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots, m$.\n\nFor\
  \ example, let $p = [4, 5, 1, 3, 2, 6]$. In this case, the numbers $1, 3, 5, 6$\
  \ are beautiful and $2, 4$ are not. It is because:  if $l = 3$ and $r = 3$ we will\
  \ have a permutation $[1]$ for $m = 1$;  if $l = 3$ and $r = 5$ we will have a permutation\
  \ $[1, 3, 2]$ for $m = 3$;  if $l = 1$ and $r = 5$ we will have a permutation $[4,\
  \ 5, 1, 3, 2]$ for $m = 5$;  if $l = 1$ and $r = 6$ we will have a permutation $[4,\
  \ 5, 1, 3, 2, 6]$ for $m = 6$;  it is impossible to take some $l$ and $r$, such\
  \ that $[p_l, p_{l+1}, \\ldots, p_r]$ is a permutation of numbers $1, 2, \\ldots,\
  \ m$ for $m = 2$ and for $m = 4$. \n\nYou are given a permutation $p=[p_1, p_2,\
  \ \\ldots, p_n]$. For all $m$ ($1 \\le m \\le n$) determine if it is a beautiful\
  \ number or not.\n\n\n-----Input-----\n\nThe first line contains the only integer\
  \ $t$ ($1 \\le t \\le 1000$)  — the number of test cases in the input. The next\
  \ lines contain the description of test cases.\n\nThe first line of a test case\
  \ contains a number $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the length of the given\
  \ permutation $p$. The next line contains $n$ integers $p_1, p_2, \\ldots, p_n$\
  \ ($1 \\le p_i \\le n$, all $p_i$ are different) — the given permutation $p$.\n\n\
  It is guaranteed, that the sum of $n$ from all test cases in the input doesn't exceed\
  \ $2 \\cdot 10^5$.\n\n\n-----Output-----\n\nPrint $t$ lines — the answers to test\
  \ cases in the order they are given in the input. \n\nThe answer to a test case\
  \ is the string of length $n$, there the $i$-th character is equal to $1$ if $i$\
  \ is a beautiful number and is equal to $0$ if $i$ is not a beautiful number.\n\n\
  \n-----Example-----\nInput\n3\n6\n4 5 1 3 2 6\n5\n5 3 1 2 4\n4\n1 4 3 2\n\nOutput\n\
  101011\n11111\n1001\n\n\n\n-----Note-----\n\nThe first test case is described in\
  \ the problem statement.\n\nIn the second test case all numbers from $1$ to $5$\
  \ are beautiful:  if $l = 3$ and $r = 3$ we will have a permutation $[1]$ for $m\
  \ = 1$;  if $l = 3$ and $r = 4$ we will have a permutation $[1, 2]$ for $m = 2$;\
  \  if $l = 2$ and $r = 4$ we will have a permutation $[3, 1, 2]$ for $m = 3$;  if\
  \ $l = 2$ and $r = 5$ we will have a permutation $[3, 1, 2, 4]$ for $m = 4$;  if\
  \ $l = 1$ and $r = 5$ we will have a permutation $[5, 3, 1, 2, 4]$ for $m = 5$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_beautiful_permutation (nums : List Nat) : List Nat :=\
  \ sorry\n\ntheorem solve_first_pos_beautiful (nums : List Nat) \n  (h : nums.length\
  \ = 5) \n  (h2 : nums.Perm [1,2,3,4,5]) : \n  (solve_beautiful_permutation nums).get!\
  \ 0 = 1 := sorry\n"
"vc-theorems": "theorem solve_preserves_length (nums : List Nat)  \n  (h : nums.length\
  \ = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  (solve_beautiful_permutation nums).length\
  \ = nums.length := sorry \n\n\ntheorem solve_returns_binary (nums : List Nat)\n\
  \  (h : nums.length = 5)\n  (h2 : nums.Perm [1,2,3,4,5]) :\n  ∀ x ∈ solve_beautiful_permutation\
  \ nums, x = 0 ∨ x = 1 := sorry\n\n/--\ninfo: '101011'\n-/\n#guard_msgs in\n#eval\
  \ solve_beautiful_permutation [4, 5, 1, 3, 2, 6]\n\n/--\ninfo: '11111'\n-/\n#guard_msgs\
  \ in\n#eval solve_beautiful_permutation [5, 3, 1, 2, 4]\n\n/--\ninfo: '1001'\n-/\n\
  #guard_msgs in\n#eval solve_beautiful_permutation [1, 4, 3, 2]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
