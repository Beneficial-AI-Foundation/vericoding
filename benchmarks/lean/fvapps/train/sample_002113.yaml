"vc-description": "You have unweighted tree of $n$ vertices. You have to assign a\
  \ positive weight to each edge so that the following condition would hold:\n\n \
  \ For every two different leaves $v_{1}$ and $v_{2}$ of this tree, bitwise XOR of\
  \ weights of all edges on the simple path between $v_{1}$ and $v_{2}$ has to be\
  \ equal to $0$. \n\nNote that you can put very large positive integers (like $10^{(10^{10})}$).\n\
  \nIt's guaranteed that such assignment always exists under given constraints. Now\
  \ let's define $f$ as the number of distinct weights in assignment.\n\n [Image]\
  \ In this example, assignment is valid, because bitwise XOR of all edge weights\
  \ between every pair of leaves is $0$. $f$ value is $2$ here, because there are\
  \ $2$ distinct edge weights($4$ and $5$).\n\n[Image] In this example, assignment\
  \ is invalid, because bitwise XOR of all edge weights between vertex $1$ and vertex\
  \ $6$ ($3, 4, 5, 4$) is not $0$. \n\nWhat are the minimum and the maximum possible\
  \ values of $f$ for the given tree? Find and print both.\n\n\n-----Input-----\n\n\
  The first line contains integer $n$ ($3 \\le n \\le 10^{5}$) — the number of vertices\
  \ in given tree.\n\nThe $i$-th of the next $n-1$ lines contains two integers $a_{i}$\
  \ and $b_{i}$ ($1 \\le a_{i} \\lt b_{i} \\le n$) — it means there is an edge between\
  \ $a_{i}$ and $b_{i}$. It is guaranteed that given graph forms tree of $n$ vertices.\n\
  \n\n-----Output-----\n\nPrint two integers — the minimum and maximum possible value\
  \ of $f$ can be made from valid assignment of given tree. Note that it's always\
  \ possible to make an assignment under given constraints.\n\n\n-----Examples-----\n\
  Input\n6\n1 3\n2 3\n3 4\n4 5\n5 6\n\nOutput\n1 4\n\nInput\n6\n1 3\n2 3\n3 4\n4 5\n\
  4 6\n\nOutput\n3 3\n\nInput\n7\n1 2\n2 7\n3 4\n4 7\n5 6\n6 7\n\nOutput\n1 6\n\n\n\
  \n-----Note-----\n\nIn the first example, possible assignments for each minimum\
  \ and maximum are described in picture below. Of course, there are multiple possible\
  \ assignments for each minimum and maximum.  [Image] \n\nIn the second example,\
  \ possible assignments for each minimum and maximum are described in picture below.\
  \ The $f$ value of valid assignment of this tree is always $3$.  [Image] \n\nIn\
  \ the third example, possible assignments for each minimum and maximum are described\
  \ in picture below. Of course, there are multiple possible assignments for each\
  \ minimum and maximum.  [Image]"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Edge := Nat × Nat\n\ndef solve (n : Nat) (edges : List Edge)\
  \ : Nat × Nat :=\n  sorry\n\nstructure IsValidTree (n : Nat) (edges : List Edge)\
  \ : Prop where\n  edge_count : edges.length = n - 1\n  valid_vertices : ∀ (e : Edge),\
  \ e ∈ edges → 1 ≤ e.1 ∧ e.1 ≤ n ∧ 1 ≤ e.2 ∧ e.2 ≤ n\n  is_acyclic : ∀ e ∈ edges,\
  \ True -- placeholder for acyclic property\n  is_connected : ∀ e ∈ edges, True --\
  \ placeholder for connected property\n"
"vc-theorems": "theorem solve_type_output {n : Nat} {edges : List Edge}\n  (h : IsValidTree\
  \ n edges) :\n  let (mn, mx) := solve n edges\n  mn ∈ [1, 3] ∧ 1 ≤ mn ∧ mn ≤ mx\
  \ ∧ mx ≤ n - 1 :=\n  sorry\n\n\ntheorem solve_output_natural {n : Nat} {edges :\
  \ List Edge}\n  (h : IsValidTree n edges) :\n  let (mn, mx) := solve n edges\n \
  \ Nat.zero ≤ mn ∧ Nat.zero ≤ mx :=\n  sorry\n\n/--\ninfo: (1, 4)\n-/\n#guard_msgs\
  \ in\n#eval solve 6 [(1, 3), (2, 3), (3, 4), (4, 5), (5, 6)]\n\n/--\ninfo: (3, 3)\n\
  -/\n#guard_msgs in\n#eval solve 6 [(1, 3), (2, 3), (3, 4), (4, 5), (4, 6)]\n\n/--\n\
  info: (1, 6)\n-/\n#guard_msgs in\n#eval solve 7 [(1, 2), (2, 7), (3, 4), (4, 7),\
  \ (5, 6), (6, 7)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
