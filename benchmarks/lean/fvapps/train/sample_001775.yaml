"vc-description": "You are given a series of video clips from a sporting event that\
  \ lasted T seconds.  These video clips can be overlapping with each other and have\
  \ varied lengths.\nEach video clip clips[i] is an interval: it starts at time clips[i][0]\
  \ and ends at time clips[i][1].  We can cut these clips into segments freely: for\
  \ example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\nReturn\
  \ the minimum number of clips needed so that we can cut the clips into segments\
  \ that cover the entire sporting event ([0, T]).  If the task is impossible, return\
  \ -1.\n \nExample 1:\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T =\
  \ 10\nOutput: 3\nExplanation: \nWe take the clips [0,2], [8,10], [1,9]; a total\
  \ of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut [1,9]\
  \ into segments [1,2] + [2,8] + [8,9].\nNow we have segments [0,2] + [2,8] + [8,10]\
  \ which cover the sporting event [0, 10].\n\nExample 2:\nInput: clips = [[0,1],[1,2]],\
  \ T = 5\nOutput: -1\nExplanation: \nWe can't cover [0,5] with only [0,1] and [1,2].\n\
  \nExample 3:\nInput: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]],\
  \ T = 9\nOutput: 3\nExplanation: \nWe can take clips [0,4], [4,7], and [6,9].\n\n\
  Example 4:\nInput: clips = [[0,4],[2,8]], T = 5\nOutput: 2\nExplanation: \nNotice\
  \ you can have extra video after the event ends.\n\n \nConstraints:\n\n1 <= clips.length\
  \ <= 100\n0 <= clips[i][0] <= clips[i][1] <= 100\n0 <= T <= 100"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def videoStitching (clips : List (List Nat)) (T : Nat) : Int :=\n\
  \  sorry\n\n-- Property 1: If target is beyond max end point, result must be -1"
"vc-theorems": "theorem target_beyond_max_end {clips : List (List Nat)} (h : clips\
  \ ≠ []) :\n  let maxEnd := List.foldl (fun acc clip => max acc (clip.get! 1)) 0\
  \ clips\n  videoStitching clips (maxEnd + 1) = -1 := \n  sorry\n\n-- Property 2:\
  \ Order of clips doesn't matter\n\ntheorem order_invariant (clips : List (List Nat))\
  \ (T : Nat) :\n  videoStitching clips T = videoStitching clips.reverse T :=\n  sorry\n\
  \n-- Property 3: Result is either -1 or positive\n\ntheorem result_range (clips\
  \ : List (List Nat)) (T : Nat) :\n  videoStitching clips T ≥ -1 :=\n  sorry\n\n\
  -- Property 4: If result is positive, it must be less than or equal to number of\
  \ clips\n\ntheorem positive_result_bound (clips : List (List Nat)) (T : Nat) :\n\
  \  videoStitching clips T > 0 → videoStitching clips T ≤ clips.length :=\n  sorry\n\
  \n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval video_stitching [[0, 2], [4, 6], [8, 10],\
  \ [1, 9], [1, 5], [5, 9]] 10\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval video_stitching\
  \ [[0, 1], [1, 2]] 5\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval video_stitching\
  \ [[0, 4], [2, 8]] 5\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
