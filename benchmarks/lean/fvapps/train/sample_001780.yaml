"vc-description": "In an n*n grid, there is a snake that spans 2 cells and starts\
  \ moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells\
  \ represented by zeros and blocked cells represented by ones. The snake wants to\
  \ reach the lower right corner at (n-1, n-2) and (n-1, n-1).\nIn one move the snake\
  \ can:\n\nMove one cell to the right if there are no blocked cells there. This move\
  \ keeps the horizontal/vertical position of the snake as it is.\nMove down one cell if\
  \ there are no blocked cells there. This move keeps the horizontal/vertical position\
  \ of the snake as it is.\nRotate clockwise if it's in a horizontal position and\
  \ the two cells under it are both empty. In that case the snake moves from (r, c) and (r,\
  \ c+1) to (r, c) and (r+1, c).\n\nRotate counterclockwise if it's in a vertical\
  \ position and the two cells to its right are both empty. In that case the snake\
  \ moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).\n\n\nReturn the minimum\
  \ number of moves to reach the target.\nIf there is no way to reach the target,\
  \ return -1.\n \nExample 1:\n\nInput: grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n\
                 [0,0,0,0,1,1],\n               [0,0,1,0,1,0],\n               [0,1,1,0,0,0],\n\
                 [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is\
  \ [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise,\
  \ right, down].\n\nExample 2:\nInput: grid = [[0,0,1,1,1,1],\n               [0,0,0,0,1,1],\n\
                 [1,1,0,0,0,1],\n               [1,1,1,0,0,1],\n               [1,1,1,0,0,1],\n\
                 [1,1,1,0,0,0]]\nOutput: 9\n\n \nConstraints:\n\n2 <= n <= 100\n0\
  \ <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def minimum_moves (grid : Array (Array Nat)) : Int := sorry\n\n\
  /-- For any non-empty n×n grid with all zeros, there exists a valid path to reach\
  \ bottom right -/"
"vc-theorems": "theorem min_moves_empty_grid_reaches {n : Nat} (h : n ≥ 3) :\n  let\
  \ grid := Array.mk (List.replicate n (Array.mk (List.replicate n (0:Nat))))\n  minimum_moves\
  \ grid > 0 := sorry\n\n/-- For any n×n grid that is blocked except start position,\
  \ no valid path exists -/\n\ntheorem min_moves_blocked_grid_unreachable {n : Nat}\
  \ (h : n ≥ 3) :\n  let blockedGrid := Array.mk (List.replicate n (Array.mk (List.replicate\
  \ n (1:Nat))))\n  let grid := blockedGrid.set! 0 (blockedGrid[0]!.set! 0 0) |>.set!\
  \ 0 (blockedGrid[0]!.set! 1 0)\n  minimum_moves grid = -1 := sorry\n\n/-- For minimal\
  \ 3×3 grid of all zeros, there exists a valid path -/\n\ntheorem min_moves_minimal_grid_reaches\
  \ :\n  let grid := Array.mk [Array.mk [(0:Nat),(0:Nat),(0:Nat)], Array.mk [(0:Nat),(0:Nat),(0:Nat)],\
  \ Array.mk [(0:Nat),(0:Nat),(0:Nat)]]\n  minimum_moves grid > 0 := sorry\n\n/--\n\
  info: 11\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 0, 0, 0, 1], [1, 1, 0,\
  \ 0, 1, 0], [0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0], [0, 1, 1,\
  \ 0, 0, 0]]\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval minimum_moves #[[0, 0, 1,\
  \ 1, 1, 1], [0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1], [1, 1, 1,\
  \ 0, 0, 1], [1, 1, 1, 0, 0, 0]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
