"vc-description": "The life goes up and down, just like nice sequences. Sequence t_1,\
  \ t_2, ..., t_{n} is called nice if the following two conditions are satisfied:\
  \   t_{i} < t_{i} + 1 for each odd i < n;  t_{i} > t_{i} + 1 for each even i < n.\
  \ \n\nFor example, sequences (2, 8), (1, 5, 1) and (2, 5, 1, 100, 99, 120) are nice,\
  \ while (1, 1), (1, 2, 3) and (2, 5, 3, 2) are not.\n\nBear Limak has a sequence\
  \ of positive integers t_1, t_2, ..., t_{n}. This sequence is not nice now and Limak\
  \ wants to fix it by a single swap. He is going to choose two indices i < j and\
  \ swap elements t_{i} and t_{j} in order to get a nice sequence. Count the number\
  \ of ways to do so. Two ways are considered different if indices of elements chosen\
  \ for a swap are different.\n\n\n-----Input-----\n\nThe first line of the input\
  \ contains one integer n (2 ≤ n ≤ 150 000) — the length of the sequence.\n\nThe\
  \ second line contains n integers t_1, t_2, ..., t_{n} (1 ≤ t_{i} ≤ 150 000) — the\
  \ initial sequence. It's guaranteed that the given sequence is not nice.\n\n\n-----Output-----\n\
  \nPrint the number of ways to swap two elements exactly once in order to get a nice\
  \ sequence.\n\n\n-----Examples-----\nInput\n5\n2 8 4 7 7\n\nOutput\n2\n\nInput\n\
  4\n200 150 100 50\n\nOutput\n1\n\nInput\n10\n3 2 1 4 1 4 1 4 1 4\n\nOutput\n8\n\n\
  Input\n9\n1 2 3 4 5 6 7 8 9\n\nOutput\n0\n\n\n\n-----Note-----\n\nIn the first sample,\
  \ there are two ways to get a nice sequence with one swap:   Swap t_2 = 8 with t_4\
  \ = 7.  Swap t_1 = 2 with t_5 = 7. \n\nIn the second sample, there is only one way —\
  \ Limak should swap t_1 = 200 with t_4 = 50."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_nice_sequence_swaps (n : Nat) (sequence : List Int) :\
  \ Nat :=\n  sorry\n"
"vc-theorems": "theorem count_nice_sequence_swaps_is_natural (n : Nat) (sequence :\
  \ List Int) :\n  ∃ (result : Nat), count_nice_sequence_swaps n sequence = result\
  \ :=\n  sorry\n\n\ntheorem count_nice_sequence_swaps_non_negative (n : Nat) (sequence\
  \ : List Int) :\n  count_nice_sequence_swaps n sequence ≥ 0 :=\n  sorry\n\n\ntheorem\
  \ count_nice_sequence_swaps_preserves_input (n : Nat) (sequence : List Int) :\n\
  \  let original := sequence;\n  count_nice_sequence_swaps n original = count_nice_sequence_swaps\
  \ n sequence :=\n  sorry\n\n\ntheorem count_nice_sequence_swaps_monotonic_input\
  \ (n : Nat) (sequence : List Int) :\n  ∃ (result_asc result_desc : Nat),\n    count_nice_sequence_swaps\
  \ n sequence = result_asc ∧\n    count_nice_sequence_swaps n sequence = result_desc\
  \ :=\n  sorry\n\n\ntheorem count_nice_sequence_swaps_small_values \n  {n : Nat}\
  \ {sequence : List Int}\n  (h₁ : ∀ x ∈ sequence, 1 ≤ x ∧ x ≤ 10)\n  (h₂ : 1 ≤ sequence.length\
  \ ∧ sequence.length ≤ 10) :\n  ∃ (result : Nat), count_nice_sequence_swaps n sequence\
  \ = result ∧ result ≥ 0 :=\n  sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval count_nice_sequence_swaps\
  \ 5 [2, 8, 4, 7, 7]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_nice_sequence_swaps\
  \ 4 [200, 150, 100, 50]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval count_nice_sequence_swaps\
  \ 10 [3, 2, 1, 4, 1, 4, 1, 4, 1, 4]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
