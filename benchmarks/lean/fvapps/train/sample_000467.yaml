"vc-description": "Given two positive integers n and k, the binary string  Sn is formed\
  \ as follows:\n\nS1 = \"0\"\nSi = Si-1 + \"1\" + reverse(invert(Si-1)) for i > 1\n\
  \nWhere + denotes the concatenation operation, reverse(x) returns the reversed string\
  \ x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\n\
  For example, the first 4 strings in the above sequence are:\n\nS1 = \"0\"\nS2 =\
  \ \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn.\
  \ It is guaranteed that k is valid for the given n.\n \nExample 1:\nInput: n = 3,\
  \ k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\". The first bit is \"0\".\n\
  \nExample 2:\nInput: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\"\
  . The 11th bit is \"1\".\n\nExample 3:\nInput: n = 1, k = 1\nOutput: \"0\"\n\nExample\
  \ 4:\nInput: n = 2, k = 3\nOutput: \"1\"\n\n \nConstraints:\n\n1 <= n <= 20\n1 <=\
  \ k <= 2n - 1"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_kth_bit (n : Nat) (k : Nat) : Char := \n  sorry\n"
"vc-theorems": "theorem find_kth_bit_valid_output (n : Nat) (k : Nat) (h1 : n > 0)\
  \ (h2 : k > 0) (h3 : k ≤ 2^n - 1) : \n  find_kth_bit n k = '0' ∨ find_kth_bit n\
  \ k = '1' := sorry\n\n\ntheorem find_kth_bit_first_is_zero (n : Nat) (h : n > 0)\
  \ :\n  find_kth_bit n 1 = '0' := sorry\n\n\ntheorem find_kth_bit_middle_is_one (n\
  \ : Nat) (h : n > 1) :\n  find_kth_bit n ((2^n - 1)/2 + 1) = '1' := sorry\n\n\n\
  theorem find_kth_bit_specific_cases :\n  find_kth_bit 3 1 = '0' ∧ \n  find_kth_bit\
  \ 4 11 = '1' ∧\n  find_kth_bit 1 1 = '0' := sorry\n\n/--\ninfo: '0'\n-/\n#guard_msgs\
  \ in\n#eval find_kth_bit 3 1\n\n/--\ninfo: '1'\n-/\n#guard_msgs in\n#eval find_kth_bit\
  \ 4 11\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval find_kth_bit 1 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
