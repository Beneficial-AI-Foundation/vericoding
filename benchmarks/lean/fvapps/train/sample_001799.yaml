"vc-description": "We are given an elevation map, heights[i] representing the height\
  \ of the terrain at that index.  The width at each index is 1.  After V units of\
  \ water fall at index K, how much water is at each index?\n\nWater first drops at\
  \ index K and rests on top of the highest terrain or water at that index.  Then,\
  \ it flows according to the following rules:\nIf the droplet would eventually fall\
  \ by moving left, then move left.\nOtherwise, if the droplet would eventually fall\
  \ by moving right, then move right.\nOtherwise, rise at it's current position.\n\
  Here, \"eventually fall\" means that the droplet will eventually be at a lower level\
  \ if it moves in that direction.\nAlso, \"level\" means the height of the terrain\
  \ plus any water in that column.\n\nWe can assume there's infinitely high terrain\
  \ on the two sides out of bounds of the array.  Also, there could not be partial\
  \ water being spread out evenly on more than 1 grid block - each unit of water has\
  \ to be in exactly one block.\n\n\nExample 1:\n\nInput: heights = [2,1,1,2,1,2,2],\
  \ V = 4, K = 3\nOutput: [2,2,2,3,2,2,2]\nExplanation:\n#       #\n#       #\n##\
  \  # ###\n#########\n 0123456    \n\n\nExample 2:\n\nInput: heights = [1,2,3,4],\
  \ V = 2, K = 2\nOutput: [2,3,3,4]\nExplanation:\nThe last droplet settles at index\
  \ 1, since moving further left would not cause it to eventually fall to a lower\
  \ height.\n\n\n\nExample 3:\n\nInput: heights = [3,1,3], V = 5, K = 1\nOutput: [4,4,4]\n\
  \n\n\nNote:\nheights will have length in [1, 100] and contain integers in [0, 99].\n\
  V will be in range [0, 2000].\nK will be in range [0, heights.length - 1]."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def pour_water (heights : List Nat) (V : Nat) (K : Nat) : List\
  \ Nat :=\n  sorry\n"
"vc-theorems": "theorem pour_water_result_length {heights : List Nat} {V K : Nat}\
  \ \n  (h : K < heights.length) :\n  (pour_water heights V K).length = heights.length\
  \ :=\n  sorry\n\n\ntheorem pour_water_total_water_added {heights : List Nat} {V\
  \ K : Nat}\n  (h : K < heights.length) :\n  (pour_water heights V K).foldl (· +\
  \ ·) 0 - heights.foldl (· + ·) 0 = V :=\n  sorry\n\n\ntheorem pour_water_heights_never_decrease\
  \ {heights : List Nat} {V K : Nat}\n  (h : K < heights.length) :\n  List.zip (pour_water\
  \ heights V K) heights\n  |>.all (fun p => p.1 ≥ p.2) := \n  sorry\n\n\ntheorem\
  \ pour_water_water_trapped {heights : List Nat} {V K : Nat} \n  (h : K < heights.length)\n\
  \  (i : Nat)\n  (hi : i > 0 ∧ i < (heights.length - 1))\n  (hw : (pour_water heights\
  \ V K).get ⟨i, sorry⟩ > heights.get ⟨i, sorry⟩) :\n  ((pour_water heights V K).get\
  \ ⟨i-1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) ∨\n  ((pour_water heights\
  \ V K).get ⟨i+1, sorry⟩ ≥ (pour_water heights V K).get ⟨i, sorry⟩) :=\n  sorry\n\
  \n/--\ninfo: [2, 2, 2, 3, 2, 2, 2]\n-/\n#guard_msgs in\n#eval pour_water [2, 1,\
  \ 1, 2, 1, 2, 2] 4 3\n\n/--\ninfo: [2, 3, 3, 4]\n-/\n#guard_msgs in\n#eval pour_water\
  \ [1, 2, 3, 4] 2 2\n\n/--\ninfo: [4, 4, 4]\n-/\n#guard_msgs in\n#eval pour_water\
  \ [3, 1, 3] 5 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
