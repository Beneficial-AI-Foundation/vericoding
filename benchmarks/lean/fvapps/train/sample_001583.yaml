"vc-description": "# The Kata\nYour task is to transform an input nested list into\
  \ an hypercube list, which is a special kind of nested list where each level must\
  \ have the very same size,\nThis Kata is an exercise on recursion and algorithms.\
  \ You will need to visualize many aspects of this question to be able to solve it\
  \ efficiently, as such there is a section on definitions of the terms that will\
  \ be used in the Kata, make sure to fully understand them before attempting. A naive\
  \ brute-force-ish answer will most likely fail the tests. There will be tests on\
  \  nested lists of dimension and size up to 10. Good luck.\n\n\n# Definitions\n\
  ### Nested List\nA nested list is a list that may contain either non-list items\
  \ or more nested lists as items in the list. Here are a few examples of nested lists.\n\
  \n    [[2, 3], 4, 5, 6, [2, [2, 3, 4, 5], 2, 1, 2], [[[[1]]]], []]\n    [[[]]]\n\
  \    [1, 2]\n    [[], []]\n    [4, 5, 6, 7, [], 2]\n    []\n\n\n- A *basic element*\
  \ refers to any non-list element of a nested list.\n\n\n- A nested list's *dimension*\
  \ is defined as the deepest the list goes.  \n\n\n- A nested list's *size* is defined\
  \ as the longest the list or any of its sublists go.  \n\nFor example, the *dimension*\
  \ and *size* of the above nested lists is as follows.\n\n    [[2, 3], 4, 5, 6, [2,\
  \ [2, 3, 4, 5], 2, 1, 2], [[[[1]]]], []]  # dimension: 5, size: 7\n    [[[]]]  \
  \                                                      # dimension: 3, size: 1\n\
  \    [1, 2]                                                        # dimension:\
  \ 1, size: 2\n    [[], []]                                                     \
  \ # dimension: 2, size: 2\n    [4, 5, 6, 7, [], 2]                             \
  \              # dimension: 2, size: 6\n    []                                 \
  \                           # dimension: 1, size: 0\n\n\n### Hypercube List\n- A\
  \ `1`-dimensional **hypercube list** of size `n` is a nested list of dimension `1`\
  \ and size `n`.  \n\n\n- A `d`-dimensional hypercube list of size `n` is a nested\
  \ list of dimension `d` and size `n` such that the nested list has `n` elements\
  \ each of which is a `d - 1`-dimensional hypercube list of size `n`.  \n\n\nHere\
  \ are some examples of hypercube lists.\n\n    [1]                             \
  \                          # dimension: 1, size: 1\n    [[1, 2], [3, 4]]       \
  \                                   # dimension: 2, size: 2\n    [[1, 2, 3], [4,\
  \ 5, 6], [7, 8, 9]]                         # dimension: 2, size: 3\n    [[0]] \
  \                                                    # dimension: 2, size: 1\n \
  \   [[[0, 0], [1, 1]], [[2, 2], [3, 3]]]                      # dimension: 3, size:\
  \ 2\n    [1, 2, 3, 4]                                              # dimension:\
  \ 1, size: 4\n    [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]  # dimension:\
  \ 2, size: 4\n\n\n# The Task\nYour task is to implement `normalize` which converts\
  \ any given `nested_list` to be in hypercube format with the same dimension and\
  \ size as the given nested list, extending and growing with the given `growing_value`.\
  \ The default growing value is the integer `0`.\n\n### The Algorithm\nIn most scenarios\
  \ you will encounter a nested list that does not have the same size throughout.\
  \ When working on such a list the algorithm should behave as follows.\n\n * If a\
  \ hypercube list of dimension 1 needs extra elements, append the required number\
  \ of growing value elements.\n * If a hypercube list of dimension greater than 1\
  \ has a direct basic element as a child, replace it with the required hypercube\
  \ list with its basic elements all being the replaced item.\n * If a hypercube list\
  \ of dimension greater than 1 needs extra elements, append the required hypercube\
  \ list with its basic elements all being the growing value.\n\n\nTake note of the\
  \ given example, it will be very helpful in understanding the intricacies of the\
  \ algorithm.\n\n    >>> normalize(\n            [\n                [\n         \
  \           [2, 3, 4],\n                    [1, 2],\n                    2,\n  \
  \                  [1]\n                ],\n                [\n                \
  \    2,\n                    [2, 3],\n                    1,\n                 \
  \   4,\n                    [2, 2, 6, 7]\n                ],\n                5\n\
  \            ]\n        )\n        \nGives the following result.\n\n    [\n    \
  \    [\n            [2, 3, 4, 0, 0],\n            [1, 2, 0, 0, 0],\n           \
  \ [2, 2, 2, 2, 2],\n            [1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]\n\
  \        ],\n        [\n            [2, 2, 2, 2, 2],\n            [2, 3, 0, 0, 0],\n\
  \            [1, 1, 1, 1, 1],\n            [4, 4, 4, 4, 4],\n            [2, 2,\
  \ 6, 7, 0]\n        ],\n        [\n            [5, 5, 5, 5, 5],\n            [5,\
  \ 5, 5, 5, 5],\n            [5, 5, 5, 5, 5],\n            [5, 5, 5, 5, 5],\n   \
  \         [5, 5, 5, 5, 5]\n        ],\n        [\n            [0, 0, 0, 0, 0],\n\
  \            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0,\
  \ 0, 0, 0],\n            [0, 0, 0, 0, 0]\n        ],\n        [\n            [0,\
  \ 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n   \
  \         [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]\n        ]\n    ]\n\n\n\
  Good luck!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def normalize {α : Type} (lst : List (List α ⊕ α)) : List (List\
  \ α ⊕ α) := sorry\n\ntheorem normalize_identity_flat {α : Type} (lst : List α) :\n\
  \  normalize (lst.map (fun x => Sum.inr x)) = lst.map (fun x => Sum.inr x) := sorry\n"
"vc-theorems": "theorem normalize_sublist_lengths {α : Type} (lst : List (List α ⊕\
  \ α)) :\n  (∃ x y, x ∈ lst ∧ y ∈ lst ∧ ∃ l1 l2, x = Sum.inl l1 ∧ y = Sum.inl l2)\
  \ →\n  (∀ x y, x ∈ normalize lst → y ∈ normalize lst → \n    match x, y with \n\
  \    | Sum.inl l1, Sum.inl l2 => List.length l1 = List.length l2\n    | _, _ =>\
  \ True) := sorry\n\n\ntheorem normalize_empty {α : Type} :\n  normalize ([] : List\
  \ (List α ⊕ α)) = [] := sorry\n\n\ntheorem normalize_singleton_empty {α : Type}\
  \ :\n  normalize [Sum.inl ([] : List α)] = [Sum.inl []] := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
