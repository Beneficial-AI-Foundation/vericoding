"vc-description": "Write a function which takes one parameter representing the dimensions\
  \ of a checkered board. The board will always be square, so 5 means you will need\
  \ a 5x5 board.\n\nThe dark squares will be represented by a unicode white square,\
  \ while the light squares will be represented by a unicode black square (the opposite\
  \ colours ensure the board doesn't look reversed on code wars' dark background).\
  \ It should return a string of the board with a space in between each square and\
  \ taking into account new lines. \n\nAn even number should return a board that begins\
  \ with a dark square. An odd number should return a board that begins with a light\
  \ square.\n\nThe input is expected to be a whole number that's at least two, and\
  \ returns false otherwise (Nothing in Haskell).\n\nExamples:\n\n```python\ncheckered_board(5)\n\
  ```\n\nreturns the string\n```\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □\
  \ ■ □ ■\n```\n\n**There should be no trailing white space at the end of each line,\
  \ or new line characters at the end of the string.**\n\n**Note**   \nDo not use\
  \ HTML entities for the squares (e.g. `□` for white square) as the code doesn't\
  \ consider it a valid square. A good way to check is if your solution prints a correct\
  \ checker board on your local terminal.  \n\n**Ruby note:**\nCodeWars has encoding\
  \ issues with rendered unicode in Ruby.\nYou'll need to use unicode source code\
  \ (e.g. \"\\u25A0\") instead of rendered unicode (e.g \"■\")."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def checkered_board (n : Int) : String := sorry\n\n/-- For valid\
  \ inputs (n ≥ 2), checkered_board produces a string with:\n    1. n rows\n    2.\
  \ n columns in each row\n    3. Alternating pattern of □ and ■ where:\n       -\
  \ For even n, top-left is □\n       - For odd n, top-left is ■ -/"
"vc-theorems": "theorem valid_board_pattern (n : Int) (h : n ≥ 2) :\n  let result\
  \ := checkered_board n\n  let rows := result.splitOn \"\\n\"\n  (result.isEmpty\
  \ = false) ∧ \n  (rows.length = n) ∧ \n  (∀ row ∈ rows, (row.splitOn \" \").length\
  \ = n) ∧\n  (∀ (i j : Nat), i < n.toNat → j < n.toNat → \n    ((rows.get! i).splitOn\
  \ \" \").get! j = \n      if ((i : Int) + j) % 2 = n % 2 \n      then \"■\" \n \
  \     else \"□\") := sorry\n\n/-- For invalid inputs (n ≤ 1), checkered_board returns\
  \ false -/\n\ntheorem invalid_inputs (n : Int) (h : n ≤ 1) :\n  checkered_board\
  \ n = \"false\" := sorry\n\nend CheckeredBoard\n\n/--\ninfo: '■ □ ■ □ ■\\n□ ■ □\
  \ ■ □\\n■ □ ■ □ ■\\n□ ■ □ ■ □\\n■ □ ■ □ ■'\n-/\n#guard_msgs in\n#eval checkered_board\
  \ 5\n\n/--\ninfo: '■ □ ■\\n□ ■ □\\n■ □ ■'\n-/\n#guard_msgs in\n#eval checkered_board\
  \ 3\n\n/--\ninfo: '□ ■\\n■ □'\n-/\n#guard_msgs in\n#eval checkered_board 2\n\n/--\n\
  info: False\n-/\n#guard_msgs in\n#eval checkered_board 1\n\n/--\ninfo: False\n-/\n\
  #guard_msgs in\n#eval checkered_board -1\n\n/--\ninfo: False\n-/\n#guard_msgs in\n\
  #eval checkered_board \"test\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval checkered_board\
  \ None\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
