"vc-description": "Little Petya often visits his grandmother in the countryside. The\
  \ grandmother has a large vertical garden, which can be represented as a set of\
  \ `n` rectangles of varying height. Due to the newest irrigation system we can create\
  \ artificial rain above them.\n\nCreating artificial rain is an expensive operation.\
  \ That's why we limit ourselves to creating the artificial rain only above one section.\
  \ The water will then flow to the neighbouring sections but only if each of their\
  \ heights does not exceed the height of the previous watered section.\n\n___\n\n\
  ## Example:\n\nLet's say there's a garden consisting of 5 rectangular sections of\
  \ heights `4, 2, 3, 3, 2`.\n\nCreating the artificial rain over the left-most section\
  \ is inefficient as the water **WILL FLOW DOWN** to the section with the height\
  \ of `2`, but it **WILL NOT FLOW UP** to the section with the height of `3` from\
  \ there. Only 2 sections will be covered: `4, 2`.\n\nThe most optimal choice will\
  \ be either of the sections with the height of `3` because the water will flow to\
  \ its neighbours covering 4 sections altogether: `2, 3, 3, 2`. You can see this\
  \ process in the following illustration:\n\n\n\n___\n\nAs Petya is keen on programming,\
  \ he decided to find such section that if we create artificial rain above it, the\
  \ number of watered sections will be maximal.\n\n## Output:\nThe maximal number\
  \ of watered sections if we create artificial rain above exactly one section.\n\n\
  **Note: performance will be tested.**"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def artificial_rain (garden: List Nat) : Nat := sorry\n\ntheorem\
  \ artificial_rain_length_invariant {garden: List Nat} (h: garden ≠ []) :\n  1 ≤\
  \ artificial_rain garden ∧ artificial_rain garden ≤ garden.length := sorry\n"
"vc-theorems": "theorem artificial_rain_identical_values {garden: List Nat} (h: garden.length\
  \ ≥ 2) \n  (h2: ∀ (i j: Nat) (hi: i < garden.length) (hj: j < garden.length), garden.get\
  \ ⟨i, hi⟩ = garden.get ⟨j, hj⟩) :\n  artificial_rain garden = garden.length := sorry\n\
  \n\ntheorem artificial_rain_single_peak_singleton {garden: List Nat} (h: garden.length\
  \ = 1) :\n  artificial_rain garden = 1 := sorry\n\n\ntheorem artificial_rain_single_peak\
  \ {garden: List Nat} (h: garden.length > 1)\n  (peak_idx: Nat) (h2: peak_idx < garden.length)\n\
  \  (h3: ∀ (i: Nat) (hi: i < garden.length) (hip: i < peak_idx) (hi1: i + 1 < garden.length),\
  \ \n    garden.get ⟨i, hi⟩ ≤ garden.get ⟨i + 1, hi1⟩)\n  (h4: ∀ (i: Nat) (hi: i\
  \ < garden.length) (hip: peak_idx ≤ i) (hi1: i + 1 < garden.length), \n    garden.get\
  \ ⟨i, hi⟩ ≥ garden.get ⟨i + 1, hi1⟩) :\n  artificial_rain garden ≥ peak_idx + 1\
  \ := sorry\n\n\ntheorem artificial_rain_monotonic_increasing {garden: List Nat}\
  \ (h: garden.length ≥ 2)\n  (h2: ∀ (i: Nat) (hi: i < garden.length) (hi1: i + 1\
  \ < garden.length), \n    garden.get ⟨i, hi⟩ ≤ garden.get ⟨i + 1, hi1⟩) :\n  artificial_rain\
  \ garden = garden.length := sorry\n\n\ntheorem artificial_rain_monotonic_decreasing\
  \ {garden: List Nat} (h: garden.length ≥ 2)\n  (h2: ∀ (i: Nat) (hi: i < garden.length)\
  \ (hi1: i + 1 < garden.length), \n    garden.get ⟨i, hi⟩ ≥ garden.get ⟨i + 1, hi1⟩)\
  \ :\n  artificial_rain garden = garden.length := sorry\n\n/--\ninfo: 4\n-/\n#guard_msgs\
  \ in\n#eval artificial_rain [4, 2, 3, 3, 2]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n\
  #eval artificial_rain [1, 2, 3, 4, 5]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval\
  \ artificial_rain [1, 2, 2, 2, 1]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
