"vc-description": "We have a list of points on the plane.  Find the K closest points\
  \ to the origin (0, 0).\n(Here, the distance between two points on a plane is the\
  \ Euclidean distance.)\nYou may return the answer in any order.  The answer is guaranteed\
  \ to be unique (except for the order that it is in.)\n \n\nExample 1:\nInput: points\
  \ = [[1,3],[-2,2]], K = 1\nOutput: [[-2,2]]\nExplanation: \nThe distance between\
  \ (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin\
  \ is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only\
  \ want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\n\
  \n\nExample 2:\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\nOutput: [[3,3],[-2,4]]\n\
  (The answer [[-2,4],[3,3]] would also be accepted.)\n\n \nNote:\n\n1 <= K <= points.length\
  \ <= 10000\n-10000 < points[i][0] < 10000\n-10000 < points[i][1] < 10000"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def kClosest (points : List (List Int)) (k : Nat) : List (List\
  \ Int) := sorry\n\ndef euclDistance (point : List Int) : Int :=\n  match point with\n\
  \  | [x, y] => x*x + y*y\n  | _ => 0\n\n/-- For valid inputs, kClosest returns k\
  \ points -/"
"vc-theorems": "theorem kClosest_correct_length {points : List (List Int)} {k : Nat}\n\
  \  (h1 : k > 0)\n  (h2 : k ≤ points.length)\n  (h3 : ∀ p ∈ points, p.length = 2)\
  \ :\n  (kClosest points k).length = k := sorry\n\n/-- All points in the result were\
  \ in the original list -/\n\ntheorem kClosest_subset {points : List (List Int)}\
  \ {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ points.length)\n  (h3 : ∀ p ∈ points, p.length\
  \ = 2) :\n  ∀ p ∈ kClosest points k, p ∈ points := sorry\n\n/-- The distances in\
  \ the result are non-decreasing -/\n\ntheorem kClosest_distances_ordered {points\
  \ : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ points.length)\n  (h3\
  \ : ∀ p ∈ points, p.length = 2) :\n  ∀ i j, i < j → j < (kClosest points k).length\
  \ →\n  euclDistance ((kClosest points k)[i]!) ≤ euclDistance ((kClosest points k)[j]!)\
  \ := sorry\n\n/-- The result contains the k closest points -/\n\ntheorem kClosest_optimal\
  \ {points : List (List Int)} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ points.length)\n\
  \  (h3 : ∀ p ∈ points, p.length = 2) :\n  ∀ p ∈ kClosest points k, ∀ q ∈ points,\
  \ q ∉ kClosest points k →\n  euclDistance p ≤ euclDistance q := sorry\n\n/-- When\
  \ k equals length, returns all points -/\n\ntheorem kClosest_full_list {points :\
  \ List (List Int)}\n  (h : ∀ p ∈ points, p.length = 2) :\n  kClosest points points.length\
  \ = points := sorry\n\n/-- When k = 1, returns point with minimum distance -/\n\n\
  theorem kClosest_k_one {points : List (List Int)}\n  (h1 : points.length > 0)\n\
  \  (h2 : ∀ p ∈ points, p.length = 2) :\n  ∀ p ∈ points, \n  euclDistance (List.head!\
  \ (kClosest points 1)) ≤ euclDistance p := sorry\n\n/--\ninfo: [[-2, 2]]\n-/\n#guard_msgs\
  \ in\n#eval kClosest [[1, 3], [-2, 2]] 1\n\n/--\ninfo: [[1, 1], [2, 2]]\n-/\n#guard_msgs\
  \ in\n#eval kClosest [[1, 1], [2, 2], [3, 3]] 2\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
