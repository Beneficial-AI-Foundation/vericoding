"vc-description": "# Base64 Numeric Translator\n\nOur standard numbering system is\
  \ (Base 10). That includes 0 through 9. Binary is (Base 2), only 1’s and 0’s.  And\
  \ Hexadecimal is (Base 16) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F). A hexadecimal\
  \ “F” has a (Base 10) value of 15. (Base 64) has 64 individual characters which\
  \ translate in value in (Base 10) from between 0 to 63.\n\n####Write a method that\
  \ will convert a string from (Base 64) to it's (Base 10) integer value.\n\nThe (Base\
  \ 64) characters from least to greatest will be\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n\
  ```\nWhere 'A' is equal to 0 and '/' is equal to 63.\n\nJust as in standard (Base\
  \ 10) when you get to the highest individual integer 9 the next number adds an additional\
  \ place and starts at the beginning 10; so also (Base 64) when you get to the 63rd\
  \ digit '/' and the next number adds an additional place and starts at the beginning\
  \ \"BA\".\n\nExample:\n```\nbase64_to_base10(\"/\") # => 63\nbase64_to_base10(\"\
  BA\") # => 64\nbase64_to_base10(\"BB\") # => 65\nbase64_to_base10(\"BC\") # => 66\n\
  ```\n\nWrite a method `base64_to_base10` that will take a string (Base 64) number\
  \ and output it's (Base 10) value as an integer."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def DIGITS : List Char := sorry\n\ndef base64_to_base10 (s : String)\
  \ : Nat := sorry\n"
"vc-theorems": "theorem base64_to_base10_nonnegative (s: String) \n  (h: s.length\
  \ > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s ≥ 0 := sorry\n\n\
  \ntheorem base64_to_base10_longer_is_larger (s: String)\n  (h: s.length > 1)\n \
  \ (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s > base64_to_base10 (String.dropRight\
  \ s 1) := sorry\n\n\ntheorem base64_to_base10_matches_manual (s: String)\n  (h:\
  \ s.length > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s = \n \
  \   (List.enum s.data.reverse).foldl\n      (fun acc (i, c) => acc + (DIGITS.findIdx?\
  \ (· = c)).get! * (64 ^ i)) 0 := sorry\n\n\ntheorem base64_to_base10_type (s: String)\n\
  \  (h: s.length > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s ≥\
  \ 0 := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
