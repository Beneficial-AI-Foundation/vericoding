"vc-description": "One of the services provided by an operating system is memory management.\
  \ The OS typically provides an API for allocating and releasing memory in a process's\
  \ address space. A process should only read and write memory at addresses which\
  \ have been allocated by the operating system. In this kata you will implement a\
  \ simulation of a simple memory manager.\n\nThe language you will be using has no\
  \ low level memory API, so for our simulation we will simply use an array as the\
  \ process address space. The memory manager constructor will accept an array (further\
  \ referred to as `memory`) where blocks of indices will be allocated later.\n\n\
  ___\n\n# Memory Manager Contract\n\n## allocate(size)\n\n`allocate` reserves a sequential\
  \ block (sub-array) of `size` received as an argument in `memory`. It should return\
  \ the index of the first element in the allocated block, or throw an exception if\
  \ there is no block big enough to satisfy the requirements.\n\n## release(pointer)\n\
  \n`release` accepts an integer representing the start of the block allocated ealier,\
  \ and frees that block. If the released block is adjacent to a free block, they\
  \ should be merged into a larger free block. Releasing an unallocated block should\
  \ cause an exception.\n\n## write(pointer, value)\n\nTo support testing this simulation\
  \ our memory manager needs to support read/write functionality. Only elements within\
  \ allocated blocks may be written to. The `write` method accepts an index in `memory`\
  \ and a `value`. The `value` should be stored in `memory` at that index if it lies\
  \ within an allocated block, or throw an exception otherwise.\n\n## read(pointer)\n\
  \nThis method is the counterpart to `write`. Only indices within allocated blocks\
  \ may be read. The `read` method accepts an index. If the `index` is within an allocated\
  \ block, the value stored in `memory` at that index should be returned, or an exception\
  \ should be thrown otherwise."
"vc-preamble": "import Imports.AllImports\n\ndef MemoryManager.init {α : Type} (memory\
  \ : List α) : MemoryManager α := sorry\ndef MemoryManager.allocate {α : Type} (mm\
  \ : MemoryManager α) (size : Nat) : Option Nat := sorry\n\ndef MemoryManager.write\
  \ {α : Type} (mm : MemoryManager α) (pointer : Nat) (value : α) : MemoryManager\
  \ α := sorry\ndef MemoryManager.read {α : Type} (mm : MemoryManager α) (pointer\
  \ : Nat) : Option α := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def MemoryManager.release {α : Type} (mm : MemoryManager α) (pointer\
  \ : Nat) : MemoryManager α := sorry\ndef MemoryManager.allocate_multiple {α : Type}\
  \ (mm : MemoryManager α) (sizes : List Nat) : List (Nat × Nat) := sorry\n\n/-- Memory\
  \ manager initialization preserves sizes and sets initial state -/"
"vc-theorems": "theorem memory_manager_init {α : Type} {memory : List α} (h : memory.length\
  \ > 0) :\n  let mm := MemoryManager.init memory\n  (mm.storage.length = memory.length)\
  \ ∧\n  (mm.previous_allocated_index = 0) ∧ \n  (mm.allocated = []) ∧\n  (mm.data\
  \ = memory) := sorry\n\n/-- Allocation respects size bounds -/\n\ntheorem allocation_size_bounds\
  \ {α : Type} {memory : List α} {size : Nat} \n  (h : memory.length > 0) :\n  let\
  \ mm := MemoryManager.init memory \n  if size > memory.length then\n    (MemoryManager.allocate\
  \ mm size).isNone\n  else match MemoryManager.allocate mm size with\n    | some\
  \ pointer => \n      (0 ≤ pointer) ∧ \n      (pointer ≤ memory.length - size) ∧\n\
  \      ((pointer, pointer + size) ∈ mm.allocated)\n    | none => False := sorry\n\
  \n/-- Multiple allocations and releases maintain memory consistency -/\n\ntheorem\
  \ multiple_allocations {α : Type} {memory : List α} {sizes : List Nat}\n  (h : memory.length\
  \ > 0) :\n  let mm := MemoryManager.init memory\n  ∀ (alloc : Nat × Nat),\n    alloc\
  \ ∈ MemoryManager.allocate_multiple mm sizes →\n    let (pointer, size) := alloc\n\
  \    (0 ≤ pointer ∧ pointer + size ≤ memory.length) ∧\n    (alloc ∈ mm.allocated)\
  \ ∧\n    (alloc ∉ (MemoryManager.release mm pointer).allocated) := sorry\n\n/--\
  \ Memory read/write operations maintain expected behavior -/\n\ntheorem memory_operations\
  \ {α : Type} {memory : List α} {size : Nat} {value : α}\n  (h : memory.length >\
  \ 0) (h₂ : size ≤ memory.length) :\n  let mm := MemoryManager.init memory\n  match\
  \ MemoryManager.allocate mm size with\n  | some pointer => \n    (MemoryManager.read\
  \ (MemoryManager.write mm pointer value) pointer = some value) ∧\n    (MemoryManager.read\
  \ (MemoryManager.release mm pointer) pointer = none)\n  | none => False := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
